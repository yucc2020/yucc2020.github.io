<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[300. Longest Increasing Subsequence]]></title>
    <url>%2Fp%2F71a6e0e6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[299. Bulls and Cows]]></title>
    <url>%2Fp%2Fee81c67e%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[297. Serialize and Deserialize Binary Tree]]></title>
    <url>%2Fp%2Fcf7c0855%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[295. Find Median from Data Stream]]></title>
    <url>%2Fp%2F4e6b5bd8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[292. Nim Game]]></title>
    <url>%2Fp%2Fb77dfaa9%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[290. Word Pattern]]></title>
    <url>%2Fp%2F1836af6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[289. Game of Life]]></title>
    <url>%2Fp%2F4d6d4f2b%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[284. Peeking Iterator]]></title>
    <url>%2Fp%2F8f8ef073%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[283. Move Zeroes]]></title>
    <url>%2Fp%2F59f0159a%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[282. Expression Add Operators]]></title>
    <url>%2Fp%2F2290fe4%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[279. Perfect Squares]]></title>
    <url>%2Fp%2F81d53cb4%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[278. First Bad Version]]></title>
    <url>%2Fp%2F7b51cdf3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[275. H-Index II]]></title>
    <url>%2Fp%2F79619e9a%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[274. H-Index]]></title>
    <url>%2Fp%2F1b8dbba0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[273. Integer to English Words]]></title>
    <url>%2Fp%2F17e7ae89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[268. Missing Number]]></title>
    <url>%2Fp%2F4176e3e5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[264. Ugly Number II]]></title>
    <url>%2Fp%2Fff8ccd53%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[263. Ugly Number]]></title>
    <url>%2Fp%2F2e99b71d%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[260. Single Number III]]></title>
    <url>%2Fp%2Fc6227aad%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[258. Add Digits]]></title>
    <url>%2Fp%2F3ec955c1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[257. Binary Tree Paths]]></title>
    <url>%2Fp%2F900d76e0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[242. Valid Anagram]]></title>
    <url>%2Fp%2Fda56d9f0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[241. Different Ways to Add Parentheses]]></title>
    <url>%2Fp%2F58bae46e%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[240. Search a 2D Matrix II]]></title>
    <url>%2Fp%2Fac205ce%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[239. Sliding Window Maximum]]></title>
    <url>%2Fp%2Fd8741db0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[238. Product of Array Except Self]]></title>
    <url>%2Fp%2F8baaef8d%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[237. Delete Node in a Linked List]]></title>
    <url>%2Fp%2Ffec895cd%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[236. Lowest Common Ancestor of a Binary Tree]]></title>
    <url>%2Fp%2Fda126211%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[235. Lowest Common Ancestor of a Binary Search Tree]]></title>
    <url>%2Fp%2F6e0230a7%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[234. Palindrome Linked List]]></title>
    <url>%2Fp%2F8fba543e%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[233. Number of Digit One]]></title>
    <url>%2Fp%2Fbb8f353e%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[232. Implement Queue using Stacks]]></title>
    <url>%2Fp%2F567717e2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[231. Power of Two]]></title>
    <url>%2Fp%2F79f66f39%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[230. Kth Smallest Element in a BST]]></title>
    <url>%2Fp%2F589d7851%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[229. Majority Element II]]></title>
    <url>%2Fp%2Fb53b72f4%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[228. Summary Ranges]]></title>
    <url>%2Fp%2F62fcefb8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[227. Basic Calculator II]]></title>
    <url>%2Fp%2Fec140a05%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[226. Invert Binary Tree]]></title>
    <url>%2Fp%2Ff3118605%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[225. Implement Stack using Queues]]></title>
    <url>%2Fp%2Fdb897a5%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[224. Basic Calculator]]></title>
    <url>%2Fp%2Fe3f3672e%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[223. Rectangle Area]]></title>
    <url>%2Fp%2Ff73f178%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[222. Count Complete Tree Nodes]]></title>
    <url>%2Fp%2Fada3754a%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[221. Maximal Square]]></title>
    <url>%2Fp%2F9ceb5f12%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[220. Contains Duplicate III]]></title>
    <url>%2Fp%2F86f6637a%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[219. Contains Duplicate II]]></title>
    <url>%2Fp%2F4c1e3175%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[218. The Skyline Problem]]></title>
    <url>%2Fp%2Fb0846169%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[217. Contains Duplicate]]></title>
    <url>%2Fp%2F4dd031de%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[216. Combination Sum III]]></title>
    <url>%2Fp%2F76a270b0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[215. Kth Largest Element in an Array]]></title>
    <url>%2Fp%2F85bb0f40%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[214. Shortest Palindrome]]></title>
    <url>%2Fp%2Fd81a1f9f%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[213. House Robber II]]></title>
    <url>%2Fp%2Ff35c89e6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[212. Word Search II]]></title>
    <url>%2Fp%2Fd7166e68%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[211. Add and Search Word - Data structure design]]></title>
    <url>%2Fp%2F7bf4b9ae%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[210. Course Schedule II]]></title>
    <url>%2Fp%2Fe6c1d8e3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[209. Minimum Size Subarray Sum]]></title>
    <url>%2Fp%2Fcf54181a%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[208. Implement Trie (Prefix Tree)]]></title>
    <url>%2Fp%2Fb78a563d%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[207. Course Schedule]]></title>
    <url>%2Fp%2F9a622bea%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[206. Reverse Linked List]]></title>
    <url>%2Fp%2Fc9c8233c%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[204. Count Primes]]></title>
    <url>%2Fp%2F99ef7c25%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[203. Remove Linked List Elements]]></title>
    <url>%2Fp%2F8392dc6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[202. Happy Number]]></title>
    <url>%2Fp%2Ff91a3fae%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[201. Bitwise AND of Numbers Range]]></title>
    <url>%2Fp%2Fee620e%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[200. Number of Islands]]></title>
    <url>%2Fp%2Fa61d2ad8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[199. Binary Tree Right Side View]]></title>
    <url>%2Fp%2Ffe12b283%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[198. House Robber]]></title>
    <url>%2Fp%2Fb015b294%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[191. Number of 1 Bits]]></title>
    <url>%2Fp%2F1f95eca1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[190. Reverse Bits]]></title>
    <url>%2Fp%2F60d7c33e%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[189. Rotate Array]]></title>
    <url>%2Fp%2Fde5421e%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[188. Best Time to Buy and Sell Stock IV]]></title>
    <url>%2Fp%2F96f6f6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[187. Repeated DNA Sequences]]></title>
    <url>%2Fp%2F11769ba3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[179. Largest Number]]></title>
    <url>%2Fp%2F7dd5a2b3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[174. Dungeon Game]]></title>
    <url>%2Fp%2F77abb633%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[173. Binary Search Tree Iterator]]></title>
    <url>%2Fp%2F85cdceee%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[172. Factorial Trailing Zeroes]]></title>
    <url>%2Fp%2F75ca0b86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[169. Majority Element]]></title>
    <url>%2Fp%2Ffc93121c%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[167. Two Sum II - Input array is sorted]]></title>
    <url>%2Fp%2F360afcfa%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[166. Fraction to Recurring Decimal]]></title>
    <url>%2Fp%2Fdff0e65f%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[165. Compare Version Numbers]]></title>
    <url>%2Fp%2F74b375a4%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[164. Maximum Gap]]></title>
    <url>%2Fp%2F304b41e7%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[162. Find Peak Element]]></title>
    <url>%2Fp%2Feb35e778%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[160. Intersection of Two Linked Lists]]></title>
    <url>%2Fp%2Fbf711257%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[159.Longest Substring with At Most Two Distinct Characters]]></title>
    <url>%2Fp%2F5c6ef69c%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[155. Min Stack]]></title>
    <url>%2Fp%2F901eaa11%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[154. Find Minimum in Rotated Sorted Array II]]></title>
    <url>%2Fp%2F3156a2f3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[153. Find Minimum in Rotated Sorted Array]]></title>
    <url>%2Fp%2F64895756%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[152. Maximum Product Subarray]]></title>
    <url>%2Fp%2Fab8f143e%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[151. Reverse Words in a String]]></title>
    <url>%2Fp%2Fc9db0a7a%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[150. Evaluate Reverse Polish Notation]]></title>
    <url>%2Fp%2F37aff2ee%2F</url>
    <content type="text"><![CDATA[26.4% Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. 123Some examples: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] -&gt; ((2 + 1) * 3) -&gt; 9 [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] -&gt; (4 + (13 / 5)) -&gt; 6 https://discuss.leetcode.com/topic/1323/6-132-0-or-1 6/（-132）= 0 or -1 when I test [“10”,”6”,”9”,”3”,”+”,”-11”,””,”/“,””,”17”,”+”,”5”,”+”], in this program, the result I got is 12, I think I am right. Because when I calculate 6/(-132) = -1, not 0, so i think the result is 12 not 22. Accepted C++ recursive solution (56 ms) with explanation. Simplest possible? Algorithm: pop string from the end of the vector if it’s number, just return it if it’s operation, call function recursively for 2nd operand and 1st 12345678910111213int evalRPN(vector&lt;string&gt; &amp;n) &#123;string s = n.back(); n.pop_back();if ( s== &quot;&quot; || s==&quot;/&quot; || s==&quot;+&quot; || s == &quot;-&quot; )&#123;int r2 = evalRPN(n);int r1 = evalRPN(n);if ( s==&quot;&quot;) return r1*r2;if ( s==&quot;/&quot;) return r1/r2;if ( s==&quot;+&quot;) return r1+r2;if ( s==&quot;-&quot;) return r1-r2;&#125;elsereturn atoi(s.c_str());&#125; https://discuss.leetcode.com/topic/38178/fancy-c-lambda-expression-solution Fancy C++ lambda expression solution 123456789101112131415161718192021222324class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; unordered_map&lt;string, function&lt;int (int, int) &gt; &gt; map = &#123; &#123; &quot;+&quot; , [] (int a, int b) &#123; return a + b; &#125; &#125;, &#123; &quot;-&quot; , [] (int a, int b) &#123; return a - b; &#125; &#125;, &#123; &quot;*&quot; , [] (int a, int b) &#123; return a * b; &#125; &#125;, &#123; &quot;/&quot; , [] (int a, int b) &#123; return a / b; &#125; &#125; &#125;; std::stack&lt;int&gt; stack; for (string&amp; s : tokens) &#123; if (!map.count(s)) &#123; stack.push(stoi(s)); &#125; else &#123; int op1 = stack.top(); stack.pop(); int op2 = stack.top(); stack.pop(); stack.push(map[s](op2, op1)); &#125; &#125; return stack.top(); &#125;&#125;; https://discuss.leetcode.com/topic/21965/python-solution-with-comments-don-t-use-eval-function Python solution with comments (don’t use eval() function). 12345678910111213141516171819202122def evalRPN(self, tokens): stack = [] for t in tokens: if t not in [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;]: stack.append(int(t)) else: r, l = stack.pop(), stack.pop() if t == &quot;+&quot;: stack.append(l+r) elif t == &quot;-&quot;: stack.append(l-r) elif t == &quot;*&quot;: stack.append(l*r) else: # here take care of the case like &quot;1/-22&quot;, # in Python 2.x, it returns -1, while in # Leetcode it should return 0 if l*r &lt; 0 and l % r != 0: stack.append(l/r+1) else: stack.append(l/r) return stack.pop() https://discuss.leetcode.com/topic/15344/a-simple-python-solution-o-n-72ms A simple Python solution - O(n) 72ms 123456789101112131415161718192021222324class Solution: # @param &#123;string[]&#125; tokens # @return &#123;integer&#125; def __init__(self): self.operators = &#123; &apos;+&apos;: lambda y, x: x + y, &apos;-&apos;: lambda y, x: x - y, &apos;*&apos;: lambda y, x: x * y, &apos;/&apos;: lambda y, x: int(operator.truediv(x, y)) &#125; def evalRPN(self, tokens): if not tokens: return 0 stack = [] for token in tokens: if token in self.operators: stack.append(self.operators[token](stack.pop(), stack.pop())) else: stack.append(int(token)) return stack[0]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[149. Max Points on a Line]]></title>
    <url>%2Fp%2F138e238c%2F</url>
    <content type="text"><![CDATA[15.5% https://leetcode.com/problems/max-points-on-a-line/#/description Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. https://discuss.leetcode.com/topic/6028/sharing-my-simple-solution-with-explanation Sharing my simple solution with explanation 1234567891011121314151617181920212223242526int maxPoints(vector&lt;Point&gt; &amp;points) &#123; int result = 0; for(int i = 0; i &lt; points.size(); i++)&#123; int samePoint = 1; unordered_map&lt;double, int&gt; map; for(int j = i + 1; j &lt; points.size(); j++)&#123; if(points[i].x == points[j].x &amp;&amp; points[i].y == points[j].y)&#123; samePoint++; &#125; else if(points[i].x == points[j].x)&#123; map[INT_MAX]++; &#125; else&#123; double slope = double(points[i].y - points[j].y) / double(points[i].x - points[j].x); map[slope]++; &#125; &#125; int localMax = 0; for(auto it = map.begin(); it != map.end(); it++)&#123; localMax = max(localMax, it-&gt;second); &#125; localMax += samePoint; result = max(result, localMax); &#125; return result;&#125; First, let’s talk about mathematics. How to determine if three points are on the same line? The answer is to see if slopes of arbitrary two pairs are the same. Second, let’s see what the minimum time complexity can be. Definitely, O(n^2). It’s because you have to calculate all slopes between any two points. Then let’s go back to the solution of this problem. In order to make this discussion simpler, let’s pick a random point A as an example. Given point A, we need to calculate all slopes between A and other points. There will be three cases: Some other point is the same as point A. Some other point has the same x coordinate as point A, which will result to a positive infinite slope. General case. We can calculate slope. We can store all slopes in a hash table. And we find which slope shows up mostly. Then add the number of same points to it. Then we know the maximum number of points on the same line for point A. We can do the same thing to point B, point C… Finally, just return the maximum result among point A, point B, point C… https://discuss.leetcode.com/topic/2709/c-o-n-2-solution-for-your-reference Hint by @stellari “For each point pi, calculate the slope of each line it forms with all other points with greater indices, i.e. pi+1, pi+2, …, and use a map to record how many lines have the same slope (If two lines have the same slope and share a common point, then the two lines must be the same one). By doing so, you can easily find how many points are on the same line that ends at pi in O(n). Thus the amortized running time of the whole algorithm is O(n^2).” In order to avoid using double type(the slope k) as map key, I used pair (int a, int b) as the key where a=pj.x-pi.x, b=pj.y-pi.y, and k=b/a. Using greatest common divider of a and b to divide both a, b ensures that lines with same slope have the same key. I also handled two special cases: (1) when two points are on a vertical line (2) when two points are the same. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: int maxPoints(vector&lt;Point&gt; &amp;points) &#123; if(points.size()&lt;2) return points.size(); int result=0; for(int i=0; i&lt;points.size(); i++) &#123; map&lt;pair&lt;int, int&gt;, int&gt; lines; int localmax=0, overlap=0, vertical=0; for(int j=i+1; j&lt;points.size(); j++) &#123; if(points[j].x==points[i].x &amp;&amp; points[j].y==points[i].y) &#123; overlap++; continue; &#125; else if(points[j].x==points[i].x) vertical++; else &#123; int a=points[j].x-points[i].x, b=points[j].y-points[i].y; int gcd=GCD(a, b); a/=gcd; b/=gcd; lines[make_pair(a, b)]++; localmax=max(lines[make_pair(a, b)], localmax); &#125; localmax=max(vertical, localmax); &#125; result=max(result, localmax+overlap+1); &#125; return result; &#125;private: int GCD(int a, int b) &#123; if(b==0) return a; else return GCD(b, a%b); &#125;&#125;; https://discuss.leetcode.com/topic/12877/20-line-c-o-n-2-hashing-solution The idea is straight forward. Calculate each slope between two points and handle two special cases: 1. vertical, 2. duplicate. 1234567891011121314151617181920212223242526class Solution &#123;public: int maxPoints(vector&lt;Point&gt;&amp; points) &#123; if(points.size()&lt;=2) return points.size(); int res=0; for(int i=0;i&lt;points.size()-1;i++) &#123; int numVertical=1,local=1,duplicate=0; unordered_map&lt;double,int&gt; map; for(int j=i+1;j&lt;points.size();j++) if(points[i].x==points[j].x) // special cases if(points[i].y==points[j].y) // duplicate duplicate++; else // vertical numVertical++; else &#123; double slope=(points[i].y-points[j].y)*1.0/(points[i].x-points[j].x); map[slope]==0?map[slope]=2:map[slope]++; local=max(local,map[slope]); &#125; local=max(local+duplicate,numVertical+duplicate); res=max(res,local); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/18447/16ms-28ms-c-solutions-with-explanations 16ms/28ms C++ Solutions with Explanations This problem has a naive idea, which is to traverse all possible pairs of two points and see how many other points fall in the line determined by them. This idea is of O(n^3) time complexity and will meet TLE. Well, let’s focus on lines instead of pairs of points. Could we just find out how many points fall in all possible lines? The answer is yes. Remember that a line is determined by its slope and intercept. In fact, if two lines with the same slope share a common point, then they are just the same line. So to determine a line, we need its slope and a point. Now comes the idea to solve this problem. We start from a specific point p, and compute all the slopes of the lines between p and the remaining points. Then those with the same slopes will be the same line. We can find out the maximum number of points fall on a line containing p. We exhaust all possible p’s and record the largest number we have seen. This number is just answer. Well, there are still two special cases to handle: Duplicate points: a pair of duplicate points give no determined line, so we just count the number of duplicates and add them to the result. Vertical lines: the slope of these lines is infinity mathematically. We simply set it to be INT_MAX in the following code. Now we have the following code, using an unordered_map&lt;float, int&gt; slopes to record how many points fall in the line of a specific slope and containing points[i]. Since all the operations of unordered_map is O(1), this code is of O(n^2) complexity. 12345678910111213141516171819202122232425class Solution &#123;public: int maxPoints(vector&lt;Point&gt;&amp; points) &#123; unordered_map&lt;float, int&gt; slopes; int maxp = 0, n = points.size(); for (int i = 0; i &lt; n; i++) &#123; slopes.clear(); int duplicate = 1; for (int j = i + 1; j &lt; n; j++) &#123; if (points[j].x == points[i].x &amp;&amp; points[j].y == points[i].y) &#123; duplicate++; continue; &#125; float slope = (points[j].x == points[i].x) ? INT_MAX : (float)(points[j].y - points[i].y) / (points[j].x - points[i].x); slopes[slope]++; &#125; maxp = max(maxp, duplicate); for (auto slope : slopes) if (slope.second + duplicate &gt; maxp) maxp = slope.second + duplicate; &#125; return maxp; &#125;&#125;; Well, since the representation of floating point numbers is sometimes inaccurate, we may use a more safer way to represent the slope (dy / dx), which is to record dx and dy in a pair&lt;int, int&gt;. However, once we use pair&lt;int, int&gt; for the key of the map, we cannot use an unordered_map since pair&lt;int, int&gt; is unhashable. We now change to map and the time complexity becomes O(n^2logn). Also, since dy = 4, dx = 2 and dy = 8, dx = 4 represents the same slope, we need to divide both of them by their gcd first. The code is as follows. The logic is the same of the one above, just introducing pair and gcd. 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public: int maxPoints(vector&lt;Point&gt;&amp; points) &#123; map&lt;pair&lt;int, int&gt;, int&gt; slopes; int maxp = 0, n = points.size(); for (int i = 0; i &lt; n; i++) &#123; slopes.clear(); int duplicate = 1; for (int j = i + 1; j &lt; n; j++) &#123; if (points[j].x == points[i].x &amp;&amp; points[j].y == points[i].y) &#123; duplicate++; continue; &#125; int dx = points[j].x - points[i].x; int dy = points[j].y - points[i].y; int dvs = gcd(dx, dy); slopes[make_pair(dx / dvs, dy / dvs)]++; &#125; maxp = max(maxp, duplicate); for (auto slope : slopes) if (slope.second + duplicate &gt; maxp) maxp = slope.second + duplicate; &#125; return maxp; &#125;private: int gcd(int num1, int num2) &#123; while (num2) &#123; int temp = num2; num2 = num1 % num2; num1 = temp; &#125; return num1; &#125;&#125;; https://discuss.leetcode.com/topic/21896/python-68-ms-code Python 68 ms code 1234567891011121314151617def maxPoints(self, points): l = len(points) m = 0 for i in range(l): dic = &#123;&apos;i&apos;: 1&#125; same = 0 for j in range(i+1, l): tx, ty = points[j].x, points[j].y if tx == points[i].x and ty == points[i].y: same += 1 continue if points[i].x == tx: slope = &apos;i&apos; else:slope = (points[i].y-ty) * 1.0 /(points[i].x-tx) if slope not in dic: dic[slope] = 1 dic[slope] += 1 m = max(m, max(dic.values()) + same)return m https://discuss.leetcode.com/topic/2979/a-java-solution-with-notes A line is determined by two factors,say y=ax+b If two points(x1,y1) (x2,y2) are on the same line(Of course). Consider the gap between two points. We have (y2-y1)=a(x2-x1),a=(y2-y1)/(x2-x1) a is a rational, b is canceled since b is a constant If a third point (x3,y3) are on the same line. So we must have y3=ax3+b Thus,(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a Since a is a rational, there exists y0 and x0, y0/x0=(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a So we can use y0&amp;x0 to track a line; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for a point. * class Point &#123; * int x; * int y; * Point() &#123; x = 0; y = 0; &#125; * Point(int a, int b) &#123; x = a; y = b; &#125; * &#125; */public class Solution&#123; public int maxPoints(Point[] points) &#123; if (points==null) return 0; if (points.length&lt;=2) return points.length; Map&lt;Integer,Map&lt;Integer,Integer&gt;&gt; map = new HashMap&lt;Integer,Map&lt;Integer,Integer&gt;&gt;(); int result=0; for (int i=0;i&lt;points.length;i++)&#123; map.clear(); int overlap=0,max=0; for (int j=i+1;j&lt;points.length;j++)&#123; int x=points[j].x-points[i].x; int y=points[j].y-points[i].y; if (x==0&amp;&amp;y==0)&#123; overlap++; continue; &#125; int gcd=generateGCD(x,y); if (gcd!=0)&#123; x/=gcd; y/=gcd; &#125; if (map.containsKey(x))&#123; if (map.get(x).containsKey(y))&#123; map.get(x).put(y, map.get(x).get(y)+1); &#125;else&#123; map.get(x).put(y, 1); &#125; &#125;else&#123; Map&lt;Integer,Integer&gt; m = new HashMap&lt;Integer,Integer&gt;(); m.put(y, 1); map.put(x, m); &#125; max=Math.max(max, map.get(x).get(y)); &#125; result=Math.max(result, max+overlap+1); &#125; return result; &#125; private int generateGCD(int a,int b)&#123; if (b==0) return a; else return generateGCD(b,a%b); &#125;&#125; https://discuss.leetcode.com/topic/24011/accepted-java-solution-easy-to-understand1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a point. * class Point &#123; * int x; * int y; * Point() &#123; x = 0; y = 0; &#125; * Point(int a, int b) &#123; x = a; y = b; &#125; * &#125; */public class Solution &#123; public int maxPoints(Point[] points) &#123; if(points.length &lt;= 0) return 0; if(points.length &lt;= 2) return points.length; int result = 0; for(int i = 0; i &lt; points.length; i++)&#123; HashMap&lt;Double, Integer&gt; hm = new HashMap&lt;Double, Integer&gt;(); int samex = 1; int samep = 0; for(int j = 0; j &lt; points.length; j++)&#123; if(j != i)&#123; if((points[j].x == points[i].x) &amp;&amp; (points[j].y == points[i].y))&#123; samep++; &#125; if(points[j].x == points[i].x)&#123; samex++; continue; &#125; double k = (double)(points[j].y - points[i].y) / (double)(points[j].x - points[i].x); if(hm.containsKey(k))&#123; hm.put(k,hm.get(k) + 1); &#125;else&#123; hm.put(k, 2); &#125; result = Math.max(result, hm.get(k) + samep); &#125; &#125; result = Math.max(result, samex); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>math</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[148. Sort List]]></title>
    <url>%2Fp%2F41f5a08%2F</url>
    <content type="text"><![CDATA[27.7% https://leetcode.com/problems/sort-list/?tab=Description Sort a linked list in O(n log n) time using constant space complexity. 归并排序 微信面试题：使用快速排序，对链表进行排序 方法一： 归并排序 https://discuss.leetcode.com/topic/17150/clean-and-short-merge-sort-solution-in-c Clean and short Merge sort Solution in c++ 12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* merge( ListNode* head1 , ListNode * head2)&#123; ListNode* d = new ListNode (0); // dummy node ListNode* e = d; while(head1||head2)&#123; if(head1 &amp;&amp; (!head2 || head1-&gt;val &lt;= head2 -&gt; val) )&#123; e=e-&gt;next= head1 ; head1 = head1 -&gt; next; &#125; if(head2 &amp;&amp; (!head1 || head2-&gt;val &lt; head1 -&gt; val) )&#123; e=e-&gt;next= head2 ; head2 = head2 -&gt; next; &#125; &#125; e-&gt;next = NULL; return d-&gt;next; &#125; ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* slow = head; ListNode* fast =head-&gt;next; while(fast &amp;&amp; fast-&gt;next)&#123; // to find middle node fast= fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; ListNode* headb = slow-&gt;next; // headb is start of 2nd half of list slow-&gt;next = NULL; return merge(sortList(head) , sortList(headb)); &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* fast = head, *slow = head; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; ListNode* tmp = slow-&gt;next; slow-&gt;next = NULL; ListNode* head1 = sortList(head); ListNode* head2 = sortList(tmp); ListNode* node = merge(head1, head2); return node; &#125; ListNode* merge(ListNode* head1, ListNode* head2)&#123; if(head1==NULL) return head2; if(head2==NULL) return head1; if(head1-&gt;val&lt;=head2-&gt;val)&#123; head1-&gt;next = merge(head1-&gt;next, head2); return head1; &#125;else&#123; head2-&gt;next = merge(head1, head2-&gt;next); return head2; &#125; &#125;&#125;; 方法二： 使用147题的插入排序，效率O(n^2)不能满足要求 超时 方法三： 归并排序 我的代码实现: 有bug 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* slow = head, *fast = head; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; fast = slow-&gt;next; slow-&gt;next = nullptr; sortList(head); sortList(fast); return merge(head, fast); &#125; ListNode* merge(ListNode* l1, ListNode* l2)&#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = merge(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = merge(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/10382/bottom-to-up-not-recurring-with-o-1-space-complextity-and-o-nlgn-time-complextity Bottom-to-up(not recurring) with o(1) space complextity and o(nlgn) time complextity this problem can be easily solved using recurrence and divide-and-conquer. But it consumes program stack to store the recurring function stack frame, actually it consumes o(lgn) space complexity. Recursion use up-to-bottom strategy , why not try the opposite way–bottom-to-up, luckily it works, it only consumes 0(1) space complexity and o(nlgn) time complextity. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Merge sort use bottom-up policy, * so Space Complexity is O(1) * Time Complexity is O(NlgN) * stable sort*/class Solution &#123;public: ListNode *sortList(ListNode *head) &#123; if(!head || !(head-&gt;next)) return head; //get the linked list&apos;s length ListNode* cur = head; int length = 0; while(cur)&#123; length++; cur = cur-&gt;next; &#125; ListNode dummy(0); dummy.next = head; ListNode *left, *right, *tail; for(int step = 1; step &lt; length; step &lt;&lt;= 1)&#123; cur = dummy.next; tail = &amp;dummy; while(cur)&#123; left = cur; right = split(left, step); cur = split(right,step); tail = merge(left, right, tail); &#125; &#125; return dummy.next; &#125;private: /** * Divide the linked list into two lists, * while the first list contains first n ndoes * return the second list&apos;s head */ ListNode* split(ListNode *head, int n)&#123; //if(!head) return NULL; for(int i = 1; head &amp;&amp; i &lt; n; i++) head = head-&gt;next; if(!head) return NULL; ListNode *second = head-&gt;next; head-&gt;next = NULL; return second; &#125; /** * merge the two sorted linked list l1 and l2, * then append the merged sorted linked list to the node head * return the tail of the merged sorted linked list */ ListNode* merge(ListNode* l1, ListNode* l2, ListNode* head)&#123; ListNode *cur = head; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &gt; l2-&gt;val)&#123; cur-&gt;next = l2; cur = l2; l2 = l2-&gt;next; &#125; else&#123; cur-&gt;next = l1; cur = l1; l1 = l1-&gt;next; &#125; &#125; cur-&gt;next = (l1 ? l1 : l2); while(cur-&gt;next) cur = cur-&gt;next; return cur; &#125;&#125;; https://discuss.leetcode.com/topic/3085/my-o-n-log-n-time-o-1-space-solution My O(n log n) time, O(1) space solution Nice problem. I use a non-recurisve way to write merge sort. For example, the size of ListNode is 8, Round #1 block_size = 1 (a1, a2), (a3, a4), (a5, a6), (a7, a8) Compare a1 with a2, a3 with a4 … Round #2 block_size = 2 (a1, a2, a3, a4), (a5, a6, a7, a8) merge two sorted arrays (a1, a2) and (a3, a4), then merge tow sorted arrays(a5, a6) and (a7, a8) Round #3 block_size = 4 (a1, a2, a3, a4, a5, a6, a7, a8) merge two sorted arrays (a1, a2, a3, a4), and (a5, a6, a7, a8) No need for round #4 cause block_size = 8 &gt;= n = 8 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: int count_size(ListNode *node)&#123; int n = 0; while (node != NULL)&#123; node = node-&gt;next; ++n; &#125; return n; &#125; ListNode *sortList(ListNode *head) &#123; int block_size = 1, n = count_size(head), iter = 0, i = 0, a = 0, b = 0; ListNode virtual_head(0); ListNode *last = NULL, *it = NULL, *A = NULL, *B = NULL, *tmp = NULL; virtual_head.next = head; while (block_size &lt; n)&#123; iter = 0; last = &amp;virtual_head; it = virtual_head.next; while (iter &lt; n)&#123; a = min(n - iter, block_size); b = min(n - iter - a, block_size); A = it; if (b != 0)&#123; for (i = 0; i &lt; a - 1; ++i) it = it-&gt;next; B = it-&gt;next; it-&gt;next = NULL; it = B; for (i = 0; i &lt; b - 1; ++i) it = it-&gt;next; tmp = it-&gt;next; it-&gt;next = NULL; it = tmp; &#125; while (A || B)&#123; if (B == NULL || (A != NULL &amp;&amp; A-&gt;val &lt;= B-&gt;val))&#123; last-&gt;next = A; last = last-&gt;next; A = A-&gt;next; &#125; else &#123; last-&gt;next = B; last = last-&gt;next; B = B-&gt;next; &#125; &#125; last-&gt;next = NULL; iter += a + b; &#125; block_size &lt;&lt;= 1; &#125; return virtual_head.next; &#125;&#125;; python https://discuss.leetcode.com/topic/30407/clean-python-code Clean python code 12345678910111213141516171819202122class Solution(object): def merge(self, h1, h2): dummy = tail = ListNode(None) while h1 and h2: if h1.val &lt; h2.val: tail.next, tail, h1 = h1, h1, h1.next else: tail.next, tail, h2 = h2, h2, h2.next tail.next = h1 or h2 return dummy.next def sortList(self, head): if not head or not head.next: return head pre, slow, fast = None, head, head while fast and fast.next: pre, slow, fast = slow, slow.next, fast.next.next pre.next = None return self.merge(*map(self.sortList, (head, slow))) java https://discuss.leetcode.com/topic/18100/java-merge-sort-solution Java merge sort solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public ListNode sortList(ListNode head) &#123; if (head == null || head.next == null) return head; // step 1. cut the list to two halves ListNode prev = null, slow = head, fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; prev = slow; slow = slow.next; fast = fast.next.next; &#125; prev.next = null; // step 2. sort each half ListNode l1 = sortList(head); ListNode l2 = sortList(slow); // step 3. merge l1 and l2 return merge(l1, l2); &#125; ListNode merge(ListNode l1, ListNode l2) &#123; ListNode l = new ListNode(0), p = l; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt; l2.val) &#123; p.next = l1; l1 = l1.next; &#125; else &#123; p.next = l2; l2 = l2.next; &#125; p = p.next; &#125; if (l1 != null) p.next = l1; if (l2 != null) p.next = l2; return l.next; &#125;&#125; https://discuss.leetcode.com/topic/643/i-have-a-pretty-good-mergesort-method-can-anyone-speed-up-the-run-time-or-reduce-the-memory-usage I have a pretty good MergeSort method. Can anyone speed up the run time or reduce the memory usage? 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode sortList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode f = head.next.next; ListNode p = head; while (f != null &amp;&amp; f.next != null) &#123; p = p.next; f = f.next.next; &#125; ListNode h2 = sortList(p.next); p.next = null; return merge(sortList(head), h2); &#125; public ListNode merge(ListNode h1, ListNode h2) &#123; ListNode hn = new ListNode(Integer.MIN_VALUE); ListNode c = hn; while (h1 != null &amp;&amp; h2 != null) &#123; if (h1.val &lt; h2.val) &#123; c.next = h1; h1 = h1.next; &#125; else &#123; c.next = h2; h2 = h2.next; &#125; c = c.next; &#125; if (h1 != null) c.next = h1; if (h2 != null) c.next = h2; return hn.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>linked list</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[147. Insertion Sort List]]></title>
    <url>%2Fp%2Fcd2ad8e1%2F</url>
    <content type="text"><![CDATA[32.2% Sort a linked list using insertion sort. 方法一： 常规的插入排序，改成针对链表排序。 插入排序，每次从后向前走，这里每次从前向后走，找到插入位置。因为链表插入时O(1)空间，所以一样的。 我的代码实现： Oct 11th, 2017 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(head==nullptr || head-&gt;next==nullptr) return head; ListNode* dummy = new ListNode(-1); ListNode* p1 = head, *p2 = dummy, *p3; while(p1!=nullptr)&#123; p2 = dummy; while(p2-&gt;next!=nullptr &amp;&amp; p2-&gt;next-&gt;val &lt;= p1-&gt;val)&#123; p2 = p2-&gt;next; &#125; p3 = p1-&gt;next; p1-&gt;next = p2-&gt;next; p2-&gt;next = p1; p1 = p3; &#125; return dummy-&gt;next; &#125;&#125;; my code 新建一个新节点，ListNode* dummy = new ListNode(0); 12345678910111213141516171819202122class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(head==NULL || head-&gt;next==NULL) return head; ListNode* cur; cur=head-&gt;next; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; head-&gt;next = NULL; while(cur!=NULL)&#123; ListNode* tmp = cur-&gt;next; head = dummy; while(head-&gt;next!=NULL &amp;&amp; head-&gt;next-&gt;val &lt; cur-&gt;val) head = head-&gt;next; cur-&gt;next = head-&gt;next; head-&gt;next = cur; cur = tmp; &#125; return dummy-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/8570/an-easy-and-clear-way-to-sort-o-1-space An easy and clear way to sort ( O(1) space ) 12345678910111213141516171819202122232425public ListNode insertionSortList(ListNode head) &#123; if( head == null )&#123; return head; &#125; ListNode helper = new ListNode(0); //new starter of the sorted list ListNode cur = head; //the node will be inserted ListNode pre = helper; //insert node between pre and pre.next ListNode next = null; //the next node will be inserted //not the end of input list while( cur != null )&#123; next = cur.next; //find the right place to insert while( pre.next != null &amp;&amp; pre.next.val &lt; cur.val )&#123; pre = pre.next; &#125; //insert between pre and pre.next cur.next = pre.next; pre.next = cur; pre = helper; cur = next; &#125; return helper.next; &#125; https://discuss.leetcode.com/topic/14916/explained-c-solution-24ms Explained C++ solution (24ms) Well, life gets difficult pretty soon whenever the same operation on array is transferred to linked list. First, a quick recap of insertion sort: Start from the second element (simply a[1] in array and the annoying head -&gt; next -&gt; val in linked list), each time when we see a node with val smaller than its previous node, we scan from the head and find the position that the current node should be inserted. Since a node may be inserted before head, we create a new_head that points to head. The insertion operation, however, is a little easier for linked list. Now comes the code: 1234567891011121314151617181920212223242526class Solution &#123; public: ListNode* insertionSortList(ListNode* head) &#123; ListNode* new_head = new ListNode(0); new_head -&gt; next = head; ListNode* pre = new_head; ListNode* cur = head; while (cur) &#123; if (cur -&gt; next &amp;&amp; cur -&gt; next -&gt; val &lt; cur -&gt; val) &#123; while (pre -&gt; next &amp;&amp; pre -&gt; next -&gt; val &lt; cur -&gt; next -&gt; val) pre = pre -&gt; next; /* Insert cur -&gt; next after pre.*/ ListNode* temp = pre -&gt; next; pre -&gt; next = cur -&gt; next; cur -&gt; next = cur -&gt; next -&gt; next; pre -&gt; next -&gt; next = temp; /* Move pre back to new_head. */ pre = new_head; &#125; else cur = cur -&gt; next; &#125; ListNode* res = new_head -&gt; next; delete new_head; return res; &#125;&#125;; https://discuss.leetcode.com/topic/1855/accepted-solution-using-java Accepted Solution using JAVA 12345678910111213141516public ListNode insertionSortList(ListNode head) &#123; ListNode helper=new ListNode(0); ListNode pre=helper; ListNode current=head; while(current!=null) &#123; pre=helper; while(pre.next!=null&amp;&amp;pre.next.val&lt;current.val) &#123; pre=pre.next; &#125; ListNode next=current.next; current.next=pre.next; pre.next=current; current=next; &#125; return helper.next;&#125; https://discuss.leetcode.com/topic/4932/python-time-limit-is-too-tight Python time limit is too tight I have basically the same code in python and java (see below). python got TLE, but java was accepted. I propose to relax the python time limit a little bit. Python 12345678910111213141516171819class Solution:# @param head, a ListNode# @return a ListNodedef insertionSortList(self, head): srt = None while head: node = head head = head.next node.next = None srt = self.insertTo(srt, node) return srt def insertTo(self, head, node): node.next = head head = node while node.next and node.val &gt; node.next.val: node.val, node.next.val = node.next.val, node.val node = node.next return head java 123456789101112131415161718192021222324public class Solution &#123; public ListNode insertionSortList(ListNode head) &#123; ListNode srt = null; while (head != null) &#123; ListNode node = head; head = head.next; node.next = null; srt = insertTo(srt, node); &#125; return srt; &#125; public ListNode insertTo(ListNode head, ListNode node) &#123; node.next = head; head = node; while (node.next != null &amp;&amp; node.val &gt; node.next.val) &#123; node.val = node.val ^ node.next.val; node.next.val = node.val ^ node.next.val; node.val = node.val ^ node.next.val; node = node.next; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>two pointers</tag>
        <tag>medium</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[146. LRU Cache]]></title>
    <url>%2Fp%2F5f411b29%2F</url>
    <content type="text"><![CDATA[16.7% Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up: Could you do both operations in O(1) time complexity? 12345678910111213Example:LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 https://discuss.leetcode.com/topic/6812/c-11-code-74ms-hash-table-list C++11 code 74ms - Hash table + List There is a similar example in Java, but I wanted to share my solution using the new C++11 unordered_map and a list. The good thing about lists is that iterators are never invalidated by modifiers (unless erasing the element itself). This way, we can store the iterator to the corresponding LRU queue in the values of the hash map. Since using erase on a list with an iterator takes constant time, all operations of the LRU cache run in constant time. 12345678910111213141516171819202122232425262728293031323334353637383940class LRUCache &#123;public: LRUCache(int capacity) : _capacity(capacity) &#123;&#125; int get(int key) &#123; auto it = cache.find(key); if (it == cache.end()) return -1; touch(it); return it-&gt;second.first; &#125; void set(int key, int value) &#123; auto it = cache.find(key); if (it != cache.end()) touch(it); else &#123; if (cache.size() == _capacity) &#123; cache.erase(used.back()); used.pop_back(); &#125; used.push_front(key); &#125; cache[key] = &#123; value, used.begin() &#125;; &#125; private: typedef list&lt;int&gt; LI; typedef pair&lt;int, LI::iterator&gt; PII; typedef unordered_map&lt;int, PII&gt; HIPII; void touch(HIPII::iterator it) &#123; int key = it-&gt;first; used.erase(it-&gt;second.second); used.push_front(key); it-&gt;second.second = used.begin(); &#125; HIPII cache; LI used; int _capacity;&#125;; https://discuss.leetcode.com/topic/25792/clean-short-standard-c-solution-not-writing-c-in-c-like-all-other-lengthy-ones Clean Short Standard C++ solution – NOT writing C in C++ like all other lengthy ones I saw so many (or all) “C++” solutions posted here were not written in C++ at all. For those 200-line solutions, I don’t see the point in implementing a double-linked-list by themselves. If you are writing C++, please use STL! The code below is way cleaner, shorter and easier to read than most other C++ solutions posted here.And above all, it was written in a standard C++ way. 1234567891011121314151617181920212223242526272829303132class LRUCache&#123; size_t m_capacity; unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; m_map; //m_map_iter-&gt;first: key, m_map_iter-&gt;second: list iterator; list&lt;pair&lt;int, int&gt;&gt; m_list; //m_list_iter-&gt;first: key, m_list_iter-&gt;second: value;public: LRUCache(size_t capacity):m_capacity(capacity) &#123; &#125; int get(int key) &#123; auto found_iter = m_map.find(key); if (found_iter == m_map.end()) //key doesn&apos;t exist return -1; m_list.splice(m_list.begin(), m_list, found_iter-&gt;second); //move the node corresponding to key to front return found_iter-&gt;second-&gt;second; //return value of the node &#125; void set(int key, int value) &#123; auto found_iter = m_map.find(key); if (found_iter != m_map.end()) //key exists &#123; m_list.splice(m_list.begin(), m_list, found_iter-&gt;second); //move the node corresponding to key to front found_iter-&gt;second-&gt;second = value; //update value of the node return; &#125; if (m_map.size() == m_capacity) //reached capacity &#123; int key_to_del = m_list.back().first; m_list.pop_back(); //remove node in list; m_map.erase(key_to_del); //remove key in map &#125; m_list.emplace_front(key, value); //create new node in list m_map[key] = m_list.begin(); //create correspondence between key and node &#125;&#125;; https://discuss.leetcode.com/topic/4324/accepted-c-solution-296-ms Accepted C++ solution, 296 ms Solution is unusual - combination of 2 data structures - hash map and linked list.Algorithm: hash map holds iterators to linked list linked list holds key and value, key to access hash map items when item is accessed, it’s promoted - moved to the tail of the list - O(1) operation when item should be removed, we remove head of the list - O(1) operation when item is not promoted long time, it’s moved to the head of the list automatically get() - O(1) performance, set() - O(1) performance { 123456789101112131415161718192021222324252627282930313233343536373839404142434445class LRUCache&#123;private: struct item_t&#123; int key, val; item_t(int k, int v) :key(k), val(v)&#123;&#125; &#125;; typedef list&lt;item_t&gt; list_t; typedef unordered_map&lt;int, list_t::iterator&gt; map_t; map_t m_map; list_t m_list; int m_capacity;public: LRUCache(int capacity) : m_capacity(capacity) &#123; &#125; int get(int key) &#123; map_t::iterator i = m_map.find(key); if (i == m_map.end()) return -1; m_map[key] = promote(i-&gt;second); return m_map[key]-&gt;val; &#125; void set(int key, int value) &#123; map_t::iterator i = m_map.find(key); if (i != m_map.end())&#123; m_map[key] = promote(i-&gt;second); m_map[key]-&gt;val = value; &#125; else &#123; if (m_map.size() &lt; m_capacity)&#123; m_map[key] = m_list.insert(m_list.end(), item_t(key, value)); &#125; else &#123; m_map.erase(m_list.front().key); m_list.pop_front(); m_map[key] = m_list.insert(m_list.end(), item_t(key, value)); &#125; &#125; &#125; list_t::iterator promote(list_t::iterator i)&#123; list_t::iterator inew = m_list.insert(m_list.end(), *i); m_list.erase(i); return inew; &#125;&#125;;&#125; btw LeetCode, it was really hard to insert this code, after pressing {} button, class was improperly formatted. I inserted additional braces around class. https://discuss.leetcode.com/topic/12262/o-1-unordered_map-list-splice O(1) unordered_map + list + splice 12345678910111213141516171819202122232425262728293031323334353637383940class LRUCache &#123;private: // A list of (key, value) pairs list&lt;pair&lt;int, int&gt;&gt; items; // Map items to iterators (pointers) to list nodes unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; cache; // The capacity of the list int capacity;public: LRUCache(int capacity) : capacity(capacity) &#123;&#125; int get(int key) &#123; // If key is not found in hash map, return -1 if (cache.find(key) == cache.end()) return -1; // Move the (key, value) pair to the beginning of the list items.splice(items.begin(), items, cache[key]); return cache[key]-&gt;second; &#125; void set(int key, int value) &#123; // The key is not in the hash table if (cache.find(key) == cache.end()) &#123; // If the cache is full then delete the least recently // used item, which is at the end of the list if (items.size() == capacity) &#123; cache.erase(items.back().first); items.pop_back(); &#125; items.push_front(make_pair(key, value)); cache[key] = items.begin(); &#125; else &#123; // Update the value associated with the key cache[key]-&gt;second = value; // Move the (key, value) pair to the beginning of the list items.splice(items.begin(), items, cache[key]); &#125; &#125;&#125; https://discuss.leetcode.com/topic/14591/python-dict-double-linkedlist Python Dict + Double LinkedList 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Node:def __init__(self, k, v): self.key = k self.val = v self.prev = None self.next = Noneclass LRUCache:def __init__(self, capacity): self.capacity = capacity self.dic = dict() self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.headdef get(self, key): if key in self.dic: n = self.dic[key] self._remove(n) self._add(n) return n.val return -1def set(self, key, value): if key in self.dic: self._remove(self.dic[key]) n = Node(key, value) self._add(n) self.dic[key] = n if len(self.dic) &gt; self.capacity: n = self.head.next self._remove(n) del self.dic[n.key]def _remove(self, node): p = node.prev n = node.next p.next = n n.prev = pdef _add(self, node): p = self.tail.prev p.next = node self.tail.prev = node node.prev = p node.next = self.tail https://discuss.leetcode.com/topic/24757/python-concise-solution-with-comments-using-ordereddict Python concise solution with comments (Using OrderedDict). 1234567891011121314151617181920def __init__(self, capacity): self.dic = collections.OrderedDict() self.remain = capacitydef get(self, key): if key not in self.dic: return -1 v = self.dic.pop(key) self.dic[key] = v # set key as the newest one return vdef set(self, key, value): if key in self.dic: self.dic.pop(key) else: if self.remain &gt; 0: self.remain -= 1 else: # self.dic is full self.dic.popitem(last=False) self.dic[key] = value]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[145. Binary Tree Postorder Traversal]]></title>
    <url>%2Fp%2F4b821bfc%2F</url>
    <content type="text"><![CDATA[39.0% https://leetcode.com/problems/binary-tree-postorder-traversal/#/description Given a binary tree, return the postorder traversal of its nodes’ values. 12345678For example:Given binary tree &#123;1,#,2,3&#125;, 1 \ 2 / 3return [3,2,1]. Note: Recursive solution is trivial, could you do it iteratively? 方法一：递归，此方法可用于先序、中序、后续。但是面试时肯定是不够用的。 Recursive solution 时间空间复杂度 ： O(n) time and O(n) space (considering the spaces of function call stack); 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; helper(root, res); return res; &#125; void helper(TreeNode* root, vector&lt;int&gt;&amp; res)&#123; if(root)&#123; helper(root-&gt;left, res); helper(root-&gt;right, res); res.push_back(root-&gt;val); &#125; &#125;&#125;; 方法二：使用栈来保存要遍历的节点，后续是先左，后右，最后根。反过来，最后结果反转。 先根节点，然后再先右，再左。 先右，左节点就需要保存一下，所以先把左节点压入栈中，然后把右节点压入栈。 取出时，先取出右节点的，进行处理。处理完毕，再处理做节点的。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; stack&lt;TreeNode*&gt; nodeStack; vector&lt;int&gt; result; //base case if(root==NULL) return result; nodeStack.push(root); while(!nodeStack.empty()) &#123; TreeNode* node= nodeStack.top(); result.push_back(node-&gt;val); nodeStack.pop(); if(node-&gt;left) nodeStack.push(node-&gt;left); if(node-&gt;right) nodeStack.push(node-&gt;right); &#125; reverse(result.begin(),result.end()); return result; &#125;&#125;; 思路相同，另一种写法如下： 与上述代码的不同之处在于，没有反转，而是直接在vector前面插入一个value。 v.insert(v.begin(), val); 123456789101112131415161718vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; v; if (!root) return v; stack&lt;TreeNode *&gt; s; s.push(root); TreeNode *p = NULL; while(!s.empty()) &#123; p = s.top(); s.pop(); v.insert(v.begin(), p-&gt;val); if (p-&gt;left) s.push(p-&gt;left); if (p-&gt;right) s.push(p-&gt;right); &#125; return v;&#125; 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; stack; stack.push(root); while(!stack.empty())&#123; TreeNode* node = stack.top(); stack.pop(); res.push_back(node-&gt;val); if(node-&gt;left) stack.push(node-&gt;left); if(node-&gt;right) stack.push(node-&gt;right); &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 方法三：Iterative solution using stack — O(n) time and O(n) space; 我的代码实现: Dec 10th, 2017 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; while(cur!=nullptr || !stack.empty())&#123; if(cur)&#123; res.push_back(cur-&gt;val); stack.push(cur); cur = cur-&gt;right; &#125;else&#123; TreeNode* tmp = stack.top(); stack.pop(); cur = tmp-&gt;left; &#125; &#125; // 最后不要忘记反转 reverse(res.begin(), res.end()); return res; &#125;&#125;; 1234567891011121314151617181920212223vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; stack&lt;TreeNode*&gt; toVisit; TreeNode* curNode = root; TreeNode* lastNode = NULL; while (curNode || !toVisit.empty()) &#123; if (curNode) &#123; toVisit.push(curNode); curNode = curNode -&gt; left; &#125; else &#123; TreeNode* topNode = toVisit.top(); if (topNode -&gt; right &amp;&amp; lastNode != topNode -&gt; right) curNode = topNode -&gt; right; else &#123; nodes.push_back(topNode -&gt; val); lastNode = topNode; toVisit.pop(); &#125; &#125; &#125; return nodes;&#125; 我的代码实现： 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; stack; while(root || stack.size())&#123; if(root)&#123; stack.push(root); res.push_back(root-&gt;val); root = root-&gt;right; &#125;else&#123; TreeNode* node = stack.top(); stack.pop(); root = node-&gt;left; &#125; &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 方法四：https://discuss.leetcode.com/topic/14473/0-ms-clear-c-solutions-iterative-recursive-morris-traversal-3-different-solutions Morris traversal 时间空间复杂度 ： O(n) time and O(1) space!!! Morris traversal: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void reverseNodes(TreeNode* start, TreeNode* end) &#123; if (start == end) return; TreeNode* x = start; TreeNode* y = start -&gt; right; TreeNode* z; while (x != end) &#123; z = y -&gt; right; y -&gt; right = x; x = y; y = z; &#125;&#125;void reverseAddNodes(TreeNode* start, TreeNode* end, vector&lt;int&gt;&amp; nodes) &#123; reverseNodes(start, end); TreeNode* node = end; while (true) &#123; nodes.push_back(node -&gt; val); if (node == start) break; node = node -&gt; right; &#125; reverseNodes(end, start);&#125;vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; TreeNode* dump = new TreeNode(0); dump -&gt; left = root; TreeNode* curNode = dump; while (curNode) &#123; if (curNode -&gt; left) &#123; TreeNode* predecessor = curNode -&gt; left; while (predecessor -&gt; right &amp;&amp; predecessor -&gt; right != curNode) predecessor = predecessor -&gt; right; if (!(predecessor -&gt; right)) &#123; predecessor -&gt; right = curNode; curNode = curNode -&gt; left; &#125; else &#123; reverseAddNodes(curNode -&gt; left, predecessor, nodes); predecessor -&gt; right = NULL; curNode = curNode -&gt; right; &#125; &#125; else curNode = curNode -&gt; right; &#125; return nodes;&#125; 我的代码实现： 按照先序遍历，先根再右再左，然后再对vector res进行reverse 访问时使用morris遍历 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; TreeNode* cur = root; while(cur)&#123; if(cur-&gt;right)&#123; TreeNode* pre = cur-&gt;right; while(pre-&gt;left &amp;&amp; pre-&gt;left!=cur) pre = pre-&gt;left; if(pre-&gt;left==cur)&#123; pre-&gt;left = NULL; cur = cur-&gt;left; &#125;else&#123; res.push_back(cur-&gt;val); pre-&gt;left = cur; cur = cur-&gt;right; &#125; &#125;else&#123; res.push_back(cur-&gt;val); cur = cur-&gt;left; &#125; &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 先序、中序、后序的迭代方法总结： https://discuss.leetcode.com/topic/30632/preorder-inorder-and-postorder-iteratively-summarization Preorder, Inorder, and Postorder Iteratively Summarization Here I summarize the iterative implementation for preorder, inorder, and postorder traverse. PRE ORDER TRAVERSE 12345678910111213141516public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); TreeNode p = root; while(!stack.isEmpty() || p != null) &#123; if(p != null) &#123; stack.push(p); result.add(p.val); // Add before going to children p = p.left; &#125; else &#123; TreeNode node = stack.pop(); p = node.right; &#125; &#125; return result;&#125; IN ORDER TRAVERSE 12345678910111213141516public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); TreeNode p = root; while(!stack.isEmpty() || p != null) &#123; if(p != null) &#123; stack.push(p); p = p.left; &#125; else &#123; TreeNode node = stack.pop(); result.add(node.val); // Add after all left children p = node.right; &#125; &#125; return result;&#125; POST ORDER TRAVERSE 12345678910111213141516public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); TreeNode p = root; while(!stack.isEmpty() || p != null) &#123; if(p != null) &#123; stack.push(p); result.addFirst(p.val); // Reverse the process of preorder p = p.right; // Reverse the process of preorder &#125; else &#123; TreeNode node = stack.pop(); p = node.left; // Reverse the process of preorder &#125; &#125; return result;&#125; 0ms, 24.98%, July 14th, 2016 https://discuss.leetcode.com/topic/2919/my-accepted-code-with-explaination-does-anyone-have-a-better-idea My Accepted code with explaination. Does anyone have a better idea? 先进行类似于先序遍历，但是先跟后右再左，结果反转。 pre-order traversal is root-left-right, and post order is left-right-root. modify the code for pre-order to make it root-right-left, and then reverse the output so that we can get left-right-root . Create an empty stack, Push root node to the stack. Do following while stack is not empty. 2.1. pop an item from the stack and print it. 2.2. push the left child of popped item to stack. 2.3. push the right child of popped item to stack. reverse the ouput. 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; stack&lt;TreeNode*&gt; nodeStack; vector&lt;int&gt; result; //base case if(root==NULL) return result; nodeStack.push(root); while(!nodeStack.empty()) &#123; TreeNode* node= nodeStack.top(); result.push_back(node-&gt;val); nodeStack.pop(); if(node-&gt;left) nodeStack.push(node-&gt;left); if(node-&gt;right) nodeStack.push(node-&gt;right); &#125; reverse(result.begin(),result.end()); return result; &#125;&#125;; 4ms, 0.62%, July 14th, 2016 https://discuss.leetcode.com/topic/7427/a-very-concise-solution A very concise solution i have saw lots of post in this discussion, but most of them are not concise, just share mine for your reference, writing a concise code is very important 123456789101112131415161718vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; v; if (!root) return v; stack&lt;TreeNode *&gt; s; s.push(root); TreeNode *p = NULL; while(!s.empty()) &#123; p = s.top(); s.pop(); v.insert(v.begin(), p-&gt;val); if (p-&gt;left) s.push(p-&gt;left); if (p-&gt;right) s.push(p-&gt;right); &#125; return v;&#125; https://discuss.leetcode.com/topic/14473/0-ms-clear-c-solutions-iterative-recursive-morris-traversal-3-different-solutions 0 ms Clear C++ solutions — iterative, recursive, Morris traversal (3 different solutions!) Hi, this is a fundamental and yet classic problem. I share my three solutions here: Iterative solution using stack — O(n) time and O(n) space; Recursive solution — O(n) time and O(n) space (considering the spaces of function call stack); Morris traversal — O(n) time and O(1) space!!! Iterative solution using stack: 1234567891011121314151617181920212223vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; stack&lt;TreeNode*&gt; toVisit; TreeNode* curNode = root; TreeNode* lastNode = NULL; while (curNode || !toVisit.empty()) &#123; if (curNode) &#123; toVisit.push(curNode); curNode = curNode -&gt; left; &#125; else &#123; TreeNode* topNode = toVisit.top(); if (topNode -&gt; right &amp;&amp; lastNode != topNode -&gt; right) curNode = topNode -&gt; right; else &#123; nodes.push_back(topNode -&gt; val); lastNode = topNode; toVisit.pop(); &#125; &#125; &#125; return nodes;&#125; Recursive solution: 1234567891011void postorder(TreeNode* root, vector&lt;int&gt;&amp; nodes) &#123; if (!root) return; postorder(root -&gt; left, nodes); postorder(root -&gt; right, nodes); nodes.push_back(root -&gt; val);&#125;vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; postorder(root, nodes); return nodes;&#125; Morris traversal: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void reverseNodes(TreeNode* start, TreeNode* end) &#123; if (start == end) return; TreeNode* x = start; TreeNode* y = start -&gt; right; TreeNode* z; while (x != end) &#123; z = y -&gt; right; y -&gt; right = x; x = y; y = z; &#125;&#125;void reverseAddNodes(TreeNode* start, TreeNode* end, vector&lt;int&gt;&amp; nodes) &#123; reverseNodes(start, end); TreeNode* node = end; while (true) &#123; nodes.push_back(node -&gt; val); if (node == start) break; node = node -&gt; right; &#125; reverseNodes(end, start);&#125;vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; TreeNode* dump = new TreeNode(0); dump -&gt; left = root; TreeNode* curNode = dump; while (curNode) &#123; if (curNode -&gt; left) &#123; TreeNode* predecessor = curNode -&gt; left; while (predecessor -&gt; right &amp;&amp; predecessor -&gt; right != curNode) predecessor = predecessor -&gt; right; if (!(predecessor -&gt; right)) &#123; predecessor -&gt; right = curNode; curNode = curNode -&gt; left; &#125; else &#123; reverseAddNodes(curNode -&gt; left, predecessor, nodes); predecessor -&gt; right = NULL; curNode = curNode -&gt; right; &#125; &#125; else curNode = curNode -&gt; right; &#125; return nodes;&#125; 44ms, 81.02%, July 14th, 2016 https://discuss.leetcode.com/topic/17540/share-my-two-python-iterative-solutions-post-order-and-modified-preorder-then-reverse Share my two Python iterative solutions, post-order and modified preorder then reverse The first is by postorder using a flag to indicate whether the node has been visited or not. 123456789101112131415161718class Solution: # @param &#123;TreeNode&#125; root # @return &#123;integer[]&#125; def postorderTraversal(self, root): traversal, stack = [], [(root, False)] while stack: node, visited = stack.pop() if node: if visited: # add to result if visited traversal.append(node.val) else: # post-order stack.append((node, True)) stack.append((node.right, False)) stack.append((node.left, False)) return traversal The 2nd uses modified preorder (right subtree first). Then reverse the result. 123456789101112131415class Solution: # @param &#123;TreeNode&#125; root # @return &#123;integer[]&#125; def postorderTraversal(self, root): traversal, stack = [], [root] while stack: node = stack.pop() if node: # pre-order, right first traversal.append(node.val) stack.append(node.left) stack.append(node.right) # reverse result return traversal[::-1] https://discuss.leetcode.com/topic/2325/accepted-just-a-reversal-of-a-modified-pre-order-traversal Accepted – Just a reversal of a modified Pre-order traversal This is my accepted code. I found out that pre-order traversal is root-left-right, and post order is left-right-root. I modified the code for pre-order a little to make it root-right-left, and then reverse the output. I think others would have thought of it already, but anyways here’s my code… 123456789101112131415161718class Solution:# @param root, a tree node# @return a list of integersdef postorderTraversal(self, root): traversalInt = list() if root!=None: traversal = list() traversal.append(root) while len(traversal)&gt;0: probe = traversal[0] traversalInt.append(probe.val) traversal.remove(probe) if (probe.left != None): traversal.insert(0,probe.left) if (probe.right != None): traversal.insert(0,probe.right) return traversalInt[::-1] https://discuss.leetcode.com/topic/34258/iterative-method-to-do-three-kinds-of-traversal-just-like-recursive-method-only-changing-one-line-code Iterative method to do three kinds of traversal just like recursive method only changing one line code For three different kinds of traversal, we only need to change the order of tuples in one line as we’ve done this in the recursive solution which is very decent and classical. Just put (0, p[1]) in different position! For post-order traversal: 1234567def postorderTraversal(self, root): res, stack = [], [(1, root)] while stack: p = stack.pop() if not p[1]: continue stack.extend([(0, p[1]), (1, p[1].right), (1, p[1].left)]) if p[0] != 0 else res.append(p[1].val) return res For in-order traversal: 1234567def inorderTraversal(self, root): res, stack = [], [(1, root)] while stack: p = stack.pop() if not p[1]: continue stack.extend([(1, p[1].right), (0, p[1]), (1, p[1].left)]) if p[0] != 0 else res.append(p[1].val) return res For pre-order traversal: 1234567def preorderTraversal(self, root): res, stack = [], [(1, root)] while stack: p = stack.pop() if not p[1]: continue stack.extend([(1, p[1].right), (1, p[1].left), (0, p[1])]) if p[0] != 0 else res.append(p[1].val) return res https://discuss.leetcode.com/topic/44231/preorder-inorder-and-postorder-traversal-iterative-java-solution Preorder, Inorder and Postorder Traversal Iterative Java Solution Postorder traversal : Binary Tree Postorder Traversal 12345678910111213public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null) return list; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.empty())&#123; root = stack.pop(); list.add(0, root.val); if(root.left != null) stack.push(root.left); if(root.right != null) stack.push(root.right); &#125; return list;&#125; Preorder traversal : Binary Tree Preorder Traversal 12345678910111213public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null) return list; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.empty())&#123; root = stack.pop(); list.add(root.val); if(root.right != null) stack.push(root.right); if(root.left != null) stack.push(root.left); &#125; return list;&#125; Inorder traversal : Binary Tree Inorder Traversal 123456789101112131415public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null) return list; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(root != null || !stack.empty())&#123; while(root != null)&#123; stack.push(root); root = root.left; &#125; root = stack.pop(); list.add(root.val); root = root.right; &#125; return list;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>stack</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[144. Binary Tree Preorder Traversal]]></title>
    <url>%2Fp%2Fc601580f%2F</url>
    <content type="text"><![CDATA[43.8% https://leetcode.com/problems/binary-tree-preorder-traversal/#/description Given a binary tree, return the preorder traversal of its nodes’ values. 12345678For example:Given binary tree &#123;1,#,2,3&#125;, 1 \ 2 / 3return [1,2,3]. Note: Recursive solution is trivial, could you do it iteratively? 方法一：递归 O(n)时间 O(n)空间 123456789101112// recursive, but it&apos;s trivial...vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; preTraversal(root, v); return v;&#125;void preTraversal(TreeNode* root, vector&lt;int&gt;&amp; v)&#123; if(!root) return; v.push_back(root-&gt;val); preTraversal(root-&gt;left, v); preTraversal(root-&gt;right, v);&#125; 方法二：迭代方法，使用栈，遍历先根再左后右。存入栈，先右后左。很好理解。 Create an empty stack, Push root node to the stack. Do following while stack is not empty. 2.1. pop an item from the stack and print it.2.2. push the right child of popped item to stack.2.3. push the left child of popped item to stack. 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; stack&lt;TreeNode*&gt; nodeStack; vector&lt;int&gt; result; //base case if(root==NULL) return result; nodeStack.push(root); while(!nodeStack.empty()) &#123; TreeNode* node= nodeStack.top(); result.push_back(node-&gt;val); nodeStack.pop(); if(node-&gt;right) nodeStack.push(node-&gt;right); if(node-&gt;left) nodeStack.push(node-&gt;left); &#125; return result; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; stack; stack.push(root); while(!stack.empty())&#123; TreeNode* node = stack.top(); stack.pop(); res.push_back(node-&gt;val); if(node-&gt;right) stack.push(node-&gt;right); if(node-&gt;left) stack.push(node-&gt;left); &#125; return res; &#125;&#125;; 方法三： 使用栈，按照递归的方法遍历 我的代码实现： Dec 10th, 2017 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; while(stack.size() || cur)&#123; if(cur)&#123; res.push_back(cur-&gt;val); stack.push(cur); cur = cur-&gt;left; &#125;else&#123; TreeNode* tmp = stack.top(); stack.pop(); cur = tmp-&gt;right; &#125; &#125; return res; &#125;&#125;; 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; stack; while(root || stack.size())&#123; if(root)&#123; stack.push(root); res.push_back(root-&gt;val); root = root-&gt;left; &#125;else&#123; TreeNode* node = stack.top(); stack.pop(); root = node-&gt;right; &#125; &#125; return res; &#125;&#125;; 我的代码实现二: 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; while(cur || stack.size())&#123; if(cur)&#123; stack.push(cur); res.push_back(cur-&gt;val); cur = cur-&gt;left; &#125;else&#123; cur = stack.top(); stack.pop(); cur = cur-&gt;right; &#125; &#125; return res; &#125;&#125;; 方法四：morris traversal O(1)空间复杂度 O(n)时间复杂度 123456789101112131415161718192021222324// morris traversal， O(1) spacevector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root, *prev; while(temp)&#123; if(!temp-&gt;left)&#123; v.push_back(temp-&gt;val); temp = temp-&gt;right; &#125;else&#123; prev = temp-&gt;left; while(prev-&gt;right&amp;&amp;(prev-&gt;right != temp)) prev = prev-&gt;right; if(!prev-&gt;right)&#123; v.push_back(temp-&gt;val); prev-&gt;right = temp; temp = temp-&gt;left; &#125;else&#123; prev-&gt;right = NULL; temp = temp-&gt;right; &#125; &#125; &#125;&#125; 我的代码实现: 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; TreeNode* cur = root; while(cur)&#123; if(cur-&gt;left)&#123; TreeNode* pre = cur-&gt;left; while(pre-&gt;right &amp;&amp; pre-&gt;right!=cur) pre = pre-&gt;right; if(pre-&gt;right==cur)&#123; pre-&gt;right = NULL; cur = cur-&gt;right; &#125;else&#123; res.push_back(cur-&gt;val); pre-&gt;right = cur; cur = cur-&gt;left; &#125; &#125;else&#123; res.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125; return res; &#125;&#125;; 迭代方法总结，值得学习 https://discuss.leetcode.com/topic/44387/preorder-inorder-postorder-iterative-solution-by-c Preorder、inorder、postorder iterative solution by c++ preorder: 123456789101112131415vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; std::stack&lt;TreeNode*&gt; temp; while (root || !temp.empty()) &#123; while (root) &#123; temp.push(root); res.push_back(root-&gt;val); root = root-&gt;left; &#125; root = temp.top(); temp.pop(); root = root-&gt;right; &#125; return res;&#125; inorder: 123456789101112131415vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; std::stack&lt;TreeNode*&gt; temp; while (root || !temp.empty()) &#123; while (root) &#123; temp.push(root); root = root-&gt;left; &#125; root = temp.top(); temp.pop(); res.push_back(root-&gt;val); root = root-&gt;right; &#125; return res;&#125; postorder: 123456789101112131415vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; std::stack&lt;TreeNode*&gt; temp; while (root || !temp.empty()) &#123; while (root) &#123; temp.push(root); res.insert(res.begin(),root-&gt;val); root = root-&gt;right; &#125; root = temp.top(); temp.pop(); root = root-&gt;left; &#125; return res;&#125; https://discuss.leetcode.com/topic/2917/accepted-code-explaination-with-algo Accepted code. Explaination with Algo. Create an empty stack, Push root node to the stack. Do following while stack is not empty. 2.1. pop an item from the stack and print it.2.2. push the right child of popped item to stack.2.3. push the left child of popped item to stack. 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; stack&lt;TreeNode*&gt; nodeStack; vector&lt;int&gt; result; //base case if(root==NULL) return result; nodeStack.push(root); while(!nodeStack.empty()) &#123; TreeNode* node= nodeStack.top(); result.push_back(node-&gt;val); nodeStack.pop(); if(node-&gt;right) nodeStack.push(node-&gt;right); if(node-&gt;left) nodeStack.push(node-&gt;left); &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/12515/3-different-solutions 3 Different Solutions Recursive method with List as returning value: 12345678public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; pre = new LinkedList&lt;Integer&gt;(); if(root==null) return pre; pre.add(root.val); pre.addAll(preorderTraversal(root.left)); pre.addAll(preorderTraversal(root.right)); return pre;&#125; Recursive method with Helper method to have a List as paramater, so we can modify the parameter and don’t have to instantiate a new List at each recursive call: 1234567891011public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; pre = new LinkedList&lt;Integer&gt;(); preHelper(root,pre); return pre;&#125;public void preHelper(TreeNode root, List&lt;Integer&gt; pre) &#123; if(root==null) return; pre.add(root.val); preHelper(root.left,pre); preHelper(root.right,pre);&#125; Iterative method with Stack: 12345678910111213public List&lt;Integer&gt; preorderIt(TreeNode root) &#123; List&lt;Integer&gt; pre = new LinkedList&lt;Integer&gt;(); if(root==null) return pre; Stack&lt;TreeNode&gt; tovisit = new Stack&lt;TreeNode&gt;(); tovisit.push(root); while(!tovisit.empty()) &#123; TreeNode visiting = tovisit.pop(); pre.add(visiting.val); if(visiting.right!=null) tovisit.push(visiting.right); if(visiting.left!=null) tovisit.push(visiting.left); &#125; return pre;&#125; https://discuss.leetcode.com/topic/5748/easy-c-solution-using-stack Easy C++ solution using Stack 1234567891011121314151617181920212223class Solution &#123;public:vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; if (root==NULL) &#123; return vector&lt;int&gt;(); &#125; vector&lt;int&gt; result; stack&lt;TreeNode *&gt; treeStack; treeStack.push(root); while (!treeStack.empty()) &#123; TreeNode *temp = treeStack.top(); result.push_back(temp-&gt;val); treeStack.pop(); if (temp-&gt;right!=NULL) &#123; treeStack.push(temp-&gt;right); &#125; if (temp-&gt;left!=NULL) &#123; treeStack.push(temp-&gt;left); &#125; &#125; return result;&#125;&#125;; https://discuss.leetcode.com/topic/21936/4-solutions-in-c 4 solutions in c++ 123456789101112// recursive, but it&apos;s trivial...vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; preTraversal(root, v); return v;&#125;void preTraversal(TreeNode* root, vector&lt;int&gt;&amp; v)&#123; if(!root) return; v.push_back(root-&gt;val); preTraversal(root-&gt;left, v); preTraversal(root-&gt;right, v);&#125; 123456789101112131415// iterate, use stack to imitate recursivevector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root; stack&lt;TreeNode*&gt; s; s.push(root); while(!s.empty())&#123; temp = s.top(); s.pop(); v.push_back(temp-&gt;val); if(temp-&gt;right) s.push(temp-&gt;right); if(temp-&gt;left) s.push(temp-&gt;left); &#125;&#125; 12345678910111213141516vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root; stack&lt;TreeNode*&gt; s; while(true)&#123; while(temp)&#123; v.push_back(temp-&gt;val); if(temp-&gt;right) s.push(temp-&gt;right); temp = temp-&gt;left; &#125; if(s.empty()) break; temp = s.top(); s.pop(); &#125;;&#125; 123456789101112131415161718192021222324// morris traversal， O(1) spacevector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root, *prev; while(temp)&#123; if(!temp-&gt;left)&#123; v.push_back(temp-&gt;val); temp = temp-&gt;right; &#125;else&#123; prev = temp-&gt;left; while(prev-&gt;right&amp;&amp;(prev-&gt;right != temp)) prev = prev-&gt;right; if(!prev-&gt;right)&#123; v.push_back(temp-&gt;val); prev-&gt;right = temp; temp = temp-&gt;left; &#125;else&#123; prev-&gt;right = NULL; temp = temp-&gt;right; &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/7976/very-simple-iterative-python-solution Very simple iterative Python solution Classical usage of stack’s LIFO feature, very easy to grasp: 12345678910def preorderTraversal(self, root): ret = [] stack = [root] while stack: node = stack.pop() if node: ret.append(node.val) stack.append(node.right) stack.append(node.left) return ret https://discuss.leetcode.com/topic/6493/accepted-iterative-solution-in-java-using-stack Accepted iterative solution in Java using stack. Note that in this solution only right children are stored to stack. 123456789101112131415public List&lt;Integer&gt; preorderTraversal(TreeNode node) &#123; List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; rights = new Stack&lt;TreeNode&gt;(); while(node != null) &#123; list.add(node.val); if (node.right != null) &#123; rights.push(node.right); &#125; node = node.left; if (node == null &amp;&amp; !rights.isEmpty()) &#123; node = rights.pop(); &#125; &#125; return list;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>stack</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[143. Reorder List]]></title>
    <url>%2Fp%2Ffa09b9a8%2F</url>
    <content type="text"><![CDATA[24.9% https://leetcode.com/problems/reorder-list/#/description Given a singly linked list L: L0→L1→…→Ln-1→Ln,reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You must do this in-place without altering the nodes’ values. 12For example,Given &#123;1,2,3,4&#125;, reorder it to &#123;1,4,2,3&#125;. 方法一： 按照题意，先找一半处，后一半反转，然后并入前一段。 我的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void reorderList(ListNode* head) &#123; if(!head || !head-&gt;next) return; ListNode* fast = head, * slow = head; while(fast-&gt;next!=NULL &amp;&amp; fast-&gt;next-&gt;next!=NULL)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; fast = slow-&gt;next; ListNode* pre = NULL; while(fast)&#123; ListNode* nex = fast-&gt;next; fast-&gt;next = pre; pre = fast; fast = nex; &#125; fast = pre; slow-&gt;next = NULL; slow = head; while(fast!=NULL)&#123; ListNode* nex = fast-&gt;next; fast-&gt;next = slow-&gt;next; slow-&gt;next = fast; slow = slow-&gt;next-&gt;next; fast = nex; &#125; return; &#125;&#125;; 49ms, September 22, 2016 https://discuss.leetcode.com/topic/7425/a-concise-o-n-time-o-1-in-place-solution A concise O(n) time, O(1) in place solution 1234567891011121314151617181920212223242526272829303132333435363738// O(N) time, O(1) space in totalvoid reorderList(ListNode *head) &#123; if (!head || !head-&gt;next) return; // find the middle node: O(n) ListNode *p1 = head, *p2 = head-&gt;next; while (p2 &amp;&amp; p2-&gt;next) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next-&gt;next; &#125; // cut from the middle and reverse the second half: O(n) ListNode *head2 = p1-&gt;next; p1-&gt;next = NULL; p2 = head2-&gt;next; head2-&gt;next = NULL; while (p2) &#123; p1 = p2-&gt;next; p2-&gt;next = head2; head2 = p2; p2 = p1; &#125; // merge two lists: O(n) for (p1 = head, p2 = head2; p1; ) &#123; auto t = p1-&gt;next; p1 = p1-&gt;next = p2; p2 = t; &#125; //for (p1 = head, p2 = head2; p2; ) &#123; // auto t = p1-&gt;next; // p1-&gt;next = p2; // p2 = p2-&gt;next; // p1 = p1-&gt;next-&gt;next = t; //&#125;&#125; https://discuss.leetcode.com/topic/4061/my-o-n-c-method-accepted My O(n) C++ Method, accepted Firstly, I split the list from the middle into two lists. One from head to middle, and the other from middle to the end. Then we reverse the second list. Finally we merge these two lists. O(n) time complexity and O(1) space complexity. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void reorderList(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL || head-&gt;next-&gt;next==NULL) return; //find the middle of the list, and split into two lists. ListNode *p=head,*q=head; while(p &amp;&amp; q &amp;&amp; q-&gt;next &amp;&amp; q-&gt;next-&gt;next)&#123; p=p-&gt;next; q=q-&gt;next-&gt;next; &#125; ListNode *mid = p-&gt;next; p-&gt;next=NULL; p=head; //reverse from the middle to the end ListNode *q1=mid, *q2,*q3; if(mid-&gt;next)&#123; q1=mid; q2=mid-&gt;next; while(q2)&#123; q3=q2-&gt;next; q2-&gt;next=q1; q1=q2; q2=q3; &#125; mid-&gt;next=NULL; &#125; q=q1; //merge these two list ListNode *s=p; p=p-&gt;next; while(p &amp;&amp; q)&#123; s-&gt;next=q; s=s-&gt;next; q=q-&gt;next; s-&gt;next=p; s=s-&gt;next; p=p-&gt;next; &#125; if(p)&#123; s-&gt;next=p; &#125; if(q)&#123; s-&gt;next=q; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/10894/share-a-consise-recursive-solution-in-c Share a consise recursive solution in C++ The recursive idea have been posted by yucheng.wang. Given a example, 1-&gt;2-&gt;3-&gt;4-&gt;5, the solution will reorder node(3), then reorder 2 and 4 to have (2-&gt;4-&gt;3), then 1 and 5 get have 1-&gt;5-&gt;2-&gt;4-&gt;3. Each call of reorderList(ListNode* head, int len) will return the last element after this reorderList() call. 123456789101112131415161718192021222324252627int getLength(ListNode *head)&#123;int len = 0;while( head != NULL )&#123;++len; head = head-&gt;next;&#125;return len;&#125;ListNode * reorderList(ListNode *head, int len)&#123; if(len == 0) return NULL; if( len == 1 ) return head; if( len == 2 ) return head-&gt;next; ListNode * tail = reorderList(head-&gt;next, len-2); ListNode * tmp = tail-&gt;next; tail-&gt;next = tail-&gt;next-&gt;next; tmp-&gt;next = head-&gt;next; head-&gt;next = tmp; return tail;&#125;void reorderList(ListNode *head) &#123; //recursive ListNode * tail = NULL; tail = reorderList(head, getLength(head));&#125; https://discuss.leetcode.com/topic/3345/a-python-solution-o-n-time-o-1-space A python solution O(n) time, O(1) space 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# Splits in place a list in two halves, the first half is &gt;= in size than the second.# @return A tuple containing the heads of the two halvesdef _splitList(head): fast = head slow = head while fast and fast.next: slow = slow.next fast = fast.next fast = fast.next middle = slow.next slow.next = None return head, middle# Reverses in place a list.# @return Returns the head of the new reversed listdef _reverseList(head): last = None currentNode = head while currentNode: nextNode = currentNode.next currentNode.next = last last = currentNode currentNode = nextNode return last# Merges in place two lists# @return The newly merged list.def _mergeLists(a, b): tail = a head = a a = a.next while b: tail.next = b tail = tail.next b = b.next if a: a, b = b, a return headclass Solution: # @param head, a ListNode # @return nothing def reorderList(self, head): if not head or not head.next: return a, b = _splitList(head) b = _reverseList(b) head = _mergeLists(a, b) https://discuss.leetcode.com/topic/13869/java-solution-with-3-steps Java solution with 3 steps This question is a combination of Reverse a linked list I &amp; II. It should be pretty straight forward to do it in 3 steps :) 1234567891011121314151617181920212223242526272829303132public void reorderList(ListNode head) &#123; if(head==null||head.next==null) return; //Find the middle of the list ListNode p1=head; ListNode p2=head; while(p2.next!=null&amp;&amp;p2.next.next!=null)&#123; p1=p1.next; p2=p2.next.next; &#125; //Reverse the half after middle 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 to 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4 ListNode preMiddle=p1; ListNode preCurrent=p1.next; while(preCurrent.next!=null)&#123; ListNode current=preCurrent.next; preCurrent.next=current.next; current.next=preMiddle.next; preMiddle.next=current; &#125; //Start reorder one by one 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4 to 1-&gt;6-&gt;2-&gt;5-&gt;3-&gt;4 p1=head; p2=preMiddle.next; while(p1!=preMiddle)&#123; preMiddle.next=p2.next; p2.next=p1.next; p1.next=p2; p1=p2.next; p2=preMiddle.next; &#125; &#125; https://discuss.leetcode.com/topic/18092/java-solution-with-3-steps Java solution with 3 steps 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; public void reorderList(ListNode head) &#123; if (head == null || head.next == null) return; // step 1. cut the list to two halves // prev will be the tail of 1st half // slow will be the head of 2nd half ListNode prev = null, slow = head, fast = head, l1 = head; while (fast != null &amp;&amp; fast.next != null) &#123; prev = slow; slow = slow.next; fast = fast.next.next; &#125; prev.next = null; // step 2. reverse the 2nd half ListNode l2 = reverse(slow); // step 3. merge the two halves merge(l1, l2); &#125; ListNode reverse(ListNode head) &#123; ListNode prev = null, curr = head, next = null; while (curr != null) &#123; next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; return prev; &#125; void merge(ListNode l1, ListNode l2) &#123; while (l1 != null) &#123; ListNode n1 = l1.next, n2 = l2.next; l1.next = l2; if (n1 == null) break; l2.next = n1; l1 = n1; l2 = n2; &#125; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[142. Linked List Cycle II]]></title>
    <url>%2Fp%2Fc5856708%2F</url>
    <content type="text"><![CDATA[31.0% https://leetcode.com/problems/linked-list-cycle-ii/?tab=Description Given a linked list, return the node where the cycle begins. If there is no cycle, return null. Note: Do not modify the linked list. Follow up: Can you solve it without using extra space? 方法一： 我的代码实现： 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(!head) return NULL; ListNode* slow = head, *fast = head; // 注意!fast表示fast为NULL的情况下为true，fast表示fast不为NULL // 区分!fast,fast,fast!=NULL这几种情况 while(fast &amp;&amp; fast-&gt;next)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(slow==fast)&#123; fast = head; while(fast!=slow)&#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return fast; &#125; &#125; return NULL; &#125;&#125;; 类似版本： 一个重点是，题目中要求循环开始的地方，所以当找到相遇的地方时，还要通过for循环找到最开始相遇的地方。 1234567891011121314151617181920212223class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head==NULL) return head; ListNode * slow, * fast; slow = head; fast = head; while(fast!=NULL &amp;&amp; fast-&gt;next!=NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow==fast)&#123; ListNode* slow2 = head; while(slow2!=slow)&#123; slow = slow-&gt;next; slow2 = slow2-&gt;next; &#125; return slow2; &#125; &#125; return NULL; &#125;&#125;; https://discuss.leetcode.com/topic/5284/concise-o-n-solution-by-using-c-with-detailed-alogrithm-description Concise O(n) solution by using C++ with Detailed Alogrithm Description Alogrithm Description:Step 1: Determine whether there is a cycle 1.1. Using a slow pointer that move forward 1 step each time 1.2. Using a fast pointer that move forward 2 steps each time 1.3. If the slow pointer and fast pointer both point to the same location after several moving steps, there is a cycle; 1.4. Otherwise, if (fast-&gt;next == NULL || fast-&gt;next-&gt;next == NULL), there has no cycle. Step 2: If there is a cycle, return the entry location of the cycle 2.1. L1 is defined as the distance between the head point and entry point 2.2. L2 is defined as the distance between the entry point and the meeting point 2.3. C is defined as the length of the cycle 2.4. n is defined as the travel times of the fast pointer around the cycle When the first encounter of the slow pointer and the fast pointer According to the definition of L1, L2 and C, we can obtain: the total distance of the slow pointer traveled when encounter is L1 + L2 the total distance of the fast pointer traveled when encounter is L1 + L2 + n * C Because the total distance the fast pointer traveled is twice as the slow pointer, Thus: 2 (L1+L2) = L1 + L2 + n C =&gt; L1 + L2 = n C =&gt; L1 = (n - 1) C + (C - L2) 快指针不会超过慢指针好几圈，因为如果当前节点没有相遇，则下一个节点一定会相遇。 It can be concluded that the distance between the head location and entry location is equal to the distance between the meeting location and the entry location along the direction of forward movement. So, when the slow pointer and the fast pointer encounter in the cycle, we can define a pointer “entry” that point to the head, this “entry” pointer moves one step each time so as the slow pointer. When this “entry” pointer and the slow pointer both point to the same location, this location is the node where the cycle begins. Here is the code: 123456789101112131415161718192021ListNode *detectCycle(ListNode *head) &#123; if (head == NULL || head-&gt;next == NULL) return NULL; ListNode *slow = head; ListNode *fast = head; ListNode *entry = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (slow == fast) &#123; // there is a cycle while(slow != entry) &#123; // found the entry location slow = slow-&gt;next; entry = entry-&gt;next; &#125; return entry; &#125; &#125; return NULL; // there has no cycle&#125; cpp 9ms, September 22, 2016 https://discuss.leetcode.com/topic/2975/o-n-solution-by-using-two-pointers-without-change-anything O(n) solution by using two pointers without change anything my solution is like this: using two pointers, one of them one step at a time. another pointer each take two steps. Suppose the first meet at step k,the length of the Cycle is r. so..2k-k=nr,k=nr Now, the distance between the start node of list and the start node of cycle is s. the distance between the start of list and the first meeting node is k(the pointer which wake one step at a time waked k steps).the distance between the start node of cycle and the first meeting node is m, so…s=k-m, s=nr-m=(n-1)r+(r-m),here we takes n = 1..so, using one pointer start from the start node of list, another pointer start from the first meeting node, all of them wake one step at a time, the first time they meeting each other is the start of the cycle. 12345678910111213141516171819202122232425262728class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head==NULL || head-&gt;next == NULL) return NULL; ListNode* firstp = head; ListNode* secondp = head; bool isCycle = false; while(firstp!=NULL &amp;&amp; secondp!=NULL)&#123; firstp = firstp-&gt;next; if(secondp-&gt;next==NULL) return NULL; secondp = secondp-&gt;next-&gt;next; if(firstp==secondp)&#123; isCycle = true; break; &#125; &#125; if(!isCycle) return NULL; firstp = head; while(firstp != secondp)&#123; firstp = firstp-&gt;next; secondp = secondp-&gt;next; &#125; return firstp; &#125;&#125;; https://discuss.leetcode.com/topic/33191/c-implementation-with-much-more-clear-and-strict-explanation-any-one-can-give-more-clear C++ implementation with much more clear and strict explanation ! any one can give more clear ? Just use the dummy head pointer and why first find the meeting point and then set the result-pointer at the dummy and move forward to find the result position.There are the reasons : 123456789101112131415161718192021222324252627282930set the [#cycle length = C ] [#length-from-head-to-cycle-start-point = L] [#cycle-start-point-meeting-point=S] [#meeting-point-clock-direction-to-cycle-start-point=Y] [#step needed to meeting=T]Then when they meet, we have 2 * T = T + N1 * C N1=0,1,2...so we get T = N1 * CAlso we have 2 * T = L + N2 * C + S N2=0,1,2...we can get N3 * C = L + S with C = S + Y N3 = 2 * N1 - N2so we have (N3 - 1) * C + S + Y = L + Sthen we have (N3 - 1) * C + Y = Ljust means that we can do the things that have been explained by others. We can move a node from head and node from the meeting point, then when they meet, it is the start point of the cycle. Here is the code : 123456789101112131415161718192021class Solution &#123; public: ListNode *detectCycle(ListNode *head) &#123; ListNode* dummy=new ListNode(-1); dummy-&gt;next=head; ListNode *slow=dummy, *fast=dummy; bool flag=false; while(fast &amp;&amp; fast-&gt;next)&#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(fast==slow) &#123; flag=true; break; &#125; &#125; if(!flag) return NULL; ListNode* result=dummy; while(result != slow)&#123; result=result-&gt;next; slow=slow-&gt;next;**strong text** &#125; return result; &#125; &#125;; my code: python 85ms, 51.12%, September 22, 2016 https://discuss.leetcode.com/topic/17521/share-my-python-solution-with-detailed-explanation Share my python solution with detailed explanation My solution consists of two parts. The first one checks if a cycle exists or not. The second one determines the entry of the cycle if it exists.The first part is inspired by this post. about Linked List Cycle IThe logic behind the 2nd part is like this: Consider the following linked list, where E is the cylce entry and X, the crossing point of fast and slow. 12345678H: distance from head to cycle entry ED: distance from E to XL: cycle length _____ / \head_____H______E \ \ / X_____/ If fast and slow both start at head, when fast catches slow, slow has traveled H+D and fast 2(H+D).Assume fast has traveled n loops in the cycle, we have:2H + 2D = H + D + L –&gt; H + D = nL –&gt; H = nL - DThus if two pointers start from head and X, respectively, one first reaches E, the other also reaches E.In my solution, since fast starts at head.next, we need to move slow one step forward in the beginning of part 2 123456789101112131415161718192021class Solution: # @param head, a ListNode # @return a list node def detectCycle(self, head): try: fast = head.next slow = head while fast is not slow: fast = fast.next.next slow = slow.next except: # if there is an exception, we reach the end and there is no cycle return None # since fast starts at head.next, we need to move slow one step forward slow = slow.next while head is not slow: head = head.next slow = slow.next return head https://discuss.leetcode.com/topic/5438/sharing-my-python-solution Sharing my Python solution Same idea as many other posts, just the python version: 12345678910111213def detectCycle(self, head): slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None while head != slow: slow = slow.next head = head.next return head java 1ms, September 22, 2016 https://discuss.leetcode.com/topic/19367/java-o-1-space-solution-with-detailed-explanation Java O(1) space solution with detailed explanation. Define two pointers slow and fast. Both start at head node, fast is twice as fast as slow. If it reaches the end it means there is no cycle, otherwise eventually it will eventually catch up to slow pointer somewhere in the cycle. Let the distance from the first node to the the node where cycle begins be A, and let say the slow pointer travels travels A+B. The fast pointer must travel 2A+2B to catch up. The cycle size is N. Full cycle is also how much more fast pointer has traveled than slow pointer at meeting point. 12A+B+N = 2A+2BN=A+B From our calculation slow pointer traveled exactly full cycle when it meets fast pointer, and since originally it travled A before starting on a cycle, it must travel A to reach the point where cycle begins! We can start another slow pointer at head node, and move both pointers until they meet at the beginning of a cycle. 123456789101112131415161718192021public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while (fast!=null &amp;&amp; fast.next!=null)&#123; fast = fast.next.next; slow = slow.next; if (fast == slow)&#123; ListNode slow2 = head; while (slow2 != slow)&#123; slow = slow.next; slow2 = slow2.next; &#125; return slow; &#125; &#125; return null; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>two pointers</tag>
        <tag>medium</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[141. Linked List Cycle]]></title>
    <url>%2Fp%2F20f14e92%2F</url>
    <content type="text"><![CDATA[35.6% https://leetcode.com/problems/linked-list-cycle/description/ Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 方法一： 一个快指针，一个慢指针 https://discuss.leetcode.com/topic/4218/my-faster-and-slower-runner-solution My faster and slower runner solution 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ /** use faster and lower runner solution. (2 pointers) the faster one move 2 steps, and slower one move only one step. if there&apos;s a circle, the faster one will finally &quot;catch&quot; the slower one. (the distance between these 2 pointers will decrease one every time.) if there&apos;s no circle, the faster runner will reach the end of linked list. (NULL) */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head == NULL || head -&gt; next == NULL) return false; ListNode *fast = head; ListNode *slow = head; while(fast -&gt; next &amp;&amp; fast -&gt; next -&gt; next)&#123; fast = fast -&gt; next -&gt; next; slow = slow -&gt; next; if(fast == slow) return true; &#125; return false; &#125;&#125;; 我的代码实现一： 1234567891011121314class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head==NULL) return false; ListNode* slow, *fast; slow = head; fast = head-&gt;next; while(slow!=fast&amp;&amp;fast!=NULL &amp;&amp; fast-&gt;next!=NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow==fast; &#125;&#125;; 我的代码实现二： 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(!head || !head-&gt;next) return false; ListNode* slow = head, *fast = head-&gt;next; while(fast!=NULL &amp;&amp; fast-&gt;next!=NULL)&#123; if(slow==fast) return true; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/16098/except-ionally-fast-python Except-ionally fast Python Took 88 ms and the “Accepted Solutions Runtime Distribution” doesn’t show any faster Python submissions. The “trick” is to not check all the time whether we have reached the end but to handle it via an exception. “Easier to ask for forgiveness than permission.” The algorithm is of course Tortoise and hare. 12345678910def hasCycle(self, head): try: slow = head fast = head.next while slow is not fast: slow = slow.next fast = fast.next.next return True except: return False java https://discuss.leetcode.com/topic/12516/o-1-space-solution O(1) Space Solution 1234567891011public boolean hasCycle(ListNode head) &#123; if(head==null) return false; ListNode walker = head; ListNode runner = head; while(runner.next!=null &amp;&amp; runner.next.next!=null) &#123; walker = walker.next; runner = runner.next.next; if(walker==runner) return true; &#125; return false;&#125; Use two pointers, walker and runner. walker moves step by step. runner moves two steps at time. if the Linked List has a cycle walker and runner will meet at some point. 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head == null) return false; ListNode slow, fast; slow = head; fast = head; while(fast.next!=null &amp;&amp; fast.next.next != null)&#123; slow = slow.next; fast = fast.next.next; if(slow==fast) return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[140. Word Break II]]></title>
    <url>%2Fp%2F2ce5facb%2F</url>
    <content type="text"><![CDATA[23.3% https://leetcode.com/problems/word-break-ii/ Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words. Return all such possible sentences. 12345For example, givens = &quot;catsanddog&quot;,dict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;].A solution is [&quot;cats and dog&quot;, &quot;cat sand dog&quot;]. UPDATE (2017/1/4):The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. 还需要思考 方法一: https://discuss.leetcode.com/topic/12997/11ms-c-solution-concise 11ms C++ solution (concise) 1234567891011121314151617181920212223242526272829class Solution &#123; unordered_map&lt;string, vector&lt;string&gt;&gt; m; vector&lt;string&gt; combine(string word, vector&lt;string&gt; prev)&#123; for(int i=0;i&lt;prev.size();++i)&#123; prev[i]+=&quot; &quot;+word; &#125; return prev; &#125;public: vector&lt;string&gt; wordBreak(string s, unordered_set&lt;string&gt;&amp; dict) &#123; if(m.count(s)) return m[s]; //take from memory vector&lt;string&gt; result; if(dict.count(s))&#123; //a whole string is a word result.push_back(s); &#125; for(int i=1;i&lt;s.size();++i)&#123; string word=s.substr(i); if(dict.count(word))&#123; string rem=s.substr(0,i); vector&lt;string&gt; prev=combine(word,wordBreak(rem,dict)); result.insert(result.end(),prev.begin(), prev.end()); &#125; &#125; m[s]=result; //memorize return result; &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/35762/9-lines-python-10-lines-c 9 lines Python, 10 lines C++ 123456789101112vector&lt;string&gt; wordBreak(string s, unordered_set&lt;string&gt;&amp; wordDict) &#123; unordered_map&lt;int, vector&lt;string&gt;&gt; memo &#123;&#123;s.size(), &#123;&quot;&quot;&#125;&#125;&#125;; function&lt;vector&lt;string&gt;(int)&gt; sentences = [&amp;](int i) &#123; if (!memo.count(i)) for (int j=i+1; j&lt;=s.size(); j++) if (wordDict.count(s.substr(i, j-i))) for (string tail : sentences(j)) memo[i].push_back(s.substr(i, j-i) + (tail==&quot;&quot; ? &quot;&quot; : &apos; &apos; + tail)); return memo[i]; &#125;; return sentences(0);&#125; 方法三： 我的代码实现： 超时了 “aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa”[“a”,”aa”,”aaa”,”aaaa”,”aaaaa”,”aaaaaa”,”aaaaaaa”,”aaaaaaaa”,”aaaaaaaaa”,”aaaaaaaaaa”] 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; int n = s.size(); unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); unordered_map&lt;int, vector&lt;vector&lt;string&gt;&gt;&gt; memo; vector&lt;vector&lt;string&gt;&gt; tmp&#123;vector&lt;vector&lt;string&gt;&gt;(1, vector&lt;string&gt;(1, ""))&#125;; memo[0] = tmp; for(int i=1; i&lt;=n; i++)&#123; // 严格区分 ++ -- vector&lt;vector&lt;string&gt;&gt; v; bool flag = false; for(int j=i-1; j&gt;=0; j--)&#123; string word = s.substr(j, i-j); if(wordSet.find(word)!=wordSet.end() &amp;&amp; memo.find(j)!=memo.end())&#123; flag = true; for(auto cur:memo[j])&#123; cur.push_back(word); v.push_back(cur); &#125; &#125; &#125; if(flag) memo[i] = v; &#125; vector&lt;string&gt; res; for(int i=0; i&lt;memo[n].size(); i++)&#123; string t = memo[n][i][1]; for(int j=2; j&lt;memo[n][i].size(); j++) t += " " + memo[n][i][j]; res.push_back(t); &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/35762/9-lines-python-10-lines-c 9 lines Python, 10 lines C++ 12345678910def wordBreak(self, s, wordDict): memo = &#123;len(s): [&apos;&apos;]&#125; def sentences(i): if i not in memo: memo[i] = [s[i:j] + (tail and &apos; &apos; + tail) for j in range(i+1, len(s)+1) if s[i:j] in wordDict for tail in sentences(j)] return memo[i] return sentences(0) java https://discuss.leetcode.com/topic/27855/my-concise-java-solution-based-on-memorized-dfs My concise JAVA solution based on memorized DFS 18ms, 34.39%, Jan.13 2017 Explanation Using DFS directly will lead to TLE, so I just used HashMap to save the previous results to prune duplicated branches, as the following: 1234567891011121314151617181920212223242526public class Solution &#123; public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123; return DFS(s, wordDict, new HashMap&lt;String, LinkedList&lt;String&gt;&gt;()); &#125; // DFS function returns an array including all substrings derived from s. List&lt;String&gt; DFS(String s, List&lt;String&gt; wordDict, HashMap&lt;String, LinkedList&lt;String&gt;&gt;map) &#123; if (map.containsKey(s)) return map.get(s); LinkedList&lt;String&gt;res = new LinkedList&lt;String&gt;(); if (s.length() == 0) &#123; res.add(&quot;&quot;); return res; &#125; for (String word : wordDict) &#123; if (s.startsWith(word)) &#123; List&lt;String&gt;sublist = DFS(s.substring(word.length()), wordDict, map); for (String sub : sublist) res.add(word + (sub.isEmpty() ? &quot;&quot; : &quot; &quot;) + sub); &#125; &#125; map.put(s, res); return res; &#125;&#125; Brilliant idea, also can be simplified like this. 1234567891011121314151617181920212223public class Solution &#123;HashMap&lt;String, LinkedList&lt;String&gt;&gt; map = new HashMap&lt;String, LinkedList&lt;String&gt;&gt;();public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; if (map.containsKey(s)) return map.get(s); LinkedList&lt;String&gt; res = new LinkedList&lt;String&gt;(); if (s.length() == 0) &#123; res.add(&quot;&quot;); return res; &#125; for (String word : wordDict) &#123; if (s.startsWith(word)) &#123; List&lt;String&gt; sublist = wordBreak(s.substring(word.length()), wordDict); for (String sub : sublist) res.add(word + (sub.isEmpty() ? &quot;&quot; : &quot; &quot;) + sub); &#125; &#125; map.put(s, res); return res;&#125;&#125; https://discuss.leetcode.com/topic/9837/my-concise-answer My concise answer. 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; dict) &#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;(); for(int j = s.length() - 1; j &gt;= 0; j--)&#123; if(dict.contains(s.substring(j))) break; else&#123; if(j == 0) return result; &#125; &#125; for(int i = 0; i &lt; s.length()-1; i++) &#123; if(dict.contains(s.substring(0,i+1))) &#123; List&lt;String&gt; strs = wordBreak(s.substring(i+1,s.length()),dict); if(strs.size() != 0) for(Iterator&lt;String&gt; it = strs.iterator();it.hasNext();) &#123; result.add(s.substring(0,i+1)+&quot; &quot;+it.next()); &#125; &#125; &#125; if(dict.contains(s)) result.add(s); return result; &#125;&#125; https://discuss.leetcode.com/topic/8178/slightly-modified-dp-java-solution Slightly modified DP Java solution Hi guys! There’s a lot of concern in other posts about “aaaa…aab” test case that causes TLE when we run through our string not in reverse but from start to end. I’ve thought a bit on how to add a tiny modification and make just the whole thing more effective, not only pass the TLE case. The approach is the same as before: we loop through all possible prefixes checking if it in the dictionary and caching the results. But just before jumping into recursion we could also check that the right reminder has a prefix from the dictionary, because if it hasn’t then there’s no sense in splitting the reminder into sub-strings. It’s just a linear check, which I think also could be optimized with some caching but even without optimization the solution is accepted. And also the code looks quite understandable. 123456789101112131415161718192021222324252627public class Solution &#123; private final Map&lt;String, List&lt;String&gt;&gt; cache = new HashMap&lt;&gt;(); private boolean containsSuffix(Set&lt;String&gt; dict, String str) &#123; for (int i = 0; i &lt; str.length(); i++) &#123; if (dict.contains(str.substring(i))) return true; &#125; return false; &#125; public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; dict) &#123; if (cache.containsKey(s)) return cache.get(s); List&lt;String&gt; result = new LinkedList&lt;&gt;(); if (dict.contains(s)) result.add(s); for (int i = 1; i &lt; s.length(); i++) &#123; String left = s.substring(0,i), right = s.substring(i); if (dict.contains(left) &amp;&amp; containsSuffix(dict, right)) &#123; for (String ss : wordBreak(right, dict)) &#123; result.add(left + &quot; &quot; + ss); &#125; &#125; &#125; cache.put(s, result); return result; &#125;&#125; https://discuss.leetcode.com/topic/39833/java-6ms-simple-solution-beating-88 Java 6ms simple solution beating 88% 1234567891011121314151617181920212223242526272829public class Solution &#123; HashMap&lt;Integer, List&lt;String&gt;&gt; dp = new HashMap&lt;&gt;(); public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; int maxLength = -1; for(String ss : wordDict) maxLength = Math.max(maxLength, ss.length()); return addSpaces(s, wordDict, 0, maxLength); &#125; private List&lt;String&gt; addSpaces(String s, Set&lt;String&gt; wordDict, int start, int max)&#123; List&lt;String&gt; words = new ArrayList&lt;&gt;(); if(start == s.length()) &#123; words.add(&quot;&quot;); return words; &#125; for(int i = start + 1; i &lt;= max + start &amp;&amp; i &lt;= s.length(); i++)&#123; String temp = s.substring(start, i); if(wordDict.contains(temp))&#123; List&lt;String&gt; ll; if(dp.containsKey(i)) ll = dp.get(i); else ll = addSpaces(s, wordDict, i, max); for(String ss : ll) words.add(temp + (ss.equals(&quot;&quot;) ? &quot;&quot; : &quot; &quot;) + ss); &#125; &#125; dp.put(start, words); return words; &#125;&#125; https://discuss.leetcode.com/topic/3495/my-dp-solution-in-java My DP solution in JAVA Basically my idea is the following: Scan the the string from the tail Build possible solution for the current index based on DP results Return the solution when index==0 123456789101112131415161718192021222324public class Solution &#123; public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; dict) &#123; Map&lt;Integer, List&lt;String&gt;&gt; validMap = new HashMap&lt;Integer, List&lt;String&gt;&gt;(); // initialize the valid values List&lt;String&gt; l = new ArrayList&lt;String&gt;(); l.add(&quot;&quot;); validMap.put(s.length(), l); // generate solutions from the end for(int i = s.length() - 1; i &gt;= 0; i--) &#123; List&lt;String&gt; values = new ArrayList&lt;String&gt;(); for(int j = i + 1; j &lt;= s.length(); j++) &#123; if (dict.contains(s.substring(i, j))) &#123; for(String word : validMap.get(j)) &#123; values.add(s.substring(i, j) + (word.isEmpty() ? &quot;&quot; : &quot; &quot;) + word); &#125; &#125; &#125; validMap.put(i, values); &#125; return validMap.get(0); &#125;&#125; https://discuss.leetcode.com/topic/34260/java-dp-dfs-memoization-dfs-and-dp-pruning-solutions-with-analysis Java DP+DFS, Memoization+DFS, and DP Pruning Solutions with Analysis I’ve been struggling with this problem for a long time, and I’d love to share three different strategies I have tried to solve it. All of them are ACed. Method 1: DP + DFS. Very similar to Word Break I, but instead of using a boolean dp array, I used an array of Lists to maintain all of the valid start positions for every end position. Then just do classic backtracking to find all solutions. The time complexity is O(n*m) + O(n * number of solutions), where n is the length of the input string, m is the length of the longest word in the dictionary. The run time was 6ms. It is very efficient because DP is used to find out all the valid answers, and no time is wasted on doing the backtracking. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; List&lt;Integer&gt;[] starts = new List[s.length() + 1]; // valid start positions starts[0] = new ArrayList&lt;Integer&gt;(); int maxLen = getMaxLen(wordDict); for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = i - 1; j &gt;= i - maxLen &amp;&amp; j &gt;= 0; j--) &#123; if (starts[j] == null) continue; String word = s.substring(j, i); if (wordDict.contains(word)) &#123; if (starts[i] == null) &#123; starts[i] = new ArrayList&lt;Integer&gt;(); &#125; starts[i].add(j); &#125; &#125; &#125; List&lt;String&gt; rst = new ArrayList&lt;&gt;(); if (starts[s.length()] == null) &#123; return rst; &#125; dfs(rst, "", s, starts, s.length()); return rst;&#125;private void dfs(List&lt;String&gt; rst, String path, String s, List&lt;Integer&gt;[] starts, int end) &#123; if (end == 0) &#123; rst.add(path.substring(1)); return; &#125; for (Integer start: starts[end]) &#123; String word = s.substring(start, end); dfs(rst, " " + word + path, s, starts, start); &#125;&#125;private int getMaxLen(Set&lt;String&gt; wordDict) &#123; int max = 0; for (String s : wordDict) &#123; max = Math.max(max, s.length()); &#125; return max;&#125; Method 2: Memoization + Backtracking. Before I came up with Method 1, I also tried using a HashMap to memoize all the possible strings that can be formed starting from index i. I referred to this post from @Pixel_The time complexity is O(len(wordDict) ^ len(s / minWordLenInDict)) as @Pixel_ mentioned. The space complexity would be larger than other methods though. Here is my code: 1234567891011121314151617181920212223242526272829public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; HashMap&lt;Integer, List&lt;String&gt;&gt; memo = new HashMap&lt;&gt;(); // &lt;Starting index, rst list&gt; return dfs(s, 0, wordDict, memo);&#125;private List&lt;String&gt; dfs(String s, int start, Set&lt;String&gt; dict, HashMap&lt;Integer, List&lt;String&gt;&gt; memo) &#123; if (memo.containsKey(start)) &#123; return memo.get(start); &#125; List&lt;String&gt; rst = new ArrayList&lt;&gt;(); if (start == s.length()) &#123; rst.add(""); return rst; &#125; String curr = s.substring(start); for (String word: dict) &#123; if (curr.startsWith(word)) &#123; List&lt;String&gt; sublist = dfs(s, start + word.length(), dict, memo); for (String sub : sublist) &#123; rst.add(word + (sub.isEmpty() ? "" : " ") + sub); &#125; &#125; &#125; memo.put(start, rst); return rst;&#125; Method 3: DP Prunning + Backtracking. My very first solution is like this: using a boolean array to memoize whether a substring starting from position i to the end is breakable. This works well for worst cases like: s = “aaaaaaaaaaaab”, dict = [“a”, “aa”, “aaa”, “aaaa”]. However, for cases like: s = “aaaaaaaaaaaaa”, dict = [“a”, “aa”, “aaa”, “aaaa”], the time complexity is still O(2^n). Here is the code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; List&lt;String&gt; rst = new ArrayList&lt;&gt;(); if (s == null || s.length() == 0 || wordDict == null) &#123; return rst; &#125; boolean[] canBreak = new boolean[s.length()]; Arrays.fill(canBreak, true); StringBuilder sb = new StringBuilder(); dfs(rst, sb, s, wordDict, canBreak, 0); return rst;&#125;private void dfs(List&lt;String&gt; rst, StringBuilder sb, String s, Set&lt;String&gt; dict, boolean[] canBreak, int start) &#123; if (start == s.length()) &#123; rst.add(sb.substring(1)); return; &#125; if (!canBreak[start]) &#123; return; &#125; for (int i = start + 1; i &lt;= s.length(); i++) &#123; String word = s.substring(start, i); if (!dict.contains(word)) continue; int sbBeforeAdd = sb.length(); sb.append(" " + word); int rstBeforeDFS = rst.size(); dfs(rst, sb, s, dict, canBreak, i); if (rst.size() == rstBeforeDFS) &#123; canBreak[i] = false; &#125; sb.delete(sbBeforeAdd, sb.length()); &#125;&#125;private int getMaxLen(Set&lt;String&gt; wordDict) &#123; int max = 0; for (String s : wordDict) &#123; max = Math.max(max, s.length()); &#125; return max;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[139. Word Break]]></title>
    <url>%2Fp%2Fc7e5d8ed%2F</url>
    <content type="text"><![CDATA[28.9% https://leetcode.com/problems/word-break/ Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words. 12345For example, givens = &quot;leetcode&quot;,dict = [&quot;leet&quot;, &quot;code&quot;].Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;. UPDATE (2017/1/4): The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. 方法一： 我的代码实现: 1234567891011121314151617181920212223class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; int n = s.size(); if(n==0) return true; vector&lt;bool&gt; dp(n+1, false); dp[0] = true; // vector to unordered_set的用法，重点学习一下 unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); for(int i=1; i&lt;=n; i++)&#123; for(int j=i-1; j&gt;=0; j--)&#123; if(dp[j])&#123; string word = s.substr(j, i-j); if(wordSet.find(word)!=wordSet.end())&#123; dp[i] = true; break; &#125; &#125; &#125; &#125; return dp[n]; &#125;&#125;; https://discuss.leetcode.com/topic/7299/c-dynamic-programming-simple-and-fast-solution-4ms-with-optimization 6ms, September 9, 2016 C++ Dynamic Programming simple and fast solution (4ms) with optimization We use a boolean vector dp[]. dp[i] is set to true if a valid word (word sequence) ends there. The optimization is to look from current position i back and only substring and do dictionary look up in case the preceding position j with dp[j] == true is found. 12345678910111213141516171819202122class Solution &#123;public: bool wordBreak(string s, unordered_set&lt;string&gt;&amp; wordDict) &#123; if(wordDict.size()==0) return false; vector&lt;bool&gt; dp(s.size()+1, false); dp[0]=true; for(int i=1; i&lt;=s.size(); i++)&#123; for(int j=i-1; j&gt;=0; j--)&#123; if(dp[j])&#123; string word = s.substr(j, i-j); if(wordDict.find(word)!=wordDict.end())&#123; dp[i] = true; break; &#125; &#125; &#125; &#125; return dp[s.size()]; &#125;&#125;; https://discuss.leetcode.com/topic/2545/a-solution-using-bfs A solution using BFS People have posted elegant solutions using DP. The solution I post below using BFS is no better than those. Just to share some new thoughts. We can use a graph to represent the possible solutions. The vertices of the graph are simply the positions of the first characters of the words and each edge actually represents a word. For example, the input string is “nightmare”, there are two ways to break it, “night mare” and “nightmare”. The graph would be 0–&gt;5–&gt;9 | _^ The question is simply to check if there is a path from 0 to 9. The most efficient way is traversing the graph using BFS with the help of a queue and a hash set. The hash set is used to keep track of the visited nodes to avoid repeating the same work. For this problem, the time complexity is O(n^2) and space complexity is O(n), the same with DP. This idea can be used to solve the problem word break II. We can simple construct the graph using BFS, save it into a map and then find all the paths using DFS. 12345678910111213141516171819202122232425262728bool wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) &#123; // BFS queue&lt;int&gt; BFS; unordered_set&lt;int&gt; visited; BFS.push(0); while(BFS.size() &gt; 0) &#123; int start = BFS.front(); BFS.pop(); if(visited.find(start) == visited.end()) &#123; visited.insert(start); for(int j=start; j&lt;s.size(); j++) &#123; string word(s, start, j-start+1); if(dict.find(word) != dict.end()) &#123; BFS.push(j+1); if(j+1 == s.size()) return true; &#125; &#125; &#125; &#125; return false;&#125; python https://discuss.leetcode.com/topic/8109/simple-dp-solution-in-python-with-description Simple DP solution in Python with description 75ms, 18.48%, September 7, 2016 The idea is the following: d is an array that contains booleans d[i] is True if there is a word in the dictionary that ends at ith index of s AND d is also True at the beginning of the word Example: s = “leetcode” words = [“leet”, “code”] d[3] is True because there is “leet” in the dictionary that ends at 3rd index of “leetcode” d[7] is True because there is “code” in the dictionary that ends at the 7th index of “leetcode” AND d[3] is True The result is the last index of d.12345678910111213class Solution(object): def wordBreak(self, s, wordDict): &quot;&quot;&quot; :type s: str :type wordDict: Set[str] :rtype: bool &quot;&quot;&quot; d = [False] * len(s) for i in range(len(s)): for w in wordDict: if w == s[i-len(w)+1:i+1] and (d[i-len(w)] or i-len(w) == -1): d[i] = True return d[-1] https://discuss.leetcode.com/topic/16701/4-lines-in-python 4 lines in Python ok[i] tells whether s[:i] can be built. 12345def wordBreak(self, s, words): ok = [True] for i in range(1, len(s)+1): ok += any(ok[j] and s[j:i] in words for j in range(i)), return ok[-1] java https://discuss.leetcode.com/topic/6156/java-implementation-using-dp-in-two-ways 12ms, September 9, 2016 Java implementation using DP in two ways 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public boolean wordBreak(String s, Set&lt;String&gt; dict) &#123; boolean[] f = new boolean[s.length() + 1]; f[0] = true; /* First DP for(int i = 1; i &lt;= s.length(); i++)&#123; for(String str: dict)&#123; if(str.length() &lt;= i)&#123; if(f[i - str.length()])&#123; if(s.substring(i-str.length(), i).equals(str))&#123; f[i] = true; break; &#125; &#125; &#125; &#125; &#125;*/ //Second DP for(int i=1; i &lt;= s.length(); i++)&#123; for(int j=0; j &lt; i; j++)&#123; if(f[j] &amp;&amp; dict.contains(s.substring(j, i)))&#123; f[i] = true; break; &#125; &#125; &#125; return f[s.length()]; &#125;&#125; https://discuss.leetcode.com/topic/9615/dfs-with-path-memorizing-java-solution DFS with Path Memorizing Java Solution I write this method by what I learned from @mahdy in his post Decode Ways Use a set to record all position that cannot find a match in dict. That cuts down the run time of DFS to O(n^2) 12345678910111213141516171819202122232425public class Solution &#123; public boolean wordBreak(String s, Set&lt;String&gt; dict) &#123; // DFS Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); return dfs(s, 0, dict, set); &#125; private boolean dfs(String s, int index, Set&lt;String&gt; dict, Set&lt;Integer&gt; set)&#123; // base case if(index == s.length()) return true; // check memory if(set.contains(index)) return false; // recursion for(int i = index+1;i &lt;= s.length();i++)&#123; String t = s.substring(index, i); if(dict.contains(t)) if(dfs(s, i, dict, set)) return true; else set.add(i); &#125; set.add(index); return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[138. Copy List with Random Pointer]]></title>
    <url>%2Fp%2F9bcae609%2F</url>
    <content type="text"><![CDATA[26.5% https://leetcode.com/problems/copy-list-with-random-pointer/#/description A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. https://discuss.leetcode.com/topic/5831/2-clean-c-algorithms-without-using-extra-array-hash-table-algorithms-are-explained-step-by-step 2 clean C++ algorithms without using extra array/hash table. Algorithms are explained step by step. 123456789101112131415161718192021222324252627282930313233343536373839//// Here&apos;s how the 1st algorithm goes.// Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.// Step 1:// Build the 2nd list by creating a new node for each node in 1st list. // While doing so, insert each new node after it&apos;s corresponding node in the 1st list.// Step 2:// The new head is the 2nd node as that was the first inserted node.// Step 3:// Fix the random pointers in the 2nd list: (Remember that l1-&gt;next is actually l2)// l2-&gt;random will be the node in 2nd list that corresponds l1-&gt;random, // which is next node of l1-&gt;random.// Step 4:// Separate the combined list into 2: Splice out nodes that are part of second list. // Return the new head that we saved in step 2.//RandomListNode *copyRandomList(RandomListNode *head) &#123; RandomListNode *newHead, *l1, *l2; if (head == NULL) return NULL; for (l1 = head; l1 != NULL; l1 = l1-&gt;next-&gt;next) &#123; l2 = new RandomListNode(l1-&gt;label); l2-&gt;next = l1-&gt;next; l1-&gt;next = l2; &#125; newHead = head-&gt;next; for (l1 = head; l1 != NULL; l1 = l1-&gt;next-&gt;next) &#123; if (l1-&gt;random != NULL) l1-&gt;next-&gt;random = l1-&gt;random-&gt;next; &#125; for (l1 = head; l1 != NULL; l1 = l1-&gt;next) &#123; l2 = l1-&gt;next; l1-&gt;next = l2-&gt;next; if (l2-&gt;next != NULL) l2-&gt;next = l2-&gt;next-&gt;next; &#125; return newHead;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//// Here&apos;s how the 2nd algorithm goes.// Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.// Step 1:// Build the 2nd list by creating a new node for each node in 1st list. // While doing so, set the next pointer of the new node to the random pointer // of the corresponding node in the 1st list. And set the random pointer of the // 1st list&apos;s node to the newly created node.// Step 2:// The new head is the node pointed to by the random pointer of the 1st list.// Step 3:// Fix the random pointers in the 2nd list: (Remember that l1-&gt;random is l2)// l2-&gt;random will be the node in 2nd list that corresponds to the node in the // 1st list that is pointed to by l2-&gt;next, // Step 4:// Restore the random pointers of the 1st list and fix the next pointers of the // 2nd list. random pointer of the node in 1st list is the next pointer of the // corresponding node in the 2nd list. This is what we had done in the // 1st step and now we are reverting back. next pointer of the node in // 2nd list is the random pointer of the node in 1st list that is pointed to // by the next pointer of the corresponding node in the 1st list.// Return the new head that we saved in step 2.//RandomListNode *copyRandomList(RandomListNode *head) &#123; RandomListNode *newHead, *l1, *l2; if (head == NULL) return NULL; for (l1 = head; l1 != NULL; l1 = l1-&gt;next) &#123; l2 = new RandomListNode(l1-&gt;label); l2-&gt;next = l1-&gt;random; l1-&gt;random = l2; &#125; newHead = head-&gt;random; for (l1 = head; l1 != NULL; l1 = l1-&gt;next) &#123; l2 = l1-&gt;random; l2-&gt;random = l2-&gt;next ? l2-&gt;next-&gt;random : NULL; &#125; for (l1 = head; l1 != NULL; l1 = l1-&gt;next) &#123; l2 = l1-&gt;random; l1-&gt;random = l2-&gt;next; l2-&gt;next = l1-&gt;next ? l1-&gt;next-&gt;random : NULL; &#125; return newHead;&#125; https://discuss.leetcode.com/topic/22194/o-n-time-o-1-space-c O(n) time O(1) Space C++ 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode * head) &#123; RandomListNode * head_cp = nullptr, * cur = head, * cur_cp = nullptr; if (head == nullptr) return nullptr; while (cur != nullptr) &#123; cur_cp = new RandomListNode (cur-&gt;label); cur_cp-&gt;next = cur-&gt;next; cur-&gt;next = cur_cp; cur = cur_cp-&gt;next; &#125; cur = head; while (cur != nullptr) &#123; cur_cp = cur-&gt;next; if (cur-&gt;random) cur_cp-&gt;random = cur-&gt;random-&gt;next; cur = cur_cp -&gt;next; &#125; cur = head; head_cp = head-&gt;next; while (cur != nullptr) &#123; cur_cp = cur-&gt;next; cur-&gt;next = cur_cp-&gt;next; cur = cur-&gt;next; if (cur) cur_cp-&gt;next = cur-&gt;next; &#125; return head_cp; &#125;&#125;; https://discuss.leetcode.com/topic/12025/c-simple-recursive-solution C++ simple recursive solution 12345678910111213141516class Solution &#123;unordered_map&lt;RandomListNode*, RandomListNode*&gt; hmap;public:RandomListNode *copyRandomList(RandomListNode *head) &#123; if (!head) return NULL; if (hmap.find(head) != hmap.end()) return hmap.find(head)-&gt;second; RandomListNode* node = new RandomListNode(head-&gt;label); hmap[head] = node; node-&gt;next = copyRandomList(head-&gt;next); node-&gt;random = copyRandomList(head-&gt;random); return node;&#125;&#125;; https://discuss.leetcode.com/topic/7594/a-solution-with-constant-space-complexity-o-1-and-linear-time-complexity-o-n A solution with constant space complexity O(1) and linear time complexity O(N) An intuitive solution is to keep a hash table for each node in the list, via which we just need to iterate the list in 2 rounds respectively to create nodes and assign the values for their random pointers. As a result, the space complexity of this solution is O(N), although with a linear time complexity. As an optimised solution, we could reduce the space complexity into constant. The idea is to associate the original node with its copy node in a single linked list. In this way, we don’t need extra space to keep track of the new nodes. The algorithm is composed of the follow three steps which are also 3 iteration rounds. Iterate the original list and duplicate each node. The duplicate of each node follows its original immediately. Iterate the new list and assign the random pointer for each duplicated node. Restore the original list and extract the duplicated nodes. The algorithm is implemented as follows: 123456789101112131415161718192021222324252627282930313233343536373839404142434445public RandomListNode copyRandomList(RandomListNode head) &#123; RandomListNode iter = head, next; // First round: make copy of each node, // and link them together side-by-side in a single list. while (iter != null) &#123; next = iter.next; RandomListNode copy = new RandomListNode(iter.label); iter.next = copy; copy.next = next; iter = next; &#125; // Second round: assign random pointers for the copy nodes. iter = head; while (iter != null) &#123; if (iter.random != null) &#123; iter.next.random = iter.random.next; &#125; iter = iter.next.next; &#125; // Third round: restore the original list, and extract the copy list. iter = head; RandomListNode pseudoHead = new RandomListNode(0); RandomListNode copy, copyIter = pseudoHead; while (iter != null) &#123; next = iter.next.next; // extract the copy copy = iter.next; copyIter.next = copy; copyIter = copy; // restore the original list iter.next = next; iter = next; &#125; return pseudoHead.next;&#125; https://discuss.leetcode.com/topic/18086/java-o-n-solution Java O(n) solution 12345678910111213141516171819202122public RandomListNode copyRandomList(RandomListNode head) &#123; if (head == null) return null; Map&lt;RandomListNode, RandomListNode&gt; map = new HashMap&lt;RandomListNode, RandomListNode&gt;(); // loop 1. copy all the nodes RandomListNode node = head; while (node != null) &#123; map.put(node, new RandomListNode(node.label)); node = node.next; &#125; // loop 2. assign next and random pointers node = head; while (node != null) &#123; map.get(node).next = map.get(node.next); map.get(node).random = map.get(node.random); node = node.next; &#125; return map.get(head);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>linked list</tag>
        <tag>hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[137. Single Number II]]></title>
    <url>%2Fp%2F3b63b6e2%2F</url>
    <content type="text"><![CDATA[40.5% https://leetcode.com/problems/single-number-ii/?tab=Description Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 方法一： 统计每一位的个数，模3，然后就是答案了 方法二： https://discuss.leetcode.com/topic/2031/challenge-me-thx Challenge me , thx 12345678public int singleNumber(int[] A) &#123; int ones = 0, twos = 0; for(int i = 0; i &lt; A.length; i++)&#123; ones = (ones ^ A[i]) &amp; ~twos; twos = (twos ^ A[i]) &amp; ~ones; &#125; return ones;&#125; https://discuss.leetcode.com/topic/11877/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers Detailed explanation and generalization of the bitwise operation method for single numbers Statement of our problem: “Given an array of integers, every element appears k (k &gt; 1) times except for one, which appears p times (p &gt;= 1, p % k != 0). Find that single one.” As others pointed out, in order to apply the bitwise operations, we should rethink how integers are represented in computers – by bits. To start, let’s consider only one bit for now. Suppose we have an array of 1-bit numbers (which can only be 0 or 1), we’d like to count the number of 1’s in the array such that whenever the counted number of 1 reaches a certain value, say k, the count returns to zero and starts over (In case you are curious, this k will be the same as the one in the problem statement above). To keep track of how many 1’s we have encountered so far, we need a counter. Suppose the counter has m bits in binary form: xm, …, x1 (from most significant bit to least significant bit). We can conclude at least the following four properties of the counter: There is an initial state of the counter, which for simplicity is zero; For each input from the array, if we hit a 0, the counter should remain unchanged; For each input from the array, if we hit a 1, the counter should increase by one; In order to cover k counts, we require 2^m &gt;= k, which implies m &gt;= logk. Here is the key part: how each bit in the counter (x1 to xm) changes as we are scanning the array. Note we are prompted to use bitwise operations. In order to satisfy the second property, recall what bitwise operations will not change the operand if the other operand is 0? Yes, you got it: x = x | 0 and x = x ^ 0. Okay, we have an expression now: x = x | i or x = x ^ i, where i is the scanned element from the array. Which one is better? We don’t know yet. So, let’s just do the actual counting: At the beginning, all bits of the counter is initialized to zero, i.e., xm = 0, …, x1 = 0. Since we are gonna choose bitwise operations that guarantee all bits of the counter remain unchanged if we hit 0’s, the counter will be 0 until we hit the first 1 in the array. After we hit the first 1, we got: xm = 0, …,x2 = 0, x1 = 1. Let’s continue until we hit the second 1, after which we have: xm = 0, …, x2 = 1, x1 = 0. Note that x1 changed from 1 to 0. For x1 = x1 | i, after the second count, x1 will still be 1. So it’s clear we should use x1 = x1 ^ i. What about x2, …, xm? The idea is to find the condition under which x2, …, xm will change their values. Take x2 as an example. If we hit a 1 and need to change the value of x2, what must be the value of x1 right before we do the change? The answer is: x1 must be 1 otherwise we shouldn’t change x2 because changing x1 from 0 to 1 will do the job. So x2 will change value only if x1 and i are both 1, or mathematically, x2 = x2 ^ (x1 &amp; i). Similarly xm will change value only when xm-1, …, x1 and i are all 1: xm = xm ^ (xm-1 &amp; … &amp; x1 &amp; i). Bingo, we’ve found the bitwise operations! However, you may notice that the bitwise operations found above will count from 0 until 2^m - 1, instead of k. If k &lt; 2^m - 1, we need some “cutting” mechanism to reinitialize the counter to 0 when the count reaches k. To this end, we apply bitwise AND to xm,…, x1 with some variable called mask, i.e., xm = xm &amp; mask, …, x1 = x1 &amp; mask. If we can make sure that mask will be 0 only when the count reaches k and be 1 for all other count cases, then we are done. How do we achieve that? Try to think what distinguishes the case with k count from all other count cases. Yes, it’s the count of 1’s! For each count, we have unique values for each bit of the counter, which can be regarded as its state. If we write k in its binary form: km,…, k1. we can construct mask as follows: 1mask = ~(y1 &amp; y2 &amp; ... &amp; ym), where yj = xj if kj = 1 and yj = ~xj if kj = 0 (j = 1 to m). 12345Let&apos;s do some examples:k = 3: k1 = 1, k2 = 1, mask = ~(x1 &amp; x2);k = 5: k1 = 1, k2 = 0, k3 = 1, mask = ~(x1 &amp; ~x2 &amp; x3); In summary, our algorithm will go like this: 123456789101112for (int i : array) &#123; xm ^= (xm-1 &amp; ... &amp; x1 &amp; i); xm-1 ^= (xm-2 &amp; ... &amp; x1 &amp; i); ..... x1 ^= i; mask = ~(y1 &amp; y2 &amp; ... &amp; ym) where yj = xj if kj = 1 and yj = ~xj if kj = 0 (j = 1 to m). xm &amp;= mask; ...... x1 &amp;= mask;&#125; Now it’s time to generalize our results from 1-bit number case to 32-bit integers. One straightforward way would be creating 32 counters for each bit in the integer. You’ve probably already seen this in other posted codes. But if we take advantage of bitwise operations, we may be able to manage all the 32 counters “collectively”. By saying “collectively” we mean using m 32-bit integers instead of 32 m-bit counters, where m is the minimum integer that satisfies m &gt;= logk. The reason is that bitwise operations apply only to each bit so operations on different bits are independent of each other(kind obvious, right?). This allows us to group the corresponding bits of the 32 counters into one 32-bit integer (for schematic steps, see comments below). Since each counter has m bits, we end up with m 32-bit integers. Therefore, in the algorithm developed above, we just need to regard x1 to xm as 32-bit integers instead of 1-bit numbers and we are done. Easy, hum? The last thing is what value we should return, or equivalently which one of x1 to xm will equal the single element. To get the correct answer, we need to understand what the m 32-bit integers x1 to xm represent. Take x1 as an example. x1 has 32 bits and let’s label them as r (r = 1 to 32), After we are done scanning the input array, the value for the r-th bit of x1 will be determined by the r-th bit of all the elements in the array (more specifically, suppose the total count of 1 for the r-th bit of all the elements in the array is q, q’ = q % k and in its binary form: q’m,…,q’1, then by definition the r-th bit of x1 will be equal to q’1). Now you can ask yourself this question: what does it imply if the r-th bit of x1 is 1? The answer is to find what can contribute to this 1. Will an element that appears k times contribute? No. Why? Because for an element to contribute, it has to satisfy at least two conditions at the same time: the r-th bit of this element is 1 and the number of appearance of this 1 is not an integer multiple of k. The first condition is trivial. The second comes from the fact that whenever the number of 1 hit is k, the counter will go back to zero, which means the corresponding bit in x1 will be reset to 0. For an element that appears k times, it’s impossible to meet these two conditions simultaneously so it won’t contribute. At last, only the single element which appears p (p % k != 0) times will contribute. If p &gt; k, then the first k * [p/k] ([p/k]denotes the integer part of p/k) single elements won’t contribute either. Then we can always set p’ = p % k and say the single element appears effectively p’ times. Let’s write p’ in its binary form: p’m, …, p’1. (note that p’ &lt; k, so it will fit into m bits). Here I claim the condition for x1 to equal the single element is p’1 = 1. Quick proof: if the r-th bit of x1 is 1, we can safely say the r-th bit of the single element is also 1. We are left to prove that if the r-th bit of x1 is 0, then the r-th bit of the single element can only be 0. Just suppose in this case the r-th bit of the single element is 1, let’s see what will happen. At the end of the scan, this 1 will be counted p’ times. If we write p’ in its binary form: p’m, …, p’1, then by definition the r-th bit of x1 will equal p’1, which is 1. This contradicts with the presumption that the r-th bit of x1 is 0. Since this is true for all bits in x1, we can conclude x1 will equal the single element if p’1 = 1. Similarly we can show xj will equal the single element if p’j = 1 (j = 1 to m). Now it’s clear what we should return. Just express p’ = p % k in its binary form and return any of the corresponding xj as long as p’j = 1. In total, the algorithm will run in O(n * logk) time and O(logk) space. Hope this helps! https://discuss.leetcode.com/topic/11877/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers/2 Here is a list of few quick examples to show how the algorithm works: k = 2, p = 1. k is 2, then m = 1, we need only one 32-bit integer(x1) as the counter. And 2^m = k so we do not even need a mask! A complete java program will look like: 1234567public int singleNumber(int[] A) &#123; int x1 = 0; for (int i : A) &#123; x1 ^= i; &#125; return x1;&#125; k = 3, p = 1. k is 3, then m = 2, we need two 32-bit integers(x2, x1) as the counter. And 2^m &gt; k so we do need a mask. Write k in its binary form: k = ‘11’, then k1 = 1, k2 = 1, so we have mask = ~ (x1 &amp; x2). A complete java program will look like: 12345678910111213141516public int singleNumber(int[] A) &#123; int x1 = 0; int x2 = 0; int mask = 0; for (int i : A) &#123; x2 ^= x1 &amp; i; x1 ^= i; mask = ~(x1 &amp; x2); x2 &amp;= mask; x1 &amp;= mask; &#125; return x1; // p = 1, in binary form p = &apos;01&apos;, then p1 = 1, so we should return x1; // if p = 2, in binary form p = &apos;10&apos;, then p2 = 1, so we should return x2.&#125; k = 5, p = 3. k is 5, then m = 3, we need three 32-bit integers(x3, x2, x1) as the counter. And 2^m &gt; k so we need a mask. Write k in its binary form: k = ‘101’, then k1 = 1, k2 = 0, k3 = 1, so we have mask = ~(x1 &amp; ~x2 &amp; x3). A complete java program will look like: 123456789101112131415161718192021public int singleNumber(int[] A) &#123; int x1 = 0; int x2 = 0; int x3 = 0; int mask = 0; for (int i : A) &#123; x3 ^= x2 &amp; x1 &amp; i; x2 ^= x1 &amp; i; x1 ^= i; mask = ~(x1 &amp; ~x2 &amp; x3); x3 &amp;= mask; x2 &amp;= mask; x1 &amp;= mask; &#125; return x1; // p = 3, in binary form p = &apos;011&apos;, then p1 = p2 = 1, // so we can return either x1 or x2; // But if p = 4, in binary form p = &apos;100&apos;, then only p3 = 1, // which implies we can only return x3.&#125; You can easily come up with other examples. If you have any questions about the explanation, please let me know. I would appreciate your feedback. Thanks! https://discuss.leetcode.com/topic/22821/an-general-way-to-handle-all-this-sort-of-questions An General Way to Handle All this sort of questions. this kind of question the key idea is design a counter that record state. the problem can be every one occurs K times except one occurs M times. for this question, K =3 ,M = 1(or 2) .so to represent 3 state, we need two bit. let say it is a and b, and c is the incoming bit.then we can design a table to implement the state move. 12345678current incoming nexta b c a b0 0 0 0 00 1 0 0 11 0 0 1 00 0 1 0 10 1 1 1 01 0 1 0 0 like circuit design, we can find out what the next state will be with the incoming bit.( we only need find the ones)then we have for a to be 1, we have 1234current incoming nexta b c a b1 0 0 1 00 1 1 1 0 and this is can be represented by 1a=a&amp;~b&amp;~c + ~a&amp;b&amp;c and b can do the same we , and we find that 1b= ~a&amp;b&amp;~c+~a&amp;~b&amp;c and this is the final formula of a and b and just one of the result set, because for different state move table definition, we can generate different formulas, and this one is may not the most optimised. as you may see other’s answer that have a much simple formula, and that formula also corresponding to specific state move table. (if you like ,you can reverse their formula to a state move table, just using the same way but reversely) for this questions we need to find the except one as the question don’t say if the one appears one time or two time , so for ab both 1201 10 =&gt; 100 =&gt; 0 we should return a|b; this is the key idea , we can design any based counter and find the occurs any times except one . here is my code. with comment. 1234567891011121314151617181920212223public class Solution &#123; public int singleNumber(int[] nums) &#123; //we need to implement a tree-time counter(base 3) that if a bit appears three time ,it will be zero. //#curent income ouput //# ab c/c ab/ab //# 00 1/0 01/00 //# 01 1/0 10/01 //# 10 1/0 00/10 // a=~abc+a~b~c; // b=~a~bc+~ab~c; int a=0; int b=0; for(int c:nums)&#123; int ta=(~a&amp;b&amp;c)|(a&amp;~b&amp;~c); b=(~a&amp;~b&amp;c)|(~a&amp;b&amp;~c); a=ta; &#125; //we need find the number that is 01,10 =&gt; 1, 00 =&gt; 0. return a|b; &#125;&#125; this is a general solution . and it comes from the Circuit Design on course digital logic. https://discuss.leetcode.com/topic/43166/java-o-n-easy-to-understand-solution-easily-extended-to-any-times-of-occurance Java O(n) easy to understand solution, easily extended to any times of occurance The usual bit manipulation code is bit hard to get and replicate. I like to think about the number in 32 bits and just count how many 1s are there in each bit, and sum %= 3 will clear it once it reaches 3. After running for all the numbers for each bit, if we have a 1, then that 1 belongs to the single number, we can simply move it back to its spot by doing ans |= sum &lt;&lt; i; This has complexity of O(32n), which is essentially O(n) and very easy to think and implement. Plus, you get a general solution for any times of occurrence. Say all the numbers have 5 times, just do sum %= 5. 12345678910111213141516public int singleNumber(int[] nums) &#123; int ans = 0; for(int i = 0; i &lt; 32; i++) &#123; int sum = 0; for(int j = 0; j &lt; nums.length; j++) &#123; if(((nums[j] &gt;&gt; i) &amp; 1) == 1) &#123; sum++; sum %= 3; &#125; &#125; if(sum != 0) &#123; ans |= sum &lt;&lt; i; &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/2926/accepted-code-with-proper-explaination-does-anyone-have-a-better-idea Accepted code with proper Explaination. Does anyone have a better idea? The code makes use of 2 variables. ones - At any point of time, this variable holds XOR of all the elements which haveappeared “only” once.twos - At any point of time, this variable holds XOR of all the elements which haveappeared “only” twice. So if at any point time, A new number appears - It gets XOR’d to the variable “ones”. A number gets repeated(appears twice) - It is removed from “ones” and XOR’d to the variable “twos”. A number appears for the third time - It gets removed from both “ones” and “twos”. The final answer we want is the value present in “ones” - coz, it holds the unique element. So if we explain how steps 1 to 3 happens in the code, we are done.Before explaining above 3 steps, lets look at last three lines of the code, common_bit_mask = ~ (ones &amp; twos) ones &amp; = common_bit_mask twos &amp; = common_bit_mask All it does is, common 1’s between “ones” and “twos” are converted to zero. For simplicity, in all the below explanations - consider we have got only 4 elements in the array (one unique element and 3 repeated elements - in any order). Explanation for step 1 Lets say a new element(x) appears. CURRENT SITUATION - Both variables - “ones” and “twos” has not recorded “x”. Observe the statement “twos| = ones &amp; x”.Since bit representation of “x” is not present in “ones”, AND condition yields nothing. So “twos” does not get bit representation of “x”.But, in next step “ones ^= x” - “ones” ends up adding bits of “x”. Thus new element gets recorded in “ones” but not in “twos”. The last 3 lines of code as explained already, converts common 1’s b/w “ones” and “twos” to zeros.Since as of now, only “ones” has “x” and not “twos” - last 3 lines does nothing. Explanation for step 2. Lets say an element(x) appears twice. CURRENT SITUATION - “ones” has recorded “x” but not “twos”. Now due to the statement, “twos| = ones &amp; x” - “twos” ends up getting bits of x.But due to the statement, “ones ^ = x” - “ones” removes “x” from its binary representation. Again, last 3 lines of code does nothing.So ultimately, “twos” ends up getting bits of “x” and “ones” ends up losing bits of “x”. Explanation for step 3. Lets say an element(x) appears for the third time. CURRENT SITUATION - “ones” does not have bit representation of “x” but “twos” has. Though “ones &amp; x” does not yield nothing .. “twos” by itself has bit representation of “x”. So after this statement, “two” has bit representation of “x”.Due to “ones^=x”, after this step, “one” also ends up getting bit representation of “x”. Now last 3 lines of code removes common 1’s of “ones” and “twos” - which is the bit representation of “x”.Thus both “ones” and “twos” ends up losing bit representation of “x”. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public: // Let us take the example of &#123;3, 3, 2, 3&#125; to understand this int singleNumber(int A[], int n) &#123; int ones=0, twos =0; int common_bit_mask; for(int i=0; i&lt;n;i++) &#123; /* The expression &quot;one &amp; arr[i]&quot; gives the bits that are there in both &apos;ones&apos; and new element from arr[]. We add these bits to &apos;twos&apos; using bitwise OR Value of &apos;twos&apos; will be set as 0, 3, 3 and 1 after 1st, 2nd, 3rd and 4th iterations respectively */ twos= twos|(ones&amp;A[i]); /* XOR the new bits with previous &apos;ones&apos; to get all bits appearing odd number of times Value of &apos;ones&apos; will be set as 3, 0, 2 and 3 after 1st, 2nd, 3rd and 4th iterations respectively */ ones=ones^A[i]; /* The common bits are those bits which appear third time So these bits should not be there in both &apos;ones&apos; and &apos;twos&apos;. common_bit_mask contains all these bits as 0, so that the bits can be removed from &apos;ones&apos; and &apos;twos&apos; Value of &apos;common_bit_mask&apos; will be set as 00, 00, 01 and 10 after 1st, 2nd, 3rd and 4th iterations respectively */ common_bit_mask= ~(ones&amp;twos); /* Remove common bits (the bits that appear third time) from &apos;ones&apos; Value of &apos;ones&apos; will be set as 3, 0, 0 and 2 after 1st, 2nd, 3rd and 4th iterations respectively */ ones &amp;=common_bit_mask; /* Remove common bits (the bits that appear third time) from &apos;twos&apos; Value of &apos;twos&apos; will be set as 0, 3, 1 and 0 after 1st, 2nd, 3rd and 4th itearations respectively */ twos &amp;=common_bit_mask; &#125; return ones; &#125; &#125;; https://discuss.leetcode.com/topic/23584/a-general-c-solution-for-these-type-problems A general C++ solution for these type problems There are so many brilliant solutions for this problem used “| &amp; ^ ~”, and I have learned a lot from these solutions. Here is a general solution for who not familiar with “| &amp; ^ ~”. Q: Most elements appeared k times, except one. Find this “one”. 12345678910111213141516171819202122232425int singleNumber(vector&lt;int&gt;&amp; s) &#123; vector&lt;int&gt; t(32);////Made a array contain 32 elements. int sz = s.size(); int i, j, n; for (i = 0; i &lt; sz; ++i) &#123; n = s[i]; for (j = 31; j &gt;= 0; --j) &#123; t[j] += n &amp; 1;//Find the last digit. n &gt;&gt;= 1; if (!n) break; &#125; &#125; int res = 0; for (j = 31; j &gt;= 0; --j) &#123; n = t[j] % 3;//&quot;3&quot; represents k times. if (n) res += 1 &lt;&lt; (31 - j); &#125; return res;&#125; https://discuss.leetcode.com/topic/34725/my-own-explanation-of-bit-manipulation-method-might-be-easier-to-understand My own explanation of bit manipulation method, might be easier to understand Consider the following fact: Write all numbers in binary form, then for any bit 1 that appeared 3*n times (n is an integer), the bit can only present in numbers that appeared 3 times e.g. 0010 0010 0010 1011 1011 1011 1000 (assuming 4-bit integers)2(0010) and 11(1011) appeared 3 times, and digit counts are: 12345Digits 3 2 1 0Counts 4 0 6 3Counts%3 1 0 0 0 Counts on 2,1,0 are all times of 3, the only digit index that has Counts % 3 != 0 is 3 Therefore, to find the number that appeared only 1 or 2 times, we only need to extract all bits that has Counts %3 != 0 Now consider how we could do this by bit manipulation since counts % 3 has only 3 states: 0(00),1(01),2(10)we could use a TWO BIT COUNTER (Two, One) to represent Counts % 3, now we could do a little research on state transitions, for each bit, let B be the input bit, we can enumerate the all possible state transitions, Two+, One+ is the new state of Two, One. (here we need to use some knowledge in Digital Logic Design) 1234567891011121314151617Two One B Two+ One+0 0 0 0 00 0 1 0 10 1 0 0 10 1 1 1 01 0 0 1 01 0 1 0 01 1 0 X X (X represents we don&apos;t care)1 1 1 X X We could then draw the Karnaugh map to analyze the logic (https://en.wikipedia.org/wiki/Karnaugh_map), and then we get: 123One+ = (One ^ B) &amp; (~Two)Two+ = (~One+) &amp; (Two ^ B) Now for int_32, we need only 2 int_32 two represent Two and One for each bit and update Two and One using the rules derived above Code is here (C++): 12345678910111213class Solution &#123; public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int counterOne = 0; int counterTwo = 0; for (int i = 0; i &lt; nums.size(); i++)&#123; counterOne = (~counterTwo) &amp; (counterOne ^ nums[i]); counterTwo = (~counterOne) &amp; (counterTwo ^ nums[i]); &#125; return counterOne; &#125;&#125;; https://discuss.leetcode.com/topic/17629/the-simplest-solution-ever-with-clear-explanation The simplest solution ever with clear explanation The key to solve this problem is the count of 1s of each bit of all numbers. Take one bit number for example: nums = [1, 1, 1, 0, 0, 0, …, x] . All numbers are 0 or 1. We know that every number appears three times except for just one number. So, if the count of 1s in nums is 0, 3, 6, …, 3 n, then the single number is 0. And if the count of 1s in nums is 1, 4, 7, …, 3\n+1, then the single number is 1. So, for an array “ nums “ that contains only 0 or 1, the code to find the single number are: 1234count = 0for num in nums: count = (count + num) % 3return count To make “count” less than 3, mod “count” with 3 in every loop. Below is the procedure for finding the single number in [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]: 123456Table 1:++=======++===+===+===+===+===+===+===+===+===+===+===+===+===+====++|| num || | 1 | 0 | 1 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 ||++-------++---+---+---+---+---+---+---+---+---+---+---+---+---+----++|| count || 0 | 1 | 1 | 2 | 0 | 0 | 1 | 1 | 2 | 2 | 0 | 0 | 1 | 1* ||++=======++===+===+===+===+===+===+===+===+===+===+===+===+===+====++ So the single number is 1. We can write the calculate table for expression “count’ = (count + num) % 3”: 12345678910111213141516Table 2:++=======+=====+========++|| count | num | count&apos; ||++-------+-----+--------++|| 0 | 0 | 0 ||++-------+-----+--------++|| 1 | 0 | 1 ||++-------+-----+--------++|| 2 | 0 | 2 ||++-------+-----+--------++|| 0 | 1 | 1 ||++-------+-----+--------++|| 1 | 1 | 2 ||++-------+-----+--------++|| 2 | 1 | 0 ||++-------+-----+--------++ To extend this algorithm to 32bits number. We need to rewrite these code to bit operation expressions. And the key is rewriting the expression “ count’ = (count + num) % 3 “ to bit operation expressions. Write binary numbers of “ count “ and “ count’ “ in “Table 2”. And split their bits into two column: 12345678910111213141516171819Table 3:++=======+============+=====+============+========++|| | count | num | count&apos; | |||| count | (bin) | | (bin) | count&apos; |||| (dec) ++=====+=====+=====+=====+=====++ (dec) |||| || b1 | b0 | num | b1&apos; | b0&apos; || ||++-------++-----+-----+-----+-----+-----++--------++|| 0 || 0 | 0 | 0 | 0 | 0 || 0 ||++-------++-----+-----+-----+-----+-----++--------++|| 1 || 0 | 1 | 0 | 0 | 1 || 1 ||++-------++-----+-----+-----+-----+-----++--------++|| 2 || 1 | 0 | 0 | 1 | 0 || 2 ||++-------++-----+-----+-----+-----+-----++--------++|| 0 || 0 | 0 | 1 | 0 | 1 || 1 ||++-------++-----+-----+-----+-----+-----++--------++|| 1 || 0 | 1 | 1 | 1 | 0 || 2 ||++-------++-----+-----+-----+-----+-----++--------++|| 2 || 1 | 0 | 1 | 0 | 0 || 0 ||++=======++===========+=====+===========++========++ Here comes the hardest part of this solution. “Table 3” is a truth table, we need to use it to find the formulas to calculate “ b0’ “ and “ b1’ “: 12b0&apos; = f(b1, b0, num)b1&apos; = g(b1, b0, num) With observations, guesses, experiments and even some luck. Finally I got two simple and elegant formulas: 12b0&apos; = (b0 ^ num) &amp; (~b1)b1&apos; = (b1 ^ num) &amp; (~b0&apos;) The AC code: 123456789class Solution: # @param &#123;integer[]&#125; nums # @return &#123;integer&#125; def singleNumber(self, nums): b1, b0 = 0, 0 for num in nums: b0 = (b0 ^ num) &amp; (~b1) b1 = (b1 ^ num) &amp; (~b0) return b0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[136. Single Number]]></title>
    <url>%2Fp%2F66a2ee90%2F</url>
    <content type="text"><![CDATA[53.2% https://leetcode.com/problems/single-number/?tab=Description Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 方法一： 注意下面代码中res=0，不能是 int res，要给res赋一个初始值，否则出现错误。 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for(auto num:nums) res ^= num; return res; &#125;&#125;; 我的代码实现： 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for(auto num:nums) res ^= num; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/19563/python-different-solutions 1234567def singleNumber1(self, nums): dic = &#123;&#125; for num in nums: dic[num] = dic.get(num, 0)+1 for key, val in dic.items(): if val == 1: return key 12345def singleNumber2(self, nums): res = 0 for num in nums: res ^= num return res 12def singleNumber3(self, nums): return 2*sum(set(nums))-sum(nums) 12def singleNumber4(self, nums): return reduce(lambda x, y: x ^ y, nums) 12def singleNumber(self, nums): return reduce(operator.xor, nums) https://discuss.leetcode.com/topic/42358/1-line-simple-python-solution 123class Solution(object): def singleNumber(self, nums): return sum(list(set(nums)))*2 - sum(nums) my code12345678910class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; res = 0 for num in nums: res ^= num return res 1234567class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; return reduce((lambda x, y : x^y), nums) java 12345678public class Solution &#123; public int singleNumber(int[] nums) &#123; int res = 0; for(int i=0; i&lt;nums.length; i++) res ^= nums[i]; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
        <tag>bin manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[135. Candy]]></title>
    <url>%2Fp%2Fd0cc5467%2F</url>
    <content type="text"><![CDATA[24.2% https://leetcode.com/problems/candy/ There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? 方法一： A simple solution 1234567891011121314151617181920class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int size = ratings.size(); if(size&lt;=1) return size; vector&lt;int&gt; ret(size, 1); for(int i=1; i&lt;size; i++)&#123; if(ratings[i]&gt;ratings[i-1]) ret[i] = ret[i-1]+1; &#125; for(int i=size-1; i&gt;0; i--)&#123; if(ratings[i-1]&gt;ratings[i]) ret[i-1] = max(ret[i-1], ret[i]+1); &#125; int result = 0; for(int i=0; i&lt;size; i++) result += ret[i]; return result; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; auto n = ratings.size(); if(n==1) return 1; vector&lt;int&gt; v(n, 1); for(int i=1; i&lt;n; i++)&#123; if(ratings[i]&gt;ratings[i-1]) v[i] = v[i-1]+1; &#125; for(int i=n-2; i&gt;=0; i--)&#123; if(ratings[i]&gt;ratings[i+1]) v[i] = max(v[i], v[i+1]+1); &#125; int res = 0; for(int i=0; i&lt;n; i++) res += v[i]; return res; &#125;&#125;; https://discuss.leetcode.com/topic/5243/a-simple-solution A simple solution 1234567891011121314151617181920class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int size = ratings.size(); if(size&lt;=1) return size; vector&lt;int&gt; ret(size, 1); for(int i=1; i&lt;size; i++)&#123; if(ratings[i]&gt;ratings[i-1]) ret[i] = ret[i-1]+1; &#125; for(int i=size-1; i&gt;0; i--)&#123; if(ratings[i-1]&gt;ratings[i]) ret[i-1] = max(ret[i-1], ret[i]+1); &#125; int result = 0; for(int i=0; i&lt;size; i++) result += ret[i]; return result; &#125;&#125;; https://discuss.leetcode.com/topic/17722/two-c-solutions-given-with-explanation-both-with-o-n-time-one-with-o-1-space-the-other-with-o-n-space Two C++ solutions given with explanation (both with O(N) time, one with O(1) space, the other with O(N) space) The question requires us to make sure a child with a higher rate has more candies than its left and right neighbors. One simple solution is to do two scans: one foward scan (from 1 to N-1) to make sure child i has more candies than its left neighbor if its rate is higher than its left neighbor. After the forward scan, we can guarantee that the left neighbor relationship is correct but we have to do more to make the right neighbor relationship in order; so we do the backwarad scan (from N-2 to 0) to make child i has more candies than its right neighbor i+1 if its rate is higher than its right neighbor. In the following implementation, we need a O(N) array number to save the number of candies needed for children, so it has O(N) space complexity and we do two linear scans so the time complexity is O(N) 123456789101112131415161718192021class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int len = ratings.size(), res = 0, i; if(len&gt;0) &#123; vector&lt;int&gt; number(len,0); // to save the number of candies for child[0:N-1] number[0] = 1; // forward scan to calculate how many candies needed for child i to make sure it has more candies than its left neighbor if it has a higher rate, otherwise, give one candy to it for(i=1; i&lt;len;++i) number[i] = ratings[i]&gt;ratings[i-1]?number[i-1]+1:1;// backward scan to calculate to make sure child i has more candies than its right neighbor if it has a higher rate, pick the bigger one from forward and backward scans as the final number for child i for(i=len-2, res = number[len-1]; i&gt;=0;--i) &#123; if( (ratings[i]&gt;ratings[i+1]) &amp;&amp; number[i]&lt;(number[i+1]+1) ) number[i] = number[i+1]+1; res += number[i]; &#125; &#125; return res; &#125;&#125;; Now, the question is can we do better? Do we really need two scans? If we do only forward scan, then the problem is we can not guarantee the right neighbor relationship holds. i.e. we don’t know if the following order is descending (i&gt;i+1&gt;i+2&gt;…). and that may cause issues. To fix that, we will detect the dips (the points at which the order switchs from increasing to decreasng). We will make sure all the local dips (minimum points) has only one candy and update its previous neighbors (which has hgher rates than its rate) accordingly. To do such update, we need to know when the decrease starts, so we use pPos to save that starting points.So the solution becomes: do the forward scan, if it is in an increasing order (child i rate &gt; child i-1 order), check if it is a local dip (neg_peak == true): if so, update the candy number to make sure child i-1 has one candy. if not, just give one more candy to child i. If it is in an decreasing order (child i rate &lt; child i-1 order), just give one less candy to i. don’t forget at last, we still need to make sure child N-1 has one or more candy. So O(1) space , O(N) time 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; const int len = ratings.size(); if(len&lt;=1) return len; int i, pPos, res=1, peak=1; // peak: # candies given to the i-1 child bool neg_peak = false; // flag to indicate if it is a local dip for(i=1; i&lt;len;i++) &#123; if(ratings[i] &gt;= ratings[i-1]) &#123; // it is increasing if(neg_peak) &#123; // it is a local dip, we need to make sure i-1 has one candy res -= (peak-1) * (i-pPos - (peak&gt;0)); peak = 1; neg_peak = false; &#125; // update child i candy number, if equal, set to 1 peak = (ratings[i] == ratings[i-1])? 1:++peak; res += peak; &#125; else &#123; // decreasing, just give one less candy, if it is the starting point of a decrease, update pPos if(!neg_peak) &#123;pPos = i-1; neg_peak = true;&#125; res += --peak; &#125; &#125;// don&apos;t forget to update res, if the last one is a local dip return !neg_peak? res : res - (peak-1) * (i-pPos - (peak&gt;0)); &#125;&#125;; python https://discuss.leetcode.com/topic/21025/simple-python-solution-with-two-passes Simple python solution with two passes 1234567891011121314151617class Solution: # @param &#123;integer[]&#125; ratings # @return &#123;integer&#125; def candy(self, ratings): # use two pass scan from left to right and vice versa to keep the candy level up to now # similar to like the Trapping Rain Water question res = [1]*len(ratings) # also compatable with [] input lbase = rbase = 1 # left scan for i in xrange(1, len(ratings)): lbase = lbase + 1 if ratings[i] &gt; ratings[i-1] else 1 res[i] = lbase # right scan for i in xrange(len(ratings)-2, -1, -1): rbase = rbase + 1 if ratings[i] &gt; ratings[i+1] else 1 res[i] = max(rbase, res[i]) return sum(res) java https://discuss.leetcode.com/topic/25985/simple-o-n-java-solution-with-comments Simple O(n) Java solution with comments 12345678910111213141516public class Solution &#123; public int candy(int[] ratings) &#123; int candies[] = new int[ratings.length]; Arrays.fill(candies, 1); for(int i=1; i&lt;ratings.length; i++) if(ratings[i]&gt;ratings[i-1]) candies[i] = candies[i-1] + 1; for(int i=ratings.length-1; i&gt;0; i--) if(ratings[i-1]&gt;ratings[i]) candies[i-1] = Math.max(candies[i-1], candies[i]+1); int result = 0; for(int i=0; i&lt;ratings.length; i++) result += candies[i]; return result; &#125;&#125; 1234567891011121314151617public int candy(int[] ratings) &#123; int candies[] = new int[ratings.length]; Arrays.fill(candies, 1);// Give each child 1 candy for (int i = 1; i &lt; candies.length; i++)&#123;// Scan from left to right, to make sure right higher rated child gets 1 more candy than left lower rated child if (ratings[i] &gt; ratings[i - 1]) candies[i] = (candies[i - 1] + 1); &#125; for (int i = candies.length - 2; i &gt;= 0; i--) &#123;// Scan from right to left, to make sure left higher rated child gets 1 more candy than right lower rated child if (ratings[i] &gt; ratings[i + 1]) candies[i] = Math.max(candies[i], (candies[i + 1] + 1)); &#125; int sum = 0; for (int candy : candies) sum += candy; return sum;&#125; https://discuss.leetcode.com/topic/8208/one-pass-constant-space-java-solution One-pass constant space Java solution This solution picks each element from the input array only once. First, we give a candy to the first child. Then for each child we have three cases: His/her rating is equal to the previous one -&gt; give 1 candy. His/her rating is greater than the previous one -&gt; give him (previous + 1) candies. His/her rating is less than the previous one -&gt; don’t know what to do yet, let’s just count the number of such consequent cases. When we enter 1 or 2 condition we can check our count from 3. If it’s not zero then we know that we were descending before and we have everything to update our total candies amount: number of children in descending sequence of raitings - coundDown, number of candies given at peak - prev (we don’t update prev when descending). Total number of candies for “descending” children can be found through arithmetic progression formula (1+2+…+countDown). Plus we need to update our peak child if his number of candies is less then or equal to countDown. Here’s a pretty concise code below. 详情参考以下链接：http://www.allenlipeng47.com/blog/index.php/2016/07/21/candy/ But there is a O(n) time, O(1) space solution, which is pretty hard to understand. Let me try to explain this O(1) space solution.123456789101112131415161718192021222324252627public static int candy(int[] ratings) &#123; int pre = 1, countDown = 0, total = 1; for (int i = 1; i &lt; ratings.length; i++) &#123; if (ratings[i] &gt;= ratings[i - 1]) &#123; if (countDown &gt; 0) &#123; total += countDown * (countDown + 1) / 2; // progression part if (countDown &gt;= pre) &#123; // check if pre is tall enough total += countDown - pre + 1; &#125; pre = 1; // when ascending and there is countDown, prev should be 1 countDown = 0; &#125; pre = ratings[i] == ratings[i - 1] ? 1 : pre + 1; // when equals to previous one, set to 1. Else set to prev + 1 total += pre; &#125; else &#123; countDown++; &#125; &#125; if (countDown &gt; 0) &#123; // check if there is countDown in the end total += countDown * (countDown + 1) / 2; if (countDown &gt;= pre) &#123; total += countDown - pre + 1; &#125; &#125; return total;&#125; https://discuss.leetcode.com/topic/37924/very-simple-java-solution-with-detail-explanation Very Simple Java Solution with detail explanation 1We take ratings array as [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1] In the given problem each student will have at least 1 candy. So distribute 1 candy to each. 12ratings: [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]candies: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] Now traverse the array from left to right. If the rating of (n+1) child is greater than (n) child then set the candy of (n+1) child as one candy more than the (n) child candies. 12ratings: [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]candies: [1, 2, 1, 1, 2, 3, 4, 1, 1, 1, 2, 1] Now traverse the array from right to left. If the (n) child rating is more than (n+1) child and (n) child candies is less than one more than (n+1) child candies then update the candies of (n) child as 1+ (n+1) candies. 12ratings: [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]candies: [1, 2, 1, 1, 2, 3, 4, 3, 2, 1, 2, 1] Total minimum candies: 23 123456789101112131415161718192021222324252627282930public int candy(int[] ratings) &#123; int sum=0; int[] a=new int[ratings.length]; for(int i=0;i&lt;a.length;i++) &#123; a[i]=1; &#125; for(int i=0;i&lt;ratings.length-1;i++) &#123; if(ratings[i+1]&gt;ratings[i]) &#123; a[i+1]=a[i]+1; &#125; &#125; for(int i=ratings.length-1;i&gt;0;i--) &#123; if(ratings[i-1]&gt;ratings[i]) &#123; if(a[i-1]&lt;(a[i]+1)) &#123; a[i-1]=a[i]+1; &#125; &#125; &#125; for(int i=0;i&lt;a.length;i++) &#123; sum+=a[i]; &#125; return sum; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>greedy</tag>
        <tag>candy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[134. Gas Station]]></title>
    <url>%2Fp%2Fb124e3aa%2F</url>
    <content type="text"><![CDATA[29.3% https://leetcode.com/problems/gas-station/ There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1. Note: The solution is guaranteed to be unique. 具体原理及贪心算法还需要再思考 方法一： 我的代码实现: Oct 18，2017 1234567891011121314151617class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int start = gas.size()-1, end = 0; int sum = gas[start] - cost[start]; while(start&gt;end)&#123; if(sum&gt;=0)&#123; sum += gas[end] - cost[end]; end++; &#125;else&#123; start--; sum += gas[start] - cost[start]; &#125; &#125; return sum&gt;=0 ? start : -1; &#125;&#125;; My AC is O(1) space O(n) running time solution. Does anybody have posted this solution? I have got one solution to this problem. I am not sure whether somebody has already posted this solution. 1234567891011121314151617181920class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123; int start = gas.size()-1; int end = 0; int sum = gas[start] - cost[start]; // 注意此处初值的赋值 while (start &gt; end) &#123; if (sum &gt;= 0) &#123; sum += gas[end] - cost[end]; ++end; &#125; else &#123; --start; sum += gas[start] - cost[start]; &#125; &#125; return sum &gt;= 0 ? start : -1; &#125;&#125;; my code: 1234567891011121314151617181920class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int n = gas.size(), m = cost.size(); if(n!=m || m==n &amp;&amp; m==0) return -1; int start = n-1, end = 0; int cur_gas = gas[start]-cost[start]; while(end &lt;= start)&#123; if(cur_gas&gt;=0)&#123; cur_gas += gas[end] - cost[end]; end++; &#125; else&#123; start--; cur_gas += gas[start] - cost[start]; &#125; &#125; return cur_gas&gt;=0?start:-1; &#125;&#125;; cpp https://discuss.leetcode.com/topic/1344/share-some-of-my-ideas Share some of my ideas. I have thought for a long time and got two ideas: If car starts at A and can not reach B. Any station between A and B can not reach B.(B is the first station that A can not reach.) If the total number of gas is bigger than the total number of cost. There must be a solution. (Should I prove them?) Here is my solution based on those ideas: 123456789class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123; int start(0),total(0),tank(0); //if car fails at 'start', record the next station for(int i=0;i&lt;gas.size();i++) if((tank=tank+gas[i]-cost[i])&lt;0) &#123;start=i+1;total+=tank;tank=0;&#125; return (total+tank&lt;0)? -1:start; &#125;&#125;; https://discuss.leetcode.com/topic/5088/my-ac-is-o-1-space-o-n-running-time-solution-does-anybody-have-posted-this-solution My AC is O(1) space O(n) running time solution. Does anybody have posted this solution? I have got one solution to this problem. I am not sure whether somebody has already posted this solution. 1234567891011121314151617181920class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123; int start = gas.size()-1; int end = 0; int sum = gas[start] - cost[start]; while (start &gt; end) &#123; if (sum &gt;= 0) &#123; sum += gas[end] - cost[end]; ++end; &#125; else &#123; --start; sum += gas[start] - cost[start]; &#125; &#125; return sum &gt;= 0 ? start : -1; &#125;&#125;; https://discuss.leetcode.com/topic/39755/proof-of-if-total-gas-is-greater-than-total-cost-there-is-a-solution-c Proof of “if total gas is greater than total cost, there is a solution”. C++ We prove the following statement. If sum of all gas[i]-cost[i] is greater than or equal to 0, then there is a start position you can travel the whole circle.Let i be the index such that the the partial sum 1gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i] is the smallest, then the start position should be start=i+1 ( start=0 if i=n-1). Consider any other partial sum, for example, 1gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i]+gas[i+1]-cost[i+1] Since gas[0]-cost[0]+gas[1]-cost[1]+…+gas[i]-cost[i] is the smallest, we must have 1gas[i+1]-cost[i+1]&gt;=0 in order for gas[0]-cost[0]+gas[1]-cost[1]+…+gas[i]-cost[i]+gas[i+1]-cost[i+1] to be greater.The same reasoning gives that 1234gas[i+1]-cost[i+1]&gt;=0gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]&gt;=0.......gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]+...+gas[n-1]-cost[n-1]&gt;=0 What about for the partial sums that wraps around? 1234gas[0]-cost[0]+gas[1]-cost[1]+...+gas[j]-cost[j] + gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1]&gt;=gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i] + gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1]&gt;=0 The last inequality is due to the assumption that the entire sum of gas[k]-cost[k] is greater than or equal to 0.So we have that all the partial sums 123456gas[i+1]-cost[i+1]&gt;=0,gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]&gt;=0,gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]+...+gas[n-1]-cost[n-1]&gt;=0,...gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1] + gas[0]-cost[0]+gas[1]-cost[1]+...+gas[j]-cost[j]&gt;=0,... Thus i+1 is the position to start. Coding using this reasoning is as follows: 123456789101112131415class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int n = gas.size(); int total(0), subsum(INT_MAX), start(0); for(int i = 0; i &lt; n; ++i)&#123; total += gas[i] - cost[i]; if(total &lt; subsum) &#123; subsum = total; start = i + 1; &#125; &#125; return (total &lt; 0) ? -1 : (start%n); &#125;&#125;; https://discuss.leetcode.com/topic/8860/fully-commented-o-n-c-solution-enabled-by-a-single-observation-of-mine Fully-commented O(n) C++ solution enabled by a single observation of mine 123456789101112131415161718192021222324252627class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123; int i, j, n = gas.size(); /* * If start from i, stop before station x -&gt; no station k from i + 1 to x - 1 can reach x. * Bcoz if so, i can reach k and k can reach x, then i reaches x. Contradiction. * Thus i can jump directly to x instead of i + 1, bringing complexity from O(n^2) to O(n). */ // start from station i for (i = 0; i &lt; n; i += j) &#123; int gas_left = 0; // forward j stations for (j = 1; j &lt;= n; j++) &#123; int k = (i + j - 1) % n; gas_left += gas[k] - cost[k]; if (gas_left &lt; 0) break; &#125; if (j &gt; n) return i; &#125; return -1; &#125;&#125;; https://discuss.leetcode.com/topic/29487/my-one-pass-solution My one pass solution. 123456789101112131415161718class Solution &#123;public:int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int size=gas.size(); int sum=0; int res=0; int total=0; for(int i=0; i&lt;size; ++i)&#123; sum+=gas[i]-cost[i]; if(sum&lt;0)&#123; total+=sum; sum=0; res=i+1; &#125; &#125; total+=sum; return total&lt;0?-1:res;&#125;&#125;; The idea is simple. Whenever the sum is negative, reset it and let the car start from next point. In the mean time, add up all of the left gas to total. If it’s negative finally, return -1 since it’s impossible to finish. If it’s non-negative, return the last point saved in res; https://discuss.leetcode.com/topic/5088/my-ac-is-o-1-space-o-n-running-time-solution-does-anybody-have-posted-this-solution 6ms, September 20, 2016 12345678910111213141516171819class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int start = gas.size() - 1; int end = 0; int sum = gas[start] - cost[start]; while(start &gt; end)&#123; if(sum &gt;= 0)&#123; sum += gas[end] - cost[end]; ++end; &#125; else&#123; --start; sum += gas[start] - cost[start]; &#125; &#125; return sum &gt;= 0 ? start : -1; &#125;&#125;; python https://discuss.leetcode.com/topic/27760/possibly-the-most-easiest-approach-o-n-one-variable-python 55ms, 32.89%, September 20, 2016 解析：sum（gas）&gt;= sum（gas），能保证存在一个位置，可以作为起点。如果从位置position开始进行旅行，这一段到某一点没有油了，则以position为起点的这一段肯定不存在作为起点的位置，否则走不完这一段，所以postion设为从下一个位置开始，其他的类似。my code的思想类似，不过是移动起点和终点的位置，如果小于0，起点向前移动，如果大于0，则起点向后移动。1234567891011121314151617class Solution(object): def canCompleteCircuit(self, gas, cost): &quot;&quot;&quot; :type gas: List[int] :type cost: List[int] :rtype: int &quot;&quot;&quot; if len(gas) == 0 or len(cost) == 0 or sum(gas) &lt; sum(cost): return -1 position = 0 balance = 0 for i in range(len(gas)): balance += gas[i] - cost[i] if balance &lt; 0: balance = 0 position = i+1 return position my code 1234567891011121314151617class Solution(object): def canCompleteCircuit(self, gas, cost): &quot;&quot;&quot; :type gas: List[int] :type cost: List[int] :rtype: int &quot;&quot;&quot; start, end = len(gas)-1, 0 cur = gas[start]-cost[start] while end&lt;start: if cur&lt;0: start -= 1 cur += gas[start] - cost[start] else: cur += gas[end] - cost[end] end += 1 return start if cur&gt;=0 else -1 java https://discuss.leetcode.com/topic/7247/my-o-n-time-o-1-extra-space-solution My O(N) time, O(1) extra space solution. 1234567891011121314151617181920public class Solution &#123;public int canCompleteCircuit(int[] gas, int[] cost) &#123; for(int i = 0; i &lt; gas.length; i++) &#123; gas[i] -= cost[i]; &#125; int sum = 0; int result = 0; int n = gas.length; for(int i = 0; i &lt; n * 2 - 1; i++) &#123; sum += gas[i % n]; if(sum &lt; 0) &#123; result = i + 1; if(result &gt;= n) &#123; return -1; &#125; sum = 0; &#125; &#125; return result;&#125; https://discuss.leetcode.com/topic/25289/straightforward-java-linear-solution-with-o-1-space-explanation-and-math-proof Straightforward Java Linear Solution with O(1) space, explanation and Math proof The algorithm is pretty easy to understand. Imagine we take a tour around this circle, the only condition that we can complete this trip is to have more fuel provided than costed in total. That’s what the first loop does. If we do have more fuel provided than costed, that means we can always find a start point around this circle that we could complete the journey with an empty tank. Hence, we check from the beginning of the array, if we can gain more fuel at the current station, we will maintain the start point, else, which means we will burn out of oil before reaching to the next station, we will start over at the next station. 1234567891011121314151617181920public int canCompleteCircuit(int[] gas, int[] cost) &#123; int tank = 0; for(int i = 0; i &lt; gas.length; i++) tank += gas[i] - cost[i]; if(tank &lt; 0) return - 1; int start = 0; int accumulate = 0; for(int i = 0; i &lt; gas.length; i++)&#123; int curGain = gas[i] - cost[i]; if(accumulate + curGain &lt; 0)&#123; start = i + 1; accumulate = 0; &#125; else accumulate += curGain; &#125; return start;&#125; https://discuss.leetcode.com/topic/25990/simple-o-n-java-solution-with-comments 1ms, September 20, 2016 123456789101112131415public class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int total = 0, tank = 0, index = 0; for(int i=0; i&lt;cost.length; i++)&#123; int cur = gas[i] - cost[i]; tank += cur; if(tank&lt;0)&#123; index = i+1; tank = 0; &#125; total += cur; &#125; return total &lt; 0 ? -1:index; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[132. Palindrome Partitioning II]]></title>
    <url>%2Fp%2Fc5f750e%2F</url>
    <content type="text"><![CDATA[23.7% https://leetcode.com/problems/palindrome-partitioning-ii/#/description Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. 12For example, given s = &quot;aab&quot;,Return 1 since the palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut. 13ms, September 22, 2016 https://discuss.leetcode.com/topic/2840/my-solution-does-not-need-a-table-for-palindrome-is-it-right-it-uses-only-o-n-space My solution does not need a table for palindrome, is it right ? It uses only O(n) space. 12345678910111213141516class Solution &#123;public: int minCut(string s) &#123; int n = s.size(); vector&lt;int&gt; cut(n+1, 0); // number of cuts for the first k characters for (int i = 0; i &lt;= n; i++) cut[i] = i-1; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; i-j &gt;= 0 &amp;&amp; i+j &lt; n &amp;&amp; s[i-j]==s[i+j] ; j++) // odd length palindrome cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]); for (int j = 1; i-j+1 &gt;= 0 &amp;&amp; i+j &lt; n &amp;&amp; s[i-j+1] == s[i+j]; j++) // even length palindrome cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]); &#125; return cut[n]; &#125;&#125;; https://discuss.leetcode.com/topic/2048/my-dp-solution-explanation-and-code My DP Solution ( explanation and code) Calculate and maintain 2 DP states: pal[i][j] , which is whether s[i..j] forms a pal d[i], which is the minCut for s[i..n-1] Once we comes to a pal[i][j]==true: if j==n-1, the string s[i..n-1] is a Pal, minCut is 0, d[i]=0; else: the current cut num (first cut s[i..j] and then cut the rest s[j+1…n-1]) is 1+d[j+1], compare it to the exisiting minCut num d[i], repalce if smaller. d[0] is the answer. 12345678910111213141516171819202122232425class Solution &#123; public: int minCut(string s) &#123; if(s.empty()) return 0; int n = s.size(); vector&lt;vector&lt;bool&gt;&gt; pal(n,vector&lt;bool&gt;(n,false)); vector&lt;int&gt; d(n); for(int i=n-1;i&gt;=0;i--) &#123; d[i]=n-i-1; for(int j=i;j&lt;n;j++) &#123; if(s[i]==s[j] &amp;&amp; (j-i&lt;2 || pal[i+1][j-1])) &#123; pal[i][j]=true; if(j==n-1) d[i]=0; else if(d[j+1]+1&lt;d[i]) d[i]=d[j+1]+1; &#125; &#125; &#125; return d[0]; &#125; &#125;; https://discuss.leetcode.com/topic/19298/two-c-versions-given-one-dp-28ms-one-manancher-like-algorithm-10-ms Two C++ versions given (one DP 28ms, one Manancher-like algorithm 10 ms) One typical solution is DP based. Such solution first constructs a two-dimensional bool array isPalin to indicate whether the sub-string s[i..j] is palindrome. To get such array, we need O(N^2) time complexity. Moreover, to get the minimum cuts, we need another array minCuts to do DP and minCuts[i] saves the minimum cuts found for the sub-string s[0..i-1]. minCuts[i] is initialized to i-1, which is the maximum cuts needed (cuts the string into one-letter characters) and minCuts[0] initially sets to -1, which is needed in the case that s[0..i-1] is a palindrome. When we construct isPalin array, we update minCuts everytime we found a palindrome sub-string, i.e. if s[i..j] is a palindrome, then minCuts[j+1] will be updated to the minimum of the current minCuts[j+1] and minCut[i]+1(i.e. cut s[0..j] into s[0,i-1] and s[i,j]). At last, we return minCuts[N].So the complexity is O(N^2). However, it can be further improved since as described above, we only update minCuts when we find a palindrome substring, while the DP algorithm spends lots of time to calculate isPalin, most of which is false (i.e. not a palindrome substring). If we can reduce such unnecessary calculation, then we can speed up the algorithm. This can be achieved with a Manancher-like solution, which is also given as following. 123456789101112131415161718192021222324252627// DP solutionclass Solution &#123;public: int minCut(string s) &#123; const int N = s.size(); if(N&lt;=1) return 0; int i,j; bool isPalin[N][N]; fill_n(&amp;isPalin[0][0], N*N, false); int minCuts[N+1]; for(i=0; i&lt;=N; ++i) minCuts[i] = i-1; for(j=1; j&lt;N; ++j) &#123; for(i=j; i&gt;=0; --i) &#123; if( (s[i] == s[j]) &amp;&amp; ( ( j-i &lt; 2 ) || isPalin[i+1][j-1] ) ) &#123; isPalin[i][j] = true; minCuts[j+1] = min(minCuts[j+1], 1 + minCuts[i]); &#125; &#125; &#125; return minCuts[N]; &#125;&#125;; The Manancher-like solution scan the array from left to right (for i loop) and only check those sub-strings centered at s[i]; once a non-palindrome string is found, it will stop and move to i+1. Same as the DP solution, minCUTS[i] is used to save the minimum cuts for s[0:i-1]. For each i, we do two for loops (for j loop) to check if the substrings s[i-j .. i+j] (odd-length substring) and s[i-j-1.. i+j] (even-length substring) are palindrome. By increasing j from 0, we can find all the palindrome sub-strings centered at i and update minCUTS accordingly. Once we meet one non-palindrome sub-string, we stop for-j loop since we know there no further palindrome substring centered at i. This helps us avoid unnecessary palindrome substring checks, as we did in the DP algorithm. Therefore, this version is faster. 123456789101112131415161718192021//Manancher-like solutionclass Solution &#123;public: int minCut(string s) &#123; const int N = s.size(); if(N&lt;=1) return 0; int i, j, minCUTS[N+1]; for(i=0; i&lt;=N; ++i) minCUTS[i] = i-1; for(i=1;i&lt;N;i++) &#123; for(j=0;(i-j)&gt;=0 &amp;&amp; (i+j)&lt;N &amp;&amp; s[i-j]== s[i+j]; ++j) // odd-length substrings minCUTS[i+j+1] = min(minCUTS[i+j+1], 1 + minCUTS[i-j]); for(j=0;(i-j-1)&gt;=0 &amp;&amp; (i+j)&lt;N &amp;&amp; s[i-j-1]== s[i+j]; ++j) // even-length substrings minCUTS[i+j+1] = min(minCUTS[i+j+1], 1 + minCUTS[i-j-1]); &#125; return minCUTS[N]; &#125;&#125;; https://discuss.leetcode.com/topic/22388/56-ms-python-with-explanation 56 ms python with explanation Algorithm (460 ms) credits go to: https://leetcode.com/discuss/9476/solution-does-not-need-table-palindrome-right-uses-only-space The main algorithm idea is if s[i,j] is a palindrome, then the minCut(s[:j]) is at most minCut(s[:i-1])+1. This literally needs to find out all possible palindromes in the list. The above post provides an efficient search algorithm. O(n) space and O(n^2) time complexity. Further acceleration (460 ms -&gt; 56 ms) credits go to: https://leetcode.com/discuss/43950/python-100ms-extra-dealing-super-cases-reduces-576ms-100ms The main idea for acceleration is to quickly check and exclude a few long palindrome tests.. 1234567891011121314151617181920def minCut(self, s): # acceleration if s == s[::-1]: return 0 for i in range(1, len(s)): if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]: return 1 # algorithm cut = [x for x in range(-1,len(s))] # cut numbers in worst case (no palindrome) for i in range(len(s)): r1, r2 = 0, 0 # use i as origin, and gradually enlarge radius if a palindrome exists # odd palindrome while i-r1 &gt;= 0 and i+r1 &lt; len(s) and s[i-r1] == s[i+r1]: cut[i+r1+1] = min(cut[i+r1+1], cut[i-r1]+1) r1 += 1 # even palindrome while i-r2 &gt;= 0 and i+r2+1 &lt; len(s) and s[i-r2] == s[i+r2+1]: cut[i+r2+2] = min(cut[i+r2+2], cut[i-r2]+1) r2 += 1 return cut[-1] The following code simply implements the algorithm without any optimization (1800 ms), and should be easier to understand. O(n) space and O(n^3) time complexity. 1234567def minCut(self, s): cut = [x for x in range(-1,len(s))] for i in range(0,len(s)): for j in range(i,len(s)): if s[i:j] == s[j:i:-1]: cut[j+1] = min(cut[j+1],cut[i]+1) return cut[-1] https://discuss.leetcode.com/topic/32575/easiest-java-dp-solution-97-36 Easiest Java DP Solution (97.36%) This can be solved by two points: cut[i] is the minimum of cut[j - 1] + 1 (j &lt;= i), if [j, i] is palindrome. If [j, i] is palindrome, [j + 1, i - 1] is palindrome, and c[j] == c[i]. The 2nd point reminds us of using dp (caching). 1234a b a | c c j i j-1 | [j, i] is palindrome cut(j-1) + 1 Hope it helps! 123456789101112131415161718public int minCut(String s) &#123; char[] c = s.toCharArray(); int n = c.length; int[] cut = new int[n]; boolean[][] pal = new boolean[n][n]; for(int i = 0; i &lt; n; i++) &#123; int min = i; for(int j = 0; j &lt;= i; j++) &#123; if(c[j] == c[i] &amp;&amp; (j + 1 &gt; i - 1 || pal[j + 1][i - 1])) &#123; pal[j][i] = true; min = j == 0 ? 0 : Math.min(min, cut[j - 1] + 1); &#125; &#125; cut[i] = min; &#125; return cut[n - 1];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[131. Palindrome Partitioning]]></title>
    <url>%2Fp%2F505b452c%2F</url>
    <content type="text"><![CDATA[31.6% https://leetcode.com/problems/palindrome-partitioning/#/description Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. 1234567For example, given s = &quot;aab&quot;,Return[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] https://discuss.leetcode.com/topic/10955/clean-c-backtracking-solution Clean C++ backtracking solution The Idea is simple: loop through the string, check if substr(0, i) is palindrome. If it is, recursively call dfs() on the rest of sub string: substr(i+1, length). keep the current palindrome partition so far in the ‘path’ argument of dfs(). When reaching the end of string, add current partition in the result. 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt; &gt; ret; if(s.empty()) return ret; vector&lt;string&gt; path; dfs(0, s, path, ret); return ret; &#125; void dfs(int index, string&amp; s, vector&lt;string&gt;&amp; path, vector&lt;vector&lt;string&gt; &gt;&amp; ret) &#123; if(index == s.size()) &#123; ret.push_back(path); return; &#125; for(int i = index; i &lt; s.size(); ++i) &#123; if(isPalindrome(s, index, i)) &#123; path.push_back(s.substr(index, i - index + 1)); dfs(i+1, s, path, ret); path.pop_back(); &#125; &#125; &#125; bool isPalindrome(const string&amp; s, int start, int end) &#123; while(start &lt;= end) &#123; if(s[start++] != s[end--]) return false; &#125; return true; &#125;&#125;; https://discuss.leetcode.com/topic/15432/12ms-14-lines-c 12ms 14-lines C++ The problem has a nice structure that backtracking naturally fits in. The structure is, given a starting position idx, we search from idx till the end of the string s.length() - 1. Once we reach a position i such that the sub-string from idx to i (s.substr(idx, i - idx + 1)) is a palindrome, we add it to a temporary tmp. Then we recursively call the same function to process the remaining sub-string. Once we reach the end of the string, we add tmp into the result res of all the possible partitioning. Then, backtracking happens! Remember that at position i, we find s.substr(idx, i - idx + 1) to be a palindrome and we immediately add it to tmp. It is obvious that there may be some position j such that j &gt; i and s.substr(idx, j - idx + 1) is also a palindrome. So we need to recover to the state before adding s.substr(idx, i - idx + 1) to tmp and continue to find the next palindrome position after i. And we simply need to pop s.substr(idx, i - idx + 1) out of tmp to make things work. Putting these together, we can write down the following code, which should be self-explanatory. 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; tmp; getPartition(s, 0, tmp, res); return res; &#125;private: void getPartition(string&amp; s, int idx, vector&lt;string&gt;&amp; tmp, vector&lt;vector&lt;string&gt;&gt;&amp; res) &#123; if (idx == s.length()) &#123; res.push_back(tmp); return; &#125; for (int i = idx, n = s.length(); i &lt; n; i++) &#123; int l = idx, r = i; while (l &lt; r &amp;&amp; s[l] == s[r]) l++, r--; if (l &gt;= r) &#123; tmp.push_back(s.substr(idx, i - idx + 1)); getPartition(s, i + 1, tmp, res); tmp.pop_back(); &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/19370/1-liner-python-ruby 1-liner Python, Ruby Python: Broken into several physical lines for readability, but still one logical line and just one simple statement. 12345def partition(self, s): return [[s[:i]] + rest for i in xrange(1, len(s)+1) if s[:i] == s[i-1::-1] for rest in self.partition(s[i:])] or [[]] https://discuss.leetcode.com/topic/33425/python-recursive-iterative-backtracking-solution Python recursive/iterative backtracking solution Inspired by caikehe’s solution: 123456789101112131415def partition(self, s): res = [] self.dfs(s, [], res) return resdef dfs(self, s, path, res): if not s: res.append(path) return for i in range(1, len(s)+1): if self.isPal(s[:i]): self.dfs(s[i:], path+[s[:i]], res) def isPal(self, s): return s == s[::-1] https://discuss.leetcode.com/topic/6186/java-backtracking-solution Java: Backtracking solution. if the input is “aab”, check if [0,0] “a” is palindrome. then check [0,1] “aa”, then [0,2] “aab”.While checking [0,0], the rest of string is “ab”, use ab as input to make a recursive call. in this example, in the loop of i=l+1, a recursive call will be made with input = “ab”.Every time a recursive call is made, the position of l move right. How to define a correct answer? Think about DFS, if the current string to be checked (Palindrome) contains the last position, in this case “c”, this path is a correct answer, otherwise, it’s a false answer. line 13: is the boundary to check if the current string contains the last element.l&gt;=s.length() 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; List&lt;List&lt;String&gt;&gt; resultLst; ArrayList&lt;String&gt; currLst; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; resultLst = new ArrayList&lt;List&lt;String&gt;&gt;(); currLst = new ArrayList&lt;String&gt;(); backTrack(s,0); return resultLst; &#125; public void backTrack(String s, int l)&#123; if(currLst.size()&gt;0 //the initial str could be palindrome &amp;&amp; l&gt;=s.length())&#123; List&lt;String&gt; r = (ArrayList&lt;String&gt;) currLst.clone(); resultLst.add(r); &#125; for(int i=l;i&lt;s.length();i++)&#123; if(isPalindrome(s,l,i))&#123; if(l==i) currLst.add(Character.toString(s.charAt(i))); else currLst.add(s.substring(l,i+1)); backTrack(s,i+1); currLst.remove(currLst.size()-1); &#125; &#125; &#125; public boolean isPalindrome(String str, int l, int r)&#123; if(l==r) return true; while(l&lt;r)&#123; if(str.charAt(l)!=str.charAt(r)) return false; l++;r--; &#125; return true; &#125;&#125; https://discuss.leetcode.com/topic/2884/my-java-dp-only-solution-without-recursion-o-n-2 My Java DP only solution without recursion. O(n^2) 12345678910111213141516171819202122232425public class Solution &#123; public static List&lt;List&lt;String&gt;&gt; partition(String s) &#123; int len = s.length(); List&lt;List&lt;String&gt;&gt;[] result = new List[len + 1]; result[0] = new ArrayList&lt;List&lt;String&gt;&gt;(); result[0].add(new ArrayList&lt;String&gt;()); boolean[][] pair = new boolean[len][len]; for (int i = 0; i &lt; s.length(); i++) &#123; result[i + 1] = new ArrayList&lt;List&lt;String&gt;&gt;(); for (int left = 0; left &lt;= i; left++) &#123; if (s.charAt(left) == s.charAt(i) &amp;&amp; (i-left &lt;= 1 || pair[left + 1][i - 1])) &#123; pair[left][i] = true; String str = s.substring(left, i + 1); for (List&lt;String&gt; r : result[left]) &#123; List&lt;String&gt; ri = new ArrayList&lt;String&gt;(r); ri.add(str); result[i + 1].add(ri); &#125; &#125; &#125; &#125; return result[len]; &#125;&#125; Here the pair is to mark a range for the substring is a Pal. if pair[i][j] is true, that means sub string from i to j is pal. The result[i], is to store from beginng until current index i (Non inclusive), all possible partitions. From the past result we can determine current result. https://discuss.leetcode.com/topic/37756/java-dp-dfs-solution Java DP + DFS solution The normal dfs backtracking will need to check each substring for palindrome, but a dp array can be used to record the possible break for palindrome before we start recursion. Edit: Sharing my thought process: first, I ask myself that how to check if a string is palindrome or not, usually a two point solution scanning from front and back. Here if you want to get all the possible palindrome partition, first a nested for loop to get every possible partitions for a string, then a scanning for all the partitions. That’s a O(n^2) for partition and O(n^2) for the scanning of string, totaling at O(n^4) just for the partition. However, if we use a 2d array to keep track of any string we have scanned so far, with an addition pair, we can determine whether it’s palindrome or not by justing looking at that pair, which is this line if(s.charAt(i) == s.charAt(j) &amp;&amp; (i - j &lt;= 2 || dp[j+1][i-1])). This way, the 2d array dp contains the possible palindrome partition among all. second, based on the prescanned palindrome partitions saved in dp array, a simple backtrack does the job. 123456789101112131415161718192021222324252627282930public class Solution &#123; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); boolean[][] dp = new boolean[s.length()][s.length()]; for(int i = 0; i &lt; s.length(); i++) &#123; for(int j = 0; j &lt;= i; j++) &#123; if(s.charAt(i) == s.charAt(j) &amp;&amp; (i - j &lt;= 2 || dp[j+1][i-1])) &#123; dp[j][i] = true; &#125; &#125; &#125; helper(res, new ArrayList&lt;&gt;(), dp, s, 0); return res; &#125; private void helper(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; path, boolean[][] dp, String s, int pos) &#123; if(pos == s.length()) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i = pos; i &lt; s.length(); i++) &#123; if(dp[pos][i]) &#123; path.add(s.substring(pos,i+1)); helper(res, path, dp, s, i+1); path.remove(path.size()-1); &#125; &#125; &#125;&#125; 回溯法 https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/2 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list; &#125; public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125; &#125; public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[130. Surrounded Regions]]></title>
    <url>%2Fp%2F702b0957%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/surrounded-regions/?tab=Description Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’. A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region. 1234567891011For example,X X X XX O O XX X O XX O X XAfter running your function, the board should be:X X X XX X X XX X X XX O X X cpp23ms, 32.42%, October 14, 2016 https://discuss.leetcode.com/topic/17224/a-really-simple-and-readable-c-solution-only-cost-12ms A really simple and readable C++ solution，only cost 12ms First, check the four border of the matrix. If there is a element is ‘O’, alter it and all its neighbor ‘O’ elements to ‘1’. Then ,alter all the ‘O’ to ‘X’ At last,alter all the ‘1’ to ‘O’ 123456For example: X X X X X X X X X X X X X X O X -&gt; X X O X -&gt; X X X X X O X X X 1 X X X O X X X O X X X 1 X X X O X X 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int i, j; int row = board.size(); if(!row) return; int col = board[0].size(); for(i=0; i&lt;row; i++)&#123; check(board, i, 0, row, col); if(col&gt;1) check(board, i, col-1, row, col); &#125; for(j=1; j+1&lt;col; j++)&#123; check(board, 0, j, row, col); if(row&gt;1) check(board, row-1, j, row, col); &#125; for(i=0; i&lt;row; i++) for(j=0; j&lt;col; j++) if(board[i][j]==&apos;O&apos;) board[i][j] = &apos;X&apos;; for(i=0; i&lt;row; i++) for(j=0; j&lt;col; j++) if(board[i][j] == &apos;1&apos;) board[i][j] = &apos;O&apos;; &#125; void check(vector&lt;vector&lt;char&gt;&gt; &amp;vec, int i, int j, int row, int col)&#123; if(vec[i][j] == &apos;O&apos;)&#123; vec[i][j] = &apos;1&apos;; if(i&gt;1) check(vec, i-1, j, row, col); if(j&gt;1) check(vec, i, j-1, row, col); if(i+1&lt;row) check(vec, i+1, j, row, col); if(j+1&lt;col) check(vec, i, j+1, row, col); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/1944/solve-it-using-union-find Solve it using Union Find 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class UF&#123;private: int* id; // id[i] = parent of i int* rank; // rank[i] = rank of subtree rooted at i (cannot be more than 31) int count; // number of componentspublic: UF(int N) &#123; count = N; id = new int[N]; rank = new int[N]; for (int i = 0; i &lt; N; i++) &#123; id[i] = i; rank[i] = 0; &#125; &#125; ~UF() &#123; delete [] id; delete [] rank; &#125; int find(int p) &#123; while (p != id[p]) &#123; id[p] = id[id[p]]; // path compression by halving p = id[p]; &#125; return p; &#125; int getCount() &#123; return count; &#125; bool connected(int p, int q) &#123; return find(p) == find(q); &#125; void connect(int p, int q) &#123; int i = find(p); int j = find(q); if (i == j) return; if (rank[i] &lt; rank[j]) id[i] = j; else if (rank[i] &gt; rank[j]) id[j] = i; else &#123; id[j] = i; rank[i]++; &#125; count--; &#125;&#125;;class Solution &#123;public: void solve(vector&lt;vector&lt;char&gt;&gt; &amp;board) &#123; int n = board.size(); if(n==0) return; int m = board[0].size(); UF uf = UF(n*m+1); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if((i==0||i==n-1||j==0||j==m-1)&amp;&amp;board[i][j]==&apos;O&apos;) // if a &apos;O&apos; node is on the boundry, connect it to the dummy node uf.connect(i*m+j,n*m); else if(board[i][j]==&apos;O&apos;) // connect a &apos;O&apos; node to its neighbour &apos;O&apos; nodes &#123; if(board[i-1][j]==&apos;O&apos;) uf.connect(i*m+j,(i-1)*m+j); if(board[i+1][j]==&apos;O&apos;) uf.connect(i*m+j,(i+1)*m+j); if(board[i][j-1]==&apos;O&apos;) uf.connect(i*m+j,i*m+j-1); if(board[i][j+1]==&apos;O&apos;) uf.connect(i*m+j,i*m+j+1); &#125; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(!uf.connected(i*m+j,n*m))&#123; // if a &apos;O&apos; node is not connected to the dummy node, it is captured board[i][j]=&apos;X&apos;; &#125; &#125; &#125; &#125;&#125;; Hi. So here is my accepted code using Union Find data structure. The idea comes from the observation that if a region is NOT captured, it is connected to the boundry. So if we connect all the ‘O’ nodes on the boundry to a dummy node, and then connect each ‘O’ node to its neighbour ‘O’ nodes, then we can tell directly whether a ‘O’ node is captured by checking whether it is connected to the dummy node. For more about Union Find, the first assignment in the algo1 may help: https://www.coursera.org/course/algs4partI https://discuss.leetcode.com/topic/1944/solve-it-using-union-find/2 just another version in java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123; int[] unionSet; // union find set boolean[] hasEdgeO; // whether an union has an &apos;O&apos; which is on the edge of the matrix public void solve(char[][] board) &#123; if(board.length == 0 || board[0].length == 0) return; // init, every char itself is an union int height = board.length, width = board[0].length; unionSet = new int[height * width]; hasEdgeO = new boolean[unionSet.length]; for(int i = 0;i&lt;unionSet.length; i++) unionSet[i] = i; for(int i = 0;i&lt;hasEdgeO.length; i++)&#123; int x = i / width, y = i % width; hasEdgeO[i] = (board[x][y] == &apos;O&apos; &amp;&amp; (x==0 || x==height-1 || y==0 || y==width-1)); &#125; // iterate the matrix, for each char, union it + its upper char + its right char if they equals to each other for(int i = 0;i&lt;unionSet.length; i++)&#123; int x = i / width, y = i % width, up = x - 1, right = y + 1; if(up &gt;= 0 &amp;&amp; board[x][y] == board[up][y]) union(i,i-width); if(right &lt; width &amp;&amp; board[x][y] == board[x][right]) union(i,i+1); &#125; // for each char in the matrix, if it is an &apos;O&apos; and its union doesn&apos;t has an &apos;edge O&apos;, the whole union should be setted as &apos;X&apos; for(int i = 0;i&lt;unionSet.length; i++)&#123; int x = i / width, y = i % width; if(board[x][y] == &apos;O&apos; &amp;&amp; !hasEdgeO[findSet(i)]) board[x][y] = &apos;X&apos;; &#125; &#125; private void union(int x,int y)&#123; int rootX = findSet(x); int rootY = findSet(y); // if there is an union has an &apos;edge O&apos;,the union after merge should be marked too boolean hasEdgeO = this.hasEdgeO[rootX] || this.hasEdgeO[rootY]; unionSet[rootX] = rootY; this.hasEdgeO[rootY] = hasEdgeO; &#125; private int findSet(int x)&#123; if(unionSet[x] == x) return x; unionSet[x] = findSet(unionSet[x]); return unionSet[x]; &#125;&#125; https://discuss.leetcode.com/topic/18706/9-lines-python-148-ms 9 lines, Python 148 ms Phase 1: “Save” every O-region touching the border, changing its cells to ‘S’. Phase 2: Change every ‘S’ on the board to ‘O’ and everything else to ‘X’. 123456789101112def solve(self, board): if not any(board): return m, n = len(board), len(board[0]) save = [ij for k in range(m+n) for ij in ((0, k), (m-1, k), (k, 0), (k, n-1))] while save: i, j = save.pop() if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and board[i][j] == &apos;O&apos;: board[i][j] = &apos;S&apos; save += (i, j-1), (i, j+1), (i-1, j), (i+1, j) board[:] = [[&apos;XO&apos;[c == &apos;S&apos;] for c in row] for row in board] In case you don’t like my last line, you could do this instead: 123for row in board: for i, c in enumerate(row): row[i] = &apos;XO&apos;[c == &apos;S&apos;] https://discuss.leetcode.com/topic/2982/my-bfs-solution-c-28ms My BFS solution (C++ 28ms) The algorithm is quite simple: Use BFS starting from ‘O’s on the boundary and mark them as ‘B’, then iterate over the whole board and mark ‘O’ as ‘X’ and ‘B’ as ‘O’. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void bfsBoundary(vector&lt;vector&lt;char&gt; &gt;&amp; board, int w, int l)&#123; int width = board.size(); int length = board[0].size(); deque&lt;pair&lt;int, int&gt; &gt; q; q.push_back(make_pair(w, l)); board[w][l] = &apos;B&apos;; while (!q.empty()) &#123; pair&lt;int, int&gt; cur = q.front(); q.pop_front(); pair&lt;int, int&gt; adjs[4] = &#123;&#123;cur.first-1, cur.second&#125;, &#123;cur.first+1, cur.second&#125;, &#123;cur.first, cur.second-1&#125;, &#123;cur.first, cur.second+1&#125;&#125;; for (int i = 0; i &lt; 4; ++i) &#123; int adjW = adjs[i].first; int adjL = adjs[i].second; if ((adjW &gt;= 0) &amp;&amp; (adjW &lt; width) &amp;&amp; (adjL &gt;= 0) &amp;&amp; (adjL &lt; length) &amp;&amp; (board[adjW][adjL] == &apos;O&apos;)) &#123; q.push_back(make_pair(adjW, adjL)); board[adjW][adjL] = &apos;B&apos;; &#125; &#125; &#125;&#125;void solve(vector&lt;vector&lt;char&gt; &gt; &amp;board) &#123; int width = board.size(); if (width == 0) //Add this to prevent run-time error! return; int length = board[0].size(); if (length == 0) // Add this to prevent run-time error! return; for (int i = 0; i &lt; length; ++i) &#123; if (board[0][i] == &apos;O&apos;) bfsBoundary(board, 0, i); if (board[width-1][i] == &apos;O&apos;) bfsBoundary(board, width-1, i); &#125; for (int i = 0; i &lt; width; ++i) &#123; if (board[i][0] == &apos;O&apos;) bfsBoundary(board, i, 0); if (board[i][length-1] == &apos;O&apos;) bfsBoundary(board, i, length-1); &#125; for (int i = 0; i &lt; width; ++i) &#123; for (int j = 0; j &lt; length; ++j) &#123; if (board[i][j] == &apos;O&apos;) board[i][j] = &apos;X&apos;; else if (board[i][j] == &apos;B&apos;) board[i][j] = &apos;O&apos;; &#125; &#125;&#125; Note that one of the test cases is when the board is empty. So if you don’t check it in your code, you will encounter an run-time error. https://discuss.leetcode.com/topic/25010/java-dfs-boundary-cell-turning-solution-simple-and-clean-code-commented Java DFS + boundary cell turning solution, simple and clean code, commented. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void solve(char[][] board) &#123; if (board.length == 0 || board[0].length == 0) return; if (board.length &lt; 2 || board[0].length &lt; 2) return; int m = board.length, n = board[0].length; //Any &apos;O&apos; connected to a boundary can&apos;t be turned to &apos;X&apos;, so ... //Start from first and last column, turn &apos;O&apos; to &apos;*&apos;. for (int i = 0; i &lt; m; i++) &#123; if (board[i][0] == &apos;O&apos;) boundaryDFS(board, i, 0); if (board[i][n-1] == &apos;O&apos;) boundaryDFS(board, i, n-1); &#125; //Start from first and last row, turn &apos;0&apos; to &apos;*&apos; for (int j = 0; j &lt; n; j++) &#123; if (board[0][j] == &apos;O&apos;) boundaryDFS(board, 0, j); if (board[m-1][j] == &apos;O&apos;) boundaryDFS(board, m-1, j); &#125; //post-prcessing, turn &apos;O&apos; to &apos;X&apos;, &apos;*&apos; back to &apos;O&apos;, keep &apos;X&apos; intact. for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (board[i][j] == &apos;O&apos;) board[i][j] = &apos;X&apos;; else if (board[i][j] == &apos;*&apos;) board[i][j] = &apos;O&apos;; &#125; &#125;&#125;//Use DFS algo to turn internal however boundary-connected &apos;O&apos; to &apos;*&apos;;private void boundaryDFS(char[][] board, int i, int j) &#123; if (i &lt; 0 || i &gt; board.length - 1 || j &lt;0 || j &gt; board[0].length - 1) return; if (board[i][j] == &apos;O&apos;) board[i][j] = &apos;*&apos;; if (i &gt; 1 &amp;&amp; board[i-1][j] == &apos;O&apos;) boundaryDFS(board, i-1, j); if (i &lt; board.length - 2 &amp;&amp; board[i+1][j] == &apos;O&apos;) boundaryDFS(board, i+1, j); if (j &gt; 1 &amp;&amp; board[i][j-1] == &apos;O&apos;) boundaryDFS(board, i, j-1); if (j &lt; board[i].length - 2 &amp;&amp; board[i][j+1] == &apos;O&apos; ) boundaryDFS(board, i, j+1);&#125; https://discuss.leetcode.com/topic/6496/my-java-o-n-2-accepted-solution My Java O(n^2) accepted solution The idea is pretty simple: a ‘O’ marked cell cannot be captured whether: It is in contact with the border of the board or It is adjacent to an unflippable cell. So the algorithm is straightforward: Go around the border of the board When a ‘O’ cell is found mark it with ‘U’ and perform a DFS on its adjacent cells looking for other ‘O’ marked cells. When the entire border is processed scan again the board If a cell is marked as ‘O’ it wasn’t connected to unflippable cell. Hence capture it with ‘X’ If a cell is marked as ‘X’ nothing must be done. If a cell is marked as ‘U’ mark it as ‘O’ because it was an original ‘O’ marked cell which satisfied one of the above conditions.On a technical side regarding the code: In the problem statement it’s not specified that the board is rectangular. So different checks must performed when scanning the border. Since a pure recursive search causes stack overflow it’s necessary to make the DFS iterative using a stack to simulate recursion.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Solution &#123; static class Pair &#123; public int first; public int second; public Pair(int f, int s) &#123; first = f; second = s; &#125;&#125;public void solve(char[][] board) &#123; if(board == null || board.length == 0) &#123; return ; &#125; for(int i = 0; i &lt; board[0].length; ++i) &#123; if(board[0][i] == &apos;O&apos;) &#123; markUnflippable(board,0,i); &#125; &#125; for(int i = 0; i &lt; board[board.length-1].length; ++i) &#123; if(board[board.length-1][i] == &apos;O&apos;) &#123; markUnflippable(board,board.length-1,i); &#125; &#125; for(int i = 0 ; i &lt; board.length; ++i) &#123; if(board[i][0] == &apos;O&apos;) &#123; markUnflippable(board,i,0); &#125; &#125; for(int i =0; i &lt; board.length; ++i) &#123; if(board[i][board[i].length-1] == &apos;O&apos;) &#123; markUnflippable(board,i,board[i].length-1); &#125; &#125; // modify the board for(int i = 0; i &lt; board.length; ++i) &#123; for(int j = 0; j &lt; board[i].length; ++j) &#123; if(board[i][j] == &apos;O&apos;) &#123; board[i][j] = &apos;X&apos;; &#125; else if(board[i][j] == &apos;U&apos;) &#123; board[i][j] = &apos;O&apos;; &#125; &#125; &#125;&#125;public void markUnflippable(char[][] board, int r, int c) &#123; int[] dirX = &#123;-1,0,1,0&#125;; int[] dirY = &#123;0,1,0,-1&#125;; ArrayDeque&lt;Pair&gt; stack = new ArrayDeque&lt;&gt;(); stack.push(new Pair(r,c)); while(!stack.isEmpty()) &#123; Pair p = stack.pop(); board[p.first][p.second] = &apos;U&apos;; for(int i = 0; i &lt; dirX.length; ++i) &#123; if(p.first + dirX[i] &gt;= 0 &amp;&amp; p.first + dirX[i] &lt; board.length &amp;&amp; p.second + dirY[i] &gt;= 0 &amp;&amp; p.second +dirY[i] &lt; board[p.first + dirX[i]].length &amp;&amp; board[p.first+dirX[i]][p.second+dirY[i]] == &apos;O&apos;) &#123; stack.push(new Pair(p.first+dirX[i],p.second+dirY[i])); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>breadth first search</tag>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[129. Sum Root to Leaf Numbers]]></title>
    <url>%2Fp%2Fac2bd33a%2F</url>
    <content type="text"><![CDATA[35.5% https://leetcode.com/problems/sum-root-to-leaf-numbers/?tab=Description Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. 123456789For example, 1 / \ 2 3The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13.Return the sum = 12 + 13 = 25. 方法一： 56ms, 46.63%, July 15th, 2016 https://discuss.leetcode.com/topic/12048/5-ms-c-code-using-dfs 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int sumNumbers(TreeNode* root) &#123; if(!root) return 0; sum = 0; DFS(root, 0); return sum; &#125; void DFS(TreeNode *&amp;node, int currentSum)&#123; currentSum = currentSum * 10 + node-&gt;val; if(!node-&gt;left &amp;&amp; !node-&gt;right) sum += currentSum; if(node-&gt;left) DFS(node-&gt;left, currentSum); if(node-&gt;right) DFS(node-&gt;right, currentSum); &#125;private: int sum;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int sumNumbers(TreeNode* root) &#123; int res = 0, cur = 0; helper(root, res, cur); return res; &#125; void helper(TreeNode* root, int&amp; res, int cur)&#123; if(!root) return; cur = cur*10 + root-&gt;val; if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123; res += cur; return; &#125; helper(root-&gt;left, res, cur); helper(root-&gt;right, res, cur); &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/3025/one-of-the-easier-solution-using-preorder-traversal-recursion One of the easier solution using preorder traversal (recursion) The idea is to do a preorder traversal of the tree. In the preorder traversal, keep track of the value calculated till the current node, let this value be val. For every node, we update the val as val10 plus node’s data.* 123456789101112131415161718192021class Solution &#123;public: int sumNumbers(TreeNode *root) &#123; return sumNumberUtil(root,0); &#125; // preorder int sumNumberUtil(struct TreeNode* node, int val) &#123; if(node==NULL) return 0; val= val*10+node-&gt;val; if(node-&gt;left==NULL &amp;&amp; node-&gt;right==NULL) &#123; return val; &#125; return sumNumberUtil(node-&gt;left,val)+sumNumberUtil(node-&gt;right, val); &#125;&#125;; python 76ms, 10.56%, July 15th, 2016 https://discuss.leetcode.com/topic/21363/python-solutions-dfs-stack-bfs-queue-dfs-recursively Python solutions (dfs+stack, bfs+queue, dfs recursively). 123456789101112131415# dfs + stackdef sumNumbers1(self, root): if not root: return 0 stack, res = [(root, root.val)], 0 while stack: node, value = stack.pop() if node: if not node.left and not node.right: res += value if node.right: stack.append((node.right, value*10+node.right.val)) if node.left: stack.append((node.left, value*10+node.left.val)) return res 123456789101112131415# bfs + queuedef sumNumbers2(self, root): if not root: return 0 queue, res = collections.deque([(root, root.val)]), 0 while queue: node, value = queue.popleft() if node: if not node.left and not node.right: res += value if node.left: queue.append((node.left, value*10+node.left.val)) if node.right: queue.append((node.right, value*10+node.right.val)) return res 12345678910111213141516# recursively def sumNumbers(self, root): self.res = 0 self.dfs(root, 0) return self.res def dfs(self, root, value): if root: #if not root.left and not root.right: # self.res += value*10 + root.val self.dfs(root.left, value*10+root.val) #if not root.left and not root.right: # self.res += value*10 + root.val self.dfs(root.right, value*10+root.val) if not root.left and not root.right: self.res += value*10 + root.val java solution 1: 1ms, 28.00%, July 15th, 2016 https://discuss.leetcode.com/topic/6731/short-java-solution-recursion 1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public int sumNumbers(TreeNode root) &#123; return sum(root, 0); &#125; public int sum(TreeNode n, int s)&#123; if(n==null) return 0; if(n.right == null &amp;&amp; n.left == null) return s*10 + n.val; return sum(n.left, s*10+n.val) + sum(n.right, s*10 + n.val); &#125;&#125; solution 2: 1ms, 28.00%, July 15th, 2016 https://discuss.leetcode.com/topic/644/can-you-improve-this-algorithm Can you improve this algorithm? 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public int sumNumbers(TreeNode root) &#123; if (root == null) return 0; return sumR(root, 0); &#125; public int sumR(TreeNode root, int x) &#123; if (root.right == null &amp;&amp; root.left == null) return 10 * x + root.val; int val = 0; if (root.left != null) val += sumR(root.left, 10 * x + root.val); if (root.right != null) val += sumR(root.right, 10 * x + root.val); return val; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[128. Longest Consecutive Sequence]]></title>
    <url>%2Fp%2Fb1f32255%2F</url>
    <content type="text"><![CDATA[35.7% https://leetcode.com/problems/longest-consecutive-sequence/?tab=Description Given an unsorted array of integers, find the length of the longest consecutive elements sequence. 123For example,Given [100, 4, 200, 1, 3, 2],The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4. Your algorithm should run in O(n) complexity. 方法一： 排序，一个个的查找 my code: 先排序，然后依次查找，同时注意出现相同数字的处理。 但是达到不了题目要求的O（n） 12345678910111213141516171819202122232425class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0 || nums.size()==1) return nums.size(); sort(nums.begin(), nums.end()); int res=1; int tmp=1; int last = nums[0]; for(int i=1; i&lt;nums.size(); i++)&#123; if(nums[i]==nums[i-1]) continue; else if(nums[i]==last+1)&#123; tmp += 1; last = nums[i]; &#125; else&#123; res = max(tmp, res); tmp = 1; last = nums[i]; &#125; &#125; res = max(res, tmp); return res; &#125;&#125;; 方法二： 使用set，然而效率仍然是o（nlogn） https://discuss.leetcode.com/topic/16483/a-simple-c-solution-using-unordered_set-and-simple-consideration-about-this-problem A simple C++,solution using unordered_set.And simple consideration about this problem I have seen a lot of discussion about this problem.In my opinion,it is not correct to use set(which is ordered),because very time we insert an element to a ordered set,it will cost O(n),so the total complexity is O(nlogn),which violates the request of the problem.So here we use an unordered_set,and one is enough. Besides,to think about this problem,one principle issue we should realize is that usually when we want to reduce the time complexity,we have to increase the space complexity.In this case,if we want to access an element within O(1),we have to use hash table. 12345678910111213141516class Solution &#123;public: int longestConsecutive(vector&lt;int&gt; &amp;num) &#123; unordered_set&lt;int&gt; record(num.begin(),num.end()); int res = 1; for(int n : num)&#123; if(record.find(n)==record.end()) continue; record.erase(n); int prev = n-1,next = n+1; while(record.find(prev)!=record.end()) record.erase(prev--); while(record.find(next)!=record.end()) record.erase(next++); res = max(res,next-prev-1); &#125; return res; &#125;&#125;; my code： 123456789101112131415161718class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; set(nums.begin(), nums.end()); int ret = 1; for(auto &amp;n: nums) &#123; if(!set.count(n)) continue; set.erase(n); // 删除元素 int pre=n-1, next=n+1; while(set.count(pre)) set.erase(pre--); // set.count(n) 返回匹配给主键的元素的个数 while(set.count(next)) set.erase(next++); ret = max(ret, next-pre-1); &#125; return ret; &#125;&#125;; 方法三： 使用hashmap m[i]表示i为中间值的一段的长度的大小，初始为0 https://discuss.leetcode.com/topic/5333/possibly-shortest-cpp-solution-only-6-lines Possibly shortest cpp solution, only 6 lines. use a hash map to store boundary information of consecutive sequence for each element; there 4 cases when a new element i reached: neither i+1 nor i-1 has been seen: m[i]=1; both i+1 and i-1 have been seen: extend m[i+m[i+1]] and m[i-m[i-1]] to each other; only i+1 has been seen: extend m[i+m[i+1]] and m[i] to each other; only i-1 has been seen: extend m[i-m[i-1]] and m[i] to each other. 123456789int longestConsecutive(vector&lt;int&gt; &amp;num) &#123; unordered_map&lt;int, int&gt; m; int r = 0; for (int i : num) &#123; if (m[i]) continue; r = max(r, m[i] = m[i + m[i + 1]] = m[i - m[i - 1]] = m[i + 1] + m[i - 1] + 1); &#125; return r;&#125; 我的代码实现： 12345678910111213141516class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; map; int res = 0; for(int num:nums)&#123; if(map[num]) continue; int len = map[num-1] + map[num+1] + 1; map[num+map[num+1]] = len; map[num-map[num-1]] = len; map[num] = len; res = max(res, len); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/6408/13-line-c-solution 13-line C++ solution Thought I would share it here. May be useful for some one. The algorithm itself is pretty straightforward. But it benefited quite much from the neat expression of C++ idioms. Comments are appreciated! 12345678910111213int longestConsecutive(const vector&lt;int&gt; &amp;num) &#123; unordered_set&lt;int&gt; s(num.begin(), num.end()), searched; int longest = 0; for (int i: num) &#123; if (searched.find(i) != searched.end()) continue; searched.insert(i); int j = i - 1, k = i + 1; while (s.find(j) != s.end()) searched.insert(j--); while (s.find(k) != s.end()) searched.insert(k++); longest = max(longest, k - 1 - j); &#125; return longest;&#125; python https://discuss.leetcode.com/topic/15383/simple-o-n-with-explanation-just-walk-each-streak Simple O(n) with Explanation - Just walk each streak First turn the input into a set of numbers. That takes O(n) and then we can ask in O(1) whether we have a certain number. Then go through the numbers. If the number x is the start of a streak (i.e., x-1 is not in the set), then test y = x+1, x+2, x+3, … and stop at the first number y not in the set. The length of the streak is then simply y-x and we update our global best with that. Since we check each streak only once, this is overall O(n). This ran in 44 ms on the OJ, one of the fastest Python submissions. 12345678910def longestConsecutive(self, nums): nums = set(nums) best = 0 for x in nums: if x - 1 not in nums: y = x + 1 while y in nums: y += 1 best = max(best, y - x) return best https://discuss.leetcode.com/topic/10678/python-o-n-solution-using-sets Python O(n) solution using sets 12345678910111213141516171819202122class Solution: # @param num, a list of integer # @return an integer def longestConsecutive(self, num): num=set(num) maxLen=0 while num: n=num.pop() i=n+1 l1=0 l2=0 while i in num: num.remove(i) i+=1 l1+=1 i=n-1 while i in num: num.remove(i) i-=1 l2+=1 maxLen=max(maxLen,l1+l2+1) return maxLen java https://discuss.leetcode.com/topic/6148/my-really-simple-java-o-n-solution-accepted My really simple Java O(n) solution - Accepted We will use HashMap. The key thing is to keep track of the sequence length and store that in the boundary points of the sequence. For example, as a result, for sequence {1, 2, 3, 4, 5}, map.get(1) and map.get(5) should both return 5. Whenever a new element n is inserted into the map, do two things: See if n - 1 and n + 1 exist in the map, and if so, it means there is an existing sequence next to n. Variables left and right will be the length of those two sequences, while 0 means there is no sequence and n will be the boundary point later. Store (left + right + 1) as the associated value to key n into the map. Use left and right to locate the other end of the sequences to the left and right of n respectively, and replace the value with the new length. Everything inside the for loop is O(1) so the total time is O(n). Please comment if you see something wrong. Thanks. 123456789101112131415161718192021222324252627public int longestConsecutive(int[] num) &#123; int res = 0; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int n : num) &#123; if (!map.containsKey(n)) &#123; int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0; int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0; // sum: length of the sequence n is in int sum = left + right + 1; map.put(n, sum); // keep track of the max length res = Math.max(res, sum); // extend the length to the boundary(s) // of the sequence // will do nothing if n has no neighbors map.put(n - left, sum); map.put(n + right, sum); &#125; else &#123; // duplicates continue; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/29286/my-java-solution-using-unionfound My Java Solution using UnionFound 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Solution &#123; public int longestConsecutive(int[] nums) &#123; UF uf = new UF(nums.length); Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); // &lt;value,index&gt; for(int i=0; i&lt;nums.length; i++)&#123; if(map.containsKey(nums[i]))&#123; continue; &#125; map.put(nums[i],i); if(map.containsKey(nums[i]+1))&#123; uf.union(i,map.get(nums[i]+1)); &#125; if(map.containsKey(nums[i]-1))&#123; uf.union(i,map.get(nums[i]-1)); &#125; &#125; return uf.maxUnion(); &#125; &#125; class UF&#123; private int[] list; public UF(int n)&#123; list = new int[n]; for(int i=0; i&lt;n; i++)&#123; list[i] = i; &#125; &#125; private int root(int i)&#123; while(i!=list[i])&#123; list[i] = list[list[i]]; i = list[i]; &#125; return i; &#125; public boolean connected(int i, int j)&#123; return root(i) == root(j); &#125; public void union(int p, int q)&#123; int i = root(p); int j = root(q); list[i] = j; &#125; // returns the maxium size of union public int maxUnion()&#123; // O(n) int[] count = new int[list.length]; int max = 0; for(int i=0; i&lt;list.length; i++)&#123; count[root(i)] ++; max = Math.max(max, count[root(i)]); &#125; return max; &#125; &#125; https://discuss.leetcode.com/topic/9088/o-n-hashmap-java-solution O(n) HashMap Java Solution Use a hashmap to map a number to its longest consecutive sequence length, each time find a new consecutive sequence, only the begin number and end number need to be modified. 12345678910111213141516171819202122public class Solution &#123; public int longestConsecutive(int[] num) &#123; int longest = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0;i &lt; num.length;i++)&#123; // if there is no duplicates, these two lines can be commented if(map.containsKey(num[i])) continue; map.put(num[i],1); int end = num[i]; int begin = num[i]; if(map.containsKey(num[i]+1)) end = num[i] + map.get(num[i]+1); if(map.containsKey(num[i]-1)) begin = num[i] - map.get(num[i]-1); longest = Math.max(longest, end-begin+1); map.put(end, end-begin+1); map.put(begin, end-begin+1); &#125; return longest; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hard</tag>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[127. Word Ladder]]></title>
    <url>%2Fp%2Ffdab0eca%2F</url>
    <content type="text"><![CDATA[19.2% https://leetcode.com/problems/word-ladder/#/description Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. 12345678For example,Given:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,return its length 5. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. UPDATE (2017/1/20): The wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. https://discuss.leetcode.com/topic/16983/easy-76ms-c-solution-using-bfs Easy 76ms C++ Solution using BFS Well, this problem has a nice BFS structure. Let’s see the example in the problem statement. 12345start = &quot;hit&quot;end = &quot;cog&quot;dict = [&quot;hot&quot;, &quot;dot&quot;, &quot;dog&quot;, &quot;lot&quot;, &quot;log&quot;] Since only one letter can be changed at a time, if we start from “hit”, we can only change to those words which have only one different letter from it, like “hot”. Putting in graph-theoretic terms, we can say that “hot” is a neighbor of “hit”. The idea is simpy to begin from start, then visit its neighbors, then the non-visited neighbors of its neighbors… Well, this is just the typical BFS structure. To simplify the problem, we insert end into dict. Once we meet end during the BFS, we know we have found the answer. We maintain a variable dist for the current distance of the transformation and update it by dist++ after we finish a round of BFS search (note that it should fit the definition of the distance in the problem statement). Also, to avoid visiting a word for more than once, we erase it from dict once it is visited. The code is as follows. 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int ladderLength(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordDict) &#123; wordDict.insert(endWord); queue&lt;string&gt; toVisit; addNextWords(beginWord, wordDict, toVisit); int dist = 2; while (!toVisit.empty()) &#123; int num = toVisit.size(); for (int i = 0; i &lt; num; i++) &#123; string word = toVisit.front(); toVisit.pop(); if (word == endWord) return dist; addNextWords(word, wordDict, toVisit); &#125; dist++; &#125; &#125;private: void addNextWords(string word, unordered_set&lt;string&gt;&amp; wordDict, queue&lt;string&gt;&amp; toVisit) &#123; wordDict.erase(word); for (int p = 0; p &lt; (int)word.length(); p++) &#123; char letter = word[p]; for (int k = 0; k &lt; 26; k++) &#123; word[p] = &apos;a&apos; + k; if (wordDict.find(word) != wordDict.end()) &#123; toVisit.push(word); wordDict.erase(word); &#125; &#125; word[p] = letter; &#125; &#125; &#125;; The above code can still be speeded up if we also begin from end. Once we meet the same word from start and end, we know we are done. This link provides a nice two-end search solution. I rewrite the code below for better readability. Note that the use of two pointers phead and ptail save a lot of time. At each round of BFS, depending on the relative size of head and tail, we point phead to the smaller set to reduce the running time. 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int ladderLength(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; head, tail, *phead, *ptail; head.insert(beginWord); tail.insert(endWord); int dist = 2; while (!head.empty() &amp;&amp; !tail.empty()) &#123; if (head.size() &lt; tail.size()) &#123; phead = &amp;head; ptail = &amp;tail; &#125; else &#123; phead = &amp;tail; ptail = &amp;head; &#125; unordered_set&lt;string&gt; temp; for (auto itr = phead -&gt; begin(); itr != phead -&gt; end(); itr++) &#123; string word = *itr; wordDict.erase(word); for (int p = 0; p &lt; (int)word.length(); p++) &#123; char letter = word[p]; for (int k = 0; k &lt; 26; k++) &#123; word[p] = &apos;a&apos; + k; if (ptail -&gt; find(word) != ptail -&gt; end()) return dist; if (wordDict.find(word) != wordDict.end()) &#123; temp.insert(word); wordDict.erase(word); &#125; &#125; word[p] = letter; &#125; &#125; dist++; swap(*phead, temp); &#125; return 0; &#125;&#125;; https://discuss.leetcode.com/topic/10372/share-my-two-end-bfs-in-c-80ms Share my two-end BFS in C++ 80ms. 12345678910111213141516171819202122232425262728293031323334353637383940//BFS， two-end method//traverse the path simultaneously from start node and end node, and merge in the middle//the speed will increase (logN/2)^2 times compared with one-end methodint ladderLength(string start, string end, unordered_set&lt;string&gt; &amp;dict) &#123; unordered_set&lt;string&gt; begSet, endSet, *set1, *set2; begSet.insert(start); endSet.insert(end); int h=1, K=start.size(); while(!begSet.empty()&amp;&amp;!endSet.empty())&#123; if(begSet.size()&lt;=endSet.size())&#123; //Make the size of two sets close for optimization set1=&amp;begSet; //set1 is the forward set set2=&amp;endSet; //set2 provides the target node for set1 to search &#125; else&#123; set1=&amp;endSet; set2=&amp;begSet; &#125; unordered_set&lt;string&gt; itmSet; //intermediate Set h++; for(auto i=set1-&gt;begin();i!=set1-&gt;end();i++)&#123; string cur=*i; for(int k=0;k&lt;K;k++)&#123; //iterate the characters in string cur char temp=cur[k]; for(int l=0;l&lt;26;l++)&#123; //try all 26 alphabets cur[k]=&apos;a&apos;+l; auto f=set2-&gt;find(cur); if(f!=set2-&gt;end())return h; f=dict.find(cur); if(f!=dict.end())&#123; itmSet.insert(cur); dict.erase(f); &#125; &#125; cur[k]=temp; &#125; &#125; swap(*set1, itmSet); &#125; return 0;&#125; https://discuss.leetcode.com/topic/43246/simple-to-understand-python-solution-using-list-preprocessing-and-bfs-beats-95 Simple to understand Python solution using list preprocessing and BFS, beats 95% 1234567891011121314151617181920212223242526272829303132from collections import dequeclass Solution(object): def ladderLength(self, beginWord, endWord, wordList): def construct_dict(word_list): d = &#123;&#125; for word in word_list: for i in range(len(word)): s = word[:i] + &quot;_&quot; + word[i+1:] d[s] = d.get(s, []) + [word] return d def bfs_words(begin, end, dict_words): queue, visited = deque([(begin, 1)]), set() while queue: word, steps = queue.popleft() if word not in visited: visited.add(word) if word == end: return steps for i in range(len(word)): s = word[:i] + &quot;_&quot; + word[i+1:] neigh_words = dict_words.get(s, []) for neigh in neigh_words: if neigh not in visited: queue.append((neigh, steps + 1)) return 0 d = construct_dict(wordList | set([beginWord, endWord])) return bfs_words(beginWord, endWord, d) https://discuss.leetcode.com/topic/42623/compact-python-solution Compact Python solution 123456789101112131415class Solution(object): def ladderLength(self, beginWord, endWord, wordList): wordList.add(endWord) queue = collections.deque([[beginWord, 1]]) while queue: word, length = queue.popleft() if word == endWord: return length for i in range(len(word)): for c in &apos;abcdefghijklmnopqrstuvwxyz&apos;: next_word = word[:i] + c + word[i+1:] if next_word in wordList: wordList.remove(next_word) queue.append([next_word, length + 1]) return 0 172ms, 78.99%, June.24th, 2016 https://leetcode.com/discuss/48083/share-python-solutions-concise-160ms-optimized-solution-100ms 12345678910111213141516171819202122232425class Solution(object): def ladderLength(self, beginWord, endWord, wordList): &quot;&quot;&quot; :type beginWord: str :type endWord: str :type wordList: Set[str] :rtype: int &quot;&quot;&quot; length = 2 front, back = set([beginWord]), set([endWord]) wordList.discard(beginWord) while front: # generate all valid transformations front = wordList &amp; (set(word[:index] + ch + word[index+1:] for word in front for index in range(len(beginWord)) for ch in &apos;abcdefghijklmnopqrstuvwxyz&apos;)) if front &amp; back: # there are common elements in front and back, done return length length += 1 if len(front) &gt; len(back): # swap front and back for better performance (fewer choices in generating nextSet) front, back = back, front # remove transformations from wordList to avoid cycle wordList -= front return 0 https://discuss.leetcode.com/topic/20965/java-solution-using-dijkstra-s-algorithm-with-explanation Java Solution using Dijkstra’s algorithm, with explanation 1234567891011121314151617181920212223242526public int ladderLength(String beginWord, String endWord, Set&lt;String&gt; wordDict) &#123; Set&lt;String&gt; reached = new HashSet&lt;String&gt;(); reached.add(beginWord); wordDict.add(endWord); int distance = 1; while (!reached.contains(endWord)) &#123; Set&lt;String&gt; toAdd = new HashSet&lt;String&gt;(); for (String each : reached) &#123; for (int i = 0; i &lt; each.length(); i++) &#123; char[] chars = each.toCharArray(); for (char ch = &apos;a&apos;; ch &lt;= &apos;z&apos;; ch++) &#123; chars[i] = ch; String word = new String(chars); if (wordDict.contains(word)) &#123; toAdd.add(word); wordDict.remove(word); &#125; &#125; &#125; &#125; distance++; if (toAdd.size() == 0) return 0; reached = toAdd; &#125; return distance;&#125; Basically I keep two sets of words, one set reached that represents the borders that have been reached with “distance” steps; another set wordDict that has not been reached. In the while loop, for each word in the reached set, I give all variations and check if it matches anything from wordDict, if it has a match, I add that word into toAdd set, which will be my “reached” set in the next loop, and remove the word from wordDict because I already reached it in this step. And at the end of while loop, I check the size of toAdd, which means that if I can’t reach any new String from wordDict, I won’t be able to reach the endWord, then just return 0. Finally if the endWord is in reached set, I return the current steps “distance”. The idea is that reached always contain only the ones we just reached in the last step, and wordDict always contain the ones that haven’t been reached. This is pretty much what Dijkstra’s algorithm does, or you can see this as some variation of BFS. ps: I get TLE at the first two submissions, because when I check if wordDict has any matches with reached set, I use two for loops and determine if any pair of words differ by one. That’s a huge slow-down because it’ll takes m (size of reached) n (size of wordDict) l (length of words) time, while in this solution, it takes 26 l m time. So when n is huge, this solution will be (n/26) times faster. https://discuss.leetcode.com/topic/20965/java-solution-using-dijkstra-s-algorithm-with-explanation/2 I think we can use a queue to replace the reached set, by which we can avoid duplicate check? 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int ladderLength(String beginWord, String endWord, Set&lt;String&gt; wordList) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.offer(beginWord); wordList.add(endWord); wordList.remove(beginWord); int level = 1; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0;i&lt;size;i++)&#123; String str = queue.poll(); if(str.equals(endWord))return level; for(String neighbor : neighbors(str,wordList))&#123; queue.offer(neighbor); &#125; &#125; level++; &#125; return 0; &#125; public List&lt;String&gt; neighbors(String s, Set&lt;String&gt; wordList)&#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); for(int i=0;i&lt;s.length();i++)&#123; char [] chars = s.toCharArray(); for(char ch = &apos;a&apos;; ch &lt;= &apos;z&apos;; ch++)&#123; chars[i] = ch; String word = new String(chars); if(wordList.remove(word))&#123; res.add(word); &#125; &#125; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/29303/two-end-bfs-in-java-31ms Two-end BFS in Java 31ms. Modified from Share my two-end BFS in C++ 80ms. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123;public int ladderLength(String beginWord, String endWord, Set&lt;String&gt; wordList) &#123; Set&lt;String&gt; beginSet = new HashSet&lt;String&gt;(), endSet = new HashSet&lt;String&gt;(); int len = 1; int strLen = beginWord.length(); HashSet&lt;String&gt; visited = new HashSet&lt;String&gt;(); beginSet.add(beginWord); endSet.add(endWord); while (!beginSet.isEmpty() &amp;&amp; !endSet.isEmpty()) &#123; if (beginSet.size() &gt; endSet.size()) &#123; Set&lt;String&gt; set = beginSet; beginSet = endSet; endSet = set; &#125; Set&lt;String&gt; temp = new HashSet&lt;String&gt;(); for (String word : beginSet) &#123; char[] chs = word.toCharArray(); for (int i = 0; i &lt; chs.length; i++) &#123; for (char c = &apos;a&apos;; c &lt;= &apos;z&apos;; c++) &#123; char old = chs[i]; chs[i] = c; String target = String.valueOf(chs); if (endSet.contains(target)) &#123; return len + 1; &#125; if (!visited.contains(target) &amp;&amp; wordList.contains(target)) &#123; temp.add(target); visited.add(target); &#125; chs[i] = old; &#125; &#125; &#125; beginSet = temp; len++; &#125; return 0;&#125;&#125; https://discuss.leetcode.com/topic/17890/another-accepted-java-solution-bfs Another accepted Java solution (BFS) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public int ladderLength(String start, String end, Set&lt;String&gt; dict) &#123; // Use queue to help BFS Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.add(start); queue.add(null); // Mark visited word Set&lt;String&gt; visited = new HashSet&lt;String&gt;(); visited.add(start); int level = 1; while (!queue.isEmpty()) &#123; String str = queue.poll(); if (str != null) &#123; // Modify str&apos;s each character (so word distance is 1) for (int i = 0; i &lt; str.length(); i++) &#123; char[] chars = str.toCharArray(); for (char c = &apos;a&apos;; c &lt;= &apos;z&apos;; c++) &#123; chars[i] = c; String word = new String(chars); // Found the end word if (word.equals(end)) return level + 1; // Put it to the queue if (dict.contains(word) &amp;&amp; !visited.contains(word)) &#123; queue.add(word); visited.add(word); &#125; &#125; &#125; &#125; else &#123; level++; if (!queue.isEmpty()) &#123; queue.add(null); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[126. Word Ladder II]]></title>
    <url>%2Fp%2F2dae1d4c%2F</url>
    <content type="text"><![CDATA[13.7% https://leetcode.com/problems/word-ladder-ii/#/description Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that: Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word. 1234567891011For example,Given:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Return [ [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;], [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;] ] Note: Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. UPDATE (2017/1/20): The wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. https://discuss.leetcode.com/topic/16826/88ms-accepted-c-solution-with-two-end-bfs-68ms-for-word-ladder-and-88ms-for-word-ladder-ii 88ms! Accepted c++ solution with two-end BFS. 68ms for Word Ladder and 88ms for Word Ladder II In order to reduce the running time, we should use two-end BFS to slove the problem. Accepted 68ms c++ solution for Word Ladder. 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int ladderLength(std::string beginWord, std::string endWord, std::unordered_set&lt;std::string&gt; &amp;dict) &#123; if (beginWord == endWord) return 1; std::unordered_set&lt;std::string&gt; words1, words2; words1.insert(beginWord); words2.insert(endWord); dict.erase(beginWord); dict.erase(endWord); return ladderLengthHelper(words1, words2, dict, 1); &#125;private: int ladderLengthHelper(std::unordered_set&lt;std::string&gt; &amp;words1, std::unordered_set&lt;std::string&gt; &amp;words2, std::unordered_set&lt;std::string&gt; &amp;dict, int level) &#123; if (words1.empty()) return 0; if (words1.size() &gt; words2.size()) return ladderLengthHelper(words2, words1, dict, level); std::unordered_set&lt;std::string&gt; words3; for (auto it = words1.begin(); it != words1.end(); ++it) &#123; std::string word = *it; for (auto ch = word.begin(); ch != word.end(); ++ch) &#123; char tmp = *ch; for (*ch = &apos;a&apos;; *ch &lt;= &apos;z&apos;; ++(*ch)) if (*ch != tmp) if (words2.find(word) != words2.end()) return level + 1; else if (dict.find(word) != dict.end()) &#123; dict.erase(word); words3.insert(word); &#125; *ch = tmp; &#125; &#125; return ladderLengthHelper(words2, words3, dict, level + 1); &#125;&#125;; Accepted 88ms c++ solution for Word Ladder II. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution &#123;public: std::vector&lt;std::vector&lt;std::string&gt; &gt; findLadders(std::string beginWord, std::string endWord, std::unordered_set&lt;std::string&gt; &amp;dict) &#123; std::vector&lt;std::vector&lt;std::string&gt; &gt; paths; std::vector&lt;std::string&gt; path(1, beginWord); if (beginWord == endWord) &#123; paths.push_back(path); return paths; &#125; std::unordered_set&lt;std::string&gt; words1, words2; words1.insert(beginWord); words2.insert(endWord); std::unordered_map&lt;std::string, std::vector&lt;std::string&gt; &gt; nexts; bool words1IsBegin = false; if (findLaddersHelper(words1, words2, dict, nexts, words1IsBegin)) getPath(beginWord, endWord, nexts, path, paths); return paths; &#125;private: bool findLaddersHelper( std::unordered_set&lt;std::string&gt; &amp;words1, std::unordered_set&lt;std::string&gt; &amp;words2, std::unordered_set&lt;std::string&gt; &amp;dict, std::unordered_map&lt;std::string, std::vector&lt;std::string&gt; &gt; &amp;nexts, bool &amp;words1IsBegin) &#123; words1IsBegin = !words1IsBegin; if (words1.empty()) return false; if (words1.size() &gt; words2.size()) return findLaddersHelper(words2, words1, dict, nexts, words1IsBegin); for (auto it = words1.begin(); it != words1.end(); ++it) dict.erase(*it); for (auto it = words2.begin(); it != words2.end(); ++it) dict.erase(*it); std::unordered_set&lt;std::string&gt; words3; bool reach = false; for (auto it = words1.begin(); it != words1.end(); ++it) &#123; std::string word = *it; for (auto ch = word.begin(); ch != word.end(); ++ch) &#123; char tmp = *ch; for (*ch = &apos;a&apos;; *ch &lt;= &apos;z&apos;; ++(*ch)) if (*ch != tmp) if (words2.find(word) != words2.end()) &#123; reach = true; words1IsBegin ? nexts[*it].push_back(word) : nexts[word].push_back(*it); &#125; else if (!reach &amp;&amp; dict.find(word) != dict.end()) &#123; words3.insert(word); words1IsBegin ? nexts[*it].push_back(word) : nexts[word].push_back(*it); &#125; *ch = tmp; &#125; &#125; return reach || findLaddersHelper(words2, words3, dict, nexts, words1IsBegin); &#125; void getPath( std::string beginWord, std::string &amp;endWord, std::unordered_map&lt;std::string, std::vector&lt;std::string&gt; &gt; &amp;nexts, std::vector&lt;std::string&gt; &amp;path, std::vector&lt;std::vector&lt;std::string&gt; &gt; &amp;paths) &#123; if (beginWord == endWord) paths.push_back(path); else for (auto it = nexts[beginWord].begin(); it != nexts[beginWord].end(); ++it) &#123; path.push_back(*it); getPath(*it, endWord, nexts, path, paths); path.pop_back(); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/40902/clean-but-the-best-submission-68ms-in-c-well-commented Clean but the best-submission (68ms) in C++, well-commented 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution &#123; public: vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, unordered_set&lt;string&gt; &amp;dict) &#123; vector&lt;vector&lt;string&gt; &gt; paths; vector&lt;string&gt; path(1, beginWord); if (beginWord == endWord) //corner case; &#123; paths.push_back(path); return paths; &#125; unordered_set&lt;string&gt; forward, backward; forward.insert(beginWord); backward.insert(endWord); unordered_map&lt;string, vector&lt;string&gt; &gt; tree; bool reversed = false; //make sure the tree generating direction is consistent, since we have to start from the smaller set to accelerate; if (buildTree(forward, backward, dict, tree, reversed)) getPath(beginWord, endWord, tree, path, paths); return paths; &#125; private: bool buildTree(unordered_set&lt;string&gt; &amp;forward, unordered_set&lt;string&gt; &amp;backward, unordered_set&lt;string&gt; &amp;dict, unordered_map&lt;string, vector&lt;string&gt; &gt; &amp;tree, bool reversed) &#123; if (forward.empty()) return false; if (forward.size() &gt; backward.size()) return buildTree(backward, forward, dict, tree, !reversed); for (auto &amp;word: forward) dict.erase(word); for (auto &amp;word: backward) dict.erase(word); unordered_set&lt;string&gt; nextLevel; bool done = false; //in case of invalid further searching; for (auto &amp;it: forward) //traverse each word in the forward -&gt; the current level of the tree; &#123; string word = it; for (auto &amp;c: word) &#123; char c0 = c; //store the original; for (c = &apos;a&apos;; c &lt;= &apos;z&apos;; ++c) //try each case; &#123; if (c != c0) //avoid futile checking; &#123; if (backward.count(word)) //using count is an accelerating method; &#123; done = true; !reversed ? tree[it].push_back(word) : tree[word].push_back(it); //keep the tree generation direction consistent; &#125; else if (!done &amp;&amp; dict.count(word)) &#123; nextLevel.insert(word); !reversed ? tree[it].push_back(word) : tree[word].push_back(it); &#125; &#125; &#125; c = c0; //restore the word; &#125; &#125; return done || buildTree(nextLevel, backward, dict, tree, reversed); &#125; void getPath(string &amp;beginWord, string &amp;endWord, unordered_map&lt;string, vector&lt;string&gt; &gt; &amp;tree, vector&lt;string&gt; &amp;path, vector&lt;vector&lt;string&gt; &gt; &amp;paths) //using reference can accelerate; &#123; if (beginWord == endWord) paths.push_back(path); //till the end; else &#123; for (auto &amp;it: tree[beginWord]) &#123; path.push_back(it); getPath(it, endWord, tree, path, paths); //DFS retrieving the path; path.pop_back(); &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/43603/fast-and-clean-python-c-solution-using-double-bfs-beats-98 FAST AND CLEAN Python/C++ Solution using Double BFS, beats 98% If we know source and destination, we can build the word tree by going forward in one direction and backwards in the other. We stop when we have found that a word in the next level of BFS is in the other level, but first we need to update the tree for the words in the current level. Then we build the result by doing a DFS on the tree constructed by the BFS. The difference between normal and double BFS is that the search changes from O(k^d) to O(k^(d/2) + k^(d/2)). Same complexity class, right? Yeah, tell it to the Facebook guys that have to search in graphs with hundreds of thousands of nodes. 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): # Solution using double BFS def findLadders(self, begin, end, words_list): def construct_paths(source, dest, tree): if source == dest: return [[source]] return [[source] + path for succ in tree[source] for path in construct_paths(succ, dest, tree)] def add_path(tree, word, neigh, is_forw): if is_forw: tree[word] += neigh, else: tree[neigh] += word, def bfs_level(this_lev, oth_lev, tree, is_forw, words_set): if not this_lev: return False if len(this_lev) &gt; len(oth_lev): return bfs_level(oth_lev, this_lev, tree, not is_forw, words_set) for word in (this_lev | oth_lev): words_set.discard(word) next_lev, done = set(), False while this_lev: word = this_lev.pop() for c in string.ascii_lowercase: for index in range(len(word)): neigh = word[:index] + c + word[index+1:] if neigh in oth_lev: done = True add_path(tree, word, neigh, is_forw) if not done and neigh in words_set: next_lev.add(neigh) add_path(tree, word, neigh, is_forw) return done or bfs_level(next_lev, oth_lev, tree, is_forw, words_set) tree, path, paths = collections.defaultdict(list), [begin], [] is_found = bfs_level(set([begin]), set([end]), tree, True, words_list) return construct_paths(begin, end, tree) C++ code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283void add_to_tree(map&lt;string, vector&lt;string&gt;&gt;&amp; tree, string word, string neigh, bool forward) &#123; if (forward) tree[word].push_back(neigh); else tree[neigh].push_back(word);&#125;vector&lt;vector&lt;string&gt;&gt; construct_paths(map&lt;string, vector&lt;string&gt;&gt;&amp; tree, string start, string dest) &#123; if (start == dest) &#123; vector&lt;string&gt; res = &#123;start&#125;; vector&lt;vector&lt;string&gt;&gt; arr = &#123;res&#125;; return arr; &#125; vector&lt;vector&lt;string&gt;&gt; result; for (auto succ: tree[start]) &#123; for (auto path: construct_paths(tree, succ, dest)) &#123; path.insert(path.begin(), start); result.push_back(path); &#125; &#125; return result;&#125;bool bfs_levels(unordered_set&lt;string&gt;&amp; now, unordered_set&lt;string&gt;&amp; oth, bool&amp; forward, map&lt;string, vector&lt;string&gt;&gt;&amp; tree, unordered_set&lt;string&gt;&amp; words_list, vector&lt;char&gt;&amp; alphabet) &#123; if (not now.size()) return false; if (now.size() &gt; oth.size())&#123; forward = not forward; return bfs_levels(oth, now, forward, tree, words_list, alphabet); &#125; for (auto word: now) words_list.erase(word); for (auto word: oth) words_list.erase(word); bool done = false; unordered_set&lt;string&gt; next; for (string word: now) &#123; for (int i = 0; i &lt; word.size(); i++) &#123; for (char c: alphabet) &#123; auto neigh = word.substr(0, i) + c + word.substr(i+1); if (oth.count(neigh) &gt; 0) &#123; done = true; add_to_tree(tree, word, neigh, forward); &#125; else &#123; if (not done and words_list.count(neigh) &gt; 0) &#123; next.insert(neigh); add_to_tree(tree, word, neigh, forward); &#125; &#125; &#125; &#125; &#125; forward = not forward; return done or bfs_levels(oth, next, forward, tree, words_list, alphabet);&#125;class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, unordered_set&lt;string&gt; &amp;wordList) &#123; vector&lt;char&gt; alphabet(26); std::iota(alphabet.begin(), alphabet.end(), &apos;a&apos;); unordered_set&lt;string&gt; now = &#123;beginWord&#125;, oth = &#123;endWord&#125;; map&lt;string, vector&lt;string&gt;&gt; tree; bool forward = true; auto is_found = bfs_levels(now, oth, forward, tree, wordList, alphabet); return construct_paths(tree, beginWord, endWord); &#125;&#125;; https://discuss.leetcode.com/topic/8343/use-defaultdict-for-traceback-and-easy-writing-20-lines-python-code Use defaultdict for traceback and easy writing, 20 lines python code 1234567891011121314151617181920212223class Solution:# @param start, a string# @param end, a string# @param dict, a set of string# @return a list of lists of stringdef findLadders(self, start, end, dic): dic.add(end) level = &#123;start&#125; parents = collections.defaultdict(set) while level and end not in parents: next_level = collections.defaultdict(set) for node in level: for char in string.ascii_lowercase: for i in range(len(start)): n = node[:i]+char+node[i+1:] if n in dic and n not in parents: next_level[n].add(node) level = next_level parents.update(next_level) res = [[end]] while res and res[0][0] != start: res = [[p]+r for r in res for p in parents[r[0]]] return res Every level we use the defaultdict to get rid of the duplicates https://discuss.leetcode.com/topic/2857/share-two-similar-java-solution-that-accpted-by-oj Share two similar Java solution that Accpted by OJ. The solution contains two steps 1 Use BFS to construct a graph. 2. Use DFS to construct the paths from end to start.Both solutions got AC within 1s. The first step BFS is quite important. I summarized three tricks Using a MAP to store the min ladder of each word, or use a SET to store the words visited in current ladder, when the current ladder was completed, delete the visited words from unvisited. That’s why I have two similar solutions. Use Character iteration to find all possible paths. Do not compare one word to all the other words and check if they only differ by one character. One word is allowed to be inserted into the queue only ONCE. See my comments. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class Solution &#123; Map&lt;String,List&lt;String&gt;&gt; map; List&lt;List&lt;String&gt;&gt; results; public List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, Set&lt;String&gt; dict) &#123; results= new ArrayList&lt;List&lt;String&gt;&gt;(); if (dict.size() == 0) return results; int min=Integer.MAX_VALUE; Queue&lt;String&gt; queue= new ArrayDeque&lt;String&gt;(); queue.add(start); map = new HashMap&lt;String,List&lt;String&gt;&gt;(); Map&lt;String,Integer&gt; ladder = new HashMap&lt;String,Integer&gt;(); for (String string:dict) ladder.put(string, Integer.MAX_VALUE); ladder.put(start, 0); dict.add(end); //BFS: Dijisktra search while (!queue.isEmpty()) &#123; String word = queue.poll(); int step = ladder.get(word)+1;//&apos;step&apos; indicates how many steps are needed to travel to one word. if (step&gt;min) break; for (int i = 0; i &lt; word.length(); i++)&#123; StringBuilder builder = new StringBuilder(word); for (char ch=&apos;a&apos;; ch &lt;= &apos;z&apos;; ch++)&#123; builder.setCharAt(i,ch); String new_word=builder.toString(); if (ladder.containsKey(new_word)) &#123; if (step&gt;ladder.get(new_word))//Check if it is the shortest path to one word. continue; else if (step&lt;ladder.get(new_word))&#123; queue.add(new_word); ladder.put(new_word, step); &#125;else;// It is a KEY line. If one word already appeared in one ladder, // Do not insert the same word inside the queue twice. Otherwise it gets TLE. if (map.containsKey(new_word)) //Build adjacent Graph map.get(new_word).add(word); else&#123; List&lt;String&gt; list= new LinkedList&lt;String&gt;(); list.add(word); map.put(new_word,list); //It is possible to write three lines in one: //map.put(new_word,new LinkedList&lt;String&gt;(Arrays.asList(new String[]&#123;word&#125;))); //Which one is better? &#125; if (new_word.equals(end)) min=step; &#125;//End if dict contains new_word &#125;//End:Iteration from &apos;a&apos; to &apos;z&apos; &#125;//End:Iteration from the first to the last &#125;//End While //BackTracking LinkedList&lt;String&gt; result = new LinkedList&lt;String&gt;(); backTrace(end,start,result); return results; &#125; private void backTrace(String word,String start,List&lt;String&gt; list)&#123; if (word.equals(start))&#123; list.add(0,start); results.add(new ArrayList&lt;String&gt;(list)); list.remove(0); return; &#125; list.add(0,word); if (map.get(word)!=null) for (String s:map.get(word)) backTrace(s,start,list); list.remove(0); &#125;&#125; Another solution using two sets. This is similar to the answer in the most viewed thread. While I found my solution more readable and efficient. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Solution &#123; List&lt;List&lt;String&gt;&gt; results; List&lt;String&gt; list; Map&lt;String,List&lt;String&gt;&gt; map; public List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, Set&lt;String&gt; dict) &#123; results= new ArrayList&lt;List&lt;String&gt;&gt;(); if (dict.size() == 0) return results; int curr=1,next=0; boolean found=false; list = new LinkedList&lt;String&gt;(); map = new HashMap&lt;String,List&lt;String&gt;&gt;(); Queue&lt;String&gt; queue= new ArrayDeque&lt;String&gt;(); Set&lt;String&gt; unvisited = new HashSet&lt;String&gt;(dict); Set&lt;String&gt; visited = new HashSet&lt;String&gt;(); queue.add(start); unvisited.add(end); unvisited.remove(start); //BFS while (!queue.isEmpty()) &#123; String word = queue.poll(); curr--; for (int i = 0; i &lt; word.length(); i++)&#123; StringBuilder builder = new StringBuilder(word); for (char ch=&apos;a&apos;; ch &lt;= &apos;z&apos;; ch++)&#123; builder.setCharAt(i,ch); String new_word=builder.toString(); if (unvisited.contains(new_word))&#123; //Handle queue if (visited.add(new_word))&#123;//Key statement,Avoid Duplicate queue insertion next++; queue.add(new_word); &#125; if (map.containsKey(new_word))//Build Adjacent Graph map.get(new_word).add(word); else&#123; List&lt;String&gt; l= new LinkedList&lt;String&gt;(); l.add(word); map.put(new_word, l); &#125; if (new_word.equals(end)&amp;&amp;!found) found=true; &#125; &#125;//End:Iteration from &apos;a&apos; to &apos;z&apos; &#125;//End:Iteration from the first to the last if (curr==0)&#123; if (found) break; curr=next; next=0; unvisited.removeAll(visited); visited.clear(); &#125; &#125;//End While backTrace(end,start); return results; &#125; private void backTrace(String word,String start)&#123; if (word.equals(start))&#123; list.add(0,start); results.add(new ArrayList&lt;String&gt;(list)); list.remove(0); return; &#125; list.add(0,word); if (map.get(word)!=null) for (String s:map.get(word)) backTrace(s,start); list.remove(0); &#125; &#125; https://discuss.leetcode.com/topic/2857/share-two-similar-java-solution-that-accpted-by-oj Share two similar Java solution that Accpted by OJ. The solution contains two steps 1 Use BFS to construct a graph. 2. Use DFS to construct the paths from end to start.Both solutions got AC within 1s. The first step BFS is quite important. I summarized three tricks Using a MAP to store the min ladder of each word, or use a SET to store the words visited in current ladder, when the current ladder was completed, delete the visited words from unvisited. That’s why I have two similar solutions.Use Character iteration to find all possible paths. Do not compare one word to all the other words and check if they only differ by one character.One word is allowed to be inserted into the queue only ONCE. See my comments.public class Solution { Map&lt;String,List&gt; map; List&lt;List&gt; results; public List&lt;List&gt; findLadders(String start, String end, Set dict) { results= new ArrayList&lt;List&gt;(); if (dict.size() == 0) return results; int min=Integer.MAX_VALUE; Queue&lt;String&gt; queue= new ArrayDeque&lt;String&gt;(); queue.add(start); map = new HashMap&lt;String,List&lt;String&gt;&gt;(); Map&lt;String,Integer&gt; ladder = new HashMap&lt;String,Integer&gt;(); for (String string:dict) ladder.put(string, Integer.MAX_VALUE); ladder.put(start, 0); dict.add(end); //BFS: Dijisktra search while (!queue.isEmpty()) { String word = queue.poll(); int step = ladder.get(word)+1;//&apos;step&apos; indicates how many steps are needed to travel to one word. if (step&gt;min) break; for (int i = 0; i &lt; word.length(); i++){ StringBuilder builder = new StringBuilder(word); for (char ch=&apos;a&apos;; ch &lt;= &apos;z&apos;; ch++){ builder.setCharAt(i,ch); String new_word=builder.toString(); if (ladder.containsKey(new_word)) { if (step&gt;ladder.get(new_word))//Check if it is the shortest path to one word. continue; else if (step&lt;ladder.get(new_word)){ queue.add(new_word); ladder.put(new_word, step); }else;// It is a KEY line. If one word already appeared in one ladder, // Do not insert the same word inside the queue twice. Otherwise it gets TLE. if (map.containsKey(new_word)) //Build adjacent Graph map.get(new_word).add(word); else{ List&lt;String&gt; list= new LinkedList&lt;String&gt;(); list.add(word); map.put(new_word,list); //It is possible to write three lines in one: //map.put(new_word,new LinkedList&lt;String&gt;(Arrays.asList(new String[]{word}))); //Which one is better? } if (new_word.equals(end)) min=step; }//End if dict contains new_word }//End:Iteration from &apos;a&apos; to &apos;z&apos; }//End:Iteration from the first to the last }//End While //BackTracking LinkedList&lt;String&gt; result = new LinkedList&lt;String&gt;(); backTrace(end,start,result); return results; } private void backTrace(String word,String start,List&lt;String&gt; list){ if (word.equals(start)){ list.add(0,start); results.add(new ArrayList&lt;String&gt;(list)); list.remove(0); return; } list.add(0,word); if (map.get(word)!=null) for (String s:map.get(word)) backTrace(s,start,list); list.remove(0); } }Another solution using two sets. This is similar to the answer in the most viewed thread. While I found my solution more readable and efficient. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Solution &#123; List&lt;List&lt;String&gt;&gt; results; List&lt;String&gt; list; Map&lt;String,List&lt;String&gt;&gt; map; public List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, Set&lt;String&gt; dict) &#123; results= new ArrayList&lt;List&lt;String&gt;&gt;(); if (dict.size() == 0) return results; int curr=1,next=0; boolean found=false; list = new LinkedList&lt;String&gt;(); map = new HashMap&lt;String,List&lt;String&gt;&gt;(); Queue&lt;String&gt; queue= new ArrayDeque&lt;String&gt;(); Set&lt;String&gt; unvisited = new HashSet&lt;String&gt;(dict); Set&lt;String&gt; visited = new HashSet&lt;String&gt;(); queue.add(start); unvisited.add(end); unvisited.remove(start); //BFS while (!queue.isEmpty()) &#123; String word = queue.poll(); curr--; for (int i = 0; i &lt; word.length(); i++)&#123; StringBuilder builder = new StringBuilder(word); for (char ch=&apos;a&apos;; ch &lt;= &apos;z&apos;; ch++)&#123; builder.setCharAt(i,ch); String new_word=builder.toString(); if (unvisited.contains(new_word))&#123; //Handle queue if (visited.add(new_word))&#123;//Key statement,Avoid Duplicate queue insertion next++; queue.add(new_word); &#125; if (map.containsKey(new_word))//Build Adjacent Graph map.get(new_word).add(word); else&#123; List&lt;String&gt; l= new LinkedList&lt;String&gt;(); l.add(word); map.put(new_word, l); &#125; if (new_word.equals(end)&amp;&amp;!found) found=true; &#125; &#125;//End:Iteration from &apos;a&apos; to &apos;z&apos; &#125;//End:Iteration from the first to the last if (curr==0)&#123; if (found) break; curr=next; next=0; unvisited.removeAll(visited); visited.clear(); &#125; &#125;//End While backTrace(end,start); return results; &#125; private void backTrace(String word,String start)&#123; if (word.equals(start))&#123; list.add(0,start); results.add(new ArrayList&lt;String&gt;(list)); list.remove(0); return; &#125; list.add(0,word); if (map.get(word)!=null) for (String s:map.get(word)) backTrace(s,start); list.remove(0); &#125; &#125; https://discuss.leetcode.com/topic/27504/my-concise-java-solution-based-on-bfs-and-dfs My concise JAVA solution based on BFS and DFS Explanation The basic idea is: 1). Use BFS to find the shortest distance between start and end, tracing the distance of crossing nodes from start node to end node, and store node’s next level neighbors to HashMap; 2). Use DFS to output paths with the same distance as the shortest distance from distance HashMap: compare if the distance of the next level node equals the distance of the current node + 1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, List&lt;String&gt; wordList) &#123; HashSet&lt;String&gt; dict = new HashSet&lt;String&gt;(wordList); List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();// Neighbors for every node HashMap&lt;String, Integer&gt; distance = new HashMap&lt;String, Integer&gt;();// Distance of every node from the start node ArrayList&lt;String&gt; solution = new ArrayList&lt;String&gt;(); dict.add(start); bfs(start, end, dict, nodeNeighbors, distance); dfs(start, end, dict, nodeNeighbors, distance, solution, res); return res;&#125;// BFS: Trace every node&apos;s distance from the start node (level by level).private void bfs(String start, String end, Set&lt;String&gt; dict, HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors, HashMap&lt;String, Integer&gt; distance) &#123; for (String str : dict) nodeNeighbors.put(str, new ArrayList&lt;String&gt;()); Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.offer(start); distance.put(start, 0); while (!queue.isEmpty()) &#123; int count = queue.size(); boolean foundEnd = false; for (int i = 0; i &lt; count; i++) &#123; String cur = queue.poll(); int curDistance = distance.get(cur); ArrayList&lt;String&gt; neighbors = getNeighbors(cur, dict); for (String neighbor : neighbors) &#123; nodeNeighbors.get(cur).add(neighbor); if (!distance.containsKey(neighbor)) &#123;// Check if visited distance.put(neighbor, curDistance + 1); if (end.equals(neighbor))// Found the shortest path foundEnd = true; else queue.offer(neighbor); &#125; &#125; &#125; if (foundEnd) break; &#125; &#125;// Find all next level nodes. private ArrayList&lt;String&gt; getNeighbors(String node, Set&lt;String&gt; dict) &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); char chs[] = node.toCharArray(); for (char ch =&apos;a&apos;; ch &lt;= &apos;z&apos;; ch++) &#123; for (int i = 0; i &lt; chs.length; i++) &#123; if (chs[i] == ch) continue; char old_ch = chs[i]; chs[i] = ch; if (dict.contains(String.valueOf(chs))) &#123; res.add(String.valueOf(chs)); &#125; chs[i] = old_ch; &#125; &#125; return res;&#125;// DFS: output all paths with the shortest distance.private void dfs(String cur, String end, Set&lt;String&gt; dict, HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors, HashMap&lt;String, Integer&gt; distance, ArrayList&lt;String&gt; solution, List&lt;List&lt;String&gt;&gt; res) &#123; solution.add(cur); if (end.equals(cur)) &#123; res.add(new ArrayList&lt;String&gt;(solution)); &#125; else &#123; for (String next : nodeNeighbors.get(cur)) &#123; if (distance.get(next) == distance.get(cur) + 1) &#123; dfs(next, end, dict, nodeNeighbors, distance, solution, res); &#125; &#125; &#125; solution.remove(solution.size() - 1);&#125; Solution 1: 672ms, 40.34%, June.24th, 2016 https://leetcode.com/discuss/24191/defaultdict-for-traceback-and-easy-writing-lines-python-code 12345678910111213141516171819202122232425class Solution(object): def findLadders(self, beginWord, endWord, wordlist): &quot;&quot;&quot; :type beginWord: str :type endWord: str :type wordlist: Set[str] :rtype: List[List[int]] &quot;&quot;&quot; wordlist.add(endWord) level = &#123;beginWord&#125; parents = collections.defaultdict(set) while level and endWord not in parents: next_level = collections.defaultdict(set) for node in level: for char in string.ascii_lowercase: for i in range(len(beginWord)): n = node[:i]+char+node[i+1:] if n in wordlist and n not in parents: next_level[n].add(node) level = next_level parents.update(next_level) res = [[endWord]] while res and res[0][0] != beginWord: res = [[p]+r for r in res for p in parents[r[0]]] return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>string</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[125. Valid Palindrome]]></title>
    <url>%2Fp%2Feb15f900%2F</url>
    <content type="text"><![CDATA[25.7% https://leetcode.com/problems/valid-palindrome/#/description Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. 123For example,&quot;A man, a plan, a canal: Panama&quot; is a palindrome.&quot;race a car&quot; is not a palindrome. Note: Have you consider that the string might be empty? This is a good question to ask during an interview. For the purpose of this problem, we define empty string as valid palindrome. isalnum 是否数字字符 isalpha 是否字母字符 tolower/toupper 方法一： Here’s a clean C++ solution 123456789bool isPalindrome(string s) &#123; for (int i = 0, j = s.size() - 1; i &lt; j; i++, j--) &#123; // Move 2 pointers from each end until they collide while (isalnum(s[i]) == false &amp;&amp; i &lt; j) i++; // Increment left pointer if not alphanumeric while (isalnum(s[j]) == false &amp;&amp; i &lt; j) j--; // Decrement right pointer if no alphanumeric if (toupper(s[i]) != toupper(s[j])) return false; // Exit and return error if not match &#125; return true;&#125; 我的代码实现： 123456789101112131415class Solution &#123;public: bool isPalindrome(string s) &#123; int n = s.size(); if(n==0) return true; int i = 0, j = n-1; while(i&lt;j)&#123; while(i&lt;j &amp;&amp; !isalnum(s[i])) i++; while(i&lt;j &amp;&amp; !isalnum(s[j])) j--; if(toupper(s[i])!=toupper(s[j])) return false; i++; j--; &#125; return true; &#125;&#125;; https://discuss.leetcode.com/topic/5581/here-s-a-clean-c-solution Here’s a clean C++ solution 123456789bool isPalindrome(string s) &#123; for (int i = 0, j = s.size() - 1; i &lt; j; i++, j--) &#123; // Move 2 pointers from each end until they collide while (isalnum(s[i]) == false &amp;&amp; i &lt; j) i++; // Increment left pointer if not alphanumeric while (isalnum(s[j]) == false &amp;&amp; i &lt; j) j--; // Decrement right pointer if no alphanumeric if (toupper(s[i]) != toupper(s[j])) return false; // Exit and return error if not match &#125; return true;&#125; https://discuss.leetcode.com/topic/10862/passed-clean-c-code Passed clean c++ code 1234567891011bool isPalindrome(string s) &#123; int start=0, end=s.length()-1; while(start&lt;end) &#123; if (!isalnum(s[start])) start++; else if (!isalnum(s[end])) end--; else &#123; if (tolower(s[start++])!=tolower(s[end--])) return false; &#125; &#125; return true;&#125; https://discuss.leetcode.com/topic/22479/python-in-place-two-pointer-solution Python in-place two-pointer solution. 1234567891011def isPalindrome(self, s): l, r = 0, len(s)-1 while l &lt; r: while l &lt; r and not s[l].isalnum(): l += 1 while l &lt;r and not s[r].isalnum(): r -= 1 if s[l].lower() != s[r].lower(): return False l +=1; r -= 1 return True 80ms, 78.34%, April.23rd, 2016 https://leetcode.com/discuss/11241/challenge-shortest-possible-answer-python-palindrome-python 12345678class Solution(object): def isPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; newS = [i.lower() for i in s if i.isalnum()] return newS == newS[::-1] https://discuss.leetcode.com/topic/8282/accepted-pretty-java-solution-271ms Accepted pretty Java solution(271ms) 1234567891011121314151617181920212223242526public class Solution &#123; public boolean isPalindrome(String s) &#123; if (s.isEmpty()) &#123; return true; &#125; int head = 0, tail = s.length() - 1; char cHead, cTail; while(head &lt;= tail) &#123; cHead = s.charAt(head); cTail = s.charAt(tail); if (!Character.isLetterOrDigit(cHead)) &#123; head++; &#125; else if(!Character.isLetterOrDigit(cTail)) &#123; tail--; &#125; else &#123; if (Character.toLowerCase(cHead) != Character.toLowerCase(cTail)) &#123; return false; &#125; head++; tail--; &#125; &#125; return true; &#125;&#125; Solution 2: 12ms, 40.64%, April.23rd, 2016 https://leetcode.com/discuss/80399/7-lines-concise-and-easy-understand-c-solution 12345678910111213class Solution &#123;public: bool isPalindrome(string s) &#123; int l=0, r = s.size() - 1; while(l &lt;= r)&#123; while(!isalnum(s[l]) &amp;&amp; l &lt; r) l++; while(!isalnum(s[r]) &amp;&amp; l &lt; r) r--; if(toupper(s[l]) != toupper(s[r])) return false; l++, r--; &#125; return true; &#125;&#125;; Solution 3: 16ms, 10.11%, April.23rd, 2016 1234567891011121314class Solution &#123;public: bool isPalindrome(string s) &#123; transform(s.begin(), s.end(), s.begin(), ::tolower); auto left = s.begin(), right = s.end(); while(left &lt; right)&#123; if(!::isalnum(*left)) ++left; else if(!::isalnum(*right)) --right; else if(*left != *right) return false; else&#123;left++, right--;&#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[124. Binary Tree Maximum Path Sum]]></title>
    <url>%2Fp%2Fa3afbfd3%2F</url>
    <content type="text"><![CDATA[25.3% https://leetcode.com/problems/binary-tree-maximum-path-sum/?tab=Description Given a binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. 1234567For example:Given the below binary tree, 1 / \ 2 3Return 6. 面试360时遇到，核心提示，使用带参数的函数。 方法一： [recommend for beginners]clean C++ implementation with detailed explanation help函数，表征从root节点开始，至叶节点之间的最大value。 sum通过获取，help(root-&gt;left), help(root-&gt;right)， 再加上root-&gt;val的和为sum，与先前的sum比较，进行更新。 其中，help(root-&gt;left)&lt;=0时，此处应为0。 code 1： 1234567891011121314151617181920class Solution &#123; int sum;public: int maxPathSum(TreeNode* root) &#123; sum=INT_MIN; help(root); return sum; &#125; /*** return the max-value-ended-at-root-node ***/ int help(TreeNode* root)&#123; if(!root) return 0; int left = max(0, help(root-&gt;left)); int right = max(0, help(root-&gt;right)); /*** key parts : embedding the max-value-find in the recursion process ***/ sum = max(sum, left+right+root-&gt;val); /*** get the max-value-ended-at-root ***/ return max(left, right)+root-&gt;val; &#125;&#125;; code 2： 1234567891011121314151617class Solution &#123; int maxToRoot(TreeNode *root, int &amp;re) &#123; if (!root) return 0; int l = maxToRoot(root-&gt;left, re); int r = maxToRoot(root-&gt;right, re); if (l &lt; 0) l = 0; if (r &lt; 0) r = 0; if (l + r + root-&gt;val &gt; re) re = l + r + root-&gt;val; return root-&gt;val += max(l, r); &#125;public: int maxPathSum(TreeNode *root) &#123; int max = -2147483648; maxToRoot(root, max); return max; &#125;&#125;; code 3： 我自己的代码 逻辑还是很简单的，但是要考虑周全，不然ac不过去。 res表示最长路径的大小，然后在helper函数中，传的是地址。 helper中是树的先序遍历。root==NULL自不必说。helper函数返回当前节点出发至下面任意节点之间的最大的值得大小。当前的root对应的的值为cur，要考虑这个大小，就要考虑左节点出发的大小，右节点的大小，这时，更新下res的大小，通过当前节点的加上左右分支的节点的最大值，为cur_max去更新res的值。然后返回值呢，就是左节点右节点的最大值与0的最大值加上cur，因为返回值是通过当前节点的一条分支的最大值。 1234567891011121314151617181920class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; if(root==NULL) return 0; int res = INT_MIN; // 初始值设置为INT_MIN，而不是0，否则负数会出错误结果。 helper(root, res); return res; &#125; int helper(TreeNode* root, int &amp; res)&#123; if(root==NULL) return 0; int cur = root-&gt;val; int left = helper(root-&gt;left, res); int right = helper(root-&gt;right, res); int cur_max = max(left,0) + max(right, 0) + cur; res = max(cur_max, res); return max(max(left, right), 0)+cur; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; int res = INT_MIN; helper(root, res); return res; &#125; int helper(TreeNode* root, int &amp; res)&#123; if(!root) return 0; int left = helper(root-&gt;left, res); int right = helper(root-&gt;right, res); left = max(left, 0); right = max(right, 0); res = max(left+right+root-&gt;val, res); return max(left, right)+root-&gt;val; &#125;&#125;; 方法二： 这种方法与上一种逻辑上是一样的，不同的是，一是res在全局变量（是这个名字？？），更重要的是它设定了一个res的初始值，就避免了使用INT_MIN。 12345678910111213141516class Solution &#123; int res;public: int depth(TreeNode *root)&#123; if(root==NULL) return 0; int a=depth(root-&gt;left), b=depth(root-&gt;right); res=max(res,a+b+root-&gt;val);//if *root is the top node in the path return max(0,max(a, b)+root-&gt;val);//if *root is in the path, if this branch a burden or a plus &#125; int maxPathSum(TreeNode *root) &#123; if(root==NULL) return 0; res=root-&gt;val; depth(root); return res; &#125;&#125;; https://discuss.leetcode.com/topic/5508/simple-o-n-algorithm-with-one-traversal-through-the-tree Simple O(n) algorithm with one traversal through the tree 1234567891011121314151617class Solution &#123; int maxToRoot(TreeNode *root, int &amp;re) &#123; if (!root) return 0; int l = maxToRoot(root-&gt;left, re); int r = maxToRoot(root-&gt;right, re); if (l &lt; 0) l = 0; if (r &lt; 0) r = 0; if (l + r + root-&gt;val &gt; re) re = l + r + root-&gt;val; return root-&gt;val += max(l, r); &#125;public: int maxPathSum(TreeNode *root) &#123; int max = -2147483648; maxToRoot(root, max); return max; &#125;&#125;; update the val of each node of the tree bottom-up, the new val of TreeNode *x stands for the max sum started from any node in subtree x and ended in x, mataining the re for result in traversal at the same time. https://discuss.leetcode.com/topic/5508/simple-o-n-algorithm-with-one-traversal-through-the-tree/5 Good solution! Essentially same as mine, but I don’t see why you update the val of each node, since each node is visited only once. In my version, I just return the maximum path ending at the root of the current tree while potentially updating the value of the global maximum with the path that links left and right. 1234567891011121314151617class Solution &#123;public: int maxPathSum(TreeNode *root) &#123; int max = numeric_limits&lt;int&gt;::min(); maxPathAndGlobalUpdate(root, &amp;max); return max; &#125;private: int maxPathAndGlobalUpdate(TreeNode *root, int* _global_max) &#123; if (root == nullptr) return 0; int&amp; global_max = *_global_max; int l = max(0, maxPathAndGlobalUpdate(root-&gt;left, &amp;global_max)); int r = max(0, maxPathAndGlobalUpdate(root-&gt;right, &amp;global_max)); global_max = max(global_max, l + r + root-&gt;val); return root-&gt;val + max(l, r); &#125;&#125;; 42ms, 15.55%, October 14, 2016 A very concise recursive solution https://discuss.leetcode.com/topic/7325/a-very-concise-recursive-solution 12345678910111213141516class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; int maxPath = INT_MIN; dfsMaxPath(root, maxPath); return maxPath; &#125; int dfsMaxPath(TreeNode *root, int &amp;maxPath)&#123; if(!root) return 0; int l = max(0, dfsMaxPath(root-&gt;left, maxPath)); int r = max(0, dfsMaxPath(root-&gt;right, maxPath)); maxPath = max(maxPath, l+r+root-&gt;val); return root-&gt;val + max(l, r); &#125;&#125;; https://discuss.leetcode.com/topic/2644/accepted-o-n-solution Accepted O(n) solution The idea is based on the solution of max sum of a sequence array, Here is the explaination of the code: Have a recursive method which traverse the binary tree, it also return the max possible sum of left branch and right branch saperately. for example, For node A, when it’s left and right node recusive call returned, we will know the max possible sum of left branch, right branch. Have a CheckMax function which will compare the sequence sum and record the max history. For node A, check whether left branch + this node + right branch is the maximum, check whether left branch + this node is max， check whether right branch + this node is max. When recursive method return, we should only return the max sum of one path - either the left branch + this node, or the right branch + this node. So that this is still a single path and can be used to link by node A’s parent node. It’s accepted by OL. Let me know if you have any question 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public: int maxPathSum(TreeNode *root) &#123; if(!root) return 0; maxSum = root-&gt;val; recNodes(root); return maxSum; &#125; protected: int recNodes(TreeNode* node) &#123; int numl=0,numr=0; if (node-&gt;left) numl = recNodes(node-&gt;left); if (node-&gt;right) numr = recNodes(node-&gt;right); //choose the max path, either left or right int value = node-&gt;val; int sumWhole = checkMax(value,numl+numr); int sumLeft = numl&gt;0?checkMax(value,numl):value; int sumRight = numr&gt;0?checkMax(value,numr):value; return max(sumLeft,sumRight); &#125; int checkMax(int value, int sum) &#123; if(sum&gt;0) sum+=value; else sum=value; if(sum&gt;maxSum) maxSum = sum; return sum; &#125; int maxSum; &#125;; https://discuss.leetcode.com/topic/35300/recommend-for-beginners-clean-c-implementation-with-detailed-explanation [recommend for beginners]clean C++ implementation with detailed explanation 1234567891011121314151617181920class Solution &#123; int sum;public: int maxPathSum(TreeNode* root) &#123; sum=INT_MIN; help(root); return sum; &#125; /*** return the max-value-ended-at-root-node ***/ int help(TreeNode* root)&#123; if(!root) return 0; int left = max(0, help(root-&gt;left)); int right = max(0, help(root-&gt;right)); /*** key parts : embedding the max-value-find in the recursion process ***/ sum = max(sum, left+right+root-&gt;val); /*** get the max-value-ended-at-root ***/ return max(left, right)+root-&gt;val; &#125;&#125;; https://discuss.leetcode.com/topic/11112/clean-c-solution Clean c++ solution 12345678910111213141516class Solution &#123; int res;public: int depth(TreeNode *root)&#123; if(root==NULL) return 0; int a=depth(root-&gt;left), b=depth(root-&gt;right); res=max(res,a+b+root-&gt;val);//if *root is the top node in the path return max(0,max(a, b)+root-&gt;val);//if *root is in the path, if this branch a burden or a plus &#125; int maxPathSum(TreeNode *root) &#123; if(root==NULL) return 0; res=root-&gt;val; depth(root); return res; &#125;&#125;; 2ms, 42.51%, October 14, 2016 https://discuss.leetcode.com/topic/4407/accepted-short-solution-in-java 1234567891011121314151617public class Solution &#123; int maxValue; public int maxPathSum(TreeNode root) &#123; maxValue = Integer.MIN_VALUE; maxPathDown(root); return maxValue; &#125; private int maxPathDown(TreeNode node)&#123; if(node == null) return 0; int left = Math.max(0, maxPathDown(node.left)); int right = Math.max(0, maxPathDown(node.right)); maxValue = Math.max(maxValue, left+right+node.val); return Math.max(left, right) + node.val; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[123. Best Time to Buy and Sell Stock III]]></title>
    <url>%2Fp%2F3ac663d0%2F</url>
    <content type="text"><![CDATA[28.6% https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 方法一： 微策略面试题 我的代码实现： Oct 17, 2017 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; v = &#123;INT_MIN, 0, INT_MIN, 0&#125;; for(auto price:prices)&#123; v[0] = max(v[0], -price); v[1] = max(v[1], v[0]+price); v[2] = max(v[2], v[1]-price); v[3] = max(v[3], v[2]+price); &#125; return max(v[1], v[3]); &#125;&#125;; My C++ solution (O(N) time, O(1) space, 8ms) It is similar to other buy/sell problems. just do DP and define an array of states to track the current maximum profits at different stages. For example, in the below code states[][0]: one buy states[][1]: one buy, one sell states[][2]: two buys, one sell states[][3]: two buy, two sells The states transistions occurs when buy/sell operations are executed. For example, state[][0] can move to state[][1] via one sell operation. 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int states[2][4] = &#123;INT_MIN, 0, INT_MIN, 0&#125;; // 0: 1 buy, 1: one buy/sell, 2: 2 buys/1 sell, 3, 2 buys/sells int len = prices.size(), i, cur = 0, next =1; for(i=0; i&lt;len; ++i) &#123; states[next][0] = max(states[cur][0], -prices[i]); states[next][1] = max(states[cur][1], states[cur][0]+prices[i]); states[next][2] = max(states[cur][2], states[cur][1]-prices[i]); states[next][3] = max(states[cur][3], states[cur][2]+prices[i]); swap(next, cur); &#125; return max(states[cur][1], states[cur][3]); &#125;&#125;; 方法二： 高效、简便、容易想到的方法 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); if(n&lt;2) return 0; vector&lt;int&gt; dp1(n, 0); vector&lt;int&gt; dp2(n, 0); int minPrice = INT_MAX; int maxProfit1 = 0; for(int i=0; i&lt;n; i++)&#123; minPrice = min(minPrice, prices[i]); maxProfit1 = max(maxProfit1, prices[i]-minPrice); dp1[i] = maxProfit1; &#125; int maxPrice = INT_MIN; int maxProfit2 = 0; for(int i=n-1; i&gt;=0; i--)&#123; maxPrice = max(maxPrice, prices[i]); maxProfit2 = max(maxProfit2, maxPrice-prices[i]); dp2[i] = maxProfit2; &#125; int maxProfit = 0; for(int i=0; i&lt;n; i++)&#123; maxProfit = max(maxProfit, dp1[i]+dp2[i]); &#125; return maxProfit; &#125;&#125;; cpp https://discuss.leetcode.com/topic/19750/my-c-solution-o-n-time-o-1-space-8ms My C++ solution (O(N) time, O(1) space, 8ms) It is similar to other buy/sell problems. just do DP and define an array of states to track the current maximum profits at different stages. For example, in the below code states[][0]: one buy states[][1]: one buy, one sell states[][2]: two buys, one sell states[][3]: two buy, two sells The states transistions occurs when buy/sell operations are executed. For example, state[][0] can move to state[][1] via one sell operation. 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int states[2][4] = &#123;INT_MIN, 0, INT_MIN, 0&#125;; // 0: 1 buy, 1: one buy/sell, 2: 2 buys/1 sell, 3, 2 buys/sells int len = prices.size(), i, cur = 0, next =1; for(i=0; i&lt;len; ++i) &#123; states[next][0] = max(states[cur][0], -prices[i]); states[next][1] = max(states[cur][1], states[cur][0]+prices[i]); states[next][2] = max(states[cur][2], states[cur][1]-prices[i]); states[next][3] = max(states[cur][3], states[cur][2]+prices[i]); swap(next, cur); &#125; return max(states[cur][1], states[cur][3]); &#125;&#125;; https://discuss.leetcode.com/topic/27426/a-solution-not-so-dynamic-programming A solution not so dynamic programming. I think the most difficult part is how to connect the first transaction to the second transaction. The final target is to get the maximum value of profit2. You must try to get money as much as possible after you buy the stock second time. Then after the second time of sell, with the as high as possible price, you get the maximum profit. 1234567891011121314151617class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int size=prices.size(); int profit1=0; int profit2=0; int o1=INT_MAX; int o2=INT_MIN; for(int i=0; i&lt;size; ++i)&#123; o1=min(o1, prices[i]); profit1=max(profit1, prices[i]-o1); o2=max(o2, profit1-prices[i]); profit2=max(profit2, prices[i]+o2); &#125; return profit2; &#125;&#125;; https://discuss.leetcode.com/topic/902/don-t-need-dp-to-solve-it-within-o-n Don’t need DP to solve it within O(n) Don’t need DP to solve this problem. It is still O(n) and basically use the same algorithm solving “Stock I” four times. Get the max profit with one transaction to the full array. Keep down the start and end positions. the start and end positions will be included in the result of two transaction. It falls into two categories:A) it is one full transaction, B) they belong to two separate transactions(start belongs to first transaction and end belongs to second transaction). if A)– get max profit with one transaction to subarray from 0 to start ; get max profit with one transaction to subarray from end to prices.length. if B)– get the max profit with one transaction within start and end in reverse order return the max profit in those cases. https://discuss.leetcode.com/topic/41049/clear-c-solution Clear c++ solution 123456789101112int maxProfit(vector&lt;int&gt;&amp; prices) &#123; //It&apos;s wrong if you choose the minimum price for buy2 , but you can maximize the left money. // int buy1 = INT_MIN, sale1 = 0, buy2 = INT_MIN, sale2 = 0; for(int i=0; i&lt;prices.size(); i++)&#123; //the more money left, the happier you will be buy1 = max(buy1, -prices[i]); //left money after buy1 sale1 = max(sale1, prices[i] + buy1); //left money after sale1 buy2 = max(buy2, sale1 - prices[i]); //left money after buy2 sale2 = max(sale2, prices[i] + buy2); //left money after sale2 &#125; return sale2;&#125; https://discuss.leetcode.com/topic/42087/why-don-t-we-make-our-life-easier Why don’t we make our life easier The idea is very basic. At most two transactions means we can break at any time point and compute the max revenue before this time point and after this time point. For every possible time point, we choose the maximum. Note that right_max start from the last time point, which is just like a mirror algorithm from the Best Time to Buy and Sell Stock I 123456789101112131415161718192021222324252627int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; left_max; vector&lt;int&gt; right_max; int n = prices.size(); if(n == 0)&#123; return 0; &#125; int cur_min = prices[0]; int max_r = 0; for(int i = 0; i &lt; n; i++)&#123; max_r = max(max_r, prices[i] - cur_min); left_max.push_back(max_r); cur_min = min(cur_min, prices[i]); &#125; int cur_max = prices[n-1]; max_r = 0; for(int i = n-1; i &gt;= 0; i--)&#123; max_r = max(max_r, cur_max - prices[i]); right_max.insert(right_max.begin(), max_r); cur_max = max(cur_max, prices[i]); &#125; int sum_max = 0; for(int i = 0; i &lt; n; i++)&#123; sum_max = max(sum_max, left_max[i] + right_max[i]); &#125; return sum_max;&#125; python https://discuss.leetcode.com/topic/6811/python-dp-solution-120ms Python DP solution, 120ms Two passes through the list, O(n) time, O(n) space: 12345678910111213141516171819202122232425def maxProfit(self, prices): if not prices: return 0 # forward traversal, profits record the max profit # by the ith day, this is the first transaction profits = [] max_profit = 0 current_min = prices[0] for price in prices: current_min = min(current_min, price) max_profit = max(max_profit, price - current_min) profits.append(max_profit) # backward traversal, max_profit records the max profit # after the ith day, this is the second transaction total_max = 0 max_profit = 0 current_max = prices[-1] for i in range(len(prices) - 1, -1, -1): current_max = max(current_max, prices[i]) max_profit = max(max_profit, current_max - prices[i]) total_max = max(total_max, max_profit + profits[i]) return total_max https://discuss.leetcode.com/topic/51468/7-liner-in-python-beats-99 7-liner in Python, beats 99% 1234567891011121314class Solution(object): def maxProfit(self, p): if not p: return 0 sell, buyd, n, minp, maxp = [0], [0], len(p), p[0], p[-1] for i in range(1, n): minp, maxp = min(minp, p[i]), max(maxp, p[n-i-1]) sell.append(max(sell[i-1], p[i] - minp)) buyd.append(max(buyd[i-1], maxp - p[n-i-1])) return max(sell[i] + buyd[n-i-1] for i in range(n))# 198 / 198 test cases passed.# Status: Accepted# Runtime: 56 ms java https://discuss.leetcode.com/topic/5934/is-it-best-solution-with-o-n-o-1 Is it Best Solution with O(n), O(1). The thinking is simple and is inspired by the best solution from Single Number II (I read through the discussion after I use DP). Assume we only have 0 money at first; 4 Variables to maintain some interested ‘ceilings’ so far: The maximum of if we’ve just buy 1st stock, if we’ve just sold 1nd stock, if we’ve just buy 2nd stock, if we’ve just sold 2nd stock. Very simple code too and work well. I have to say the logic is simple than those in Single Number II. 12345678910111213public class Solution &#123; public int maxProfit(int[] prices) &#123; int hold1 = Integer.MIN_VALUE, hold2 = Integer.MIN_VALUE; int release1 = 0, release2 = 0; for(int i:prices)&#123; // Assume we only have 0 money at first release2 = Math.max(release2, hold2+i); // The maximum if we&apos;ve just sold 2nd stock so far. hold2 = Math.max(hold2, release1-i); // The maximum if we&apos;ve just buy 2nd stock so far. release1 = Math.max(release1, hold1+i); // The maximum if we&apos;ve just sold 1nd stock so far. hold1 = Math.max(hold1, -i); // The maximum if we&apos;ve just buy 1st stock so far. &#125; return release2; ///Since release1 is initiated as 0, so release2 will always higher than release1. &#125;&#125; https://discuss.leetcode.com/topic/4766/a-clean-dp-solution-which-generalizes-to-k-transactions A clean DP solution which generalizes to k transactions Solution is commented in the code. Time complexity is O(kn), space complexity can be O(n) because this DP only uses the result from last step. But for cleaness this solution still used O(kn) space complexity to preserve similarity to the equations in the comments. 12345678910111213141516171819202122232425class Solution &#123;public: int maxProfit(vector&lt;int&gt; &amp;prices) &#123; // f[k, ii] represents the max profit up until prices[ii] (Note: NOT ending with prices[ii]) using at most k transactions. // f[k, ii] = max(f[k, ii-1], prices[ii] - prices[jj] + f[k-1, jj]) &#123; jj in range of [0, ii-1] &#125; // = max(f[k, ii-1], prices[ii] + max(f[k-1, jj] - prices[jj])) // f[0, ii] = 0; 0 times transation makes 0 profit // f[k, 0] = 0; if there is only one price data point you can&apos;t make any money no matter how many times you can trade if (prices.size() &lt;= 1) return 0; else &#123; int K = 2; // number of max transation allowed int maxProf = 0; vector&lt;vector&lt;int&gt;&gt; f(K+1, vector&lt;int&gt;(prices.size(), 0)); for (int kk = 1; kk &lt;= K; kk++) &#123; int tmpMax = f[kk-1][0] - prices[0]; for (int ii = 1; ii &lt; prices.size(); ii++) &#123; f[kk][ii] = max(f[kk][ii-1], prices[ii] + tmpMax); tmpMax = max(tmpMax, f[kk-1][ii] - prices[ii]); maxProf = max(f[kk][ii], maxProf); &#125; &#125; return maxProf; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/4766/a-clean-dp-solution-which-generalizes-to-k-transactions/2 Brilliant solution! a small point: there is no need to track maxProf. we can simply return f[K][prices.size()-1] https://discuss.leetcode.com/topic/4766/a-clean-dp-solution-which-generalizes-to-k-transactions/9 Brilliant solution! Thanks for sharing~ Minor point, but f[kk-1][0] is just 0. I’d also explain the algorithm a little differently, something like the following: 123456// dpProfit[t][i]: maximum Profit using at most t transactions up to day i (including day i)// dpProfit[t][i] = max(dpProfit[t][i - 1], prices[i] - prices[j] + dpProfit[t - 1][j]) for all j in range [0, i - 1]// = max(dpProfit[t][i - 1], prices[i] + max(dpProfit[t - 1][j] - prices[j])) for all j in range [0, i - 1]// = max(dpProfit[t][i - 1], prices[i] + max prev [t - 1] trans profit at the corresponding j in range [0, i - 1] less price at j)// maxPreProfitLessI inside loop iterations// Note: subtracting price at j is for the last additional transaction to sell at day i https://discuss.leetcode.com/topic/39751/my-explanation-for-o-n-solution My explanation for O(N) solution! First assume that we have no money, so buy1 means that we have to borrow money from others, we want to borrow less so that we have to make our balance as max as we can(because this is negative). sell1 means we decide to sell the stock, after selling it we have price[i] money and we have to give back the money we owed, so we have price[i] - |buy1| = prices[i ] + buy1, we want to make this max. buy2 means we want to buy another stock, we already have sell1 money, so after buying stock2 we have buy2 = sell1 - price[i] money left, we want more money left, so we make it max sell2 means we want to sell stock2, we can have price[i] money after selling it, and we have buy2 money left before, so sell2 = buy2 + prices[i], we make this max. So sell2 is the most money we can have. Hope it is helpful and welcome quesions! 12345678910public int maxProfit(int[] prices) &#123; int sell1 = 0, sell2 = 0, buy1 = Integer.MIN_VALUE, buy2 = Integer.MIN_VALUE; for (int i = 0; i &lt; prices.length; i++) &#123; buy1 = Math.max(buy1, -prices[i]); sell1 = Math.max(sell1, buy1 + prices[i]); buy2 = Math.max(buy2, sell1 - prices[i]); sell2 = Math.max(sell2, buy2 + prices[i]); &#125; return sell2; &#125; https://discuss.leetcode.com/topic/32288/2ms-java-dp-solution 2ms Java DP Solution Sorry for my poor English 12345678910111213141516public int maxProfit(int[] prices) &#123; // these four variables represent your profit after executing corresponding transaction // in the beginning, your profit is 0. // when you buy a stock ,the profit will be deducted of the price of stock. int firstBuy = Integer.MIN_VALUE, firstSell = 0; int secondBuy = Integer.MIN_VALUE, secondSell = 0; for (int curPrice : prices) &#123; if (firstBuy &lt; -curPrice) firstBuy = -curPrice; // the max profit after you buy first stock if (firstSell &lt; firstBuy + curPrice) firstSell = firstBuy + curPrice; // the max profit after you sell it if (secondBuy &lt; firstSell - curPrice) secondBuy = firstSell - curPrice; // the max profit after you buy the second stock if (secondSell &lt; secondBuy + curPrice) secondSell = secondBuy + curPrice; // the max profit after you sell the second stock &#125; return secondSell; // secondSell will be the max profit after passing the prices&#125; https://discuss.leetcode.com/topic/7028/java-solution-with-just-two-traverses Java solution with just two traverses. Go from left to right and calculate max profit for each index (i). Go from right to left and calculate max profit for (i). Add max right profit for (i) and max left profit for (i-1) and check if it’s max profit. 123456789101112131415161718192021222324252627public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) return 0; int lenght = prices.length; int[] leftProfit = new int[lenght]; int leftMaxProfit = 0; int leftMin = prices[0]; for (int i=0; i&lt;lenght; i++) &#123; if (prices[i] &lt; leftMin) leftMin = prices[i]; if (prices[i] - leftMin &gt; leftMaxProfit) leftMaxProfit = prices[i]-leftMin; leftProfit[i] = leftMaxProfit; &#125; int maxProfit = 0; int rightMaxProfit = 0; int rightMax = prices[lenght-1]; for (int i=lenght-1; i&gt;=0; i--) &#123; if (prices[i] &gt; rightMax) rightMax = prices[i]; if (rightMax - prices[i] &gt; rightMaxProfit) rightMaxProfit = rightMax - prices[i]; int currentProfit = rightMaxProfit + (i&gt;0 ? leftProfit[i-1] : 0); if (currentProfit &gt; maxProfit) &#123; maxProfit = currentProfit; &#125; &#125; return maxProfit;&#125; my code dp1中的dp[i] 表示从第一天至第i天，只卖出一次的最大收益。 dp2中的dp[i] 表示从第i天至最后一天，只卖出一次的最大收益。 dp1从前向后，dp2从后向前 12345678910111213141516171819202122232425262728public class Solution &#123; public int maxProfit(int[] prices) &#123; int[] dp1 = new int[prices.length]; int[] dp2 = new int[prices.length]; int minprice = Integer.MAX_VALUE; int maxprofit = 0; for(int i=0; i&lt;prices.length; i++)&#123; if(prices[i] &lt; minprice) minprice = prices[i]; else maxprofit = Math.max(maxprofit, prices[i]-minprice); dp1[i] = maxprofit; &#125; int maxprice = Integer.MIN_VALUE; maxprofit = 0; for(int j=prices.length-1; j&gt;=0; j--)&#123; if(prices[j] &gt; maxprice) maxprice = prices[j]; else maxprofit = Math.max(maxprofit, maxprice-prices[j]); dp2[j] = maxprofit; &#125; maxprofit = 0; for(int i=0; i&lt;prices.length; i++) maxprofit = Math.max(maxprofit, dp1[i]+dp2[i]); return maxprofit; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[122. Best Time to Buy and Sell Stock II]]></title>
    <url>%2Fp%2Ffca87911%2F</url>
    <content type="text"><![CDATA[46.0% https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 方法一： 我的代码实现： 123456789class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0; for(int i = 1; i&lt;prices.size(); i++) res += max(prices[i]-prices[i-1], 0); return res; &#125;&#125;; Second, suppose the first sequence is “a &lt;= b &lt;= c &lt;= d”, the profit is “d - a = (b - a) + (c - b) + (d - c)” without a doubt. And suppose another one is “a &lt;= b &gt;= b’ &lt;= c &lt;= d”, the profit is not difficult to be figured out as “(b - a) + (d - b’)”. So you just target at monotone sequences. 12345678910class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int maxprofit = 0; for(size_t i=1; i&lt;prices.size(); i++)&#123; maxprofit += max(prices[i]-prices[i-1], 0); &#125; return maxprofit; &#125;&#125;; python Basically, if tomorrow’s price is higher than today’s, we buy it today and sell tomorrow. Otherwise, we don’t. Here is the code: 1234567class Solution(object): def maxProfit(self, prices): &quot;&quot;&quot; :type prices: List[int] :rtype: int &quot;&quot;&quot; return sum(max(prices[i+1]-prices[i], 0) for i in range(len(prices)-1)) java Algorithm This solution follows the logic used in Approach 2 itself, but with only a slight variation. In this case, instead of looking for every peak following a valley, we can simply go on crawling over the slope and keep on adding the profit obtained from every consecutive transaction. In the end,we will be using the peaks and valleys effectively, but we need not track the costs corresponding to the peaks and valleys along with the maximum profit, but we can directly keep on adding the difference between the consecutive numbers of the array if the second number is larger than the first one, and at the total sum we obtain will be the maximum profit. This approach will simplify the solution. This can be made clearer by taking this example: [1, 7, 2, 3, 6, 7, 6, 7] The graph corresponding to this array is: If we analyze the graph, we notice that the points of interest are the consecutive valleys and peaks. Complexity Analysis Time complexity : O(n)O(n). Single pass. Space complexity : O(1)O(1). Constant space required. 12345678910111213141516171819public class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices.length==0) return 0; int i=0; int maxprofit = 0; int valley = prices[0]; int peak = prices[0]; while(i&lt;prices.length-1)&#123; while(i&lt;prices.length-1 &amp;&amp; prices[i]&gt;=prices[i+1]) i++; valley = prices[i]; while(i&lt;prices.length-1 &amp;&amp; prices[i]&lt;=prices[i+1]) i++; peak = prices[i]; maxprofit += peak - valley; &#125; return maxprofit; &#125;&#125; https://leetcode.com/articles/best-time-buy-and-sell-stock-ii/ Algorithm This solution follows the logic used in Approach 2 itself, but with only a slight variation. In this case, instead of looking for every peak following a valley, we can simply go on crawling over the slope and keep on adding the profit obtained from every consecutive transaction. In the end,we will be using the peaks and valleys effectively, but we need not track the costs corresponding to the peaks and valleys along with the maximum profit, but we can directly keep on adding the difference between the consecutive numbers of the array if the second number is larger than the first one, and at the total sum we obtain will be the maximum profit. This approach will simplify the solution. This can be made clearer by taking this example: [1, 7, 2, 3, 6, 7, 6, 7] The graph corresponding to this array is: From the above graph, we can observe that the sum A+B+CA+B+C is equal to the difference DD corresponding to the difference between the heights of the consecutive peak and valley. Complexity Analysis Time complexity : O(n)O(n). Single pass. Space complexity: O(1)O(1). Constant space needed. 12345678910public class Solution &#123; public int maxProfit(int[] prices) &#123; int maxprofit = 0; for(int i=1; i&lt;prices.length; i++)&#123; if(prices[i] - prices[i-1] &gt; 0) maxprofit += prices[i] - prices[i-1]; &#125; return maxprofit; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[121. Best Time to Buy and Sell Stock]]></title>
    <url>%2Fp%2F588afc94%2F</url>
    <content type="text"><![CDATA[40.0% https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. 123456Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) 123456Example 2:Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. 两种思路： 寻找低谷与峰值之间的差。设置一个变量为低谷，vally，另一个变量为目前找到的最大值，maxsofar，则从头开始遍历，如果当前值小于vally，则此值与vally的差为负，所以vally改为当前值，如果当前值大于vally，则计算当前值与vally的差。一次遍历。 第二种思路，重新设置一个数组，记录邻近两个数字的差，类似于寻找最长的数组。 方法一： 微策略面试题 我的代码实现： Oct 17， 2017 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int minPrice = INT_MAX; int maxPro = 0; for(auto price:prices)&#123; minPrice = min(price, minPrice); maxPro = max(maxPro, price - minPrice); &#125; return maxPro; &#125;&#125;; https://discuss.leetcode.com/topic/5863/sharing-my-simple-and-clear-c-solution Sharing my simple and clear C++ solution 123456789int maxProfit(vector&lt;int&gt; &amp;prices) &#123; int maxPro = 0; int minPrice = INT_MAX; // 此处不能用prices[0]代替，如果用，需要先判断prices.size()与0的关系 for(int i = 0; i &lt; prices.size(); i++)&#123; minPrice = min(minPrice, prices[i]); maxPro = max(maxPro, prices[i] - minPrice); &#125; return maxPro;&#125; minPrice is the minimum price from day 0 to day i. And maxPro is the maximum profit we can get from day 0 to day i. How to get maxPro? Just get the larger one between current maxPro and prices[i] - minPrice. 方法二： https://discuss.leetcode.com/topic/5863/sharing-my-simple-and-clear-c-solution/5 Very nice solution! But it still can be optimized. We only need to calculate either maxProfit or minPrice not both in every loop. Running time can be dropped by 33% percent. 1234567891011121314public int maxProfit(int[] prices) &#123; if(prices == null || prices.length &lt; 2) return 0; int maxProfit = 0, minPrice = prices[0]; for(int i = 1; i &lt; prices.length; i++) &#123; if(prices[i] &gt; prices[i - 1]) &#123; maxProfit = Math.max(maxProfit, prices[i] - minPrice); &#125; else &#123; minPrice = Math.min(minPrice, prices[i]); &#125; &#125; return maxProfit;&#125; cpp https://discuss.leetcode.com/topic/5863/sharing-my-simple-and-clear-c-solution Sharing my simple and clear C++ solution 123456789int maxProfit(vector&lt;int&gt; &amp;prices) &#123; int maxPro = 0; int minPrice = INT_MAX; for(int i = 0; i &lt; prices.size(); i++)&#123; minPrice = min(minPrice, prices[i]); maxPro = max(maxPro, prices[i] - minPrice); &#125; return maxPro;&#125; minPrice is the minimum price from day 0 to day i. And maxPro is the maximum profit we can get from day 0 to day i. How to get maxPro? Just get the larger one between current maxPro and prices[i] - minPrice. https://discuss.leetcode.com/topic/5863/sharing-my-simple-and-clear-c-solution/5 Very nice solution! But it still can be optimized. We only need to calculate either maxProfit or minPrice not both in every loop. Running time can be dropped by 33% percent. 1234567891011121314public int maxProfit(int[] prices) &#123; if(prices == null || prices.length &lt; 2) return 0; int maxProfit = 0, minPrice = prices[0]; for(int i = 1; i &lt; prices.length; i++) &#123; if(prices[i] &gt; prices[i - 1]) &#123; maxProfit = Math.max(maxProfit, prices[i] - minPrice); &#125; else &#123; minPrice = Math.min(minPrice, prices[i]); &#125; &#125; return maxProfit;&#125; https://discuss.leetcode.com/topic/42716/5-line-cpp-solution 5 line CPP solution 12345678int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int maxPro = 0, minPrice = INT_MAX; for(int i = 0; i &lt; prices.size(); i++) &#123; minPrice = min(minPrice, prices[i]); maxPro = max(prices[i] - minPrice, maxPro); &#125; return maxPro;&#125; python https://discuss.leetcode.com/topic/33241/easy-o-n-python-solution Easy O(n) Python solution 1234567def maxProfit(prices): max_profit, min_price = 0, float(&apos;inf&apos;) for price in prices: min_price = min(min_price, price) profit = price - min_price max_profit = max(max_profit, profit) return max_profit java Algorithm Say the given array is: [7, 1, 5, 3, 6, 4] If we plot the numbers of the given array on a graph, we get: The points of interest are the peaks and valleys in the given graph. We need to find the largest peak following the smallest valley. We can maintain two variables - minprice and maxprofit corresponding to the smallest valley and maximum profit (maximum difference between selling price and minprice) obtained so far respectively. Complexity Analysis Time complexity : O(n)O(n). Only a single pass is needed. Space complexity : O(1)O(1). Only two variables are used. 针对每个点，与最小点比差值，如果最小点小于当前值，可以看其差值是否可以做最小值，如果最小点大于当前最小值，当前值可以作为最小值。 关键在于对每一个值遍历。12345678910111213public class Solution &#123; public int maxProfit(int[] prices) &#123; int minprice = Integer.MAX_VALUE; int maxprofit = 0; for(int i=0; i&lt;prices.length; i++)&#123; if(prices[i]&lt;minprice) minprice = prices[i]; else if(prices[i] - minprice &gt; maxprofit) maxprofit = prices[i] - minprice; &#125; return maxprofit; &#125;&#125; my code: 1234567891011121314public class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices.length&lt;=1) return 0; int valley=prices[0]; int maxprofit = 0; for(int i=1; i&lt;prices.length; i++)&#123; if(prices[i-1]&gt;prices[i]) valley = Math.min(valley, prices[i]); else if(prices[i]-valley&gt;maxprofit) maxprofit = prices[i]-valley; &#125; return maxprofit; &#125;&#125; https://discuss.leetcode.com/topic/19853/kadane-s-algorithm-since-no-one-has-mentioned-about-this-so-far-in-case-if-interviewer-twists-the-input The logic to solve this problem is same as “max subarray problem” using Kadane’s Algorithm. Since no body has mentioned this so far, I thought it’s a good thing for everybody to know. All the straight forward solution should work, but if the interviewer twists the question slightly by giving the difference array of prices, Ex: for {1, 7, 4, 11}, if he gives {0, 6, -3, 7}, you might end up being confused. Here, the logic is to calculate the difference (maxCur += prices[i] - prices[i-1]) of the original array, and find a contiguous subarray giving maximum profit. If the difference falls below 0, reset it to zero. maxCur = current maximum value maxSoFar = maximum value found so far 12345678public int maxProfit(int[] prices) &#123; int maxCur = 0, maxSoFar = 0; for(int i = 1; i &lt; prices.length; i++) &#123; maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]); maxSoFar = Math.max(maxCur, maxSoFar); &#125; return maxSoFar;&#125; https://discuss.leetcode.com/topic/19853/kadane-s-algorithm-since-no-one-has-mentioned-about-this-so-far-in-case-if-interviewer-twists-the-input/2 Please refer to this for more details on the algorithm : https://en.wikipedia.org/wiki/Maximum_subarray_problem]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[120. Triangle]]></title>
    <url>%2Fp%2F9545f0d7%2F</url>
    <content type="text"><![CDATA[32.8% https://leetcode.com/problems/triangle/?tab=Description Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. 12345678For example, given the following triangle[ [2], [3,4], [6,5,7], [4,1,8,3]]The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note:Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. C++ top-down and bottom-up solutions 方法一： top down 1234567891011121314// top-down int minimumTotal1(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; res(triangle.size(), triangle[0][0]); for (unsigned int i = 1; i &lt; triangle.size(); i++) for (int j = i; j &gt;= 0; j--) &#123; if (j == 0) res[0] += triangle[i][j]; else if (j == i) res[j] = triangle[i][j] + res[j-1]; else res[j] = triangle[i][j] + min(res[j-1], res[j]); &#125; return *min_element(res.begin(), res.end());&#125; 方法二： bottom up 我的代码实现: Oct 17, 2017 123456789101112class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int n = triangle.size(); if(n==0) return 0; for(int i=n-2; i&gt;=0; i--)&#123; for(int j=0; j&lt;triangle[i].size(); j++) triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]); &#125; return triangle[0][0]; &#125;&#125;; 12345678// bottom-upint minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; res = triangle.back(); for (int i = triangle.size()-2; i &gt;= 0; i--) for (unsigned int j = 0; j &lt;= i; j++) res[j] = triangle[i][j] + min(res[j], res[j+1]); return res[0];&#125; cpp https://discuss.leetcode.com/topic/1669/dp-solution-for-triangle DP Solution for Triangle This problem is quite well-formed in my opinion. The triangle has a tree-like structure, which would lead people to think about traversal algorithms such as DFS. However, if you look closely, you would notice that the adjacent nodes always share a ‘branch’. In other word, there are overlapping subproblems. Also, suppose x and y are ‘children’ of k. Once minimum paths from x and y to the bottom are known, the minimum path starting from k can be decided in O(1), that is optimal substructure. Therefore, dynamic programming would be the best solution to this problem in terms of time complexity. What I like about this problem even more is that the difference between ‘top-down’ and ‘bottom-up’ DP can be ‘literally’ pictured in the input triangle. For ‘top-down’ DP, starting from the node on the very top, we recursively find the minimum path sum of each node. When a path sum is calculated, we store it in an array (memoization); the next time we need to calculate the path sum of the same node, just retrieve it from the array. However, you will need a cache that is at least the same size as the input triangle itself to store the pathsum, which takes O(N^2) space. With some clever thinking, it might be possible to release some of the memory that will never be used after a particular point, but the order of the nodes being processed is not straightforwardly seen in a recursive solution, so deciding which part of the cache to discard can be a hard job. ‘Bottom-up’ DP, on the other hand, is very straightforward: we start from the nodes on the bottom row; the min pathsums for these nodes are the values of the nodes themselves. From there, the min pathsum at the ith node on the kth row would be the lesser of the pathsums of its two children plus the value of itself, i.e.: 1minpath[k][i] = min( minpath[k+1][i], minpath[k+1][i+1]) + triangle[k][i]; Or even better, since the row minpath[k+1] would be useless after minpath[k] is computed, we can simply set minpath as a 1D array, and iteratively update itself: 12For the kth level:minpath[i] = min( minpath[i], minpath[i+1]) + triangle[k][i]; Thus, we have the following solution 12345678910111213int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) &#123; int n = triangle.size(); vector&lt;int&gt; minlen(triangle.back()); for (int layer = n-2; layer &gt;= 0; layer--) // For each layer &#123; for (int i = 0; i &lt;= layer; i++) // Check its every &apos;node&apos; &#123; // Find the lesser of its two children, and sum the current value in the triangle with it. minlen[i] = min(minlen[i], minlen[i+1]) + triangle[layer][i]; &#125; &#125; return minlen[0];&#125; https://discuss.leetcode.com/topic/6671/bottom-up-5-line-c-solution Bottom Up 5 line C++ Solution 1234567891011class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) &#123; vector&lt;int&gt; mini = triangle[triangle.size()-1]; for ( int i = triangle.size() - 2; i&gt;= 0 ; --i ) for ( int j = 0; j &lt; triangle[i].size() ; ++ j ) mini[j] = triangle[i][j] + min(mini[j],mini[j+1]); return mini[0]; &#125;&#125;; https://discuss.leetcode.com/topic/29834/c-top-down-and-bottom-up-solutions C++ top-down and bottom-up solutions 1234567891011121314// top-down int minimumTotal1(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; res(triangle.size(), triangle[0][0]); for (unsigned int i = 1; i &lt; triangle.size(); i++) for (int j = i; j &gt;= 0; j--) &#123; if (j == 0) res[0] += triangle[i][j]; else if (j == i) res[j] = triangle[i][j] + res[j-1]; else res[j] = triangle[i][j] + min(res[j-1], res[j]); &#125; return *min_element(res.begin(), res.end());&#125; 12345678// bottom-upint minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; res = triangle.back(); for (int i = triangle.size()-2; i &gt;= 0; i--) for (unsigned int j = 0; j &lt;= i; j++) res[j] = triangle[i][j] + min(res[j], res[j+1]); return res[0];&#125; https://discuss.leetcode.com/topic/19834/my-c-code-bottom-up-dp-8ms My C++ code (Bottom up DP, 8ms) Just do bottom up DP, it is easier and cleaner than top-down DP. 12345678910class Solution &#123; public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; for(int i= triangle.size()-2; i&gt;=0; --i) for(int j=0; j&lt;triangle[i].size();++j) triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1]); return triangle[0][0]; &#125; &#125;; 123456789101112// another version, without modifying the input arrayclass Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; res(triangle[triangle.size()-1]); for(int i= triangle.size()-2; i&gt;=0; --i) for(int j=0; j&lt;triangle[i].size();++j) res[j] = triangle[i][j] + min(res[j],res[j+1]); return res[0]; &#125;&#125;; my code: 12345678910111213141516171819class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; if(triangle.size()==0) return 0; if(triangle.size()==1) return triangle[0][0]; for(int i=1; i&lt;triangle.size(); i++)&#123; for(int j=0; j&lt;triangle[i].size(); j++)&#123; if(j==0) triangle[i][j] += triangle[i-1][j]; else if(j==triangle[i].size()-1) triangle[i][j] += triangle[i-1][j-1]; else triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j]); &#125; &#125; int res = triangle[triangle.size()-1][0]; for(auto num:triangle[triangle.size()-1])&#123; res = min(res, num); &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/19754/python-easy-to-understand-solutions-top-down-bottom-up Python easy to understand solutions (top-down, bottom-up). 123456789101112131415# O(n*n/2) space, top-down def minimumTotal1(self, triangle): if not triangle: return res = [[0 for i in xrange(len(row))] for row in triangle] res[0][0] = triangle[0][0] for i in xrange(1, len(triangle)): for j in xrange(len(triangle[i])): if j == 0: res[i][j] = res[i-1][j] + triangle[i][j] elif j == len(triangle[i])-1: res[i][j] = res[i-1][j-1] + triangle[i][j] else: res[i][j] = min(res[i-1][j-1], res[i-1][j]) + triangle[i][j] return min(res[-1]) 12345678910111213# Modify the original triangle, top-downdef minimumTotal2(self, triangle): if not triangle: return for i in xrange(1, len(triangle)): for j in xrange(len(triangle[i])): if j == 0: triangle[i][j] += triangle[i-1][j] elif j == len(triangle[i])-1: triangle[i][j] += triangle[i-1][j-1] else: triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j]) return min(triangle[-1]) 12345678# Modify the original triangle, bottom-updef minimumTotal3(self, triangle): if not triangle: return for i in xrange(len(triangle)-2, -1, -1): for j in xrange(len(triangle[i])): triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]) return triangle[0][0] 123456789# bottom-up, O(n) spacedef minimumTotal(self, triangle): if not triangle: return res = triangle[-1] for i in xrange(len(triangle)-2, -1, -1): for j in xrange(len(triangle[i])): res[j] = min(res[j], res[j+1]) + triangle[i][j] return res[0] https://discuss.leetcode.com/topic/13970/one-liner-in-python One-liner in Python Solution 12def minimumTotal(self, t): return reduce(lambda a,b:[f+min(d,e)for d,e,f in zip(a,a[1:],b)],t[::-1])[0] Explanation Starting with the bottom row, I move upwards, always combining the current row and the next upper row. At the end, I have combined everything into the top row and simply return its only element. Here’s a longer version with meaningful variable names: 123456def minimumTotal(self, triangle): def combine_rows(lower_row, upper_row): return [upper + min(lower_left, lower_right) for upper, lower_left, lower_right in zip(upper_row, lower_row, lower_row[1:])] return reduce(combine_rows, triangle[::-1])[0] Solution mine: 60ms, 57.14%, June.22th, 2016 1234567891011121314class Solution(object): def minimumTotal(self, triangle): &quot;&quot;&quot; :type triangle: List[List[int]] :rtype: int &quot;&quot;&quot; if not triangle: return 0 for i in xrange(1, len(triangle)): triangle[i][0] += triangle[i-1][0] triangle[i][-1] += triangle[i-1][-1] for j in xrange(1, i): triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j]) return min(triangle[-1]) java https://discuss.leetcode.com/topic/8077/my-8-line-dp-java-code-4-meaningful-lines-with-o-1-space My 8 line DP Java code(4 meaningful lines) with O(1) space 12345678public class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; for(int i = triangle.size() - 2; i &gt;= 0; i--) for(int j = 0; j &lt;= i; j++) triangle.get(i).set(j, triangle.get(i).get(j) + Math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1))); return triangle.get(0).get(0); &#125;&#125; The idea is simple. Go from bottom to top. We start form the row above the bottom row [size()-2]. Each number add the smaller number of two numbers that below it. And finally we get to the top we the smallest sum. https://discuss.leetcode.com/topic/22254/7-lines-neat-java-solution 7 lines neat Java Solution 123456789public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int[] A = new int[triangle.size()+1]; for(int i=triangle.size()-1;i&gt;=0;i--)&#123; for(int j=0;j&lt;triangle.get(i).size();j++)&#123; A[j] = Math.min(A[j],A[j+1])+triangle.get(i).get(j); &#125; &#125; return A[0];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[119. Pascal's Triangle II]]></title>
    <url>%2Fp%2Ffb36f4c4%2F</url>
    <content type="text"><![CDATA[35.5% https://leetcode.com/problems/pascals-triangle-ii/?tab=Description Given an index k, return the kth row of the Pascal’s triangle. 12For example, given k = 3,Return [1,3,3,1]. Note: Could you optimize your algorithm to use only O(k) extra space? 方法一： 我的代码实现： Oct 17, 2017 12345678910class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; res(rowIndex+1, 1); for(int i=2; i&lt;=rowIndex; i++) for(int j=i-1; j&gt;0; j--) res[j] = res[j] + res[j-1]; return res; &#125;&#125;; 1234567891011class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; A(rowIndex+1, 0); A[0] = 1; for(int i=1; i&lt;rowIndex+1; i++) for(int j=i; j&gt;=1; j--) A[j] += A[j-1]; return A; &#125;&#125;; my code: 根据规则，同时从后向前加，就完成了。 12345678910111213class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; res(rowIndex+1, 0); res[0] = 1; for(int i=0; i&lt;rowIndex; i++)&#123; for(int j=i+1; j&gt;0; j--)&#123; res[j] += res[j-1]; &#125; &#125; return res; &#125;&#125;; java 3ms, 23.13%, June.21th, 2016 https://leetcode.com/discuss/40144/my-8-lines-java-solution-use-arraylist 123456789101112public class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); for(int i = 0;i&lt;rowIndex+1;i++) &#123; res.add(1); for(int j=i-1;j&gt;0;j--) &#123; res.set(j, res.get(j-1)+res.get(j)); &#125; &#125; return res; &#125;&#125; cpp 0ms, 21.63%, June.21th, 2016 https://leetcode.com/discuss/8364/here-is-my-brief-o-k-solution 1234567891011class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; A(rowIndex+1, 0); A[0] = 1; for(int i=1; i&lt;rowIndex+1; i++) for(int j=i; j&gt;=1; j--) A[j] += A[j-1]; return A; &#125;&#125;; my code: 根据规则，同时从后向前加，就完成了。 12345678910111213class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; res(rowIndex+1, 0); res[0] = 1; for(int i=0; i&lt;rowIndex; i++)&#123; for(int j=i+1; j&gt;0; j--)&#123; res[j] += res[j-1]; &#125; &#125; return res; &#125;&#125;; python Solution 1: 40ms, 94.22%, June.21th, 2016 https://leetcode.com/discuss/38977/very-simple-python-solution 12345678910class Solution(object): def getRow(self, rowIndex): &quot;&quot;&quot; :type rowIndex: int :rtype: List[int] &quot;&quot;&quot; row = [1] for i in range(1, rowIndex+1): row = list(map(lambda x, y: x+y, [0]+row, row +[0])) return row]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[118. Pascal's Triangle]]></title>
    <url>%2Fp%2Fe2b46218%2F</url>
    <content type="text"><![CDATA[37.2% https://leetcode.com/problems/pascals-triangle/ Given numRows, generate the first numRows of Pascal’s triangle. 12345678910For example, given numRows = 5,Return[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 方法一： 我的代码实现： October 17， 2017 1234567891011121314class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; if(numRows==0) return vector&lt;vector&lt;int&gt;&gt;(); vector&lt;vector&lt;int&gt;&gt; res(numRows, vector&lt;int&gt;(1, 1)); for(int i=2; i&lt;=numRows; i++)&#123; res[i-1].resize(i); res[i-1][0] = res[i-1][i-1] = 1; for(int j=0; j&lt;i-2; j++) res[i-1][j+1] = res[i-2][j] + res[i-2][j+1]; &#125; return res; &#125;&#125;; resize这个函数好用，同时想明白逻辑r[i][j] = r[i-1][j-1] + r[i-1][j]，就可以实现了。 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; r(numRows); for(int i = 0; i&lt;numRows; i++)&#123; r[i].resize(i+1); r[i][0] = r[i][i] = 1; for(int j=1; j&lt;i; j++) r[i][j] = r[i-1][j-1] + r[i-1][j]; &#125; return r; &#125;&#125;; 2ms, 3.04%, June.21th, 2016 https://leetcode.com/discuss/20606/my-concise-solution-in-java 12345678910111213141516public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; allrows = new ArrayList&lt;List&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; row = new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;numRows;i++) &#123; row.add(0, 1); for(int j=1;j&lt;row.size()-1;j++) row.set(j, row.get(j)+row.get(j+1)); allrows.add(new ArrayList&lt;Integer&gt;(row)); &#125; return allrows; &#125;&#125; 0ms, 26.23%, June.21th, 2016 https://leetcode.com/discuss/13921/maybe-shortest-c-solution resize这个函数好用，同时想明白逻辑r[i][j] = r[i-1][j-1] + r[i-1][j]，就可以实现了。 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; r(numRows); for(int i = 0; i&lt;numRows; i++)&#123; r[i].resize(i+1); r[i][0] = r[i][i] = 1; for(int j=1; j&lt;i; j++) r[i][j] = r[i-1][j-1] + r[i-1][j]; &#125; return r; &#125;&#125;; 68ms, 9.44%, June.21th, 2016 https://leetcode.com/discuss/54525/python-4-lines-short-solution-using-map 123456789101112class Solution(object): def generate(self, numRows): &quot;&quot;&quot; :type numRows: int :rtype: List[List[int]] &quot;&quot;&quot; if numRows == 0: return [] res = [[1]] for i in range(1, numRows): res += [map(lambda x, y:x+y, res[-1] + [0], [0] + res[-1])] return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[117. Populating Next Right Pointers in Each Node II]]></title>
    <url>%2Fp%2Fb4ed2826%2F</url>
    <content type="text"><![CDATA[38.6% https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/#/description Follow up for problem “Populating Next Right Pointers in Each Node”. What if the given tree could be any binary tree? Would your previous solution still work? Note: You may only use constant extra space. 12345678910111213For example,Given the following binary tree, 1 / \ 2 3 / \ \ 4 5 7After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ \ 4-&gt; 5 -&gt; 7 -&gt; NULL 方法一： Simple 40ms c++ o(n) ,o(1) solution with only one while loop Thanks for liji94188 for adding the explanation: It’s a BFS traversal. now pointer is the current level traveler and head is the left most element at next level and the tail is the right most element at next level till now. We move now pointer at current level and populate the the next-link at its children level. (Here the gist is we can move now to its next because this relationship was already populated in the previous round). 三个指针，now指向当前位置，针对now的下一层进行做运算，其中，head指针指向now下一位的首位，tail指针从head开始移动，在移动中完成了链接操作，最终移动至now下一层的尾部。然后将now指向head，head和tail置NULL。 1234567891011121314151617181920void connect(TreeLinkNode *root) &#123; TreeLinkNode *now, *tail, *head; now = root; head = tail = NULL; while(now) &#123; if (now-&gt;left) if (tail) tail = tail-&gt;next =now-&gt;left; else head = tail = now-&gt;left; if (now-&gt;right) if (tail) tail = tail-&gt;next =now-&gt;right; else head = tail = now-&gt;right; if(!(now = now-&gt;next)) &#123; now = head; head = tail=NULL; &#125; &#125;&#125; 我自己的实现，跟上面代码是一样的，分开写，更容易理解。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(root==NULL) return; TreeLinkNode* now=root, *head=NULL, *tail=NULL; while(now)&#123; if(now-&gt;left)&#123; if(tail)&#123; tail-&gt;next = now-&gt;left; tail = tail-&gt;next; &#125;else&#123; tail = now-&gt;left; head = tail; &#125; &#125; if(now-&gt;right)&#123; if(tail)&#123; tail-&gt;next = now-&gt;right; tail = tail-&gt;next; &#125;else&#123; tail = now-&gt;right; head = tail; &#125; &#125; now = now-&gt;next; if(!now)&#123; now = head; head = NULL; tail = NULL; &#125; &#125; &#125;&#125;; 我的代码实现: 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return; TreeLinkNode* now = root, *head = NULL, *tail=NULL; while(now)&#123; if(now-&gt;left)&#123; if(!tail)&#123; head = now-&gt;left; tail = head; &#125;else&#123; tail-&gt;next = now-&gt;left; tail = tail-&gt;next; &#125; &#125; if(now-&gt;right)&#123; if(!tail)&#123; head = now-&gt;right; tail = head; &#125;else&#123; tail-&gt;next = now-&gt;right; tail = tail-&gt;next; &#125; &#125; now = now-&gt;next; if(!now)&#123; now = head; head = NULL; tail = NULL; &#125; &#125; &#125;&#125;; 方法二： 使用层序遍历，queue 123456789101112131415161718192021222324252627282930313233/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return; queue&lt;TreeLinkNode*&gt; que; if(root-&gt;left) que.push(root-&gt;left); if(root-&gt;right) que.push(root-&gt;right); while(que.size()&gt;0)&#123; int n = que.size(); TreeLinkNode* lastNode = que.front(); que.pop(); if(lastNode-&gt;left) que.push(lastNode-&gt;left); if(lastNode-&gt;right) que.push(lastNode-&gt;right); for(int i=1; i&lt;n; i++)&#123; TreeLinkNode* cur = que.front(); lastNode-&gt;next = cur; que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); lastNode = cur; &#125; &#125; return; &#125;&#125;; 我的代码实现: 12345678910111213141516171819202122232425262728293031323334/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return; // 用队列还是栈，要仔细思考，这里使用队列 queue&lt;TreeLinkNode*&gt; que; que.push(root); while(que.size())&#123; int n = que.size(); TreeLinkNode* pre = que.front(); que.pop(); if(pre-&gt;left) que.push(pre-&gt;left); if(pre-&gt;right) que.push(pre-&gt;right); for(int i=1; i&lt;n; i++)&#123; TreeLinkNode* cur = que.front(); que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); pre-&gt;next = cur; pre = cur; &#125; &#125; return; &#125;&#125;; https://discuss.leetcode.com/topic/18119/simple-40ms-c-o-n-o-1-solution-with-only-one-while-loop Simple 40ms c++ o(n) ,o(1) solution with only one while loop Thanks for liji94188 for adding the explanation: It’s a BFS traversal. now pointer is the current level traveler and head is the left most element at next level and the tail is the right most element at next level till now. We move now pointer at current level and populate the the next-link at its children level. (Here the gist is we can move now to its next because this relationship was already populated in the previous round). 三个指针，now指向当前位置，针对now的下一层进行做运算，其中，head指针指向now下一位的首位，tail指针从head开始移动，在移动中完成了链接操作，最终移动至now下一层的尾部。然后将now指向head，head和tail置NULL。 1234567891011121314151617181920void connect(TreeLinkNode *root) &#123; TreeLinkNode *now, *tail, *head; now = root; head = tail = NULL; while(now) &#123; if (now-&gt;left) if (tail) tail = tail-&gt;next =now-&gt;left; else head = tail = now-&gt;left; if (now-&gt;right) if (tail) tail = tail-&gt;next =now-&gt;right; else head = tail = now-&gt;right; if(!(now = now-&gt;next)) &#123; now = head; head = tail=NULL; &#125; &#125;&#125; https://discuss.leetcode.com/topic/9735/just-convert-common-bfs-solution-to-o-1-space-a-simple-python-code Just convert common BFS solution to O(1) space, a simple python code common BFS 12345678910111213141516class Solution:# @param root, a tree link node# @return nothingdef connect(self, root): if not root: return queue, level = collections.deque([root]), collections.deque() while queue: node = queue.popleft() if node.left: level.append(node.left) if node.right: level.append(node.right) node.next = queue[0] if queue else None if not queue and level: queue, level = level, queue O(1) space 123456789101112131415161718192021class Solution:# @param root, a tree link node# @return nothingdef connect(self, root): queue, level, curr = root, None, None while queue: if queue.left: if not level: level = curr = queue.left else: curr.next = queue.left curr = curr.next if queue.right: if not level: level = curr = queue.right else: curr.next = queue.right curr = curr.next queue = queue.next if not queue and level: queue, level, curr = level, None, None Use a fake head can save a few lines https://discuss.leetcode.com/topic/27792/ac-python-o-1-space-solution-12-lines-and-easy-to-understand AC Python O(1) space solution 12 lines and easy to understand The algorithm is a BFS or level order traversal. We go through the tree level by level. node is the pointer in the parent level, tail is the tail pointer in the child level.The parent level can be view as a singly linked list or queue, which we can traversal easily with a pointer.Connect the tail with every one of the possible nodes in child level, update it only if the connected node is not nil.Do this one level by one level. The whole thing is quite straightforward. Python 12345678910111213141516171819def connect(self, node): tail = dummy = TreeLinkNode(0) while node: tail.next = node.left if tail.next: tail = tail.next tail.next = node.right if tail.next: tail = tail.next node = node.next if not node: tail = dummy node = dummy.next# 61 / 61 test cases passed.# Status: Accepted# Runtime: 100 ms# 95.26% https://discuss.leetcode.com/topic/1106/o-1-space-o-n-complexity-iterative-solution O(1) space O(n) complexity Iterative Solution Just share my iterative solution with O(1) space and O(n) Time complexity 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; //based on level order traversal public void connect(TreeLinkNode root) &#123; TreeLinkNode head = null; //head of the next level TreeLinkNode prev = null; //the leading node on the next level TreeLinkNode cur = root; //current node of current level while (cur != null) &#123; while (cur != null) &#123; //iterate on the current level //left child if (cur.left != null) &#123; if (prev != null) &#123; prev.next = cur.left; &#125; else &#123; head = cur.left; &#125; prev = cur.left; &#125; //right child if (cur.right != null) &#123; if (prev != null) &#123; prev.next = cur.right; &#125; else &#123; head = cur.right; &#125; prev = cur.right; &#125; //move to next node cur = cur.next; &#125; //move to next level cur = head; head = null; prev = null; &#125; &#125;&#125; https://discuss.leetcode.com/topic/8447/simple-solution-using-constant-space Simple solution using constant space The idea is simple: level-order traversal. You can see the following code: 123456789101112131415public class Solution &#123; public void connect(TreeLinkNode root) &#123; while(root != null)&#123; TreeLinkNode tempChild = new TreeLinkNode(0); TreeLinkNode currentChild = tempChild; while(root!=null)&#123; if(root.left != null) &#123; currentChild.next = root.left; currentChild = currentChild.next;&#125; if(root.right != null) &#123; currentChild.next = root.right; currentChild = currentChild.next;&#125; root = root.next; &#125; root = tempChild.next; &#125; &#125;&#125; 1ms, 51.83%, September 25, 2016 https://discuss.leetcode.com/topic/8447/simple-solution-using-constant-space Java solution with constant space 1234567891011121314151617181920public void connect(TreeLinkNode root) &#123; TreeLinkNode dummyHead = new TreeLinkNode(0); TreeLinkNode pre = dummyHead; while (root != null) &#123; if (root.left != null) &#123; pre.next = root.left; pre = pre.next; &#125; if (root.right != null) &#123; pre.next = root.right; pre = pre.next; &#125; root = root.next; if (root == null) &#123; pre = dummyHead; root = dummyHead.next; dummyHead.next = null; &#125; &#125;&#125; https://discuss.leetcode.com/topic/36615/o-1-concise-fast-what-s-so-hard O(1). Concise. Fast. What’s so hard? This is definitely medium, not hard. Took me about 5 minutes, and some medium problems took me a few hours! Since you have to walk the tree in BFS order and you’re given extra references to help you do just that, it’s intuitive, it’s simple and it’s fast. The first level (root) is connected already, so you connect the next level and then you just walk through the linked list you’ve just created and so on. 12345678910111213141516public void connect(TreeLinkNode root) &#123; for (TreeLinkNode head = root; head != null; ) &#123; TreeLinkNode nextHead = new TreeLinkNode(0), nextTail = nextHead; for (TreeLinkNode node = head; node != null; node = node.next) &#123; if (node.left != null) &#123; nextTail.next = node.left; nextTail = node.left; &#125; if (node.right != null) &#123; nextTail.next = node.right; nextTail = node.right; &#125; &#125; head = nextHead.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[116. Populating Next Right Pointers in Each Node]]></title>
    <url>%2Fp%2F6168139a%2F</url>
    <content type="text"><![CDATA[36.9% https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ 1234567891011Given a binary tree struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; &#125;Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.Initially, all next pointers are set to NULL. Note: You may only use constant extra space. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children). 1234567891011121314For example,Given the following perfect binary tree, 1 / \ 2 3 / \ / \ 4 5 6 7After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \ 4-&gt;5-&gt;6-&gt;7 -&gt; NULL 24ms Easy Iterative and Recursive C++ Solutions 方法一： The idea is similar to a level-order traversal and remember to take full advantages of the prefect binary tree assumption in the problem statement. The code (iterative solution) is as follows. 1234567891011121314151617class Solution &#123;public: void connect(TreeLinkNode *root) &#123; TreeLinkNode* pre = root; TreeLinkNode* cur = NULL; while (pre) &#123; cur = pre; while (cur &amp;&amp; cur -&gt; left) &#123; cur -&gt; left -&gt; next = cur -&gt; right; if (cur -&gt; next) cur -&gt; right -&gt; next = cur -&gt; next -&gt; left; cur = cur -&gt; next; &#125; pre = pre -&gt; left; &#125; &#125; &#125;; 我的代码实现： 1234567891011121314151617181920212223242526272829303132/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return; // 排除只有一个root节点的情况，勿忘 TreeLinkNode* curhead = root; TreeLinkNode* nexhead = root-&gt;left; TreeLinkNode *tail = nexhead; while(nexhead)&#123; tail-&gt;next = curhead-&gt;right; tail = tail-&gt;next; while(curhead-&gt;next)&#123; curhead = curhead-&gt;next; tail-&gt;next = curhead-&gt;left; tail = tail-&gt;next; tail-&gt;next = curhead-&gt;right; tail = tail-&gt;next; &#125; curhead = nexhead; nexhead = nexhead-&gt;left; tail = nexhead; &#125; return; &#125;&#125;; 方法二： This problem can also be solved recursively. 12345678910111213class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (!root) return; if (root -&gt; left) &#123; root -&gt; left -&gt; next = root -&gt; right; if (root -&gt; next) root -&gt; right -&gt; next = root -&gt; next -&gt; left; &#125; connect(root -&gt; left); connect(root -&gt; right); &#125;&#125;; 方法三： 层序遍历的方法 1234567891011121314151617181920212223242526272829303132/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return; queue&lt;TreeLinkNode*&gt; que; que.push(root); while(que.size()&gt;0)&#123; int n = que.size(); TreeLinkNode* lastNode = que.front(); que.pop(); if(lastNode-&gt;left) que.push(lastNode-&gt;left); if(lastNode-&gt;right) que.push(lastNode-&gt;right); for(int i=1; i&lt;n; i++)&#123; TreeLinkNode* cur = que.front(); que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); lastNode-&gt;next = cur; lastNode = cur; &#125; &#125; return; &#125;&#125;; https://discuss.leetcode.com/topic/1214/hint-for-o-1-space Hint for O(1) space If you don’t want a solution for O(1) space but just a hint, here it is: you need to make use of the next links that you’re creating. https://discuss.leetcode.com/topic/671/you-may-only-use-constant-extra-space-so-does-it-mean-we-cannot-use-recursion “You may only use constant extra space.” - So does it mean we cannot use recursion? Does anyone have an iteration method with constant space solution? https://discuss.leetcode.com/topic/671/you-may-only-use-constant-extra-space-so-does-it-mean-we-cannot-use-recursion/2 Here is solution from old discuss by skaugust. Thanks to skaugust! I’m confused why people are trying to use recursive solutions here. The problem states that you can only use constant space. To get to the leaf nodes, a recursive solution needs to be log2(n) calls deep, and each call has a call stack, which takes up memory. This means that a recursive solution isn’t constant memory, but O(log(n)) memory. To solve this, you just replace the recursive call with a while loop wrapping all of your logic. 1234567891011121314151617181920212223/* Go through parent level by its next pointer to generate children level next pointer */public class Solution &#123; public void connect(TreeLinkNode root) &#123; TreeLinkNode leftWall = root; while (leftWall != null) &#123; TreeLinkNode across = leftWall; while (across != null) &#123; if (across.left != null) &#123; across.left.next = across.right; &#125; if (across.right != null &amp;&amp; across.next != null) &#123; across.right.next = across.next.left; &#125; across = across.next; &#125; leftWall = leftWall.left; &#125; &#125;&#125; 19ms, 80.75%, September 25, 2016 https://discuss.leetcode.com/topic/2202/a-simple-accepted-solution A simple accepted solution 如果pre-&gt;left 为空怎么办？题目假设的是所有都有左右子树 12345678910111213141516171819202122232425/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(root==NULL) return; TreeLinkNode* pre = root; TreeLinkNode* cur = NULL; while(pre-&gt;left)&#123; cur = pre; while(cur)&#123; cur-&gt;left-&gt;next = cur-&gt;right; if(cur-&gt;next) cur-&gt;right-&gt;next = cur-&gt;next-&gt;left; cur = cur-&gt;next; &#125; pre = pre-&gt;left; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/9579/my-simple-non-iterative-c-code-with-o-1-memory My simple non-iterative C++ code with O(1) memory 12345678910111213141516void connect(TreeLinkNode *root) &#123; if(!root) return; while(root -&gt; left) &#123; TreeLinkNode *p = root; while(p) &#123; p -&gt; left -&gt; next = p -&gt; right; if(p -&gt; next) p -&gt; right -&gt; next = p -&gt; next -&gt; left; p = p -&gt; next; &#125; root = root -&gt; left; &#125;&#125; https://discuss.leetcode.com/topic/16547/7-lines-iterative-real-o-1-space 7 lines, iterative, real O(1) space Simply do it level by level, using the next-pointers of the current level to go through the current level and set the next-pointers of the next level. I say “real” O(1) space because of the many recursive solutions ignoring that recursion management needs space. 12345678def connect(self, root): while root and root.left: next = root.left while root: root.left.next = root.right root.right.next = root.next and root.next.left root = root.next root = next https://discuss.leetcode.com/topic/18432/24ms-easy-iterative-and-recursive-c-solutions 24ms Easy Iterative and Recursive C++ Solutions The idea is similar to a level-order traversal and remember to take full advantages of the prefect binary tree assumption in the problem statement. The code (iterative solution) is as follows. 1234567891011121314151617class Solution &#123;public: void connect(TreeLinkNode *root) &#123; TreeLinkNode* pre = root; TreeLinkNode* cur = NULL; while (pre) &#123; cur = pre; while (cur &amp;&amp; cur -&gt; left) &#123; cur -&gt; left -&gt; next = cur -&gt; right; if (cur -&gt; next) cur -&gt; right -&gt; next = cur -&gt; next -&gt; left; cur = cur -&gt; next; &#125; pre = pre -&gt; left; &#125; &#125; &#125;; This problem can also be solved recursively. 12345678910111213class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (!root) return; if (root -&gt; left) &#123; root -&gt; left -&gt; next = root -&gt; right; if (root -&gt; next) root -&gt; right -&gt; next = root -&gt; next -&gt; left; &#125; connect(root -&gt; left); connect(root -&gt; right); &#125;&#125;; 1ms, 29.64%, September 25, 2016 https://discuss.leetcode.com/topic/6221/java-solution-with-o-1-memory-o-n-time Java solution with O(1) memory+ O(n) time 123456789101112131415public class Solution &#123; public void connect(TreeLinkNode root) &#123; TreeLinkNode level_start=root; while(level_start!=null)&#123; TreeLinkNode cur=level_start; while(cur!=null)&#123; if(cur.left!=null) cur.left.next=cur.right; if(cur.right!=null &amp;&amp; cur.next!=null) cur.right.next=cur.next.left; cur=cur.next; &#125; level_start=level_start.left; &#125; &#125;&#125; https://discuss.leetcode.com/topic/12241/my-recursive-solution-java My recursive solution(Java) 12345678910111213public void connect(TreeLinkNode root) &#123; if(root == null) return; if(root.left != null)&#123; root.left.next = root.right; if(root.next != null) root.right.next = root.next.left; &#125; connect(root.left); connect(root.right);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[115. Distinct Subsequences]]></title>
    <url>%2Fp%2F5eae1966%2F</url>
    <content type="text"><![CDATA[30.9% https://leetcode.com/problems/distinct-subsequences/?tab=Description Given a string S and a string T, count the number of distinct subsequences of T in S. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not). 1234Here is an example:S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;Return 3. 方法一： 我的代码实现： Oct 17， 2017 123456789101112131415class Solution &#123;public: int numDistinct(string s, string t) &#123; int m = s.size(), n = t.size(); if(m&lt;n) return 0; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=0; i&lt;=m; i++)&#123; dp[i][0] = 1; &#125; for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) dp[i][j] = dp[i-1][j] + (s[i-1]==t[j-1]?dp[i-1][j-1]:0); return dp[m][n]; &#125;&#125;; 13ms, 55.07%, September 25, 2016 https://discuss.leetcode.com/topic/760/any-better-solution-that-takes-less-than-o-n-2-space-while-in-o-n-2-time Any better solution that takes less than O(n^2) space while in O(n^2) time? My solution is using O(n^2) space and running in O(n^2) time. I wonder is there a better way to do that which consumes less memory? I guess run time could not be improved though. Any thought/input would be highly appreciated, thanks! 123456789101112131415161718192021222324252627/** * Solution (DP): * We keep a m*n matrix and scanning through string S, while * m = T.length() + 1 and n = S.length() + 1 * and each cell in matrix Path[i][j] means the number of distinct subsequences of * T.substr(1...i) in S(1...j) * * Path[i][j] = Path[i][j-1] (discard S[j]) * + Path[i-1][j-1] (S[j] == T[i] and we are going to use S[j]) * or 0 (S[j] != T[i] so we could not use S[j]) * while Path[0][j] = 1 and Path[i][0] = 0. */int numDistinct(string S, string T) &#123; int m = T.length(); int n = S.length(); if (m &gt; n) return 0; // impossible for subsequence vector&lt;vector&lt;int&gt;&gt; path(m+1, vector&lt;int&gt;(n+1, 0)); for (int k = 0; k &lt;= n; k++) path[0][k] = 1; // initialization for (int j = 1; j &lt;= n; j++) &#123; for (int i = 1; i &lt;= m; i++) &#123; path[i][j] = path[i][j-1] + (T[i-1] == S[j-1] ? path[i-1][j-1] : 0); &#125; &#125; return path[m][n];&#125; my code: 搞清楚s t的区别，m n分别对应的关系，不要搞混了。 12345678910111213141516171819class Solution &#123;public: int numDistinct(string s, string t) &#123; if(t.empty()) return 1; if(s.empty()) return 0; int m = t.size(); int n = s.size(); if(m&gt;n) return 0; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=0; i&lt;=n; i++) dp[0][i] = 1; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; dp[i+1][j+1] = dp[i+1][j] + (t[i]==s[j]?dp[i][j] : 0); &#125; &#125; return dp[m][n]; &#125;&#125;; 方法二： 从上一种方法中，发现需要的空间复杂度还是可以降低的。 https://discuss.leetcode.com/topic/19778/7-10-lines-c-solutions-with-detailed-explanations-o-m-n-time-and-o-m-space 7-10 lines C++ Solutions with Detailed Explanations (O(m*n) time and O(m) space) Well, a dynamic programming problem. Let’s first define its state dp[i][j] to be the number of distinct subsequences of t[0..i - 1] in s[0..j - 1]. Then we have the following state equations: General case 1: dp[i][j] = dp[i][j - 1] if t[i - 1] != s[j - 1]; General case 2: dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1] if t[i - 1] == s[j - 1]; Boundary case 1: dp[0][j] = 1 for all j; Boundary case 2: dp[i][0] = 0 for all positive i. Now let’s give brief explanations to the four equations above. If t[i - 1] != s[j - 1], the distinct subsequences will not include s[j - 1] and thus all the number of distinct subsequences will simply be those in s[0..j - 2], which corresponds to dp[i][j - 1]; If t[i - 1] == s[j - 1], the number of distinct subsequences include two parts: those with s[j - 1] and those without; An empty string will have exactly one subsequence in any string :-) Non-empty string will have no subsequences in an empty string. Putting these together, we will have the following simple codes (just like translation :-)): 123456789101112class Solution &#123;public: int numDistinct(string s, string t) &#123; int m = t.length(), n = s.length(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt; (n + 1, 0)); for (int j = 0; j &lt;= n; j++) dp[0][j] = 1; for (int j = 1; j &lt;= n; j++) for (int i = 1; i &lt;= m; i++) dp[i][j] = dp[i][j - 1] + (t[i - 1] == s[j - 1] ? dp[i - 1][j - 1] : 0); return dp[m][n]; &#125;&#125;; Notice that we keep the whole m*n matrix simply for dp[i - 1][j - 1]. So we can simply store that value in a single variable and further optimize the space complexity. The final code is as follows. 1234567891011121314151617class Solution &#123;public: int numDistinct(string s, string t) &#123; int m = t.length(), n = s.length(); vector&lt;int&gt; cur(m + 1, 0); cur[0] = 1; for (int j = 1; j &lt;= n; j++) &#123; int pre = 1; for (int i = 1; i &lt;= m; i++) &#123; int temp = cur[i]; cur[i] = cur[i] + (t[i - 1] == s[j - 1] ? pre : 0); pre = temp; &#125; &#125; return cur[m]; &#125;&#125;; java 16ms, 41.15%, September 25, 2016 https://discuss.leetcode.com/topic/9488/easy-to-understand-dp-in-java Easy to understand DP in Java The idea is the following: we will build an array mem where mem[i+1][j+1] means that S[0..j] contains T[0..i] that many times as distinct subsequences. Therefor the result will be mem[T.length()][S.length()]. we can build this array rows-by-rows: the first row must be filled with 1. That’s because the empty string is a subsequence of any string but only 1 time. So mem[0][j] = 1 for every j. So with this we not only make our lives easier, but we also return correct value if T is an empty string. the first column of every rows except the first must be 0. This is because an empty string cannot contain a non-empty string as a substring – the very first item of the array: mem[0][0] = 1, because an empty string contains the empty string 1 time. So the matrix looks like this: 12345678910test S 0123....jT +----------+ |1111111111|0 |0 |1 |0 |2 |0 |. |0 |. |0 |i |0 | From here we can easily fill the whole grid: for each (x, y), we check if S[x] == T[y] we add the previous item and the previous item in the previous row, otherwise we copy the previous item in the same row. The reason is simple: if the current character in S doesn’t equal to current character T, then we have the same number of distinct subsequences as we had without the new character. if the current character in S equal to the current character T, then the distinct number of subsequences: the number we had before plus the distinct number of subsequences we had with less longer T and less longer S.An example: S: [acdabefbc] and T: [ab] first we check with a: 1234test * * S = [acdabefbc]mem[1] = [0111222222] then we check with ab: 12345test * * ] S = [acdabefbc]mem[1] = [0111222222]mem[2] = [0000022244] And the result is 4, as the distinct subsequences are: 12345test S = [a b ] S = [a b ] S = [ ab ] S = [ a b ] See the code in Java: 1234567891011121314151617181920212223public int numDistinct(String S, String T) &#123; // array creation int[][] mem = new int[T.length()+1][S.length()+1]; // filling the first row: with 1s for(int j=0; j&lt;=S.length(); j++) &#123; mem[0][j] = 1; &#125; // the first column is 0 by default in every other rows but the first, which we need. for(int i=0; i&lt;T.length(); i++) &#123; for(int j=0; j&lt;S.length(); j++) &#123; if(T.charAt(i) == S.charAt(j)) &#123; mem[i+1][j+1] = mem[i][j] + mem[i+1][j]; &#125; else &#123; mem[i+1][j+1] = mem[i+1][j]; &#125; &#125; &#125; return mem[T.length()][S.length()];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[114. Flatten Binary Tree to Linked List]]></title>
    <url>%2Fp%2Fad56aabd%2F</url>
    <content type="text"><![CDATA[34.1% https://leetcode.com/problems/flatten-binary-tree-to-linked-list/ Given a binary tree, flatten it to a linked list in-place. 12345678910111213141516171819202122For example,Given 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 Hints: If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal. 方法一： 题目中要求转换为链表，实际上是Tree，只不过要求左分支都为0，右分支串联。 迭代 对于root， 把root的右节点接上右节点在先序遍历下的前驱节点。然后root右节点指向左节点，左节点设置为空，然后root指向下一个节点。依次迭代。 Share my simple NON-recursive solution, O(1) space complexity! 123456789101112131415161718192021222324class Solution &#123;public: void flatten(TreeNode *root) &#123; TreeNode*now = root; while (now) &#123; if(now-&gt;left) &#123; //Find current node&apos;s prenode that links to current node&apos;s right subtree TreeNode* pre = now-&gt;left; while(pre-&gt;right) &#123; pre = pre-&gt;right; &#125; pre-&gt;right = now-&gt;right; //Use current node&apos;s left subtree to replace its right subtree(original right //subtree is already linked by current node&apos;s prenode now-&gt;right = now-&gt;left; now-&gt;left = NULL; &#125; now = now-&gt;right; &#125; &#125;&#125;; 我的代码实现 12345678910111213141516171819class Solution &#123;public: void flatten(TreeNode* root) &#123; if(root==NULL) return; while(root)&#123; if(root-&gt;left)&#123; TreeNode* prev = root-&gt;left; while(prev-&gt;right!=NULL) prev = prev-&gt;right; prev-&gt;right = root-&gt;right; root-&gt;right = root-&gt;left; root-&gt;left = NULL; root = root-&gt;right; &#125;else&#123; root = root-&gt;right; &#125; &#125; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void flatten(TreeNode* root) &#123; if(!root || !root-&gt;left&amp;&amp;!root-&gt;right) return; TreeNode* curnode = root; while(curnode)&#123; if(curnode-&gt;left)&#123; TreeNode* pre = curnode-&gt;left; while(pre-&gt;right) pre = pre-&gt;right; pre-&gt;right = curnode-&gt;right; curnode-&gt;right = curnode-&gt;left; curnode-&gt;left = NULL; curnode = curnode-&gt;right; &#125;else&#123; curnode = curnode-&gt;right; &#125; &#125; return; &#125;&#125;; 我的代码实现： 优化后的代码，相对于上面，优化了if else语句，如果有cur-&gt;left,进行一定的处理 无论有没有cur-&gt;left，最后都要去cur-&gt;right 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void flatten(TreeNode* root) &#123; if(!root || !root-&gt;left&amp;&amp;!root-&gt;right) return; TreeNode* curnode = root; while(curnode)&#123; if(curnode-&gt;left)&#123; TreeNode* pre = curnode-&gt;left; while(pre-&gt;right) pre = pre-&gt;right; pre-&gt;right = curnode-&gt;right; curnode-&gt;right = curnode-&gt;left; curnode-&gt;left = NULL; &#125; curnode = curnode-&gt;right; &#125; return; &#125;&#125;; https://discuss.leetcode.com/topic/3995/share-my-simple-non-recursive-solution-o-1-space-complexity Share my simple NON-recursive solution, O(1) space complexity! 123456789101112131415161718192021222324class Solution &#123;public: void flatten(TreeNode *root) &#123; TreeNode*now = root; while (now) &#123; if(now-&gt;left) &#123; //Find current node&apos;s prenode that links to current node&apos;s right subtree TreeNode* pre = now-&gt;left; while(pre-&gt;right) &#123; pre = pre-&gt;right; &#125; pre-&gt;right = now-&gt;right; //Use current node&apos;s left subtree to replace its right subtree(original right //subtree is already linked by current node&apos;s prenode now-&gt;right = now-&gt;left; now-&gt;left = NULL; &#125; now = now-&gt;right; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/14481/8ms-non-recursive-no-stack-c-solution 8ms, Non-recursive, No stack, C++ solution 123456789101112131415void flatten(TreeNode *root) &#123; while (root) &#123; if (root-&gt;left &amp;&amp; root-&gt;right) &#123; TreeNode* t = root-&gt;left; while (t-&gt;right) t = t-&gt;right; t-&gt;right = root-&gt;right; &#125; if(root-&gt;left) root-&gt;right = root-&gt;left; root-&gt;left = NULL; root = root-&gt;right; &#125;&#125; https://discuss.leetcode.com/topic/19087/my-recursive-solution-is-easy-and-clean My recursive solution is easy and clean! 1234567891011void flatten(TreeNode* root) &#123; if (!root) return; flatten(root-&gt;left); flatten(root-&gt;right); TreeNode *tmp = root-&gt;right; root-&gt;right = root-&gt;left; root-&gt;left = nullptr; while (root-&gt;right) root = root-&gt;right; root-&gt;right = tmp;&#125; https://discuss.leetcode.com/topic/9933/16-lines-iterative-c-solution 16 lines iterative c++ solution 12345678910111213141516void flatten(TreeNode *root) &#123; while(root)&#123; if(root-&gt;left == NULL) root = root-&gt;right; else &#123; if(root-&gt;right)&#123; TreeNode *l = root-&gt;left; while(l-&gt;right) l = l-&gt;right; l-&gt;right = root-&gt;right; &#125; root-&gt;right = root-&gt;left; root-&gt;left = NULL; root = root-&gt;right; &#125; &#125;&#125; Inspired by Morris traversal. https://discuss.leetcode.com/topic/10606/an-inorder-python-solution An inorder python solution 12345678910111213141516171819202122232425262728class Solution:# @param root, a tree node# @return nothing, do it in placeprev = Nonedef flatten(self, root): if not root: return self.prev = root self.flatten(root.left) temp = root.right root.right, root.left = root.left, None self.prev.right = temp self.flatten(temp) * / n / \ left right \ * * \ p The idea is very simple. Suppose n is the current visiting node, and p is the previous node of preorder traversal to n.right. We just need to do the inorder replacement: n.left -&gt; NULL n.right - &gt; n.left p-&gt;right -&gt; n.right https://discuss.leetcode.com/topic/11444/my-short-post-order-traversal-java-solution-for-share My short post order traversal Java solution for share 1234567891011private TreeNode prev = null;public void flatten(TreeNode root) &#123; if (root == null) return; flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root;&#125; https://discuss.leetcode.com/topic/9936/straightforward-java-solution Straightforward Java Solution 12345678910111213141516public void flatten(TreeNode root) &#123; if (root == null) return; TreeNode left = root.left; TreeNode right = root.right; root.left = null; flatten(left); flatten(right); root.right = left; TreeNode cur = root; while (cur.right != null) cur = cur.right; cur.right = right; &#125; This solution is based on recursion. We simply flatten left and right subtree and paste each sublist to the right child of the root. (don’t forget to set left child to null) 3ms, 4.67%, September 25, 2016 https://discuss.leetcode.com/topic/5783/accepted-simple-java-solution-iterative 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public void flatten(TreeNode root) &#123; if(root==null) return; Stack&lt;TreeNode&gt; stk = new Stack&lt;TreeNode&gt;(); stk.push(root); while(!stk.isEmpty())&#123; TreeNode curr = stk.pop(); if(curr.right!=null) stk.push(curr.right); if(curr.left!=null) stk.push(curr.left); if(!stk.isEmpty()) curr.right = stk.peek(); curr.left = null; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[113. Path Sum II]]></title>
    <url>%2Fp%2F37ccb4d%2F</url>
    <content type="text"><![CDATA[32.1% https://leetcode.com/problems/path-sum-ii/?tab=Description Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. 1234567891011121314For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1return[ [5,4,11,2], [5,8,4,5]] 方法一： 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; paths; vector&lt;int&gt; path; dfs(root, path, paths, sum); return paths; &#125; void dfs(TreeNode* root, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; paths, int sum)&#123; if(!root) return; path.push_back(root-&gt;val); if(root-&gt;val==sum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) paths.push_back(path); dfs(root-&gt;left, path, paths, sum-root-&gt;val); dfs(root-&gt;right, path, paths, sum-root-&gt;val); path.pop_back(); &#125;&#125;; 典型的深度优先搜索（回溯法），典型题目，需要牢记方法。 Well, a typical backtracking problem. The code is as follows. You may walk through it using the example in the problem statement to see how it works. 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; paths; vector&lt;int&gt; path; findPaths(root, sum, path, paths); return paths; &#125; private: void findPaths(TreeNode* node, int sum, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; paths)&#123; if(!node) return; path.push_back(node-&gt;val); if(!(node-&gt;left) &amp;&amp; !(node-&gt;right) &amp;&amp; sum == node-&gt;val) paths.push_back(path); findPaths(node-&gt;left, sum-node-&gt;val, path, paths); findPaths(node-&gt;right, sum-node-&gt;val, path, paths); path.pop_back(); &#125;&#125;; 12ms, September 21, 2016 https://discuss.leetcode.com/topic/18454/12ms-11-lines-c-solution 12ms 11-lines C++ Solution Well, a typical backtracking problem. The code is as follows. You may walk through it using the example in the problem statement to see how it works. 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; paths; vector&lt;int&gt; path; findPaths(root, sum, path, paths); return paths; &#125; private: void findPaths(TreeNode* node, int sum, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; paths)&#123; if(!node) return; path.push_back(node-&gt;val); if(!(node-&gt;left) &amp;&amp; !(node-&gt;right) &amp;&amp; sum == node-&gt;val) paths.push_back(path); findPaths(node-&gt;left, sum-node-&gt;val, path, paths); findPaths(node-&gt;right, sum-node-&gt;val, path, paths); path.pop_back(); &#125;&#125;; https://discuss.leetcode.com/topic/8919/18-ms-c-recursive-solution 18 ms c++ recursive solution 12345678910111213141516171819202122232425262728vector&lt;vector&lt;int&gt; &gt; pathSum(TreeNode *root, int sum) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; cur_path(0); pathSumRec(root, sum, result, cur_path); return result;&#125;// pass the current path as a reference and remember to pop out the last added element// this improves the performance by 5 timesvoid pathSumRec(TreeNode* root, int sum, vector&lt;vector&lt;int&gt; &gt;&amp; result, vector&lt;int&gt;&amp; cur_path) &#123; if (root == NULL) &#123; return; &#125; if (root-&gt;val == sum &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123; cur_path.push_back(root-&gt;val); result.push_back(cur_path); cur_path.pop_back(); return; &#125; int sum_left = sum - root-&gt;val; cur_path.push_back(root-&gt;val); pathSumRec(root-&gt;left, sum_left, result, cur_path); //cur_path.pop_back(); pathSumRec(root-&gt;right, sum_left, result, cur_path); cur_path.pop_back();&#125; 92ms, September 21, 2016 https://discuss.leetcode.com/topic/16607/short-python-solution Short python solution 12345678910111213141516class Solution(object): def pathSum(self, root, sum): &quot;&quot;&quot; :type root: TreeNode :type sum: int :rtype: List[List[int]] &quot;&quot;&quot; if not root: return [] if root.left == None and root.right == None: if sum == root.val: return [[root.val]] else: return [] a = self.pathSum(root.left, sum-root.val) + \ self.pathSum(root.right, sum - root.val) return [[root.val] + i for i in a] https://discuss.leetcode.com/topic/18444/python-solutions-recursively-bfs-queue-dfs-stack Python solutions (Recursively, BFS+queue, DFS+stack) 1234567891011121314151617181920212223def pathSum(self, root, sum): if not root: return [] res = [] self.dfs(root, sum, [], res) return res def dfs(self, root, sum, ls, res): if not root.left and not root.right and sum == root.val: ls.append(root.val) res.append(ls) if root.left: self.dfs(root.left, sum-root.val, ls+[root.val], res) if root.right: self.dfs(root.right, sum-root.val, ls+[root.val], res) def pathSum2(self, root, sum): if not root: return [] if not root.left and not root.right and sum == root.val: return [[root.val]] tmp = self.pathSum(root.left, sum-root.val) + self.pathSum(root.right, sum-root.val) return [[root.val]+i for i in tmp] 123456789101112131415# BFS + queue def pathSum3(self, root, sum): if not root: return [] res = [] queue = [(root, root.val, [root.val])] while queue: curr, val, ls = queue.pop(0) if not curr.left and not curr.right and val == sum: res.append(ls) if curr.left: queue.append((curr.left, val+curr.left.val, ls+[curr.left.val])) if curr.right: queue.append((curr.right, val+curr.right.val, ls+[curr.right.val])) return res 123456789101112131415# DFS + stack I def pathSum4(self, root, sum): if not root: return [] res = [] stack = [(root, sum-root.val, [root.val])] while stack: curr, val, ls = stack.pop() if not curr.left and not curr.right and val == 0: res.append(ls) if curr.right: stack.append((curr.right, val-curr.right.val, ls+[curr.right.val])) if curr.left: stack.append((curr.left, val-curr.left.val, ls+[curr.left.val])) return res 123456789101112131415# DFS + stack II def pathSum5(self, root, s): if not root: return [] res = [] stack = [(root, [root.val])] while stack: curr, ls = stack.pop() if not curr.left and not curr.right and sum(ls) == s: res.append(ls) if curr.right: stack.append((curr.right, ls+[curr.right.val])) if curr.left: stack.append((curr.left, ls+[curr.left.val])) return res https://discuss.leetcode.com/topic/5414/dfs-with-one-linkedlist-accepted-java-solution DFS with one LinkedList , accepted java solution 1234567891011121314151617181920212223public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; currentResult = new LinkedList&lt;Integer&gt;(); pathSum(root, sum, currentResult, result); return result; &#125; public void pathSum(TreeNode root, int sum, List&lt;Integer&gt; currentResult, List&lt;List&lt;Integer&gt;&gt; result)&#123; if(root == null) return; currentResult.add(new Integer(root.val)); if(root.left == null &amp;&amp; root.right == null &amp;&amp; sum == root.val)&#123; result.add(new LinkedList(currentResult)); currentResult.remove(currentResult.size() - 1); return; &#125;else&#123; pathSum(root.left, sum-root.val, currentResult, result); pathSum(root.right, sum-root.val, currentResult, result); &#125; currentResult.remove(currentResult.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[112. Path Sum]]></title>
    <url>%2Fp%2F17e12313%2F</url>
    <content type="text"><![CDATA[33.2% https://leetcode.com/problems/path-sum/description/ Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. 12345678910For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 方法一： 我的代码实现： Oct 17， 2017 12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(!root) return false; if(!root-&gt;left &amp;&amp; !root-&gt;right) return root-&gt;val == sum; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; code 1： 从根节点开始，如果根等于NULL，false，如果左右节点为空，并且根的值等于sum，那么为true，否则进行迭代。 12345678class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(root == NULL) return false; if(root-&gt;val == sum &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right ==NULL) return true; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; code 2： 我自己的代码 123456789class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(root==NULL) return false; if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return root-&gt;val == sum; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; 方法二： 迭代的方法，使用后序遍历的方法 By using postorder traversal In the postorder traversal, the node will be removed from the stack only when the right sub-tree has been visited. so the path will be stored in the stack. we can keep check the SUM, the length from root to leaf node.at leaf node, if SUM == sum, OK, return true. After postorder traversal, return false. I have compared this solution with recursion solutions. In the leetcode OJ, the run time of two solutions is very near. below is my iterator code. 12345678910111213141516171819202122232425262728class Solution &#123;public: bool hasPathSum(TreeNode *root, int sum) &#123; stack&lt;TreeNode *&gt; s; TreeNode *pre = NULL, *cur = root; int SUM = 0; while (cur || !s.empty()) &#123; while (cur) &#123; s.push(cur); SUM += cur-&gt;val; cur = cur-&gt;left; &#125; cur = s.top(); if (cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL &amp;&amp; SUM == sum) &#123; return true; &#125; if (cur-&gt;right &amp;&amp; pre != cur-&gt;right) &#123; cur = cur-&gt;right; &#125; else &#123; pre = cur; s.pop(); SUM -= cur-&gt;val; cur = NULL; &#125; &#125; return false; &#125;&#125;; 注意：本题答案来看，只有没有左右孩子节点的路径才算一条完整路径。 https://discuss.leetcode.com/topic/892/why-is-the-output-of-1-2-1-is-false 1234Why is the output of &quot;&#123;1, 2&#125;, 1&quot; is false? 12 The struct is like above, and the sum of right path is 1. Why the output is false? Additional: Find another problem: the output of “{1}, 1” is true…… why….. the question is “determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum”. So the condition is there is a path from the root to a leaf. For your tree, there is only one leaf (2) cpp https://leetcode.com/discuss/27236/3-lines-of-c-solution 12ms, 22.26%, June.17th, 2016 1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(root == NULL) return false; if(root-&gt;val == sum &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right ==NULL) return true; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; https://discuss.leetcode.com/topic/2455/accepted-by-using-postorder-traversal [Accepted] By using postorder traversal In the postorder traversal, the node will be removed from the stack only when the right sub-tree has been visited. so the path will be stored in the stack. we can keep check the SUM, the length from root to leaf node.at leaf node, if SUM == sum, OK, return true. After postorder traversal, return false. I have compared this solution with recursion solutions. In the leetcode OJ, the run time of two solutions is very near. below is my iterator code. 12345678910111213141516171819202122232425262728class Solution &#123;public: bool hasPathSum(TreeNode *root, int sum) &#123; stack&lt;TreeNode *&gt; s; TreeNode *pre = NULL, *cur = root; int SUM = 0; while (cur || !s.empty()) &#123; while (cur) &#123; s.push(cur); SUM += cur-&gt;val; cur = cur-&gt;left; &#125; cur = s.top(); if (cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL &amp;&amp; SUM == sum) &#123; return true; &#125; if (cur-&gt;right &amp;&amp; pre != cur-&gt;right) &#123; cur = cur-&gt;right; &#125; else &#123; pre = cur; s.pop(); SUM -= cur-&gt;val; cur = NULL; &#125; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/26599/share-my-3-lines-c-solution Share my 3 lines c++ solution 1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(!root) return false; if((root -&gt; val == sum) &amp;&amp; ((!root -&gt; left) &amp;&amp; (!root -&gt; right))) return true; return hasPathSum(root -&gt; left, sum - root -&gt; val) || hasPathSum(root -&gt; right, sum - root -&gt; val); &#125;&#125;; python 84ms, 29.07%, June.17th, 2016 https://leetcode.com/discuss/28873/short-python-recursive-solution-o-n 123456789101112131415161718# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): &quot;&quot;&quot; :type root: TreeNode :type sum: int :rtype: bool &quot;&quot;&quot; if not root: return False if not root.left and not root.right and root.val == sum: return True sum -= root.val return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum) https://discuss.leetcode.com/topic/18433/python-solutions-dfs-recursively-dfs-stack-bfs-queue Python solutions (DFS recursively, DFS+stack, BFS+queue) 123456789101112131415# DFS Recursively def hasPathSum1(self, root, sum): res = [] self.dfs(root, sum, res) return any(res) def dfs(self, root, target, res): if root: if not root.left and not root.right: if root.val == target: res.append(True) if root.left: self.dfs(root.left, target-root.val, res) if root.right: self.dfs(root.right, target-root.val, res) 123456789101112131415# DFS with stackdef hasPathSum2(self, root, sum): if not root: return False stack = [(root, root.val)] while stack: curr, val = stack.pop() if not curr.left and not curr.right: if val == sum: return True if curr.right: stack.append((curr.right, val+curr.right.val)) if curr.left: stack.append((curr.left, val+curr.left.val)) return False 123456789101112131415# BFS with queuedef hasPathSum(self, root, sum): if not root: return False queue = [(root, sum-root.val)] while queue: curr, val = queue.pop(0) if not curr.left and not curr.right: if val == 0: return True if curr.left: queue.append((curr.left, val-curr.left.val)) if curr.right: queue.append((curr.right, val-curr.right.val)) return False java The basic idea is to subtract the value of current node from sum until it reaches a leaf node and the subtraction equals 0, then we know that we got a hit. Otherwise the subtraction at the end could not be 0. 1ms, 9.51%, June.17th, 2016 https://leetcode.com/discuss/10456/accepted-my-recursive-solution-in-java 12345678910111213141516/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null) return false; if(root.left == null &amp;&amp; root.right == null &amp;&amp; sum - root.val == 0) return true; return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[111. Minimum Depth of Binary Tree]]></title>
    <url>%2Fp%2Fb1d96f1f%2F</url>
    <content type="text"><![CDATA[32.5% https://leetcode.com/problems/minimum-depth-of-binary-tree/ Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 方法一： 利用求树的深度的方法之一，使用一个队列的方法。 bfs，广度优先搜索 1234567891011121314151617181920212223class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(root==NULL) return 0; int res = 0; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty())&#123; res++; int n = que.size(); for(int i=0; i&lt;n; i++)&#123; TreeNode* cur = que.front(); que.pop(); if(cur-&gt;left==NULL &amp;&amp; cur-&gt;right==NULL) return res; if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); &#125; &#125; &#125;&#125;; 方法二： 同样是树的深度，深度优先遍历 123456789class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; if(!root-&gt;left) return 1 + minDepth(root-&gt;right); if(!root-&gt;right) return 1 + minDepth(root-&gt;left); return 1+min(minDepth(root-&gt;left),minDepth(root-&gt;right)); &#125;&#125;; 我的代码实现： 12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; if(!root-&gt;left) return 1+minDepth(root-&gt;right); if(!root-&gt;right) return 1+minDepth(root-&gt;left); return min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + 1; &#125;&#125;; 方法三： 利用一个helper函数，递归调用 123456789101112131415161718192021class Solution &#123;private: int depth;public: int minDepth(TreeNode* root) &#123; if(root==NULL) return 0; depth = 1; return helper(root, depth); &#125; int helper(TreeNode* root, int depth)&#123; if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return depth; else if(root-&gt;right!=NULL &amp;&amp; root-&gt;left!=NULL) return min(helper(root-&gt;left, depth+1), helper(root-&gt;right, depth+1)); else if(root-&gt;right!=NULL) return helper(root-&gt;right, depth+1); else return helper(root-&gt;left, depth+1); &#125;&#125;; cpp9ms, 41.83%, September 25, 2016 https://discuss.leetcode.com/topic/6767/my-concise-c-solution 123456789class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; if(!root-&gt;left) return 1 + minDepth(root-&gt;right); if(!root-&gt;right) return 1 + minDepth(root-&gt;left); return 1+min(minDepth(root-&gt;left),minDepth(root-&gt;right)); &#125;&#125;; my code: 123456789101112131415161718192021class Solution &#123;private: int depth;public: int minDepth(TreeNode* root) &#123; if(root==NULL) return 0; depth = 1; return helper(root, depth); &#125; int helper(TreeNode* root, int depth)&#123; if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return depth; else if(root-&gt;right!=NULL &amp;&amp; root-&gt;left!=NULL) return min(helper(root-&gt;left, depth+1), helper(root-&gt;right, depth+1)); else if(root-&gt;right!=NULL) return helper(root-&gt;right, depth+1); else return helper(root-&gt;left, depth+1); &#125;&#125;; 1ms, 15.51%, September 25, 2016 https://discuss.leetcode.com/topic/8723/my-4-line-java-solution 12345678public class Solution &#123; public int minDepth(TreeNode root) &#123; if(root==null) return 0; int left = minDepth(root.left); int right = minDepth(root.right); return(left==0||right==0)?left+right+1:Math.min(left, right)+1; &#125;&#125; 1ms, 15.51%, September 25, 2016 https://discuss.leetcode.com/topic/8723/my-4-line-java-solution 12345678public class Solution &#123; public int minDepth(TreeNode root) &#123; if(root==null) return 0; if(root.left == null) return minDepth(root.right)+1; if(root.right == null) return minDepth(root.left)+1; return Math.min(minDepth(root.left), minDepth(root.right)) + 1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[110. Balanced Binary Tree]]></title>
    <url>%2Fp%2F205e8441%2F</url>
    <content type="text"><![CDATA[36.5% https://leetcode.com/problems/balanced-binary-tree/?tab=Description Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 剑指offer 39 第二题 The bottom up O(N) solution would be better This problem is generally believed to have two solutions: the top down approach and the bottom up way. 方法一： 最简单最直接，根据题目定义来决策。 缺点：复杂度高，效率低。 1.The first method checks whether the tree is balanced strictly according to the definition of balanced binary tree: the difference between the heights of the two sub trees are not bigger than 1, and both the left sub tree and right sub tree are also balanced. With the helper function depth(), we could easily write the code; 12345678910111213141516class solution &#123;public: int depth (TreeNode *root) &#123; if (root == NULL) return 0; return max (depth(root -&gt; left), depth (root -&gt; right)) + 1; &#125; bool isBalanced (TreeNode *root) &#123; if (root == NULL) return true; int left=depth(root-&gt;left); int right=depth(root-&gt;right); return abs(left - right) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;; For the current node root, calling depth() for its left and right children actually has to access all of its children, thus the complexity is O(N). We do this for each node in the tree, so the overall complexity of isBalanced will be O(N^2). This is a top down approach. 方法二： 基于dfs的方法，自底向上的方法，每一步一个判断。 有点：效率高。 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; return depth(root)!=-1; &#125; int depth(TreeNode* root)&#123; if(!root) return 0; int l = depth(root-&gt;left); if(l==-1) return -1; int r = depth(root-&gt;right); if(r==-1) return -1; if(abs(l-r)&gt;1) return -1; return max(l, r)+1; &#125;&#125;; 2.The second method is based on DFS. Instead of calling depth() explicitly for each child node, we return the height of the current node in DFS recursion. When the sub tree of the current node (inclusive) is balanced, the function dfsHeight() returns a non-negative value as the height. Otherwise -1 is returned. According to the leftHeight and rightHeight of the two children, the parent node could check if the sub tree is balanced, and decides its return value. 1234567891011121314151617class solution &#123;public:int dfsHeight (TreeNode *root) &#123; if (root == NULL) return 0; int leftHeight = dfsHeight (root -&gt; left); if (leftHeight == -1) return -1; int rightHeight = dfsHeight (root -&gt; right); if (rightHeight == -1) return -1; if (abs(leftHeight - rightHeight) &gt; 1) return -1; return max (leftHeight, rightHeight) + 1; &#125; bool isBalanced(TreeNode *root) &#123; return dfsHeight (root) != -1; &#125;&#125;; In this bottom up approach, each node in the tree only need to be accessed once. Thus the time complexity is O(N), better than the first solution. 我的代码实现： 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; // 使用一个depth函数，如果符合则返回深度，否则返回-1 return depth(root)!=-1; &#125; int depth(TreeNode* root)&#123; if(!root) return 0; int left = depth(root-&gt;left); if(left==-1) return -1; int right = depth(root-&gt;right); if(right==-1) return -1; if(abs(left-right)&gt;1) return -1; return max(left, right) + 1; &#125;&#125;; 代码的另一种实现： 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; int depth = 0; return helper(root, &amp;depth); &#125; bool helper(TreeNode* root, int* depth)&#123; if(!root)&#123; depth = 0; return true; &#125; int left, right; if(helper(root-&gt;left, &amp;left)) return false; if(helper(root-&gt;right, &amp;right)) return false; if(abs(left-right)&gt;1) return false; * depth = max(left, right) + 1; return true; &#125;&#125;; 理解学习区 https://discuss.leetcode.com/topic/276/two-different-definitions-of-balanced-binary-tree-result-in-two-different-judgments Two different definitions of balanced binary tree result in two different judgments Input: {1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5} Output: false (based on balanced binary definition “no 2 leaf nodes differ in distance from the root by more than 1”) Expected: true (base on balanced binary definition “two subtrees of every node never differ by more than 1” ) From the problem description, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.Below is a representation of the tree input: {1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}: 1234567891011blank ____1____ / \ 2 2 / \ / \ 3 3 3 3 /\ /\ /\ 4 4 4 4 4 4 /\5 5 Let’s start with the root node (1). As you can see, left subtree’s depth is 5, while right subtree’s depth is 4. Therefore, the condition for a height-balanced binary tree holds for the root node. We continue the same comparison recursively for both left and right subtree, and we conclude that this is indeed a balanced binary tree. Additional Note: AVL Tree’s height-balanced definition is exactly the same as above definition, and its height-balancedness is more rigid compared to a Red Black Tree. As quoted from Wikipedia’s definition of AVL tree: In an AVL tree, the heights of the two child subtrees of any node differ by at most one…. For lookup-intensive applications, AVL trees are faster than red-black trees because they are more rigidly balanced. https://discuss.leetcode.com/topic/7798/the-bottom-up-o-n-solution-would-be-better The bottom up O(N) solution would be better This problem is generally believed to have two solutions: the top down approach and the bottom up way. 1.The first method checks whether the tree is balanced strictly according to the definition of balanced binary tree: the difference between the heights of the two sub trees are not bigger than 1, and both the left sub tree and right sub tree are also balanced. With the helper function depth(), we could easily write the code; 12345678910111213141516class solution &#123;public: int depth (TreeNode *root) &#123; if (root == NULL) return 0; return max (depth(root -&gt; left), depth (root -&gt; right)) + 1; &#125; bool isBalanced (TreeNode *root) &#123; if (root == NULL) return true; int left=depth(root-&gt;left); int right=depth(root-&gt;right); return abs(left - right) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;; For the current node root, calling depth() for its left and right children actually has to access all of its children, thus the complexity is O(N). We do this for each node in the tree, so the overall complexity of isBalanced will be O(N^2). This is a top down approach. 2.The second method is based on DFS. Instead of calling depth() explicitly for each child node, we return the height of the current node in DFS recursion. When the sub tree of the current node (inclusive) is balanced, the function dfsHeight() returns a non-negative value as the height. Otherwise -1 is returned. According to the leftHeight and rightHeight of the two children, the parent node could check if the sub treeis balanced, and decides its return value. 1234567891011121314151617class solution &#123;public:int dfsHeight (TreeNode *root) &#123; if (root == NULL) return 0; int leftHeight = dfsHeight (root -&gt; left); if (leftHeight == -1) return -1; int rightHeight = dfsHeight (root -&gt; right); if (rightHeight == -1) return -1; if (abs(leftHeight - rightHeight) &gt; 1) return -1; return max (leftHeight, rightHeight) + 1; &#125; bool isBalanced(TreeNode *root) &#123; return dfsHeight (root) != -1; &#125;&#125;; In this bottom up approach, each node in the tree only need to be accessed once. Thus the time complexity is O(N), better than the first solution. 1ms, 69.69%, September 25, 2016 https://discuss.leetcode.com/topic/11007/java-solution-based-on-height-check-left-and-right-node-in-every-recursion-to-avoid-further-useless-search Java solution based on height, check left and right node in every recursion to avoid further useless search 1234567891011121314151617public class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if(root == null) return true; return height(root) != -1; &#125; public int height(TreeNode node)&#123; if(node==null) return 0; int LH = height(node.left); if(LH == -1) return -1; int RH = height(node.right); if(RH == -1) return -1; if(LH-RH&lt;-1 || LH-RH &gt;1) return -1; return Math.max(LH, RH)+1; &#125;&#125; https://discuss.leetcode.com/topic/3746/accepted-o-n-solution Accepted O(n) solution We determine recursively the height of the root node but when the recursion is coming upwards we return UNBALANCED instead of the actual height if we know that the tree is already known to be unbalanced. We visit each node just once thus it has linear time complexity. 1234567891011121314151617181920private static final int UNBALANCED = -99;public boolean isBalanced(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return getHeight(root) != UNBALANCED;&#125;private int getHeight(TreeNode root) &#123; if (root == null) &#123; return -1; &#125; int l = getHeight(root.left); int r = getHeight(root.right); if (l == UNBALANCED || r == UNBALANCED || Math.abs(l-r) &gt; 1) &#123; return UNBALANCED; &#125; return 1 + Math.max(l,r);&#125; https://discuss.leetcode.com/topic/42953/very-simple-python-solutions-iterative-and-recursive-both-beat-90 VERY SIMPLE Python solutions (iterative and recursive), both beat 90% 1234567891011121314151617class Solution(object): def isBalanced(self, root): def check(root): if root is None: return 0 left = check(root.left) right = check(root.right) if left == -1 or right == -1 or abs(left - right) &gt; 1: return -1 return 1 + max(left, right) return check(root) != -1# 226 / 226 test cases passed.# Status: Accepted# Runtime: 80 ms Iterative, based on postorder traversal: 123456789101112131415161718192021222324class Solution(object): def isBalanced(self, root): stack, node, last, depths = [], root, None, &#123;&#125; while stack or node: if node: stack.append(node) node = node.left else: node = stack[-1] if not node.right or last == node.right: node = stack.pop() left, right = depths.get(node.left, 0), depths.get(node.right, 0) if abs(left - right) &gt; 1: return False depths[node] = 1 + max(left, right) last = node node = None else: node = node.right return True# 226 / 226 test cases passed.# Status: Accepted# Runtime: 84 ms https://discuss.leetcode.com/topic/1278/can-we-have-a-better-solution Can we have a better solution My solution for this problem is as follows: 123456789101112131415public class Solution &#123;public boolean isBalanced(TreeNode root) &#123; if (root == null) return true; if (Math.abs(depth(root.left) - depth(root.right)) &gt;1) return false; return isBalanced(root.left) &amp;&amp; isBalanced(root.right);&#125;private int depth(TreeNode root)&#123; if (root == null) return 0; return Math.max(depth(root.left), depth(root.right)) + 1;&#125;&#125; But it has two recursions, one for depth() and one for isBalanced(). Will there be a performance issue? 109ms, 32.19%, September 25, 2016 https://discuss.leetcode.com/topic/14752/a-simple-python-recursive-solution-172ms 1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isBalanced(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if not root: return True return abs(self.getHeight(root.left)-self.getHeight(root.right))&lt;2 and self.isBalanced(root.left) and self.isBalanced(root.right) def getHeight(self, root): if not root: return 0 return 1+max(self.getHeight(root.left), self.getHeight(root.right))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[109. Convert Sorted List to Binary Search Tree]]></title>
    <url>%2Fp%2F15b352ee%2F</url>
    <content type="text"><![CDATA[33.1% https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/ Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. 方法一: 先找到中间点，将左侧右侧断开。断开这一点值得学习，我们可以原有的数据结构。 我的代码实现： 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *//** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* sortedListToBST(ListNode* head) &#123; if(!head) return nullptr; // 考虑只有一个元素的情况 if(!head-&gt;next) return new TreeNode(head-&gt;val); ListNode* pre=head, *slow=head, *fast=head; while(fast &amp;&amp; fast-&gt;next)&#123; pre = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; TreeNode* root = new TreeNode(slow-&gt;val); pre-&gt;next = nullptr; root-&gt;left = sortedListToBST(head); root-&gt;right = sortedListToBST(slow-&gt;next); return root; &#125;&#125;; https://discuss.leetcode.com/topic/10979/clean-c-solution-recursion-o-nlogn-with-comment Clean C++ solution. Recursion. O(nlogn). With comment Recursively build tree. find midpoint by fast/slow method, use middle node as root. build left child by first half of the list build right child by second half of the list (head is midpoint-&gt;next) 12345678910111213141516171819202122232425class Solution &#123;public: TreeNode *sortedListToBST(ListNode *head) &#123; if(!head) return NULL; if(!head-&gt;next) return new TreeNode(head-&gt;val); // fast/slow pointer to find the midpoint auto slow = head; auto fast = head; auto pre = head; while(fast &amp;&amp; fast-&gt;next) &#123; pre = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; pre-&gt;next = 0; // break two halves // slow is the midpoint, use as root TreeNode* root = new TreeNode(slow-&gt;val); root-&gt;left = sortedListToBST(head); root-&gt;right = sortedListToBST(slow-&gt;next); return root; &#125;&#125;; 方法二： 这种方法还需要再思考。 https://discuss.leetcode.com/topic/3286/share-my-code-with-o-n-time-and-o-1-space Share my code with O(n) time and O(1) space count is a function to calculate the size of list. Key words: inorder traversal. 12345678910111213141516171819202122232425262728class Solution &#123;public: ListNode *list; int count(ListNode *node)&#123; int size = 0; while (node) &#123; ++size; node = node-&gt;next; &#125; return size; &#125; TreeNode *generate(int n)&#123; if (n == 0) return NULL; TreeNode *node = new TreeNode(0); node-&gt;left = generate(n / 2); node-&gt;val = list-&gt;val; list = list-&gt;next; node-&gt;right = generate(n - n / 2 - 1); return node; &#125; TreeNode *sortedListToBST(ListNode *head) &#123; this-&gt;list = head; return generate(count(head)); &#125;&#125;; https://discuss.leetcode.com/topic/6444/my-accepted-c-solution My Accepted C++ solution 1234567891011121314151617181920212223242526272829class Solution &#123;public: TreeNode *sortedListToBST(ListNode *head) &#123; return sortedListToBST( head, NULL ); &#125; private: TreeNode *sortedListToBST(ListNode *head, ListNode *tail) &#123; if( head == tail ) return NULL; if( head-&gt;next == tail ) // &#123; TreeNode *root = new TreeNode( head-&gt;val ); return root; &#125; ListNode *mid = head, *temp = head; while( temp != tail &amp;&amp; temp-&gt;next != tail ) // 寻找中间节点 &#123; mid = mid-&gt;next; temp = temp-&gt;next-&gt;next; &#125; TreeNode *root = new TreeNode( mid-&gt;val ); root-&gt;left = sortedListToBST( head, mid ); root-&gt;right = sortedListToBST( mid-&gt;next, tail ); return root; &#125;&#125;; https://discuss.leetcode.com/topic/2286/how-about-like-this How about like this? 1234567891011121314151617TreeNode *sortedListToBST(ListNode *head) &#123; if(head == NULL) return NULL; if(head-&gt;next == NULL) return new TreeNode(head-&gt;val); ListNode *step1 = head; ListNode *step2 = head-&gt;next; while(step2-&gt;next != NULL &amp;&amp; step2-&gt;next-&gt;next != NULL)&#123; step1 = step1-&gt;next; step2 = step2-&gt;next-&gt;next; &#125; TreeNode *root = new TreeNode(step1-&gt;next-&gt;val); ListNode *head2 = step1-&gt;next-&gt;next; delete step1-&gt;next; step1-&gt;next = NULL; root-&gt;left = sortedListToBST(head); root-&gt;right = sortedListToBST(head2); return root;&#125; https://discuss.leetcode.com/topic/21414/python-recursive-solution-with-detailed-comments-operate-linked-list-directly Python recursive solution with detailed comments (operate linked-list directly). recursively 12345678910111213141516171819202122def sortedListToBST(self, head): if not head: return if not head.next: return TreeNode(head.val) # here we get the middle point, # even case, like &apos;1234&apos;, slow points to &apos;2&apos;, # &apos;3&apos; is root, &apos;12&apos; belongs to left, &apos;4&apos; is right # odd case, like &apos;12345&apos;, slow points to &apos;2&apos;, &apos;12&apos; # belongs to left, &apos;3&apos; is root, &apos;45&apos; belongs to right slow, fast = head, head.next.next while fast and fast.next: fast = fast.next.next slow = slow.next # tmp points to root tmp = slow.next # cut down the left child slow.next = None root = TreeNode(tmp.val) root.left = self.sortedListToBST(head) root.right = self.sortedListToBST(tmp.next) return root https://discuss.leetcode.com/topic/35997/share-my-java-solution-1ms-very-short-and-concise Share my JAVA solution, 1ms, very short and concise. 123456789101112131415161718public TreeNode sortedListToBST(ListNode head) &#123; if(head==null) return null; return toBST(head,null);&#125;public TreeNode toBST(ListNode head, ListNode tail)&#123; ListNode slow = head; ListNode fast = head; if(head==tail) return null; while(fast!=tail&amp;&amp;fast.next!=tail)&#123; fast = fast.next.next; slow = slow.next; &#125; TreeNode thead = new TreeNode(slow.val); thead.left = toBST(head,slow); thead.right = toBST(slow.next,tail); return thead;&#125; https://discuss.leetcode.com/topic/8141/share-my-o-1-space-and-o-n-time-java-code Share my O(1) space and O(n) time Java code private ListNode node; 12345678910111213141516171819202122232425262728293031323334public TreeNode sortedListToBST(ListNode head) &#123; if(head == null)&#123; return null; &#125; int size = 0; ListNode runner = head; node = head; while(runner != null)&#123; runner = runner.next; size ++; &#125; return inorderHelper(0, size - 1);&#125;public TreeNode inorderHelper(int start, int end)&#123; if(start &gt; end)&#123; return null; &#125; int mid = start + (end - start) / 2; TreeNode left = inorderHelper(start, mid - 1); TreeNode treenode = new TreeNode(node.val); treenode.left = left; node = node.next; TreeNode right = inorderHelper(mid + 1, end); treenode.right = right; return treenode;&#125; https://discuss.leetcode.com/topic/24418/recursive-bst-construction-using-slow-fast-traversal-on-linked-list Recursive BST construction using slow-fast traversal on linked list 12345678910111213141516171819202122public TreeNode sortedListToBST(ListNode head) &#123; if(head == null) return null; ListNode fast = head; ListNode slow = head; ListNode prev =null; while(fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; prev =slow; slow=slow.next; &#125; TreeNode root = new TreeNode(slow.val); if(prev != null) prev.next = null; else head = null; root.left = sortedListToBST(head); root.right = sortedListToBST(slow.next); return root;&#125; Traverse the list to get the middle element and make that the root. left side of the list forms left sub-tree and right side of the middle element forms the right sub-tree.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>linked list</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[108. Convert Sorted Array to Binary Search Tree]]></title>
    <url>%2Fp%2F4e75dfe7%2F</url>
    <content type="text"><![CDATA[41.0% https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 方法一： 20ms, 24.24%, July 14th, 2016 https://discuss.leetcode.com/topic/6472/accepted-c-recursive-solution-within-a-single-method Accepted C++ recursive solution within a single method Recursively call the sortedArrayToBST() method providing new vector for each call to construct left and right children: 123456789101112131415161718class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return NULL; if(nums.size() == 1) return new TreeNode(nums[0]); int middle = nums.size()/2; TreeNode* root = new TreeNode(nums[middle]); vector&lt;int&gt; leftInts(nums.begin(), nums.begin() + middle); vector&lt;int&gt; rightInts(nums.begin()+middle+1, nums.end()); root-&gt;left = sortedArrayToBST(leftInts); root-&gt;right = sortedArrayToBST(rightInts); return root; &#125; &#125;; 方法二 ： https://discuss.leetcode.com/topic/24667/16-ms-c-solution 16 ms C++ solution 1234567891011121314class Solution &#123; TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums, int start, int end)&#123; if(end&lt;=start) return NULL; int midIdx=(end+start)/2; TreeNode* root=new TreeNode(nums[midIdx]); root-&gt;left=sortedArrayToBST(nums, start, midIdx); root-&gt;right=sortedArrayToBST(nums, midIdx+1,end); return root; &#125;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return sortedArrayToBST(nums, 0,nums.size()); &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return helper(nums, 0, nums.size()-1); &#125; TreeNode* helper(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if(left&gt;right) return NULL; int mid = left+(right-left)/2; TreeNode* root = new TreeNode(nums[mid]); root-&gt;left = helper(nums, left, mid-1); root-&gt;right = helper(nums, mid+1, right); return root; &#125;&#125;; 116ms, 24.46%, July 14th, 2016 https://discuss.leetcode.com/topic/10519/an-easy-python-solutio An easy Python solution The idea is to find the root first, then recursively build each left and right subtree 12345678910111213141516class Solution(object): def sortedArrayToBST(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: TreeNode &quot;&quot;&quot; if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid+1:]) return root 0ms, 99.14%, July 14th, 2016 https://discuss.leetcode.com/topic/3158/my-accepted-java-solution My Accepted Java Solution Hi everyone, this is my accepted recursive Java solution. I get overflow problems at first because I didn’t use mid - 1 and mid + 1 as the bound. Hope this helps :) 1234567891011121314151617public class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; if(nums.length == 0) return null; TreeNode head = helper(nums, 0, nums.length-1); return head; &#125; public TreeNode helper(int[] nums, int low, int high)&#123; if(low &gt; high) return null; int mid = (low + high) / 2; TreeNode node = new TreeNode(nums[mid]); node.left = helper(nums, low, mid-1); node.right = helper(nums, mid+1, high); return node; &#125;&#125; https://discuss.leetcode.com/topic/14412/java-iterative-solution Java Iterative Solution I came up with the recursion solution first and tried to translate it into an iterative solution. It is very similar to doing a tree inorder traversal, I use three stacks - nodeStack stores the node I am going to process next, and leftIndexStack and rightIndexStack store the range where this node need to read from the nums. 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; int len = nums.length; if ( len == 0 ) &#123; return null; &#125; // 0 as a placeholder TreeNode head = new TreeNode(0); Deque&lt;TreeNode&gt; nodeStack = new LinkedList&lt;TreeNode&gt;() &#123;&#123; push(head); &#125;&#125;; Deque&lt;Integer&gt; leftIndexStack = new LinkedList&lt;Integer&gt;() &#123;&#123; push(0); &#125;&#125;; Deque&lt;Integer&gt; rightIndexStack = new LinkedList&lt;Integer&gt;() &#123;&#123; push(len-1); &#125;&#125;; while ( !nodeStack.isEmpty() ) &#123; TreeNode currNode = nodeStack.pop(); int left = leftIndexStack.pop(); int right = rightIndexStack.pop(); int mid = left + (right-left)/2; // avoid overflow currNode.val = nums[mid]; if ( left &lt;= mid-1 ) &#123; currNode.left = new TreeNode(0); nodeStack.push(currNode.left); leftIndexStack.push(left); rightIndexStack.push(mid-1); &#125; if ( mid+1 &lt;= right ) &#123; currNode.right = new TreeNode(0); nodeStack.push(currNode.right); leftIndexStack.push(mid+1); rightIndexStack.push(right); &#125; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[107. Binary Tree Level Order Traversal II]]></title>
    <url>%2Fp%2F7174bdf5%2F</url>
    <content type="text"><![CDATA[38.6% https://leetcode.com/problems/binary-tree-level-order-traversal-ii/#/description Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). 12345678910111213For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its bottom-up level order traversal as:[ [15,7], [9,20], [3]] 方法一： 本题类似于102题，只是最后结果给翻转一下就可以了。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty())&#123; int n = que.size(); vector&lt;int&gt; tmp; for(int i=0; i&lt;n; i++)&#123; TreeNode* cur = que.front(); que.pop(); tmp.push_back(cur-&gt;val); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); &#125; res.push_back(tmp); &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 方法二： 层序遍历，dfs，然后最后返回结果修改一下顺序就可以了。 6ms, 37.42%, September 25, 2016 https://discuss.leetcode.com/topic/1672/is-there-any-better-idea-than-doing-regular-level-order-traversal-and-reverse-the-result Is there any better idea than doing regular level order traversal and reverse the result? The way I see this problem is that it is EXACTLY the same as “Level-Order Traversal I” except that we need to reverse the final container for output, which is trivial. Is there a better idea that fits this problem specifically? The attached is my current recursive solution. In each function call, we pass in the current node and its level. If this level does not yet exist in the output container, then we should add a new empty level. Then, we add the current node to the end of the current level, and recursively call the function passing the two children of the current node at the next level. This algorithm is really a DFS, but it saves the level information for each node and produces the same result as BFS would. 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; res; void DFS(TreeNode* root, int level) &#123; if (root == NULL) return; if (level == res.size()) // The level does not exist in output &#123; res.push_back(vector&lt;int&gt;()); // Create a new level &#125; res[level].push_back(root-&gt;val); // Add the current value to its level DFS(root-&gt;left, level+1); // Go to the next level DFS(root-&gt;right,level+1); &#125; vector&lt;vector&lt;int&gt; &gt; levelOrderBottom(TreeNode *root) &#123; DFS(root, 0); return vector&lt;vector&lt;int&gt; &gt; (res.rbegin(), res.rend()); &#125;&#125;; https://discuss.leetcode.com/topic/10903/my-neat-solution-in-c My Neat Solution in C++ 123456789101112131415161718192021222324vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt; &gt; retVal; levelOrder(root, retVal, 0); reverse(retVal.begin(), retVal.end()); return retVal;&#125;void levelOrder(TreeNode* root, vector&lt;vector&lt;int&gt; &gt; &amp;v, int currLevel) &#123; if (root == NULL) &#123; return; &#125; if (v.empty() || currLevel &gt; (v.size() - 1)) &#123; v.push_back(vector&lt;int&gt;()); &#125; v[currLevel].push_back(root-&gt;val); levelOrder(root-&gt;left, v, currLevel + 1); levelOrder(root-&gt;right, v, currLevel + 1);&#125; https://discuss.leetcode.com/topic/27413/c-4ms-solution C++ 4ms solution! First version costs 8ms: 123456789101112131415void levelOrder(vector&lt;vector&lt;int&gt;&gt; &amp;ans, TreeNode *node, int level) &#123; if (!node) return; if (level &gt;= ans.size()) ans.push_back(&#123;&#125;); ans[level].push_back(node-&gt;val); levelOrder(ans,node-&gt;left,level+1); levelOrder(ans,node-&gt;right,level+1);&#125;vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ans; levelOrder(ans,root,0); reverse(ans.begin(),ans.end()); return ans;&#125; Second version costs 4ms: 123456789101112131415161718int depth(TreeNode *root) &#123; if (!root) return 0; return max(depth(root-&gt;left),depth(root-&gt;right))+1;&#125;void levelOrder(vector&lt;vector&lt;int&gt;&gt; &amp;ans, TreeNode *node, int level) &#123; if (!node) return; ans[level].push_back(node-&gt;val); levelOrder(ans,node-&gt;left,level-1); levelOrder(ans,node-&gt;right,level-1);&#125;vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; int d = depth(root); vector&lt;vector&lt;int&gt;&gt; ans(d,vector&lt;int&gt; &#123;&#125;); levelOrder(ans,root,d-1); return ans;&#125; https://discuss.leetcode.com/topic/17702/19-line-c-8ms-solution-very-easy 19 line C++ 8ms Solution, very easy 1234567891011121314151617181920class Solution &#123;protected: vector&lt;vector&lt;int&gt;&gt; ans; void dfs(TreeNode *root, int height)&#123; if (root == NULL) return; while (ans.size() &lt;= height) ans.push_back(vector&lt;int&gt;()); ans[height].push_back(root-&gt;val); dfs(root-&gt;left, height + 1); dfs(root-&gt;right, height + 1); &#125;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; dfs(root, 0); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; https://discuss.leetcode.com/topic/21276/python-solutions-dfs-recursively-dfs-stack-bfs-queue Python solutions (dfs recursively, dfs+stack, bfs+queue). dfs recursively 123456789101112def levelOrderBottom1(self, root): res = [] self.dfs(root, 0, res) return resdef dfs(self, root, level, res): if root: if len(res) &lt; level + 1: res.insert(0, []) res[-(level+1)].append(root.val) self.dfs(root.left, level+1, res) self.dfs(root.right, level+1, res) dfs + stack 123456789101112def levelOrderBottom2(self, root): stack = [(root, 0)] res = [] while stack: node, level = stack.pop() if node: if len(res) &lt; level+1: res.insert(0, []) res[-(level+1)].append(node.val) stack.append((node.right, level+1)) stack.append((node.left, level+1)) return res bfs + queue 123456789101112def levelOrderBottom(self, root): queue, res = collections.deque([(root, 0)]), [] while queue: node, level = queue.popleft() if node: if len(res) &lt; level+1: res.insert(0, []) res[-(level+1)].append(node.val) queue.append((node.left, level+1)) queue.append((node.right, level+1)) return resreply quote https://discuss.leetcode.com/topic/7651/my-dfs-and-bfs-java-solution My DFS and BFS java solution DFS solution: 123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList&lt;List&lt;Integer&gt;&gt;(); if(root == null) return wrapList; queue.offer(root); while(!queue.isEmpty())&#123; int levelNum = queue.size(); List&lt;Integer&gt; subList = new LinkedList&lt;Integer&gt;(); for(int i=0; i&lt;levelNum; i++) &#123; if(queue.peek().left != null) queue.offer(queue.peek().left); if(queue.peek().right != null) queue.offer(queue.peek().right); subList.add(queue.poll().val); &#125; wrapList.add(0, subList); &#125; return wrapList; &#125;&#125; BFS solution: 1234567891011121314151617public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList&lt;List&lt;Integer&gt;&gt;(); levelMaker(wrapList, root, 0); return wrapList; &#125; public void levelMaker(List&lt;List&lt;Integer&gt;&gt; list, TreeNode root, int level) &#123; if(root == null) return; if(level &gt;= list.size()) &#123; list.add(0, new LinkedList&lt;Integer&gt;()); &#125; levelMaker(list, root.left, level+1); levelMaker(list, root.right, level+1); list.get(list.size()-level-1).add(root.val); &#125; &#125; 1ms, 96.03%, September 25, 2016 https://discuss.leetcode.com/topic/7489/simple-java-solution-with-linkedlist 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; LinkedList&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;List&lt;Integer&gt;&gt;(); addLevel(list, 0, root); return list; &#125; private void addLevel(LinkedList&lt;List&lt;Integer&gt;&gt; list, int level, TreeNode node) &#123; if (node == null) return; if (list.size()-1 &lt; level) list.addFirst(new LinkedList&lt;Integer&gt;()); list.get(list.size()-1-level).add(node.val); addLevel(list, level+1, node.left); addLevel(list, level+1, node.right); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[106. Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <url>%2Fp%2F6f813868%2F</url>
    <content type="text"><![CDATA[31.2% https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/?tab=Description Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. 方法一： 检查边界条件 类似105题，剑指 offer第6题 1234567891011121314151617181920212223class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; int n = inorder.size(); if(n&lt;=0) return NULL; TreeNode* root = helper(inorder, postorder, 0, n-1, 0, n-1); return root; &#125; TreeNode* helper(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int is, int ie, int ps, int pe)&#123; if(is&gt;ie || ps&gt;pe) return NULL; TreeNode* root = new TreeNode(postorder[pe]); int pos=is; for(;pos&lt;=ie;pos++)&#123; if(inorder[pos]==postorder[pe]) break; &#125; root-&gt;left = helper(inorder, postorder, is, pos-1, ps, pos-is+ps-1); root-&gt;right = helper(inorder, postorder, pos+1, ie, ps+pos-is, pe-1); return root; &#125;&#125;; cpp my code: 借鉴105题，递归思路。 12345678910111213141516171819202122class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return create(inorder, postorder, 0, inorder.size()-1, 0, postorder.size()-1); &#125; TreeNode* create(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int is, int ie, int ps, int pe)&#123; if(is&gt;ie || ps&gt;pe) return NULL; TreeNode* root = new TreeNode(postorder[pe]); int pos; for(int i=ie; i&gt;=is; i--)&#123; if(inorder[i]==root-&gt;val)&#123; pos = i; break; &#125; &#125; root-&gt;left = create(inorder, postorder, is, pos-1, ps, ps+pos-is-1); root-&gt;right = create(inorder, postorder, pos+1, ie, ps+pos-is, pe-1); return root; &#125;&#125;; 方法二: 迭代法 待解决 https://discuss.leetcode.com/topic/4746/my-comprehension-of-o-n-solution-from-hongzhi My comprehension of O(n) solution from @hongzhi Below is the O(n) solution from @hongzhi but that discuss is closed now ‘cause @hongzhi says little about his code. https://oj.leetcode.com/discuss/6334/here-is-my-o-n-solution-is-it-neat I’ve modified some of and tried this code and got AC. Just share about some comprehension about his code. I’ve modified vtn(vector) to stn(stack) in that stack is probably what this algs means and needs. What matters most is the meaning of stn. Only nodes whoes left side hasn’t been handled will be pushed into stn. And inorder is organized as (inorder of left) root (inorder of right), And postorder is as (postorder of left) (postorder of right) root. So at the very begin, we only have root in stn and we check if inorder.back() == root-&gt;val and in most cases it’s false(see Note 1). Then we make this node root’s right sub-node and push it into stn. Note 1: this is actually (inorder of right).back() == (postorder of right).back(), so if only there’s no right subtree or the answer will always be false. Note 2: we delete one node from postorder as we push one into stn. Now we have [root, root’s right] as stn and we check inorder.back() == stn.top()-&gt;val again. true means inorder.back() is the root node and needs handled left case. false means inorder.back() is the next right sub-node So when we encounter a true, we will cache stn.top() as p and delete both nodes from inorder and stn. Then we check inorder.size(), if there’s no nodes left, it means p has no left node. Else the next node in inorder could be p’s left node or p’s father which equals to the now stn.top() (remember we popped p from stn above). If the latter happens, it means p has no left node and we need to move on to p’s father(stn.top()). If the former happens, it means p has one left node and it’s postorder.back(), so we put it to p’s left and delete it from the postorder and push the left node into stn ‘cause it should be the next check node as the postorder is organized as above. That’s all of it. The algs just build a binary tree. :) Inform me if there’s anything vague or wrong, I’m open to any suggestions. 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: TreeNode *buildTree(vector&lt;int&gt; &amp;inorder, vector&lt;int&gt; &amp;postorder) &#123; if(inorder.size() == 0)return NULL; TreeNode *p; TreeNode *root; stack&lt;TreeNode *&gt; stn; root = new TreeNode(postorder.back()); stn.push(root); postorder.pop_back(); while(true) &#123; if(inorder.back() == stn.top()-&gt;val) &#123; p = stn.top(); stn.pop(); inorder.pop_back(); if(inorder.size() == 0) break; if(stn.size() &amp;&amp; inorder.back() == stn.top()-&gt;val) continue; p-&gt;left = new TreeNode(postorder.back()); postorder.pop_back(); stn.push(p-&gt;left); &#125; else &#123; p = new TreeNode(postorder.back()); postorder.pop_back(); stn.top()-&gt;right = p; stn.push(p); &#125; &#125; return root; &#125;&#125;; https://discuss.leetcode.com/topic/5846/sharing-my-straightforward-recursive-solution Sharing my straightforward recursive solution TreeNode *buildTree(vector &amp;inorder, vector &amp;postorder) { return create(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);} TreeNode create(vector &amp;inorder, vector &amp;postorder, int is, int ie, int ps, int pe){ if(ps &gt; pe){ return nullptr; } TreeNode node = new TreeNode(postorder[pe]); int pos; for(int i = is; i &lt;= ie; i++){ if(inorder[i] == node-&gt;val){ pos = i; break; } } node-&gt;left = create(inorder, postorder, is, pos - 1, ps, ps + pos - is - 1); node-&gt;right = create(inorder, postorder, pos + 1, ie, pe - ie + pos, pe - 1); return node;}Actually, this problem is pretty similar as the previous one. Here is a like to that solution. https://discuss.leetcode.com/topic/1954/here-is-my-o-n-solution-is-it-neat Here is my O(n) solution. Is it neat? 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: TreeNode *buildTree(vector&lt;int&gt; &amp;inorder, vector&lt;int&gt; &amp;postorder) &#123; if(inorder.size() == 0)return NULL; TreeNode* p; TreeNode* root; vector&lt;int&gt; vint; vector&lt;TreeNode*&gt; vtn; root = new TreeNode(postorder.back()); vtn.push_back(root); postorder.pop_back(); while(true) &#123; if(inorder.back() == vtn.back()-&gt;val) &#123; p = vtn.back(); vtn.pop_back(); inorder.pop_back(); if(inorder.size() == 0) break; if(vtn.size()) if(inorder.back() == vtn.back()-&gt;val)continue; p-&gt;left = new TreeNode(postorder.back()); postorder.pop_back(); vtn.push_back(p-&gt;left); &#125; else &#123; p = new TreeNode(postorder.back()); postorder.pop_back(); vtn.back()-&gt;right = p; vtn.push_back(p); &#125; &#125; return root; &#125;&#125;; https://discuss.leetcode.com/topic/16861/my-c-solution My C++ Solution 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return helper(inorder,0,inorder.size(),postorder,0,postorder.size()); &#125;private: TreeNode* helper(vector&lt;int&gt;&amp; inorder,int i,int j,vector&lt;int&gt;&amp; postorder,int ii,int jj) &#123; // 每次取postorder的最后一个值mid，将其作为树的根节点 // 然后从inroder中找到mid，将其分割成为两部分，左边作为mid的左子树，右边作为mid的右子树 // tree: 8 4 10 3 6 9 11 // Inorder [3 4 6] 8 [9 10 11] // postorder [3 6 4] [9 11 10] 8 if(i &gt;= j || ii &gt;= jj) return NULL; int mid = postorder[jj - 1]; auto f = find(inorder.begin() + i,inorder.begin() + j,mid); int dis = f - inorder.begin() - i; TreeNode* root = new TreeNode(mid); root -&gt; left = helper(inorder,i,i + dis,postorder,ii,ii + dis); root -&gt; right = helper(inorder,i + dis + 1,j,postorder,ii + dis,jj - 1); return root; &#125;&#125;; python 222ms, 30.82%, September 25, 2016 https://discuss.leetcode.com/topic/10516/a-python-recursive-solution A Python recursive solution 123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, inorder, postorder): &quot;&quot;&quot; :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode &quot;&quot;&quot; if not inorder or not postorder: return None root = TreeNode(postorder.pop()) inorderIndex = inorder.index(root.val) root.right = self.buildTree(inorder[inorderIndex+1:], postorder) root.left = self.buildTree(inorder[:inorderIndex], postorder) return root https://discuss.leetcode.com/topic/21286/python-short-solution-recursively Python short solution (recursively). 1234567def buildTree(self, inorder, postorder): if inorder: ind = inorder.index(postorder.pop()) root = TreeNode(inorder[ind]) root.right = self.buildTree(inorder[ind+1:], postorder) root.left = self.buildTree(inorder[:ind], postorder) return root java https://discuss.leetcode.com/topic/3296/my-recursive-java-code-with-o-n-time-and-o-n-space My recursive Java code with O(n) time and O(n) space The the basic idea is to take the last element in postorder array as the root, find the position of the root in the inorder array; then locate the range for left sub-tree and right sub-tree and do recursion. Use a HashMap to record the index of root in the inorder array. 123456789101112131415161718192021public TreeNode buildTreePostIn(int[] inorder, int[] postorder) &#123; if (inorder == null || postorder == null || inorder.length != postorder.length) return null; HashMap&lt;Integer, Integer&gt; hm = new HashMap&lt;Integer,Integer&gt;(); for (int i=0;i&lt;inorder.length;++i) hm.put(inorder[i], i); return buildTreePostIn(inorder, 0, inorder.length-1, postorder, 0, postorder.length-1,hm);&#125;private TreeNode buildTreePostIn(int[] inorder, int is, int ie, int[] postorder, int ps, int pe, HashMap&lt;Integer,Integer&gt; hm)&#123; if (ps&gt;pe || is&gt;ie) return null; TreeNode root = new TreeNode(postorder[pe]); int ri = hm.get(postorder[pe]); TreeNode leftchild = buildTreePostIn(inorder, is, ri-1, postorder, ps, ps+ri-is-1, hm); TreeNode rightchild = buildTreePostIn(inorder,ri+1, ie, postorder, ps+ri-is, pe-1, hm); root.left = leftchild; root.right = rightchild; return root;&#125; https://discuss.leetcode.com/topic/3296/my-recursive-java-code-with-o-n-time-and-o-n-space/2 This is my version: similar idea, but no HashMap needed! (TreeNode end is the boundary of left subtree.) 1234567891011121314151617181920212223242526272829303132int pInorder; // index of inorder arrayint pPostorder; // index of postorder arrayprivate TreeNode buildTree(int[] inorder, int[] postorder, TreeNode end) &#123; if (pPostorder &lt; 0) &#123; return null; &#125; // create root node TreeNode n = new TreeNode(postorder[pPostorder--]); // if right node exist, create right subtree if (inorder[pInorder] != n.val) &#123; n.right = buildTree(inorder, postorder, n); &#125; pInorder--; // if left node exist, create left subtree if ((end == null) || (inorder[pInorder] != end.val)) &#123; n.left = buildTree(inorder, postorder, end); &#125; return n;&#125;public TreeNode buildTree(int[] inorder, int[] postorder) &#123; pInorder = inorder.length - 1; pPostorder = postorder.length - 1; return buildTree(inorder, postorder, null);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[105. Construct Binary Tree from Preorder and Inorder Traversal]]></title>
    <url>%2Fp%2Fbf9e0006%2F</url>
    <content type="text"><![CDATA[31.1% https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?tab=Description Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. 方法一： 根据preorder和inorder的特点，找规律。 剑指offer， 第6题 新建一个节点代码：TreeNode* node = new TreeNode(preorder[ps]); 1234567891011121314151617181920TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; return create(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);&#125;TreeNode* create(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int ps, int pe, int is, int ie)&#123; if(ps &gt; pe)&#123; return nullptr; &#125; TreeNode* node = new TreeNode(preorder[ps]); int pos; for(int i = is; i &lt;= ie; i++)&#123; if(inorder[i] == node-&gt;val)&#123; pos = i; break; &#125; &#125; node-&gt;left = create(preorder, inorder, ps + 1, ps + pos - is, is, pos - 1); node-&gt;right = create(preorder, inorder, pe - ie + pos + 1, pe, pos + 1, ie); return node;&#125; 方法二： https://discuss.leetcode.com/topic/10244/my-o-n-19ms-solution-without-recusion-hope-help-you My O(n)(19ms) solution without recusion. Hope help you! 12345678910111213141516171819202122232425class Solution &#123;public: TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; TreeNode *root=NULL; stack&lt;TreeNode *&gt; MyData; if(preorder.empty()) return root; root = new TreeNode(preorder[0]); MyData.push(root); int index = 0; for(int i=1; i&lt;=preorder.size(); i++) &#123; TreeNode *cur = MyData.top(); if((MyData.top()-&gt;val)!=inorder[index]) &#123; cur-&gt;left = new TreeNode(preorder[i]); MyData.push(cur-&gt;left); &#125; else &#123; while(!MyData.empty() &amp;&amp; ((MyData.top()-&gt;val)==inorder[index])) &#123; cur=MyData.top(); MyData.pop(); index++; &#125; if(index&lt;inorder.size()) &#123; cur-&gt;right = new TreeNode(preorder[i]); MyData.push(cur-&gt;right); &#125; &#125; &#125; return root; &#125;&#125;; https://discuss.leetcode.com/topic/16860/my-neat-c-solution My neat C++ solution 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: /* from Preorder and Inorder Traversal */ TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; return helper(preorder,0,preorder.size(),inorder,0,inorder.size()); &#125; TreeNode* helper(vector&lt;int&gt;&amp; preorder,int i,int j,vector&lt;int&gt;&amp; inorder,int ii,int jj) &#123; // tree 8 4 5 3 7 3 // preorder 8 [4 3 3 7] [5] // inorder [3 3 4 7] 8 [5] // 每次从 preorder 头部取一个值 mid，作为树的根节点 // 检查 mid 在 inorder 中 的位置，则 mid 前面部分将作为 树的左子树，右部分作为树的右子树 if(i &gt;= j || ii &gt;= j) return NULL; int mid = preorder[i]; auto f = find(inorder.begin() + ii,inorder.begin() + jj,mid); int dis = f - inorder.begin() - ii; TreeNode* root = new TreeNode(mid); root -&gt; left = helper(preorder,i + 1,i + 1 + dis,inorder,ii,ii + dis); root -&gt; right = helper(preorder,i + 1 + dis,j,inorder,ii + dis + 1,jj); return root; &#125;&#125;; cpp https://discuss.leetcode.com/topic/795/the-iterative-solution-is-easier-than-you-think The iterative solution is easier than you think! I din’t find iterative solutions discussed in the old Discuss. So, I thought, I will add my solution in here. The idea is as follows: Keep pushing the nodes from the preorder into a stack (and keep making the tree by adding nodes to the left of the previous node) until the top of the stack matches the inorder. At this point, pop the top of the stack until the top does not equal inorder (keep a flag to note that you have made a pop). Repeat 1 and 2 until preorder is empty. The key point is that whenever the flag is set, insert a node to the right and reset the flag. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; if(preorder.size()==0) return NULL; stack&lt;int&gt; s; stack&lt;TreeNode *&gt; st; TreeNode *t,*r,*root; int i,j,f; f=i=j=0; s.push(preorder[i]); root = new TreeNode(preorder[i]); st.push(root); t = root; i++; while(i&lt;preorder.size()) &#123; if(!st.empty() &amp;&amp; st.top()-&gt;val==inorder[j]) &#123; t = st.top(); st.pop(); s.pop(); f = 1; j++; &#125; else &#123; if(f==0) &#123; s.push(preorder[i]); t -&gt; left = new TreeNode(preorder[i]); t = t -&gt; left; st.push(t); i++; &#125; else &#123; f = 0; s.push(preorder[i]); t -&gt; right = new TreeNode(preorder[i]); t = t -&gt; right; st.push(t); i++; &#125; &#125; &#125; return root; &#125;&#125;; 33ms, 64.41%, September 25, 2016 https://discuss.leetcode.com/topic/5845/sharing-my-straightforward-recursive-solution Sharing my straightforward recursive solution 递归，直接了当 1234567891011121314151617181920TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; return create(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);&#125;TreeNode* create(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int ps, int pe, int is, int ie)&#123; if(ps &gt; pe)&#123; return nullptr; &#125; TreeNode* node = new TreeNode(preorder[ps]); int pos; for(int i = is; i &lt;= ie; i++)&#123; if(inorder[i] == node-&gt;val)&#123; pos = i; break; &#125; &#125; node-&gt;left = create(preorder, inorder, ps + 1, ps + pos - is, is, pos - 1); node-&gt;right = create(preorder, inorder, pe - ie + pos + 1, pe, pos + 1, ie); return node;&#125; The first element in preorder array can divide inorder array into two parts. Then we can divide preorder array into two parts. Make this element a node. And the left sub-tree of this node is the left part, right sub-tree of this node is the right part. This problem can be solved following this logic. python 199ms, 37.16%, September 25, 2016 https://discuss.leetcode.com/topic/21287/python-short-recursive-solution Python short recursive solution. 1234567def buildTree(self, preorder, inorder): if inorder: ind = inorder.index(preorder.pop(0)) root = TreeNode(inorder[ind]) root.left = self.buildTree(preorder, inorder[0:ind]) root.right = self.buildTree(preorder, inorder[ind+1:]) return root https://discuss.leetcode.com/topic/10474/a-python-recursive-solution A Python recursive solution The idea is to find the root first, and then recursively build each left and right subtree Only Solution 3 could pass the OJ, but theoretically they should all work … Solution 1 - clean and easy to understand, but Memory Limit Exceeded … 123456789101112131415161718192021222324# Definition for a binary tree node# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # @param preorder, a list of integers # @param inorder, a list of integers # @return a tree node # 1:59 def buildTree(self, preorder, inorder): if not preorder or not inorder: return None rootValue = preorder[0] root = TreeNode(rootValue) inorderIndex = inorder.index(rootValue) root.left = self.buildTree(preorder[1:inorderIndex+1], inorder[:inorderIndex]) root.right = self.buildTree(preorder[inorderIndex+1:], inorder[inorderIndex+1:]) return root Solution 2 - Same as solution one, but pass index instead of doing list slicing (and thus reduce the memory usage) 1234567891011121314151617181920212223class Solution: # @param preorder, a list of integers # @param inorder, a list of integers # @return a tree node # 1:59 def buildTree(self, preorder, inorder, preorderStart = 0, preorderEnd = None, inorderStart = 0, inorderEnd = None): if preorderEnd is None: preorderEnd = len(preorder) - 1 if inorderEnd is None: inorderEnd = len(inorder) - 1 if preorderStart &gt; len(preorder) - 1 or inorderStart &gt; inorderEnd: return None rootValue = preorder[preorderStart] root = TreeNode(rootValue) inorderIndex = inorder.index(rootValue) root.left = self.buildTree(preorder, inorder, preorderStart+1, inorderIndex, inorderStart, inorderIndex-1) root.right = self.buildTree(preorder, inorder, preorderStart+inorderIndex+1-inorderStart, preorderEnd, inorderIndex+1, inorderEnd) return root Solution 3 - Based on Solution 1, we don’t necessary need to slice the preorder array, when we are done with the left tree, the left half of the preorder array should already be empty 123456789101112131415161718192021222324# Definition for a binary tree node# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # @param preorder, a list of integers # @param inorder, a list of integers # @return a tree node # 1:59 def buildTree(self, preorder, inorder): if not preorder or not inorder: return None rootValue = preorder.pop(0) root = TreeNode(rootValue) inorderIndex = inorder.index(rootValue) root.left = self.buildTree(preorder, inorder[:inorderIndex]) root.right = self.buildTree(preorder, inorder[inorderIndex+1:]) return root java https://discuss.leetcode.com/topic/3695/my-accepted-java-solution My Accepted Java Solution Hi guys, this is my Java solution. I read this post, which is very helpful. The basic idea is here: Say we have 2 arrays, PRE and IN. Preorder traversing implies that PRE[0] is the root node. Then we can find this PRE[0] in IN, say it’s IN[5]. Now we know that IN[5] is root, so we know that IN[0] - IN[4] is on the left side, IN[6] to the end is on the right side. Recursively doing this on subarrays, we can build a tree out of it :) Hope this helps. 12345678910111213141516171819public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return helper(0, 0, inorder.length - 1, preorder, inorder);&#125;public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) &#123; if (preStart &gt; preorder.length - 1 || inStart &gt; inEnd) &#123; return null; &#125; TreeNode root = new TreeNode(preorder[preStart]); int inIndex = 0; // Index of current root in inorder for (int i = inStart; i &lt;= inEnd; i++) &#123; if (inorder[i] == root.val) &#123; inIndex = i; &#125; &#125; root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder); root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder); return root;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[104. Maximum Depth of Binary Tree]]></title>
    <url>%2Fp%2F22757163%2F</url>
    <content type="text"><![CDATA[51.2% https://leetcode.com/problems/maximum-depth-of-binary-tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 方法一： 深度优先遍历 My code of C++, Depth-first-search and Breadth-first-search Depth-first-search Only one line code. 1234int maxDepth(TreeNode *root)&#123; return root == NULL ? 0 : max(maxDepth(root -&gt; left), maxDepth(root -&gt; right)) + 1;&#125; 我的代码实现： 123456789101112131415/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; return root?max(maxDepth(root-&gt;left), maxDepth(root-&gt;right))+1:0; &#125;&#125;; 方法二： 广度优先搜索 使用一个队列，将root push进取，然后每次对队列的长度进行遍历，res++； Breadth-first-search Calculate the count of the last level. 注意：栈和队列，又都push pop,没有push_back,pop_back 12345678910111213141516171819202122232425int maxDepth(TreeNode *root)&#123; if(root == NULL) return 0; int res = 0; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty()) &#123; ++ res; for(int i = 0, n = q.size(); i &lt; n; ++ i) &#123; TreeNode *p = q.front(); q.pop(); if(p -&gt; left != NULL) q.push(p -&gt; left); if(p -&gt; right != NULL) q.push(p -&gt; right); &#125; &#125; return res;&#125; 我的代码实现： 其实就是层序遍历 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(root==NULL) return 0; queue&lt;TreeNode*&gt; que; que.push(root); int res = 0; while(!que.empty())&#123; res++; int n = que.size(); for(int i=0; i&lt;n; i++)&#123; TreeNode* cur = que.front(); que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); &#125; &#125; return res; &#125;&#125;; 学习一下queue的成员函数，有back，push，pop，没有push_back (constructor) Construct queue (public member function ) empty Test whether container is empty (public member function ) size Return size (public member function ) front Access next element (public member function ) back Access last element (public member function ) push Insert element (public member function ) emplace Construct and insert element (public member function ) pop Remove next element (public member function ) swap Swap contents (public member function ) 学习一下栈的成员函数，有pop push 等，没有push_back pop_back (constructor)Construct stack (public member function )emptyTest whether container is empty (public member function )sizeReturn size (public member function )topAccess next element (public member function )pushInsert element (public member function )emplaceConstruct and insert element (public member function )popRemove top element (public member function )swapSwap contents (public member function ) https://discuss.leetcode.com/topic/10317/my-code-of-c-depth-first-search-and-breadth-first-search My code of C++, Depth-first-search and Breadth-first-search Depth-first-search Only one line code. 1234int maxDepth(TreeNode *root)&#123; return root == NULL ? 0 : max(maxDepth(root -&gt; left), maxDepth(root -&gt; right)) + 1;&#125; Breadth-first-search Calculate the count of the last level. 12345678910111213141516171819202122232425int maxDepth(TreeNode *root)&#123; if(root == NULL) return 0; int res = 0; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty()) &#123; ++ res; for(int i = 0, n = q.size(); i &lt; n; ++ i) &#123; TreeNode *p = q.front(); q.pop(); if(p -&gt; left != NULL) q.push(p -&gt; left); if(p -&gt; right != NULL) q.push(p -&gt; right); &#125; &#125; return res;&#125; python https://discuss.leetcode.com/topic/24177/1-line-ruby-and-python 1 line Ruby and Python Just a bit shorter/different than previous solutions. Python: 12def maxDepth(self, root): return 1 + max(map(self.maxDepth, (root.left, root.right))) if root else 0 java https://discuss.leetcode.com/topic/4087/simple-solution-using-java Simple solution using Java if the node does not exist, simply return 0. Otherwise, return the 1+the longer distance of its subtree. 123456public int maxDepth(TreeNode root) &#123; if(root==null)&#123; return 0; &#125; return 1+Math.max(maxDepth(root.left),maxDepth(root.right)); &#125; https://discuss.leetcode.com/topic/27017/clean-java-iterative-solution Clean Java Iterative Solution I do believe if you can think of an iterative solution, it’s always better than using a recursive one. And technical y every recursive solution can be converted into a equivalent iterative one. 123456789101112131415161718192021222324public int maxDepth(TreeNode root) &#123; if (root == null) return 0; Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;(); stack.push(root); int count = 0; while (!stack.isEmpty()) &#123; int size = stack.size(); while (size-- &gt; 0) &#123; TreeNode cur = stack.pop(); if (cur.left != null) stack.addLast(cur.left); if (cur.right != null) stack.addLast(cur.right); &#125; count++; &#125; return count;&#125; https://discuss.leetcode.com/topic/33826/two-java-iterative-solution-dfs-and-bfs Two Java Iterative solution DFS and BFS This is the iterative version of finding the depth. The recursive version is trivial, so expect the interviewer to ask for the iterative version. I used two stacks for the dfs one and a queue for the level-order traversal one. Level order one is faster. DFS 1234567891011121314151617181920212223242526public int maxDepth(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; value = new Stack&lt;&gt;(); stack.push(root); value.push(1); int max = 0; while(!stack.isEmpty()) &#123; TreeNode node = stack.pop(); int temp = value.pop(); max = Math.max(temp, max); if(node.left != null) &#123; stack.push(node.left); value.push(temp+1); &#125; if(node.right != null) &#123; stack.push(node.right); value.push(temp+1); &#125; &#125; return max;&#125;// 7ms BFS 1234567891011121314151617181920212223public int maxDepth(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int count = 0; while(!queue.isEmpty()) &#123; int size = queue.size(); while(size-- &gt; 0) &#123; TreeNode node = queue.poll(); if(node.left != null) &#123; queue.offer(node.left); &#125; if(node.right != null) &#123; queue.offer(node.right); &#125; &#125; count++; &#125; return count;&#125;// 3ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[103. Binary Tree Zigzag Level Order Traversal]]></title>
    <url>%2Fp%2Fa0a3d7c5%2F</url>
    <content type="text"><![CDATA[34.8% https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/ Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). 12345678910111213For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its zigzag level order traversal as:[ [3], [20,9], [15,7]] 方法一： 层序遍历，然后把相应的反转就可以了 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; q; // 首选把root压进去，不要忘了 q.push(root); while(q.size())&#123; int n = q.size(); vector&lt;int&gt; tmp; for(int i=0; i&lt;n; i++)&#123; // queue叫front，stack叫top，不要弄混了 TreeNode* cur = q.front(); q.pop(); tmp.push_back(cur-&gt;val); if(cur-&gt;left) q.push(cur-&gt;left); if(cur-&gt;right) q.push(cur-&gt;right); &#125; // 遍历一圈后，把结果压入 res.push_back(tmp); &#125; for(int i=0; i&lt;res.size(); i++) if(i%2) reverse(res[i].begin(), res[i].end()); return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>stack</tag>
        <tag>tree</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[102. Binary Tree Level Order Traversal]]></title>
    <url>%2Fp%2Fbeb6650a%2F</url>
    <content type="text"><![CDATA[37.7% https://leetcode.com/problems/binary-tree-level-order-traversal/?tab=Description Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). 12345678910111213For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its level order traversal as:[ [3], [9,20], [15,7]] 二叉树层序遍历 对于二叉树的先序、中序、后续遍历，应该掌握的非常牢靠。对于层序遍历，掌握的应该如同先序、中序、后续遍历一样。 方法一： 先序遍历，同时传入树的深度，如果树到达新的深度，则ret里加入一个新的vector. 1234567891011121314151617vector&lt;vector&lt;int&gt;&gt; ret;void buildVector(TreeNode *root, int depth)&#123; if(root == NULL) return; if(ret.size() == depth) ret.push_back(vector&lt;int&gt;()); ret[depth].push_back(root-&gt;val); buildVector(root-&gt;left, depth + 1); buildVector(root-&gt;right, depth + 1);&#125;vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; buildVector(root, 0); return ret;&#125; 方法二： 使用一个函数来辅助 递归调用 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(root==NULL) return res; vector&lt;TreeNode*&gt; cur = &#123;root&#125;; helper(cur, res); return res; &#125; void helper(vector&lt;TreeNode*&gt; cur, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(cur.size()==0) return; vector&lt;int&gt; tmp; vector&lt;TreeNode*&gt; nex; for(auto root:cur)&#123; tmp.push_back(root-&gt;val); if(root-&gt;left !=NULL) nex.push_back(root-&gt;left); if(root-&gt;right!=NULL) nex.push_back(root-&gt;right); &#125; res.push_back(tmp); helper(nex, res); return; &#125;&#125;; 方法三： 使用队列，非递归，中间使用一个marker，NULL表示间隔。 注意队列里是push和pop，没有push_back和pop_back. 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt; &gt; result; if (!root) return result; queue&lt;TreeNode*&gt; q; q.push(root); q.push(NULL); vector&lt;int&gt; cur_vec; while(!q.empty()) &#123; TreeNode* t = q.front(); q.pop(); if (t==NULL) &#123; result.push_back(cur_vec); cur_vec.resize(0); if (q.size() &gt; 0) &#123; q.push(NULL); &#125; &#125; else &#123; cur_vec.push_back(t-&gt;val); if (t-&gt;left) q.push(t-&gt;left); if (t-&gt;right) q.push(t-&gt;right); &#125; &#125; return result; &#125;&#125;; 方法四： 使用队列，针对每一层，一个保存至一个vector中，同时更新queue 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty())&#123; int n = que.size(); vector&lt;int&gt; tmp; for(int i=0; i&lt;n; i++)&#123; TreeNode* cur = que.front(); que.pop(); tmp.push_back(cur-&gt;val); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); &#125; res.push_back(tmp); &#125; return res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/4894/one-of-c-solutions-preorder One of C++ solutions (preorder) 先序遍历，同时ret在函数外面 1234567891011121314151617vector&lt;vector&lt;int&gt;&gt; ret;void buildVector(TreeNode *root, int depth)&#123; if(root == NULL) return; if(ret.size() == depth) ret.push_back(vector&lt;int&gt;()); ret[depth].push_back(root-&gt;val); buildVector(root-&gt;left, depth + 1); buildVector(root-&gt;right, depth + 1);&#125;vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; buildVector(root, 0); return ret;&#125; https://discuss.leetcode.com/topic/10469/c-solution-using-only-one-queue-use-a-marker-null C++ solution using only one queue / use a marker NULL 使用队列 先入先出，明显要使用队列 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt; &gt; result; if (!root) return result; queue&lt;TreeNode*&gt; q; q.push(root); q.push(NULL); vector&lt;int&gt; cur_vec; while(!q.empty()) &#123; TreeNode* t = q.front(); q.pop(); if (t==NULL) &#123; result.push_back(cur_vec); cur_vec.resize(0); if (q.size() &gt; 0) &#123; q.push(NULL); &#125; &#125; else &#123; cur_vec.push_back(t-&gt;val); if (t-&gt;left) q.push(t-&gt;left); if (t-&gt;right) q.push(t-&gt;right); &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/16900/short-8ms-c-solution-with-queue Short 8ms C++ solution with queue 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; if (!root) &#123; return &#123;&#125;; &#125; vector&lt;int&gt; row; vector&lt;vector&lt;int&gt; &gt; result; queue&lt;TreeNode*&gt; q; q.push(root); int count = 1; while (!q.empty()) &#123; if (q.front()-&gt;left) &#123; q.push(q.front()-&gt;left); &#125; if (q.front()-&gt;right) &#123; q.push(q.front()-&gt;right); &#125; row.push_back(q.front()-&gt;val), q.pop(); if (--count == 0) &#123; result.emplace_back(row), row.clear(); count = q.size(); &#125; &#125; return result; &#125;&#125;; my code: 其一，是vector&lt;TeeNode*&gt; 而不是vector 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(root==NULL) return res; vector&lt;TreeNode*&gt; cur = &#123;root&#125;; helper(cur, res); return res; &#125; void helper(vector&lt;TreeNode*&gt; cur, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(cur.size()==0) return; vector&lt;int&gt; tmp; vector&lt;TreeNode*&gt; nex; for(auto root:cur)&#123; tmp.push_back(root-&gt;val); if(root-&gt;left !=NULL) nex.push_back(root-&gt;left); if(root-&gt;right!=NULL) nex.push_back(root-&gt;right); &#125; res.push_back(tmp); helper(nex, res); return; &#125;&#125;; python https://discuss.leetcode.com/topic/26402/5-6-lines-fast-python-solution-48-ms 5-6 lines fast python solution (48 ms) level is a list of the nodes in the current level. Keep appending a list of the values of these nodes to ans and then updating level with all the nodes in the next level (kids) until it reaches an empty level. Python’s list comprehension makes it easier to deal with many conditions in a concise manner. Solution 1, (6 lines) 1234567def levelOrder(self, root): ans, level = [], [root] while root and level: ans.append([node.val for node in level]) LRpair = [(node.left, node.right) for node in level] level = [leaf for LR in LRpair for leaf in LR if leaf] return ans Solution 2, (5 lines), same idea but use only one list comprehension in while loop to get the next level 123456def levelOrder(self, root): ans, level = [], [root] while root and level: ans.append([node.val for node in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return ans Solution 3 (10 lines), just an expansion of solution 1&amp;2 for better understanding. 1234567891011def levelOrder(self, root): if not root: return [] ans, level = [], [root] while level: ans.append([node.val for node in level]) temp = [] for node in level: temp.extend([node.left, node.right]) level = [leaf for leaf in temp if leaf] return ans 82ms, 5.83%, September 23, 2016 https://discuss.leetcode.com/topic/26402/5-6-lines-fast-python-solution-48-ms 123456789101112131415161718# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrder(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[List[int]] &quot;&quot;&quot; ans, level = [], [root] while root and level: ans.append([node.val for node in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return ans java https://discuss.leetcode.com/topic/7647/java-solution-with-a-queue-used Java solution with a queue used 123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList&lt;List&lt;Integer&gt;&gt;(); if(root == null) return wrapList; queue.offer(root); while(!queue.isEmpty())&#123; int levelNum = queue.size(); List&lt;Integer&gt; subList = new LinkedList&lt;Integer&gt;(); for(int i=0; i&lt;levelNum; i++) &#123; if(queue.peek().left != null) queue.offer(queue.peek().left); if(queue.peek().right != null) queue.offer(queue.peek().right); subList.add(queue.poll().val); &#125; wrapList.add(subList); &#125; return wrapList; &#125;&#125; https://discuss.leetcode.com/topic/7332/java-solution-using-dfs Java Solution using DFS Nothing special. Just wanna provide a different way from BFS. 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); levelHelper(res, root, 0); return res; &#125; public void levelHelper(List&lt;List&lt;Integer&gt;&gt; res, TreeNode root, int height) &#123; if (root == null) return; if (height &gt;= res.size()) &#123; res.add(new LinkedList&lt;Integer&gt;()); &#125; res.get(height).add(root.val); levelHelper(res, root.left, height+1); levelHelper(res, root.right, height+1); &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[101. Symmetric Tree]]></title>
    <url>%2Fp%2F1260a346%2F</url>
    <content type="text"><![CDATA[37.5% https://leetcode.com/problems/symmetric-tree/ Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). 1234567For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \ 3 4 4 3 123456But the following [1,2,2,null,3,null,3] is not: 1 / \ 2 2 \ \ 3 3 Note: Bonus points if you could solve it both recursively and iteratively. 方法一： 迭代 我的代码实现： 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; return helper(root, root); &#125; bool helper(TreeNode* left, TreeNode* right)&#123; if(!left &amp;&amp; !right) return true; if(!left || !right) return false; return left-&gt;val == right-&gt;val &amp;&amp; helper(left-&gt;left, right-&gt;right) &amp;&amp; helper(left-&gt;right, right-&gt;left); &#125;&#125;; 方法二： 4ms, 25.42%, July 14th, 2016 使用两个队列，一个先root，再左再右的层序，一个先root，再右再左的遍历。 https://discuss.leetcode.com/topic/4332/my-c-accepted-code-in-16ms-with-iteration-solution 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; TreeNode *left, *right; if(!root) return true; queue&lt;TreeNode*&gt; q1, q2; q1.push(root-&gt;left); q2.push(root-&gt;right); while(!q1.empty() &amp;&amp; !q2.empty())&#123; left = q1.front(); q1.pop(); right = q2.front(); q2.pop(); if(left == NULL &amp;&amp; right == NULL) continue; if(left == NULL || right == NULL) return false; if(left-&gt;val != right-&gt;val) return false; q1.push(left-&gt;left); q1.push(left-&gt;right); q2.push(right-&gt;right); q2.push(right-&gt;left); &#125; return true; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; queue&lt;TreeNode*&gt; q1, q2; TreeNode* left, *right; q1.push(root-&gt;left); q2.push(root-&gt;right); while(!q1.empty() &amp;&amp; !q2.empty())&#123; left = q1.front(); // 使用变量前要先定义，不要忘了 TreNode* right = q2.front(); q1.pop(); // 要在下面的判断前pop，不然就进入了死循环了。 q2.pop(); if(!left &amp;&amp; !right) continue; //注意： 此处不同于递归，不能直接return true; if(!left || !right || left-&gt;val != right-&gt;val) return false; q1.push(left-&gt;left); q1.push(left-&gt;right); q2.push(right-&gt;right); q2.push(right-&gt;left); &#125; return true; &#125;&#125;; 4ms, 25.42%, July 14th, 2016 https://discuss.leetcode.com/topic/9503/15-lines-of-c-solution-8-ms 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; return helper(root-&gt;left, root-&gt;right); &#125; bool helper(TreeNode* p, TreeNode* q)&#123; if(!p &amp;&amp; !q) return true; else if(!p || !q) return false; if(p-&gt;val != q-&gt;val) return false; return helper(p-&gt;left, q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left); &#125;&#125;; python 64ms, 31.10%, July 14th, 2016 https://discuss.leetcode.com/topic/8440/6line-ac-python 12345678910111213141516171819# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; def isSym(L, R): if not L and not R: return True if L and R and L.val == R.val: return isSym(L.left, R.right) and isSym(L.right, R.left) return False return isSym(root, root) my code 12345678910111213141516class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if not root: return True return self.helper(root.left, root.right) def helper(self, left, right): if not left and not right: return True if left and right: return left.val==right.val and self.helper(left.left, right.right) and self.helper(left.right, right.left) return False java 1ms, 25.80%, July 14th, 2016 https://discuss.leetcode.com/topic/28589/1ms-recursive-java-solution-easy-to-understand 123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root == null) return true; return isMirror(root.left, root.right); &#125; public boolean isMirror(TreeNode p, TreeNode q)&#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; return (p.val == q.val) &amp;&amp; isMirror(p.left, q.right) &amp;&amp; isMirror(p.right, q.left); &#125;&#125; 3ms, 5.59%, July 14th, 2016 Recursive and non-recursive solutions in Java https://discuss.leetcode.com/topic/5941/recursive-and-non-recursive-solutions-in-java Recursive–400ms: 1234567891011public boolean isSymmetric(TreeNode root) &#123; return root==null || isSymmetricHelp(root.left, root.right);&#125;private boolean isSymmetricHelp(TreeNode left, TreeNode right)&#123; if(left==null || right==null) return left==right; if(left.val!=right.val) return false; return isSymmetricHelp(left.left, right.right) &amp;&amp; isSymmetricHelp(left.right, right.left);&#125; Non-recursive(use Stack)–460ms: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root==null) return true; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode left, right; if(root.left!=null)&#123; if(root.right==null) return false; stack.push(root.left); stack.push(root.right); &#125; else if(root.right!=null)&#123; return false; &#125; while(!stack.empty())&#123; if(stack.size()%2!=0) return false; right = stack.pop(); left = stack.pop(); if(right.val!=left.val) return false; if(left.left!=null)&#123; if(right.right==null) return false; stack.push(left.left); stack.push(right.right); &#125; else if(right.right!=null)&#123; return false; &#125; if(left.right!=null)&#123; if(right.left==null) return false; stack.push(left.right); stack.push(right.left); &#125; else if(right.left!=null)&#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100. Same Tree]]></title>
    <url>%2Fp%2F7dcacf8f%2F</url>
    <content type="text"><![CDATA[45.6% https://leetcode.com/problems/same-tree/ Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 方法一： https://discuss.leetcode.com/topic/5972/here-s-a-c-recursion-solution-in-minimal-lines-of-code 123456789101112131415161718//// Algorithm for the recursion:// 1)// If one of the node is NULL then return the equality result of p an q.// This boils down to if both are NULL then return true, // but if one of them is NULL but not the other one then return false// 2)// At this point both root nodes represent valid pointers.// Return true if the root nodes have same value and // the left tree of the roots are same (recursion)// and the right tree of the roots are same (recursion). // Otherwise return false. //bool isSameTree(TreeNode *p, TreeNode *q) &#123; if (p == NULL || q == NULL) return (p == q); return (p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right));&#125; 我的代码实现： 1234567class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if(p==NULL &amp;&amp; q==NULL) return true; return p!=NULL &amp;&amp; q!=NULL &amp;&amp; p-&gt;val==q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125;&#125;; 方法二： 1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if(!p &amp;&amp; !q) return true; if(!p || !q) return false; return p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125;&#125;; python https://discuss.leetcode.com/topic/14561/shortest-simplest-python The “proper” way: 1234def isSameTree(self, p, q): if p and q: return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) return p is q The “tupleify” way: 1234def isSameTree(self, p, q): def t(n): return n and (n.val, t(n.left), t(n.right)) return t(p) == t(q) The first way as one-liner: 12def isSameTree(self, p, q): return p and q and p.val == q.val and all(map(self.isSameTree, (p.left, p.right), (q.left, q.right))) or p is q https://discuss.leetcode.com/topic/18353/python-recursive-solution-and-dfs-iterative-solution-with-stack-and-bfs-iterative-solution-with-queue Python Recursive solution and DFS Iterative solution with stack and BFS Iterative solution with queue 12345678910111213141516171819202122232425262728293031323334353637def isSameTree1(self, p, q): if p and q: return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) else: return p == q# DFS with stack def isSameTree2(self, p, q): stack = [(p, q)] while stack: node1, node2 = stack.pop() if not node1 and not node2: continue elif None in [node1, node2]: return False else: if node1.val != node2.val: return False stack.append((node1.right, node2.right)) stack.append((node1.left, node2.left)) return True # BFS with queue def isSameTree3(self, p, q): queue = [(p, q)] while queue: node1, node2 = queue.pop(0) if not node1 and not node2: continue elif None in [node1, node2]: return False else: if node1.val != node2.val: return False queue.append((node1.left, node2.left)) queue.append((node1.right, node2.right)) return True my code 12345678910class Solution(object): def isSameTree(self, p, q): &quot;&quot;&quot; :type p: TreeNode :type q: TreeNode :rtype: bool &quot;&quot;&quot; if not p and not q: return True return p!=None and q!=None and (p.val==q.val) and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) 其中 p!=None and q!=None，这一段，如果换成p and q，则结果不是false，而是null。 java https://discuss.leetcode.com/topic/4737/five-line-java-solution-with-recursion 123456789101112131415161718/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; if(p.val == q.val) return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); return false; &#125;&#125; https://discuss.leetcode.com/topic/9739/2-lines-java-code 12345public class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) return true; return p != null &amp;&amp; q != null &amp;&amp; p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth fisrt search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[099. Recover Binary Search Tree]]></title>
    <url>%2Fp%2F3a244e25%2F</url>
    <content type="text"><![CDATA[29.0% https://leetcode.com/problems/recover-binary-search-tree/?tab=Description Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Note: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 方法一： 我的代码实现: 中序遍历，dfs 违反的，更新到first，如果first有值，更新到second。 中间second可能多次更新。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void recoverTree(TreeNode* root) &#123; TreeNode* first = nullptr, *second = nullptr; TreeNode* prev = nullptr; traverse(root, prev, first, second); swap(first-&gt;val, second-&gt;val); return; &#125; void traverse(TreeNode* root, TreeNode*&amp; prev, TreeNode*&amp; first, TreeNode*&amp; second)&#123; if(!root) return; traverse(root-&gt;left, prev, first, second); if(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val &amp;&amp; !first) first = prev; if(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val &amp;&amp; first) second = root; prev = root; // 不要忘记更新prev traverse(root-&gt;right, prev, first, second); return; &#125;&#125;; https://discuss.leetcode.com/topic/35013/recommend-for-beginners-clean-c-implementation-with-detailed-explaination [recommend for beginners]clean C++ implementation with detailed explaination Just use the “first” and “second” pointer to find the 2 nodes that violate the order. Then change the value of the first node ad the second node by their value. 12345678910111213141516171819class Solution &#123; TreeNode* first=NULL; TreeNode* second=NULL; TreeNode* prev = new TreeNode(INT_MIN);public: void recoverTree(TreeNode* root) &#123; help(root); swp(first-&gt;val, second-&gt;val); &#125; void help(TreeNode* root)&#123; if(root==NULL) return; help(root-&gt;left); if(first==NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val) first=prev; if(first!=NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val) second=root; prev=root; help(root-&gt;right); &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; TreeNode* first = NULL; TreeNode* second = NULL; TreeNode* prev = new TreeNode(INT_MIN);public: void recoverTree(TreeNode* root) &#123; helper(root); // 注意交换的是first-&gt;val，second-&gt;val swap(first-&gt;val, second-&gt;val); &#125; void helper(TreeNode* root)&#123; if(!root) return; helper(root-&gt;left); if(first==NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val) first=prev; if(first!=NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val) second=root; prev = root; helper(root-&gt;right); &#125;&#125;; 关于算法的解释： https://discuss.leetcode.com/topic/3988/no-fancy-algorithm-just-simple-and-powerful-in-order-traversal No Fancy Algorithm, just Simple and Powerful In-Order Traversal This question appeared difficult to me but it is really just a simple in-order traversal! I got really frustrated when other people are showing off Morris Traversal which is totally not necessary here. Let’s start by writing the in order traversal: 1234567private void traverse (TreeNode root) &#123; if (root == null) return; traverse(root.left); // Do some business traverse(root.right);&#125; So when we need to print the node values in order, we insert System.out.println(root.val) in the place of “Do some business”. What is the business we are doing here?We need to find the first and second elements that are not in order right? How do we find these two elements? For example, we have the following tree that is printed as in order traversal: 6, 3, 4, 5, 2 We compare each node with its next one and we can find out that 6 is the first element to swap because 6 &gt; 3 and 2 is the second element to swap because 2 &lt; 5. Really, what we are comparing is the current node and its previous node in the “in order traversal”. Let us define three variables, firstElement, secondElement, and prevElement. Now we just need to build the “do some business” logic as finding the two elements. See the code below: 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; TreeNode firstElement = null; TreeNode secondElement = null; // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized TreeNode prevElement = new TreeNode(Integer.MIN_VALUE); public void recoverTree(TreeNode root) &#123; // In order traversal to find the two elements traverse(root); // Swap the values of the two nodes int temp = firstElement.val; firstElement.val = secondElement.val; secondElement.val = temp; &#125; private void traverse(TreeNode root) &#123; if (root == null) return; traverse(root.left); // Start of &quot;do some business&quot;, // If first element has not been found, assign it to prevElement (refer to 6 in the example above) if (firstElement == null &amp;&amp; prevElement.val &gt;= root.val) &#123; firstElement = prevElement; &#125; // If first element is found, assign the second element to the root (refer to 2 in the example above) if (firstElement != null &amp;&amp; prevElement.val &gt;= root.val) &#123; secondElement = root; &#125; prevElement = root; // End of &quot;do some business&quot; traverse(root.right);&#125; And we are done, it is just that easy! https://discuss.leetcode.com/topic/19771/real-o-1-space-no-recursion-no-stack-etc-o-n-time-solution-48ms-c REAL O(1) Space (No recursion/No stack, etc) O(n) Time solution. 48ms C++ Someone complained that a recursion solution isn’t really a O(1) space solution. Ok, here comes the real O(1) solution. No recursion, no stack. Pure Morris traversal. 48 ms, C++ : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; TreeNode * wrong_node0 = nullptr, * wrong_node1 = nullptr, * prev = nullptr; void verify(TreeNode * cur) &#123; if (prev != nullptr &amp;&amp; prev -&gt; val &gt; cur -&gt; val) &#123; if (wrong_node0 == nullptr) &#123; wrong_node0 = prev; wrong_node1 = cur; // in case the tree has only 2 elements. &#125; else wrong_node1 = cur; &#125; prev = cur; &#125; void morrisInorder(TreeNode * root) &#123; TreeNode * cur = root; while (cur) &#123; if (cur-&gt;left == nullptr) &#123; verify(cur); cur = cur-&gt;right; continue; &#125; TreeNode * pred = cur-&gt;left; while (pred -&gt; right != nullptr &amp;&amp; pred -&gt; right != cur) pred = pred -&gt; right; //finding predecessor if (pred -&gt; right == nullptr) &#123; pred -&gt; right = cur; cur = cur -&gt; left; &#125;else &#123;//pred -&gt; right == cur; pred -&gt; right = nullptr; verify(cur); cur = cur -&gt; right; &#125; &#125; &#125; public: void recoverTree(TreeNode* root) &#123; morrisInorder(root); swap(wrong_node0-&gt;val, wrong_node1-&gt;val); &#125; &#125;; python https://discuss.leetcode.com/topic/16600/tree-deserializer-and-visualizer-for-python Tree Deserializer and Visualizer for Python Wrote some tools for my own local testing. For example1deserialize(&apos;[1,2,3,null,null,4,null,null,5]&apos;) will turn that into a tree and return the root as explained in the FAQ. I also wrote a visualizer. Two examples: 1drawtree(deserialize(&apos;[1,2,3,null,null,4,null,null,5]&apos;)): 1drawtree(deserialize(&apos;[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]&apos;)): Here’s the code. If you save it as a Python script and run it, it should as a demo show the above two pictures in turtle windows (one after the other). And you can of course import it from other scripts and then it will only provide the class/functions and not show the demo. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def __repr__(self): return &apos;TreeNode(&#123;&#125;)&apos;.format(self.val) def deserialize(string): if string == &apos;&#123;&#125;&apos;: return None nodes = [None if val == &apos;null&apos; else TreeNode(int(val)) for val in string.strip(&apos;[]&#123;&#125;&apos;).split(&apos;,&apos;)] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return rootdef drawtree(root): def height(root): return 1 + max(height(root.left), height(root.right)) if root else -1 def jumpto(x, y): t.penup() t.goto(x, y) t.pendown() def draw(node, x, y, dx): if node: t.goto(x, y) jumpto(x, y-20) t.write(node.val, align=&apos;center&apos;, font=(&apos;Arial&apos;, 12, &apos;normal&apos;)) draw(node.left, x-dx, y-60, dx/2) jumpto(x, y-20) draw(node.right, x+dx, y-60, dx/2) import turtle t = turtle.Turtle() t.speed(0); turtle.delay(0) h = height(root) jumpto(0, 30*h) draw(root, 0, 30*h, 40*h) t.hideturtle() turtle.mainloop() if __name__ == &apos;__main__&apos;: drawtree(deserialize(&apos;[1,2,3,null,null,4,null,null,5]&apos;)) drawtree(deserialize(&apos;[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]&apos;)) java https://discuss.leetcode.com/topic/3988/no-fancy-algorithm-just-simple-and-powerful-in-order-traversal No Fancy Algorithm, just Simple and Powerful In-Order Traversal This question appeared difficult to me but it is really just a simple in-order traversal! I got really frustrated when other people are showing off Morris Traversal which is totally not necessary here. Let’s start by writing the in order traversal: 1234567private void traverse (TreeNode root) &#123; if (root == null) return; traverse(root.left); // Do some business traverse(root.right);&#125; So when we need to print the node values in order, we insert System.out.println(root.val) in the place of “Do some business”. What is the business we are doing here? We need to find the first and second elements that are not in order right? How do we find these two elements? For example, we have the following tree that is printed as in order traversal: 6, 3, 4, 5, 2 We compare each node with its next one and we can find out that 6 is the first element to swap because 6 &gt; 3 and 2 is the second element to swap because 2 &lt; 5. Really, what we are comparing is the current node and its previous node in the “in order traversal”. Let us define three variables, firstElement, secondElement, and prevElement. Now we just need to build the “do some business” logic as finding the two elements. See the code below: 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; TreeNode firstElement = null; TreeNode secondElement = null; // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized TreeNode prevElement = new TreeNode(Integer.MIN_VALUE); public void recoverTree(TreeNode root) &#123; // In order traversal to find the two elements traverse(root); // Swap the values of the two nodes int temp = firstElement.val; firstElement.val = secondElement.val; secondElement.val = temp; &#125; private void traverse(TreeNode root) &#123; if (root == null) return; traverse(root.left); // Start of &quot;do some business&quot;, // If first element has not been found, assign it to prevElement (refer to 6 in the example above) if (firstElement == null &amp;&amp; prevElement.val &gt;= root.val) &#123; firstElement = prevElement; &#125; // If first element is found, assign the second element to the root (refer to 2 in the example above) if (firstElement != null &amp;&amp; prevElement.val &gt;= root.val) &#123; secondElement = root; &#125; prevElement = root; // End of &quot;do some business&quot; traverse(root.right);&#125; And we are done, it is just that easy! https://discuss.leetcode.com/topic/9305/detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer Detail Explain about How Morris Traversal Finds two Incorrect Pointer To understand this, you need to first understand Morris Traversal or Morris Threading Traversal.It take use of leaf nodes’ right/left pointer to achieve O(1) space Traversal on a Binary Tree.Below is a standard Inorder Morris Traversal, referred from http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html (a Chinese Blog, while the graphs are great for illustration) 123456789101112131415161718192021222324public void morrisTraversal(TreeNode root)&#123; TreeNode temp = null; while(root!=null)&#123; if(root.left!=null)&#123; // connect threading for root temp = root.left; while(temp.right!=null &amp;&amp; temp.right != root) temp = temp.right; // the threading already exists if(temp.right!=null)&#123; temp.right = null; System.out.println(root.val); root = root.right; &#125;else&#123; // construct the threading temp.right = root; root = root.left; &#125; &#125;else&#123; System.out.println(root.val); root = root.right; &#125; &#125; &#125; In the above code, System.out.println(root.val);appear twice, which functions as outputing the Node in ascending order (BST). Since these places are in order, replace them with 12345if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123; if(first==null)&#123;first = pre;second = root;&#125; else&#123;second = root;&#125; &#125;pre = root; each time, the pre node and root are in order as System.out.println(root.val); outputs them in order. Then, come to how to specify the first wrong node and second wrong node. When they are not consecutive, the first time we meet pre.val &gt; root.val ensure us the first node is the pre node, since root should be traversal ahead of pre, pre should be at least at small as root. The second time we meet pre.val &gt; root.val ensure us the second node is the root node, since we are now looking for a node to replace with out first node, which is found before. When they are consecutive, which means the case pre.val &gt; cur.val will appear only once. We need to take case this case without destroy the previous analysis. So the first node will still be pre, and the second will be just set to root. Once we meet this case again, the first node will not be affected. Below is the updated version on Morris Traversal. 123456789101112131415161718192021222324252627282930313233343536373839404142public void recoverTree(TreeNode root) &#123; TreeNode pre = null; TreeNode first = null, second = null; // Morris Traversal TreeNode temp = null; while(root!=null)&#123; if(root.left!=null)&#123; // connect threading for root temp = root.left; while(temp.right!=null &amp;&amp; temp.right != root) temp = temp.right; // the threading already exists if(temp.right!=null)&#123; if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123; if(first==null)&#123;first = pre;second = root;&#125; else&#123;second = root;&#125; &#125; pre = root; temp.right = null; root = root.right; &#125;else&#123; // construct the threading temp.right = root; root = root.left; &#125; &#125;else&#123; if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123; if(first==null)&#123;first = pre;second = root;&#125; else&#123;second = root;&#125; &#125; pre = root; root = root.right; &#125; &#125; // swap two node values; if(first!= null &amp;&amp; second != null)&#123; int t = first.val; first.val = second.val; second.val = t; &#125; &#125; https://discuss.leetcode.com/topic/29161/share-my-solutions-and-detailed-explanation-with-recursive-iterative-in-order-traversal-and-morris-traversal Share my solutions and detailed explanation with recursive/iterative in-order-traversal and Morris-traversal In-order traversal is really useful in BST. Following in-order traversal, we should have following order: prev.val &lt; curr.val. If not, then we found at least one incorrectly placed node So the basic idea is to visit the tree with in-order traversal and search for two swapped nodes. Then swap them back. Now the problem is if we found an incorrect pair where prev.val &gt; curr.val, how do we know which node is the incorrect one? The answer is it depends on whether we have found incorrect node before. So What is that? Since we get two elements that are swapped by mistake, there must be a smaller TreeNode get a larger value and a larger TreeNode get a smaller value. Their value are swapped, but the incorrect smaller node is still in smaller tree and incorrect larger node is still in larger tree. So we will visit the incorrect smaller node first, and this node will be detected when we compare its value with next.val, i.e. when it is treated as prev node. The incorrect larger node will be detected when we compare its value with prev.val. We don’t know if it is close or not close to incorrect smaller node, so we should continue search BST and update it if we found another incorrect node. Therefore if it is the first time we found an incorrect pair, the prev node must be the first incorrect node.If it is not the first time we found an incorrect pair, the curr node must be the second incorrect node, thoughwe may have corner case that two incorrect nodes are in same pair. Recursive in-order traversal based on above idea: public void recoverTree(TreeNode root) { 12345678910111213141516171819202122232425262728293031323334//use inorder traversal to detect incorrect node inOrder(root); int temp = first.val; first.val = second.val; second.val = temp;&#125;TreeNode prev = null;TreeNode first = null;TreeNode second = null;public void inOrder(TreeNode root)&#123; if(root == null) return; //search left tree inOrder(root.left); //in inorder traversal of BST, prev should always have smaller value than current value if(prev != null &amp;&amp; prev.val &gt;= root.val)&#123; //incorrect smaller node is always found as prev node if(first == null) first = prev; //incorrect larger node is always found as curr(root) node second = root; &#125; //update prev node prev = root; //search right tree inOrder(root.right);&#125; iterative in-order traversal based on above idea: 12345678910111213141516171819202122232425262728293031323334353637public void recoverTree(TreeNode root) &#123; TreeNode first = null; TreeNode second = null; TreeNode curr = root; TreeNode prev = null; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while(!stack.isEmpty() || curr != null)&#123; if(curr != null)&#123; //visit curr&apos;s left subtree stack.push(curr); curr = curr.left; &#125;else&#123; //done left subtree of curr Node curr = stack.pop(); //compare curr.val with prev.val if we have one if(prev != null &amp;&amp; curr.val &lt;= prev.val)&#123; //incorrect smaller node is always found as prev node if(first == null) first = prev; //incorrect larger node is always found as curr node second = curr; &#125; //visit curr&apos;s right subtree prev = curr; curr = curr.right; &#125; &#125; //recover swapped nodes int temp = first.val; first.val = second.val; second.val = temp;&#125; Both recursive and iterative will occupy O(n) space in worst case, in which the tree is like a LinkedList To reduce the space to constant space, we have to use Morris-traversal. Morris-traversal is similar to recursive/iterative traversal, but we need to modify the tree structure during thetraversal. before we visiting the left tree of a root, we will build a back-edge between rightmost node in left tree and the root. So we can go back to the root node after we are done with the left tree. Then we locate the rightmost node in left subtree again, cut the back-edge, recover the tree structure and start visit right subtree. The detection of two incorrect TreeNodes is similar to iterative/recursive in-order traversal.We don’t use extra data structure here, so the space complexity is reduced to O(1) and the time complexity will be O(n) Morris-traversal based on above description: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void recoverTree(TreeNode root) &#123; //Morris-traversal TreeNode first = null; TreeNode second = null; TreeNode pred = null; //rightmost node in left tree TreeNode prev = null; TreeNode curr = root; while(curr != null)&#123; //for each node, we compare it with prev node as we did in in-order-traversal if(prev != null &amp;&amp; curr.val &lt;= prev.val)&#123; if(first == null) first = prev; second = curr; &#125; if(curr.left != null)&#123; //got left tree, then let&apos;s locate its rightmost node in left tree pred = curr.left; //we may have visited the left tree before, and connect the rightmost node with curr node (root node) while(pred.right != null &amp;&amp; pred.right != curr)&#123; pred = pred.right; &#125; if(pred.right == curr)&#123; //if this left tree has been visited before, then we are done with it //cut the connection with currNode and start visit curr&apos;s right tree pred.right = null; prev = curr; curr = curr.right; &#125;else&#123; //if this left tree has not been visited before, then we create a back edge from rightmost node // to curr node, so we can return to the start point after done the left tree pred.right = curr; curr = curr.left; &#125; &#125;else&#123; //no left tree, then just visit its right tree prev = curr; curr = curr.right; &#125; &#125; int temp = first.val; first.val = second.val; second.val = temp;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[098. Validate Binary Search Tree]]></title>
    <url>%2Fp%2F92064786%2F</url>
    <content type="text"><![CDATA[22.6% https://leetcode.com/problems/validate-binary-search-tree/?tab=Description Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. 12345Example 1: 2 / \ 1 3Binary tree [2,1,3], return true. 12345Example 2: 1 / \ 2 3Binary tree [1,2,3], return false. 方法一： 可以中序遍历，判断值是否由小到大。 先中序遍历，则遍历后必定满足是递增数组，否则不满足。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if(!root) return true; vector&lt;int&gt; v; inorder(root, v); int n = v.size(); for(int i=1; i&lt;n; i++) // 要求根大于左边，小于右边，所以是&lt;=，不是&lt; if(v[i]&lt;=v[i-1]) return false; return true; &#125; void inorder(TreeNode* root, vector&lt;int&gt;&amp; v)&#123; if(root)&#123; inorder(root-&gt;left, v); v.push_back(root-&gt;val); inorder(root-&gt;right, v); &#125; &#125;&#125;; 方法二： 我的代码实现： O(n)时间和空间 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; return helper(root, nullptr, nullptr); &#125; bool helper(TreeNode* root, TreeNode* left, TreeNode* right)&#123; if(!root) return true; if(left &amp;&amp; left-&gt;val&gt;=root-&gt;val) return false; if(right &amp;&amp; right-&gt;val&lt;=root-&gt;val) return false; bool l = helper(root-&gt;left, left, root); bool r = helper(root-&gt;right, root, right); return l&amp;r; &#125;&#125;; 可以root值小于最大值，大于最小值，下一个节点要满足以上了两个条件，并且小于或大于根的值。 https://discuss.leetcode.com/topic/18573/c-simple-recursive-solution C++ simple recursive solution 下面这个方法巧妙之处是使用了节点，可以判断是否为NULL 递归方法，在递归中就能确定结果了。 代码中使用了NULL，而不是 INT_MAX ，INT_MIN，这是一个优点。 12345678910bool isValidBST(TreeNode* root) &#123; return isValidBST(root, NULL, NULL);&#125;bool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) &#123; if(!root) return true; if(minNode &amp;&amp; root-&gt;val &lt;= minNode-&gt;val || maxNode &amp;&amp; root-&gt;val &gt;= maxNode-&gt;val) return false; return isValidBST(root-&gt;left, minNode, root) &amp;&amp; isValidBST(root-&gt;right, root, maxNode);&#125; 我的代码实现： 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if(!root) return true; // 使用INT_MIN过不去，使用LONG_MIN就可以过去了 return helper(root, LONG_MIN, LONG_MAX); &#125; // 此处使用的是long类型 bool helper(TreeNode* root, long l, long r)&#123; if(!root) return true; if(root-&gt;val &lt;= l || root-&gt;val &gt;= r) return false; bool left = helper(root-&gt;left, l, root-&gt;val); bool right = helper(root-&gt;right, root-&gt;val, r); return left &amp;&amp; right; &#125;&#125;; 方法三： 我的代码实现： 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; TreeNode* prev = nullptr; return helper(root, prev); &#125; bool helper(TreeNode* root, TreeNode*&amp; prev)&#123; if(!root) return true; if(!helper(root-&gt;left, prev)) return false; if(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val) return false; prev = root; return helper(root-&gt;right, prev); &#125;&#125;; 判断当前节点与前一个节点 二叉搜索树中序遍历后是有序的，所以我们只需要判断中序遍历中，当前节点node和中序遍历的前一个节点prev的关系，全部满足才是BST，否则false。 1234567891011121314class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; TreeNode* prev = NULL; return validate(root, prev); &#125; bool validate(TreeNode* node, TreeNode* &amp;prev) &#123; if (node == NULL) return true; if (!validate(node-&gt;left, prev)) return false; if (prev != NULL &amp;&amp; prev-&gt;val &gt;= node-&gt;val) return false; prev = node; return validate(node-&gt;right, prev); &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; TreeNode* prev = NULL; return helper(root, prev); &#125; // 引用在后面，说明prev首先是一个引用，然后指向tree指针的引用 bool helper(TreeNode* node, TreeNode* &amp; prev)&#123; if(!node) return true; if(!helper(node-&gt;left, prev)) return false; if(prev &amp;&amp; prev-&gt;val &gt;= node-&gt;val) return false; prev = node; return helper(node-&gt;right, prev); &#125;&#125;; If we use in-order traversal to serialize a binary search tree, we can get a list of values in ascending order. It can be proved with the definition of BST. And here I use the reference of TreeNode pointer prev as a global variable to mark the address of previous node in the list. “In-order Traversal”: https://en.wikipedia.org/wiki/Tree_traversal#In-order If you know what INT_MAX or INT_MIN is, then it is no excuse for your carelessness. python https://discuss.leetcode.com/topic/10455/python-version-based-on-inorder-traversal 136ms, 5.82%, September 23, 2016 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; output = [] self.inOrder(root, output) for i in range(1, len(output)): if output[i-1] &gt;= output[i]: return False return True def inOrder(self, root, output): if root is None: return self.inOrder(root.left, output) output.append(root.val) self.inOrder(root.right, output) java 注意，不仅仅要左侧值小于根，根小于右侧，其实下面所有左侧值都要小于根，右侧值都要大于根。 java 最小最大的值，Long.MIN_VALUE, Long.MAX_VALUE. https://discuss.leetcode.com/topic/7179/my-simple-java-solution-in-3-lines My simple Java solution in 3 lines 1234567891011public class Solution &#123; public boolean isValidBST(TreeNode root) &#123; return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE); &#125; public boolean isValidBST(TreeNode root, long minVal, long maxVal) &#123; if (root == null) return true; if (root.val &gt;= maxVal || root.val &lt;= minVal) return false; return isValidBST(root.left, minVal, root.val) &amp;&amp; isValidBST(root.right, root.val, maxVal); &#125;&#125; Basically what I am doing is recursively iterating over the tree while defining interval &lt;minVal, maxVal&gt; for each node which value must fit in.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[097. Interleaving String]]></title>
    <url>%2Fp%2Fa33cb2cc%2F</url>
    <content type="text"><![CDATA[24.1% https://leetcode.com/problems/interleaving-string/ Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. 1234567For example,Given:s1 = &quot;aabcc&quot;,s2 = &quot;dbbca&quot;,When s3 = &quot;aadbbcbcac&quot;, return true.When s3 = &quot;aadbbbaccc&quot;, return false. 本题是一道动态规划题目，建立一个s1.length * s2.length的动态规划数组。 方法一： 0ms, 89.51%, September 21, 2016 https://discuss.leetcode.com/topic/3532/my-dp-solution-in-c Here is some explanation: DP table represents if s3 is interleaving at (i+j)th position when s1 is at ith position, and s2 is at jth position. 0th position means empty string. So if both s1 and s2 is currently empty, s3 is empty too, and it is considered interleaving. If only s1 is empty, then if previous s2 position is interleaving and current s2 position char is equal to s3 current position char, it is considered interleaving. similar idea applies to when s2 is empty. when both s1 and s2 is not empty, then if we arrive i, j from i-1, j, then if i-1,j is already interleaving and i and current s3 position equal, it s interleaving. If we arrive i,j from i, j-1, then if i, j-1 is already interleaving and j and current s3 position equal. it is interleaving. 123456789101112131415161718192021class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if(s3.length()!=s1.length() + s2.length()) return false; bool table[s1.length()+1][s2.length()+1]; for(int i=0; i&lt;s1.length()+1; i++) for(int j=0; j&lt;s2.length()+1; j++)&#123; if(i==0&amp;&amp;j==0) table[i][j] = true; else if(i==0) table[i][j] = (table[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]); else if(j==0) table[i][j] = (table[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1]); else table[i][j] = (table[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1])||(table[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]); &#125; return table[s1.length()][s2.length()]; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if(s1.size()+s2.size()!=s3.size()) return false; // 等于还是不等于，要考虑清楚 int m = s1.size(), n = s2.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=1; i&lt;n+1; i++) dp[0][i] = dp[0][i-1] &amp;&amp; s3[i-1]==s2[i-1]; for(int i=1; i&lt;m+1; i++) dp[i][0] = dp[i-1][0] &amp;&amp; s3[i-1]==s1[i-1]; for(int i=1; i&lt;m+1; i++)&#123; for(int j=1; j&lt;n+1; j++)&#123; // 注意== 与 = 的区分 dp[i][j] = (dp[i-1][j] &amp;&amp; (s3[i+j-1]==s1[i-1])) || (dp[i][j-1] &amp;&amp; (s3[i+j-1]==s2[j-1])); &#125; &#125; return dp[m][n]; // (m=1)*(n+1)矩阵最后一位索引m，n而不是m+1，n+1 &#125;&#125;; 我的代码实现： 1234567891011121314151617class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; int m = s1.size(), n = s2.size(), l = s3.size(); if(m+n!=l) return false; vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=1; i&lt;=n; i++) dp[0][i] = dp[0][i-1] &amp;&amp; s2[i-1]==s3[i-1]; for(int i=1; i&lt;=m; i++) dp[i][0] = dp[i-1][0] &amp;&amp; s1[i-1]==s3[i-1]; for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) dp[i][j] = dp[i-1][j] &amp;&amp; s1[i-1]==s3[i+j-1] || dp[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]; return dp[m][n]; &#125;&#125;; https://discuss.leetcode.com/topic/6562/8ms-c-solution-using-bfs-with-explanation If we expand the two strings s1 and s2 into a chessboard, then this problem can be transferred into a path seeking problem from the top-left corner to the bottom-right corner. The key is, each cell (y, x) in the board corresponds to an interval between y-th character in s1 and x-th character in s2. And adjacent cells are connected with like a grid. A BFS can then be efficiently performed to find the path. Better to illustrate with an example here: 123456789101112131415Say s1 = &quot;aab&quot; and s2 = &quot;abc&quot;. s3 = &quot;aaabcb&quot;. Then the board looks likeo--a--o--b--o--c--o| | | |a a a a| | | |o--a--o--b--o--c--o| | | |a a a a| | | |o--a--o--b--o--c--o| | | |b b b b| | | |o--a--o--b--o--c--o 123456789101112131415Each &quot;o&quot; is a cell in the board. We start from the top-left corner, and try to move right or down. If the next char in s3 matches the edge connecting the next cell, then we&apos;re able to move. When we hit the bottom-right corner, this means s3 can be represented by interleaving s1 and s2. One possible path for this example is indicated with &quot;x&quot;es below:x--a--x--b--o--c--o| | | |a a a a| | | |o--a--x--b--o--c--o| | | |a a a a| | | |o--a--x--b--x--c--x| | | |b b b b| | | |o--a--o--b--o--c--x Note if we concatenate the chars on the edges we went along, it’s exactly s3. And we went through all the chars in s1 and s2, in order, exactly once. Therefore if we view this board as a graph, such path finding problem is trivial with BFS. I use an unordered_map to store the visited nodes, which makes the code look a bit complicated. But a vector should be enough to do the job. Although the worse case timeis also O(mn), typically it doesn’t require us to go through every node to find a path. Therefore it’s faster than regular DP than average. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct MyPoint &#123; int y, x; bool operator==(const MyPoint &amp;p) const &#123; return p.y == y &amp;&amp; p.x == x; &#125;&#125;;namespace std &#123; template &lt;&gt; struct hash&lt;MyPoint&gt; &#123; size_t operator () (const MyPoint &amp;f) const &#123; return (std::hash&lt;int&gt;()(f.x) &lt;&lt; 1) ^ std::hash&lt;int&gt;()(f.y); &#125; &#125;;&#125;class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if (s1.size() + s2.size() != s3.size()) return false; queue&lt;MyPoint&gt; q; unordered_set&lt;MyPoint&gt; visited; bool isSuccessful = false; int i = 0; q.push(MyPoint &#123; 0, 0 &#125;); q.push(MyPoint &#123; -1, -1 &#125;); while (!(1 == q.size() &amp;&amp; -1 == q.front().x)) &#123; auto p = q.front(); q.pop(); if (p.y == s1.size() &amp;&amp; p.x == s2.size()) &#123; return true; &#125; if (-1 == p.y) &#123; q.push(p); i++; continue; &#125; if (visited.find(p) != visited.end()) &#123; continue; &#125; visited.insert(p); if (p.y &lt; s1.size()) &#123; // down if (s1[p.y] == s3[i]) &#123; q.push(MyPoint &#123; p.y + 1, p.x &#125;); &#125; &#125; if (p.x &lt; s2.size()) &#123; // right if (s2[p.x] == s3[i]) &#123; q.push(MyPoint &#123; p.y, p.x + 1 &#125;); &#125; &#125; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/17059/my-dp-c-solution-is-only-10-lines-with-o-n-space My dp C++ solution is only 10 lines with O(n) space! 12345678910111213141516class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; int m = s1.size(), n = s2.size(); if(m+n != s3.size()) return false; bool c[n+1] = &#123;true&#125;; int i, j = 0; while(j &lt; n &amp;&amp; s2[j] == s3[j]) c[++j] = true; for(i = 0; i &lt; m; ++i) &#123; c[0] = c[0] &amp; (s1[i] == s3[i]); for(j = 1; j &lt;= n; ++j) c[j] = ((s1[i] == s3[i+j]) &amp; c[j]) | ((s2[j-1] == s3[i+j]) &amp; c[j-1]); &#125; return c[n]; &#125;&#125;; https://discuss.leetcode.com/topic/4695/c-sharing-my-recursive-tle-and-dp-solution-30ms-easy-to-understand [C++] Sharing my recursive (TLE) and DP solution (30ms) - easy to understand. First, I’m a big recursion person. Here’s my first attempt which is purely recursive. At an intermediate stage, we can either match one char from s1 to one char from s3 and advance one pointer at s1 and s3. Or we can do the same with s2 and s3. I’m open to suggestions to my recursive code. One improvement could come from not having to call the strcmp function? 123456789101112131415class Solution &#123;public: bool isInterleave(char* s1, char* s2, char* s3) &#123; if (*s1==&apos;\0&apos; &amp;&amp; *s2==&apos;\0&apos;) return *s3==&apos;\0&apos;? true : false; else if (*s1==&apos;\0&apos;)&#123; return strcmp(s2,s3)==0 ? true : false; &#125; else if (*s2==&apos;\0&apos;)&#123; return strcmp(s1,s3)==0 ? true : false; &#125; return (*s1==*s3 &amp;&amp; isInterleave(s1+1,s2,s3+1)) | (*s2==*s3 &amp;&amp; isInterleave(s1,s2+1,s3+1)); &#125;&#125;; Here’s the DP version (30ms) as well. Unsurprisingly the DP solution passed the judge and it’s pretty efficient. The logic straightforward if you understood the recursive version since there’s 1:1 correspondence between the two code. I think it’s elegant since it doesn’t have any ugly if, else if shenanigans. 12345678910111213141516171819202122232425class Solution &#123;public: bool isInterleave(string s1, string s2, string s3)&#123; int n1 = s1.length(), n2 = s2.length(), n3 = s3.length(); if (n1+n2 != n3) return false; vector&lt;vector&lt;bool&gt;&gt; V(n1+1, vector&lt;bool&gt;(n2+1, false)); V[n1][n2] = (s3[n1+n2]==&apos;\0&apos;); // fill bottom for (int j=n2-1; j&gt;=0; j--) V[n1][j] = (s2[j]==s3[n1+j] &amp;&amp; V[n1][j+1]); // fill right for (int i=n1-1; i&gt;=0; i--) V[i][n2] = (s1[i]==s3[n2+i] &amp;&amp; V[i+1][n2]); // fill DP table from bottom right for (int j=n2-1; j&gt;=0; j--)&#123; for (int i=n1-1; i&gt;=0; i--)&#123; V[i][j] = (s1[i]==s3[i+j] &amp;&amp; V[i+1][j]) | (s2[j]==s3[i+j] &amp;&amp; V[i][j+1]); &#125; &#125; return V[0][0]; &#125;&#125;; python 112ms, 4.93%, September 21, 2016 https://discuss.leetcode.com/topic/19900/python-dp-solutions-o-m-n-o-n-space-bfs-dfs 12345678910111213141516171819202122# O(m*n) spaceclass Solution(object): def isInterleave(self, s1, s2, s3): &quot;&quot;&quot; :type s1: str :type s2: str :type s3: str :rtype: bool &quot;&quot;&quot; r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False dp = [[True for _ in xrange(c+1)] for _ in xrange(r+1)] for i in xrange(1, r+1): dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1] for j in xrange(1, c+1): dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1] for i in xrange(1, r+1): for j in xrange(1, c+1): dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i-1+j]) or \ (dp[i][j-1] and s2[j-1] == s3[i-1+j]) return dp[-1][-1] 123456789101112131415# O(2*n) spacedef isInterleave2(self, s1, s2, s3): l1, l2, l3 = len(s1)+1, len(s2)+1, len(s3)+1 if l1+l2 != l3+1: return False pre = [True for _ in xrange(l2)] for j in xrange(1, l2): pre[j] = pre[j-1] and s2[j-1] == s3[j-1] for i in xrange(1, l1): cur = [pre[0] and s1[i-1] == s3[i-1]] * l2 for j in xrange(1, l2): cur[j] = (cur[j-1] and s2[j-1] == s3[i+j-1]) or \ (pre[j] and s1[i-1] == s3[i+j-1]) pre = cur[:] return pre[-1] 12345678910111213# O(n) spacedef isInterleave3(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False dp = [True for _ in xrange(c+1)] for j in xrange(1, c+1): dp[j] = dp[j-1] and s2[j-1] == s3[j-1] for i in xrange(1, r+1): dp[0] = (dp[0] and s1[i-1] == s3[i-1]) for j in xrange(1, c+1): dp[j] = (dp[j] and s1[i-1] == s3[i-1+j]) or (dp[j-1] and s2[j-1] == s3[i-1+j]) return dp[-1] 123456789101112131415# DFS def isInterleave4(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False stack, visited = [(0, 0)], set((0, 0)) while stack: x, y = stack.pop() if x+y == l: return True if x+1 &lt;= r and s1[x] == s3[x+y] and (x+1, y) not in visited: stack.append((x+1, y)); visited.add((x+1, y)) if y+1 &lt;= c and s2[y] == s3[x+y] and (x, y+1) not in visited: stack.append((x, y+1)); visited.add((x, y+1)) return False 123456789101112131415# BFS def isInterleave(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False queue, visited = [(0, 0)], set((0, 0)) while queue: x, y = queue.pop(0) if x+y == l: return True if x+1 &lt;= r and s1[x] == s3[x+y] and (x+1, y) not in visited: queue.append((x+1, y)); visited.add((x+1, y)) if y+1 &lt;= c and s2[y] == s3[x+y] and (x, y+1) not in visited: queue.append((x, y+1)); visited.add((x, y+1)) return False java 4ms, 68.74%, September 21, 2016 https://discuss.leetcode.com/topic/7728/dp-solution-in-java DP Solution in Java 123456789101112131415161718192021222324public class Solution &#123; public boolean isInterleave(String s1, String s2, String s3) &#123; if((s1.length()+s2.length()) !=s3.length()) return false; boolean[][] matrix = new boolean[s2.length()+1][s1.length()+1]; matrix[0][0] = true; for(int i = 1; i &lt; matrix[0].length; i++) matrix[0][i] = matrix[0][i-1] &amp;&amp; (s1.charAt(i-1) == s3.charAt(i-1)); for(int i=1; i&lt;matrix.length; i++) matrix[i][0] = matrix[i-1][0] &amp;&amp; (s2.charAt(i-1) == s3.charAt(i-1)); for(int i=1; i&lt;matrix.length; i++)&#123; for(int j=1; j&lt;matrix[0].length; j++)&#123; matrix[i][j] = (matrix[i-1][j] &amp;&amp; (s2.charAt(i-1)==s3.charAt(i+j-1))) || (matrix[i][j-1] &amp;&amp; (s1.charAt(j-1)==s3.charAt(i+j-1))); &#125; &#125; return matrix[s2.length()][s1.length()]; &#125;&#125; https://discuss.leetcode.com/topic/3436/my-accepted-java-recursive-solution-for-interleaving-string My Accepted Java Recursive Solution for interleaving string The private method isInterleave is the recursive method. it takes additional i1, i2, i3 as the start indexes of s1, s2, s3, so it solves the substring of s1, s2, s3 with those start indexes. The recursion starting condition is i1, i2, i3 are set to 0, means it solves the whole string. in each recursion, it will just check the first character in s3 with s2 and s1, if it equals s1, it will increase i3 and i1 to solve remain, if remain return true, this recursion will also return true. Same logic for s2. The end condition is when remain of either s1 or s2 is empty, then just compare remain of s3 with remain of s1 or s2, if they are equal, it will return true. A pure recursive solution will cause time limit exceed. We can optimize it by caching the false visited solutions in the visited set. That will short circuit many repeated search path. 12345678910111213141516171819202122232425262728public class Solution &#123; private static Set&lt;Integer&gt; visited; // The combination of i1, i2 has been visited and return false public static boolean isInterleave(String s1, String s2, String s3) &#123; if(s3.length() != s1.length() + s2.length()) return false; visited = new HashSet&lt;Integer&gt;(); return isInterleave(s1, 0, s2, 0, s3, 0); &#125; private static boolean isInterleave(String s1, int i1, String s2, int i2, String s3, int i3) &#123; int hash = i1 * s3.length() + i2; if(visited.contains(hash)) return false; if(i1 == s1.length()) return s2.substring(i2).equals(s3.substring(i3)); if(i2 == s2.length()) return s1.substring(i1).equals(s3.substring(i3)); if(s3.charAt(i3) == s1.charAt(i1) &amp;&amp; isInterleave(s1, i1+1, s2, i2, s3, i3+1) || s3.charAt(i3) == s2.charAt(i2) &amp;&amp; isInterleave(s1, i1, s2, i2+1, s3, i3+1)) return true; visited.add(hash); return false; &#125;&#125; https://discuss.leetcode.com/topic/31991/1ms-tiny-dfs-beats-94-57 To solve this problem, let’s look at if s1[0 ~ i] s2[0 ~ j] can be interleaved to s3[0 ~ k]. Start from indices0, 0, 0 and compare s1[i] == s3[k] or s2[j] == s3[k] Return valid only if either i or j match k and the remaining is also valid Caching is the key to performance. This is very similar to top down dp Only need to cache invalid[i][j] since most of the case s1[0 ~ i] and s2[0 ~ j] does not form s3[0 ~ k]. Also tested caching valid[i][j] the run time is also 1ms Many guys use substring but it’s duplicate code since substring itself is checking char by char. We are already doing so Hope it helps! 12345678910111213141516public boolean isInterleave(String s1, String s2, String s3) &#123; char[] c1 = s1.toCharArray(), c2 = s2.toCharArray(), c3 = s3.toCharArray(); int m = s1.length(), n = s2.length(); if(m + n != s3.length()) return false; return dfs(c1, c2, c3, 0, 0, 0, new boolean[m + 1][n + 1]);&#125;public boolean dfs(char[] c1, char[] c2, char[] c3, int i, int j, int k, boolean[][] invalid) &#123; if(invalid[i][j]) return false; if(k == c3.length) return true; boolean valid = i &lt; c1.length &amp;&amp; c1[i] == c3[k] &amp;&amp; dfs(c1, c2, c3, i + 1, j, k + 1, invalid) || j &lt; c2.length &amp;&amp; c2[j] == c3[k] &amp;&amp; dfs(c1, c2, c3, i, j + 1, k + 1, invalid); if(!valid) invalid[i][j] = true; return valid;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[096. Unique Binary Search Trees]]></title>
    <url>%2Fp%2Fd9eba394%2F</url>
    <content type="text"><![CDATA[40.1% https://leetcode.com/problems/unique-binary-search-trees/ Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? 12345678For example,Given n = 3, there are a total of 5 unique BST&apos;s. 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 方法一： 使用动态规划的方法，依次观察求解f(n)的个数，观察规律和公式。 https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there 0ms, September 9, 2016 https://discuss.leetcode.com/topic/17950/c-code-w-explanation C++ code w/ explanation 1234567891011121314class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; f; f.push_back(1); for (int i = 1; i &lt;= n; ++i) &#123; int t = 0; for (int j = 0; j &lt; i; ++j) t += f[j] * f[i-j-1]; f.push_back(t); &#125; return f.back(); &#125;&#125;; Consider f_i: choose 1 as the root, we have 0 node for the left tree, i-1 for the right; choose 2 as the root, we have 1 node for the left tree, i-2 for the right; … choose i as the root, we have i-1 nodes for the left tree, 0 for the right. Therefore, the recursive solution is f_i = \sum_{j=0}^{i-1} f_j f_{i-j-1} 我的代码实现： 12345678910111213class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; v(n+1, 0); v[0] = 1; v[1] = 1; for(int i=2; i&lt;=n; i++)&#123; for(int j=0; j&lt;=i; j++) v[i] += v[j] * v[i-j-1]; &#125; return v[n]; &#125;&#125;; 方法二： 使用直接计算公式，此处是 卡特兰数 https://discuss.leetcode.com/topic/5822/it-s-catalan-number http://en.wikipedia.org/wiki/Catalan_number 卡特兰数的另一个公式如下： https://discuss.leetcode.com/topic/5673/dp-problem-10-lines-with-comments Dp problem. 10+ lines with comments 123456789101112131415161718192021222324/** * Taking 1~n as root respectively: * 1 as root: # of trees = F(0) * F(n-1) // F(0) == 1 * 2 as root: # of trees = F(1) * F(n-2) * 3 as root: # of trees = F(2) * F(n-3) * ... * n-1 as root: # of trees = F(n-2) * F(1) * n as root: # of trees = F(n-1) * F(0) * * So, the formulation is: * F(n) = F(0) * F(n-1) + F(1) * F(n-2) + F(2) * F(n-3) + ... + F(n-2) * F(1) + F(n-1) * F(0) */int numTrees(int n) &#123; int dp[n+1]; dp[0] = dp[1] = 1; for (int i=2; i&lt;=n; i++) &#123; dp[i] = 0; for (int j=1; j&lt;=i; j++) &#123; dp[i] += dp[j-1] * dp[i-j]; &#125; &#125; return dp[n];&#125; https://discuss.leetcode.com/topic/13321/a-very-simple-and-straight-ans-based-on-math-catalan-number-o-n-times-o-1-space A very simple and straight ans based on Math,Catalan Number ,O(N) times,O(1)space 123456789int numTrees(int n) &#123; //cantalan树 //C(2n,n)/(n+1) long long ans =1; for(int i=n+1;i&lt;=2*n;i++)&#123; ans = ans*i/(i-n); &#125; return ans/(n+1);&#125; python 36ms, September 9, 2016 https://discuss.leetcode.com/topic/19670/python-solutions-dp-catalan-numbers Python solutions (DP + Catalan number) 12345678# DPdef numTrees1(self, n): res = [0] * (n+1) res[0] = 1 for i in xrange(1, n+1): for j in xrange(i): res[i] += res[j] * res[i-1-j] return res[n] 123# Catalan Number (2n)!/((n+1)!*n!) def numTrees(self, n): return math.factorial(2*n)/(math.factorial(n)*math.factorial(n+1)) java 0ms, September 9, 2016 https://discuss.leetcode.com/topic/8398/dp-solution-in-6-lines-with-explanation-f-i-n-g-i-1-g-n-i DP Solution in 6 lines with explanation. F(i, n) = G(i-1) * G(n-i) The problem can be solved in a dynamic programming way. I’ll explain the intuition and formulas in the following. Given a sequence 1…n, to construct a Binary Search Tree (BST) out of the sequence, we could enumerate each number i in the sequence, and use the number as the root, naturally, the subsequence 1…(i-1) on its left side would lay on the left branch of the root, and similarly the right subsequence (i+1)…n lay on the right branch of the root. We then can construct the subtree from the subsequence recursively. Through the above approach, we could ensure that the BST that we construct are all unique, since they have unique roots. The problem is to calculate the number of unique BST. To do so, we need to define two functions: G(n): the number of unique BST for a sequence of length n. F(i, n), 1 &lt;= i &lt;= n: the number of unique BST, where the number i is the root of BST, and the sequence ranges from 1 to n. As one can see, G(n) is the actual function we need to calculate in order to solve the problem. And G(n) can be derived from F(i, n), which at the end, would recursively refer to G(n). First of all, given the above definitions, we can see that the total number of unique BST G(n), is the sum of BST F(i) using each number i as a root.i.e. 1G(n) = F(1, n) + F(2, n) + ... + F(n, n). Particularly, the bottom cases, there is only one combination to construct a BST out of a sequence of length 1 (only a root) or 0 (empty tree).i.e. 1G(0)=1, G(1)=1. Given a sequence 1…n, we pick a number i out of the sequence as the root, then the number of unique BST with the specified root F(i), is the cartesian product of the number of BST for its left and right subtrees. For example, F(3, 7): the number of unique BST tree with number 3 as its root. To construct an unique BST out of the entire sequence [1, 2, 3, 4, 5, 6, 7] with 3 as the root, which is to say, we need to construct an unique BST out of its left subsequence [1, 2] and another BST out of the right subsequence [4, 5, 6, 7], and then combine them together (i.e. cartesian product). The tricky part is that we could consider the number of unique BST out of sequence [1,2] as G(2), and the number of of unique BST out of sequence [4, 5, 6, 7] as G(4). Therefore, F(3,7) = G(2) * G(4). i.e. 1F(i, n) = G(i-1) * G(n-i) 1 &lt;= i &lt;= n Combining the above two formulas, we obtain the recursive formula for G(n). i.e. 1G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0) In terms of calculation, we need to start with the lower number, since the value of G(n) depends on the values of G(0) … G(n-1). With the above explanation and formulas, here is the implementation in Java. 123456789101112public int numTrees(int n) &#123; int [] G = new int[n+1]; G[0] = G[1] = 1; for(int i=2; i&lt;=n; ++i) &#123; for(int j=1; j&lt;=i; ++j) &#123; G[i] += G[j-1] * G[i-j]; &#125; &#125; return G[n];&#125; c 0ms, September 9, 2016 https://discuss.leetcode.com/topic/5673/dp-problem-10-lines-with-comments 12345678910int numTrees(int n) &#123; int dp[n+1]; dp[0] = dp[1] = 1; for(int i=2; i&lt;=n; i++)&#123; dp[i] = 0; for(int j=1; j&lt;=i; j++) dp[i] += dp[j-1] * dp[i-j]; &#125; return dp[n];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[095. Unique Binary Search Trees II]]></title>
    <url>%2Fp%2F68405e1a%2F</url>
    <content type="text"><![CDATA[30.8% https://leetcode.com/problems/unique-binary-search-trees/?tab=Description Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? 12345678For example,Given n = 3, there are a total of 5 unique BST&apos;s. 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 方法一： 此题，与96题的区别在于，96题要求返回个数，此题要求返回所有结果。 使用递归的方法 https://discuss.leetcode.com/topic/9313/30-ms-c-solution 30 ms c++ solution 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;TreeNode *&gt; generateTrees(int n) &#123; if(n&lt;1) return vector&lt;TreeNode*&gt;(); return helper(1,n); &#125; vector&lt;TreeNode*&gt; helper(int s, int e) &#123; if (s &gt; e) &#123; return vector&lt;TreeNode*&gt;(1,NULL); &#125; vector&lt;TreeNode*&gt; result; for (int i=s; i &lt;= e; ++i) &#123; vector&lt;TreeNode*&gt; left, right; left = helper(s,i-1); right = helper(i+1,e); for (int j = 0; j &lt; left.size(); ++j) &#123; for (int k = 0; k &lt; right.size(); ++k) &#123; TreeNode* root = new TreeNode(i); root-&gt;left = left[j]; root-&gt;right = right[k]; result.push_back(root); &#125; &#125; &#125; return result; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if(n&lt;1) return vector&lt;TreeNode*&gt;(); // 对于复杂的问题，很多使用一个辅助函数，同时使用递归 return helper(1, n); &#125; // 注意区分ListNode TreeNode vector&lt;TreeNode*&gt; helper(int start, int end)&#123; if(end&lt;start) return vector&lt;TreeNode*&gt;(1, NULL); if(start==end)&#123; TreeNode* node = new TreeNode(start); vector&lt;TreeNode*&gt; res; res.push_back(node); return res; &#125; vector&lt;TreeNode*&gt; result; for(int i=start; i&lt;=end; i++)&#123; vector&lt;TreeNode*&gt; left = helper(start, i-1); vector&lt;TreeNode*&gt; right = helper(i+1, end); for(int j=0; j&lt;left.size(); j++)&#123; for(int k=0; k&lt;right.size(); k++)&#123; TreeNode* root = new TreeNode(i); root-&gt;left = left[j]; root-&gt;right = right[k]; result.push_back(root); &#125; &#125; &#125; return result; &#125;&#125;; cpp 19ms, 86.97%, September 23, 2016 https://discuss.leetcode.com/topic/6711/share-a-c-dp-solution-with-o-1-space Share a C++ DP solution with O(1) space The basic idea is that we can construct the result of n node tree just from the result of n-1 node tree.Here’s how we do it: only 2 conditions: 1) The nth node is the new root, so newroot-&gt;left = oldroot; 2) the nth node is not root, we traverse the old tree, every time the node in the old tree has a right child, we can perform: old node-&gt;right = nth node, nth node -&gt;left = right child; and when we reach the end of the tree, don’t forget we can also add the nth node here. One thing to notice is that every time we push a TreeNode in our result, I push the clone version of the root, and I recover what I do to the old node immediately. This is because you may use the old tree for several times. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public: TreeNode* clone(TreeNode* root)&#123; if(root == nullptr) return nullptr; TreeNode* newroot = new TreeNode(root-&gt;val); newroot-&gt;left = clone(root-&gt;left); newroot-&gt;right = clone(root-&gt;right); return newroot; &#125; vector&lt;TreeNode *&gt; generateTrees(int n) &#123; vector&lt;TreeNode *&gt; res(1,nullptr); for(int i = 1; i &lt;= n; i++)&#123; vector&lt;TreeNode *&gt; tmp; for(int j = 0; j&lt;res.size();j++)&#123; TreeNode* oldroot = res[j]; TreeNode* root = new TreeNode(i); TreeNode* target = clone(oldroot); root-&gt;left = target; tmp.push_back(root); if(oldroot!=nullptr)&#123; TreeNode* tmpold = oldroot; while(tmpold-&gt;right!=nullptr)&#123; TreeNode* nonroot = new TreeNode(i); TreeNode *tright = tmpold-&gt;right; tmpold-&gt;right = nonroot; nonroot-&gt;left = tright; TreeNode *target = clone(oldroot); tmp.push_back(target); tmpold-&gt;right = tright; tmpold = tmpold-&gt;right; &#125; tmpold-&gt;right = new TreeNode(i); TreeNode *target = clone(oldroot); tmp.push_back(target); tmpold-&gt;right = nullptr; &#125; &#125; res=tmp; &#125; return res; &#125; &#125;; https://discuss.leetcode.com/topic/4795/my-accepted-c-solution-recursive-less-than-30-lines My Accepted C++ solution (recursive, less than 30 lines) explaination: Given a tree which n nodes, it has the follwing form: (0)root(n-1) (1)root(n-2) (2)root(n-3) where (x) denotes the trees with x nodes. Now take n=3 for example. Given n=3, we have [1 2 3] in which each of them can be used as the tree root. when root=1: [1 # 2 # 3]; [1 # 3 2]; when root=2: [2 1 3]; when root=3: (similar with the situations when root=1.) Thus, if we write a recursive function who generates a group of trees in which the numbers range from f to t, we have to generate the left trees and right trees of each tree in the vector. I give the following recursive code and expect to see non-recursive ones. please! code: 123456789101112131415161718192021222324252627282930vector&lt;TreeNode *&gt; generateTree(int from, int to)&#123; vector&lt;TreeNode *&gt; ret; if(to - from &lt; 0) ret.push_back(0); if(to - from == 0) ret.push_back(new TreeNode(from)); if(to - from &gt; 0) &#123; for(int i=from; i&lt;=to; i++) &#123; vector&lt;TreeNode *&gt; l = generateTree(from, i-1); vector&lt;TreeNode *&gt; r = generateTree(i+1, to); for(int j=0; j&lt;l.size(); j++) &#123; for(int k=0; k&lt;r.size(); k++) &#123; TreeNode * h = new TreeNode (i); h-&gt;left = l[j]; h-&gt;right = r[k]; ret.push_back(h); &#125; &#125; &#125; &#125; return ret;&#125;vector&lt;TreeNode *&gt; generateTrees(int n) &#123; return generateTree(1, n);&#125; python https://discuss.leetcode.com/topic/15886/should-be-6-liner Should-be-6-Liner If only LeetCode had a TreeNode(val, left, right) constructor… sigh. Then I wouldn’t need to provide my own and my solution would be six lines instead of eleven. 123456789101112def generateTrees(self, n): def node(val, left, right): node = TreeNode(val) node.left = left node.right = right return node def trees(first, last): return [node(root, left, right) for root in range(first, last+1) for left in trees(first, root-1) for right in trees(root+1, last)] or [None] return trees(1, n) Or even just four lines, if it’s not forbidden to add an optional argument: 123456789101112def node(val, left, right): node = TreeNode(val) node.left = left node.right = right return nodeclass Solution: def generateTrees(self, last, first=1): return [node(root, left, right) for root in range(first, last+1) for left in self.generateTrees(root-1, first) for right in self.generateTrees(last, root+1)] or [None] Just another version, using loops instead of list comprehension: 123456789101112def generateTrees(self, n): def generate(first, last): trees = [] for root in range(first, last+1): for left in generate(first, root-1): for right in generate(root+1, last): node = TreeNode(root) node.left = left node.right = right trees += node, return trees or [None] return generate(1, n) java https://discuss.leetcode.com/topic/3079/a-simple-recursive-solution A simple recursive solution I start by noting that 1..n is the in-order traversal for any BST with nodes 1 to n. So if I pick i-th node as my root, the left subtree will contain elements 1 to (i-1), and the right subtree will contain elements (i+1) to n. I use recursive calls to get back all possible trees for left and right subtrees and combine them in all possible ways with the root. 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; return genTrees(1,n); &#125; public List&lt;TreeNode&gt; genTrees (int start, int end) &#123; List&lt;TreeNode&gt; list = new ArrayList&lt;TreeNode&gt;(); if(start&gt;end) &#123; list.add(null); return list; &#125; if(start == end)&#123; list.add(new TreeNode(start)); return list; &#125; List&lt;TreeNode&gt; left,right; for(int i=start;i&lt;=end;i++) &#123; left = genTrees(start, i-1); right = genTrees(i+1,end); for(TreeNode lnode: left) &#123; for(TreeNode rnode: right) &#123; TreeNode root = new TreeNode(i); root.left = lnode; root.right = rnode; list.add(root); &#125; &#125; &#125; return list; &#125;&#125; https://discuss.leetcode.com/topic/2940/java-solution-with-dp Java Solution with DP Here is my java solution with DP: 123456789101112131415161718192021222324252627282930313233public static List&lt;TreeNode&gt; generateTrees(int n) &#123; List&lt;TreeNode&gt;[] result = new List[n + 1]; result[0] = new ArrayList&lt;TreeNode&gt;(); if (n == 0) &#123; return result[0]; &#125; result[0].add(null); for (int len = 1; len &lt;= n; len++) &#123; result[len] = new ArrayList&lt;TreeNode&gt;(); for (int j = 0; j &lt; len; j++) &#123; for (TreeNode nodeL : result[j]) &#123; for (TreeNode nodeR : result[len - j - 1]) &#123; TreeNode node = new TreeNode(j + 1); node.left = nodeL; node.right = clone(nodeR, j + 1); result[len].add(node); &#125; &#125; &#125; &#125; return result[n];&#125;private static TreeNode clone(TreeNode n, int offset) &#123; if (n == null) &#123; return null; &#125; TreeNode node = new TreeNode(n.val + offset); node.left = clone(n.left, offset); node.right = clone(n.right, offset); return node;&#125; result[i] stores the result until length i. For the result for length i+1, select the root node j from 0 to i, combine the result from left side and right side. Note for the right side we have to clone the nodes as the value will be offsetted by j. https://discuss.leetcode.com/topic/8410/divide-and-conquer-f-i-g-i-1-g-n-i Divide-and-conquer. F(i) = G(i-1) * G(n-i) This problem is a variant of the problem of Unique Binary Search Trees. I provided a solution along with explanation for the above problem, in the question “DP solution in 6 lines with explanation” It is intuitive to solve this problem by following the same algorithm. Here is the code in a divide-and-conquer style. 1234567891011121314151617181920212223242526public List&lt;TreeNode&gt; generateTrees(int n) &#123; return generateSubtrees(1, n);&#125;private List&lt;TreeNode&gt; generateSubtrees(int s, int e) &#123; List&lt;TreeNode&gt; res = new LinkedList&lt;TreeNode&gt;(); if (s &gt; e) &#123; res.add(null); // empty tree return res; &#125; for (int i = s; i &lt;= e; ++i) &#123; List&lt;TreeNode&gt; leftSubtrees = generateSubtrees(s, i - 1); List&lt;TreeNode&gt; rightSubtrees = generateSubtrees(i + 1, e); for (TreeNode left : leftSubtrees) &#123; for (TreeNode right : rightSubtrees) &#123; TreeNode root = new TreeNode(i); root.left = left; root.right = right; res.add(root); &#125; &#125; &#125; return res;&#125; 5ms, 22.90%, September 23, 2016 https://discuss.leetcode.com/topic/8410/divide-and-conquer-f-i-g-i-1-g-n-i 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; List&lt;TreeNode&gt; tmp = new LinkedList&lt;TreeNode&gt;(); if(n==0) return tmp; return generateSubtrees(1, n); &#125; private List&lt;TreeNode&gt; generateSubtrees(int s, int e)&#123; List&lt;TreeNode&gt; res = new LinkedList&lt;TreeNode&gt;(); if(s&gt;e)&#123; res.add(null); return res; &#125; for(int i=s; i&lt;=e; ++i)&#123; List&lt;TreeNode&gt; leftSubtrees = generateSubtrees(s, i-1); List&lt;TreeNode&gt; rightSubtrees = generateSubtrees(i+1, e); for(TreeNode left:leftSubtrees)&#123; for(TreeNode right:rightSubtrees)&#123; TreeNode root = new TreeNode(i); root.left = left; root.right = right; res.add(root); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[094. Binary Tree Inorder Traversal]]></title>
    <url>%2Fp%2Fa4c01477%2F</url>
    <content type="text"><![CDATA[44.5% https://leetcode.com/problems/binary-tree-inorder-traversal/#/description Given a binary tree, return the inorder traversal of its nodes’ values. For example:Given binary tree [1,null,2,3], 1 \ 2 / 3return [1,3,2]. Note: Recursive solution is trivial, could you do it iteratively? 方法一：递归版本，最简单 Dec 10th, 2017 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; helper(root, res); return res; &#125; void helper(TreeNode* root, vector&lt;int&gt;&amp; res)&#123; if(root!=nullptr)&#123; helper(root-&gt;left, res); res.push_back(root-&gt;val); helper(root-&gt;right, res); &#125; &#125;&#125;; 1234567891011void inorder(TreeNode* root, vector&lt;int&gt;&amp; nodes) &#123; if (!root) return; inorder(root -&gt; left, nodes); nodes.push_back(root -&gt; val); inorder(root -&gt; right, nodes);&#125;vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; inorder(root, nodes); return nodes;&#125; 我的代码实现： 12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; vector&lt;int&gt; res;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; if(!root) return res; // 虽然有返回值，但我们不使用 inorderTraversal(root-&gt;left); res.push_back(root-&gt;val); inorderTraversal(root-&gt;right); return res; &#125;&#125;; 方法二：迭代版本 使用栈 pCurrent指向当前节点。 如果当前节点不为空，压入栈，然后当前节点指向做节点。 当前节点为空，从栈中取出一个节点，节点值放入vector，当前节点指向右节点。 Dec 10th, 2017 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; // 这个要满足两个条件，stack不为空且cur不为nullptr while(stack.size() || cur!=nullptr)&#123; if(cur!=nullptr)&#123; stack.push(cur); cur = cur-&gt;left; &#125;else&#123; TreeNode* tmp = stack.top(); stack.pop(); res.push_back(tmp-&gt;val); cur = tmp-&gt;right; &#125; &#125; return res; &#125;&#125;; 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; vector; stack&lt;TreeNode *&gt; stack; TreeNode *pCurrent = root; while(!stack.empty() || pCurrent) &#123; if(pCurrent) &#123; stack.push(pCurrent); pCurrent = pCurrent-&gt;left; &#125; else &#123; TreeNode *pNode = stack.top(); vector.push_back(pNode-&gt;val); stack.pop(); pCurrent = pNode-&gt;right; &#125; &#125; return vector; &#125;&#125;; 我的代码实现： 先把左边全部压入， 然后取出，放入一个节点，向上走，向右走。 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; stack; while(root || !stack.empty())&#123; if(root)&#123; stack.push(root); root = root-&gt;left; &#125;else&#123; TreeNode* node = stack.top(); stack.pop(); res.push_back(node-&gt;val); root = node-&gt;right; &#125; &#125; return res; &#125;&#125;; 方法三： Morris traversal: 12345678910111213141516171819202122232425vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; TreeNode* curNode = root; vector&lt;int&gt; nodes; while (curNode) &#123; if (curNode -&gt; left) &#123; TreeNode* predecessor = curNode -&gt; left; while (predecessor -&gt; right &amp;&amp; predecessor -&gt; right != curNode) predecessor = predecessor -&gt; right; if (!(predecessor -&gt; right)) &#123; predecessor -&gt; right = curNode; curNode = curNode -&gt; left; &#125; else &#123; predecessor -&gt; right = NULL; nodes.push_back(curNode -&gt; val); curNode = curNode -&gt; right; &#125; &#125; else &#123; nodes.push_back(curNode -&gt; val); curNode = curNode -&gt; right; &#125; &#125; return nodes;&#125; 我的代码实现: 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; TreeNode* cur = root; while(cur)&#123; if(cur-&gt;left)&#123; TreeNode* pre = cur-&gt;left; while(pre-&gt;right!=NULL &amp;&amp; pre-&gt;right!=cur) pre = pre-&gt;right; if(pre-&gt;right!=cur)&#123; pre-&gt;right = cur; cur = cur-&gt;left; &#125;else&#123; pre-&gt;right = NULL; res.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125;else&#123; res.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/3288/three-methods-to-solve-c Three Methods to Solve (C++) Method 1: Using one stack and the binary tree node will be changed. Easy ,not Practical 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; vector; if(!root) return vector; stack&lt;TreeNode *&gt; stack; stack.push(root); while(!stack.empty()) &#123; TreeNode *pNode = stack.top(); if(pNode-&gt;left) &#123; stack.push(pNode-&gt;left); pNode-&gt;left = NULL; &#125; else &#123; vector.push_back(pNode-&gt;val); stack.pop(); if(pNode-&gt;right) stack.push(pNode-&gt;right); &#125; &#125; return vector; &#125;&#125;; Method 2: Using one stack and one unordered_map, this will not changed the node. Better 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; vector; if(!root) return vector; unordered_map&lt;TreeNode *, bool&gt; map;//left child has been visited:true. stack&lt;TreeNode *&gt; stack; stack.push(root); while(!stack.empty()) &#123; TreeNode *pNode = stack.top(); if(pNode-&gt;left &amp;&amp; !map[pNode]) &#123; stack.push(pNode-&gt;left); map[pNode] = true; &#125; else &#123; vector.push_back(pNode-&gt;val); stack.pop(); if(pNode-&gt;right) stack.push(pNode-&gt;right); &#125; &#125; return vector; &#125;&#125;; Method 3: Using one stack and will not changed the node. Best(at least in this three solutions) 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; vector; stack&lt;TreeNode *&gt; stack; TreeNode *pCurrent = root; while(!stack.empty() || pCurrent) &#123; if(pCurrent) &#123; stack.push(pCurrent); pCurrent = pCurrent-&gt;left; &#125; else &#123; TreeNode *pNode = stack.top(); vector.push_back(pNode-&gt;val); stack.pop(); pCurrent = pNode-&gt;right; &#125; &#125; return vector; &#125;&#125;; https://discuss.leetcode.com/topic/14475/clear-c-solutions-iterative-recursive-and-morris-traversal-3-different-solutions Clear C++ solutions — iterative, recursive and Morris traversal (3 different solutions!) Hi, this is a fundamental and yet classic problem. I share my three solutions here: Iterative solution using stack — O(n) time and O(n) space; Recursive solution — O(n) time and O(n) space (considering the spaces of function call stack); Morris traversal — O(n) time and O(1) space!!! Iterative solution using stack: 123456789101112131415161718vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; stack&lt;TreeNode*&gt; toVisit; TreeNode* curNode = root; while (curNode || !toVisit.empty()) &#123; if (curNode) &#123; toVisit.push(curNode); curNode = curNode -&gt; left; &#125; else &#123; curNode = toVisit.top(); toVisit.pop(); nodes.push_back(curNode -&gt; val); curNode = curNode -&gt; right; &#125; &#125; return nodes;&#125; Recursive solution: 1234567891011void inorder(TreeNode* root, vector&lt;int&gt;&amp; nodes) &#123; if (!root) return; inorder(root -&gt; left, nodes); nodes.push_back(root -&gt; val); inorder(root -&gt; right, nodes);&#125;vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; inorder(root, nodes); return nodes;&#125; Morris traversal: 12345678910111213141516171819202122232425vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; TreeNode* curNode = root; vector&lt;int&gt; nodes; while (curNode) &#123; if (curNode -&gt; left) &#123; TreeNode* predecessor = curNode -&gt; left; while (predecessor -&gt; right &amp;&amp; predecessor -&gt; right != curNode) predecessor = predecessor -&gt; right; if (!(predecessor -&gt; right)) &#123; predecessor -&gt; right = curNode; curNode = curNode -&gt; left; &#125; else &#123; predecessor -&gt; right = NULL; nodes.push_back(curNode -&gt; val); curNode = curNode -&gt; right; &#125; &#125; else &#123; nodes.push_back(curNode -&gt; val); curNode = curNode -&gt; right; &#125; &#125; return nodes;&#125; https://discuss.leetcode.com/topic/21942/my-3-solutions-in-c My 3 solutions in c++ 123456789// recursive, it&apos;s trivial...vector&lt;int&gt; v;vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; if(!root) return v; inorderTraversal(root-&gt;left); v.push_back(root-&gt;val); inorderTraversal(root-&gt;right); return v;&#125; 12345678910111213141516171819// iterate, use stackvector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root; stack&lt;TreeNode*&gt; s; while(true)&#123; while(temp)&#123; s.push(temp); temp = temp-&gt;left; &#125; if(s.empty()) break; temp = s.top(); s.pop(); v.push_back(temp-&gt;val); temp = temp-&gt;right; &#125; return v;&#125; 123456789101112131415161718192021222324// iterate, morris traversal, without stackvector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root, *prev; while(temp)&#123; if(!temp-&gt;left)&#123; v.push_back(temp-&gt;val); temp = temp-&gt;right; &#125;else&#123; prev = temp-&gt;left; while(prev-&gt;right&amp;&amp;(prev-&gt;right != temp)) prev = prev-&gt;right; if(!prev-&gt;right)&#123; prev-&gt;right = temp; temp = temp-&gt;left; &#125;else&#123; v.push_back(temp-&gt;val); prev-&gt;right = NULL; temp = temp-&gt;right; &#125; &#125; &#125;&#125; python https://discuss.leetcode.com/topic/21350/python-recursive-and-iterative-solutions Python recursive and iterative solutions. 1234567891011# recursivelydef inorderTraversal1(self, root): res = [] self.helper(root, res) return res def helper(self, root, res): if root: self.helper(root.left, res) res.append(root.val) self.helper(root.right, res) 123456789101112# iteratively def inorderTraversal(self, root): res, stack = [], [] while True: while root: stack.append(root) root = root.left if not stack: return res node = stack.pop() res.append(node.val) root = node.right https://discuss.leetcode.com/topic/14640/simple-python-iterative-solution-by-using-a-visited-flag-o-n-56ms Simple Python iterative solution by using a visited flag - O(n) 56ms 123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # @param &#123;TreeNode&#125; root # @return &#123;integer[]&#125; def inorderTraversal(self, root): result, stack = [], [(root, False)] while stack: cur, visited = stack.pop() if cur: if visited: result.append(cur.val) else: stack.append((cur.right, False)) stack.append((cur, True)) stack.append((cur.left, False)) return result 48ms, 57.41%, June.16th, 2016 https://leetcode.com/discuss/51816/python-recursive-and-iterative-solutions 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def inorderTraversal(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; ans = [] stack = [] while stack or root: if root: stack.append(root) root = root.left else: tmpNode = stack.pop() ans.append(tmpNode.val) root = tmpNode.right return ans java https://discuss.leetcode.com/topic/6478/iterative-solution-in-java-simple-and-readable Iterative solution in Java - simple and readable 123456789101112131415161718public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode cur = root; while(cur!=null || !stack.empty())&#123; while(cur!=null)&#123; stack.add(cur); cur = cur.left; &#125; cur = stack.pop(); list.add(cur.val); cur = cur.right; &#125; return list;&#125; https://discuss.leetcode.com/topic/3402/morris-traversal-no-recursion-no-stack Morris Traversal——- NO RECURSION NO STACK 12345678910111213141516171819202122232425262728293031323334public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;public class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if(root == null) return new ArrayList&lt;Integer&gt;(); List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); TreeNode pre = null; while(root != null)&#123; if(root.left == null)&#123; res.add(root.val); root = root.right; &#125;else&#123; pre = root.left; while(pre.right != null &amp;&amp; pre.right != root)&#123; pre = pre.right; &#125; if(pre.right == null)&#123; pre.right = root; root = root.left; &#125;else&#123; pre.right = null; res.add(root.val); root = root.right; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>medium</tag>
        <tag>stack</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[093. Restore IP Addresses]]></title>
    <url>%2Fp%2F3f3a9681%2F</url>
    <content type="text"><![CDATA[26.2% https://leetcode.com/problems/restore-ip-addresses/ Given a string containing only digits, restore it by returning all possible valid IP address combinations. 1234For example:Given &quot;25525511135&quot;,return [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]. (Order does not matter) 方法一： 学习string的函数，substr、stoi int转string的函数，to_string 0ms, 85.96%, September 22, 2016 https://discuss.leetcode.com/topic/38342/who-can-beat-this-code 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; ret; string ans; for(int a=1; a&lt;=3; a++) for(int b=1; b&lt;=3; b++) for(int c=1; c&lt;=3; c++) for(int d=1; d&lt;=3; d++) if(a+b+c+d == s.length())&#123; int A = stoi(s.substr(0, a)); int B = stoi(s.substr(a, b)); int C = stoi(s.substr(a+b, c)); int D = stoi(s.substr(a+b+c, d)); if(A&lt;=255&amp;&amp;B&lt;=255&amp;&amp;C&lt;=255&amp;&amp;D&lt;=255) if((ans=to_string(A)+&quot;.&quot;+to_string(B)+&quot;.&quot;+to_string(C)+&quot;.&quot;+ to_string(D)).length() == s.length()+3) ret.push_back(ans); &#125; return ret; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; res; // 要注意时&lt;=还是&lt; for(int i=1; i&lt;=3; i++)&#123; for(int j=1; j&lt;=3; j++)&#123; for(int k=1; k&lt;=3; k++)&#123; for(int l=1; l&lt;=3; l++)&#123; if(i+k+j+l==s.size())&#123; int a = stoi(s.substr(0, i)); int b = stoi(s.substr(i, j)); int c = stoi(s.substr(i+j, k)); int d = stoi(s.substr(i+j+k, l)); // 要有&lt;=255这个判断 if(a&lt;=255 &amp;&amp; b&lt;=255 &amp;&amp; c&lt;=255 &amp;&amp; d&lt;=255)&#123; // 注意使用"."还是'.'，尤其注意c++时 string t = to_string(a)+"."+to_string(b)+"."+ to_string(c)+"."+to_string(d); if(t.size()==s.size()+3) res.push_back(t); &#125; &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125;; 方法二： dfs https://discuss.leetcode.com/topic/19274/share-0ms-neat-and-clear-c-solution-using-dfs Share 0ms neat and clear c++ solution using DFS 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; result; string ip; dfs(s,0,0,ip,result); //paras:string s,start index of s,step(from0-3),intermediate ip,final result return result; &#125; void dfs(string s,int start,int step,string ip,vector&lt;string&gt;&amp; result)&#123; if(start==s.size()&amp;&amp;step==4)&#123; ip.erase(ip.end()-1); //remove the last &apos;.&apos; from the last decimal number result.push_back(ip); return; &#125; if(s.size()-start&gt;(4-step)*3) return; if(s.size()-start&lt;(4-step)) return; int num=0; for(int i=start;i&lt;start+3;i++)&#123; num=num*10+(s[i]-&apos;0&apos;); if(num&lt;=255)&#123; ip+=s[i]; dfs(s,i+1,step+1,ip+&apos;.&apos;,result); &#125; if(num==0) break; &#125; &#125;&#125;; java 4ms, 58.66%, September 22, 2016 https://discuss.leetcode.com/topic/3919/my-code-in-java 3-loop divides the string s into 4 substring: s1, s2, s3, s4. Check if each substring is valid.In isValid, strings whose length greater than 3 or equals to 0 is not valid; or if the string’s length is longer than 1 and the first letter is ‘0’ then it’s invalid; or the string whose integer representation greater than 255 is invalid. 12345678910111213141516171819202122public class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); int len = s.length(); for(int i=1; i&lt;4&amp;&amp;i&lt;len-2; i++)&#123; for(int j=i+1; j&lt;i+4&amp;&amp; j&lt;len; j++)&#123; for(int k=j+1; k&lt;j+4&amp;&amp;k&lt;len; k++)&#123; String s1 = s.substring(0, i), s2 = s.substring(i, j), s3=s.substring(j,k), s4=s.substring(k,len); if(isValid(s1) &amp;&amp; isValid(s2) &amp;&amp; isValid(s3) &amp;&amp; isValid(s4)) res.add(s1+&quot;.&quot;+s2+&quot;.&quot;+s3+&quot;.&quot;+s4); &#125; &#125; &#125; return res; &#125; public boolean isValid(String s)&#123; if(s.length()&gt;3 || s.length()==0 || (s.charAt(0)==&apos;0&apos;&amp;&amp;s.length()&gt;1) || Integer.parseInt(s)&gt;255) return false; return true; &#125;&#125; https://discuss.leetcode.com/topic/4742/very-simple-dfs-solution Very simple DFS solution 1234567891011121314151617public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; solutions = new ArrayList&lt;String&gt;(); restoreIp(s, solutions, 0, &quot;&quot;, 0); return solutions;&#125;private void restoreIp(String ip, List&lt;String&gt; solutions, int idx, String restored, int count) &#123; if (count &gt; 4) return; if (count == 4 &amp;&amp; idx == ip.length()) solutions.add(restored); for (int i=1; i&lt;4; i++) &#123; if (idx+i &gt; ip.length()) break; String s = ip.substring(idx,idx+i); if ((s.startsWith(&quot;0&quot;) &amp;&amp; s.length()&gt;1) || (i==3 &amp;&amp; Integer.parseInt(s) &gt;= 256)) continue; restoreIp(ip, solutions, idx+i, restored+s+(count==3?&quot;&quot; : &quot;.&quot;), count+1); &#125;&#125; https://discuss.leetcode.com/topic/6304/my-concise-ac-java-code My concise AC java code the basic idea is to make three cuts into the string, separating it into four parts, each part contains 1 ~ 3 digits and it must be &lt; 255. 12345678910111213141516171819202122static List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; ans = new ArrayList&lt;String&gt;(); int len = s.length(); for (int i = 1; i &lt;=3; ++i)&#123; // first cut if (len-i &gt; 9) continue; for (int j = i+1; j&lt;=i+3; ++j)&#123; //second cut if (len-j &gt; 6) continue; for (int k = j+1; k&lt;=j+3 &amp;&amp; k&lt;len; ++k)&#123; // third cut int a,b,c,d; // the four int&apos;s seperated by &quot;.&quot; a = Integer.parseInt(s.substring(0,i)); b = Integer.parseInt(s.substring(i,j)); // notice that &quot;01&quot; can be parsed into 1. Need to deal with that later. c = Integer.parseInt(s.substring(j,k)); d = Integer.parseInt(s.substring(k)); if (a&gt;255 || b&gt;255 || c&gt;255 || d&gt;255) continue; String ip = a+&quot;.&quot;+b+&quot;.&quot;+c+&quot;.&quot;+d; if (ip.length()&lt;len+3) continue; // this is to reject those int&apos;s parsed from &quot;01&quot; or &quot;00&quot;-like substrings ans.add(ip); &#125; &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/20009/easy-java-code-of-backtracking-within-16-lines Easy Java code of backtracking within 16 lines 12345678910111213141516171819public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); helper(s,&quot;&quot;,res,0); return res; &#125; public void helper(String s, String tmp, List&lt;String&gt; res,int n)&#123; if(n==4)&#123; if(s.length()==0) res.add(tmp.substring(0,tmp.length()-1)); //substring here to get rid of last &apos;.&apos; return; &#125; for(int k=1;k&lt;=3;k++)&#123; if(s.length()&lt;k) continue; int val = Integer.parseInt(s.substring(0,k)); if(val&gt;255 || k!=String.valueOf(val).length()) continue; /*in the case 010 the parseInt will return len=2 where val=10, but k=3, skip this.*/ helper(s.substring(k),tmp+s.substring(0,k)+&quot;.&quot;,res,n+1); &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[092. Reverse Linked List II]]></title>
    <url>%2Fp%2F7b414406%2F</url>
    <content type="text"><![CDATA[30.0% https://leetcode.com/problems/reverse-linked-list-ii/?tab=Description Reverse a linked list from position m to n. Do it in-place and in one-pass. 1234For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. Note: Given m, n satisfy the following condition: 1 ≤ m ≤ n ≤ length of list. cpp 3ms, 7.08%, September 21, 2016 https://discuss.leetcode.com/topic/4980/share-my-14-lines-c-solution Share my 14 lines C++ solution 1234567891011121314151617ListNode *reverseBetween(ListNode *head, int m, int n) &#123; if(m==n)return head; n-=m; ListNode prehead(0); prehead.next=head; ListNode* pre=&amp;prehead; while(--m)pre=pre-&gt;next; ListNode* pstart=pre-&gt;next; while(n--) &#123; ListNode *p=pstart-&gt;next; pstart-&gt;next=p-&gt;next; p-&gt;next=pre-&gt;next; pre-&gt;next=p; &#125; return prehead.next;&#125; https://discuss.leetcode.com/topic/15034/12-lines-4ms-c 12-lines 4ms C++ The basic idea is as follows: (1) Create a new_head that points to head and use it to locate the immediate node before the m-th (notice that it is 1-indexed) node pre; (2) Set cur to be the immediate node after pre and at each time move the immediate node after cur (named move) to be the immediate node after pre. Repeat it for n - m times. 123456789101112131415161718class Solution &#123; public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; ListNode* new_head = new ListNode(0); new_head -&gt; next = head; ListNode* pre = new_head; for (int i = 0; i &lt; m - 1; i++) pre = pre -&gt; next; ListNode* cur = pre -&gt; next; for (int i = 0; i &lt; n - m; i++) &#123; ListNode* move = cur -&gt; next; cur -&gt; next = move -&gt; next; move -&gt; next = pre -&gt; next; pre -&gt; next = move; &#125; return new_head -&gt; next; &#125;&#125;; python 56ms, September 21, 2016 https://discuss.leetcode.com/topic/10378/python-one-pass-iterative-solution Python one pass iterative solution The idea is simple and intuitive: find linkedlist [m, n], reverse it, then connect m with n+1, connect n with m-1 1234567891011121314151617181920212223242526272829class Solution: # @param head, a ListNode # @param m, an integer # @param n, an integer # @return a ListNode def reverseBetween(self, head, m, n): if m == n: return head dummyNode = ListNode(0) dummyNode.next = head pre = dummyNode for i in range(m - 1): pre = pre.next # reverse the [m, n] nodes reverse = None cur = pre.next for i in range(n - m + 1): next = cur.next cur.next = reverse reverse = cur cur = next pre.next.next = cur pre.next = reverse return dummyNode.next https://discuss.leetcode.com/topic/27852/python-implementation-and-detailed-explanation Python implementation and detailed explanation For List with [1, 2, 3, 4, 5], supposed m == 2 and n == 4 Step1: The part I need to reversed is node 2 to node 4, which has n - m + 1 = 3 nodes. Therefore, I would like to maintain a window with n - m + 1 nodes with the window’s head whead and window’s tail wtail, then if whead is head, wtail would be the next n-m node from head. [123]45 =&gt; whead is 1 and wtail is 3 Step2: And to get to the right reversed portion we want, we need to shift the window m-1 times 1[234]5 =&gt; whead is 2 and wtail is 4 Step3: Isolate the nodes inside the window, reverse the window as Reverse Linked List Step4: combine the outside node with reversed node. To do so, I need to record the head outside the window ohead, and the tail outside the window otail ohead is 1, otail is 5 1-[432]-5 Implementation detail: Since in step 4, you need to let ohead.next = reversed_headIf you create a dummy node, you can save some lines for m == 1 cases, where ohead would be None and ohead.next would fail the program. 12345678910111213141516171819202122232425class Solution(object): def reverseBetween(self, head, m, n): if m &gt;= n: return head #Step 1# ohead = dummy = ListNode(0) whead = wtail = head dummy.next = head for i in range(n-m): wtail = wtail.next #Step 2# for i in range(m-1): ohead, whead, wtail = whead, whead.next, wtail.next #Step 3# otail, wtail.next = wtail.next, None revhead, revtail = self.reverse(whead) #Step 4# ohead.next, revtail.next = revhead, otail return dummy.next def reverse(self, head): pre, cur, tail = None, head, head while cur: cur.next, pre, cur = pre, cur, cur.next return pre, tail java 0ms, 13.07%, September 21, 2016 https://discuss.leetcode.com/topic/8976/simple-java-solution-with-clear-explanation Simple Java solution with clear explanation Simply just reverse the list along the way using 4 pointers: dummy, pre, start, then 123456789101112131415161718192021222324252627public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(head == null) return null; ListNode dummy = new ListNode(0); // create a dummy node to mark the head of this list dummy.next = head; ListNode pre = dummy; // make a pointer pre as a marker for the node before reversing for(int i = 0; i&lt;m-1; i++) pre = pre.next; ListNode start = pre.next; // a pointer to the beginning of a sub-list that will be reversed ListNode then = start.next; // a pointer to a node that will be reversed // 1 - 2 -3 - 4 - 5 ; m=2; n =4 ---&gt; pre = 1, start = 2, then = 3 // dummy-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 for(int i=0; i&lt;n-m; i++) &#123; start.next = then.next; then.next = pre.next; pre.next = then; then = start.next; &#125; // first reversing : dummy-&gt;1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4 // second reversing: dummy-&gt;1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish) return dummy.next; &#125; https://discuss.leetcode.com/topic/3250/share-my-java-code Share my Java code The basic idea is to build a sub-list when we hit Node m by adding the subsequent nodes to the head of the sub-list one by one until we hit Node n. Then connect the nodes before Node m, the sub-list and the nodes following Node n. 12345678910111213141516171819202122232425public ListNode reverseBetween(ListNode head, int m, int n) &#123; ListNode dummyhead = new ListNode(0); dummyhead.next = head; ListNode sublisthead = new ListNode(0); ListNode sublisttail = new ListNode(0); int count = 1; ListNode pre_cur = dummyhead, cur = head; while(count &lt;=n)&#123; ListNode temp = cur.next; if (count &lt; m) pre_cur = cur; else if (count == m)&#123; sublisttail = cur; sublisthead.next = cur; &#125;else if (count &gt; m)&#123; cur.next = sublisthead.next; sublisthead.next = cur; &#125; cur = temp; ++count; &#125; pre_cur.next = sublisthead.next; sublisttail.next = cur; return dummyhead.next;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[091. Decode Ways]]></title>
    <url>%2Fp%2F33438676%2F</url>
    <content type="text"><![CDATA[19.6% https://leetcode.com/problems/decode-ways/ A message containing letters from A-Z is being encoded to numbers using the following mapping: 1234&apos;A&apos; -&gt; 1&apos;B&apos; -&gt; 2...&apos;Z&apos; -&gt; 26 Given an encoded message containing digits, determine the total number of ways to decode it. For example,Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12). The number of ways decoding “12” is 2. 方法一： 两个两个的解决，一个一个的遍历，两个两个的验证，防止100这样的无法解析的。 对于数字，有两种解码方式。 一种是s[i-2] + ‘i-1, i’（i-1,i组合成一个字母），一种是s[i-1] + ‘i’ （i自己组合成一个方式） 首先，如果s[i] == ‘0’这种情况下，s[i-1]解码失效，设定值为0 然后’i-1,i’组合成一个字母的话， 就可以更新s[i]解码方式为s[i-1]和s[i-2]的和了 如果组合不成字母，则s[i] = s[i-1] 0ms, 73.36%, September 20, 2016 https://discuss.leetcode.com/topic/7025/a-concise-dp-solution 123456789101112131415161718192021class Solution &#123;public: int numDecodings(string s) &#123; if(!s.size() || s.front() == &apos;0&apos;) return 0; // r2: decode ways of s[i-2] , r1: decode ways of s[i-1] int r1 = 1, r2 = 1; for(int i=1; i&lt;s.size(); i++)&#123; // zero voids ways of the last because zero cannot be used separately if(s[i] == &apos;0&apos;) r1 = 0; // possible two-digit letter, so new r1 is sum of both while new r2 is the old r1 if(s[i-1] == &apos;1&apos; || s[i-1] == &apos;2&apos; &amp;&amp; s[i] &lt;= &apos;6&apos;)&#123; r1 = r1 + r2; r2 = r1 - r2; &#125; // one-digit letter, no new way added else r2 = r1; &#125; return r1; &#125;&#125;; 我的代码实现： 两个变量，r1， r2，一个是遍历到i时，r1表示，从开始至i-2位时的decode ways r2表示开始至i-1的decode ways 更新时，新的r1显然是等于r2。 新的r2，要从r1和r2及他们后面一两位的情况，是否合法去判断。 12345678910111213141516171819class Solution &#123;public: int numDecodings(string s) &#123; // string的函数front() if(s.empty() || s.front()=='0') return 0; int r1=1, r2=1; for(int i=1; i&lt;s.size(); i++)&#123; int nr2 = 0; if(s[i]!='0') nr2 += r2; if(s[i-1]=='1' || s[i-1]=='2'&amp;&amp;s[i]&lt;='6') nr2 += r1; r1 = r2; r2 = nr2; &#125; return r2; &#125;&#125;; 我的代码实现二: 1234567891011121314151617181920class Solution &#123;public: int numDecodings(string s) &#123; int n = s.size(); if(n&lt;1) return 0; // r1 i-2, r2 i-1 int r1 = 1, r2 = s[0]&gt;='1' &amp;&amp; s[1]&lt;='9' ? 1 : 0; for(int i=1; i&lt;n; i++)&#123; int nr1 = r2; int nr2 = 0; if(s[i]&gt;='1' &amp;&amp; s[i]&lt;='9') nr2 += r2; if(s[i-1]=='1' || s[i-1]=='2' &amp;&amp; s[i]&lt;='6') nr2 += r1; r1 = nr1; r2 = nr2; &#125; return r2; &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/15440/my-c-0ms-dp-solution-o-n My c++ 0ms DP solution O(n) 12345678910111213141516171819202122int n = s.size(); if(n == 0 || s[0] == &apos;0&apos;) return 0; if(n == 1) return 1; int res = 0,fn_1 = 1,fn_2 = 1; for(int i = 1;i &lt; n;i++)&#123; int temp = fn_1; if(isValid(s[i])&amp;&amp;isValid(s[i-1],s[i])) res+=fn_1+fn_2; if(!isValid(s[i])&amp;&amp;isValid(s[i-1],s[i])) res+=fn_2; if(isValid(s[i])&amp;&amp;!isValid(s[i-1],s[i])) res+=fn_1; if(!isValid(s[i])&amp;&amp;!isValid(s[i-1],s[i])) return 0; fn_1 = res; fn_2 = temp; res = 0; &#125; return fn_1;&#125;bool isValid(char a,char b)&#123; return a == &apos;1&apos;||(a == &apos;2&apos; &amp;&amp; b &lt;=&apos;6&apos;);&#125;bool isValid(char a)&#123; return a != &apos;0&apos;;&#125; python62ms, 23.31%, September 20, 2016 https://discuss.leetcode.com/topic/19042/1-liner-o-1-space w tells the number of ways v tells the previous number of ways d is the current digit p is the previous digit 12345678910class Solution(object): def numDecodings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; v, w, p = 0, int(s&gt;&apos;&apos;), &apos;&apos; for d in s: v, w, p = w, (d&gt;&apos;0&apos;)*w + (9&lt;int(p+d)&lt;27)*v, d return w 12def numDecodings(self, s): return reduce(lambda(v,w,p),d:(w,(d&gt;&apos;0&apos;)*w+(9&lt;int(p+d)&lt;27)*v,d),s,(0,s&gt;&apos;&apos;,&apos;&apos;))[1]*1 java5ms, 27.87%, September 20, 2016 https://discuss.leetcode.com/topic/35840/java-clean-dp-solution-with-explanation I used a dp array of size n + 1 to save subproblem solutions. dp[0] means an empty string will have one way to decode, dp[1] means the way to decode a string of size 1. I then check one digit and two digit combination and save the results along the way. In the end, dp[n] will be the end result. 123456789101112131415161718public class Solution &#123; public int numDecodings(String s) &#123; if(s == null || s.length() == 0) return 0; int n = s.length(); int[] dp = new int[n+1]; dp[0] = 1; dp[1] = s.charAt(0) != &apos;0&apos; ? 1: 0; for(int i = 2; i&lt;=n; i++)&#123; int first = Integer.valueOf(s.substring(i-1, i)); int second = Integer.valueOf(s.substring(i-2, i)); if(first &gt;= 1 &amp;&amp; first &lt;= 9) dp[i] += dp[i-1]; if(second &gt;= 10 &amp;&amp; second &lt;= 26) dp[i] += dp[i-2]; &#125; return dp[n]; &#125;&#125; https://discuss.leetcode.com/topic/2562/dp-solution-java-for-reference DP Solution (Java) for reference 12345678910111213141516public class Solution &#123; public int numDecodings(String s) &#123; int n = s.length(); if (n == 0) return 0; int[] memo = new int[n+1]; memo[n] = 1; memo[n-1] = s.charAt(n-1) != &apos;0&apos; ? 1 : 0; for (int i = n - 2; i &gt;= 0; i--) if (s.charAt(i) == &apos;0&apos;) continue; else memo[i] = (Integer.parseInt(s.substring(i,i+2))&lt;=26) ? memo[i+1]+memo[i+2] : memo[i+1]; return memo[0]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>medium</tag>
        <tag>dynamci programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[090. Subsets II]]></title>
    <url>%2Fp%2Ff25f3971%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/subsets-ii/ Given a collection of integers that might contain duplicates, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. 1234567891011For example,If nums = [1,2,2], a solution is:[ [2], [1], [1,2,2], [2,2], [1,2], []] 方法一： 回溯法 针对重复的，去除就好了。 https://discuss.leetcode.com/topic/13543/accepted-10ms-c-solution-use-backtracking-only-10-lines-easy-understand Accepted 10ms c++ solution use backtracking, only 10 lines, easy understand. The characteristics of C++ reference is an outstanding tool for backtracking algorithm! let us use [1,2,3,4] as an example to explain my solution: 12345678910subsets([1,2,3,4]) = [] // push(1) [1, subsets([2,3,4])] // if push N times in subsets([2,3,4]), the pop times is also N, so vec is also [1] after backtrack. // pop(), push(2) [2, subsets([3,4])] // pop(), push(3) [3, subsets([4])] // pop(), push(4) [4, subsets([])] // pop() Accepted 10ms c++ solution use backtracking for Subsets 12345678910111213141516171819class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; subsets(std::vector&lt;int&gt; &amp;nums) &#123; std::sort(nums.begin(), nums.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; vec; subsets(res, nums, vec, 0); return res; &#125;private: void subsets(std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;nums, std::vector&lt;int&gt; &amp;vec, int begin) &#123; res.push_back(vec); for (int i = begin; i != nums.size(); ++i) &#123; vec.push_back(nums[i]); subsets(res, nums, vec, i + 1); vec.pop_back(); &#125; &#125;&#125;; Accepted 10ms c++ solution use backtracking for Subsets II 1234567891011121314151617181920class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; subsetsWithDup(std::vector&lt;int&gt; &amp;nums) &#123; std::sort(nums.begin(), nums.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; vec; subsetsWithDup(res, nums, vec, 0); return res; &#125;private: void subsetsWithDup(std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;nums, std::vector&lt;int&gt; &amp;vec, int begin) &#123; res.push_back(vec); for (int i = begin; i != nums.size(); ++i) if (i == begin || nums[i] != nums[i - 1]) &#123; vec.push_back(nums[i]); subsetsWithDup(res, nums, vec, i + 1); vec.pop_back(); &#125; &#125;&#125;; 我的代码实现 加入了sort，防止nums={4，4，1，4}这种情况 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; subs; vector&lt;int&gt; sub; if(nums.empty()) return subs; sort(nums.begin(), nums.end()); dfs(subs, sub, 0, nums); return subs; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; subs, vector&lt;int&gt;&amp; sub, int k, vector&lt;int&gt;&amp; nums)&#123; subs.push_back(sub); for(int i=k; i&lt;nums.size(); i++)&#123; if(i!=k &amp;&amp; nums[i]==nums[i-1]) continue; sub.push_back(nums[i]); dfs(subs, sub, i+1, nums); sub.pop_back(); &#125; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs; vector&lt;int&gt; sub; dfs(nums, sub, subs, 0); return subs; &#125; void dfs(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; sub, vector&lt;vector&lt;int&gt;&gt;&amp; subs, int k)&#123; subs.push_back(sub); for(int i=k; i&lt;nums.size(); i++)&#123; if(i!=k &amp;&amp; nums[i]==nums[i-1]) continue; sub.push_back(nums[i]); dfs(nums, sub, subs, i+1); sub.pop_back(); &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/4661/c-solution-and-explanation C++ solution and explanation To solve this problem, it is helpful to first think how many subsets are there. If there is no duplicate element, the answer is simply 2^n, where n is the number of elements. This is because you have two choices for each element, either putting it into the subset or not. So all subsets for this no-duplicate set can be easily constructed:num of subset (1 to 2^0) empty set is the first subset (2^0+1 to 2^1) add the first element into subset from (1) (2^1+1 to 2^2) add the second element into subset (1 to 2^1) (2^2+1 to 2^3) add the third element into subset (1 to 2^2) …. (2^(n-1)+1 to 2^n) add the nth element into subset(1 to 2^(n-1)) Then how many subsets are there if there are duplicate elements? We can treat duplicate element as a spacial element. For example, if we have duplicate elements (5, 5), instead of treating them as two elements that are duplicate, we can treat it as one special element 5, but this element has more than two choices: you can either NOT put it into the subset, or put ONE 5 into the subset, or put TWO 5s into the subset. Therefore, we are given an array (a1, a2, a3, …, an) with each of them appearing (k1, k2, k3, …, kn) times, the number of subset is (k1+1)(k2+1)…(kn+1). We can easily see how to write down all the subsets similar to the approach above. 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; subsetsWithDup(vector&lt;int&gt; &amp;S) &#123; vector&lt;vector&lt;int&gt; &gt; totalset = &#123;&#123;&#125;&#125;; sort(S.begin(),S.end()); for(int i=0; i&lt;S.size();)&#123; int count = 0; // num of elements are the same while(count + i&lt;S.size() &amp;&amp; S[count+i]==S[i]) count++; int previousN = totalset.size(); for(int k=0; k&lt;previousN; k++)&#123; vector&lt;int&gt; instance = totalset[k]; for(int j=0; j&lt;count; j++)&#123; instance.push_back(S[i]); totalset.push_back(instance); &#125; &#125; i += count; &#125; return totalset; &#125;&#125;; https://discuss.leetcode.com/topic/3601/simple-iterative-solution Simple iterative solution If we want to insert an element which is a dup, we can only insert it after the newly inserted elements from last step. 123456789101112131415vector&lt;vector&lt;int&gt; &gt; subsetsWithDup(vector&lt;int&gt; &amp;S) &#123; sort(S.begin(), S.end()); vector&lt;vector&lt;int&gt;&gt; ret = &#123;&#123;&#125;&#125;; int size = 0, startIndex = 0; for (int i = 0; i &lt; S.size(); i++) &#123; startIndex = i &gt;= 1 &amp;&amp; S[i] == S[i - 1] ? size : 0; size = ret.size(); for (int j = startIndex; j &lt; size; j++) &#123; vector&lt;int&gt; temp = ret[j]; temp.push_back(S[i]); ret.push_back(temp); &#125; &#125; return ret;&#125; python https://discuss.leetcode.com/topic/8541/simple-python-solution-without-extra-space Simple python solution without extra space. 123456789101112class Solution: # @param num, a list of integer # @return a list of lists of integer def subsetsWithDup(self, S): res = [[]] S.sort() for i in range(len(S)): if i == 0 or S[i] != S[i - 1]: l = len(res) for j in range(len(res) - l, len(res)): res.append(res[j] + [S[i]]) return res if S[i] is same to S[i - 1], then it needn’t to be added to all of the subset, just add it to the last l subsets which are created by adding S[i - 1] java https://discuss.leetcode.com/topic/22638/very-simple-and-fast-java-solution Very simple and fast java solution 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; each = new ArrayList&lt;&gt;(); helper(res, each, 0, nums); return res;&#125;public void helper(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; each, int pos, int[] n) &#123; if (pos &lt;= n.length) &#123; res.add(each); &#125; int i = pos; while (i &lt; n.length) &#123; each.add(n[i]); helper(res, new ArrayList&lt;&gt;(each), i + 1, n); each.remove(each.size() - 1); i++; while (i &lt; n.length &amp;&amp; n[i] == n[i - 1]) &#123;i++;&#125; &#125; return;&#125; The Basic idea is: use “while (i &lt; n.length &amp;&amp; n[i] == n[i - 1]) {i++;}” to avoid the duplicate. For example, the input is 2 2 2 3 4. Consider the helper function. The process is: each.add(n[i]); –&gt; add first 2 (index 0) helper(res, new ArrayList&lt;&gt;(each), i + 1, n); –&gt; go to recursion part, list each is while (i &lt; n.length &amp;&amp; n[i] == n[i - 1]) {i++;} –&gt; after this, i == 3, add the element as in subset I https://discuss.leetcode.com/topic/16666/standard-dfs-java-solution Standard DFS Java Solution 123456789101112131415161718public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result= new ArrayList&lt;&gt;(); dfs(nums,0,new ArrayList&lt;Integer&gt;(),result); return result; &#125; public void dfs(int[] nums,int index,List&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; result)&#123; result.add(path); for(int i=index;i&lt;nums.length;i++)&#123; if(i&gt;index&amp;&amp;nums[i]==nums[i-1]) continue; List&lt;Integer&gt; nPath= new ArrayList&lt;&gt;(path); nPath.add(nums[i]); dfs(nums,i+1,nPath,result); &#125; &#125;&#125; https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; 12345678910111213141516171819public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i=start; i&lt;nums.length; i++)&#123; if(i==start || nums[i] != nums[i-1])&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i+1); tempList.remove(tempList.size()-1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[089. Gray Code]]></title>
    <url>%2Fp%2F57e82460%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/gray-code/ The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. 123456For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:00 - 001 - 111 - 310 - 2 Note: For a given n, a gray code sequence is not uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence according to the above definition. For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that. java https://discuss.leetcode.com/topic/8557/an-accepted-three-line-solution-in-java An accepted three line solution in JAVA 12345public List&lt;Integer&gt; grayCode(int n) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; 1&lt;&lt;n; i++) result.add(i ^ i&gt;&gt;1); return result;&#125; The idea is simple. G(i) = i^ (i/2). 1ms, September 20, 2016 https://discuss.leetcode.com/topic/3021/share-my-solution Share my solution My idea is to generate the sequence iteratively. For example, when n=3, we can get the result based on n=2.00,01,11,10 -&gt; (000,001,011,010 ) (110,111,101,100). The middle two numbers only differ at their highest bit, while the rest numbers of part two are exactly symmetric of part one. It is easy to see its correctness. Code is simple: 123456789101112public class Solution &#123; public List&lt;Integer&gt; grayCode(int n) &#123; List&lt;Integer&gt; rs = new ArrayList&lt;Integer&gt;(); rs.add(0); for(int i=0; i&lt;n; i++)&#123; int size = rs.size(); for(int k=size-1; k&gt;=0; k--) rs.add(rs.get(k) | 1&lt;&lt;i); &#125; return rs; &#125;&#125; cpp 3ms, 38.18%, September 20, 2016 https://discuss.leetcode.com/topic/1011/what-is-the-best-solution-for-gray-code-problem-no-extra-space-used-and-no-recursion What is the best solution for Gray Code problem? No extra space used and no recursion? I have a solution here which takes O(1) on space and no recursion used. Is this the best possible solution? (I combined the base cases in the loop as mike3 does. Thanks mike3!) 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; result(1, 0); for(int i=0; i&lt;n; i++)&#123; int curCount = result.size(); while(curCount)&#123; curCount--; int curNum = result[curCount]; curNum += (1&lt;&lt;i); result.push_back(curNum); &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/3997/share-my-simple-way-of-this-problem-_ Share my simple way of this problem^_^ 12345678910111213class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; int N(1 &lt;&lt; n), tmp; vector&lt;int&gt; result; for(int i(0); i &lt; N; i++) &#123; tmp = i &lt;&lt; 1; result.push_back((tmp^i) &gt;&gt; 1); &#125; return result; &#125;&#125;; As we known: 1Gi = Bi+1 xor Bi For example, trans binay ‘001’ to gray code: 1tmp = 001 &lt;&lt; 1 then, 1234bin 0 0 0 1tmp 0 0 1 0-xor------------ 0 0 1 1 and the gray code is: 10 0 1 1 &gt;&gt; 1 (ignore last bit) =&gt; 0 0 1 https://discuss.leetcode.com/topic/14776/4ms-simple-iterative-solution 4ms simple iterative solution 1234567891011vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; result = &#123; 0 &#125;; int t = 1; for(int i = 0; i&lt;n; i++) &#123; for(int j = result.size() - 1; j &gt;= 0; j--) result.push_back(result[j]^t); t &lt;&lt;= 1; &#125; return result;&#125; python 52ms, September 20, 2016 https://discuss.leetcode.com/topic/4883/one-liner-python-solution-with-demo-in-comments One-liner Python solution (with demo in comments) All you need is a bit of careful thought. Btw, it’s extremely useful to write down your thought/demo in comments before you actually start to write the code, especially during interview. Even if you do not solve the problem finally, the interviewer at least get to know what you’re thinking. And if you don’t get the problem right, he/she will have a chance to correct you. 1234567891011121314151617181920class Solution: # @return a list of integers &apos;&apos;&apos; from up to down, then left to right 0 1 11 110 10 111 101 100 start: [0] i = 0: [0, 1] i = 1: [0, 1, 3, 2] i = 2: [0, 1, 3, 2, 6, 7, 5, 4] &apos;&apos;&apos; def grayCode(self, n): results = [0] for i in range(n): results += [x + pow(2, i) for x in reversed(results)] return results]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[088. Merge Sorted Array]]></title>
    <url>%2Fp%2F505da9dc%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/merge-sorted-array/ Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 方法一： 常规解法，双指针分别指向尾部，从后向前，依次进行。 1234567891011121314151617class Solution &#123;public: void merge(int A[], int m, int B[], int n) &#123; int i=m-1; int j=n-1; int k = m+n-1; while(i &gt;=0 &amp;&amp; j&gt;=0) &#123; if(A[i] &gt; B[j]) A[k--] = A[i--]; else A[k--] = B[j--]; &#125; while(j&gt;=0) A[k--] = B[j--]; &#125;&#125;; 方法二： 类似于1，但是要思考清楚其中的逻辑。 j&gt;=0是必要条件，j &lt; 0就不进行循环了 对于i&gt;=0，并且nums1大的选择它，否则nums2 123456789class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int i = m - 1, j = n - 1, tar = m + n - 1; while (j &gt;= 0) &#123; nums1[tar--] = i &gt;= 0 &amp;&amp; nums1[i] &gt; nums2[j] ? nums1[i--] : nums2[j--]; &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/2461/this-is-my-ac-code-may-help-you This is my AC code, may help you 1234567891011121314151617class Solution &#123;public: void merge(int A[], int m, int B[], int n) &#123; int i=m-1; int j=n-1; int k = m+n-1; while(i &gt;=0 &amp;&amp; j&gt;=0) &#123; if(A[i] &gt; B[j]) A[k--] = A[i--]; else A[k--] = B[j--]; &#125; while(j&gt;=0) A[k--] = B[j--]; &#125;&#125;; https://discuss.leetcode.com/topic/16946/4ms-c-solution-with-single-loop 4ms C++ solution with single loop This code relies on the simple observation that once all of the numbers from nums2 have been merged into nums1, the rest of the numbers in nums1 that were not moved are already in the correct place. 123456789class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int i = m - 1, j = n - 1, tar = m + n - 1; while (j &gt;= 0) &#123; nums1[tar--] = i &gt;= 0 &amp;&amp; nums1[i] &gt; nums2[j] ? nums1[i--] : nums2[j--]; &#125; &#125;&#125;; 4ms, 10.91%, April.23rd, 2016 12345678910class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int ia = m - 1, ib = n - 1, ic = m + n - 1; while(ia &gt;= 0 &amp;&amp; ib &gt;= 0)&#123; nums1[ic--] = nums1[ia] &gt; nums2[ib] ? nums1[ia--] : nums2[ib--]; &#125; while(ib &gt;= 0) nums1[ic--] = nums2[ib--]; &#125;&#125;; 4ms, 10.91%, April.23rd, 2016 1234567class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; for(int i=m-1, j=n-1, k=m+n-1; j&gt;=0; ) nums1[k--] = i&gt;=0 &amp;&amp; nums1[i]&gt;nums2[j]? nums1[i--]: nums2[j--]; &#125;&#125;; https://discuss.leetcode.com/topic/11508/1-line-solution 1 Line Solution 1while(n&gt;0) A[m+n-1] = (m==0||B[n-1] &gt; A[m-1]) ? B[--n] : A[--m]; https://discuss.leetcode.com/topic/35761/2-lines-very-simple-c-solution 2 lines very simple C++ solution 1234void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; for(int i=m-1, j=n-1, k=m+n-1; j&gt;=0; ) nums1[k--] = i&gt;=0 &amp;&amp; nums1[i]&gt;nums2[j]? nums1[i--]: nums2[j--];&#125; python 52ms, 33.16%, April.23rd, 2016 https://leetcode.com/discuss/47608/beautiful-python-solution Beautiful Python Solution 123456789101112131415161718class Solution(object): def merge(self, nums1, m, nums2, n): &quot;&quot;&quot; :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. &quot;&quot;&quot; while m &gt; 0 and n &gt; 0: if nums1[m-1] &gt;= nums2[n-1]: nums1[m+n-1] = nums1[m-1] m -= 1 else: nums1[m+n-1] = nums2[n-1] n -= 1 if n &gt; 0: nums1[:n] = nums2[:n] java https://discuss.leetcode.com/topic/10257/3-line-java-solution 3 line Java Solution 12345public void merge(int A[], int m, int B[], int n) &#123; int i=m-1, j=n-1, k=m+n-1; while (i&gt;-1 &amp;&amp; j&gt;-1) A[k--]= (A[i]&gt;B[j]) ? A[i--] : B[j--]; while (j&gt;-1) A[k--]=B[j--];&#125; https://discuss.leetcode.com/topic/11919/share-my-accepted-java-solution Share my accepted Java solution! 1234567891011public class Solution &#123; public void merge(int A[], int m, int B[], int n) &#123; int i = m - 1, j = n - 1, k = m + n - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; A[k--] = A[i] &gt; B[j] ? A[i--] : B[j--]; &#125; while(j &gt;= 0) &#123; A[k--] = B[j--]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[087. Scramble String]]></title>
    <url>%2Fp%2Fae9f5ec9%2F</url>
    <content type="text"><![CDATA[29.2% https://leetcode.com/problems/scramble-string/ Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. 123456789Below is one possible representation of s1 = &quot;great&quot;: great / \ gr eat / \ / \g r e at / \ a t To scramble the string, we may choose any non-leaf node and swap its two children. 12345678910For example, if we choose the node &quot;gr&quot; and swap its two children, it produces a scrambled string &quot;rgeat&quot;. rgeat / \ rg eat / \ / \r g e at / \ a tWe say that &quot;rgeat&quot; is a scrambled string of &quot;great&quot;. 12345678910Similarly, if we continue to swap the children of nodes &quot;eat&quot; and &quot;at&quot;, it produces a scrambled string &quot;rgtae&quot;. rgtae / \ rg tae / \ / \r g ta e / \ t aWe say that &quot;rgtae&quot; is a scrambled string of &quot;great&quot;. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. 方法一： 递归， 根据题意来进行判断。判断时排除字符个数都不相同的情况。 然后考虑各个叶子节点的交换。 3ms, 85.03%, September 22, 2016 https://discuss.leetcode.com/topic/14337/share-my-4ms-c-recursive-solution Share my 4ms c++ recursive solution Assume the strings are all lower case letters 123456789101112131415161718192021222324252627class Solution &#123;public: bool isScramble(string s1, string s2) &#123; if(s1 == s2) return true; int len = s1.length(); int count[26] = &#123;0&#125;; for(int i=0; i&lt;len; i++)&#123; count[s1[i]-&apos;a&apos;]++; count[s2[i]-&apos;a&apos;]--; &#125; for(int i=0; i&lt;26; i++)&#123; if(count[i]!=0) return false; &#125; for(int i=1; i&lt;=len-1; i++)&#123; if(isScramble(s1.substr(0, i), s2.substr(0, i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i))) return true; if(isScramble(s1.substr(0, i), s2.substr(len-i)) &amp;&amp; isScramble((s1.substr(i)), s2.substr(0, len-i))) return true; &#125; return false; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526class Solution &#123;public: bool isScramble(string s1, string s2) &#123; if(s1==s2) return true; int m = s1.size(), n = s2.size(); if(m!=n) return false; vector&lt;int&gt; v(26, 0); for(int i=0; i&lt;m; i++)&#123; v[s1[i]-'a']++; v[s2[i]-'a']--; &#125; // 下面是i&lt;26不是i&lt;m, 不要手误 for(int i=0; i&lt;26; i++) if(v[i]!=0) return false; for(int i=1; i&lt;m; i++)&#123; // substr(0, i)从index=0开始，顺着i个，及0至i-1。substr(i)从index=i的字符串 if(isScramble(s1.substr(0, i), s2.substr(0, i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i))) return true; // 下面是m-i，表明s1的前i个与s2的后i个是否相等 if(isScramble(s1.substr(0, i), s2.substr(m-i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(0, m-i))) return true; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/20094/my-c-solutions-recursion-with-cache-dp-recursion-with-cache-and-pruning-with-explanation-4ms My C++ solutions (recursion with cache , DP, recursion with cache and pruning) with explanation (4ms) The basic idea is to divide s1(s2) into two substrings with length k and len-k and check if the two substrings s1[0..k-1] and s1[k, len-1] are the scrambles of s2[0..k-1] and s2[k,len-1] or s2[len-k, len-1] and s2[0..len-k-1] via recursion. The straigtforward recursion will be very slow due to many repeated recursive function calls. To speed up the recursion, we can use an unordered_map isScramblePair to save intermediate results. The key used here is s1+s2, but other keys are also possible (e.g. using indices) 123456789101112131415161718192021222324252627282930class Solution &#123; bool DP_helper(unordered_map&lt;string, bool&gt; &amp;isScramblePair, string s1, string s2) &#123; int i,len = s1.size(); bool res = false; if(0==len) return true; else if(1==len) return s1 == s2; else &#123; if(isScramblePair.count(s1+s2)) return isScramblePair[s1+s2]; // checked before, return intermediate result directly if(s1==s2) res=true; else&#123; for(i=1; i&lt;len &amp;&amp; !res; ++i) &#123;//check s1[0..i-1] with s2[0..i-1] and s1[i..len-1] and s2[i..len-1] res = res || (DP_helper(isScramblePair, s1.substr(0,i), s2.substr(0,i)) &amp;&amp; DP_helper(isScramblePair, s1.substr(i,len-i), s2.substr(i,len-i))); //if no match, then check s1[0..i-1] with s2[len-k.. len-1] and s1[i..len-1] and s2[0..len-i] res = res || (DP_helper(isScramblePair, s1.substr(0,i), s2.substr(len-i,i)) &amp;&amp; DP_helper(isScramblePair, s1.substr(i,len-i), s2.substr(0,len-i))); &#125; &#125; return isScramblePair[s1+s2]= res; //save the intermediate results &#125; &#125; public: bool isScramble(string s1, string s2) &#123; unordered_map&lt;string, bool&gt; isScramblePair; return DP_helper(isScramblePair, s1, s2); &#125; &#125;; The recursive version has exponential complexity. To further improve the performance, we can use bottom-up DP, which is O(N^4) complexity. Here we build a table isS[len][i][j], which indicates whether s1[i..i+len-1] is a scramble of s2[j..j+len-1]. 123456789101112131415161718192021222324252627class Solution &#123;public: bool isScramble(string s1, string s2) &#123; int sSize = s1.size(), len, i, j, k; if(0==sSize) return true; if(1==sSize) return s1==s2; bool isS[sSize+1][sSize][sSize]; for(i=0; i&lt;sSize; ++i) for(j=0; j&lt;sSize; ++j) isS[1][i][j] = s1[i] == s2[j]; for(len=2; len &lt;=sSize; ++len) for(i=0; i&lt;=sSize-len; ++i) for(j=0; j&lt;=sSize-len; ++j) &#123; isS[len][i][j] = false; for(k=1; k&lt;len &amp;&amp; !isS[len][i][j]; ++k) &#123; isS[len][i][j] = isS[len][i][j] || (isS[k][i][j] &amp;&amp; isS[len-k][i+k][j+k]); isS[len][i][j] = isS[len][i][j] || (isS[k][i+len-k][j] &amp;&amp; isS[len-k][i][j+k]); &#125; &#125; return isS[sSize][0][0]; &#125;&#125;; Furhtermore, in many cases, we found we can terminate our recursion early by pruning: i.e. by first checking if s1 and s2 have the same character set before we do recursion: if not, just terminate without recursion. This observation leads us to the following Recursion+cache+pruning version. Here the key of the cache changes to idx1sSize +idx2 + lensSize*sSize; 123456789101112131415161718192021222324252627282930313233class Solution &#123;private: bool DP_helper(string &amp;s1, string &amp;s2, int idx1, int idx2, int len, char isS[]) &#123; int sSize = s1.size(),i, j, k, hist[26] , zero_count =0; if(isS[(len*sSize+idx1)*sSize+idx2]) return isS[(len*sSize+idx1)*sSize+idx2]==1; bool res = false; fill_n(hist, 26, 0); for(k=0; k&lt;len;++k) &#123; // check if s1[idx1:idx1+len-1] and s2[idx2:idx2+len-1] have same characters zero_count += (0==hist[s1[idx1+k]-&apos;a&apos;]) - (0== ++hist[s1[idx1+k]-&apos;a&apos;]); zero_count += (0==hist[s2[idx2+k]-&apos;a&apos;]) - (0== --hist[s2[idx2+k]-&apos;a&apos;]); &#125; if(zero_count) &#123;isS[(len*sSize+idx1)*sSize+idx2] = 2; return false;&#125; //if not, return directly if(len==1) &#123;isS[(len*sSize+idx1)*sSize+idx2] = 1; return true;&#125; for(k=1;k&lt;len &amp;&amp; !res;++k) //otherwise, recursion with cache &#123; res = res || (DP_helper(s1, s2, idx1, idx2, k, isS) &amp;&amp; DP_helper(s1, s2, idx1+k, idx2+k, len-k, isS) ); res = res || (DP_helper(s1, s2, idx1+len-k, idx2, k, isS) &amp;&amp; DP_helper(s1, s2, idx1, idx2+k, len-k, isS) ); &#125; isS[(len*sSize+idx1)*sSize+idx2] = res?1:2; return res; &#125;public: bool isScramble(string s1, string s2) &#123; const int sSize = s1.size(); if(0==sSize) return true; char isS[(sSize+1)*sSize*sSize]; fill_n(isS, (sSize+1)*sSize*sSize, 0); return DP_helper(s1, s2, 0, 0, sSize, isS); &#125;&#125;; https://discuss.leetcode.com/topic/1195/any-better-solution Any better solution? My AC code is as below. I think it’s not very efficient. Is there any better solution? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;private: bool anagram(string &amp;s1, string &amp;s2)&#123; if(s1.size() != s2.size()) return false; unordered_map&lt;char, int&gt; m; int n = s1.size(); for(int i = 0; i &lt; n; ++i)&#123; if(m.find(s1[i]) != m.end())&#123; ++m[s1[i]]; &#125;else&#123; m[s1[i]] = 1; &#125; &#125; for(int i = 0; i &lt; n; ++i)&#123; if(m.find(s2[i]) != m.end())&#123; --m[s2[i]]; if(m[s2[i]] &lt; 0)&#123; return false; &#125; &#125;else&#123; return false; &#125; &#125; return true; &#125;public: bool isScramble(string s1, string s2) &#123; if(s1.size() != s2.size()) return false; if(s1 == s2) return true; int n = s1.size(); for(int i = 1; i &lt; n; ++i)&#123; string s11 = s1.substr(0, i); string s12 = s1.substr(i, n - i); string s21 = s2.substr(0, i); string s22 = s2.substr(i, n - i); string s23 = s2.substr(n - i, i); string s24 = s2.substr(0, n - i); if(anagram(s11, s21) &amp;&amp; anagram(s12, s22) &amp;&amp; isScramble(s11, s21) &amp;&amp; isScramble(s12, s22) || anagram(s11, s23) &amp;&amp; anagram(s12, s24) &amp;&amp; isScramble(s11, s23) &amp;&amp; isScramble(s12, s24))&#123; return true; &#125; &#125; return false; &#125;&#125;; The main idea is: separate s1 into two parts, namely –s11–, ——–s12——– separate s2 into two parts, namely –s21–, ——–s22——–, and test the corresponding part (s11 and s21 &amp;&amp; s12 and s22) with isScramble. separate s2 into two parts, namely ——–s23——–, –s24–, and test the corresponding part (s11 and s24 &amp;&amp; s12 and s23) with isScramble. Note that before testing each sub-part with isScramble, anagram is used first to test if the corresponding parts are anagrams. If not, skip directly. https://discuss.leetcode.com/topic/8253/a-simple-solution-without-dp-in-c A simple solution without dp in C++ 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isScramble(string s1, string s2) &#123; int n = s1.length(); return judge(s1.c_str(), s2.c_str(), 0, n-1, 0, n-1); &#125; bool judge(const char* s1, const char* s2,int a,int b,int u, int v)&#123; if(b-a!=v-u) return false; if(b-a==0 &amp;&amp; s1[a]==s2[u]) return true; int cnt[256]=&#123;0&#125;; for(int i=a;i&lt;=b;++i)&#123; cnt[s1[i]]++; &#125; for(int i=u;i&lt;=v;++i)&#123; cnt[s2[i]]--; &#125; for(int i=0;i&lt;256;++i)&#123; if(cnt[i]!=0) return false; &#125; for(int i=a;i&lt;b;++i)&#123; if(judge(s1,s2,a,i,u,u+i-a) &amp;&amp; judge(s1,s2,i+1,b,v-(b-i-1),v))&#123; return true; &#125; if(judge(s1,s2,a,i,v-(i-a),v) &amp;&amp; judge(s1,s2,i+1,b,u,u+b-(i+1)))&#123; return true; &#125; &#125; return false; &#125;&#125;; Surprisingly, it runs very fast even without dynamic programming. python https://discuss.leetcode.com/topic/9726/python-recursive-solution Python recursive solution 1234567891011121314class Solution:# @return a booleandef isScramble(self, s1, s2): n, m = len(s1), len(s2) if n != m or sorted(s1) != sorted(s2): return False if n &lt; 4 or s1 == s2: return True f = self.isScramble for i in range(1, n): if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \ f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]): return True return False java 4ms, 91.08%, September 22, 2016 https://discuss.leetcode.com/topic/19158/accepted-java-solution Accepted Java solution 1234567891011121314151617181920public class Solution &#123; public boolean isScramble(String s1, String s2) &#123; if (s1.equals(s2)) return true; int[] letters = new int[26]; for (int i=0; i&lt;s1.length(); i++) &#123; letters[s1.charAt(i)-&apos;a&apos;]++; letters[s2.charAt(i)-&apos;a&apos;]--; &#125; for (int i=0; i&lt;26; i++) if (letters[i]!=0) return false; for (int i=1; i&lt;s1.length(); i++) &#123; if (isScramble(s1.substring(0,i), s2.substring(0,i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) return true; if (isScramble(s1.substring(0,i), s2.substring(s2.length()-i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(0,s2.length()-i))) return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[086. Partition List]]></title>
    <url>%2Fp%2Fdc466425%2F</url>
    <content type="text"><![CDATA[32.7% https://leetcode.com/problems/partition-list/ Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. 123For example,Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 方法一： 建立一个哑结点，这是这个方法的高明之处。 6ms, 29.86%, September 20, 2016 https://discuss.leetcode.com/topic/7005/very-concise-one-pass-solution 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; ListNode node1(0), node2(0); ListNode *p1 = &amp;node1, *p2 = &amp;node2; while(head)&#123; if(head-&gt;val &lt; x) p1 = p1-&gt;next = head; else p2 = p2 -&gt;next = head; head = head-&gt;next; &#125; p2-&gt;next = NULL; p1-&gt;next = node2.next; return node1.next; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; ListNode node1(0), node2(0); ListNode* p1 = &amp;node1, *p2 = &amp;node2; while(head)&#123; if(head-&gt;val &lt; x)&#123; p1-&gt;next = head; p1 = p1-&gt;next; &#125;else&#123; p2-&gt;next = head; p2 = p2-&gt;next; &#125; head = head-&gt;next; &#125; p1-&gt;next = node2.next; //此处用的是.,而不是-&gt;,为什么？ p2-&gt;next = NULL; return node1.next; // 此处也是.,不是-&gt;，因为不是指针？ &#125;&#125;; python 65ms, September 20, 2016 https://discuss.leetcode.com/topic/21417/python-concise-solution-with-dummy-nodes 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def partition(self, head, x): &quot;&quot;&quot; :type head: ListNode :type x: int :rtype: ListNode &quot;&quot;&quot; h1 = l1 = ListNode(0) h2 = l2 = ListNode(0) while head: if head.val &lt; x: l1.next = head l1 = l1.next else: l2.next = head l2 = l2.next head = head.next l2.next = None l1.next = h2.next return h1.next java 1ms, 4.45%, September 20, 2016 https://discuss.leetcode.com/topic/7795/concise-java-code-with-explanation-one-pass 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode partition(ListNode head, int x) &#123; ListNode dummy1 = new ListNode(0), dummy2 = new ListNode(0); ListNode curr1 = dummy1, curr2 = dummy2; while(head!=null)&#123; if(head.val&lt;x)&#123; curr1.next = head; curr1 = head; &#125;else&#123; curr2.next = head; curr2 = head; &#125; head = head.next; &#125; curr2.next = null; curr1.next = dummy2.next; return dummy1.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>two pointers</tag>
        <tag>medium</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[085. Maximal Rectangle]]></title>
    <url>%2Fp%2Fba45e9ed%2F</url>
    <content type="text"><![CDATA[26.6% https://leetcode.com/problems/maximal-rectangle/ Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area. 1234567For example, given the following matrix:1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Return 6. 方法一: 9ms, 93.96%, September 23, 2016 https://discuss.leetcode.com/topic/6650/share-my-dp-solution Share my DP solution The DP solution proceeds row by row, starting from the first row. Let the maximal rectangle area at row i and column j be computed by [right(i,j) - left(i,j)]*height(i,j). All the 3 variables left, right, and height can be determined by the information from previous row, and also information from the current row. So it can be regarded as a DP solution. The transition equations are: 1234left(i,j) = max(left(i-1,j), cur_left), cur_left can be determined from the current rowright(i,j) = min(right(i-1,j), cur_right), cur_right can be determined from the current rowheight(i,j) = height(i-1,j) + 1, if matrix[i][j]==&apos;1&apos;;height(i,j) = 0, if matrix[i][j]==&apos;0&apos; The code is as below. The loops can be combined for speed but I separate them for more clarity of the algorithm. 123456789101112131415161718192021222324252627282930class Solution &#123;public:int maximalRectangle(vector&lt;vector&lt;char&gt; &gt; &amp;matrix) &#123; if(matrix.empty()) return 0; const int m = matrix.size(); const int n = matrix[0].size(); int left[n], right[n], height[n]; fill_n(left,n,0); fill_n(right,n,n); fill_n(height,n,0); int maxA = 0; for(int i=0; i&lt;m; i++) &#123; int cur_left=0, cur_right=n; for(int j=0; j&lt;n; j++) &#123; // compute height (can do this from either side) if(matrix[i][j]==&apos;1&apos;) height[j]++; else height[j]=0; &#125; for(int j=0; j&lt;n; j++) &#123; // compute left (from left to right) if(matrix[i][j]==&apos;1&apos;) left[j]=max(left[j],cur_left); else &#123;left[j]=0; cur_left=j+1;&#125; &#125; // compute right (from right to left) for(int j=n-1; j&gt;=0; j--) &#123; if(matrix[i][j]==&apos;1&apos;) right[j]=min(right[j],cur_right); else &#123;right[j]=n; cur_right=j;&#125; &#125; // compute the area of rectangle (can do this from either side) for(int j=0; j&lt;n; j++) maxA = max(maxA,(right[j]-left[j])*height[j]); &#125; return maxA;&#125;&#125;; If you think this algorithm is not easy to understand, you can try this example: 1230 0 0 1 0 0 0 0 0 1 1 1 0 0 0 1 1 1 1 1 0 The vector “left” and “right” from row 0 to row 2 are as follows row 0: 12l: 0 0 0 3 0 0 0r: 7 7 7 4 7 7 7 row 1: 12l: 0 0 2 3 2 0 0r: 7 7 5 4 5 7 7 row 2: 12l: 0 1 2 3 2 1 0r: 7 6 5 4 5 6 7 The vector “left” is computing the left boundary. Take (i,j)=(1,3) for example. On current row 1, the left boundary is at j=2. However, because matrix[1][3] is 1, you need to consider the left boundary on previous row as well, which is 3. So the real left boundary at (1,3) is 3. I hope this additional explanation makes things clearer. https://discuss.leetcode.com/topic/5806/sharing-my-straightforward-c-solution-with-o-n-2-time-with-explanation Sharing my straightforward C++ solution with O(n^2) time with explanation 12345678910111213141516171819202122232425262728293031323334353637int maximalRectangle(vector&lt;vector&lt;char&gt; &gt; &amp;matrix) &#123; if(matrix.empty())&#123; return 0; &#125; int maxRec = 0; vector&lt;int&gt; height(matrix[0].size(), 0); for(int i = 0; i &lt; matrix.size(); i++)&#123; for(int j = 0; j &lt; matrix[0].size(); j++)&#123; if(matrix[i][j] == &apos;0&apos;)&#123; height[j] = 0; &#125; else&#123; height[j]++; &#125; &#125; maxRec = max(maxRec, largestRectangleArea(height)); &#125; return maxRec;&#125;int largestRectangleArea(vector&lt;int&gt; &amp;height) &#123; stack&lt;int&gt; s; height.push_back(0); int maxSize = 0; for(int i = 0; i &lt; height.size(); i++)&#123; if(s.empty() || height[i] &gt;= height[s.top()])&#123; s.push(i); &#125; else&#123; int temp = height[s.top()]; s.pop(); maxSize = max(maxSize, temp * (s.empty() ? i : i - 1 - s.top())); i--; &#125; &#125; return maxSize;&#125; In order to solve this problem, I use the solution from “Largest Rectangle in Histogram”. Now I assume you already know how to solve “Largest Rectangle in Histogram”. We can regard a matrix as many histograms. For example, given a matrix below: 1 0 1 0 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 1 From top to bottom, we can find these histograms: Number 1: 1 0 1 0 Number 2: 0 1 0 1 Number 3: 0 2 1 0 Number 4: 1 0 2 0 Number 5: 2 0 3 1 Pass all of these histograms to the function which can solve “Largest Rectangle in Histogram”. And then find the maximum one. Finally, we get the answer. https://discuss.leetcode.com/topic/1122/my-o-n-3-solution-for-your-reference My O(n^3) solution for your reference 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int maximalRectangle(vector&lt;vector&lt;char&gt; &gt; &amp;matrix) &#123; int num_i=matrix.size(); if (num_i==0) return 0; int num_j=matrix[0].size(); if (num_j==0) return 0; vector&lt;vector&lt;int&gt;&gt; max_x(num_i,vector&lt;int&gt;(num_j,0)); //number of consecutive 1s to the left of matrix[i][j], including itself int area=0; for (int i=0;i&lt;num_i;i++)&#123; for (int j=0;j&lt;num_j;j++)&#123; if (matrix[i][j]==&apos;1&apos;)&#123; if (j==0) max_x[i][j]=1; else max_x[i][j]=max_x[i][j-1]+1; int y=1; int x=num_j; while((i-y+1&gt;=0)&amp;&amp;(matrix[i-y+1][j]==&apos;1&apos;))&#123; x=min(x, max_x[i-y+1][j]); area=max(area,x*y); y++; &#125; &#125; &#125; &#125; return area; &#125;&#125;; python https://discuss.leetcode.com/topic/27844/ac-python-dp-solutioin-120ms-based-on-largest-rectangle-in-histogram AC Python DP solutioin 120ms based on largest rectangle in histogram 12345678910111213141516171819202122def maximalRectangle(self, matrix): if not matrix or not matrix[0]: return 0 n = len(matrix[0]) height = [0] * (n + 1) ans = 0 for row in matrix: for i in xrange(n): height[i] = height[i] + 1 if row[i] == &apos;1&apos; else 0 stack = [-1] for i in xrange(n + 1): while height[i] &lt; height[stack[-1]]: h = height[stack.pop()] w = i - 1 - stack[-1] ans = max(ans, h * w) stack.append(i) return ans# 65 / 65 test cases passed.# Status: Accepted# Runtime: 120 ms# 100% The solution is based on largest rectangle in histogram solution. Every row in the matrix is viewed as the ground with some buildings on it. The building height is the count of consecutive 1s from that row to above rows. The rest is then the same as this solution for largest rectangle in histogram java https://discuss.leetcode.com/topic/1634/a-o-n-2-solution-based-on-largest-rectangle-in-histogram A O(n^2) solution based on Largest Rectangle in Histogram This question is similar as [Largest Rectangle in Histogram]: You can maintain a row length of Integer array H recorded its height of ‘1’s, and scan and update row by row to find out the largest rectangle of each row. For each row, if matrix[row][i] == ‘1’. H[i] +=1, or reset the H[i] to zero.and accroding the algorithm of [Largest Rectangle in Histogram], to update the maximum area. 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int maximalRectangle(char[][] matrix) &#123; if (matrix==null||matrix.length==0||matrix[0].length==0) return 0; int cLen = matrix[0].length; // column length int rLen = matrix.length; // row length // height array int[] h = new int[cLen+1]; h[cLen]=0; int max = 0; for (int row=0;row&lt;rLen;row++) &#123; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); for (int i=0;i&lt;cLen+1;i++) &#123; if (i&lt;cLen) if(matrix[row][i]==&apos;1&apos;) h[i]+=1; else h[i]=0; if (s.isEmpty()||h[s.peek()]&lt;=h[i]) s.push(i); else &#123; while(!s.isEmpty()&amp;&amp;h[i]&lt;h[s.peek()])&#123; int top = s.pop(); int area = h[top]*(s.isEmpty()?i:(i-s.peek()-1)); if (area&gt;max) max = area; &#125; s.push(i); &#125; &#125; &#125; return max; &#125;&#125; https://discuss.leetcode.com/topic/21772/my-java-solution-based-on-maximum-rectangle-in-histogram-with-explanation My java solution based on Maximum Rectangle in Histogram with explanation We can apply the maximum in histogram in each row of the 2D matrix. What we need is to maintain an int array for each row, which represent for the height of the histogram. Please refer to https://leetcode.com/problems/largest-rectangle-in-histogram/ first. Suppose there is a 2D matrix like 1 1 0 1 0 1 0 1 0 0 1 1 1 1 1 1 0 1 1 1 1 1 0 1 First initiate the height array as 1 1 0 1 0 1, which is just a copy of the first row. Then we can easily calculate the max area is 2. Then update the array. We scan the second row, when the matrix[1][i] is 0, set the height[i] to 0; else height[i] += 1, which means the height has increased by 1. So the height array again becomes 0 2 0 0 1 2. The max area now is also 2. Apply the same method until we scan the whole matrix. the last height arrays is 2 4 2 2 0 2, so the max area has been found as 2 * 4 = 8. Then reason we scan the whole matrix is that the maximum value may appear in any row of the height. Code as follows: 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123;public int maximalRectangle(char[][] matrix) &#123; if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0; int[] height = new int[matrix[0].length]; for(int i = 0; i &lt; matrix[0].length; i ++)&#123; if(matrix[0][i] == &apos;1&apos;) height[i] = 1; &#125; int result = largestInLine(height); for(int i = 1; i &lt; matrix.length; i ++)&#123; resetHeight(matrix, height, i); result = Math.max(result, largestInLine(height)); &#125; return result;&#125;private void resetHeight(char[][] matrix, int[] height, int idx)&#123; for(int i = 0; i &lt; matrix[0].length; i ++)&#123; if(matrix[idx][i] == &apos;1&apos;) height[i] += 1; else height[i] = 0; &#125;&#125; public int largestInLine(int[] height) &#123; if(height == null || height.length == 0) return 0; int len = height.length; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int maxArea = 0; for(int i = 0; i &lt;= len; i++)&#123; int h = (i == len ? 0 : height[i]); if(s.isEmpty() || h &gt;= height[s.peek()])&#123; s.push(i); &#125;else&#123; int tp = s.pop(); maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - 1 - s.peek())); i--; &#125; &#125; return maxArea;&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[084. Largest Rectangle in Histogram]]></title>
    <url>%2Fp%2F4e21238e%2F</url>
    <content type="text"><![CDATA[26.6% https://leetcode.com/problems/largest-rectangle-in-histogram/ Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. 123For example,Given heights = [2,1,5,6,2,3],return 10. 方法一: 效率o(nlogn) 我的代码实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int n = heights.size(); if(n==0) return 0; return largestArea(heights, 0, n-1); &#125; int largestArea(vector&lt;int&gt;&amp; heights, int start, int end)&#123; if(start == end) return heights[start]; int mid = start + (end-start)/2; int leftArea = largestArea(heights, start, mid); //这里必须是mid+1 不能是mid，否则不能ac // 想一想 end = left + 1, 左边是(left, left)， 右边是(left, left+1) // 右边永远无法结束 // 这个分治法的逻辑在于氛围两部分，左部分，右部分，穿越中间的部分 int rightArea = largestArea(heights, mid+1, end); int midArea = helper(heights, start, mid, end); return max(midArea, max(leftArea, rightArea)); &#125; int helper(vector&lt;int&gt;&amp; heights, int start, int mid, int end)&#123; int res = 0; int l = mid, r = mid+1, height = min(heights[l], heights[r]); while(l&gt;=start &amp;&amp; r&lt;=end)&#123; height = min(height, min(heights[l], heights[r])); res = max(res, height*(r-l+1)); if(l==start) r++; else if(r==end) l--; else&#123; if(heights[l-1]&gt;heights[r+1])&#123; l--; &#125;else&#123; r++; &#125; &#125; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/7491/simple-divide-and-conquer-ac-solution-without-segment-tree Simple Divide and Conquer AC solution without Segment Tree The idea is simple: for a given range of bars, the maximum area can either from left or right half of the bars, or from the area containing the middle two bars. For the last condition, expanding from the middle two bars to find a maximum area is O(n), which makes a typical Divide and Conquer solution with T(n) = 2T(n/2) + O(n). Thus the overall complexity is O(nlgn) for time and O(1) for space (or O(lgn) considering stack usage). Following is the code accepted with 44ms. I posted this because I didn’t find a similar solution, but only the RMQ idea which seemed less straightforward to me. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; int maxCombineArea(const vector&lt;int&gt; &amp;height, int s, int m, int e) &#123; // Expand from the middle to find the max area containing height[m] and height[m+1] int i = m, j = m+1; int area = 0, h = min(height[i], height[j]); while(i &gt;= s &amp;&amp; j &lt;= e) &#123; h = min(h, min(height[i], height[j])); area = max(area, (j-i+1) * h); if (i == s) &#123; ++j; &#125; else if (j == e) &#123; --i; &#125; else &#123; // if both sides have not reached the boundary, // compare the outer bars and expand towards the bigger side if (height[i-1] &gt; height[j+1]) &#123; --i; &#125; else &#123; ++j; &#125; &#125; &#125; return area; &#125; int maxArea(const vector&lt;int&gt; &amp;height, int s, int e) &#123; // if the range only contains one bar, return its height as area if (s == e) &#123; return height[s]; &#125; // otherwise, divide &amp; conquer, the max area must be among the following 3 values int m = s + (e-s)/2; // 1 - max area from left half int area = maxArea(height, s, m); // 2 - max area from right half area = max(area, maxArea(height, m+1, e)); // 3 - max area across the middle area = max(area, maxCombineArea(height, s, m, e)); return area; &#125;public: int largestRectangleArea(vector&lt;int&gt; &amp;height) &#123; if (height.empty()) &#123; return 0; &#125; return maxArea(height, 0, height.size()-1); &#125;&#125;; 方法二： 效率o（n） 使用栈保存index，保存比i小，但高度比ID 我的代码实现： 12345678910111213141516171819202122class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; // 学习针对某些原始输入进行一定的更改，比如后面加入0 heights.push_back(0); int res = 0; int height = 0; stack&lt;int&gt; stack; for(int i=0; i&lt;heights.size(); i++)&#123; // stack的top函数, 还有vector的back函数 // stack有top函数，没有back函数 while(stack.size() &amp;&amp; heights[stack.top()] &gt; heights[i])&#123; height = heights[stack.top()]; stack.pop(); int idx = stack.size() ? stack.top() : -1; res = max(res, (i-idx-1)*height); &#125; stack.push(i); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/3913/my-concise-c-solution-ac-90-ms My concise C++ solution, AC 90 ms I push a sentinel node back into the end of height to make the code logic more concise. 12345678910111213141516171819202122232425class Solution &#123; public: int largestRectangleArea(vector&lt;int&gt; &amp;height) &#123; int ret = 0; height.push_back(0); vector&lt;int&gt; index; for(int i = 0; i &lt; height.size(); i++) &#123; while(index.size() &gt; 0 &amp;&amp; height[index.back()] &gt;= height[i]) &#123; int h = height[index.back()]; index.pop_back(); int sidx = index.size() &gt; 0 ? index.back() : -1; if(h * (i-sidx-1) &gt; ret) ret = h * (i-sidx-1); &#125; index.push_back(i); &#125; return ret; &#125; &#125;; https://discuss.leetcode.com/topic/14406/my-concise-code-20ms-stack-based-o-n-one-trick-used My concise code (20ms, stack based, O(n)), one trick used The idea is simple, use a stack to save the index of each vector entry in a ascending order; once the current entry is smaller than the one with the index s.top(), then that means the rectangle with the height height[s.top()] ends at the current position, so calculate its area and update the maximum.The only trick I use to avoid checking whether the stack is empty (due to pop) and also avoiding emptying the stack at the end (i.e. after going through the vector, s is not empty and we have to consider those in the stack) is to put a dummy “0” at the beginning of vector “height” and the end of “height”: the first one makes sure the stack will never be empty (since all the height entries are &gt;=0) and the last one will flush all the remaining non-zero entries of the stack at the end of “for” iteration. This trick helps us keep the code concise. 1234567891011121314151617181920212223class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; height) &#123; height.insert(height.begin(),0); // dummy &quot;0&quot; added to make sure stack s will never be empty height.push_back(0); // dummy &quot;0&quot; added to clear the stack at the end int len = height.size(); int i, res = 0, idx; stack&lt;int&gt; s; // stack to save &quot;height&quot; index s.push(0); // index to the first dummy &quot;0&quot; for(i=1;i&lt;len;i++) &#123; while(height[i]&lt;height[idx = s.top()]) // if the current entry is out of order &#123; s.pop(); res = max(res, height[idx] * (i-s.top()-1) ); // note how the width is calculated, use the previous index entry &#125; s.push(i); &#125; height.erase(height.begin()); // remove two dummy &quot;0&quot; height.pop_back(); return res; &#125;&#125;; python 92ms, 71.82%, June.24th, 2016 https://leetcode.com/discuss/65647/ac-python-clean-solution-using-stack-76ms AC Python clean solution using stack 76ms 12345678910111213141516171819def largestRectangleArea(self, height): height.append(0) stack = [-1] ans = 0 for i in xrange(len(height)): while height[i] &lt; height[stack[-1]]: h = height[stack.pop()] w = i - stack[-1] - 1 ans = max(ans, h * w) stack.append(i) height.pop() return ans# 94 / 94 test cases passed.# Status: Accepted# Runtime: 76 ms# 97.34% The stack maintain the indexes of buildings with ascending height. Before adding a new building pop the building who is taller than the new one. The building popped out represent the height of a rectangle with the new building as the right boundary and the current stack top as the left boundary. Calculate its area and update ans of maximum area. Boundary is handled using dummy buildings. java https://discuss.leetcode.com/topic/7599/o-n-stack-based-java-solution O(n) stack based JAVA solution For explanation, please see http://www.geeksforgeeks.org/largest-rectangle-under-histogram/ 123456789101112131415161718public class Solution &#123; public int largestRectangleArea(int[] height) &#123; int len = height.length; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int maxArea = 0; for(int i = 0; i &lt;= len; i++)&#123; int h = (i == len ? 0 : height[i]); if(s.isEmpty() || h &gt;= height[s.peek()])&#123; s.push(i); &#125;else&#123; int tp = s.pop(); maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - 1 - s.peek())); i--; &#125; &#125; return maxArea; &#125;&#125; https://discuss.leetcode.com/topic/2424/my-modified-answer-from-geeksforgeeks-in-java My modified answer from GeeksforGeeks, in JAVA I was stuck and took an eye on Geeks4Geeks. I got the idea and tried to figure it out by myself…It takes me a lot of time to make it through…. EDITED: Now it is pretty concise…. 1234567891011121314151617181920212223242526public class Solution &#123;public int largestRectangleArea(int[] height) &#123; if (height==null) return 0;//Should throw exception if (height.length==0) return 0; Stack&lt;Integer&gt; index= new Stack&lt;Integer&gt;(); index.push(-1); int max=0; for (int i=0;i&lt;height.length;i++)&#123; //Start calculate the max value while (index.peek()&gt;-1) if (height[index.peek()]&gt;height[i])&#123; int top=index.pop(); max=Math.max(max,height[top]*(i-1-index.peek())); &#125;else break; index.push(i); &#125; while(index.peek()!=-1)&#123; int top=index.pop(); max=Math.max(max,height[top]*(height.length-1-index.peek())); &#125; return max;&#125;&#125; https://discuss.leetcode.com/topic/39151/5ms-o-n-java-solution-explained-beats-96 5ms O(n) Java solution explained (beats 96%) For any bar i the maximum rectangle is of width r - l - 1 where r - is the last coordinate of the bar to the right with height h[r] &gt;= h[i] and l - is the last coordinate of the bar to the left which height h[l] &gt;= h[i] So if for any i coordinate we know his utmost higher (or of the same height) neighbors to the right and to the left, we can easily find the largest rectangle: 1234int maxArea = 0;for (int i = 0; i &lt; height.length; i++) &#123; maxArea = Math.max(maxArea, height[i] * (lessFromRight[i] - lessFromLeft[i] - 1));&#125; The main trick is how to effectively calculate lessFromRight and lessFromLeft arrays. The trivial solution is to use O(n^2) solution and for each i element first find his left/right heighbour in the second inner loop just iterating back or forward: 123456789101112for (int i = 1; i &lt; height.length; i++) &#123; if (height[i] &gt; height[i - 1]) &#123; lessFromLeft[i] = i - 1; &#125; else &#123; int p = i - 1; while (p &gt;= 0 &amp;&amp; height[p] &gt;= height[i]) &#123; p--; &#125; lessFromLeft[i] = p; &#125; &#125; The only line change shifts this algorithm from O(n^2) to O(n) complexity: we don’t need to rescan each item to the left - we can reuse results of previous calculations and “jump” through indices in quick manner: 123while (p &gt;= 0 &amp;&amp; height[p] &gt;= height[i]) &#123; p = lessFromLeft[p];&#125; Here is the whole solution: 12345678910111213141516171819202122232425262728293031323334353637public int largestRectangleArea(int[] height) &#123; if (height == null || height.length == 0) &#123; return 0; &#125; int[] lessFromLeft = new int[height.length]; // idx of the first bar the left that is lower than current int[] lessFromRight = new int[height.length]; // idx of the first bar the right that is lower than current lessFromRight[height.length - 1] = height.length; lessFromLeft[0] = -1; for (int i = 1; i &lt; height.length; i++) &#123; if (height[i] &gt; height[i - 1]) &#123; lessFromLeft[i] = i - 1; &#125; else &#123; int p = i - 1; while (p &gt;= 0 &amp;&amp; height[p] &gt;= height[i]) p = lessFromLeft[p]; lessFromLeft[i] = p; &#125; &#125; for (int i = height.length - 2; i &gt;= 0; i--) &#123; if (height[i] &gt; height[i + 1]) &#123; lessFromRight[i] = i + 1; &#125; else &#123; int p = i + 1; while (p &lt; height.length &amp;&amp; height[p] &gt;= height[i]) p = lessFromRight[p]; lessFromRight[i] = p; &#125; &#125; int maxArea = 0; for (int i = 0; i &lt; height.length; i++) &#123; maxArea = Math.max(maxArea, height[i] * (lessFromRight[i] - lessFromLeft[i] - 1)); &#125; return maxArea;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hard</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[083. Remove Duplicates from Sorted List]]></title>
    <url>%2Fp%2Ff95633fb%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/remove-duplicates-from-sorted-list/ Given a sorted linked list, delete all duplicates such that each element appear only once. 123For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 方法一： 启示，只要比较跟前面的比较。 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* slow = head, *fast = head-&gt;next; // 要求slow &amp;&amp; slow-&gt;next 不是slow-&gt;next // 考虑问题要全面 while(slow &amp;&amp; slow-&gt;next)&#123; fast = slow-&gt;next; while(fast &amp;&amp; slow-&gt;val == fast-&gt;val) fast = fast-&gt;next; // 此处是fast 不是fast-&gt;next // 因为fast指向的是最后一个元素的下一位，而不是最后一个元素了 // 注意区分 slow-&gt;next = fast; slow = slow-&gt;next; &#125; return head; &#125;&#125;; 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* cur = head; while(cur!=NULL)&#123; ListNode* nex = cur-&gt;next; while(nex!=NULL &amp;&amp; nex-&gt;val==cur-&gt;val) nex = nex-&gt;next; cur-&gt;next = nex; cur = nex; &#125; return dummy-&gt;next; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode *cur = head; while(cur)&#123; while(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) cur-&gt;next = cur-&gt;next-&gt;next; cur = cur-&gt;next; &#125; return head; &#125;&#125;; 12ms, 80.53%, July 14th, 2016 https://discuss.leetcode.com/topic/2168/concise-solution-and-memory-freeing1234567891011121314151617181920/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode * cur = head; while(cur)&#123; while(cur-&gt;next &amp;&amp; cur-&gt;val == cur -&gt; next -&gt;val) cur -&gt;next = cur -&gt;next-&gt;next; cur = cur-&gt;next; &#125; return head; &#125;&#125;; python java 1ms, 17.66%, July 14th, 2016 https://discuss.leetcode.com/topic/14775/3-line-java-recursive-solution/2 123456789101112131415/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); return head.val == head.next.val ? head.next : head; &#125;&#125; 2ms, 5.53%, July 14th, 2016 https://discuss.leetcode.com/topic/8345/my-pretty-solution-java 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode list = head; while(list != null)&#123; if(list.next == null) break; if(list.val == list.next.val) list.next = list.next.next; else list = list.next; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[082. Remove Duplicates from Sorted List II]]></title>
    <url>%2Fp%2F89010df4%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/ Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. 123For example,Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 方法一： 8ms, 57.12%, July 14th, 2016 https://discuss.leetcode.com/topic/12892/simple-and-clear-c-recursive-solution/2 递归法 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head) return 0; if(!head-&gt;next) return head; int val = head-&gt;val; ListNode * p = head -&gt;next; if(p-&gt;val != val)&#123; head-&gt;next = deleteDuplicates(p); return head; &#125;else&#123; while(p &amp;&amp; p-&gt;val == val) p = p-&gt;next; return deleteDuplicates(p); &#125; &#125;&#125;; 方法二： 使用迭代的方法 我的代码实现： 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* slow = dummy, *fast; // 要保证slow和slow-&gt;next while(slow &amp;&amp; slow-&gt;next)&#123; fast = slow-&gt;next; while(fast-&gt;next &amp;&amp; slow-&gt;next-&gt;val == fast-&gt;next-&gt;val) fast = fast-&gt;next; if(fast!=slow-&gt;next) slow-&gt;next = fast-&gt;next; else slow = slow-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* cur = dummy; while(cur-&gt;next)&#123; ListNode* nex = cur-&gt;next; while(nex-&gt;next!=NULL &amp;&amp; nex-&gt;next-&gt;val == nex-&gt;val) nex = nex-&gt;next; if(cur-&gt;next!=nex) cur-&gt;next = nex-&gt;next; else cur = cur-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; python 72ms, 44.80%, July 14th, 2016 https://discuss.leetcode.com/topic/21369/python-in-place-solution-with-dummy-head-node/2 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteDuplicates(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; dummy = pre = ListNode(0) dummy.next = head while head and head.next: if head.val == head.next.val: while head and head.next and head.val == head.next.val: head = head.next head = head.next pre.next = head else: pre = pre.next head = head.next return dummy.next java 一个pre指针，一个cur指针，每次cur指针判断是否需要右移，如果没有移动的话，pre就向后移动，如果移动的话，建立pre与cur.next的关系。cur负责当前位置，pre负责前一个位置，每次循环，负责找出pre的next的位置。 https://discuss.leetcode.com/topic/3890/my-accepted-java-code 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head==null) return head; ListNode FakeHead = new ListNode(0); FakeHead.next = head; ListNode pre = FakeHead; ListNode cur = head; while(cur != null)&#123; while(cur.next != null &amp;&amp; cur.val == cur.next.val) cur = cur.next; if(pre.next == cur) pre = pre.next; else pre.next = cur.next; cur = cur.next; &#125; return FakeHead.next; &#125;&#125; 使用迭代的方法 if current node is not unique, return deleteDuplicates with head.next. If current node is unique, link it to the result of next list made by recursive call. https://discuss.leetcode.com/topic/5206/my-recursive-java-solution 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head == null) return null; if(head.next != null &amp;&amp; head.next.val == head.val)&#123; while(head.next!=null &amp;&amp; head.val == head.next.val) head = head.next; return deleteDuplicates(head.next); &#125;else head.next = deleteDuplicates(head.next); return head; &#125;&#125; 1ms, 20.48%, July 14th, 2016 https://discuss.leetcode.com/topic/5206/my-recursive-java-solution 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head == null) return null; if(head.next != null &amp;&amp; head.val == head.next.val)&#123; while(head.next != null &amp;&amp; head.val == head.next.val) head = head.next; return deleteDuplicates(head.next); &#125; else head.next = deleteDuplicates(head.next); return head; &#125;&#125; 1ms, 20.48%, July 14th, 2016 https://discuss.leetcode.com/topic/3890/my-accepted-java-code/2 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head==null) return null; ListNode FakeHead=new ListNode(0); FakeHead.next=head; ListNode pre=FakeHead; ListNode cur=head; while(cur!=null)&#123; while(cur.next!=null&amp;&amp;cur.val==cur.next.val)&#123; cur=cur.next; &#125; if(pre.next==cur)&#123; pre=pre.next; &#125; else&#123; pre.next=cur.next; &#125; cur=cur.next; &#125; return FakeHead.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[081. Search in Rotated Sorted Array II]]></title>
    <url>%2Fp%2Faabfef19%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/search-in-rotated-sorted-array-ii/ Follow up for “Search in Rotated Sorted Array”: What if duplicates are allowed? Would this affect the run-time complexity? How and why? Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. 1(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Write a function to determine if a given target is in the array. The array may contain duplicates. https://discuss.leetcode.com/topic/23382/medium-level-question-is-follow-up-for-a-hard-level-question Medium level question is follow up for a hard level question? It says this problem is a follow up for Search in Rotated Sorted Array. Search in Rotated Sorted Array is a hard level question. It is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions. If this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around. 方法一： 二分查找 面试奇虎360曾遇到过 beats 12.39% of cppsubmissions 我的代码实现： 对于重复的，这种是left++来实现。 1234567891011121314151617181920212223242526class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if(n==0) return false; int left = 0, right = n-1; while(left&lt;=right)&#123; int mid = left + (right-left)/2; if(nums[mid]==target) return true; if(nums[left]&lt;nums[mid])&#123; if(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid]) right = mid-1; else left = mid+1; &#125;else if(nums[left]&gt;nums[mid])&#123; if(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right]) left = mid+1; else right = mid-1; &#125;else left++; &#125; return false; &#125;&#125;; 有借鉴剑指offer 8的解法，对于left mid right三者相等的情况， 无法判断，只能顺序查找，所以单独顺序查找。 其他情况还是二分查找。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if(n==0) return false; int left = 0, right = n-1; while(left&lt;=right)&#123; int mid = left + (right-left)/2; if(nums[mid]==target) return true; if(nums[left]==nums[mid] &amp;&amp; nums[left]==nums[right])&#123; // 只能线性查找情况 return inorder_search(nums, left+1, right-1, target); &#125; if(nums[left]&lt;=nums[mid])&#123; if(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid]) right = mid-1; else left = mid+1; &#125;else if(nums[left]&gt;nums[mid])&#123; if(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right]) left = mid+1; else right = mid-1; &#125; &#125; return false; &#125; bool inorder_search(vector&lt;int&gt;&amp; nums, int left, int right, int target)&#123; if(left&gt;right) return false; for(int i=left; i&lt;=right; i++)&#123; if(nums[i]==target) return true; &#125; return false; &#125;&#125;; 其他代码实现方法 12345678910111213141516171819202122232425class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int first = 0, last = nums.size(); while(first != last)&#123; const int mid = first + (last - first) / 2; if(nums[mid] == target) return true; if(nums[first] &lt; nums[mid])&#123; if(nums[first] &lt;= target &amp;&amp; target &lt; nums[mid]) last = mid; else first = mid + 1; &#125;else if(nums[first] &gt; nums[mid])&#123; if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[last-1]) first = mid + 1; else last = mid; &#125; else // skip duplicate one first++; &#125; return false; &#125;&#125;; cpp https://discuss.leetcode.com/topic/8087/c-concise-log-n-solution C++ concise log(n) solution 12345678910111213141516171819202122class Solution &#123;public: bool search(int A[], int n, int target) &#123; int lo =0, hi = n-1; int mid = 0; while(lo&lt;hi)&#123; mid=(lo+hi)/2; if(A[mid]==target) return true; if(A[mid]&gt;A[hi])&#123; if(A[mid]&gt;target &amp;&amp; A[lo] &lt;= target) hi = mid; else lo = mid + 1; &#125;else if(A[mid] &lt; A[hi])&#123; if(A[mid]&lt;target &amp;&amp; A[hi] &gt;= target) lo = mid + 1; else hi = mid; &#125;else&#123; hi--; &#125; &#125; return A[lo] == target ? true : false; &#125;&#125;; https://discuss.leetcode.com/topic/16660/my-8ms-c-solution-o-logn-on-average-o-n-worst-case My 8ms C++ solution (o(logn) on average, o(n) worst case) The idea is the same as the previous one without duplicates 12345671) everytime check if targe == nums[mid], if so, we find it.2) otherwise, we check if the first half is in order (i.e. nums[left]&lt;=nums[mid]) and if so, go to step 3), otherwise, the second half is in order, go to step 4)3) check if target in the range of [left, mid-1] (i.e. nums[left]&lt;=target &lt; nums[mid]), if so, do search in the first half, i.e. right = mid-1; otherwise, search in the second half left = mid+1;4) check if target in the range of [mid+1, right] (i.e. nums[mid]&lt;target &lt;= nums[right]), if so, do search in the second half, i.e. left = mid+1; otherwise search in the first half right = mid-1;The only difference is that due to the existence of duplicates, we can have nums[left] == nums[mid] and in that case, the first half could be out of order (i.e. NOT in the ascending order, e.g. [3 1 2 3 3 3 3]) and we have to deal this case separately. In that case, it is guaranteed that nums[right] also equals to nums[mid], so what we can do is to check if nums[mid]== nums[left] == nums[right] before the original logic, and if so, we can move left and right both towards the middle by 1. and repeat. 123456789101112131415161718192021222324252627class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size()-1, mid; while(left&lt;=right) &#123; mid = (left + right) &gt;&gt; 1; if(nums[mid] == target) return true; // the only difference from the first one, trickly case, just updat left and right if( (nums[left] == nums[mid]) &amp;&amp; (nums[right] == nums[mid]) ) &#123;++left; --right;&#125; else if(nums[left] &lt;= nums[mid]) &#123; if( (nums[left]&lt;=target) &amp;&amp; (nums[mid] &gt; target) ) right = mid-1; else left = mid + 1; &#125; else &#123; if((nums[mid] &lt; target) &amp;&amp; (nums[right] &gt;= target) ) left = mid+1; else right = mid-1; &#125; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/19116/easy-c-solution-based-on-version-i-of-the-problem Easy C++ Solution based on Version I of the Problem For those who have already solved Search in Rotated Sorted Array, this problem can be solved similarly using codes for that problem and simply adding codes to skip the duplicates. For Search in Rotated Sorted Array, I post solutions in C/C++/Python here (C and C++ only needs 11 lines). Now, based on the above codes, you can solve this problem by simply adding two lines to skip duplicates both starting from left and right. 123456789101112131415161718192021class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size() - 1; while (l &lt;= r) &#123; while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; // skip duplicates from the left while (r &gt; l &amp;&amp; nums[r] == nums[r - 1]) r--; // skip duplicates from the right int mid = (l + r) / 2; if (nums[mid] == target) return true; if (nums[mid] &gt; target) &#123; if (nums[l] &lt;= target || nums[mid] &lt; nums[l]) r = mid - 1; else l = mid + 1; &#125; else &#123; if (nums[l] &gt; target || nums[mid] &gt;= nums[l]) l = mid + 1; else r = mid - 1; &#125; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/20593/python-easy-to-understand-solution-with-comments Python easy to understand solution (with comments). 1234567891011121314151617181920212223def search(self, nums, target): l, r = 0, len(nums)-1 while l &lt;= r: mid = l + (r-l)//2 if nums[mid] == target: return True while l &lt; mid and nums[l] == nums[mid]: # tricky part l += 1 # the first half is ordered if nums[l] &lt;= nums[mid]: # target is in the first half if nums[l] &lt;= target &lt; nums[mid]: r = mid - 1 else: l = mid + 1 # the second half is ordered else: # target is in the second half if nums[mid] &lt; target &lt;= nums[r]: l = mid + 1 else: r = mid - 1 return False java https://discuss.leetcode.com/topic/310/when-there-are-duplicates-the-worst-case-is-o-n-could-we-do-better When there are duplicates, the worst case is O(n). Could we do better? Since we will have some duplicate elements in this problem, it is a little tricky because sometimes we cannot decide whether to go to the left side or right side. So for this condition, I have to probe both left and right side simultaneously to decide which side we need to find the number. Only in this condition, the time complexity may be O(n). The rest conditions are always O(log n). For example: input: 113111111111, Looking for target 3. Is my solution correct? My code is as followed: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public boolean search(int[] A, int target) &#123; // IMPORTANT: Please reset any member data you declared, as // the same Solution instance will be reused for each test case. int i = 0; int j = A.length - 1; while(i &lt;= j)&#123; int mid = (i + j) / 2; if(A[mid] == target) return true; else if(A[mid] &lt; A[i])&#123; if(target &gt; A[j]) j = mid - 1; else if(target &lt; A[mid]) j = mid - 1; else i = mid + 1; &#125;else if(A[mid] &gt; A[i])&#123; if(target &lt; A[mid] &amp;&amp; target &gt;= A[i]) j = mid - 1; else i = mid + 1; &#125;else&#123; // A[mid] == A[i] if(A[mid] != A[j]) i = mid + 1; else&#123; boolean flag = true; for(int k = 1; mid - k &gt;= i &amp;&amp; mid + k &lt;= j; k++)&#123; if(A[mid] != A[mid - k])&#123; j = mid - k; flag = false; break; &#125;else if(A[mid] != A[mid + k])&#123; i = mid + k; flag = false; break; &#125; &#125; if(flag) return false; &#125; &#125; &#125; return false; &#125;&#125; https://discuss.leetcode.com/topic/25487/neat-java-solution-using-binary-search Neat JAVA solution using binary search 12345678910111213141516171819202122232425262728293031public boolean search(int[] nums, int target) &#123; int start = 0, end = nums.length - 1, mid = -1; while(start &lt;= end) &#123; mid = (start + end) / 2; if (nums[mid] == target) &#123; return true; &#125; //If we know for sure right side is sorted or left side is unsorted if (nums[mid] &lt; nums[end] || nums[mid] &lt; nums[start]) &#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) &#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125; //If we know for sure left side is sorted or right side is unsorted &#125; else if (nums[mid] &gt; nums[start] || nums[mid] &gt; nums[end]) &#123; if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) &#123; end = mid - 1; &#125; else &#123; start = mid + 1; &#125; //If we get here, that means nums[start] == nums[mid] == nums[end], then shifting out //any of the two sides won&apos;t change the result but can help remove duplicate from //consideration, here we just use end-- but left++ works too &#125; else &#123; end--; &#125; &#125; return false;&#125; In case anyone wonders, yes I agree that we don’t need to check two parts. It’s just that Doing that can slightly boost the performance, no asymptotic difference though.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[080. Remove Duplicates from Sorted Array II]]></title>
    <url>%2Fp%2F86a087%2F</url>
    <content type="text"><![CDATA[36.1% https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/ Follow up for “Remove Duplicates”: What if duplicates are allowed at most twice? 123456For example,Given sorted array nums = [1,1,1,2,2,3],Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn&apos;t matter what you leave beyond the new length. 方法一： 12345678910111213141516171819202122class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return n; int i=0, j=0; int index = 0; while(i&lt;n)&#123; j=i; while(j&lt;n &amp;&amp; nums[i]==nums[j]) j++; if(j==i+1)&#123; nums[index++] = nums[j-1]; &#125; else&#123; nums[index++] = nums[j-1]; nums[index++] = nums[j-1]; &#125; i = j; &#125; return index; &#125;&#125;; 怀疑下面的解法都是手误 cpp https://discuss.leetcode.com/topic/12892/simple-and-clear-c-recursive-solution Simple and clear c++ recursive solution 123456789101112131415161718class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (!head) return 0; if (!head-&gt;next) return head; int val = head-&gt;val; ListNode* p = head-&gt;next; if (p-&gt;val != val) &#123; head-&gt;next = deleteDuplicates(p); return head; &#125; else &#123; while (p &amp;&amp; p-&gt;val == val) p = p-&gt;next; return deleteDuplicates(p); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/7224/is-this-the-best-c-solution Is this the best C++ solution? 123456789101112131415161718192021222324class Solution &#123;public: ListNode *deleteDuplicates(ListNode *head) &#123; ListNode **runner = &amp;head; if(!head || !head-&gt;next)return head; while(*runner) &#123; if((*runner)-&gt;next &amp;&amp; (*runner)-&gt;next-&gt;val == (*runner)-&gt;val) &#123; ListNode *temp = *runner; while(temp &amp;&amp; (*runner)-&gt;val == temp-&gt;val) temp = temp-&gt;next; *runner = temp; &#125; else runner = &amp;((*runner)-&gt;next); &#125; return head; &#125;&#125;; 123456789101112131415class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int size=nums.size(); int i=0,j=0; while(i&lt;size)&#123; nums[j++]=nums[i]; while(i+2&lt;size &amp;&amp; nums[i]==nums[i+1] &amp;&amp; nums[i+1]==nums[i+2])&#123; i++; &#125; i++; &#125; return j; &#125;&#125;; python https://discuss.leetcode.com/topic/21369/python-in-place-solution-with-dummy-head-node Python in-place solution with dummy head node. 12345678910111213def deleteDuplicates(self, head): dummy = pre = ListNode(0) dummy.next = head while head and head.next: if head.val == head.next.val: while head and head.next and head.val == head.next.val: head = head.next head = head.next pre.next = head else: pre = pre.next head = head.next return dummy.next java https://discuss.leetcode.com/topic/3890/my-accepted-java-code My accepted Java code 1234567891011121314151617181920public ListNode deleteDuplicates(ListNode head) &#123; if(head==null) return null; ListNode FakeHead=new ListNode(0); FakeHead.next=head; ListNode pre=FakeHead; ListNode cur=head; while(cur!=null)&#123; while(cur.next!=null&amp;&amp;cur.val==cur.next.val)&#123; cur=cur.next; &#125; if(pre.next==cur)&#123; pre=pre.next; &#125; else&#123; pre.next=cur.next; &#125; cur=cur.next; &#125; return FakeHead.next; &#125; https://discuss.leetcode.com/topic/5206/my-recursive-java-solution My Recursive Java Solution 12345678910111213public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) return null; if (head.next != null &amp;&amp; head.val == head.next.val) &#123; while (head.next != null &amp;&amp; head.val == head.next.val) &#123; head = head.next; &#125; return deleteDuplicates(head.next); &#125; else &#123; head.next = deleteDuplicates(head.next); &#125; return head;&#125; if current node is not unique, return deleteDuplicates with head.next. If current node is unique, link it to the result of next list made by recursive call. Any improvement? https://discuss.leetcode.com/topic/24470/java-simple-and-clean-code-with-comment Java simple and clean code with comment 123456789101112131415161718192021public class Solution &#123;public ListNode deleteDuplicates(ListNode head) &#123; //use two pointers, slow - track the node before the dup nodes, // fast - to find the last node of dups. ListNode dummy = new ListNode(0), fast = head, slow = dummy; slow.next = fast; while(fast != null) &#123; while (fast.next != null &amp;&amp; fast.val == fast.next.val) &#123; fast = fast.next; //while loop to find the last node of the dups. &#125; if (slow.next != fast) &#123; //duplicates detected. slow.next = fast.next; //remove the dups. fast = slow.next; //reposition the fast pointer. &#125; else &#123; //no dup, move down both pointer. slow = slow.next; fast = fast.next; &#125; &#125; return dummy.next;&#125; &#125; https://discuss.leetcode.com/topic/11234/a-short-and-simple-java-solution A short and simple Java solution 12345678910111213141516public ListNode deleteDuplicates(ListNode head) &#123; ListNode dummy = new ListNode(0); ListNode d = dummy; while (head != null) &#123; if (head.next != null &amp;&amp; head.val == head.next.val) &#123; while (head.next != null &amp;&amp; head.val == head.next.val) head = head.next; &#125; else &#123; d.next = head; d = d.next; &#125; head = head.next; &#125; d.next = null; return dummy.next;&#125; 1-&gt;1-&gt;1-&gt;2-&gt;2-&gt;3 we skip all the 1’s and start the loop from 2 and also skip all the 2’s, and now head.val == 3; ponit d.next to the tail, end the loop]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[079. Word Search]]></title>
    <url>%2Fp%2F289213d2%2F</url>
    <content type="text"><![CDATA[26.8% https://leetcode.com/problems/word-search/ Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. 1234567891011For example,Given board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]word = &quot;ABCCED&quot;, -&gt; returns true,word = &quot;SEE&quot;, -&gt; returns true,word = &quot;ABCB&quot;, -&gt; returns false. 方法一： 我的代码实现: 123456789101112131415161718192021222324252627class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if(word.empty()) return true; if(board.size()==0 || board[0].size()==0) return false; for(int i=0; i&lt;board.size(); i++) for(int j=0; j&lt;board[0].size(); j++) if(helper(board, word, i, j, 0)) return true; return false; &#125; bool helper(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int i, int j, int k)&#123; int m=board.size(), n=board[0].size(); if(board[i][j]!=word[k]) return false; if(k==word.size()-1) return true; char c = board[i][j]; board[i][j] = '*'; bool res = false; if(j+1&lt;n) res = helper(board, word, i, j+1, k+1); if(!res &amp;&amp; i-1&gt;=0) res = helper(board, word, i-1, j, k+1); if(!res &amp;&amp; j-1&gt;=0) res = helper(board, word, i, j-1, k+1); if(!res &amp;&amp; i+1&lt;m) res = helper(board, word, i+1, j, k+1); board[i][j] = c; return res; &#125;&#125;; 典型的dfs，backtracking方法 My 19ms accepted C++ code 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt; &gt; &amp;board, string word) &#123; m=board.size(); n=board[0].size(); for(int x=0;x&lt;m;x++) for(int y=0;y&lt;n;y++) &#123; if(isFound(board,word.c_str(),x,y)) return true; &#125; return false; &#125;private: int m; int n; bool isFound(vector&lt;vector&lt;char&gt; &gt; &amp;board, const char* w, int x, int y) &#123; if(x&lt;0||y&lt;0||x&gt;=m||y&gt;=n||board[x][y]=='\0'||*w!=board[x][y]) return false; if(*(w+1)=='\0') return true; char t=board[x][y]; board[x][y]='\0'; if(isFound(board,w+1,x-1,y)||isFound(board,w+1,x+1,y)||isFound(board,w+1,x,y-1)||isFound(board,w+1,x,y+1)) return true; board[x][y]=t; return false; &#125;&#125;; My DFS + Backtracking C++ solution (16ms) Typical dfs+backtracking question. It compare board[row][col] with word[start], if they match, change board[row][col] to ‘*‘ to mark it as visited. Then move to the next one (i.e. word[start+1]) and compare it to the current neighbors ( doing it by recursion) 1234567891011121314151617181920212223242526272829class Solution &#123;private: bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, const string &amp;word, int start, int M, int N, int sLen) &#123; char curC; bool res = false; if( (curC = board[row][col]) != word[start]) return false; if(start==sLen-1) return true; board[row][col] = &apos;*&apos;; if(row&gt;0) res = dfs(board, row-1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; row &lt; M-1) res = dfs(board, row+1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; col &gt; 0) res = dfs(board, row, col-1, word, start+1, M, N, sLen); if(!res &amp;&amp; col &lt; N-1) res = dfs(board, row, col+1, word, start+1, M, N, sLen); board[row][col] = curC; return res; &#125; public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; int M,N,i,j,sLen = word.size(); if( (M=board.size()) &amp;&amp; (N=board[0].size()) &amp;&amp; sLen) &#123; for(i=0; i&lt;M; ++i) for(j=0; j&lt;N; ++j) if(dfs(board, i, j, word, 0, M, N, sLen)) return true; &#125; return false; &#125;&#125;; cpp https://discuss.leetcode.com/topic/9826/my-19ms-accepted-c-code My 19ms accepted C++ code 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt; &gt; &amp;board, string word) &#123; m=board.size(); n=board[0].size(); for(int x=0;x&lt;m;x++) for(int y=0;y&lt;n;y++) &#123; if(isFound(board,word.c_str(),x,y)) return true; &#125; return false; &#125;private: int m; int n; bool isFound(vector&lt;vector&lt;char&gt; &gt; &amp;board, const char* w, int x, int y) &#123; if(x&lt;0||y&lt;0||x&gt;=m||y&gt;=n||board[x][y]=='\0'||*w!=board[x][y]) return false; if(*(w+1)=='\0') return true; char t=board[x][y]; board[x][y]='\0'; if(isFound(board,w+1,x-1,y)||isFound(board,w+1,x+1,y)||isFound(board,w+1,x,y-1)||isFound(board,w+1,x,y+1)) return true; board[x][y]=t; return false; &#125;&#125;; https://discuss.leetcode.com/topic/19658/my-dfs-backtracking-c-solution-16ms My DFS + Backtracking C++ solution (16ms) Typical dfs+backtracking question. It compare board[row][col] with word[start], if they match, change board[row][col] to ‘*‘ to mark it as visited. Then move to the next one (i.e. word[start+1]) and compare it to the current neighbors ( doing it by recursion) 1234567891011121314151617181920212223242526272829class Solution &#123;private: bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, const string &amp;word, int start, int M, int N, int sLen) &#123; char curC; bool res = false; if( (curC = board[row][col]) != word[start]) return false; if(start==sLen-1) return true; board[row][col] = &apos;*&apos;; if(row&gt;0) res = dfs(board, row-1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; row &lt; M-1) res = dfs(board, row+1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; col &gt; 0) res = dfs(board, row, col-1, word, start+1, M, N, sLen); if(!res &amp;&amp; col &lt; N-1) res = dfs(board, row, col+1, word, start+1, M, N, sLen); board[row][col] = curC; return res; &#125; public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; int M,N,i,j,sLen = word.size(); if( (M=board.size()) &amp;&amp; (N=board[0].size()) &amp;&amp; sLen) &#123; for(i=0; i&lt;M; ++i) for(j=0; j&lt;N; ++j) if(dfs(board, i, j, word, 0, M, N, sLen)) return true; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/22788/python-dfs-solution-with-comments Python dfs solution with comments. 12345678910111213141516171819202122def exist(self, board, word): if not board: return False for i in xrange(len(board)): for j in xrange(len(board[0])): if self.dfs(board, i, j, word): return True return False# check whether can find word, start at (i,j) position def dfs(self, board, i, j, word): if len(word) == 0: # all the characters are checked return True if i&lt;0 or i&gt;=len(board) or j&lt;0 or j&gt;=len(board[0]) or word[0]!=board[i][j]: return False tmp = board[i][j] # first character is found, check the remaining part board[i][j] = &quot;#&quot; # avoid visit agian # check whether can find &quot;word&quot; along one direction res = self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i-1, j, word[1:]) \ or self.dfs(board, i, j+1, word[1:]) or self.dfs(board, i, j-1, word[1:]) board[i][j] = tmp return res https://discuss.leetcode.com/topic/12391/python-simple-dfs-solution Python simple dfs solution 1234567891011121314151617181920212223242526272829def exist(self, board, word): if not word: return True if not board: return False for i in range(len(board)): for j in range(len(board[0])): if self.exist_helper(board, word, i, j): return True return False def exist_helper(self, board, word, i, j): if board[i][j] == word[0]: if not word[1:]: return True board[i][j] = &quot; &quot; # indicate used cell # check all adjacent cells if i &gt; 0 and self.exist_helper(board, word[1:], i-1, j): return True if i &lt; len(board)-1 and self.exist_helper(board, word[1:], i+1, j): return True if j &gt; 0 and self.exist_helper(board, word[1:], i, j-1): return True if j &lt; len(board[0])-1 and self.exist_helper(board, word[1:], i, j+1): return True board[i][j] = word[0] # update the cell to its original value return False else: return False java https://discuss.leetcode.com/topic/7907/accepted-very-short-java-solution-no-additional-space Accepted very short Java solution. No additional space. Here accepted solution based on recursion. To save memory I decuded to apply bit mask for every visited cell. Please check board[y][x] ^= 256; 12345678910111213141516171819202122public boolean exist(char[][] board, String word) &#123; char[] w = word.toCharArray(); for (int y=0; y&lt;board.length; y++) &#123; for (int x=0; x&lt;board[y].length; x++) &#123; if (exist(board, y, x, w, 0)) return true; &#125; &#125; return false;&#125;private boolean exist(char[][] board, int y, int x, char[] word, int i) &#123; if (i == word.length) return true; if (y&lt;0 || x&lt;0 || y == board.length || x == board[y].length) return false; if (board[y][x] != word[i]) return false; board[y][x] ^= 256; boolean exist = exist(board, y, x+1, word, i+1) || exist(board, y, x-1, word, i+1) || exist(board, y+1, x, word, i+1) || exist(board, y-1, x, word, i+1); board[y][x] ^= 256; return exist;&#125; https://discuss.leetcode.com/topic/25591/simple-solution Simple solution 12345678910111213141516171819202122public boolean exist(char[][] board, String word) &#123; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[i].length; j++) &#123; if(exist(board, i, j, word, 0)) return true; &#125; &#125; return false;&#125;private boolean exist(char[][] board, int x, int y, String word, int start) &#123; if(start &gt;= word.length()) return true; if(x &lt; 0 || x &gt;= board.length || y &lt; 0 || y &gt;= board[0].length) return false; if (board[x][y] == word.charAt(start++)) &#123; char c = board[x][y]; board[x][y] = &apos;#&apos;; boolean res = exist(board, x + 1, y, word, start) || exist(board, x - 1, y, word, start) || exist(board, x, y + 1, word, start) || exist(board, x, y - 1, word, start); board[x][y] = c; return res; &#125; return false;&#125; https://discuss.leetcode.com/topic/21142/my-java-solution My Java solution 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; static boolean[][] visited; public boolean exist(char[][] board, String word) &#123; visited = new boolean[board.length][board[0].length]; for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[i].length; j++)&#123; if((word.charAt(0) == board[i][j]) &amp;&amp; search(board, word, i, j, 0))&#123; return true; &#125; &#125; &#125; return false; &#125; private boolean search(char[][]board, String word, int i, int j, int index)&#123; if(index == word.length())&#123; return true; &#125; if(i &gt;= board.length || i &lt; 0 || j &gt;= board[i].length || j &lt; 0 || board[i][j] != word.charAt(index) || visited[i][j])&#123; return false; &#125; visited[i][j] = true; if(search(board, word, i-1, j, index+1) || search(board, word, i+1, j, index+1) || search(board, word, i, j-1, index+1) || search(board, word, i, j+1, index+1))&#123; return true; &#125; visited[i][j] = false; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[078. Subsets]]></title>
    <url>%2Fp%2Fb92586e7%2F</url>
    <content type="text"><![CDATA[37.7% https://leetcode.com/problems/subsets/ Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. 12345678910111213For example,If nums = [1,2,3], a solution is:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 最标准解法，回溯法 位运算法，计算答案个数为2**n个，然后针对每一个，进行位运算，计算是否有相应位。 类似于动态规划，如果是0个数字，那肯定是空集。如果有一个元素，则要么是原答案空集，要么所有答案都加上这个新元素，所以每次翻倍。 方法一： my code: 回溯法：还需要再思考和理解 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs; vector&lt;int&gt; sub; genSubsets(nums, 0, sub, subs); return subs; &#125; void genSubsets(vector&lt;int&gt;&amp; nums, int start, vector&lt;int&gt;&amp; sub, vector&lt;vector&lt;int&gt;&gt;&amp; subs) &#123; subs.push_back(sub); for (int i = start; i &lt; nums.size(); i++) &#123; sub.push_back(nums[i]); genSubsets(nums, i + 1, sub, subs); sub.pop_back(); &#125; &#125;&#125;; 回溯法，我的实现 dfs表示，从0开始至n的一个回溯。 dfs(res, tmp, i+1, n, nums)表示从i+1开始的 可以看出，从start为第一个，开始，dfs一下后面的结果。 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; dfs(res, tmp, 0, nums.size(), nums); return res; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt;&amp; tmp, int start, int n, vector&lt;int&gt;&amp; nums)&#123; res.push_back(tmp); for(int i=start; i&lt;n; i++)&#123; tmp.push_back(nums[i]); dfs(res, tmp, i+1, n, nums); tmp.pop_back(); &#125; &#125;&#125;; 我的代码实现： 8.27.2017 12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; dfs(nums, res, tmp, 0); return res; &#125; void dfs(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, int k)&#123; res.push_back(tmp); if(k&gt;=nums.size()) return; for(int i=k; i&lt;nums.size(); i++)&#123; tmp.push_back(nums[i]); dfs(nums, res, tmp, i+1); tmp.pop_back(); &#125; &#125;&#125;; 方法二： 位运算： 12345678910111213141516class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int n = nums.size(); int subnum = pow(2, n); vector&lt;vector&lt;int&gt;&gt; res(subnum, vector&lt;int&gt;()); for(int i=0; i&lt;subnum; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if((i&gt;&gt;j)&amp;1) res[i].push_back(nums[j]); &#125; &#125; return res; &#125;&#125;; 方法三： 类似于dp的解法： 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs(1, vector&lt;int&gt;()); for (int i = 0; i &lt; nums.size(); i++) &#123; int n = subs.size(); for (int j = 0; j &lt; n; j++) &#123; subs.push_back(subs[j]); subs.back().push_back(nums[i]); &#125; &#125; return subs; &#125;&#125;; 下面这个discuss，很棒。 https://discuss.leetcode.com/topic/19110/c-recursive-iterative-bit-manipulation-solutions-with-explanations C++ Recursive/Iterative/Bit-Manipulation Solutions with Explanations Recursive (Backtracking) This is a typical problem that can be tackled by backtracking. Since backtracking has a more-or-less similar template, so I do not give explanations for this method. 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs; vector&lt;int&gt; sub; genSubsets(nums, 0, sub, subs); return subs; &#125; void genSubsets(vector&lt;int&gt;&amp; nums, int start, vector&lt;int&gt;&amp; sub, vector&lt;vector&lt;int&gt;&gt;&amp; subs) &#123; subs.push_back(sub); for (int i = start; i &lt; nums.size(); i++) &#123; sub.push_back(nums[i]); genSubsets(nums, i + 1, sub, subs); sub.pop_back(); &#125; &#125;&#125;; Iterative This problem can also be solved iteratively. Take [1, 2, 3] in the problem statement as an example. The process of generating all the subsets is like: Initially: [[]] Adding the first number to all the existed subsets: [[], [1]]; Adding the second number to all the existed subsets: [[], [1], [2], [1, 2]]; Adding the third number to all the existed subsets: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]. Have you got the idea :-) The code is as follows. 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs(1, vector&lt;int&gt;()); for (int i = 0; i &lt; nums.size(); i++) &#123; int n = subs.size(); for (int j = 0; j &lt; n; j++) &#123; subs.push_back(subs[j]); subs.back().push_back(nums[i]); &#125; &#125; return subs; &#125;&#125;; Bit Manipulation This is the most clever solution that I have seen. The idea is that to give all the possible subsets, we just need to exhaust all the possible combinations of the numbers. And each number has only two possibilities: either in or not in a subset. And this can be represented using a bit. There is also another a way to visualize this idea. That is, if we use the above example, 1 appears once in every two consecutive subsets, 2 appears twice in every four consecutive subsets, and 3 appears four times in every eight subsets, shown in the following (initially the 8 subsets are all empty): 1234567[], [], [], [], [], [], [], [][], [1], [], [1], [], [1], [], [1][], [1], [2], [1, 2], [], [1], [2], [1, 2][], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3] The code is as follows. 12345678910111213class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int num_subset = pow(2, nums.size()); vector&lt;vector&lt;int&gt; &gt; res(num_subset, vector&lt;int&gt;()); for (int i = 0; i &lt; nums.size(); i++) for (int j = 0; j &lt; num_subset; j++) if ((j &gt;&gt; i) &amp; 1) res[j].push_back(nums[i]); return res; &#125;&#125;; Well, just a final remark. For Python programmers, this may be an easy task in practice since the itertools package has a function combinations for it :-) https://discuss.leetcode.com/topic/19110/c-recursive-iterative-bit-manipulation-solutions-with-explanations/2 Interesting way to use the bit masks, building all subsets in parallel. I don’t think I’ve seen that before. Made me write a way to “only iterate over the 1-bits”: 1234for (int i = 0; i &lt; nums.size(); i++) for (int step = 1 &lt;&lt; i, start = 0; start &lt; num_subset; start += 2 * step) for (int j = start; j &lt; start + step; j++) res[j].push_back(nums[i]); Don’t know whether it’s faster. Overall, half of the bits are 1 anyway, so I save at most 50%. And I might have more overhead costs. Python’s combinations doesn’t quite do it, btw, it only creates subsets of a certain size. But it can be used, yes. Doesn’t help much compared to other solutions, though, as you can see here. And Ruby is even shorter :-) https://discuss.leetcode.com/topic/2764/my-solution-using-bit-manipulation My solution using bit manipulation 1234567891011121314class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt; &amp;S) &#123; sort (S.begin(), S.end()); int elem_num = S.size(); int subset_num = pow (2, elem_num); vector&lt;vector&lt;int&gt; &gt; subset_set (subset_num, vector&lt;int&gt;()); for (int i = 0; i &lt; elem_num; i++) for (int j = 0; j &lt; subset_num; j++) if ((j &gt;&gt; i) &amp; 1) subset_set[j].push_back (S[i]); return subset_set; &#125;&#125;; https://discuss.leetcode.com/topic/2764/my-solution-using-bit-manipulation/7 123456789101112131415161718192021222324252627282930313233343536This is an amazing solution.Learnt a lot.Let me try to explain this to those who didn&apos;t get the logic. Number of subsets for &#123;1 , 2 , 3 &#125; = 2^3 . why ? case possible outcomes for the set of subsets 1 -&gt; Take or dont take = 2 2 -&gt; Take or dont take = 2 3 -&gt; Take or dont take = 2 therefore , total = 2*2*2 = 2^3 = &#123; &#123; &#125; , &#123;1&#125; , &#123;2&#125; , &#123;3&#125; , &#123;1,2&#125; , &#123;1,3&#125; , &#123;2,3&#125; , &#123;1,2,3&#125; &#125;Lets assign bits to each outcome -&gt; First bit to 1 , Second bit to 2 and third bit to 3Take = 1Dont take = 0 0) 0 0 0 -&gt; Dont take 3 , Dont take 2 , Dont take 1 = &#123; &#125; 1) 0 0 1 -&gt; Dont take 3 , Dont take 2 , take 1 = &#123;1 &#125; 2) 0 1 0 -&gt; Dont take 3 , take 2 , Dont take 1 = &#123; 2 &#125; 3) 0 1 1 -&gt; Dont take 3 , take 2 , take 1 = &#123; 1 , 2 &#125; 4) 1 0 0 -&gt; take 3 , Dont take 2 , Dont take 1 = &#123; 3 &#125; 5) 1 0 1 -&gt; take 3 , Dont take 2 , take 1 = &#123; 1 , 3 &#125; 6) 1 1 0 -&gt; take 3 , take 2 , Dont take 1 = &#123; 2 , 3 &#125; 7) 1 1 1 -&gt; take 3 , take 2 , take 1 = &#123; 1 , 2 , 3 &#125; In the above logic ,Insert S[i] only if (j&gt;&gt;i)&amp;1 ==true &#123; j E &#123; 0,1,2,3,4,5,6,7 &#125; i = ith element in the input array &#125;element 1 is inserted only into those places where 1st bit of j is 1 if( j &gt;&gt; 0 &amp;1 ) ==&gt; for above above eg. this is true for sl.no.( j )= 1 , 3 , 5 , 7 element 2 is inserted only into those places where 2nd bit of j is 1 if( j &gt;&gt; 1 &amp;1 ) == for above above eg. this is true for sl.no.( j ) = 2 , 3 , 6 , 7element 3 is inserted only into those places where 3rd bit of j is 1 if( j &gt;&gt; 2 &amp; 1 ) == for above above eg. this is true for sl.no.( j ) = 4 , 5 , 6 , 7 Time complexity : O(n*2^n) , for every input element loop traverses the whole solution set length i.e. 2^n https://discuss.leetcode.com/topic/11373/c-8ms-simple-iterative-solution C++ 8ms simple iterative solution 1234567891011121314151617class Solution &#123;public:vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt; &amp;S) &#123; vector&lt;vector&lt;int&gt; &gt; res(1, vector&lt;int&gt;()); sort(S.begin(), S.end()); for (int i = 0; i &lt; S.size(); i++) &#123; int n = res.size(); for (int j = 0; j &lt; n; j++) &#123; res.push_back(res[j]); res.back().push_back(S[i]); &#125; &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/19561/python-easy-to-understand-solutions-dfs-recursively-bit-manipulation-iteratively Python easy to understand solutions (DFS recursively, Bit Manipulation, Iteratively). 12345678910# DFS recursively def subsets1(self, nums): res = [] self.dfs(sorted(nums), 0, [], res) return res def dfs(self, nums, index, path, res): res.append(path) for i in xrange(index, len(nums)): self.dfs(nums, i+1, path+[nums[i]], res) 1234567891011# Bit Manipulation def subsets2(self, nums): res = [] nums.sort() for i in xrange(1&lt;&lt;len(nums)): tmp = [] for j in xrange(len(nums)): if i &amp; 1 &lt;&lt; j: # if i &gt;&gt; j &amp; 1: tmp.append(nums[j]) res.append(tmp) return res 123456# Iterativelydef subsets(self, nums): res = [[]] for num in sorted(nums): res += [item+[num] for item in res] return res https://discuss.leetcode.com/topic/30867/simple-iteration-no-recursion-no-twiddling-explanation Simple iteration (no recursion, no twiddling) + explanation My idea was to start out with an empty subset and either take or don’t take the next element in the input array. Here’s how it goes down for input [1,2,3]: start with 1[] // empty set is always a subset then either take or not take the next element (1), this doubles the result size: 12[] // not take 1[1] // take 1 + new then take or not take the next element: 2 1234[] // not take 1, not take 2[2] // not take 1, take 2 + new[1] // take 1, not take 2[1,2] // take 1, take 2 + new and finally take or not take 3. 12345678[] // not take 1, not take 2, not take 3[3] // not take 1, not take 2, take 3 + new[2] // not take 1, take 2, not take 3[2,3] // not take 1, take 2, take 3 + new[1] // take 1, not take 2, not take 3[1,3] // take 1, not take 2, take 3 + new[1,2] // take 1, take 2, not take 3[1,2,3] // take 1, take 2, take 3 + new And we’re done, we have all 2^3 = 8 subsets generated. It is possible to generate these with a simple loop, there’s only one trick here, the variable size. It’s usually a good practice to cache method call results, but now it is cached for a different reason: because it changes in every iteration. If we don’t want to end up with an infinite loop, we have to remember how many results were available in the previous iteration, which is exactly the size() of the result at the beginning of the current iteration. 12345678910111213public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; Arrays.sort(nums); // make sure subsets are ordered List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); result.add(new ArrayList&lt;&gt;()); // start with empty set for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = 0, size = result.size(); j &lt; size; ++j) &#123; // remember List&lt;Integer&gt; subset = new ArrayList&lt;&gt;(result.get(j)); // copy a new one subset.add(nums[i]); // expand result.add(subset); // collect &#125; &#125; return result;&#125; It is also necessary to order the input to satisfy the requirement: 1Elements in a subset must be in non-descending order. Because i is increasing it means that whatever we take from nums will also be in increasing order. The other requirement: 1The solution set must not contain duplicate subsets. is automatically guaranteed by the input specification and the algorithm walking indices straight and once: 1Given a set of distinct integers, nums, return all possible subsets. [emphasis mine] java https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning) This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. Subsets : https://leetcode.com/problems/subsets/ 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Subsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Permutations : https://leetcode.com/problems/permutations/ 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/ 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum : https://leetcode.com/problems/combination-sum/ 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum II (can’t reuse same element) : https://leetcode.com/problems/combination-sum-ii/ 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Palindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/ 12345678910111213141516171819202122232425public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list;&#125;public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125;&#125;public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true;&#125; https://discuss.leetcode.com/topic/9031/simple-java-solution-with-for-each-loops Simple Java Solution with For-Each loops No messy indexing. Avoid the ConcurrentModificationException by using a temp list. 123456789101112131415161718public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] S) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); res.add(new ArrayList&lt;Integer&gt;()); Arrays.sort(S); for(int i : S) &#123; List&lt;List&lt;Integer&gt;&gt; tmp = new ArrayList&lt;&gt;(); for(List&lt;Integer&gt; sub : res) &#123; List&lt;Integer&gt; a = new ArrayList&lt;&gt;(sub); a.add(i); tmp.add(a); &#125; res.addAll(tmp); &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/10885/java-subsets-solution Java subsets solution 123456789101112131415161718192021222324public class Solution &#123;public List&lt;List&lt;Integer&gt;&gt; subsets(int[] S) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(S.length == 0)&#123; return result; &#125; Arrays.sort(S); dfs(S, 0, new ArrayList&lt;Integer&gt;(), result); return result;&#125;public void dfs(int[] s, int index, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)&#123; result.add(new ArrayList&lt;Integer&gt;(path)); for(int i = index; i &lt; s.length; i++)&#123; path.add(s[i]); dfs(s, i+1, path, result); path.remove(path.size()-1); &#125;&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[077. Combinations]]></title>
    <url>%2Fp%2F20864a35%2F</url>
    <content type="text"><![CDATA[39.6% https://leetcode.com/problems/combinations/ Given two integers n and k, return all possible combinations of k numbers out of 1 … n. 1234567891011For example,If n = 4 and k = 2, a solution is:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 方法一： 回溯法，dfs code 1： My shortest c++ solution,using dfs my idea is using backtracking ,every time I push a number into vector,then I push a bigger one into it; then i pop the latest one,and push a another bigger one… and if I has push k number into vector,I push this into result; this solution take 24 ms. 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt; &gt;res; if(n&lt;k)return res; vector&lt;int&gt; temp(0,k); combine(res,temp,0,0,n,k); return res; &#125; void combine(vector&lt;vector&lt;int&gt; &gt; &amp;res,vector&lt;int&gt; &amp;temp,int start,int num,int n ,int k)&#123; if(num==k)&#123; res.push_back(temp); return; &#125; for(int i = start;i&lt;n;i++)&#123; temp.push_back(i+1); combine(res,temp,i+1,num+1,n,k); temp.pop_back(); &#125; &#125;&#125;; code 2: 我的实现 经典的回溯法算法，一定要会。 my code： 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; if(n&lt;k) return res; dfs(res, tmp, 0, 0, n, k); return res; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, int start, int num, int n, int k)&#123; if(num==k)&#123; res.push_back(tmp); return; &#125; for(int i=start+1; i&lt;=n; i++)&#123; tmp.push_back(i); dfs(res, tmp, i, num+1, n, k); tmp.pop_back(); &#125; &#125;&#125;; code 3： https://discuss.leetcode.com/topic/22569/c-concise-recursive-solution-c-n-k-c-n-1-k-1-8ms C++ concise recursive solution C(n,k) -&gt;C(n-1,k-1) / 8ms 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; temp; combine(1,n,k,ans,temp); //call fuction to get combination of k numbers which range is 1-n return ans; &#125;private: void combine(int begin,int n, int k, vector&lt;vector&lt;int&gt;&gt; &amp;ans, vector&lt;int&gt;&amp; temp)&#123; if(k==0)&#123; ans.push_back(temp); return; &#125; //condition : n-i+1 is the range, range must greater than k for(int i=begin;n-i+1&gt;=k;i++)&#123; // for the ith iteration, get the combination of i and k-1 numbers differ from i. temp.push_back(i); combine(i+1,n,k-1,ans,temp);// get the combination of k-1 numbers which range is(i+1,n) temp.pop_back(); &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/26689/short-iterative-c-answer-8ms Short Iterative C++ Answer 8ms 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; result; int i = 0; vector&lt;int&gt; p(k, 0); while (i &gt;= 0) &#123; p[i]++; if (p[i] &gt; n) --i; else if (i == k - 1) result.push_back(p); else &#123; ++i; p[i] = p[i - 1]; &#125; &#125; return result; &#125;&#125;; 12ms, 27.43%, May.6th, 2016 https://leetcode.com/discuss/12915/my-shortest-c-solution-using-dfs My shortest c++ solution,using dfs my idea is using backtracking ,every time I push a number into vector,then I push a bigger one into it; then i pop the latest one,and push a another bigger one… and if I has push k number into vector,I push this into result; this solution take 24 ms. 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt; &gt;res; if(n&lt;k)return res; vector&lt;int&gt; temp(0,k); combine(res,temp,0,0,n,k); return res; &#125; void combine(vector&lt;vector&lt;int&gt; &gt; &amp;res,vector&lt;int&gt; &amp;temp,int start,int num,int n ,int k)&#123; if(num==k)&#123; res.push_back(temp); return; &#125; for(int i = start;i&lt;n;i++)&#123; temp.push_back(i+1); combine(res,temp,i+1,num+1,n,k); temp.pop_back(); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/22569/c-concise-recursive-solution-c-n-k-c-n-1-k-1-8ms C++ concise recursive solution C(n,k) -&gt;C(n-1,k-1) / 8ms 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; temp; combine(1,n,k,ans,temp); //call fuction to get combination of k numbers which range is 1-n return ans; &#125;private: void combine(int begin,int n, int k, vector&lt;vector&lt;int&gt;&gt; &amp;ans, vector&lt;int&gt;&amp; temp)&#123; if(k==0)&#123; ans.push_back(temp); return; &#125; //condition : n-i+1 is the range, range must greater than k for(int i=begin;n-i+1&gt;=k;i++)&#123; // for the ith iteration, get the combination of i and k-1 numbers differ from i. temp.push_back(i); combine(i+1,n,k-1,ans,temp);// get the combination of k-1 numbers which range is(i+1,n) temp.pop_back(); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/14626/1-liner-3-liner-4-liner 1-liner, 3-liner, 4-liner Library - AC in 64 ms First the obvious solution - Python already provides this functionality and it’s not forbidden, so let’s take advantage of it. 12345from itertools import combinationsclass Solution: def combine(self, n, k): return list(combinations(range(1, n+1), k)) Recursive - AC in 76 ms But doing it yourself is more interesting, and not that hard. Here’s a recursive version. 12345class Solution: def combine(self, n, k): if k == 0: return [[]] return [pre + [i] for i in range(1, n+1) for pre in self.combine(i-1, k-1)] Iterative - AC in 76 ms And here’s an iterative one. 123456class Solution: def combine(self, n, k): combs = [[]] for _ in range(k): combs = [[i] + c for c in combs for i in range(1, c[0] if c else n+1)] return combs Reduce - AC in 76 ms Same as that iterative one, but using reduce instead of a loop: 1234class Solution: def combine(self, n, k): return reduce(lambda C, _: [[i]+c for c in C for i in range(1, c[0] if c else n+1)], range(k), [[]]) https://discuss.leetcode.com/topic/25958/ac-python-backtracking-iterative-solution-60-ms AC Python backtracking iterative solution 60 ms 1234567891011121314151617181920def combine(self, n, k): ans = [] stack = [] x = 1 while True: l = len(stack) if l == k: ans.append(stack[:]) if l == k or x &gt; n - k + l + 1: if not stack: return ans x = stack.pop() + 1 else: stack.append(x) x += 1# 26 / 26 test cases passed.# Status: Accepted# Runtime: 60 ms# 98.51% Combinations is typical application for backtracking. Two conditions for back track: (1) the stack length is already k (2) the current value is too large for the rest slots to fit in since we are using ascending order to make sure the uniqueness of each combination. java https://discuss.leetcode.com/topic/11718/backtracking-solution-java Backtracking Solution Java 12345678910111213141516public static List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; combs = new ArrayList&lt;List&lt;Integer&gt;&gt;(); combine(combs, new ArrayList&lt;Integer&gt;(), 1, n, k); return combs;&#125;public static void combine(List&lt;List&lt;Integer&gt;&gt; combs, List&lt;Integer&gt; comb, int start, int n, int k) &#123; if(k==0) &#123; combs.add(new ArrayList&lt;Integer&gt;(comb)); return; &#125; for(int i=start;i&lt;=n;i++) &#123; comb.add(i); combine(combs, comb, i+1, n, k-1); comb.remove(comb.size()-1); &#125;&#125; https://discuss.leetcode.com/topic/12537/a-short-recursive-java-solution-based-on-c-n-k-c-n-1-k-1-c-n-1-k A short recursive Java solution based on C(n,k)=C(n-1,k-1)+C(n-1,k) Basically, this solution follows the idea of the mathematical formula C(n,k)=C(n-1,k-1)+C(n-1,k). Here C(n,k) is divided into two situations. Situation one, number n is selected, so we only need to select k-1 from n-1 next. Situation two, number n is not selected, and the rest job is selecting k from n-1. 123456789101112131415public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; if (k == n || k == 0) &#123; List&lt;Integer&gt; row = new LinkedList&lt;&gt;(); for (int i = 1; i &lt;= k; ++i) &#123; row.add(i); &#125; return new LinkedList&lt;&gt;(Arrays.asList(row)); &#125; List&lt;List&lt;Integer&gt;&gt; result = this.combine(n - 1, k - 1); result.forEach(e -&gt; e.add(n)); result.addAll(this.combine(n - 1, k)); return result; &#125;&#125; https://discuss.leetcode.com/topic/3943/dp-for-the-problem DP for the problem I didn’t see any DP solution for this problem, so I share mine: The idea is simple, if the combination k out of n (select k elements from [1,n]) is combine(k, n). Let’s consider how can we get combine(k, n) by adding the last element n to something we already have (combine(k - 1, n - 1) and combine(k, n - 1)). Actually, the combine(k, n) has two parts, one part is all combinations without n, it’s combine(k, n - 1), another is all combinations with n, which can be gotten by appending n to every element in combine(k - 1, n - 1). Note, the combine(i, i) is what we can get directly. Below is my code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Solution&#123; // Combine(n, n). private List&lt;Integer&gt; allContain(int n) &#123; final List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= n; ++i) &#123; result.add(i); &#125; return result; &#125; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;List&lt;Integer&gt;&gt;&gt; previous = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= n; ++i) &#123; previous.add(Collections.singletonList(Collections.&lt;Integer&gt;emptyList())); &#125; for (int i = 1; i &lt;= k; ++i) &#123; final List&lt;List&lt;List&lt;Integer&gt;&gt;&gt; current = new ArrayList&lt;&gt;(); current.add(Collections.singletonList(allContain(i))); // Combine(i, j). for (int j = i + 1; j &lt;= n; ++j) &#123; final List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Combine(i, j - 1). list.addAll(current.get(current.size() - 1)); // Comine(i - 1, j - 1). for (final List&lt;Integer&gt; item : previous.get(current.size())) &#123; final List&lt;Integer&gt; newItem = new ArrayList&lt;&gt;(item); newItem.add(j); list.add(newItem); &#125; current.add(list); &#125; previous = current; &#125; return (previous.size() == 0) ? Collections.&lt;List&lt;Integer&gt;&gt;emptyList() : previous.get(previous.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[076. Minimum Window Substring]]></title>
    <url>%2Fp%2F9aa229a6%2F</url>
    <content type="text"><![CDATA[25.7% https://leetcode.com/problems/minimum-window-substring/ Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). 1234For example,S = &quot;ADOBECODEBANC&quot;T = &quot;ABC&quot;Minimum window is &quot;BANC&quot;. Note:If there is no such window in S that covers all characters in T, return the empty string “”. If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S. Subscribe to see which companies asked this question 方法一： 我的代码实现，更容易理解逻辑，如下： 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string minWindow(string s, string t) &#123; int m = s.size(), n = t.size(); if(n&gt;m) return &quot;&quot;; vector&lt;int&gt; v(256, 0); for(int i=0; i&lt;n; i++) v[t[i]]++; int left = 0; int right = 0; int head = 0; int len = INT_MAX; int cnt = n; while(right&lt;m)&#123; if(v[s[right]]&gt;0) cnt--; v[s[right]]--; right++; while(cnt==0)&#123; // left++, 不考虑left&gt;=m 因为left不可能&gt;=m，否则cnt！=0 if(right-left&lt;len)&#123; head = left; len = right-left; &#125; if(v[s[left]]==0) cnt++; v[s[left]]++; left++; &#125; &#125; return len!=INT_MAX?s.substr(head, len):&quot;&quot;; &#125;&#125;; 重点方法，重点学习，并且带有模板 https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems 9ms, 86.18%, September 22, 2016 Here is a 10-line template that can solve most ‘substring’ problems I will first give the solution then show you the magic template. The code of solving this problem is below. It might be the shortest among all solutions provided in Discuss. 12345678910111213141516class Solution &#123;public: string minWindow(string s, string t) &#123; vector&lt;int&gt; map(128, 0); for(auto c:t) map[c]++; int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0; while(end&lt;s.size())&#123; if(map[s[end++]]--&gt;0) counter--; while(counter==0)&#123; if(end-begin&lt;d) d=end-(head=begin); if(map[s[begin++]]++==0) counter++; &#125; &#125; return d==INT_MAX?&quot;&quot;:s.substr(head, d); &#125;&#125;; Here comes the template. For most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers. The template is given below. 12345678910111213141516171819202122232425int findSubstring(string s)&#123; vector&lt;int&gt; map(128,0); int counter; // check whether the substring is valid int begin=0, end=0; //two pointers, one point to tail and one head int d; //the length of substring for() &#123; /* initialize the hash map here */ &#125; while(end&lt;s.size())&#123; if(map[s[end++]]-- ?)&#123; /* modify counter here */ &#125; while(/* counter condition */)&#123; /* update d here if finding minimum*/ //increase begin to make it invalid/valid again if(map[s[begin++]]++ ?)&#123; /*modify counter here*/ &#125; &#125; /* update d here if finding maximum*/ &#125; return d; &#125; One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop. The code of solving Longest Substring with At Most Two Distinct Characters is below: 12345678910int lengthOfLongestSubstringTwoDistinct(string s) &#123; vector&lt;int&gt; map(128, 0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++==0) counter++; while(counter&gt;2) if(map[s[begin++]]--==1) counter--; d=max(d, end-begin); &#125; return d; &#125; Longest Substring with At Most Two Distinct Characters （带锁） The code of solving Longest Substring Without Repeating Characters is below: Update 01.04.2016, thanks @weiyi3 for advise. 12345678910int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; map(128,0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++&gt;0) counter++; while(counter&gt;0) if(map[s[begin++]]--&gt;1) counter--; d=max(d, end-begin); //while valid, update d &#125; return d; &#125; I think this post deserves some upvotes! : ) code 2： 代码解读： 12345678910111213141516171819202122232425// S = &quot;ADOBECODEBANC&quot;// T = &quot;ABC&quot;class Solution &#123;public: string minWindow(string s, string t) &#123; vector&lt;int&gt; map(128, 0); for(auto c:t) map[c]++; int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0; while(end&lt;s.size())&#123; if(map[s[end++]]--&gt;0) counter--; while(counter==0)&#123; // 如果能进入count==0， 说明begin至end之间的包括t的所有字符 if(end-begin&lt;d)&#123; //简单的判断 head = begin; d = end - head; &#125; if(map[s[begin]]==0)&#123;// begin指向值的如果在此时是0，说明这个值一定是t的值，如果不是，值一定是负的，因为前面减了。 counter++; &#125; map[s[begin]]++; // 本来进入一个值是减的，减少一个值，这个map值的增加的 begin++; // 如果进入了满足counter==0状态，肯定要begin++，向前走的 &#125; &#125; return d==INT_MAX?&quot;&quot;:s.substr(head, d); &#125;&#125;; https://discuss.leetcode.com/topic/3107/accepted-o-n-solution https://oj.leetcode.com/discuss/5469/is-the-length-of-t-considered-constant-or-m Implementation of mike3’s idea 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: string minWindow(string S, string T) &#123; if (S.empty() || T.empty()) &#123; return &quot;&quot;; &#125; int count = T.size(); int require[128] = &#123;0&#125;; bool chSet[128] = &#123;false&#125;; for (int i = 0; i &lt; count; ++i) &#123; require[T[i]]++; chSet[T[i]] = true; &#125; int i = -1; int j = 0; int minLen = INT_MAX; int minIdx = 0; while (i &lt; (int)S.size() &amp;&amp; j &lt; (int)S.size()) &#123; if (count) &#123; i++; require[S[i]]--; if (chSet[S[i]] &amp;&amp; require[S[i]] &gt;= 0) &#123; count--; &#125; &#125; else &#123; if (minLen &gt; i - j + 1) &#123; minLen = i - j + 1; minIdx = j; &#125; require[S[j]]++; if (chSet[S[j]] &amp;&amp; require[S[j]] &gt; 0) &#123; count++; &#125; j++; &#125; &#125; if (minLen == INT_MAX) &#123; return &quot;&quot;; &#125; return S.substr(minIdx, minLen); &#125;&#125;; https://discuss.leetcode.com/topic/6026/sharing-my-straightforward-o-n-solution-with-explanation There are three key variables in my solution: 1unordered_map &lt;char, int&gt; map; unordered_map&lt;char, int&gt; window; int letterCounter; variable “map” is used to indicate what characters and how many characters are in T. variable “window” is to indicate what characters and how many characters are between pointer “slow” and pointer “fast”. Now let’s start. The first For loop is used to construct variable “map”. The second For loop is used to find the minimum window. The first thing we should do in the second For loop is to find a window which can cover T. I use “letterCounter” to be a monitor. If “letterCounter” is equal to T.length(), then we find this window. Before that, only the first If clause can be executed. However, after we find this window, the second If clause can also be executed. In the second If clause, we move “slow” forward in order to shrink the window size. Every time finding a smaller window, I update the result. At the end of program, I return result, which is the minimum window. 123456789101112131415161718192021222324252627282930313233string minWindow(string S, string T) &#123; string result; if(S.empty() || T.empty())&#123; return result; &#125; unordered_map&lt;char, int&gt; map; unordered_map&lt;char, int&gt; window; for(int i = 0; i &lt; T.length(); i++)&#123; map[T[i]]++; &#125; int minLength = INT_MAX; int letterCounter = 0; for(int slow = 0, fast = 0; fast &lt; S.length(); fast++)&#123; char c = S[fast]; if(map.find(c) != map.end())&#123; window[c]++; if(window[c] &lt;= map[c])&#123; letterCounter++; &#125; &#125; if(letterCounter &gt;= T.length())&#123; while(map.find(S[slow]) == map.end() || window[S[slow]] &gt; map[S[slow]])&#123; window[S[slow]]--; slow++; &#125; if(fast - slow + 1 &lt; minLength)&#123; minLength = fast - slow + 1; result = S.substr(slow, minLength); &#125; &#125; &#125; return result;&#125; python 232ms, 32.27%, September 23, 2016 12 lines Python https://discuss.leetcode.com/topic/20692/12-lines-python The current window is s[i:j] and the result window is s[I:J]. In need[c] I store how many times I need character c (can be negative) and missing tells how many characters are still missing. In the loop, first add the new character to the window. Then, if nothing is missing, remove as much as possible from the window start and then update the result.12345678910111213141516171819class Solution(object): def minWindow(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: str &quot;&quot;&quot; need, missing = collections.Counter(t), len(t) i = I = J = 0 for j, c in enumerate(s, 1): missing -= need[c] &gt; 0 need[c] -= 1 if not missing: while i&lt;j and need[s[i]] &lt; 0: need[s[i]] += 1 i += 1 if not J or j-i &lt;= J-I: I, J = i, j return s[I:J] https://discuss.leetcode.com/topic/6665/accepted-python-solution-using-hashtable Accepted Python solution using hashtable 1234567891011121314151617181920212223242526class Solution: # @return a string def minWindow(self, S, T): indices = &#123;&#125; for char in T: indices[char] = [] miss = list(T) start = 0 end = len(S) for i in range(len(S)): if S[i] in T: if S[i] not in miss and indices[S[i]] != []: indices[S[i]].pop(0) elif S[i] in miss: miss.remove(S[i]) indices[S[i]].append(i) if miss == []: maximum = max([x[-1] for x in indices.values()]) minimum = min([x[0] for x in indices.values()]) if maximum-minimum+1 &lt; end-start+1: start = minimum end = maximum if miss != []: return &quot;&quot; else: return S[start:end+1] Basically I kept a dictionary to record the index of each character of T. Each time I found a window, (when miss == []), I checked the length of this window by subtracting the maximum index and the minimum index of the characters. If this window is the smallest one so far, I record its beginning and ending index as “start” and “end.” java https://discuss.leetcode.com/topic/12492/share-my-neat-java-solution Share my neat java solution 123456789101112131415161718192021222324252627282930313233343536public String minWindow(String S, String T) &#123; if(S==null||S.isEmpty()||T==null||T.isEmpty()) return &quot;&quot;; int i=0, j=0; int[] Tmap=new int[256]; int[] Smap=new int[256]; for(int k=0; k&lt; T.length(); k++)&#123; Tmap[T.charAt(k)]++; &#125; int found=0; int length=Integer.MAX_VALUE; String res=&quot;&quot;; while(j&lt;S.length())&#123; if(found&lt;T.length())&#123; if(Tmap[S.charAt(j)]&gt;0)&#123; Smap[S.charAt(j)]++; if(Smap[S.charAt(j)]&lt;=Tmap[S.charAt(j)])&#123; found++; &#125; &#125; j++; &#125; while(found==T.length())&#123; if(j-i&lt;length)&#123; length=j-i; res=S.substring(i,j); &#125; if(Tmap[S.charAt(i)]&gt;0)&#123; Smap[S.charAt(i)]--; if(Smap[S.charAt(i)]&lt;Tmap[S.charAt(i)])&#123; found--; &#125; &#125; i++; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/21143/java-solution-using-two-pointers-hashmap Java solution. using two pointers + HashMap 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123;public String minWindow(String s, String t) &#123; if(s == null || s.length() &lt; t.length() || s.length() == 0)&#123; return &quot;&quot;; &#125; HashMap&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); for(char c : t.toCharArray())&#123; if(map.containsKey(c))&#123; map.put(c,map.get(c)+1); &#125;else&#123; map.put(c,1); &#125; &#125; int left = 0; int minLeft = 0; int minLen = s.length()+1; int count = 0; for(int right = 0; right &lt; s.length(); right++)&#123; if(map.containsKey(s.charAt(right)))&#123; map.put(s.charAt(right),map.get(s.charAt(right))-1); if(map.get(s.charAt(right)) &gt;= 0)&#123; count ++; &#125; while(count == t.length())&#123; if(right-left+1 &lt; minLen)&#123; minLeft = left; minLen = right-left+1; &#125; if(map.containsKey(s.charAt(left)))&#123; map.put(s.charAt(left),map.get(s.charAt(left))+1); if(map.get(s.charAt(left)) &gt; 0)&#123; count --; &#125; &#125; left ++ ; &#125; &#125; &#125; if(minLen&gt;s.length()) &#123; return &quot;&quot;; &#125; return s.substring(minLeft,minLeft+minLen);&#125;&#125; https://discuss.leetcode.com/topic/41308/java-4ms-bit-97-6 Java 4ms bit 97.6% Basically, there are two pointers for windows sliding. One for exploiting new matched substring, other pointer for expiring previous substring. 1234567891011121314151617181920212223242526272829303132333435363738public String minWindow(String s, String t) &#123; char[] s_array = s.toCharArray(); char[] t_array = t.toCharArray(); int[] map = new int[256]; int end = 0; int start = 0; int min_length = Integer.MAX_VALUE; for(int i = 0; i &lt; t_array.length; i++) map[t_array[i]] ++; int count = t_array.length; int min_start = 0; while(end &lt; s_array.length) &#123; if(map[s_array[end]] &gt; 0) &#123; count--; &#125; map[s_array[end]] --; while(count == 0) &#123; if((end - start + 1) &lt; min_length) &#123; min_length = end - start + 1; min_start = start; &#125; map[s_array[start]] ++; if(map[s_array[start]] &gt; 0)&#123; count ++; &#125; start++; &#125; end ++; &#125; if( min_start+min_length &gt; s_array.length) return &quot;&quot;; return s.substring(min_start, min_start+min_length); &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[075. Sort Colors]]></title>
    <url>%2Fp%2Fb84bd86e%2F</url>
    <content type="text"><![CDATA[37.0% https://leetcode.com/problems/sort-colors/ Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note:You are not suppose to use the library’s sort function for this problem. click to show follow up. Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with an one-pass algorithm using only constant space? 本题属于#三向快速排序#，可以参考#算法导论#。 方法一： 12345678910class Solution &#123;public: void sortColors(int A[], int n) &#123; int second=n-1, zero=0; for (int i=0; i&lt;=second; i++) &#123; while (A[i]==2 &amp;&amp; i&lt;second) swap(A[i], A[second--]); while (A[i]==0 &amp;&amp; i&gt;zero) swap(A[i], A[zero++]); &#125; &#125;&#125;; 我的实现： left定义为指向0的指针，right为2 i是遍历的指针指向的位置，从0开始。 如果nums[i]等于0， 则前面left指向0的尾部，left右边是1， 交换nums[i]与nums[++left]，nums[i]=1了相当于，num[++left]=0 如果nums[i]为2，则与尾部交换。由于交换后的结果不确定是几 所以此处i不增加 如果nums[i]为1，则默默增加i就行了。 left，right的初始定义值，借鉴的是算法导论里的方法。 1234567891011121314151617181920class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return; int left = -1, right = n; int i = 0; while(i&lt;right)&#123; if(nums[i]==0)&#123; swap(nums[++left], nums[i]); i++; &#125;else if(nums[i]==2)&#123; swap(nums[--right], nums[i]); &#125;else if(nums[i]==1)&#123; i++; &#125; &#125; return; &#125;&#125;; cpp https://discuss.leetcode.com/topic/5422/share-my-one-pass-constant-space-10-line-solution Share my one pass constant space 10-line solution The idea is to sweep all 0s to the left and all 2s to the right, then all 1s are left in the middle. 12345678910class Solution &#123;public: void sortColors(int A[], int n) &#123; int second=n-1, zero=0; for (int i=0; i&lt;=second; i++) &#123; while (A[i]==2 &amp;&amp; i&lt;second) swap(A[i], A[second--]); while (A[i]==0 &amp;&amp; i&gt;zero) swap(A[i], A[zero++]); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/6968/four-different-solutions Four different solutions 1234567891011121314// two pass O(m+n) spacevoid sortColors(int A[], int n) &#123; int num0 = 0, num1 = 0, num2 = 0; for(int i = 0; i &lt; n; i++) &#123; if (A[i] == 0) ++num0; else if (A[i] == 1) ++num1; else if (A[i] == 2) ++num2; &#125; for(int i = 0; i &lt; num0; ++i) A[i] = 0; for(int i = 0; i &lt; num1; ++i) A[num0+i] = 1; for(int i = 0; i &lt; num2; ++i) A[num0+num1+i] = 2;&#125; 123456789101112131415161718// one pass in place solutionvoid sortColors(int A[], int n) &#123; int n0 = -1, n1 = -1, n2 = -1; for (int i = 0; i &lt; n; ++i) &#123; if (A[i] == 0) &#123; A[++n2] = 2; A[++n1] = 1; A[++n0] = 0; &#125; else if (A[i] == 1) &#123; A[++n2] = 2; A[++n1] = 1; &#125; else if (A[i] == 2) &#123; A[++n2] = 2; &#125; &#125;&#125; 12345678910// one pass in place solutionvoid sortColors(int A[], int n) &#123; int j = 0, k = n - 1; for (int i = 0; i &lt;= k; ++i)&#123; if (A[i] == 0 &amp;&amp; i != j) swap(A[i--], A[j++]); else if (A[i] == 2 &amp;&amp; i != k) swap(A[i--], A[k--]); &#125;&#125; 12345678910// one pass in place solutionvoid sortColors(int A[], int n) &#123; int j = 0, k = n-1; for (int i=0; i &lt;= k; i++) &#123; if (A[i] == 0) swap(A[i], A[j++]); else if (A[i] == 2) swap(A[i--], A[k--]); &#125;&#125; https://discuss.leetcode.com/topic/36832/sharing-c-solution-with-good-explanation Sharing C++ solution with Good Explanation The solution requires the use of tracking 3 positions, the Low, Mid and High. We assume that the mid is the “Unknown” area that we must evaluate. If we encounter a 0, we know that it will be on the low end of the array, and if we encounter a 2, we know it will be on the high end of the array. To achieve this in one pass without preprocessing (counting), we simply traverse the unknown will generating the low and high ends. Take this example: Assume our input is: 1 0 2 2 1 0 (short for simplicity). Running the algorithm by hand would look something like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647481 0 2 2 1 0^ ^L HMMid != 0 || 2Mid++1 0 2 2 1 0^ ^ ^L M HMid == 0Swap Low and MidMid++Low++0 1 2 2 1 0 ^ ^ ^ L M HMid == 2Swap High and MidHigh--0 1 0 2 1 2 ^ ^ ^ L M HMid == 0Swap Low and MidMid++Low++0 0 1 2 1 2 ^ ^ ^ L M HMid == 2Swap High and MidHigh--0 0 1 1 2 2 ^ ^ L M HMid &lt;= High is our exit case Implemented in C++, it looks like: 123456789101112131415161718192021222324252627282930class Solution &#123; public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int tmp = 0, low = 0, mid = 0, high = nums.size() - 1; while(mid &lt;= high) &#123; if(nums[mid] == 0) &#123; tmp = nums[low]; nums[low] = nums[mid]; nums[mid] = tmp; low++; mid++; &#125; else if(nums[mid] == 1) &#123; mid++; &#125; else if(nums[mid] == 2) &#123; tmp = nums[high]; nums[high] = nums[mid]; nums[mid] = tmp; high--; &#125; &#125; &#125;&#125;; my code: 1234567891011121314151617181920212223class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int lo = 0; int hi = nums.size()-1; int i=0; while(i&lt;=hi)&#123; if(nums[i]==2)&#123; swap(nums[i], nums[hi]); hi--; &#125; if(nums[i]==0)&#123; swap(nums[i], nums[lo]); lo++; i++; &#125; if(nums[i]==1)&#123; i++; &#125; &#125; return; &#125;&#125;; python https://discuss.leetcode.com/topic/26181/ac-python-in-place-one-pass-solution-o-n-time-o-1-space-no-swap-no-count AC Python in place one pass solution O(n) time O(1) space, no swap no count 12345678910111213141516def sortColors(self, nums): i = j = 0 for k in xrange(len(nums)): v = nums[k] nums[k] = 2 if v &lt; 2: nums[j] = 1 j += 1 if v == 0: nums[i] = 0 i += 1# 86 / 86 test cases passed.# Status: Accepted# Runtime: 44 ms# 84.03% Just like the Lomuto partition algorithm usually used in quick sort. We keep a loop invariant that [0,i) [i, j) [j, k) are 0s, 1s and 2s sorted in place for [0,k). Here “)” means exclusive. We don’t need to swap because we know the values we want. java https://discuss.leetcode.com/topic/19201/java-solution-both-2-pass-and-1-pass Java solution, both 2-pass and 1-pass 2-pass 两次遍历1-pass 一次遍历 123456789101112131415161718public void sortColors(int[] nums) &#123; // 1-pass int p1 = 0, p2 = nums.length - 1, index = 0; while (index &lt;= p2) &#123; if (nums[index] == 0) &#123; nums[index] = nums[p1]; nums[p1] = 0; p1++; &#125; if (nums[index] == 2) &#123; nums[index] = nums[p2]; nums[p2] = 2; p2--; index--; &#125; index++; &#125;&#125; 1234567891011121314public void sortColors(int[] nums) &#123; // 2-pass int count0 = 0, count1 = 0, count2 = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == 0) &#123;count0++;&#125; if (nums[i] == 1) &#123;count1++;&#125; if (nums[i] == 2) &#123;count2++;&#125; &#125; for(int i = 0; i &lt; nums.length; i++) &#123; if (i &lt; count0) &#123;nums[i] = 0;&#125; else if (i &lt; count0 + count1) &#123;nums[i] = 1;&#125; else &#123;nums[i] = 2;&#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
        <tag>medium</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[074. Search a 2D Matrix]]></title>
    <url>%2Fp%2F5049e182%2F</url>
    <content type="text"><![CDATA[35.1% https://leetcode.com/problems/search-a-2d-matrix/ Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. 12345678910For example,Consider the following matrix:[ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]Given target = 3, return true. 方法一： 二分搜索 我的实现 12345678910111213141516171819202122class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int m = matrix.size(); if(m==0) return false; int n = matrix[0].size(); if(n==0) return false; if(target&lt;matrix[0][0] || target&gt;matrix[m-1][n-1]) return false; int left = 0, right = m*n-1; while(left&lt;=right)&#123; int mid = left + (right-left)/2; if(matrix[mid/n][mid%n]==target) return true; else if(matrix[mid/n][mid%n]&gt;target) right = mid-1; else left = mid + 1; &#125; return false; &#125;&#125;; cpp 12ms, 24.93%, June.21th, 2016 https://leetcode.com/discuss/10735/dont-treat-it-as-a-2d-matrix-just-treat-it-as-a-sorted-list 12345678910111213141516class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int target) &#123; int n = matrix.size(); int m = matrix[0].size(); int l = 0, r = m * n - 1; while (l != r)&#123; int mid = (l + r - 1) &gt;&gt; 1; if (matrix[mid / m][mid % m] &lt; target) l = mid + 1; else r = mid; &#125; return matrix[r / m][r % m] == target; &#125;&#125;; Solution Mime: 12ms, 24.93%, June.21th, 2016 123456789101112131415161718class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int target) &#123; int n = matrix.size(); int m = matrix[0].size(); int l = 0, r = m * n - 1; while (l != r)&#123; int mid = (l + r - 1) &gt;&gt; 1; if (matrix[mid / m][mid % m] &lt; target) l = mid + 1; else if(matrix[mid / m][mid % m] &gt; target) r = mid; else return true; &#125; return matrix[r / m][r % m] == target; &#125;&#125;; python Solution Mine: 52ms, 65.89%, June.21th, 2016 123456789101112class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; for i in xrange(len(matrix)): for j in xrange(len(matrix[0])): if target == matrix[i][j]: return True return False 60ms, 31.27%, June.21th, 2016 https://leetcode.com/discuss/28208/a-python-binary-search-solution-o-logn 123456789101112131415161718192021222324class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; if not matrix or target is None: return False rows, cols = len(matrix), len(matrix[0]) low, high = 0, rows * cols - 1 while low &lt;= high: mid = (low + high) / 2 num = matrix[mid / cols][mid % cols] if num == target: return True elif num &lt; target: low = mid + 1 else: high = mid - 1 return False Solution Mine: 48ms, 85.27%, June.21th, 2016 1234567891011121314151617181920212223242526class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; if not matrix or target is None: return False if target &lt; matrix[0][0] or target &gt; matrix[-1][-1]: return False rows, cols = len(matrix), len(matrix[0]) low, high = 0, rows * cols - 1 while low &lt;= high: mid = (low + high) / 2 num = matrix[mid / cols][mid % cols] if num == target: return True elif num &lt; target: low = mid + 1 else: high = mid - 1 return False java 1ms, 6.12%, June.21th, 2016 https://leetcode.com/discuss/15379/binary-search-on-an-ordered-matrix 123456789101112131415161718192021public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int row_num = matrix.length; int col_num = matrix[0].length; int begin = 0, end = row_num * col_num - 1; while(begin &lt;= end)&#123; int mid = (begin + end) / 2; int mid_value = matrix[mid / col_num][mid % col_num]; if(mid_value == target) return true; else if(mid_value &lt; target) begin = mid + 1; else end = mid - 1; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[073. Set Matrix Zeroes]]></title>
    <url>%2Fp%2F87522f31%2F</url>
    <content type="text"><![CDATA[36.0% https://leetcode.com/problems/set-matrix-zeroes/ Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. Follow up: Did you use extra space? A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? 貌似剑指offer？ 方法一： 保存所有结果到第一行和第一列，遍历非第一行，非第一列，只要有出现0的就设置为0。 至于第一行第一列要不要设置为0，可以设置两个标志来判断。 https://discuss.leetcode.com/topic/5056/any-shorter-o-1-space-solution Any shorter O(1) space solution? My idea is simple: store states of each row in the first of that row, and store states of each column in the first of that column. Because the state of row0 and the state of column0 would occupy the same cell, I let it be the state of row0, and use another variable “col0” for column0. In the first phase, use matrix elements to set states in a top-down way. In the second phase, use states to set matrix elements in a bottom-up way. 1234567891011121314151617void setZeroes(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int col0 = 1, rows = matrix.size(), cols = matrix[0].size(); for (int i = 0; i &lt; rows; i++) &#123; if (matrix[i][0] == 0) col0 = 0; for (int j = 1; j &lt; cols; j++) if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0; &#125; for (int i = rows - 1; i &gt;= 0; i--) &#123; for (int j = cols - 1; j &gt;= 1; j--) if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0; if (col0 == 0) matrix[i][0] = 0; &#125;&#125; 我的代码实现： 多个循环，第一行，第一列，非第一行第一列，三个循环，清晰明了。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return; int row0 = 1, col0 = 1; int rows = matrix.size(), cols = matrix[0].size(); for(int i=0; i&lt;cols; i++)&#123; if(matrix[0][i]==0)&#123; row0 = 0; break; &#125; &#125; for(int i=0; i&lt;rows; i++)&#123; if(matrix[i][0]==0)&#123; col0 = 0; break; &#125; &#125; for(int i=1; i&lt;rows; i++)&#123; for(int j=1; j&lt;cols; j++)&#123; if(matrix[i][j]==0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; for(int i=1; i&lt;rows; i++)&#123; for(int j=1; j&lt;cols; j++)&#123; if(matrix[i][0]==0 || matrix[0][j]==0) matrix[i][j] = 0; &#125; &#125; if(row0==0)&#123; for(int i=0; i&lt;cols; i++) matrix[0][i] = 0; &#125; if(col0==0)&#123; for(int i=0; i&lt;rows; i++) matrix[i][0] = 0; &#125; return; &#125;&#125;; https://discuss.leetcode.com/topic/7087/my-c-o-1-yoooooo My C++ O(1) yoooooo I find the last row which has 0, and use it to store the 0-collumns. Then go row by row set them to 0. Then go column by column set them to 0. Finally set the last row which has 0. It’s long but hey it’s O(1) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int H = matrix.size(); int W = matrix[0].size(); // find the last 0 row int last_0_row = -1; for (int y = H - 1; y &gt;= 0 &amp;&amp; last_0_row == -1; y--) for (int x = 0; x &lt; W; x++) if (matrix[y][x] == 0) &#123; last_0_row = y; break; &#125; if (last_0_row == -1) return; // go row by row for (int y = 0; y &lt; last_0_row; y++) &#123; bool this_is_a_0_row = false; for (int x = 0; x &lt; W; x++) &#123; if (matrix[y][x] == 0) &#123; this_is_a_0_row = true; matrix[last_0_row][x] = 0; &#125; &#125; if (this_is_a_0_row) for (int x = 0; x &lt; W; x++) &#123; matrix[y][x] = 0; &#125; &#125; // set collums to 0 for (int y = 0; y &lt; H; y++) for (int x = 0; x &lt; W; x++) &#123; if (matrix[last_0_row][x] == 0) matrix[y][x] = 0; &#125; // set the last 0 row for (int x = 0; x &lt; W; x++) &#123; matrix[last_0_row][x] = 0; &#125; &#125;&#125;; python 188ms, 49.31%, June.18th, 2016 https://leetcode.com/discuss/49003/o-1-space-solution-in-python O(1) space solution in Python 12345678910111213141516171819202122232425262728293031323334353637383940class Solution:# @param &#123;integer[][]&#125; matrix# @return &#123;void&#125; Do not return anything, modify matrix in-place instead.def setZeroes(self, matrix): m = len(matrix) if m == 0: return n = len(matrix[0]) row_zero = False for i in range(m): if matrix[i][0] == 0: row_zero = True col_zero = False for j in range(n): if matrix[0][j] == 0: col_zero = True for i in range(1, m): for j in range(1, n): if matrix[i][j] == 0: matrix[i][0] = 0 matrix[0][j] = 0 for i in range(1, m): if matrix[i][0] == 0: for j in range(1, n): matrix[i][j] = 0 for j in range(1, n): if matrix[0][j] == 0: for i in range(1, m): matrix[i][j] = 0 if col_zero: for j in range(n): matrix[0][j] = 0 if row_zero: for i in range(m): matrix[i][0] = 0 java https://discuss.leetcode.com/topic/15193/my-ac-java-o-1-solution-easy-to-read My AC java O(1) solution (easy to read) 123456789101112131415161718192021222324252627282930313233public class Solution &#123;public void setZeroes(int[][] matrix) &#123; boolean fr = false,fc = false; for(int i = 0; i &lt; matrix.length; i++) &#123; for(int j = 0; j &lt; matrix[0].length; j++) &#123; if(matrix[i][j] == 0) &#123; if(i == 0) fr = true; if(j == 0) fc = true; matrix[0][j] = 0; matrix[i][0] = 0; &#125; &#125; &#125; for(int i = 1; i &lt; matrix.length; i++) &#123; for(int j = 1; j &lt; matrix[0].length; j++) &#123; if(matrix[i][0] == 0 || matrix[0][j] == 0) &#123; matrix[i][j] = 0; &#125; &#125; &#125; if(fr) &#123; for(int j = 0; j &lt; matrix[0].length; j++) &#123; matrix[0][j] = 0; &#125; &#125; if(fc) &#123; for(int i = 0; i &lt; matrix.length; i++) &#123; matrix[i][0] = 0; &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/8807/my-java-o-1-solution-easy-to-understand My java O(1) solution (easy to understand) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Solution &#123; public void setZeroes(int[][] matrix) &#123; if(matrix==null)&#123; return; &#125; int m = matrix.length; int n = matrix[0].length; boolean rowHasZero = false; boolean colHasZero = false; for(int i=0; i&lt;n; i++)&#123; if(matrix[0][i]==0)&#123; rowHasZero = true; break; &#125; &#125; for(int i=0; i&lt;m; i++)&#123; if(matrix[i][0]==0)&#123; colHasZero = true; break; &#125; &#125; for(int i=1; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; if(matrix[i][j]==0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; for(int j=1;j&lt;n; j++)&#123; if(matrix[0][j]==0)&#123; nullifyCol(matrix, j, m, n); &#125; &#125; for(int i=1; i&lt;m; i++)&#123; if(matrix[i][0]==0)&#123; nullifyRow(matrix, i, m, n); &#125; &#125; if(rowHasZero)&#123; nullifyRow(matrix, 0, m, n); &#125; if(colHasZero)&#123; nullifyCol(matrix, 0, m, n); &#125; &#125; public void nullifyRow(int[][] matrix, int i, int m, int n)&#123; for(int col=0; col&lt;n; col++)&#123; matrix[i][col] = 0; &#125; &#125; public void nullifyCol(int[][] matrix, int j, int m, int n)&#123; for(int row=0; row&lt;m; row++)&#123; matrix[row][j] = 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[072. Edit Distance]]></title>
    <url>%2Fp%2F8e0e9f97%2F</url>
    <content type="text"><![CDATA[30.9% https://leetcode.com/problems/edit-distance/ Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) 12345You have the following 3 operations permitted on a word:a) Insert a characterb) Delete a characterc) Replace a character 方法一： 我的代码实现： 12345678910111213141516171819202122class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.size(); int n = word2.size(); if(n==0) return m; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=0; i&lt;m+1; i++) dp[i][0] = i; for(int j=0; j&lt;n+1; j++) dp[0][j] = j; for(int i=1; i&lt;m+1; i++)&#123; for(int j=1; j&lt;n+1; j++)&#123; if(word1[i-1] != word2[j-1]) dp[i][j] = min(min(dp[i][j-1], dp[i-1][j]), dp[i-1][j-1]) + 1; else dp[i][j] = dp[i-1][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; 根据题目分析问题，然后动态规划解决问题，很常规的一类 从中定义模式，两个的话，定义（m+1）*（n+1）的数组 19ms, 70.83%, September 21, 2016 https://discuss.leetcode.com/topic/17639/20ms-detailed-explained-c-solutions-o-n-space This is a classic problem of Dynamic Programming. We define the state dp[i][j] to be the minimum number of operations to convert word1[0..i - 1] to word2[0..j - 1]. The state equations have two cases: the boundary case and the general case. Note that in the above notations, both i and j take values starting from 1. For the boundary case, that is, to convert a string to an empty string, it is easy to see that the mininum number of operations to convert word1[0..i - 1] to “” requires at least i operations (deletions). In fact, the boundary case is simply: dp[i][0] = i; dp[0][j] = j. Now let’s move on to the general case, that is, convert a non-empty word1[0..i - 1] to another non-empty word2[0..j - 1]. Well, let’s try to break this problem down into smaller problems (sub-problems). Suppose we have already known how to convert word1[0..i - 2] to word2[0..j - 2], which is dp[i - 1][j - 1]. Now let’s consider word[i - 1] and word2[j - 1]. If they are euqal, then no more operation is needed and dp[i][j] = dp[i - 1][j - 1]. Well, what if they are not equal? If they are not equal, we need to consider three cases: Replace word1[i - 1] by word2[j - 1] (dp[i][j] = dp[i - 1][j - 1] + 1 (for replacement)); Delete word1[i - 1] and word1[0..i - 2] = word2[0..j - 1] (dp[i][j] = dp[i - 1][j] + 1 (for deletion)); Insert word2[j - 1] to word1[0..i - 1] and word1[0..i - 1] + word2[j - 1] = word2[0..j - 1] (dp[i][j] = dp[i][j - 1] + 1 (for insertion)). Make sure you understand the subtle differences between the equations for deletion and insertion. For deletion, we are actually converting word1[0..i - 2] to word2[0..j - 1], which costs dp[i - 1][j], and then deleting the word1[i - 1], which costs 1. The case is similar for insertion. Putting these together, we now have: dp[i][0] = i; dp[0][j] = j; dp[i][j] = dp[i - 1][j - 1], if word1[i - 1] = word2[j - 1]; dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1), otherwise. The above state equations can be turned into the following code directly. 123456789101112131415161718class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.length(), n = word2.length(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=1; i&lt;=m; i++) dp[i][0] = i; for(int j=1; j&lt;=n; j++) dp[0][j] = j; for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = min(dp[i-1][j-1]+1, min(dp[i][j-1]+1, dp[i-1][j]+1)); return dp[m][n]; &#125;&#125;; 方法二： 我的代码实现 dp[i][j],只有三条路可以走，一个是从dp[i-1][j-1]不相等替换 相等就不变， 一个是dp[i][j-1]增加或删除，一个是dp[i-1][j]增加或删除 有两个string的时候，长度分别是m和n，要特别分清到底哪个是m，哪个是n 12345678910111213141516171819class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.size(); int n = word2.size(); if(n==0) return m; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=0; i&lt;m+1; i++) dp[i][0] = i; for(int j=0; j&lt;n+1; j++) dp[0][j] = j; for(int i=1; i&lt;m+1; i++)&#123; for(int j=1; j&lt;n+1; j++)&#123; dp[i][j] = min(min(dp[i][j-1], dp[i-1][j])+1, word1[i-1]==word2[j-1]?dp[i-1][j-1]:dp[i-1][j-1]+1); &#125; &#125; return dp[m][n]; &#125;&#125;; 13ms, 86.67%, September 21, 2016 https://discuss.leetcode.com/topic/17639/20ms-detailed-explained-c-solutions-o-n-space Well, you may have noticed that each time when we update dp[i][j], we only need dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]. In fact, we need not maintain the full m*n matrix. Instead, maintaing one column is enough. The code can be optimized to O(m) or O(n) space, depending on whether you maintain a row or a column of the original matrix. The optimized code is as follows. 12345678910111213141516171819202122class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.length(), n = word2.length(); vector&lt;int&gt; cur(m+1, 0); for(int i=1; i&lt;=m; i++) cur[i] = i; for(int j=1; j&lt;=n; j++)&#123; int pre = cur[0]; cur[0] = j; for(int i=1; i&lt;=m; i++)&#123; int temp = cur[i]; if(word1[i-1] == word2[j-1]) cur[i] = pre; else cur[i] = min(pre+1, min(cur[i]+1, cur[i-1]+1)); pre = temp; &#125; &#125; return cur[m]; &#125;&#125;; Well, if you find the above code hard to understand, you may first try to write a two-column version that explicitly maintains two columns (the previous column and the current column) and then simplify the two-column version into the one-column version like the above code :-) python 256ms, 35.52%, September 21, 2016 https://discuss.leetcode.com/topic/19877/python-solutions-o-m-n-o-n-space O(m*n) space 1234567891011121314151617class Solution(object): def minDistance(self, word1, word2): &quot;&quot;&quot; :type word1: str :type word2: str :rtype: int &quot;&quot;&quot; l1, l2 = len(word1)+1, len(word2)+1 dp = [[0 for _ in xrange(l2)] for _ in xrange(l1)] for i in xrange(l1): dp[i][0] = i for j in xrange(l2): dp[0][j] = j for i in xrange(1, l1): for j in xrange(1, l2): dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+(word1[i-1]!=word2[j-1])) return dp[-1][-1] 262ms, 32.79%, September 21, 2016 https://discuss.leetcode.com/topic/19877/python-solutions-o-m-n-o-n-space O(n) space with rolling array1234567891011121314151617class Solution(object): def minDistance(self, word1, word2): &quot;&quot;&quot; :type word1: str :type word2: str :rtype: int &quot;&quot;&quot; l1, l2 = len(word1)+1, len(word2)+1 pre = [0 for _ in xrange(l2)] for j in xrange(l2): pre[j] = j for i in xrange(1, l1): cur = [i]*l2 for j in xrange(1, l2): cur[j] = min(cur[j-1]+1, pre[j]+1, pre[j-1]+(word1[i-1] != word2[j-1])) pre = cur[:] return pre[-1] java 16ms, 31.71%, September 21, 2016 https://discuss.leetcode.com/topic/20922/java-dp-solution-o-nm Let following be the function definition :- 1234567891011f(i, j) := minimum cost (or steps) required to convert first i characters of word1 to first j characters of word2Case 1: word1[i] == word2[j], i.e. the ith the jth character matches.f(i, j) = f(i - 1, j - 1)Case 2: word1[i] != word2[j], then we must either insert, delete or replace, whichever is cheaperf(i, j) = 1 + min &#123; f(i, j - 1), f(i - 1, j), f(i - 1, j - 1) &#125;1. f(i, j - 1) represents insert operation2. f(i - 1, j) represents delete operation3. f(i - 1, j - 1) represents replace operation Here, we consider any operation from word1 to word2. It means, when we say insert operation, we insert a new character after word1 that matches the jth character of word2. So, now have to match i characters of word1 to j - 1 characters of word2. Same goes for other 2 operations as well. Note that the problem is symmetric. The insert operation in one direction (i.e. from word1 to word2) is same as delete operation in other. So, we could choose any direction. Above equations become the recursive definitions for DP. Base Case: 1f(0, k) = f(k, 0) = k Below is the direct bottom-up translation of this recurrent relation. It is only important to take care of 0-based index with actual code :- Time complexity : If n is the length of word1, m of word2, because of the two indented loops, it is O(nm)123456789101112131415161718192021222324252627public class Solution &#123; public int minDistance(String word1, String word2) &#123; int m = word1.length(); int n = word2.length(); int[][] cost = new int[m+1][n+1]; for(int i=0; i&lt;=m; i++) cost[i][0] = i; for(int j=0; j&lt;=n; j++) cost[0][j] = j; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(word1.charAt(i) == word2.charAt(j)) cost[i+1][j+1] = cost[i][j]; else&#123; int a = cost[i][j]; int b = cost[i][j+1]; int c = cost[i+1][j]; cost[i+1][j+1] = a &lt; b?(a&lt;c?a:c):(b&lt;c?b:c); cost[i+1][j+1]++; &#125; &#125; &#125; return cost[m][n]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[071. Simplify Path]]></title>
    <url>%2Fp%2F6cd51db6%2F</url>
    <content type="text"><![CDATA[25.4% https://leetcode.com/problems/simplify-path/ Given an absolute path for a file (Unix-style), simplify it. 123For example,path = &quot;/home/&quot;, =&gt; &quot;/home&quot;path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot; Corner Cases: Did you consider the case where path = “/../“? In this case, you should return “/“. Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“. In this case, you should ignore redundant slashes and return “/home/foo”. 方法一： https://discuss.leetcode.com/topic/2872/my-o-n-ac-code-just-need-to-handle-two-special-cases My O(n) AC code . just need to handle two special cases. traverse the string to record each folder name. two special cases: a.double dot:pop one. b.single dot: do nothing (don`t push it). 123456789101112131415161718192021222324252627string simplifyPath(string path) &#123; vector&lt;string&gt; nameVect; string name; path.push_back(&apos;/&apos;); for(int i=0;i&lt;path.size();i++)&#123; if(path[i]==&apos;/&apos;)&#123; if(name.size()==0)continue; if(name==&quot;..&quot;)&#123; //special case 1：double dot，pop dir if(nameVect.size()&gt;0)nameVect.pop_back(); &#125;else if(name==&quot;.&quot;)&#123;//special case 2:singel dot，don`t push &#125;else&#123; nameVect.push_back(name); &#125; name.clear(); &#125;else&#123; name.push_back(path[i]);//record the name &#125; &#125; string result; if(nameVect.empty())return &quot;/&quot;; for(int i=0;i&lt;nameVect.size();i++)&#123; result.append(&quot;/&quot;+nameVect[i]); &#125; return result;&#125; 我的代码实现： string的函数clear，append，push_back 给定的字符串可以更改的 1234567891011121314151617181920212223242526class Solution &#123;public: string simplifyPath(string path) &#123; vector&lt;string&gt; v; string name = ""; path.push_back('/'); // 针对原有string的首或尾进行改变，这是一种思路 int n = path.size(); // 长度改变了，所以要在改变后求长度，否则不对的 for(int i=0; i&lt;n; i++)&#123; if(path[i]=='/')&#123; if(name=="") continue; // 下面的大括号外，不要分号的 else if(name==".")&#123;&#125; //此处不能continue，因为要清空name，才下一步 else if(name=="..") &#123; if(!v.empty()) v.pop_back();&#125; else v.push_back(name); name.clear(); // 此处学会针对string的clear &#125;else&#123; name.push_back(path[i]); &#125; &#125; string res = ""; for(int i=0; i&lt;v.size(); i++) res.append("/" + v[i]); return v.empty()? "/" : res; &#125;&#125;; cpp 6ms, September 11, 2016 https://discuss.leetcode.com/topic/8678/c-10-lines-solution C++ 10-lines solution C++ also have getline which acts like Java’s split. I guess the code can comment itself. 123456789101112131415class Solution &#123;public: string simplifyPath(string path) &#123; string res, tmp; vector&lt;string&gt; stk; stringstream ss(path); while(getline(ss, tmp, &apos;/&apos;))&#123; if(tmp == &quot;&quot; or tmp == &quot;.&quot;) continue; if(tmp == &quot;..&quot; and !stk.empty()) stk.pop_back(); else if(tmp!=&quot;..&quot;) stk.push_back(tmp); &#125; for(auto str:stk) res += &quot;/&quot; + str; return res.empty() ? &quot;/&quot; : res; &#125;&#125;; python 82ms, September 11, 2016 https://discuss.leetcode.com/topic/41158/9-line-python-solution-easy-to-understand 9-line Python solution, easy to understand 12345678910111213141516class Solution(object): def simplifyPath(self, path): &quot;&quot;&quot; :type path: str :rtype: str &quot;&quot;&quot; stack = [] for token in path.split(&apos;/&apos;): if token in (&apos;&apos;, &apos;.&apos;): pass elif token == &apos;..&apos;: if stack: stack.pop() else: stack.append(token) return &apos;/&apos; + &apos;/&apos;.join(stack) java 18ms, September 11, 2016 https://discuss.leetcode.com/topic/7675/java-10-lines-solution-with-stack Java 10-lines solution with stack Hi guys! The main idea is to push to the stack every valid file name (not in {“”,”.”,”..”}), popping only if there’s smth to pop and we met “..”. I don’t feel like the code below needs any additional comments. 12345678910111213public class Solution &#123; public String simplifyPath(String path) &#123; Deque&lt;String&gt; stack = new LinkedList&lt;&gt;(); Set&lt;String&gt; skip = new HashSet&lt;&gt;(Arrays.asList(&quot;..&quot;, &quot;.&quot;, &quot;&quot;)); for(String dir : path.split(&quot;/&quot;))&#123; if(dir.equals(&quot;..&quot;) &amp;&amp; !stack.isEmpty()) stack.pop(); else if(!skip.contains(dir)) stack.push(dir); &#125; String res = &quot;&quot;; for(String dir:stack) res = &quot;/&quot; + dir + res; return res.isEmpty()? &quot;/&quot; : res; &#125;&#125; https://discuss.leetcode.com/topic/7014/accepted-solution-using-deque Accepted solution using Deque I think using Deque is probably the most intuitive way to solve this problem. 12345678910111213141516171819202122232425262728293031323334/** * Deque of strings (directories). * iterate path: * if &quot;/&quot;, continue, * if &quot;.&quot;, conitnue, * if &quot;..&quot;, poll last, * else, add a new directory * in the end, build result from deque. */public String simplifyPath(String path) &#123; Deque&lt;String&gt; deque = new LinkedList&lt;String&gt;(); String[] splits = path.split(&quot;/&quot;); for (String split : splits) &#123; // CATCH: must use &quot;equals()&quot; instead of &quot;==&quot;, // because &apos;split&apos; is a variable! // Also, &apos;split&apos; could be empty string. if (split.equals(&quot;&quot;)) continue; else if (split.equals(&quot;.&quot;)) continue; else if (split.equals(&quot;..&quot;)) deque.pollLast(); else deque.addLast(split); &#125; StringBuilder builder = new StringBuilder(); while (!deque.isEmpty()) &#123; String s = deque.pollFirst(); builder.append(&quot;/&quot;).append(s); &#125; if (builder.length() == 0) return &quot;/&quot;; return builder.toString();&#125; https://discuss.leetcode.com/topic/12767/ac-solution-in-java AC Solution in Java 12345678910111213141516public class Solution &#123; public String simplifyPath(String path) &#123; Set&lt;String&gt; isSkip = new HashSet&lt;&gt;(Arrays.asList(&quot;&quot;, &quot;.&quot;, &quot;..&quot;)); Deque&lt;String&gt; stack = new ArrayDeque&lt;&gt;(); for (String token : path.split(&quot;/&quot;)) &#123; if (token.equals(&quot;..&quot;) &amp;&amp; !stack.isEmpty()) stack.pop(); if (isSkip.contains(token)) continue; stack.push(token); &#125; StringBuilder sb = new StringBuilder(); while (!stack.isEmpty()) &#123; sb.append(&quot;/&quot; + stack.pollLast()); &#125; return sb.length() == 0 ? &quot;/&quot; : sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>medium</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[070. Climbing Stairs]]></title>
    <url>%2Fp%2Ff1d6ecb9%2F</url>
    <content type="text"><![CDATA[39.0% https://leetcode.com/problems/climbing-stairs/ You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 方法一： 12345678910111213class Solution &#123;public: int climbStairs(int n) &#123; if(n&lt;0) return 0; int a=0, b=1; while(n--)&#123; int c = a+b; a = b; b = c; &#125; return b; &#125;&#125;; 相似题： 有一楼梯共m级，刚开始时你在第一级，若每次只能跨上一级或者二级，要走上m级，共有多少走法？注：规定从一级到一级有0种走法。给定一个正整数int n，请返回一个数，代表上楼的方式数。保证n小于等于100。为了防止溢出，请返回结果Mod 1000000007的值。 测试样例： 3 返回：2 my code: 123456789101112131415class GoUpstairs &#123;public: int countWays(int n) &#123; // write code here long long a=1, b=1, i=1; long long c; while(i&lt;n)&#123; c = a; a = (a+b)%1000000007; b = (c)%1000000007; i++; &#125; return b; &#125;&#125;; 其中，要求mod值，在最终结果处会溢出，所以在中间mod。 解析https://discuss.leetcode.com/topic/17002/3-4-short-lines-in-every-language Same simple algorithm written in every offered language. Variable a tells you the number of ways to reach the current step, and b tells you the number of ways to reach the next step. So for the situation one step further up, the old b becomes the new a, and the new b is the old a+b, since that new step can be reached by climbing 1 step from what b represented or 2 steps from what a represented. Ruby wins, and “the C languages” all look the same. java 123456public int climbStairs(int n) &#123; int a = 1, b = 1; while (n-- &gt; 0) a = (b += a) - a; return a;&#125; cpp 123456int climbStairs(int n) &#123; int a = 1, b = 1; while (n--) a = (b += a) - a; return a;&#125; python 12345def climbStairs(self, n): a = b = 1 for _ in range(n): a, b = b, a + b return a 评价：n–是亮点，不必单独设置一个变量i++ https://discuss.leetcode.com/topic/5371/basically-it-s-a-fibonacci Basically it’s a fibonacci. The problem seems to be a dynamic programming one. Hint: the tag also suggests that!Here are the steps to get the solution incrementally. Base cases: if n &lt;= 0, then the number of ways should be zero. if n == 1, then there is only way to climb the stair. if n == 2, then there are two ways to climb the stairs. One solution is one step by another; the other one is two steps at one time. The key intuition to solve the problem is that given a number of stairs n, if we know the number ways to get to the points [n-1] and [n-2] respectively, denoted as n1 and n2 , then the total ways to get to the point [n] is n1 + n2. Because from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there. There is NO overlapping between these two solution sets, because we differ in the final step. Now given the above intuition, one can construct an array where each node stores the solution for each number n. Or if we look at it closer, it is clear that this is basically a fibonacci number, with the starting numbers as 1 and 2, instead of 1 and 1. The implementation in Java as follows: 1234567891011121314151617public int climbStairs(int n) &#123; // base cases if(n &lt;= 0) return 0; if(n == 1) return 1; if(n == 2) return 2; int one_step_before = 2; int two_steps_before = 1; int all_ways = 0; for(int i=2; i&lt;n; i++)&#123; all_ways = one_step_before + two_steps_before; two_steps_before = one_step_before; one_step_before = all_ways; &#125; return all_ways;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[069. Sqrt(x)]]></title>
    <url>%2Fp%2Fae863641%2F</url>
    <content type="text"><![CDATA[27.9% https://leetcode.com/problems/sqrtx/ Implement int sqrt(int x). Compute and return the square root of x. 方法一： 基本方法，二分搜索 1234567891011121314151617class Solution &#123;public: int sqrt(int x) &#123; if (0 == x) return 0; int left = 1, right = x, ans; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (mid &lt;= x / mid) &#123; left = mid + 1; ans = mid; &#125; else &#123; right = mid - 1; &#125; &#125; return ans; &#125;&#125;; 我的代码实现： 1234567891011121314151617class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return x; // 先对特殊情况判断 int left=1, right=x, ans; while(left&lt;=right)&#123; // 判断条件left&lt;=right int mid = left + (right-left)/2; if(mid&lt;=x/mid)&#123; // 如果mid*mid可能超出int范围 left = mid + 1; ans = mid; &#125;else&#123; right = mid - 1; &#125; &#125; return ans; &#125;&#125;; 方法二： 我的代码实现： 123456789101112class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return 0; double res = x; double delta = 0.0001; while(abs(pow(res, 2)-x)&gt;delta)&#123; res = (res + x/res)/2; &#125; return int(res); &#125;&#125;; 1234567891011f(x) = ans^2 - x = 0f&apos;(x) = 2*ans y = f&apos;(ans)*(nex - ans) + f(ans)y = 0=&gt; nex = ans - f(ans) / f&apos;(ans)迭代方法 Newton方法，迭代 The key point is the average result is calculate by “ans = (ans + x / ans) / 2”; 12345678int sqrt(int x) &#123; double ans = x; double delta = 0.0001; while (fabs(pow(ans, 2) - x) &gt; delta) &#123; ans = (ans + x / ans) / 2; &#125; return ans;&#125; 我的代码实现： 123456789101112class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return x; double ans = x; // 注意此处用的是double，不是int double delta = 0.0001; // 用double，而不是int while(fabs(pow(ans,2) - x)&gt;delta)&#123; ans = (ans + x/ans)/2; &#125; return ans; &#125;&#125;; 方法三： 牛顿法的另一种实现 12345678910class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return 0; long long r = x; while(r*r &gt; x) r = (r+x/r)/2; return r; &#125;&#125;; https://discuss.leetcode.com/topic/24532/3-4-short-lines-integer-newton-every-language 3-4 short lines, Integer Newton, Every Language Quite a few people used Newton already, but I didn’t see someone make it this short. Same solution in every language. Explanation under the solutions. C++ and C 1234long r = x;while (r*r &gt; x) r = (r + x/r) / 2;return r; Python 1234r = xwhile r*r &gt; x: r = (r + x/r) / 2return r Java and C# 1234long r = x;while (r*r &gt; x) r = (r + x/r) / 2;return (int) r; Explanation Apparently, using only integer division for the Newton method works. And I guessed that if I start at x, the root candidate will decrease monotonically and never get too small. The above solutions all got accepted, and in C++ I also verified it locally on my PC for all possible inputs (0 to 2147483647): 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std;int mySqrt(int x) &#123; long long r = x; while (r*r &gt; x) r = (r + x/r) / 2; return r;&#125;int main() &#123; for (long long x=0; x&lt;=INT_MAX; ++x) &#123; long long r = mySqrt(x); if (r&lt;0 || r*r &gt; x || (r+1)*(r+1) &lt;= x) cout &lt;&lt; &quot;false: &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl; if (x % 10000000 == 0) cout &lt;&lt; x &lt;&lt; endl; &#125; cout &lt;&lt; &quot;all checked&quot; &lt;&lt; endl;&#125; https://discuss.leetcode.com/topic/1225/solve-this-problem-with-binary-search Solve this problem with Binary Search 1234567891011121314151617class Solution &#123;public: int sqrt(int x) &#123; if (0 == x) return 0; int left = 1, right = x, ans; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (mid &lt;= x / mid) &#123; left = mid + 1; ans = mid; &#125; else &#123; right = mid - 1; &#125; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/8689/newton-s-iterative-method-in-c Newton’s Iterative Method in C++ 12345678int sqrt(int x) &#123; double ans = x; double delta = 0.0001; while (fabs(pow(ans, 2) - x) &gt; delta) &#123; ans = (ans + x / ans) / 2; &#125; return ans;&#125; The key point is the average result is calculate by “ans = (ans + x / ans) / 2”; For instance, when calculate sqrt(2) : 12345Guess Result Quotient Average Result 1 2 / 1 = 2 (2 + 1) / 2 = 1.5 1.5 2 / 1.5 = 1.3333 (1.3333 + 1.5) / 2 = 1.4167 1.4167 2 / 1.4167 = 1.4118 (1.4167 + 1.4118) / 2 = 1.4142 ... ... https://discuss.leetcode.com/topic/19698/my-clean-c-code-8ms My clean C++ code 8ms Binary search and high is always converged to the one that 1 larger than the result. 123456789101112131415class Solution &#123;public: int mySqrt(int x) &#123; int low = 0, high = x, mid; if(x&lt;2) return x; // to avoid mid = 0 while(low&lt;high) &#123; mid = (low + high)/2; if(x/mid &gt;= mid) low = mid+1; else high = mid; &#125; return high-1; &#125;&#125;; python https://discuss.leetcode.com/topic/5472/newton-method-accepted-solution Newton method, accepted solution. 1234567891011class Solution:# @param x, an integer# @return an integerdef sqrt(self, x): i=1.0; while(True): j=(i+x/i)/2.0; if(abs(i-j)&lt; 0.000000000005): break; i=j; return int(j); java https://discuss.leetcode.com/topic/8680/a-binary-search-solution A Binary Search Solution Instead of using fancy Newton’s method, this plain binary search approach also works. 123456789101112131415public int sqrt(int x) &#123; if (x == 0) return 0; int left = 1, right = Integer.MAX_VALUE; while (true) &#123; int mid = left + (right - left)/2; if (mid &gt; x/mid) &#123; right = mid - 1; &#125; else &#123; if (mid + 1 &gt; x/(mid + 1)) return mid; left = mid + 1; &#125; &#125;&#125; https://discuss.leetcode.com/topic/2671/share-my-o-log-n-solution-using-bit-manipulation Share my O(log n) Solution using bit manipulation Basic Idea: Since sqrt(x) is composed of binary bits, I calculate sqrt(x) by deciding every bit from the most significant to least significant. Since an integer n can have O(log n) bits with each bit decided within constant time, this algorithm has time limit O(log n), actually, because an Integer can have at most 32 bits, I can also say this algorithm takes O(32)=O(1) time. 12345678910111213141516public int sqrt(int x) &#123; if(x==0) return 0; int h=0; while((long)(1&lt;&lt;h)*(long)(1&lt;&lt;h)&lt;=x) // firstly, find the most significant bit h++; h--; int b=h-1; int res=(1&lt;&lt;h); while(b&gt;=0)&#123; // find the remaining bits if((long)(res | (1&lt;&lt;b))*(long)(res |(1&lt;&lt;b))&lt;=x) res|=(1&lt;&lt;b); b--; &#125; return res;&#125; https://discuss.leetcode.com/topic/35357/share-my-2ms-and-4lines-java-code Share my 2ms and 4lines JAVA code, My idea is, for any non-negative number N, sqrt(N) = 2/2sqrt(N) =2sqrt(1/4)sqrt(N) = 2sqrt(N/4). And for the Ns that are not multiple of 4, for example, 9, 25 or 49, the actual result should be 1+2*sqrt(N/4), because we need to take remainders into account. 123456public int mySqrt(int x) &#123; if(x &lt; 4) return x == 0 ? 0 : 1; int res = 2 * mySqrt(x/4); if((res+1) * (res+1) &lt;= x &amp;&amp; (res+1) * (res+1) &gt;= 0) return res+1; return res;&#125; Hope it helps.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>math</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[068. Text Justification]]></title>
    <url>%2Fp%2F91398cc3%2F</url>
    <content type="text"><![CDATA[19.1% https://leetcode.com/problems/text-justification/ Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly L characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. 12345678910For example,words: [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]L: 16.Return the formatted lines as:[&quot;This is an&quot;,&quot;example of text&quot;,&quot;justification. &quot;] Note: Each word is guaranteed not to exceed L in length. click to show corner cases. Corner Cases: A line other than the last line might contain only one word. What should you do in this case? In this case, that line should be left-justified. https://discuss.leetcode.com/topic/7256/what-does-this-question-aim-to-teach What does this question aim to teach? In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. As far as I understand the “idea” of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. In this question’s description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. Do you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned? https://discuss.leetcode.com/topic/7256/what-does-this-question-aim-to-teach/4 it teaches you in the real world. Programmers are always been ask to deal with dirty works. cpp https://discuss.leetcode.com/topic/4189/share-my-concise-c-solution-less-than-20-lines Share my concise c++ solution - less than 20 lines 1234567891011121314151617vector&lt;string&gt; fullJustify(vector&lt;string&gt; &amp;words, int L) &#123; vector&lt;string&gt; res; for(int i = 0, k, l; i &lt; words.size(); i += k) &#123; for(k = l = 0; i + k &lt; words.size() and l + words[i+k].size() &lt;= L - k; k++) &#123; l += words[i+k].size(); &#125; string tmp = words[i]; for(int j = 0; j &lt; k - 1; j++) &#123; if(i + k &gt;= words.size()) tmp += &quot; &quot;; else tmp += string((L - l) / (k - 1) + (j &lt; (L - l) % (k - 1)), &apos; &apos;); tmp += words[i+j+1]; &#125; tmp += string(L - tmp.size(), &apos; &apos;); res.push_back(tmp); &#125; return res;&#125; For each line, I first figure out which words can fit in. According to the code, these words are words[i] through words[i+k-1]. Then spaces are added between the words. The trick here is to use mod operation to manage the spaces that can’t be evenly distrubuted: the first (L-l) % (k-1) gaps acquire an additional space. https://discuss.leetcode.com/topic/11507/share-my-2-ms-30-lines-solution Share my 2 ms, 30 lines solution 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;string&gt; fullJustify(vector&lt;string&gt; &amp;words, int L) &#123; vector&lt;string&gt; ans; int begin = 0; while (begin &lt; words.size()) &#123; int last = begin; int linesize = words[begin++].size(); while (begin &lt; words.size() &amp;&amp; linesize + 1 + words[begin].size() &lt;= L) &#123; linesize += 1 + words[begin].size(); begin++; &#125; int spaces = 1, extra = 0; if (begin &lt; words.size() &amp;&amp; begin != last + 1) &#123; spaces = (L - linesize) / (begin - last - 1) + 1; extra = (L - linesize) % (begin - last - 1); &#125; ans.push_back(words[last++]); while (extra--) &#123; ans.back().append(spaces+1, &apos; &apos;); ans.back().append(words[last++]); &#125; while (last &lt; begin) &#123; ans.back().append(spaces, &apos; &apos;); ans.back().append(words[last++]); &#125; ans.back().append(L-ans.back().size(), &apos; &apos;); &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/6946/easy-understanding-solution Easy understanding solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546vector&lt;string&gt; fullJustify(vector&lt;string&gt; &amp;words, int L) &#123; vector&lt;string&gt; ans, vs; string str; int len = 0; for (int i = 0; i &lt; words.size(); ++i) &#123; if (len + vs.size() + words[i].size() &lt;= L) &#123; // vs not full, need to get more words in the line vs.push_back(words[i]); len += words[i].size(); &#125; else &#123; // vs full, get the whole line if (vs.size() == 1) &#123; // just one word, the left justify str = vs[0]; str.append(L - str.size(), &apos; &apos;); ans.push_back(str); &#125; else if (vs.size() &gt; 1) &#123; // the first &quot;mod&quot; words get &quot;div+1&quot; spaces // the remaining words get &quot;div&quot; spaces int div = (L - len) / (vs.size() - 1); int mod = (L - len) % (vs.size() - 1); str = vs[0]; for (int j = 1; j &lt; vs.size(); ++j) &#123; if (j &lt;= mod) str.append(div+1, &apos; &apos;); // one more space else str.append(div, &apos; &apos;); str += vs[j]; &#125; ans.push_back(str); &#125; vs.clear(); vs.push_back(words[i]); len = words[i].size(); &#125; &#125; // the last line, left justified and no extra space is inserted between words str = vs[0]; for (int j = 1; j &lt; vs.size(); ++j) str += &apos; &apos; + vs[j]; str.append(L-str.size(), &apos; &apos;); ans.push_back(str); return ans;&#125; python 58ms, 18.55%, September 23, 2016 https://discuss.leetcode.com/topic/25970/concise-python-solution-10-lines Concise python solution, 10 lines. 1234567891011def fullJustify(self, words, maxWidth): res, cur, num_of_letters = [], [], 0 for w in words: if num_of_letters + len(w) + len(cur) &gt; maxWidth: for i in range(maxWidth - num_of_letters): cur[i%(len(cur)-1 or 1)] += &apos; &apos; res.append(&apos;&apos;.join(cur)) cur, num_of_letters = [], 0 cur += [w] num_of_letters += len(w) return res + [&apos; &apos;.join(cur).ljust(maxWidth)] How does it work? Well in the question statement, the sentence “Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right” was just a really long and awkward way to say round robin. The following line implements the round robin logic: 12for i in range(maxWidth - num_of_letters): cur[i%(len(cur)-1 or 1)] += &apos; &apos; What does this line do? Once you determine that there are only k words that can fit on a given line, you know what the total length of those words is num_of_letters. Then the rest are spaces, and there are (maxWidth - num_of_letters) of spaces. The “or 1” part is for dealing with the edge case len(cur) == 1. The following is my older solution for reference, longer and less clear. The idea is the same, but I did not figure out the nice way to distribute the space at the time. 1234567891011121314151617def fullJustify(self, words, maxWidth): res, cur, num_of_letters = [], [], 0 for w in words: if num_of_letters + len(w) + len(cur) &gt; maxWidth: if len(cur) == 1: res.append( cur[0] + &apos; &apos;*(maxWidth - num_of_letters) ) else: num_spaces = maxWidth - num_of_letters space_between_words, num_extra_spaces = divmod( num_spaces, len(cur)-1) for i in range(num_extra_spaces): cur[i] += &apos; &apos; res.append( (&apos; &apos;*space_between_words).join(cur) ) cur, num_of_letters = [], 0 cur += [w] num_of_letters += len(w) res.append( &apos; &apos;.join(cur) + &apos; &apos;*(maxWidth - num_of_letters - len(cur) + 1) ) return res https://discuss.leetcode.com/topic/36136/15-line-python-solution-40ms 15-line Python solution, 40ms 123456789101112131415161718def fullJustify(self, words, maxWidth): i, N, result = 0, len(words), [] while i &lt; N: # decide how many words to be put in one line oneLine, j, currWidth, positionNum, spaceNum = [words[i]], i + 1, len(words[i]), 0, maxWidth - len(words[i]) while j &lt; N and currWidth + 1 + len(words[j]) &lt;= maxWidth: oneLine.append(words[j]) currWidth += 1 + len(words[j]) spaceNum -= len(words[j]) positionNum, j = positionNum + 1, j + 1 i = j # decide the layout of one line if i &lt; N and positionNum: spaces = [&apos; &apos; * (spaceNum / positionNum + (k &lt; spaceNum % positionNum)) for k in range(positionNum)] + [&apos;&apos;] else: # last line or the line only has one word spaces = [&apos; &apos;] * positionNum + [&apos; &apos; * (maxWidth - currWidth)] result.append(&apos;&apos;.join([s for pair in zip(oneLine, spaces) for s in pair])) return result java https://discuss.leetcode.com/topic/9147/simple-java-solution Simple Java Solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public List&lt;String&gt; fullJustify(String[] words, int L) &#123; List&lt;String&gt; lines = new ArrayList&lt;String&gt;(); int index = 0; while (index &lt; words.length) &#123; int count = words[index].length(); int last = index + 1; while (last &lt; words.length) &#123; if (words[last].length() + count + 1 &gt; L) break; count += words[last].length() + 1; last++; &#125; StringBuilder builder = new StringBuilder(); int diff = last - index - 1; // if last line or number of words in the line is 1, left-justified if (last == words.length || diff == 0) &#123; for (int i = index; i &lt; last; i++) &#123; builder.append(words[i] + &quot; &quot;); &#125; builder.deleteCharAt(builder.length() - 1); for (int i = builder.length(); i &lt; L; i++) &#123; builder.append(&quot; &quot;); &#125; &#125; else &#123; // middle justified int spaces = (L - count) / diff; int r = (L - count) % diff; for (int i = index; i &lt; last; i++) &#123; builder.append(words[i]); if (i &lt; last - 1) &#123; for (int j = 0; j &lt;= (spaces + ((i - index) &lt; r ? 1 : 0)); j++) &#123; builder.append(&quot; &quot;); &#125; &#125; &#125; &#125; lines.add(builder.toString()); index = last; &#125; return lines; &#125;&#125; 3ms, 1.45%, September 22, 2016 https://discuss.leetcode.com/topic/4189/share-my-concise-c-solution-less-than-20-lines 1234567891011121314151617181920class Solution &#123;public: vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int L) &#123; vector&lt;string&gt; res; for(int i=0, k, l; i&lt;words.size(); i+=k)&#123; for(k=l=0; i+k&lt;words.size() and l+words[i+k].size() &lt;= L-k; k++)&#123; l += words[i+k].size(); &#125; string tmp = words[i]; for(int j=0; j&lt;k-1; j++)&#123; if(i+k&gt;=words.size()) tmp += &quot; &quot;; else tmp+=string((L-l)/(k-1) + (j&lt;(L-l)%(k-1)), &apos; &apos;); tmp += words[i+j+1]; &#125; tmp += string(L-tmp.size(), &apos; &apos;); res.push_back(tmp); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[067. Add Binary]]></title>
    <url>%2Fp%2Fde93a709%2F</url>
    <content type="text"><![CDATA[32.5% https://leetcode.com/problems/add-binary/ Given two binary strings, return their sum (also a binary string). 1234For example,a = &quot;11&quot;b = &quot;1&quot;Return &quot;100&quot;. 方法一： 根据最基本的规则运算，类似于链表求和 https://discuss.leetcode.com/topic/8981/short-code-by-c Short code by c++ 12345678910111213141516171819class Solution&#123;public: string addBinary(string a, string b) &#123; string s = &quot;&quot;; int c = 0, i = a.size() - 1, j = b.size() - 1; while(i &gt;= 0 || j &gt;= 0 || c == 1) &#123; c += i &gt;= 0 ? a[i --] - &apos;0&apos; : 0; c += j &gt;= 0 ? b[j --] - &apos;0&apos; : 0; s = char(c % 2 + &apos;0&apos;) + s; c /= 2; &#125; return s; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324class Solution &#123;public: string addBinary(string a, string b) &#123; if(a.empty()) return b; if(b.empty()) return a; int carry = 0; int i = a.size()-1; int j = b.size()-1; string res = ""; while(i&gt;=0 || j&gt;=0 || carry)&#123; int l = i&gt;=0? a[i]-'0' : 0; int r = j&gt;=0 ? b[j]-'0' : 0; carry = l+r+carry; res += char(carry%2 + '0'); carry /= 2; if(i&gt;=0) i--; if(j&gt;=0) j--; &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 4ms, 30.34%, 16 July 2016 https://discuss.leetcode.com/topic/16441/short-o-n-time-o-1-space-c-solution Short O(n) time, O(1) space C++ solution I just write the sum into the longer one of the inputs. Don’t worry about modifying them, as getting string means we’re getting copies. The “O(1) space” of course refers to the space I use in addition to input and output. If the output doesn’t need to be longer than the longer input, I even only use O(1) space in addition to only the input. 12345678910111213141516class Solution &#123;public: string addBinary(string a, string b) &#123; if (a.size() &lt; b.size()) swap(a, b); int i = a.size(), j = b.size(); while (i--) &#123; if (j) a[i] += b[--j] &amp; 1; if (a[i] &gt; &apos;1&apos;) &#123; a[i] -= 2; if (i) a[i-1]++; else a = &apos;1&apos; + a; &#125; &#125; return a; &#125;&#125;; python 76ms, 34.89%, 16 July, 2016 https://discuss.leetcode.com/topic/19383/one-line-python-solution 12345678class Solution(object): def addBinary(self, a, b): &quot;&quot;&quot; :type a: str :type b: str :rtype: str &quot;&quot;&quot; return bin(eval(&apos;0b&apos;+a) + eval(&apos;0b&apos;+b))[2:] 60ms, 80.04%, 16 July 2016 https://discuss.leetcode.com/topic/12116/simple-python-solution-76ms if int() function is allowed, the following code may be more simple. :) 12345678910class Solution(object): def addBinary(self, a, b): &quot;&quot;&quot; :type a: str :type b: str :rtype: str &quot;&quot;&quot; a = int(a, 2) b = int(b, 2) return (&apos;&apos; + bin(a+b))[2:] Simple Python Solution 76ms I assume using int and str is okay, I think this is easy to understand. 12345678910111213141516def addBinary(self, a, b): result = &apos;&apos; index = 0 carry = &apos;0&apos; while index &lt; max(len(a), len(b)) or carry == &apos;1&apos;: num_a = a[-1 - index] if index &lt; len(a) else &apos;0&apos; num_b = b[-1 - index] if index &lt; len(b) else &apos;0&apos; val = int(num_a) + int(num_b) + int(carry) result = str(val % 2) + result carry = &apos;1&apos; if val &gt; 1 else &apos;0&apos; index += 1 return result update No int and str version. 123456789101112131415161718192021222324252627class Solution:# @param a, a string# @param b, a string# @return a string# 75msdef addBinary(self, a, b): result = &apos;&apos; index = 0 carry = &apos;0&apos; while index &lt; max(len(a), len(b)) or carry == &apos;1&apos;: num_a = a[-1 - index] if index &lt; len(a) else &apos;0&apos; num_b = b[-1 - index] if index &lt; len(b) else &apos;0&apos; val = self.to_int(num_a) + self.to_int(num_b) + self.to_int(carry) result = &quot;%s%s&quot; % (val % 2, result) carry = &apos;1&apos; if val &gt; 1 else &apos;0&apos; index += 1 return resultdef to_int(self, c): if c == &apos;1&apos;: return 1 elif c == &apos;0&apos;: return 0 java https://discuss.leetcode.com/topic/13698/short-ac-solution-in-java-with-explanation Short AC solution in Java with explanation Computation from string usually can be simplified by using a carry as such. 123456789101112131415public class Solution &#123; public String addBinary(String a, String b) &#123; StringBuilder sb = new StringBuilder(); int i = a.length() - 1, j = b.length() -1, carry = 0; while (i &gt;= 0 || j &gt;= 0) &#123; int sum = carry; if (j &gt;= 0) sum += b.charAt(j--) - &apos;0&apos;; if (i &gt;= 0) sum += a.charAt(i--) - &apos;0&apos;; sb.append(sum % 2); carry = sum / 2; &#125; if (carry != 0) sb.append(carry); return sb.reverse().toString(); &#125;&#125; https://discuss.leetcode.com/topic/5172/simple-accepted-java-solution Simple accepted java solution Addition bits are calculated by xor. Carry bit is calculated as simple integer addition.1234567891011121314151617181920212223242526272829public class Solution &#123; public String addBinary(String a, String b) &#123; if(a == null || a.isEmpty()) &#123; return b; &#125; if(b == null || b.isEmpty()) &#123; return a; &#125; char[] aArray = a.toCharArray(); char[] bArray = b.toCharArray(); StringBuilder stb = new StringBuilder(); int i = aArray.length - 1; int j = bArray.length - 1; int aByte; int bByte; int carry = 0; int result; while(i &gt; -1 || j &gt; -1 || carry == 1) &#123; aByte = (i &gt; -1) ? Character.getNumericValue(aArray[i--]) : 0; bByte = (j &gt; -1) ? Character.getNumericValue(bArray[j--]) : 0; result = aByte ^ bByte ^ carry; carry = ((aByte + bByte + carry) &gt;= 2) ? 1 : 0; stb.append(result); &#125; return stb.reverse().toString(); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[066. Plus One]]></title>
    <url>%2Fp%2F15c6dd1%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/plus-one/ Given a non-negative number represented as an array of digits, plus one to the number. The digits are stored such that the most significant digit is at the head of the list. https://discuss.leetcode.com/topic/987/to-avoid-confusion-please-mention-that-the-lowest-digit-is-on-the-right-end To avoid confusion, please mention that the lowest digit is on the right end The question description does not explicitly say that. I found that is the case. https://discuss.leetcode.com/topic/1264/missing-information Missing information When I started writing the solution I was thinking we were talking about binary digits, please add this information to the text of the problem. The numerical base requested. Would be cool to have a more general problem that also passes the numerical base to the function ;-) 方法一： 更改每一位，从最后一位向前走。 如果尾数是9，就改为0。 如果到某一位不是9，直接返回。 如果走到头都是9，则第一位改为1，最后加一位0. code 1： 12345678910111213141516171819void plusone(vector&lt;int&gt; &amp;digits)&#123; int n = digits.size(); for (int i = n - 1; i &gt;= 0; --i) &#123; if (digits[i] == 9) &#123; digits[i] = 0; &#125; else &#123; digits[i]++; return; &#125; &#125; digits[0] =1; digits.push_back(0); &#125; code 2： 1234567891011class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; for (int i=digits.size(); i--; digits[i] = 0) if (digits[i]++ &lt; 9) return digits; digits[0]++; digits.push_back(0); return digits; &#125;&#125;; java https://discuss.leetcode.com/topic/24288/my-simple-java-solution My Simple Java Solution 1234567891011121314151617public int[] plusOne(int[] digits) &#123; int n = digits.length; for(int i=n-1; i&gt;=0; i--) &#123; if(digits[i] &lt; 9) &#123; digits[i]++; return digits; &#125; digits[i] = 0; &#125; int[] newNumber = new int [n+1]; newNumber[0] = 1; return newNumber;&#125; https://discuss.leetcode.com/topic/19149/simple-java-solution Simple java solution 12345678910111213141516public int[] plusOne(int[] digits) &#123; for (int i = digits.length - 1; i &gt;=0; i--) &#123; if (digits[i] != 9) &#123; digits[i]++; break; &#125; else &#123; digits[i] = 0; &#125; &#125; if (digits[0] == 0) &#123; int[] res = new int[digits.length+1]; res[0] = 1; return res; &#125; return digits;&#125; https://discuss.leetcode.com/topic/41728/java-concise-solution-with-early-return Java concise solution with early return. 123456789101112public int[] plusOne(int[] digits) &#123; int carry = 1; for (int i = digits.length-1; i&gt;= 0; i--) &#123; digits[i] += carry; if (digits[i] &lt;= 9) // early return return digits; digits[i] = 0; &#125; int[] ret = new int[digits.length+1]; ret[0] = 1; return ret;&#125; 0ms, 38.09%, June.17th, 2016 http://www.itnose.net/news/172/6334216 12345678910111213141516171819202122232425public class Solution &#123; public int[] plusOne(int[] digits) &#123; int carry = 1; // 进位标志，下一位来的进位标志 int tmp; for (int i = digits.length - 1; i &gt;= 0; i--) &#123; tmp = digits[i]; digits[i] = (tmp + carry) % 10; // 计算当前位的新值 carry = (tmp + carry) / 10; // 计算新的进位 if (carry == 0) &#123; // 没有进位了就可以退出了 break; &#125; &#125; if (carry == 1) &#123; // 最后还有一个进位 int[] result = new int[digits.length + 1]; System.arraycopy(digits, 0, result, 1, digits.length); result[0] = carry;; return result; &#125; else &#123; return digits; &#125; &#125;&#125; cpp https://discuss.leetcode.com/topic/4556/is-it-a-simple-code-c Is it a simple code(C++)? 12345678910111213141516171819void plusone(vector&lt;int&gt; &amp;digits)&#123; int n = digits.size(); for (int i = n - 1; i &gt;= 0; --i) &#123; if (digits[i] == 9) &#123; digits[i] = 0; &#125; else &#123; digits[i]++; return; &#125; &#125; digits[0] =1; digits.push_back(0); &#125; https://discuss.leetcode.com/topic/9016/my-c-solution-with-few-lines My C++ Solution with few lines 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt; &amp;digits) &#123; bool carry = true; for(int i=digits.size()-1; i &gt;= 0 &amp;&amp; carry; i--) &#123; carry = (++digits[i]%=10) == 0; &#125; if(carry) &#123; digits.insert(digits.begin(), 1); &#125; return digits; &#125;&#125;; 4ms, 9.24%, June.17th, 2016 https://leetcode.com/discuss/14616/is-it-a-simple-code-c 1234567891011class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; for (int i=digits.size(); i--; digits[i] = 0) if (digits[i]++ &lt; 9) return digits; digits[0]++; digits.push_back(0); return digits; &#125;&#125;; python 46ms, 94.03%, June.17th, 2016 https://leetcode.com/discuss/18768/simple-python-solution-with-explanation-plus-one Simple Python solution with explanation (Plus One) 12345def plusOne(digits): num = 0 for i in range(len(digits)): num += digits[i] * pow(10, (len(digits)-1-i)) return [int(i) for i in str(num+1)] We’re given a list of digits, and the idea here is to convert that list to an integer, num. So each digit is multiplied by the proper place value and added to num. For example, if digits = [3, 8, 2, 5] then on the first iteration 3 is multiplied by 10 to the power of 4-1-0 = 3, so this results in 3000, which is added to num. Then 8 is multiplied by 10^2 and added to num, and so on. The last step is to add 1 to num, convert it to a list and return that list.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[065. Valid Number]]></title>
    <url>%2Fp%2Fdad046c3%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/valid-number/ Validate if a given string is numeric. 123456Some examples:&quot;0&quot; =&gt; true&quot; 0.1 &quot; =&gt; true&quot;abc&quot; =&gt; false&quot;1 a&quot; =&gt; false&quot;2e10&quot; =&gt; true Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. https://discuss.leetcode.com/topic/1095/the-worst-problem-i-have-ever-met-in-this-oj The worst problem i have ever met in this oj The description do not give a clear explantion of the definition of a valid Number, we just use more and more trick to get the right solution. It’s too bad, it’s waste of my time https://discuss.leetcode.com/topic/1095/the-worst-problem-i-have-ever-met-in-this-oj/4 +1 for the worst problem on OJ. This is definitely a valid interview question, but it requires heavy clarification through interaction. In a real interview, you have one and only one source to get all the missing information, a.k.a. your interviewer. On OJ, however, there is no interaction whatsoever except through trial and error. This, as far as I am concerned, is directly against the principle of ‘collecting all the info before implementing’. Internet searching also does not work since the word ‘numeric’ is not even defined in the question. No wonder this relatively easy (implementation-wise) problem has one of the lowest rates of acceptance. I would suggest OJ: provide all the details to let users focus on the implementation, or leave room for ambiguity but also suggest where the info can be collected, or provide an interactive applet or something like that on the page so that the user can try the string combinations that they are uncertain of before implementing. I think this is an easy thing to do, and it saves everybody’s time. java https://discuss.leetcode.com/topic/9490/clear-java-solution-with-ifs Clear Java solution with ifs All we need is to have a couple of flags so we can process the string in linear time: 123456789101112131415161718192021222324252627282930313233public boolean isNumber(String s) &#123; s = s.trim(); boolean pointSeen = false; boolean eSeen = false; boolean numberSeen = false; boolean numberAfterE = true; for(int i=0; i&lt;s.length(); i++) &#123; if(&apos;0&apos; &lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= &apos;9&apos;) &#123; numberSeen = true; numberAfterE = true; &#125; else if(s.charAt(i) == &apos;.&apos;) &#123; if(eSeen || pointSeen) &#123; return false; &#125; pointSeen = true; &#125; else if(s.charAt(i) == &apos;e&apos;) &#123; if(eSeen || !numberSeen) &#123; return false; &#125; numberAfterE = false; eSeen = true; &#125; else if(s.charAt(i) == &apos;-&apos; || s.charAt(i) == &apos;+&apos;) &#123; if(i != 0 &amp;&amp; s.charAt(i-1) != &apos;e&apos;) &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; return numberSeen &amp;&amp; numberAfterE;&#125; We start with trimming. If we see [0-9] we reset the number flags. We can only see . if we didn’t see e or .. We can only see e if we didn’t see e but we did see a number. We reset numberAfterE flag. We can only see + and - in the beginning and after an e any other character break the validation. At the and it is only valid if there was at least 1 number and if we did see an e then a number after it as well. So basically the number should match this regular expression: 1[-+]?(([0-9]+(.[0-9]*)?)|.[0-9]+)(e[-+]?[0-9]+)? https://discuss.leetcode.com/topic/8029/a-clean-design-solution-by-using-design-pattern A clean design solution By using design pattern This problem give me a good chance to convey the importance of good design. The problem is very vogue. The point here is not how you design a algorithm, it is how you handle all cases well. There is no a clear standard for whether is a number valid, is it .50 , 39. a legal float point number? Are there only valid formats given by the example? Is hex format such as 0x12ab legal? How about if we need to add another format such as roman number like “I, II , IV” as legal format. I found all solution are just plug logic into one function, there are lots of switch case, if else in there. It is problematic, easy for bugs, difficult to add new features, and of course, in-reusable, and here I propose a design to handle this problem easily and nicely. First we we can give out an interface for this problem: 1234interface NumberValidate &#123; boolean validate(String s);&#125; for any string, we call validate and it return whether the given string is a valid number. Follow we can create concrete implementation for this interface, such as IntegeValidator, FloatValidator, ScienceValidator. and then using chain of responsibility design patter (from book of GOF) , chain all those validator into a list, and feed the string to each one, if there is one validator return true, then the string is a valid number. The design has two advantages, one is easy to fix, for any corner cases or bug, we can locate the problem to specific validator, the effect of changing one validator will not sprint out to the all system, we call this as “encapsulation”. Second is easy to extend, if we need to verify hex format or roman number format , we just need to create new validator and add to the chain, we call this advantage as “close for modification open for extension”. Follow is code for the passed design: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295interface NumberValidate &#123; boolean validate(String s);&#125;abstract class NumberValidateTemplate implements NumberValidate&#123;public boolean validate(String s) &#123; if (checkStringEmpty(s)) &#123; return false; &#125; s = checkAndProcessHeader(s); if (s.length() == 0) &#123; return false; &#125; return doValidate(s); &#125; private boolean checkStringEmpty(String s) &#123; if (s.equals(&quot;&quot;)) &#123; return true; &#125; return false; &#125; private String checkAndProcessHeader(String value) &#123; value = value.trim(); if (value.startsWith(&quot;+&quot;) || value.startsWith(&quot;-&quot;)) &#123; value = value.substring(1); &#125; return value; &#125; protected abstract boolean doValidate(String s);&#125;class NumberValidator implements NumberValidate &#123; private ArrayList&lt;NumberValidate&gt; validators = new ArrayList&lt;NumberValidate&gt;(); public NumberValidator() &#123; addValidators(); &#125; private void addValidators() &#123; NumberValidate nv = new IntegerValidate(); validators.add(nv); nv = new FloatValidate(); validators.add(nv); nv = new HexValidate(); validators.add(nv); nv = new SienceFormatValidate(); validators.add(nv); &#125; @Override public boolean validate(String s) &#123; for (NumberValidate nv : validators) &#123; if (nv.validate(s) == true) &#123; return true; &#125; &#125; return false; &#125; &#125;class IntegerValidate extends NumberValidateTemplate&#123; protected boolean doValidate(String integer) &#123; for (int i = 0; i &lt; integer.length(); i++) &#123; if(Character.isDigit(integer.charAt(i)) == false) &#123; return false; &#125; &#125; return true; &#125;&#125;class HexValidate extends NumberValidateTemplate&#123; private char[] valids = new char[] &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;&#125;; protected boolean doValidate(String hex) &#123; hex = hex.toLowerCase(); if (hex.startsWith(&quot;0x&quot;)) &#123; hex = hex.substring(2); &#125; else &#123; return false; &#125; for (int i = 0; i &lt; hex.length(); i++) &#123; if (Character.isDigit(hex.charAt(i)) != true &amp;&amp; isValidChar(hex.charAt(i)) != true) &#123; return false; &#125; &#125; return true; &#125; private boolean isValidChar(char c) &#123; for (int i = 0; i &lt; valids.length; i++) &#123; if (c == valids[i]) &#123; return true; &#125; &#125; return false; &#125;&#125;class SienceFormatValidate extends NumberValidateTemplate&#123;protected boolean doValidate(String s) &#123; s = s.toLowerCase(); int pos = s.indexOf(&quot;e&quot;); if (pos == -1) &#123; return false; &#125; if (s.length() == 1) &#123; return false; &#125; String first = s.substring(0, pos); String second = s.substring(pos+1, s.length()); if (validatePartBeforeE(first) == false || validatePartAfterE(second) == false) &#123; return false; &#125; return true; &#125; private boolean validatePartBeforeE(String first) &#123; if (first.equals(&quot;&quot;) == true) &#123; return false; &#125; if (checkHeadAndEndForSpace(first) == false) &#123; return false; &#125; NumberValidate integerValidate = new IntegerValidate(); NumberValidate floatValidate = new FloatValidate(); if (integerValidate.validate(first) == false &amp;&amp; floatValidate.validate(first) == false) &#123; return false; &#125; return true; &#125; private boolean checkHeadAndEndForSpace(String part) &#123; if (part.startsWith(&quot; &quot;) || part.endsWith(&quot; &quot;)) &#123; return false; &#125; return true; &#125; private boolean validatePartAfterE(String second) &#123; if (second.equals(&quot;&quot;) == true) &#123; return false; &#125; if (checkHeadAndEndForSpace(second) == false) &#123; return false; &#125; NumberValidate integerValidate = new IntegerValidate(); if (integerValidate.validate(second) == false) &#123; return false; &#125; return true; &#125;&#125;class FloatValidate extends NumberValidateTemplate&#123; protected boolean doValidate(String floatVal) &#123; int pos = floatVal.indexOf(&quot;.&quot;); if (pos == -1) &#123; return false; &#125; if (floatVal.length() == 1) &#123; return false; &#125; NumberValidate nv = new IntegerValidate(); String first = floatVal.substring(0, pos); String second = floatVal.substring(pos + 1, floatVal.length()); if (checkFirstPart(first) == true &amp;&amp; checkFirstPart(second) == true) &#123; return true; &#125; return false; &#125; private boolean checkFirstPart(String first) &#123; if (first.equals(&quot;&quot;) == false &amp;&amp; checkPart(first) == false) &#123; return false; &#125; return true; &#125; private boolean checkPart(String part) &#123; if (Character.isDigit(part.charAt(0)) == false || Character.isDigit(part.charAt(part.length() - 1)) == false) &#123; return false; &#125; NumberValidate nv = new IntegerValidate(); if (nv.validate(part) == false) &#123; return false; &#125; return true; &#125;&#125;public class Solution &#123; public boolean isNumber(String s) &#123; NumberValidate nv = new NumberValidator(); return nv.validate(s); &#125;&#125; https://discuss.leetcode.com/topic/40983/java-logically-simple-flexible-and-clear-solution-including-rules-of-a-valid-number Java logically simple, flexible and clear solution including rules of a valid number The idea is to identify the rules of a valid number first, then set boolean variables to mark key characters and judge the validity. This solution is logically simple and easy to understand, and moreover, it is flexible to extend to the cases where a string of a valid number can accept any space appears anywhere, or/and the exponent can be a decimal number. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public boolean isNumber(String s) &#123; /** * isNumber(s)==true if and only if s=s1 or s1+&apos;e&apos;+s2, where s1, s2 * are valid strings of a number without the char &apos;e&apos;, and s2 is an * integer. * * &apos;e&apos; : valid_count=0~1; [boolean hasE] * * Valid chars in a string of a number without &apos;e&apos;: * * &apos; &apos; : valid_count=0~n; must appear at two ends * * &apos;+/-&apos; : valid_count=0~1; must be the first non-space valid char; * [boolean hasFirst] * * &apos;.&apos; : valid_count=0~1; cannot appear after &apos;e&apos;; [boolean hasDot] * * &apos;0~9&apos; : valid_count=1~n; [boolean hasDigit] */ s = s.trim(); int n = s.length(); if (n == 0) return false; boolean hasE, hasFirst, hasDot, hasDigit; hasE = hasFirst = hasDot = hasDigit = false; char c; for (int i = 0; i &lt; n; i++) &#123; c = s.charAt(i); if (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) &#123; hasFirst = hasDigit = true; continue; &#125; switch (c) &#123; /* * case &apos; &apos;: continue; */ // extend to accept any space everywhere case &apos;e&apos;: // already has &apos;e&apos; or no digit before &apos;e&apos; if (hasE || !hasDigit) return false; hasE = true; // reset for the exponential number hasFirst = hasDigit = false; hasDot = true; // the exponent must be an integer, hence // regard as if a dot exists already. Set // hasDot = false extending to accept any // (decimal) number as an exponent. continue; case &apos;+&apos;: case &apos;-&apos;: if (hasFirst) return false; hasFirst = true; continue; case &apos;.&apos;: if (hasDot) return false; hasFirst = hasDot = true; continue; default: return false; &#125; &#125; return hasDigit; &#125; https://discuss.leetcode.com/topic/2973/java-solution-with-one-line Java solution with one line 1return s.matches(&quot;(\\s*)[+-]?((\\.[0-9]+)|([0-9]+(\\.[0-9]*)?))(e[+-]?[0-9]+)?(\\s*)&quot;); cpp https://discuss.leetcode.com/topic/2710/a-simple-solution-in-cpp A simple solution in cpp The idea is pretty straightforward. A valid number is composed of the significand and the exponent (which is optional). As we go through the string, do the following things one by one: skip the leading whitespaces; check if the significand is valid. To do so, simply skip the leading sign and count the number of digits and the number of points. A valid significand has no more than one point and at least one digit. check if the exponent part is valid. We do this if the significand is followed by ‘e’. Simply skip the leading sign and count the number of digits. A valid exponent contain at least one digit. skip the trailing whitespaces. We must reach the ending 0 if the string is a valid number. 1234567891011121314151617181920212223242526272829303132bool isNumber(const char *s) &#123; int i = 0; // skip the whilespaces for(; s[i] == &apos; &apos;; i++) &#123;&#125; // check the significand if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; // skip the sign if exist int n_nm, n_pt; for(n_nm=0, n_pt=0; (s[i]&lt;=&apos;9&apos; &amp;&amp; s[i]&gt;=&apos;0&apos;) || s[i]==&apos;.&apos;; i++) s[i] == &apos;.&apos; ? n_pt++:n_nm++; if(n_pt&gt;1 || n_nm&lt;1) // no more than one point, at least one digit return false; // check the exponent if exist if(s[i] == &apos;e&apos;) &#123; i++; if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; // skip the sign int n_nm = 0; for(; s[i]&gt;=&apos;0&apos; &amp;&amp; s[i]&lt;=&apos;9&apos;; i++, n_nm++) &#123;&#125; if(n_nm&lt;1) return false; &#125; // skip the trailing whitespaces for(; s[i] == &apos; &apos;; i++) &#123;&#125; return s[i]==0; // must reach the ending 0 of the string&#125; https://discuss.leetcode.com/topic/30058/a-simple-solution-in-python-based-on-dfa A simple solution in Python based on DFA I was asked in the interview of linkedIn, writing it directly can be extremely complicated, for there are many special cases we have to deal with, and the code I wrote was messy. Then I failed to pass the interview. Here’s a clear solution. With DFA we can easily get our idea into shape and then debug, and the source code is clear and simple. 12345678910111213141516171819202122232425262728293031class Solution(object): def isNumber(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; #define a DFA state = [&#123;&#125;, &#123;&apos;blank&apos;: 1, &apos;sign&apos;: 2, &apos;digit&apos;:3, &apos;.&apos;:4&#125;, &#123;&apos;digit&apos;:3, &apos;.&apos;:4&#125;, &#123;&apos;digit&apos;:3, &apos;.&apos;:5, &apos;e&apos;:6, &apos;blank&apos;:9&#125;, &#123;&apos;digit&apos;:5&#125;, &#123;&apos;digit&apos;:5, &apos;e&apos;:6, &apos;blank&apos;:9&#125;, &#123;&apos;sign&apos;:7, &apos;digit&apos;:8&#125;, &#123;&apos;digit&apos;:8&#125;, &#123;&apos;digit&apos;:8, &apos;blank&apos;:9&#125;, &#123;&apos;blank&apos;:9&#125;] currentState = 1 for c in s: if c &gt;= &apos;0&apos; and c &lt;= &apos;9&apos;: c = &apos;digit&apos; if c == &apos; &apos;: c = &apos;blank&apos; if c in [&apos;+&apos;, &apos;-&apos;]: c = &apos;sign&apos; if c not in state[currentState].keys(): return False currentState = state[currentState][c] if currentState not in [3,5,8,9]: return False return True https://discuss.leetcode.com/topic/4219/c-my-thought-with-dfa [C++] My thought with DFA Code first 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool isNumber(string str) &#123; int state=0, flag=0; // flag to judge the special case &quot;.&quot; while(str[0]==&apos; &apos;) str.erase(0,1);//delete the prefix whitespace while(str[str.length()-1]==&apos; &apos;) str.erase(str.length()-1, 1);//delete the suffix whitespace for(int i=0; i&lt;str.length(); i++)&#123; if(&apos;0&apos;&lt;=str[i] &amp;&amp; str[i]&lt;=&apos;9&apos;)&#123; flag=1; if(state&lt;=2) state=2; else state=(state&lt;=5)?5:7; &#125; else if(&apos;+&apos;==str[i] || &apos;-&apos;==str[i])&#123; if(state==0 || state==3) state++; else return false; &#125; else if(&apos;.&apos;==str[i])&#123; if(state&lt;=2) state=6; else return false; &#125; else if(&apos;e&apos;==str[i])&#123; if(flag&amp;&amp;(state==2 || state==6 || state==7)) state=3; else return false; &#125; else return false; &#125; return (state==2 || state==5 || (flag&amp;&amp;state==6) || state==7); &#125;&#125;; DFA Thank @unknowcs, he came up with a brilliant provement in comments that making this a perfect DFA！ It’s just some states changes depend on inputs only. There 8 state in my states in my DFA.Below is my DFA transition diagram. DFA transition diagram or click picture hereDFA transition diagram There are 5 kind of inputs in my DFA: digit : number 0-9 for +,- : operator + or -(negative or positive) exp: e dot: . other: you can return false Immediately 4 final States in my DFA transition diagram : s2, s6, s7, s8 If the state change to final state at last, return true. s2 can accept digits only : +1 -23432 123 and etc s5 can accept exp expression: +2.4e+12 3e9 and etc s6 can accept decimals end with dot: 1. -42. and etc(careful, what if there exist only one dot “.” I use a variable flag judging weather there existing numbers. cause 0. and .0 is valid and . is invalid ) s7 can accept decimals: +12.23, 87., 132 It is clear how DFA works in my pictures. We just need to handle the inputs, and update the state according to DFA. https://discuss.leetcode.com/topic/17942/c-12-ms-give-some-invalid-examples-easily-understand C++ 12 ms,Give some invalid examples,easily understand 1234567891011121314151617181920212223class Solution &#123;public: bool isNumber(string s) &#123; //&quot;1 1&quot;is not valid, &quot;0x11&quot; is not valid, &quot;.&quot; is not valid, &quot;2e3.1&quot; is not valid, &quot;2e&quot; is not valid,&quot;1a&quot; is not valid,&quot;++1&quot; is not valid int n = s.size(); if(n == 0) return false; int i = 0; int count_num = 0,count_point = 0; while(s[i] == &apos; &apos;) i++; if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; while(isdigit(s[i]) || s[i] == &apos;.&apos;) s[i++] == &apos;.&apos;?count_point++:count_num++; if(count_point &gt; 1 || count_num &lt; 1) return false; if(s[i] == &apos;e&apos;)&#123; i++; count_num = 0;count_point = 0; if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; while(isdigit(s[i]) || s[i] == &apos;.&apos;) s[i++] == &apos;.&apos;?count_point++:count_num++; if(count_point &gt; 0 || count_num &lt; 1) return false; &#125; while(s[i] == &apos; &apos;) i++; return i == n; &#125;&#125;; python https://discuss.leetcode.com/topic/26746/easy-python-solution-68-ms-beats-100 Easy Python Solution 68 ms beats 100% 1234def isNumber(self, s): try: float(s) except ValueError: return False else: return True Easy Peasy :)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[064. Minimum Path Sum]]></title>
    <url>%2Fp%2Ff9fa56b2%2F</url>
    <content type="text"><![CDATA[37.5% https://leetcode.com/problems/minimum-path-sum/ Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. 方法一: 我的代码实现: 1234567891011121314151617class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(); for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(i&gt;0 &amp;&amp; j&gt;0) grid[i][j] += min(grid[i-1][j], grid[i][j-1]); else if(i==0 &amp;&amp; j&gt;0) grid[i][j] += grid[i][j-1]; else if(i&gt;0 &amp;&amp; j==0) grid[i][j] += grid[i-1][j]; &#125; &#125; return grid[m-1][n-1]; &#125;&#125;; https://discuss.leetcode.com/topic/15269/10-lines-28ms-o-n-space-dp-solution-in-c-with-explanations 10-lines 28ms O(n)-space DP solution in C++ with Explanations This is a typical DP problem. Suppose the minimum path sum of arriving at point (i, j) is S[i][j], then the state equation is S[i][j] = min(S[i - 1][j], S[i][j - 1]) + grid[i][j]. Well, some boundary conditions need to be handled. The boundary conditions happen on the topmost row (S[i - 1][j] does not exist) and the leftmost column (S[i][j - 1] does not exist). Suppose grid is like [1, 1, 1, 1], then the minimum sum to arrive at each point is simply an accumulation of previous points and the result is [1, 2, 3, 4]. Now we can write down the following (unoptimized) code. 12345678910111213141516class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); vector&lt;vector&lt;int&gt; &gt; sum(m, vector&lt;int&gt;(n, grid[0][0])); for (int i = 1; i &lt; m; i++) sum[i][0] = sum[i - 1][0] + grid[i][0]; for (int j = 1; j &lt; n; j++) sum[0][j] = sum[0][j - 1] + grid[0][j]; for (int i = 1; i &lt; m; i++) for (int j = 1; j &lt; n; j++) sum[i][j] = min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j]; return sum[m - 1][n - 1]; &#125;&#125;; 方法二: As can be seen, each time when we update sum[i][j], we only need sum[i - 1][j] (at the current column) and sum[i][j - 1] (at the left column). So we need not maintain the full m*n matrix. Maintaining two columns is enough and now we have the following code. 123456789101112131415161718class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); vector&lt;int&gt; pre(m, grid[0][0]); vector&lt;int&gt; cur(m, 0); for (int i = 1; i &lt; m; i++) pre[i] = pre[i - 1] + grid[i][0]; for (int j = 1; j &lt; n; j++) &#123; cur[0] = pre[0] + grid[0][j]; for (int i = 1; i &lt; m; i++) cur[i] = min(cur[i - 1], pre[i]) + grid[i][j]; swap(pre, cur); &#125; return pre[m - 1]; &#125;&#125;; Further inspecting the above code, it can be seen that maintaining pre is for recovering pre[i], which is simply cur[i] before its update. So it is enough to use only one vector. Now the space is further optimized and the code also gets shorter. 12345678910111213141516class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); vector&lt;int&gt; cur(m, grid[0][0]); for (int i = 1; i &lt; m; i++) cur[i] = cur[i - 1] + grid[i][0]; for (int j = 1; j &lt; n; j++) &#123; cur[0] += grid[0][j]; for (int i = 1; i &lt; m; i++) cur[i] = min(cur[i - 1], cur[i]) + grid[i][j]; &#125; return cur[m - 1]; &#125;&#125;; https://discuss.leetcode.com/topic/3403/dp-solution-linear-space DP Solution, Linear space You can only reach a cell by going from its left or top neighbor. 123456789101112131415161718192021class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) &#123; if(!grid.size())return 0; const int rows=grid.size(),cols=grid[0].size(); // r[i] == min path sum to previous row&apos;s column i. vector&lt;int&gt; r(cols,0); int i,j; r[0]=grid[0][0]; for(j=1;j&lt;cols;j++)&#123; r[j]=grid[0][j]+r[j-1]; &#125; for(i=1;i&lt;rows;i++)&#123; r[0]+=grid[i][0]; for(j=1;j&lt;cols;j++)&#123; r[j]=min(r[j-1],r[j])+grid[i][j]; &#125; &#125; return r[cols-1]; &#125;&#125;; https://discuss.leetcode.com/topic/448/minimum-path-sum-how-can-i-reduce-the-memory Minimum Path Sum ———How can I reduce the memory. Here is the idea: f[m][n] is a matrix store the min value of every location we canget. f[0][0] =grid[0][0], f[i][0]=f[i-1][0]+grid[i][0], f[0][j]=f[0][j-1]+grid[0][j] f[i][j]=min(f[i-1][j],f[i][j-1])+grid[i][j]. at last return the f[m-1][n-1] 1234567891011121314151617181920212223242526272829303132class Solution &#123; public: int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) &#123; // IMPORTANT: Please reset any member data you declared, as // the same Solution instance will be reused for each test case. int m=grid.size(); int n=grid[0].size(); int** f; f=new int*[m]; for(int i=0;i&lt;m;i)&#123; f[i]=new int[n]; &#125; f[0][0]=grid[0][0]; for(int i=1;i&lt;m;i++)&#123; f[i][0]=f[i-1][0]+grid[i][0]; &#125; for(int i=1;i&lt;n;i++)&#123; f[0][i]=f[0][i-1]+grid[0][i]; &#125; for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++) f[i][j]=min(f[i-1][j],f[i][j-1])+grid[i][j]; &#125; return f[m-1][n-1]; &#125; int min(int a,int b)&#123; if(a&gt;b) return b; else return a; &#125; &#125;; https://discuss.leetcode.com/topic/16654/c-easy-solution-using-dp-space-compexity-o-1 C++ easy solution using dp. space compexity : O(1) 123456789101112131415161718class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; a) &#123; int m=a.size(); if(m==0) return 0; int n= a[0].size(); for(int i = 0 ; i&lt;m; i++ )&#123; for(int j=0; j&lt;n ; j++)&#123; int left= (j==0) ? INT_MAX : a[i][j-1]; int up = (i==0) ? INT_MAX : a[i-1][j]; if(i==0 &amp;&amp; j==0) continue; a[i][j] += min(left, up ); &#125; &#125; return a[m-1][n-1]; &#125;&#125;; python https://leetcode.com/discuss/34905/simple-python-dp-70ms 76ms, 49.83%, June.20th, 2016 12345678910111213141516class Solution(object): def minPathSum(self, grid): &quot;&quot;&quot; :type grid: List[List[int]] :rtype: int &quot;&quot;&quot; m = len(grid) n = len(grid[0]) for i in xrange(1, n): grid[0][i] += grid[0][i-1] for i in xrange(1, m): grid[i][0] += grid[i-1][0] for i in xrange(1,m): for j in xrange(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[-1][-1] java https://discuss.leetcode.com/topic/5459/my-java-solution-using-dp-and-no-extra-space My java solution using DP and no extra space 1234567891011121314151617181920public int minPathSum(int[][] grid) &#123; int m = grid.length;// row int n = grid[0].length; // column for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == 0 &amp;&amp; j != 0) &#123; grid[i][j] = grid[i][j] + grid[i][j - 1]; &#125; else if (i != 0 &amp;&amp; j == 0) &#123; grid[i][j] = grid[i][j] + grid[i - 1][j]; &#125; else if (i == 0 &amp;&amp; j == 0) &#123; grid[i][j] = grid[i][j]; &#125; else &#123; grid[i][j] = Math.min(grid[i][j - 1], grid[i - 1][j]) + grid[i][j]; &#125; &#125; &#125; return grid[m - 1][n - 1];&#125; https://discuss.leetcode.com/topic/30575/my-8-lines-simple-solution My 8 lines simple solution 123456789int m = grid.length, n = grid[0].length;for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == 0 &amp;&amp; j != 0) grid[i][j] += grid[i][j-1]; if(i != 0 &amp;&amp; j == 0) grid[i][j] += grid[i-1][j]; if (i != 0 &amp;&amp; j != 0) grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]); &#125;&#125;return grid[m-1][n-1]; https://discuss.leetcode.com/topic/3184/ac-java-dp-solution-v-s-tle-dijstra-solution AC Java DP solution v.s. TLE Dijstra solution When I looked at this question, the first thought was the Dijkstra solution, which is a very fast algorithm to calculate the shortest path. But this solution got TLE in this question, while DP solution worked fine. I will talk about the Dijkstra solution first, as it’s the first though came into my mind, and there is already discussions on the DP solution. If you are not interested in the Dijkstra solution, you can jump to the latter part of this post, which is about the DP solution, which is accepted. DijkstraThe idea of Dijkstra algorithm is to divide the graph into 2 parts, visited and unvisited.For every node in the visited part has a dist value. Then we need to exam every edges across the visited part and the unvisited parts, which are edges that its start node is in the visited part, while its end node is in the unvisited part. What we are looking for is one edge, which has the minimum value of (dist(start node) + the edge’s value). Then we put this node into the visited part and exam the edges again. Following is the code. It uses a Java Heap, PriorityQueue to keep track of the minimum (dist(start node) + the edge’s value), but in this question, the edge value is in the node itself, which is the same for every edges ending to it, so actually the heap just keeps track of the mimimum dist(start node) of every unvisited nodes around the boarder between visited and unvisited. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Solution_dijkstra &#123;class PointComparator implements Comparator&lt;int[]&gt;&#123; int[][] dist; public PointComparator(int[][] dist)&#123; this.dist = dist; &#125; @Override public int compare(int[] o1, int[] o2) &#123; int[] point1 = (int[])o1; int[] point2 = (int[])o2; return Integer.valueOf(dist[point1[0]][point1[1]]) .compareTo(Integer.valueOf(dist[point2[0]][point2[1]])); &#125;&#125; public int minPathSum(int[][] grid) &#123; if(grid == null || grid.length == 0) return 0; int m = grid.length; int n = grid[0].length; boolean[][] visited = new boolean[m][n]; int[][] dist = new int[m][n]; for(int x = 0; x &lt; m; x++)&#123; for(int y = 0; y &lt; n; y++)&#123; dist[x][y] = Integer.MAX_VALUE; &#125; &#125; dist[0][0] = grid[0][0]; PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;( m*n, new PointComparator(dist)); pq.add(new int[]&#123;0, 0&#125;); while(!pq.isEmpty())&#123; int[] point = pq.poll(); int x = point[0]; int y = point[1]; int d = dist[x][y]; if(x == n-1 &amp;&amp; y == m-1)&#123; return d; &#125; visited[x][y] = true; if((y+1 &lt; n) &amp;&amp; !visited[x][y+1])&#123; dist[x][y+1] = min( dist[x][y+1], d + grid[x][y+1]); pq.add(new int[]&#123;x, y+1&#125;); &#125; if((x+1 &lt; m ) &amp;&amp; !visited[x+1][y])&#123; dist[x+1][y] = min( dist[x+1][y], d + grid[x+1][y]); pq.add(new int[]&#123;x+1, y&#125;); &#125; &#125; return 0; &#125;private int min(int i1, int i2)&#123; return i1 &lt; i2 ? i1 : i2;&#125;&#125; This solution got LTE error, mostly because of the priority queue and doesn’t consider the special condition here that it’s a grid and directed, which means a node can only be accessed from it’s left and upper nodes. Put all these into consideration, we have the DP solution. It’s essentially formula is dist(node) = min( dist(upper node), dist(left node)) + node’s value DPhere is the code: 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution_dp &#123;private int getDist(int[][] dist, int x, int y)&#123; if(x &lt; 0 || y &lt; 0)&#123; return Integer.MAX_VALUE; &#125; return dist[x][y]; &#125;private int min(int i1, int i2)&#123; return i1 &lt; i2 ? i1 : i2;&#125;public int minPathSum(int[][] grid) &#123; if(grid == null || grid.length == 0) return 0; int m = grid.length; int n = grid[0].length; int[][] dist = new int[m][n]; for(int x = 0; x &lt; m; x++)&#123; for(int y = 0; y &lt; n; y++)&#123; if(x == 0 &amp;&amp; y == 0)&#123; dist[0][0] = grid[0][0]; &#125;else&#123; dist[x][y] = min(getDist(dist, x-1, y), getDist(dist, x, y-1)) + grid[x][y]; &#125; &#125; &#125; return dist[m-1][n-1]; &#125;&#125; my code 1234567891011121314public class Solution &#123; public int minPathSum(int[][] grid) &#123; int m=grid.length; int n=grid[0].length; for(int i=0; i&lt;m; i++) for(int j=0; j&lt;n; j++)&#123; if(i==0 &amp;&amp; j==0) continue; if(i&gt;0 &amp;&amp; j==0) grid[i][j] += grid[i-1][j]; if(i==0 &amp;&amp; j&gt;0) grid[i][j] += grid[i][j-1]; if(i&gt;0 &amp;&amp; j&gt;0) grid[i][j] += Math.min(grid[i][j-1], grid[i-1][j]); &#125; return grid[m-1][n-1]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[063. Unique Paths II]]></title>
    <url>%2Fp%2F64df03c8%2F</url>
    <content type="text"><![CDATA[31.1% https://leetcode.com/problems/unique-paths-ii/ Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. 12345678910For example,There is one obstacle in the middle of a 3x3 grid as illustrated below.[ [0,0,0], [0,1,0], [0,0,0]]The total number of unique paths is 2. Note: m and n will be at most 100. 方法一： m*n，变为(m+1) * (n+1) ，然后（0,1）设为1，依次遍历就好了。 12345678910111213class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i = 1; i &lt;= m; ++i) for(int j = 1; j &lt;= n; ++j) if(!obstacleGrid[i-1][j-1]) dp[i][j] = dp[i-1][j] + dp[i][j-1]; return dp[m][n]; &#125;&#125;; 我的代码实现： 1234567891011121314151617class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i=1; i&lt;=m; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; if(obstacleGrid[i-1][j-1]) dp[i][j] = 0; else dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; 方法二： 上面的空间是O（mn），想法空间变为O（n）或者O（m）。 我的代码实现： Dec 7th, 2017 该方法主要是降低了空间复杂度，相对于下面的代码，这个借鉴了上面的思想，不是设置m个，而是m+1个。这样子就代码简洁和思路清晰多了。 注意代码中注释可能会犯的错。 1234567891011121314151617class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; if(obstacleGrid.empty() || obstacleGrid[0].empty()) return 0; int m = obstacleGrid[0].size(); vector&lt;int&gt; res(m+1, 0); res[1] = 1; // 不要忘了初始化 for(int i=0; i&lt;obstacleGrid.size(); i++) for(int j=0; j&lt;obstacleGrid[0].size(); j++) if(obstacleGrid[i][j]==0) //分清楚0还是1，条件 res[j+1] += res[j]; else res[j+1] = 0; return res[m];// m+1个最后一位是res[m],不是res[m+1] &#125;&#125;; 123456789101112131415161718192021222324252627class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); if(m==0 || n==0) return 0; vector&lt;int&gt; res(n, 0); if(obstacleGrid[0][0]==1) return 0; res[0] = 1; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(i==0 &amp;&amp; j==0) continue; if(i&gt;0 &amp;&amp; j==0)&#123; if(obstacleGrid[i][j]) res[j] = 0; &#125; if(j&gt;0)&#123; if(obstacleGrid[i][j]) res[j] = 0; else res[j] += res[j-1]; &#125; &#125; &#125; return res[n-1]; &#125;&#125;; cpp https://leetcode.com/discuss/13965/my-c-dp-solution-very-simple My C++ Dp solution , very simple! just use dp to find the answer , if there is a obstacle at (i,j), then dp[i][j] = 0. time is O(nm) , space is O(nm) . here is my code: 5ms, 8.13%, June.22th, 2016 12345678910111213class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i = 1; i &lt;= m; ++i) for(int j = 1; j &lt;= n; ++j) if(!obstacleGrid[i-1][j-1]) dp[i][j] = dp[i-1][j] + dp[i][j-1]; return dp[m][n]; &#125;&#125;; https://discuss.leetcode.com/topic/15267/4ms-o-n-dp-solution-in-c-with-explanations 4ms O(n) DP Solution in C++ with Explanations Well, this problem is similar to Unique Paths. The introduction of obstacles only changes the boundary conditions and make some points unreachable (simply set to 0). Denote the number of paths to arrive at point (i, j) to be P[i][j], the state equation is P[i][j] = P[i - 1][j] + P[i][j - 1] if obstacleGrid[i][j] != 1 and 0 otherwise. Now let’s finish the boundary conditions. In the Unique Paths problem, we initialize P[0][j] = 1, P[i][0] = 1 for all valid i, j. Now, due to obstacles, some boundary points are no longer reachable and need to be initialized to 0. For example, if obstacleGrid is like [0, 0, 1, 0, 0], then the last three points are not reachable and need to be initialized to be 0. The result is [1, 1, 0, 0, 0]. Now we can write down the following (unoptimized) code. Note that we pad the obstacleGrid by 1 and initialize dp[0][1] = 1 to unify the boundary cases. 12345678910111213class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt; &gt; dp(m + 1, vector&lt;int&gt; (n + 1, 0)); dp[0][1] = 1; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (!obstacleGrid[i - 1][j - 1]) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; return dp[m][n]; &#125; &#125;; Well, the code is accepted but it has some obvious redundancy. There are two major concerns: Each time when we update path[i][j], we only need path[i - 1][j] (at the same column) and path[i][j - 1] (at the left column), so it is unnecessary to maintain the full m*n matrix. Maintaining two columns is enough.There are some cases that the loop can be terminated earlier. Suppose obstacleGrid = [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]], then we can see that it is impossible to reach the bottom-right corner after updating the second column since the number of paths to reach each element in the second column is 0.Taken these into considerations, we write down the following optimized code. 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;int&gt; pre(m, 0); vector&lt;int&gt; cur(m, 0); for (int i = 0; i &lt; m; i++) &#123; if (!obstacleGrid[i][0]) pre[i] = 1; else break; &#125; for (int j = 1; j &lt; n; j++) &#123; bool flag = false; if (!obstacleGrid[0][j]) &#123; cur[0] = pre[0]; if (cur[0]) flag = true; &#125; else cur[0] = 0; for (int i = 1; i &lt; m; i++) &#123; if (!obstacleGrid[i][j]) &#123; cur[i] = cur[i - 1] + pre[i]; if (cur[i]) flag = true; &#125; else cur[i] = 0; &#125; if (!flag) return 0; swap(pre, cur); &#125; return pre[m - 1]; &#125;&#125;; Further inspecting the above code, keeping two vectors only serve for the purpose of recovering pre[i], which is simply cur[i] before its update. So we can use only one vector and the space is further optimized. 12345678910111213141516171819202122232425262728class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;int&gt; cur(m, 0); for (int i = 0; i &lt; m; i++) &#123; if (!obstacleGrid[i][0]) cur[i] = 1; else break; &#125; for (int j = 1; j &lt; n; j++) &#123; bool flag = false; if (obstacleGrid[0][j]) cur[0] = 0; else flag = true; for (int i = 1; i &lt; m; i++) &#123; if (!obstacleGrid[i][j]) &#123; cur[i] += cur[i - 1]; if (cur[i]) flag = true; &#125; else cur[i] = 0; &#125; if (!flag) return 0; &#125; return cur[m - 1]; &#125;&#125;; python https://leetcode.com/discuss/19681/accepted-simple-python-in-place-solution Accepted simple Python in-place solution As below. Any comments on how to make it shorter? Thx! 68ms, 14.48%, June.22th, 20161234567891011121314151617class Solution(object): def uniquePathsWithObstacles(self, obstacleGrid): &quot;&quot;&quot; :type obstacleGrid: List[List[int]] :rtype: int &quot;&quot;&quot; m = len(obstacleGrid) n = len(obstacleGrid[0]) ResGrid = [[0 for x in range(n+1)] for x in range(m+1)] ResGrid[0][1] = 1 for i in range(1, m+1): for j in range(1, n+1): if not obstacleGrid[i-1][j-1]: ResGrid[i][j] = ResGrid[i][j-1] + ResGrid[i-1][j] return ResGrid[m][n] java https://leetcode.com/discuss/29816/short-java-solution Short JAVA solution 1ms, 22.20%, June.22th, 20161234567891011121314public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int width = obstacleGrid[0].length; int[] dp = new int[width]; dp[0] = 1; for(int[] row:obstacleGrid) for(int j=0; j&lt;width; j++) if(row[j] == 1) dp[j] = 0; else if(j&gt;0) dp[j] += dp[j-1]; return dp[width - 1]; &#125;&#125; https://discuss.leetcode.com/topic/4987/java-solution-using-dynamic-programming-o-1-space Java Solution using Dynamic Programming, O(1) space 12345678910111213141516171819202122232425262728public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; //Empty case if(obstacleGrid.length == 0) return 0; int rows = obstacleGrid.length; int cols = obstacleGrid[0].length; for(int i = 0; i &lt; rows; i++)&#123; for(int j = 0; j &lt; cols; j++)&#123; if(obstacleGrid[i][j] == 1) obstacleGrid[i][j] = 0; else if(i == 0 &amp;&amp; j == 0) obstacleGrid[i][j] = 1; else if(i == 0) obstacleGrid[i][j] = obstacleGrid[i][j - 1] * 1;// For row 0, if there are no paths to left cell, then its 0,else 1 else if(j == 0) obstacleGrid[i][j] = obstacleGrid[i - 1][j] * 1;// For col 0, if there are no paths to upper cell, then its 0,else 1 else obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]; &#125; &#125; return obstacleGrid[rows - 1][cols - 1]; &#125;&#125; https://discuss.leetcode.com/topic/9687/easy-java-solution-in-place-dp Easy Java solution, in-place, DP The idea is simple, set all obstacles to be 0 while doing the DP. No extra space is used. 123456789101112131415161718192021public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length; int n = obstacleGrid[0].length; obstacleGrid[0][0]^=1; for(int i = 1;i&lt;m;i++)&#123; obstacleGrid[i][0]=(obstacleGrid[i][0]==1)? 0:obstacleGrid[i-1][0]; &#125; for(int j = 1;j&lt;n;j++)&#123; obstacleGrid[0][j] =(obstacleGrid[0][j]==1)? 0: obstacleGrid[0][j-1]; &#125; for(int i = 1;i&lt;m;i++)&#123; for(int j =1;j&lt;n;j++)&#123; obstacleGrid[i][j] =(obstacleGrid[i][j]==1)? 0: obstacleGrid[i-1][j]+obstacleGrid[i][j-1]; &#125; &#125; return obstacleGrid[m-1][n-1]; &#125; &#125; my code动态规划 12345678910111213141516171819202122232425public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; if(obstacleGrid.length == 0 || obstacleGrid[0].length == 0) return 0; int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[] ans = new int[n]; if(obstacleGrid[0][0]==1) return 0; ans[0] = 1; for(int i=0; i&lt;m; i++) for(int j=0; j&lt;n; j++)&#123; if(i==0 &amp;&amp; j==0) continue; if(i&gt;0 &amp;&amp; j==0)&#123; if(obstacleGrid[i][j]==1) ans[j] = 0; &#125; if(j&gt;0)&#123; if(obstacleGrid[i][j]==1) ans[j] = 0; else ans[j] += ans[j-1]; &#125; &#125; return ans[n-1]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[062. Unique Paths]]></title>
    <url>%2Fp%2F59afcf56%2F</url>
    <content type="text"><![CDATA[39.7% https://leetcode.com/problems/unique-paths/ A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 3 x 7 grid. How many possible unique paths are there? 解析 用dp算法或者使用公式，共m+n-2步，然后从中选取m-1步作为向右。 方法一： dp算法记录每一步有的方法数，以此类推。 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; if(m==0 || n==0) return 0; vector&lt;int&gt; dp(n, 1); for(int i=1; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; dp[j] += dp[j-1]; &#125; &#125; return dp[n-1]; &#125;&#125;; 类似的方法， 上面的更简单。 1234567891011121314class Solution &#123;public: int uniquePaths(int m, int n) &#123; if(m==0 || n==0) return 0; vector&lt;int&gt; dp(n, 0); dp[0] = 1; for(int i=0; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; dp[j] += dp[j-1]; &#125; &#125; return dp[n-1]; &#125;&#125;; 方法二： 使用公式的话，记得定义值的类型要为double，否则数值就会出问题。 123456789101112131415class Solution &#123; public: int uniquePaths(int m, int n) &#123; int N = n + m - 2;// how much steps we need to do int k = m - 1; // number of steps that need to go down double res = 1; // here we calculate the total possible path number // Combination(N, k) = n! / (k!(n - k)!) // reduce the numerator and denominator and get // C = ( (n - k + 1) * (n - k + 2) * ... * n ) / k! for (int i = 1; i &lt;= k; i++) res = res * (N - k + i) / i; return (int)res; &#125; &#125;; my code: 1234567891011class Solution &#123;public: int uniquePaths(int m, int n) &#123; if(m==0 || n==0) return 0; double res = 1.0; for(int i=1; i&lt;=n-1; i++)&#123; res = res * (m-1+i) / i; &#125; return (int)res; &#125;&#125;; 方法三： m+1 * n+1数组 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i=1; i&lt;=m; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; cpp https://discuss.leetcode.com/topic/15265/0ms-5-lines-dp-solution-in-c-with-explanations 0ms, 5-lines DP Solution in C++ with Explanations This is a fundamental DP problem. First of all, let’s make some observations. Since the robot can only move right and down, when it arrives at a point, there are only two possibilities: It arrives at that point from above (moving down to that point); It arrives at that point from left (moving right to that point).Thus, we have the following state equations: suppose the number of paths to arrive at a point (i, j) is denoted as P[i][j], it is easily concluded that P[i][j] = P[i - 1][j] + P[i][j - 1]. The boundary conditions of the above equation occur at the leftmost column (P[i][j - 1] does not exist) and the uppermost row (P[i - 1][j] does not exist). These conditions can be handled by initialization (pre-processing) — initialize P[0][j] = 1, P[i][0] = 1 for all valid i, j. Note the initial value is 1 instead of 0! Now we can write down the following (unoptimized) code. 123456789class Solution &#123; int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt; &gt; path(m, vector&lt;int&gt; (n, 1)); for (int i = 1; i &lt; m; i++) for (int j = 1; j &lt; n; j++) path[i][j] = path[i - 1][j] + path[i][j - 1]; return path[m - 1][n - 1]; &#125;&#125;; As can be seen, the above solution runs in O(n^2) time and costs O(m*n) space. However, you may have observed that each time when we update path[i][j], we only need path[i - 1][j] (at the same column) and path[i][j - 1] (at the left column). So it is enough to maintain two columns (the current column and the left column) instead of maintaining the full m*n matrix. Now the code can be optimized to have O(min(m, n)) space complexity. 12345678910111213class Solution &#123; int uniquePaths(int m, int n) &#123; if (m &gt; n) return uniquePaths(n, m); vector&lt;int&gt; pre(m, 1); vector&lt;int&gt; cur(m, 1); for (int j = 1; j &lt; n; j++) &#123; for (int i = 1; i &lt; m; i++) cur[i] = cur[i - 1] + pre[i]; swap(pre, cur); &#125; return pre[m - 1]; &#125;&#125;; Further inspecting the above code, we find that keeping two columns is used to recover pre[i], which is just cur[i] before its update. So there is even no need to use two vectors and one is just enough. Now the space is further saved and the code also gets much shorter. 12345678910class Solution &#123; int uniquePaths(int m, int n) &#123; if (m &gt; n) return uniquePaths(n, m); vector&lt;int&gt; cur(m, 1); for (int j = 1; j &lt; n; j++) for (int i = 1; i &lt; m; i++) cur[i] += cur[i - 1]; return cur[m - 1]; &#125;&#125;; Well, till now, I guess you may even want to optimize it to O(1) space complexity since the above code seems to rely on only cur[i] and cur[i - 1]. You may think that 2 variables is enough? Well, it is not. Since the whole cur needs to be updated for n - 1 times, it means that all of its values need to be saved for next update and so two variables is not enough. https://leetcode.com/discuss/9110/my-ac-solution-using-formula 0ms, 17.54%, June.19th, 2016 Binomial coefficient: 123456789101112131415class Solution &#123; public: int uniquePaths(int m, int n) &#123; int N = n + m - 2;// how much steps we need to do int k = m - 1; // number of steps that need to go down double res = 1; // here we calculate the total possible path number // Combination(N, k) = n! / (k!(n - k)!) // reduce the numerator and denominator and get // C = ( (n - k + 1) * (n - k + 2) * ... * n ) / k! for (int i = 1; i &lt;= k; i++) res = res * (N - k + i) / i; return (int)res; &#125; &#125;; First of all you should understand that we need to do n + m - 2 movements : m - 1 down, n - 1 right, because we start from cell (1, 1). Secondly, the path it is the sequence of movements( go down / go right), therefore we can say that two paths are different when there is i-th (1 .. m + n - 2) movement in path1 differ i-th movement in path2. So, how we can build paths. Let’s choose (n - 1) movements(number of steps to the right) from (m + n - 2), and rest (m - 1) is (number of steps down). I think now it is obvious that count of different paths are all combinations (n - 1) movements from (m + n-2). python https://leetcode.com/discuss/63819/1-line-math-solution-python 1 Line Math Solution (Python) 48ms, 54.13%, June.19th, 201612345678class Solution(object): def uniquePaths(self, m, n): &quot;&quot;&quot; :type m: int :type n: int :rtype: int &quot;&quot;&quot; return math.factorial(m+n-2) / math.factorial(m-1) / math.factorial(n-1) https://discuss.leetcode.com/topic/6440/accpeted-simple-python-dp-solution Accpeted simple Python DP solution. 12345678class Solution: # @return an integer def uniquePaths(self, m, n): aux = [[1 for x in range(n)] for x in range(m)] for i in range(1, m): for j in range(1, n): aux[i][j] = aux[i][j-1]+aux[i-1][j] return aux[-1][-1] my code 1234567891011121314151617181920212248ms, 54.13%, June.19th, 2016class Solution(object): def uniquePaths(self, m, n): &quot;&quot;&quot; :type m: int :type n: int :rtype: int &quot;&quot;&quot; if m == 1 or n == 1: return 1 p1 = max(m-1, n-1) p2 = min(m-1, n-1) p3 = m + n - 2 res1 = 1 i = p3 while i &gt; p3 - p2: res1 *= i i -= 1 res2 = 1 while p2 &gt; 0: res2 *= p2 p2 -= 1 return res1 / res2 java https://discuss.leetcode.com/topic/5623/java-dp-solution-with-complexity-o-n-m Java DP solution with complexity O(n*m) 1234567891011121314151617public class Solution &#123; public int uniquePaths(int m, int n) &#123; Integer[][] map = new Integer[m][n]; for(int i = 0; i&lt;m;i++)&#123; map[i][0] = 1; &#125; for(int j= 0;j&lt;n;j++)&#123; map[0][j]=1; &#125; for(int i = 1;i&lt;m;i++)&#123; for(int j = 1;j&lt;n;j++)&#123; map[i][j] = map[i-1][j]+map[i][j-1]; &#125; &#125; return map[m-1][n-1]; &#125;&#125; The assumptions are When (n == 0||m == 0) the function always returns 1 since the robot can’t go left or up. For all other cells. The result = uniquePaths(m-1,n)+uniquePaths(m,n-1) Therefore I populated the edges with 1 first and use DP to get the full 2-D array. Please give any suggestions on improving the code. my code 1234567891011121314public class Solution &#123; public int uniquePaths(int m, int n) &#123; if(m == 0 || n == 0) return 0; int[] ans = new int[n]; for(int i=0; i&lt;n; i++) ans[i] = 1; for(int i=1; i&lt;m; i++) for(int j=1; j&lt;n; j++) ans[j] += ans[j-1]; return ans[n-1]; &#125;&#125; 123456789100ms, 84.01%, June.19th, 2016https://leetcode.com/discuss/9110/my-ac-solution-using-formulapublic class Solution &#123; public int uniquePaths(int m, int n) &#123; double value = 1; for(int i = 1; i &lt;= n-1; i++) value *= ((double)(m+i-1)/(double)i); return (int)Math.round(value); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[061. Rotate List]]></title>
    <url>%2Fp%2F61df86e1%2F</url>
    <content type="text"><![CDATA[24.3% https://leetcode.com/problems/rotate-list/ Given a list, rotate the list to the right by k places, where k is non-negative. 123For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. 方法一： 先遍历一遍，求出长度 通过将尾节点与头结点相链接 然后向前走 len - k%len步，就可以了。 核心：一次遍历求长度，然后尾部相连 我的代码实现： Oct, 11th, 2017 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; // 是或||的关系，不是&amp;&amp; // k==0的情况要考虑到 if(!head || !head-&gt;next || k==0) return head; ListNode* p1 = head; int cnt = 1; while(p1-&gt;next)&#123; cnt++; p1 = p1-&gt;next; &#125; // 现除以cnt // 要移动的步数，需要用cnt-k k %= cnt; k = cnt -k; p1-&gt;next = head; while(k!=0)&#123; p1 = p1-&gt;next; k--; &#125; ListNode* node = p1-&gt;next; p1-&gt;next = nullptr; return node; &#125;&#125;; C++ simple algorithm with explanation Enumerate through the list to find the last node, count the size along the way. Make a loop, by connection last to first Get modulo of |k/size| - avoiding extra rotation Enumerate again size-k nodes Break the loop and return new head code: 123456789101112131415161718192021222324252627282930ListNode *rotateRight(ListNode *head, int k) &#123; if(head == NULL || head-&gt;next == NULL||k==0) return head; ListNode* node = head; int size =1; while(node-&gt;next != NULL) &#123; size++; node = node-&gt;next; &#125; //loop the list node-&gt;next=head; //handle the case of k&gt;size k = k%size; //find the node to break the loop at while(--size &gt;= k) &#123; node=node-&gt;next; &#125; ListNode* first = node-&gt;next; node-&gt;next=NULL; return first; &#125; 代码的另一种实现 My clean C++ code, quite standard (find tail and reconnect the list) There is no trick for this problem. Some people used slow/fast pointers to find the tail node but I don’t see the benefit (in the sense that it doesn’t reduce the pointer move op) to do so. So I just used one loop to find the length first. 12ms, September 11, 2016 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(!head) return head; int len=1; // number of nodes ListNode *newH, *tail; newH=tail=head; while(tail-&gt;next) // get the number of nodes in the list &#123; tail = tail-&gt;next; len++; &#125; tail-&gt;next = head; // circle the link if(k %= len) &#123; for(auto i=0; i&lt;len-k; i++) tail = tail-&gt;next; // the tail node is the (len-k)-th node (1st node is head) &#125; newH = tail-&gt;next; tail-&gt;next = NULL; return newH; &#125;&#125;; https://discuss.leetcode.com/topic/815/what-to-do-when-k-is-greater-than-size-of-list What to do when k is greater than size of list ? i am not getting that what i should do when K is greater than size of the list. https://discuss.leetcode.com/topic/815/what-to-do-when-k-is-greater-than-size-of-list/2 Let’s start with an example. Given [0,1,2], rotate 1 steps to the right -&gt; [2,0,1]. Given [0,1,2], rotate 2 steps to the right -&gt; [1,2,0]. Given [0,1,2], rotate 3 steps to the right -&gt; [0,1,2]. Given [0,1,2], rotate 4 steps to the right -&gt; [2,0,1]. So, no matter how big K, the number of steps is, the result is always the same as rotating K % n steps to the right. https://discuss.leetcode.com/topic/9161/i-think-the-description-of-this-problem-is-misleading I think the description of this problem is misleading. Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle. cpp https://discuss.leetcode.com/topic/14470/my-clean-c-code-quite-standard-find-tail-and-reconnect-the-list My clean C++ code, quite standard (find tail and reconnect the list) There is no trick for this problem. Some people used slow/fast pointers to find the tail node but I don’t see the benefit (in the sense that it doesn’t reduce the pointer move op) to do so. So I just used one loop to find the length first. 12ms, September 11, 2016 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(!head) return head; int len=1; // number of nodes ListNode *newH, *tail; newH=tail=head; while(tail-&gt;next) // get the number of nodes in the list &#123; tail = tail-&gt;next; len++; &#125; tail-&gt;next = head; // circle the link if(k %= len) &#123; for(auto i=0; i&lt;len-k; i++) tail = tail-&gt;next; // the tail node is the (len-k)-th node (1st node is head) &#125; newH = tail-&gt;next; tail-&gt;next = NULL; return newH; &#125;&#125;; https://discuss.leetcode.com/topic/7293/c-simple-algorithm-with-explanation C++ simple algorithm with explanation Enumerate through the list to find the last node, count the size along the way. Make a loop, by connection last to first Get modulo of |k/size| - avoiding extra rotation Enumerate again size-k nodes Break the loop and return new head code: 123456789101112131415161718192021222324252627282930ListNode *rotateRight(ListNode *head, int k) &#123; if(head == NULL || head-&gt;next == NULL||k==0) return head; ListNode* node = head; int size =1; while(node-&gt;next != NULL) &#123; size++; node = node-&gt;next; &#125; //loop the list node-&gt;next=head; //handle the case of k&gt;size k = k%size; //find the node to break the loop at while(--size &gt;= k) &#123; node=node-&gt;next; &#125; ListNode* first = node-&gt;next; node-&gt;next=NULL; return first; &#125; java 1ms, September 11, 2016 https://discuss.leetcode.com/topic/2861/share-my-java-solution-with-explanation Share my java solution with explanation Since n may be a large number compared to the length of list. So we need to know the length of linked list.After that, move the list after the (l-n%l )th node to the front to finish the rotation. Ex: {1,2,3} k=2 Move the list after the 1st node to the front Ex: {1,2,3} k=5, In this case Move the list after (3-5%3=1)st node to the front. So the code has three parts. Get the length Move to the (l-n%l)th node 3)Do the rotation 12345678910111213141516171819public ListNode rotateRight(ListNode head, int n) &#123; if (head==null||head.next==null) return head; ListNode dummy=new ListNode(0); dummy.next=head; ListNode fast=dummy,slow=dummy; int i; for (i=0;fast.next!=null;i++)//Get the total length fast=fast.next; for (int j=i-n%i;j&gt;0;j--) //Get the i-n%i th node slow=slow.next; fast.next=dummy.next; //Do the rotation dummy.next=slow.next; slow.next=null; return dummy.next;&#125; https://discuss.leetcode.com/topic/26364/clean-java-solution-with-brief-explanation Clean Java Solution with Brief Explanation The basic idea is to link the tail of the list with the head, make it a cycle. Then count to the rotate point and cut it. 123456789101112131415161718192021if (head == null) return head; ListNode copyHead = head; int len = 1; while (copyHead.next != null) &#123; copyHead = copyHead.next; len++; &#125; copyHead.next = head; for (int i = len - k % len; i &gt; 1; i--) head = head.next; copyHead = head.next; head.next = null; return copyHead;&#125; https://discuss.leetcode.com/topic/10991/my-short-java-solution-with-comments My short java solution with comments 1234567891011121314151617public ListNode rotateRight(ListNode head, int k) &#123; if(head==null||head.next==null||k==0) return head; //make it a cricle, break from k postion far from the head ListNode index=head; int len=1;// int len to record the length of list while(index.next!=null) &#123;index=index.next; len++;&#125; index.next=head; for(int i=0;i&lt;len-k%len;i++) &#123; index=index.next; &#125; ListNode result=index.next; index.next=null; return result;&#125; https://discuss.leetcode.com/topic/42445/java-clean-solution-only-one-pointer-used Java clean solution, only one pointer used I first used a ListNode p, and point it to the head, then move it to the end of the list, and at the same time get the length of the list. Then p.next = head; gives me a circle. At this time, by moving p for len-k times, it will be pointing to the node before the break point. Then all we need to do is record the next node as head, and break the circle with p.next = null. 12345678910111213141516171819public ListNode rotateRight(ListNode head, int k) &#123; if(head == null || k == 0) &#123; return head; &#125; ListNode p = head; int len = 1; while(p.next != null) &#123; p = p.next; len++; &#125; p.next = head; k %= len; for(int i = 0; i &lt; len - k; i++) &#123; p = p.next; &#125; head = p.next; p.next = null; return head;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>two pointers</tag>
        <tag>medium</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[060. Permutation Sequence]]></title>
    <url>%2Fp%2F7d81a399%2F</url>
    <content type="text"><![CDATA[28.6% https://leetcode.com/problems/permutation-sequence/ The set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, 12345678We get the following sequence (ie, for n = 3):1. &quot;123&quot;2. &quot;132&quot;3. &quot;213&quot;4. &quot;231&quot;5. &quot;312&quot;6. &quot;321&quot; Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. 需要再思考 cpp https://discuss.leetcode.com/topic/3313/most-concise-c-solution-minimal-memory-required Most concise C++ solution, minimal memory required 1234567891011121314151617181920string getPermutation(int n, int k) &#123; int i,j,f=1; // left part of s is partially formed permutation, right part is the leftover chars. string s(n,&apos;0&apos;); for(i=1;i&lt;=n;i++)&#123; f*=i; s[i-1]+=i; // make s become 1234...n &#125; for(i=0,k--;i&lt;n;i++)&#123; f/=n-i; j=i+k/f; // calculate index of char to put at s[i] char c=s[j]; // remove c by shifting to cover up (adjust the right part). for(;j&gt;i;j--) s[j]=s[j-1]; k%=f; s[i]=c; &#125; return s;&#125; https://discuss.leetcode.com/topic/7002/sharing-my-straightforward-c-solution-with-explanation Sharing my straightforward C++ solution with explanation 12345678910111213141516171819202122232425string getPermutation(int n, int k) &#123; int pTable[10] = &#123;1&#125;; for(int i = 1; i &lt;= 9; i++)&#123; pTable[i] = i * pTable[i - 1]; &#125; string result; vector&lt;char&gt; numSet; numSet.push_back(&apos;1&apos;); numSet.push_back(&apos;2&apos;); numSet.push_back(&apos;3&apos;); numSet.push_back(&apos;4&apos;); numSet.push_back(&apos;5&apos;); numSet.push_back(&apos;6&apos;); numSet.push_back(&apos;7&apos;); numSet.push_back(&apos;8&apos;); numSet.push_back(&apos;9&apos;); while(n &gt; 0)&#123; int temp = (k - 1) / pTable[n - 1]; result += numSet[temp]; numSet.erase(numSet.begin() + temp); k = k - temp * pTable[n - 1]; n--; &#125; return result;&#125; In this program, pTable refers to permutation table and numSet refers to a set of numbers from 1 to 9. Before while loop, we need to initialize pTable and numSet, which is trivial. In while loop, we do these following things. 1 calculate which number we will use. 2 remove that number from numSet. 3 recalculate k. 4 n–. Finally, we return result. https://discuss.leetcode.com/topic/19181/0ms-c-12-line-concise-solution-no-recursion-no-helper-function 0ms C++ 12-line concise solution (no recursion, no helper function) Attached please find my solution. Idea: For an n-element permutation, there are (n-1)! permutations started with ‘1’, (n-1)! permutations started with ‘2’, and so forth. Therefore we can determine the value of the first element. After determining the first element, there are (n-1) candidates left. Then there are (n-2)! permutations started with the minimum element within the remaining set, and so forth. Complexities: Time complexity: O(n^2) Space complexity: O(n) 123456789101112131415161718192021222324252627class Solution &#123;public: string getPermutation(int n, int k) &#123; // initialize a dictionary that stores 1, 2, ..., n. This string will store the permutation. string dict(n, 0); iota(dict.begin(), dict.end(), &apos;1&apos;); // build up a look-up table, which stores (n-1)!, (n-2)!, ..., 1!, 0! vector&lt;int&gt; fract(n, 1); for (int idx = n - 3; idx &gt;= 0; --idx) &#123; fract[idx] = fract[idx + 1] * (n - 1 - idx); &#125; // let k be zero base --k; // the main part. string ret(n, 0); for (int idx = 0; idx &lt; n; ++idx) &#123; int select = k / fract[idx]; k %= fract[idx]; ret[idx] = dict[select]; dict.erase(next(dict.begin(), select)); // note that it is an O(n) operation &#125; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/37865/simple-0s-c-solution Simple 0s C++ solution since n will be between 1 and 9 inclusive. pre-calculate the factorials is faster. 12345678910111213141516class Solution &#123;public: string getPermutation(int n, int k) &#123; string res; string nums = &quot;123456789&quot;; int f[10] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;; --k; for (int i = n; i &gt;= 1; --i) &#123; int j = k / f[i - 1]; k %= f[i - 1]; res.push_back(nums[j]); nums.erase(nums.begin() + j); &#125; return res; &#125;&#125;; python 44ms, 90.94%, 17 July 2016 https://discuss.leetcode.com/topic/19269/share-my-python-solution-with-detailed-explanation Share my Python solution with detailed explanation The idea is as follow: For permutations of n, the first (n-1)! permutations start with 1, next (n-1)! ones start with 2, … and so on. And in each group of (n-1)! permutations, the first (n-2)! permutations start with the smallest remaining number, … take n = 3 as an example, the first 2 (that is, (3-1)! ) permutations start with 1, next 2 start with 2 and last 2 start with 3. For the first 2 permutations (123 and 132), the 1st one (1!) starts with 2, which is the smallest remaining number (2 and 3). So we can use a loop to check the region that the sequence number falls in and get the starting digit. Then we adjust the sequence number and continue. 123456789101112131415161718import mathclass Solution: # @param &#123;integer&#125; n # @param &#123;integer&#125; k # @return &#123;string&#125; def getPermutation(self, n, k): numbers = range(1, n+1) permutation = &apos;&apos; k -= 1 while n &gt; 0: n -= 1 # get the index of current digit index, k = divmod(k, math.factorial(n)) permutation += str(numbers[index]) # remove handled number numbers.remove(numbers[index]) return permutation https://discuss.leetcode.com/topic/1746/does-anyone-have-a-better-idea-share-my-accepted-python-code-here Does anyone have a better idea? Share my accepted python code here It’s obvious that if we try to come up with n! solutions one by one until it reach kth element - O(k), it will exceed the time limit. Therefore, I tried to implement a mathematical solution as follows: 1234567891011121314151617181920212223242526272829class Solution: # @return a string def getPermutation(self, n, k): ll = [str(i) for i in range(1,n+1)] # build a list of [&quot;1&quot;,&quot;2&quot;,...&quot;n&quot;] divisor = 1 for i in range(1,n): # calculate 1*2*3*...*(n-1) divisor *= i answer = &quot;&quot; while k&gt;0 and k&lt;=divisor*n: # there are only (divisor*n) solutions in total group_num = k/divisor k %= divisor if k&gt;0: # it&apos;s kth element of (group_num+1)th group choose = ll.pop(group_num) answer += choose else: # it&apos;s last element of (group_num)th group choose = ll.pop(group_num-1) answer += choose ll.reverse() # reverse the list to get DESC order for the last element to_add = &quot;&quot;.join(ll) answer += to_add break divisor/=len(ll) return answer Briefly take (n,k) = (4,21) for example, in the first iteration we divide the solution set into 4 groups: “1xxx”, “2xxx”, “3xxx”, and “4xxx”, while each group has 3! = 6 members. From 21/6 = 3…3, we know that the 21th element is the 3rd element in the (3+1)th group. In this group, we can divide it into 3 sub-groups again: “41xx”, “42xx” and “43xx”, and each group has 2!=2 members. Then, we calculate 3/2 and get 1…1, so it’s the 1st element of (1+1)nd sub-group - “421x”, and now it reach the base case with only one possibility - “4213”. Anyone pass the problem with different ideas? java https://discuss.leetcode.com/topic/17348/explain-like-i-m-five-java-solution-in-o-n “Explain-like-I’m-five” Java Solution in O(n) I’m sure somewhere can be simplified so it’d be nice if anyone can let me know. The pattern was that: say n = 4, you have {1, 2, 3, 4} If you were to list out all the permutations you have 1 + (permutations of 2, 3, 4) 2 + (permutations of 1, 3, 4) 3 + (permutations of 1, 2, 4) 4 + (permutations of 1, 2, 3) We know how to calculate the number of permutations of n numbers… n! So each of those with permutations of 3 numbers means there are 6 possible permutations. Meaning there would be a total of 24 permutations in this particular one. So if you were to look for the (k = 14) 14th permutation, it would be in the 3 + (permutations of 1, 2, 4) subset. To programmatically get that, you take k = 13 (subtract 1 because of things always starting at 0) and divide that by the 6 we got from the factorial, which would give you the index of the number you want. In the array {1, 2, 3, 4}, k/(n-1)! = 13/(4-1)! = 13/3! = 13/6 = 2. The array {1, 2, 3, 4} has a value of 3 at index 2. So the first number is a 3. Then the problem repeats with less numbers. The permutations of {1, 2, 4} would be: 1 + (permutations of 2, 4) 2 + (permutations of 1, 4) 4 + (permutations of 1, 2) But our k is no longer the 14th, because in the previous step, we’ve already eliminated the 12 4-number permutations starting with 1 and 2. So you subtract 12 from k.. which gives you 1. Programmatically that would be… k = k - (index from previous) (n-1)! = k - 2(n-1)! = 13 - 2*(3)! = 1 In this second step, permutations of 2 numbers has only 2 possibilities, meaning each of the three permutations listed above a has two possibilities, giving a total of 6. We’re looking for the first one, so that would be in the 1 + (permutations of 2, 4) subset. Meaning: index to get number from is k / (n - 2)! = 1 / (4-2)! = 1 / 2! = 0.. from {1, 2, 4}, index 0 is 1 so the numbers we have so far is 3, 1… and then repeating without explanations. {2, 4} k = k - (index from pervious) (n-2)! = k - 0 (n - 2)! = 1 - 0 = 1; third number’s index = k / (n - 3)! = 1 / (4-3)! = 1/ 1! = 1… from {2, 4}, index 1 has 4 Third number is 4 {2} k = k - (index from pervious) (n - 3)! = k - 1 (4 - 3)! = 1 - 1 = 0; third number’s index = k / (n - 4)! = 0 / (4-4)! = 0/ 1 = 0… from {2}, index 0 has 2 Fourth number is 2 Giving us 3142. If you manually list out the permutations using DFS method, it would be 3142. Done! It really was all about pattern finding. 12345678910111213141516171819202122232425262728293031323334public class Solution &#123;public String getPermutation(int n, int k) &#123; int pos = 0; List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); int[] factorial = new int[n+1]; StringBuilder sb = new StringBuilder(); // create an array of factorial lookup int sum = 1; factorial[0] = 1; for(int i=1; i&lt;=n; i++)&#123; sum *= i; factorial[i] = sum; &#125; // factorial[] = &#123;1, 1, 2, 6, 24, ... n!&#125; // create a list of numbers to get indices for(int i=1; i&lt;=n; i++)&#123; numbers.add(i); &#125; // numbers = &#123;1, 2, 3, 4&#125; k--; for(int i = 1; i &lt;= n; i++)&#123; int index = k/factorial[n-i]; sb.append(String.valueOf(numbers.get(index))); numbers.remove(index); k-=index*factorial[n-i]; &#125; return String.valueOf(sb);&#125;&#125; 4ms, 3.65%, 17 July 2016 https://discuss.leetcode.com/topic/5081/an-iterative-solution-for-reference An iterative solution for reference Recursion will use more memory, while this problem can be solved by iteration. I solved this problem before, but I didn’t realize that using k = k-1 would avoid dealing with case k%(n-1)!==0. Rewrote this code, should be pretty concise now. Only thing is that I have to use a list to store the remaining numbers, neither linkedlist nor arraylist are very efficient, anyone has a better idea? The logic is as follows: for n numbers the permutations can be divided to (n-1)! groups, for n-1 numbers can be divided to (n-2)! groups, and so on. Thus k/(n-1)! indicates the index of current number, and k%(n-1)! denotes remaining index for the remaining n-1 numbers.We keep doing this until n reaches 0, then we get n numbers permutations that is kth. 12345678910111213141516public String getPermutation(int n, int k) &#123; List&lt;Integer&gt; num = new LinkedList&lt;Integer&gt;(); for (int i = 1; i &lt;= n; i++) num.add(i); int[] fact = new int[n]; // factorial fact[0] = 1; for (int i = 1; i &lt; n; i++) fact[i] = i*fact[i-1]; k = k-1; StringBuilder sb = new StringBuilder(); for (int i = n; i &gt; 0; i--)&#123; int ind = k/fact[i-1]; k = k%fact[i-1]; sb.append(num.get(ind)); num.remove(ind); &#125; return sb.toString(); &#125; https://discuss.leetcode.com/topic/5081/an-iterative-solution-for-reference/2 Thanks for your post and explanation. I think linkedlist is as efficient as you can get in order to store the remaining numbers. Linkedlist may require counting index to get to the number, but it is more efficient than an array for removing elements. I haven’t seen a better solution yet. We can reduce the memory usage for factorial a little by using just one integer, since we are going down in factorial anyway. I think you meant “permutations can be divided into n groups with (n - 1)! elements in each group”. Thus, k / (n - 1)! is the index among current n groups, and k % (n - 1)! is the index for next iteration. 123456789101112131415public String getPermutation(int n, int k) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int i = 1; i &lt;= n; i++) list.add(i); int fact = 1; for (int i = 2; i &lt;= n; i++) fact *= i; // factorial StringBuilder strBuilder = new StringBuilder(); for (k--; n &gt; 0; n--) &#123; fact /= n; strBuilder.append(list.remove(k / fact)); k %= fact; &#125; return strBuilder.toString();&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>math</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[059. Spiral Matrix II]]></title>
    <url>%2Fp%2F3551638a%2F</url>
    <content type="text"><![CDATA[38.4% https://leetcode.com/problems/spiral-matrix-ii/ Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. 123456789For example,Given n = 3,You should return the following matrix:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 方法一: 借鉴54题的思想，类似的代码 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; if(n==0) return &#123;&#125;; if(n==1) return &#123;&#123;1&#125;&#125;; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n)); int i=1, up=0, down=n-1, left=0, right=n-1; while(true)&#123; for(int col=left; col&lt;=right; col++) res[up][col] = i++; if(++up&gt;down) break; for(int row=up; row&lt;=down; row++) res[row][right] = i++; if(--right&lt;left) break; for(int col=right; col&gt;=left; col--) res[down][col] = i++; if(--down&lt;up) break; for(int row=down; row&gt;=up; row--) res[row][left] = i++; if(++left&gt;right) break; &#125; return res; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; int cnt = 0; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); int left = 0, right = n-1, up = 0, down = n-1; while(true)&#123; for(int i=left; i&lt;=right; i++) res[up][i] = ++cnt; up++; if(up&gt;down) break; for(int j=up; j&lt;=down; j++) res[j][right] = ++cnt; right--; if(left&gt;right) break; for(int k=right; k&gt;=left; k--) res[down][k] = ++cnt; down--; if(up&gt;down) break; for(int l=down; l&gt;=up; l--) res[l][left] = ++cnt; left++; if(left&gt;right) break; &#125; return res; &#125;&#125;; cpp 4ms, 13.71%, June.19th, 2016 https://leetcode.com/discuss/21677/simple-c-solution-with-explaination 12345678910111213141516171819202122232425class Solution &#123; public: vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt; &gt; ret( n, vector&lt;int&gt;(n) ); int k = 1, i = 0; while( k &lt;= n * n ) &#123; int j = i; // four steps while( j &lt; n - i ) // 1. horizonal, left to right ret[i][j++] = k++; j = i + 1; while( j &lt; n - i ) // 2. vertical, top to bottom ret[j++][n-i-1] = k++; j = n - i - 2; while( j &gt; i ) // 3. horizonal, right to left ret[n-i-1][j--] = k++; j = n - i - 1; while( j &gt; i ) // 4. vertical, bottom to top ret[j--][i] = k++; i++; // next loop &#125; return ret; &#125; &#125;; 方法二： 修改判断条件在while条件里，不必每次都去判断是否跳出循环 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; int cnt = 0; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); int left = 0, right = n-1, up = 0, down = n-1; while(up&lt;=down &amp;&amp; left&lt;=right)&#123; for(int i=left; i&lt;=right; i++) res[up][i] = ++cnt; up++; for(int j=up; j&lt;=down; j++) res[j][right] = ++cnt; right--; for(int k=right; k&gt;=left; k--) res[down][k] = ++cnt; down--; for(int l=down; l&gt;=up; l--) res[l][left] = ++cnt; left++; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/2736/my-ac-solution-with-using-direction-variable My AC solution with using direction variable 12345678910111213141516171819202122232425vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) &#123; int dir = 0; vector&lt; vector&lt;int&gt; &gt; matrix(n, vector&lt;int&gt; (n, 0)); int i = 0, j = 0, k = 1; while (k &lt;= n * n) &#123; matrix[i][j] = k++; if (dir == 0)&#123; j++; if (j == n || matrix[i][j] != 0) dir = 1, j--, i++; &#125; else if (dir == 1) &#123; i++; if (i == n || matrix[i][j] != 0) dir = 2, i--, j--; &#125; else if (dir == 2) &#123; j--; if (j &lt; 0 || matrix[i][j] != 0) dir = 3, j++, i--; &#125; else if (dir == 3) &#123; i--; if (i &lt; 0 || matrix[i][j] != 0) dir = 0, i++, j++; &#125; &#125; return matrix; &#125; https://discuss.leetcode.com/topic/11317/simple-c-solution Simple C++ solution 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt; &gt; vv(n, vector&lt;int&gt;(n)); int rowStart = 0, rowEnd = n - 1; int colStart = 0, colEnd = n - 1; int cnt = 1; while(rowStart &lt;= rowEnd &amp;&amp; colStart &lt;= colEnd) &#123; for(int i = colStart; i&lt;= colEnd; i++) vv[rowStart][i] = cnt++; rowStart++; for(int i = rowStart; i&lt;= rowEnd; i++) vv[i][colEnd] = cnt++; colEnd--; for(int i = colEnd; i&gt;= colStart; i--) vv[rowEnd][i] = cnt++; rowEnd--; for(int i = rowEnd; i&gt;= rowStart; i--) vv[i][colStart] = cnt++; colStart++; &#125; return vv; &#125;&#125;; https://discuss.leetcode.com/topic/30057/c-concise-solution C++ concise solution. 1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt; (n, 1)); int left, right, top, down, index; left = top = index = 0, right = down = n-1; while (left &lt;= right &amp;&amp; top &lt;= down) &#123; for (unsigned int j = left; j &lt;= right; j++) res[top][j] = ++index; top++; for (unsigned int i = top; i &lt;= down; i++) res[i][right] = ++index; right--; for (int j = right; j &gt;= left; j--) res[down][j] = ++index; down--; for (int i = down; i &gt;= top; i--) res[i][left] = ++index; left++; &#125; return res;&#125; python 56ms, 49.97%, June.19th, 2016 https://leetcode.com/discuss/46720/4-9-lines-python-solutions 4-9 lines Python solutions Solution 1: Build it inside-out - 44 ms, 5 lines Start with the empty matrix, add the numbers in reverse order until we added the number 1. Always rotate the matrix clockwise and add a top row: 123|| =&gt; |9| =&gt; |8| |6 7| |4 5| |1 2 3| |9| =&gt; |9 8| =&gt; |9 6| =&gt; |8 9 4| |8 7| |7 6 5| The code: 123456def generateMatrix(self, n): A, lo = [], n*n+1 while lo &gt; 1: lo, hi = lo - len(A), lo A = [range(lo, hi)] + zip(*A[::-1]) return A While this isn’t O(n^2), it’s actually quite fast, presumably due to me not doing much in Python but relying on zip and range and + being fast. I got it accepted in 44 ms, matching the fastest time for recent Python submissions (according to the submission detail page). Solution 2: Ugly inside-out - 48 ms, 4 lines Same as solution 1, but without helper variables. Saves a line, but makes it ugly. Also, because I access A[0][0], I had to handle the n=0 case differently. 12345def generateMatrix(self, n): A = [[n*n]] while A[0][0] &gt; 1: A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1]) return A * (n&gt;0) Solution 3: Walk the spiral - 52 ms, 9 lines Initialize the matrix with zeros, then walk the spiral path and write the numbers 1 to n*n. Make a right turn when the cell ahead is already non-zero. 12345678910def generateMatrix(self, n): A = [[0] * n for _ in range(n)] i, j, di, dj = 0, 0, 0, 1 for k in xrange(n*n): A[i][j] = k + 1 if A[(i+di)%n][(j+dj)%n]: di, dj = dj, -di i += di j += dj return A https://discuss.leetcode.com/topic/7739/if-we-can-t-write-data-to-the-matrix-we-change-the-direction-a-simple-python-solution If we can’t write data to the matrix, we change the direction,a simple python solution 1234567891011121314151617class Solution:# @return a list of lists of integerdef generateMatrix(self, n): matrix = [[0]*n for _ in range(n)] directions = ((0, 1), (1, 0), (0, -1), (-1, 0)) d = 0 y, x = 0, 0 for i in range(1, n*n+1): matrix[y][x] = i dy, dx = directions[d % 4] if -1 &lt; y+dy &lt; n and -1 &lt; x+dx &lt; n and matrix[y+dy][x+dx] == 0: y, x = y+dy, x+dx else: d += 1 dy, dx = directions[d % 4] y, x = y+dy, x+dx return matrix Change the direction If the we can’t write to the matrix java https://discuss.leetcode.com/topic/4362/my-super-simple-solution-can-be-used-for-both-spiral-matrix-i-and-ii My Super Simple Solution. Can be used for both Spiral Matrix I and II This is my solution for Spiral Matrix I, https://oj.leetcode.com/discuss/12228/super-simple-and-easy-to-understand-solution. If you can understand that, this one is a no brainer :) Guess what? I just made several lines of change (with comment “//change”) from that and I have the following AC code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public int[][] generateMatrix(int n) &#123; // Declaration int[][] matrix = new int[n][n]; // Edge Case if (n == 0) &#123; return matrix; &#125; // Normal Case int rowStart = 0; int rowEnd = n-1; int colStart = 0; int colEnd = n-1; int num = 1; //change while (rowStart &lt;= rowEnd &amp;&amp; colStart &lt;= colEnd) &#123; for (int i = colStart; i &lt;= colEnd; i ++) &#123; matrix[rowStart][i] = num ++; //change &#125; rowStart ++; for (int i = rowStart; i &lt;= rowEnd; i ++) &#123; matrix[i][colEnd] = num ++; //change &#125; colEnd --; for (int i = colEnd; i &gt;= colStart; i --) &#123; if (rowStart &lt;= rowEnd) matrix[rowEnd][i] = num ++; //change &#125; rowEnd --; for (int i = rowEnd; i &gt;= rowStart; i --) &#123; if (colStart &lt;= colEnd) matrix[i][colStart] = num ++; //change &#125; colStart ++; &#125; return matrix; &#125;&#125; Obviously, you could merge colStart and colEnd into rowStart and rowEnd because it is a square matrix. But this is easily extensible to matrices that are m*n. Hope this helps :) 0ms, 17.235, June.19th, 2016 https://leetcode.com/discuss/38659/share-my-java-solution Share my java solution 123456789101112131415161718192021222324252627public class Solution &#123; public static int[][] generateMatrix(int n) &#123; int[][] ret = new int[n][n]; int left = 0,top = 0; int right = n -1,down = n - 1; int count = 1; while (left &lt;= right) &#123; for (int j = left; j &lt;= right; j ++) &#123; ret[top][j] = count++; &#125; top ++; for (int i = top; i &lt;= down; i ++) &#123; ret[i][right] = count ++; &#125; right --; for (int j = right; j &gt;= left; j --) &#123; ret[down][j] = count ++; &#125; down --; for (int i = down; i &gt;= top; i --) &#123; ret[i][left] = count ++; &#125; left ++; &#125; return ret; &#125;&#125; https://discuss.leetcode.com/topic/9299/share-my-simple-solution-with-graphical-explanation-java Share my simple solution with graphical explanation - Java If n is odd, only the first direction will cover it (top left -&gt; right, shown as # in the graph), because the other three direction all start from the next position( +1 or -1). 1234567891011121314151617181920212223242526272829303132333435363738/** * -&gt; -&gt; -&gt; * ^ | * | | * &lt;- &lt;-- V * * # # # # * % $ * % $ * &amp; &amp; &amp; $ * */ public static int[][] generateMatrix(int n) &#123; int[][] res = new int[n][n]; int num = 1; int level = (int) Math.ceil(n / 2.); for(int i = 0; i &lt; level; i++) &#123; // top left -&gt; right, shown as # for(int j = i; j &lt; n - i; j++) res[i][j] = num++; // top right + 1 -&gt; bot, shown as $ for(int j = i + 1; j &lt; n - i; j++) res[j][n - i - 1] = num++; // bot right - 1 -&gt; left, shown as &amp; for(int j = n - i - 2; j &gt;= i; j--) res[n - i - 1][j] = num++; // bot left -1 -&gt; top + 1, shown as % for(int j = n - i - 2; j &gt; i; j--) res[j][i] = num++; &#125; return res; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[058. Length of Last Word]]></title>
    <url>%2Fp%2Fe32fb410%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/length-of-last-word/ Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. 123For example, Given s = &quot;Hello World&quot;,return 5. 方法一： code 1： 核心思想，从后向前遍历，从后遍历，这个想法很好。 很多时候从前向后可能有一定的麻烦，但是从后向前的遍历， 会收到很好的效果。 或许这就是所谓的逆向思维吧。 https://discuss.leetcode.com/topic/17312/7-lines-4ms-c-solution 7-lines 4ms C++ Solution Well, the basic idea is very simple. Start from the tail of s and move backwards to find the first non-space character. Then from this character, move backwards and count the number of non-space characters until we pass over the head of s or meet a space character. The count will then be the length of the last word. 123456789101112class Solution &#123;public: int lengthOfLastWord(string s) &#123; int len = 0, tail = s.length() - 1; while (tail &gt;= 0 &amp;&amp; s[tail] == &apos; &apos;) tail--; while (tail &gt;= 0 &amp;&amp; s[tail] != &apos; &apos;) &#123; len++; tail--; &#125; return len; &#125;&#125;; code 2: 12345678910111213141516class Solution &#123;public: int lengthOfLastWord(string s) &#123; if(s.empty()) return 0; int n = s.size(); int len = 0; int tail = n-1; while(tail&gt;=0 &amp;&amp; s[tail]==&apos; &apos;) tail--; while(tail&gt;=0 &amp;&amp; s[tail]!=&apos; &apos;)&#123; len++; tail--; &#125; return len; &#125;&#125;; python Solution mine: 40ms, 88.34%, June.23th, 2016 1234567class Solution(object): def lengthOfLastWord(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; return len(s.strip().split(&apos; &apos;)[-1]) https://discuss.leetcode.com/topic/7733/one-line-python-solution One line Python solution12def lengthOfLastWord(self, s): return len(s.rstrip(&apos; &apos;).split(&apos; &apos;)[-1]) java 1ms, 41.25%, June.23th, 2016 https://leetcode.com/discuss/18670/a-single-line-of-code-in-java A single line of Code in Java12345public class Solution &#123; public int lengthOfLastWord(String s) &#123; return s.trim().length()-s.trim().lastIndexOf(&quot; &quot;)-1; &#125;&#125; https://discuss.leetcode.com/topic/27201/my-3-line-0-ms-java-solution My 3 line 0 ms java solution12345public int lengthOfLastWord(String s) &#123; s = s.trim(); int lastIndex = s.lastIndexOf(&apos; &apos;) + 1; return s.length() - lastIndex; &#125; https://discuss.leetcode.com/topic/17762/228ms-java-solution 228ms Java Solution 1 - Use 2 loops. One to locate the last non-space character, one to count. 123456789101112131415161718public int lengthOfLastWord(String s) &#123; //228ms int lenIndex = s.length()-1; int len = 0; /*can also use while here, resulting in 264ms while (lenIndex&gt;=0 &amp;&amp; s.charAt(lenIndex)==&apos; &apos;) lenIndex--;*/ /*or use trim - 324ms s = s.trim();*/ for (int i=lenIndex; i&gt;=0 &amp;&amp; s.charAt(i)==&apos; &apos;; i--) lenIndex--; for (int i=lenIndex; i&gt;=0 &amp;&amp; s.charAt(i)!=&apos; &apos;; i--) len++; return len;&#125; 2 - Use split 1234//292ms String[] words = s.split(&quot; &quot;); if (words.length==0) return 0; else return words[words.length-1].length(); 3 - use lastIndexOf 12//308ms return s.trim().length() - s.trim().lastIndexOf(&quot; &quot;) - 1;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[057. Insert Interval]]></title>
    <url>%2Fp%2F65f5c34%2F</url>
    <content type="text"><![CDATA[26.7% https://leetcode.com/problems/insert-interval/ Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. 1234567Example 1:Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].Example 2:Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10]. 方法一： 头条代码 Easy and clean O(n) C++ solution Very easy to understand code as follows. First, put all intervals that are to the left of the inserted interval. Second, merge all intervals that intersect with the inserted interval. Finally, put all intervals that are to the right of the inserted interval. That’s it! You are done! 重点答案，简单直白高效 一个启示，未必只用一个while/for循环，可以前一段一个while，中间一个while，后面一个while，这样分开讨论的情况，很简洁，思路畅通。 针对相遇的情况，更改了newInterval的值，始终保持start最小，end最大，最后加入到结果中。 1234567891011121314151617181920class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int index = 0; while(index &lt; intervals.size() &amp;&amp; intervals[index].end &lt; newInterval.start)&#123; res.push_back(intervals[index++]); &#125; while(index &lt; intervals.size() &amp;&amp; intervals[index].start &lt;= newInterval.end)&#123; newInterval.start = min(newInterval.start, intervals[index].start); newInterval.end = max(newInterval.end, intervals[index].end); index++; &#125; res.push_back(newInterval); while(index &lt; intervals.size())&#123; res.push_back(intervals[index++]); &#125; return res; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; int n = intervals.size(); vector&lt;Interval&gt; res; int i = 0; while(i&lt;n &amp;&amp; intervals[i].end&lt;newInterval.start) res.push_back(intervals[i++]); while(i&lt;n &amp;&amp; intervals[i].start&lt;=newInterval.end)&#123; newInterval.start = min(newInterval.start, intervals[i].start); newInterval.end = max(newInterval.end, intervals[i].end); i++; &#125; res.push_back(newInterval); while(i&lt;n) res.push_back(intervals[i++]); return res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/12899/very-short-and-easy-to-understand-c-solution Very short and easy to understand C++ solution 12345678910111213141516171819vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; ret; auto it = intervals.begin(); for(; it!=intervals.end(); ++it)&#123; if(newInterval.end &lt; (*it).start) //all intervals after will not overlap with the newInterval break; else if(newInterval.start &gt; (*it).end) //*it will not overlap with the newInterval ret.push_back(*it); else&#123; //update newInterval bacause *it overlap with the newInterval newInterval.start = min(newInterval.start, (*it).start); newInterval.end = max(newInterval.end, (*it).end); &#125; &#125; // don&apos;t forget the rest of the intervals and the newInterval ret.push_back(newInterval); for(; it!=intervals.end(); ++it) ret.push_back(*it); return ret;&#125; My question is why this code need 500ms !? https://discuss.leetcode.com/topic/28015/elegant-c-stl-solution-using-equal_range-to-find-overlapped-intervals Elegant C++ STL solution, using “equal_range” to find overlapped intervals. 123456789101112131415161718class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; auto compare = [] (const Interval &amp;intv1, const Interval &amp;intv2) &#123; return intv1.end &lt; intv2.start; &#125;; auto range = equal_range(intervals.begin(), intervals.end(), newInterval, compare); auto itr1 = range.first, itr2 = range.second; if (itr1 == itr2) &#123; intervals.insert(itr1, newInterval); &#125; else &#123; itr2--; itr2-&gt;start = min(newInterval.start, itr1-&gt;start); itr2-&gt;end = max(newInterval.end, itr2-&gt;end); intervals.erase(itr1, itr2); &#125; return intervals; &#125;&#125;; https://discuss.leetcode.com/topic/24439/easy-and-clean-o-n-c-solution Easy and clean O(n) C++ solution Very easy to understand code as follows. First, put all intervals that are to the left of the inserted interval. Second, merge all intervals that intersect with the inserted interval. Finally, put all intervals that are to the right of the inserted interval. That’s it! You are done! 重点答案，简单直白高效 一个启示，未必只用一个while/for循环，可以前一段一个while，中间一个while，后面一个while，这样分开讨论的情况，很简洁，思路畅通。 针对相遇的情况，更改了newInterval的值，始终保持start最小，end最大，最后加入到结果中。 1234567891011121314151617181920class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int index = 0; while(index &lt; intervals.size() &amp;&amp; intervals[index].end &lt; newInterval.start)&#123; res.push_back(intervals[index++]); &#125; while(index &lt; intervals.size() &amp;&amp; intervals[index].start &lt;= newInterval.end)&#123; newInterval.start = min(newInterval.start, intervals[index].start); newInterval.end = max(newInterval.end, intervals[index].end); index++; &#125; res.push_back(newInterval); while(index &lt; intervals.size())&#123; res.push_back(intervals[index++]); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/17937/two-easy-o-n-c-solutions-with-explanations Two Easy O(n) C++ Solutions with Explanations By far the best solution I have seen is of O(n) time (some solutions claim to be of O(logn) turns out to be O(n)). One of the simplest ideas is to compare each interval in intervals (intervals[i]) with newInterval and then perform respective operations according to their relationships. If they overlap, merge them to newInterval; If intervals[i] is to the left of newInterval, push intervals[i] to the result vector; If newInterval is to the left of intervals[i], push newInterval and all the remaining intervals (intervals[i], …, intervals[n - 1]) to the result vector. The code is as follows. 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int n = intervals.size(); for (int i = 0; i &lt; n; i++) &#123; if (intervals[i].end &lt; newInterval.start) res.push_back(intervals[i]); else if (newInterval.end &lt; intervals[i].start) &#123; res.push_back(newInterval); for (int j = i; j &lt; n; j++) res.push_back(intervals[j]); return res; &#125; else newInterval = merge(intervals[i], newInterval); &#125; res.push_back(newInterval); return res; &#125;private: Interval merge(Interval&amp; interval1, Interval&amp; interval2) &#123; int start = min(interval1.start, interval2.start); int end = max(interval1.end, interval2.end); return Interval(start, end); &#125;&#125;; Another idea is to search for the two ends of the overlapping intervals using binary search. Then we only need to merge newInterval with the intervals at the two ends if they overlap. All the intervals within the two ends will be contained innewInterval. Let’s do the example in the problem statement: intervals = [1, 2], [3, 5], [6, 7], [8, 10], [12, 16] and newInterval = [4, 9]. We first find the rightmost interval with start smaller than that of newInterval, which is [3, 5]. Then we find the leftmost interval with end larger than that of newInterval, which is [8, 10]. Then all the intervals between them will be contained within newInterval (you may check this to convince yourself) and so can be safely ignored. We only need to check whether newInterval overlaps with the two intervals on the two ends and merge them if necessary. The complete code is as follows. 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; int n = intervals.size(), leftEnd, rightEnd, l, r; vector&lt;Interval&gt; res; // Find the rightmost interval with start smaller than that of newInterval for (l = 0, r = n - 1; l &lt;= r; ) &#123; int mid = l + ((r - l) &gt;&gt; 1); if (intervals[mid].start &gt; newInterval.start) r = mid - 1; else l = mid + 1; &#125; leftEnd = r; // Find the leftmost interval with end larger than that of newInterval for (l = 0, r = n - 1; l &lt;= r; ) &#123; int mid = l + ((r - l) &gt;&gt; 1); if (intervals[mid].end &lt; newInterval.end) l = mid + 1; else r = mid - 1; &#125; rightEnd = l; // Merge newInterval with intervals[leftEnd] and intervals[rightEnd] if necessary if (leftEnd &gt;= 0 &amp;&amp; intervals[leftEnd].end &gt;= newInterval.start) newInterval.start = intervals[leftEnd--].start; if (rightEnd &lt; n &amp;&amp; intervals[rightEnd].start &lt;= newInterval.end) newInterval.end = intervals[rightEnd++].end; // Save the intervals sequentially for (int i = 0; i &lt;= leftEnd; i++) res.push_back(intervals[i]); res.push_back(newInterval); for (int i = rightEnd; i &lt; n; i++) res.push_back(intervals[i]); return res; &#125;&#125;; python https://discuss.leetcode.com/topic/16988/7-lines-3-easy-solutions 7+ lines, 3 easy solutions Solution 1: (7 lines, 88 ms) Collect the intervals strictly left or right of the new interval, then merge the new one with the middle ones (if any) before inserting it between left and right ones. 12345678def insert(self, intervals, newInterval): s, e = newInterval.start, newInterval.end left = [i for i in intervals if i.end &lt; s] right = [i for i in intervals if i.start &gt; e] if left + right != intervals: s = min(s, intervals[len(left)].start) e = max(e, intervals[~len(right)].end) return left + [Interval(s, e)] + right Solution 2: (8 lines, 84 ms) Same algorithm as solution 1, but different implementation with only one pass and explicitly collecting the to-be-merged intervals. 123456789def insert(self, intervals, newInterval): s, e = newInterval.start, newInterval.end parts = merge, left, right = [], [], [] for i in intervals: parts[(i.end &lt; s) - (i.start &gt; e)].append(i) if merge: s = min(s, merge[0].start) e = max(e, merge[-1].end) return left + [Interval(s, e)] + right Solution 3: (11 lines, 80 ms) Same again, but collect and merge while going over the intervals once. 123456789101112def insert(self, intervals, newInterval): s, e = newInterval.start, newInterval.end left, right = [], [] for i in intervals: if i.end &lt; s: left += i, elif i.start &gt; e: right += i, else: s = min(s, i.start) e = max(e, i.end) return left + [Interval(s, e)] + right https://discuss.leetcode.com/topic/6976/o-n-python-solution O(n) Python solution 123456789101112131415161718192021class Solution: # @param intervals, a list of Intervals # @param newInterval, a Interval # @return a list of Interval def insert(self, intervals, newInterval): start = newInterval.start end = newInterval.end result = [] i = 0 while i &lt; len(intervals): if start &lt;= intervals[i].end: if end &lt; intervals[i].start: break start = min(start, intervals[i].start) end = max(end, intervals[i].end) else: result.append(intervals[i]) i += 1 result.append(Interval(start, end)) result += intervals[i:] return result 112ms, 19.91%, June.23th, 2016 123456789101112131415161718192021# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def insert(self, intervals, newInterval): &quot;&quot;&quot; :type intervals: List[Interval] :type newInterval: Interval :rtype: List[Interval] &quot;&quot;&quot; intervals.append(newInterval) rtype = [] for i in sorted(intervals, key = lambda x:x.start): if rtype and i.start &lt;= rtype[-1].end: rtype[-1].end = max(rtype[-1].end, i.end) else: rtype += i, return rtype java https://discuss.leetcode.com/topic/7808/short-and-straight-forward-java-solution Short and straight-forward Java solution Hi guys! Here’s a pretty straight-forward and concise solution below. 这个直白的解法，很喜欢，先针对intervals比较小的，未接触处理，然后进行中间相遇的处理，然后处理相遇后的。很直白，很简单。 123456789101112131415161718public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new LinkedList&lt;&gt;(); int i = 0; // add all the intervals ending before newInterval starts while (i &lt; intervals.size() &amp;&amp; intervals.get(i).end &lt; newInterval.start) result.add(intervals.get(i++)); // merge all overlapping intervals to one considering newInterval while (i &lt; intervals.size() &amp;&amp; intervals.get(i).start &lt;= newInterval.end) &#123; newInterval = new Interval( // we could mutate newInterval here also Math.min(newInterval.start, intervals.get(i).start), Math.max(newInterval.end, intervals.get(i).end)); i++; &#125; result.add(newInterval); // add the union of intervals we got // add all the rest while (i &lt; intervals.size()) result.add(intervals.get(i++)); return result;&#125; Hope it helps. https://discuss.leetcode.com/topic/12691/short-java-code Short java code 123456789101112131415161718public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new ArrayList&lt;Interval&gt;(); for (Interval i : intervals) &#123; if (newInterval == null || i.end &lt; newInterval.start) result.add(i); else if (i.start &gt; newInterval.end) &#123; result.add(newInterval); result.add(i); newInterval = null; &#125; else &#123; newInterval.start = Math.min(newInterval.start, i.start); newInterval.end = Math.max(newInterval.end, i.end); &#125; &#125; if (newInterval != null) result.add(newInterval); return result;&#125; https://discuss.leetcode.com/topic/41004/my-binary-search-approach-implementation-2ms My Binary Search Approach Implementation, 2ms I know this is a little messy. For clean and simple code, please use the O(n) approach. We have great answer here with just 3 while loops. The BS approach utilizes the ordered characteristic of the input. For me, I want to get the position of the interval that is the first to have start equal to or larger than the inserted interval’s start. Similarly, I get the position of the interval that is the first to have end equal to or larger than the new interval’s end. Then I can get the range of intervals that the new interval connects. There are some corner cases that need to be considered, i.e. when the new interval has no overlap with any of the existing intervals (smaller, larger, or the original list is empty). In these corner cases, we just don’t need to update the new interval. The code could possibly be cleaner and simpler without sacrificing the speed, or even with less time and space. Please let me know if you have any suggestions. Thank you! 123456789101112131415161718192021222324252627282930313233343536373839404142public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); if (intervals == null || newInterval == null) return result; int iStart = findStartPos(intervals, newInterval.start); int iEnd = findEndPos(intervals, newInterval.end); if (iStart &gt; 0 &amp;&amp; intervals.get(iStart - 1).end &gt;= newInterval.start) iStart--; if (iEnd == intervals.size() || intervals.get(iEnd).start &gt; newInterval.end) iEnd--; //If not in the corner cases, this condition should apply. if (iStart &lt;= iEnd) &#123; newInterval = new Interval(Math.min(newInterval.start, intervals.get(iStart).start),Math.max(newInterval.end, intervals.get(iEnd).end)); &#125; int i = 0; while (i &lt; iStart) result.add(intervals.get(i++)); result.add(newInterval); i = iEnd + 1; while (i &lt; intervals.size()) result.add(intervals.get(i++)); return result;&#125;private int findStartPos(List&lt;Interval&gt; intervals, int value) &#123; int l = 0, r = intervals.size() - 1; while (l &lt;= r) &#123; int m = (l + r) &gt;&gt; 1; if (intervals.get(m).start == value) return m; else if (intervals.get(m).start &lt; value) l = m + 1; else r = m - 1; &#125; return l;&#125;private int findEndPos(List&lt;Interval&gt; intervals, int value) &#123; int l = 0, r = intervals.size() - 1; while (l &lt;= r) &#123; int m = (l + r) &gt;&gt; 1; if (intervals.get(m).end == value) return m; else if (intervals.get(m).end &lt; value) l = m + 1; else r = m - 1; &#125; return l;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hard</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[056. Merge Intervals]]></title>
    <url>%2Fp%2F5eec50bd%2F</url>
    <content type="text"><![CDATA[28.9% https://leetcode.com/problems/merge-intervals/ Given a collection of intervals, merge all overlapping intervals. 123For example,Given [1,3],[2,6],[8,10],[15,18],return [1,6],[8,10],[15,18]. 方法一： 先排序，再一个个的处理。 重点学习： sort函数的用法 vector的back函数 max函数的用法 123456789101112131415class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; ins) &#123; if (ins.empty()) return vector&lt;Interval&gt;&#123;&#125;; vector&lt;Interval&gt; res; sort(ins.begin(), ins.end(), [](Interval a, Interval b)&#123;return a.start &lt; b.start;&#125;); res.push_back(ins[0]); for (int i = 1; i &lt; ins.size(); i++) &#123; if (res.back().end &lt; ins[i].start) res.push_back(ins[i]); else res.back().end = max(res.back().end, ins[i].end); &#125; return res; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324252627/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; int n = intervals.size(); if(n&lt;=1) return intervals; vector&lt;Interval&gt; res; sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;return a.start&lt;b.start;&#125;); res.push_back(intervals[0]); for(int i=1; i&lt;n; i++)&#123; if(intervals[i].start &gt; res.back().end)&#123; res.push_back(intervals[i]); &#125;else&#123; res.back().end = max(res.back().end, intervals[i].end); &#125; &#125; return res; &#125;&#125;; 我的代码实现: Dec 10th, 2017 1234567891011121314151617181920class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; vector&lt;Interval&gt; res; if(intervals.size()&lt;=1) return intervals; sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;if(a.start&lt;b.start || (a.start==b.start) &amp;&amp; a.end&lt;b.end) return true; return false;&#125;); int s=intervals[0].start, e = intervals[0].end; for(int i=1; i&lt;intervals.size(); i++)&#123; if(e&lt;intervals[i].start)&#123; res.push_back(Interval(s, e)); s = intervals[i].start; e = intervals[i].end; &#125;else&#123; e = max(e, intervals[i].end); &#125; &#125; res.push_back(Interval(s, e)); return res; &#125;&#125;; cpp 20ms, 28.53%, June.22th, 2016 https://leetcode.com/discuss/49276/c-10-line-solution-easing-understanding C++ 10 line solution. easing understanding 先排序，然后开始开始遍历。 重点在于排序怎么写。 关于sort函数的用法，可以参考以下链接 http://www.cplusplus.com/reference/algorithm/sort/ http://www.cplusplus.com/articles/NhA0RXSz/ 123456789101112131415161718192021222324/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; ins) &#123; if (ins.empty()) return vector&lt;Interval&gt;&#123;&#125;; vector&lt;Interval&gt; res; sort(ins.begin(), ins.end(), [](Interval a, Interval b)&#123;return a.start &lt; b.start;&#125;); res.push_back(ins[0]); for (int i = 1; i &lt; ins.size(); i++) &#123; if (res.back().end &lt; ins[i].start) res.push_back(ins[i]); else res.back().end = max(res.back().end, ins[i].end); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/5765/my-easy-c-solution My easy C++ solution 12345678910111213141516171819202122static bool comp(const Interval&amp; a, const Interval&amp; b)&#123; return a.start &lt; b.start;&#125;vector&lt;Interval&gt; merge(vector&lt;Interval&gt; &amp;intervals) &#123; vector&lt;Interval&gt; result; if(intervals.empty())&#123; return result; &#125; sort(intervals.begin(), intervals.end(), comp); result.push_back(intervals[0]); for(int i = 1; i &lt; intervals.size(); i++)&#123; if(intervals[i].start &lt;= result.back().end)&#123; Interval temp(result.back().start, max(result.back().end, intervals[i].end)); result.pop_back(); result.push_back(temp); &#125; else&#123; result.push_back(intervals[i]); &#125; &#125; return result;&#125; https://discuss.leetcode.com/topic/20628/my-c-o-nlogn-solution-580ms My C++ O(NlogN) solution 580ms Just copy the input to res and do sorting (in ascending order of start). Then try to merge the sorted interval: cur is the last processed interval and i is the current to-be-processed interval. if cur is ahead of i and no overlapping, just copy i to cur+1, and update cur to cur+1, otherwise, merge interval cur and i and move to i+1. At last, we need to resize res to remove the redundent intervals. 12345678910111213141516class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; int len = intervals.size(),i,cur; vector&lt;Interval&gt; res(intervals); if(len&gt;1) &#123; std::sort(res.begin(), res.end(), [](Interval i, Interval j)&#123;return i.start&lt;j.start;&#125;); for(cur=0, i=1;i&lt;len; ++i) if(res[cur].end&lt;res[i].start) res[++cur] = res[i]; // no overlapping, copy to cur+1, else res[cur].end = max(res[cur].end, res[i].end); // cur and i overlap with each other, merge res.resize(cur+1); // resize to remove redundant intervals &#125; return res; &#125;&#125;; python 88ms, 81.79%, June.22th, 2016 https://leetcode.com/discuss/42344/7-lines-easy-python 7 lines, easy, Python Just go through the intervals sorted by start coordinate and either combine the current interval with the previous one if they overlap, or add it to the output by itself if they don’t. 12345678910111213141516171819# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def merge(self, intervals): &quot;&quot;&quot; :type intervals: List[Interval] :rtype: List[Interval] &quot;&quot;&quot; out = [] for i in sorted(intervals, key = lambda i: i.start): if out and i.start &lt;= out[-1].end: out[-1].end = max(out[-1].end, i.end) else: out += i, return out https://discuss.leetcode.com/topic/27383/short-python-solution Short python solution Sort the list first. Check if the new interval overlaps with the previous one in the output list. If yes, update it. Otherwise, append the new one. 12345678910111213class Solution(object): def merge(self, intervals): &quot;&quot;&quot; :type intervals: List[Interval] :rtype: List[Interval] &quot;&quot;&quot; if len(intervals) == 0: return [] intervals = sorted(intervals, key = lambda x: x.start) res = [intervals[0]] for n in intervals[1:]: if n.start &lt;= res[-1].end: res[-1].end = max(n.end, res[-1].end) else: res.append(n) return res java https://discuss.leetcode.com/topic/4319/a-simple-java-solution A simple Java solution The idea is to sort the intervals by their starting points. Then, we take the first interval and compare its end with the next intervals starts. As long as they overlap, we update the end to be the max end of the overlapping intervals. Once we find a non overlapping interval, we can add the previous “extended” interval and start over. Sorting takes O(n log(n)) and merging the intervals takes O(n). So, the resulting algorithm takes O(n log(n)). I used an anonymous comparator and a for-each loop to try to keep the code clean and simple. 123456789101112131415161718192021222324252627282930public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; if (intervals.size() &lt;= 1) return intervals; // Sort by ascending starting point using an anonymous Comparator Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval i1, Interval i2) &#123; return Integer.compare(i1.start, i2.start); &#125; &#125;); List&lt;Interval&gt; result = new LinkedList&lt;Interval&gt;(); int start = intervals.get(0).start; int end = intervals.get(0).end; for (Interval interval : intervals) &#123; if (interval.start &lt;= end) // Overlapping intervals, move the end if needed end = Math.max(end, interval.end); else &#123; // Disjoint intervals, add the previous one and reset bounds result.add(new Interval(start, end)); start = interval.start; end = interval.end; &#125; &#125; // Add the last interval result.add(new Interval(start, end)); return result;&#125; https://discuss.leetcode.com/topic/12788/a-clean-java-solution A clean java solution 1234567891011121314151617181920212223public class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; Collections.sort(intervals, new Comparator&lt;Interval&gt;()&#123; @Override public int compare(Interval obj0, Interval obj1) &#123; return obj0.start - obj1.start; &#125; &#125;); List&lt;Interval&gt; ret = new ArrayList&lt;&gt;(); Interval prev = null; for (Interval inter : intervals) &#123; if ( prev==null || inter.start&gt;prev.end ) &#123; ret.add(inter); prev = inter; &#125; else if (inter.end&gt;prev.end) &#123; // Modify the element already in list prev.end = inter.end; &#125; &#125; return ret; &#125;&#125; https://discuss.leetcode.com/topic/38628/beat-98-java-sort-start-end-respectively Beat 98% Java. Sort start &amp; end respectively. The idea is that for the result distinct Interval, the latter one’s start must &gt; previous one’s end. 123456789101112131415161718192021public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; // sort start&amp;end int n = intervals.size(); int[] starts = new int[n]; int[] ends = new int[n]; for (int i = 0; i &lt; n; i++) &#123; starts[i] = intervals.get(i).start; ends[i] = intervals.get(i).end; &#125; Arrays.sort(starts); Arrays.sort(ends); // loop through List&lt;Interval&gt; res = new ArrayList&lt;Interval&gt;(); for (int i = 0, j = 0; i &lt; n; i++) &#123; // j is start of interval. if (i == n - 1 || starts[i + 1] &gt; ends[i]) &#123; res.add(new Interval(starts[j], ends[i])); j = i + 1; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/8571/fast-ana-simple-java-code Fast ana simple java code The idea is to sort intervals based on start and iterate all itervals to merge them if: 1curr.end &gt;= iter.start The time complexity is : sort nO(logn)+ merge: O(n) = nO(logn) No Extra space except necessary result : ) 1234567891011121314151617181920212223public class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; res = new LinkedList&lt;Interval&gt;(); if(intervals.size()&lt;2) return intervals; Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval o1, Interval o2) &#123; return o1.start-o2.start; &#125; &#125;); Interval curr = intervals.get(0); for(Interval iter: intervals) &#123; if(curr.end &gt;= iter.start) &#123; curr.end = Math.max(curr.end,iter.end); &#125;else &#123; res.add(curr); curr = iter; &#125; &#125; res.add(curr); return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[055. Jump Game]]></title>
    <url>%2Fp%2F5ad5dd79%2F</url>
    <content type="text"><![CDATA[29.5% https://leetcode.com/problems/jump-game/ Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. 1234For example:A = [2,3,1,1,4], return true.A = [3,2,1,0,4], return false. 方法一： code 1： 12345678910class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int i = 0; for(int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + nums[i], reach); return i == n; &#125;&#125;; code 2： 我的实现 12345678910class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int i = 0; for(int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + nums[i], reach); return i == n; &#125;&#125;; cpp https://leetcode.com/discuss/15567/linear-and-simple-solution-in-c 12ms, 98.85%, June.22th, 2016 12345678910class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int i = 0; for(int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + nums[i], reach); return i == n; &#125;&#125;; https://discuss.leetcode.com/topic/4911/linear-and-simple-solution-in-c Linear and simple solution in C++ I just iterate and update the maximal index that I can reach 123456bool canJump(int A[], int n) &#123; int i = 0; for (int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + A[i], reach); return i == n;&#125; https://discuss.leetcode.com/topic/3443/simplest-o-n-solution-with-constant-space Simplest O(N) solution with constant space Idea is to work backwards from the last index. Keep track of the smallest index that can “jump” to the last index. Check whether the current index can jump to this smallest index. 1234567bool canJump(int A[], int n) &#123; int last=n-1,i,j; for(i=n-2;i&gt;=0;i--)&#123; if(i+A[i]&gt;=last)last=i; &#125; return last&lt;=0;&#125; https://discuss.leetcode.com/topic/21062/c-elegant-solution-o-n-time C++, elegant solution, O(n) time. 123456789101112bool canJump(vector&lt;int&gt;&amp; nums) &#123; int size=nums.size(); int step=nums[0]; for(int i=1;i&lt;size;++i)&#123; step--; if(step&lt;0) return false; if(nums[i]&gt;step) step=nums[i]; &#125; return true;&#125; my code 12345678910111213class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int m = 0; int cur_max = 1; while(m &lt; cur_max &amp;&amp; cur_max &lt; n)&#123; cur_max = max(nums[m]+m+1, cur_max); m += 1; &#125; return cur_max &gt; n-1; &#125;&#125;; my code 123456789101112131415class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return true; int loc = 0; for(int i=0; i&lt;n-1; i++)&#123; if(i&lt;=loc) loc = max(i+nums[i], loc); if(i&gt;loc) return false; &#125; return loc &gt;= n-1; &#125;&#125;; python https://leetcode.com/discuss/41420/1-6-lines-o-n-time-o-1-space 68ms, 46.69%, June.22th, 2016123456789101112class Solution(object): def canJump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; m = 0 for i, n in enumerate(nums): if i &gt; m: return False m = max(m, i+n) return True https://discuss.leetcode.com/topic/16704/1-6-lines-o-n-time-o-1-space 1-6 lines, O(n) time, O(1) space Solution 1 Going forwards. m tells the maximum index we can reach so far. 1234567def canJump(self, nums): m = 0 for i, n in enumerate(nums): if i &gt; m: return False m = max(m, i+n) return True Solution 2 One-liner version: 12def canJump(self, nums): return reduce(lambda m, (i, n): max(m, i+n) * (i &lt;= m), enumerate(nums, 1), 1) &gt; 0 Solution 3 Going backwards, most people seem to do that, here’s my version. 123456def canJump(self, nums): goal = len(nums) - 1 for i in range(len(nums))[::-1]: if i + nums[i] &gt;= goal: goal = i return not goal Solution 4 C version. 1234567bool canJump(int* nums, int n) &#123; int goal=n-1, i; for (i=n; i--;) if (i+nums[i] &gt;= goal) goal=i; return !goal;&#125; Solution mine: 96ms, 10.22%, June.22th, 2016 1234567891011121314class Solution(object): def canJump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; i = 0 max = 0 while i &lt; len(nums) and i &lt;= max: tmp = i + nums[i] if tmp &gt; max: max = tmp i += 1 return max &gt;= len(nums) - 1 Solution mine: 60ms, 79.56%, June.22th, 2016 12345678910111213class Solution(object): def canJump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; i = 0 m = 0 n = len(nums) while i &lt; n and i &lt;= m: m = max(i+nums[i], m) i += 1 return m &gt;= len(nums) -1 java https://leetcode.com/discuss/22560/java-solution-easy-to-understand 3ms, 26.71%, June.22th, 2016 Java Solution easy to understand 12345678910public class Solution &#123; public boolean canJump(int[] nums) &#123; int max = 0; for(int i = 0; i&lt; nums.length; i++)&#123; if(i &gt; max) return false; max = Math.max(nums[i] + i, max); &#125; return true; &#125;&#125; https://discuss.leetcode.com/topic/19931/6-line-java-solution-in-o-n 6 line java solution in O(n) The basic idea is this: at each step, we keep track of the furthest reachable index. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable. Hence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable. 12345678public boolean canJump(int[] nums) &#123; int reachable = 0; for (int i=0; i&lt;nums.length; ++i) &#123; if (i &gt; reachable) return false; reachable = Math.max(reachable, i + nums[i]); &#125; return true;&#125; https://discuss.leetcode.com/topic/36578/java-98-percentile-solution Java 98% Percentile Solution The easiest way to think about this problem is to ask are the elements with a 0 value avoidable? this is the algorithm that I constructed to answer this question.Starting from the second to last element in the array we continue to decrement towards the start of the array. Only stopping if we hit an element with a value of 0; in this case we evaluate if there exist an element somewhere at the start of the array which has a jump value large enough to jump over this 0 value element. 1234567891011121314151617public class Solution &#123; public boolean canJump(int[] nums) &#123; if(nums.length &lt; 2) return true; for(int curr = nums.length-2; curr&gt;=0;curr--)&#123; if(nums[curr] == 0)&#123; int neededJumps = 1; while(neededJumps &gt; nums[curr])&#123; neededJumps++; curr--; if(curr &lt; 0) return false; &#125; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[054. Spiral Matrix]]></title>
    <url>%2Fp%2F50cae0bf%2F</url>
    <content type="text"><![CDATA[25.1% https://leetcode.com/problems/spiral-matrix/ Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. 123456789For example,Given the following matrix:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]You should return [1,2,3,6,9,8,7,4,5]. 方法一： 设置四个变量，up，down， left， right，控制边界，直到要跳出循环。 剑指offer，20题。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return &#123;&#125;; int m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; spiral(m * n); int u = 0, d = m - 1, l = 0, r = n - 1, k = 0; while (true) &#123; // up for (int col = l; col &lt;= r; col++) spiral[k++] = matrix[u][col]; if (++u &gt; d) break; // right for (int row = u; row &lt;= d; row++) spiral[k++] = matrix[row][r]; if (--r &lt; l) break; // down for (int col = r; col &gt;= l; col--) spiral[k++] = matrix[d][col]; if (--d &lt; u) break; // left for (int row = d; row &gt;= u; row--) spiral[k++] = matrix[row][l]; if (++l &gt; r) break; &#125; return spiral; &#125;&#125;; 我的代码实现； 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; if(matrix.empty() || matrix[0].empty()) return res; // right = matrix[0].size()-1 而不是matrix[0]-1 我们要的是index int left = 0, right = matrix[0].size()-1, up = 0, down = matrix.size()-1; // 这里设置为永远为true while(true)&#123; for(int i=left; i&lt;=right; i++) res.push_back(matrix[up][i]); up++; // 需要在这里判断一下是否跳出循环 if(up&gt;down) break; for(int j=up; j&lt;=down; j++) res.push_back(matrix[j][right]); right--; if(left&gt;right) break; for(int k=right; k&gt;=left; k--) res.push_back(matrix[down][k]); down--; if(up&gt;down) break; for(int l=down; l&gt;=up; l--) res.push_back(matrix[l][left]); left++; if(left&gt;right) break; &#125; return res; &#125;&#125;; 0ms, 15.19%, June.25th, 2016 https://leetcode.com/discuss/38974/a-concise-c-implementation-based-on-directions A concise C++ implementation based on Directions When traversing the matrix in the spiral order, at any time we follow one out of the following four directions: RIGHT DOWN LEFT UP. Suppose we are working on a 5 x 3 matrix as such: 0 1 2 3 4 56 7 8 9 1011 12 13 14 15 Imagine a cursor starts off at (0, -1), i.e. the position at ‘0’, then we can achieve the spiral order by doing the following: Go right 5 times Go down 2 times Go left 4 times Go up 1 times. Go right 3 times Go down 0 times -&gt; quit Notice that the directions we choose always follow the order ‘right-&gt;down-&gt;left-&gt;up’, and for horizontal movements, the number of shifts follows:{5, 4, 3}, and vertical movements follows {2, 1, 0}. Thus, we can make use of a direction matrix that records the offset for all directions, then an array of two elements that stores the number of shifts for horizontal and vertical movements, respectively. This way, we really just need one for loop instead of four. Another good thing about this implementation is that: If later we decided to do spiral traversal on a different direction (e.g. Counterclockwise), then we only need to change the Direction matrix; the main loop does not need to be touched. 1234567891011121314151617181920vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;vector&lt;int&gt; &gt; dirs&#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; vector&lt;int&gt; res; int nr = matrix.size(); if (nr == 0) return res; int nc = matrix[0].size(); if (nc == 0) return res; vector&lt;int&gt; nSteps&#123;nc, nr-1&#125;; int iDir = 0; // index of direction. int ir = 0, ic = -1; // initial position while (nSteps[iDir%2]) &#123; for (int i = 0; i &lt; nSteps[iDir%2]; ++i) &#123; ir += dirs[iDir][0]; ic += dirs[iDir][1]; res.push_back(matrix[ir][ic]); &#125; nSteps[iDir%2]--; iDir = (iDir + 1) % 4; &#125; return res;&#125; https://discuss.leetcode.com/topic/21090/0ms-clear-c-solution 0ms Clear C++ Solution The idea is just to add the elements in the spiral order. First the up-most row (u), then the right-most column (r), then the down-most row (d), and finally the left-most column (l). After finishing a row or a column, update the corresponding variable to continue the process. The code is as follows. 简单直接 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return &#123;&#125;; int m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; spiral(m * n); int u = 0, d = m - 1, l = 0, r = n - 1, k = 0; while (true) &#123; // up for (int col = l; col &lt;= r; col++) spiral[k++] = matrix[u][col]; if (++u &gt; d) break; // right for (int row = u; row &lt;= d; row++) spiral[k++] = matrix[row][r]; if (--r &lt; l) break; // down for (int col = r; col &gt;= l; col--) spiral[k++] = matrix[d][col]; if (--d &lt; u) break; // left for (int row = d; row &gt;= u; row--) spiral[k++] = matrix[row][l]; if (++l &gt; r) break; &#125; return spiral; &#125;&#125;; my code: 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.size()==0 || matrix[0].size()==0) return &#123;&#125;; int m = matrix.size(); int n = matrix[0].size(); vector&lt;int&gt; spiral(m*n, 0); int up=0, down=m-1, left=0, right=n-1, i=0; while(true)&#123; for(int col=left; col&lt;=right; col++) spiral[i++] = matrix[up][col]; if(++up&gt;down) break; for(int row=up; row&lt;=down; row++) spiral[i++] = matrix[row][right]; if(--right&lt;left) break; for(int col=right; col&gt;=left; col--) spiral[i++] = matrix[down][col]; if(--down&lt;up) break; for(int row=down; row&gt;=up; row--) spiral[i++] = matrix[row][left]; if(++left&gt;right) break; &#125; return spiral; &#125;&#125;; https://discuss.leetcode.com/topic/19034/1-liner-in-python 1-liner in Python Take the first row plus the spiral order of the rotated remaining matrix. Inefficient for large matrices, but here I got it accepted in 40 ms, one of the fastest Python submissions. 12def spiralOrder(self, matrix): return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1]) 52ms, 35.84%, June.25th, 2016 https://leetcode.com/discuss/17818/simple-python-solution-by-mutating-the-matrix Simple Python solution by mutating the matrix The con is mutating the matrix, if this is not allowed, we can make a deep copy of the matrix first. And of course it comes with the additional memory usage. 123456789101112131415161718class Solution(object): def spiralOrder(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: List[int] &quot;&quot;&quot; ret = [] while matrix: ret += matrix.pop(0) if matrix and matrix[0]: for row in matrix: ret.append(row.pop()) if matrix: ret += matrix.pop()[::-1] if matrix and matrix[0]: for row in matrix[::-1]: ret.append(row.pop(0)) return ret https://discuss.leetcode.com/topic/26242/ac-python-32ms-solution AC Python 32ms solution 1234567891011121314151617181920212223def spiralOrder(self, matrix): if not matrix or not matrix[0]: return [] ans = [] m, n = len(matrix), len(matrix[0]) u, d, l, r = 0, m - 1, 0, n - 1 while l &lt; r and u &lt; d: ans.extend([matrix[u][j] for j in xrange(l, r)]) ans.extend([matrix[i][r] for i in xrange(u, d)]) ans.extend([matrix[d][j] for j in xrange(r, l, -1)]) ans.extend([matrix[i][l] for i in xrange(d, u, -1)]) u, d, l, r = u + 1, d - 1, l + 1, r - 1 if l == r: ans.extend([matrix[i][r] for i in xrange(u, d + 1)]) elif u == d: ans.extend([matrix[u][j] for j in xrange(l, r + 1)]) return ans# 22 / 22 test cases passed.# Status: Accepted# Runtime: 32 ms# 100% https://discuss.leetcode.com/topic/3713/super-simple-and-easy-to-understand-solution Super Simple and Easy to Understand Solution This is a very simple and easy to understand solution. I traverse right and increment rowBegin, then traverse down and decrement colEnd, then I traverse left and decrement rowEnd, and finally I traverse up and increment colBegin. The only tricky part is that when I traverse left or up I have to check whether the row or col still exists to prevent duplicates. If anyone can do the same thing without that check, please let me know! Any comments greatly appreciated. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (matrix.length == 0) &#123; return res; &#125; int rowBegin = 0; int rowEnd = matrix.length-1; int colBegin = 0; int colEnd = matrix[0].length - 1; while (rowBegin &lt;= rowEnd &amp;&amp; colBegin &lt;= colEnd) &#123; // Traverse Right for (int j = colBegin; j &lt;= colEnd; j ++) &#123; res.add(matrix[rowBegin][j]); &#125; rowBegin++; // Traverse Down for (int j = rowBegin; j &lt;= rowEnd; j ++) &#123; res.add(matrix[j][colEnd]); &#125; colEnd--; if (rowBegin &lt;= rowEnd) &#123; // Traverse Left for (int j = colEnd; j &gt;= colBegin; j --) &#123; res.add(matrix[rowEnd][j]); &#125; &#125; rowEnd--; if (colBegin &lt;= colEnd) &#123; // Traver Up for (int j = rowEnd; j &gt;= rowBegin; j --) &#123; res.add(matrix[j][colBegin]); &#125; &#125; colBegin ++; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/22270/elegant-and-fast-java-solution-240ms Elegant and fast Java solution (240ms) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;List&lt;Integer&gt; spiralList = new ArrayList&lt;&gt;();if(matrix == null || matrix.length == 0) return spiralList;// declare indicesint top = 0;int bottom = matrix.length - 1;int left = 0;int right = matrix[0].length - 1;while(true)&#123; // 1. print top row for(int j=left; j &lt;=right;j++)&#123; spiralList.add(matrix[top][j]); &#125; top++; if(boundriesCrossed(left,right,bottom,top)) break; // 2. print rightmost column for(int i=top; i &lt;= bottom; i++)&#123; spiralList.add(matrix[i][right]); &#125; right--; if(boundriesCrossed(left,right,bottom,top)) break; // 3. print bottom row for(int j=right; j &gt;=left; j--)&#123; spiralList.add(matrix[bottom][j]); &#125; bottom--; if(boundriesCrossed(left,right,bottom,top)) break; // 4. print leftmost column for(int i=bottom; i &gt;= top; i--)&#123; spiralList.add(matrix[i][left]); &#125; left++; if(boundriesCrossed(left,right,bottom,top)) break; &#125;// end while truereturn spiralList;&#125;private boolean boundriesCrossed(int left,int right,int bottom,int top)&#123;if(left&gt;right || bottom&lt;top) return true;else return false;&#125; https://discuss.leetcode.com/topic/44784/clean-java-readable-human-friendly-code Clean Java, readable, human friendly code 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(matrix.length == 0 || matrix[0].length == 0) return res; int top = 0; int bottom = matrix.length-1; int left = 0; int right = matrix[0].length-1; while(true)&#123; for(int i = left; i &lt;= right; i++) res.add(matrix[top][i]); top++; if(left &gt; right || top &gt; bottom) break; for(int i = top; i &lt;= bottom; i++) res.add(matrix[i][right]); right--; if(left &gt; right || top &gt; bottom) break; for(int i = right; i &gt;= left; i--) res.add(matrix[bottom][i]); bottom--; if(left &gt; right || top &gt; bottom) break; for(int i = bottom; i &gt;= top; i--) res.add(matrix[i][left]); left++; if(left &gt; right || top &gt; bottom) break; &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[053. Maximum Subarray]]></title>
    <url>%2Fp%2Fe4eaff71%2F</url>
    <content type="text"><![CDATA[39.0% https://leetcode.com/problems/maximum-subarray/ Find the contiguous subarray within an array (containing at least one number) which has the largest sum. 12For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. click to show more practice. More practice: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 方法一： 动态规划 dp[n] 保存以nums[n]结尾的最大值，ans保存当前到n所有表中的最大值。 1234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; vector&lt;int&gt; dp(nums.size(), 0); dp[0] = nums[0]; int ans = nums[0]; for(int i=1; i&lt;nums.size(); i++)&#123; dp[i] = nums[i] + (dp[i-1]&gt;0?dp[i-1]:0); ans = max(ans, dp[i]); &#125; return ans; &#125;&#125;; 方法二： 与上面逻辑其实是类似的，保存一个当前最大值cur_sum，表示第i个位置之前，从i-1向前所能取得的最大值，并且以i-1结尾的， 全局最大值 max_sum表示0至i-1之前的最大值。到达第i位时，先更新当前最大值，再更新全局的。 1234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;0) return 0; int cur_sum = 0; int max_sum = INT_MIN; for(auto num:nums)&#123; cur_sum = max(cur_sum, 0) + num; max_sum = max(cur_sum, max_sum); &#125; return max_sum; &#125;&#125;; 我的代码实现： 通过初始化为第0位，避免了使用INT_MIN。 12345678910111213class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;1) return n; int cur_max = nums[0], all_max = nums[0]; for(int i=1; i&lt;n; i++)&#123; cur_max = max(cur_max+nums[i], nums[i]); all_max = max(all_max, cur_max); &#125; return all_max; &#125;&#125;; 我的代码实现: 123456789101112131415161718class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;1) return 0; if(n==1) return nums[0]; int cur_max = nums[0], res = nums[0]; int i=1; while(i&lt;n)&#123; // 仔细思考，这里是 max(nums[i], cur_max+nums[i]) // 而不是max(cur_max, cur_max+nums[i]); cur_max = max(nums[i], cur_max+nums[i]); res = max(res, cur_max); i++; &#125; return res; &#125;&#125;; cpp https://leetcode.com/discuss/11288/simplest-and-fastest-o-n-c-solution 8ms, 72.20%, June.18th, 2016 Simplest and fastest O(n) C++ solution Idea is very simple. Basically, keep adding each integer to the sequence until the sum drops below 0. If sum is negative, then should reset the sequence. 123456789101112class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int ans = nums[0], sum = 0; for(int i=0; i &lt; nums.size();i++)&#123; sum += nums[i]; ans = max(ans, sum); sum = max(sum, 0); &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/4175/share-my-solutions-both-greedy-and-divide-and-conquer Share my solutions - both greedy and divide and conquer greedy: 123456789101112class Solution &#123;public: int maxSubArray(int A[], int n) &#123; int sum = 0, min = 0, res = A[0]; for(int i = 0; i &lt; n; i++) &#123; sum += A[i]; if(sum - min &gt; res) res = sum - min; if(sum &lt; min) min = sum; &#125; return res; &#125;&#125;; The idea is to find the largest difference between the sums when you summing up the array from left to right. The largest difference corresponds to the sub-array with largest sum. I worked it out independently although It is very close to lucastan’s solution https://oj.leetcode.com/discuss/11288/simple-o-n-c-solution-no-dp-no-divide-and-conquer divide and conquer: 12345678910111213141516171819202122struct val &#123; int l, m, r, s; val(int l, int m, int r, int s):l(l), m(m), r(r), s(s)&#123;&#125;&#125;;class Solution &#123;public: val dac(int A[], int n) &#123; if(n == 1) return val(A[0], A[0], A[0], A[0]); val v1 = dac(A, n / 2), v2 = dac(A + n / 2, n - n / 2); int l, m, r, s; l = max(v1.l, v1.s + v2.l); m = max(v1.r + v2.l, max(v1.m, v2.m)); r = max(v2.r, v1.r + v2.s); s = v1.s + v2.s; return val(l, m, r, s); &#125; int maxSubArray(int A[], int n) &#123; val v = dac(A, n); return v.m; &#125;&#125;; the idea is: for each sub array we calculate 4 values in O(1) time based on the return values of its two halves. The meaning of the values: l: the sum of the sub array with largest sum starting from the first element m: the sum of the sub array with largest sum r: the sum of the sub array with largest sum ending at the last element s: the sum of the whole array the recursive relation is clear in the code. https://discuss.leetcode.com/topic/25396/c-an-clear-o-n-divide-and-conquer-solution-with-comments [C++] An clear O(n) divide and conquer solution with comments For each subarray, calculate four attributes: 1234mx (largest sum of this subarray), lmx(largest sum starting from the left most element), rmx(largest sum ending with the right most element), sum(the sum of the total subarray). The recurrence is: T(n) = 2T(n / 2) + O(1). So the running time of this algorithm is O(n). 123456789101112131415161718192021222324252627class Solution &#123;public: void maxSubArray(vector&lt;int&gt;&amp; nums, int l, int r, int&amp; mx, int&amp; lmx, int&amp; rmx, int&amp; sum) &#123; if (l == r) &#123; mx = lmx = rmx = sum = nums[l]; &#125; else &#123; int m = (l + r) / 2; int mx1, lmx1, rmx1, sum1; int mx2, lmx2, rmx2, sum2; maxSubArray(nums, l, m, mx1, lmx1, rmx1, sum1); maxSubArray(nums, m + 1, r, mx2, lmx2, rmx2, sum2); mx = max(max(mx1, mx2), rmx1 + lmx2); lmx = max(lmx1, sum1 + lmx2); rmx = max(rmx2, sum2 + rmx1); sum = sum1 + sum2; &#125; &#125; int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) &#123; return 0; &#125; int mx, lmx, rmx, sum; maxSubArray(nums, 0, nums.size() - 1, mx, lmx, rmx, sum); return mx; &#125;&#125;; https://discuss.leetcode.com/topic/426/how-to-solve-maximum-subarray-by-using-the-divide-and-conquer-approach How to solve “Maximum Subarray” by using the divide and conquer approach ? I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach. I cannot figure out how to do it with divide and conquer. You guys have ideas? https://discuss.leetcode.com/topic/426/how-to-solve-maximum-subarray-by-using-the-divide-and-conquer-approach/2 Step1. Select the middle element of the array. So the maximum subarray may contain that middle element or not. Step 2.1 If the maximum subarray does not contain the middle element, then we can apply the same algorithm to the the subarray to the left of the middle element and the subarray to the right of the middle element. Step 2.2 If the maximum subarray does contain the middle element, then the result will be simply the maximum suffix subarray of the left subarray plus the maximum prefix subarray of the right subarray Step 3 return the maximum of those three answer. Here is a sample code for divide and conquer solution. Please try to understand the algorithm before look at the code 1234567891011121314151617181920212223242526272829class Solution &#123;public: int maxSubArray(int A[], int n) &#123; // IMPORTANT: Please reset any member data you declared, as // the same Solution instance will be reused for each test case. if(n==0) return 0; return maxSubArrayHelperFunction(A,0,n-1); &#125; int maxSubArrayHelperFunction(int A[], int left, int right) &#123; if(right == left) return A[left]; int middle = (left+right)/2; int leftans = maxSubArrayHelperFunction(A, left, middle); int rightans = maxSubArrayHelperFunction(A, middle+1, right); int leftmax = A[middle]; int rightmax = A[middle+1]; int temp = 0; for(int i=middle;i&gt;=left;i--) &#123; temp += A[i]; if(temp &gt; leftmax) leftmax = temp; &#125; temp = 0; for(int i=middle+1;i&lt;=right;i++) &#123; temp += A[i]; if(temp &gt; rightmax) rightmax = temp; &#125; return max(max(leftans, rightans),leftmax+rightmax); &#125;&#125;; python https://leetcode.com/discuss/29296/a-python-solution 64ms, 49.06%, June.18th, 201612345678910111213class Solution(object): def maxSubArray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if not nums: return 0 cursum = maxsum = nums[0] for num in nums[1:]: cursum = max(num, num+cursum) maxsum = max(cursum, maxsum) return maxsum java https://discuss.leetcode.com/topic/6413/dp-solution-some-thoughts Analysis of this problem: Apparently, this is a optimization problem, which can be usually solved by DP. So when it comes to DP, the first thing for us to figure out is the format of the sub problem(or the state of each sub problem). The format of the sub problem can be helpful when we are trying to come up with the recursive relation. At first, I think the sub problem should look like: maxSubArray(int A[], int i, int j), which means the maxSubArray for A[i: j]. In this way, our goal is to figure out what maxSubArray(A, 0, A.length - 1) is. However, if we define the format of the sub problem in this way, it’s hard to find the connection from the sub problem to the original problem(at least for me). In other words, I can’t find a way to divided the original problem into the sub problems and use the solutions of the sub problems to somehow create the solution of the original one. So I change the format of the sub problem into something like: maxSubArray(int A[], int i), which means the maxSubArray for A[0:i ] which must has A[i] as the end element. Note that now the sub problem’s format is less flexible and less powerful than the previous one because there’s a limitation that A[i] should be contained in that sequence and we have to keep track of each solution of the sub problem to update the global optimal value. However, now the connect between the sub problem &amp; the original one becomes clearer: 1maxSubArray(A, i) = maxSubArray(A, i - 1) &gt; 0 ? maxSubArray(A, i - 1) : 0 + A[i]; And here’s the code 123456789101112131415public class Solution &#123; public int maxSubArray(int[] nums) &#123; int n = nums.length; int[] dp = new int[n]; dp[0] = nums[0]; int max = dp[0]; for(int i=1; i&lt;n; i++)&#123; dp[i] = nums[i] + (dp[i-1]&gt;0?dp[i-1]:0); max = Math.max(max, dp[i]); &#125; return max; &#125;&#125; https://leetcode.com/discuss/15805/accepted-o-n-solution-in-java 1ms, 69.50%, June.18th, 2016 Accepted O(n) solution in java this problem was discussed by Jon Bentley (Sep. 1984 Vol. 27 No. 9 Communications of the ACM P885) the paragraph below was copied from his paper (with a little modifications) algorithm that operates on arrays: it starts at the left end (element A[1]) and scans through to the right end (element A[n]), keeping track of the maximum sum subvector seen so far. The maximum is initially A[0]. Suppose we’ve solved the problem for A[1 .. i - 1]; how can we extend that to A[1 .. i]? The maximumsum in the first I elements is either the maximum sum in the first i - 1 elements (which we’ll call MaxSoFar), or it is that of a subvector that ends in position i (which we’ll call MaxEndingHere). MaxEndingHere is either A[i] plus the previous MaxEndingHere, or just A[i], whichever is larger. 12345678public static int maxSubArray(int[] A) &#123; int maxSoFar=A[0], maxEndingHere=A[0]; for (int i=1;i&lt;A.length;++i)&#123; maxEndingHere= Math.max(maxEndingHere+A[i],A[i]); maxSoFar=Math.max(maxSoFar, maxEndingHere); &#125; return maxSoFar;&#125; https://discuss.leetcode.com/topic/7447/o-n-java-solution O(n) Java solution The catch here is that we have to take care of negative value. The solution does 1 iteration with constant space and no DP. 1234567891011121314public class Solution &#123;public int maxSubArray(int[] A) &#123; int max = Integer.MIN_VALUE, sum = 0; for (int i = 0; i &lt; A.length; i++) &#123; if (sum &lt; 0) sum = A[i]; else sum += A[i]; if (sum &gt; max) max = sum; &#125; return max;&#125;&#125; https://discuss.leetcode.com/topic/27151/my-concise-o-n-dp-java-solution My concise O(n) DP JAVA Solution Explanation Although there’re some other simplified solutions, but DP solution can make the original thought for this problem clearer. In this solution, dp[i] means the largest sum among the subarrays whose last element is A[i]. Solution1. DP Solution - O(n) time, O(n) space 12345678public int maxSubArray(int[] A) &#123; int dp[] = new int[A.length]; int max = A[0]; dp[0] = A[0]; for (int i = 1; i &lt; A.length; i++) &#123; dp[i] = Math.max(dp[i-1] + A[i] ,A[i]); max = Math.max(max, dp[i]); &#125; return max;&#125; Solution2. Simplified DP Solution - O(n) time, O(1) space - Special thanks for TWiStErRob’s smart comment The basic idea is to check previous sum, reset it to 0 if it’s less than 0. 12345678public int maxSubArray(int[] A) &#123; int res = Integer.MIN_VALUE, sum = 0; for (int i = 0; i &lt; A.length; i++) &#123; sum = Math.max(sum, 0) + A[i]; res = Math.max(res, sum); &#125; return res;&#125; Solution3. Pre-Sum Array Solution - O(n) time, O(n) space The basic idea is to use pre-sum array, max = Math.max(max, sum[i] - minSum). (minSum is the minimum sum before A[i]) 123456789101112public int maxSubArray(int[] A) &#123; if (A == null || A.length == 0) return 0; int max = A[0], minSum = Integer.MAX_VALUE; int sum[] = new int[A.length]; sum[0] = A[0]; for (int i = 1; i &lt; A.length; i++) &#123; sum[i] = sum[i-1] + A[i]; minSum = Math.min(0, Math.min(minSum, sum[i-1])); max = Math.max(max, sum[i] - minSum); &#125; return max;&#125; https://discuss.leetcode.com/topic/42213/my-divide-and-conquer-solution-in-java-under-instruction-of-clrs-o-nlogn My Divide and Conquer Solution in Java under instruction of CLRS(O(nlogn)) 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123;//divdie and conquer public int maxSubArray(int[] nums) &#123; return Subarray(nums, 0 ,nums.length -1 ); &#125; public int Subarray(int[] A,int left, int right)&#123; if(left == right)&#123;return A[left];&#125; int mid = left + (right - left) / 2; int leftSum = Subarray(A,left,mid);// left part int rightSum = Subarray(A,mid+1,right);//right part int crossSum = crossSubarray(A,left,right);// cross part if(leftSum &gt;= rightSum &amp;&amp; leftSum &gt;= crossSum)&#123;// left part is max return leftSum; &#125; if(rightSum &gt;= leftSum &amp;&amp; rightSum &gt;= crossSum)&#123;// right part is max return rightSum; &#125; return crossSum; // cross part is max &#125; public int crossSubarray(int[] A,int left,int right)&#123; int leftSum = Integer.MIN_VALUE; int rightSum = Integer.MIN_VALUE; int sum = 0; int mid = left + (right - left) / 2; for(int i = mid; i &gt;= left ; i--)&#123; sum = sum + A[i]; if(leftSum &lt; sum)&#123; leftSum = sum; &#125; &#125; sum = 0; for(int j = mid + 1; j &lt;= right; j++)&#123; sum = sum + A[j]; if(rightSum &lt; sum)&#123; rightSum = sum; &#125; &#125; return leftSum + rightSum; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>divide and conquer</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[052. N-Queens II]]></title>
    <url>%2Fp%2F8e5f0d6d%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/n-queens-ii/ Follow up for N-Queens problem. Now, instead outputting board configurations, return the total number of distinct solutions. cpp https://discuss.leetcode.com/topic/19741/c-solution-dfs-easy-understanding C++ solution - DFS - easy understanding 1234567891011121314151617181920212223int totalNQueens(int n) &#123; vector&lt;bool&gt; col(n, true); vector&lt;bool&gt; anti(2*n-1, true); vector&lt;bool&gt; main(2*n-1, true); vector&lt;int&gt; row(n, 0); int count = 0; dfs(0, row, col, main, anti, count); return count;&#125;void dfs(int i, vector&lt;int&gt; &amp;row, vector&lt;bool&gt; &amp;col, vector&lt;bool&gt;&amp; main, vector&lt;bool&gt; &amp;anti, int &amp;count) &#123; if (i == row.size()) &#123; count++; return; &#125; for (int j = 0; j &lt; col.size(); j++) &#123; if (col[j] &amp;&amp; main[i+j] &amp;&amp; anti[i+col.size()-1-j]) &#123; row[i] = j; col[j] = main[i+j] = anti[i+col.size()-1-j] = false; dfs(i+1, row, col, main, anti, count); col[j] = main[i+j] = anti[i+col.size()-1-j] = true; &#125; &#125;&#125; https://discuss.leetcode.com/topic/19741/c-solution-dfs-easy-understanding/2 Nice job!I think row is useless, delete it is ok. 123456789101112131415161718192021222324252627282930class Solution &#123;public:int totalNQueens(int n) &#123; int count = 0; vector&lt;bool&gt; cols(n, true); vector&lt;bool&gt; main(2 * n - 1, true); vector&lt;bool&gt; anti(2 * n - 1, true); helper(0, count, cols, main, anti); return count;&#125;private:void helper(int s, int&amp; count, vector&lt;bool&gt;&amp; cols, vector&lt;bool&gt;&amp; main, vector&lt;bool&gt;&amp; anti)&#123; if (s == cols.size()) &#123; count++; return; &#125; for (int i = 0; i &lt; cols.size(); i++) &#123; if (cols[i] &amp;&amp; main[s + i] &amp;&amp; anti[s + cols.size() - 1 - i]) &#123; cols[i] = main[s + i] = anti[s + cols.size() - 1 - i] = false; helper(s + 1, count, cols, main, anti); cols[i] = main[s + i] = anti[s + cols.size() - 1 - i] = true; &#125; &#125;&#125;&#125;; And I want to share my 4ms Solution. The ideas are same but the diagonal conflict checking method diffes. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public:int totalNQueens(int n) &#123; int count = 0; vector&lt;bool&gt; mark(n); vector&lt;int&gt; cols(n, -1); for (int i = 0; i &lt; n; i++) &#123; cols[0] = i; mark[i] = true; helper(1, n, count, mark, cols); cols[0] = -1; mark[i] = false; &#125; return count;&#125;private:void helper(int s, int n, int&amp; count, vector&lt;bool&gt;&amp; mark, vector&lt;int&gt;&amp; cols)&#123; if (s == n) &#123; count++; return; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!mark[i]) &#123; bool mark2 = true; for (int k = 0; k &lt; s; k++) &#123; if (abs(s - k) == abs(i - cols[k])) &#123; mark2 = false; break; &#125; &#125; if (mark2) &#123; cols[s] = i; mark[i] = true; helper(s + 1, n, count, mark, cols); cols[s] = -1; mark[i] = false; &#125; &#125; &#125;&#125;&#125;; https://discuss.leetcode.com/topic/38923/share-my-java-code-beats-97-83-run-times Share my Java code (beats 97.83% run times) 1234567891011121314151617181920212223242526272829/* 常规n-queens解法, 数答案个数. 用column标记此行之前的哪些column已经放置了queen. 棋盘坐标(row, col)对应column的第col位(LSB --&gt; MSB, 下同). 用diag标记此位置之前的哪些主对角线已经放置了queen. 棋盘坐标(row, col)对应diag的第(n - 1 + row - col)位. 用antiDiag标记此位置之前的哪些副对角线已经放置了queen. 棋盘坐标(row, col)对应antiDiag的第(row + col)位.*/public class Solution &#123; int count = 0; public int totalNQueens(int n) &#123; dfs(0, n, 0, 0, 0); return count; &#125; private void dfs(int row, int n, int column, int diag, int antiDiag) &#123; if (row == n) &#123; ++count; return; &#125; for (int i = 0; i &lt; n; ++i) &#123; boolean isColSafe = ((1 &lt;&lt; i) &amp; column) == 0; boolean isDiagSafe = ((1 &lt;&lt; (n - 1 + row - i)) &amp; diag) == 0; boolean isAntiDiagSafe = ((1 &lt;&lt; (row + i)) &amp; antiDiag) == 0; if (isColSafe &amp;&amp; isDiagSafe &amp;&amp; isAntiDiagSafe) &#123; dfs(row + 1, n, (1 &lt;&lt; i) | column, (1 &lt;&lt; (n - 1 + row - i)) | diag, (1 &lt;&lt; (row + i)) | antiDiag); &#125; &#125; &#125;&#125; cpp https://discuss.leetcode.com/topic/15329/shortest-c-solution-in-0ms Shortest C++ solution in 0ms Idea is to use vectors to keep track of invalid positions , so validity can be checked in O(1) and put a queen in each column 12345678910111213141516171819202122#include&lt;vector&gt;using namespace std;class Solution &#123;public: int find(int n, int left, int i, int r, vector&lt;int&gt;&amp;rows,vector&lt;int&gt;&amp;d1,vector&lt;int&gt;&amp;d2)&#123; if (left == 0) return 1; int j,sum=0; for (j=r; j&lt;n; j++)&#123; if (rows[j] || d1[i+j] || d2[n-1+i-j]) continue; rows[j]=d1[i+j]=d2[n-1+i-j]=1; sum += find(n, left-1, i+1, 0,rows,d1,d2 ); rows[j]=d1[i+j]=d2[n-1+i-j]=0; &#125; return sum; &#125; int totalNQueens(int n) &#123; vector&lt;int&gt; rows(n),d1(2*n-1),d2(2*n-1); return find(n,n,0,0,rows,d1,d2); &#125;&#125;; https://discuss.leetcode.com/topic/11348/my-concise-dfs-c-solution-using-three-unordered_map-int-bool My concise DFS C++ solution using three unordered_map&lt;int, bool&gt;. 1234567891011121314151617181920212223242526class Solution &#123;public: unordered_map&lt;int, bool&gt; column, obliqueLeft, obliqueRight; int total; void NQueensHelper(int row, int n) &#123; if (row == n+1) &#123; total++; return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!column[i] &amp;&amp; !obliqueLeft[i + row] &amp;&amp; !obliqueRight[i - row]) &#123; column[i] = obliqueLeft[i + row] = obliqueRight[i - row] = true; NQueensHelper(row+1, n); column[i] = obliqueLeft[i + row] = obliqueRight[i - row] = false; &#125; &#125; &#125; int totalNQueens(int n) &#123; column.clear(); obliqueLeft.clear(); obliqueRight.clear(); total = 0; NQueensHelper(1, n); return total; &#125;&#125;; Each unordered_map represents whether column/left oblique line/right oblique line is occupied before. python https://discuss.leetcode.com/topic/22294/python-recursive-dfs-solution Python recursive dfs solution. The idea here is quite similar to N-Queens while we don’t need to record the path, and as the return value is a number not a list, it’s better to use a global variable to record the result. 12345678910111213141516171819def totalNQueens(self, n): self.res = 0 self.dfs([-1]*n, 0) return self.res def dfs(self, nums, index): if index == len(nums): self.res += 1 return for i in xrange(len(nums)): nums[index] = i if self.valid(nums, index): self.dfs(nums, index+1) def valid(self, nums, n): for i in xrange(n): if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i: return False return True 72ms, 85.33%, June.17th, 2016 1234567891011121314151617class Solution(object): def totalNQueens(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; def DFS(queens, xy_dif, xy_sum): p = len(queens) if p==n: result.append(queens) return None for q in range(n): if q not in queens and p-q not in xy_dif and p+q not in xy_sum: DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q]) result = [] DFS([],[],[]) return len(result) java https://discuss.leetcode.com/topic/5962/accepted-java-solution Accepted Java Solution 123456789101112131415161718192021222324252627282930313233343536373839404142/** * don&apos;t need to actually place the queen, * instead, for each row, try to place without violation on * col/ diagonal1/ diagnol2. * trick: to detect whether 2 positions sit on the same diagnol: * if delta(col, row) equals, same diagnol1; * if sum(col, row) equals, same diagnal2. */private final Set&lt;Integer&gt; occupiedCols = new HashSet&lt;Integer&gt;();private final Set&lt;Integer&gt; occupiedDiag1s = new HashSet&lt;Integer&gt;();private final Set&lt;Integer&gt; occupiedDiag2s = new HashSet&lt;Integer&gt;();public int totalNQueens(int n) &#123; return totalNQueensHelper(0, 0, n);&#125;private int totalNQueensHelper(int row, int count, int n) &#123; for (int col = 0; col &lt; n; col++) &#123; if (occupiedCols.contains(col)) continue; int diag1 = row - col; if (occupiedDiag1s.contains(diag1)) continue; int diag2 = row + col; if (occupiedDiag2s.contains(diag2)) continue; // we can now place a queen here if (row == n-1) count++; else &#123; occupiedCols.add(col); occupiedDiag1s.add(diag1); occupiedDiag2s.add(diag2); count = totalNQueensHelper(row+1, count, n); // recover occupiedCols.remove(col); occupiedDiag1s.remove(diag1); occupiedDiag2s.remove(diag2); &#125; &#125; return count;&#125; https://discuss.leetcode.com/topic/29626/easiest-java-solution-1ms-98-22 Easiest Java Solution (1ms, 98.22%) This is a classic backtracking problem. Start row by row, and loop through columns. At each decision point, skip unsafe positions by using three boolean arrays. Start going back when we reach row n. Just FYI, if using HashSet, running time will be at least 3 times slower! 123456789101112131415161718192021222324public class Solution &#123; int count = 0; public int totalNQueens(int n) &#123; boolean[] cols = new boolean[n]; // columns | boolean[] d1 = new boolean[2 * n]; // diagonals \ boolean[] d2 = new boolean[2 * n]; // diagonals / backtracking(0, cols, d1, d2, n); return count; &#125; public void backtracking(int row, boolean[] cols, boolean[] d1, boolean []d2, int n) &#123; if(row == n) count++; for(int col = 0; col &lt; n; col++) &#123; int id1 = col - row + n; int id2 = col + row; if(cols[col] || d1[id1] || d2[id2]) continue; cols[col] = true; d1[id1] = true; d2[id2] = true; backtracking(row + 1, cols, d1, d2, n); cols[col] = false; d1[id1] = false; d2[id2] = false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[051. N-Queens]]></title>
    <url>%2Fp%2Faa0d9b9e%2F</url>
    <content type="text"><![CDATA[31.1% https://leetcode.com/problems/n-queens/ The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively. 1234567891011121314For example,There exist two distinct solutions to the 4-queens puzzle:[ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] https://discuss.leetcode.com/topic/1154/the-description-should-give-a-clear-explanation-of-the-problem-of-n-queens The description should give a clear explanation of the problem of “n-queens” queens can attack other queen in the same row, same column, but i forget the diagonal.. = 。= 方法一： https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand Accepted 4ms c++ solution use backtracking and bitmask, easy understand. In this problem, we can go row by row, and in each position, we need to check if the column, the 45° diagonal and the 135° diagonal had a queen before. Solution A: Directly check the validity of each position, 12ms: 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: std::vector&lt;std::vector&lt;std::string&gt; &gt; solveNQueens(int n) &#123; std::vector&lt;std::vector&lt;std::string&gt; &gt; res; std::vector&lt;std::string&gt; nQueens(n, std::string(n, &apos;.&apos;)); solveNQueens(res, nQueens, 0, n); return res; &#125;private: void solveNQueens(std::vector&lt;std::vector&lt;std::string&gt; &gt; &amp;res, std::vector&lt;std::string&gt; &amp;nQueens, int row, int &amp;n) &#123; if (row == n) &#123; res.push_back(nQueens); return; &#125; for (int col = 0; col != n; ++col) if (isValid(nQueens, row, col, n)) &#123; nQueens[row][col] = &apos;Q&apos;; solveNQueens(res, nQueens, row + 1, n); nQueens[row][col] = &apos;.&apos;; &#125; &#125; bool isValid(std::vector&lt;std::string&gt; &amp;nQueens, int row, int col, int &amp;n) &#123; //check if the column had a queen before. for (int i = 0; i != row; ++i) if (nQueens[i][col] == &apos;Q&apos;) return false; //check if the 45° diagonal had a queen before. for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) if (nQueens[i][j] == &apos;Q&apos;) return false; //check if the 135° diagonal had a queen before. for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j) if (nQueens[i][j] == &apos;Q&apos;) return false; return true; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; queens(n, string(n, '.')); helper(res, queens, 0, n); return res; &#125; void helper(vector&lt;vector&lt;string&gt;&gt;&amp; res, vector&lt;string&gt;&amp; queens, int row, int n)&#123; if(row==n)&#123; res.push_back(queens); return; &#125; for(int col=0; col&lt;n; col++)&#123; if(isvalid(queens, row, col, n))&#123; queens[row][col] = 'Q'; helper(res, queens, row+1, n); queens[row][col] = '.'; &#125; &#125; &#125; bool isvalid(vector&lt;string&gt;&amp; queens, int row, int col, int n)&#123; for(int i=0; i&lt;row; i++) if(queens[i][col]=='Q') return false; for(int i=row-1, j=col-1; i&gt;=0 &amp;&amp; j&gt;=0; i--, j--) if(queens[i][j]=='Q') return false; for(int i=row-1, j=col+1; i&gt;=0 &amp;&amp; j&lt;n; i--, j++) if(queens[i][j]=='Q') return false; return true; &#125;&#125;; Solution B: Use flag vectors as bitmask, 4ms: The number of columns is n, the number of 45° diagonals is 2 n - 1, the number of 135° diagonals is also 2 n - 1. When reach [row, col], the column No. is col, the 45° diagonal No. is row + col and the 135° diagonal No. is n - 1 + col - row. We can use three arrays to indicate if the column or the diagonal had a queen before, if not, we can put a queen in this position and continue. 12345678910111213141516171819202122232425262728293031323334/** | | | / / / \ \ \ * O O O O O O O O O * | | | / / / / \ \ \ \ * O O O O O O O O O * | | | / / / / \ \ \ \ * O O O O O O O O O * | | | / / / \ \ \ * 3 columns 5 45° diagonals 5 135° diagonals (when n is 3) */class Solution &#123;public: std::vector&lt;std::vector&lt;std::string&gt; &gt; solveNQueens(int n) &#123; std::vector&lt;std::vector&lt;std::string&gt; &gt; res; std::vector&lt;std::string&gt; nQueens(n, std::string(n, &apos;.&apos;)); std::vector&lt;int&gt; flag_col(n, 1), flag_45(2 * n - 1, 1), flag_135(2 * n - 1, 1); solveNQueens(res, nQueens, flag_col, flag_45, flag_135, 0, n); return res; &#125;private: void solveNQueens(std::vector&lt;std::vector&lt;std::string&gt; &gt; &amp;res, std::vector&lt;std::string&gt; &amp;nQueens, std::vector&lt;int&gt; &amp;flag_col, std::vector&lt;int&gt; &amp;flag_45, std::vector&lt;int&gt; &amp;flag_135, int row, int &amp;n) &#123; if (row == n) &#123; res.push_back(nQueens); return; &#125; for (int col = 0; col != n; ++col) if (flag_col[col] &amp;&amp; flag_45[row + col] &amp;&amp; flag_135[n - 1 + col - row]) &#123; flag_col[col] = flag_45[row + col] = flag_135[n - 1 + col - row] = 0; nQueens[row][col] = &apos;Q&apos;; solveNQueens(res, nQueens, flag_col, flag_45, flag_135, row + 1, n); nQueens[row][col] = &apos;.&apos;; flag_col[col] = flag_45[row + col] = flag_135[n - 1 + col - row] = 1; &#125; &#125;&#125;; But we actually do not need to use three arrays, we just need one. Now, when reach [row, col], the subscript of column is col, the subscript of 45° diagonal is n + row + col and the subscript of 135° diagonal is n + 2 * n - 1 + n - 1 + col - row. 123456789101112131415161718192021222324252627282930class Solution &#123;public: std::vector&lt;std::vector&lt;std::string&gt; &gt; solveNQueens(int n) &#123; std::vector&lt;std::vector&lt;std::string&gt; &gt; res; std::vector&lt;std::string&gt; nQueens(n, std::string(n, &apos;.&apos;)); /* flag[0] to flag[n - 1] to indicate if the column had a queen before. flag[n] to flag[3 * n - 2] to indicate if the 45° diagonal had a queen before. flag[3 * n - 1] to flag[5 * n - 3] to indicate if the 135° diagonal had a queen before. */ std::vector&lt;int&gt; flag(5 * n - 2, 1); solveNQueens(res, nQueens, flag, 0, n); return res; &#125;private: void solveNQueens(std::vector&lt;std::vector&lt;std::string&gt; &gt; &amp;res, std::vector&lt;std::string&gt; &amp;nQueens, std::vector&lt;int&gt; &amp;flag, int row, int &amp;n) &#123; if (row == n) &#123; res.push_back(nQueens); return; &#125; for (int col = 0; col != n; ++col) if (flag[col] &amp;&amp; flag[n + row + col] &amp;&amp; flag[4 * n - 2 + col - row]) &#123; flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 0; nQueens[row][col] = &apos;Q&apos;; solveNQueens(res, nQueens, flag, row + 1, n); nQueens[row][col] = &apos;.&apos;; flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 1; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/4007/accepted-auxillary-space-o-n-using-dfs-cpp Accepted : auxillary space O(n) , using dfs , cpp Space complexity : Instead of using a 2D array to represent the chess board, i am using a 1D array , the index of which would represent the row number and the value of arr at row index will be the column number for the correct position of the queen. i.e 12Instead of doing arr[row][col]=1i am using arr[row]=col ; where queen is positioned at (row,col); Logic : DFS for every column number ,ranging from 0 to n-1, for all the rows from 0 to n-1 and check the validity of queen position for every row,col combination(using isSafe function) isSafe function : It checks whether the queen in current position(r,c) is being attacked by any of the r-1 queens positioned in row numbers 0 through r-1. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; public: vector &lt; vector &lt;string&gt; &gt; sol; int limit; vector&lt;string&gt; toChessString(vector&lt;int&gt; arr) &#123; string s(arr.size(),&apos;.&apos;); vector&lt;string&gt; ans(arr.size(),s); for(int i=0 ; i&lt;arr.size() ; i++) ans[i][arr[i]]=&apos;Q&apos;; return ans; &#125; bool isSafe(vector&lt;int&gt; arr, int r , int c ) &#123; int check; for(int row=r-1,ldia=c-1,rdia=c+1 ; row&gt;=0 ; row--,ldia--,rdia++) &#123; check=arr[row]; if(check==c || check==ldia || check==rdia) return false; &#125; return true; &#125; void solveNqueen(vector&lt;int&gt; arr , int r , int c) &#123; if(r==limit) sol.push_back(toChessString(arr)); else &#123; for(int col=c ; col&lt;limit ; col++) &#123; arr[r]=col; if(isSafe(arr,r,col)) solveNqueen(arr,r+1,0); &#125; &#125; &#125; vector&lt;vector&lt;string&gt; &gt; solveNQueens(int n) &#123; vector&lt;int&gt; arr(n,0); limit=n; solveNqueen(arr,0,0); return sol; &#125; &#125;; https://discuss.leetcode.com/topic/7644/c-6ms-solution-use-bitmask C++ 6ms solution use bitmask 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; int n; string getNq(int p) &#123; string s(n, &apos;.&apos;); s[p] = &apos;Q&apos;; return s; &#125; void nQueens(int p, int l, int m, int r, vector&lt;vector&lt;string&gt;&gt; &amp;res) &#123; static vector&lt;string&gt; ans; if (p &gt;= n) &#123; res.push_back(ans); return ; &#125; int mask = l | m | r; for (int i = 0, b = 1; i &lt; n; ++ i, b &lt;&lt;= 1) if (!(mask &amp; b)) &#123; ans.push_back(getNq(i)); nQueens(p + 1, (l | b) &gt;&gt; 1, m | b, (r | b) &lt;&lt; 1, res); ans.pop_back(); &#125; &#125;public: vector&lt;vector&lt;string&gt; &gt; solveNQueens(int n) &#123; this-&gt;n = n; vector&lt;vector&lt;string&gt;&gt; res; nQueens(0, 0, 0, 0, res); return res; &#125;&#125;; python 108ms, 77.32%, June.16th, 2016 https://leetcode.com/discuss/49179/fast-short-and-easy-understand-python-solution-11-lines-76ms Fast, short, and easy-to-understand python solution, 11 lines, 76ms ideas: Use the DFS helper function to find solutions recursively. A solution will be found when the length of queens is equal to n ( queens is a list of the indices of the queens). In this problem, whenever a location (x, y) is occupied, any other locations (p, q ) where p + q == x + y or p - q == x - y would be invalid. We can use this information to keep track of the indicators (xy_dif and xy_sum ) of the invalid positions and then call DFS recursively with valid positions only. At the end, we convert the result (a list of lists; each sublist is the indices of the queens) into the desire format. 123456789101112def solveNQueens(self, n): def DFS(queens, xy_dif, xy_sum): p = len(queens) if p==n: result.append(queens) return None for q in range(n): if q not in queens and p-q not in xy_dif and p+q not in xy_sum: DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q]) result = [] DFS([],[],[]) return [ [&quot;.&quot;*i + &quot;Q&quot; + &quot;.&quot;*(n-i-1) for i in sol] for sol in result] https://discuss.leetcode.com/topic/9445/14-lines-python-code-dfs-solution 14 lines python code, DFS solution 1234567891011121314class Solution:# @return a list of lists of stringdef solveNQueens(self, n): stack, res = [[(0, i)] for i in range(n)], [] while stack: board = stack.pop() row = len(board) if row == n: res.append([&apos;&apos;.join(&apos;Q&apos; if i == c else &apos;.&apos; for i in range(n)) for r, c in board]) for col in range(n): if all(col != c and abs(row-r) != abs(col-c)for r, c in board): stack.append(board+[(row, col)]) return res https://discuss.leetcode.com/topic/22293/python-recursive-dfs-solution-with-comments Python recursive dfs solution with comments 123456789101112131415161718192021222324def solveNQueens(self, n): res = [] self.dfs([-1]*n, 0, [], res) return res # nums is a one-dimension array, like [1, 3, 0, 2] means# first queen is placed in column 1, second queen is placed# in column 3, etc.def dfs(self, nums, index, path, res): if index == len(nums): res.append(path) return # backtracking for i in xrange(len(nums)): nums[index] = i if self.valid(nums, index): # pruning tmp = &quot;.&quot;*len(nums) self.dfs(nums, index+1, path+[tmp[:i]+&quot;Q&quot;+tmp[i+1:]], res)# check whether nth queen can be placed in that columndef valid(self, nums, n): for i in xrange(n): if abs(nums[i]-nums[n]) == n -i or nums[i] == nums[n]: return False return True java https://discuss.leetcode.com/topic/8592/comparably-concise-java-code Comparably concise Java code Hi guys! I didn’t invent a wheel here. We just remember the busy columns and diagonals and recursively try to put the queen into the next row. But I think the code below is short enough to be reproduced in the interview. Hope it helps! 123456789101112131415161718192021222324252627public class Solution &#123; private void helper(int r, boolean[] cols, boolean[] d1, boolean[] d2, String[] board, List&lt;String[]&gt; res) &#123; if (r == board.length) res.add(board.clone()); else &#123; for (int c = 0; c &lt; board.length; c++) &#123; int id1 = r - c + board.length, id2 = 2*board.length - r - c - 1; if (!cols[c] &amp;&amp; !d1[id1] &amp;&amp; !d2[id2]) &#123; char[] row = new char[board.length]; Arrays.fill(row, &apos;.&apos;); row[c] = &apos;Q&apos;; board[r] = new String(row); cols[c] = true; d1[id1] = true; d2[id2] = true; helper(r+1, cols, d1, d2, board, res); cols[c] = false; d1[id1] = false; d2[id2] = false; &#125; &#125; &#125; &#125; public List&lt;String[]&gt; solveNQueens(int n) &#123; List&lt;String[]&gt; res = new ArrayList&lt;&gt;(); helper(0, new boolean[n], new boolean[2*n], new boolean[2*n], new String[n], res); return res; &#125;&#125; https://discuss.leetcode.com/topic/19470/my-easy-understanding-java-solution My easy understanding Java Solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; char[][] board = new char[n][n]; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) board[i][j] = &apos;.&apos;; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); dfs(board, 0, res); return res; &#125; private void dfs(char[][] board, int colIndex, List&lt;List&lt;String&gt;&gt; res) &#123; if(colIndex == board.length) &#123; res.add(construct(board)); return; &#125; for(int i = 0; i &lt; board.length; i++) &#123; if(validate(board, i, colIndex)) &#123; board[i][colIndex] = &apos;Q&apos;; dfs(board, colIndex + 1, res); board[i][colIndex] = &apos;.&apos;; &#125; &#125; &#125; private boolean validate(char[][] board, int x, int y) &#123; for(int i = 0; i &lt; board.length; i++) &#123; for(int j = 0; j &lt; y; j++) &#123; if(board[i][j] == &apos;Q&apos; &amp;&amp; (x + j == y + i || x + y == i + j || x == i)) return false; &#125; &#125; return true; &#125; private List&lt;String&gt; construct(char[][] board) &#123; List&lt;String&gt; res = new LinkedList&lt;String&gt;(); for(int i = 0; i &lt; board.length; i++) &#123; String s = new String(board[i]); res.add(s); &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/24329/share-my-java-dfs-solution-very-easy-to-understand Share my JAVA DFS solution very easy to understand 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; private Set&lt;Integer&gt; col = new HashSet&lt;Integer&gt;(); private Set&lt;Integer&gt; diag1 = new HashSet&lt;Integer&gt;(); private Set&lt;Integer&gt; diag2 = new HashSet&lt;Integer&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); dfs(res,new ArrayList&lt;String&gt;(), 0, n); return res; &#125; private void dfs(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; list, int row, int n)&#123; if (row == n)&#123; res.add(new ArrayList&lt;String&gt;(list)); return; &#125; for (int i = 0; i &lt; n; i++)&#123; if (col.contains(i) || diag1.contains(row + i) || diag2.contains(row - i)) continue; char[] charArray = new char[n]; Arrays.fill(charArray, &apos;.&apos;); charArray[i] = &apos;Q&apos;; String rowString = new String(charArray); list.add(rowString); col.add(i); diag1.add(row + i); diag2.add(row - i); dfs(res, list, row + 1, n); list.remove(list.size() - 1); col.remove(i); diag1.remove(row + i); diag2.remove(row - i); &#125; &#125;&#125; https://discuss.leetcode.com/topic/40881/93-concise-fast-and-clear-java-solution 93% concise, fast, and clear java solution The code has comment. 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; boolean[] //ocp0 = new boolean[n], //whether there&apos;s a queen ocupying nth row, I don&apos;t need it ocp90 = new boolean[n], //whether there&apos;s a queen ocupying nth column ocp45 = new boolean[2 * n - 1], // mark 45 degree occupation ocp135 = new boolean[2 * n - 1]; // mark 135 degree occupation List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;List&lt;String&gt;&gt;(); char[][] map = new char[n][n]; for (char[] tmp : map) Arrays.fill(tmp, &apos;.&apos;); //init solve(0, n, map, ans, ocp45, ocp90, ocp135); return ans; &#125; private void solve(int depth, int n, char[][] map, List&lt;List&lt;String&gt;&gt; ans, boolean[] ocp45, boolean[] ocp90, boolean[] ocp135) &#123; if (depth == n) &#123; addSolution(ans, map); return; &#125; for (int j = 0; j &lt; n; j++) if (!ocp90[j] &amp;&amp; !ocp45[depth + j] &amp;&amp; !ocp135[j - depth + n - 1]) &#123; ocp90[j] = true; ocp45[depth + j] = true; ocp135[j - depth + n - 1] = true; map[depth][j] = &apos;Q&apos;; solve(depth + 1, n, map, ans, ocp45, ocp90, ocp135); ocp90[j] = false; ocp45[depth + j] = false; ocp135[j - depth + n - 1] = false; map[depth][j] = &apos;.&apos;; &#125; &#125; private void addSolution(List&lt;List&lt;String&gt;&gt; ans, char[][] map) &#123; List&lt;String&gt; cur = new ArrayList&lt;String&gt;(); for (char[] i : map) cur.add(String.valueOf(i)); ans.add(cur); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[050. Pow(x, n)]]></title>
    <url>%2Fp%2Ff4cb4bf8%2F</url>
    <content type="text"><![CDATA[26.3% https://leetcode.com/problems/powx-n/ Implement pow(x, n). 解法如下： https://discuss.leetcode.com/topic/21837/5-different-choices-when-talk-with-interviewers After reading some good sharing solutions, I’d like to show them together. You can see different ideas in the code. nest myPow 1234567double myPow(double x, int n) &#123; if(n&lt;0) return 1/x * myPow(1/x, -(n+1)); if(n==0) return 1; if(n==2) return x*x; if(n%2==0) return myPow( myPow(x, n/2), 2); else return x*myPow( myPow(x, n/2), 2);&#125; double myPow 123456double myPow(double x, int n) &#123; if(n==0) return 1; double t = myPow(x,n/2); if(n%2) return n&lt;0 ? 1/x*t*t : x*t*t; else return t*t;&#125; double x 12345678double myPow(double x, int n) &#123; if(n==0) return 1; if(n&lt;0)&#123; n = -n; x = 1/x; &#125; return n%2==0 ? myPow(x*x, n/2) : x*myPow(x*x, n/2);&#125; iterative one 1234567891011121314double myPow(double x, int n) &#123; if(n==0) return 1; if(n&lt;0) &#123; n = -n; x = 1/x; &#125; double ans = 1; while(n&gt;0)&#123; if(n&amp;1) ans *= x; x *= x; n &gt;&gt;= 1; &#125; return ans;&#125; bit operation https://discuss.leetcode.com/topic/3636/my-answer-using-bit-operation-c-implementation In bit format and for a unsigned number, the number is represented as k02^0 + k12^1 + … +k31 2 ^31. Therefore, once we know the pow(x,2^0), pow(x,2^1), …, pow(x,2^31), we can get pow(x,n). And pow(x,2 ^ m) can be constructed easily as pow(x,2^m) = pow(x,2^(m-1)) pow(x,2^(m-1)). 123456789101112131415161718192021class Solution &#123;public: double pow(double x, int n) &#123; if(n&lt;0)&#123; x = 1.0/x; n = -n; &#125; int unsigned m = n; double tbl[32] = &#123;0&#125;; double result = 1; tbl[0] = x; for(int i=1;i&lt;32;i++)&#123; tbl[i] = tbl[i-1]*tbl[i-1]; &#125; for(int i=0;i&lt;32;i++)&#123; if( m &amp; (0x1&lt;&lt;i) ) result *= tbl[i]; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/17832/non-recursive-c-log-n-solution 1234567891011121314151617181920class Solution &#123;public: double myPow(double x, int n) &#123; double ans = 1; unsigned long long p; if (n &lt; 0) &#123; p = -n; x = 1 / x; &#125; else &#123; p = n; &#125; while (p) &#123; if (p &amp; 1) ans *= x; x *= x; p &gt;&gt;= 1; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/10572/8-lines-of-c-7-ms 123456789double pow(double x, int n) &#123; if (n==0) return 1; double t = pow(x,n/2); if (n%2) &#123; return n&lt;0 ? 1/x*t*t : x*t*t; &#125; else &#123; return t*t; &#125;&#125; python https://discuss.leetcode.com/topic/15630/shortest-python-guaranteed Surprisingly, I can just use Python’s existing pow like this: 12class Solution: myPow = pow That’s even shorter than the other more obvious “cheat”: 123class Solution: def myPow(self, x, n): return x ** n And to calm down the haters, here’s me “doing it myself”: Recursive: 123456789class Solution: def myPow(self, x, n): if not n: return 1 if n &lt; 0: return 1 / self.myPow(x, -n) if n % 2: return x * self.myPow(x, n-1) return self.myPow(x*x, n/2) Iterative: 123456789101112class Solution: def myPow(self, x, n): if n &lt; 0: x = 1 / x n = -n pow = 1 while n: if n &amp; 1: pow *= x x *= x n &gt;&gt;= 1 return pow java https://discuss.leetcode.com/topic/5425/short-and-easy-to-understand-solution 1234567891011public class Solution &#123; public double pow(double x, int n) &#123; if(n == 0) return 1; if(n&lt;0)&#123; n = -n; x = 1/x; &#125; return (n%2 == 0) ? pow(x*x, n/2) : x*pow(x*x, n/2); &#125;&#125; https://discuss.leetcode.com/topic/2836/o-logn-solution-in-java /* This is a simple solution based on divide and conquer */ 1234567891011121314151617public class Solution &#123; public double pow(double x, int m) &#123; double temp=x; if(m==0) return 1; temp=pow(x,m/2); if(m%2==0) return temp*temp; else &#123; if(m &gt; 0) return x*temp*temp; else return (temp*temp)/x; &#125; &#125; https://discuss.leetcode.com/topic/40546/iterative-log-n-solution-with-clear-explanation I couldn’t find a clear explanation for an interative Log(n) solution so here’s mine. The basic idea is to decompose the exponent into powers of 2, so that you can keep dividing the problem in half. For example, lets say N = 9 = 2^3 + 2^0 = 1001 in binary. Then: x^9 = x ^ (2 ^ 3) * x ^ (2 ^ 0) We can see that every time we encounter a 1 in the binary representation of N, we need to multiply the answer with x^(2^i) where i is the ith bit of the exponent. Thus, we can keep a running total of repeatedly squaring x - (x, x^2, x^4, x^8, etc) and multiply it by the answer when we see a 1. To handle the case where N=INTEGER_MIN we use a long (64-bit) variable. Below is solution: 123456789101112public class Solution &#123; public double MyPow(double x, int n) &#123; double ans = 1; long absN = Math.Abs((long)n); while(absN &gt; 0) &#123; if((absN&amp;1)==1) ans *= x; absN &gt;&gt;= 1; x *= x; &#125; return n &lt; 0 ? 1/ans : ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>math</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[049. Group Anagrams]]></title>
    <url>%2Fp%2F6810cb45%2F</url>
    <content type="text"><![CDATA[35.2% https://leetcode.com/problems/group-anagrams/description/ Given an array of strings, group anagrams together. 12345678For example, given: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;], Return:[ [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lower-case. 方法一： 排序号的str作为key，相应的队伍作为value的vector，然后map迭代器把这些都合并就可以了。 我的代码实现： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; vector&lt;vector&lt;string&gt;&gt; res; // 用vector&lt;string&gt; 而不是vector&lt;string&gt;() // 使用排序好string作为key unordered_map&lt;string, vector&lt;string&gt;&gt; map; for(auto str: strs)&#123; string key = helper(str); // 不管有没有key，都push_back map[key].push_back(str); &#125; // 学习map的迭代器的使用 for(auto it=map.begin(); it!=map.end(); it++)&#123; res.push_back(it-&gt;second); &#125; return res; &#125; string helper(string s)&#123; if(s.empty()) return s; int n = s.size(); vector&lt;int&gt; cnt(26, 0); for(int i=0; i&lt;n; i++) cnt[s[i]-'a']++; string t(n, 'a'); int p = 0; for(int i=0; i&lt;26; i++)&#123; for(int j=0; j&lt;cnt[i]; j++)&#123; t[p++] += i; &#125; &#125; return t; &#125;&#125;; https://discuss.leetcode.com/topic/307/what-does-it-mean-return-all-groups-but-the-return-result-is-vector-string-how-can-we-return-all-groups What does it mean “return all groups”? But the return result is vector? How can we return all groups? What does it mean “return all groups”? But the return result is vector? How can we return all groups? I mean, for example, we have such vector [“dog”,”cat”,”god”,”tac”]. What should I return? https://discuss.leetcode.com/topic/307/what-does-it-mean-return-all-groups-but-the-return-result-is-vector-string-how-can-we-return-all-groups/2 1337c0d3rReputation: 1,607UPDATE: The return type had been changed to a list of list to avoid confusion. An example would be [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”], return: 12345[ [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note that even a single word is included as a group containing a single element. And here is the original old post: It means return all group of anagrams being flatten into one single list. For the input [“dog”,”cat”,”god”,”tac”], it should return: [“dog”,”cat”,”god”,”tac”], as dog and god are one group of anagrams, and cat and tac are another group of anagrams. I will probably change the return format to a more intuitive manner sometime in the future, such as: 1234[ [&quot;dog&quot;, &quot;god&quot;], [&quot;cat&quot;, &quot;tac&quot;]] Until this change happens, you will have to deal with the slightly confusing way of returning a flatten list, which should not affect the algorithm itself. https://discuss.leetcode.com/topic/8269/why-not-list-of-list-of-strings-as-output Why not list of list of strings as output? Why the output is list and not a list of list. What If there are multiple groups of anagrams? cpp 68ms, 79.37%, September 21, 2016 https://discuss.leetcode.com/topic/21038/10-lines-76ms-easy-c-solution-updated-function-signature 10-lines 76ms Easy C++ Solution (Updated Function Signature) The function signature has been updated to return a more intuitive vector&lt;vector&gt; which treats a single string as a group of anagrams consisting of only itself. The idea is to use an unordered_map to store those strings that are anagrams. We use the sorted string as the key and the string itself as the value. The strings are stored in a multiset since there may be duplicates. Moreover, multiset will sort them by default as we desire. The code is as follows. 1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, multiset&lt;string&gt;&gt; mp; for (string s : strs) &#123; string t = s; sort(t.begin(), t.end()); mp[t].insert(s); &#125; vector&lt;vector&lt;string&gt;&gt; anagrams; for (auto m : mp) &#123; vector&lt;string&gt; anagram(m.second.begin(), m.second.end()); anagrams.push_back(anagram); &#125; return anagrams; &#125;&#125;; Update: as suggested by yswu1234 in the answer, general sort takes O(nlogn) time. In this problem, since the string only contains lower-case alphabets, we can write a sorting function using counting sort (O(n) time) to speed up the sorting process. I write a string sorting function strSort below and using it to sort the string achieves the overall running time 72ms for this problem. 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, multiset&lt;string&gt;&gt; mp; for (string s : strs) &#123; string t = strSort(s); mp[t].insert(s); &#125; vector&lt;vector&lt;string&gt;&gt; anagrams; for (auto m : mp) &#123; vector&lt;string&gt; anagram(m.second.begin(), m.second.end()); anagrams.push_back(anagram); &#125; return anagrams; &#125;private: string strSort(string&amp; s) &#123; int count[26] = &#123;0&#125;, n = s.length(); for (int i = 0; i &lt; n; i++) count[s[i] - &apos;a&apos;]++; int p = 0; string t(n, &apos;a&apos;); for (int j = 0; j &lt; 26; j++) for (int i = 0; i &lt; count[j]; i++) t[p++] += j; return t; &#125; &#125;; https://discuss.leetcode.com/topic/6053/sharing-my-very-concise-solution-with-explanation Sharing my very concise solution with explanation 1234567891011121314151617vector&lt;string&gt; anagrams(vector&lt;string&gt; &amp;strs) &#123; vector&lt;string&gt; result; vector&lt;string&gt; sortedStrs = strs; unordered_map&lt;string, vector&lt;int&gt;&gt; map; for(int i = 0; i &lt; strs.size(); i++)&#123; sort(sortedStrs[i].begin(), sortedStrs[i].end()); map[sortedStrs[i]].push_back(i); &#125; for(auto it = map.begin(); it != map.end(); it++)&#123; if(it-&gt;second.size() &gt; 1)&#123; for(int i = 0; i &lt; it-&gt;second.size(); i++)&#123; result.push_back(strs[it-&gt;second[i]]); &#125; &#125; &#125; return result;&#125; Here is basic idea for this problem. First, get a copy of “strs”. Let’s name this copy “sortedStrs”. Second, sort all strings in “sortedStrs”. And we have a hash map unordered_map&lt;string, vector&gt; map. Every string in “sortedStrs” will be recorded in this hash map with its position. In the second loop, we traverse this hash map. And find each value of which size is larger than 1. Then find the original string in “strs”. Done. https://discuss.leetcode.com/topic/26074/a-clean-c-solution-with-unordered_map A clean c++ solution with unordered_map vector&lt;vector&gt; groupAnagrams(vector&amp; strs) { 1234567891011121314unordered_map&lt;string, vector&lt;string&gt;&gt; count; int i = 0; for (auto s : strs) &#123; sort(s.begin(), s.end()); count[s].push_back(strs[i++]); &#125; vector&lt;vector&lt;string&gt;&gt; res; for (auto n : count)&#123; sort(n.second.begin(), n.second.end()); res.push_back(n.second); &#125; return res;&#125; python https://discuss.leetcode.com/topic/3297/2-line-python-solution-ac-with-350ms-some-useful-python-tricks 2-line Python solution, AC with 350ms (some useful Python tricks) 123def anagrams(self, strs): count = collections.Counter([tuple(sorted(s)) for s in strs]) return filter(lambda x: count[tuple(sorted(x))]&gt;1, strs) collections.Counter creates a counter object. A counter object is like a specific kind of dictionary where it is build for counting (objects that hashes to same value) tuple(sorted(s)) is used here so that anagrams will be hashed to the same value. tuple is used because sorted returns a list which cannot be hashed but tuples can be hashed filter: selects some elements of the list based on given function (first argument - a lambda function is given here) lambda function defined here returns True if number of anagrams of that elements is greater than 1 https://discuss.leetcode.com/topic/3297/2-line-python-solution-ac-with-350ms-some-useful-python-tricks/2 Here is another python solution which is 4-line but a little more concise and faster (~ 20ms faster) 12345def anagrams(self, strs): d = collections.defaultdict(list) for s in strs: d[tuple(sorted(s))].append(s) return [a for agram_group in d.values() if len(agram_group)&gt;1 for a in agram_group] collection.defaultdict is used instead of Counter. It is almost same as dict but you can set default value (the value when item is not found in the dictionary) list comprehension is used in the return statement in order to select anagrams which have more than 1 word and also to flatten the d.values() which is list of lists https://discuss.leetcode.com/topic/21052/1-line-ruby-python-for-updated-problem 1 line Ruby/Python for Updated Problem The problem just got updated, now asking for different results. Here are some solutions for the new version. All of them use the sorted string as the group identifier, so for example the words “leetcoder” and “electrode” both have the group identifier “cdeeelort” (or rather an array version of it), which is how I know that they’re anagrams of each other. Python solution 1 Sort and group by group identifier, then sort each group normally. 12def groupAnagrams(self, strs): return [sorted(g) for _, g in itertools.groupby(sorted(strs, key=sorted), sorted)] Or “breaking it down” to maybe make it more readable for beginners and because I just noticed that in Firefox it violates my self-imposed “no scrollbars” rule (I usually use Chrome and didn’t think it differed): 123def groupAnagrams(self, strs): groups = itertools.groupby(sorted(strs, key=sorted), sorted) return [sorted(members) for _, members in groups] Python solution 2 Using defaultdict to collect the groups. 12345def groupAnagrams(self, strs): groups = collections.defaultdict(list) for s in strs: groups[tuple(sorted(s))].append(s) return map(sorted, groups.values()) java 46ms, 4.52%, September 21, 2016 https://discuss.leetcode.com/topic/24494/share-my-short-java-solution Share my short JAVA solution 123456789101112131415public class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; if(strs == null || strs.length == 0) return new ArrayList&lt;List&lt;String&gt;&gt;(); Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); Arrays.sort(strs); for(String s: strs)&#123; char[] ca = s.toCharArray(); Arrays.sort(ca); String keyStr = String.valueOf(ca); if(!map.containsKey(keyStr)) map.put(keyStr, new ArrayList&lt;String&gt;()); map.get(keyStr).add(s); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125; https://discuss.leetcode.com/topic/45639/java-beat-100-use-prime-number Java beat 100%!!! use prime number 12345678910111213141516171819202122public static List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; int[] prime = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103&#125;;//最多10609个z List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (String s : strs) &#123; int key = 1; for (char c : s.toCharArray()) &#123; key *= prime[c - &apos;a&apos;]; &#125; List&lt;String&gt; t; if (map.containsKey(key)) &#123; t = res.get(map.get(key)); &#125; else &#123; t = new ArrayList&lt;&gt;(); res.add(t); map.put(key, res.size() - 1); &#125; t.add(s); &#125; return res; &#125; https://discuss.leetcode.com/topic/12509/o-m-n-algorithm-using-hash-without-sort O(M * N) algorithm using hash, without sort() Assign a prime number for a to z, and then multiply all prime numbers together to form a hash value. 123456789101112131415161718192021222324private static final int[] PRIMES = new int[]&#123;2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107&#125;;public List&lt;String&gt; anagrams(String[] strs) &#123; List&lt;String&gt; list = new LinkedList&lt;&gt;(); Map&lt;Integer, List&lt;String&gt;&gt; mapString = new HashMap&lt;&gt;(); int result = -1; for (int i = 0; i &lt; strs.length; i++)&#123; int mapping = 1; for (int j = 0, max = strs[i].length(); j &lt; max; j++) &#123; mapping *= PRIMES[strs[i].charAt(j) - &apos;a&apos;]; &#125; List&lt;String&gt; strings = mapString.get(mapping); if (strings == null) &#123; strings = new LinkedList&lt;&gt;(); mapString.put(mapping, strings); &#125; strings.add(strs[i]); &#125; for (List&lt;String&gt; mapList : mapString.values())&#123; if (mapList.size() &gt; 1) list.addAll(mapList); &#125; return list;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>string</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[048. Rotate Image]]></title>
    <url>%2Fp%2Ff0ab6b95%2F</url>
    <content type="text"><![CDATA[38.5% https://leetcode.com/problems/rotate-image/ You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up: Could you do this in-place? 方法一： https://leetcode.com/discuss/20589/a-common-method-to-rotate-the-image 两次反转，一次上下反转，一次侧着反转 学习revers函数 reverse(matrix.begin(), matrix.end()); A common method to rotate the image here give a common method to solve the image rotation problems. 12345678910111213141516171819202122/* * clockwise rotate * first reverse up to down, then swap the symmetry * 1 2 3 7 8 9 7 4 1 * 4 5 6 =&gt; 4 5 6 =&gt; 8 5 2 * 7 8 9 1 2 3 9 6 3*/void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; reverse(matrix.begin(), matrix.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125;/* * anticlockwise rotate * first reverse left to right, then swap the symmetry * 1 2 3 3 2 1 3 6 9 * 4 5 6 =&gt; 6 5 4 =&gt; 2 5 8 * 7 8 9 9 8 7 1 4 7*/ 1234567void anti_rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; for (auto vi : matrix) reverse(vi.begin(), vi.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125; 我的代码实现： 12345678910111213141516171819class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix.size()==0 || matrix[0].size()==0) return; int n = matrix.size(); if(n==1) return; for(int i=0; i&lt;(n+1)/2; i++)&#123; for(int j=0; j&lt;n; j++)&#123; swap(matrix[i][j], matrix[n-1-i][j]); &#125; &#125; for(int i=0; i&lt;n; i++)&#123; for(int j=i+1; j&lt;n; j++) swap(matrix[i][j], matrix[j][i]); &#125; return; &#125;&#125;; cpp 6ms, 7.71%, June.17th, 2016 https://leetcode.com/discuss/20589/a-common-method-to-rotate-the-image A common method to rotate the image here give a common method to solve the image rotation problems. 12345678910111213141516171819202122/* * clockwise rotate * first reverse up to down, then swap the symmetry * 1 2 3 7 8 9 7 4 1 * 4 5 6 =&gt; 4 5 6 =&gt; 8 5 2 * 7 8 9 1 2 3 9 6 3*/void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; reverse(matrix.begin(), matrix.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125;/* * anticlockwise rotate * first reverse left to right, then swap the symmetry * 1 2 3 3 2 1 3 6 9 * 4 5 6 =&gt; 6 5 4 =&gt; 2 5 8 * 7 8 9 9 8 7 1 4 7*/ 1234567void anti_rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; for (auto vi : matrix) reverse(vi.begin(), vi.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125; https://discuss.leetcode.com/topic/20921/4ms-few-lines-c-code-rotate-image-90-degree-for-o-1-space 4ms few lines C++ code Rotate Image 90 degree for O(1) space 1234567891011121314void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); int a = 0; int b = n-1; while(a&lt;b)&#123; for(int i=0;i&lt;(b-a);++i)&#123; swap(matrix[a][a+i], matrix[a+i][b]); swap(matrix[a][a+i], matrix[b][b-i]); swap(matrix[a][a+i], matrix[b-i][a]); &#125; ++a; --b; &#125; &#125; https://discuss.leetcode.com/topic/17645/6-lines-of-code-and-with-o-1-space-in-c 6 lines of code and with O(1) space in c++ First we transpose the matrix and then reverse every row: 12345678910void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; m) &#123; int n = m.size(); for(int i=0; i&lt;n; i++) for(int j=0; j&lt;i; j++) swap(m[i][j], m[j][i]); for(int i=0; i&lt;n; i++) reverse(m[i].begin(), m[i].end()); &#125; https://discuss.leetcode.com/topic/5564/share-my-inplace-solution Share my inplace solution 123456789101112131415161718192021class Solution &#123;public: //fold for the middle, fold for the diagnal void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; //find middle int mid = matrix.size()/2; int n = matrix.size(); //swap, i swap with matrix.size()-1-i for(int i = 0; i &lt; mid; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; swap(matrix[i][j], matrix[n-1-i][j]); &#125; &#125; //swap, i,j swap with j,i for(int i = 0; i &lt; n; i++)&#123; for(int j = i; j &lt; n; j++)&#123; swap(matrix[i][j], matrix[j][i]); &#125; &#125; &#125;&#125;; Fold matrix once to the middle line. Fold matrix one more time along the diagonal line. python https://discuss.leetcode.com/topic/15295/seven-short-solutions-1-to-7-lines Seven Short Solutions (1 to 7 lines) While these solutions are Python, I think they’re understandable/interesting for non-Python coders as well. But before I begin: No mathematician would call a matrix matrix, so I’ll use the usual A. Also, btw, the 40 ms reached by two of the solutions is I think the fastest achieved by Python solutions so far. Most Pythonic - [::-1] and zip - 44 ms The most pythonic solution is a simple one-liner using [::-1] to flip the matrix upside down and then zip to transpose it. It assigns the result back into A, so it’s “in-place” in a sense and the OJ accepts it as such, though some people might not. 123class Solution: def rotate(self, A): A[:] = zip(*A[::-1]) Most Direct - 52 ms A 100% in-place solution. It even reads and writes each matrix element only once and doesn’t even use an extra temporary variable to hold them. It walks over the “top-left quadrant” of the matrix and directly rotates each element with the three corresponding elements in the other three quadrants. Note that I’m moving the four elements in parallel and that [~ i] is way nicer than [n-1-i]. 1234567class Solution: def rotate(self, A): n = len(A) for i in range(n/2): for j in range(n-n/2): A[i][j], A[~j][i], A[~i][~j], A[j][~i] = \ A[~j][i], A[~i][~j], A[j][~i], A[i][j] Clean Most Pythonic - 56 ms While the OJ accepts the above solution, the the result rows are actually tuples, not lists, so it’s a bit dirty. To fix this, we can just apply list to every row: 123class Solution: def rotate(self, A): A[:] = map(list, zip(*A[::-1])) List Comprehension - 60 ms If you don’t like zip, you can use a nested list comprehension instead: 123class Solution: def rotate(self, A): A[:] = [[row[i] for row in A[::-1]] for i in range(len(A))] Almost as Direct - 40 ms If you don’t like the little repetitive code of the above “Most Direct” solution, we can instead do each four-cycle of elements by using three swaps of just two elements. 12345678class Solution: def rotate(self, A): n = len(A) for i in range(n/2): for j in range(n-n/2): for _ in &apos;123&apos;: A[i][j], A[~j][i], i, j = A[~j][i], A[i][j], ~j, ~i i = ~j Flip Flip - 40 ms Basically the same as the first solution, but using reverse instead of [::-1] and transposing the matrix with loops instead of zip. It’s 100% in-place, just instead of only moving elements around, it also moves the rows around. 123456class Solution: def rotate(self, A): A.reverse() for i in range(len(A)): for j in range(i): A[i][j], A[j][i] = A[j][i], A[i][j] Flip Flip, all by myself - 48 ms Similar again, but I first transpose and then flip left-right instead of upside-down, and do it all by myself in loops. This one is 100% in-place again in the sense of just moving the elements. 123456789class Solution: def rotate(self, A): n = len(A) for i in range(n): for j in range(i): A[i][j], A[j][i] = A[j][i], A[i][j] for row in A: for j in range(n/2): row[j], row[~j] = row[~j], row[j] java 0ms, 26.51%, June.17th, 2016 https://leetcode.com/discuss/27262/java-in-place-solution-with-explanation-easy-to-understand AC Java in place solution with explanation Easy to understand. The idea was firstly transpose the matrix and then flip it symmetrically. For instance, 1231 2 3 4 5 67 8 9 after transpose, it will be swap(matrix[i][j], matrix[j][i]) 1231 4 72 5 83 6 9 Then flip the matrix horizontally. (swap(matrix[i][j], matrix[i][matrix.length-1-j]) 1237 4 18 5 29 6 3 Hope this helps. 1234567891011121314151617181920public class Solution &#123; public void rotate(int[][] matrix) &#123; for(int i = 0; i&lt;matrix.length; i++)&#123; for(int j = i; j&lt;matrix[0].length; j++)&#123; int temp = 0; temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125; for(int i =0 ; i&lt;matrix.length; i++)&#123; for(int j = 0; j&lt;matrix.length/2; j++)&#123; int temp = 0; temp = matrix[i][j]; matrix[i][j] = matrix[i][matrix.length-1-j]; matrix[i][matrix.length-1-j] = temp; &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/20212/clear-java-solution Clear Java solution 12345678910111213public class Solution &#123;public void rotate(int[][] matrix) &#123; int n=matrix.length; for (int i=0; i&lt;n/2; i++) for (int j=i; j&lt;n-i-1; j++) &#123; int tmp=matrix[i][j]; matrix[i][j]=matrix[n-j-1][i]; matrix[n-j-1][i]=matrix[n-i-1][n-j-1]; matrix[n-i-1][n-j-1]=matrix[j][n-i-1]; matrix[j][n-i-1]=tmp; &#125; &#125;&#125; https://discuss.leetcode.com/topic/25989/a-simple-and-in-place-solution-in-java A Simple and In-Place Solution in Java 123456789101112131415161718192021222324public void rotate(int[][] matrix) &#123; if (matrix == null || matrix.length &lt;= 1) &#123; return; &#125; int n = matrix.length; for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &lt; n; j++) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; int head = 0; int tail = n - 1; while (head &lt; tail) &#123; int temp = matrix[i][head]; matrix[i][head] = matrix[i][tail]; matrix[i][tail] = temp; head++; tail--; &#125; &#125;&#125; For example, if the matrix is: 1 2 3 4 5 6 7 8 9 then after the first for loop, it becomes: 1 4 7 2 5 8 3 6 9 then after the second for loop, it becomes: 7 4 1 8 5 2 9 6 3]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[047. Permutations II]]></title>
    <url>%2Fp%2F94a736fc%2F</url>
    <content type="text"><![CDATA[32.8% https://leetcode.com/problems/permutations-ii/ Given a collection of numbers that might contain duplicates, return all possible unique permutations. 1234567891011For example,[1,1,2] have the following unique permutations:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 方法一： 123456789101112131415161718192021class Solution &#123;public: void recursion(vector&lt;int&gt; nums, int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp; res)&#123; if(i==j-1)&#123; res.push_back(nums); return; &#125; for(int k=i; k&lt;j; k++)&#123; if(i!=k &amp;&amp; nums[i] == nums[k]) continue; swap(nums[i], nums[k]); recursion(nums, i+1, j, res); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; recursion(nums, 0, nums.size(), res); return res; &#125;&#125;; 方法二： 此方法通不过，有疑问 错误样例 Input: [2,2,1,1] Output: [[1,1,2,2],[1,2,1,2],[1,2,2,1],[1,2,2,1],[1,2,1,2],[2,1,1,2],[2,1,2,1],[2,2,1,1],[2,1,2,1],[2,1,1,2],[2,2,1,1]] Expected: [[1,1,2,2],[1,2,1,2],[1,2,2,1],[2,1,1,2],[2,1,2,1],[2,2,1,1]] 12345678910111213141516171819202122class Solution &#123;public: void recursion(vector&lt;int&gt;&amp; nums, int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp; res)&#123; if(i==j-1)&#123; res.push_back(nums); return; &#125; for(int k=i; k&lt;j; k++)&#123; if(i!=k &amp;&amp; nums[i] == nums[k]) continue; swap(nums[i], nums[k]); recursion(nums, i+1, j, res); swap(nums[i], nums[k]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; recursion(nums, 0, nums.size(), res); return res; &#125;&#125;; cpp 23ms, 98.52%, September 21, 2016 https://discuss.leetcode.com/topic/8831/a-simple-c-solution-in-only-20-lines A simple C++ solution in only 20 lines 123456789101112131415161718192021class Solution &#123;public: void recursion(vector&lt;int&gt; nums, int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp; res)&#123; if(i==j-1)&#123; res.push_back(nums); return; &#125; for(int k=i; k&lt;j; k++)&#123; if(i!=k &amp;&amp; nums[i] == nums[k]) continue; swap(nums[i], nums[k]); recursion(nums, i+1, j, res); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; recursion(nums, 0, nums.size(), res); return res; &#125;&#125;; https://discuss.leetcode.com/topic/3194/a-non-recursive-c-implementation-with-o-1-space-cost A non-recursive C++ implementation with O(1) space cost 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permuteUnique(vector&lt;int&gt; &amp;S) &#123; // res.clear(); sort(S.begin(), S.end()); res.push_back(S); int j; int i = S.size()-1; while (1)&#123; for (i=S.size()-1; i&gt;0; i--)&#123; if (S[i-1]&lt; S[i])&#123; break; &#125; &#125; if(i == 0)&#123; break; &#125; for (j=S.size()-1; j&gt;i-1; j--)&#123; if (S[j]&gt;S[i-1])&#123; break; &#125; &#125; swap(S[i-1], S[j]); reverse(S, i, S.size()-1); res.push_back(S); &#125; return res; &#125; void reverse(vector&lt;int&gt; &amp;S, int s, int e)&#123; while (s&lt;e)&#123; swap(S[s++], S[e--]); &#125; &#125; vector&lt;vector&lt;int&gt; &gt; res;&#125;; Basically, assume we have “1234”, the idea is to increase the number in ascending order, so next is “1243”, next is “1324”, and so on. python https://discuss.leetcode.com/topic/32976/9-line-python-solution-with-1-line-to-handle-duplication-beat-99-of-others 9-line python solution with 1 line to handle duplication, beat 99% of others :-) Very similar to Permutation I, see explanations in https://leetcode.com/discuss/19510/my-ac-simple-iterative-java-python-solution. To handle duplication, just avoid inserting a number before any of its duplicates. 12345678910def permuteUnique(self, nums): ans = [[]] for n in nums: new_ans = [] for l in ans: for i in xrange(len(l)+1): new_ans.append(l[:i]+[n]+l[i:]) if i&lt;len(l) and l[i]==n: break #handles duplication ans = new_ans return ans https://discuss.leetcode.com/topic/32976/9-line-python-solution-with-1-line-to-handle-duplication-beat-99-of-others/2 Nice one! Here’s an even shorter and I think faster implementation, though. Got it accepted in 100 ms, achieving the coveted “Your runtime beats 100.00% of python submissions.” (Well, I tried five times, they were 112, 104, 100, 104 and 116 ms). 1234567def permuteUnique(self, nums): ans = [[]] for n in nums: ans = [l[:i]+[n]+l[i:] for l in ans for i in xrange((l+[n]).index(n)+1)] return ans And for fun, a one-liner version: 12def permuteUnique(self, nums): return reduce(lambda a,n:[l[:i]+[n]+l[i:]for l in a for i in xrange((l+[n]).index(n)+1)],nums,[[]]) https://discuss.leetcode.com/topic/7667/iterative-python-solution-without-using-set-111ms Iterative Python solution without using set, 111ms Duplication happens when we insert the duplicated element before and after the same element, to eliminate duplicates, just insert only after the same element. 123456789101112131415def permuteUnique(self, num): if not num: return [] num.sort() ret = [[]] for n in num: new_ret = [] l = len(ret[-1]) for seq in ret: for i in range(l, -1, -1): if i &lt; l and seq[i] == n: break new_ret.append(seq[:i] + [n] + seq[i:]) ret = new_ret return ret java https://discuss.leetcode.com/topic/31445/really-easy-java-solution-much-easier-than-the-solutions-with-very-high-vote Really easy Java solution, much easier than the solutions with very high vote Use an extra boolean array “ boolean[] used” to indicate whether the value is added to list. Sort the array “int[] nums” to make sure we can skip the same value. when a number has the same value with its previous, we can use this number only if his previous is used 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(nums==null || nums.length==0) return res; boolean[] used = new boolean[nums.length]; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Arrays.sort(nums); dfs(nums, used, list, res); return res; &#125; public void dfs(int[] nums, boolean[] used, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res)&#123; if(list.size()==nums.length)&#123; res.add(new ArrayList&lt;Integer&gt;(list)); return; &#125; for(int i=0;i&lt;nums.length;i++)&#123; if(used[i]) continue; if(i&gt;0 &amp;&amp;nums[i-1]==nums[i] &amp;&amp; !used[i-1]) continue; used[i]=true; list.add(nums[i]); dfs(nums,used,list,res); used[i]=false; list.remove(list.size()-1); &#125; &#125;&#125; https://discuss.leetcode.com/topic/5993/share-my-recursive-solution Share my recursive solution 1234567891011121314151617181920212223242526272829public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] num) &#123; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; current = new ArrayList&lt;Integer&gt;(); boolean[] visited = new boolean[num.length]; permute(result, current, num, visited); return result; &#125; private void permute(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; current, int[] num, boolean[] visited) &#123; if (current.size() == num.length) &#123; result.add(new ArrayList&lt;Integer&gt;(current)); return; &#125; for (int i=0; i&lt;visited.length; i++) &#123; if (!visited[i]) &#123; if (i &gt; 0 &amp;&amp; num[i] == num[i-1] &amp;&amp; visited[i-1]) &#123; return; &#125; visited[i] = true; current.add(num[i]); permute(result, current, num, visited); current.remove(current.size()-1); visited[i] = false; &#125; &#125; &#125;&#125; The idea to resolve duplicate is to ensure that for elements with the same value, we make sure that they are picked up in the ascending order of index. To implement this, every time we try to pick up some value, we just check if the previous element has the same value and is visited or not. If so, we just return! https://discuss.leetcode.com/topic/36221/share-my-java-code-with-detailed-explanantion Share my Java code with detailed explanantion 12345678910111213141516171819202122232425262728293031public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (nums==null || nums.length==0) &#123; return ans; &#125; permute(ans, nums, 0); return ans; &#125; private void permute(List&lt;List&lt;Integer&gt;&gt; ans, int[] nums, int index) &#123; if (index == nums.length) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for (int num: nums) &#123; temp.add(num); &#125; ans.add(temp); return; &#125; Set&lt;Integer&gt; appeared = new HashSet&lt;&gt;(); for (int i=index; i&lt;nums.length; ++i) &#123; if (appeared.add(nums[i])) &#123; swap(nums, index, i); permute(ans, nums, index+1); swap(nums, index, i); &#125; &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int save = nums[i]; nums[i] = nums[j]; nums[j] = save; &#125;&#125; https://discuss.leetcode.com/topic/12923/short-iterative-java-solution Short iterative Java solution Hi guys! Here’s an iterative solution which doesn’t use nextPermutation helper. It builds the permutations for i-1 first elements of an input array and tries to insert the ith element into all positions of each prebuilt i-1 permutation. I couldn’t come up with more effective controling of uniqueness than just using a Set. See the code below! 12345678910111213141516171819public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] num) &#123; LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); res.add(new ArrayList&lt;&gt;()); for (int i = 0; i &lt; num.length; i++) &#123; Set&lt;String&gt; cache = new HashSet&lt;&gt;(); while (res.peekFirst().size() == i) &#123; List&lt;Integer&gt; l = res.removeFirst(); for (int j = 0; j &lt;= l.size(); j++) &#123; List&lt;Integer&gt; newL = new ArrayList&lt;&gt;(l.subList(0,j)); newL.add(num[i]); newL.addAll(l.subList(j,l.size())); if (cache.add(newL.toString())) res.add(newL); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[046. Permutations]]></title>
    <url>%2Fp%2Fc83ab0f7%2F</url>
    <content type="text"><![CDATA[42.0% https://leetcode.com/problems/permutations/ Given a collection of distinct numbers, return all possible permutations. 12345678910For example,[1,2,3] have the following permutations:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 方法一：标准的回溯法 剑指offer 28 我的代码实现: 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; dfs(nums, res, 0); return res; &#125; void dfs(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; res, int k)&#123; if(k==nums.size()-1)&#123; res.push_back(nums); return; &#125; for(int i=k; i&lt;nums.size(); i++)&#123; swap(nums[k], nums[i]); dfs(nums, res, k+1); swap(nums[k], nums[i]); &#125; &#125;&#125;; 注意，倒数第三行，参数是begin+1, 不是i+1. permuteRecursive(nums, begin, result); 代表nums中0至begin-1已经排好序了，剩下的是begin至n-1 n = nums.size()-1 所以当begin = n时，则push进去。 然后，begin未排好，从begin开始，begin与后面的都交换一遍 每次交换后，调用permuteRecurive(nums, begin+1, res); 所以逻辑是很清晰的了。 My elegant recursive C++ solution with inline explanation This recursive solution is the my first response for this problem. I was surprised when I found no similar solution posted here. It is much easier to understand than DFS-based ones, at least in my opinion. Please find more explanations here. All comments are welcome. 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; result; permuteRecursive(num, 0, result); return result; &#125; // permute num[begin..end] // invariant: num[0..begin-1] have been fixed/permuted void permuteRecursive(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;result) &#123; if (begin &gt;= num.size()) &#123; // one permutation instance result.push_back(num); return; &#125; for (int i = begin; i &lt; num.size(); i++) &#123; swap(num[begin], num[i]); permuteRecursive(num, begin + 1, result); // reset swap(num[begin], num[i]); &#125; &#125;&#125;; 我的实现 经典回溯法 思考清楚过程 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; res; helper(nums, 0, n, res); return res; &#125; void helper(vector&lt;int&gt;&amp; nums, int k, int n, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(k==n)&#123; res.push_back(nums); return; &#125; for(int i=k; i&lt;n; i++)&#123; swap(nums[k], nums[i]); helper(nums, k+1, n, res); // 此处变为k+1，不是i+1 swap(nums[k], nums[i]); &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/5881/my-elegant-recursive-c-solution-with-inline-explanation My elegant recursive C++ solution with inline explanation This recursive solution is the my first response for this problem. I was surprised when I found no similar solution posted here. It is much easier to understand than DFS-based ones, at least in my opinion. Please find more explanations here. All comments are welcome. 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; result; permuteRecursive(num, 0, result); return result; &#125; // permute num[begin..end] // invariant: num[0..begin-1] have been fixed/permuted void permuteRecursive(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;result) &#123; if (begin &gt;= num.size()) &#123; // one permutation instance result.push_back(num); return; &#125; for (int i = begin; i &lt; num.size(); i++) &#123; swap(num[begin], num[i]); permuteRecursive(num, begin + 1, result); // reset swap(num[begin], num[i]); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/6740/share-my-three-different-solutions Share my three different solutions 1234567891011121314151617181920// method 1: standard backtracing solutionvector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; ans; permutation(num, 0, ans); return ans;&#125;void permutation(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;ans) &#123; if (begin &gt;= num.size()) &#123; ans.push_back(num); return; &#125; // every number chosen to be the begin once for (int i = begin; i &lt; num.size(); ++i) &#123; swap(num[begin], num[i]); permutation(num, begin+1, ans); swap(num[begin], num[i]); &#125;&#125; 12345678910// method 2: using next_permutation to iterate all the permutaionsvector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; ans; sort(num.begin(), num.end()); ans.push_back(num); while(next_permutation(num.begin(), num.end())) ans.push_back(num); return ans;&#125; 12345678910111213141516171819202122232425262728// method 3: recursive dfsvector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; ans; dfs(num, ans); return ans;&#125;void dfs(vector&lt;int&gt; &amp;num, vector&lt;vector&lt;int&gt;&gt; &amp;ans) &#123; if (num.size() == 1) &#123; vector&lt;int&gt; tmp(num.begin(), num.end()); ans.push_back(tmp); return; &#125; vector&lt;vector&lt;int&gt; &gt; ans1; vector&lt;int&gt; num1(num.begin()+1, num.end()); dfs(num1, ans); for(int i = 0; i &lt; ans.size(); ++i) &#123; for(int j = 0; j &lt;= ans[i].size(); ++j) &#123; vector&lt;int&gt; tmp = ans[i]; tmp.insert(tmp.begin()+j, num[0]); ans1.push_back(tmp); &#125; &#125; ans = ans1;&#125; 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; result; permuteRecursive(num, 0, result); return result; &#125; // permute num[begin..end] // invariant: num[0..begin-1] have been fixed/permuted void permuteRecursive(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;result) &#123; if (begin &gt;= num.size()) &#123; // one permutation instance result.push_back(num); return; &#125; for (int i = begin; i &lt; num.size(); i++) &#123; swap(num[begin], num[i]); permuteRecursive(num, begin + 1, result); // reset swap(num[begin], num[i]); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/17277/one-liners-in-python One-Liners in Python Solution 1: Recursive, take any number as first Take any number as the first number and append any permutation of the other numbers. 1234def permute(self, nums): return [[n] + p for i, n in enumerate(nums) for p in self.permute(nums[:i] + nums[i+1:])] or [[]] Solution 2: Recursive, insert first number anywhere Insert the first number anywhere in any permutation of the remaining numbers. 1234def permute(self, nums): return nums and [p[:i] + [nums[0]] + p[i:] for p in self.permute(nums[1:]) for i in range(len(nums))] or [[]] Solution 3: Reduce, insert next number anywhere Use reduce to insert the next number anywhere in the already built permutations. 1234def permute(self, nums): return reduce(lambda P, n: [p[:i] + [n] + p[i:] for p in P for i in range(len(p)+1)], nums, [[]]) Solution 4: Using the library 12def permute(self, nums): return list(itertools.permutations(nums)) That returns a list of tuples, but the OJ accepts it anyway. If needed, I could easily turn it into a list of lists: 12def permute(self, nums): return map(list, itertools.permutations(nums)) 76ms, 93.03%, June.17th, 2016 https://leetcode.com/discuss/51398/simple-python-solution-dfs 12345678910111213141516class Solution(object): def permute(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; res = [] self.dfs(nums, [], res) return res def dfs(self, nums, path, res): if not nums: res.append(path) else: for i in xrange(len(nums)): self.dfs(nums[:i] + nums[i+1:], path+[nums[i]], res) java https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partioning) This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. Subsets : https://leetcode.com/problems/subsets/ 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Subsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Permutations : https://leetcode.com/problems/permutations/ 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/ 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum : https://leetcode.com/problems/combination-sum/ 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum II (can’t reuse same element) : https://leetcode.com/problems/combination-sum-ii/ 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Palindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/ 12345678910111213141516171819202122232425public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list;&#125;public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125;&#125;public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true;&#125; https://discuss.leetcode.com/topic/6377/my-ac-simple-iterative-java-python-solution 123456789My AC simple iterative java/python solutionthe basic idea is, to permute n numbers, we can add the nth number into the resulting List&lt;List&lt;Integer&gt;&gt; from the n-1 numbers, in every possible position.For example, if the input num[] is &#123;1,2,3&#125;: First, add 1 into the initial List&lt;List&lt;Integer&gt;&gt; (let&apos;s call it &quot;answer&quot;).Then, 2 can be added in front or after 1. So we have to copy the List&lt;Integer&gt; in answer (it&apos;s just &#123;1&#125;), add 2 in position 0 of &#123;1&#125;, then copy the original &#123;1&#125; again, and add 2 in position 1. Now we have an answer of &#123;&#123;2,1&#125;,&#123;1,2&#125;&#125;. There are 2 lists in the current answer.Then we have to add 3. first copy &#123;2,1&#125; and &#123;1,2&#125;, add 3 in position 0; then copy &#123;2,1&#125; and &#123;1,2&#125;, and add 3 into position 1, then do the same thing for position 3. Finally we have 2\*3=6 lists in answer, which is what we want. 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (num.length ==0) return ans; List&lt;Integer&gt; l0 = new ArrayList&lt;Integer&gt;(); l0.add(num[0]); ans.add(l0); for (int i = 1; i&lt; num.length; ++i)&#123; List&lt;List&lt;Integer&gt;&gt; new_ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for (int j = 0; j&lt;=i; ++j)&#123; for (List&lt;Integer&gt; l : ans)&#123; List&lt;Integer&gt; new_l = new ArrayList&lt;Integer&gt;(l); new_l.add(j,num[i]); new_ans.add(new_l); &#125; &#125; ans = new_ans; &#125; return ans;&#125; python version is more concise: 123456789def permute(self, nums): perms = [[]] for n in nums: new_perms = [] for perm in perms: for i in xrange(len(perm)+1): new_perms.append(perm[:i] + [n] + perm[i:]) ###insert n perms = new_perms return perms https://discuss.leetcode.com/topic/10812/share-my-short-iterative-java-solution Share my short iterative JAVA solution 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) &#123; LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;List&lt;Integer&gt;&gt;(); res.add(new ArrayList&lt;Integer&gt;()); for (int n : num) &#123; int size = res.size(); for (; size &gt; 0; size--) &#123; List&lt;Integer&gt; r = res.pollFirst(); for (int i = 0; i &lt;= r.size(); i++) &#123; List&lt;Integer&gt; t = new ArrayList&lt;Integer&gt;(r); t.add(i, n); res.add(t); &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/23036/java-clean-code-two-recursive-solutions Java Clean Code - Two recursive solutions Bottom up? approach - 280ms 1234567891011121314151617181920212223242526public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; permutations = new ArrayList&lt;&gt;(); if (nums.length == 0) &#123; return permutations; &#125; collectPermutations(nums, 0, new ArrayList&lt;&gt;(), permutations); return permutations; &#125; private void collectPermutations(int[] nums, int start, List&lt;Integer&gt; permutation, List&lt;List&lt;Integer&gt;&gt; permutations) &#123; if (permutation.size() == nums.length) &#123; permutations.add(permutation); return; &#125; for (int i = 0; i &lt;= permutation.size(); i++) &#123; List&lt;Integer&gt; newPermutation = new ArrayList&lt;&gt;(permutation); newPermutation.add(i, nums[start]); collectPermutations(nums, start + 1, newPermutation, permutations); &#125; &#125;&#125; Code flow 123456789101112131415nums = 1,2,3start = 0, permutation = []i = 0, newPermutation = [1] start = 1, permutation = [1] i = 0, newPermutation = [2, 1] start = 2, permutation = [2, 1] i = 0, newPermutation = [3, 2, 1] i = 1, newPermutation = [2, 3, 1] i = 2, newPermutation = [2, 1, 3] i = 1, newPermutation = [1, 2] start = 2, permutation = [1, 2] i = 0, newPermutation = [3, 1, 2] i = 1, newPermutation = [1, 3, 2] i = 2, newPermutation = [1, 2, 3] Base case and build approach - 524ms 1234567891011121314151617181920212223242526272829public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; return permute(Arrays.stream(nums).boxed().collect(Collectors.toList())); &#125; private List&lt;List&lt;Integer&gt;&gt; permute(List&lt;Integer&gt; nums) &#123; List&lt;List&lt;Integer&gt;&gt; permutations = new ArrayList&lt;&gt;(); if (nums.size() == 0) &#123; return permutations; &#125; if (nums.size() == 1) &#123; List&lt;Integer&gt; permutation = new ArrayList&lt;&gt;(); permutation.add(nums.get(0)); permutations.add(permutation); return permutations; &#125; List&lt;List&lt;Integer&gt;&gt; smallPermutations = permute(nums.subList(1, nums.size())); int first = nums.get(0); for(List&lt;Integer&gt; permutation : smallPermutations) &#123; for (int i = 0; i &lt;= permutation.size(); i++) &#123; List&lt;Integer&gt; newPermutation = new ArrayList&lt;&gt;(permutation); newPermutation.add(i, first); permutations.add(newPermutation); &#125; &#125; return permutations; &#125;&#125; Code flow 12345678910111213141516171819nums = 1,2,3smallPermutations(2, 3) smallPermutations(3) return [[3]] first = 2 permutation = [3] i = 0, newPermutation = [2, 3] i = 1, newPermutation = [3, 2] return [[2, 3], [3, 2]]first = 1 permutation = [2, 3] i = 0, newPermutation = [1, 2, 3] i = 1, newPermutation = [2, 1, 3] i = 2, newPermutation = [2, 3, 1] permutation = [3, 2] i = 0, newPermutation = [1, 3, 2] i = 1, newPermutation = [3, 1, 2] i = 2, newPermutation = [3, 2, 1] 回溯法 https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning1234567891011121314151617181920public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), nums); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums)&#123; if(tempList.size() == nums.length) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i=0; i&lt;nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size()-1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[045. Jump Game II]]></title>
    <url>%2Fp%2Fded0cd97%2F</url>
    <content type="text"><![CDATA[26.2% https://leetcode.com/problems/jump-game-ii/ Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. 123456For example:Given array A = [2,3,1,1,4]The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.) Note: You can assume that you can always reach the last index. 方法一： 我的代码： lastJump，表示经过上一步之后，所能到达最远的点。 nextJump是step++之后，新的一段，能走的最远的点。 1234567891011121314151617class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==1) return 0; int lastJump = 0; int nextJump = 0; int step = 0; for(int i=0; i&lt;nums.size()-1; i++)&#123; nextJump = max(nextJump, i+nums[i]); if(lastJump == i)&#123; step++; lastJump = nextJump; &#125; &#125; return step; &#125;&#125;; my code 12345678910111213141516class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int step = 0; int e = 0; int ma = 0; for(int i=0; i&lt;nums.size()-1; i++)&#123; ma = max(i+nums[i], ma); if(i==e)&#123; step++; e = ma; &#125; &#125; return step; &#125;&#125;; cpp https://discuss.leetcode.com/topic/3191/o-n-bfs-solution O(n), BFS solution I try to change this problem to a BFS problem, where nodes in level i are all the nodes that can be reached in i-1th jump. for example. 2 3 1 1 4 , is 2|| 3 1|| 1 4 || clearly, the minimum jump of 4 is 2 since 4 is in level 3. my ac code. 1234567891011121314int jump(int A[], int n) &#123; if(n&lt;2)return 0; int level=0,currentMax=0,i=0,nextMax=0; while(currentMax-i+1&gt;0)&#123; //nodes count of current level&gt;0 level++; for(;i&lt;=currentMax;i++)&#123; //traverse current level , and update the max reach of next level nextMax=max(nextMax,A[i]+i); if(nextMax&gt;=n-1)return level; // if last element is in level+1, then the min jump=level &#125; currentMax=nextMax; &#125; return 0; &#125; https://leetcode.com/discuss/45992/10-lines-c-16ms-python-bfs-solutions-with-explanations 16ms, 22.73%, June.22th, 2016 10-lines C++ (16ms) / Python BFS Solutions with Explanations This problem has a nice BFS structure. Let’s illustrate it using the example nums = [2, 3, 1, 1, 4] in the problem statement. We are initially at position 0. Then we can move at most nums[0] steps from it. So, after one move, we may reach nums[1] = 3 or nums[2] = 1. So these nodes are reachable in 1 move. From these nodes, we can further move to nums[3] = 1 and nums[4] = 4. Now you can see that the target nums[4] = 4 is reachable in 2 moves. Putting these into codes, we keep two pointers start and end that record the current range of the starting nodes. Each time after we make a move, update start to be end + 1 and end to be the farthest index that can be reached in 1 move from the current [start, end]. To get an accepted solution, it is important to handle all the edge cases. And the following codes handle all of them in a unified way without using the unclean if statements :-) 1234567891011121314151617class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), start = 0, end = 0, step=0; while(end &lt; n - 1)&#123; step++; int maxend = end + 1; for(int i = start; i &lt; end + 1; i++)&#123; if(nums[i] + i &gt;= n - 1) return step; maxend = max(maxend, nums[i] + i); &#125; start = end + 1; end = maxend; &#125; return step; &#125;&#125;; https://discuss.leetcode.com/topic/5810/sharing-my-straightforward-c-solution Sharing my straightforward C++ solution 12345678910111213141516171819int jump(int A[], int n) &#123; if(n == 0)&#123; return 0; &#125; int maxReachPos = A[0]; int curMaxReachPos = A[0]; int curStep = 1; for(int i = 1; i &lt;= min(n, maxReachPos); i++)&#123; curMaxReachPos = max(curMaxReachPos, i + A[i]); if(i == n - 1)&#123; return curStep; &#125; if(i == maxReachPos)&#123; maxReachPos = curMaxReachPos; curStep++; &#125; &#125; return 0;&#125; The variable maxReachPos indicates the farthest reachable position and the variable curMaxReachPos indicates the current farthest reachable position. At the very beginning, both maxReachPos and curMaxReachPos are equal to A[0]. In the For loop, we keep updating curMaxReachPos while i &lt;= maxReachPos. However, if( i == n - 1), we return curStep, which is the minimum step. If i reaches the maxReachPos, we update maxReachPos with curMaxReachPos and increment curStep by one. Finally, if we can’t reach the end point, just return 0. python https://discuss.leetcode.com/topic/11761/easy-python-greedy-solution-with-explanation Easy Python Greedy solution with explanation 123456789101112131415class Solution:# @param A, a list of integers# @return an integerdef jump(self, A): last_max_reach, current_max_reach = 0 , 0 njump , i = 0 , 0 while current_max_reach &lt; len(A)-1: while i &lt;= last_max_reach: current_max_reach = max(i+A[i],current_max_reach) i+=1 if last_max_reach == current_max_reach: return -1 last_max_reach = current_max_reach njump+=1 return njump The basic thoughts underline is a greedy style. Every one more jump, you want to jump as far as possible.In Jump Game I, when you at position i, you care about what is the furthest position could be reached from i th position. but here in Jump Game II, instead you care about what would be the next furthest jump could be made when you could reach as far as ith position from last jump. So you iterate all positions could be reached from last jump till i th position to find it out. https://leetcode.com/discuss/45992/10-lines-c-16ms-python-bfs-solutions-with-explanations 86ms, 29.68%, June.22th, 201612345678910111213141516class Solution(object): def jump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n, start, end, step = len(nums), 0, 0, 0 while end &lt; n - 1: step += 1 maxend = end + 1 for i in range(start, end + 1): if i + nums[i] &gt;= n - 1: return step maxend = max(maxend, i + nums[i]) start, end = end + 1, maxend return step https://leetcode.com/discuss/45992/10-lines-c-16ms-python-bfs-solutions-with-explanations 84ms, 29.68%, June.22th, 2016 12345678910111213141516class Solution(object): def jump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n, start, end, step = len(nums), 0, 0, 0 while end &lt; n - 1: step += 1 maxend = end + 1 for i in range(start, end + 1): maxend = max(maxend, i + nums[i]) if maxend &gt;= n - 1: return step start, end = end + 1, maxend return step java https://discuss.leetcode.com/topic/11408/single-loop-simple-java-solution Single loop simple java solution 12345678910111213public int jump(int[] A) &#123; int step = 0; int e = 0; int max = 0; for(int i=0; i&lt;A.length-1; i++) &#123; max = Math.max(max, i+A[i]); if( i == e ) &#123; step++; e = max; &#125; &#125; return step;&#125; https://discuss.leetcode.com/topic/11408/single-loop-simple-java-solution/2 Very elegant method, but it took me a long time to understand. Some comment for the above: e: longest distance in current minimum step step: minimum steps for reaching e From i to e, even max is changed in a loop, it is reachable in one step. Help it will help : ) https://discuss.leetcode.com/topic/11408/single-loop-simple-java-solution/4 12345678910111213public int jump(int[] A) &#123; int step_count = 0; int last_jump_max = 0; int current_jump_max = 0; for(int i=0; i&lt;A.length-1; i++) &#123; current_jump_max = Math.max(current_jump_max, i+A[i]); if( i == last_jump_max ) &#123; step_count++; last_jump_max = current_jump_max; &#125; &#125; return step_count;&#125; https://discuss.leetcode.com/topic/4069/sharing-my-ac-java-solution Sharing My AC Java Solution Hi All, below is my AC solution: 12345678910111213141516171819public int jump(int[] A) &#123; int maxReach = A[0]; int edge = 0; int minstep = 0; for(int i = 1; i &lt; A.length; i++) &#123; if (i &gt; edge) &#123; minstep += 1; edge = maxReach; if(edge &gt; A.length - 1) return minstep; &#125; maxReach = Math.max(maxReach, A[i] + i); if (maxReach == i): return -1; &#125; return minstep;&#125; When iterate the array, I set an edge for the Search phase, which means that if I exceeds the edge, the minstep must add one and the maxReach will be update. And when the last index is within the range of the edge, output the minstep. [2, 3, 1, 1, 4] First, the edge is 0; Second, after start iterate the array, it exceeds the edge 0 when reaching the A[0] and update the edge to 2; Third, after it reach the A[2], it exceeds the edge 2 and update the new edge to the maxReach 4. Finally, end of the array is inside the edge, output the minstep. https://discuss.leetcode.com/topic/28470/concise-o-n-one-loop-java-solution-based-on-greedy Concise O(n) one loop JAVA solution based on Greedy Explanation The main idea is based on greedy. Let’s say the range of the current jump is [curBegin, curEnd], curFarthest is the farthest point that all points in [curBegin, curEnd] can reach. Once the current point reaches curEnd, then trigger another jump, and set the new curEnd with curFarthest, then keep the above steps, as the following: 1234567891011public int jump(int[] A) &#123; int jumps = 0, curEnd = 0, curFarthest = 0; for (int i = 0; i &lt; A.length - 1; i++) &#123; curFarthest = Math.max(curFarthest, i + A[i]); if (i == curEnd) &#123; jumps++; curEnd = curFarthest; &#125; &#125; return jumps;&#125; https://leetcode.com/discuss/30647/single-loop-simple-java-solution 3ms, 55.57%, June.22th, 2016123456789101112131415public class Solution &#123; public int jump(int[] nums) &#123; int sc = 0; int e = 0; int max = 0; for(int i=0; i&lt;nums.length-1; i++) &#123; max = Math.max(max, i+nums[i]); if( i == e ) &#123; sc++; e = max; &#125; &#125; return sc; &#125; &#125; my code 12345678910111213public class Solution &#123; public int jump(int[] nums) &#123; int step=0, cur=0, max=0; for(int i=0; i&lt;nums.length-1; i++)&#123; max = Math.max(max, i+nums[i]); if(i==cur)&#123; step += 1; cur = max; &#125; &#125; return step; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hard</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[044. Wildcard Matching]]></title>
    <url>%2Fp%2Fbcc0695c%2F</url>
    <content type="text"><![CDATA[20.4% https://leetcode.com/problems/wildcard-matching/ Implement wildcard pattern matching with support for ‘?’ and ‘*‘. 12345678910111213141516&apos;?&apos; Matches any single character.&apos;*&apos; Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;*&quot;) → trueisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;ab&quot;, &quot;?*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → false 方法一: 我的代码实现: 1234567891011121314151617181920212223class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.size(), n = p.size(); if(n==0) return m==0; vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=1; i&lt;=n; i++) dp[0][i] = dp[0][i-1] &amp;&amp; (p[i-1]=='*'); for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) if(p[j-1]!='*') dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]=='?'); else&#123; for(int k=i; k&gt;=0; k--)&#123; dp[i][j] = dp[i][j] || dp[k][j-1]; if(dp[i][j]==true) break; &#125; &#125; return dp[m][n]; &#125;&#125;; 方法二: 我的代码实现: 123456789101112131415161718class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.size(), n = p.size(); if(n==0) return m==0; vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=1; i&lt;=n; i++) dp[0][i] = dp[0][i-1] &amp;&amp; (p[i-1]=='*'); for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) if(p[j-1]!='*') dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]=='?'); else dp[i][j] = dp[i-1][j] || dp[i][j-1]; return dp[m][n]; &#125;&#125;; 更新迭代公式解释： https://discuss.leetcode.com/topic/7266/c-dp-solution/2 Equation 1). means that if p[j-1] is not *, f(i,j) is determined by if s[0:i-2] matches p[0:j-2] and if (s[i-1]==p[j-1] or p[j-1]==’?’). Equation 2). means that if p[j-1] is , f(i,j) is true if either f(i,j-1) is true: s[0:i-1] matches p[0:j-2] and is not used here; or f(i-1,j) is true: s[0:i-2] matches p[0:j-1] and * is used to match s[i-1]. https://discuss.leetcode.com/topic/17901/accepted-c-dp-solution-with-a-trick Accepted C++ DP Solution with a Trick 1312ms, 28.41%, September 22, 2016 Updated: Since the OJ has relaxed the time constraint, the following DP solution is now accepted without the trick :-) Well, so many people has tried to solve this problem using DP. And almost all of them get TLE (if you see a C++ DP solution that gets accepted, please let me know ^_^). Well, this post aims at providing an accpted DP solution which uses a trick to get around the largest test case, insteaed of a solution that is fully correct. So please do not give me down votes for that :-) Let’s briefly summarize the idea of DP. We define the state P[i][j] to be whether s[0..i) matches p[0..j). The state equations are as follows: 121. P[i][j] = P[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;?&apos;), if p[j - 1] != &apos;*&apos;;2. P[i][j] = P[i][j - 1] || P[i - 1][j], if p[j - 1] == &apos;*&apos;. If you feel confused with the second equation, you may refer to this link. There is an explanation in the comments. We optimize the DP code to O(m) space by recording P[i - 1][j - 1] using a single variable pre. The trick to avoid TLE is to hard-code the result for the largest test case by 1if (n &gt; 30000) return false; The complete code is as follows. 123456789101112131415161718192021class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(), n = p.length(); if (n &gt; 30000) return false; // the trick vector&lt;bool&gt; cur(m + 1, false); cur[0] = true; for (int j = 1; j &lt;= n; j++) &#123; bool pre = cur[0]; // use the value before update cur[0] = cur[0] &amp;&amp; p[j - 1] == &apos;*&apos;; for (int i = 1; i &lt;= m; i++) &#123; bool temp = cur[i]; // record the value before update if (p[j - 1] != &apos;*&apos;) cur[i] = pre &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;?&apos;); else cur[i] = cur[i - 1] || cur[i]; pre = temp; &#125; &#125; return cur[m]; &#125;&#125;; 方法三: For those interested in a fully correct solution, this link has a nice Greedy solution. And I have rewritten the code below to fit the new C++ interface (changed from char* to string). 123456789101112131415161718192021222324class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(), n = p.length(); int i = 0, j = 0, asterisk = -1, match; while (i &lt; m) &#123; if (j &lt; n &amp;&amp; p[j] == &apos;*&apos;) &#123; match = i; asterisk = j++; &#125; else if (j &lt; n &amp;&amp; (s[i] == p[j] || p[j] == &apos;?&apos;)) &#123; i++; j++; &#125; else if (asterisk &gt;= 0) &#123; i = ++match; j = asterisk + 1; &#125; else return false; &#125; while (j &lt; n &amp;&amp; p[j] == &apos;*&apos;) j++; return j == n; &#125;&#125;; https://discuss.leetcode.com/topic/21577/my-three-c-solutions-iterative-16ms-dp-180ms-modified-recursion-88ms My three C++ solutions (iterative (16ms) &amp; DP (180ms) &amp; modified recursion (88ms)) The reason that the iterative solution is much faster for this case is we only need to save (and deal with) the positions (iStar for s, jStar for p) of the last “” we met. We only need to do traceback using iStar and jStar and all the previous “” can be ignored since the last “” will cover all the traceback cases for the previous “”.What we need to do are if the current p character is ‘’ (i.e. p[j]==’’), then we update iStar and jStar with the cureent i and j values. iStar/jStar will be used for traceback. Also we do –i to start the depth first search with the case that ‘*’ represents a null string. if p[j]!=’’, then we check if mismatch occurs (i.e. p[j]!=s[i] and p[j]!=’?’), if so we check if we met a ‘’ before (iStar&gt;=0), if not, then we return false since no match can achieve. Otherwise, we traceback to the positions at which the last ‘*’ happens and do the next possible dfs search (i.e. i = iStar++; j = jStar; remember to update iStar too to save the i position to try in the next traceback). The loop will quit when we reach the end of s. At last, we need to skip all the ‘*’ in p to see if we can reach the end of p. if so, match, otherwise mismatch 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool isMatch(string s, string p) &#123; int slen = s.size(), plen = p.size(), i, j, iStar=-1, jStar=-1; for(i=0,j=0 ; i&lt;slen; ++i, ++j) &#123; if(p[j]==&apos;*&apos;) &#123; //meet a new &apos;*&apos;, update traceback i/j info iStar = i; jStar = j; --i; &#125; else &#123; if(p[j]!=s[i] &amp;&amp; p[j]!=&apos;?&apos;) &#123; // mismatch happens if(iStar &gt;=0) &#123; // met a &apos;*&apos; before, then do traceback i = iStar++; j = jStar; &#125; else return false; // otherwise fail &#125; &#125; &#125; while(p[j]==&apos;*&apos;) ++j; return j==plen; &#125;&#125;; A DP solution is also given here. It has O(N^2) time complexity and O(N) space 12345678910111213141516171819class Solution &#123;public: bool isMatch(string s, string p) &#123; int pLen = p.size(), sLen = s.size(), i, j, k, cur, prev; if(!pLen) return sLen == 0; bool matched[2][sLen+1]; fill_n(&amp;matched[0][0], 2*(sLen+1), false); matched[0][0] = true; for(i=1; i&lt;=pLen; ++i) &#123; cur = i%2, prev= 1-cur; matched[cur][0]= matched[prev][0] &amp;&amp; p[i-1]==&apos;*&apos;; if(p[i-1]==&apos;*&apos;) for(j=1; j&lt;=sLen; ++j) matched[cur][j] = matched[cur][j-1] || matched[prev][j]; else for(j=1; j&lt;=sLen; ++j) matched[cur][j] = matched[prev][j-1] &amp;&amp; (p[i-1]==&apos;?&apos; || p[i-1]==s[j-1]) ; &#125; return matched[cur][sLen]; &#125;&#125;; A recursion version. A typical recursion version will give us TLE due to too many unnecessary recursive calls. As we explained, all the traceback recursive calls at the ‘’ we met (except the last ‘’) are unneccessary and should be avoided. In the below version, we use recLevel to track the recursion level (i.e the total ‘’ we met) and we also use curLevel to save the order of ‘’ we currently process. If it is not the last ‘’ we met (i.e if(recLevel&gt;curLevel+1) ), then we will return false directly ( if(recLevel&gt;curLevel+1) return false;) to skip all unneccessary recursion call at the ‘’ before the last ‘*’. 12345678910111213141516171819202122232425262728class Solution &#123;private: bool helper(const string &amp;s, const string &amp;p, int si, int pi, int &amp;recLevel) &#123; int sSize = s.size(), pSize = p.size(), i, curLevel = recLevel; bool first=true; while(si&lt;sSize &amp;&amp; (p[pi]==s[si] || p[pi]==&apos;?&apos;)) &#123;++pi; ++si;&#125; //match as many as possible if(pi == pSize) return si == sSize; // if p reaches the end, return if(p[pi]==&apos;*&apos;) &#123; // if a star is met while(p[++pi]==&apos;*&apos;); //skip all the following stars if(pi&gt;=pSize) return true; // if the rest of p are all star, return true for(i=si; i&lt;sSize; ++i) &#123; // then do recursion if(p[pi]!= &apos;?&apos; &amp;&amp; p[pi]!=s[i]) continue; if(first) &#123;++recLevel; first = false;&#125; if(helper(s, p, i, pi, recLevel)) return true; if(recLevel&gt;curLevel+1) return false; // if the currently processed star is not the last one, return &#125; &#125; return false; &#125;public: bool isMatch(string s, string p) &#123; int recLevel = 0; return helper(s, p, 0, 0, recLevel); &#125;&#125;; https://discuss.leetcode.com/topic/7266/c-dp-solution C++ DP solution It seems that only Greedy solution can pass all test cases (sorry if I omit any DP solution that passes all test cases). My DP solution also fails to pass the s=aaaaaaaaaaaaaa………….. (lots of a’s…). However, despite this very large case my DP solution passes all other cases. The idea is: f(i,j) == whether the first i chars of s match the first j chars of p. The transition equation is: 1231). if(p[j-1]!=&apos;*&apos;) f(i, j) = f(i-1, j-1) &amp;&amp; (s[i-1]==p[j-1] || p[j-1]==&apos;?&apos;)2). if(p[j-1]==&apos;*&apos;) f(i, j) = f(i, j-1) || f(i-1, j) 12345678910111213141516171819202122bool isMatch(const char *s, const char *p) &#123; const int m = strlen(s); const int n = strlen(p); if(m&gt;30000) return false; // to skip the large test case vector&lt;bool&gt; prev(n+1,false); // to save space, just O(n) space is used prev[0]=true; for(int j=1; j&lt;=n; j++) prev[j] = prev[j-1] &amp;&amp; p[j-1]==&apos;*&apos;; for(int i=1; i&lt;=m; i++) &#123; vector&lt;bool&gt; cur(n+1,false); for(int j=1; j&lt;=n; j++) &#123; if(p[j-1]==&apos;*&apos;) &#123; cur[j] = cur[j-1] || prev[j]; &#125; else &#123; cur[j] = prev[j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]==&apos;?&apos;); &#125; &#125; prev = cur; &#125; return prev[n];&#125; 12345678Equation 1). means that if p[j-1] is not *, f(i,j) is determinedby if s[0:i-2] matches p[0:j-2] and if (s[i-1]==p[j-1] orp[j-1]==&apos;?&apos;).Equation 2). means that if p[j-1] is *, f(i,j) is true if eitherf(i,j-1) is true: s[0:i-1] matches p[0:j-2] and * is not usedhere; or f(i-1,j) is true: s[0:i-2] matches p[0:j-1] and * isused to match s[i-1]. my code: 1234567891011121314class Solution &#123;public: bool isMatch(string s, string p) &#123; int m=0, n=0, match=0, startIdx=-1; while(m&lt;s.size())&#123; if(n&lt;p.size() &amp;&amp; (p[n]==&apos;?&apos; || p[n]==s[m]))&#123;m++; n++;&#125; else if(n&lt;p.size() &amp;&amp; p[n]==&apos;*&apos;)&#123;startIdx=n; match=m; n++;&#125; else if(startIdx!=-1)&#123;n=startIdx+1; match++; m=match;&#125; else return false; &#125; while(n&lt;p.size() &amp;&amp; p[n]==&apos;*&apos;) n++; return n==p.size(); &#125;&#125;; python https://discuss.leetcode.com/topic/9350/python-dp-solution Python DP solution 12345678910111213141516class Solution:# @return a booleandef isMatch(self, s, p): length = len(s) if len(p) - p.count(&apos;*&apos;) &gt; length: return False dp = [True] + [False]*length for i in p: if i != &apos;*&apos;: for n in reversed(range(length)): dp[n+1] = dp[n] and (i == s[n] or i == &apos;?&apos;) else: for n in range(1, length+1): dp[n] = dp[n-1] or dp[n] dp[0] = dp[0] and i == &apos;*&apos; return dp[-1] dp[n] means the substring s[:n] if match the pattern i dp[0] means the empty string ‘’ or s[:0] which only match the pattern ‘*’ use the reversed builtin because for every dp[n+1] we use the previous ‘dp’ add Java O(m*n) version code 1234567891011121314151617181920212223public boolean isMatch(String s, String p) &#123; int count = 0; for (char c : p.toCharArray()) &#123; if (c == &apos;*&apos;) count++; &#125; if (p.length() - count &gt; s.length()) return false; boolean[][] dp = new boolean[p.length() + 1][s.length() + 1]; dp[0][0] = true; for (int j = 1; j &lt;= p.length(); j++) &#123; char pattern = p.charAt(j - 1); dp[j][0] = dp[j - 1][0] &amp;&amp; pattern == &apos;*&apos;; for (int i = 1; i &lt;= s.length(); i++) &#123; char letter = s.charAt(i - 1); if (pattern != &apos;*&apos;) &#123; dp[j][i] = dp[j - 1][i - 1] &amp;&amp; (pattern == &apos;?&apos; || pattern == letter); &#125; else dp[j][i] = dp[j][i - 1] || dp[j - 1][i]; &#125; &#125; return dp[p.length()][s.length()];&#125; java http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html 123456789101112131415161718192021Analysis:For each element in sIf *s==*p or *p == ? which means this is a match, then goes to next element s++ p++.If p=='*', this is also a match, but one or many chars may be available, so let us save this *'s position and the matched s position.If not match, then we check if there is a * previously showed up, if there is no *, return false; if there is an *, we set current p to the next element of *, and set current s to the next saved s position.e.g.abed?b*d**a=?, go on, b=b, go on,e=*, save * position star=3, save s position ss = 3, p++e!=d, check if there was a *, yes, ss++, s=ss; p=star+1d=d, go on, meet the end.check the rest element in p, if all are *, true, else false;Note that in char array, the last is NOT NULL, to check the end, use "*p" or "*p=='\0'". https://discuss.leetcode.com/topic/3040/linear-runtime-and-constant-space-solution 60ms, 60.11%, September 22, 2016 1234567891011121314151617181920212223242526public class Solution &#123; public boolean isMatch(String str, String pattern) &#123; int s=0, p=0, match=0, starIdx=-1; while(s&lt;str.length())&#123; if(p&lt;pattern.length() &amp;&amp; (pattern.charAt(p)==&apos;?&apos; || str.charAt(s)==pattern.charAt(p)))&#123; s++; p++; &#125; else if(p&lt;pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;)&#123; starIdx = p; match = s; p++; &#125; else if(starIdx!=-1)&#123; p = starIdx + 1; match++; s = match; &#125; else return false; &#125; while(p&lt;pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;) p++; return p == pattern.length(); &#125;&#125; https://discuss.leetcode.com/topic/3040/linear-runtime-and-constant-space-solution Linear runtime and constant space solution I found this solution from http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html The basic idea is to have one pointer for the string and one pointer for the pattern. This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step. Here is Yu’s elegant solution in C++ 12345678910111213141516171819202122232425bool isMatch(const char *s, const char *p) &#123; const char* star=NULL; const char* ss=s; while (*s)&#123; //advancing both pointers when (both characters match) or (&apos;?&apos; found in pattern) //note that *p will not advance beyond its length if ((*p==&apos;?&apos;)||(*p==*s))&#123;s++;p++;continue;&#125; // * found in pattern, track index of *, only advancing pattern pointer if (*p==&apos;*&apos;)&#123;star=p++; ss=s;continue;&#125; //current characters didn&apos;t match, last pattern pointer was *, current pattern pointer is not * //only advancing pattern pointer if (star)&#123; p = star+1; s=++ss;continue;&#125; //current pattern pointer is not star, last patter pointer was not * //characters do not match return false; &#125; //check for remaining characters in pattern while (*p==&apos;*&apos;)&#123;p++;&#125; return !*p; &#125; Here is my re-write in Java 12345678910111213141516171819202122232425262728293031boolean comparison(String str, String pattern) &#123; int s = 0, p = 0, match = 0, starIdx = -1; while (s &lt; str.length())&#123; // advancing both pointers if (p &lt; pattern.length() &amp;&amp; (pattern.charAt(p) == &apos;?&apos; || str.charAt(s) == pattern.charAt(p)))&#123; s++; p++; &#125; // * found, only advancing pattern pointer else if (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;)&#123; starIdx = p; match = s; p++; &#125; // last pattern pointer was *, advancing string pointer else if (starIdx != -1)&#123; p = starIdx + 1; match++; s = match; &#125; //current pattern pointer is not star, last patter pointer was not * //characters do not match else return false; &#125; //check for remaining characters in pattern while (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;) p++; return p == pattern.length();&#125; my code： 12345678910111213public class Solution &#123; public boolean isMatch(String s, String p) &#123; int m=0, n=0, match=0, startIdx=-1; while(m&lt;s.length())&#123; if(n&lt;p.length() &amp;&amp; (s.charAt(m)==p.charAt(n) || p.charAt(n)==&apos;?&apos;))&#123;m++; n++;&#125; else if(n&lt;p.length() &amp;&amp; p.charAt(n)==&apos;*&apos;)&#123;startIdx=n; match=m; n++;&#125; else if(startIdx!=-1)&#123;match++; m=match; n=startIdx+1;&#125; else return false; &#125; while(n&lt;p.length() &amp;&amp; p.charAt(n)==&apos;*&apos;)&#123;n++;&#125; return n==p.length(); &#125;&#125; https://discuss.leetcode.com/topic/22516/my-java-dp-solution-using-2d-table My java DP solution using 2D table 1234567891011121314151617181920212223public class Solution &#123; public boolean isMatch(String s, String p) &#123; boolean[][] match=new boolean[s.length()+1][p.length()+1]; match[s.length()][p.length()]=true; for(int i=p.length()-1;i&gt;=0;i--)&#123; if(p.charAt(i)!=&apos;*&apos;) break; else match[s.length()][i]=true; &#125; for(int i=s.length()-1;i&gt;=0;i--)&#123; for(int j=p.length()-1;j&gt;=0;j--)&#123; if(s.charAt(i)==p.charAt(j)||p.charAt(j)==&apos;?&apos;) match[i][j]=match[i+1][j+1]; else if(p.charAt(j)==&apos;*&apos;) match[i][j]=match[i+1][j]||match[i][j+1]; else match[i][j]=false; &#125; &#125; return match[0][0]; &#125;&#125; https://discuss.leetcode.com/topic/10794/my-java-dp-solution My Java DP Solution At first I cannot pass the the long ‘aaa…’ test case. Then I add more check and pass it. 123456789101112131415161718192021222324252627282930public class Solution &#123; public boolean isMatch(String s, String p) &#123; int m = s.length(), n = p.length(); int count = 0; for (int i = 0; i &lt; n; i++) &#123; if (p.charAt(i) == &apos;*&apos;) count++; &#125; if (count==0 &amp;&amp; m != n) return false; else if (n - count &gt; m) return false; boolean[] match = new boolean[m+1]; match[0] = true; for (int i = 0; i &lt; m; i++) &#123; match[i+1] = false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (p.charAt(i) == &apos;*&apos;) &#123; for (int j = 0; j &lt; m; j++) &#123; match[j+1] = match[j] || match[j+1]; &#125; &#125; else &#123; for (int j = m-1; j &gt;= 0; j--) &#123; match[j+1] = (p.charAt(i) == &apos;?&apos; || p.charAt(i) == s.charAt(j)) &amp;&amp; match[j]; &#125; match[0] = false; &#125; &#125; return match[m]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[043. Multiply Strings]]></title>
    <url>%2Fp%2Fd81212f5%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/multiply-strings/ Given two numbers represented as strings, return multiplication of the numbers as a string. Note: The numbers can be arbitrarily large and are non-negative. Converting the input string to integer is NOT allowed. You should NOT use internal library such as BigInteger. cpp 6ms, September 19, 2016 https://discuss.leetcode.com/topic/9449/brief-c-solution-using-only-strings-and-without-reversal Brief C++ solution using only strings and without reversal This is the standard manual multiplication algorithm. We use two nested for loops, working backward from the end of each input number. We pre-allocate our result and accumulate our partial result in there. One special case to note is when our carry requires us to write to our sum string outside of our for loop. At the end, we trim any leading zeros, or return 0 if we computed nothing but zeros. 123456789101112131415161718192021class Solution &#123;public: string multiply(string num1, string num2) &#123; string sum(num1.size() + num2.size(), &apos;0&apos;); for(int i = num1.size()-1; i &gt;= 0; --i)&#123; int carry = 0; for(int j = num2.size() - 1; j&gt;=0; --j)&#123; int tmp = (sum[i+j+1] -&apos;0&apos;) + (num1[i] - &apos;0&apos;)*(num2[j] - &apos;0&apos;) + carry; sum[i+j+1] = tmp%10 + &apos;0&apos;; carry = tmp/10; &#125; sum[i] += carry; &#125; size_t startpos = sum.find_first_not_of(&quot;0&quot;); if(string::npos!=startpos) return sum.substr(startpos); return &quot;0&quot;; &#125;&#125;; https://discuss.leetcode.com/topic/3456/one-easy-solution-with-c One Easy solution with C++ The key part is to use a vector to store all digits REVERSELY. after the calculation, find the rightmost NON-Zero digits and convert it to a string. 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: string multiply(string num1, string num2) &#123; unsigned int l1=num1.size(),l2=num2.size(); if (l1==0||l2==0) return &quot;0&quot;; vector&lt;int&gt; v(l1+l2,0); for (unsigned int i=0;i&lt;l1;i++)&#123; int carry=0; int n1=(int)(num1[l1-i-1]-&apos;0&apos;);//Calculate from rightmost to left for (unsigned int j=0;j&lt;l2;j++)&#123; int n2=(num2[l2-j-1]-&apos;0&apos;);//Calculate from rightmost to left int sum=n1*n2+v[i+j]+carry; carry=sum/10; v[i+j]=sum%10; &#125; if (carry&gt;0) v[i+l2]+=carry; &#125; int start=l1+l2-1; while(v[start]==0) start--; if (start==-1) return &quot;0&quot;; string s=&quot;&quot;; for (int i=start;i&gt;=0;i--) s+=(char)(v[i]+&apos;0&apos;); return s; &#125;&#125;; https://discuss.leetcode.com/topic/8500/very-concise-16-ms-c-solution Very concise 16 ms c++ solution See comments inline for explanation. 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string multiply(string num1, string num2) &#123; int i, j; int m = num1.size(), n = num2.size(); // max (m + n) digits vector&lt;int&gt; product(m + n, 0); string result; // reverse for ease of calc reverse(num1.begin(), num1.end()); reverse(num2.begin(), num2.end()); // digit i * digit j contributes to digit i + j for (i = 0; i &lt; m; i++) &#123; for (j = 0; j &lt; n; j++) &#123; product[i + j] += (num1[i] - &apos;0&apos;) * (num2[j] - &apos;0&apos;); product[i + j + 1] += product[i + j] / 10; product[i + j] %= 10; &#125; &#125; // remove leading 0; keep last 0 if all 0 for (i = m + n - 1; i &gt; 0 &amp;&amp; 0 == product[i]; i--) ; for (; i &gt;= 0; i--) result += to_string(product[i]); return result; &#125;&#125;; python 59ms, September 19, 2016 My solution 12345678class Solution(object): def multiply(self, num1, num2): &quot;&quot;&quot; :type num1: str :type num2: str :rtype: str &quot;&quot;&quot; return str(int(num1)*int(num2)) https://discuss.leetcode.com/topic/20883/simple-python-solution-18-lines Simple Python solution, 18 lines123456789101112131415161718def multiply(num1, num2): product = [0] * (len(num1) + len(num2)) pos = len(product)-1 for n1 in reversed(num1): tempPos = pos for n2 in reversed(num2): product[tempPos] += int(n1) * int(n2) product[tempPos-1] += product[tempPos]/10 product[tempPos] %= 10 tempPos -= 1 pos -= 1 pt = 0 while pt &lt; len(product)-1 and product[pt] == 0: pt += 1 return &apos;&apos;.join(map(str, product[pt:])) java 31ms, September 19, 2016 https://discuss.leetcode.com/topic/30508/easiest-java-solution-with-graph-explanation Easiest JAVA Solution with Graph Explanation Remember how we do multiplication? Start from right to left, perform multiplication on every pair of digits, and add them together. Let’s draw the process! From the following draft, we can immediately conclude: 1`num1[i] * num2[j]` will be placed at indices `[i + j`, `i + j + 1]` Here is my solution. Hope it helps! 123456789101112131415161718192021public class Solution &#123; public String multiply(String num1, String num2) &#123; int m = num1.length(), n = num2.length(); int[] pos = new int[m+n]; for(int i = m-1; i &gt;= 0; i--)&#123; for(int j = n-1; j&gt;=0; j--)&#123; int mul = (num1.charAt(i)-&apos;0&apos;) * (num2.charAt(j) -&apos;0&apos;); int p1 = i+j, p2 = i+j+1; int sum = mul + pos[p2]; pos[p1] += sum/10; pos[p2] = sum % 10; &#125; &#125; StringBuilder sb = new StringBuilder(); for(int p:pos) if(!(sb.length()==0 &amp;&amp; p==0)) sb.append(p); return sb.length() == 0?&quot;0&quot;:sb.toString(); &#125;&#125; https://discuss.leetcode.com/topic/13026/ac-solution-in-java-with-explanation AC solution in Java with explanation 1234567891011121314151617181920212223public class Solution &#123; public String multiply(String num1, String num2) &#123; int n1 = num1.length(), n2 = num2.length(); int[] products = new int[n1 + n2]; for (int i = n1 - 1; i &gt;= 0; i--) &#123; for (int j = n2 - 1; j &gt;= 0; j--) &#123; int d1 = num1.charAt(i) - &apos;0&apos;; int d2 = num2.charAt(j) - &apos;0&apos;; products[i + j + 1] += d1 * d2; &#125; &#125; int carry = 0; for (int i = products.length - 1; i &gt;= 0; i--) &#123; int tmp = (products[i] + carry) % 10; carry = (products[i] + carry) / 10; products[i] = tmp; &#125; StringBuilder sb = new StringBuilder(); for (int num : products) sb.append(num); while (sb.length() != 0 &amp;&amp; sb.charAt(0) == &apos;0&apos;) sb.deleteCharAt(0); return sb.length() == 0 ? &quot;0&quot; : sb.toString(); &#125;&#125; If we break it into steps, it will have the following steps. 1. compute products from each pair of digits from num1 and num2. 2. carry each element over. 3. output the solution. Things to note: The product of two numbers cannot exceed the sum of the two lengths. (e.g. 99 * 99 cannot be five digit) 123int d1 = num1.charAt(i) - &apos;0&apos;;int d2 = num2.charAt(j) - &apos;0&apos;;products[i + j + 1] += d1 * d2; https://discuss.leetcode.com/topic/10757/clear-java-solution-without-reversal Clear JAVA solution without reversal 123456789101112131415161718192021public String multiply(String num1, String num2) &#123; int len1 = num1.length(); int len2 = num2.length(); int[] product = new int[len1 + len2]; for (int i = len1 - 1; i &gt;= 0; i--) &#123; for (int j = len2 - 1; j &gt;= 0; j--) &#123; int index = len1 + len2 - i - j - 2; product[index] += (num1.charAt(i) - &apos;0&apos;) * (num2.charAt(j) - &apos;0&apos;); product[index + 1] += product[index] / 10; product[index] %= 10; &#125; &#125; StringBuilder stringBuilder = new StringBuilder(); for (int i = product.length - 1; i &gt; 0; i--) &#123; if (stringBuilder.length() == 0 &amp;&amp; product[i] == 0) continue; stringBuilder.append(product[i]); &#125; stringBuilder.append(product[0]); return stringBuilder.toString();&#125; https://discuss.leetcode.com/topic/21008/simple-clear-java-solution Simple &amp;&amp; clear java solution 12345678910111213141516171819202122232425public class Solution &#123; public String multiply(String num1, String num2) &#123; int len1 = num1.length(); int len2 = num2.length(); int len = len1 + len2; int[] mul = new int[len]; for (int i = len1 - 1; i &gt;= 0; i--) &#123; int a = num1.charAt(i) - &apos;0&apos;; int k = len2 + i; for (int j = len2 - 1; j &gt;= 0; j--) &#123; int b = num2.charAt(j) - &apos;0&apos;; int c = mul[k] + a * b; mul[k] = c % 10; mul[k - 1] = mul[k - 1] + c /10; k--; &#125; &#125; int i = 0; while(mul[i] == 0 &amp;&amp; i &lt; len - 1) i++; StringBuilder sb = new StringBuilder(); for (; i &lt; len; i++) sb.append(mul[i]); return sb.length() == 0 ? &quot;0&quot; : sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[042. Trapping Rain Water]]></title>
    <url>%2Fp%2F33f3f22a%2F</url>
    <content type="text"><![CDATA[36.7% https://leetcode.com/problems/trapping-rain-water/ Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. 12For example, Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! 方法一： https://discuss.leetcode.com/topic/5125/sharing-my-simple-c-code-o-n-time-o-1-space Sharing my simple c++ code: O(n) time, O(1) space Here is my idea: instead of calculating area by height*width, we can think it in a cumulative way. In other words, sum water amount of each bin(width=1). Search from left to right and maintain a max height of left and right separately, which is like a one-side wall of partial container. Fix the higher one and flow water from the lower part. For example, if current height of left is lower, we fill water in the left bin. Until left meets right, we filled the whole container. 123456789101112131415161718192021class Solution &#123;public: int trap(int A[], int n) &#123; int left=0; int right=n-1; int res=0; int maxleft=0, maxright=0; while(left&lt;=right)&#123; if(A[left]&lt;=A[right])&#123; if(A[left]&gt;=maxleft) maxleft=A[left]; else res+=maxleft-A[left]; left++; &#125; else&#123; if(A[right]&gt;=maxright) maxright= A[right]; else res+=maxright-A[right]; right--; &#125; &#125; return res; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if(n&lt;=1) return 0; int left=0, right=n-1; int maxleft = 0, maxright=0; int res = 0; while(left&lt;right)&#123; if(height[left]&lt;=height[right])&#123; if(height[left]&gt;maxleft) maxleft = height[left]; else res += maxleft - height[left]; left++; &#125;else&#123; if(height[right] &gt; maxright) maxright = height[right]; else res += maxright - height[right]; right--; &#125; &#125; return res; &#125;&#125;; 方法二： 三次遍历。 第一次遍历，查看当前位置i的从左侧看，左侧的挡板的最大值。第二次从右边向左遍历。 第三天遍历，计算当前位置有的水。 https://discuss.leetcode.com/topic/4136/a-different-o-n-approach-easy-to-understand-and-simple-code A different O(n) approach - easy to understand and simple code 123456789101112131415class Solution &#123;public: int trap(int a[], int n) &#123; int i, res = 0; if(!n) return res; vector&lt;int&gt; ltr(n, 0), rtl(n, 0); for(i = 1, ltr[0] = a[0]; i &lt; n; i++) ltr[i] = max(ltr[i-1], a[i]); for(i = n - 2, rtl[n-1] = a[n-1]; i &gt;= 0; i--) rtl[i] = max(rtl[i+1], a[i]); for(i = 0; i &lt; n; i++) res += min(ltr[i], rtl[i]) - a[i]; return res; &#125;&#125;; observation: scan A both from left to right and right to left, record the largest seen during the scan; then for each position the water level should be the min of the 2 large value. 我的代码实现： 12345678910111213141516171819class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if(n&lt;=1) return 0; vector&lt;int&gt; ltr(n, 0); vector&lt;int&gt; rtr(n, 0); int res = 0; ltr[0] = height[0]; for(int i=1; i&lt;n; i++) ltr[i] = max(ltr[i-1], height[i]); rtr[n-1] = height[n-1]; for(int j=n-2; j&gt;=0; j--) rtr[j] = max(rtr[j+1], height[j]); for(int k=0; k&lt;n; k++) res += min(ltr[k], rtr[k]) - height[k]; return res; &#125;&#125;; 官方解答 https://leetcode.com/articles/trapping-rain-water/#approach-3-using-stacks-accepted https://discuss.leetcode.com/topic/18731/7-lines-c-c 7 lines C / C++ Keep track of the already safe level and the total water so far. In each step, process and discard the lower one of the leftmost or rightmost elevation. C Changing the given parameters to discard the lower border. I’m quite fond of this one. 123456789int trap(int* height, int n) &#123; int level = 0, water = 0; while (n--) &#123; int lower = *height &lt; height[n] ? *height++ : height[n]; if (lower &gt; level) level = lower; water += level - lower; &#125; return water;&#125; Slight variation with two pointers (left and right). 123456789int trap(int* height, int n) &#123; int *L = height, *R = L+n-1, level = 0, water = 0; while (L &lt; R) &#123; int lower = *L &lt; *R ? *L++ : *R--; if (lower &gt; level) level = lower; water += level - lower; &#125; return water;&#125; C++ With left and right index. 123456789int trap(vector&lt;int&gt;&amp; height) &#123; int l = 0, r = height.size()-1, level = 0, water = 0; while (l &lt; r) &#123; int lower = height[height[l] &lt; height[r] ? l++ : r--]; level = max(level, lower); water += level - lower; &#125; return water;&#125; With left and right iterator. 12345678910int trap(vector&lt;int&gt;&amp; height) &#123; auto l = height.begin(), r = height.end() - 1; int level = 0, water = 0; while (l != r + 1) &#123; int lower = *l &lt; *r ? *l++ : *r--; level = max(level, lower); water += level - lower; &#125; return water;&#125; python https://discuss.leetcode.com/topic/18720/8-lines-c-c-java-python-solution 8-lines C/C++/Java/Python Solution Note: The following idea is in fact from the last answer in this link, which leads to a clean code. I just reorganize it and add some explanations. I hope it is Ok. The following are four solutions in C/C++/Java/Python respectively. The basic idea is that we set two pointers l and r to the left and right end of height. Then we get the minimum height (minHeight) of these pointers (similar to Container with Most Water due to the Leaking Bucket Effect) since the level of the water cannot be higher than it. Then we move the two pointers towards the center. If the coming level is less than minHeight, then it will hold some water. Fill the water until we meet some “barrier” (with height larger than minHeight) and update l and r to repeat this process in a new interval. C 1234567891011int trap(int* height, int heightSize) &#123; int l = 0, r = heightSize - 1, water = 0, minHeight = 0; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; height[l] &lt;= minHeight) water += minHeight - height[l++]; while (r &gt; l &amp;&amp; height[r] &lt;= minHeight) water += minHeight - height[r--]; minHeight = height[l] &lt;= height[r] ? height[l] : height[r]; &#125; return water;&#125; C++ 1234567891011121314class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(), l = 0, r = n - 1, water = 0, minHeight = 0; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; height[l] &lt;= minHeight) water += minHeight - height[l++]; while (r &gt; l &amp;&amp; height[r] &lt;= minHeight) water += minHeight - height[r--]; minHeight = min(height[l], height[r]); &#125; return water; &#125;&#125;; Java 12345678910111213public class Solution &#123; public int trap(int[] height) &#123; int n = height.length, l = 0, r = n - 1, water = 0, minHeight = 0; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; height[l] &lt;= minHeight) water += minHeight - height[l++]; while (r &gt; l &amp;&amp; height[r] &lt;= minHeight) water += minHeight - height[r--]; minHeight = Math.min(height[l], height[r]); &#125; return water; &#125;&#125; Python 123456789101112131415class Solution: # @param &#123;integer[]&#125; height # @return &#123;integer&#125; def trap(self, height): n = len(height) l, r, water, minHeight = 0, n - 1, 0, 0 while l &lt; r: while l &lt; r and height[l] &lt;= minHeight: water += minHeight - height[l] l += 1 while r &gt; l and height[r] &lt;= minHeight: water += minHeight - height[r] r -= 1 minHeight = min(height[l], height[r]) return water java https://discuss.leetcode.com/topic/3016/share-my-short-solution Share my short solution. Keep track of the maximum height from both forward directions backward directions, call them leftmax and rightmax. 1234567891011121314151617181920public int trap(int[] A)&#123; int a=0; int b=A.length-1; int max=0; int leftmax=0; int rightmax=0; while(a&lt;=b)&#123; leftmax=Math.max(leftmax,A[a]); rightmax=Math.max(rightmax,A[b]); if(leftmax&lt;rightmax)&#123; max+=(leftmax-A[a]); // leftmax is smaller than rightmax, so the (leftmax-A[a]) water can be stored a++; &#125; else&#123; max+=(rightmax-A[b]); b--; &#125; &#125; return max;&#125; 2ms, 20.31%, June.18th, 2016 https://leetcode.com/discuss/18022/sharing-my-java-code-o-n-time-o-1-space 12345678910111213141516171819202122public class Solution &#123; public int trap(int[] height) &#123; if(height.length &lt; 3) return 0; int ans = 0; int l = 0, r = height.length - 1; while(l &lt; r &amp;&amp; height[l] &lt; height[l+1]) l++; while(l &lt; r &amp;&amp; height[r] &lt; height[r-1]) r--; while(l &lt; r)&#123; int left = height[l]; int right = height[r]; if(left &lt;= right)&#123; while(l &lt; r &amp;&amp; left &gt; height[++l]) ans += left - height[l]; &#125;else&#123; while(l &lt; r &amp;&amp; right &gt; height[--r]) ans += right - height[r]; &#125; &#125; return ans; &#125;&#125; https://discuss.leetcode.com/topic/4939/a-stack-based-solution-for-reference-inspired-by-histogram A stack based solution for reference, inspired by Histogram Indeed this question can be solved in one pass and O(1) space, but it’s probably hard to come up with in a short interview. If you have read the stack O(n) solution for Largest Rectangle in Histogram, you will find this solution is very very similar. The main idea is : if we want to find out how much water on a bar(bot), we need to find out the left larger bar’s index (il), and right larger bar’s index(ir), so that the water is (min(A[il],A[ir])-A[bot])*(ir-il-1), use min since only the lower boundary can hold water, and we also need to handle the edge case that there is no il. To implement this we use a stack that store the indices with decreasing bar height, once we find a bar who’s height is larger, then let the top of the stack be bot, the cur bar is ir, and the previous bar is il. 1234567891011121314151617public int trap(int[] A) &#123; if (A==null) return 0; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int i = 0, maxWater = 0, maxBotWater = 0; while (i &lt; A.length)&#123; if (s.isEmpty() || A[i]&lt;=A[s.peek()])&#123; s.push(i++); &#125; else &#123; int bot = s.pop(); maxBotWater = s.isEmpty()? // empty means no il 0:(Math.min(A[s.peek()],A[i])-A[bot])*(i-s.peek()-1); maxWater += maxBotWater; &#125; &#125; return maxWater; &#125; https://discuss.leetcode.com/topic/5819/sharing-my-java-code-o-n-time-o-1-space Sharing my Java code: O(n) time, O(1) space 123456789101112131415161718192021222324252627public int trap(int[] A) &#123; if (A.length &lt; 3) return 0; int ans = 0; int l = 0, r = A.length - 1; // find the left and right edge which can hold water while (l &lt; r &amp;&amp; A[l] &lt;= A[l + 1]) l++; while (l &lt; r &amp;&amp; A[r] &lt;= A[r - 1]) r--; while (l &lt; r) &#123; int left = A[l]; int right = A[r]; if (left &lt;= right) &#123; // add volum until an edge larger than the left edge while (l &lt; r &amp;&amp; left &gt;= A[++l]) &#123; ans += left - A[l]; &#125; &#125; else &#123; // add volum until an edge larger than the right volum while (l &lt; r &amp;&amp; A[--r] &lt;= right) &#123; ans += right - A[r]; &#125; &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/7612/java-10-lines-accepted-code-o-n-time-o-1-space-is-there-a-better-solution JAVA 10 lines accepted code, O(n) time, O(1) space. Is there a better solution? Basically this solution runs two pointers from two sides to the middle, and the plank is used to record the height of the elevation within a certain range, plank height can only increase (or remain the same) from two sides to the middle. If the current pointer is pointing at a number that is less than the current plank height, the difference between plank height and the number would be the amount of water trapped. Otherwise, A[i] == plank, no water is trapped. 12345678910public class Solution &#123; public int trap(int[] A) &#123; int i = 0, j = A.length - 1, result = 0, plank = 0; while(i &lt;= j)&#123; plank = plank &lt; Math.min(A[i], A[j]) ? Math.min(A[i], A[j]) : plank; result = A[i] &gt;= A[j] ? result + (plank - A[j--]) : result + (plank - A[i++]); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
        <tag>hard</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[041. First Missing Positive]]></title>
    <url>%2Fp%2F257d685e%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/first-missing-positive/ Given an unsorted integer array, find the first missing positive integer. 123For example,Given [1,2,0] return 3,and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. 题意需要理解 答案需要思考 cpp https://discuss.leetcode.com/topic/8293/my-short-c-solution-o-1-space-and-o-n-time My short c++ solution, O(1) space, and O(n) time Put each number in its right place. For example: When we find 5, then swap it with A[4]. At last, the first place where its number is not right, return the place + 1. 12345678910111213141516class Solution&#123;public: int firstMissingPositive(int A[], int n) &#123; for(int i = 0; i &lt; n; ++ i) while(A[i] &gt; 0 &amp;&amp; A[i] &lt;= n &amp;&amp; A[A[i] - 1] != A[i]) swap(A[i], A[A[i] - 1]); for(int i = 0; i &lt; n; ++ i) if(A[i] != i + 1) return i + 1; return n + 1; &#125;&#125;; https://discuss.leetcode.com/topic/17035/my-c-solution-4-ms My c++ solution (4 ms) 12345678910111213141516class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; for(int i=0; i&lt;nums.size(); i++)&#123; if(i+1==nums[i]) continue; int x = nums[i]; while(x&gt;=1 &amp;&amp; x&lt;=nums.size() &amp;&amp; x!=nums[x-1])&#123; swap(x, nums[x-1]); &#125; &#125; for(int i=0; i&lt;nums.size(); i++)&#123; if(i+1!=nums[i]) return i+1; &#125; return nums.size()+1; &#125;&#125;; Since we can not use extra space, so thinking about using the nums vector itself to record a positive number occurred. https://discuss.leetcode.com/topic/3384/o-n-time-o-1-space-c O(n) time, O(1) space C++ Idea is to swap each positive integer you encounter to its “rightful” place at index (x-1) where x is the integer. It’s O(n) because you visit each integer in at most 2 unique loop iterations. 1234567891011121314151617181920class Solution &#123;public: int firstMissingPositive(int A[], int n) &#123; int i,j; for(i=0;i&lt;n;i++)&#123; int cur=A[i]; // if in place or non-pos or out of bounds, skip. if(cur==i+1||cur&lt;=0||cur&gt;n)continue; swap(A[i],A[cur-1]); // if not the same, then reprocess it. if(A[i]!=A[cur-1]) i--; &#125; for(i=0;i&lt;n;i++) if(A[i]!=i+1) return i+1; return n+1; &#125;&#125;; python https://discuss.leetcode.com/topic/1361/a-very-nice-solution-from-ants-aasma-stackoverflow A very nice solution (from Ants Aasma @stackoverflow) time complexity is O(N) and space complexity is O(1). Link: http://stackoverflow.com/questions/1586858/find-the-smallest-integer-not-in-a-list Posted by Ants Aasma on Oct 20 ‘09. The code is pasted here: 12345678910111213#Pass 1, move every value to the position of its valuefor cursor in range(N): target = array[cursor] while target &lt; N and target != array[target]: new_target = array[target] array[target] = target target = new_target#Pass 2, find first location where the index doesn&apos;t match the valuefor cursor in range(N): if array[cursor] != cursor: return cursorreturn N java https://discuss.leetcode.com/topic/2633/share-my-o-n-time-o-1-space-solution Share my O(n) time, O(1) space solution Share my O(n)/O(1) solution The basic idea is for any k positive numbers (duplicates allowed), the first missing positive number must be within [1,k+1]. The reason is like you put k balls into k+1 bins, there must be a bin empty, the empty bin can be viewed as the missing number. Unfortunately, there are 0 and negative numbers in the array, so firstly I think of using partition technique (used in quick sort) to put all positive numbers together in one side. This can be finished in O(n) time, O(1) space. After partition step, you get all the positive numbers lying within A[0,k-1]. Now, According to the basic idea, I infer the first missing number must be within [1,k+1]. I decide to use A[i] (0&lt;=i&lt;=k-1) to indicate whether the number (i+1) exists. But here I still have to main the original information A[i] holds. Fortunately, A[i] are all positive numbers, so I can set them to negative to indicate the existence of (i+1) and I can still use abs(A[i]) to get the original information A[i] holds. After step 2, I can again scan all elements between A[0,k-1] to find the first positive element A[i], that means (i+1) doesn’t exist, which is what I want. 12345678910111213141516171819202122232425262728293031323334353637383940public int firstMissingPositive(int[] A) &#123; int n=A.length; if(n==0) return 1; int k=partition(A)+1; int temp=0; int first_missing_Index=k; for(int i=0;i&lt;k;i++)&#123; temp=Math.abs(A[i]); if(temp&lt;=k) A[temp-1]=(A[temp-1]&lt;0)?A[temp-1]:-A[temp-1]; &#125; for(int i=0;i&lt;k;i++)&#123; if(A[i]&gt;0)&#123; first_missing_Index=i; break; &#125; &#125; return first_missing_Index+1;&#125;public int partition(int[] A)&#123; int n=A.length; int q=-1; for(int i=0;i&lt;n;i++)&#123; if(A[i]&gt;0)&#123; q++; swap(A,q,i); &#125; &#125; return q;&#125;public void swap(int[] A, int i, int j)&#123; if(i!=j)&#123; A[i]^=A[j]; A[j]^=A[i]; A[i]^=A[j]; &#125;&#125; https://discuss.leetcode.com/topic/10351/o-1-space-java-solution O(1) space Java Solution The key here is to use swapping to keep constant space and also make use of the length of the array, which means there can be at most n positive integers. So each time we encounter an valid integer, find its correct position and swap. Otherwise we continue. 12345678910111213141516171819public class Solution &#123; public int firstMissingPositive(int[] A) &#123; int i = 0; while(i &lt; A.length)&#123; if(A[i] == i+1 || A[i] &lt;= 0 || A[i] &gt; A.length) i++; else if(A[A[i]-1] != A[i]) swap(A, i, A[i]-1); else i++; &#125; i = 0; while(i &lt; A.length &amp;&amp; A[i] == i+1) i++; return i+1; &#125; private void swap(int[] A, int i, int j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125;&#125; https://discuss.leetcode.com/topic/25441/beat-100-fast-elegant-java-index-based-solution-with-explanation Beat 100% Fast Elegant Java Index-Based Solution with Explanation The basic idea is to traversal and try to move the current value to position whose index is exactly the value (swap them). Then travelsal again to find the first unusal value, which can not be corresponding to its index. 12345678910111213141516171819202122232425262728293031public int firstMissingPositive(int[] nums) &#123; int i = 0, n = nums.length; while (i &lt; n) &#123; // If the current value is in the range of (0,length) and it&apos;s not at its correct position, // swap it to its correct position. // Else just continue; if (nums[i] &gt;= 0 &amp;&amp; nums[i] &lt; n &amp;&amp; nums[nums[i]] != nums[i]) swap(nums, i, nums[i]); else i++; &#125; int k = 1; // Check from k=1 to see whether each index and value can be corresponding. while (k &lt; n &amp;&amp; nums[k] == k) k++; // If it breaks because of empty array or reaching the end. K must be the first missing number. if (n == 0 || k &lt; n) return k; else // If k is hiding at position 0, K+1 is the number. return nums[0] == k ? k + 1 : k;&#125;private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[040. Combination Sum II]]></title>
    <url>%2Fp%2F217971c0%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/combination-sum-ii/ Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. 123456789For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 方法一： 回溯法，我的代码实现 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end()); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; combination; helper(candidates, target, 0, combination, res); return res; &#125; void helper(vector&lt;int&gt;&amp; candidates, int target, int start, vector&lt;int&gt;&amp; combination, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(target==0)&#123; res.push_back(combination); return; &#125; if(target&lt;0 || start&gt;=candidates.size()) return; for(int i=start; i&lt;candidates.size(); i++)&#123; if(i!=start &amp;&amp; candidates[i]==candidates[i-1]) continue; combination.push_back(candidates[i]); helper(candidates, target-candidates[i], i+1, combination, res); // start+1 与 i+1 的区别 combination.pop_back(); &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/8916/c-backtracking-solution-with-detailed-explanation C++ backtracking solution with detailed explanation At the beginning, I stuck on this problem. After careful thought, I think this kind of backtracking contains a iterative component and a resursive component so I’d like to give more details to help beginners save time. The revursive component tries the elements after the current one and also tries duplicate elements. So we can get correct answer for cases like [1 1] 2. The iterative component checks duplicate combinations and skip it if it is. So we can get correct answer for cases like [1 1 1] 2. 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combinationSum2(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(num.begin(),num.end()); vector&lt;int&gt; local; findCombination(res, 0, target, local, num); return res; &#125; void findCombination(vector&lt;vector&lt;int&gt;&gt;&amp; res, const int order, const int target, vector&lt;int&gt;&amp; local, const vector&lt;int&gt;&amp; num) &#123; if(target==0) &#123; res.push_back(local); return; &#125; else &#123; for(int i = order;i&lt;num.size();i++) // iterative component &#123; if(num[i]&gt;target) return; if(i&amp;&amp;num[i]==num[i-1]&amp;&amp;i&gt;order) continue; // check duplicate combination local.push_back(num[i]), findCombination(res,i+1,target-num[i],local,num); // recursive componenet local.pop_back(); &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/17682/8ms-c-backtracking-easy-to-understand 8ms C++ backtracking easy to understand 12345678910111213141516171819vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; current; sort(candidates.begin(),candidates.end()); backTracking(candidates.begin(),current,res,candidates,target); return res;&#125;void backTracking(vector&lt;int&gt;::iterator n, vector&lt;int&gt;&amp; current,vector&lt;vector&lt;int&gt;&gt;&amp; res, const vector&lt;int&gt;&amp; candidates, int target)&#123; if(!target) res.push_back(current); else if(target&gt;0)&#123; for(;n!=candidates.end()&amp;&amp;*n&lt;=target;++n)&#123; current.push_back(*n); backTracking(n+1,current,res,candidates,target-*n); current.pop_back(); while(n+1!=candidates.end()&amp;&amp;*(n+1)==*n) ++n; &#125; &#125;&#125; https://discuss.leetcode.com/topic/3399/my-solution-without-using-set My solution without using set My idea is skip same number during recursion. Like Permutations II. Firstly sort num, then search from back for numbers sum to target. 1234567891011121314151617181920212223242526272829vector&lt;vector&lt;int&gt; &gt; combinationSum2(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(num.begin(), num.end()); vector&lt;int&gt; cur; find(num, target, num.size() - 1, res, cur); return res;&#125;void find(vector&lt;int&gt; &amp;num, int target, int end, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; cur)&#123; if (target == 0) &#123; res.push_back(cur); return; &#125; if (end &lt; 0 || num[end] * (end + 1) &lt; target) return; if (num[end] &lt;= target) &#123; cur.insert(cur.begin(), num[end]); find(num, target - num[end], end - 1, res, cur); cur.erase(cur.begin()); &#125; //find combinations ends at the first number different from num[end] int temp = num[end]; while (end &gt;= 0 &amp;&amp; num[end] == temp) end--; find(num, target, end, res, cur);&#125; 12ms, 57.77%, June.21th, 2016 https://leetcode.com/discuss/37071/accepted-16ms-c-solution-use-backtracking-easy-understand 1234567891011121314151617181920212223class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target) &#123; std::sort(candidates.begin(), candidates.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum2(candidates, target, res, combination, 0); return res; &#125;private: void combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin) &#123; if (!target) &#123; res.push_back(combination); return; &#125; for (int i = begin; i != candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) if (i == begin || candidates[i] != candidates[i - 1]) &#123; combination.push_back(candidates[i]); combinationSum2(candidates, target - candidates[i], res, combination, i + 1); combination.pop_back(); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/5777/dp-solution-in-python DP solution in Python I also did it with recursion, turns out the DP solution is 3~4 times faster. 12345678910def combinationSum2(self, candidates, target): candidates.sort() table = [None] + [set() for i in range(target)] for i in candidates: if i &gt; target: break for j in range(target - i, 0, -1): table[i + j] |= &#123;elt + (i,) for elt in table[j]&#125; table[i].add((i,)) return map(list, table[target]) https://discuss.leetcode.com/topic/11852/my-84ms-python-recursive-solution My 84ms python recursive solution. 1234567891011121314151617class Solution: def combinationSum2(self, candidates, target): candidates.sort() return self.search(candidates, 0 ,target) def search(self, candidates, start, target): if target==0: return [[]] res=[] for i in xrange(start,len(candidates)): if i!=start and candidates[i]==candidates[i-1]: continue if candidates[i]&gt;target: break for r in self.search(candidates, i+1, target-candidates[i]): res.append([candidates[i]]+r) return res https://discuss.leetcode.com/topic/47845/beating-98-python-solution-using-recursion-with-comments Beating 98% Python solution using recursion with comments 12345678910111213141516171819202122232425262728293031def combinationSum2(self, candidates, target): # Sorting is really helpful, se we can avoid over counting easily candidates.sort() result = [] self.combine_sum_2(candidates, 0, [], result, target) return result def combine_sum_2(self, nums, start, path, result, target): # Base case: if the sum of the path satisfies the target, we will consider # it as a solution, and stop there if not target: result.append(path) return for i in xrange(start, len(nums)): # Very important here! We don&apos;t use `i &gt; 0` because we always want # to count the first element in this recursive step even if it is the same # as one before. To avoid overcounting, we just ignore the duplicates # after the first element. if i &gt; start and nums[i] == nums[i - 1]: continue # If the current element is bigger than the assigned target, there is # no need to keep searching, since all the numbers are positive if nums[i] &gt; target: break # We change the start to `i + 1` because one element only could # be used once self.combine_sum_2(nums, i + 1, path + [nums[i]], result, target - nums[i]) java https://discuss.leetcode.com/topic/19845/java-solution-using-dfs-easy-understand Java solution using dfs, easy understand 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] cand, int target) &#123; Arrays.sort(cand); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;Integer&gt;(); dfs_com(cand, 0, target, path, res); return res;&#125;void dfs_com(int[] cand, int cur, int target, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (target == 0) &#123; res.add(new ArrayList(path)); return ; &#125; if (target &lt; 0) return; for (int i = cur; i &lt; cand.length; i++)&#123; if (i &gt; cur &amp;&amp; cand[i] == cand[i-1]) continue; path.add(path.size(), cand[i]); dfs_com(cand, i+1, target - cand[i], path, res); path.remove(path.size()-1); &#125;&#125; https://discuss.leetcode.com/topic/44037/combination-sum-i-ii-and-iii-java-solution-see-the-similarities-yourself Combination Sum I, II and III Java solution (see the similarities yourself) Combination Sum I 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(candidates); backtrack(list, new ArrayList&lt;Integer&gt;(), candidates, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] cand, int remain, int start) &#123; if (remain &lt; 0) return; /** no solution */ else if (remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for (int i = start; i &lt; cand.length; i++) &#123; tempList.add(cand[i]); backtrack(list, tempList, cand, remain-cand[i], i); tempList.remove(tempList.size()-1); &#125; &#125;&#125; Combination Sum II 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(candidates); backtrack(list, new ArrayList&lt;Integer&gt;(), candidates, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] cand, int remain, int start) &#123; if(remain &lt; 0) return; /** no solution */ else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for (int i = start; i &lt; cand.length; i++) &#123; if(i &gt; start &amp;&amp; cand[i] == cand[i-1]) continue; /** skip duplicates */ tempList.add(cand[i]); backtrack(list, tempList, cand, remain - cand[i], i+1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum III 1234567891011121314151617public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;Integer&gt;(), k, n, 1); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int k, int remain, int start) &#123; if(tempList.size() &gt; k) return; /** no solution */ else if(tempList.size() == k &amp;&amp; remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for (int i = start; i &lt;= 9; i++) &#123; tempList.add(i); backtrack(list, tempList, k, remain-i, i+1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; https://discuss.leetcode.com/topic/24059/java-short-and-recursive-clean-code Java - short and recursive, clean code. 123456789101112131415161718192021222324252627public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); List&lt;Integer&gt; comb = new ArrayList&lt;&gt;(); Arrays.sort(candidates); // need sort to make this work. combination(candidates, target, 0, comb, ans); return ans;&#125;private void combination(int[] candi, int target, int start, List&lt;Integer&gt; comb, List&lt;List&lt;Integer&gt;&gt; ans) &#123; for (int i = start; i &lt; candi.length; i++) &#123; if (i &gt; start &amp;&amp; candi[i] == candi[i - 1]) //remove duplicates. continue; if (candi[i] == target) &#123; //recursion exit. List&lt;Integer&gt; newComb = new ArrayList&lt;&gt;(comb); newComb.add(candi[i]); ans.add(newComb); &#125; else if (candi[i] &lt; target) &#123; //continue to look for the rest. List&lt;Integer&gt; newComb = new ArrayList&lt;&gt;(comb); newComb.add(candi[i]); combination(candi, target - candi[i], i + 1, newComb, ans); &#125; else break; //invalid path, return nothing. &#125;&#125; https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning 12345678910111213141516171819202122public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125; &#125; https://discuss.leetcode.com/topic/34364/java-solutions-beats-99-87 Java solutions beats 99,87% 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); calcCombinationSum2(candidates, 0, new int[candidates.length], 0, target, results); return results; &#125; private void calcCombinationSum2(int[] candidates, int cindex, int[] list, int lindex, int target, List&lt;List&lt;Integer&gt;&gt; results) &#123; if (target == 0) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; lindex; i++) &#123; result.add(list[i]); &#125; results.add(result); return; &#125; int prev = 0; for (int i = cindex; i &lt; candidates.length; i++) &#123; if (candidates[i] != prev) &#123; if (target - candidates[i] &lt; 0) &#123; break; &#125; list[lindex] = candidates[i]; calcCombinationSum2(candidates, i + 1, list, lindex + 1, target - candidates[i], results); prev = candidates[i]; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[039. Combination Sum]]></title>
    <url>%2Fp%2Ff5e0c04b%2F</url>
    <content type="text"><![CDATA[38.6% https://leetcode.com/problems/combination-sum/ Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. 1234567For example, given candidate set [2, 3, 6, 7] and target 7, A solution set is: [ [7], [2, 2, 3]] 方法一： 回溯法, 我的代码实现 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; sort(candidates.begin(), candidates.end()); helper(candidates, 0, target, tmp, res); return res; &#125; // 0至start-1之间的candidates已经用过了，只能从start开始用了 void helper(vector&lt;int&gt;&amp; candidates, int start, int target, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(target==0)&#123; res.push_back(tmp); return; &#125;else if(target&lt;0 || start&gt;=candidates.size())&#123; return; &#125; for(int i=start; i&lt;candidates.size(); i++)&#123; tmp.push_back(candidates[i]); helper(candidates, i, target-candidates[i], tmp, res); tmp.pop_back(); &#125; &#125;&#125;; cpp 16ms, 71.93%, June.21th, 2016 https://leetcode.com/discuss/37071/accepted-16ms-c-solution-use-backtracking-easy-understand Accepted 16ms c++ solution use backtracking, easy understand. Accepted 16ms c++ solution use backtracking for Combination Sum: 12345678910111213141516171819202122class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum(std::vector&lt;int&gt; &amp;candidates, int target) &#123; std::sort(candidates.begin(), candidates.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum(candidates, target, res, combination, 0); return res; &#125;private: void combinationSum(std::vector&lt;int&gt; &amp;candidates, int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin) &#123; if (!target) &#123; res.push_back(combination); return; &#125; for (int i = begin; i != candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) &#123; combination.push_back(candidates[i]); combinationSum(candidates, target - candidates[i], res, combination, i); combination.pop_back(); &#125; &#125;&#125;; Accepted 12ms c++ solution use backtracking for Combination Sum II: 1234567891011121314151617181920212223class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target) &#123; std::sort(candidates.begin(), candidates.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum2(candidates, target, res, combination, 0); return res; &#125;private: void combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin) &#123; if (!target) &#123; res.push_back(combination); return; &#125; for (int i = begin; i != candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) if (i == begin || candidates[i] != candidates[i - 1]) &#123; combination.push_back(candidates[i]); combinationSum2(candidates, target - candidates[i], res, combination, i + 1); combination.pop_back(); &#125; &#125;&#125;; Accepted 0ms c++ solution use backtracking for Combination Sum III: 1234567891011121314151617181920212223class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum3(int k, int n) &#123; std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum3(n, res, combination, 1, k); return res; &#125;private: void combinationSum3(int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin, int need) &#123; if (!target) &#123; res.push_back(combination); return; &#125; else if (!need) return; for (int i = begin; i != 10 &amp;&amp; target &gt;= i * need + need * (need - 1) / 2; ++i) &#123; combination.push_back(i); combinationSum3(target - i, res, combination, i + 1, need - 1); combination.pop_back(); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/6431/concise-backtracking-solution Concise Backtracking Solution We backtrack from successful searches as well because they are saved at the leafs of recursion tree 12345678910111213141516171819202122232425262728293031class Solution &#123;public: void search(vector&lt;int&gt;&amp; num, int next, vector&lt;int&gt;&amp; pSol, int target, vector&lt;vector&lt;int&gt; &gt;&amp; result) &#123; if(target == 0) &#123; result.push_back(pSol); return; &#125; if(next == num.size() || target - num[next] &lt; 0) return; pSol.push_back(num[next]); search(num, next, pSol, target - num[next], result); pSol.pop_back(); search(num, next + 1, pSol, target, result); &#125; vector&lt;vector&lt;int&gt; &gt; combinationSum(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt; &gt; result; sort(num.begin(), num.end()); vector&lt;int&gt; pSol; search(num, 0, pSol, target, result); return result; &#125;&#125;; https://discuss.leetcode.com/topic/4454/dynamic-programming-solution Dynamic Programming Solution It adapts the DP solution of coin change problem 12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combinationSum(vector&lt;int&gt; &amp;candidates, int target) &#123; vector&lt; vector&lt; vector&lt;int&gt; &gt; &gt; combinations(target + 1, vector&lt;vector&lt;int&gt;&gt;()); combinations[0].push_back(vector&lt;int&gt;()); for (auto&amp; score : candidates) for (int j = score; j &lt;= target; j++) if (combinations[j - score].size() &gt; 0) &#123; auto tmp = combinations[j - score]; for (auto&amp; s : tmp) s.push_back(score); combinations[j].insert(combinations[j].end(), tmp.begin(), tmp.end()); &#125; auto ret = combinations[target]; for (int i = 0; i &lt; ret.size(); i++) sort(ret[i].begin(), ret[i].end()); return ret; &#125;&#125;; python 188ms, 27.12%, June.21th, 2016 https://leetcode.com/discuss/55666/python-dfs-solution Python dfs solution. 1234567891011121314151617181920class Solution(object): def combinationSum(self, candidates, target): &quot;&quot;&quot; :type candidates: List[int] :type target: int :rtype: List[List[int]] &quot;&quot;&quot; res = [] candidates.sort() self.dfs(candidates, target, [], res, 0) return res def dfs(self, nums, target, path, res, index): if target &lt; 0: return if target == 0: res.append(path) return for i in xrange(index, len(nums)): self.dfs(nums, target - nums[i], path + [nums[i]], res, i) 100ms, 88.35%, June.21th, 2016 https://leetcode.com/discuss/55666/python-dfs-solution 1234567891011121314151617181920class Solution(object): def combinationSum(self, candidates, target): &quot;&quot;&quot; :type candidates: List[int] :type target: int :rtype: List[List[int]] &quot;&quot;&quot; res = [] candidates.sort() self.dfs(candidates, target, [], res, 0) return res def dfs(self, nums, target, path, res, index): if target == 0: res.append(path) return for i in xrange(index, len(nums)): if nums[i] &gt; target: break self.dfs(nums, target - nums[i], path + [nums[i]], res, i) java https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning) This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. Subsets : https://leetcode.com/problems/subsets/ 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Subsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Permutations : https://leetcode.com/problems/permutations/ 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/ 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum : https://leetcode.com/problems/combination-sum/ 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum II (can’t reuse same element) : https://leetcode.com/problems/combination-sum-ii/ 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Palindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/ 12345678910111213141516171819202122232425public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list;&#125;public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125;&#125;public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true;&#125; 6ms, 66.615, June.21th, 2016 https://leetcode.com/discuss/22651/java-solution-using-recursive Java solution using recursive 12345678910111213141516171819202122public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); getResult(result, new ArrayList&lt;Integer&gt;(), candidates, target, 0); return result; &#125; private void getResult(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; cur, int candidates[], int target, int start)&#123; if(target &gt; 0)&#123; for(int i = start; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++)&#123; cur.add(candidates[i]); getResult(result, cur, candidates, target - candidates[i], i); cur.remove(cur.size() - 1); &#125;//for &#125;//if else if(target == 0 )&#123; result.add(new ArrayList&lt;Integer&gt;(cur)); &#125;//else if &#125;&#125; https://discuss.leetcode.com/topic/8200/iterative-java-dp-solution Iterative Java DP solution Hi guys! The main idea reminds an approach for solving coins/knapsack problem - to store the result for all i &lt; target and create the solution from them. For that for each t from 1 to our target we try every candidate which is less or equal to t in ascending order. For each candidate “c” we run through all combinations for target t-c starting with the value greater or equal than c to avoid duplicates and store only ordered combinations. 123456789101112131415161718192021222324public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] cands, int t) &#123; Arrays.sort(cands); // sort candidates to try them in asc order List&lt;List&lt;List&lt;Integer&gt;&gt;&gt; dp = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= t; i++) &#123; // run through all targets from 1 to t List&lt;List&lt;Integer&gt;&gt; newList = new ArrayList(); // combs for curr i // run through all candidates &lt;= i for (int j = 0; j &lt; cands.length &amp;&amp; cands[j] &lt;= i; j++) &#123; // special case when curr target is equal to curr candidate if (i == cands[j]) newList.add(Arrays.asList(cands[j])); // if current candidate is less than the target use prev results else for (List&lt;Integer&gt; l : dp.get(i-cands[j]-1)) &#123; if (cands[j] &lt;= l.get(0)) &#123; List cl = new ArrayList&lt;&gt;(); cl.add(cands[j]); cl.addAll(l); newList.add(cl); &#125; &#125; &#125; dp.add(newList); &#125; return dp.get(t-1); &#125;&#125; Hope it helps! https://discuss.leetcode.com/topic/3043/a-solution-avoid-using-set A solution avoid using set Sort the candidates and we choose from small to large recursively, every time we add a candidate to our possible sub result, we subtract the target to a new smaller one. 12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(candidates); // sort the candidates // collect possible candidates from small to large to eliminate duplicates, recurse(new ArrayList&lt;Integer&gt;(), target, candidates, 0, ret); return ret;&#125;// the index here means we are allowed to choose candidates from that indexprivate void recurse(List&lt;Integer&gt; list, int target, int[] candidates, int index, List&lt;List&lt;Integer&gt;&gt; ret) &#123; if (target == 0) &#123; ret.add(list); return; &#125; for (int i = index; i &lt; candidates.length; i++) &#123; int newTarget = target - candidates[i]; if (newTarget &gt;= 0) &#123; List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(list); copy.add(candidates[i]); recurse(copy, newTarget, candidates, i, ret); &#125; else &#123; break; &#125; &#125;&#125; https://discuss.leetcode.com/topic/3043/a-solution-avoid-using-set/2 Slightly modified your solution, this will make the method run a little faster. 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(candidates); // sort the candidates // collect possible candidates from small to large to eliminate duplicates, recurse(new ArrayList&lt;Integer&gt;(), target, candidates, 0, ret); return ret;&#125;// the index here means we are allowed to choose candidates from that indexprivate void recurse(List&lt;Integer&gt; list, int target, int[] candidates, int index, List&lt;List&lt;Integer&gt;&gt; ret) &#123; if (target == 0) &#123; ret.add(list); return; &#125; for (int i = index; i &lt; candidates.length; i++) &#123; int newTarget = target - candidates[i]; if (newTarget &gt;= 0) &#123; List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(list); copy.add(candidates[i]); recurse(copy, newTarget, candidates, i, ret); &#125;else&#123;break;&#125; &#125; https://discuss.leetcode.com/topic/8364/java-solution-backtracking Java solution (backtracking) 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; solution; private List&lt;Integer&gt; curSolution; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; solution = new ArrayList&lt;List&lt;Integer&gt;&gt;(); curSolution = new ArrayList&lt;Integer&gt;(); Arrays.sort(candidates); backTrack(candidates, target, 0); return solution; &#125; private void backTrack(int[] candidates, int target, int lastIdx) &#123; if (target == 0) &#123; solution.add(new ArrayList&lt;&gt;(curSolution)); &#125; else if (target &lt; 0) &#123; return; &#125; else &#123; int i = lastIdx; while (i &lt; candidates.length) &#123; int candidate = candidates[i]; curSolution.add(candidate); backTrack(candidates, target - candidate, i); curSolution.remove(curSolution.size() - 1); while (i &lt; candidates.length &amp;&amp; candidates[i] == candidate) &#123; i++; &#125; &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/4997/non-recursive-java-solution Non-Recursive JAVA solution 12345678910111213141516171819202122232425262728293031public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); int i=0, size = candidates.length, sum=0; Stack&lt;Integer&gt; combi = new Stack&lt;&gt;(), indices = new Stack&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); while (i &lt; size) &#123; if (sum + candidates[i]&gt;= target) &#123; if (sum + candidates[i] == target) &#123; combi.push(candidates[i]); result.add(new ArrayList&lt;&gt;(combi)); combi.pop(); &#125; // indices stack and combination stack should have the same size all the time if (!indices.empty())&#123; sum -= combi.pop(); i = indices.pop(); while (i == size-1 &amp;&amp; !indices.empty()) &#123; i = indices.pop(); sum -= combi.pop(); &#125; &#125; i++; &#125; else &#123; combi.push(candidates[i]); sum +=candidates[i]; indices.push(i); &#125; &#125; return result;&#125; https://discuss.leetcode.com/topic/6994/recursive-java-solution Recursive java solution 12345678910111213141516171819202122232425262728293031323334public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); // sort the array, so the result could be increasing order List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i = 0; i &lt; candidates.length; i++)&#123; // target smaller than current number, jump the current and rest of numbers if(target &lt; candidates[i]) continue; // if target is equal to the current number,add it to a new list and add that list to result else if(target == candidates[i])&#123; List&lt;Integer&gt; set = new ArrayList&lt;Integer&gt;(); set.add(candidates[i]); result.add(set); &#125; // if the target is smaller the current number,call this function again else&#123; // use modified array which not includes those numbers that before i to eliminate the duplicates int[] array = Arrays.copyOfRange(candidates,i,candidates.length); // call this function. pass the new target and modified array. List&lt;List&lt;Integer&gt;&gt; temp = combinationSum(array, target - candidates[i]); // for each list in the return list, add current number in the front of list, then add it to result // attention that if return list is null, this enhanced for loop will not perform. for(List&lt;Integer&gt; list:temp)&#123; list.add(0,candidates[i]); result.add(list); &#125; &#125; &#125; return result;&#125; They key point is passing new target and modified array. Pass the modified array to make sure no duplicates set. If the new target could not find a match number, the return list will be null, thus this null list will not be added to the result list.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[038. Count and Say]]></title>
    <url>%2Fp%2Ff2d63f47%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/count-and-say/ 1234567The count-and-say sequence is the sequence of integers beginning as follows:1, 11, 21, 1211, 111221, ...1 is read off as &quot;one 1&quot; or 11.11 is read off as &quot;two 1s&quot; or 21.21 is read off as &quot;one 2, then one 1&quot; or 1211.Given an integer n, generate the nth sequence. Note: The sequence of integers will be represented as a string. https://discuss.leetcode.com/topic/1296/please-change-the-misleading-description Please change the misleading description It seems not only me misunderstood the question. Please modify the description, since it’s frustrating if you are solving a “different” question. Thanks. https://discuss.leetcode.com/topic/2264/examples-of-nth-sequence Examples of nth sequence At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I’m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10: 1234567891011test 1. 1 2. 11 3. 21 4. 1211 5. 111221 6. 312211 7. 13112221 8. 1113213211 9. 31131211131221 10. 13211311123113112211 From the examples you can see, the (i+1)th sequence is the “count and say” of the ith sequence! Hope this helps! https://discuss.leetcode.com/topic/2526/i-suggest-we-should-add-the-description-the-1-is-the-1st-string-and-calculate-the-n-th-string I suggest we should add the description: The “1” is the 1st string, and calculate the n th string. Because usually we start from the 0 th item, so add this description to avoid misunderstanding. java 6ms, September 19, 2016 https://discuss.leetcode.com/topic/2309/show-an-answer-in-java Show an Answer in Java I found nobody answered this question in Java. Actually I got some trouble even this question is not so hard. Maybe many other people had some trouble too. So I put my answer here. @code StringBuilder.append() is the default way to append one string to another. While I have tried String.cancate(),which is not working properly. Any comment is welcomed. 12345678910111213141516171819202122232425public class Solution &#123; public String countAndSay(int n) &#123; StringBuilder curr = new StringBuilder(&quot;1&quot;); StringBuilder prev; int count; char say; for(int i=1; i&lt;n; i++)&#123; prev = curr; curr = new StringBuilder(); count = 1; say = prev.charAt(0); for(int j=1, len=prev.length(); j&lt;len; j++)&#123; if(prev.charAt(j)!=say)&#123; curr.append(count).append(say); count = 1; say = prev.charAt(j); &#125; else count++; &#125; curr.append(count).append(say); &#125; return curr.toString(); &#125;&#125; https://discuss.leetcode.com/topic/14543/straightforward-java-solution Straightforward Java Solution 123456789101112131415161718192021222324252627282930public class Solution &#123; public String countAndSay(int n) &#123; String s = &quot;1&quot;; for(int i = 1; i &lt; n; i++)&#123; s = countIdx(s); &#125; return s; &#125; public String countIdx(String s)&#123; StringBuilder sb = new StringBuilder(); char c = s.charAt(0); int count = 1; for(int i = 1; i &lt; s.length(); i++)&#123; if(s.charAt(i) == c)&#123; count++; &#125; else &#123; sb.append(count); sb.append(c); c = s.charAt(i); count = 1; &#125; &#125; sb.append(count); sb.append(c); return sb.toString(); &#125;&#125; cpp 3ms, September 19, 2016 https://discuss.leetcode.com/topic/20195/c-solution-easy-understand C++ solution easy-understand 1234567891011121314151617181920class Solution &#123;public: string countAndSay(int n) &#123; if(n==0) return &quot;&quot;; string res = &quot;1&quot;; while(--n)&#123; string cur = &quot;&quot;; for(int i=0; i&lt;res.size(); i++)&#123; int count = 1; while((i+1&lt;res.size())&amp;&amp;(res[i] == res[i+1]))&#123; count++; i++; &#125; cur += to_string(count) + res[i]; &#125; res = cur; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/2068/how-to-proof-the-count-is-always-less-than-10 How to proof the COUNT is always less than 10? At first, I solved this problem with the considering of the cases when COUNT is greater than 9, which can not be handled using:curString +=count+’0’;, since it is more than one digit. And I solved it using itoa. But when I thinked about the problem, it seems that the COUNT is always less than 10, even 4. Then I re-writed the solution and also accepted by OJ. Can you guys help me proof it?My code: 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string countAndSay(int n) &#123; string prevString; string curString = &quot;1&quot;; for (int i = 1; i&lt;n; ++i)&#123; prevString = curString; curString = &quot;&quot;; int count = 1; char digit = prevString[0]; for (int j = 1; j&lt;prevString.length(); ++j)&#123; if (prevString[j] == digit)&#123; ++count; &#125; else&#123; curString +=count+&apos;0&apos;; //myItoa(count); curString += digit; digit = prevString[j]; count = 1; &#125; &#125; curString += count+&apos;0&apos;;//myItoa(count); curString += digit; &#125; return curString; &#125;/*private: string myItoa(int i)&#123; string str; while (i)&#123; str += i%10+&apos;0&apos;; i /=10; &#125; reverse(str.begin(), str.end()); return str; &#125;*/&#125;; https://discuss.leetcode.com/topic/2068/how-to-proof-the-count-is-always-less-than-10/2 Proof by exhaustion and contrapositive: In order for a number greater than 4 to be created, there must be a series of numbers n&gt;4 in length all the same digit. Therefore, there is a subset of that series where the count would only reach 4. Because of this, any proof for the existence of a chain resulting in a number greater than 4 is also a proof for the existence of a 4-chain. Using the proof by contrapositive, this means that if 4-chains are proved to be impossible, then any n-chain with n&gt;4 is also impossible. In order to start with a chain with numbers greater than 4, you must assume that a 4-chain is possible in the first place, which is circular reasoning, and so cannot be used as an initial point. It is further impossible to have a negative value, since the counting numbers do not include them. Therefore, the only chains able to create a 4 (at least the first one) are 0000, 1111, 2222, or 3333. 10 0 0 0 -&gt; 40 The 0000 is read zero 0, zero 0, which must come from . Since there is nothing present, it could in theory occur anywhere in the string. However, since they would be next to each other, if the 0 is repeated as would be neccessary, the zeros would add together, resulting in just zero 0, leaving only 20, not 40. 11 1 1 1 -&gt; 41 The 1111 is read one 1, one 1 (or 11), which translates to 21, not 1111. This contradicts the assumption that there is a way to get 1111, and so prevents 4 or greater from appearing. Therefore, 1s cannot reach 4. 12 2 2 2 -&gt; 42 The 2222 is read two 2, two 2 (or 22 22), which is identical to the output. Since the input maps to itself, there is no way to leave that cycle, or it already would have. If 2222 exists in the input, then 2222 must have mapped to it. It cannot reach 42. Therefore, 2s cannot reach 4. 13 3 3 3 -&gt; 43 The 3333 is read three 3, three 3 (or 333 333). This in turn would require 333 333 333. This fails in two respects. First, that the previous inputs would not merge to 63 or 93. The second, that the sequence eventually traces back to the origin, 1. Since it keeps increasing in length as the number of rounds since the start decreases, it cannot have started at 1. Therefore, 3s cannot reach 4. As every possible case has been examined, and none can reach a 4 while starting at the given beginning (1), it is not possible for a 4-chain to occur, meaning a 4 cannot appear in any valid string for this problem. Further, as stated above, since a 4-chain is impossible, so too are all n-chains with n&gt;4, so no number greater than 4 can appear either. https://discuss.leetcode.com/topic/5377/c-solution-runtime-o-n-space-o-n C++ solution, runtime O(n), space O(n) Please see the comments in the code.The solution is quite straight-forward. We generate k-th string, and from k-th string we generate k+1-th string, until we generate n-th string.We use string-helper to save temporary result,I’m sure there is a way for in-place solution also. 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: std::string countAndSay(int n) &#123; if (0 == n) return &quot;&quot;; if (1 == n) return &quot;1&quot;; std::string res=&quot;1&quot;; std::string s; for (int i = 1; i &lt; n; i++)&#123; // run from starting to generate second string int len = res.size(); //cheack all digits in the string for (int j = 0; j &lt; len; j++)&#123; int count=1; // we have at least 1 occourence of each digit // get the number of times same digit occurred (be carefull with the end of the string) while ((j + 1 &lt; len) &amp;&amp; (res[j] == res[j + 1]))&#123; count++; j++; // we need to keep increasing the index inside of the string &#125; // add to new string &quot;count&quot;+&quot;digit itself&quot; s += std::to_string(count) + res[j]; &#125; // save temporary result res = s; // clean our string-helper s.clear(); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/7800/c-iterative-solution-with-explanation-easy-to-understand C++ iterative solution with explanation, easy to understand. Renewed Solution The key point here is to find the maximum consecutive identical numbers, which means, for example: Say there is a array like this [1, 1, 2, 3, 4, 4, 5, 5, 5], we will need to divide the array into different segments like this, [1, 1], [2], [3], [4, 4], [5, 5, 5]. Only in this way, can we count the occurrence of each consecutive segments and convert them into “21 12 13 24 35”. The description of the problem is misleading and I struggled for a while, after some searching I found the right explanation. The number n has nothing to do with the algorithm directly, but but only control the number of iteration. The problem can be solved by using iterative algorithm. Code 1234567891011121314151617181920212223242526272829303132333435string countAndSay(int n)&#123; string curr_str; // The initial case, when n = 1 curr_str += &apos;1&apos;; // The iterative case, when n &gt; 1 for (int i = 0; i &lt; n - 1; i++) &#123; string buffer; // Handle the current string int index = 0; for (int index = 0; index &lt; curr_str.size(); ++index) &#123; // Count the occurance of each digit int cnt = 1; // At least one occurance while (index + 1 &lt; curr_str.size() and curr_str[index + 1] == curr_str[index]) &#123; index++; cnt++; &#125; buffer.push_back(cnt + &apos;0&apos;); buffer.push_back(curr_str[index]); &#125; // Update the current string curr_str = buffer; &#125; return curr_str;&#125; python 52ms, September 19, 2016 https://discuss.leetcode.com/topic/28084/simple-python-solution Idea here is keep track of the first letter in the sequence and count consecutive occurances. Once you encounter a new letter you add the previous count and letter to the chain. Repeat n-1 times (since we seeded the initial ‘1’ case). We always update temp after the inner loop since we will never have already added the last sequence. 12345678910111213141516171819class Solution(object): def countAndSay(self, n): &quot;&quot;&quot; :type n: int :rtype: str &quot;&quot;&quot; s = &apos;1&apos; for _ in range(n-1): let, temp, count = s[0], &apos;&apos;, 0 for l in s: if let == l: count += 1 else: temp += str(count) + let let = l count = 1 temp += str(count) + let s = temp return s https://discuss.leetcode.com/topic/28084/simple-python-solution Simple Python Solution Idea here is keep track of the first letter in the sequence and count consecutive occurances. Once you encounter a new letter you add the previous count and letter to the chain. Repeat n-1 times (since we seeded the initial ‘1’ case). We always update temp after the inner loop since we will never have already added the last sequence. 1234567891011121314def countAndSay(self, n): s = &apos;1&apos; for _ in range(n-1): let, temp, count = s[0], &apos;&apos;, 0 for l in s: if let == l: count += 1 else: temp += str(count)+let let = l count = 1 temp += str(count)+let s = temp return s https://discuss.leetcode.com/topic/32023/4-5-lines-python-solutions 4-5 lines Python solutions Solution 1 … using a regular expression 12345def countAndSay(self, n): s = &apos;1&apos; for _ in range(n - 1): s = re.sub(r&apos;(.)\1*&apos;, lambda m: str(len(m.group(0))) + m.group(1), s) return s Solution 2 … using a regular expression 123456def countAndSay(self, n): s = &apos;1&apos; for _ in range(n - 1): s = &apos;&apos;.join(str(len(group)) + digit for group, digit in re.findall(r&apos;((.)\2*)&apos;, s)) return s Solution 3 … using groupby 123456def countAndSay(self, n): s = &apos;1&apos; for _ in range(n - 1): s = &apos;&apos;.join(str(len(list(group))) + digit for digit, group in itertools.groupby(s)) return s]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[037. Sudoku Solver]]></title>
    <url>%2Fp%2Ff1a3dfa0%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/sudoku-solver/ Write a program to solve a Sudoku puzzle by filling the empty cells. Empty cells are indicated by the character ‘.’. You may assume that there will be only one unique solution. A sudoku puzzle… …and its solution numbers marked in red. https://discuss.leetcode.com/topic/2145/there-is-a-dancing-links-x-algorithm There is a Dancing Links X Algorithm Dr. Donald Knuth’s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem. NOTE:This is a very complicate solution. A Sudoku Solver in Java implementing Knuth’s Dancing Links Algorithm java 25ms, 54.00%, September 21, 2016 https://discuss.leetcode.com/topic/11327/straight-forward-java-solution-using-backtracking Straight Forward Java Solution Using Backtracking Try 1 through 9 for each cell. The time complexity should be 9 ^ m (m represents the number of blanks to be filled in), since each blank can have 9 choices. Details see comments inside code. Let me know your suggestions. Sorry for being late to answer the time complexity question 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public void solveSudoku(char[][] board) &#123; if(board == null || board.length == 0) return; solve(board); &#125; public boolean solve(char[][] board)&#123; for(int i=0; i&lt;board.length; i++)&#123; for(int j=0; j&lt;board[0].length; j++)&#123; if(board[i][j]==&apos;.&apos;)&#123; for(char c=&apos;1&apos;; c&lt;=&apos;9&apos;; c++)&#123; if(isValid(board, i, j, c))&#123; board[i][j] = c; if(solve(board)) return true; else board[i][j]=&apos;.&apos;; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; public boolean isValid(char[][] board, int i, int j, char c)&#123; for(int row = 0; row&lt;9; row++) if(board[row][j] == c) return false; for(int col = 0; col&lt;9; col++) if(board[i][col] == c) return false; for(int row = (i/3)*3; row &lt; (i/3)*3 + 3; row++) for(int col = (j/3)*3; col &lt; (j/3)*3+3; col++) if(board[row][col] == c) return false; return true; &#125;&#125; cpp https://discuss.leetcode.com/topic/7195/sharing-my-2ms-c-solution-with-comments-and-explanations Sharing my 2ms C++ solution with comments and explanations. Update: there’s a follow-up 0ms solution which is even more optimized This is one of the fastest Sudoku solvers I’ve ever written. It is compact enough - just 150 lines of C++ code with comments. I thought it’d be interesting to share it, since it combines several techniques like reactive network update propagation and backtracking with very aggressive pruning. The algorithm is online - it starts with an empty board and as you add numbers to it, it starts solving the Sudoku. Unlike in other solutions where you have bitmasks of allowed/disallowed values per row/column/square, this solution track bitmask for every(!) cell, forming a set of constraints for the allowed values for each particular cell. Once a value is written into a cell, new constraints are immediately propagated to row, column and 3x3 square of the cell. If during this process a value of other cell can be unambiguously deduced - then the value is set, new constraints are propagated, so on…. You can think about this as an implicit reactive network of cells. If we’re lucky (and we’ll be lucky for 19 of 20 of Sudokus published in magazines) then Sudoku is solved at the end (or even before!) processing of the input. Otherwise, there will be empty cells which have to be resolved. Algorithm uses backtracking for this purpose. To optimize it, algorithm starts with the cell with the smallest ambiguity. This could be improved even further by using priority queue (but it’s not implemented here). Backtracking is more or less standard, however, at each step we guess the number, the reactive update propagation comes back into play and it either quickly proves that the guess is unfeasible or significantly prunes the remaining search space. It’s interesting to note, that in this case taking and restoring snapshots of the compact representation of the state is faster than doing backtracking rollback by “undoing the moves”. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141class Solution &#123; struct cell // encapsulates a single cell on a Sudoku board &#123; uint8_t value; // cell value 1..9 or 0 if unset // number of possible (unconstrained) values for the cell uint8_t numPossibilities; // if bitset[v] is 1 then value can&apos;t be v bitset&lt;10&gt; constraints; cell() : value(0), numPossibilities(9),constraints() &#123;&#125;; &#125;; array&lt;array&lt;cell,9&gt;,9&gt; cells; // sets the value of the cell to [v] // the function also propagates constraints to other cells and deduce new values where possible bool set(int i, int j, int v) &#123; // updating state of the cell cell&amp; c = cells[i][j]; if (c.value == v) return true; if (c.constraints[v]) return false; c.constraints = bitset&lt;10&gt;(0x3FE); // all 1s c.constraints.reset(v); c.numPossibilities = 1; c.value = v; // propagating constraints for (int k = 0; k&lt;9; k++) &#123; // to the row: if (i != k &amp;&amp; !updateConstraints(k, j, v)) return false; // to the column: if (j != k &amp;&amp; !updateConstraints(i, k, v)) return false; // to the 3x3 square: int ix = (i / 3) * 3 + k / 3; int jx = (j / 3) * 3 + k % 3; if (ix != i &amp;&amp; jx != j &amp;&amp; !updateConstraints(ix, jx, v)) return false; &#125; return true; &#125; // update constraints of the cell i,j by excluding possibility of &apos;excludedValue&apos; // once there&apos;s one possibility left the function recurses back into set() bool updateConstraints(int i, int j, int excludedValue) &#123; cell&amp; c = cells[i][j]; if (c.constraints[excludedValue]) &#123; return true; &#125; if (c.value == excludedValue) &#123; return false; &#125; c.constraints.set(excludedValue); if (--c.numPossibilities &gt; 1) return true; for (int v = 1; v &lt;= 9; v++) &#123; if (!c.constraints[v]) &#123; return set(i, j, v); &#125; &#125; assert(false); &#125; // backtracking state - list of empty cells vector&lt;pair&lt;int, int&gt;&gt; bt; // find values for empty cells bool findValuesForEmptyCells() &#123; // collecting all empty cells bt.clear(); for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (!cells[i][j].value) bt.push_back(make_pair(i, j)); &#125; &#125; // making backtracking efficient by pre-sorting empty cells by numPossibilities sort(bt.begin(), bt.end(), [this](const pair&lt;int, int&gt;&amp;a, const pair&lt;int, int&gt;&amp;b) &#123; return cells[a.first][a.second].numPossibilities &lt; cells[b.first][b.second].numPossibilities; &#125;); return backtrack(0); &#125; // Finds value for all empty cells with index &gt;=k bool backtrack(int k) &#123; if (k &gt;= bt.size()) return true; int i = bt[k].first; int j = bt[k].second; // fast path - only 1 possibility if (cells[i][j].value) return backtrack(k + 1); auto constraints = cells[i][j].constraints; // slow path &gt;1 possibility. // making snapshot of the state array&lt;array&lt;cell,9&gt;,9&gt; snapshot(cells); for (int v = 1; v &lt;= 9; v++) &#123; if (!constraints[v]) &#123; if (set(i, j, v)) &#123; if (backtrack(k + 1)) return true; &#125; // restoring from snapshot, // note: computationally this is cheaper // than alternative implementation with undoing the changes cells = snapshot; &#125; &#125; return false; &#125;public: void solveSudoku(vector&lt;vector&lt;char&gt;&gt; &amp;board) &#123; cells = array&lt;array&lt;cell,9&gt;,9&gt;(); // clear array // Decoding input board into the internal cell matrix. // As we do it - constraints are propagated and even additional values are set as we go // (in the case if it is possible to unambiguously deduce them). for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != &apos;.&apos; &amp;&amp; !set(i, j, board[i][j] - &apos;0&apos;)) return; // sudoku is either incorrect or unsolvable &#125; &#125; // if we&apos;re lucky we&apos;ve already got a solution, // however, if we have empty cells we need to use backtracking to fill them if (!findValuesForEmptyCells()) return; // sudoku is unsolvable // copying the solution back to the board for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (cells[i][j].value) board[i][j] = cells[i][j].value + &apos;0&apos;; &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/13314/singapore-prime-minister-lee-hsien-loong-s-sudoku-solver-code-runs-in-1ms Singapore prime minister Lee Hsien Loong’s Sudoku Solver code runs in 1ms Singapore’s prime minister Lee Hsien Loong showcased his Sudoku Solver C code. You can read his original Facebook post here and another news reporting it here. I have made some slight modification to adapt it so it can be tested on LeetCode OJ. It passed all 6/6 test cases with a runtime of 1 ms. Pretty impressive for a prime minister, huh? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// Original author: Hsien Loong Lee (http://bit.ly/1zfIGMc)// Slight modification by @1337c0d3r to adapt to run on LeetCode OJ.// https://leetcode.com/problems/sudoku-solver/int InBlock[81], InRow[81], InCol[81];const int BLANK = 0;const int ONES = 0x3fe; // Binary 1111111110int Entry[81]; // Records entries 1-9 in the grid, as the corresponding bit set to 1int Block[9], Row[9], Col[9]; // Each int is a 9-bit arrayint SeqPtr = 0;int Sequence[81];void SwapSeqEntries(int S1, int S2)&#123; int temp = Sequence[S2]; Sequence[S2] = Sequence[S1]; Sequence[S1] = temp;&#125;void InitEntry(int i, int j, int val)&#123; int Square = 9 * i + j; int valbit = 1 &lt;&lt; val; int SeqPtr2; // add suitable checks for data consistency Entry[Square] = valbit; Block[InBlock[Square]] &amp;= ~valbit; Col[InCol[Square]] &amp;= ~valbit; // Simpler Col[j] &amp;= ~valbit; Row[InRow[Square]] &amp;= ~valbit; // Simpler Row[i] &amp;= ~valbit; SeqPtr2 = SeqPtr; while (SeqPtr2 &lt; 81 &amp;&amp; Sequence[SeqPtr2] != Square) SeqPtr2++ ; SwapSeqEntries(SeqPtr, SeqPtr2); SeqPtr++;&#125;void PrintArray(char **board)&#123; int i, j, valbit, val, Square; char ch; Square = 0; for (i = 0; i &lt; 9; i++) &#123; for (j = 0; j &lt; 9; j++) &#123; valbit = Entry[Square++]; if (valbit == 0) ch = &apos;-&apos;; else &#123; for (val = 1; val &lt;= 9; val++) if (valbit == (1 &lt;&lt; val)) &#123; ch = &apos;0&apos; + val; break; &#125; &#125; board[i][j] = ch; &#125; &#125;&#125;int NextSeq(int S)&#123; int S2, Square, Possibles, BitCount; int T, MinBitCount = 100; for (T = S; T &lt; 81; T++) &#123; Square = Sequence[T]; Possibles = Block[InBlock[Square]] &amp; Row[InRow[Square]] &amp; Col[InCol[Square]]; BitCount = 0; while (Possibles) &#123; Possibles &amp;= ~(Possibles &amp; -Possibles); BitCount++; &#125; if (BitCount &lt; MinBitCount) &#123; MinBitCount = BitCount; S2 = T; &#125; &#125; return S2;&#125;void Place(int S, char** board)&#123; if (S &gt;= 81) &#123; PrintArray(board); return; &#125; int S2 = NextSeq(S); SwapSeqEntries(S, S2); int Square = Sequence[S]; int BlockIndex = InBlock[Square], RowIndex = InRow[Square], ColIndex = InCol[Square]; int Possibles = Block[BlockIndex] &amp; Row[RowIndex] &amp; Col[ColIndex]; while (Possibles) &#123; int valbit = Possibles &amp; (-Possibles); // Lowest 1 bit in Possibles Possibles &amp;= ~valbit; Entry[Square] = valbit; Block[BlockIndex] &amp;= ~valbit; Row[RowIndex] &amp;= ~valbit; Col[ColIndex] &amp;= ~valbit; Place(S + 1, board); Entry[Square] = BLANK; // Could be moved out of the loop Block[BlockIndex] |= valbit; Row[RowIndex] |= valbit; Col[ColIndex] |= valbit; &#125; SwapSeqEntries(S, S2);&#125;void solveSudoku(char **board, int m, int n) &#123; SeqPtr = 0; int i, j, Square; for (i = 0; i &lt; 9; i++) for (j = 0; j &lt; 9; j++) &#123; Square = 9 * i + j; InRow[Square] = i; InCol[Square] = j; InBlock[Square] = (i / 3) * 3 + ( j / 3); &#125; for (Square = 0; Square &lt; 81; Square++) &#123; Sequence[Square] = Square; Entry[Square] = BLANK; &#125; for (i = 0; i &lt; 9; i++) Block[i] = Row[i] = Col[i] = ONES; for (int i = 0; i &lt; 9; ++i) for (int j = 0; j &lt; 9; ++j) &#123; if (&apos;.&apos; != board[i][j]) InitEntry(i, j, board[i][j] - &apos;0&apos;); &#125; Place(SeqPtr, board);&#125; https://discuss.leetcode.com/topic/5002/a-simple-dfs-solution A simple DFS solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) &#123; return true; &#125; void solveSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) &#123; util(board, 0); &#125; bool util(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) &#123; if (pos &gt;= 81) return true; int i = pos / 9; int j = pos % 9; if (board[i][j] != &apos;.&apos;) return util(board, pos + 1); else &#123; for (char c = &apos;1&apos;; c &lt;= &apos;9&apos;; c++) &#123; if (!isInRow(board, i,c) &amp;&amp; !isInCol(board, j, c) &amp;&amp; !isInRec(board, i, j, c)) &#123; board[i][j] = c; if (util(board, pos + 1)) return true; else board[i][j] = &apos;.&apos;; &#125; &#125; return false; &#125; &#125; bool isInRow(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, char c) &#123; vector&lt;char&gt;&amp; row = board[i]; for (int k = 0; k &lt; 9; k++) &#123; if (row[k] == c) return true; &#125; return false; &#125; bool isInCol(vector&lt;vector&lt;char&gt;&gt;&amp; board,int j, char c) &#123; for (int k = 0; k &lt; 9; k++) &#123; if (board[k][j] == c) return true; &#125; return false; &#125; bool isInRec(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, char c) &#123; int bigrow = i / 3, bigcol = j / 3; for (int m = 3 * bigrow; m &lt; 3 * (bigrow + 1); m++) &#123; for (int n = 3 * bigcol; n &lt; 3 * (bigcol + 1); n++) if (board[m][n] == c) return true; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/21103/simple-and-clean-solution-c Simple and Clean Solution / C++ 1234567891011121314151617181920212223242526272829303132bool check(vector&lt;vector&lt;char&gt;&gt; &amp;board, int i, int j, char val)&#123; int row = i - i%3, column = j - j%3; for(int x=0; x&lt;9; x++) if(board[x][j] == val) return false; for(int y=0; y&lt;9; y++) if(board[i][y] == val) return false; for(int x=0; x&lt;3; x++) for(int y=0; y&lt;3; y++) if(board[row+x][column+y] == val) return false; return true;&#125;bool solveSudoku(vector&lt;vector&lt;char&gt;&gt; &amp;board, int i, int j)&#123; if(i==9) return true; if(j==9) return solveSudoku(board, i+1, 0); if(board[i][j] != &apos;.&apos;) return solveSudoku(board, i, j+1); for(char c=&apos;1&apos;; c&lt;=&apos;9&apos;; c++) &#123; if(check(board, i, j, c)) &#123; board[i][j] = c; if(solveSudoku(board, i, j+1)) return true; board[i][j] = &apos;.&apos;; &#125; &#125; return false;&#125;public:void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;solveSudoku(board, 0, 0);&#125; https://discuss.leetcode.com/topic/27787/c-clear-solution-using-dfs-beating-90-c-coder C++ clear solution using dfs, beating 90% c++ coder. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: bool col[10][10],row[10][10],f[10][10]; bool flag = false; void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; memset(col,false,sizeof(col)); memset(row,false,sizeof(row)); memset(f,false,sizeof(f)); for(int i = 0; i &lt; 9;i++)&#123; for(int j = 0; j &lt; 9;j++)&#123; if(board[i][j] == &apos;.&apos;) continue; int temp = 3*(i/3)+j/3; int num = board[i][j]-&apos;0&apos;; col[j][num] = row[i][num] = f[temp][num] = true; &#125; &#125; dfs(board,0,0); &#125; void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,int i,int j)&#123; if(flag == true) return ; if(i &gt;= 9)&#123; flag = true; return ; &#125; if(board[i][j] != &apos;.&apos;)&#123; if(j &lt; 8) dfs(board,i,j+1); else dfs(board,i+1,0); if(flag) return; &#125; else&#123; int temp = 3*(i/3)+j/3; for(int n = 1; n &lt;= 9; n++)&#123; if(!col[j][n] &amp;&amp; !row[i][n] &amp;&amp; !f[temp][n])&#123; board[i][j] = n + &apos;0&apos;; col[j][n] = row[i][n] = f[temp][n] = true; if(j &lt; 8) dfs(board,i,j+1); else dfs(board,i+1,0); col[j][n] = row[i][n] = f[temp][n] = false; if(flag) return; &#125; &#125; board[i][j] = &apos;.&apos;; &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/18316/48ms-straitforward-python-dfs-solution-with-explanations 48ms straitforward python DFS solution with explanations It’s similar to how human solve Sudoku. create a hash table (dictionary) val to store possible values in every location. Each time, start from the location with fewest possible values, choose one value from it and then update the board and possible values at other locations. If this update is valid, keep solving (DFS). If this update is invalid (leaving zero possible values at some locations) or this value doesn’t lead to the solution, undo the updates and then choose the next value. Since we calculated val at the beginning and start filling the board from the location with fewest possible values, the amount of calculation and thus the runtime can be significantly reduced: The run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest python solutions here. The PossibleVals function may be further simplified/optimized, but it works just fine for now. (it would look less lengthy if we are allowed to use numpy array for the board lol). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556def solveSudoku(self, board): self.board = board self.val = self.PossibleVals() self.Solver()def PossibleVals(self): a = &quot;123456789&quot; d, val = &#123;&#125;, &#123;&#125; for i in xrange(9): for j in xrange(9): ele = self.board[i][j] if ele != &quot;.&quot;: d[(&quot;r&quot;, i)] = d.get((&quot;r&quot;, i), []) + [ele] d[(&quot;c&quot;, j)] = d.get((&quot;c&quot;, j), []) + [ele] d[(i//3, j//3)] = d.get((i//3, j//3), []) + [ele] else: val[(i,j)] = [] for (i,j) in val.keys(): inval = d.get((&quot;r&quot;,i),[])+d.get((&quot;c&quot;,j),[])+d.get((i/3,j/3),[]) val[(i,j)] = [n for n in a if n not in inval ] return valdef Solver(self): if len(self.val)==0: return True kee = min(self.val.keys(), key=lambda x: len(self.val[x])) nums = self.val[kee] for n in nums: update = &#123;kee:self.val[kee]&#125; if self.ValidOne(n, kee, update): # valid choice if self.Solver(): # keep solving return True self.undo(kee, update) # invalid choice or didn&apos;t solve it =&gt; undo return False def ValidOne(self, n, kee, update): self.board[kee[0]][kee[1]] = n del self.val[kee] i, j = kee for ind in self.val.keys(): if n in self.val[ind]: if ind[0]==i or ind[1]==j or (ind[0]/3,ind[1]/3)==(i/3,j/3): update[ind] = n self.val[ind].remove(n) if len(self.val[ind])==0: return False return Truedef undo(self, kee, update): self.board[kee[0]][kee[1]]=&quot;.&quot; for k in update: if k not in self.val: self.val[k]= update[k] else: self.val[k].append(update[k]) return None https://discuss.leetcode.com/topic/7475/accepted-python-solution Accepted Python solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution: # @param board, a 9x9 2D array # Solve the Sudoku by modifying the input board in-place. # Do not return any value. def solveSudoku(self, board): self.board = board self.solve() def findUnassigned(self): for row in range(9): for col in range(9): if self.board[row][col] == &quot;.&quot;: return row, col return -1, -1 def solve(self): row, col = self.findUnassigned() #no unassigned position is found, puzzle solved if row == -1 and col == -1: return True for num in [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;]: if self.isSafe(row, col, num): self.board[row][col] = num if self.solve(): return True self.board[row][col] = &quot;.&quot; return False def isSafe(self, row, col, ch): boxrow = row - row%3 boxcol = col - col%3 if self.checkrow(row,ch) and self.checkcol(col,ch) and self.checksquare(boxrow, boxcol, ch): return True return False def checkrow(self, row, ch): for col in range(9): if self.board[row][col] == ch: return False return True def checkcol(self, col, ch): for row in range(9): if self.board[row][col] == ch: return False return True def checksquare(self, row, col, ch): for r in range(row, row+3): for c in range(col, col+3): if self.board[r][c] == ch: return False return True It’s a simple backtracking solution.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[036. Valid Sudoku]]></title>
    <url>%2Fp%2F7b8b841d%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/valid-sudoku/ Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. A partially filled sudoku which is valid. Note: A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. java 38ms, 6.81%, September 20, 2016 https://discuss.leetcode.com/topic/9748/shared-my-concise-java-code Shared my concise Java code 123456789101112131415161718public class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; for(int i=0; i&lt;9; i++)&#123; HashSet&lt;Character&gt; rows = new HashSet&lt;Character&gt;(); HashSet&lt;Character&gt; columns = new HashSet&lt;Character&gt;(); HashSet&lt;Character&gt; cube = new HashSet&lt;Character&gt;(); for(int j=0; j &lt; 9; j++)&#123; if(board[i][j] != &apos;.&apos; &amp;&amp; !rows.add(board[i][j])) return false; if(board[j][i] != &apos;.&apos; &amp;&amp; !columns.add(board[j][i])) return false; int RowIndex = 3*(i/3); int ColIndex = 3*(i%3); if(board[RowIndex+j/3][ColIndex+j%3]!=&apos;.&apos; &amp;&amp; !cube.add(board[RowIndex+j/3][ColIndex+j%3])) return false; &#125; &#125; return true; &#125;&#125; https://discuss.leetcode.com/topic/5803/sharing-my-easy-understand-java-solution-using-set Sharing my easy-understand java solution using set 1234567891011121314151617181920212223public class Solution &#123;public boolean isValidSudoku(char[][] board) &#123; for (int i=0; i&lt;9; i++) &#123; if (!isParticallyValid(board,i,0,i,8)) return false; if (!isParticallyValid(board,0,i,8,i)) return false; &#125; for (int i=0;i&lt;3;i++)&#123; for(int j=0;j&lt;3;j++)&#123; if (!isParticallyValid(board,i*3,j*3,i*3+2,j*3+2)) return false; &#125; &#125; return true;&#125;private boolean isParticallyValid(char[][] board, int x1, int y1,int x2,int y2)&#123; Set singleSet = new HashSet(); for (int i= x1; i&lt;=x2; i++)&#123; for (int j=y1;j&lt;=y2; j++)&#123; if (board[i][j]!=&apos;.&apos;) if(!singleSet.add(board[i][j])) return false; &#125; &#125; return true;&#125;&#125; Each time send the coordinates to check if the board is partially valid. https://discuss.leetcode.com/topic/27436/short-simple-java-using-strings Short+Simple Java using Strings Collect the set of things we see, encoded as strings. For example: ‘4’ in row 7 is encoded as “(4)7”.‘4’ in column 7 is encoded as “7(4)”.‘4’ in the top-right block is encoded as “0(4)2”.Scream false if we ever fail to add something because it was already added (i.e., seen before). 12345678910111213public boolean isValidSudoku(char[][] board) &#123; Set seen = new HashSet(); for (int i=0; i&lt;9; ++i) &#123; for (int j=0; j&lt;9; ++j) &#123; if (board[i][j] != &apos;.&apos;) &#123; String b = &quot;(&quot; + board[i][j] + &quot;)&quot;; if (!seen.add(b + i) || !seen.add(j + b) || !seen.add(i/3 + b + j/3)) return false; &#125; &#125; &#125; return true;&#125; Edit: Just occurred to me that we can also make it really clear and self-explaining. I’m loving it. 1234567891011121314public boolean isValidSudoku(char[][] board) &#123; Set seen = new HashSet(); for (int i=0; i&lt;9; ++i) &#123; for (int j=0; j&lt;9; ++j) &#123; char number = board[i][j]; if (number != &apos;.&apos;) if (!seen.add(number + &quot; in row &quot; + i) || !seen.add(number + &quot; in column &quot; + j) || !seen.add(number + &quot; in block &quot; + i/3 + &quot;-&quot; + j/3)) return false; &#125; &#125; return true;&#125; https://discuss.leetcode.com/topic/40078/yet-another-java-2ms-solution Yet another java 2ms solution 1234567891011121314151617181920public boolean isValidSudoku(char[][] board) &#123; int [] vset = new int [9]; int [] hset = new int [9]; int [] bckt = new int [9]; int idx = 0; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != &apos;.&apos;) &#123; idx = 1 &lt;&lt; (board[i][j] - &apos;0&apos;) ; if ((hset[i] &amp; idx) &gt; 0 || (vset[j] &amp; idx) &gt; 0 || (bckt[(i / 3) * 3 + j / 3] &amp; idx) &gt; 0) return false; hset[i] |= idx; vset[j] |= idx; bckt[(i / 3) * 3 + j / 3] |= idx; &#125; &#125; &#125; return true;&#125; cpp 16ms, 34.54%, September 20, 2016 https://discuss.leetcode.com/topic/8241/my-short-solution-by-c-o-n2 My short solution by C++. O(n2) Three flags are used to check whether a number appear. used1: check each row used2: check each column used3: check each sub-boxes 1234567891011121314class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int used1[9][9] = &#123;0&#125;, used2[9][9] = &#123;0&#125;, used3[9][9] = &#123;0&#125;; for(int i = 0; i&lt;board.size(); ++i) for(int j = 0; j &lt; board[i].size(); ++j) if(board[i][j] != &apos;.&apos;)&#123; int num = board[i][j] - &apos;0&apos; - 1, k = i/3*3 + j/3; if(used1[i][num] || used2[j][num] || used3[k][num]) return false; used1[i][num] = used2[j][num] = used3[k][num] = 1; &#125; return true; &#125;&#125;; https://discuss.leetcode.com/topic/20201/c-very-simple-and-easy-understand-using-bit-operation C++ very simple and easy understand. using bit operation 1234567891011121314151617bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; vector&lt;short&gt; col(9, 0); vector&lt;short&gt; block(9, 0); vector&lt;short&gt; row(9, 0); for (int i = 0; i &lt; 9; i++) for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != &apos;.&apos;) &#123; int idx = 1 &lt;&lt; (board[i][j] - &apos;0&apos;); if (row[i] &amp; idx || col[j] &amp; idx || block[i/3 * 3 + j / 3] &amp; idx) return false; row[i] |= idx; col[j] |= idx; block[i/3 * 3 + j/3] |= idx; &#125; &#125; return true; &#125; https://discuss.leetcode.com/topic/15917/my-12-lines-c-c-solution-with-1-time-traversal-and-9x9x3-memory My 12 lines C/C++ solution with 1 time traversal and 9x9x3 memory 1234567891011121314int isValidSudoku(char** board, int boardRowSize, int boardColSize) &#123; int rows[9][9]=&#123;0&#125;; //rows[5][0] means whether number 1(&apos;0&apos;+1) in row 5 has appeared. int cols[9][9]=&#123;0&#125;; //cols[3][8] means whether number 9(&apos;8&apos;+1) in col 3 has appeared. int blocks[3][3][9]=&#123;0&#125;;//blocks[0][2][5] means whether number &apos;6&apos; in block 0,2 (row 0~2,col 6~8) has appeared. for(int r=0;r&lt;9;r++) //traverse board r,c for(int c=0;c&lt;9;c++) if(board[r][c]!=&apos;.&apos;)&#123; //skip all number &apos;.&apos; int number=board[r][c]-&apos;1&apos;; //calculate the number&apos;s index(board&apos;s number minus 1) if(rows[r][number]++) return 0; //if the number has already appeared once, return false. if(cols[c][number]++) return 0; if(blocks[r/3][c/3][number]++) return 0; &#125; return 1;&#125; python https://discuss.leetcode.com/topic/20016/1-7-lines-python-4-solutions 1-7 lines Python, 4 solutions Idea Just go through all you see (like “7 in row 3”) and check for duplicates. Solution 1 Using Counter. One logical line, seven physical lines. 12345678def isValidSudoku(self, board): return 1 == max(collections.Counter( x for i, row in enumerate(board) for j, c in enumerate(row) if c != &apos;.&apos; for x in ((c, i), (j, c), (i/3, j/3, c)) ).values() + [1]) The + [1] is only for the empty board, where max would get an empty list and complain. It’s not necessary to get it accepted here, as the empty board isn’t among the test cases, but it’s good to have. Solution 2 Using len(set). 123456def isValidSudoku(self, board): seen = sum(([(c, i), (j, c), (i/3, j/3, c)] for i, row in enumerate(board) for j, c in enumerate(row) if c != &apos;.&apos;), []) return len(seen) == len(set(seen)) Solution 3 Using any. 1234567def isValidSudoku(self, board): seen = set() return not any(x in seen or seen.add(x) for i, row in enumerate(board) for j, c in enumerate(row) if c != &apos;.&apos; for x in ((c, i), (j, c), (i/3, j/3, c))) Solution 4 Iterating a different way. 12345def isValidSudoku(self, board): seen = sum(([(c, i), (j, c), (i/3, j/3, c)] for i in range(9) for j in range(9) for c in [board[i][j]] if c != &apos;.&apos;), []) return len(seen) == len(set(seen)) https://discuss.leetcode.com/topic/20016/1-7-lines-python-4-solutions/2 Your solutions are briliant! Just another way to write Solution2: 1234567def isValidSudoku(self, board): seen = [] for i, row in enumerate(board): for j, c in enumerate(row): if c != &apos;.&apos;: seen += [(c,j),(i,c),(i/3,j/3,c)] return len(seen) == len(set(seen))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[035. Search Insert Position]]></title>
    <url>%2Fp%2F370b1fef%2F</url>
    <content type="text"><![CDATA[37.9% https://leetcode.com/problems/search-insert-position/ Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. 12345Here are few examples.[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 方法一： 评价：It’s just lower bound binary search. https://leetcode.com/discuss/39829/c-o-logn-binary-search-that-handles-duplicate C++ O(logn) Binary Search that handles duplicate If there are duplicate elements equal to target, my code will always return the one with smallest index. 1234567891011121314151617181920212223242526class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int low = 0, high = nums.size()-1; // Invariant: the desired index is between [low, high+1] while (low &lt;= high) &#123; int mid = low + (high-low)/2; if (nums[mid] &lt; target) low = mid+1; else high = mid-1; &#125; // (1) At this point, low &gt; high. That is, low &gt;= high+1 // (2) From the invariant, we know that the index is between [low, high+1], // so low &lt;= high+1. Follwing from (1), now we know low == high+1. // (3) Following from (2), the index is between [low, high+1] = [low, low], //which means that low is the desired index // Therefore, we return low as the answer. //You can also return high+1 as the result, //since low == high+1 return low; &#125;&#125;; 方法二： A simple CPP solution with lower_bound Actually, what we need here is std::lower_bound in C++ STL, which returns an iterator pointing to the first element that does not less than target. And then, things are quite simple: 123456class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; return lower_bound(nums.begin(), nums.end(), target) - nums.begin(); &#125;&#125;; Or we can implement an inline lower_bound: 123456789101112131415class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; auto first = nums.begin(), last = nums.end(); while (first &lt; last) &#123; auto mid = first + ((last - first) &gt;&gt; 1); if (*mid &lt; target) &#123; first = mid + 1; &#125; else &#123; last = mid; &#125; &#125; return first - nums.begin(); &#125;&#125;; cpp 8ms, 15.81%, June.18th, 2016 https://leetcode.com/discuss/39829/c-o-logn-binary-search-that-handles-duplicate C++ O(logn) Binary Search that handles duplicate If there are duplicate elements equal to target, my code will always return the one with smallest index. 12345678910111213141516171819202122class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int low = 0, high = nums.size()-1; // Invariant: the desired index is between [low, high+1] while (low &lt;= high) &#123; int mid = low + (high-low)/2; if (nums[mid] &lt; target) low = mid+1; else high = mid-1; &#125; // (1) At this point, low &gt; high. That is, low &gt;= high+1 // (2) From the invariant, we know that the index is between [low, high+1], so low &lt;= high+1. Follwing from (1), now we know low == high+1. // (3) Following from (2), the index is between [low, high+1] = [low, low], which means that low is the desired index // Therefore, we return low as the answer. You can also return high+1 as the result, since low == high+1 return low; &#125;&#125;; https://discuss.leetcode.com/topic/7648/my-8ms-accepted-code My 8ms accepted code. 1234567891011121314151617class Solution &#123;public: int searchInsert(int A[], int n, int target) &#123; int low = 0,high = n - 1; while (low &lt;= high)&#123; int mid = (low + high) / 2; if(A[mid]==target) return mid; else if (A[mid] &gt;target)&#123; high = mid - 1; &#125; else&#123; low = mid + 1; &#125; &#125; return low; &#125;&#125;; https://discuss.leetcode.com/topic/16628/a-simple-cpp-solution-with-lower_bound A simple CPP solution with lower_bound Actually, what we need here is std::lower_bound in C++ STL, which returns an iterator pointing to the first element that does not less than target. And then, things are quite simple: 123456class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; return lower_bound(nums.begin(), nums.end(), target) - nums.begin(); &#125;&#125;; Or we can implement an inline lower_bound: 123456789101112131415class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; auto first = nums.begin(), last = nums.end(); while (first &lt; last) &#123; auto mid = first + ((last - first) &gt;&gt; 1); if (*mid &lt; target) &#123; first = mid + 1; &#125; else &#123; last = mid; &#125; &#125; return first - nums.begin(); &#125;&#125;; https://discuss.leetcode.com/topic/20299/my-understanding-of-lower-bound-upper-bound-binary-search-in-c-thanks-to-two-post My understanding of (lower bound,upper bound) binary search, in C++, thanks to two post thanks to A simple CPP solution with lower_boundand C++ O(logn) Binary Search that handles duplicate, thanks to phu1ku ‘s answer on the second post. links for std::lower_bound and std::upper_bound 12345678910111213141516171819class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; /// return index of first one that comp(item,target)==true, or nums.size() if not found /// comp is greater or equal to for lower_bound /// comp is greater for upper_bound int first=0, last=nums.size(), mid; while (first&lt;last) &#123; mid=first+((last-first)&gt;&gt;1); // first&lt;=mid, mid&lt;last /// if comp(item,target)==false, advance first // if(nums[mid]&lt;=target) // for upper_bound if (nums[mid]&lt;target) // for lower_bound first=mid+1; // first always increases else /// else recede last last=mid; // last always decreases (even last-first==1) &#125; return first; &#125;&#125;; python https://discuss.leetcode.com/topic/25828/python-beats-98 Python beats 98% Once the left border is larger than key, than return index. Once the right border is less than key, then return index. 12345678910111213141516171819202122232425262728class Solution(object):def searchInsert(self, nums, key): if key &gt; nums[len(nums) - 1]: return len(nums) if key &lt; nums[0]: return 0 l, r = 0, len(nums) - 1 while l &lt;= r: m = (l + r)/2 if nums[m] &gt; key: r = m - 1 if r &gt;= 0: if nums[r] &lt; key: return r + 1 else: return 0 elif nums[m] &lt; key: l = m + 1 if l &lt; len(nums): if nums[l] &gt; key: return l else: return len(nums) else: return m https://discuss.leetcode.com/topic/30370/python-one-liner-48ms Python one liner 48ms 12345678class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; return len([x for x in nums if x&lt;target]) Solution Mine: 64ms, 5.76%, June.18th, 2016 123456789101112131415class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if target &lt;= nums[0]: return 0 if target &gt; nums[-1]: return len(nums) rtype = 0 while target &gt; nums[rtype]: rtype += 1 return rtype 48ms, 60.93%, June.18th, 2016 https://leetcode.com/discuss/61347/python-beats-98%25 123456789101112131415161718192021222324252627282930313233class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if target &gt; nums[len(nums) - 1]: return len(nums) if target &lt; nums[0]: return 0 l, r = 0, len(nums) - 1 while l &lt;= r: m = (l + r)/2 if nums[m] &gt; target: r = m - 1 if r &gt;= 0: if nums[r] &lt; target: return r + 1 else: return 0 elif nums[m] &lt; target: l = m + 1 if l &lt; len(nums): if nums[l] &gt; target: return l else: return len(nums) else: return m java 0ms, 17.55%, June.18h, 2016 https://leetcode.com/discuss/23076/my-8-line-java-solution My 8 line Java solution 1234567891011public class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int low = 0, high = nums.length; while(low &lt; high)&#123; int mid = low + (high-low) / 2; if(nums[mid] &gt;= target) high = mid; else low = mid + 1; &#125; return low; &#125;&#125; https://discuss.leetcode.com/topic/31499/very-concise-and-efficient-solution-in-java Very concise and efficient solution in Java I have several solutions to this problem; this is the most concise and efficient one I have. 12345678910111213public class Solution &#123;public int searchInsert(int[] nums, int target) &#123; int low = 0, high = nums.length; while(low &lt; high) &#123; int mid = low + (high - low) / 2; if(nums[mid] &lt; target) low = mid + 1; else high = mid; &#125; return low;&#125;&#125; https://discuss.leetcode.com/topic/2661/simple-binary-search-solution Simple Binary Search Solution I think the solution does not need a lot of if statement. Only two cases: if found, just return current index if not found, return next index where the search end 12345678910int search(int A[], int start, int end, int target) &#123; if (start &gt; end) return start; int mid = (start + end) / 2; if (A[mid] == target) return mid; else if (A[mid] &gt; target) return search(A, start, mid - 1, target); else return search(A, mid + 1, end, target);&#125;int searchInsert(int A[], int n, int target) &#123; return search(A, 0, n - 1, target);&#125; https://discuss.leetcode.com/topic/4764/accepted-o-logn-java-solution-binary-search Accepted O(logN) Java solution, binary search 12345678910111213141516171819202122232425262728public class Solution &#123; public int searchInsert(int[] A, int target) &#123; if(A.length == 0)return 0; int left = 0, right = A.length - 1; int mid = 0; while(left &lt;= right)&#123; if(target&lt;A[left])return left; if(target&gt;A[right])return right+1; mid = (left+right)/2; if(A[mid]==target)return mid; else if(target &lt; A[mid])&#123; right = mid-1; &#125;else&#123; left = mid +1; &#125; &#125; return -1; &#125;&#125; https://discuss.leetcode.com/topic/20133/simple-java-solution Simple Java solution 1234567public int searchInsert(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt;= target) return i; &#125; return nums.length;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[034. Search for a Range]]></title>
    <url>%2Fp%2Fffb88a9b%2F</url>
    <content type="text"><![CDATA[34.1% https://leetcode.com/problems/search-for-a-range/ Given a sorted array of integers, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. 123For example,Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. 剑指offer 38 方法一： 先找最左侧边界，然后右侧边界 我的代码实现: 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int left, right; // 这里是nums.size() 不是nums.size()-1 int l = 0, r = nums.size(); while(l&lt;r)&#123; int mid = l+(r-l)/2; if(nums[mid]&gt;=target) r = mid; else l = mid+1; &#125; left = l; l = 0, r = nums.size(); while(l&lt;r)&#123; int mid = l+(r-l)/2; if(nums[mid]&lt;=target) l = mid+1; else r = mid; &#125; right = l; // lower_bound和upper_bound相等时，一定是不等于额 &gt;= &gt;相等 一定是大于 return left==right?vector&lt;int&gt;&#123;-1, -1&#125; : vector&lt;int&gt;&#123;left, right-1&#125;; &#125;&#125;; 还有就是学一下这种写法：vector {-1,-1} The standard and clean c++ binary search implementation. Yeah, binary search is quite simple, but many people write complex and error-prone code. 123456789101112131415161718192021vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int start = 0, end = nums.size(), mid, left, right; while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt;= target) end = mid; else start = mid + 1; &#125; left = start; start = 0, end = nums.size(); while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt; target) end = mid; else start = mid + 1; &#125; right = start; return left == right ? vector&lt;int&gt; &#123;-1,-1&#125; : vector&lt;int&gt; &#123;left,right-1&#125;;&#125; 方法二: 就是lower_bound upper_bound两个函数，但是要记得他们的边界，以及相应函数使用方法 还有使用迭代器求元素的位置索引的方法，以及返回vector怎么去初始化返回 1234567891011class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; auto itlow = lower_bound(nums.begin(), nums.end(), target); auto itup = upper_bound(nums.begin(), nums.end(), target); if(itlow==nums.end() || (*itlow)!=target) return &#123;-1, -1&#125;; else return &#123;itlow-nums.begin(), itup-nums.begin()-1&#125;; &#125;&#125;; cpp 12ms, 19.84%, June.22th, 2016 https://leetcode.com/discuss/18242/clean-iterative-solution-binary-searches-with-explanation Clean iterative solution with two binary searches (with explanation) The problem can be simply broken down as two binary searches for the begining and end of the range, respectively: First let’s find the left boundary of the range. We initialize the range to [i=0, j=n-1]. In each step, calculate the middle element [mid = (i+j)/2]. Now according to the relative value of A[mid] to target, there are three possibilities: If A[mid] &lt; target, then the range must begins on the right of mid (hence i = mid+1 for the next iteration) If A[mid] &gt; target, it means the range must begins on the left of mid (j = mid-1) If A[mid] = target, then the range must begins on the left of or at mid (j= mid) Since we would move the search range to the same side for case 2 and 3, we might as well merge them as one single case so that less code is needed: 12*. If A[mid] &gt;= target, j = mid; Surprisingly, 1 and 2* are the only logic you need to put in loop while (i &lt; j). When the while loop terminates, the value of i/j is where the start of the range is. Why? No matter what the sequence originally is, as we narrow down the search range, eventually we will be at a situation where there are only two elements in the search range. Suppose our target is 5, then we have only 7 possible cases: 1234567case 1: [5 7] (A[i] = target &lt; A[j])case 2: [5 3] (A[i] = target &gt; A[j])case 3: [5 5] (A[i] = target = A[j])case 4: [3 5] (A[j] = target &gt; A[i])case 5: [3 7] (A[i] &lt; target &lt; A[j])case 6: [3 4] (A[i] &lt; A[j] &lt; target)case 7: [6 7] (target &lt; A[i] &lt; A[j]) For case 1, 2 and 3, if we follow the above rule, since mid = i =&gt; A[mid] = target in these cases, then we would set j = mid. Now the loop terminates and i and j both point to the first 5. For case 4, since A[mid] &lt; target, then set i = mid+1. The loop terminates and both i and j point to 5. For all other cases, by the time the loop terminates, A[i] is not equal to 5. So we can easily know 5 is not in the sequence if the comparison fails. In conclusion, when the loop terminates, if A[i]==target, then i is the left boundary of the range; otherwise, just return -1; For the right of the range, we can use a similar idea. Again we can come up with several rules: If A[mid] &gt; target, then the range must begins on the left of mid (j = mid-1) If A[mid] &lt; target, then the range must begins on the right of mid (hence i = mid+1 for the next iteration) If A[mid] = target, then the range must begins on the right of or at mid (i= mid) Again, we can merge condition 2 and 3 into: 12* If A[mid] &lt;= target, then i = mid; However, the terminate condition on longer works this time. Consider the following case: 1[5 7], target = 5 Now A[mid] = 5, then according to rule 2, we set i = mid. This practically does nothing because i is already equal to mid. As a result, the search range is not moved at all! The solution is by using a small trick: instead of calculating mid as mid = (i+j)/2, we now do: 1mid = (i+j)/2+1 Why does this trick work? When we use mid = (i+j)/2, the mid is rounded to the lowest integer. In other words, mid is always biased towards the left. This means we could have i == mid when j - i == mid, but we NEVER have j == mid. So in order to keep the search range moving, you must make sure the new i is set to something different than mid, otherwise we are at the risk that i gets stuck. But for the new j, it is okay if we set it to mid, since it was not equal to mid anyways. Our two rules in search of the left boundary happen to satisfy these requirements, so it works perfectly in that situation. Similarly, when we search for the right boundary, we must make sure i won’t get stuck when we set the new i to i = mid. The easiest way to achieve this is by making mid biased to the right, i.e. mid = (i+j)/2+1. All this reasoning boils down to the following simple code: 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int i = 0, j = nums.size() - 1; vector&lt;int&gt; ret(2, -1); while(i &lt; j)&#123; int mid = (i + j) / 2; if(nums[mid] &lt; target) i = mid + 1; else j = mid; &#125; if(nums[i] != target) return ret; else ret[0] = i; j = nums.size() - 1; while(i &lt; j)&#123; int mid = (i + j) / 2 + 1; if(nums[mid] &gt; target) j = mid - 1; else i = mid; &#125; ret[1] = j; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/19437/the-standard-and-clean-c-binary-search-implementation The standard and clean c++ binary search implementation. Yeah, binary search is quite simple, but many people write complex and error-prone code. 123456789101112131415161718192021vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int start = 0, end = nums.size(), mid, left, right; while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt;= target) end = mid; else start = mid + 1; &#125; left = start; start = 0, end = nums.size(); while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt; target) end = mid; else start = mid + 1; &#125; right = start; return left == right ? vector&lt;int&gt; &#123;-1,-1&#125; : vector&lt;int&gt; &#123;left,right-1&#125;;&#125; python 56ms, 46.67%, June.22th, 2016 https://leetcode.com/discuss/18242/clean-iterative-solution-binary-searches-with-explanation 123456789101112131415161718192021222324252627282930class Solution(object): def searchRange(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; l, r = 0, len(nums) - 1 res = [-1, -1] while(l &lt; r): mid = (l + r) / 2 if nums[mid] &lt; target: l = mid + 1 else: r = mid if nums[l] != target: return res else: res[0] = l r = len(nums) - 1 while(l &lt; r): mid = (l + r) / 2 + 1 if nums[mid] &gt; target: r = mid - 1 else: l = mid res[1] = r return res 52ms, 65.78%, June.22th, 2016 https://leetcode.com/discuss/18242/clean-iterative-solution-binary-searches-with-explanation 123456789101112131415161718192021222324252627282930313233class Solution(object): def searchRange(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; if not nums: return [-1, -1] l, r = 0, len(nums) - 1 res = [-1, -1] while(l &lt; r): mid = (l + r) / 2 if nums[mid] &lt; target: l = mid + 1 else: r = mid if nums[l] != target: return res else: res[0] = l r = len(nums) - 1 while(l &lt; r): mid = (l + r) / 2 + 1 if nums[mid] &gt; target: r = mid - 1 else: l = mid res[1] = r return res https://discuss.leetcode.com/topic/16486/9-11-lines-o-log-n 9-11 lines O(log n) Solution 1 : Divide and Conquer with early breaks : 56 ms The O(log n) time isn’t quite obvious, so I’ll explain it below. Or you can take the challenge and prove it yourself :-) 12345678910def searchRange(self, nums, target): def search(lo, hi): if nums[lo] == target == nums[hi]: return [lo, hi] if nums[lo] &lt;= target &lt;= nums[hi]: mid = (lo + hi) / 2 l, r = search(lo, mid), search(mid+1, hi) return max(l, r) if -1 in l+r else [l[0], r[1]] return [-1, -1] return search(0, len(nums)-1) The search helper function returns an index range just like the requested searchRange function, but only searches in nums[lo..hi]. It first compares the end points and immediately returns [lo, hi] if that whole part of nums is full of target, and immediately returns [-1, -1] if target is outside the range. The interesting case is when target can be in the range but doesn’t fill it completely. In that case, we split the range in left and right half, solve them recursively, and combine their results appropriately. Why doesn’t this explode exponentially? Well, let’s call the numbers in the left half A, …, B and the numbers in the right half C, …, D. Now if one of them immediately return their [lo, hi] or [-1, -1], then this doesn’t explode. And if neither immediately returns, that means we have A &lt;= target &lt;= B and C &lt;= target &lt;= D. And since nums is sorted, we actually have target &lt;= B &lt;= C &lt;= target, so B = C = target. The left half thus ends with target and the right half starts with it. I highlight that because it’s important. Now consider what happens further. The left half gets halved again. Call the middle elements a and b, so the left half is A, …, a, b, …, B. Then a &lt;= target and: If a &lt; target, then the call analyzing A, …, a immediately returns [-1, -1] and we only look further into b, …, B which is again a part that ends with target. If a == target, then a = b = … = B = target and thus the call analyzing b, …, B immediately returns its [lo, hi] and we only look further into A, …, a which is again a part that ends with target.Same for the right half C, …, D. So in the beginning of the search, as long as target is only in at most one of the two halves (so the other immediately stops), we have a single path. And if we ever come across the case where target is in both halves, then we split into two paths, but then each of those remains a single path. And both paths are only O(log n) long, so we have overall runtime O(log n). This is btw based on us917’s solution. 1234567891011121314Solution 2 : Two binary searches : 56 msdef searchRange(self, nums, target): def search(n): lo, hi = 0, len(nums) while lo &lt; hi: mid = (lo + hi) / 2 if nums[mid] &gt;= n: hi = mid else: lo = mid + 1 return lo lo = search(target) return [lo, search(target+1)-1] if target in nums[lo:lo+1] else [-1, -1] Here, my helper function is a simple binary search, telling me the first index where I could insert a number n into nums to keep it sorted. Thus, if nums contains target, I can find the first occurrence with search(target). I do that, and if target isn’t actually there, then I return [-1, -1]. Otherwise, I ask search(target+1), which tells me the first index where I could insert target+1, which of course is one index behind the last index containing target, so all I have left to do is subtract 1. Solution 3 : Two binary searches, using the library Binary search is so good and common that many languages have it in their standard library and you just need to figure out how to apply it to the problem at hand. Python: 123def searchRange(self, nums, target): lo = bisect.bisect_left(nums, target) return [lo, bisect.bisect(nums, target)-1] if target in nums[lo:lo+1] else [-1, -1] C++: 123456vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; auto bounds = equal_range(nums.begin(), nums.end(), target); return *bounds.first != target ? vector&lt;int&gt; &#123;-1, -1&#125; : vector&lt;int&gt; &#123;bounds.first - nums.begin(), bounds.second - nums.begin() - 1&#125;;&#125; Or: 1234567vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = lower_bound(nums.begin(), nums.end(), target) - nums.begin(); if (nums[lo] != target) return vector&lt;int&gt; &#123;-1, -1&#125;; int hi = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1; return vector&lt;int&gt; &#123;lo, hi&#125;;&#125; Java: Well, Java decided to be annoying and offer Arrays.binSearch but with “If the array contains multiple elements with the specified value, there is no guarantee which one will be found”. So it’s useless for us. I’m not good at Java, though, so maybe I’m overlooking a way to still make it work. If you manage to do so, please let me know. java https://discuss.leetcode.com/topic/6327/a-very-simple-java-solution-with-only-one-binary-search-algorithm/2 A very simple Java solution, with only one binary search algorithm 12345678910111213141516171819202122232425262728public class Solution &#123; public int[] searchRange(int[] A, int target) &#123; int start = Solution.firstGreaterEqual(A, target); if (start == A.length || A[start] != target) &#123; return new int[]&#123;-1, -1&#125;; &#125; return new int[]&#123;start, Solution.firstGreaterEqual(A, target + 1) - 1&#125;; &#125; //find the first number that is greater than or equal to target. //could return A.length if target is greater than A[A.length-1]. //actually this is the same as lower_bound in C++ STL. private static int firstGreaterEqual(int[] A, int target) &#123; int low = 0, high = A.length; while (low &lt; high) &#123; int mid = low + ((high - low) &gt;&gt; 1); //low &lt;= mid &lt; high if (A[mid] &lt; target) &#123; low = mid + 1; &#125; else &#123; //should not be mid-1 when A[mid]==target. //could be mid even if A[mid]&gt;target because mid&lt;high. high = mid; &#125; &#125; return low; &#125;&#125; https://discuss.leetcode.com/topic/10692/simple-and-strict-o-logn-solution-in-java-using-recursion Simple and strict O(logn) solution in Java using recursion 123456789101112131415161718192021222324252627public class Solution &#123; public int[] searchRange(int[] A, int target) &#123; int[] range = &#123;A.length, -1&#125;; searchRange(A, target, 0, A.length - 1, range); if (range[0] &gt; range[1]) range[0] = -1; return range; &#125; public void searchRange(int[] A, int target, int left, int right, int[] range) &#123; if (left &gt; right) return; int mid = left + (right - left) / 2; if (A[mid] == target) &#123; if (mid &lt; range[0]) &#123; range[0] = mid; searchRange(A, target, left, mid - 1, range); &#125; if (mid &gt; range[1]) &#123; range[1] = mid; searchRange(A, target, mid + 1, right, range); &#125; &#125; else if (A[mid] &lt; target) &#123; searchRange(A, target, mid + 1, right, range); &#125; else &#123; searchRange(A, target, left, mid - 1, range); &#125; &#125;&#125; https://discuss.leetcode.com/topic/21783/easy-java-o-logn-solution Easy java O(logn) solution There must be two indices in the array. Which means, we can just simply apply to binary search twice to find each index of the target element. 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123;public int[] searchRange(int[] nums, int target) &#123; int[] result = new int[2]; result[0] = findFirst(nums, target); result[1] = findLast(nums, target); return result;&#125;private int findFirst(int[] nums, int target)&#123; int idx = -1; int start = 0; int end = nums.length - 1; while(start &lt;= end)&#123; int mid = (start + end) / 2; if(nums[mid] &gt;= target)&#123; end = mid - 1; &#125;else&#123; start = mid + 1; &#125; if(nums[mid] == target) idx = mid; &#125; return idx;&#125;private int findLast(int[] nums, int target)&#123; int idx = -1; int start = 0; int end = nums.length - 1; while(start &lt;= end)&#123; int mid = (start + end) / 2; if(nums[mid] &lt;= target)&#123; start = mid + 1; &#125;else&#123; end = mid - 1; &#125; if(nums[mid] == target) idx = mid; &#125; return idx;&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[033. Search in Rotated Sorted Array]]></title>
    <url>%2Fp%2Ff6d1f394%2F</url>
    <content type="text"><![CDATA[32.1% https://leetcode.com/problems/search-in-rotated-sorted-array/ Suppose a sorted array is rotated at some pivot unknown to you beforehand. 1(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 方法一： 二分查找 面试奇虎360曾遇到过 我的代码实现，最清晰最明了。 简单易懂。就按这个来了。 设定一个左index，一个右index。肯定要用到中间的index，即mid。 在循环里面，首先算出mid的值，然后如果中间值等于target，返回结果。否则就要搜索了。 怎么搜索呢，要分情况讨论，现在有的值是left，right，mid 和target，用什么分好呢？ 用不用target？答案是不用。要用left和mid这样的值来比较，判断当前所处的环境， 即左半部分的情况，看左边是上升，还是先上升后从最小值上升。 右边是上升还是从最小值上升。 1234567891011121314151617181920212223242526class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if(n==0) return -1; int left=0, right = n-1; while(left&lt;=right)&#123; int mid = left+(right-left)/2; if(nums[mid]==target) return mid; if(nums[left]&lt;=nums[mid])&#123; // 这里是&lt;= 而不是&lt;，因为left可能=mid的情况，否则不能通过。 if(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid])&#123; right = mid-1; &#125;else&#123; left = mid+1; &#125; &#125;else&#123; if(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right]) left = mid+1; else right = mid-1; &#125; &#125; return -1; &#125;&#125;; 方法二： Revised Binary Search 这种方法较好，最后return需要判断与target的关系 1234567891011121314151617181920212223public int search(int[] A, int target) &#123; int lo = 0; int hi = A.length - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if (A[mid] == target) return mid; if (A[lo] &lt;= A[mid]) &#123; if (target &gt;= A[lo] &amp;&amp; target &lt; A[mid]) &#123; hi = mid - 1; &#125; else &#123; lo = mid + 1; &#125; &#125; else &#123; if (target &gt; A[mid] &amp;&amp; target &lt;= A[hi]) &#123; lo = mid + 1; &#125; else &#123; hi = mid - 1; &#125; &#125; &#125; return A[lo] == target ? lo : -1;&#125; cpp https://discuss.leetcode.com/topic/7711/revised-binary-search Revised Binary Search 1234567891011121314151617181920212223public int search(int[] A, int target) &#123; int lo = 0; int hi = A.length - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if (A[mid] == target) return mid; if (A[lo] &lt;= A[mid]) &#123; if (target &gt;= A[lo] &amp;&amp; target &lt; A[mid]) &#123; hi = mid - 1; &#125; else &#123; lo = mid + 1; &#125; &#125; else &#123; if (target &gt; A[mid] &amp;&amp; target &lt;= A[hi]) &#123; lo = mid + 1; &#125; else &#123; hi = mid - 1; &#125; &#125; &#125; return A[lo] == target ? lo : -1;&#125; https://discuss.leetcode.com/topic/34491/clever-idea-making-it-simple Clever idea making it simple This very nice idea is from rantos22’s solution who sadly only commented “You are not expected to understand that :)”, which I guess is the reason it’s now it’s hidden among the most downvoted solutions. I present an explanation and a more usual implementation. Explanation Let’s say nums looks like this: [12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] Because it’s not fully sorted, we can’t do normal binary search. But here comes the trick: If target is let’s say 14, then we adjust nums to this, where “inf” means infinity:[12, 13, 14, 15, 16, 17, 18, 19, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf] If target is let’s say 7, then we adjust nums to this:[-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] And then we can simply do ordinary binary search. Of course we don’t actually adjust the whole array but instead adjust only on the fly only the elements we look at. And the adjustment is done by comparing both the target and the actual element against nums[0]. Code If nums[mid] and target are “on the same side” of nums[0], we just take nums[mid]. Otherwise we use -infinity or +infinity as needed. 123456789101112131415161718int search(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, hi = nums.size(); while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; double num = (nums[mid] &lt; nums[0]) == (target &lt; nums[0]) ? nums[mid] : target &lt; nums[0] ? -INFINITY : INFINITY; if (num &lt; target) lo = mid + 1; else if (num &gt; target) hi = mid; else return mid; &#125; return -1;&#125; python https://discuss.leetcode.com/topic/13096/python-binary-search-solution-o-logn-48ms Python binary search solution - O(logn) - 48ms 123456789101112131415161718192021222324252627class Solution: # @param &#123;integer[]&#125; numss # @param &#123;integer&#125; target # @return &#123;integer&#125; def search(self, nums, target): if not nums: return -1 low, high = 0, len(nums) - 1 while low &lt;= high: mid = (low + high) / 2 if target == nums[mid]: return mid if nums[low] &lt;= nums[mid]: if nums[low] &lt;= target &lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &lt;= target &lt;= nums[high]: low = mid + 1 else: high = mid - 1 return -1 https://discuss.leetcode.com/topic/34467/pretty-short-c-java-ruby-python Pretty short C++/Java/Ruby/Python Explanation below the codes. Python: 123456789def search(self, nums, target): lo, hi = 0, len(nums) - 1 while lo &lt; hi: mid = (lo + hi) / 2 if (nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid]): lo = mid + 1 else: hi = mid return lo if target in nums[lo:lo+1] else -1 Python using bisect: 123456class Solution: def search(self, nums, target): self.__getitem__ = lambda i: \ (nums[0] &lt;= target) ^ (nums[0] &gt; nums[i]) ^ (target &gt; nums[i]) i = bisect.bisect_left(self, True, 0, len(nums)) return i if target in nums[i:i+1] else -1 C++: 1234567891011int search(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, hi = int(nums.size()) - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid])) lo = mid + 1; else hi = mid; &#125; return lo == hi &amp;&amp; nums[lo] == target ? lo : -1;&#125; Java: 1234567891011public int search(int[] nums, int target) &#123; int lo = 0, hi = nums.length - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid])) lo = mid + 1; else hi = mid; &#125; return lo == hi &amp;&amp; nums[lo] == target ? lo : -1;&#125; Explanation My solutions use binary search guided by the following thoughts: Remember the array is sorted, except it might drop at one point. 12345678If nums[0] &lt;= nums[i], then nums[0..i] is sorted (in case of &quot;==&quot; it&apos;s just one element, and in case of &quot;&lt;&quot; there must be a drop elsewhere). So we should keep searching in nums[0..i] if the target lies in this sorted range, i.e., if nums[0] &lt;= target &lt;= nums[i].If nums[i] &lt; nums[0], then nums[0..i] contains a drop, and thus nums[i+1..end] is sorted and lies strictly between nums[i] and nums[0]. So we should keep searching in nums[0..i] if the target doesn&apos;t lie strictly between them, i.e., if target &lt;= nums[i] &lt; nums[0] or nums[i] &lt; nums[0] &lt;= target Those three cases look cyclic: 123nums[0] &lt;= target &lt;= nums[i] target &lt;= nums[i] &lt; nums[0] nums[i] &lt; nums[0] &lt;= target So I have the three checks (nums[0] &lt;= target), (target &lt;= nums[i]) and (nums[i] &lt; nums[0]), and I want to know whether exactly two of them are true. They can’t all be true or all be false (check it), so I just need to distinguish between “two true” and “one true”. Parity is enough for that, so instead of adding them I xor them, which is a bit shorter and particularly helpful in Java and Ruby, because those don’t let me add booleans but do let me xor them. (Actually while developing this I thought of permutations of nums[0], target and nums[i] and the permutation parity and saw those three checks as representing inversions, but I had trouble putting that into words and now find the above explanation much better. But it helped me get there, so I wanted to mention it here.) java https://discuss.leetcode.com/topic/3538/concise-o-log-n-binary-search-solution Concise O(log N) Binary search solution 1234567891011121314151617181920212223242526class Solution &#123;public: int search(int A[], int n, int target) &#123; int lo=0,hi=n-1; // find the index of the smallest value using binary search. // Loop will terminate since mid &lt; hi, and lo or hi will shrink by at least 1. // Proof by contradiction that mid &lt; hi: if mid==hi, then lo==hi and loop would have been terminated. while(lo&lt;hi)&#123; int mid=(lo+hi)/2; if(A[mid]&gt;A[hi]) lo=mid+1; else hi=mid; &#125; // lo==hi is the index of the smallest value and also the number of places rotated. int rot=lo; lo=0;hi=n-1; // The usual binary search and accounting for rotation. while(lo&lt;=hi)&#123; int mid=(lo+hi)/2; int realmid=(mid+rot)%n; if(A[realmid]==target)return realmid; if(A[realmid]&lt;target)lo=mid+1; else hi=mid-1; &#125; return -1; &#125;&#125;; https://discuss.leetcode.com/topic/16580/java-ac-solution-using-once-binary-search Java AC Solution using once binary search The idea is that when rotating the array, there must be one half of the array that is still in sorted order.For example, 6 7 1 2 3 4 5, the order is disrupted from the point between 7 and 1. So when doing binary search, we can make a judgement that which part is ordered and whether the target is in that range, if yes, continue the search in that half, if not continue in the other half. 1234567891011121314151617181920212223242526public class Solution &#123; public int search(int[] nums, int target) &#123; int start = 0; int end = nums.length - 1; while (start &lt;= end)&#123; int mid = (start + end) / 2; if (nums[mid] == target) return mid; if (nums[start] &lt;= nums[mid])&#123; if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) end = mid - 1; else start = mid + 1; &#125; if (nums[mid] &lt;= nums[end])&#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) start = mid + 1; else end = mid - 1; &#125; &#125; return -1; &#125;&#125; https://discuss.leetcode.com/topic/8889/binary-search-java-solusion-o-log-n Binary Search, Java Solusion. O(log(n)) 1234567891011121314151617181920212223242526public int search(int[] A, int target) &#123; if (A.length == 0) return -1; int L = 0, R = A.length-1; // if (target &lt; A[L] &amp;&amp; target &gt; A[R]) return -1; while (L &lt; R) &#123; int M = (L + R)/2; if (A[M] &lt;= A[R]) &#123; if (target &gt; A[M] &amp;&amp; target &lt;= A[R]) &#123; L = M+1; &#125; else &#123; R = M; &#125; &#125; else &#123; if (target &lt;= A[M] &amp;&amp; target &gt;= A[L]) &#123; R = M; &#125; else &#123; L = M+1; &#125; &#125; &#125; if (A[L] == target) return L; else return -1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[032. Longest Valid Parentheses]]></title>
    <url>%2Fp%2F3f681304%2F</url>
    <content type="text"><![CDATA[23.1% https://leetcode.com/problems/longest-valid-parentheses/ Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring. 12345For &quot;(()&quot;, the longest valid parentheses substring is &quot;()&quot;, which has length = 2.Another example is &quot;)()())&quot;, where the longest valid parentheses substring is &quot;()()&quot;, which has length = 4. 方法一： 这种方法很巧妙，用了栈，并且栈里存储索引位置 My O(n) solution using a stack The workflow of the solution is as below. Scan the string from beginning to end. If current character is ‘(‘, push its index to the stack. If current character is ‘)’ and the character at the index of the top of stack is ‘(‘, we just find a matching pair so pop from the stack. Otherwise, we push the index of ‘)’ to the stack. After the scan is done, the stack will only contain the indices of characters which cannot be matched. Then let’s use the opposite side - substring between adjacent indices should be valid parentheses. If the stack is empty, the whole input string is valid. Otherwise, we can scan the stack to get longest valid substring as described in step 3. 123456789101112131415161718192021222324252627282930class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.length(), longest = 0; stack&lt;int&gt; st; for(int i=0; i&lt;n; i++)&#123; if(s[i]==&apos;(&apos;) st.push(i); else&#123; if(!st.empty())&#123; if(s[st.top()]==&apos;(&apos;) st.pop(); else st.push(i); &#125; else st.push(i); &#125; &#125; if(st.empty()) longest = n; else&#123; int a=n, b=0; while(!st.empty())&#123; b = st.top(); st.pop(); longest = max(longest, a-b-1); a = b; &#125; longest = max(longest, a); &#125; return longest; &#125;&#125;; 我的代码实现: 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.size(); if(n==0) return 0; // 对于字符串，stack可以保存具体的字符，也可以保存index // 保存index就是一种常见的操作，本处就是保存的index stack&lt;int&gt; stack; for(int i=0; i&lt;n; i++)&#123; if(s[i]=='(') stack.push(i); else&#123; if(!stack.empty() &amp;&amp; s[stack.top()]=='(') stack.pop(); else stack.push(i); &#125; &#125; if(stack.empty()) return n; int start = 0, end = n, res = 0; while(!stack.empty())&#123; start = stack.top(); // 别忘了将stack的值给pop出去 stack.pop(); res = max(res, end-start-1); end = start; &#125; // 不重不漏， 这一步要考虑周全 res = max(res, start); return res; &#125;&#125;; 我的代码实现二: 对上面的代码优化了一下 12345678910111213141516171819202122232425262728class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.size(); if(n==0) return 0; // 对于字符串，stack可以保存具体的字符，也可以保存index // 保存index就是一种常见的操作，本处就是保存的index stack&lt;int&gt; stack; for(int i=0; i&lt;n; i++)&#123; if(s[i]==')' &amp;&amp; !stack.empty() &amp;&amp; s[stack.top()]=='(') stack.pop(); else stack.push(i); &#125; if(stack.empty()) return n; int start = 0, end = n, res = 0; while(!stack.empty())&#123; start = stack.top(); // 别忘了将stack的值给pop出去 stack.pop(); res = max(res, end-start-1); end = start; &#125; // 不重不漏， 这一步要考虑周全 res = max(res, start); return res; &#125;&#125;; cpp September 22, 2016 https://discuss.leetcode.com/topic/2289/my-o-n-solution-using-a-stack My O(n) solution using a stack The workflow of the solution is as below. Scan the string from beginning to end. If current character is ‘(‘, push its index to the stack. If current character is ‘)’ and the character at the index of the top of stack is ‘(‘, we just find a matching pair so pop from the stack. Otherwise, we push the index of ‘)’ to the stack. After the scan is done, the stack will only contain the indices of characters which cannot be matched. Then let’s use the opposite side - substring between adjacent indices should be valid parentheses. If the stack is empty, the whole input string is valid. Otherwise, we can scan the stack to get longest valid substring as described in step 3.123456789101112131415161718192021222324252627282930class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.length(), longest = 0; stack&lt;int&gt; st; for(int i=0; i&lt;n; i++)&#123; if(s[i]==&apos;(&apos;) st.push(i); else&#123; if(!st.empty())&#123; if(s[st.top()]==&apos;(&apos;) st.pop(); else st.push(i); &#125; else st.push(i); &#125; &#125; if(st.empty()) longest = n; else&#123; int a=n, b=0; while(!st.empty())&#123; b = st.top(); st.pop(); longest = max(longest, a-b-1); a = b; &#125; longest = max(longest, a); &#125; return longest; &#125;&#125;; https://discuss.leetcode.com/topic/2426/my-dp-o-n-solution-without-using-stack My DP, O(n) solution without using stack My solution uses DP. The main idea is as follows: I construct a array longest[], for any longest[i], it stores the longest length of valid parentheses which is end at i. And the DP idea is : If s[i] is ‘(‘, set longest[i] to 0,because any string end with ‘(‘ cannot be a valid one. Else if s[i] is ‘)’ If s[i-1] is &apos;(&apos;, longest[i] = longest[i-2] + 2 Else if s[i-1] is &apos;)&apos; and s[i-longest[i-1]-1] == &apos;(&apos;, longest[i] = longest[i-1] + 2 + longest[i-longest[i-1]-2] For example, input “()(())”, at i = 5, longest array is [0,2,0,0,2,0], longest[5] = longest[4] + 2 + longest[1] = 6. 123456789101112131415161718192021int longestValidParentheses(string s) &#123; if(s.length() &lt;= 1) return 0; int curMax = 0; vector&lt;int&gt; longest(s.size(),0); for(int i=1; i &lt; s.length(); i++)&#123; if(s[i] == &apos;)&apos;)&#123; if(s[i-1] == &apos;(&apos;)&#123; longest[i] = (i-2) &gt;= 0 ? (longest[i-2] + 2) : 2; curMax = max(longest[i],curMax); &#125; else&#123; // if s[i-1] == &apos;)&apos;, combine the previous length. if(i-longest[i-1]-1 &gt;= 0 &amp;&amp; s[i-longest[i-1]-1] == &apos;(&apos;)&#123; longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 &gt;= 0)?longest[i-longest[i-1]-2]:0); curMax = max(longest[i],curMax); &#125; &#125; &#125; //else if s[i] == &apos;(&apos;, skip it, because longest[i] must be 0 &#125; return curMax; &#125; Updated: thanks to Philip0116, I have a more concise solution(though this is not as readable as the above one, but concise): 123456789101112int longestValidParentheses(string s) &#123; if(s.length() &lt;= 1) return 0; int curMax = 0; vector&lt;int&gt; longest(s.size(),0); for(int i=1; i &lt; s.length(); i++)&#123; if(s[i] == &apos;)&apos; &amp;&amp; i-longest[i-1]-1 &gt;= 0 &amp;&amp; s[i-longest[i-1]-1] == &apos;(&apos;)&#123; longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 &gt;= 0)?longest[i-longest[i-1]-2]:0); curMax = max(longest[i],curMax); &#125; &#125; return curMax; &#125; https://discuss.leetcode.com/topic/14690/my-simple-8ms-c-code My simple 8ms C++ code 1234567891011121314151617181920class Solution &#123;public: int longestValidParentheses(string s) &#123; stack&lt;int&gt; stk; stk.push(-1); int maxL=0; for(int i=0;i&lt;s.size();i++) &#123; int t=stk.top(); if(t!=-1&amp;&amp;s[i]==&apos;)&apos;&amp;&amp;s[t]==&apos;(&apos;) &#123; stk.pop(); maxL=max(maxL,i-stk.top()); &#125; else stk.push(i); &#125; return maxL; &#125;&#125;; https://discuss.leetcode.com/topic/2745/my-solution-using-one-stack-in-one-pass My solution using one stack in one pass Since any valid parentheses sequence starts from a ‘(‘ and ends at ‘)’, we can calculate new length when we meet a ‘)’. The key is to use a stack to store all the indices and the start position is always the one on top of the stack. See the code below for details. 12345678910111213141516171819202122// Using a stack. One passint longestValidParentheses(string s) &#123; vector&lt;int&gt; stack; int maxLen = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] == &apos;(&apos;) stack.push_back(i); else &#123; if (!stack.empty() &amp;&amp; s[stack.back()] == &apos;(&apos;) &#123; stack.pop_back(); int lastPos = -1; if (!stack.empty()) lastPos = stack.back(); int curLen = i - lastPos; maxLen = (maxLen &lt; curLen) ? curLen : maxLen; &#125; else stack.push_back(i); &#125; &#125; return maxLen;&#125; https://discuss.leetcode.com/topic/22287/constant-space-o-n-time-with-forward-and-backward-pass Constant space, O(n) time with forward and backward pass When right parentheses are more than left parentheses in the forward pass, we can discard previous parentheses. In the backward pass, when left parentheses are more than right parentheses, we can discard previous parentheses. 123456789101112131415161718192021222324252627282930313233343536373839404142434445int longestValidParentheses(string s) &#123; int longest = 0; int extra=0; int length=0; for(int i=0; i&lt;s.size(); i++) &#123; if(s[i] == &apos;(&apos;) &#123; extra++; length++; &#125; else &#123; if(extra&gt;0) &#123; extra--; length++; if(extra == 0) longest = max(longest, length); &#125; else &#123; extra = 0; length=0; &#125; &#125; &#125; length = 0; extra=0; for(int i=s.size()-1; i&gt;=0; i--) &#123; if(s[i] == &apos;)&apos;) &#123; extra++; length++; &#125; else &#123; if(extra&gt;0)&#123; extra--; length++; if(extra == 0) longest = max(longest, length); &#125; else &#123; extra = 0; length=0; &#125; &#125; &#125; return longest;&#125; python https://discuss.leetcode.com/topic/23559/pure-1d-dp-without-using-stack-python-with-detailed-explanation Pure 1D-DP without using stack (python) with detailed explanation 123456789101112131415161718192021222324252627class Solution(object): def longestValidParentheses(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; # use 1D DP # dp[i] records the longestValidParenthese EXACTLY ENDING at s[i] dp = [0 for x in xrange(len(s))] max_to_now = 0 for i in xrange(1,len(s)): if s[i] == &apos;)&apos;: # case 1: ()() if s[i-1] == &apos;(&apos;: # add nearest parentheses pairs + 2 dp[i] = dp[i-2] + 2 # case 2: (()) # i-dp[i-1]-1 is the index of last &quot;(&quot; not paired until this &quot;)&quot; elif i-dp[i-1]-1 &gt;= 0 and s[i-dp[i-1]-1] == &apos;(&apos;: if dp[i-1] &gt; 0: # content within current matching pair is valid # add nearest parentheses pairs + 2 + parentheses before last &quot;(&quot; dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2] else: # otherwise is 0 dp[i] = 0 max_to_now = max(max_to_now, dp[i]) return max_to_now java https://discuss.leetcode.com/topic/7234/simple-java-solution-o-n-time-one-stack Simple JAVA solution, O(n) time, one stack 12345678910111213141516171819public class Solution &#123; public int longestValidParentheses(String s) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int max=0; int left = -1; for(int j=0;j&lt;s.length();j++)&#123; if(s.charAt(j)==&apos;(&apos;) stack.push(j); else &#123; if (stack.isEmpty()) left=j; else&#123; stack.pop(); if(stack.isEmpty()) max=Math.max(max,j-left); else max=Math.max(max,j-stack.peek()); &#125; &#125; &#125; return max; &#125;&#125; https://discuss.leetcode.com/topic/7234/simple-java-solution-o-n-time-one-stack/3 Nice solution! Inspired by your solution. I changed a little to make it shorter and easier. 12345678910111213141516public class Solution &#123; public int longestValidParentheses(String s) &#123; LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); int result = 0; stack.push(-1); for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == &apos;)&apos; &amp;&amp; stack.size() &gt; 1 &amp;&amp; s.charAt(stack.peek()) == &apos;(&apos;) &#123; stack.pop(); result = Math.max(result, i - stack.peek()); &#125; else &#123; stack.push(i); &#125; &#125; return result; &#125;&#125; The idea is simple, we only update the result (max) when we find a “pair”. If we find a pair. We throw this pair away and see how big the gap is between current and previous invalid. EX: “( )( )” stack: -1, 0, when we get to index 1 “)”, the peek is “(“ so we pop it out and see what’s before “(“. In this example it’s -1. So the gap is “current_index” - (-1) = 2. The idea only update the result (max) when we find a “pair” and push -1 to stack first covered all edge cases. https://discuss.leetcode.com/topic/37982/my-easy-o-n-java-solution-with-explanation My easy O(n) java solution with explanation 1234567891011121314151617181920212223public class Solution &#123; public int longestValidParentheses(String s) &#123; int res=0; int tep=0; Stack&lt;Integer&gt; s1=new Stack&lt;&gt;(); int data[]=new int[s.length()]; for(int i=0;i&lt;s.length();i++)&#123; char c=s.charAt(i); if(c==&apos;(&apos;) s1.push(i); else&#123; if(!s1.empty())&#123; data[i]=1; data[s1.pop()]=1; &#125; &#125; &#125; for(int i:data)&#123; if(i==1) tep++; else &#123;res=Math.max(tep,res);tep=0;&#125; &#125; return Math.max(tep,res); &#125;&#125; Imaging we are coloring the original string, each substring that has valid parentheses is colored with ‘1’ and other characters are colored by ‘0’. For example “( ) ( ( ) “would become “11011”. Thus, the problem has converted to finding the longest subsequence that all elements are ‘1’, which could be easily solved. https://discuss.leetcode.com/topic/8305/simple-java-solution Simple Java solution. 123456789101112131415public int longestValidParentheses(String s) &#123; char[] S = s.toCharArray(); int[] V = new int[S.length]; int open = 0; int max = 0; for (int i=0; i&lt;S.length; i++) &#123; if (S[i] == &apos;(&apos;) open++; if (S[i] == &apos;)&apos; &amp;&amp; open &gt; 0) &#123; V[i] = 2 + V[i-1] + (i-2-V[i-1] &gt; 0 ? V[i-2-V[i-1]] : 0); open--; &#125; if (V[i] &gt; max) max = V[i]; &#125; return max;&#125; https://discuss.leetcode.com/topic/12200/explaining-solution-using-stack Explaining solution using Stack I have seen a lot of good answers but it is not immediately clear how they are achieving the result. I am going to make an attempt to explain my solution using a stack. Every time we encounter ‘(‘ we push the index onto the stack and when we encounter ‘)’ we pop the stack and use the current index minus the index at the top of the stack to be the current_length. we check against the max found so far and update if needed. Here is the code 1234567891011121314151617181920212223242526272829303132333435public static int longestValidParentheses(String s) &#123; Stack&lt;Integer&gt; bracketStack = new Stack&lt;Integer&gt;(); int max_len=0; int current_len=0; int last = -1; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == &apos;(&apos;) &#123; bracketStack.push(i); &#125; else&#123; if(!bracketStack.isEmpty()) &#123; bracketStack.pop(); if(!bracketStack.isEmpty()) current_len = i-bracketStack.peek(); else current_len=i-last; max_len = Math.max(max_len,current_len); &#125; else&#123; last = i; &#125; &#125; &#125; return max_len; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[031. Next Permutation]]></title>
    <url>%2Fp%2F3f16d422%2F</url>
    <content type="text"><![CDATA[28.8% https://leetcode.com/problems/next-permutation/ Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. 12345Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 方法一： 我的代码实现: 123456789101112131415161718192021222324252627class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return; int left = n-2; while(left&gt;=0)&#123; if(nums[left]&lt;nums[left+1]) break; left--; &#125; if(left&lt;0)&#123; reverse(nums.begin(), nums.end()); return; &#125; int right = n - 1; while(right&gt;=0)&#123; if(nums[right]&gt;nums[left]) break; right--; &#125; swap(nums[left], nums[right]); reverse(nums.begin()+left+1, nums.end()); return; &#125;&#125;; 我的代码实现: 1234567891011121314151617181920212223242526class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==1) return; int i = n-2; while(i&gt;=0)&#123; if(nums[i+1]&gt;nums[i]) break; i--; &#125; if(i&lt;0)&#123; reverse(nums.begin(), nums.end()); return; &#125; int j = n-1; while(j&gt;0)&#123; if(nums[j]&gt;nums[i]) break; j--; &#125; swap(nums[i], nums[j]); reverse(nums.begin()+i+1, nums.end()); return; &#125;&#125;; 成熟的解法 第一步，从后向前，找到一个index k，k是第一个满足当前节点值大于下一个点的值。 就是说后面的都是递减的。 (如果找不到，说明已经是最大的数组了，而且都是逆序，反转返回即可) 第二步，从后向前找，找到一个index l，l是nums[l] &gt; nums[k]，也就是l是大于nums[k]的最大索引。 第三步，交换l和k对应的值 第四步，把从k+1开始到nums末尾的数组，进行反转reverse。 A simple algorithm from Wikipedia with C++ implementation (can be used in Permutations and Permutations II) Well, in fact the problem of next permutation has been studied long ago. From the Wikipedia page, in the 14th century, a man named Narayana Pandita gives the following classic and yet quite simple algorithm (with minor modifications in notations to fit the problem statement): Find the largest index k such that nums[k] &lt; nums[k + 1]. If no such index exists, the permutation is sorted in descending order, just reverse it to ascending order and we are done. For example, the next permutation of [3, 2, 1] is [1, 2, 3]. Find the largest index l greater than k such that nums[k] &lt; nums[l]. Swap the value of nums[k] with that of nums[l]. Reverse the sequence from nums[k + 1] up to and including the final element nums[nums.size() - 1]. Quite simple, yeah? Now comes the following code, which is barely a translation. Well, a final note here, the above algorithm is indeed powerful — it can handle the cases of duplicates! If you have tried the problems Permutations and Permutations II, then the following function is also useful. Both of Permutations and Permutations II can be solved easily using this function. Hints: sort nums in ascending order, add it to the result of all permutations and then repeatedly generate the next permutation and add it … until we get back to the original sorted condition. If you want to learn more, please visit this solution and that solution. 123456789101112131415161718192021222324class Solution &#123; void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int k = -1; for (int i = nums.size() - 2; i &gt;= 0; i--) &#123; if (nums[i] &lt; nums[i + 1]) &#123; k = i; break; &#125; &#125; if (k == -1) &#123; reverse(nums.begin(), nums.end()); return; &#125; int l = -1; for (int i = nums.size() - 1; i &gt; k; i--) &#123; if (nums[i] &gt; nums[k]) &#123; l = i; break; &#125; &#125; swap(nums[k], nums[l]); reverse(nums.begin() + k + 1, nums.end()); &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return; int left = -1; for(int i=n-2; i&gt;=0; i--) if(nums[i]&lt;nums[i+1])&#123; left = i; break; // break不能忘 &#125; if(left == -1)&#123; reverse(nums.begin(), nums.end()); return; &#125; int right; for(int j=n-1; j&gt;left; j--) if(nums[j]&gt;nums[left])&#123; right = j; break; // break不能忘 &#125; swap(nums[left], nums[right]); reverse(nums.begin()+left+1, nums.end()); return; &#125;&#125;; cpp https://discuss.leetcode.com/topic/15216/a-simple-algorithm-from-wikipedia-with-c-implementation-can-be-used-in-permutations-and-permutations-ii A simple algorithm from Wikipedia with C++ implementation (can be used in Permutations and Permutations II) Well, in fact the problem of next permutation has been studied long ago. From the Wikipedia page, in the 14th century, a man named Narayana Pandita gives the following classic and yet quite simple algorithm (with minor modifications in notations to fit the problem statement): Find the largest index k such that nums[k] &lt; nums[k + 1]. If no such index exists, the permutation is sorted in descending order, just reverse it to ascending order and we are done. For example, the next permutation of [3, 2, 1] is [1, 2, 3]. Find the largest index l greater than k such that nums[k] &lt; nums[l]. Swap the value of nums[k] with that of nums[l]. Reverse the sequence from nums[k + 1] up to and including the final element nums[nums.size() - 1]. Quite simple, yeah? Now comes the following code, which is barely a translation. Well, a final note here, the above algorithm is indeed powerful — it can handle the cases of duplicates! If you have tried the problems Permutations and Permutations II, then the following function is also useful. Both of Permutations and Permutations II can be solved easily using this function. Hints: sort nums in ascending order, add it to the result of all permutations and then repeatedly generate the next permutation and add it … until we get back to the original sorted condition. If you want to learn more, please visit this solution and that solution. 123456789101112131415161718192021222324class Solution &#123; void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int k = -1; for (int i = nums.size() - 2; i &gt;= 0; i--) &#123; if (nums[i] &lt; nums[i + 1]) &#123; k = i; break; &#125; &#125; if (k == -1) &#123; reverse(nums.begin(), nums.end()); return; &#125; int l = -1; for (int i = nums.size() - 1; i &gt; k; i--) &#123; if (nums[i] &gt; nums[k]) &#123; l = i; break; &#125; &#125; swap(nums[k], nums[l]); reverse(nums.begin() + k + 1, nums.end()); &#125;&#125;; https://discuss.leetcode.com/topic/8508/9-lines-of-c-code-with-comments 9 Lines of C++ code with Comments 1234567891011121314151617181920212223class Solution &#123;public: void nextPermutation(vector&lt;int&gt; &amp;num) &#123; if (num.empty()) return; // in reverse order, find the first number which is in increasing trend (we call it violated number here) int i; for (i = num.size()-2; i &gt;= 0; --i) &#123; if (num[i] &lt; num[i+1]) break; &#125; // reverse all the numbers after violated number reverse(begin(num)+i+1, end(num)); // if violated number not found, because we have reversed the whole array, then we are done! if (i == -1) return; // else binary search find the first number larger than the violated number auto itr = upper_bound(begin(num)+i+1, end(num), num[i]); // swap them, done! swap(num[i], *itr); &#125;&#125;; You might need to think for a while why this would work. https://discuss.leetcode.com/topic/19264/1-4-11-lines-c 1, 4, 11 lines C++ Solution 1 Just for info: There’s a library function that does the job, even going from totally reverse sorted to sorted: 123void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; next_permutation(begin(nums), end(nums));&#125; Solution 2 Using library functions for all building blocks of the algorithm. Very nice how they all play together, notice the total lack of +1/-1, it all fits exactly. 123456void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; auto i = is_sorted_until(nums.rbegin(), nums.rend()); if (i != nums.rend()) swap(*i, *upper_bound(nums.rbegin(), i, *i)); reverse(nums.rbegin(), i);&#125; Solution 3 Doing it all on my own (except swap, let’s not be silly): 12345678910111213void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int i = nums.size() - 1, k = i; while (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i]) i--; for (int j=i; j&lt;k; j++, k--) swap(nums[j], nums[k]); if (i &gt; 0) &#123; k = i--; while (nums[k] &lt;= nums[i]) k++; swap(nums[i], nums[k]); &#125;&#125; Solution 4 Ok, let’s be silly after all and not even use swap :-) 12345678910111213void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int i = nums.size() - 1, k = i, tmp; while (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i]) i--; for (int j=i; j&lt;k; j++, k--) tmp = nums[j], nums[j] = nums[k], nums[k] = tmp; if (i &gt; 0) &#123; k = i--; while (nums[k] &lt;= nums[i]) k++; tmp = nums[i], nums[i] = nums[k], nums[k] = tmp; &#125;&#125; https://discuss.leetcode.com/topic/7138/sharing-my-really-simple-solution-with-explanation Sharing my really simple solution with explanation 123456789101112131415161718void nextPermutation(vector&lt;int&gt; &amp;num) &#123; for(int i = num.size() - 2; i &gt;= 0; i--)&#123; if(num[i] &lt; num[i + 1])&#123; int pos; int diff = INT_MAX; for(int j = i + 1; j &lt; num.size(); j++)&#123; if(num[j] &gt; num[i] &amp;&amp; abs(num[i] - num[j]) &lt; diff)&#123; diff = abs(num[i] - num[j]); pos = j; &#125; &#125; swap(num[i], num[pos]); sort(num.begin() + i + 1, num.end()); return; &#125; &#125; sort(num.begin(), num.end());&#125; For this problem, coding is not a big deal. Algorithm is! Now let’s pick a number, for example, 24387651. what is the next permutation? 24513678. How can I get the answer? First step: find the first ascending digit from the back of the number. 3 &lt; 8 &gt; 7 &gt; 6 &gt; 5 &gt; 1. Then 3 is the digit. Second step: swap that digit with the next big digit in following digits. Which one is the next big digit in 87651? 5! So swap them. Now the number becomes 24587631. Third step: sort 87631 into 13678. The final answer is 24513678. 12ms, 10.84%, April.23rd, 2016 https://github.com/haoel/leetcode/blob/master/algorithms/cpp/nextPermutation/nextPermutation.cpp 123456789101112131415161718192021222324252627282930313233343536373839/* * Take a look the following continuous permutation, can you find the patern? * * 1 2 3 4 * 1 2 4 3 * 1 3 2 4 * 1 3 4 2 * 1 4 2 3 * 1 4 3 2 * 2 1 3 4 * ... * * The pattern can be descripted as below: * * 1) from n-1 to 0, find the first place [i-1] which num[i-1] &lt; num[i] * 2) from n-1 to i, find the first number from n-1 to i which &gt;= num[i-1] * 3) swap the 2) num with the num[i-1] * 4) sort the sub-array [i, n) //actuall sort is fine as well * * For example: * * 1 4 3 2 &lt;-- 1) find the first place which num[i-1] &lt; num[i] * ^ * * 1 4 3 2 &lt;-- 2) find the first number from n-1 to i which &gt;= num[i-1] * ^ ^ * * 2 4 3 1 &lt;-- 3) swap them * ^ ^ * * 2 4 3 1 &lt;-- 4) sort * ^ ^ * * 2 1 3 4 * * Edge Case: * * 4 3 2 1, the next permutation is 1 2 3 4 */ 12345678910111213141516171819202122class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt;= 1) return; for(int i = nums.size() - 1; i &gt; 0; i--)&#123; if(nums[i-1] &lt; nums[i])&#123; int j = nums.size() - 1; while(nums[i-1] &gt;= nums[j]) j--; int tmp = nums[j]; nums[j] = nums[i-1]; nums[i-1] = tmp; reverse(nums.begin()+i, nums.end()); return; &#125; if(i == 1)&#123; reverse(nums.begin(), nums.end()); return; &#125; &#125; &#125;&#125;; 12ms, 10.84%, April.23rd, 2016 http://blog.csdn.net/m6830098/article/details/17291259 123456class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; next_permutation(nums.begin(), nums.end()); &#125;&#125;; python https://discuss.leetcode.com/topic/52275/easy-python-solution-based-on-lexicographical-permutation-algorithm Easy python solution based on lexicographical permutation algorithm For the detailed algorithm and demonstration, please go to https://www.nayuki.io/page/next-lexicographical-permutation-algorithm The steps are shown in the picture below. 123456789101112131415161718192021222324252627282930class Solution(object): def nextPermutation(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; # find longest non-increasing suffix right = len(nums)-1 while nums[right] &lt;= nums[right-1] and right-1 &gt;=0: right -= 1 if right == 0: return self.reverse(nums,0,len(nums)-1) # find pivot pivot = right-1 successor = 0 # find rightmost succesor for i in range(len(nums)-1,pivot,-1): if nums[i] &gt; nums[pivot]: successor = i break # swap pivot and successor nums[pivot],nums[successor] = nums[successor],nums[pivot] # reverse suffix self.reverse(nums,pivot+1,len(nums)-1) def reverse(self,nums,l,r): while l &lt; r: nums[l],nums[r] = nums[r],nums[l] l += 1 r -= 1 60ms, 77.71%, April.23rd, 2016 https://leetcode.com/discuss/59874/two-pointer-solution-in-python-with-detail-expalanation Two-pointer solution in python with detail expalanation Credit goes to http://blog.csdn.net/m6830098/article/details/17291259 1234567891011121314151617181920212223class Solution(object): def nextPermutation(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; # Use two-pointers: two pointers start from back # first pointer j stop at descending point # second pointer i stop at value &gt; nums[j] # swap and sort rest if not nums: return None i = len(nums)-1 j = -1 # j is set to -1 for case `4321`, so need to reverse all in following step while i &gt; 0: if nums[i-1] &lt; nums[i]: # first one violates the trend j = i-1 break i-=1 for i in xrange(len(nums)-1, -1, -1): if nums[i] &gt; nums[j]: # nums[i], nums[j] = nums[j], nums[i] # swap position nums[j+1:] = sorted(nums[j+1:]) # sort rest return java https://discuss.leetcode.com/topic/2542/share-my-o-n-time-solution Share my O(n) time solution My idea is for an array: Start from its last element, traverse backward to find the first one with index i that satisfy num[i-1] &lt; num[i]. So, elements from num[i] to num[n-1] is reversely sorted. To find the next permutation, we have to swap some numbers at different positions, to minimize the increased amount, we have to make the highest changed position as high as possible. Notice that index larger than or equal to i is not possible as num[i,n-1] is reversely sorted. So, we want to increase the number at index i-1, clearly, swap it with the smallest number between num[i,n-1] that is larger than num[i-1]. For example, original number is 121543321, we want to swap the ‘1’ at position 2 with ‘2’ at position 7. The last step is to make the remaining higher position part as small as possible, we just have to reversely sort the num[i,n-1] The following is my code: 1234567891011121314151617181920212223242526272829303132333435363738394041public void nextPermutation(int[] num) &#123; int n=num.length; if(n&lt;2) return; int index=n-1; while(index&gt;0)&#123; if(num[index-1]&lt;num[index]) break; index--; &#125; if(index==0)&#123; reverseSort(num,0,n-1); return; &#125; else&#123; int val=num[index-1]; int j=n-1; while(j&gt;=index)&#123; if(num[j]&gt;val) break; j--; &#125; swap(num,j,index-1); reverseSort(num,index,n-1); return; &#125;&#125;public void swap(int[] num, int i, int j)&#123; int temp=0; temp=num[i]; num[i]=num[j]; num[j]=temp;&#125;public void reverseSort(int[] num, int start, int end)&#123; if(start&gt;end) return; for(int i=start;i&lt;=(end+start)/2;i++) swap(num,i,start+end-i);&#125; https://discuss.leetcode.com/topic/14124/sharing-my-clean-and-easy-understand-java-code-with-explanation Sharing my clean and easy-understand java code with explanation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public void nextPermutation(int[] nums) &#123; if(nums.length&lt;=1)&#123; return; &#125; int i= nums.length-1; for(;i&gt;=1;i--)&#123; if(nums[i]&gt;nums[i-1])&#123; //find first number which is smaller than it&apos;s after number break; &#125; &#125; if(i!=0)&#123; swap(nums,i-1); //if the number exist,which means that the nums not like&#123;5,4,3,2,1&#125; &#125; reverse(nums,i); &#125; private void swap(int[] a,int i)&#123; for(int j = a.length-1;j&gt;i;j--)&#123; if(a[j]&gt;a[i])&#123; int t = a[j]; a[j] = a[i]; a[i] = t; break; &#125; &#125; &#125; private void reverse(int[] a,int i)&#123;//reverse the number after the number we have found int first = i; int last = a.length-1; while(first&lt;last)&#123; int t = a[first]; a[first] = a[last]; a[last] = t; first ++; last --; &#125; &#125; &#125; 在当前序列中，从尾端往前寻找两个相邻元素，前一个记为first，后一个记为second，并且满足first 小于 second。然后再从尾端寻找另一个元素number，如果满足first 小于number，即将第first个元素与number元素对调，并将second元素之后（包括second）的所有元素颠倒排序，即求出下一个序列 example: 6，3，4，9，8，7，1 此时 first ＝ 4，second = 9 从尾巴到前找到第一个大于first的数字，就是7 交换4和7，即上面的swap函数，此时序列变成6，3，7，9，8，4，1 再将second＝9以及以后的序列重新排序，让其从小到大排序，使得整体最小，即reverse一下（因为此时肯定是递减序列） 得到最终的结果：6，3，7，1，4，8，9 https://discuss.leetcode.com/topic/30212/easiest-java-solution Easiest JAVA Solution Using a simple example, we can derive the following steps: 123456789101112131415161718192021public void nextPermutation(int[] A) &#123; if(A == null || A.length &lt;= 1) return; int i = A.length - 2; while(i &gt;= 0 &amp;&amp; A[i] &gt;= A[i + 1]) i--; // Find 1st id i that breaks descending order if(i &gt;= 0) &#123; // If not entirely descending int j = A.length - 1; // Start from the end while(A[j] &lt;= A[i]) j--; // Find rightmost first larger id j swap(A, i, j); // Switch i and j &#125; reverse(A, i + 1, A.length - 1); // Reverse the descending sequence&#125;public void swap(int[] A, int i, int j) &#123; int tmp = A[i]; A[i] = A[j]; A[j] = tmp;&#125;public void reverse(int[] A, int i, int j) &#123; while(i &lt; j) swap(A, i++, j--);&#125; https://discuss.leetcode.com/topic/30688/readable-code-without-confusing-i-j-and-with-explanation Readable code without confusing i/j, and with explanation Implementation based on description from Project Nayuki. I cannot describe it better than them: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123;/*0*/ public void nextPermutation(int[] nums) &#123; // pivot is the element just before the non-increasing (weakly decreasing) suffix/*2*/ int pivot = indexOfLastPeak(nums) - 1; // paritions nums into [prefix pivot suffix] if (pivot != -1) &#123; int nextPrefix = lastIndexOfGreater(nums, nums[pivot]); // in the worst case it&apos;s suffix[0] // next prefix must exist because pivot &lt; suffix[0], otherwise pivot would be part of suffix/*4*/ swap(nums, pivot, nextPrefix); // this minimizes the change in prefix &#125;/*5*/ reverseSuffix(nums, pivot + 1); // reverses the whole list if there was no pivot/*6*/ &#125; /** * Find the last element which is a peak. * In case there are multiple equal peaks, return the first of those. * @return first index of last peak *//*1*/ int indexOfLastPeak(int[] nums) &#123; for (int i = nums.length - 1; 0 &lt; i; --i) &#123; if (nums[i - 1] &lt; nums[i]) return i; &#125; return 0; &#125; /** @return last index where the &#123;@code num &gt; threshold&#125; or -1 if not found *//*3*/ int lastIndexOfGreater(int[] nums, int threshold) &#123; for (int i = nums.length - 1; 0 &lt;= i; --i) &#123; if (threshold &lt; nums[i]) return i; &#125; return -1; &#125; /** Reverse numbers starting from an index till the end. */ void reverseSuffix(int[] nums, int start) &#123; int end = nums.length - 1; while (start &lt; end) &#123; swap(nums, start++, end--); &#125; &#125; void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[030. Substring with Concatenation of All Words]]></title>
    <url>%2Fp%2Ff97ee9f9%2F</url>
    <content type="text"><![CDATA[22.0% https://leetcode.com/problems/substring-with-concatenation-of-all-words/ You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. 123456For example, given:s: &quot;barfoothefoobarman&quot;words: [&quot;foo&quot;, &quot;bar&quot;]You should return the indices: [0,9].(order does not matter). 与题目 76 类似， Minimum Window Substring cpp https://discuss.leetcode.com/topic/6617/an-o-n-solution-with-detailed-explanation An O(N) solution with detailed explanation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// travel all the words combinations to maintain a window// there are wl(word len) times travel// each time, n/wl words, mostly 2 times travel for each word// one left side of the window, the other right side of the window// so, time complexity O(wl * 2 * N/wl) = O(2N)vector&lt;int&gt; findSubstring(string S, vector&lt;string&gt; &amp;L) &#123; vector&lt;int&gt; ans; int n = S.size(), cnt = L.size(); if (n &lt;= 0 || cnt &lt;= 0) return ans; // init word occurence unordered_map&lt;string, int&gt; dict; for (int i = 0; i &lt; cnt; ++i) dict[L[i]]++; // travel all sub string combinations int wl = L[0].size(); for (int i = 0; i &lt; wl; ++i) &#123; int left = i, count = 0; unordered_map&lt;string, int&gt; tdict; for (int j = i; j &lt;= n - wl; j += wl) &#123; string str = S.substr(j, wl); // a valid word, accumulate results if (dict.count(str)) &#123; tdict[str]++; if (tdict[str] &lt;= dict[str]) count++; else &#123; // a more word, advance the window left side possiablly while (tdict[str] &gt; dict[str]) &#123; string str1 = S.substr(left, wl); tdict[str1]--; if (tdict[str1] &lt; dict[str1]) count--; left += wl; &#125; &#125; // come to a result if (count == cnt) &#123; ans.push_back(left); // advance one word tdict[S.substr(left, wl)]--; count--; left += wl; &#125; &#125; // not a valid word, reset all vars else &#123; tdict.clear(); count = 0; left = j + wl; &#125; &#125; &#125; return ans;&#125; 698ms, 47.43%, September 22, 2016 https://discuss.leetcode.com/topic/17943/naive-c-solution-using-two-unordered_map-about-20-lines Naive C++ Solution using two unordered_map (about 20 lines) I think the following code is self-explanatory enough. We use an unordered_map&lt;string, int&gt; counts to record the expected times of each word and another unordered_map&lt;string, int&gt; seen to record the times we have seen. Then we check for every possible position of i. Once we meet an unexpected word or the times of some word is larger than its expected times, we stop the check. If we finish the check successfully, push i to the result indexes. 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; unordered_map&lt;string, int&gt; counts; for(string word:words) counts[word]++; int n = s.length(), num = words.size(), len = words[0].length(); vector&lt;int&gt; indexes; for(int i=0; i&lt;n-num*len+1; i++)&#123; unordered_map&lt;string, int&gt; seen; int j = 0; for(;j&lt;num; j++)&#123; string word = s.substr(i+j*len, len); if(counts.find(word)!=counts.end())&#123; seen[word]++; if(seen[word]&gt;counts[word]) break; &#125; else break; &#125; if(j==num) indexes.push_back(i); &#125; return indexes; &#125;&#125;; https://discuss.leetcode.com/topic/7552/my-ac-c-code-o-n-complexity-26ms My AC c++ code, O(n) complexity, 26ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution &#123;// The general idea:// Construct a hash function f for L, f: vector&lt;string&gt; -&gt; int, // Then use the return value of f to check whether a substring is a concatenation // of all words in L.// f has two levels, the first level is a hash function f1 for every single word in L.// f1 : string -&gt; double// So with f1, L is converted into a vector of float numbers// Then another hash function f2 is defined to convert a vector of doubles into a single int.// Finally f(L) := f2(f1(L))// To obtain lower complexity, we require f1 and f2 can be computed through moving window.// The following corner case also needs to be considered:// f2(f1([&quot;ab&quot;, &quot;cd&quot;])) != f2(f1([&quot;ac&quot;, &quot;bd&quot;]))// There are many possible options for f2 and f1. // The following code only shows one possibility (probably not the best), // f2 is the function &quot;hash&quot; in the class,// f1([a1, a2, ... , an]) := int( decimal_part(log(a1) + log(a2) + ... + log(an)) * 1000000000 )public: // The complexity of this function is O(nW). double hash(double f, double code[], string &amp;word) &#123; double result = 0.; for (auto &amp;c : word) result = result * f + code[c]; return result; &#125; vector&lt;int&gt; findSubstring(string S, vector&lt;string&gt; &amp;L) &#123; uniform_real_distribution&lt;double&gt; unif(0., 1.); default_random_engine seed; double code[128]; for (auto &amp;d : code) d = unif(seed); double f = unif(seed) / 5. + 0.8; double value = 0; // The complexity of the following for loop is O(L.size( ) * nW). for (auto &amp;str : L) value += log(hash(f, code, str)); int unit = 1e9; int key = (value-floor(value))*unit; int nS = S.size(), nL = L.size(), nW = L[0].size(); double fn = pow(f, nW-1.); vector&lt;int&gt; result; if (nS &lt; nW) return result; vector&lt;double&gt; values(nS-nW+1); string word(S.begin(), S.begin()+nW); values[0] = hash(f, code, word); // Use a moving window to hash every word with length nW in S to a float number, // which is stored in vector values[] // The complexity of this step is O(nS). for (int i=1; i&lt;=nS-nW; ++i) values[i] = (values[i-1] - code[S[i-1]]*fn)*f + code[S[i+nW-1]]; // This for loop will run nW times, each iteration has a complexity O(nS/nW) // So the overall complexity is O(nW * (nS / nW)) = O(nS) for (int i=0; i&lt;nW; ++i) &#123; int j0=i, j1=i, k=0; double sum = 0.; // Use a moving window to hash every L.size() continuous words with length nW in S. // This while loop will terminate within nS/nW iterations since the increasement of j1 is nW, // So the complexity of this while loop is O(nS / nW). while(j1&lt;=nS-nW) &#123; sum += log(values[j1]); ++k; j1 += nW; if (k==nL) &#123; int key1 = (sum-floor(sum)) * unit; if (key1==key) result.push_back(j0); sum -= log(values[j0]); --k; j0 += nW; &#125; &#125; &#125; return result; &#125;&#125;; Though theoretically it has a very small chance to fail. python https://discuss.leetcode.com/topic/3018/hash-idea-and-exception-case Hash Idea and exception case The following python code is accepted by OJ. It is based on the following idea (assumption) We know that two multisets consist of same elements and size of the multisets are equal. if sum of hashes of all elements are the same for these multisets -&gt; those multisets are identical This is not true for same very very rare cases. Please describe such a case. 12345678def findSubstring(self, S, L): n = len(L) #num words w = len(L[0]) #length of each word t = n*w # total length hashsum = sum([hash(x) for x in L]) h = [hash(S[i:i+w])*(S[i:i+w] in L) for i in xrange(len(S)-w+1)] return [i for i in xrange(len(S)-t+1) if sum(h[i:i+t:w])==hashsum] https://discuss.leetcode.com/topic/26043/ac-python-80ms-solution-dictionary-and-two-pointers AC Python 80ms solution, dictionary and two pointers 1234567891011121314151617181920212223242526272829303132333435def _findSubstring(self, l, r, n, k, t, s, req, ans): curr = &#123;&#125; while r + k &lt;= n: w = s[r:r + k] r += k if w not in req: l = r curr.clear() else: curr[w] = curr[w] + 1 if w in curr else 1 while curr[w] &gt; req[w]: curr[s[l:l + k]] -= 1 l += k if r - l == t: ans.append(l)def findSubstring(self, s, words): if not s or not words or not words[0]: return [] n = len(s) k = len(words[0]) t = len(words) * k req = &#123;&#125; for w in words: req[w] = req[w] + 1 if w in req else 1 ans = [] for i in xrange(min(k, n - t + 1)): self._findSubstring(i, i, n, k, t, s, req, ans) return ans# 169 / 169 test cases passed.# Status: Accepted# Runtime: 80 ms# 98.60% First of all consider s as several series of words with length k starting at [0, k-1]. For example “barfoothe” with k = 3, can be view as [“bar”, “foo”, “the”] for i=0 and [“arf”, “oot”] for i = 1 and [“rfo”, “oth”] for i = 2.Thus we need to check each of these series and find out the valid index by definition. For each series, we just need to check if there exist a range [l, r) where the occurrence or “spectrum” of the words in the range is the same as our given word list’s “spectrum”. We use dictionary to store the spectrum and maintain it as we loop through s. collections.Counter class may save a bit of code on updating the counts of the dictionary. However plain dict wins on the speed. https://discuss.leetcode.com/topic/13630/99ms-python-o-kmn-solution 99ms Python O(kmn) Solution The idea comes from [https://leetcode.com/discuss/20151/an-o-n-solution-with-detailed-explanation] Using a counter and a sliding window, we push the window from left to right, counting the number of valid words in the window. When the number of a word in the window is more than the times it appears in words or we meet a invalid word, push the window. 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution:# @param &#123;string&#125; s# @param &#123;string[]&#125; words# @return &#123;integer[]&#125;def findSubstring(self, s, words): if len(words) == 0: return [] # initialize d, l, ans l = len(words[0]) d = &#123;&#125; for w in words: if w in d: d[w] += 1 else: d[w] = 1 i = 0 ans = [] # sliding window(s) for k in range(l): left = k subd = &#123;&#125; count = 0 for j in xrange(k, len(s)-l+1, l): tword = s[j:j+l] # valid word if tword in d: if tword in subd: subd[tword] += 1 else: subd[tword] = 1 count += 1 while subd[tword] &gt; d[tword]: subd[s[left:left+l]] -= 1 left += l count -= 1 if count == len(words): ans.append(left) # not valid else: left = j + l subd = &#123;&#125; count = 0 return ans Assuming we have k words in words, and there are m substrings in the string, the complexity is O(kmn) because we need to adjust the window when more valid words are found. This solution runs 99ms on OJ. java 180ms, September 22, 2016 https://discuss.leetcode.com/topic/6432/simple-java-solution-with-two-pointers-and-map Simple Java Solution with Two Pointers and Map My idea is pretty simple. Just build a map for the words and their relative count in L. Then we traverse through S to check whether there is a match. 12345678910111213141516171819202122232425262728public class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(s == null || words == null || words.length == 0) return res; int len = words[0].length(); Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); for(String word:words) map.put(word, map.containsKey(word)?map.get(word)+1:1); for(int i=0; i&lt;=s.length()-len*words.length; i++)&#123; Map&lt;String, Integer&gt; copy = new HashMap&lt;String, Integer&gt;(map); for(int j = 0; j&lt;words.length; j++)&#123; String str = s.substring(i+j*len, i+j*len+len); if(copy.containsKey(str))&#123; int count = copy.get(str); if(count == 1) copy.remove(str); else copy.put(str, count-1); if(copy.isEmpty())&#123; res.add(i); break; &#125; &#125; else break; &#125; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/35676/accepted-java-solution-12ms-with-explanation Accepted Java solution 12ms with explanation It’s not too hard to find some resemblance between this problem and minimum-window-substring. Actually the main difference is the fact that we are interested at some interval length: we want intervals with fixed length K * M, where K is the number of strings in the “words” array and M the length of each target string. In order to apply the same idea we used for that problem, all we need to do is to map each string from the “words” array to something we are able to index (I prefer to use hashing for this). Also, in order to speed up the algorithm, we can find all occurrences of those strings in S (which is equivalent to do it on demand, but we will potentially do the same matching twice). Notice that, we can simply apply these occurrences as they appear because we are assured that no word is contained by some other. Finally, we use all this information to process each possibility. Notice here that, the fact that all strings has the same length, implies that we have just M (being M the length of each target string) possible starting points, hence we end up performing M linear scans over array with length O(N/M) (being N the length of S) and that makes the scanning stage of the algorithm to be linear on the length of S. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; int N = s.length(); List&lt;Integer&gt; indexes = new ArrayList&lt;Integer&gt;(s.length()); if (words.length == 0) &#123; return indexes; &#125; int M = words[0].length(); if (N &lt; M * words.length) &#123; return indexes; &#125; int last = N - M + 1; //map each string in words array to some index and compute target counters Map&lt;String, Integer&gt; mapping = new HashMap&lt;String, Integer&gt;(words.length); int [][] table = new int[2][words.length]; int failures = 0, index = 0; for (int i = 0; i &lt; words.length; ++i) &#123; Integer mapped = mapping.get(words[i]); if (mapped == null) &#123; ++failures; mapping.put(words[i], index); mapped = index++; &#125; ++table[0][mapped]; &#125; //find all occurrences at string S and map them to their current integer, -1 means no such string is in words array int [] smapping = new int[last]; for (int i = 0; i &lt; last; ++i) &#123; String section = s.substring(i, i + M); Integer mapped = mapping.get(section); if (mapped == null) &#123; smapping[i] = -1; &#125; else &#123; smapping[i] = mapped; &#125; &#125; //fix the number of linear scans for (int i = 0; i &lt; M; ++i) &#123; //reset scan variables int currentFailures = failures; //number of current mismatches int left = i, right = i; Arrays.fill(table[1], 0); //here, simple solve the minimum-window-substring problem while (right &lt; last) &#123; while (currentFailures &gt; 0 &amp;&amp; right &lt; last) &#123; int target = smapping[right]; if (target != -1 &amp;&amp; ++table[1][target] == table[0][target]) &#123; --currentFailures; &#125; right += M; &#125; while (currentFailures == 0 &amp;&amp; left &lt; right) &#123; int target = smapping[left]; if (target != -1 &amp;&amp; --table[1][target] == table[0][target] - 1) &#123; int length = right - left; //instead of checking every window, we know exactly the length we want if ((length / M) == words.length) &#123; indexes.add(left); &#125; ++currentFailures; &#125; left += M; &#125; &#125; &#125; return indexes;&#125; https://discuss.leetcode.com/topic/32038/java-12ms-beats-100 Java 12ms beats 100% The two pointers method with hashmap is known by many other solutions. The idea is to slide the scan window as far as possible, and keep throwing the impossible cases based on the length test. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; /** * Let n=s.length, k=words[0].length traverse s with indices i, i+k, * i+2k, ... for 0&lt;=i&lt;k, so that the time complexity is O(n). */ List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int n = s.length(), m = words.length, k; if (n == 0 || m == 0 || (k = words[0].length()) == 0) return res; HashMap&lt;String, Integer&gt; wDict = new HashMap&lt;String, Integer&gt;(); for (String word : words) &#123; if (wDict.containsKey(word)) wDict.put(word, wDict.get(word) + 1); else wDict.put(word, 1); &#125; int i, j, start, x, wordsLen = m * k; HashMap&lt;String, Integer&gt; curDict = new HashMap&lt;String, Integer&gt;(); String test, temp; for (i = 0; i &lt; k; i++) &#123; curDict.clear(); start = i; if (start + wordsLen &gt; n) return res; for (j = i; j + k &lt;= n; j += k) &#123; test = s.substring(j, j + k); if (wDict.containsKey(test)) &#123; if (!curDict.containsKey(test)) &#123; curDict.put(test, 1); start = checkFound(res, start, wordsLen, j, k, curDict, s); continue; &#125; // curDict.containsKey(test) x = curDict.get(test); if (x &lt; wDict.get(test)) &#123; curDict.put(test, x + 1); start = checkFound(res, start, wordsLen, j, k, curDict, s); continue; &#125; // curDict.get(test)==wDict.get(test), slide start to // the next word of the first same word as test while (!(temp = s.substring(start, start + k)).equals(test)) &#123; decreaseCount(curDict, temp); start += k; &#125; start += k; if (start + wordsLen &gt; n) break; continue; &#125; // totally failed up to index j+k, slide start and reset all start = j + k; if (start + wordsLen &gt; n) break; curDict.clear(); &#125; &#125; return res; &#125; public int checkFound(List&lt;Integer&gt; res, int start, int wordsLen, int j, int k, HashMap&lt;String, Integer&gt; curDict, String s) &#123; if (start + wordsLen == j + k) &#123; res.add(start); // slide start to the next word decreaseCount(curDict, s.substring(start, start + k)); return start + k; &#125; return start; &#125; public void decreaseCount(HashMap&lt;String, Integer&gt; curDict, String key) &#123; // remove key if curDict.get(key)==1, otherwise decrease it by 1 int x = curDict.get(key); if (x == 1) curDict.remove(key); else curDict.put(key, x - 1); &#125; https://discuss.leetcode.com/topic/6593/accepted-recursive-solution-using-trie-tree Accepted recursive solution using Trie Tree The idea is quite simple. Just use a trie tree to accelerate testing whether a substring is valid. The value of each TrieNode is used to deal with duplication and to mark whether the word is used before. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static class TrieNode &#123; int value = 0; Map&lt;Character, TrieNode&gt; children = new HashMap&lt;Character, TrieNode&gt;(); &#125; TrieNode trie;// build a trie treepublic List&lt;Integer&gt; findSubstring(String S, String[] L) &#123; trie = buildTrie(L); int length = getTotalLength(L); List&lt;Integer&gt; result = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; S.length() - length + 1; i++) &#123; if (isSubString(S, i, i + length)) result.add(i); &#125; return result;&#125;private int getTotalLength(String[] L) &#123; int sum = 0; for (String l : L) sum += l.length(); return sum;&#125;private TrieNode buildTrie(String[] L) &#123; TrieNode root = new TrieNode(); for (String l : L) addWord(root, l); return root;&#125;private void addWord(TrieNode root, String s) &#123; TrieNode node = root; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); TrieNode next = node.children.get(c); if (next == null) &#123; next = new TrieNode(); node.children.put(c, next); &#125; node = next; &#125; node.value++;&#125;private boolean isSubString(String S, int start, int end) &#123; if (start == end) return true; // search in the trie tree TrieNode node = trie; for (int i = start; i &lt; end; i++) &#123; char c = S.charAt(i); if (node.children.get(c) == null) return false; node = node.children.get(c); if (node.value &gt; 0) &#123; // leaf &amp; can be used node.value--; // mark as used if (isSubString(S, i + 1, end)) &#123; node.value++; // mark as unused return true; &#125; node.value++; // mark as unused &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[029. Divide Two Integers]]></title>
    <url>%2Fp%2Fa87eef55%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/divide-two-integers/ Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT. cpp https://discuss.leetcode.com/topic/15568/detailed-explained-8ms-c-solution Detailed Explained 8ms C++ solution In this problem, we are asked to divide two integers. However, we are not allowed to use division, multiplication and mod operations. So, what else can we use? Yeah, bit manipulations. Let’s do an example and see how bit manipulations work. Suppose we want to divide 15 by 3, so 15 is dividend and 3 is divisor. Well, division simply requires us to find how many times we can subtract the divisor from the the dividend without making the dividend negative. Let’s get started. We subtract 3 from 15 and we get 12, which is positive. Let’s try to subtract more. Well, we shift 3 to the left by 1 bit and we get 6. Subtracting 6 from 15 still gives a positive result. Well, we shift again and get 12. We subtract 12 from 15 and it is still positive. We shift again, obtaining 24 and we know we can at most subtract 12. Well, since 12 is obtained by shifting 3 to left twice, we know it is 4 times of 3. How do we obtain this 4? Well, we start from 1 and shift it to left twice at the same time. We add 4 to an answer (initialized to be 0). In fact, the above process is like 15 = 3 * 4 + 3. We now get part of the quotient (4), with a remainder 3. Then we repeat the above process again. We subtract divisor = 3 from the remaining dividend = 3 and obtain 0. We know we are done. No shift happens, so we simply add 1 &lt;&lt; 0 to the answer. Now we have the full algorithm to perform division. According to the problem statement, we need to handle some exceptions, such as overflow. Well, two cases may cause overflow: divisor = 0; dividend = INT_MIN and divisor = -1 (because abs(INT_MIN) = INT_MAX + 1). Of course, we also need to take the sign into considerations, which is relatively easy. Putting all these together, we have the following code. 123456789101112131415161718192021class Solution &#123;public: int divide(int dividend, int divisor) &#123; if (!divisor || (dividend == INT_MIN &amp;&amp; divisor == -1)) return INT_MAX; int sign = ((dividend &lt; 0) ^ (divisor &lt; 0)) ? -1 : 1; long long dvd = labs(dividend); long long dvs = labs(divisor); int res = 0; while (dvd &gt;= dvs) &#123; long long temp = dvs, multiple = 1; while (dvd &gt;= (temp &lt;&lt; 1)) &#123; temp &lt;&lt;= 1; multiple &lt;&lt;= 1; &#125; dvd -= temp; res += multiple; &#125; return sign == 1 ? res : -res; &#125;&#125;; https://discuss.leetcode.com/topic/3421/simple-o-log-n-2-c-solution Simple O((log N) ^ 2) C++ solution Long division in binary: The outer loop reduces n by at least half each iteration. So It has O(log N) iterations. The inner loop has at most log N iterations. So the overall complexity is O(( log N)^2) typedef long long ll; 123456789101112131415int divide(int n_, int d_) &#123; ll ans=0; ll n=abs((ll)n_); ll d=abs((ll)d_); while(n&gt;=d)&#123; ll a=d; ll m=1; while((a&lt;&lt;1) &lt; n)&#123;a&lt;&lt;=1;m&lt;&lt;=1;&#125; ans+=m; n-=a; &#125; if((n_&lt;0&amp;&amp;d_&gt;=0)||(n_&gt;=0&amp;&amp;d_&lt;0)) return -ans; return ans;&#125; https://discuss.leetcode.com/topic/38191/summary-of-3-c-solutions Summary of 3 C++ solutions-1- log-based solution 123456789101112131415class Solution &#123;public: int divide(int dividend, int divisor) &#123; /** a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b)) **/ if(dividend==0) return 0; if(divisor==0) return INT_MAX; double t1=log(fabs(dividend)); double t2=log(fabs(divisor)); long long result=double(exp(t1-t2)); if((dividend&lt;0) ^ (divisor&lt;0)) result=-result; if(result&gt;INT_MAX) result=INT_MAX; return result; &#125;&#125;; -2- Binary Index tree idea inspired solution, as we can decompose any result number to sum of the power of 2. Here is the C++ implementation. 123456789101112131415161718192021222324class Solution &#123;public: int divide(int dividend, int divisor) &#123; if(!divisor || (dividend==INT_MIN &amp;&amp; divisor==-1)) return INT_MAX; int sign=((dividend&lt;0)^(divisor&lt;0)) ? -1:1; long long m=labs(dividend); long long n=labs(divisor); int result=0; /** dvd &gt;= 2^k1*dvs + 2^k2*dvs ... **/ while(m&gt;=n)&#123; long long temp=n, count=1; while(m &gt;= (temp&lt;&lt;1))&#123; temp&lt;&lt;=1; count&lt;&lt;=1; &#125; m-=temp; result+=count; &#125; return sign==1?result:-result; &#125;&#125;; -3- concise version of the solution 2 1234567891011121314151617class Solution &#123;public: int divide(int dividend, int divisor) &#123; long long result=0; long long m=abs((long long)dividend); long long n=abs((long long)divisor); while(m&gt;=n)&#123; long long s=n, power=1; while((s&lt;&lt;1) &lt;= m) &#123; s&lt;&lt;=1; power&lt;&lt;=1; &#125; result+=power; m-=s; &#125; if( (dividend&gt;0) ^ (divisor&gt;0)) result = -result; return result&gt;INT_MAX ? INT_MAX:result; &#125;&#125;; python https://discuss.leetcode.com/topic/8714/clear-python-code Clear python code 12345678910111213141516class Solution:# @return an integerdef divide(self, dividend, divisor): positive = (dividend &lt; 0) is (divisor &lt; 0) dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend &gt;= divisor: temp, i = divisor, 1 while dividend &gt;= temp: dividend -= temp res += i i &lt;&lt;= 1 temp &lt;&lt;= 1 if not positive: res = -res return min(max(-2147483648, res), 2147483647) https://discuss.leetcode.com/topic/6966/15-line-easy-understand-solution-129ms 15 line easy understand solution. 129ms for example, if we want to calc (17/2) ret = 0; 17-2 ,ret+=1; left=15 15-4 ,ret+=2; left=11 11-8 ,ret+=4; left=3 3-2 ,ret+=1; left=1 ret=8; 123456789101112131415161718192021class Solution:# @return an integerdef divide(self, dividend, divisor): isMinus= ((dividend&lt;0 and divisor &gt;0) or (dividend&gt;0 and divisor &lt;0)); ret=0; dividend,divisor=abs(dividend),abs(divisor); c,sub=1,divisor; while(dividend &gt;= divisor): if(dividend&gt;=sub): dividend-=sub; ret+=c; sub=(sub&lt;&lt;1); c=(c&lt;&lt;1); else: sub=(sub&gt;&gt;1); c=(c&gt;&gt;1); if(isMinus): ret=-ret; return min(max(-2147483648,ret),2147483647); java https://discuss.leetcode.com/topic/23968/clean-java-solution-with-some-comment Clean Java solution with some comment. 12345678910111213141516171819202122232425262728293031323334353637383940public int divide(int dividend, int divisor) &#123; //Reduce the problem to positive long integer to make it easier. //Use long to avoid integer overflow cases. int sign = 1; if ((dividend &gt; 0 &amp;&amp; divisor &lt; 0) || (dividend &lt; 0 &amp;&amp; divisor &gt; 0)) sign = -1; long ldividend = Math.abs((long) dividend); long ldivisor = Math.abs((long) divisor); //Take care the edge cases. if (ldivisor == 0) return Integer.MAX_VALUE; if ((ldividend == 0) || (ldividend &lt; ldivisor)) return 0; long lans = ldivide(ldividend, ldivisor); int ans; if (lans &gt; Integer.MAX_VALUE)&#123; //Handle overflow. ans = (sign == 1)? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; else &#123; ans = (int) (sign * lans); &#125; return ans;&#125;private long ldivide(long ldividend, long ldivisor) &#123; // Recursion exit condition if (ldividend &lt; ldivisor) return 0; // Find the largest multiple so that (divisor * multiple &lt;= dividend), // whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason. // Think this as a binary search. long sum = ldivisor; long multiple = 1; while ((sum+sum) &lt;= ldividend) &#123; sum += sum; multiple += multiple; &#125; //Look for additional value for the multiple from the reminder (dividend - sum) recursively. return multiple + ldivide(ldividend - sum, ldivisor);&#125; https://discuss.leetcode.com/topic/8271/accepted-java-solution-with-comments Accepted Java solution with comments. 12345678910111213141516171819202122232425262728293031public int divide(int dividend, int divisor) &#123; long result = divideLong(dividend, divisor); return result &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)result;&#125;// It&apos;s easy to handle edge cases when// operate with long numbers rather than intpublic long divideLong(long dividend, long divisor) &#123; // Remember the sign boolean negative = dividend &lt; 0 != divisor &lt; 0; // Make dividend and divisor unsign if (dividend &lt; 0) dividend = -dividend; if (divisor &lt; 0) divisor = -divisor; // Return if nothing to divide if (dividend &lt; divisor) return 0; // Sum divisor 2, 4, 8, 16, 32 .... times long sum = divisor; long divide = 1; while ((sum+sum) &lt;= dividend) &#123; sum += sum; divide += divide; &#125; // Make a recursive call for (devided-sum) and add it to the result return negative ? -(divide + divideLong((dividend-sum), divisor)) : (divide + divideLong((dividend-sum), divisor));&#125; https://discuss.leetcode.com/topic/3631/a-readable-java-implementation A readable Java implementation At first, I used dividend / divisor, just to check. But that was cheating. Then, I implemented a solution which failed the corner cases. I solved it by using long instead of int. But I felt that was also cheating. At last, I came up with this solution. It handles all the corner cases. Running time analysis after the code. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123; public int divide(int dividend, int divisor) &#123; if (divisor == 1) // Trival case 1 return dividend; // Use negative integers to avoid integer overflow if (dividend &gt; 0) return -divide(-dividend, divisor); if (divisor &gt; 0) return -divide(dividend, -divisor); if (dividend &gt; divisor) // Trivial case 2 return 0; if ((dividend == Integer.MIN_VALUE) &amp;&amp; (divisor == -1)) // Overflow case return Integer.MAX_VALUE; // Find the highest mult = (divisor * 2^shifts) which is &lt;= dividend // by shifting mult to the left without causing an overflow. // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations. int min_divisor = Integer.MIN_VALUE &gt;&gt; 1; int mult = divisor; // = divisor * 2^shifts int shifts = 0; while ((mult &gt;= min_divisor) &amp;&amp; (mult &gt; dividend)) &#123; mult &lt;&lt;= 1; ++shifts; &#125; // Compute the result by shifting mult to the right. // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations for the outer loop. // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations for the inner loop // (in total, not per outer iteration). int result = 0; int power = 1 &lt;&lt; shifts; // = 2^shifts while (dividend &lt;= divisor) &#123; shifts = 0; while (mult &lt; dividend) &#123; mult &gt;&gt;= 1; ++shifts; &#125; dividend -= mult; power &gt;&gt;= shifts; result |= power; // Adds power to result &#125; return result; &#125;&#125; I see lots of people talking about O(log(n)) solutions. Since n is bounded by -2^31 and 2^31-1, I’m not sure the Big-Oh notation is appropriate here. Anyway, here’s a rough worst-case analysis of this code. The first loop runs (log2(|dividend|) - log2(|divisor|) + 1) times. There are 2 comparisons 1 bit shift 1 increment The second loop runs between 1 time and (log2(|dividend|) - log2(|divisor|) + 1) times. For worst-case, we take the latter. There are 1 comparison 1 assignment 1 substraction 1 bit shift 1 bitwise or The inner while loop runs (log2(|dividend|) - log2(|divisor|) + 1) times also (in total, not per outer loop iteration). There are 1 comparison 1 bit shift 1 increment So, roughly, the overall worst-case running time is 12(log2(dividend) - log2(divisor) + 1) operations. You can notice that (log2(|dividend|) - log2(|divisor|)) = log2(|result|). Thus, the running time is (worst-case) 12(log2(|result|) + 1) operations.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[028. Implement strStr()]]></title>
    <url>%2Fp%2F78eeb38d%2F</url>
    <content type="text"><![CDATA[27.5% https://leetcode.com/problems/implement-strstr/ Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 方法一：暴力法 1234567891011121314class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.size(), n = needle.size(); if(!haystack || !needle || m&lt;n) return -1; for(int i=0; ;i++)&#123; for(int j=0; ;j++)&#123; if(j==n-1) return i; if(i+j==m-1) return -1; if(haystack[i+j]!=needle[j]) break; &#125; &#125; &#125;&#125;; 我的代码实现： 123456789101112131415class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.size(), n = needle.size(); if(n==0) return 0; if(m==0 || m&lt;n) return -1; for(int i=0; ;i++)&#123; for(int j=0; ;j++)&#123; if(j==n) return i; if(i+j==m) return -1; if(haystack[i+j]!=needle[j]) break; &#125; &#125; &#125;&#125;; 方法二：KMP算法 先建立lps，然后使用kmp算法 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.length(), n = needle.length(); if (!n) return 0; vector&lt;int&gt; lps = kmpProcess(needle); for (int i = 0, j = 0; i &lt; m; ) &#123; if (haystack[i] == needle[j]) &#123; i++; j++; &#125; if (j == n) return i - j; if (i &lt; m &amp;&amp; haystack[i] != needle[j]) &#123; if (j) j = lps[j - 1]; else i++; &#125; &#125; return -1; &#125;private: vector&lt;int&gt; kmpProcess(string&amp; needle) &#123; int n = needle.length(); vector&lt;int&gt; lps(n, 0); for (int i = 1, len = 0; i &lt; n; ) &#123; if (needle[i] == needle[len]) lps[i++] = ++len; else if (len) len = lps[len - 1]; else lps[i++] = 0; &#125; return lps; &#125;&#125;; 完整实现代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// C++ program for implementation of KMP pattern searching// algorithm#include&lt;bits/stdc++.h&gt; void computeLPSArray(char *pat, int M, int *lps); // Prints occurrences of txt[] in pat[]void KMPSearch(char *pat, char *txt)&#123; int M = strlen(pat); int N = strlen(txt); // create lps[] that will hold the longest prefix suffix // values for pattern int lps[M]; // Preprocess the pattern (calculate lps[] array) computeLPSArray(pat, M, lps); int i = 0; // index for txt[] int j = 0; // index for pat[] while (i &lt; N) &#123; if (pat[j] == txt[i]) &#123; j++; i++; &#125; if (j == M) &#123; printf("Found pattern at index %d n", i-j); j = lps[j-1]; &#125; // mismatch after j matches else if (i &lt; N &amp;&amp; pat[j] != txt[i]) &#123; // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) j = lps[j-1]; else i = i+1; &#125; &#125;&#125; // Fills lps[] for given patttern pat[0..M-1]void computeLPSArray(char *pat, int M, int *lps)&#123; // length of the previous longest prefix suffix int len = 0; lps[0] = 0; // lps[0] is always 0 // the loop calculates lps[i] for i = 1 to M-1 int i = 1; while (i &lt; M) &#123; if (pat[i] == pat[len]) &#123; len++; lps[i] = len; i++; &#125; else // (pat[i] != pat[len]) &#123; // This is tricky. Consider the example. // AAACAAAA and i = 7. The idea is similar // to search step. if (len != 0) &#123; len = lps[len-1]; // Also, note that we do not increment // i here &#125; else // if (len == 0) &#123; lps[i] = 0; i++; &#125; &#125; &#125;&#125; // Driver program to test above functionint main()&#123; char *txt = "ABABDABACDABABCABAB"; char *pat = "ABABCABAB"; KMPSearch(pat, txt); return 0;&#125; 说明： http://www.cplusplus.com/reference/cstring/strstr/ 123strstrconst char * strstr ( const char * str1, const char * str2 ); char * strstr ( char * str1, const char * str2 ); Locate substring Returns a pointer to the first occurrence of str2 in str1, or a null pointer if str2 is not part of str1. The matching process does not include the terminating null-characters, but it stops there. KMP算法阅读资料 KMP on jBoxer’s blog; http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/ KMP on geeksforgeeks, with a well-commented C code. http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/ 阮一峰的博客 http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html https://discuss.leetcode.com/topic/6888/this-test-case-doesn-t-make-sense This test case doesn’t make sense. Input: “”, “”Output: -1Expected: 0 Basically there is nothing in the string, how do you get the index. If this test case is valid, then needle =””, haystack=”anything” could return any value. since empty is everywhere. cpp https://discuss.leetcode.com/topic/15569/explained-4ms-easy-c-solution Explained 4ms Easy C++ solution Well, the problem does not aim for an advanced algorithm like KMP but only a clean brute-force algorithm. So we can traverse all the possible starting points of haystack (from 0 to haystack.length() - needle.length()) and see if the following characters in haystack match those of needle. The code is as follows. 123456789101112131415class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.length(), n = needle.length(); if (!n) return 0; for (int i = 0; i &lt; m - n + 1; i++) &#123; int j = 0; for (; j &lt; n; j++) if (haystack[i + j] != needle[j]) break; if (j == n) return i; &#125; return -1; &#125;&#125;; Of course, you may challenge yourself implementing the KMP algorithm for this problem. KMP is a classic and yet notoriously hard-to-understand algorithm. However, I think the following two links give nice explanations. You may refer to them. KMP on jBoxer’s blog; http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/ KMP on geeksforgeeks, with a well-commented C code. http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/ I am sorry that I am still unable to give a personal explanation of the algorithm. I only read it from the two links above and mimic the code in the second link. My accepted C++ code using KMP is as follows. Well, it also takes 4ms -_- 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.length(), n = needle.length(); if (!n) return 0; vector&lt;int&gt; lps = kmpProcess(needle); for (int i = 0, j = 0; i &lt; m; ) &#123; if (haystack[i] == needle[j]) &#123; i++; j++; &#125; if (j == n) return i - j; if (i &lt; m &amp;&amp; haystack[i] != needle[j]) &#123; if (j) j = lps[j - 1]; else i++; &#125; &#125; return -1; &#125;private: vector&lt;int&gt; kmpProcess(string&amp; needle) &#123; int n = needle.length(); vector&lt;int&gt; lps(n, 0); for (int i = 1, len = 0; i &lt; n; ) &#123; if (needle[i] == needle[len]) lps[i++] = ++len; else if (len) len = lps[len - 1]; else lps[i++] = 0; &#125; return lps; &#125;&#125;; https://discuss.leetcode.com/topic/4340/my-c-code-that-implements-boyer-moore-string-search-got-accepted-in-12ms My c++ code that implements Boyer-Moore string search got accepted in 12ms. I implements Boyer-Moore string search algorithm and it turns out to be very efficient (accepted in 12ms). Boyer-Moore uses information gained by preprocessing the pattern string to skip as many alignments as possible. A shift is calculated by applying both rules: the bad character rule and the good suffix rule. The actual shifting offset is the maximum of the shifts calculated by these rules. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657char *strStr(char *haystack, char *needle) &#123; if(NULL==haystack||NULL==needle) return NULL; int plen = strlen(needle); int slen = strlen(haystack); if(0==plen) return haystack; else if(plen&gt;slen) return NULL; int badChar[256]; int np = 0; int i,j,k; for(i=0;i&lt;256;i++) badChar[i] = plen; while(np&lt;plen) &#123; badChar[*(needle+np)] = plen-np-1; np++; &#125; int* goodSuffix = new int[plen]; int prefix_index = plen; for(i=plen-1;i&gt;=0;i--) &#123; goodSuffix[i] = prefix_index; if(*(needle+i)==*(needle+plen-1-i)&amp;&amp;prefix_index==i+1) prefix_index = i; &#125; for(i=0;i&lt;plen-1;i++) &#123; j = plen-1, k = 0; while(k&lt;i&amp;&amp;*(needle+j)==*(needle+i-k)) &#123;j--;k++;&#125; if(*(needle+plen-1)==*(needle+i)) goodSuffix[j] = plen-1-i; &#125; goodSuffix[plen-1] = 0; int sp = 0; while(sp&lt;slen) &#123; i = plen-1; while(i&gt;=0&amp;&amp;*(haystack+sp+i)==*(needle+i)) i--; if(i&lt;0) return haystack+sp; int bj = badChar[*(haystack+sp+i)] - plen + i + 1; sp += (bj&gt;goodSuffix[i]?bj:goodSuffix[i]); &#125; delete goodSuffix; return NULL;&#125; https://discuss.leetcode.com/topic/31171/kmp-in-c-explanation-included KMP in C++, explanation included 123456789101112131415161718192021222324252627282930313233343536373839404142434445int strStr(string haystack, string needle) &#123; int nsize = needle.size(); int hsize = haystack.size(); if (nsize == 0) return 0; int *table = new int[nsize]; memset(table, 0, sizeof(int)*nsize); //building match table for (int i = 1, j = 0; i &lt; nsize - 1;)&#123; if (needle[i] != needle[j])&#123; if (j&gt;0)&#123; j = table[j - 1]; &#125; else&#123; i++; &#125; &#125; else&#123; table[i] = j + 1; i++; j++; &#125; &#125; //matching for (int i = 0, match_pos = 0; i &lt; hsize;)&#123; if (haystack[i] == needle[match_pos])&#123; if (match_pos == nsize - 1)&#123; return i - (nsize - 1); &#125; else&#123; i++; match_pos++; &#125; &#125; else&#123; if (match_pos == 0)&#123; i++; &#125; else&#123; match_pos = table[match_pos - 1]; &#125; &#125; &#125; delete[]table; return -1; &#125; I’ll talk about the basic idea behind KMP algorithm. First, some notations: Denote the pattern string as ps and the match table as table, ps and table use 0 based index. Denote substring of ps from index i to index j (i and j included) as substr(ps,i,j). Denote string1 is the same as string2 as string1==string2 The definition of my match table: table[i] when i&gt;0 means the max length of prefix of ps(0,i) which is the same as the suffix of ps(0,i). Or1table[i]=max&#123;k| substr(substr(ps,0,i),0,k-1) == substr(substr(ps,0,i),i-k+1,i), k&lt;=i&#125;. Also, we define table[i]=0. So, for string “aba”, table={0,0,1}. table[1]=0 is because no prefix equals suffix of “ab”. table[2]=1 is because prefix “a” equals suffix “a” of “aba”. for string “abcabce”, table={0,0,0,1,2,3,0}. table[4]=2 is because prefix “ab” equals suffix “ab” of “abcab” table[5]=3 is because prefix “abc” equals suffix “abc” of “abcabc” for string “aabaabaaa”, table={0,1,0,1,2,3,4,5,2}. How would this match table be helpful to string matching? Suppose we have a target string “abcabcdxxxxx” and a pattern “abcabce”.In the first round of matching, we start at first character and have 12abcabcdxxxxxabcabce We discover that ‘d’ and ‘e’ are different and string before that is the same, which is “abcabc”.if we move “abcabce” forward one character, we would be comparing 12abcabcdxxxxx abcabce let’s focus on the parts which are same in the previous round: 12abcabc abcabc we are actually comparing the suffix of length 5 of “abcabc”, which is “bcabc” and the prefix of length 5 of “abcabc”, which is “abcab”. However, table[5]==3 tells us the max length of suffix and prefix of “abcabc” which are same is 3, so suffix and prefixof length 5 can’t be the same. Thus, we can skip this round of comparing.Next, we move “abcabce” forward by another one character, we would be comparing 12abcabc abcabc Now, we are comparing suffix and prefix of length 4, since table[5]==3, we can skip this round.Next, we move “abcabce” forward by another one character, we would be comparing 12abcabc abcabc Now, we are comparing suffix and prefix of length 3, since table[5]==3, this is valid.Another property we can use to simply the matching process is that we already know the prefix and suffix of length 3 are the same, so we can start by comparing from the 4th charater in pattern, which is ‘a’, with the target string. To sum up, when the ps(pattern string) at index i(i&gt;0) failed to match ts(target string) at index j, which means substr(ps,0,i-1) matches, we start by comparing ps[table[i-1]] with ts[j]. python 35ms, 100.00%, September 6, 2016 https://discuss.leetcode.com/topic/29848/my-answer-by-python My answer by Python 1234567891011class Solution(object): def strStr(self, haystack, needle): &quot;&quot;&quot; :type haystack: str :type needle: str :rtype: int &quot;&quot;&quot; for i in range(len(haystack)-len(needle)+1): if haystack[i:i+len(needle)] == needle: return i return -1 c 0ms, 28.37%, September 6, 2016 https://discuss.leetcode.com/topic/6557/a-very-clean-solution-brute-force A very clean solution, brute-force 12345678910int strStr(char *haystack, char *needle) &#123; if (!haystack || !needle) return -1; for (int i = 0; ; ++i) &#123; for (int j = 0; ; ++j) &#123; if (needle[j] == 0) return i; if (haystack[i + j] == 0) return -1; if (haystack[i + j] != needle[j]) break; &#125; &#125; &#125; java 8ms, 28.67%, September 9, 2016 https://discuss.leetcode.com/topic/18839/elegant-java-solution Elegant Java solution 12345678910public class Solution &#123; public int strStr(String haystack, String needle) &#123; for(int i=0; ; i++) for(int j=0; ; j++)&#123; if(j == needle.length()) return i; if(i+j == haystack.length()) return -1; if(needle.charAt(j) != haystack.charAt(i+j)) break; &#125; &#125;&#125; https://discuss.leetcode.com/topic/9872/share-my-accepted-java-solution Share my accepted java solution 1234567891011121314151617public class Solution &#123; public int strStr(String haystack, String needle) &#123; int l1 = haystack.length(), l2 = needle.length(); if (l1 &lt; l2) &#123; return -1; &#125; else if (l2 == 0) &#123; return 0; &#125; int threshold = l1 - l2; for (int i = 0; i &lt;= threshold; ++i) &#123; if (haystack.substring(i,i+l2).equals(needle)) &#123; return i; &#125; &#125; return -1; &#125;&#125; https://discuss.leetcode.com/topic/3576/accepted-kmp-solution-in-java-for-reference Accepted KMP solution in java for reference 1234567891011121314151617181920212223242526272829303132333435public String strStr(String haystack, String needle) &#123; //KMP algorithms if(needle.equals(&quot;&quot;)) return haystack; if(haystack.equals(&quot;&quot;)) return null; char[] arr = needle.toCharArray(); int[] next = makeNext(arr); for(int i = 0, j = 0, end = haystack.length(); i &lt; end;)&#123; if(j == -1 || haystack.charAt(i) == arr[j])&#123; j++; i++; if(j == arr.length) return haystack.substring(i - arr.length); &#125; if(i &lt; end &amp;&amp; haystack.charAt(i) != arr[j]) j = next[j]; &#125; return null;&#125;private int[] makeNext(char[] arr)&#123; int len = arr.length; int[] next = new int[len]; next[0] = -1; for(int i = 0, j = -1; i + 1 &lt; len;)&#123; if(j == -1 || arr[i] == arr[j])&#123; next[i+1] = j+1; if(arr[i+1] == arr[j+1]) next[i+1] = next[j+1]; i++; j++; &#125; if(arr[i] != arr[j]) j = next[j]; &#125; return next;&#125; https://discuss.leetcode.com/topic/41463/java-easy-to-understand-solutions Java easy to understand solutions. 123456789101112131415161718public int strStr1(String haystack, String needle) &#123; return haystack.indexOf(needle);&#125;public int strStr(String haystack, String needle) &#123; if (haystack == null || needle == null) return -1; int l1 = haystack.length(); int l2 = needle.length(); for (int i = 0; i &lt; l1-l2+1; i++) &#123; int count = 0; while (count &lt; l2 &amp;&amp; haystack.charAt(i+count) == needle.charAt(count)) count++; if (count == l2) return i; &#125; return -1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[027. Remove Element]]></title>
    <url>%2Fp%2F98cbed82%2F</url>
    <content type="text"><![CDATA[39.1% https://leetcode.com/problems/remove-element/ Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. 1234Example:Given input array nums = [3,2,2,3], val = 3Your function should return length = 2, with the first two elements of nums being 2. Hint: Try two pointers. Did you use the property of “the order of elements can be changed”? What happens when the elements to remove are rare? 方法一： https://discuss.leetcode.com/topic/17282/very-simple-and-optimal-c-solution Very simple and optimal c++ solution. 12345678910int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int cnt = 0; for(int i = 0 ; i &lt; nums.size() ; ++i) &#123; if(nums[i] == val) cnt++; else nums[i-cnt] = nums[i]; &#125; return nums.size()-cnt;&#125; 方法二： beats 4.4%,but the other 95.6% are same to you ~ including me 4ms, 4.44%, April.23rd, 2016 123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int index = 0; for(int i = 0; i &lt; nums.size(); ++i)&#123; if(nums[i] != val)&#123; nums[index++] = nums[i]; &#125; &#125; return index; &#125;&#125;; 4ms, 4.44%, April.23rd, 2016 123456class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; return distance(nums.begin(), remove(nums.begin(), nums.end(), val)); &#125;&#125;; 4ms, 4.44%, April.23rd, 2016 123456789101112131415class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int tail = nums.size() -1; int i = 0; while(i &lt;= tail)&#123; if(nums[i] == val)&#123; nums[i] = nums[tail--]; continue; &#125; i++; &#125; return tail+1; &#125;&#125;; 我的代码实现： 123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int n = nums.size(); if(n==0) return 0; int index = -1; for(int i=0; i&lt;n; i++) if(nums[i]!=val) nums[++index] = nums[i]; return index+1; &#125;&#125;; python https://discuss.leetcode.com/topic/27777/simple-python-o-n-two-pointer-in-place-solution Simple Python O(n) two pointer in place solution Starting from the left every time we find a value that is the target value we swap it out with an item starting from the right. We decrement end each time as we know that the final item is the target value and only increment start once we know the value is ok. Once start reaches end we know all items after that point are the target value so we can stop there. 12345678def removeElement(self, nums, val): start, end = 0, len(nums) - 1 while start &lt;= end: if nums[start] == val: nums[start], nums[end], end = nums[end], nums[start], end - 1 else: start +=1 return start 48ms, 45.02%, April.23rd, 2016 12345678910class Solution(object): def removeElement(self, nums, val): &quot;&quot;&quot; :type nums: List[int] :type val: int :rtype: int &quot;&quot;&quot; while(val in nums): nums.remove(val) return len(nums) 44ms, 71.09%, April.23rd, 2016 123456789101112class Solution(object): def removeElement(self, nums, val): &quot;&quot;&quot; :type nums: List[int] :type val: int :rtype: int &quot;&quot;&quot; try: while True: nums.remove(val) except: return len(nums) java https://discuss.leetcode.com/topic/1228/my-solution-for-your-reference My solution for your reference. 12345int removeElement(int A[], int n, int elem) &#123; int begin=0; for(int i=0;i&lt;n;i++) if(A[i]!=elem) A[begin++]=A[i]; return begin;&#125; https://discuss.leetcode.com/topic/10753/accepted-java-solution Accepted java solution 123456789101112public int removeElement(int[] A, int elem) &#123; int m = 0; for(int i = 0; i &lt; A.length; i++)&#123; if(A[i] != elem)&#123; A[m] = A[i]; m++; &#125; &#125; return m;&#125; https://discuss.leetcode.com/topic/5205/9-line-java-solution 9-line java solution The basic idea is when elem is found at index i, let A[i] = the last element in the modifying array, then repeat searching until elem is not found. 123456789public int removeElement(int[] A, int elem) &#123; int len = A.length; for (int i = 0 ; i&lt; len; ++i)&#123; while (A[i]==elem &amp;&amp; i&lt; len) &#123; A[i]=A[--len]; &#125; &#125; return len;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[026. Remove Duplicates from Sorted Array]]></title>
    <url>%2Fp%2Fca4383ce%2F</url>
    <content type="text"><![CDATA[35.5% https://leetcode.com/problems/remove-duplicates-from-sorted-array/ Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. 123456For example,Given input array nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn&apos;t matter what you leave beyond the new length. 方法一： beats 35.10% of cppsubmissions 1234567891011class Solution &#123; public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n &lt; 2) return n; int id = 1; for(int i = 1; i &lt; n; ++i) if(nums[i] != nums[i-1]) nums[id++] = nums[i]; return id; &#125;&#125;; 我的代码实现： 123456789101112class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return n; int index = 0; for(int i=1; i&lt;n; i++) if(nums[i]!=nums[index]) nums[++index] = nums[i]; return index+1; &#125;&#125;; https://discuss.leetcode.com/topic/17252/5-lines-c-java-nicer-loops 5 lines C++/Java, nicer loops I don’t like old-style indexed looping. I much prefer the “enhanced” (Java) / “range-based” (C++) loops, they make things much cleaner. C++ 1234567int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int i = 0; for (int n : nums) if (!i || n &gt; nums[i-1]) nums[i++] = n; return i;&#125; And to not need the !i check in the loop: 1234567int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int i = !nums.empty(); for (int n : nums) if (n &gt; nums[i-1]) nums[i++] = n; return i;&#125; https://discuss.leetcode.com/topic/8907/share-my-clean-c-code Share my clean C++ code 123456int count = 0;for(int i = 1; i &lt; n; i++)&#123; if(A[i] == A[i-1]) count++; else A[i-count] = A[i];&#125;return n-count; https://discuss.leetcode.com/topic/25354/simple-c-o-n-solution Simple C++ O(n) solution 12345678910int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int pos = 0; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (i == 0 || nums[i] != nums[pos - 1]) nums[pos++] = nums[i]; &#125; return pos;&#125; python https://discuss.leetcode.com/topic/12672/simple-python-solution-o-n Simple Python solution - O(n) 123456789101112131415class Solution: # @param a list of integers # @return an integer def removeDuplicates(self, A): if not A: return 0 newTail = 0 for i in range(1, len(A)): if A[i] != A[newTail]: newTail += 1 A[newTail] = A[i] return newTail + 1 java https://discuss.leetcode.com/topic/3102/my-solution-time-o-n-space-o-1 My Solution : Time O(n), Space O(1) 12345678910class Solution &#123; public: int removeDuplicates(int A[], int n) &#123; if(n &lt; 2) return n; int id = 1; for(int i = 1; i &lt; n; ++i) if(A[i] != A[i-1]) A[id++] = A[i]; return id; &#125;&#125;; https://discuss.leetcode.com/topic/17252/5-lines-c-java-nicer-loops Java 1234567public int removeDuplicates(int[] nums) &#123; int i = 0; for (int n : nums) if (i == 0 || n &gt; nums[i-1]) nums[i++] = n; return i;&#125; And to not need the i == 0 check in the loop: 1234567public int removeDuplicates(int[] nums) &#123; int i = nums.length &gt; 0 ? 1 : 0; for (int n : nums) if (n &gt; nums[i-1]) nums[i++] = n; return i;&#125; https://discuss.leetcode.com/topic/10262/5-lines-java-solution 5 lines Java solution 1234567public int removeDuplicates(int[] A) &#123; if (A.length==0) return 0; int j=0; for (int i=0; i&lt;A.length; i++) if (A[i]!=A[j]) A[++j]=A[i]; return ++j;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[025. Reverse Nodes in k-Group]]></title>
    <url>%2Fp%2F6d6210c%2F</url>
    <content type="text"><![CDATA[30.0% https://leetcode.com/problems/reverse-nodes-in-k-group/ Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed. 1234567For example,Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 方法一： 此题目是25题的加强版 迭代，参考反转链表的方法 其实与206题，反转链表类似，但是多了几步。先遍历一遍，获得数目 https://discuss.leetcode.com/topic/9839/20-line-iterative-c-solution 20-line iterative C++ solution 1234567891011-1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 | | |pre cur nex -1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; 5 | | | pre cur nex -1 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5 | | | pre cur nex Above is how it works inside one group iteration(for example, k=3) 优化后的代码： Thanks to ciaoliang1992, the tmp pointer is no necessary, so the more concise solution is 12345678910111213141516171819202122232425class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;++i) &#123; cur-&gt;next=nex-&gt;next; nex-&gt;next=pre-&gt;next; pre-&gt;next=nex; nex=cur-&gt;next; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; 我的代码实现: 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if(!head || !head-&gt;next || k&lt;=1) return head; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* cur = dummy; int cnt = 0; // 有必要的时候可以遍历一遍链表，求出链表的长度 while(cur-&gt;next)&#123; cnt++; cur = cur-&gt;next; &#125; ListNode* pre = dummy, *nex; while(cnt/k)&#123; cur = pre-&gt;next; nex = cur-&gt;next; // 对于反转k个，需要的是k-1个后面的转到前面，而不是k个 for(int i=0; i&lt;k-1; i++)&#123; cur-&gt;next = nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; nex = cur-&gt;next; &#125; pre = cur; cnt -= k; &#125; return dummy-&gt;next; &#125;&#125;; 原始代码： 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *tmp, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;i++) &#123; tmp= nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; cur-&gt;next = tmp; nex = tmp; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if(!head || !head-&gt;next || k&lt;=1) return head; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* cur = dummy; int cnt = 0; // 有必要的时候可以遍历一遍链表，求出链表的长度 while(cur-&gt;next)&#123; cnt++; cur = cur-&gt;next; &#125; ListNode* pre = dummy, *nex, *tmp; while(cnt/k)&#123; cur = pre-&gt;next; nex = cur-&gt;next; // 对于反转k个，需要的是k-1个后面的转到前面，而不是k个 for(int i=0; i&lt;k-1; i++)&#123; tmp = nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; cur-&gt;next = tmp; nex = cur-&gt;next; &#125; pre = cur; cnt -= k; &#125; return dummy-&gt;next; &#125;&#125;; 方法二： 递归 C++ Elegant and Small 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: ListNode* reverse(ListNode* first, ListNode* last) &#123; ListNode* prev = last; while ( first != last ) &#123; auto tmp = first-&gt;next; first-&gt;next = prev; prev = first; first = tmp; &#125; return prev; &#125; ListNode* reverseKGroup(ListNode* head, int k) &#123; auto node=head; for (int i=0; i &lt; k; ++i) &#123; if ( ! node ) return head; // nothing to do list too sort node = node-&gt;next; &#125; auto new_head = reverse( head, node); head-&gt;next = reverseKGroup( node, k); return new_head; &#125;&#125;; 我的实现： 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; int cnt = 0; auto node = head; while(cnt&lt;k)&#123; if(node==NULL) return head; cnt++; node = node-&gt;next; &#125; auto new_head = reverse(head, k); head-&gt;next = reverseKGroup(node, k); return new_head; &#125; ListNode* reverse(ListNode* head, int k)&#123; ListNode* pre = NULL; int cnt = 0; while(cnt&lt;k)&#123; ListNode* nex = head-&gt;next; head-&gt;next = pre; pre = head; head = nex; cnt++; &#125; return pre; &#125;&#125;; cpp 其实与206题，反转链表类似，但是多了几步。先遍历一遍，获得数目 https://discuss.leetcode.com/topic/9839/20-line-iterative-c-solution 20-line iterative C++ solution 1234567891011-1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 | | | | pre cur nex tmp-1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; 5 | | | | pre cur nex tmp-1 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5 | | | | pre cur nex tmp Above is how it works inside one group iteration(for example, k=3) 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *tmp, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;i++) &#123; tmp= nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; cur-&gt;next = tmp; nex = tmp; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; Thanks to ciaoliang1992, the tmp pointer is no necessary, so the more concise solution is 12345678910111213141516171819202122232425class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;++i) &#123; cur-&gt;next=nex-&gt;next; nex-&gt;next=pre-&gt;next; pre-&gt;next=nex; nex=cur-&gt;next; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/25867/c-elegant-and-small C++ Elegant and Small 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: ListNode* reverse(ListNode* first, ListNode* last) &#123; ListNode* prev = last; while ( first != last ) &#123; auto tmp = first-&gt;next; first-&gt;next = prev; prev = first; first = tmp; &#125; return prev; &#125; ListNode* reverseKGroup(ListNode* head, int k) &#123; auto node=head; for (int i=0; i &lt; k; ++i) &#123; if ( ! node ) return head; // nothing to do list too sort node = node-&gt;next; &#125; auto new_head = reverse( head, node); head-&gt;next = reverseKGroup( node, k); return new_head; &#125;&#125;; https://discuss.leetcode.com/topic/17914/24ms-easy-c-iterative-solution-with-explanations 24ms Easy C++ Iterative Solution with Explanations Well, since the head pointer may also be modified, we create a new_head that points to it to facilitate the reverse process. For the example list 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 in the problem statement, it will become 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 (we init new_head -&gt; val to be 0). Then we set a pointer pre to new_head and another cur to head. Then we insert cur -&gt; next after pre for k - 1 times if the current node cur has at least k nodes after it (including itself). After reversing one k-group, we update pre to be cur and cur to be pre -&gt; next to reverse the next k-group. The code is as follows. 12345678910111213141516171819202122232425262728293031class Solution &#123; public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if (!hasKNodes(head, k)) return head; ListNode* new_head = new ListNode(0); new_head -&gt; next = head; ListNode* pre = new_head; ListNode* cur = head; while (hasKNodes(cur, k)) &#123; for (int i = 0; i &lt; k - 1; i++) &#123; ListNode* temp = pre -&gt; next; pre -&gt; next = cur -&gt; next; cur -&gt; next = cur -&gt; next -&gt; next; pre -&gt; next -&gt; next = temp; &#125; pre = cur; cur = pre -&gt; next; &#125; return new_head -&gt; next; &#125;private: bool hasKNodes(ListNode* node, int k) &#123; int cnt = 0; while (node) &#123; cnt++; if (cnt &gt;= k) return true; node = node -&gt; next; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/31618/succinct-iterative-python-o-n-time-o-1-space Succinct iterative Python, O(n) time O(1) space Use a dummy head, and l, r : define reversing range pre, cur : used in reversing, standard reverse linked linked list method jump : used to connect last node in previous k-group to first node in following k-group 12345678910111213141516def reverseKGroup(self, head, k): dummy = jump = ListNode(0) dummy.next = l = r = head while True: count = 0 while r and count &lt; k: # use r to locate the range r = r.next count += 1 if count == k: # if size k satisfied, reverse the inner linked list pre, cur = r, l for _ in range(k): cur.next, cur, pre = pre, cur.next, cur # standard reversing jump.next, jump, l = pre, l, r # connect two k-groups else: return dummy.next https://discuss.leetcode.com/topic/6956/simple-python-solution-one-pass-no-additional-space-109ms Simple Python solution, one pass, no additional space, 109ms The key idea is to keep track of the next_head while reversing the group, tail of the current group is always the start node of the group, once the group reversing is done, next_head is available, simply connect it to tail. 12345678910111213141516171819202122232425def reverseKGroup(self, head, k): if head is None or k &lt; 2: return head next_head = head for i in range(k - 1): next_head = next_head.next if next_head is None: return head ret = next_head current = head while next_head: tail = current prev = None for i in range(k): if next_head: next_head = next_head.next _next = current.next current.next = prev prev = current current = _next tail.next = next_head or current return ret java https://discuss.leetcode.com/topic/7126/short-but-recursive-java-code-with-comments Short but recursive Java code with comments Hi, guys! Despite the fact that the approach is recursive, the code is less than 20 lines. :) 123456789101112131415161718192021public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode curr = head; int count = 0; while (curr != null &amp;&amp; count != k) &#123; // find the k+1 node curr = curr.next; count++; &#125; if (count == k) &#123; // if k+1 node is found curr = reverseKGroup(curr, k); // reverse list with k+1 node as head // head - head-pointer to direct part, // curr - head-pointer to reversed part; while (count-- &gt; 0) &#123; // reverse current k-group: ListNode tmp = head.next; // tmp - next head in direct part head.next = curr; // preappending &quot;direct&quot; head to the reversed list curr = head; // move head of reversed part to a new node head = tmp; // move &quot;direct&quot; head to the next node in direct part &#125; head = curr; &#125; return head;&#125; Hope it helps! https://discuss.leetcode.com/topic/5604/share-my-java-solution-with-comments-in-line Share my Java Solution with comments in line 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if (head==null||head.next==null||k&lt;2) return head; ListNode dummy = new ListNode(0); dummy.next = head; ListNode tail = dummy, prev = dummy,temp; int count; while(true)&#123; count =k; while(count&gt;0&amp;&amp;tail!=null)&#123; count--; tail=tail.next; &#125; if (tail==null) break;//Has reached the end head=prev.next;//for next cycle // prev--&gt;temp--&gt;...---&gt;....---&gt;tail--&gt;.... // Delete @temp and insert to the next position of @tail // prev--&gt;...--&gt;...--&gt;tail--&gt;head--&gt;... // Assign @temp to the next node of @prev // prev--&gt;temp--&gt;...--&gt;tail--&gt;...--&gt;... // Keep doing until @tail is the next node of @prev while(prev.next!=tail)&#123; temp=prev.next;//Assign prev.next=temp.next;//Delete temp.next=tail.next; tail.next=temp;//Insert &#125; tail=head; prev=head; &#125; return dummy.next; &#125;&#125; https://discuss.leetcode.com/topic/12364/non-recursive-java-solution-and-idea Non-recursive Java solution and idea Reference: http://www.cnblogs.com/lichen782/p/leetcode_Reverse_Nodes_in_kGroup.html First, build a function reverse() to reverse the ListNode between begin and end. See the explanation below: 123456789101112131415test /** * Reverse a link list between begin and end exclusively * an example: * a linked list: * 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 * | | * begin end * after call begin = reverse(begin, end) * * 0-&gt;3-&gt;2-&gt;1-&gt;4-&gt;5-&gt;6 * | | * begin end * @return the reversed list&apos;s &apos;begin&apos; node, which is the precedence of node end */ Then walk thru the linked list and apply reverse() iteratively. See the code below. 123456789101112131415161718192021222324252627282930313233343536public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode begin; if (head==null || head.next ==null || k==1) return head; ListNode dummyhead = new ListNode(-1); dummyhead.next = head; begin = dummyhead; int i=0; while (head != null)&#123; i++; if (i%k == 0)&#123; begin = reverse(begin, head.next); head = begin.next; &#125; else &#123; head = head.next; &#125; &#125; return dummyhead.next; &#125;public ListNode reverse(ListNode begin, ListNode end)&#123; ListNode curr = begin.next; ListNode next, first; ListNode prev = begin; first = curr; while (curr!=end)&#123; next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; begin.next = prev; first.next = curr; return first;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[024. Swap Nodes in Pairs]]></title>
    <url>%2Fp%2F94079f17%2F</url>
    <content type="text"><![CDATA[38.3% https://leetcode.com/problems/swap-nodes-in-pairs/ Given a linked list, swap every two adjacent nodes and return its head. 12For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 方法一： 递归调用 Simple implementation with C++ 123456789101112131415class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(head == NULL) return NULL; if(head-&gt;next == NULL) return head; ListNode* next = head-&gt;next; head-&gt;next = swapPairs(next-&gt;next); next-&gt;next = head; return next; &#125;&#125;; 我的代码实现： 递归方法，实现起来最简单 123456789101112131415161718/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* nex = head-&gt;next; head-&gt;next = swapPairs(nex-&gt;next); nex-&gt;next = head; return nex; &#125;&#125;; 另一种实现 Very easy solution 123456789101112class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode *l=head; if(head&amp;&amp;head-&gt;next)&#123; l=head-&gt;next; head-&gt;next=swapPairs(l-&gt;next); l-&gt;next=head; &#125; return l; &#125;&#125;; 方法二： 我自己的方法，多定义几个变量，依次迭代。 12345678910111213141516class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* cur = dummy; while(cur-&gt;next!=NULL &amp;&amp; cur-&gt;next-&gt;next!=NULL)&#123; ListNode* n1=cur-&gt;next, *n2 = cur-&gt;next-&gt;next, *n3=cur-&gt;next-&gt;next-&gt;next; cur-&gt;next = n2; n2-&gt;next = n1; n1-&gt;next = n3; cur = n1; &#125; return dummy-&gt;next; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* cur = dummy, *first, *second; while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123; first = cur-&gt;next; second = cur-&gt;next-&gt;next; first-&gt;next = second-&gt;next; second-&gt;next = first; cur-&gt;next = second; cur = first; &#125; return dummy-&gt;next; &#125;&#125;; cpp 4ms, 3.56%, July 14th, 2016 https://discuss.leetcode.com/topic/18860/7-8-lines-c-python-ruby 7-8 lines C++ / Python / Ruby Three different implementations of the same algorithm, taking advantage of different strengths of the three languages. I suggest reading all three, even if you don’t know all three languages. All three of course work swap the current node with the next node by rearranging pointers, then move on to the next pair, and repeat until the end of the list. C++ Pointer-pointer pp points to the pointer to the current node. So at first, pp points to head, and later it points to the next field of ListNodes. Additionally, for convenience and clarity, pointers a and b point to the current node and the next node. We need to go from pp == a -&gt; b -&gt; (b-&gt;next) to pp == b -&gt; a -&gt; (b-&gt;next). The first three lines inside the loop do that, setting those three pointers (from right to left). The fourth line moves pp to the next pair. 12345678910ListNode* swapPairs(ListNode* head) &#123; ListNode **pp = &amp;head, *a, *b; while ((a = *pp) &amp;&amp; (b = a-&gt;next)) &#123; a-&gt;next = b-&gt;next; b-&gt;next = a; *pp = b; pp = &amp;(a-&gt;next); &#125; return head;&#125; Python Here, pre is the previous node. Since the head doesn’t have a previous node, I just use self instead. Again, a is the current node and b is the next node. To go from pre -&gt; a -&gt; b -&gt; b.next to pre -&gt; b -&gt; a -&gt; b.next, we need to change those three references. Instead of thinking about in what order I change them, I just change all three at once. 12345678def swapPairs(self, head): pre, pre.next = self, head while pre.next and pre.next.next: a = pre.next b = a.next pre.next, b.next, a.next = b, a, b.next pre = a return self.next https://discuss.leetcode.com/topic/29060/simple-implementation-with-c Simple implementation with C++ 123456789101112131415class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(head == NULL) return NULL; if(head-&gt;next == NULL) return head; ListNode* next = head-&gt;next; head-&gt;next = swapPairs(next-&gt;next); next-&gt;next = head; return next; &#125;&#125;; https://discuss.leetcode.com/topic/31626/very-easy-solution Very easy solution 123456789101112class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode *l=head; if(head&amp;&amp;head-&gt;next)&#123; l=head-&gt;next; head-&gt;next=swapPairs(l-&gt;next); l-&gt;next=head; &#125; return l; &#125;&#125;; python 4ms, 3.56%, July 14th, 2016 https://discuss.leetcode.com/topic/18860/7-8-lines-c-python-ruby 12345678910111213141516171819# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def swapPairs(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; pre, pre.next = self, head while pre.next and pre.next.next: a = pre.next b = a.next pre.next, b.next, a.next = b, a, b.next pre = a return self.next java 0ms, 6.43%, July 14th, 2016 https://discuss.leetcode.com/topic/4351/my-accepted-java-code-used-recursion My accepted java code. used recursion. 123456789101112131415161718/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if((head == null) || (head.next == null)) return head; ListNode n = head.next; head.next = swapPairs(head.next.next); n.next = head; return n; &#125;&#125; 0ms, 6.43%, July 14th, 2016 https://discuss.leetcode.com/topic/10649/my-simple-java-solution-for-share My accepted java code. used recursion. 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode current = dummy; while(current.next != null &amp;&amp; current.next.next != null)&#123; ListNode first = current.next; ListNode second = current.next.next; first.next = second.next; current.next = second; current.next.next = first; current = current.next.next; &#125; return dummy.next; &#125;&#125; https://discuss.leetcode.com/topic/41459/java-simple-recursive-solution Java simple recursive solution Starting to see that recursion is the perfect tool for (many) linked list problems (this one + merging list problem). 1234567891011121314151617181920/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode second = head.next; ListNode third = second.next; second.next = head; head.next = swapPairs(third); return second; &#125;&#125; https://discuss.leetcode.com/topic/5163/my-simple-recursive-solution My simple recursive solution My solution is quite simple. Just find the reverse job is the same for every 2 nodes. 12345678910public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode newhd = head.next; head.next = swapPairs(newhd.next); newhd.next = head; return newhd;&#125; https://discuss.leetcode.com/topic/39095/my-straight-forward-java-solution-without-recursion-or-dummy-nodes-0ms My straight-forward Java solution without recursion or dummy nodes (0ms) The idea is straightforward: use two pointers and swap a.next = b.next, b.next = a. Then continue the next pair, b = a.next.next, a=a.next Remember to check null Remember to track new head Remember to link the new pair after the prior nodes.Attached is the accepted code. 12345678910111213141516public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head==null || head.next==null) return head; ListNode newHead = head.next, a=head,b=a.next,pre = null; while(a!=null &amp;&amp; b!=null)&#123; a.next = b.next; b.next = a; if(pre!=null) pre.next = b; if(a.next==null) break; b = a.next.next; pre = a; a = a.next; &#125; return newHead; &#125;&#125; AC, 0ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[023. Merge k Sorted Lists]]></title>
    <url>%2Fp%2F32640f57%2F</url>
    <content type="text"><![CDATA[26.4% https://leetcode.com/problems/merge-k-sorted-lists/ Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 方法一： 对这个vector&lt;ListNode*&gt; 的前两个，进行合并，然后合并结果， 放入vector中，再把vector的前两个删除。只要vector的size不为1， 一直循环。 注意，vector有erase的函数，示例如下：lists.erase(lists.begin()); 123456789101112131415161718192021222324252627ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; if(lists.empty())&#123; return nullptr; &#125; while(lists.size() &gt; 1)&#123; lists.push_back(mergeTwoLists(lists[0], lists[1])); lists.erase(lists.begin()); lists.erase(lists.begin()); &#125; return lists.front();&#125;ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(l1 == nullptr)&#123; return l2; &#125; if(l2 == nullptr)&#123; return l1; &#125; if(l1-&gt;val &lt;= l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125;&#125; 我的代码实现: 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; // 考虑异常，为空时 if(lists.empty()) return NULL; while(lists.size()&gt;1)&#123; ListNode* node = helper(lists[0], lists[1]); // 学习erase的用法，里面使用的是迭代器 lists.erase(lists.begin()); lists.erase(lists.begin()); lists.push_back(node); &#125; return lists[0]; &#125; ListNode* helper(ListNode* l1, ListNode* l2)&#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = helper(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = helper(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 方法二: vector erase效率堪忧，使用deque来解决 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; int n = lists.size(); if(n==0) return NULL; if(n==1) return lists[0]; deque&lt;ListNode*&gt; dq; for(auto node:lists) dq.push_back(node); while(dq.size()&gt;1)&#123; ListNode* l1 = dq.front(); dq.pop_front(); ListNode* l2 = dq.front(); dq.pop_front(); ListNode* l3 = merge(l1, l2); dq.push_back(l3); &#125; return dq.front(); &#125; ListNode* merge(ListNode* l1, ListNode* l2)&#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = merge(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = merge(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/6882/sharing-my-straightforward-c-solution-without-data-structure-other-than-vector Sharing my straightforward C++ solution without data structure other than vector 123456789101112131415161718192021222324252627ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; if(lists.empty())&#123; return nullptr; &#125; while(lists.size() &gt; 1)&#123; lists.push_back(mergeTwoLists(lists[0], lists[1])); lists.erase(lists.begin()); lists.erase(lists.begin()); &#125; return lists.front();&#125;ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(l1 == nullptr)&#123; return l2; &#125; if(l2 == nullptr)&#123; return l1; &#125; if(l1-&gt;val &lt;= l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125;&#125; The second function is from Merge Two Sorted Lists. The basic idea is really simple. We can merge first two lists and then push it back. Keep doing this until there is only one list left in vector. Actually, we can regard this as an iterative divide-and-conquer solution. https://discuss.leetcode.com/topic/7160/brief-c-solution-with-priority_queue Brief C++ solution with priority_queue We just need to define a comparison struct for ListNodes, then managing the priority_queue is quite straightforward. After filling the priority_queue, if it is non-empty, we set the head and tail. Then we repeatedly pop the top off the queue and append that to the tail. If the next node is not null, we push it onto the queue. 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; struct compare &#123; bool operator()(const ListNode* l, const ListNode* r) &#123; return l-&gt;val &gt; r-&gt;val; &#125; &#125;; public: ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, compare&gt; q; for (auto l : lists) &#123; if (l) &#123; q.push(l); &#125; &#125; if (q.empty()) &#123; return NULL; &#125; ListNode* result = q.top(); q.pop(); if (result-&gt;next) &#123; q.push(result-&gt;next); &#125; ListNode* tail = result; while (!q.empty()) &#123; tail-&gt;next = q.top(); q.pop(); tail = tail-&gt;next; if (tail-&gt;next) &#123; q.push(tail-&gt;next); &#125; &#125; return result; &#125;&#125;; python 128ms, 79.54%, September 4, 2016 https://discuss.leetcode.com/topic/23140/108ms-python-solution-with-heapq-and-avoid-changing-heap-size 108ms python solution with heapq and avoid changing heap size 123456789101112131415def mergeKLists(self, lists): from heapq import heappush, heappop, heapreplace, heapify dummy = node = ListNode(0) h = [(n.val, n) for n in lists if n] heapify(h) while h: v, n = h[0] if n.next is None: heappop(h) #only change heap size when necessary else: heapreplace(h, (n.next.val, n.next)) node.next = n node = node.next return dummy.next https://discuss.leetcode.com/topic/33609/10-line-python-solution-with-priority-queue 10-line python solution with priority queue 12345678910111213from Queue import PriorityQueueclass Solution(object): def mergeKLists(self, lists): dummy = ListNode(None) curr = dummy q = PriorityQueue() for node in lists: if node: q.put((node.val,node)) while q.qsize()&gt;0: curr.next = q.get()[1] curr=curr.next if curr.next: q.put((curr.next.val, curr.next)) return dummy.next java https://discuss.leetcode.com/topic/2780/a-java-solution-based-on-priority-queue A java solution based on Priority Queue If someone understand how priority queue works, then it would be trivial to walk through the codes. My question: is that possible to solve this question under the same time complexity without implementing the priority queue? 123456789101112131415161718192021222324252627282930313233public class Solution &#123; public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; if (lists==null||lists.size()==0) return null; PriorityQueue&lt;ListNode&gt; queue= new PriorityQueue&lt;ListNode&gt;(lists.size(),new Comparator&lt;ListNode&gt;()&#123; @Override public int compare(ListNode o1,ListNode o2)&#123; if (o1.val&lt;o2.val) return -1; else if (o1.val==o2.val) return 0; else return 1; &#125; &#125;); ListNode dummy = new ListNode(0); ListNode tail=dummy; for (ListNode node:lists) if (node!=null) queue.add(node); while (!queue.isEmpty())&#123; tail.next=queue.poll(); tail=tail.next; if (tail.next!=null) queue.add(tail.next); &#125; return dummy.next; &#125;&#125; https://discuss.leetcode.com/topic/2780/a-java-solution-based-on-priority-queue/4 I think my code’s complexity is also O(nlogk) and not using heap or priority queue, n means the total elements and k means the size of list. The mergeTwoLists functiony in my code comes from the problem Merge Two Sorted Lists whose complexity obviously is O(n), n is the sum of length of l1 and l2. To put it simpler, assume the k is 2^x, So the progress of combination is like a full binary tree, from bottom to top. So on every level of tree, the combination complexity is n, beacause every level have all n numbers without repetition. The level of tree is x, ie logk. So the complexity is O(nlogk). 12345678910for example, 8 ListNode, and the length of every ListNode is x1, x2,x3, x4, x5, x6, x7, x8, total is n.on level 3: x1+x2, x3+x4, x5+x6, x7+x8 sum: non level 2: x1+x2+x3+x4, x5+x6+x7+x8 sum: non level 1: x1+x2+x3+x4+x5+x6+x7+x8 sum: ntotal 3n, nlog8 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; ListNode head=null; ListNode former=null; while (l1!=null&amp;&amp;l2!=null) &#123; if (l1.val&gt;l2.val) &#123; if (former==null) former=l2; else former.next=l2; if (head==null) head=former; else former=former.next; l2=l2.next; &#125; else &#123; if (former==null) former=l1; else former.next=l1; if (head==null) head=former; else former=former.next; l1=l1.next; &#125; &#125; if (l2!=null) l1=l2; former.next=l1; return head; &#125; public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; if (lists.size()==0) return null; if (lists.size()==1) return lists.get(0); if (lists.size()==2) return mergeTwoLists(lists.get(0), lists.get(1)); return mergeTwoLists(mergeKLists(lists.subList(0, lists.size()/2)), mergeKLists(lists.subList(lists.size()/2, lists.size()))); &#125;&#125; 3ms, 91.70%, September 5, 2016 https://discuss.leetcode.com/topic/26095/my-simple-java-solution-use-recursion My simple java Solution use recursion 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; return partion(lists, 0, lists.length-1); &#125; public static ListNode partion(ListNode[] lists, int s, int e)&#123; if(s==e) return lists[s]; if(s&lt;e)&#123; int q = (s+e) / 2; ListNode l1 = partion(lists, s, q); ListNode l2 = partion(lists, q+1, e); return merge(l1, l2); &#125;else return null; &#125; public static ListNode merge(ListNode l1, ListNode l2)&#123; if(l1==null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val)&#123; l1.next = merge(l1.next, l2); return l1; &#125;else&#123; l2.next = merge(l1, l2.next); return l2; &#125; &#125;&#125; https://discuss.leetcode.com/topic/31276/simple-java-merge-sort Simple Java Merge Sort For this problem, use merge sort is simple and fast, I wonder why some guys solve it use PriorityQueue. I think the complexity is k n logk. Because the recursion depth is logK, and in each level, every element will be compared. 1234567891011121314151617public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) return null; return mergeKLists(lists, 0, lists.length - 1);&#125;private ListNode mergeKLists(ListNode[] lists, int start, int end) &#123; if (start == end) &#123; return lists[start]; &#125; else if (start &lt; end)&#123; int mid = (end - start) / 2 + start; ListNode left = mergeKLists(lists, start, mid); ListNode right = mergeKLists(lists, mid + 1, end); return mergeTwoLists(left, right); &#125; else &#123; return null; &#125;&#125; mergeTwoLists is base on the Merge Two Sorted Lists problem. https://discuss.leetcode.com/topic/8949/13-lines-in-java 13-lines in Java Hi guys! The approach is standard - PriorityQueue, but I noticed that solutions presented before are kind of a bit long. So that’s the concise version. :) Hope it helps! 1234567891011121314151617public class Solution &#123; public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; Queue&lt;ListNode&gt; heap = new PriorityQueue(new Comparator&lt;ListNode&gt;()&#123; @Override public int compare(ListNode l1, ListNode l2) &#123; return l1.val - l2.val; &#125; &#125;); ListNode head = new ListNode(0), tail = head; for (ListNode node : lists) if (node != null) heap.offer(node); while (!heap.isEmpty()) &#123; tail.next = heap.poll(); tail = tail.next; if (tail.next != null) heap.offer(tail.next); &#125; return head.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>divide and conquer</tag>
        <tag>hard</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[022. Generate Parentheses]]></title>
    <url>%2Fp%2Fa9da9348%2F</url>
    <content type="text"><![CDATA[33.4% https://leetcode.com/problems/generate-parentheses/ Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 方法一： The idea is intuitive. Use two integers to count the remaining left parenthesis (n) and the right parenthesis (m) to be added. At each function call add a left parenthesis if n &gt;0 and add a right parenthesis if m&gt;0. Append the result and terminate recursive calls when both m and n are zero. https://leetcode.com/discuss/14436/concise-recursive-c-solution 123456789101112131415161718class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; addingpar(res, &quot;&quot;, n, 0); return res; &#125; void addingpar(vector&lt;string&gt; &amp;v,string str, int n, int m)&#123; if(m==0 &amp;&amp; n==0)&#123; v.push_back(str); return; &#125; if(m&gt;0) addingpar(v, str+&quot;)&quot;, n, m-1); if(n&gt;0) addingpar(v, str+&quot;(&quot;, n-1, m+1); &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/15294/6-lines-c-3-4-ms-super-easy-to-understand 6 lines c++ 3~4 ms, super easy to understand 123456789101112vector&lt;string&gt; result;void helper(string str, int left, int right)&#123; if(left == 0 &amp;&amp; right == 0) result.push_back(str); if(left!=0) helper(str+&apos;(&apos;, left-1, right); if(right!=0 &amp;&amp; right &gt; left) helper(str+&apos;)&apos;, left, right-1);&#125; vector&lt;string&gt; generateParenthesis(int n) &#123; helper(&quot;&quot;,n,n); return result;&#125; 我的代码实现： 递归， 循环调用栈,消耗内存 1234567891011121314151617class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; helper(res, n, n, ""); return res; &#125; void helper(vector&lt;string&gt;&amp; res, int left, int right, string s)&#123; if(left==0 &amp;&amp; right==0) res.push_back(s); if(left!=0) helper(res, left-1, right, s+'('); if(right!=0 &amp;&amp; right&gt;left) helper(res, left, right-1, s+')'); &#125;&#125;; 方法三； dp解法 https://discuss.leetcode.com/topic/3474/an-iterative-method My method is DP. First consider how to get the result f(n) from previous result f(0)…f(n-1).Actually, the result f(n) will be put an extra () pair to f(n-1). Let the “(“ always at the first position, to produce a valid result, we can only put “)” in a way that there will be i pairs () inside the extra () and n - 1 - i pairs () outside the extra pair. Let us consider an example to get clear view: f(0): “” f(1): “(“f(0)”)” f(2): “(“f(0)”)”f(1), “(“f(1)”)” f(3): “(“f(0)”)”f(2), “(“f(1)”)”f(1), “(“f(2)”)” So f(n) = “(“f(0)”)”f(n-1) , “(“f(1)”)”f(n-2) “(“f(2)”)”f(n-3) … “(“f(i)”)”f(n-1-i) … “(f(n-1)”)” Below is my code: 我的代码实现： 123456789101112131415161718class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; // 注意定义及初始化的问题，vector&lt;string&gt;()，而不是vector&lt;string&gt; vector&lt;vector&lt;string&gt;&gt; dp(n+1, vector&lt;string&gt;()); // 学习此处的初始化 dp[0] = vector&lt;string&gt;&#123;""&#125;; for(int i=1; i&lt;=n; i++)&#123; for(int j=0; j&lt;i; j++) for(string first:dp[j]) for(string second:dp[i-j-1])&#123; string t = '(' + first + ')' + second; dp[i].push_back(t); &#125; &#125; return dp[n]; &#125;&#125;; cpp The idea is intuitive. Use two integers to count the remaining left parenthesis (n) and the right parenthesis (m) to be added. At each function call add a left parenthesis if n &gt;0 and add a right parenthesis if m&gt;0. Append the result and terminate recursive calls when both m and n are zero. https://leetcode.com/discuss/14436/concise-recursive-c-solution123456789101112131415161718class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; addingpar(res, &quot;&quot;, n, 0); return res; &#125; void addingpar(vector&lt;string&gt; &amp;v,string str, int n, int m)&#123; if(m==0 &amp;&amp; n==0)&#123; v.push_back(str); return; &#125; if(m&gt;0) addingpar(v, str+&quot;)&quot;, n, m-1); if(n&gt;0) addingpar(v, str+&quot;(&quot;, n-1, m+1); &#125;&#125;; python https://leetcode.com/discuss/43122/4-7-lines-python 4-7 lines Python p is the parenthesis-string built so far, left and right tell the number of left and right parentheses still to add, and parens collects the parentheses. Solution 1 I used a few “tricks”… how many can you find? :-) 1234567def generateParenthesis(self, n): def generate(p, left, right, parens=[]): if left: generate(p + &apos;(&apos;, left-1, right) if right &gt; left: generate(p + &apos;)&apos;, left, right-1) if not right: parens += p, return parens return generate(&apos;&apos;, n, n) Solution 2 Here I wrote an actual Python generator. I allow myself to put the yield q at the end of the line because it’s not that bad and because in “real life” I use Python 3 where I just say yield from generate(…). 12345678def generateParenthesis(self, n): def generate(p, left, right): if right &gt;= left &gt;= 0: if not right: yield p for q in generate(p + &apos;(&apos;, left-1, right): yield q for q in generate(p + &apos;)&apos;, left, right-1): yield q return list(generate(&apos;&apos;, n, n)) Solution 3 Improved version of this. Parameter open tells the number of “already opened” parentheses, and I continue the recursion as long as I still have to open parentheses (n &gt; 0) and I haven’t made a mistake yet (open &gt;= 0). 12345def generateParenthesis(self, n, open=0): if n &gt; 0 &lt;= open: return [&apos;(&apos; + p for p in self.generateParenthesis(n-1, open+1)] + \ [&apos;)&apos; + p for p in self.generateParenthesis(n, open-1)] return [&apos;)&apos; * open] * (not n) java The idea here is to only add ‘(‘ and ‘)’ that we know will guarantee us a solution (instead of adding 1 too many close). Once we add a ‘(‘ we will then discard it and try a ‘)’ which can only close a valid ‘(‘. Each of these steps are recursively called. https://leetcode.com/discuss/25063/easy-to-understand-java-backtracking-solution 1234567891011121314151617181920public class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); backtrack(list, &quot;&quot;, 0, 0, n); return list; &#125; public void backtrack(List&lt;String&gt; list, String str, int open, int close, int max)&#123; if(str.length() == max*2)&#123; list.add(str); return; &#125; if(open&lt;max) backtrack(list, str+&quot;(&quot;, open+1, close, max); if(close&lt;open) backtrack(list, str+&quot;)&quot;, open, close+1, max); &#125; &#125; https://discuss.leetcode.com/topic/3474/an-iterative-method An iterative method. My method is DP. First consider how to get the result f(n) from previous result f(0)…f(n-1).Actually, the result f(n) will be put an extra () pair to f(n-1). Let the “(“ always at the first position, to produce a valid result, we can only put “)” in a way that there will be i pairs () inside the extra () and n - 1 - i pairs () outside the extra pair. 1234567891011Let us consider an example to get clear view:f(0): &quot;&quot;f(1): &quot;(&quot;f(0)&quot;)&quot;f(2): &quot;(&quot;f(0)&quot;)&quot;f(1), &quot;(&quot;f(1)&quot;)&quot;f(3): &quot;(&quot;f(0)&quot;)&quot;f(2), &quot;(&quot;f(1)&quot;)&quot;f(1), &quot;(&quot;f(2)&quot;)&quot;So f(n) = &quot;(&quot;f(0)&quot;)&quot;f(n-1) , &quot;(&quot;f(1)&quot;)&quot;f(n-2) &quot;(&quot;f(2)&quot;)&quot;f(n-3) ... &quot;(&quot;f(i)&quot;)&quot;f(n-1-i) ... &quot;(f(n-1)&quot;)&quot; Below is my code: 12345678910111213141516171819202122232425262728public class Solution&#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;&gt;(); lists.add(Collections.singletonList(&quot;&quot;)); for (int i = 1; i &lt;= n; ++i) &#123; final List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; i; ++j) &#123; for (final String first : lists.get(j)) &#123; for (final String second : lists.get(i - 1 - j)) &#123; list.add(&quot;(&quot; + first + &quot;)&quot; + second); &#125; &#125; &#125; lists.add(list); &#125; return lists.get(lists.size() - 1); &#125;&#125; https://discuss.leetcode.com/topic/23229/java-dfs-way-solution Java DFS way solution 1234567891011121314151617181920public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); generateOneByOne(&quot;&quot;, list, n, n); return list;&#125;public void generateOneByOne(String sublist, List&lt;String&gt; list, int left, int right)&#123; if(left &gt; right)&#123; return; &#125; if(left &gt; 0)&#123; generateOneByOne( sublist + &quot;(&quot; , list, left-1, right); &#125; if(right &gt; 0)&#123; generateOneByOne( sublist + &quot;)&quot; , list, left, right-1); &#125; if(left == 0 &amp;&amp; right == 0)&#123; list.add(sublist); return; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[021. Merge Two Sorted Lists]]></title>
    <url>%2Fp%2F149a587d%2F</url>
    <content type="text"><![CDATA[39.2% https://leetcode.com/problems/merge-two-sorted-lists/ Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 剑指offer 17题 方法一： 简单的递归就行了 我的代码实现： Oct 11， 2017 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 1234567891011121314class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(l1==NULL) return l2; if(l2==NULL) return l1; if(l1-&gt;val &lt;= l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 方法二： 我的代码实现： 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125; cur = cur-&gt;next; &#125; if(l1) cur-&gt;next = l1; if(l2) cur-&gt;next = l2; return dummy-&gt;next; &#125;&#125;; 迭代形式的写法 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; ListNode dummy(INT_MIN); ListNode *tail = &amp;dummy; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; tail-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; tail-&gt;next = l2; l2 = l2-&gt;next; &#125; tail = tail-&gt;next; &#125; tail-&gt;next = l1 ? l1 : l2; return dummy.next; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125; // cur不要忘记前向走 cur = cur-&gt;next; &#125; // 对于链表，剩下的一部分特别好处理 cur-&gt;next = l1 ? l1 : l2; return dummy-&gt;next; &#125;&#125;; cpp https://discuss.leetcode.com/topic/2513/a-recursive-solution A recursive solution 123456789101112131415class Solution &#123;public: ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(l1 == NULL) return l2; if(l2 == NULL) return l1; if(l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l2-&gt;next, l1); return l2; &#125; &#125;&#125;; This solution is not a tail-recursive, the stack will overflow while the list is too long :) http://en.wikipedia.org/wiki/Tail_call 12ms, 7.11%, June.18th, 2016 https://leetcode.com/discuss/18986/14-line-clean-c-solution 14 line clean C++ Solution 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; ListNode dummy(INT_MIN); ListNode *tail = &amp;dummy; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; tail-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; tail-&gt;next = l2; l2 = l2-&gt;next; &#125; tail = tail-&gt;next; &#125; tail-&gt;next = l1 ? l1 : l2; return dummy.next; &#125;&#125;; https://discuss.leetcode.com/topic/4480/clean-simple-o-n-m-c-solution-without-dummy-head-and-recurtion Clean, simple O(n+m) C++ Solution, without dummy head and recurtion Please refer to the comments inline. 1234567891011121314151617181920212223242526ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(NULL == l1) return l2; if(NULL == l2) return l1; ListNode* head=NULL; // head of the list to return // find first element (can use dummy node to put this part inside of the loop) if(l1-&gt;val &lt; l2-&gt;val) &#123; head = l1; l1 = l1-&gt;next; &#125; else &#123; head = l2; l2 = l2-&gt;next; &#125; ListNode* p = head; // pointer to form new list // I use &amp;&amp; to remove extra IF from the loop while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val) &#123; p-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; p-&gt;next = l2; l2 = l2-&gt;next; &#125; p=p-&gt;next; &#125; // add the rest of the tail, done! if(l1) p-&gt;next=l1; else p-&gt;next=l2; return head;&#125; python https://leetcode.com/discuss/51679/python-solutions-iteratively-recursively-iteratively-place Python solutions (iteratively, recursively, iteratively in-place). 12345678910111213# iterativelydef mergeTwoLists1(self, l1, l2): dummy = cur = ListNode(0) while l1 and l2: if l1.val &lt; l2.val: cur.next = l1 l1 = l1.next else: cur.next = l2 l2 = l2.next cur = cur.next cur.next = l1 or l2 return dummy.next 12345678910# recursively def mergeTwoLists2(self, l1, l2): if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2 123456789101112131415161718# in-place, iteratively def mergeTwoLists(self, l1, l2): if None in (l1, l2): return l1 or l2 dummy = cur = ListNode(0) dummy.next = l1 while l1 and l2: if l1.val &lt; l2.val: l1 = l1.next else: nxt = cur.next cur.next = l2 tmp = l2.next l2.next = nxt l2 = tmp cur = cur.next cur.next = l1 or l2 return dummy.next java https://discuss.leetcode.com/topic/5513/my-recursive-way-to-solve-this-problem-java-easy-understanding My recursive way to solve this problem(JAVA, easy understanding) Hello every one, here is my code, simple but works well: 123456789101112131415161718192021public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null)&#123; return l2; &#125; if(l2 == null)&#123; return l1; &#125; ListNode mergeHead; if(l1.val &lt; l2.val)&#123; mergeHead = l1; mergeHead.next = mergeTwoLists(l1.next, l2); &#125; else&#123; mergeHead = l2; mergeHead.next = mergeTwoLists(l1, l2.next); &#125; return mergeHead; &#125;&#125; https://discuss.leetcode.com/topic/45002/java-1-ms-4-lines-codes-using-recursion Java, 1 ms, 4 lines codes, using recursion 1234567891011public ListNode mergeTwoLists(ListNode l1, ListNode l2)&#123; if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val)&#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else&#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; https://discuss.leetcode.com/topic/5199/java-solution-for-reference Java solution for reference Similar to array, the difference is if any of two listnode is not null after first loop, we only need to add it as previous node’s next and no need to add them one by one. 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null &amp;&amp; l2 == null) &#123; return null; &#125; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; ListNode result = new ListNode(0); ListNode prev = result; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; prev.next = l1; l1 = l1.next; &#125; else &#123; prev.next = l2; l2 = l2.next; &#125; prev = prev.next; &#125; if (l1 != null) &#123; prev.next = l1; &#125; if (l2 != null) &#123; prev.next = l2; &#125; return result.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[020. Valid Parentheses]]></title>
    <url>%2Fp%2F44690127%2F</url>
    <content type="text"><![CDATA[32.5% https://leetcode.com/problems/valid-parentheses/ Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. 方法一： 使用栈，依次进行考虑。 My 0ms c++ solution using stack code 1： 1234567891011121314bool isValid(string s) &#123; stack&lt;char&gt; st; for(char c : s)&#123; if(c == &apos;(&apos;|| c == &apos;&#123;&apos; || c == &apos;[&apos;)&#123; st.push(c); &#125;else&#123; if(st.empty()) return false; if(c == &apos;)&apos; &amp;&amp; st.top() != &apos;(&apos;) return false; if(c == &apos;&#125;&apos; &amp;&amp; st.top() != &apos;&#123;&apos;) return false; if(c == &apos;]&apos; &amp;&amp; st.top() != &apos;[&apos;) return false; st.pop(); &#125; &#125; return st.empty(); 方法二: 我的代码实现: 12345678910111213141516171819class Solution &#123;public: bool isValid(string s) &#123; if(s.empty()) return true; stack&lt;char&gt; stack; unordered_map&lt;char, char&gt; map = &#123;&#123;'(', ')'&#125;, &#123;'[', ']'&#125;, &#123;'&#123;', '&#125;'&#125;&#125;; for(auto c:s)&#123; if(map.find(c)!=map.end()) stack.push(map[c]); else&#123; if(!stack.empty() &amp;&amp; stack.top()==c) stack.pop(); else return false; &#125; &#125; return stack.empty(); &#125;&#125;; 重点学一下，进一个map，及map的赋值操作。 1234567891011121314151617181920212223class Solution &#123; public: bool isValid(string s) &#123; map&lt;char, char&gt; parenth_dict; parenth_dict[&apos;(&apos;] = &apos;)&apos;; parenth_dict[&apos;&#123;&apos;] = &apos;&#125;&apos;; parenth_dict[&apos;[&apos;] = &apos;]&apos;; stack&lt;char&gt; aux; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos;(&apos; || s[i] == &apos;&#123;&apos; || s[i] == &apos;[&apos;) aux.push(s[i]); else if (aux.empty() || parenth_dict[aux.top()] != s[i]) return false; else aux.pop(); &#125; return aux.empty(); &#125;&#125;; java https://discuss.leetcode.com/topic/7813/my-easy-to-understand-java-solution-with-one-stack My easy to understand Java Solution with one stack 12345678910111213141516171819202122public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); // Iterate through string until empty for(int i = 0; i&lt;s.length(); i++) &#123; // Push any open parentheses onto stack if(s.charAt(i) == &apos;(&apos; || s.charAt(i) == &apos;[&apos; || s.charAt(i) == &apos;&#123;&apos;) stack.push(s.charAt(i)); // Check stack for corresponding closing parentheses, false if not valid else if(s.charAt(i) == &apos;)&apos; &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == &apos;(&apos;) stack.pop(); else if(s.charAt(i) == &apos;]&apos; &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == &apos;[&apos;) stack.pop(); else if(s.charAt(i) == &apos;&#125;&apos; &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == &apos;&#123;&apos;) stack.pop(); else return false; &#125; // return true if no open parentheses left in stack return stack.empty(); &#125;&#125; https://discuss.leetcode.com/topic/27572/short-java-solution Short java solution1234567891011121314public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c : s.toCharArray()) &#123; if (c == &apos;(&apos;) stack.push(&apos;)&apos;); else if (c == &apos;&#123;&apos;) stack.push(&apos;&#125;&apos;); else if (c == &apos;[&apos;) stack.push(&apos;]&apos;); else if (stack.isEmpty() || stack.pop() != c) return false; &#125; return stack.isEmpty();&#125; https://discuss.leetcode.com/topic/9372/12-lines-of-java 12 lines of Java 123456789101112public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Integer&gt; p = new Stack&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++) &#123; int q = &quot;()&#123;&#125;[]&quot;.indexOf(s.substring(i, i + 1)); if(q % 2 == 1) &#123; if(p.isEmpty() || p.pop() != q - 1) return false; &#125; else p.push(q); &#125; return p.isEmpty(); &#125;&#125; https://discuss.leetcode.com/topic/27768/short-easy-to-follow-8ms-java-solution Short, Easy to Follow 8ms Java Solution 123456789101112public class Solution &#123; public boolean isValid(String s) &#123; int length; do &#123; length = s.length(); s = s.replace(&quot;()&quot;, &quot;&quot;).replace(&quot;&#123;&#125;&quot;, &quot;&quot;).replace(&quot;[]&quot;, &quot;&quot;); &#125; while(length != s.length()); return s.length() == 0; &#125;&#125; In this solution you essentially can remove parentheses that you know are valid until the string is empty. If the string is not empty, that means that the parentheses were malformed. https://discuss.leetcode.com/topic/47067/java-iterative-solution-beating-97 Java iterative solution beating 97% Just implement a simple stack using a char array and check that, for each closing bracket, there is its counterpart in the top of the stack. 1234567891011121314151617181920212223242526public class Solution &#123; public boolean isValid(String s) &#123; char[] stack = new char[s.length()]; int head = 0; for(char c : s.toCharArray()) &#123; switch(c) &#123; case &apos;&#123;&apos;: case &apos;[&apos;: case &apos;(&apos;: stack[head++] = c; break; case &apos;&#125;&apos;: if(head == 0 || stack[--head] != &apos;&#123;&apos;) return false; break; case &apos;)&apos;: if(head == 0 || stack[--head] != &apos;(&apos;) return false; break; case &apos;]&apos;: if(head == 0 || stack[--head] != &apos;[&apos;) return false; break; &#125; &#125; return head == 0; &#125;&#125; my code: 1234567891011121314151617181920212223public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); if(s==null || s.length()==0) return true; for(int i=0; i&lt;s.length(); i++)&#123; char tmp = s.charAt(i); if(!stack.empty() &amp;&amp; tmp==&apos;)&apos; &amp;&amp; stack.peek()==&apos;(&apos;) stack.pop(); else if(!stack.empty() &amp;&amp; tmp==&apos;]&apos; &amp;&amp; stack.peek()==&apos;[&apos;) stack.pop(); else if(!stack.empty() &amp;&amp; tmp==&apos;&#125;&apos; &amp;&amp; stack.peek()==&apos;&#123;&apos;) stack.pop(); else if(tmp==&apos;(&apos; || tmp==&apos;[&apos; || tmp==&apos;&#123;&apos;) stack.push(tmp); else return false; &#125; if(stack.empty()) return true; else return false; &#125;&#125; cpp https://discuss.leetcode.com/topic/13231/2ms-c-sloution 2ms C++ sloution Repetitive code but I guess this is clean, and easy to understand. This solution also accepts (and ignores) any characters other than parenthesis in the string. Hence, it can be used to check if the parenthesis matches in an equation for example. 1234567891011121314151617181920#include &lt;stack&gt;class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; paren; for (char&amp; c : s) &#123; switch (c) &#123; case &apos;(&apos;: case &apos;&#123;&apos;: case &apos;[&apos;: paren.push(c); break; case &apos;)&apos;: if (paren.empty() || paren.top()!=&apos;(&apos;) return false; else paren.pop(); break; case &apos;&#125;&apos;: if (paren.empty() || paren.top()!=&apos;&#123;&apos;) return false; else paren.pop(); break; case &apos;]&apos;: if (paren.empty() || paren.top()!=&apos;[&apos;) return false; else paren.pop(); break; default: ; // pass &#125; &#125; return paren.empty() ; &#125;&#125;; https://discuss.leetcode.com/topic/32413/my-0ms-c-solution-using-stack My 0ms c++ solution using stack 1234567891011121314bool isValid(string s) &#123; stack&lt;char&gt; st; for(char c : s)&#123; if(c == &apos;(&apos;|| c == &apos;&#123;&apos; || c == &apos;[&apos;)&#123; st.push(c); &#125;else&#123; if(st.empty()) return false; if(c == &apos;)&apos; &amp;&amp; st.top() != &apos;(&apos;) return false; if(c == &apos;&#125;&apos; &amp;&amp; st.top() != &apos;&#123;&apos;) return false; if(c == &apos;]&apos; &amp;&amp; st.top() != &apos;[&apos;) return false; st.pop(); &#125; &#125; return st.empty(); https://discuss.leetcode.com/topic/7188/sharing-my-simple-cpp-code-with-2ms Sharing my simple cpp code with 2ms 1234567891011121314151617181920212223class Solution &#123; public: bool isValid(string s) &#123; map&lt;char, char&gt; parenth_dict; parenth_dict[&apos;(&apos;] = &apos;)&apos;; parenth_dict[&apos;&#123;&apos;] = &apos;&#125;&apos;; parenth_dict[&apos;[&apos;] = &apos;]&apos;; stack&lt;char&gt; aux; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos;(&apos; || s[i] == &apos;&#123;&apos; || s[i] == &apos;[&apos;) aux.push(s[i]); else if (aux.empty() || parenth_dict[aux.top()] != s[i]) return false; else aux.pop(); &#125; return aux.empty(); &#125;&#125;; python https://discuss.leetcode.com/topic/6534/simple-python-solution-with-stack Simple Python solution with stack 1234567891011121314class Solution: # @return a boolean def isValid(self, s): stack = [] dict = &#123;&quot;]&quot;:&quot;[&quot;, &quot;&#125;&quot;:&quot;&#123;&quot;, &quot;)&quot;:&quot;(&quot;&#125; for char in s: if char in dict.values(): stack.append(char) elif char in dict.keys(): if stack == [] or dict[char] != stack.pop(): return False else: return False return stack == [] https://discuss.leetcode.com/topic/40897/python-is-this-a-cheating-method-accepted-with-40ms-easy-to-understand-but [Python] is this a cheating method? accepted with 40ms, easy to understand, but 1234567891011121314151617181920class Solution(object): def isValid(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; n = len(s) if n == 0: return True if n % 2 != 0: return False while &apos;()&apos; in s or &apos;&#123;&#125;&apos; in s or &apos;[]&apos; in s: s = s.replace(&apos;&#123;&#125;&apos;,&apos;&apos;).replace(&apos;()&apos;,&apos;&apos;).replace(&apos;[]&apos;,&apos;&apos;) if s == &apos;&apos;: return True else: return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[019. Remove Nth Node From End of List]]></title>
    <url>%2Fp%2F72420d7f%2F</url>
    <content type="text"><![CDATA[33.6% https://leetcode.com/problems/remove-nth-node-from-end-of-list/ Given a linked list, remove the nth node from the end of list and return its head. 12345For example,Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Try to do this in one pass. 类似于剑指offer 15 方法一： 4ms, 37.53%, September 3, 2016 https://discuss.leetcode.com/topic/5397/my-short-c-solution My short C++ solution 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode** t1 = &amp;head, *t2 = head; for(int i=1; i&lt;n; ++i) t2 = t2-&gt;next; while(t2-&gt;next != NULL)&#123; t1 = &amp;((*t1)-&gt;next); t2 = t2 -&gt; next; &#125; *t1 = (*t1)-&gt;next; return head; &#125;&#125;; 方法二： 我的代码实现： 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; // 链表经常在头部设置一个哑变量， 针对一些特殊情况，非常有效 ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* fast = dummy, *slow = dummy; while(n&gt;0)&#123; fast = fast-&gt;next; n--; &#125; while(fast-&gt;next)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return dummy-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/7753/c-solution-easy-to-understand-with-explanations C++ solution, easy to understand with explanations. Renewed SolutionThe difference between the final node and the to_be_delete node is N. And here the assumption is that n is always valid. fast pointer points to the node which is N step away from the to_be_delete node. slow pointer points to the to_be_delete node. The algorithms is described as below: Firstly, move fast pointer N step forward. Secondly,move fast and slow pointers simultaneously one step a time forward till the fast pointer reach the end, which will cause the slow pointer points to the previous node of the to_be_delete node. Finally, slow-&gt;next = slow-&gt;next-&gt;next. 1234567891011121314151617181920212223242526ListNode *removeNthFromEnd(ListNode *head, int n) &#123; if (!head) return nullptr; ListNode new_head(-1); new_head.next = head; ListNode *slow = &amp;new_head, *fast = &amp;new_head; for (int i = 0; i &lt; n; i++) fast = fast-&gt;next; while (fast-&gt;next) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; ListNode *to_de_deleted = slow-&gt;next; slow-&gt;next = slow-&gt;next-&gt;next; delete to_be_deleted; return new_head.next;&#125; Fixed : Added code for deleting the N-th node. java 1ms, 5.49%, September 3, 2016 https://discuss.leetcode.com/topic/7031/simple-java-solution-in-one-pass Simple Java solution in one pass A one pass solution can be done using pointers. Move one pointer fast –&gt; n+1 places forward, to maintain a gap of n between the two pointers and then move both at the same speed. Finally, when the fast pointer reaches the end, the slow pointer will be n+1 places behind - just the right spot for it to be able to skip the next node. Since the question gives that n is valid, not too many checks have to be put in place. Otherwise, this would be necessary. 12345678910111213141516171819public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode start = new ListNode(0); ListNode slow = start, fast = start; slow.next = head; //Move fast in front so that the gap between slow and fast becomes n for(int i=1; i&lt;=n+1; i++) &#123; fast = fast.next; &#125; //Move fast to the end, maintaining the gap while(fast != null) &#123; slow = slow.next; fast = fast.next; &#125; //Skip the desired node slow.next = slow.next.next; return start.next;&#125; 1ms, 5.49%, September 3, 2016 https://discuss.leetcode.com/topic/20745/my-one-pass-solution My one pass solution 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode h1 = head, h2=head; while(n--&gt;0) h2 = h2.next; if(h2==null) return head.next; h2=h2.next; while(h2!=null)&#123; h1 = h1.next; h2 = h2.next; &#125; h1.next = h1.next.next; return head; &#125;&#125; https://discuss.leetcode.com/topic/42339/java-solution-1ms-%E5%AE%B9%E6%98%93%E7%90%86%E8%A7%A3 Java solution 1ms 容易理解 12345678910111213141516//还是走的快的点(fastNode)与走得慢的点(slowNode)路程差的问题 public static ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode headNode = new ListNode(9527); headNode.next = head; ListNode fastNode = headNode; ListNode slowNode = headNode; while(fastNode.next != null)&#123; if(n &lt;= 0) slowNode = slowNode.next; fastNode = fastNode.next; n--; &#125; if(slowNode.next != null) slowNode.next = slowNode.next.next; return headNode.next; &#125; https://discuss.leetcode.com/topic/12125/my-simple-java-solution-in-one-pass My simple Java solution in one pass 123456789101112131415public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy=new ListNode(0); dummy.next=head; ListNode fast=dummy; ListNode slow=dummy; int temp=n; for(;fast.next!=null;temp--)&#123; if(temp&lt;=0)&#123; //control slow=slow.next; &#125; fast=fast.next; &#125; slow.next=slow.next.next;//delete Nth return dummy.next;&#125; python 39ms, 100.00%, September 3, 2016 https://discuss.leetcode.com/topic/14692/3-short-python-solutions Value-Shifting - AC in 64 ms My first solution is “cheating” a little. Instead of really removing the nth node, I remove the nth value. I recursively determine the indexes (counting from back), then shift the values for all indexes larger than n, and then always drop the head. 1234567891011class Solution: def removeNthFromEnd(self, head, n): def index(node): if not node: return 0 i = index(node.next) + 1 if i &gt; n: node.next.val = node.val return i index(head) return head.next Index and Remove - AC in 56 ms In this solution I recursively determine the indexes again, but this time my helper function removes the nth node. It returns two values. The index, as in my first solution, and the possibly changed head of the remaining list. 12345678class Solution: def removeNthFromEnd(self, head, n): def remove(head): if not head: return 0, head i, head.next = remove(head.next) return i+1, (head, head.next)[i+1 == n] return remove(head)[1] n ahead - AC in 48 ms The standard solution, but without a dummy extra node. Instead, I simply handle the special case of removing the head right after the fast cursor got its head start. 123456789101112class Solution: def removeNthFromEnd(self, head, n): fast = slow = head for _ in range(n): fast = fast.next if not fast: return head.next while fast.next: fast = fast.next slow = slow.next slow.next = slow.next.next return head]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>two pointers</tag>
        <tag>medium</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[018. 4Sum]]></title>
    <url>%2Fp%2F964c48a1%2F</url>
    <content type="text"><![CDATA[25.9% https://leetcode.com/problems/4sum/ Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 12345678For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 方法一： 我的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); if(n&lt;4) return res; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-3; i++)&#123; if(i!=0 &amp;&amp; nums[i]==nums[i-1]) continue; if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target) break; // 此处为break； if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]&lt;target) continue; // 此处为continue; 注意区分 for(int j=i+1; j&lt;n-2; j++)&#123; if(j!=i+1 &amp;&amp; nums[j]==nums[j-1]) continue; if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; int k=j+1, l=n-1; while(k&lt;l)&#123; int sum = nums[i]+nums[j]+nums[k]+nums[l]; if(sum==target)&#123; res.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[k], nums[l]&#125;); while(k&lt;l &amp;&amp; nums[k+1]==nums[k]) k++; while(k&lt;l &amp;&amp; nums[l-1]==nums[l]) l--; k++; l--; &#125;else if(sum&gt;target) l--; else k++; &#125; &#125; &#125; return res; &#125;&#125;; 16ms, 91.80%, April.23rd, 2016 https://leetcode.com/discuss/87769/implementation-carefully-pruning-accelerates-from-100ms First thanks to the post from @cx1992 I will just say that with out the 2 using of the 123if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; The runing time without these two lines cost 100ms. But with these lines, cost 16ms ! Here is the final implementation 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; result; int n=nums.size(); if(n&lt;4) return result; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-3; i++)&#123; if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) continue; /** cut edge to accelerate the speed **/ if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target) break; // 此处加break if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]&lt;target) continue; for(int j=i+1; j&lt;n-2; j++)&#123; if(j&gt;i+1 &amp;&amp; nums[j]==nums[j-1]) continue; /** cut edge to accelerate the speed **/ if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; /** jia bi process **/ int start=j+1, end=n-1; while(start &lt; end)&#123; int sum=nums[start]+nums[end]+nums[i]+nums[j]; if(sum&lt;target) start++; else if(sum&gt;target) end--; else&#123; result.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[start], nums[end]&#125;); start++; end--; while(nums[start-1]==nums[start] &amp;&amp; start&lt;end) start++; while(nums[end+1]==nums[end] &amp;&amp; start&lt;end) end--; &#125; &#125; &#125; &#125; return result; &#125;&#125;; 另一种代码实现： https://discuss.leetcode.com/topic/28641/my-16ms-c-code My 16ms c++ code 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; total; int n = nums.size(); if(n&lt;4) return total; sort(nums.begin(),nums.end()); for(int i=0;i&lt;n-3;i++) &#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue; if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target) break; if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]&lt;target) continue; for(int j=i+1;j&lt;n-2;j++) &#123; if(j&gt;i+1&amp;&amp;nums[j]==nums[j-1]) continue; if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; int left=j+1,right=n-1; while(left&lt;right)&#123; int sum=nums[left]+nums[right]+nums[i]+nums[j]; if(sum&lt;target) left++; else if(sum&gt;target) right--; else&#123; total.push_back(vector&lt;int&gt;&#123;nums[i],nums[j],nums[left],nums[right]&#125;); do&#123;left++;&#125;while(nums[left]==nums[left-1]&amp;&amp;left&lt;right); do&#123;right--;&#125;while(nums[right]==nums[right+1]&amp;&amp;left&lt;right); &#125; &#125; &#125; &#125; return total; &#125;&#125;; 方法二： 100ms, 45.73%, Apr.23rd, 2016 http://c4fun.cn/blog/2014/03/20/leetcode-solution-02/ 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt; &gt; ans; sort(num.begin(), num.end()); for (int i = 0; i &lt; num.size(); i++) &#123; if (i &gt; 0 &amp;&amp; num[i] == num[i-1]) continue; for (int j = i + 1; j &lt; num.size(); j++) &#123; if (j &gt; i + 1 &amp;&amp; num[j] == num[j - 1]) continue; int l = j + 1, r = num.size() - 1; while (l &lt; r) &#123; int sum = num[i] + num[j] + num[l] + num[r]; if (sum == target) &#123; ans.push_back(&#123;num[i], num[j], num[l], num[r]&#125;); while (l &lt; r &amp;&amp; num[l] == num[l + 1]) l++; l++; while (l &lt; r &amp;&amp; num[r] == num[r - 1]) r--; r--; &#125; else if (sum &lt; target) &#123; l++; &#125; else &#123; r--; &#125; &#125; &#125; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/27445/lower-bound-n-3 Lower bound n^3 Some people say their solutions are O(n2 log n) or even O(n2), but… Consider cases where nums is the n numbers from 1 to n. =&gt; There are Θ(n4) different quadruplets (nC4, to be exact, so about n4 / 24). =&gt; There are Θ(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums). =&gt; At least one sum must have Ω(n3) different quadruplets. =&gt; For that sum, we must generate those Ω(n3) quadruplets. =&gt; For these cases we have to do Ω(n3) work. =&gt; O(n2 log n) or even O(n2) are impossible. (I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.) cpp https://discuss.leetcode.com/topic/3752/my-c-solution-using-hashtable My C++ solution using hashtable My idea is to sort num first, then build a hashtable with the key as the sum of the pair and the value as a vector storing all pairs of index of num that having the same sum. In this way, all elements stored in hashtable has a order that duplicate pairs are neighbors. Therefore scanning the vector in the hashtable we only put non duplicate elements into the final answer vvi. Is this method O(n^2) ? or Does anyone can improve it to O(n^2); 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution&#123; //using hashtable, avg O(n^2)public: vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target)&#123; vector&lt;vector&lt;int&gt; &gt; vvi; int n = num.size(); if(n &lt; 4) return vvi; sort(num.begin(), num.end()); unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt; &gt; mp; for(int i = 0; i &lt; n; i++)&#123; for(int j = i + 1; j &lt; n; j++)&#123; mp[num[i]+num[j]].push_back(make_pair(i,j)); &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; if(i&gt;0 &amp;&amp; num[i] == num[i-1]) continue; for(int j = i + 1; j &lt; n; j++)&#123; if(j &gt; i + 1 &amp;&amp; num[j] == num[j-1]) continue; int res = target - num[i] - num[j]; if(mp.count(res))&#123; for(auto it = mp[res].begin(); it != mp[res].end(); it++)&#123; int k = (*it).first, l = (*it).second; if(k &gt; j)&#123; // k&gt;j make sure that the second pair has bigger values than the first pair. if(!vvi.empty() &amp;&amp; num[i]==vvi.back()[0] &amp;&amp; num[j]==vvi.back()[1] &amp;&amp; num[k]==vvi.back()[2] &amp;&amp; num[l] == vvi.back()[3])&#123; continue; //if the obtained 4 elements are the same as previous one continue to next &#125; vector&lt;int&gt; vi=&#123;num[i], num[j], num[k], num[l]&#125;; vvi.push_back(vi); &#125; // if k&gt;j &#125;//for it &#125;//if &#125;// forj &#125;//for i return vvi; &#125; &#125;; python https://discuss.leetcode.com/topic/10995/share-my-python-code-run-time-200-20ms Share my python code, run time 200+- 20ms 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution: # @return a list of lists of length 4, [[val1,val2,val3,val4]] def fourSum(self, num, target): num.sort() result = [] for i in xrange(len(num)-3): if num[i] &gt; target/4.0: break if i &gt; 0 and num[i] == num[i-1]: continue target2 = target - num[i] for j in xrange(i+1, len(num)-2): if num[j] &gt; target2/3.0: break if j &gt; i+1 and num[j] == num[j-1]: continue k = j + 1 l = len(num) - 1 target3 = target2 - num[j] # we should use continue not break # because target3 changes as j changes if num[k] &gt; target3/2.0: continue if num[l] &lt; target3/2.0: continue while k &lt; l: sum_value = num[k] + num[l] if sum_value == target3: result.append([num[i], num[j], num[k], num[l]]) kk = num[k] k += 1 while k&lt;l and num[k] == kk: k += 1 ll = num[l] l -= 1 while k&lt;l and num[l] == ll: l -= 1 elif sum_value &lt; target3: k += 1 else: l -= 1 return result We can reduce run time by adding some restrictions. https://discuss.leetcode.com/topic/9078/twosum-twosum-foursum-a-simple-python-solution TwoSum+twoSum == fourSum, a simple python solution 12345678910111213141516class Solution:# @return a list of lists of length 4, [[val1,val2,val3,val4]]def fourSum(self, num, target): two_sum = collections.defaultdict(list) res = set() for (n1, i1), (n2, i2) in itertools.combinations(enumerate(num), 2): two_sum[i1+i2].append(&#123;n1, n2&#125;) for t in list(two_sum.keys()): if not two_sum[target-t]: continue for pair1 in two_sum[t]: for pair2 in two_sum[target-t]: if pair1.isdisjoint(pair2): res.add(tuple(sorted(num[i] for i in pair1 | pair2))) del two_sum[t] return [list(r) for r in res] https://discuss.leetcode.com/topic/10556/a-conise-python-solution-based-on-ksum A conise python solution based on ksum 12345678910111213141516171819202122232425262728class Solution: # @return a list of lists of length 4, [[val1,val2,val3,val4]] def fourSum(self, num, target): num.sort() def ksum(num, k, target): i = 0 result = set() if k == 2: j = len(num) - 1 while i &lt; j: if num[i] + num[j] == target: result.add((num[i], num[j])) i += 1 elif num[i] + num[j] &gt; target: j -= 1 else: i += 1 else: while i &lt; len(num) - k + 1: newtarget = target - num[i] subresult = ksum(num[i+1:], k - 1, newtarget) if subresult: result = result | set( (num[i],) + nr for nr in subresult) i += 1 return result return [list(t) for t in ksum(num, 4, target)] 148ms, 86.46%, April.23rd, 2016 https://leetcode.com/discuss/83152/python-beats-86-07%25-may-be-better python beats 86.07% may be better make sure nums[i]!=nums[i+1] to avoid duplication and unnecessary computations and whennums[i]*4 &gt; target,It’ll be impossible to get another answer. and when nums[j]*4 &lt; target,It should turn to next loop maybe in some situations:usenums[i]+nums[i+1]+nums[i+2]+nums[i+3]wil be better.I am just for convenience.. 1234567891011121314151617181920212223242526class Solution(object): def fourSum(self, nums, target): res, n, nums, limit = [], len(nums), sorted(nums), target &gt;&gt; 2 for i in xrange(n-3): if nums[i] &gt; limit: #limit 1 break if i != 0 and nums[i] == nums[i-1]: #remove duplicate continue for j in xrange(n-1,i+2,-1): #Reverse traversal if nums[j] &lt; limit: #limit 2 break if j != n -1 and nums[j] == nums[j+1]: #remove duplicate continue lo, hi, sum2 = i + 1, j - 1, nums[i] + nums[j] limit2 = (target - sum2) &gt;&gt; 1 while lo &lt; hi and nums[lo] &lt;= limit2 and nums[hi] &gt;= limit2: #limit 3 sum = sum2 + nums[lo] + nums[hi] if sum == target: res += (nums[i], nums[lo], nums[hi], nums[j]), while lo &lt; hi and nums[hi] == nums[hi-1]: #remove duplicate hi -= 1 while lo &lt; hi and nums[lo] == nums[lo+1]: #remove duplicate lo += 1 lo += sum &lt;= target hi -= sum &gt;= target return res https://discuss.leetcode.com/topic/22705/python-140ms-beats-100-and-works-for-n-sum-n-2 Python 140ms beats 100%, and works for N-sum (N&gt;=2) The core is to implement a fast 2-pointer to solve 2-sum, and recursion to reduce the N-sum to 2-sum. Some optimization was be made knowing the list is sorted. 1234567891011121314151617181920212223242526272829303132def fourSum(self, nums, target): nums.sort() results = [] self.findNsum(nums, target, 4, [], results) return resultsdef findNsum(self, nums, target, N, result, results): if len(nums) &lt; N or N &lt; 2: return # solve 2-sum if N == 2: l,r = 0,len(nums)-1 while l &lt; r: if nums[l] + nums[r] == target: results.append(result + [nums[l], nums[r]]) l += 1 r -= 1 while l &lt; r and nums[l] == nums[l - 1]: l += 1 while r &gt; l and nums[r] == nums[r + 1]: r -= 1 elif nums[l] + nums[r] &lt; target: l += 1 else: r -= 1 else: for i in range(0, len(nums)-N+1): # careful about range if target &lt; nums[i]*N or target &gt; nums[-1]*N: # take advantages of sorted list break if i == 0 or i &gt; 0 and nums[i-1] != nums[i]: # recursively reduce N self.findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results) return Just revisited and clean the code 12345678910111213141516171819202122232425def fourSum(self, nums, target): def findNsum(nums, target, N, result, results): if len(nums) &lt; N or N &lt; 2 or target &lt; nums[0]*N or target &gt; nums[-1]*N: # early termination return if N == 2: # two pointers solve sorted 2-sum problem l,r = 0,len(nums)-1 while l &lt; r: s = nums[l] + nums[r] if s == target: results.append(result + [nums[l], nums[r]]) l += 1 while l &lt; r and nums[l] == nums[l-1]: l += 1 elif s &lt; target: l += 1 else: r -= 1 else: # recursively reduce N for i in range(len(nums)-N+1): if i == 0 or (i &gt; 0 and nums[i-1] != nums[i]): findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results) results = [] findNsum(sorted(nums), target, 4, [], results) return results java https://discuss.leetcode.com/topic/29585/7ms-java-code-win-over-100 26ms, 97.32% 7ms java code win over 100% The first time win over 100%. Basic idea is using subfunctions for 3sum and 2sum, and keeping throwing all impossible cases. O(n^3) time complexity, O(1) extra space complexity.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); int len = nums.length; if (nums == null || len &lt; 4) return res; Arrays.sort(nums); int max = nums[len - 1]; if (4 * nums[0] &gt; target || 4 * max &lt; target) return res; int i, z; for (i = 0; i &lt; len; i++) &#123; z = nums[i]; if (i &gt; 0 &amp;&amp; z == nums[i - 1])// avoid duplicate continue; if (z + 3 * max &lt; target) // z is too small continue; if (4 * z &gt; target) // z is too large break; if (4 * z == target) &#123; // z is the boundary if (i + 3 &lt; len &amp;&amp; nums[i + 3] == z) res.add(Arrays.asList(z, z, z, z)); break; &#125; threeSumForFourSum(nums, target - z, i + 1, len - 1, res, z); &#125; return res; &#125; /* * Find all possible distinguished three numbers adding up to the target * in sorted array nums[] between indices low and high. If there are, * add all of them into the ArrayList fourSumList, using * fourSumList.add(Arrays.asList(z1, the three numbers)) */ public void threeSumForFourSum(int[] nums, int target, int low, int high, ArrayList&lt;List&lt;Integer&gt;&gt; fourSumList, int z1) &#123; if (low + 1 &gt;= high) return; int max = nums[high]; if (3 * nums[low] &gt; target || 3 * max &lt; target) return; int i, z; for (i = low; i &lt; high - 1; i++) &#123; z = nums[i]; if (i &gt; low &amp;&amp; z == nums[i - 1]) // avoid duplicate continue; if (z + 2 * max &lt; target) // z is too small continue; if (3 * z &gt; target) // z is too large break; if (3 * z == target) &#123; // z is the boundary if (i + 1 &lt; high &amp;&amp; nums[i + 2] == z) fourSumList.add(Arrays.asList(z1, z, z, z)); break; &#125; twoSumForFourSum(nums, target - z, i + 1, high, fourSumList, z1, z); &#125; &#125; /* * Find all possible distinguished two numbers adding up to the target * in sorted array nums[] between indices low and high. If there are, * add all of them into the ArrayList fourSumList, using * fourSumList.add(Arrays.asList(z1, z2, the two numbers)) */ public void twoSumForFourSum(int[] nums, int target, int low, int high, ArrayList&lt;List&lt;Integer&gt;&gt; fourSumList, int z1, int z2) &#123; if (low &gt;= high) return; if (2 * nums[low] &gt; target || 2 * nums[high] &lt; target) return; int i = low, j = high, sum, x; while (i &lt; j) &#123; sum = nums[i] + nums[j]; if (sum == target) &#123; fourSumList.add(Arrays.asList(z1, z2, nums[i], nums[j])); x = nums[i]; while (++i &lt; j &amp;&amp; x == nums[i]) // avoid duplicate ; x = nums[j]; while (i &lt; --j &amp;&amp; x == nums[j]) // avoid duplicate ; &#125; if (sum &lt; target) i++; if (sum &gt; target) j--; &#125; return; &#125;&#125; https://discuss.leetcode.com/topic/12368/clean-accepted-java-o-n-3-solution-based-on-3sum Clean accepted java O(n^3) solution based on 3sum 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] num, int target) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if(num.length&lt;4)return ans; Arrays.sort(num); for(int i=0; i&lt;num.length-3; i++)&#123; if(i&gt;0&amp;&amp;num[i]==num[i-1])continue; for(int j=i+1; j&lt;num.length-2; j++)&#123; if(j&gt;i+1&amp;&amp;num[j]==num[j-1])continue; int low=j+1, high=num.length-1; while(low&lt;high)&#123; int sum=num[i]+num[j]+num[low]+num[high]; if(sum==target)&#123; ans.add(Arrays.asList(num[i], num[j], num[low], num[high])); while(low&lt;high&amp;&amp;num[low]==num[low+1])low++; while(low&lt;high&amp;&amp;num[high]==num[high-1])high--; low++; high--; &#125; else if(sum&lt;target)low++; else high--; &#125; &#125; &#125; return ans; &#125;&#125; https://discuss.leetcode.com/topic/12893/on-average-o-n-2-and-worst-case-o-n-3-java-solution-by-reducing-4sum-to-2sum On average O(n^2) and worst case O(n^3) java solution by reducing 4Sum to 2Sum Basic idea is to reduce the 4Sum problem to 2Sum one. In order to achieve that, we can use an array (size of n^2) to store the pair sums and this array will act as the array in 2Sum case (Here n is the size of the original 1D array and it turned out that we do not even need to explicitly use the n^2 sized array ). We also use a hashmap to mark if a pair sum has been visited or not (the same as in the 2Sum case). The tricky part here is that we may have multiple pairs that result in the same pair sum. So we will use a list to group these pairs together. For every pair with a particular sum, check if the pair sum that is needed to get the target has been visited. If so, further check if there is overlapping between these two pairs. If not, record the result. Time complexity to get all the pairs is O(n^2). For each pair, if the pair sum needed to get the target has been visited, the time complexity will be O(k), where k is the maximum size of the lists holding pairs with visited pair sum. Therefore the total time complexity will be O(k*n^2). Now we need to determine the range of k. Basically the more distinct pair sums we get, the smaller k will be. If all the pair sums are different from each other, k will just be 1. However, if we have many repeated elements in the original 1D array, or in some extreme cases such as the elements form an arithmetic progression, k can be of the order of n (strictly speaking, for the repeated elements case, k can go as high as n^2, but we can get rid of many of them). On average k will be some constant between 1 and n for normal elements distribution in the original 1D array. So on average our algorithm will go in O(n^2) but with worst case of O(n^3). Here is the complete code in java: 1234567891011121314151617181920212223242526272829303132333435363738394041public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] num, int target) &#123; Arrays.sort(num); Map&lt;Integer, List&lt;int[]&gt;&gt; twoSumMap = new HashMap&lt;&gt;(); // for holding visited pair sums. All pairs with the same pair sum are grouped together Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;(); // for holding the results for (int i = 0; i &lt; num.length; i++) &#123; // get rid of repeated pair sums if (i &gt; 1 &amp;&amp; num[i] == num[i - 2]) continue; for (int j = i + 1; j &lt; num.length; j++) &#123; // get rid of repeated pair sums if (j &gt; i + 2 &amp;&amp; num[j] == num[j - 2]) continue; // for each pair sum, check if the pair sum that is needed to get the target has been visited. if (twoSumMap.containsKey(target - (num[i] + num[j]))) &#123; // if so, get all the pairs that contribute to this visited pair sum. List&lt;int[]&gt; ls = twoSumMap.get(target - (num[i] + num[j])); for (int[] pair : ls) &#123; // we have two pairs: one is indicated as (pair[0], pair[1]), the other is (i, j). // we first need to check if they are overlapping with each other. int m1 = Math.min(pair[0], i); // m1 will always be the smallest index int m2 = Math.min(pair[1], j); // m2 will be one of the middle two indices int m3 = Math.max(pair[0], i); // m3 will be one of the middle two indices int m4 = Math.max(pair[1], j); // m4 will always be the largest index if (m1 == m3 || m1 == m4 || m2 == m3 || m2 == m4) continue; // two pairs are overlapping, so just ignore this case res.add(Arrays.asList(num[m1], num[Math.min(m2, m3)], num[Math.max(m2, m3)], num[m4])); // else record the result &#125; &#125; // mark that we have visited current pair and add it to the corrsponding pair sum group. // here we&apos;ve encoded the pair indices i and j into an integer array of length 2. twoSumMap.computeIfAbsent(num[i] + num[j], key -&gt; new ArrayList&lt;&gt;()).add(new int[] &#123;i, j&#125;); &#125; &#125; return new ArrayList&lt;List&lt;Integer&gt;&gt;(res);&#125; https://discuss.leetcode.com/topic/46339/my-solution-generalized-for-ksums-in-java My solution generalized for kSums in JAVA General Idea If you have already read and implement the 3sum and 4sum by using the sorting approach: reduce them into 2sum at the end, you might already got the feeling that, all ksum problem can be divided into two problems: 2sum Problem Reduce K sum problem to K – 1 sum Problem Therefore, the ideas is simple and straightforward. We could use recursive to solve this problem. Time complexity is O(N^(K-1)). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; int len = 0; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; len = nums.length; Arrays.sort(nums); return kSum(nums, target, 4, 0); &#125; private ArrayList&lt;List&lt;Integer&gt;&gt; kSum(int[] nums, int target, int k, int index) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(index &gt;= len) &#123; return res; &#125; if(k == 2) &#123; int i = index, j = len - 1; while(i &lt; j) &#123; //find a pair if(target - nums[i] == nums[j]) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); temp.add(nums[i]); temp.add(target-nums[i]); res.add(temp); //skip duplication while(i&lt;j &amp;&amp; nums[i]==nums[i+1]) i++; while(i&lt;j &amp;&amp; nums[j-1]==nums[j]) j--; i++; j--; //move left bound &#125; else if (target - nums[i] &gt; nums[j]) &#123; i++; //move right bound &#125; else &#123; j--; &#125; &#125; &#125; else&#123; for (int i = index; i &lt; len - k + 1; i++) &#123; //use current number to reduce ksum into k-1sum ArrayList&lt;List&lt;Integer&gt;&gt; temp = kSum(nums, target - nums[i], k-1, i+1); if(temp != null)&#123; //add previous results for (List&lt;Integer&gt; t : temp) &#123; t.add(0, nums[i]); &#125; res.addAll(temp); &#125; while (i &lt; len-1 &amp;&amp; nums[i] == nums[i+1]) &#123; //skip duplicated numbers i++; &#125; &#125; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/33433/java-a-little-bit-faster-than-other-common-methods-9ms-beats-95 Java a little bit faster than other common methods (9ms, beats 95%) To avoid duplicate list items, I skip unnecessary indices at two locations: one at the end of the outer loop (i-loop) the other at the end of the inner loop (j-loop). To avoid useless computations, the following is kind of critical: the function return immediately when nums[i]*4 &gt; target the inner loop break immediately when nums[j]*4 &lt; target. These two lines save quite some time due to the set up of the test cases in OJ. 12345678910111213141516171819202122232425262728public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(nums); int second = 0, third = 0, nexti = 0, nextj = 0; for(int i=0, L=nums.length; i&lt;L-3; i++) &#123; if(nums[i]&lt;&lt;2 &gt; target) return list; // return immediately for(int j=L-1; j&gt;i+2; j--) &#123; if(nums[j]&lt;&lt;2 &lt; target) break; // break immediately int rem = target-nums[i]-nums[j]; int lo = i+1, hi=j-1; while(lo&lt;hi) &#123; int sum = nums[lo] + nums[hi]; if(sum&gt;rem) --hi; else if(sum&lt;rem) ++lo; else &#123; list.add(Arrays.asList(nums[i],nums[lo],nums[hi],nums[j])); while(++lo&lt;=hi &amp;&amp; nums[lo-1]==nums[lo]) continue; // avoid duplicate results while(--hi&gt;=lo &amp;&amp; nums[hi]==nums[hi+1]) continue; // avoid duplicate results &#125; &#125; while(j&gt;=1 &amp;&amp; nums[j]==nums[j-1]) --j; // skip inner loop &#125; while(i&lt;L-1 &amp;&amp; nums[i]==nums[i+1]) ++i; // skip outer loop &#125; return list; &#125;&#125; https://discuss.leetcode.com/topic/9712/4sum-c-solution-with-explanation-and-comparison-with-3sum-problem-easy-to-understand For the reference, please have a look at my explanation of 3Sum problem because the algorithm are exactly the same. The link is as blow. My 3Sum problem answer The key idea is to downgrade the problem to a 2Sum problem eventually. And the same algorithm can be expand to NSum problem. After you had a look at my explanation of 3Sum, the code below will be extremely easy to understand. 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] num, int target) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if(num.length&lt;4)return ans; Arrays.sort(num); for(int i=0; i&lt;num.length-3; i++)&#123; if(i&gt;0&amp;&amp;num[i]==num[i-1])continue; for(int j=i+1; j&lt;num.length-2; j++)&#123; if(j&gt;i+1&amp;&amp;num[j]==num[j-1])continue; int low=j+1, high=num.length-1; while(low&lt;high)&#123; int sum=num[i]+num[j]+num[low]+num[high]; if(sum==target)&#123; ans.add(Arrays.asList(num[i], num[j], num[low], num[high])); while(low&lt;high&amp;&amp;num[low]==num[low+1])low++; while(low&lt;high&amp;&amp;num[high]==num[high-1])high--; low++; high--; &#125; else if(sum&lt;target)low++; else high--; &#125; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>two pointers</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[017. Letter Combinations of a Phone Number]]></title>
    <url>%2Fp%2F9a201804%2F</url>
    <content type="text"><![CDATA[34.7% https://leetcode.com/problems/letter-combinations-of-a-phone-number/ Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. 12Input:Digit string &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 方法一： 迭代的方法 My iterative sollution, very simple under 15 lines This is my solution, FYI 针对新来的一个数字，比如2=“abc”，从原有的res中的所有string都取出来，针对每一个都加一个a或b或c，再放入新的vector中，再把新的赋值给res。 12345678910111213141516171819class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.size()==0) return res; string charmap[10] = &#123;&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; res.push_back(&quot;&quot;); for (int i = 0; i &lt; digits.size(); i++) &#123; vector&lt;string&gt; tempres; string chars = charmap[digits[i] - &apos;0&apos;]; for (int c = 0; c &lt; chars.size();c++) for (int j = 0; j &lt; res.size();j++) tempres.push_back(res[j]+chars[c]); res = tempres; &#125; return res; &#125;&#125;; 我的代码实现: 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.empty()) return res; // string用双引号 单双引号要仔细考虑 unordered_map&lt;char, string&gt;map = &#123;&#123;'1', ""&#125;, &#123;'2', "abc"&#125;, &#123;'3', "def"&#125;, &#123;'4', "ghi"&#125;, &#123;'5', "jkl"&#125;, &#123;'6', "mno"&#125;, &#123;'7', "pqrs"&#125;, &#123;'8', "tuv"&#125;, &#123;'9', "wxyz"&#125;&#125;; string s = ""; dfs(digits, 0, s, res, map); return res; &#125; void dfs(string&amp; digits, int k, string&amp; s, vector&lt;string&gt;&amp; res, unordered_map&lt;char, string&gt;&amp; map)&#123; if(k==digits.size())&#123; res.push_back(s); return; &#125; for(auto c:map[digits[k]])&#123; // string 的push_back，pop_back方法 s.push_back(c); dfs(digits, k+1, s, res, map); s.pop_back(); &#125; &#125;&#125;; java https://discuss.leetcode.com/topic/8125/concise-o-n-2-java-solution Concise O(N^2) Java solution Hi guys! The idea is to sort an input array and then run through all indices of a possible first element of a triplet. For each possible first element we make a standard bi-directional 2Sum sweep of the remaining part of the array. Also we want to skip equal elements to avoid duplicates in the answer without making a set or smth like that. 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) &#123; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; num.length-2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; num[i] != num[i-1])) &#123; int lo = i+1, hi = num.length-1, sum = 0 - num[i]; while (lo &lt; hi) &#123; if (num[lo] + num[hi] == sum) &#123; res.add(Arrays.asList(num[i], num[lo], num[hi])); while (lo &lt; hi &amp;&amp; num[lo] == num[lo+1]) lo++; while (lo &lt; hi &amp;&amp; num[hi] == num[hi-1]) hi--; lo++; hi--; &#125; else if (num[lo] + num[hi] &lt; sum) lo++; else hi--; &#125; &#125; &#125; return res;&#125; Have a nice coding! https://discuss.leetcode.com/topic/28857/easiest-java-solution Easiest Java Solution Sort the array, iterate through the list, and use another two pointers to approach the target. 12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i + 2 &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; // skip same result continue; &#125; int j = i + 1, k = nums.length - 1; int target = -nums[i]; while (j &lt; k) &#123; if (nums[j] + nums[k] == target) &#123; res.add(Arrays.asList(nums[i], nums[j], nums[k])); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++; // skip same result while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--; // skip same result &#125; else if (nums[j] + nums[k] &gt; target) &#123; k--; &#125; else &#123; j++; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/45491/share-my-simple-java-solution Share my simple java solution 123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(nums.length &lt; 3) return result; Arrays.sort(nums); int i = 0; while(i &lt; nums.length - 2) &#123; if(nums[i] &gt; 0) break; int j = i + 1; int k = nums.length - 1; while(j &lt; k) &#123; int sum = nums[i] + nums[j] + nums[k]; if(sum == 0) result.add(Arrays.asList(nums[i], nums[j], nums[k])); if(sum &lt;= 0) while(nums[j] == nums[++j] &amp;&amp; j &lt; k); if(sum &gt;= 0) while(nums[k--] == nums[k] &amp;&amp; j &lt; k); &#125; while(nums[i] == nums[++i] &amp;&amp; i &lt; nums.length - 2); &#125; return result; &#125;&#125; https://discuss.leetcode.com/topic/26050/simple-o-n-2-two-pointers-java-solution Simple O(n^2) two pointers Java solution Runtime = O(n^2); Space = O(1) 12345678910111213141516171819202122232425262728public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] A) &#123; List&lt;List&lt;Integer&gt;&gt;res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (A == null || A.length == 0) return res; Arrays.sort(A); for (int i = 0; i &lt; A.length; i++) &#123; if (i - 1 &gt;= 0 &amp;&amp; A[i] == A[i - 1]) continue;// Skip equal elements to avoid duplicates int left = i + 1, right = A.length - 1; while (left &lt; right) &#123;// Two Pointers int sum = A[i] + A[left] + A[right]; if (sum == 0) &#123; res.add(Arrays.asList(A[i], A[left], A[right])); while (left + 1 &lt; right &amp;&amp; A[left] == A[left+1])// Skip equal elements to avoid duplicates left++; while (right -1 &gt; left &amp;&amp; A[right] == A[right-1])// Skip equal elements to avoid duplicates right--; left++; right--; &#125; else if (sum &lt; 0) &#123; left++; &#125; else &#123; right--; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/8465/my-java-solution-with-fifo-queue My java solution with FIFO queue1234567891011121314public List&lt;String&gt; letterCombinations(String digits) &#123; LinkedList&lt;String&gt; ans = new LinkedList&lt;String&gt;(); String[] mapping = new String[] &#123;&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; ans.add(&quot;&quot;); for(int i =0; i&lt;digits.length();i++)&#123; int x = Character.getNumericValue(digits.charAt(i)); while(ans.peek().length()==i)&#123; String t = ans.remove(); for(char s : mapping[x].toCharArray()) ans.add(t+s); &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/6380/my-recursive-solution-using-java My recursive solution using Java1234567891011121314151617181920public class Solution &#123; private static final String[] KEYS = &#123; &quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot; &#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; ret = new LinkedList&lt;String&gt;(); combination(&quot;&quot;, digits, 0, ret); return ret; &#125; private void combination(String prefix, String digits, int offset, List&lt;String&gt; ret) &#123; if (offset &gt;= digits.length()) &#123; ret.add(prefix); return; &#125; String letters = KEYS[(digits.charAt(offset) - &apos;0&apos;)]; for (int i = 0; i &lt; letters.length(); i++) &#123; combination(prefix + letters.charAt(i), digits, offset + 1, ret); &#125; &#125; &#125; cpp https://discuss.leetcode.com/topic/8107/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments Share my AC C++ solution, around 50ms, O(N*N), with explanation and comments the key idea is the same as the TwoSum problem. When we fix the 1st number, the 2nd and 3rd number can be found following the same reasoning as TwoSum. The only difference is that, the TwoSum problem of LEETCODE has a unique solution. However, in ThreeSum, we have multiple duplicate solutions that can be found. Most of the OLE errors happened here because you could’ve ended up with a solution with so many duplicates. The naive solution for the duplicates will be using the STL methods like below : 12std::sort(res.begin(), res.end());res.erase(unique(res.begin(), res.end()), res.end()); But according to my submissions, this way will cause you double your time consuming almostly. A better approach is that, to jump over the number which has been scanned, no matter it is part of some solution or not. If the three numbers formed a solution, we can safely ignore all the duplicates of them. We can do this to all the three numbers such that we can remove the duplicates. Here’s my AC C++ Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; res; std::sort(num.begin(), num.end()); for (int i = 0; i &lt; num.size(); i++) &#123; int target = -num[i]; int front = i + 1; int back = num.size() - 1; while (front &lt; back) &#123; int sum = num[front] + num[back]; // Finding answer which start from number num[i] if (sum &lt; target) front++; else if (sum &gt; target) back--; else &#123; vector&lt;int&gt; triplet(3, 0); triplet[0] = num[i]; triplet[1] = num[front]; triplet[2] = num[back]; res.push_back(triplet); // Processing duplicates of Number 2 // Rolling the front pointer to the next different number forwards while (front &lt; back &amp;&amp; num[front] == triplet[1]) front++; // Processing duplicates of Number 3 // Rolling the back pointer to the next different number backwards while (front &lt; back &amp;&amp; num[back] == triplet[2]) rear--; &#125; &#125; // Processing duplicates of Number 1 while (i + 1 &lt; num.size() &amp;&amp; num[i + 1] == num[i]) i++; &#125; return res; &#125; https://discuss.leetcode.com/topic/15291/20-lines-68ms-c-solution-used-two-pointers-similar-to-2sum ~20 lines. 68ms. c++ solution. Used two pointers similar to 2sum 1234567891011121314151617181920212223242526272829303132vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt;=2) return &#123;&#125;; vector&lt;vector&lt;int&gt; &gt; rtn; sort(nums.begin(), nums.end()); for(int i =0; i &lt; nums.size();)&#123; int start = i+1, end = nums.size()-1; while(start &lt; end)&#123; if(nums[i]+nums[start]+nums[end] == 0)&#123; rtn.push_back(&#123;nums[i],nums[start],nums[end]&#125;); start++; end--; while((start &lt; end) &amp;&amp; nums[start] == nums[start-1]) start++; while((start &lt; end) &amp;&amp; nums[end] == nums[end+1]) end--; &#125;else if(nums[i]+nums[start]+nums[end]&lt;0)&#123; start++; while((start &lt; end) &amp;&amp; nums[start] == nums[start-1]) start++; &#125;else&#123; end--; while((start &lt; end) &amp;&amp; nums[end] == nums[end+1]) end--; &#125; &#125; i++; while((i &lt; nums.size()) &amp;&amp; nums[i] == nums[i-1]) i++; &#125; return rtn;&#125; Thanks to my friend Yang Li inspired me of using two pointers https://discuss.leetcode.com/topic/15291/20-lines-68ms-c-solution-used-two-pointers-similar-to-2sum/2 Excellent way to avoid duplicate triples! (I had previously collected them in a set and moved them to a vector in the end). Here’s my take on it (got it to run in 52 ms): 12345678910111213141516vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; triples; sort(nums.begin(), nums.end()); int i = 0, last = nums.size() - 1; while (i &lt; last) &#123; int a = nums[i], j = i+1, k = last; while (j &lt; k) &#123; int b = nums[j], c = nums[k], sum = a+b+c; if (sum == 0) triples.push_back(&#123;a, b, c&#125;); if (sum &lt;= 0) while (nums[j] == b &amp;&amp; j &lt; k) j++; if (sum &gt;= 0) while (nums[k] == c &amp;&amp; j &lt; k) k--; &#125; while (nums[i] == a &amp;&amp; i &lt; last) i++; &#125; return triples;&#125; https://discuss.leetcode.com/topic/3396/my-iterative-sollution-very-simple-under-15-lines My iterative sollution, very simple under 15 lines This is my solution, FYI 针对新来的一个数字，比如2=“abc”，从原有的res中的所有string都取出来，针对每一个都加一个a或b或c，再放入res。 12345678910111213141516171819class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.size()==0) return res; string charmap[10] = &#123;&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; res.push_back(&quot;&quot;); for (int i = 0; i &lt; digits.size(); i++) &#123; vector&lt;string&gt; tempres; string chars = charmap[digits[i] - &apos;0&apos;]; for (int c = 0; c &lt; chars.size();c++) for (int j = 0; j &lt; res.size();j++) tempres.push_back(res[j]+chars[c]); res = tempres; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/13160/8-line-backtracking-function-c-solution 8-line Backtracking-Function C++ Solution Most concise backtracking function, no? 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.size()==0) return res; string local; vector&lt;vector&lt;char&gt;&gt; table(2,vector&lt;char&gt;()); table.push_back(vector&lt;char&gt;&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;); // index 2 table.push_back(vector&lt;char&gt;&#123;&apos;d&apos;,&apos;e&apos;,&apos;f&apos;&#125;); // 3 table.push_back(vector&lt;char&gt;&#123;&apos;g&apos;,&apos;h&apos;,&apos;i&apos;&#125;); table.push_back(vector&lt;char&gt;&#123;&apos;j&apos;,&apos;k&apos;,&apos;l&apos;&#125;); // 5 table.push_back(vector&lt;char&gt;&#123;&apos;m&apos;,&apos;n&apos;,&apos;o&apos;&#125;); table.push_back(vector&lt;char&gt;&#123;&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;&#125;); // 7 table.push_back(vector&lt;char&gt;&#123;&apos;t&apos;,&apos;u&apos;,&apos;v&apos;&#125;); table.push_back(vector&lt;char&gt;&#123;&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;&#125;); // 9 backtracking(table,res,local,0,digits); return res; &#125; void backtracking(const vector&lt;vector&lt;char&gt;&gt;&amp; table, vector&lt;string&gt;&amp; res, string&amp; local, int index, const string&amp; digits) &#123; if(index==digits.size()) res.push_back(local); else for(int i=0;i&lt;table[digits[index]-&apos;0&apos;].size();i++) &#123; local.push_back(table[digits[index]-&apos;0&apos;][i]); backtracking(table, res, local, index+1, digits); local.pop_back(); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/22619/python-easy-to-understand-solution-o-n-n-time Python easy to understand solution (O(n*n) time). 123456789101112131415161718192021def threeSum(self, nums): res = [] nums.sort() for i in xrange(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue l, r = i+1, len(nums)-1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s &lt; 0: l +=1 elif s &gt; 0: r -= 1 else: res.append((nums[i], nums[l], nums[r])) while l &lt; r and nums[l] == nums[l+1]: l += 1 while l &lt; r and nums[r] == nums[r-1]: r -= 1 l += 1; r -= 1 return res https://discuss.leetcode.com/topic/13703/straight-forward-python-ac-o-n-2-solution-with-decent-explanation Straight forward Python AC O(n^2) solution with decent explanation 1234567891011121314151617181920212223242526272829class Solution: # @param &#123;integer[]&#125; nums # @return &#123;integer[][]&#125; def threeSum(self, nums): if len(nums) &lt;3: # deal with special input return [] elif len(nums) == 3: if sum(nums) == 0: return [sorted(nums)] nums = sorted(nums) # sorted, O(nlgn) ans = [] for i in range(len(nums) -2): j = i+1 k = len(nums) -1 # hence i &lt; j &lt; k while j&lt;k: # if not cross line temp_sum = nums[i] + nums[j] + nums[k] if temp_sum == 0: ans.append((nums[i], nums[j], nums[k])) if temp_sum &gt; 0: # which means we need smaller sum, move k backward, remember we sort the array k -= 1 else: j += 1 return list(set(tuple(ans))) # I bet this is not the best way to eliminate duplicate solutions https://discuss.leetcode.com/topic/11783/one-line-python-solution 48ms, 58.58%, September 1, 2016 123456789101112131415161718class Solution(object): def letterCombinations(self, digits): &quot;&quot;&quot; :type digits: str :rtype: List[str] &quot;&quot;&quot; if digits == &apos;&apos;: return [] kvmaps = &#123; &apos;2&apos;:&apos;abc&apos;, &apos;3&apos;:&apos;def&apos;, &apos;4&apos;:&apos;ghi&apos;, &apos;5&apos;:&apos;jkl&apos;, &apos;6&apos;:&apos;mno&apos;, &apos;7&apos;:&apos;pqrs&apos;, &apos;8&apos;:&apos;tuv&apos;, &apos;9&apos;:&apos;wxyz&apos; &#125; return reduce(lambda acc, digit:[x+y for x in acc for y in kvmaps[digit]], digits, [&apos;&apos;])]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[016. 3Sum Closest]]></title>
    <url>%2Fp%2F473b519e%2F</url>
    <content type="text"><![CDATA[30.7% https://leetcode.com/problems/3sum-closest/ Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. 123For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 方法一： 先sort，然后一个指针，从头遍历，另外两个指针。 https://discuss.leetcode.com/topic/17215/c-solution-o-n-2-using-sort C++ solution O(n^2) using sort Sort the vector and then no need to run O(N^3) algorithm as each index has a direction to move. 1234567The code starts from this formation.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678if nums[first] + nums[second] + nums[third] is smaller than the target, we know we have to increase the sum. so only choice is moving the second index forward.----------------------------------------------------^ ^ ^| | || +- second third+-first 123456789if the sum is bigger than the target, we know that we need to reduce the sum. so only choice is moving &apos;third&apos; to backward. of course if the sum equals to target, we can immediately return the sum.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678when second and third cross, the round is done so start next round by moving &apos;first&apos; and resetting second and third.---------------------------------------------------- ^ ^ ^ | | | | +- second third +-first 123456789while doing this, collect the closest sum of each stage by calculating and comparing delta. Compare abs(target-newSum) and abs(target-closest). At the end of the process the three indexes will eventually be gathered at the end of the array.---------------------------------------------------- ^ ^ ^ | | `- third | +- second +-first if no exactly matching sum has been found so far, the value in closest will be the answer. 1234567891011121314151617181920212223int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size() &lt; 3) return 0; int closest = nums[0]+nums[1]+nums[2]; sort(nums.begin(), nums.end()); for(int first = 0 ; first &lt; nums.size()-2 ; ++first) &#123; if(first &gt; 0 &amp;&amp; nums[first] == nums[first-1]) continue; int second = first+1; int third = nums.size()-1; while(second &lt; third) &#123; int curSum = nums[first]+nums[second]+nums[third]; if(curSum == target) return curSum; if(abs(target-curSum)&lt;abs(target-closest)) &#123; closest = curSum; &#125; if(curSum &gt; target) &#123; --third; &#125; else &#123; ++second; &#125; &#125; &#125; return closest;&#125; https://discuss.leetcode.com/topic/36978/12-lines-concise-and-easy-understand-c-solultion 12 lines concise and easy understand c++ solultion 1234567891011121314151617class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; nums.size() - 2; i++)&#123; int j = i + 1, k = nums.size() - 1; while(j &lt; k)&#123; int num = nums[i] + nums[j] + nums[k]; if(abs(num - target) &lt; abs(res - target)) res = num; if(num &lt; target) j++; else k--; &#125; &#125; return res; &#125;&#125;; 我的代码实现: 123456789101112131415161718192021222324class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; // res 初始化为INT_MAX可能会导致各种意外，因为res要进行加减 // 容易超范围，最好的办法是任意初始化 int res = nums[0]+nums[1]+nums[2]; int n = nums.size(); sort(nums.begin(), nums.end()); for(int first=0; first&lt;n-2; first++)&#123; int second = first+1, third = n-1; while(second&lt;third)&#123; int cur = nums[first]+nums[second]+nums[third]; // 学习使用abs函数，用于求绝对值 if(abs(cur-target)&lt;abs(res-target)) res = cur; if(cur&lt;target) second++; else third--; &#125; &#125; return res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/1978/a-n-2-solution-can-we-do-better Here is a solution in Order(N^2). I got help from this post onstackoverflow Can we improve this time complexity ? Edit:Thanks @thr for pointing out that. I have corrected it and also renamed ‘mx’ by ‘ans’. 12345678910111213141516171819202122232425262728293031323334353637383940int threeSumClosest(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;int&gt; v(num.begin(), num.end()); // I didn&apos;t wanted to disturb original array. int n = 0; int ans = 0; int sum; sort(v.begin(), v.end()); // If less then 3 elements then return their sum while (v.size() &lt;= 3) &#123; return accumulate(v.begin(), v.end(), 0); &#125; n = v.size(); /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1] * v[i] &lt;= v[j] &lt;= v[k] always, because we sorted our array. * Now, for each number, v[i] : we look for pairs v[j] &amp; v[k] such that * absolute value of (target - (v[i] + v[j] + v[k]) is minimised. * if the sum of the triplet is greater then the target it implies * we need to reduce our sum, so we do K = K - 1, that is we reduce * our sum by taking a smaller number. * Simillarly if sum of the triplet is less then the target then we * increase out sum by taking a larger number, i.e. J = J + 1. */ ans = v[0] + v[1] + v[2]; for (int i = 0; i &lt; n-2; i++) &#123; int j = i + 1; int k = n - 1; while (j &lt; k) &#123; sum = v[i] + v[j] + v[k]; if (abs(target - ans) &gt; abs(target - sum)) &#123; ans = sum; if (ans == target) return ans; &#125; (sum &gt; target) ? k-- : j++; &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/17215/c-solution-o-n-2-using-sort C++ solution O(n^2) using sort Sort the vector and then no need to run O(N^3) algorithm as each index has a direction to move. 1234567The code starts from this formation.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678if nums[first] + nums[second] + nums[third] is smaller than the target, we know we have to increase the sum. so only choice is moving the second index forward.----------------------------------------------------^ ^ ^| | || +- second third+-first 123456789if the sum is bigger than the target, we know that we need to reduce the sum. so only choice is moving &apos;third&apos; to backward. of course if the sum equals to target, we can immediately return the sum.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678when second and third cross, the round is done so start next round by moving &apos;first&apos; and resetting second and third.---------------------------------------------------- ^ ^ ^ | | | | +- second third +-first 123456789while doing this, collect the closest sum of each stage by calculating and comparing delta. Compare abs(target-newSum) and abs(target-closest). At the end of the process the three indexes will eventually be gathered at the end of the array.---------------------------------------------------- ^ ^ ^ | | `- third | +- second +-first if no exactly matching sum has been found so far, the value in closest will be the answer. 1234567891011121314151617181920212223int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size() &lt; 3) return 0; int closest = nums[0]+nums[1]+nums[2]; sort(nums.begin(), nums.end()); for(int first = 0 ; first &lt; nums.size()-2 ; ++first) &#123; if(first &gt; 0 &amp;&amp; nums[first] == nums[first-1]) continue; int second = first+1; int third = nums.size()-1; while(second &lt; third) &#123; int curSum = nums[first]+nums[second]+nums[third]; if(curSum == target) return curSum; if(abs(target-curSum)&lt;abs(target-closest)) &#123; closest = curSum; &#125; if(curSum &gt; target) &#123; --third; &#125; else &#123; ++second; &#125; &#125; &#125; return closest;&#125; https://discuss.leetcode.com/topic/36978/12-lines-concise-and-easy-understand-c-solultion 12 lines concise and easy understand c++ solultion 1234567891011121314151617class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; nums.size() - 2; i++)&#123; int j = i + 1, k = nums.size() - 1; while(j &lt; k)&#123; int num = nums[i] + nums[j] + nums[k]; if(abs(num - target) &lt; abs(res - target)) res = num; if(num &lt; target) j++; else k--; &#125; &#125; return res; &#125;&#125;; 12ms, 51.55%, Apr.23rd, 2016 https://github.com/haoel/leetcode/blob/master/algorithms/cpp/3SumClosest/3SumClosest.cpp 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int n = nums.size(); int distance = 2147483647; int result; for(int i=0; i&lt;n-2; i++)&#123; if(i&gt;0 &amp;&amp; nums[i-1]==nums[i]) continue; int a = nums[i]; int low = i+1; int high = n-1; while(low &lt; high)&#123; int b = nums[low]; int c = nums[high]; int sum = a + b + c; if(sum - target == 0) return target; else&#123; if(abs(sum - target) &lt; distance)&#123; distance = abs(sum - target); result = sum; &#125; if (sum - target &gt; 0)&#123; while(high &gt; 0 &amp;&amp; nums[high] == nums[high-1]) high--; high--; &#125;else&#123; while(low &lt; n-1 &amp;&amp; nums[low] == nums[low+1]) low++; low++; &#125; &#125; &#125; &#125; return result; &#125;&#125;; 28ms, 16.01%, Apr.23rd, 2016 https://leetcode.com/discuss/85999/12-lines-concise-and-easy-understand-c-solultion 1234567891011121314151617class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; nums.size(); i++)&#123; int j = i + 1, k = nums.size() - 1; while(j &lt; k)&#123; int num = nums[i] + nums[j] + nums[k]; if(abs(num - target) &lt; abs(res - target)) res = num; if(num &lt; target) j++; else k--; &#125; &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/9815/python-o-n-2-solution Python O(N^2) solution 123456789101112131415161718192021class Solution: # @return an integer def threeSumClosest(self, num, target): num.sort() result = num[0] + num[1] + num[2] for i in range(len(num) - 2): j, k = i+1, len(num) - 1 while j &lt; k: sum = num[i] + num[j] + num[k] if sum == target: return sum if abs(sum - target) &lt; abs(result - target): result = sum if sum &lt; target: j += 1 elif sum &gt; target: k -= 1 return result https://discuss.leetcode.com/topic/20359/python-solution-two-pointer Python solution (two-pointer). 12345678910111213141516def threeSumClosest(self, nums, target): nums.sort() res = sum(nums[:3]) for i in xrange(len(nums)): l, r = i+1, len(nums)-1 while l &lt; r: s = sum((nums[i], nums[l], nums[r])) if abs(s-target) &lt; abs(res-target): res = s if s &lt; target: l += 1 elif s &gt; target: r -= 1 else: # break early return res return res 508ms, 2.61%, Apr.23rd, 2016 http://c4fun.cn/blog/2014/03/20/leetcode-solution-02/ 求集合中3个数能够得到的距离target最近的和 和3Sum一样，而且不用处理重复解问题了。 1234567891011121314151617181920class Solution(object): def threeSumClosest(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; nums.sort() ans = None for i in range(len(nums)): l, r = i + 1, len(nums) - 1 while l &lt; r: sum = nums[l] + nums[r] + nums[i] if ans is None or abs(sum - target) &lt; abs(ans - target): ans = sum if sum &lt;= target: l = l + 1 else: r = r - 1 return ans java https://discuss.leetcode.com/topic/5192/java-solution-with-o-n2-for-reference Java solution with O(n2) for reference Similar to 3 Sum problem, use 3 pointers to point current element, next element and the last element. If the sum is less than target, it means we have to add a larger element so next element move to the next. If the sum is greater, it means we have to add a smaller element so last element move to the second last element. Keep doing this until the end. Each time compare the difference between sum and target, if it is less than minimum difference so far, then replace result with it, otherwise keep iterating. 123456789101112131415161718192021public class Solution &#123; public int threeSumClosest(int[] num, int target) &#123; int result = num[0] + num[1] + num[num.length - 1]; Arrays.sort(num); for (int i = 0; i &lt; num.length - 2; i++) &#123; int start = i + 1, end = num.length - 1; while (start &lt; end) &#123; int sum = num[i] + num[start] + num[end]; if (sum &gt; target) &#123; end--; &#125; else &#123; start++; &#125; if (Math.abs(sum - target) &lt; Math.abs(result - target)) &#123; result = sum; &#125; &#125; &#125; return result; &#125;&#125; https://discuss.leetcode.com/topic/31117/7ms-and-o-n-2-java-solution 7ms and o(n^2) java solution My solution does not need compare each sum ,just need to compare possible sum ,so can save time. 123456789101112131415161718192021222324public class Solution &#123;public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int closest=nums[0]+nums[1]+nums[2]; int low,high; for(int i=0;i&lt;nums.length-1;i++)&#123; low=i+1; high=nums.length-1; while(low&lt;high)&#123; if(nums[low]+nums[high]==target-nums[i]) return target; else if(nums[low]+nums[high]&gt;target-nums[i])&#123; while(low&lt;high&amp;&amp;nums[low]+nums[high]&gt;target-nums[i]) high--; if(Math.abs(nums[i]+nums[low]+nums[high+1]-target)&lt;Math.abs(closest-target)) closest=nums[i]+nums[low]+nums[high+1]; &#125; else&#123; while(low&lt;high&amp;&amp;nums[low]+nums[high]&lt;target-nums[i]) low++; if(Math.abs(nums[i]+nums[low-1]+nums[high]-target)&lt;Math.abs(closest-target)) closest=nums[i]+nums[low-1]+nums[high]; &#125; &#125; &#125; return closest;&#125; https://discuss.leetcode.com/topic/35892/share-my-24-line-java-code-beats-94-57-run-times Share my 24-line Java code (beats 94.57% run times) 1234567891011121314151617181920212223242526public class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int diff = Integer.MAX_VALUE, closest = 0; for (int k=0; k&lt;nums.length-2; ++k) &#123; for (int i=k+1, j=nums.length-1; i&lt;j; ) &#123; int sum = nums[k] + nums[i] + nums[j]; if (sum == target) &#123; return target; &#125; else if (sum &gt; target) &#123; if (sum-target &lt; diff) &#123; diff = sum-target; closest = sum; &#125; --j; &#125; else &#123; if (target-sum &lt; diff) &#123; diff = target-sum; closest = sum; &#125; ++i; &#125; &#125; &#125; return closest; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[015. 3Sum]]></title>
    <url>%2Fp%2F6a4c11d8%2F</url>
    <content type="text"><![CDATA[21.2% https://leetcode.com/problems/3sum/ Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 1234567For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [[-1, 0, 1],[-1, -1, 2] ] 方法一： 先排序，然后以i进行遍历，然后放j和k两个指针遍历。 重点是考虑重复的情况，所以有两处考虑了重复的问题。 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); int n = nums.size(); for(int i=0; i&lt;n-2; i++)&#123; if(i!=0 &amp;&amp; nums[i]==nums[i-1]) continue; int target = 0 - nums[i]; int j=i+1, k=n-1; while(j&lt;k)&#123; if(nums[j]+nums[k]==target)&#123; vector&lt;int&gt; tmp&#123;nums[i], nums[j], nums[k]&#125;; res.push_back(tmp); while(j&lt;k &amp;&amp; nums[j]==tmp[1]) j++; while(j&lt;k &amp;&amp; nums[k]==tmp[2]) k--; &#125;else if(nums[j]+nums[k]&gt;target)&#123; k--; &#125;else j++; &#125; &#125; return res; &#125;&#125;; 我的代码实现一： 注意其中的重点，一个是要考虑重复，一个是要考虑跳出循环 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); if(n&lt;3) return res; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-2; i++)&#123; if(i!=0 &amp;&amp; nums[i]==nums[i-1]) // 考虑重复情况 continue; int left = i+1, right = n-1; while(left&lt;right)&#123; int sum = nums[i]+nums[left]+nums[right]; if(sum==0)&#123; vector&lt;int&gt; tmp = &#123;nums[i], nums[left], nums[right]&#125;; res.push_back(tmp); while(left+1&lt;right &amp;&amp; nums[left+1]==nums[left]) left++; // 此处要跳出循环，继续寻找 while(left&lt;right-1 &amp;&amp; nums[right-1]==nums[right]) right--; left++, right--; &#125;else if(sum&lt;0) left++; else right--; &#125; &#125; return res; &#125;&#125;; 我的代码实现二: 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); if(n&lt;3) return res; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-2; i++)&#123; // 考虑重复的情况 if(i!=0 &amp;&amp; nums[i]==nums[i-1]) continue; int target = - nums[i]; int left = i+1, right = n-1; while(left&lt;right)&#123; int sum = nums[left] + nums[right]; if(sum==target)&#123; res.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;); while(left&lt;right &amp;&amp; nums[left+1]==nums[left]) left++; while(left&lt;right &amp;&amp; nums[right-1]==nums[right]) right--; left++; right--; &#125; else if(sum&lt;target) left++; else right--; &#125; &#125; return res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/8107/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments the key idea is the same as the TwoSum problem. When we fix the 1st number, the 2nd and 3rd number can be found following the same reasoning as TwoSum. The only difference is that, the TwoSum problem of LEETCODE has a unique solution. However, in ThreeSum, we have multiple duplicate solutions that can be found. Most of the OLE errors happened here because you could’ve ended up with a solution with so many duplicates. The naive solution for the duplicates will be using the STL methods like below : 12std::sort(res.begin(), res.end());res.erase(unique(res.begin(), res.end()), res.end()); But according to my submissions, this way will cause you double your time consuming almostly. A better approach is that, to jump over the number which has been scanned, no matter it is part of some solution or not. If the three numbers formed a solution, we can safely ignore all the duplicates of them. We can do this to all the three numbers such that we can remove the duplicates. Here’s my AC C++ Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; res; std::sort(num.begin(), num.end()); for (int i = 0; i &lt; num.size(); i++) &#123; int target = -num[i]; int front = i + 1; int back = num.size() - 1; while (front &lt; back) &#123; int sum = num[front] + num[back]; // Finding answer which start from number num[i] if (sum &lt; target) front++; else if (sum &gt; target) back--; else &#123; vector&lt;int&gt; triplet(3, 0); triplet[0] = num[i]; triplet[1] = num[front]; triplet[2] = num[back]; res.push_back(triplet); // Processing duplicates of Number 2 // Rolling the front pointer to the next different number forwards while (front &lt; back &amp;&amp; num[front] == triplet[1]) front++; // Processing duplicates of Number 3 // Rolling the back pointer to the next different number backwards while (front &lt; back &amp;&amp; num[back] == triplet[2]) rear--; &#125; &#125; // Processing duplicates of Number 1 while (i + 1 &lt; num.size() &amp;&amp; num[i + 1] == num[i]) i++; &#125; return res; &#125; 64ms, 23.81%, Apr.23rd, 2016 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt; vector&lt;int&gt; &gt; result; // 先排序 sort(nums.begin(), nums.end()); int n = nums.size(); for(int i=0; i&lt;n-2; i++)&#123; // 跳过重复项 if(i&gt;0 &amp;&amp; nums[i-1]==nums[i]) continue; int a = nums[i]; int low = i + 1; int high = n - 1; while(low &lt; high)&#123; int b = nums[low]; int c = nums[high]; if(a + b + c == 0)&#123; vector&lt;int&gt; v; v.push_back(a); v.push_back(b); v.push_back(c); result.push_back(v); // 继续寻找答案,忽略重复项，high，low各加1 while(low &lt; n-1 &amp;&amp; nums[low] == nums[low+1]) low++; while(high &gt; 0 &amp;&amp; nums[high] == nums[high-1]) high--; low++; high--; &#125;else if(a+b+c &gt; 0)&#123; while(high &gt; 0 &amp;&amp; nums[high] == nums[high-1]) high--; high--; &#125;else&#123; while(low &gt; 0 &amp;&amp; nums[low] == nums[low+1]) low++; low++; &#125; &#125; &#125; return result; &#125;&#125;; python 224ms, 44.36%, Apr.23rd, 2016 求3个数的和为target的所有解。 枚举第一个数，然后第二个数为这个数的后一个数，第三个数为最后一个数，如果和小于0，第二个数后移， 如大于0第三个数前移，等于0的话记录结果并且都向中间移。注意处理重复解。 123456789101112131415161718192021class Solution: # @return a list of lists of length 3, [[val1,val2,val3]] def threeSum(self, num): num.sort() ans = [] for i in range(len(num)): if (i &gt; 0 and num[i] == num[i-1]): continue l, r = i + 1, len(num) - 1 while l &lt; r: sum = num[l] + num[r] + num[i] if sum == 0: ans.append([num[i], num[l], num[r]]) while l &lt; r and num[l] == num[l + 1]: l = l + 1 while l &lt; r and num[r] == num[r - 1]: r = r - 1 l, r = l + 1, r - 1 elif sum &lt; 0: l = l + 1 else: r = r - 1 return ans java https://discuss.leetcode.com/topic/8125/concise-o-n-2-java-solution Concise O(N^2) Java solution Hi guys! The idea is to sort an input array and then run through all indices of a possible first element of a triplet. For each possible first element we make a standard bi-directional 2Sum sweep of the remaining part of the array. Also we want to skip equal elements to avoid duplicates in the answer without making a set or smth like that. Have a nice coding! 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) &#123; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; num.length-2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; num[i] != num[i-1])) &#123; int lo = i+1, hi = num.length-1, sum = 0 - num[i]; while (lo &lt; hi) &#123; if (num[lo] + num[hi] == sum) &#123; res.add(Arrays.asList(num[i], num[lo], num[hi])); while (lo &lt; hi &amp;&amp; num[lo] == num[lo+1]) lo++; while (lo &lt; hi &amp;&amp; num[hi] == num[hi-1]) hi--; lo++; hi--; &#125; else if (num[lo] + num[hi] &lt; sum) lo++; else hi--; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/28857/easiest-java-solution Easiest Java Solution Sort the array, iterate through the list, and use another two pointers to approach the target. 12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i + 2 &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; // skip same result continue; &#125; int j = i + 1, k = nums.length - 1; int target = -nums[i]; while (j &lt; k) &#123; if (nums[j] + nums[k] == target) &#123; res.add(Arrays.asList(nums[i], nums[j], nums[k])); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++; // skip same result while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--; // skip same result &#125; else if (nums[j] + nums[k] &gt; target) &#123; k--; &#125; else &#123; j++; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/45491/share-my-simple-java-solution Share my simple java solution 123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(nums.length &lt; 3) return result; Arrays.sort(nums); int i = 0; while(i &lt; nums.length - 2) &#123; if(nums[i] &gt; 0) break; int j = i + 1; int k = nums.length - 1; while(j &lt; k) &#123; int sum = nums[i] + nums[j] + nums[k]; if(sum == 0) result.add(Arrays.asList(nums[i], nums[j], nums[k])); if(sum &lt;= 0) while(nums[j] == nums[++j] &amp;&amp; j &lt; k); if(sum &gt;= 0) while(nums[k--] == nums[k] &amp;&amp; j &lt; k); &#125; while(nums[i] == nums[++i] &amp;&amp; i &lt; nums.length - 2); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[014. Longest Common Prefix]]></title>
    <url>%2Fp%2F58ae5420%2F</url>
    <content type="text"><![CDATA[31.5% https://leetcode.com/problems/longest-common-prefix/ Write a function to find the longest common prefix string amongst an array of strings. 方法一： First one: check from strs[0][0] to strs[i][0]. If matches, check strs[0][1] to strs[i][1]. Code: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=&quot;&quot;; int max=INT_MAX; for(auto&amp; s:strs) &#123; max=(max&gt;s.length())?s.length():max; &#125; for(int i=0;i&lt;max;i++) &#123; bool flag=true; char x=strs[0][i]; for(auto&amp; s:strs) &#123; if(s[i]!=x) &#123; flag=false; break; &#125; &#125; if(flag==false) return ans; ans+=x; &#125; return ans; &#125;&#125;; 代码的另一种写法： 12345678910111213class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string prefix = &quot;&quot;; for(int idx=0; strs.size()&gt;0;idx++)&#123; for(int i=0; i&lt;strs.size(); i++) if(idx&gt;=strs[i].size() || (i&gt;0&amp;&amp;strs[i][idx] != strs[i-1][idx])) return prefix; prefix+=strs[0][idx]; &#125; return prefix; &#125;&#125;; 我的代码实现： 12345678910111213141516171819class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string res = ""; int n = strs.size(); // 一定考虑是否有异常情况的可能性 if(n==0) return res; int i = 0; while(true)&#123; for(int j=0; j&lt;n; j++)&#123; if(i&gt;=strs[j].size() || j&gt;0 &amp;&amp; strs[j][i]!=strs[j-1][i])&#123; return res; &#125; &#125; res += strs[0][i]; i++; &#125; &#125;&#125;; 方法二： Second one: assume the prefix is strs[0]. Compair with strs[i], and cut the letters which don’t match. Code: 1234567891011121314151617181920212223class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=strs[0]; int max=INT_MAX; for(auto&amp; s:strs) &#123; if(s.length()==0) return &quot;&quot;; int i=0; for(i=0;i&lt;ans.length()&amp;&amp;i&lt;s.length();i++) &#123; if(s[i]!=ans[i]) break; &#125; ans=ans.substr(0,i); &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/13121/what-does-longest-common-prefix-mean What does Longest Common Prefix mean ? The problem statement is confusing and unclear. Can someone throw light on this ? Is it to find prefix between each pair of strings and return the one which is longest. Or all the strings has to have a common prefix? https://discuss.leetcode.com/topic/13121/what-does-longest-common-prefix-mean/2 It seems that it is not to check between pair of strings but on all the strings in the array. For example: {“a”,”a”,”b”} should give “” as there is nothing common in all the 3 strings. {“a”, “a”} should give “a” as a is longest common prefix in all the strings. {“abca”, “abc”} as abc {“ac”, “ac”, “a”, “a”} as a. Logic goes something like this: Pick a character at i=0th location and compare it with the character at that location in every string. If anyone doesn’t have that just return “” Else append that character in to the result. Increment i and do steps 1-3 till the length of that string. return result. Make sure proper checks are maintained to avoid index out of bounds error. cpp https://discuss.leetcode.com/topic/20991/accepted-c-6-lines-4ms Accepted c++ 6 lines 4ms 6ms, September 19, 2016 1234567891011class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string prefix = &quot;&quot;; for(int idx=0; strs.size()&gt;0;prefix+=strs[0][idx], idx++) for(int i=0; i&lt;strs.size(); i++) if(idx&gt;=strs[i].size() || (i&gt;0&amp;&amp;strs[i][idx] != strs[i-1][idx])) return prefix; return prefix; &#125;&#125;; https://discuss.leetcode.com/topic/16623/3-diffrent-c-solutions-each-one-costs-8ms 3 diffrent C++ solutions, each one costs 8ms. First one: check from strs[0][0] to strs[i][0]. If matches, check strs[0][1] to strs[i][1]. Code: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=&quot;&quot;; int max=INT_MAX; for(auto&amp; s:strs) &#123; max=(max&gt;s.length())?s.length():max; &#125; for(int i=0;i&lt;max;i++) &#123; bool flag=true; char x=strs[0][i]; for(auto&amp; s:strs) &#123; if(s[i]!=x) &#123; flag=false; break; &#125; &#125; if(flag==false) return ans; ans+=x; &#125; return ans; &#125;&#125;; Second one: assume the prefix is strs[0]. Compair with strs[i], and cut the letters which don’t match. Code: 1234567891011121314151617181920212223class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=strs[0]; int max=INT_MAX; for(auto&amp; s:strs) &#123; if(s.length()==0) return &quot;&quot;; int i=0; for(i=0;i&lt;ans.length()&amp;&amp;i&lt;s.length();i++) &#123; if(s[i]!=ans[i]) break; &#125; ans=ans.substr(0,i); &#125; return ans; &#125;&#125;; Third one: use a Trie data structure to save the strs. Search the trie, and stops when a TrieNode has more than one son. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879Code:class TrieNode&#123;public: bool val; TrieNode* next[52]; int sons; TrieNode() :val(false), sons(0) &#123; for (int i = 0; i &lt; 52; i++) next[i] = nullptr; &#125;&#125;;class Trie&#123;private: TrieNode* putst(string&amp; s, TrieNode * node, int loc, TrieNode *father) &#123; if (s.length() == 0) &#123; node-&gt;val = true; node-&gt;sons++; return node; &#125; if (node == nullptr) &#123; node = new TrieNode(); if (father != nullptr) father-&gt;sons++; &#125; if (loc == s.length()) &#123; node-&gt;val = true; return node; &#125; if (s[loc] &gt;= &apos;a&apos;) node-&gt;next[s[loc] - &apos;a&apos;] = putst(s, node-&gt;next[s[loc] - &apos;a&apos;], loc + 1, node); else node-&gt;next[s[loc] - &apos;A&apos; + 26] = putst(s, node-&gt;next[s[loc] - &apos;A&apos; + 26], loc + 1, node); return node; &#125;public: TrieNode *root; void insert(string &amp; str)&#123; putst(str, root, 0, nullptr); &#125; Trie()&#123; root = new TrieNode(); &#125;&#125;;class Solution &#123;private: string findPre(TrieNode * node) &#123; if (node == nullptr || (node != nullptr&amp;&amp;node-&gt;sons &gt; 1)) return string(&quot;&quot;); int i = 0; for (i = 0; i &lt; 52; i++) &#123; if (node-&gt;next[i] != nullptr) break; &#125; if (i == 52) return string(&quot;&quot;); char temp1 = ((i&gt;25) ? (&apos;A&apos; + i) : (&apos;a&apos; + i)); string temp; temp.insert(temp.begin(), temp1); if (node-&gt;val) &#123; return string(&quot;&quot;); &#125; else &#123; return temp + findPre(node-&gt;next[i]); &#125; &#125;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; Trie a; for (auto&amp; str : strs) a.insert(str); return findPre(a.root); &#125;&#125;; python https://discuss.leetcode.com/topic/6308/simple-python-solution Simple Python solution 62ms, September 19, 2016 Might be a bit slow, but here’s my relatively elegant Python solution: 1234567891011121314class Solution(object): def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str] :rtype: str &quot;&quot;&quot; if not strs: return &apos;&apos; for i, letter_group in enumerate(zip(*strs)): if len(set(letter_group)) &gt; 1: return strs[0][:i] return min(strs) https://discuss.leetcode.com/topic/6308/simple-python-solution/2 Nice use of zip. Here’s my version, it ran in 58 ms. I was proud of myself for using reduce() appropriately: 123456789101112131415161718class Solution: def lcp(self, str1, str2): i = 0 while (i &lt; len(str1) and i &lt; len(str2)): if str1[i] == str2[i]: i = i+1 else: break return str1[:i] # @return a string def longestCommonPrefix(self, strs): if not strs: return &apos;&apos; else: return reduce(self.lcp,strs) https://discuss.leetcode.com/topic/27094/5-line-python-with-zip-and-len-set 5 line python with zip() and len(set()) Just for fun :) 1234567891011class Solution(object): def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str]; rtype: str &quot;&quot;&quot; sz, ret = zip(*strs), &quot;&quot; # looping corrected based on @StefanPochmann&apos;s comment below for c in sz: if len(set(c)) &gt; 1: break ret += c[0] return ret https://discuss.leetcode.com/topic/21222/already-implemented-in-python Already implemented in Python 1234567import osclass Solution: # @param &#123;string[]&#125; strs # @return &#123;string&#125; def longestCommonPrefix(self, strs): return os.path.commonprefix(strs) java https://discuss.leetcode.com/topic/6987/java-code-with-13-lines Java code with 13 lines 1234567891011public String longestCommonPrefix(String[] strs) &#123; if(strs == null || strs.length == 0) return &quot;&quot;; String pre = strs[0]; int i = 1; while(i &lt; strs.length)&#123; while(strs[i].indexOf(pre) != 0) pre = pre.substring(0,pre.length()-1); i++; &#125; return pre;&#125; https://discuss.leetcode.com/topic/6987/java-code-with-13-lines/6 Since you seem to value the number of lines, why didn’t you use a for-loop? It saves three lines. 12345678public String longestCommonPrefix(String[] strs) &#123; if (strs.length == 0) return &quot;&quot;; String pre = strs[0]; for (int i = 1; i &lt; strs.length; i++) while(strs[i].indexOf(pre) != 0) pre = pre.substring(0,pre.length()-1); return pre;&#125; https://discuss.leetcode.com/topic/27913/sorted-the-array-java-solution-2-ms Sorted the array, Java solution, 2 ms Sort the array first, and then you can simply compare the first and last elements in the sorted array. 1234567891011121314151617181920public String longestCommonPrefix(String[] strs) &#123; StringBuilder result = new StringBuilder(); if (strs!= null &amp;&amp; strs.length &gt; 0)&#123; Arrays.sort(strs); char [] a = strs[0].toCharArray(); char [] b = strs[strs.length-1].toCharArray(); for (int i = 0; i &lt; a.length; i ++)&#123; if (b.length &gt; i &amp;&amp; b[i] == a[i])&#123; result.append(b[i]); &#125; else &#123; return result.toString(); &#125; &#125; return result.toString();&#125; https://discuss.leetcode.com/topic/12173/fast-and-simple-java-code-231ms Fast and simple Java code 231ms 1234567891011121314public class Solution &#123; public String longestCommonPrefix(List&lt;String&gt; strs) &#123; if(strs.size()==0) return &quot;&quot;; StringBuilder lcp=new StringBuilder(); for(int i=0;i&lt;strs.get(0).length();i++)&#123; char c=strs.get(0).charAt(i); for(String s:strs)&#123; if(s.length()&lt;i+1||c!=s.charAt(i)) return lcp.toString(); &#125; lcp.append(c); &#125; return lcp.toString(); &#125;&#125; https://discuss.leetcode.com/topic/40472/java-we-love-clear-code Java —— We Love Clear Code! 123456789101112public String longestCommonPrefix(String[] strs) &#123; if (strs == null) return null; if (strs.length == 0) return &quot;&quot;; Arrays.sort(strs); char[] first = strs[0].toCharArray(); char[] last = strs[strs.length - 1].toCharArray(); int i = 0, len = Math.min(first.length, last.length); while (i &lt; len &amp;&amp; first[i] == last[i]) i++; return strs[0].substring(0, i);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[013. Roman to Integer]]></title>
    <url>%2Fp%2F850f821a%2F</url>
    <content type="text"><![CDATA[46.0% https://leetcode.com/problems/roman-to-integer/ Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 方法一: 从后向前遍历，如果当前值大于右边，加上当前值，如果当前值小于右边，减去当前值。 https://leetcode.com/discuss/22867/clean-o-n-c-solution Clean O(n) c++ solution 80ms, 7.24%, May.4th, 2016 Problem is simpler to solve by working the string from back to front and using a map. Runtime speed is 88 ms. 12345678910111213141516class Solution &#123;public: int romanToInt(string s) &#123; unordered_map&lt;char, int&gt; T = &#123;&#123; &apos;I&apos;, 1&#125;, &#123;&apos;V&apos;, 5&#125;, &#123;&apos;X&apos;, 10&#125;, &#123;&apos;L&apos;, 50&#125;, &#123;&apos;C&apos;, 100&#125;, &#123;&apos;D&apos;, 500&#125;, &#123;&apos;M&apos;, 1000&#125;&#125;; int sum = T[s.back()]; for(int i = s.length() - 2; i &gt;= 0; --i)&#123; if(T[s[i]] &lt; T[s[i + 1]]) sum -= T[s[i]]; else sum += T[s[i]]; &#125; return sum; &#125;&#125;; 我的代码实现： 123456789101112131415161718class Solution &#123;public: int romanToInt(string s) &#123; int n = s.size(); if(n==0) return 0; // 学习map的初始化 map&lt;char, int&gt; map = &#123;&#123;'I',1&#125;, &#123;'V', 5&#125;, &#123;'X', 10&#125;, &#123;'L', 50&#125;, &#123;'C', 100&#125;, &#123;'D', 500&#125;, &#123;'M', 1000&#125;&#125;; int res = map[s[n-1]]; // 逆向思考问题，有时更容易解决 for(int i=n-2; i&gt;=0; i--) if(map[s[i]] &gt;= map[s[i+1]]) res += map[s[i]]; else res -= map[s[i]]; return res; &#125;&#125;; https://discuss.leetcode.com/topic/6127/my-easy-to-understand-c-solutions My easy-to-understand C++ solutions 1234567891011121314151617181920212223242526272829class Solution &#123;public: int romanToInt(string s) &#123; int num = 0; int size = s.size(); for (int i = 0; i &lt; size; i++) &#123; if (i &lt; (size - 1) &amp;&amp; romanCharToInt(s[i]) &lt; romanCharToInt(s[i + 1])) &#123; num -= romanCharToInt(s[i]); &#125; else &#123; num += romanCharToInt(s[i]); &#125; &#125; return num; &#125; int romanCharToInt(char c) &#123; switch (c) &#123; case &apos;I&apos;: return 1; case &apos;V&apos;: return 5; case &apos;X&apos;: return 10; case &apos;L&apos;: return 50; case &apos;C&apos;: return 100; case &apos;D&apos;: return 500; case &apos;M&apos;: return 1000; default: return 0; &#125; &#125;&#125;; The code is faster if the body of the for loop is replaced with: 12345678if (i &lt; (size - 1) &amp;&amp; ( &apos;I&apos; == s[i] &amp;&amp; (&apos;V&apos; == s[i + 1] || &apos;X&apos; == s[i + 1]) || &apos;X&apos; == s[i] &amp;&amp; (&apos;L&apos; == s[i + 1] || &apos;C&apos; == s[i + 1]) || &apos;C&apos; == s[i] &amp;&amp; (&apos;D&apos; == s[i + 1] || &apos;M&apos; == s[i + 1]) )) &#123; num -= romanCharToInt(s[i]);&#125; else &#123; num += romanCharToInt(s[i]);&#125; https://discuss.leetcode.com/topic/15224/simple-56ms-c-solution Simple 56ms C++ solution Processing the roman number from right to left turns out to be a bit easier since we can easily tell when to add or subtract: 123456789101112class Solution &#123;public: int romanToInt(string s) &#123; if (s.empty()) &#123; return 0; &#125; unordered_map&lt;char, int&gt; mp &#123; &#123;&apos;I&apos;, 1&#125;, &#123;&apos;V&apos;, 5&#125;, &#123;&apos;X&apos;, 10&#125;, &#123;&apos;L&apos;, 50&#125;, &#123;&apos;C&apos;, 100&#125;, &#123;&apos;D&apos;, 500&#125;, &#123;&apos;M&apos;, 1000&#125; &#125;; int sum = mp[s.back()]; for (int i = s.size() - 2; i &gt;= 0; --i) &#123; sum += mp[s[i]] &gt;= mp[s[i + 1]] ? mp[s[i]] : -mp[s[i]]; &#125; return sum; &#125;&#125;; https://discuss.leetcode.com/topic/30205/i-strongly-suggest-leetcode-explains-the-conversion-rule-clearer I strongly suggest leetcode explains the conversion rule clearer. It would help a lot for those who are not familiar with Roman numerals if the conversion rule is provided, or a conversion table similar to Roman Numerals Chart is given. python https://discuss.leetcode.com/topic/17110/my-straightforward-python-solution My Straightforward Python Solution 123456789101112class Solution:# @param &#123;string&#125; s# @return &#123;integer&#125;def romanToInt(self, s): roman = &#123;&apos;M&apos;: 1000,&apos;D&apos;: 500 ,&apos;C&apos;: 100,&apos;L&apos;: 50,&apos;X&apos;: 10,&apos;V&apos;: 5,&apos;I&apos;: 1&#125; z = 0 for i in range(0, len(s) - 1): if roman[s[i]] &lt; roman[s[i+1]]: z -= roman[s[i]] else: z += roman[s[i]] return z + roman[s[-1]] *Note: The trick is that the last letter is always added. Except the last one, if one letter is less than its latter one, this letter is subtracted. https://discuss.leetcode.com/topic/47179/4-lines-in-python 4 lines in Python d = {‘M’:1000, ‘D’:500, ‘C’:100, ‘L’:50, ‘X’:10, ‘V’:5, ‘I’:1} 12345def romanToInt(self, s): res, p = 0, &apos;I&apos; for c in s[::-1]: res, p = res - d[c] if d[c] &lt; d[p] else res + d[c], c return res https://leetcode.com/discuss/21888/python-solution Python solution 160ms, 85.18%, May.4th, 2016 12345678910111213141516171819class Solution(object): def romanToInt(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; romans = &#123;&apos;M&apos;:1000, &apos;D&apos;:500, &apos;C&apos;:100, &apos;L&apos;:50, &apos;X&apos;:10, &apos;V&apos;:5, &apos;I&apos;:1&#125; prev_value = running_total = 0 for i in xrange(len(s)-1, -1, -1): int_val = romans[s[i]] if int_val &lt; prev_value: running_total -= int_val else: running_total += int_val prev_value = int_val return running_total java https://discuss.leetcode.com/topic/821/my-solution-for-this-question-but-i-don-t-know-is-there-any-easier-way My solution for this question but I don’t know is there any easier way? count every Symbol and add its value to the sum, and minus the extra part of special cases. 1234567891011121314151617181920212223242526public int romanToInt(String s) &#123; int sum=0; if(s.indexOf(&quot;IV&quot;)!=-1)&#123;sum-=2;&#125; if(s.indexOf(&quot;IX&quot;)!=-1)&#123;sum-=2;&#125; if(s.indexOf(&quot;XL&quot;)!=-1)&#123;sum-=20;&#125; if(s.indexOf(&quot;XC&quot;)!=-1)&#123;sum-=20;&#125; if(s.indexOf(&quot;CD&quot;)!=-1)&#123;sum-=200;&#125; if(s.indexOf(&quot;CM&quot;)!=-1)&#123;sum-=200;&#125; char c[]=s.toCharArray(); int count=0; for(;count&lt;=s.length()-1;count++)&#123; if(c[count]==&apos;M&apos;) sum+=1000; if(c[count]==&apos;D&apos;) sum+=500; if(c[count]==&apos;C&apos;) sum+=100; if(c[count]==&apos;L&apos;) sum+=50; if(c[count]==&apos;X&apos;) sum+=10; if(c[count]==&apos;V&apos;) sum+=5; if(c[count]==&apos;I&apos;) sum+=1; &#125; return sum; &#125; https://leetcode.com/discuss/2369/solution-for-this-question-but-dont-know-there-any-easier-way/2 6ms, 97.91%, May.4th, 2016 My solution, only scan string once 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public int romanToInt(String s) &#123; int res = 0; for(int i = s.length() - 1; i &gt;= 0; i--)&#123; char c = s.charAt(i); switch(c)&#123; case &apos;I&apos;: res += (res &gt;= 5 ? -1 : 1); break; case &apos;V&apos;: res += 5; break; case &apos;X&apos;: res += 10 * (res &gt;= 50 ? -1 : 1); break; case &apos;L&apos;: res += 50; break; case &apos;C&apos;: res += 100 * (res &gt;= 500 ? -1 : 1); break; case &apos;D&apos;: res += 500; break; case &apos;M&apos;: res += 1000; break; &#125; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/821/my-solution-for-this-question-but-i-don-t-know-is-there-any-easier-way/3 My solution, scan string once from tail to head. If s[i]’s corresponding integer is no less than the previous one, add it to the result; otherwise, subtract it from the result. 1234567891011121314151617181920int romanToInt(string s) &#123; unordered_map&lt;char, int&gt; charToInt = &#123; &#123; &apos;I&apos;, 1 &#125;, &#123; &apos;V&apos;, 5 &#125;, &#123; &apos;X&apos;, 10 &#125;, &#123; &apos;L&apos;, 50 &#125;, &#123; &apos;C&apos;, 100 &#125;, &#123; &apos;D&apos;, 500 &#125;, &#123; &apos;M&apos;, 1000 &#125; &#125;; int result = 0; int index = s.length() - 1; int preInt = 0; while (index &gt;= 0) &#123; char ch = s[index]; int curInt = charToInt[ch]; if (curInt &gt;= preInt) result += curInt; else result -= curInt; preInt = curInt; index--; &#125; return result;&#125; https://discuss.leetcode.com/topic/28471/7ms-solution-in-java-easy-to-understand 7ms solution in Java. easy to understand 123456789101112131415161718192021222324252627282930313233343536public int romanToInt(String s) &#123; int nums[]=new int[s.length()]; for(int i=0;i&lt;s.length();i++)&#123; switch (s.charAt(i))&#123; case &apos;M&apos;: nums[i]=1000; break; case &apos;D&apos;: nums[i]=500; break; case &apos;C&apos;: nums[i]=100; break; case &apos;L&apos;: nums[i]=50; break; case &apos;X&apos; : nums[i]=10; break; case &apos;V&apos;: nums[i]=5; break; case &apos;I&apos;: nums[i]=1; break; &#125; &#125; int sum=0; for(int i=0;i&lt;nums.length-1;i++)&#123; if(nums[i]&lt;nums[i+1]) sum-=nums[i]; else sum+=nums[i]; &#125; return sum+nums[nums.length-1];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[012. Integer to Roman]]></title>
    <url>%2Fp%2F7da1ea45%2F</url>
    <content type="text"><![CDATA[45.0% https://leetcode.com/problems/integer-to-roman/ Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 方法一： 48ms, 15.75%, May.4th, 2016 12345678910class Solution &#123;public: string intToRoman(int num) &#123; vector&lt;string&gt;M&#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125;; vector&lt;string&gt;C&#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;; vector&lt;string&gt;X&#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;; vector&lt;string&gt;I&#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;; return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10]; &#125;&#125;; https://discuss.leetcode.com/topic/7061/sharing-my-really-simple-solution-with-explanation Sharing my really simple solution with explanation 12345678910111213141516string intToRoman(int num) &#123; string table[4][10] = &#123;&#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;, &#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;, &#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;, &#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125; &#125;; string result; int count = 0; while(num &gt; 0)&#123; int temp = num % 10; result = table[count][temp] + result; num /= 10; count++; &#125; return result;&#125; The basic idea is really simple: replace every digit in num by roman numerals. For example, we have a num: 2438. 2 –&gt; “MM” 4 –&gt; “CD” 3 –&gt; “XXX” 8 –&gt; “VIII” Then the result is “MMCDXXXVIII”. python https://discuss.leetcode.com/topic/32333/share-my-python-solution-96ms Share My Python Solution 96ms 124ms, 69.84%, May.4th, 2016 1234567891011class Solution(object): def intToRoman(self, num): &quot;&quot;&quot; :type num: int :rtype: str &quot;&quot;&quot; M = [&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;] C = [&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;] X = [&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;] I = [&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;] return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10] java https://leetcode.com/discuss/32626/simple-solution Simple Solution 10ms, 34.15%, 3999 / 3999, May.4th, 2016 123456789public class Solution &#123; public String intToRoman(int num) &#123; String M[] = &#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125;; String C[] = &#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;; String X[] = &#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;; String I[] = &#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;; return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10]; &#125;&#125; https://discuss.leetcode.com/topic/20510/my-java-solution-easy-to-understand My java solution easy to understand Reference: http://blog.csdn.net/beiyeqingteng/article/details/8547565 1234567891011121314151617public class Solution &#123;public String intToRoman(int num) &#123; int[] values = &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; String[] strs = &#123;&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;&#125;; StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;values.length;i++) &#123; while(num &gt;= values[i]) &#123; num -= values[i]; sb.append(strs[i]); &#125; &#125; return sb.toString();&#125;&#125; https://discuss.leetcode.com/topic/20510/my-java-solution-easy-to-understand/3 Your function is not really optimal because you will ALWAYS iterate until the end of your values array even if your number becomes zero! Which is not optimal at all. In addition to that you didn’t even check if the input number has a valid roman representation. You had to check that (even if the exercice assumes that the number has it already), you can do that easily with one line. Here is an improvement of your function : 12345678910111213141516171819public static String intToRoman(int num)&#123; if (num &lt; 1 || num &gt; 3999) return &quot;&quot;; StringBuilder result = new StringBuilder(); String[] roman = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;; int[] values = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;; int i = 0; //iterate until the number becomes zero, NO NEED to go until the last element in roman array while (num &gt;0) &#123; while ( num &gt;= values[i]) &#123; num -= values[i]; result.append(roman[i]); &#125; i++; &#125; return result.toString();&#125; As you see, you add just a simple line and you win an optimisation since the code will stop if the current number becomes zero (instead of doing additionnal iterations in the roman array). https://discuss.leetcode.com/topic/26543/easy-to-understand-java-solution Easy to understand Java solution 1234567891011121314151617public enum Type&#123; M(1000),CM(900),D(500),CD(400),C(100),XC(90),L(50),XL(40),X(10),IX(9),V(5),IV(4),I(1); private final int value; Type(int value) &#123; this.value = value; &#125;&#125;;public String intToRoman(int num) &#123; StringBuilder output = new StringBuilder(); for (Type t:Type.values()) &#123; while (num&gt;=t.value) &#123; output.append(t); num -= t.value; &#125; &#125; return output.toString();&#125; https://discuss.leetcode.com/topic/2858/share-my-iterative-solution Share my iterative Solution 1234567891011121314151617public String intToRoman(int num) &#123; int[] weights=&#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; String[] tokens=&#123;&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;&#125;; StringBuilder rs=new StringBuilder(&quot;&quot;); int start=0; while(num&gt;0)&#123; for(int i=start;i&lt;13;i++)&#123; if(num&gt;=weights[i])&#123; num-=weights[i]; rs.append(tokens[i]); break; &#125; start=i+1; // skip those impossible check, make it faster &#125; &#125; return rs.toString();&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>medium</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[011. Container With Most Water]]></title>
    <url>%2Fp%2F971339dc%2F</url>
    <content type="text"><![CDATA[36.2% https://leetcode.com/problems/container-with-most-water/ Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container. https://discuss.leetcode.com/topic/29962/for-someone-who-is-not-so-clear-on-this-question For someone who is not so clear on this question 12345678910test y ^ | | a2 | | a3 an | a1 | | a5 | | | | | a4 | | | | | | | | .. | ---------------------------&gt; 0 1 2 3 4 5 .. n x For someone who is not clear on this question. It’s not like “https://leetcode.com/problems/trapping-rain-water/ “ Which is to get the total water for all the bars problem, It actually is to find the any 2 bars ai, aj, which hold most water together with x-axis. This post give a very good detail explanation as well. https://leetcode.com/discuss/37631/simple-and-clear-proof-explanation 方法一： 双指针 https://leetcode.com/discuss/41527/simple-and-fast-c-c-with-explanation 24ms, 61.49%, June.20th, 2016 Start by evaluating the widest container, using the first and the last line. All other possible containers are less wide, so to hold more water, they need to be higher. Thus, after evaluating that widest container, skip lines at both ends that don’t support a higher height. Then evaluate that new container we arrived at. Repeat until there are no more possible containers left. C++ 1234567891011int maxArea(vector&lt;int&gt;&amp; height) &#123; int water = 0; int i = 0, j = height.size() - 1; while (i &lt; j) &#123; int h = min(height[i], height[j]); water = max(water, (j - i) * h); while (height[i] &lt;= h &amp;&amp; i &lt; j) i++; while (height[j] &lt;= h &amp;&amp; i &lt; j) j--; &#125; return water;&#125; 我的代码实现一： 12345678910111213141516class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int left = 0, right = height.size()-1; int maxArea=0, minHeight=0; // 要设置初始值，后续有max while(left&lt;right)&#123; minHeight = min(height[right], height[left]); // 使用max， 而不是直接等于(right-left)*minHeight,因为变化之后可能变小 // 因为不满足left&lt;right的情况 maxArea = max(maxArea, (right-left)*minHeight); while(left&lt;right &amp;&amp; height[left]&lt;=minHeight) left++; while(left&lt;right &amp;&amp; height[right]&lt;=minHeight) right--; &#125; return maxArea; &#125;&#125;; 我的代码实现二： 12345678910111213141516class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if(n&lt;2) return 0; int left = 0, right = n-1; int res = 0, h = 0; while(left&lt;right)&#123; h = min(height[left], height[right]); res = max(res, h*(right-left)); while(left&lt;right &amp;&amp; height[left]&lt;=h) left++; while(left&lt;right &amp;&amp; height[right]&lt;=h) right--; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/3462/yet-another-way-to-see-what-happens-in-the-o-n-algorithm Yet another way to see what happens in the O(n) algorithm The O(n) solution with proof by contradiction doesn’t look intuitive enough to me. Before moving on, read the algorithm first if you don’t know it yet. Here’s another way to see what happens in a matrix representation: Draw a matrix where the row is the first line, and the column is the second line. For example, say n=6. In the figures below, x means we don’t need to compute the volume for that case: (1) On the diagonal, the two lines are overlapped; (2) The lower left triangle area of the matrix is symmetric to the upper right area. 123456789101112We start by computing the volume at (1,6), denoted by o. Now if the left line is shorter than the right line, then all the elements left to (1,6) on the first row have smaller volume, so we don&apos;t need to compute those cases (crossed by ---). 1 2 3 4 5 61 x ------- o2 x x3 x x x 4 x x x x5 x x x x x6 x x x x x x 1234567891011Next we move the left line and compute (2,6). Now if the right line is shorter, all cases below (2,6) are eliminated. 1 2 3 4 5 61 x ------- o2 x x o3 x x x |4 x x x x |5 x x x x x |6 x x x x x x 1234567891011And no matter how this o path goes, we end up only need to find the max value on this path, which contains n-1 cases. 1 2 3 4 5 61 x ------- o2 x x - o o o3 x x x o | |4 x x x x | |5 x x x x x |6 x x x x x x Hope this helps. I feel more comfortable seeing things this way. https://discuss.leetcode.com/topic/4552/very-simple-o-n-solution Very simple O(n) solution The idea is : to compute area, we need to take min(height[i],height[j]) as our height. Thus if height[i]&lt;height[j], then the expression min(height[i],height[j]) will always lead to at maximum height[i] for all other j(i being fixed), hence no point checking them. Similarly when height[i]&gt;height[j] then all the other i’s can be ignored for that particular j. 123456789101112131415161718class Solution &#123;public: int maxArea(vector&lt;int&gt; &amp;height) &#123; int j=height.size()-1,i=0,mx=0; while(i&lt;j) &#123; mx=max(mx,((j-i)*(min(height[i],height[j])))); if(height[i]&lt;height[j]) i++; else if(height[i]&gt;=height[j]) j--; &#125; return mx; &#125;&#125;; https://discuss.leetcode.com/topic/42122/c-o-n-solution-with-thought-process-applying-simple-bucket-theory C++ O(n) solution with thought process applying simple bucket theory The brute force solution can definitely lead us to the right answer just by doing too many redundant comparisons. When two pointer approach comes to mind, it is intuitive to set both pointers i, j at each end of this array, and move them strategically to the middle of array, update the answer during this process return the answer when we reach the end of array. Suppose now we have the scenarios below: 1237, 5, 6, 9i j When i = 1, j = 4, 1ans = min(7, 9) * (4 - 1) = 21 What’s next? Should we move i or j? We notice that to calculate the area, the height is really identified by the smaller number / shorter end between the two ends, since it’s required that you may not slant the water, so it sounds like Bucket theory: how much water a bucket can contain depends on the shortest plank. So, as to find the next potential maximum area, we disregard the shorter end by moving it to the next position. So in the above case, the next status is to move i to the left, 1237, 5, 6, 9 i j update: 12area (i, j) = area(2, 4) = min(5, 9) * (4 - 2) = 10ans = max(21, 10) = 21 You may notice that, if we move j instead, you actually get a larger area for length of 2: 1area (i, j) = area(1, 3) = min(7, 6) * (3 - 1) = 18 Does that mean this approach will not work? If you look at this way, we move pointer as to get the next potential max, so it doesn’t need to be the maximum for all combinations with length l. Even though 18 is greater than 10, it’s smaller than 21 right? So don’t worry, we can move on to find the next potential maximum result. Now we need to prove, why disregard the shorter end can safely lead us to the right answer by doing a little maths. 12Given an array: a1, a2, a3, a4, ai, ......, aj, ......, an i j Assume the maximum area so far is ans, we prove that 12&quot;By moving shorter end pointer further doesn&apos;t eliminate the final answer (with two ends at maxi, maxj respectively) in our process&quot; Suppose we have two ends at (i, j) respectively at this moment: (i) If the final answer equals what we have already achieved, it’s done! In this scenario, we must have 1maxi &lt;= i, maxj &gt;= j (ii) Otherwise, we know as we move any pointer further, the length of the next rectangle decreases, so the height needs to increase as to result in a larger area. So we have 1min(height[maxi], height[maxj]) &gt; min(height[i], height[j]) So the smaller one in height[i], height[j] won’t become any end in the maximum rectangle, so it’s safe to move forward without it. Till now, it has been proved that this approach can work in O(n) time since we advance one end towards the middle in each iteration, and update ans takes constant time in each iteration. 12345678910111213class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int ans = 0; int i = 0, j = height.size() - 1; while(i &lt; j)&#123; ans = max(ans, (j - i) * min(height[i], height[j])); height[i] &gt; height[j] ? j-- : i++; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/12843/my-short-and-easy-c-code-in-o-n My short and easy c++ code in O(n) 12345678910111213class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int i=0,j=height.size()-1,ans = 0; while(j&gt;i) &#123; ans = max(min(height[i],height[j])*(j-i),ans); if(height[i]&gt;height[j]) j--; else i++; &#125; return ans; &#125;&#125;; python https://discuss.leetcode.com/topic/14940/simple-and-clear-proof-explanation Simple and clear proof/explanation I’ve seen some “proofs” for the common O(n) solution, but I found them very confusing and lacking. Some even didn’t explain anything but just used lots of variables and equations and were like “Tada! See?”. I think mine makes more sense: Idea / Proof: The widest container (using first and last line) is a good candidate, because of its width. Its water level is the height of the smaller one of first and last line.All other containers are less wide and thus would need a higher water level in order to hold more water.The smaller one of first and last line doesn’t support a higher water level and can thus be safely removed from further consideration. Further explanation: Variables i and j define the container under consideration. We initialize them to first and last line, meaning the widest container. Variable water will keep track of the highest amount of water we managed so far. We compute j - i, the width of the current container, and min(height[i], height[j]), the water level that this container can support. Multiply them to get how much water this container can hold, and update water accordingly. Next remove the smaller one of the two lines from consideration, as justified above in “Idea / Proof”. Continue until there is nothing left to consider, then return the result. Implementation: (Python) 1234567891011class Solution: def maxArea(self, height): i, j = 0, len(height) - 1 water = 0 while i &lt; j: water = max(water, (j - i) * min(height[i], height[j])) if height[i] &lt; height[j]: i += 1 else: j -= 1 return water java https://discuss.leetcode.com/topic/25004/easy-concise-java-o-n-solution-with-proof-and-explanation Easy Concise Java O(N) Solution with Proof and Explanation AKA, the general idea to find some max is to go through all cases where max value can possibly occur and keep updating the max value. The efficiency of the scan depends on the size of cases you plan to scan.To increase efficiency, all we need to do is to find a smart way of scan to cut off the useless cases and meanwhile 100% guarantee the max value can be reached through the rest of cases. In this problem, the smart scan way is to set two pointers initialized at both ends of the array. Every time move the smaller value pointer to inner array. Then after the two pointers meet, all possible max cases have been scanned and the max situation is 100% reached somewhere in the scan. Following is a brief prove of this. Given a1,a2,a3…..an as input array. Lets assume a10 and a20 are the max area situation. We need to prove that a10 can be reached by left pointer and during the time left pointer stays at a10, a20 can be reached by right pointer. That is to say, the core problem is to prove: when left pointer is at a10 and right pointer is at a21, the next move must be right pointer to a20. Since we are always moving the pointer with the smaller value, i.e. if a10 &gt; a21, we should move pointer at a21 to a20, as we hope. Why a10 &gt;a21? Because if a21&gt;a10, then area of a10 and a20 must be less than area of a10 and a21. Because the area of a10 and a21 is at least height[a10] (21-10) while the area of a10 and a20 is at most height[a10] (20-10). So there is a contradiction of assumption a10 and a20 has the max area. So, a10 must be greater than a21, then next move a21 has to be move to a20. The max cases must be reached. 123456789101112131415public int maxArea(int[] height) &#123; int left = 0, right = height.length - 1; int maxArea = 0; while (left &lt; right) &#123; maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left)); if (height[left] &lt; height[right]) left++; else right--; &#125; return maxArea;&#125; https://discuss.leetcode.com/topic/33498/java-3ms-solution-with-step-by-step-explanations-beats-85 Java 3ms solution with step-by-step explanations (beats 85%) It took me quite some time to finally optimize my solution from 21ms to 3ms :( If you have difficulty understanding the following code, check this link for a detailed explanation. 12345678910111213141516public int maxArea(int[] height) &#123; int L = height.length, lo = 0, hi = L-1; int max = 0; while(lo&lt;hi) &#123; int loMax = height[lo], hiMax = height[hi]; int candidate = (hi-lo) * (loMax&lt;hiMax ? loMax : hiMax); max = candidate &gt; max ? candidate : max; if(height[lo]&lt;=height[hi]) while(lo&lt;hi &amp;&amp; height[lo]&lt;=loMax) ++lo; else while(hi&gt;lo &amp;&amp; height[hi]&lt;=hiMax) --hi; &#125; return max;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[010. Regular Expression Matching]]></title>
    <url>%2Fp%2F34b0b346%2F</url>
    <content type="text"><![CDATA[23.9% https://leetcode.com/problems/regular-expression-matching/ 123456789101112131415161718Implement regular expression matching with support for &apos;.&apos; and &apos;*&apos;.&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;aa&quot;, &quot;.*&quot;) → trueisMatch(&quot;ab&quot;, &quot;.*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true 方法一： 优先考虑递归 递归方法 学习string的substr的用法 My concise recursive and DP solutions with full explanation in C++ Please refer to my blog post if you have any comment. Wildcard matching problem can be solved similarly. 12345678910111213class Solution &#123;public: bool isMatch(string s, string p) &#123; if (p.empty()) return s.empty(); if (&apos;*&apos; == p[1]) // x* matches empty string or at least one character: x* -&gt; xx* // *s is to ensure s is non-empty return (isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p)); else return !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; my code: 12345678910class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.empty()) return s.empty(); if(p.size()&gt;1 &amp;&amp; p[1]==&apos;*&apos;)&#123; return isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0]==p[0] || p[0]==&apos;.&apos;) &amp;&amp; isMatch(s.substr(1), p); &#125;else return !s.empty() &amp;&amp; (s[0]==p[0] || p[0]==&apos;.&apos;) &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; 我的代码实现二: 12345678910class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.empty()) return s.empty(); if(p.size()&gt;1 &amp;&amp; p[1]=='*') return isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0]==p[0] || p[0]=='.') &amp;&amp; isMatch(s.substr(1), p); // 要检查s是否为空，不能忘记 return !s.empty() &amp;&amp; (s[0]==p[0] || p[0]=='.') &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; 方法二： dp mn 设置(m+1) (n+1)的长度，多的一行表示空的时候的结果。 经常有上述做法。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: bool isMatch(string s, string p) &#123; /** * f[i][j]: if s[0..i-1] matches p[0..j-1] * if p[j - 1] != &apos;*&apos; * f[i][j] = f[i - 1][j - 1] &amp;&amp; s[i - 1] == p[j - 1] * if p[j - 1] == &apos;*&apos;, denote p[j - 2] with x * f[i][j] is true iff any of the following is true * 1) &quot;x*&quot; repeats 0 time and matches empty: f[i][j - 2] * 2) &quot;x*&quot; repeats &gt;= 1 times and matches &quot;x*x&quot;: s[i - 1] == x &amp;&amp; f[i - 1][j] * &apos;.&apos; matches any single character */ int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; f(m + 1, vector&lt;bool&gt;(n + 1, false)); f[0][0] = true; for (int i = 1; i &lt;= m; i++) f[i][0] = false; // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is &apos;*&apos; and p[0..j - 3] matches empty for (int j = 1; j &lt;= n; j++) f[0][j] = j &gt; 1 &amp;&amp; &apos;*&apos; == p[j - 1] &amp;&amp; f[0][j - 2]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (p[j - 1] != &apos;*&apos;) f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || &apos;.&apos; == p[j - 1]); else // p[0] cannot be &apos;*&apos; so no need to check &quot;j &gt; 1&quot; here f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || &apos;.&apos; == p[j - 2]) &amp;&amp; f[i - 1][j]; return f[m][n]; &#125;&#125;; 我的代码实现 : 与方法一类似 都是每次要么增长s，要么增长p 以当前位置是否为*作为判断条件 1234567891011121314151617181920class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.empty()) return s.empty(); int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=2; i&lt;=n; i++) dp[0][i] = p[i-1]=='*' &amp;&amp; dp[0][i-2]; for(int i=1; i&lt;=m; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; if(p[j-1]=='*') dp[i][j] = dp[i][j-2] || dp[i-1][j] &amp;&amp; (s[i-1]==p[j-2] || p[j-2]=='.'); else dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]=='.'); &#125; &#125; return dp[m][n]; &#125;&#125;; 相似题目：正则表达式匹配请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 方法一： 使用递归 123456789101112131415161718192021222324class Solution &#123;public: bool match(char* str, char* pattern) &#123; if(str==NULL || pattern==NULL) return false; return helper(str, pattern); &#125; bool helper(char* str, char* pattern)&#123; if(*str==&apos;\0&apos; &amp;&amp; *pattern==&apos;\0&apos;) return true; if(*str!=&apos;\0&apos; &amp;&amp; *pattern==&apos;\0&apos;) return false; if(*(pattern+1)==&apos;*&apos;)&#123; if(*pattern==*str || (*pattern==&apos;.&apos; &amp;&amp; *str!=&apos;\0&apos;))&#123; return helper(str+1, pattern+2) || helper(str+1, pattern) || helper(str, pattern+2); &#125;else&#123; return helper(str, pattern+2); &#125; &#125; if(*str==*pattern || (*pattern==&apos;.&apos; &amp;&amp; *str!=&apos;\0&apos;)) return helper(str+1, pattern+1); return false; &#125;&#125;; https://discuss.leetcode.com/topic/6183/my-concise-recursive-and-dp-solutions-with-full-explanation-in-c My concise recursive and DP solutions with full explanation in C++ Please refer to my blog post if you have any comment. Wildcard matching problem can be solved similarly. 递归方法 12345678910111213class Solution &#123;public: bool isMatch(string s, string p) &#123; if (p.empty()) return s.empty(); if (&apos;*&apos; == p[1]) // x* matches empty string or at least one character: x* -&gt; xx* // *s is to ensure s is non-empty return (isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p)); else return !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; dp： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: bool isMatch(string s, string p) &#123; /** * f[i][j]: if s[0..i-1] matches p[0..j-1] * if p[j - 1] != &apos;*&apos; * f[i][j] = f[i - 1][j - 1] &amp;&amp; s[i - 1] == p[j - 1] * if p[j - 1] == &apos;*&apos;, denote p[j - 2] with x * f[i][j] is true iff any of the following is true * 1) &quot;x*&quot; repeats 0 time and matches empty: f[i][j - 2] * 2) &quot;x*&quot; repeats &gt;= 1 times and matches &quot;x*x&quot;: s[i - 1] == x &amp;&amp; f[i - 1][j] * &apos;.&apos; matches any single character */ int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; f(m + 1, vector&lt;bool&gt;(n + 1, false)); f[0][0] = true; for (int i = 1; i &lt;= m; i++) f[i][0] = false; // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is &apos;*&apos; and p[0..j - 3] matches empty for (int j = 1; j &lt;= n; j++) f[0][j] = j &gt; 1 &amp;&amp; &apos;*&apos; == p[j - 1] &amp;&amp; f[0][j - 2]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (p[j - 1] != &apos;*&apos;) f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || &apos;.&apos; == p[j - 1]); else // p[0] cannot be &apos;*&apos; so no need to check &quot;j &gt; 1&quot; here f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || &apos;.&apos; == p[j - 2]) &amp;&amp; f[i - 1][j]; return f[m][n]; &#125;&#125;; 16ms, 60.02%, September 21, 2016 https://discuss.leetcode.com/topic/17852/9-lines-16ms-c-dp-solutions-with-explanations 9-lines 16ms C++ DP Solutions with Explanations This problem has a typical solution using Dynamic Programming. We define the state P[i][j] to be true if s[0..i) matches p[0..j) and false otherwise. Then the state equations are: P[i][j] = P[i - 1][j - 1], if p[j - 1] != ‘*’ &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == ‘.’); P[i][j] = P[i][j - 2], if p[j - 1] == ‘*’ and the pattern repeats for 0 times; P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == ‘.’), if p[j - 1] == ‘*’ and the pattern repeats for at least 1 times. Putting these together, we will have the following code. 1234567891011121314class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(), n = p.length(); vector&lt;vector&lt;bool&gt; &gt; dp(m + 1, vector&lt;bool&gt; (n + 1, false)); dp[0][0] = true; for (int i = 0; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (p[j - 1] == &apos;*&apos;) dp[i][j] = dp[i][j - 2] || (i &gt; 0 &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == &apos;.&apos;) &amp;&amp; dp[i - 1][j]); else dp[i][j] = i &gt; 0 &amp;&amp; dp[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;.&apos;); return dp[m][n]; &#125;&#125;; https://discuss.leetcode.com/topic/2818/the-shortest-ac-code The shortest AC code. 1.’.’ is easy to handle. if p has a ‘.’, it can pass any single character in s except ‘\0’. 2.’’ is a totally different problem. if p has a ‘’ character, it can pass any length of first-match characters in s including ‘\0’. 12345678910111213141516171819class Solution &#123; public: bool matchFirst(const char *s, const char *p)&#123; return (*p == *s || (*p == &apos;.&apos; &amp;&amp; *s != &apos;\0&apos;)); &#125;bool isMatch(const char *s, const char *p) &#123; if (*p == &apos;\0&apos;) return *s == &apos;\0&apos;; //empty if (*(p + 1) != &apos;*&apos;) &#123;//without * if(!matchFirst(s,p)) return false; return isMatch(s + 1, p + 1); &#125; else &#123; //next: with a * if(isMatch(s, p + 2)) return true; //try the length of 0 while ( matchFirst(s,p) ) //try all possible lengths if (isMatch(++s, p + 2))return true; &#125;&#125;&#125;; https://discuss.leetcode.com/topic/21370/my-4ms-c-dp-solution-another-recursive-version-also-given-72ms My 4ms C++ DP solution (another recursive version also given 72ms) Just to build a DP table checked, where checked[i][j] indicates whether s[0..i-1] matches with p[0..j-1]. The recursive relationship is as below: To match with the empty string s[0..0] (i.e. to make checked[0][j]), P[0..j-1] has to meet: p[j-1]==’*’ (to cancel p[j-2]) and checked[0][j-2] == true; To match with the string s[0..i-1] (i.e. to make checked[i][j]), P[0..j-1] has to meet: if p[j-1] ==’*’, then j must be larger than 1 (j&gt;1) and checked[i][j-2] (i.e. p[j-2] cancelled by ‘*’) checked[i-1][j] &amp;&amp; (s[i-1] ==p[j-2] || p[j-2] ==’.’) (s[i-1] matches with p[j-2] or ‘.’, ) if p[j-1] !=’*’, checked[i-1][j-1] &amp;&amp; (s[i-1] ==p[j-1] || p[j-1] ==’.’)(i.e. s[i-1] matches with p[j-1] or ‘.’) 123456789101112131415161718192021class Solution &#123; public: bool isMatch(string s, string p) &#123; int sSize = s.size(), pSize = p.size(), i, j; bool checked[sSize+1][pSize+1]; // fill_n(&amp;matched[0][0], (sSize+1)*(pSize+1), false); for(j=2, checked[0][0]=true, checked[0][1]= false; j&lt;=pSize; ++j) // match s[0..0] checked[0][j] = p[j-1] == &apos;*&apos;? checked[0][j-2] : false; for(i=1; i&lt;=sSize; ++i) for(j=1, checked[i][0]=false; j&lt;=pSize; ++j) &#123; if(p[j-1]==&apos;*&apos;) // case (1) checked[i][j] = (j&gt;1) &amp;&amp; ( checked[i][j-2] || ( ( checked[i-1][j]) &amp;&amp; (s[i-1]== p[j-2] || p[j-2] == &apos;.&apos;)) ); else // case (2) checked[i][j] = checked[i-1][j-1] &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == &apos;.&apos;); &#125; return checked[sSize][pSize]; &#125; &#125;; A recursive version, divide cases into two groups (if the next p char is ‘*’ or not) 123456789101112131415161718192021222324class Solution &#123;private: bool helper(const string &amp;s, const string &amp;p, int sS, int pS) &#123; int sSize = s.size(), pSize = p.size(), i, j; if(pS==pSize) return sS ==sSize; // if p goes to its end, then only if s also goes to its end to return true; if(p[pS+1]!=&apos;*&apos;) &#123; if( sS&lt;sSize &amp;&amp; (p[pS]==s[sS] || p[pS] == &apos;.&apos;)) return helper(s, p, sS+1, pS+1); &#125; else &#123; if(helper(s, p, sS,pS+2)) return true; while(sS&lt;sSize &amp;&amp; (p[pS]==s[sS] || p[pS] == &apos;.&apos;)) if(helper(s,p, ++sS, pS+2)) return true; &#125; return false; &#125;public: bool isMatch(string s, string p) &#123; helper(s, p, 0, 0); &#125;&#125;; python https://discuss.leetcode.com/topic/22948/my-dp-approach-in-python-with-comments-and-unittest My DP approach in Python with comments and unittest I shared my DP approach with comments and provided some unit tests for it. Some statements in the approach directly affect some corner cases, for example, comment out line 22-23, then the unittest test_symbol_0 will fail. Hope this script helps us better understand the problem. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import unittestclass Solution(object): def isMatch(self, s, p): # The DP table and the string s and p use the same indexes i and j, but # table[i][j] means the match status between p[:i] and s[:j], i.e. # table[0][0] means the match status of two empty strings, and # table[1][1] means the match status of p[0] and s[0]. Therefore, when # refering to the i-th and the j-th characters of p and s for updating # table[i][j], we use p[i - 1] and s[j - 1]. # Initialize the table with False. The first row is satisfied. table = [[False] * (len(s) + 1) for _ in range(len(p) + 1)] # Update the corner case of matching two empty strings. table[0][0] = True # Update the corner case of when s is an empty string but p is not. # Since each &apos;*&apos; can eliminate the charter before it, the table is # vertically updated by the one before previous. [test_symbol_0] for i in range(2, len(p) + 1): table[i][0] = table[i - 2][0] and p[i - 1] == &apos;*&apos; for i in range(1, len(p) + 1): for j in range(1, len(s) + 1): if p[i - 1] != &quot;*&quot;: # Update the table by referring the diagonal element. table[i][j] = table[i - 1][j - 1] and \ (p[i - 1] == s[j - 1] or p[i - 1] == &apos;.&apos;) else: # Eliminations (referring to the vertical element) # Either refer to the one before previous or the previous. # I.e. * eliminate the previous or count the previous. # [test_symbol_1] table[i][j] = table[i - 2][j] or table[i - 1][j] # Propagations (referring to the horizontal element) # If p&apos;s previous one is equal to the current s, with # helps of *, the status can be propagated from the left. # [test_symbol_2] if p[i - 2] == s[j - 1] or p[i - 2] == &apos;.&apos;: table[i][j] |= table[i][j - 1] return table[-1][-1]class TestSolution(unittest.TestCase): def test_none_0(self): s = &quot;&quot; p = &quot;&quot; self.assertTrue(Solution().isMatch(s, p)) def test_none_1(self): s = &quot;&quot; p = &quot;a&quot; self.assertFalse(Solution().isMatch(s, p)) def test_no_symbol_equal(self): s = &quot;abcd&quot; p = &quot;abcd&quot; self.assertTrue(Solution().isMatch(s, p)) def test_no_symbol_not_equal_0(self): s = &quot;abcd&quot; p = &quot;efgh&quot; self.assertFalse(Solution().isMatch(s, p)) def test_no_symbol_not_equal_1(self): s = &quot;ab&quot; p = &quot;abb&quot; self.assertFalse(Solution().isMatch(s, p)) def test_symbol_0(self): s = &quot;&quot; p = &quot;a*&quot; self.assertTrue(Solution().isMatch(s, p)) def test_symbol_1(self): s = &quot;a&quot; p = &quot;ab*&quot; self.assertTrue(Solution().isMatch(s, p)) def test_symbol_2(self): # E.g. # s a b b # p 1 0 0 0 # a 0 1 0 0 # b 0 0 1 0 # * 0 1 1 1 s = &quot;abb&quot; p = &quot;ab*&quot; self.assertTrue(Solution().isMatch(s, p))if __name__ == &quot;__main__&quot;: unittest.main() https://discuss.leetcode.com/topic/6739/fast-python-solution-with-backtracking-and-caching-dp-solution Fast Python solution with backtracking and caching + DP solution Takes about 174ms: 123456789101112131415161718cache = &#123;&#125;def isMatch(self, s, p): if (s, p) in self.cache: return self.cache[(s, p)] if not p: return not s if p[-1] == &apos;*&apos;: if self.isMatch(s, p[:-2]): self.cache[(s, p)] = True return True if s and (s[-1] == p[-2] or p[-2] == &apos;.&apos;) and self.isMatch(s[:-1], p): self.cache[(s, p)] = True return True if s and (p[-1] == s[-1] or p[-1] == &apos;.&apos;) and self.isMatch(s[:-1], p[:-1]): self.cache[(s, p)] = True return True self.cache[(s, p)] = False return False DP version: 1234567891011121314def isMatch(self, s, p): dp = [[False] * (len(s) + 1) for _ in range(len(p) + 1)] dp[0][0] = True for i in range(1, len(p)): dp[i + 1][0] = dp[i - 1][0] and p[i] == &apos;*&apos; for i in range(len(p)): for j in range(len(s)): if p[i] == &apos;*&apos;: dp[i + 1][j + 1] = dp[i - 1][j + 1] or dp[i][j + 1] if p[i - 1] == s[j] or p[i - 1] == &apos;.&apos;: dp[i + 1][j + 1] |= dp[i + 1][j] else: dp[i + 1][j + 1] = dp[i][j] and (p[i] == s[j] or p[i] == &apos;.&apos;) return dp[-1][-1] https://discuss.leetcode.com/topic/40371/easy-dp-java-solution-with-detailed-explanation Easy DP Java Solution with detailed Explanation This Solution use 2D DP. beat 90% solutions, very simple. Here are some conditions to figure out, then the logic can be very straightforward. 1234567891, If p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1];2, If p.charAt(j) == &apos;.&apos; : dp[i][j] = dp[i-1][j-1];3, If p.charAt(j) == &apos;*&apos;: here are two sub conditions: 1 if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty 2 if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == &apos;.&apos;: dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a or dp[i][j] = dp[i][j-1] // in this case, a* counts as single a or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty Here is the solution 12345678910111213141516171819202122232425262728293031public boolean isMatch(String s, String p) &#123; if (s == null || p == null) &#123; return false; &#125; boolean[][] dp = new boolean[s.length()+1][p.length()+1]; dp[0][0] = true; for (int i = 0; i &lt; p.length(); i++) &#123; if (p.charAt(i) == &apos;*&apos; &amp;&amp; dp[0][i-1]) &#123; dp[0][i+1] = true; &#125; &#125; for (int i = 0 ; i &lt; s.length(); i++) &#123; for (int j = 0; j &lt; p.length(); j++) &#123; if (p.charAt(j) == &apos;.&apos;) &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == s.charAt(i)) &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == &apos;*&apos;) &#123; if (p.charAt(j-1) != s.charAt(i) &amp;&amp; p.charAt(j-1) != &apos;.&apos;) &#123; dp[i+1][j+1] = dp[i+1][j-1]; &#125; else &#123; dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]); &#125; &#125; &#125; &#125; return dp[s.length()][p.length()];&#125; https://discuss.leetcode.com/topic/12289/clean-java-solution Clean Java Solution 1234567891011121314151617181920212223public boolean isMatch(String s, String p) &#123; if (p.isEmpty()) &#123; return s.isEmpty(); &#125; if (p.length() == 1 || p.charAt(1) != &apos;*&apos;) &#123; if (s.isEmpty() || (p.charAt(0) != &apos;.&apos; &amp;&amp; p.charAt(0) != s.charAt(0))) &#123; return false; &#125; else &#123; return isMatch(s.substring(1), p.substring(1)); &#125; &#125; //P.length() &gt;=2 while (!s.isEmpty() &amp;&amp; (s.charAt(0) == p.charAt(0) || p.charAt(0) == &apos;.&apos;)) &#123; if (isMatch(s, p.substring(2))) &#123; return true; &#125; s = s.substring(1); &#125; return isMatch(s, p.substring(2));&#125; https://discuss.leetcode.com/topic/2601/my-ac-dp-solution-for-this-problem-asking-for-improvements My AC DP solution for this problem, asking for improvements. 123456789101112131415161718192021222324252627282930public boolean isMatch(String s, String p) &#123; int m = s.length(); int n = p.length(); if (s == null || p == null) &#123; return false; &#125; boolean[][] OPT = new boolean[m+1][n+1]; OPT[0][0] = true; for (int i = 1; i &lt;= m; i++) &#123; OPT[i][0] = false; &#125; for (int j = 1; j &lt;= n; j++) &#123; OPT[0][j] = (p.charAt(j-1) == &apos;*&apos;) &amp;&amp; (j-2 &gt;= 0) &amp;&amp; OPT[0][j-2]; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; OPT[i][j] = ((OPT[i-1][j-1]) &amp;&amp; equals(s, p, i-1, j-1)) || ((OPT[i-1][j] || OPT[i][j-1]) &amp;&amp; (p.charAt(j-1) == &apos;*&apos;) &amp;&amp; equals(s, p, i-1, j-2)) || ((p.charAt(j-1) == &apos;*&apos;) &amp;&amp; (j-2 &gt;= 0) &amp;&amp; OPT[i][j-2]); &#125; &#125; return OPT[m][n];&#125; private boolean equals(String s, String p, int si, int pi) { return (s.charAt(si) == p.charAt(pi) || p.charAt(pi) == ‘.’);}Basically, the OPT[i][j] means preceding substring of length i of s and length j of p. For any two substrings, the value of OPT[i][j] can be from one of following four cases: case 1: OPT[i-1][j-1] is true, and ith character of s is equal to j th character of p. Or j th character of p is ‘.’ case 2: OPT[i-1][j] is true, then my pattern now is ‘*’ and preceding character is equal to incoming character of s case 3: OPT[i][j-1] is true, then my pattern now is ‘*’ which can match an empty string case 4: OPT[i][j-2] is true, and the pattern like (a*) matches an empty stringbase case is the OPT[0][0], OPT[i][0], OPT[0][j]. https://discuss.leetcode.com/topic/2601/my-ac-dp-solution-for-this-problem-asking-for-improvements/2 I found I was using the exact algorithm as you did. So I post one for your references.It has no additional brace. It is very difficult to write a pretty code in string operations by Java due to .charAt(). By the way Your value assignment in the nested loop is indeed a pain to read(At least for me ). I do suggest you to give more lines on that part. 1234567891011121314151617181920212223242526272829303132333435363738public class RegularExpressionMatching &#123; public boolean isMatch(String s, String p) &#123; if (s==null&amp;&amp;p==null) return true; if (s.length()==0&amp;&amp;p.length()==0) return true; boolean[][] matrix = new boolean[s.length()+1][p.length()+1]; matrix[0][0]=true; for (int i=1;i&lt;=s.length();i++) matrix[i][0]=false; for (int j=1;j&lt;=p.length();j++) if (p.charAt(j-1)==&apos;*&apos;&amp;&amp;j&gt;1) matrix[0][j]=matrix[0][j-2]; else matrix[0][j]=false; for (int i=1;i&lt;=s.length();i++) for (int j=1;j&lt;=p.length();j++) if (p.charAt(j-1)==s.charAt(i-1)||p.charAt(j-1)==&apos;.&apos;) matrix[i][j]=matrix[i-1][j-1]; else if (p.charAt(j-1)==&apos;*&apos;&amp;&amp;j&gt;1) if (p.charAt(j-2)==s.charAt(i-1)||p.charAt(j-2)==&apos;.&apos;) matrix[i][j]=matrix[i-1][j]||matrix[i][j-2]||matrix[i][j-1]; //matrix[i-1][j]:abb vs ab*: depends on ab vs ab* //matrix[i][j-2] a vs ab* depends on a vs a //matrix[i][j-1] ab vs ab*: depends on ab vs ab else matrix[i][j]=matrix[i][j-2]; else matrix[i][j]=false; return matrix[s.length()][p.length()]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[009. Palindrome Number]]></title>
    <url>%2Fp%2Fc3ad93e8%2F</url>
    <content type="text"><![CDATA[35.4% https://leetcode.com/problems/palindrome-number/ Determine whether an integer is a palindrome. Do this without extra space. click to show spoilers. Some hints:Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 方法一： 先特殊情况，负数，最后一位为0且数值不等于0，排除。 然后翻转得到值 判断情况，相等，或者等于rev/10，这是因为只走了一半 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0 || x != 0 &amp;&amp; x%10 == 0) return false; int rev = 0; while(x &gt; rev)&#123; rev = rev * 10 + x % 10; x = x / 10; &#125; return (x == rev || x == rev / 10); &#125;&#125;; 我的代码实现一： 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0 || x&gt;0 &amp;&amp; x%10==0) return false; // 排除10， 100，1000这种情况 int rev = 0; while(rev&lt;x)&#123; rev = rev*10 + x%10; x /= 10; &#125; return rev == x || rev/10 == x; &#125;&#125;; 我的代码实现二： 1234567891011121314class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0 || x!=0 &amp;&amp; x%10 == 0) return false; int y = 0; while(y&lt;x)&#123; y = y*10 + x%10; x /= 10; &#125; // 注意此处该/还是% return x==y || x==y/10; &#125;&#125;; https://discuss.leetcode.com/topic/31602/this-problem-is-meanless This problem is meanless Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack. If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space. https://discuss.leetcode.com/topic/3151/2147447412-is-not-a-palindromic-number -2147447412 is not a palindromic number I am wondering how the other people got their code ACed, the testing result of “-2147447412” seems a little odd to me. Should it be a palindromic number or not? Note: I believe the range of int is [-2147483648, 2147483647] and “-2147447412” is not overflowed, plus I handled the overflow cases already (test case “-2147483648” in particular). 11499 / 11502 test cases passed. Status: Wrong Answer Input: -2147447412 Output: true Expected: false Here’s my second question: Why does the function take “int” as input instead of “unsigned int”, when we assume all negative numbers are NOT palindromic. java https://leetcode.com/discuss/23563/line-accepted-java-code-without-the-need-handling-overflow 9-line accepted Java code, without the need of handling overflow 12ms, 46.14%, May.4th, 2016 compare half of the digits in x, so don’t need to deal with overflow. 123456789public boolean isPalindrome(int x) &#123; if (x&lt;0 || (x!=0 &amp;&amp; x%10==0)) return false; int rev = 0; while (x&gt;rev)&#123; rev = rev*10 + x%10; x = x/10; &#125; return (x==rev || x==rev/10);&#125; https://discuss.leetcode.com/topic/9477/o-1-space-o-lgn-time-java-solution-no-overflow-risk O(1) space, O(lgn) time java solution, no overflow risk 123456789101112131415public boolean isPalindrome(int x) &#123; if (x &lt; 0) return false; int p = x; int q = 0; while (p &gt;= 10)&#123; q *=10; q += p%10; p /=10; &#125; return q == x / 10 &amp;&amp; p == x % 10;&#125; so the reversed version of int is always 1 time short in the factor of 10s . in case of Int16, check 63556 will finally check if (6553 == 6355 &amp;&amp; 6 == 63556%10) so there will have no concerns about the overflow. https://discuss.leetcode.com/topic/3879/neat-ac-java-code-o-n-time-complexity Neat AC java code. O(n) time complexity. 123456789public boolean isPalindrome(int x) &#123; int palindromeX = 0; int inputX = x; while(x&gt;0)&#123; palindromeX = palindromeX*10 + (x % 10); x = x/10; &#125; return palindromeX==inputX; &#125; https://discuss.leetcode.com/topic/39795/simple-java-o-1-space-solution Simple JAVA O(1) space solution 12345678910public boolean isPalindrome(int x) &#123; if(x&lt;0 || (x!=0 &amp;&amp; x%10==0)) return false; int res = 0; while(x&gt;res)&#123; res = res*10 + x%10; x = x/10; &#125; return (x==res || x==res/10);&#125; cpp https://leetcode.com/discuss/33500/an-easy-lines-code-only-reversing-till-half-and-then-compare An easy c++ 8 lines code (only reversing till half and then compare) 76ms, 65.37%, May.4th, 2016 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0 || x != 0 &amp;&amp; x%10 == 0) return false; int rev = 0; while(x &gt; rev)&#123; rev = rev * 10 + x % 10; x = x / 10; &#125; return (x == rev || x == rev / 10); &#125;&#125;; https://discuss.leetcode.com/topic/39259/7-line-simple-c-solution-beats-90-submissions-in-o-1-space-two-pointers 7 line simple C++ solution beats 90% submissions in O(1) space, two pointers Use two pointers concept, find the half point, and compare first half and 2nd half. Variable revhalf is the reversed 2nd half(x has even number of digits), or 2nd half with the middle digit(if x has odd number of digits) 12345678910111213class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0) return false; int revhalf = 0, slow = x, fast = x; while(fast)&#123; revhalf = revhalf * 10 + slow % 10; slow /= 10; fast /= 100; &#125; return slow == revhalf || slow == revhalf / 10; &#125;&#125;; https://discuss.leetcode.com/topic/18921/my-c-solution My C++ solution.. 1234567891011121314151617bool isPalindrome(int x) &#123; if(x&lt;0) return false; int num=x; int a=0; while(x) &#123; a=a*10 + x%10; x=x/10; &#125; if(a==num) return true; else return false; &#125; python 272ms, 66.06%, May.4th, 2016 https://leetcode.com/discuss/82355/5-line-python-solution-248ms 1234567891011class Solution(object): def isPalindrome(self, x): &quot;&quot;&quot; :type x: int :rtype: bool &quot;&quot;&quot; if x &lt; 0 or (x &gt; 0 and x % 10 == 0): return False half = 0 while x &gt; half: half, x = half * 10 + x % 10, x / 10 return x in (half, half / 10)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[008. String to Integer (atoi)]]></title>
    <url>%2Fp%2F7d4ee2b3%2F</url>
    <content type="text"><![CDATA[14.0% https://leetcode.com/problems/string-to-integer-atoi/ Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. spoilers alert… click to show requirements for atoi. Requirements for atoi: The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. https://discuss.leetcode.com/topic/35270/such-a-shitty-problem Such a shitty problem The description is not clear not all unless you click on the hint. What’s the point of testing all the “+-1” or “-+1” without any input spec nor any situation where input is obtained. 方法一： 如下代码，从第一个非 ‘ ‘开始，然后正负号，然后每个进行判别，考虑与最大最小值的差异。 string的函数方法find_first_not_of(‘ ‘) 1234567891011121314151617int myAtoi(string str) &#123; long result = 0; int indicator = 1; for(int i = 0; i&lt;str.size();) &#123; i = str.find_first_not_of(&apos; &apos;); if(str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) indicator = (str[i++] == &apos;-&apos;)? -1 : 1; while(&apos;0&apos;&lt;= str[i] &amp;&amp; str[i] &lt;= &apos;9&apos;) &#123; result = result*10 + (str[i++]-&apos;0&apos;); if(result*indicator &gt;= INT_MAX) return INT_MAX; if(result*indicator &lt;= INT_MIN) return INT_MIN; &#125; return result*indicator; &#125;&#125; 我优化后的代码实现： 123456789101112131415161718class Solution &#123;public: int myAtoi(string str) &#123; long result = 0; int indicator = 1; int i = 0; i = str.find_first_not_of(' '); if(str[i] == '-' || str[i] == '+') indicator = (str[i++] == '-')? -1 : 1; while('0'&lt;= str[i] &amp;&amp; str[i] &lt;= '9') &#123; result = result*10 + (str[i++]-'0'); if(result*indicator &gt;= INT_MAX) return INT_MAX; if(result*indicator &lt;= INT_MIN) return INT_MIN; &#125; return result*indicator; &#125;&#125;; 我的代码实现： 注意里面的坑，处理整数int数字，一定要注意溢出问题，所以这样的，反转的等等，一定要用long 不用int，而是用long，处理溢出问题，此处要特别注意。 123456789101112131415161718class Solution &#123;public: int myAtoi(string str) &#123; if(str.empty()) return 0; int flag = 1; int i = 0; i = str.find_first_not_of(' '); if(str[i]=='+' || str[i]=='-') flag = (str[i++]=='-') ? -1 : 1; long base = 0; // 此处一定要用long while(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9')&#123; base = base*10 + (str[i++]-'0'); if(base*flag &gt;= INT_MAX) return INT_MAX; if(base*flag &lt;= INT_MIN) return INT_MIN; &#125; return flag*base; &#125;&#125;; 我的代码实现： 对于int可能溢出的题目，就用long long 123456789101112131415161718192021class Solution &#123;public: int myAtoi(string str) &#123; long long res = 0; int i = str.find_first_not_of(' '); int flag = 1; if(str[i] == '+')&#123; flag = 1; i++; &#125;else if(str[i]=='-')&#123; flag = -1; i++; &#125; while(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9')&#123; res = res*10 + str[i++] - '0'; if(flag*res &gt; INT_MAX) return INT_MAX; if(flag*res &lt; INT_MIN) return INT_MIN; &#125; return flag*res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/15891/8ms-c-solution-easy-to-understand 8ms C++ solution, easy to understand 12ms, 15.61%, August 31, 2016 1234567891011121314151617int myAtoi(string str) &#123; long result = 0; int indicator = 1; for(int i = 0; i&lt;str.size();) &#123; i = str.find_first_not_of(&apos; &apos;); if(str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) indicator = (str[i++] == &apos;-&apos;)? -1 : 1; while(&apos;0&apos;&lt;= str[i] &amp;&amp; str[i] &lt;= &apos;9&apos;) &#123; result = result*10 + (str[i++]-&apos;0&apos;); if(result*indicator &gt;= INT_MAX) return INT_MAX; if(result*indicator &lt;= INT_MIN) return INT_MIN; &#125; return result*indicator; &#125;&#125; https://discuss.leetcode.com/topic/29207/8-line-c-concise-solution 8 line C++ concise solution 12345678910int myAtoi(string str) &#123; int ret = 0, sign = 1, i = str.find_first_not_of(&apos; &apos;), base = INT_MAX / 10; if (str[i] == &apos;+&apos; || str[i] == &apos;-&apos;) sign = str[i++] == &apos;+&apos; ?: -1; while (isdigit(str[i])) &#123; if (ret &gt; base || (ret == base &amp;&amp; str[i] - &apos;0&apos; &gt; 7)) return sign &gt; 0 ? INT_MAX : INT_MIN; ret = 10 * ret + (str[i++] - &apos;0&apos;); &#125; return sign * ret;&#125; https://discuss.leetcode.com/topic/32966/c-10-lines-solution-easy-understanding-clean-code C++ 10 lines solution, easy understanding, clean code 12345678910111213int myAtoi(string str) &#123; if (str.empty()) return 0; int i = 0, sign = 1; while (i + 1 &lt; str.size() &amp;&amp; isspace(str[i])) ++i; long res = 0; if (str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) sign = 44 - str[i++]; while (i &lt; str.size()) &#123; if (isdigit(str[i])) res = 10 * res + str[i++] - &apos;0&apos;; else return res * sign; if (res &gt; INT_MAX) return sign == -1 ? INT_MIN : INT_MAX; &#125; return res * sign;&#125; python https://discuss.leetcode.com/topic/10740/python-solution-based-on-regex Python solution based on RegEx 123456789101112131415161718class Solution: # @return an integer def atoi(self, str): str = str.strip() str = re.findall(&apos;(^[\+\-0]*\d+)\D*&apos;, str) try: result = int(&apos;&apos;.join(str)) MAX_INT = 2147483647 MIN_INT = -2147483648 if result &gt; MAX_INT &gt; 0: return MAX_INT elif result &lt; MIN_INT &lt; 0: return MIN_INT else: return result except: return 0 https://discuss.leetcode.com/topic/26920/60ms-python-solution-oj-says-this-beats-100-python-submissions 60ms python solution; OJ says this beats 100% python submissions 12345678910111213141516171819class Solution(object): def myAtoi(self, s): &quot;&quot;&quot; :type str: str :rtype: int &quot;&quot;&quot; ###better to do strip before sanity check (although 8ms slower): #ls = list(s.strip()) #if len(ls) == 0 : return 0 if len(s) == 0 : return 0 ls = list(s.strip()) sign = -1 if ls[0] == &apos;-&apos; else 1 if ls[0] in [&apos;-&apos;,&apos;+&apos;] : del ls[0] ret, i = 0, 0 while i &lt; len(ls) and ls[i].isdigit() : ret = ret*10 + ord(ls[i]) - ord(&apos;0&apos;) i += 1 return max(-2**31, min(sign * ret,2**31-1)) java https://discuss.leetcode.com/topic/2666/my-simple-solution My simple solution I think we only need to handle four cases: discards all leading whitespaces sign of the number overflow invalid input Is there any better solution? Thanks for pointing out! 123456789101112131415int atoi(const char *str) &#123; int sign = 1, base = 0, i = 0; while (str[i] == &apos; &apos;) &#123; i++; &#125; if (str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) &#123; sign = 1 - 2 * (str[i++] == &apos;-&apos;); &#125; while (str[i] &gt;= &apos;0&apos; &amp;&amp; str[i] &lt;= &apos;9&apos;) &#123; if (base &gt; INT_MAX / 10 || (base == INT_MAX / 10 &amp;&amp; str[i] - &apos;0&apos; &gt; 7)) &#123; if (sign == 1) return INT_MAX; else return INT_MIN; &#125; base = 10 * base + (str[i++] - &apos;0&apos;); &#125; return base * sign;&#125; https://discuss.leetcode.com/topic/12473/java-solution-with-4-steps-explanations 3ms, August 31, 2016 Java Solution with 4 steps explanations 1234567891011121314151617181920212223242526272829public int myAtoi(String str) &#123; int index = 0, sign = 1, total = 0; //1. Empty string if(str.length() == 0) return 0; //2. Remove Spaces while(str.charAt(index) == &apos; &apos; &amp;&amp; index &lt; str.length()) index ++; //3. Handle signs if(str.charAt(index) == &apos;+&apos; || str.charAt(index) == &apos;-&apos;)&#123; sign = str.charAt(index) == &apos;+&apos; ? 1 : -1; index ++; &#125; //4. Convert number and avoid overflow while(index &lt; str.length())&#123; int digit = str.charAt(index) - &apos;0&apos;; if(digit &lt; 0 || digit &gt; 9) break; //check if total will be overflow after 10 times and add digit if(Integer.MAX_VALUE/10 &lt; total || Integer.MAX_VALUE/10 == total &amp;&amp; Integer.MAX_VALUE %10 &lt; digit) return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; total = 10 * total + digit; index ++; &#125; return total * sign;&#125; https://discuss.leetcode.com/topic/33142/java-easy-version-to-understand JAVA——-Easy Version To Understand!!!!!!!!!! 1234567891011121314151617181920212223242526public static int myAtoi(String str) &#123; if (str == null || str.length() == 0) return 0;// str = str.trim(); char firstChar = str.charAt(0); int sign = 1, start = 0, len = str.length(); long sum = 0; if (firstChar == &apos;+&apos;) &#123; sign = 1; start++; &#125; else if (firstChar == &apos;-&apos;) &#123; sign = -1; start++; &#125; for (int i = start; i &lt; len; i++) &#123; if (!Character.isDigit(str.charAt(i))) return (int) sum * sign; sum = sum * 10 + str.charAt(i) - &apos;0&apos;; if (sign == 1 &amp;&amp; sum &gt; Integer.MAX_VALUE) return Integer.MAX_VALUE; if (sign == -1 &amp;&amp; (-1) * sum &lt; Integer.MIN_VALUE) return Integer.MIN_VALUE; &#125; return (int) sum * sign;&#125; https://discuss.leetcode.com/topic/37311/my-nice-java-code-3ms My Nice Java Code 3ms 123456789101112131415161718192021public class Solution &#123; public int myAtoi(String str) &#123; if (str.isEmpty()) return 0; str = str.trim(); int i = 0, ans = 0, sign = 1, len = str.length(); if (str.charAt(i) == &apos;-&apos; || str.charAt(i) == &apos;+&apos;) sign = str.charAt(i++) == &apos;+&apos; ? 1 : -1; for (; i &lt; len; ++i) &#123; int tmp = str.charAt(i) - &apos;0&apos;; if (tmp &lt; 0 || tmp &gt; 9) break; if (ans &gt; Integer.MAX_VALUE / 10 || (ans == Integer.MAX_VALUE / 10 &amp;&amp; Integer.MAX_VALUE % 10 &lt; tmp)) return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; else ans = ans * 10 + tmp; &#125; return sign * ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>medium</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[007. Reverse Integer]]></title>
    <url>%2Fp%2Ff2b740bb%2F</url>
    <content type="text"><![CDATA[23.8% https://leetcode.com/problems/reverse-integer/ Reverse digits of an integer. 12Example1: x = 123, return 321Example2: x = -123, return -321 click to show spoilers. Have you thought about this? Here are some good questions to ask before coding. Bonus points for you if you have already thought through this! If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100. Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases? For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Update (2014-11-10): Test cases had been added to test the overflow behavior. 如果为负数，是怎么样的情形呢？ 1234567-78 / 10 = -7 -78 % 10 = -8-78 / 100 = 0-78 % 100 = 78-9 / 10 = 0-9 % 10 = -9 方法一： 考虑负数和0的情况 Shortest code possible in c++ long long make res a 64 bit number, the overflow is checked. 1234567891011class Solution &#123;public: int reverse(int x) &#123; long long res = 0; while(x) &#123; res = res*10 + x%10; x /= 10; &#125; return (res&lt;INT_MIN || res&gt;INT_MAX) ? 0 : res; &#125;&#125;; 我的代码实现及注意事项 1234567891011class Solution &#123;public: int reverse(int x) &#123; long long res = 0; // 此处要用long long，因为int会溢出 while(x)&#123; res = res*10 + x%10; x /= 10; &#125; return (res&lt;INT_MIN || res&gt;INT_MAX)?0:res; // 括号最好不要省略，不然可能会出问题 &#125;&#125;; 我的代码实现二: 1234567891011121314class Solution &#123;public: int reverse(int x) &#123; // 用到大数的时候一定要记得用long long // 虽然给的是int，但是我们依然要用long long long long res = 0; while(x!=0)&#123; res = res*10 + x%10; x /= 10; &#125; // 下面最好加括号，以示区分，虽然不要括号也能正确运行 return (res&lt;INT_MIN || res&gt;INT_MAX) ? 0 : res; &#125;&#125;; 方法二： 边走边检查边界 8 ms simple C++ solution which checks overflow 8ms, 49.31%, 17 July 2016 123456789101112131415class Solution &#123;public: int reverse(int x) &#123; int ans = 0; while(x)&#123; int temp = ans * 10 + x % 10; if(temp / 10 != ans) return 0; ans = temp; x /= 10; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/6005/shortest-code-possible-in-c Shortest code possible in c++ long long make res a 64 bit number, the overflow is checked. 1234567891011class Solution &#123;public: int reverse(int x) &#123; long long res = 0; while(x) &#123; res = res*10 + x%10; x /= 10; &#125; return (res&lt;INT_MIN || res&gt;INT_MAX) ? 0 : res; &#125;&#125;; https://discuss.leetcode.com/topic/34506/8-ms-simple-c-solution-which-checks-overflow 8 ms simple C++ solution which checks overflow 8ms, 49.31%, 17 July 2016 123456789101112131415class Solution &#123;public: int reverse(int x) &#123; int ans = 0; while(x)&#123; int temp = ans * 10 + x % 10; if(temp / 10 != ans) return 0; ans = temp; x /= 10; &#125; return ans; &#125;&#125;; python https://discuss.leetcode.com/topic/15832/golfing-in-python Golfing in Python Get the sign, get the reversed absolute integer, and return their product if r didn’t “overflow”. 1234def reverse(self, x): s = cmp(x, 0) r = int(`s*x`[::-1]) return s*r * (r &lt; 2**31) As compressed one-liner, for potential comparison: 12def reverse(self, x): s=cmp(x,0);r=int(`s*x`[::-1]);return(r&lt;2**31)*s*r Anybody got something shorter? 12345678910111268ms, 50.07%, 17 July 2016class Solution(object): def reverse(self, x): &quot;&quot;&quot; :type x: int :rtype: int &quot;&quot;&quot; x = (-1 if x &lt; 0 else 1) * int(str(abs(x))[::-1]) if (x &lt; 2**31 - 1) and (x &gt; -2**31 + 1): return x else: return 0 c https://discuss.leetcode.com/topic/12975/a-simple-c-solution-with-5ms A simple C solution with 5ms 12345678910int reverse(int x) &#123; long long val = 0; do &#123; val = val * 10 + x % 10; x /= 10; &#125; while (x); return (val &gt; INT_MAX || val &lt; INT_MIN) ? 0 : val;&#125; java https://discuss.leetcode.com/topic/6104/my-accepted-15-lines-of-code-for-java My accepted 15 lines of code for Java Only 15 lines. If overflow exists, the new result will not equal previous one. No flags needed. No hard code like 0xf7777777 needed. Sorry for my bad english. 12345678910111213141516public int reverse(int x)&#123; int result = 0; while (x != 0) &#123; int tail = x % 10; int newResult = result * 10 + tail; if ((newResult - tail) / 10 != result) &#123; return 0; &#125; result = newResult; x = x / 10; &#125; return result;&#125; https://discuss.leetcode.com/topic/15134/very-short-7-lines-and-elegant-solution Very Short (7 lines) and Elegant Solution 2ms, 48.43%, 17 July 2016 123456789101112public class Solution &#123; public int reverse(int x) &#123; long rev= 0; while( x != 0)&#123; rev= rev*10 + x % 10; x= x/10; if( rev &gt; Integer.MAX_VALUE || rev &lt; Integer.MIN_VALUE) return 0; &#125; return (int) rev; &#125;&#125; https://discuss.leetcode.com/topic/8941/simple-java-solution-o-n-time-and-o-1-space Simple Java Solution O(N) time and O(1) space. Simply just modulo the input by 10, add it to a long-integer variable as the result. Repeat. When the result is &gt; max integer or &lt; min integer, return 0. Hence, return the result as an integer 123456789101112131415public class Solution &#123; public int reverse(int x) &#123; long result =0; while(x != 0) &#123; result = (result*10) + (x%10); if(result &gt; Integer.MAX_VALUE) return 0; if(result &lt; Integer.MIN_VALUE) return 0; x = x/10; &#125; return (int)result; &#125;&#125; https://discuss.leetcode.com/topic/41683/might-be-helpful-to-you-my-2ms-11-lines-java-solution Might be helpful to you: my 2ms 11 lines Java solution 1234567891011public int reverse(int x) &#123; long result = 0; while (x != 0) &#123; result = result * 10 + x%10; if (result &gt; Integer.MAX_VALUE || result &lt; Integer.MIN_VALUE) &#123; return 0; &#125; x = x / 10; &#125; return (int)result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[006. ZigZag Conversion]]></title>
    <url>%2Fp%2F6cbc5e00%2F</url>
    <content type="text"><![CDATA[26.3% https://leetcode.com/problems/zigzag-conversion/ 123456789101112The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P A H NA P L S I I GY I RAnd then read line by line: &quot;PAHNAPLSIIGYIR&quot;Write the code that will take a string and make this conversion given a number of rows:string convert(string text, int nRows);convert(&quot;PAYPALISHIRING&quot;, 3) should return &quot;PAHNAPLSIIGYIR&quot;. 方法一： 最好的一点是使用了空间，分成了n个组，每个组都是string，最后合并。 https://discuss.leetcode.com/topic/4502/share-simple-c-solution 28ms, 23.79%, August 31, 2016 The problem statement itself is unclear for many. Especially for 2-row case. “ABCD”, 2 –&gt; “ACBD”. The confusion most likely is from the character placement. I would like to extend it a little bit to make ZigZag easy understood. 设了一个数组，每一组代表一行的值，然后将他们串联到一起 The example can be written as follow: P…….A……..H…….N ..A..P….L..S….I…I….G ….Y………I……..R Therefore, &lt;ABCD, 2&gt; can be arranged as: A….C …B….D My simple accepted code: 12345678910111213141516171819202122232425262728class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows &lt;= 1) return s; const int len = (int)s.length(); string *str = new string[numRows]; int row = 0, step=1; for(int i = 0; i &lt; len; ++i)&#123; str[row].push_back(s[i]); if(row==0) step = 1; else if(row == numRows - 1) step = -1; row += step; &#125; s.clear(); for(int j= 0; j &lt; numRows; ++j) s.append(str[j]); delete[] str; return s; &#125;&#125;; 我的代码实现： 可以学习上一段代码中的clear，append，delete函数 123456789101112131415161718192021class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows&lt;=1) return s; // 此处要初始化为v(numRows) vector&lt;string&gt; v(numRows); int pos = 0, flag = 1; for(int i=0; i&lt;s.size(); i++)&#123; v[pos] += s[i]; if(pos==0) flag = 1; else if(pos==numRows-1) flag = -1; pos += flag; &#125; string t = ""; for(int i=0; i&lt;numRows; i++) t.append(v[i]); return t; &#125;&#125;; https://discuss.leetcode.com/topic/22925/if-you-are-confused-with-zigzag-pattern-come-and-see If you are confused with zigzag pattern,come and see! 123456789/*n=numRowsΔ=2n-2 1 2n-1 4n-3Δ= 2 2n-2 2n 4n-4 4n-2Δ= 3 2n-3 2n+1 4n-5 .Δ= . . . . .Δ= . n+2 . 3n .Δ= n-1 n+1 3n-3 3n-1 5n-5Δ=2n-2 n 3n-2 5n-4*/ that’s the zigzag pattern the question asked!Be careful with nR=1 &amp;&amp; nR=2 my 16ms code in c++: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string convert(string s, int numRows) &#123; string result=""; if(numRows==1) return s; int step1,step2; int len=s.size(); for(int i=0;i&lt;numRows;++i)&#123; step1=(numRows-i-1)*2; step2=(i)*2; int pos=i; if(pos&lt;len) result+=s.at(pos); while(1)&#123; pos+=step1; if(pos&gt;=len) break; if(step1) result+=s.at(pos); pos+=step2; if(pos&gt;=len) break; if(step2) result+=s.at(pos); &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/22925/if-you-are-confused-with-zigzag-pattern-come-and-see1234567891011/*n=numRowsΔ=2n-2 1 2n-1 4n-3Δ= 2 2n-2 2n 4n-4 4n-2Δ= 3 2n-3 2n+1 4n-5 .Δ= . . . . .Δ= . n+2 . 3n .Δ= n-1 n+1 3n-3 3n-1 5n-5Δ=2n-2 n 3n-2 5n-4*/that&apos;s the zigzag pattern the question asked!Be careful with nR=1 &amp;&amp; nR=2 my 16ms code in c++: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string convert(string s, int numRows) &#123; string result=&quot;&quot;; if(numRows==1) return s; int step1,step2; int len=s.size(); for(int i=0;i&lt;numRows;++i)&#123; step1=(numRows-i-1)*2; step2=(i)*2; int pos=i; if(pos&lt;len) result+=s.at(pos); while(1)&#123; pos+=step1; if(pos&gt;=len) break; if(step1) result+=s.at(pos); pos+=step2; if(pos&gt;=len) break; if(step2) result+=s.at(pos); &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/21196/a-10-lines-one-pass-o-n-time-o-1-space-accepted-solution-with-detailed-explantation A 10-lines one-pass o(n)-time o(1)-space accepted solution with detailed explantation The distribution of the elements is period. 123P A H NA P L S I I GY I R For example, the following has 4 periods(cycles): 123P | A | H | NA P | L S | I I | GY | I | R | The size of every period is defined as “cycle” 1cycle = (2*nRows - 2), except nRows == 1. In this example, (2*nRows - 2) = 4. In every period, every row has 2 elements, except the first row and the last row. Suppose the current row is i, the index of the first element is j: 1j = i + cycle*k, k = 0, 1, 2, ... The index of the second element is secondJ: 1secondJ = (j - i) + cycle - i (j-i) is the start of current period, (j-i) + cycle is the start of next period. 12345678910111213141516string convert(string s, int nRows) &#123; if(nRows &lt;= 1) return s; string result = &quot;&quot;; //the size of a cycle(period) int cycle = 2 * nRows - 2; for(int i = 0; i &lt; nRows; ++i) &#123; for(int j = i; j &lt; s.length(); j = j + cycle)&#123; result = result + s[j]; int secondJ = (j - i) + cycle - i; if(i != 0 &amp;&amp; i != nRows-1 &amp;&amp; secondJ &lt; s.length()) result = result + s[secondJ]; &#125; &#125; return result; &#125; python https://discuss.leetcode.com/topic/34573/python-o-n-solution-in-96ms-99-43 Python O(n) Solution in 96ms (99.43%) 12345678910111213141516171819202122class Solution(object): def convert(self, s, numRows): &quot;&quot;&quot; :type s: str :type numRows: int :rtype: str &quot;&quot;&quot; if numRows == 1 or numRows &gt;= len(s): return s L = [&apos;&apos;] * numRows index, step = 0, 1 for x in s: L[index] += x if index == 0: step = 1 elif index == numRows -1: step = -1 index += step return &apos;&apos;.join(L) https://discuss.leetcode.com/topic/10330/a-simple-python-solution-97ms-8-lines A simple python solution, 97ms, 8 lines 12345678910111213141516def convert(self, s, nRows): if nRows==1: return s period= 2*(nRows -1) lines=[&quot;&quot; for i in range(nRows)] d=&#123;&#125; # dict remainder:line for i in xrange(period): if i&lt;nRows: d[i]=i else: d[i]=period-i for i in xrange(len(s)): lines[ d[i%period] ] +=s[i] return &quot;&quot;.join(lines) The idea is to use the remainder (index%period) to determine which line the character at the given index will be. The period is calculated first based on nRows. A dictionary with remainder:line as key:value is then created (this can also be done with a list or a tuple). Once these are done, we simply go through s, assign each character to its new line, and then combine these lines to get the converted string. The code can be further shortened to 8 lines by using dict comprehension: 1d=&#123;i:i if i&lt;nRows else (period-i) for i in xrange(period)&#125; 1234567891011def convert(self, s, nRows): if nRows==1: return s period= 2*(nRows -1) lines=[&quot;&quot; for i in range(nRows)] d=&#123;i:i if i&lt;nRows else (period-i) for i in xrange(period)&#125; for i in xrange(len(s)): lines[ d[i%period] ] +=s[i] return &quot;&quot;.join(lines) java https://discuss.leetcode.com/topic/3162/easy-to-understand-java-solution Easy to understand Java solution Create nRows StringBuffers, and keep collecting characters from original string to corresponding StringBuffer. Just take care of your index to keep them in bound. 1234567891011121314151617public String convert(String s, int nRows) &#123; char[] c = s.toCharArray(); int len = c.length; StringBuffer[] sb = new StringBuffer[nRows]; for (int i = 0; i &lt; sb.length; i++) sb[i] = new StringBuffer(); int i = 0; while (i &lt; len) &#123; for (int idx = 0; idx &lt; nRows &amp;&amp; i &lt; len; idx++) // vertically down sb[idx].append(c[i++]); for (int idx = nRows-2; idx &gt;= 1 &amp;&amp; i &lt; len; idx--) // obliquely up sb[idx].append(c[i++]); &#125; for (int idx = 1; idx &lt; sb.length; idx++) sb[0].append(sb[idx]); return sb[0].toString();&#125; https://discuss.leetcode.com/topic/41037/java-solution-easy-and-clear-interesting-approach JAVA solution–easy and clear ( interesting approach ) 12345678910111213141516171819202122public class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows&lt;=1)return s; StringBuilder[] sb=new StringBuilder[numRows]; for(int i=0;i&lt;sb.length;i++)&#123; sb[i]=new StringBuilder(&quot;&quot;); //init every sb element **important step!!!! &#125; int incre=1; int index=0; for(int i=0;i&lt;s.length();i++)&#123; sb[index].append(s.charAt(i)); if(index==0)&#123;incre=1;&#125; if(index==numRows-1)&#123;incre=-1;&#125; index+=incre; &#125; String re=&quot;&quot;; for(int i=0;i&lt;sb.length;i++)&#123; re+=sb[i]; &#125; return re.toString(); &#125;&#125; https://discuss.leetcode.com/topic/3305/two-ways-of-o-n-solutions-one-follows-the-order-of-input-string-and-other-follows-the-order-of-output-string Two ways of O(n) solutions one follows the order of input string and other follows the order of output string Both the algorithms are of O(n) time complexity as every character in the input string is traversed only once.In the first version of algorithm, the output string’s string buffer get populated based on the output string order i.e, string builder gets populated incrementally from 0 to size-1. 12345670 6 12 181 5 7 11 13 17 192 4 8 10 14 16 203 9 15 21 In the above sample case the number of rows is 4, when the first iteration is completed the locations 0,1,2,3 of the string builder gets filled with the locations 0,6,12,18 of the input string it goes on further for other three rows. 123456789101112131415161718192021222324252627282930public class Solution &#123; public String convert(String s, int nRows) &#123; if (nRows == 1) return s; StringBuilder strBuilder = new StringBuilder(); int borderRowStep = 2 * nRows - 2; for (int i = 0; i &lt; nRows; i++) &#123; if (i == 0 || i == nRows - 1) &#123; for (int j = i; j &lt; s.length(); j = j + borderRowStep) &#123; strBuilder.append(s.charAt(j)); &#125; &#125; else &#123; int j = i; boolean flag = true; int insideRowLargeStep = 2 * (nRows - 1 - i); int insideRowSmallStep = borderRowStep - insideRowLargeStep; while (j &lt; s.length()) &#123; strBuilder.append(s.charAt(j)); if (flag) j = j + insideRowLargeStep; else j = j + insideRowSmallStep; flag = !flag; &#125; &#125; &#125; return strBuilder.toString(); &#125;&#125; In the second version of algorithm string buffer is filled in the order of input string i.e, the string buffer gets filled in the zig zag order, when the first iteration of the outer while loop completes the locations 0,5,11,17 in string builder gets filled with the locations 0,1,2,3, from the input string 123456789101112131415161718class Solution&#123;public String convert(String s, int nRows) &#123; char[] c = s.toCharArray(); int len = c.length; StringBuffer[] sb = new StringBuffer[nRows]; for (int z=0; z &lt; sb.length; z++) sb[z] = new StringBuffer(); int k=0; while (k &lt; len) &#123; for (int zigZagIndex = 0; zigZagIndex &lt; nRows &amp;&amp; k &lt; len; zigZagIndex++) // vertically down sb[zigZagIndex].append(c[k++]); for (int zigZagIndex = nRows-2; zigZagIndex &gt;= 1 &amp;&amp; k &lt; len; zigZagIndex--) // obliquely up sb[zigZagIndex].append(c[k++]); &#125; for (int index = 1; index &lt; sb.length; index++) sb[0].append(sb[index]); return sb[0].toString();&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[005. Longest Palindromic Substring]]></title>
    <url>%2Fp%2Fa8573ae4%2F</url>
    <content type="text"><![CDATA[25.0% https://leetcode.com/problems/longest-palindromic-substring/ Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. 1234567Example:Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. 12345Example:Input: &quot;cbbd&quot;Output: &quot;bb&quot; 方法一： 依次遍历，遍历至i时，从i开始向左向右移动，找到最大长度。 12345678910111213141516171819202122232425class Solution &#123; int start, longest;public: string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; for(int i=0; i&lt;n-1; i++)&#123; helper(s, i, i); helper(s, i, i+1); &#125; return s.substr(start, longest); &#125; void helper(string&amp; s, int i, int j)&#123; while(i&gt;=0 &amp;&amp; j&lt;s.size() &amp;&amp; s[i]==s[j])&#123; i--; j++; &#125; if(longest&lt;j-i-1)&#123; start = i+1; longest = j-i-1; &#125; return; &#125;&#125;; 我的代码实现一： 1234567891011121314151617181920212223242526class Solution &#123;public: int head = 0; int l = 0; string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; for(int i=0; i&lt;n-1; i++)&#123; helper(i, i, s); helper(i, i+1, s); &#125; return s.substr(head, l); &#125; void helper(int left, int right, string &amp; s)&#123; int n = s.size(); while(left&gt;=0 &amp;&amp; right&lt;n &amp;&amp; s[left]==s[right])&#123; left--; right++; &#125; if(right-left-1&gt;l)&#123; head = left+1; l = right-left-1; &#125; &#125;&#125;; 我的代码实现二： 12345678910111213141516171819202122232425class Solution &#123;public: string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; int head = 0, d = 0; for(int i=0; i&lt;n-1; i++)&#123; helper(s, i, i, head, d); helper(s, i, i+1, head, d); &#125; return s.substr(head, d); &#125; void helper(string s, int left, int right, int&amp; head, int&amp; d)&#123; while(left&gt;=0 &amp;&amp; right&lt;s.size() &amp;&amp; s[left]==s[right])&#123; left--; right++; &#125; if(right-left-1&gt;d)&#123; head = left+1; d = right-left-1; &#125; return; &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/16317/accepted-4ms-c-solution Accepted 4ms c++ solution. 核心逻辑点： 1 5 5 5 5 6 7 8 遍历到某一个核心如 5 5时，一定要把5全部放中间才是最长的，不然肯定遇见一个不对称的5 然后下一个核心是6，同时当前位置距离末尾小于最长长度时要停止，进一步优化了算法 1234567891011121314151617181920212223class Solution &#123;public: std::string longestPalindrome(std::string s) &#123; if (s.size() &lt; 2) return s; int len = s.size(), max_left = 0, max_len = 1, left, right; for (int start = 0; start &lt; len &amp;&amp; len - start &gt; max_len / 2;) &#123; left = right = start; while (right &lt; len - 1 &amp;&amp; s[right + 1] == s[right]) ++right; start = right + 1; while (right &lt; len - 1 &amp;&amp; left &gt; 0 &amp;&amp; s[right + 1] == s[left - 1]) &#123; ++right; --left; &#125; if (max_len &lt; right - left + 1) &#123; max_left = left; max_len = right - left + 1; &#125; &#125; return s.substr(max_left, max_len); &#125;&#125;; 我的代码实现： 两点优化 3ms，94.75% 123456789101112131415161718192021222324class Solution &#123;public: string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; int head = 0, d = 0; int left = 0, right = 0; for(int i=0; i&lt;n-d/2; )&#123; left = right = i; while(right+1&lt;n &amp;&amp; s[right+1]==s[right]) right++; i = right+1; while(left-1&gt;=0 &amp;&amp; right+1&lt;n &amp;&amp; s[left-1]==s[right+1])&#123; left--; right++; &#125; if(right-left+1&gt;d)&#123; head = left; d = right-left+1; &#125; &#125; return s.substr(head, d); &#125;&#125;; https://discuss.leetcode.com/topic/12187/simple-c-solution-8ms-13-lines Simple C++ solution (8ms, 13 lines) 123456789101112131415string longestPalindrome(string s) &#123; if (s.empty()) return &quot;&quot;; if (s.size() == 1) return s; int min_start = 0, max_len = 1; for (int i = 0; i &lt; s.size();) &#123; if (s.size() - i &lt;= max_len / 2) break; int j = i, k = i; while (k &lt; s.size()-1 &amp;&amp; s[k+1] == s[k]) ++k; // Skip duplicate characters. i = k+1; while (k &lt; s.size()-1 &amp;&amp; j &gt; 0 &amp;&amp; s[k + 1] == s[j - 1]) &#123; ++k; --j; &#125; // Expand. int new_len = k - j + 1; if (new_len &gt; max_len) &#123; min_start = j; max_len = new_len; &#125; &#125; return s.substr(min_start, max_len);&#125; python https://discuss.leetcode.com/topic/7144/python-o-n-2-method-with-some-optimization-88ms 14ms, 79.15%, 23 July 2016 maxLen是长度，i为当前位置，判断，i-maxLen至i之间是否对称 Basic thought is simple. when you increase s by 1 character, you could only increase maxPalindromeLen by 1 or 2, and that new maxPalindrome includes this new character. Proof: if on adding 1 character, maxPalindromeLen increased by 3 or more, say the new maxPalindromeLen is Q, and the old maxPalindromeLen is P, and Q&gt;=P+3. Then it would mean, even without this new character, there would be a palindromic substring ending in the last character, whose length is at least Q-2. Since Q-2 would be &gt;P, this contradicts the condition that P is the maxPalindromeLen without the additional character. So, it becomes simple, you only need to scan from beginning to the end, adding one character at a time, keeping track of maxPalindromeLen, and for each added character, you check if the substrings ending with this new character, with length P+1 or P+2, are palindromes, and update accordingly. Now, this is O(n^2) as taking substrings and checking palindromicity seem O(n) time. We can speed up it by realizing that strings are immutable, and there are memory slicing tricks will help to speed these operations up. comparing string equality with “==” is O(1), and using slicing to substring and reverse is ̶a̶l̶s̶o̶ ̶O̶(̶1̶)̶ ̶(̶n̶o̶t̶ ̶t̶o̶t̶a̶l̶l̶y̶ ̶s̶u̶r̶e̶ ̶a̶b̶o̶u̶t̶ ̶t̶h̶e̶ ̶s̶l̶i̶c̶i̶n̶g̶ ̶t̶h̶o̶u̶g̶h̶.̶ ̶ ̶I̶ ̶t̶h̶i̶n̶k̶ ̶i̶t̶ ̶i̶s̶ ̶O̶(̶1̶)̶,̶ ̶b̶u̶t̶ ̶c̶o̶u̶l̶d̶ ̶n̶o̶t̶ ̶f̶i̶n̶d̶ ̶a̶n̶y̶ ̶s̶o̶l̶i̶d̶ ̶l̶i̶t̶e̶r̶a̶t̶u̶r̶e̶ ̶a̶b̶o̶u̶t̶ ̶i̶t̶.̶ O(n) (thanks to ChuntaoLu). But as slicing is optimized by the interpreter’s C code, it should run pretty fast. I’m pretty new to Python. Would appreciate you would give more insights or further optimization. Thus, here is the O(n) method: 123456789101112131415161718class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; if len(s) == 0: return 0 maxLen = 1 start = 0 for i in xrange(len(s)): if i - maxLen &gt;= 1 and s[i-maxLen - 1: i+1] == s[i - maxLen-1:i+1][::-1]: start = i-maxLen -1 maxLen+= 2 continue if i - maxLen &gt;= 0 and s[i-maxLen:i+1] == s[i-maxLen:i+1][::-1]: start = i - maxLen maxLen += 1 return s[start:start+maxLen] https://discuss.leetcode.com/topic/20844/python-easy-to-understand-solution-with-comments-from-middle-to-two-ends Python easy to understand solution with comments (from middle to two ends). 12345678910111213141516171819def longestPalindrome(self, s): res = &quot;&quot; for i in xrange(len(s)): # odd case, like &quot;aba&quot; tmp = self.helper(s, i, i) if len(tmp) &gt; len(res): res = tmp # even case, like &quot;abba&quot; tmp = self.helper(s, i, i+1) if len(tmp) &gt; len(res): res = tmp return res # get the longest palindrome, l, r are the middle indexes # from inner to outerdef helper(self, s, l, r): while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]: l -= 1; r += 1 return s[l+1:r] java https://discuss.leetcode.com/topic/23498/very-simple-clean-java-solution The performance is pretty good, surprisingly. 12345678910111213141516171819202122232425public class Solution &#123;private int lo, maxLen;public String longestPalindrome(String s) &#123; int len = s.length(); if (len &lt; 2) return s; for (int i = 0; i &lt; len-1; i++) &#123; extendPalindrome(s, i, i); //assume odd length, try to extend Palindrome as possible extendPalindrome(s, i, i+1); //assume even length. &#125; return s.substring(lo, lo + maxLen);&#125;private void extendPalindrome(String s, int j, int k) &#123; while (j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k)) &#123; j--; k++; &#125; if (maxLen &lt; k - j - 1) &#123; lo = j + 1; maxLen = k - j - 1; &#125;&#125;&#125; https://discuss.leetcode.com/topic/21848/ac-relatively-short-and-very-clear-java-solution (AC) relatively short and very clear Java solution Key idea, every time we move to right, we only need to consider whether using this new character as tail could produce new palindrome string of length (current length +1) or (current length +2) 12345678910111213141516171819202122232425public class Solution &#123; public String longestPalindrome(String s) &#123; String res = &quot;&quot;; int currLength = 0; for(int i=0;i&lt;s.length();i++)&#123; if(isPalindrome(s,i-currLength-1,i))&#123; res = s.substring(i-currLength-1,i+1); currLength = currLength+2; &#125; else if(isPalindrome(s,i-currLength,i))&#123; res = s.substring(i-currLength,i+1); currLength = currLength+1; &#125; &#125; return res; &#125; public boolean isPalindrome(String s, int begin, int end)&#123; if(begin&lt;0) return false; while(begin&lt;end)&#123; if(s.charAt(begin++)!=s.charAt(end--)) return false; &#125; return true; &#125;&#125; For friends who are confused about the key idea to check only new palindrome with length = current length +2 or +1, I add some more explanation here. 12345678910Example: &quot;xxxbcbxxxxxa&quot;, (x is random character, not all x are equal) now we are dealing with the last character &apos;a&apos;. The current longest palindrome is &quot;bcb&quot; with length 3.1. check &quot;xxxxa&quot; so if it is palindrome we could get a new palindrome of length 5.2. check &quot;xxxa&quot; so if it is palindrome we could get a new palindrome of length 4.3. do NOT check &quot;xxa&quot; or any shorter string since the length of the new string is no bigger than current longest length.4. do NOT check &quot;xxxxxa&quot; or any longer string because if &quot;xxxxxa&quot; is palindrome then &quot;xxxx&quot; got from cutting off the head and tail is also palindrom. It has length &gt; 3 which is impossible.&apos; https://discuss.leetcode.com/topic/25500/share-my-java-solution-using-dynamic-programming Share my Java solution using dynamic programming dp(i, j) represents whether s(i … j) can form a palindromic substring, dp(i, j) is true when s(i) equals to s(j) and s(i+1 … j-1) is a palindromic substring. When we found a palindrome, check if it’s the longest one. Time complexity O(n^2). 123456789101112131415161718public String longestPalindrome(String s) &#123; int n = s.length(); String res = null; boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i; j &lt; n; j++) &#123; dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; 3 || dp[i + 1][j - 1]); if (dp[i][j] &amp;&amp; (res == null || j - i + 1 &gt; res.length())) &#123; res = s.substring(i, j + 1); &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/23498/very-simple-clean-java-solution 14ms, 79.15%, 23 July 2016 第一遍循环，针对每个索引，开始向两遍扩展，直到不能扩展为止。 123456789101112131415161718192021222324252627public class Solution &#123; private int lo, maxLen; public String longestPalindrome(String s) &#123; int len = s.length(); if(len &lt; 2) return s; for(int i=0; i&lt;len-1;i++)&#123; // assume odd length, try to extend Palindrome as possible extenPalindrome(s, i, i); //assume even length. extenPalindrome(s, i, i+1); &#125; return s.substring(lo, lo + maxLen); &#125; private void extenPalindrome(String s, int j, int k)&#123; while(j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k))&#123; j--; k++; &#125; if(maxLen &lt; k - j - 1)&#123; lo = j + 1; maxLen = k - j - 1; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[004. Median of Two Sorted Arrays]]></title>
    <url>%2Fp%2F82de9929%2F</url>
    <content type="text"><![CDATA[21.0% https://leetcode.com/problems/median-of-two-sorted-arrays/ There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 12345Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0 12345Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 cpp https://discuss.leetcode.com/topic/16797/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation Very concise O(log(min(M,N))) iterative solution with detailed explanation This problem is notoriously hard to implement due to all the corner cases. Most implementations consider odd-lengthed and even-lengthed arrays as two different cases and treat them separately. As a matter of fact, with a little mind twist. These two cases can be combined as one, leading to a very simple solution where (almost) no special treatment is needed. First, let’s see the concept of ‘MEDIAN’ in a slightly unconventional way. That is: 123&quot;if we cut the sorted array to two halves of EQUAL LENGTHS, thenmedian is the AVERAGE OF Max(lower_half) and Min(upper_half), i.e. thetwo numbers immediately next to the cut&quot;. For example, for [2 3 5 7], we make the cut between 3 and 5: 1[2 3 / 5 7] then the median = (3+5)/2. Note that I’ll use ‘/‘ to represent a cut, and (number / number) to represent a cut made through a number in this article. for [2 3 4 5 6], we make the cut right through 4 like this: [2 3 (4/4) 5 7] Since we split 4 into two halves, we say now both the lower and upper subarray contain 4. This notion also leads to the correct answer: (4 + 4) / 2 = 4; For convenience, let’s use L to represent the number immediately left to the cut, and R the right counterpart. In [2 3 5 7], for instance, we have L = 3 and R = 5, respectively. We observe the index of L and R have the following relationship with the length of the array N: 123456789N Index of L / R1 0 / 02 0 / 13 1 / 1 4 1 / 2 5 2 / 26 2 / 37 3 / 38 3 / 4 It is not hard to conclude that index of L = (N-1)/2, and R is at N/2. Thus, the median can be represented as 1(L + R)/2 = (A[(N-1)/2] + A[N/2])/2 To get ready for the two array situation, let’s add a few imaginary ‘positions’ (represented as #’s) in between numbers, and treat numbers as ‘positions’ as well. 12345[6 9 13 18] -&gt; [# 6 # 9 # 13 # 18 #] (N = 4)position index 0 1 2 3 4 5 6 7 8 (N_Position = 9) [6 9 11 13 18]-&gt; [# 6 # 9 # 11 # 13 # 18 #] (N = 5)position index 0 1 2 3 4 5 6 7 8 9 10 (N_Position = 11) As you can see, there are always exactly 2*N+1 ‘positions’ regardless of length N. Therefore, the middle cut should always be made on the Nth position (0-based). Since index(L) = (N-1)/2 and index(R) = N/2 in this situation, we can infer that index(L) = (CutPosition-1)/2, index(R) = (CutPosition)/2. Now for the two-array case: 123A1: [# 1 # 2 # 3 # 4 # 5 #] (N1 = 5, N1_positions = 11)A2: [# 1 # 1 # 1 # 1 #] (N2 = 4, N2_positions = 9) Similar to the one-array problem, we need to find a cut that divides the two arrays each into two halves such that 12&quot;any number in the two left halves&quot; &lt;= &quot;any number in the two righthalves&quot;. We can also make the following observations： There are 2N1 + 2N2 + 2 position altogether. Therefore, there must be exactly N1 + N2 positions on each side of the cut, and 2 positions directly on the cut. Therefore, when we cut at position C2 = K in A2, then the cut position in A1 must be C1 = N1 + N2 - k. For instance, if C2 = 2, then we must have C1 = 4 + 5 - C2 = 7. 123[# 1 # 2 # 3 # (4/4) # 5 #] [# 1 / 1 # 1 # 1 #] When the cuts are made, we’d have two L’s and two R’s. They are L1 = A1[(C1-1)/2]; R1 = A1[C1/2];L2 = A2[(C2-1)/2]; R2 = A2[C2/2];In the above example, 12L1 = A1[(7-1)/2] = A1[3] = 4; R1 = A1[7/2] = A1[3] = 4;L2 = A2[(2-1)/2] = A2[0] = 1; R2 = A1[2/2] = A1[1] = 1; Now how do we decide if this cut is the cut we want? Because L1, L2 are the greatest numbers on the left halves and R1, R2 are the smallest numbers on the right, we only need 1L1 &lt;= R1 &amp;&amp; L1 &lt;= R2 &amp;&amp; L2 &lt;= R1 &amp;&amp; L2 &lt;= R2 to make sure that any number in lower halves &lt;= any number in upper halves. As a matter of fact, sinceL1 &lt;= R1 and L2 &lt;= R2 are naturally guaranteed because A1 and A2 are sorted, we only need to make sure: L1 &lt;= R2 and L2 &lt;= R1. Now we can use simple binary search to find out the result. 12345678If we have L1 &gt; R1, it means there are too many large numbers on the left half of A1, then we must move C1 to the left (i.e. move C2 to the right); If L2 &gt; R1, then there are too many large numbers on the left half of A2, and we must move C2 to the left.Otherwise, this cut is the right one. After we find the cut, the medium can be computed as (max(L1, L2) + min(R1, R2)) / 2; Two side notes: A. since C1 and C2 can be mutually determined from each other, we might as well select the shorter array (say A2) and only move C2 around, and calculate C1 accordingly. That way we can achieve a run-time complexity of O(log(min(N1, N2))) B. The only edge case is when a cut falls on the 0th(first) or the 2Nth(last) position. For instance, if C2 = 2N2, then R2 = A2[2*N2/2] = A2[N2], which exceeds the boundary of the array. To solve this problem, we can imagine that both A1 and A2 actually have two extra elements, INT_MAX at A[-1] and INT_MAX at A[N]. These additions don’t change the result, but make the implementation easier: If any L falls out of the left boundary of the array, then L = INT_MIN, and if any R falls out of the right boundary, then R = INT_MAX. I know that was not very easy to understand, but all the above reasoning eventually boils down to the following concise code: 1234567891011121314151617181920212223double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int N1 = nums1.size(); int N2 = nums2.size(); if (N1 &lt; N2) return findMedianSortedArrays(nums2, nums1); // Make sure A2 is the shorter one. if (N2 == 0) return ((double)nums1[(N1-1)/2] + (double)nums1[N1/2])/2; // If A2 is empty int lo = 0, hi = N2 * 2; while (lo &lt;= hi) &#123; int mid2 = (lo + hi) / 2; // Try Cut 2 int mid1 = N1 + N2 - mid2; // Calculate Cut 1 accordingly double L1 = (mid1 == 0) ? INT_MIN : nums1[(mid1-1)/2]; // Get L1, R1, L2, R2 respectively double L2 = (mid2 == 0) ? INT_MIN : nums2[(mid2-1)/2]; double R1 = (mid1 == N1 * 2) ? INT_MAX : nums1[(mid1)/2]; double R2 = (mid2 == N2 * 2) ? INT_MAX : nums2[(mid2)/2]; if (L1 &gt; R2) lo = mid2 + 1; // A1&apos;s lower half is too big; need to move C1 left (C2 right) else if (L2 &gt; R1) hi = mid2 - 1; // A2&apos;s lower half too big; need to move C2 left. else return (max(L1,L2) + min(R1, R2)) / 2; // Otherwise, that&apos;s the right cut. &#125; return -1;&#125; If you have any suggestions to make the logic and implementation even more cleaner. Please do let me know! https://discuss.leetcode.com/topic/2778/share-my-simple-o-log-m-n-solution-for-your-reference Share my simple O(log(m+n)) solution for your reference Binary search. Call 2 times getkth and k is about half of (m + n). Every time call getkth can reduce the scale k to its half. So the time complexity is log(m + n). 12345678910111213141516171819202122232425class Solution &#123;public: int getkth(int s[], int m, int l[], int n, int k)&#123; // let m &lt;= n if (m &gt; n) return getkth(l, n, s, m, k); if (m == 0) return l[k - 1]; if (k == 1) return min(s[0], l[0]); int i = min(m, k / 2), j = min(n, k / 2); if (s[i - 1] &gt; l[j - 1]) return getkth(s, m, l + j, n - j, k - j); else return getkth(s + i, m - i, l, n, k - i); return 0; &#125; double findMedianSortedArrays(int A[], int m, int B[], int n) &#123; int l = (m + n + 1) &gt;&gt; 1; int r = (m + n + 2) &gt;&gt; 1; return (getkth(A, m ,B, n, l) + getkth(A, m, B, n, r)) / 2.0; &#125;&#125;; https://discuss.leetcode.com/topic/5728/share-one-divide-and-conquer-o-log-m-n-method-with-clear-description Share one divide and conquer O(log(m+n)) method with clear description // using divide and conquer idea, each time find the mid of both arrays 12345678910111213141516171819202122232425262728293031323334353637383940414243double findMedianSortedArrays(int A[], int m, int B[], int n) &#123; /* A[0, 1, 2, ..., n-1, n] */ /* A[0, 1, 2, ..., m-1, m] */ int k = (m + n + 1) / 2; double v = (double)FindKth(A, 0, m - 1, B, 0, n - 1, k); if ((m+n) % 2 == 0) &#123; int k2 = k+1; double v2 = (double)FindKth(A, 0, m - 1, B, 0, n - 1, k2); v = (v + v2) / 2; &#125; return v; &#125; // find the kth element int the two sorted arrays // let us say: A[aMid] &lt;= B[bMid], x: mid len of a, y: mid len of b, then wen can know // // (1) there will be at least (x + 1 + y) elements before bMid // (2) there will be at least (m - x - 1 + n - y) = m + n - (x + y +1) elements after aMid // therefore // if k &lt;= x + y + 1, find the kth element in a and b, but unconsidering bMid and its suffix // if k &gt; x + y + 1, find the k - (x + 1) th element in a and b, but unconsidering aMid and its prefix int FindKth(int A[], int aL, int aR, int B[], int bL, int bR, int k) &#123; if (aL &gt; aR) return B[bL + k - 1]; if (bL &gt; bR) return A[aL + k - 1]; int aMid = (aL + aR) / 2; int bMid = (bL + bR) / 2; if (A[aMid] &lt;= B[bMid]) &#123; if (k &lt;= (aMid - aL) + (bMid - bL) + 1) return FindKth(A, aL, aR, B, bL, bMid - 1, k); else return FindKth(A, aMid + 1, aR, B, bL, bR, k - (aMid - aL) - 1); &#125; else &#123; // A[aMid] &gt; B[bMid] if (k &lt;= (aMid - aL) + (bMid - bL) + 1) return FindKth(A, aL, aMid - 1, B, bL, bR, k); else return FindKth(A, aL, aR, B, bMid + 1, bR, k - (bMid - bL) - 1); &#125; &#125; https://discuss.leetcode.com/topic/11478/o-lg-m-n-c-solution-using-kth-smallest-number O(lg(m+n)) c++ solution using kth smallest number 1234567891011121314151617181920212223class Solution &#123;public: int kth(int a[], int m, int b[], int n, int k) &#123; if (m &lt; n) return kth(b,n,a,m,k); if (n==0) return a[k-1]; if (k==1) return min(a[0],b[0]); int j = min(n,k/2); int i = k-j; if (a[i-1] &gt; b[j-1]) return kth(a,i,b+j,n-j,k-j); return kth(a+i,m-i,b,j,k-i); &#125; double findMedianSortedArrays(int a[], int m, int b[], int n) &#123; int k = (m+n)/2; int m1 = kth(a,m,b,n,k+1); if ((m+n)%2==0) &#123; int m2 = kth(a,m,b,n,k); return ((double)m1+m2)/2.0; &#125; return m1; &#125;&#125;; https://discuss.leetcode.com/topic/26926/another-simple-and-neat-solution-binary-search-non-recursion-3-rows-of-core-code-o-log-min-m-n Another simple and neat solution, binary search, non-recursion, 3 rows of core code, O(log(min(m, n))) If you solve the k-th minmum value of two sorted arrays, you solve this problem.This is a classical problem of “Divide and conquer”. Here is another more simple and more neat solution. Cosider chosing first x numbers from A and k - x numbers from B.if these k numbers are the k minmum numbers of A and B, x must satisfies that A[x + 1] &gt;= B[k - x] and B[k - x + 1] &gt;= A[x] (for better explanation index is base-1). So this x is what we want. Obviously, if A[x + 1] &lt; B[k - x + 1] then x must be smaller, else if B[k - x] &lt; A[x] then x must be greater. A nice two-value definition for binary search :) To simplify edge cases, we cosider each array indefinite, with value of INTMIN when index &lt; 1 and INTMAX when index &gt; n. Here is the solution of c++ version: 12345678910111213141516171819202122232425typedef vector&lt;int&gt; vi;const int inf = 0x7fffffff, ninf = 0x80000000;class Solution &#123; int kth_min(vi&amp; a, vi&amp; b, int k, int n, int m)&#123; #define A(i) (i &lt; 1 ? ninf : (i &gt; n ? inf : a[i - 1])) #define B(i) (i &lt; 1 ? ninf : (i &gt; m ? inf : b[i - 1])) int l = 0, r = n + 1, x; while(l &lt;= r)&#123; x = (l + r) &gt;&gt; 1; if(A(x) &gt; B(k - x + 1)) r = x - 1; else if(B(k - x) &gt; A(x + 1)) l = x + 1; else return max(A(x), B(k - x)); &#125; return 0; //never execute , just to hide the warning :) #undef A #undef B &#125;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123; int n = a.size(), m = b.size(); if(n &gt; m) return findMedianSortedArrays(b, a); //make sure that a.size() &lt;= b.size() if((m + n) &amp; 1) return kth_min(a, b, (m + n + 1) &gt;&gt; 1, n, m); return (0.0 + kth_min(a, b, (m + n + 1) &gt;&gt; 1, n, m) + kth_min(a, b, ((m + n) &gt;&gt; 1) + 1, n, m)) * 0.5; &#125;&#125;; python https://discuss.leetcode.com/topic/4996/share-my-o-log-min-m-n-solution-with-explanation To solve this problem, we need to understand “What is the use of median”. In statistics, the median is used for dividing a set into two equal length subsets, that one subset is always greater than the other. If we understand the use of median for dividing, we are very close to the answer.1234First let&apos;s cut A into two parts at a random position i: left_A | right_AA[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] Since A has m elements, so there are m+1 kinds of cutting( i = 0 ~ m ). And we know: len(left_A) = i, len(right_A) = m - i . Note: when i = 0 , left_A is empty, and when i = m , right_A is empty.1234With the same way, cut B into two parts at a random position j: left_B | right_BB[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] Put left_A and left_B into one set, and put right_A and right_B into another set.1234Let&apos;s name them left_part and right_part : left_part | right_partA[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1]B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] If we can ensure:121) len(left_part) == len(right_part)2) max(left_part) &lt;= min(right_part) then we divide all elements in {A, B} into two parts with equal length, and one part is always greater than the other. Then median = (max(left_part) + min(right_part))/2. To ensure these two conditions, we just need to ensure:123(1) i + j == m - i + n - j (or: m - i + n - j + 1) if n &gt;= m, we just need to set: i = 0 ~ m, j = (m + n + 1)/2 - i(2) B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j] (For simplicity, I presume A[i-1],B[j-1],A[i],B[j] are always valid even if i=0/i=m/j=0/j=n . I will talk about how to deal with these edge values at last.) So, all we need to do is:12Searching i in [0, m], to find an object `i` that: B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j], ( where j = (m + n + 1)/2 - i ) And we can do a binary search following steps described below:123456789101112131415161718192021222324&lt;1&gt; Set imin = 0, imax = m, then start searching in [imin, imax]&lt;2&gt; Set i = (imin + imax)/2, j = (m + n + 1)/2 - i&lt;3&gt; Now we have len(left_part)==len(right_part). And there are only 3 situations that we may encounter: &lt;a&gt; B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j] Means we have found the object `i`, so stop searching. &lt;b&gt; B[j-1] &gt; A[i] Means A[i] is too small. We must `ajust` i to get `B[j-1] &lt;= A[i]`. Can we `increase` i? Yes. Because when i is increased, j will be decreased. So B[j-1] is decreased and A[i] is increased, and `B[j-1] &lt;= A[i]` may be satisfied. Can we `decrease` i? `No!` Because when i is decreased, j will be increased. So B[j-1] is increased and A[i] is decreased, and B[j-1] &lt;= A[i] will be never satisfied. So we must `increase` i. That is, we must ajust the searching range to [i+1, imax]. So, set imin = i+1, and goto &lt;2&gt;. &lt;c&gt; A[i-1] &gt; B[j] Means A[i-1] is too big. And we must `decrease` i to get `A[i-1]&lt;=B[j]`. That is, we must ajust the searching range to [imin, i-1]. So, set imax = i-1, and goto &lt;2&gt;. When the object i is found, the median is:12max(A[i-1], B[j-1]) (when m + n is odd) 注释 odd 奇数or (max(A[i-1], B[j-1]) + min(A[i], B[j]))/2 (when m + n is even) Now let’s consider the edges values i=0,i=m,j=0,j=n where A[i-1],B[j-1],A[i],B[j] may not exist. Actually this situation is easier than you think. What we need to do is ensuring that max(left_part) &lt;= min(right_part). So, if i and j are not edges values(means A[i-1],B[j-1],A[i],B[j] all exist), then we must check both B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]. But if some of A[i-1],B[j-1],A[i],B[j] don’t exist, then we don’t need to check one(or both) of these two conditions. For example, if i=0, then A[i-1] doesn’t exist, then we don’t need to check A[i-1] &lt;= B[j]. So, what we need to do is:123456789101112131415Searching i in [0, m], to find an object `i` that: (j == 0 or i == m or B[j-1] &lt;= A[i]) and (i == 0 or j == n or A[i-1] &lt;= B[j]) where j = (m + n + 1)/2 - iAnd in a searching loop, we will encounter only three situations:&lt;a&gt; (j == 0 or i == m or B[j-1] &lt;= A[i]) and (i == 0 or j = n or A[i-1] &lt;= B[j]) Means i is perfect, we can stop searching.&lt;b&gt; j &gt; 0 and i &lt; m and B[j - 1] &gt; A[i] Means i is too small, we must increase it.&lt;c&gt; i &gt; 0 and j &lt; n and A[i - 1] &gt; B[j] Means i is too big, we must decrease it. Thank @Quentin.chen , him pointed out that: i &lt; m ==&gt; j &gt; 0 and i &gt; 0 ==&gt; j &lt; n . Because:12m &lt;= n, i &lt; m ==&gt; j = (m+n+1)/2 - i &gt; (m+n+1)/2 - m &gt;= (2*m+1)/2 - m &gt;= 0 m &lt;= n, i &gt; 0 ==&gt; j = (m+n+1)/2 - i &lt; (m+n+1)/2 &lt;= (2*n+1)/2 &lt;= n So in situation and , we don’t need to check whether j &gt; 0 and whether j &lt; n. Below is the accepted code:1234567891011121314151617181920212223242526272829303132def median(A, B): m, n = len(A), len(B) if m &gt; n: A, B, m, n = B, A, n, m if n == 0: raise ValueError imin, imax, half_len = 0, m, (m + n + 1) / 2 while imin &lt;= imax: i = (imin + imax) / 2 j = half_len - i if i &lt; m and B[j-1] &gt; A[i]: # i is too small, must increase it imin = i + 1 elif i &gt; 0 and A[i-1] &gt; B[j]: # i is too big, must decrease it imax = i - 1 else: # i is perfect if i == 0: max_of_left = B[j-1] elif j == 0: max_of_left = A[i-1] else: max_of_left = max(A[i-1], B[j-1]) if (m + n) % 2 == 1: return max_of_left if i == m: min_of_right = B[j] elif j == n: min_of_right = A[i] else: min_of_right = min(A[i], B[j]) return (max_of_left + min_of_right) / 2.0 https://leetcode.com/discuss/15790/share-my-o-log-min-m-n-solution-with-explanation 120ms, 86.12%, June.25th, 2016 12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def findMedianSortedArrays(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: float &quot;&quot;&quot; m, n = len(nums1), len(nums2) if m &gt; n: nums1, nums2, m, n = nums2, nums1, n, m if n == 0: raise ValueError imin, imax, half_len = 0, m, (m + n + 1) / 2 while imin &lt;= imax: i = (imin + imax) / 2 j = half_len - i if j &gt; 0 and i &lt; m and nums2[j-1] &gt; nums1[i]: # i is too small, must increase it imin = i + 1 elif i &gt; 0 and j &lt; n and nums1[i-1] &gt; nums2[j]: # i is too big, must decrease it imax = i - 1 else: # i is perfect if i == 0: max_of_left = nums2[j-1] elif j == 0: max_of_left = nums1[i-1] else: max_of_left = max(nums1[i-1], nums2[j-1]) if (m + n) % 2 == 1: return max_of_left if i == m: min_of_right = nums2[j] elif j == n: min_of_right = nums1[i] else: min_of_right = min(nums1[i], nums2[j]) return (max_of_left + min_of_right) / 2.0 https://leetcode.com/discuss/20897/intuitive-python-solution-smallest-two-sorted-arrays-252ms Intuitive Python O(log (m+n)) solution, by kth smallest in the two sorted arrays, 252ms 144ms, 30.79%, June.25th, 2016 The idea is in the comment: 12345678910111213141516171819202122232425262728293031class Solution(object): def findMedianSortedArrays(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: float &quot;&quot;&quot; l = len(nums1) + len(nums2) if l % 2 == 1: return self.kth(nums1, nums2, l // 2) else: return (self.kth(nums1, nums2, l // 2) + self.kth(nums1, nums2, l // 2 - 1)) / 2. def kth(self, a, b, k): if not a: return b[k] if not b: return a[k] ia, ib = len(a) // 2, len(b) // 2 ma, mb = a[ia], b[ib] if ia + ib &lt; k: if ma &gt; mb: return self.kth(a, b[ib + 1:], k - ib - 1) else: return self.kth(a[ia + 1:], b, k -ia - 1) else: if ma &gt; mb: return self.kth(a[:ia], b, k) else: return self.kth(a, b[:ib], k) https://discuss.leetcode.com/topic/22406/python-o-log-min-m-n-solution Python O(log(min(m,n)) solution It’s guaranteed to be O(log(min(m,n)) because every time the findKth function cuts the shorter array by half of its size. 123456789101112131415161718192021class Solution: # @return a float def findMedianSortedArrays(self, A, B): l=len(A)+len(B) return self.findKth(A,B,l//2) if l%2==1 else (self.findKth(A,B,l//2-1)+self.findKth(A,B,l//2))/2.0 def findKth(self,A,B,k): if len(A)&gt;len(B): A,B=B,A if not A: return B[k] if k==len(A)+len(B)-1: return max(A[-1],B[-1]) i=len(A)//2 j=k-i if A[i]&gt;B[j]: #Here I assume it is O(1) to get A[:i] and B[j:]. In python, it&apos;s not but in cpp it is. return self.findKth(A[:i],B[j:],i) else: return self.findKth(A[i:],B[:j],j) java https://discuss.leetcode.com/topic/3367/share-my-iterative-solution-with-o-log-min-n-m Share my iterative solution with O(log(min(n, m))) This is my iterative solution using binary search. The main idea is to find the approximate location of the median and compare the elements around it to get the final result. do binary search. suppose the shorter list is A with length n. the runtime is O(log(n)) which means no matter how large B array is, it only depends on the size of A. It makes sense because if A has only one element while B has 100 elements, the median must be one of A[0], B[49], and B[50] without check everything else. If A[0] &lt;= B[49], B[49] is the answer; if B[49] &lt; A[0] &lt;= B[50], A[0] is the answer; else, B[50] is the answer. After binary search, we get the approximate location of median. Now we just need to compare at most 4 elements to find the answer. This step is O(1). the same solution can be applied to find kth element of 2 sorted arrays. Here is the code: 123456789101112131415161718192021222324252627282930313233343536public double findMedianSortedArrays(int A[], int B[]) &#123;int n = A.length;int m = B.length;// the following call is to make sure len(A) &lt;= len(B).// yes, it calls itself, but at most once, shouldn&apos;t be// consider a recursive solutionif (n &gt; m) return findMedianSortedArrays(B, A);// now, do binary searchint k = (n + m - 1) / 2;int l = 0, r = Math.min(k, n); // r is n, NOT n-1, this is important!!while (l &lt; r) &#123; int midA = (l + r) / 2; int midB = k - midA; if (A[midA] &lt; B[midB]) l = midA + 1; else r = midA;&#125;// after binary search, we almost get the median because it must be between// these 4 numbers: A[l-1], A[l], B[k-l], and B[k-l+1] // if (n+m) is odd, the median is the larger one between A[l-1] and B[k-l].// and there are some corner cases we need to take care of.int a = Math.max(l &gt; 0 ? A[l - 1] : Integer.MIN_VALUE, k - l &gt;= 0 ? B[k - l] : Integer.MIN_VALUE);if (((n + m) &amp; 1) == 1) return (double) a;// if (n+m) is even, the median can be calculated by // median = (max(A[l-1], B[k-l]) + min(A[l], B[k-l+1]) / 2.0// also, there are some corner cases to take care of.int b = Math.min(l &lt; n ? A[l] : Integer.MAX_VALUE, k - l + 1 &lt; m ? B[k - l + 1] : Integer.MAX_VALUE);return (a + b) / 2.0;&#125; I’m lazy to type. But I found a very good pdf to explain my algorithm: http://ocw.alfaisal.edu/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/30C68118-E436-4FE3-8C79-6BAFBB07D935/0/ps9sol.pdf BTW: Thanks to xdxiaoxin. I’ve removed the check “midB &gt; k”. https://discuss.leetcode.com/topic/28602/concise-java-solution-based-on-binary-search Concise JAVA solution based on Binary Search Explanation The key point of this problem is to ignore half part of A and B each step recursively by comparing the median of remaining A and B: 123if (aMid &lt; bMid) Keep [aRight + bLeft]else Keep [bRight + aLeft] As the following: time=O(log(m + n)) 123456789101112131415161718192021public double findMedianSortedArrays(int[] A, int[] B) &#123; int m = A.length, n = B.length; int l = (m + n + 1) / 2; int r = (m + n + 2) / 2; return (getkth(A, 0, B, 0, l) + getkth(A, 0, B, 0, r)) / 2.0; &#125;public double getkth(int[] A, int aStart, int[] B, int bStart, int k) &#123; if (aStart &gt; A.length - 1) return B[bStart + k - 1]; if (bStart &gt; B.length - 1) return A[aStart + k - 1]; if (k == 1) return Math.min(A[aStart], B[bStart]); int aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE; if (aStart + k/2 - 1 &lt; A.length) aMid = A[aStart + k/2 - 1]; if (bStart + k/2 - 1 &lt; B.length) bMid = B[bStart + k/2 - 1]; if (aMid &lt; bMid) return getkth(A, aStart + k/2, B, bStart, k - k/2);// Check: aRight + bLeft else return getkth(A, aStart, B, bStart + k/2, k - k/2);// Check: bRight + aLeft&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>divide and conquer</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[003. Longest Substring Without Repeating Characters]]></title>
    <url>%2Fp%2Ff34c3115%2F</url>
    <content type="text"><![CDATA[23.9% https://leetcode.com/problems/longest-substring-without-repeating-characters/ Given a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. leetcode 3 leetcode 76 leetcode 159 相似，模板相似，学习一下 方法一： 使用哈希表维护值和值的index 方法二： 既然是对数字的哈希，不如使用数组来的方便。 我的代码实现一： 实现效果最好。 最开始index都指向-1，指向开始索引的前一个位置，就是-1。 然后start就是指向索引的前一个位置。 一个end从0开始遍历至最后，start指向前一个位置。 更新时，先更新start，然后是length，最后更新索引，end++。 1234567891011121314151617class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.size(); if(n&lt;=1) return n; vector&lt;int&gt; indexs(256, -1); int start = -1, end = 0, length=0; while(end &lt; n)&#123; start = max(start, indexs[s[end]]); length = max(length, end-start); indexs[s[end]] = end; end++; &#125; return length; &#125;&#125;; 我的代码实现二： 实现逻辑清晰，但是不如上面代码。 字符要用256位，不要用26位。 12345678910111213141516171819class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int res = 0; int start = 0; vector&lt;int&gt; v(256, -1); for(int i=0; i&lt;s.size(); i++)&#123; if(v[s[i]]!=-1)&#123; start = max(start, v[s[i]]+1); res = max(res, i-start+1); v[s[i]] = i; &#125;else&#123; res = max(res, i-start+1); v[s[i]] = i; &#125; &#125; return res; &#125;&#125;; 我的代码实现: 123456789101112131415class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; indexs(256, -1); int length = 0, start = -1, end = 0; int n = s.size(); while(end&lt;n)&#123; start = max(start, indexs[s[end]]); length = max(length, end-start); indexs[s[end]] = end; end++; &#125; return length; &#125;&#125;; code 1： https://discuss.leetcode.com/topic/4083/shortest-o-n-dp-solution-with-explanations Shortest O(n) DP solution with explanations 12345678910111213141516171819202122232425262728293031323334/** * Solution (DP, O(n)): * * Assume L[i] = s[m...i], denotes the longest substring without repeating * characters that ends up at s[i], and we keep a hashmap for every * characters between m ... i, while storing &lt;character, index&gt; in the * hashmap. * We know that each character will appear only once. * Then to find s[i+1]: * 1) if s[i+1] does not appear in hashmap * we can just add s[i+1] to hash map. and L[i+1] = s[m...i+1] * 2) if s[i+1] exists in hashmap, and the hashmap value (the index) is k * let m = max(m, k), then L[i+1] = s[m...i+1], we also need to update * entry in hashmap to mark the latest occurency of s[i+1]. * * Since we scan the string for only once, and the &apos;m&apos; will also move from * beginning to end for at most once. Overall complexity is O(n). * * If characters are all in ASCII, we could use array to mimic hashmap. */int lengthOfLongestSubstring(string s) &#123; // for ASCII char sequence, use this as a hashmap vector&lt;int&gt; charIndex(256, -1); int longest = 0, m = 0; for (int i = 0; i &lt; s.length(); i++) &#123; m = max(charIndex[s[i]] + 1, m); // automatically takes care of -1 case charIndex[s[i]] = i; longest = max(longest, i - m + 1); &#125; return longest;&#125; code 2： start 表示最长字符串起始的位置。 i表示终止的位置，或者说当前到达的位置。 1234567891011121314class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; dict(256, -1); int maxLen = 0, start = -1; for (int i = 0; i != s.length(); i++) &#123; if (dict[s[i]] &gt; start) start = dict[s[i]]; dict[s[i]] = i; maxLen = max(maxLen, i - start); &#125; return maxLen; &#125;&#125;; 方法三： 我的代码实现： 12345678910111213141516171819202122class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int start = 0, length = 0, end = 0, cnt = 0; vector&lt;int&gt; v(256, 0); int n = s.size(); while(end&lt;n)&#123; if(v[s[end]]==1) cnt++; v[s[end]]++; end++; while(cnt&gt;0)&#123; if(v[s[start]]==2) cnt--; v[s[start]]--; start++; &#125; length = max(length, end-start); &#125; return length; &#125;&#125;; 有模板的，下面是详情 12345678910int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; map(128,0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++&gt;0) counter++; while(counter&gt;0) if(map[s[begin++]]--&gt;1) counter--; d=max(d, end-begin); //while valid, update d &#125; return d; &#125; 我的代码实现一： 1234567891011121314151617181920212223class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.size(); if(n&lt;=1) return n; vector&lt;int&gt; indexs(256, 0); int left = 0, right = 0, counter = 0, length = 0; while(right&lt;n)&#123; if(indexs[s[right]]&gt;0) counter++; indexs[s[right]]++; right++; while(counter&gt;0)&#123; if(indexs[s[left]]&gt;1) counter--; indexs[s[left]]--; left++; &#125; length = max(length, right-left); &#125; return length; &#125;&#125;; 我的代码实现二： 1234567891011121314151617181920212223class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; if(s.empty()) return 0; int head = 0, end = 0, d = 0, cnt = 0; vector&lt;int&gt; v(256, 0); while(end &lt; s.size())&#123; if(v[s[end]]!=0) cnt++; v[s[end]]++; end++; while(cnt&gt;0)&#123; if(v[s[head]]&gt;1) cnt--; v[s[head]]--; head++; &#125; d = max(d, end - head); &#125; return d; &#125;&#125;; 学习区： https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems I will first give the solution then show you the magic template. The code of solving this problem is below. It might be the shortest among all solutions provided in Discuss. Minimum Window Substring 12345678910111213string minWindow(string s, string t) &#123; vector&lt;int&gt; map(128,0); for(auto c: t) map[c]++; int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0; while(end&lt;s.size())&#123; if(map[s[end++]]--&gt;0) counter--; //in t while(counter==0)&#123; //valid if(end-begin&lt;d) d=end-(head=begin); if(map[s[begin++]]++==0) counter++; //make it invalid &#125; &#125; return d==INT_MAX? &quot;&quot;:s.substr(head, d); &#125; Here comes the template. For most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers. The template is given below. 12345678910111213141516171819202122232425int findSubstring(string s)&#123; vector&lt;int&gt; map(128,0); int counter; // check whether the substring is valid int begin=0, end=0; //two pointers, one point to tail and one head int d; //the length of substring for() &#123; /* initialize the hash map here */ &#125; while(end&lt;s.size())&#123; if(map[s[end++]]-- ?)&#123; /* modify counter here */ &#125; while(/* counter condition */)&#123; /* update d here if finding minimum*/ //increase begin to make it invalid/valid again if(map[s[begin++]]++ ?)&#123; /*modify counter here*/ &#125; &#125; /* update d here if finding maximum*/ &#125; return d; &#125; One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop. The code of solving Longest Substring with At Most Two Distinct Characters is below: 12345678910int lengthOfLongestSubstringTwoDistinct(string s) &#123; vector&lt;int&gt; map(128, 0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++==0) counter++; while(counter&gt;2) if(map[s[begin++]]--==1) counter--; d=max(d, end-begin); &#125; return d; &#125; The code of solving Longest Substring Without Repeating Characters is below: Update 01.04.2016, thanks @weiyi3 for advise. 12345678910int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; map(128,0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++&gt;0) counter++; while(counter&gt;0) if(map[s[begin++]]--&gt;1) counter--; d=max(d, end-begin); //while valid, update d &#125; return d; &#125; I think this post deserves some upvotes! : ) https://discuss.leetcode.com/topic/24739/c-code-in-9-lines 16ms, 62.39%, 23 July 2016 1234567891011121314class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; dict(256, -1); int maxLen = 0, start = -1; for (int i = 0; i != s.length(); i++) &#123; if (dict[s[i]] &gt; start) start = dict[s[i]]; dict[s[i]] = i; maxLen = max(maxLen, i - start); &#125; return maxLen; &#125;&#125;; https://discuss.leetcode.com/topic/1914/my-o-n-solution My O(n) Solution if only use DP, it’s an O(n*n) solution, adding a map to get O(n). 1234567891011121314151617181920class Solution &#123; public: int lengthOfLongestSubstring(string s) &#123; if(s.size()&lt;2) return s.size(); int d=1, maxLen=1; unordered_map&lt;char,int&gt; map; map[s[0]]=0; for(int i=1;i&lt;s.size();i++) &#123; if(map.count(s[i])==0 || map[s[i]]&lt;i-d) d++; else d= i- map[s[i]]; map[s[i]]=i; if(d&gt;maxLen) maxLen = d; &#125; return maxLen; &#125; &#125;; python https://discuss.leetcode.com/topic/11632/a-python-solution-85ms-o-n 104ms, 84.17%, 23 July 2016 1234567891011121314151617class Solution(object): def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; start = maxLength = 0 usedChar = &#123;&#125; for i in range(len(s)): if s[i] in usedChar and start &lt;= usedChar[s[i]]: start = usedChar[s[i]] + 1 else: maxLength = max(maxLength, i - start + 1) usedChar[s[i]] = i return maxLength java https://discuss.leetcode.com/topic/8232/11-line-simple-java-solution-o-n-with-explanation 11-line simple Java solution, O(n) with explanation the basic idea is, keep a hashmap which stores the characters in string as keys and their positions as values, and keep two pointers which define the max substring. move the right pointer to scan through the string , and meanwhile update the hashmap. If the character is already in the hashmap, then move the left pointer to the right of the same character last found. Note that the two pointers can only move forward. 12345678910111213public int lengthOfLongestSubstring(String s) &#123; if (s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max=0; for (int i=0, j=0; i&lt;s.length(); ++i)&#123; if (map.containsKey(s.charAt(i)))&#123; j = Math.max(j,map.get(s.charAt(i))+1); &#125; map.put(s.charAt(i),i); max = Math.max(max,i-j+1); &#125; return max;&#125; https://discuss.leetcode.com/topic/25499/share-my-java-solution-using-hashset Share my Java solution using HashSet The idea is use a hash set to track the longest substring without repeating characters so far, use a fast pointer j to see if character j is in the hash set or not, if not, great, add it to the hash set, move j forward and update the max length, otherwise, delete from the head by using a slow pointer i until we can put character j to the hash set. 123456789101112131415public int lengthOfLongestSubstring(String s) &#123; int i = 0, j = 0, max = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); while (j &lt; s.length()) &#123; if (!set.contains(s.charAt(j))) &#123; set.add(s.charAt(j++)); max = Math.max(max, set.size()); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return max;&#125; https://leetcode.com/articles/longest-substring-without-repeating-characters/ 思路：双指针，j在前，i在后，如果s[j]不包含，则添加进哈希表，如果包含，则去掉i，i向后走。123456789101112131415161718public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int ans = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) &#123; // try to extend the range [i, j] if (!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans, j - i); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return ans; &#125;&#125; 思路：建立map，不仅存字符还存字符的位置 123456789101112131415public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) &#123; if (map.containsKey(s.charAt(j))) &#123; i = Math.max(map.get(s.charAt(j)), i); &#125; ans = Math.max(ans, j - i + 1); map.put(s.charAt(j), j + 1); &#125; return ans; &#125;&#125; 与上一段代码思路相同 一个是length为0，return 0，检查特殊情况。 一个是做一个hashmap，存入获取的操作要好好看看。 22ms, 31.97%, 23 July 2016 https://discuss.leetcode.com/topic/8232/11-line-simple-java-solution-o-n-with-explanation/11234567891011121314public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max = 0; for(int i=0, j=0; i &lt; s.length(); ++i)&#123; if(map.containsKey(s.charAt(i))) j = Math.max(j, map.get(s.charAt(i))+1); map.put(s.charAt(i), i); max = Math.max(max, i-j+1); &#125; return max; &#125;&#125; The previous implements all have no assumption on the charset of the string s. If we know that the charset is rather small, we can replace the Map with an integer array as direct access table. Commonly used tables are: 123int[26] for Letters &apos;a&apos; - &apos;z&apos; or &apos;A&apos; - &apos;Z&apos;int[128] for ASCIIint[256] for Extended ASCII 12345678910111213public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; int[] index = new int[128]; // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) &#123; i = Math.max(index[s.charAt(j)], i); ans = Math.max(ans, j - i + 1); index[s.charAt(j)] = j + 1; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[002. Add Two Numbers]]></title>
    <url>%2Fp%2F7dbbe8ef%2F</url>
    <content type="text"><![CDATA[26.7% https://leetcode.com/problems/add-two-numbers/ You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. 12Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 方法一： 12345678910111213141516class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while(l1 || l2 || extra)&#123; int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + extra; extra = sum / 10; p-&gt;next = new ListNode(sum % 10); p = p-&gt;next; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; &#125; return preHead.next; &#125;&#125;; How about this? 123456789101112ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while (l1 || l2 || extra) &#123; if (l1) extra += l1-&gt;val, l1 = l1-&gt;next; if (l2) extra += l2-&gt;val, l2 = l2-&gt;next; p-&gt;next = new ListNode(extra % 10); extra /= 10; p = p-&gt;next; &#125; return preHead.next;&#125; 我的代码实现一： 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; if(!l1) return l2; else if(!l2) return l1; int carry = 0; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 || l2 || carry)&#123; carry += l1 ? l1-&gt;val : 0; carry += l2 ? l2-&gt;val : 0; cur-&gt;next = new ListNode(carry%10); cur = cur-&gt;next; carry /= 10; l1 = l1 ? l1-&gt;next : 0; l2 = l2 ? l2-&gt;next : 0; &#125; return dummy-&gt;next; &#125;&#125;; 我的代码实现二： 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); int carry = 0; ListNode* cur = dummy; while(l1 || l2 || carry)&#123; carry += l1 ? l1-&gt;val : 0; carry += l2 ? l2-&gt;val : 0; cur-&gt;next = new ListNode(carry%10); carry /= 10; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; cur = cur-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/5905/c-sharing-my-11-line-c-solution-can-someone-make-it-even-more-concise 40ms, 24.98%, 17 July 2016 12345678910111213141516class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while(l1 || l2 || extra)&#123; int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + extra; extra = sum / 10; p-&gt;next = new ListNode(sum % 10); p = p-&gt;next; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; &#125; return preHead.next; &#125;&#125;; https://discuss.leetcode.com/topic/5905/c-sharing-my-11-line-c-solution-can-someone-make-it-even-more-concise/4 How about this? 123456789101112ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while (l1 || l2 || extra) &#123; if (l1) extra += l1-&gt;val, l1 = l1-&gt;next; if (l2) extra += l2-&gt;val, l2 = l2-&gt;next; p-&gt;next = new ListNode(extra % 10); extra /= 10; p = p-&gt;next; &#125; return preHead.next;&#125; python https://discuss.leetcode.com/topic/21192/python-concise-solution 188ms, 7.15%, 17 July 2016 Python concise solution. 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; dummy = cur = ListNode(0) carry = 0 while l1 or l2 or carry: if l1: carry += l1.val l1 = l1.next if l2: carry += l2.val l2 = l2.next cur.next = ListNode(carry%10) cur = cur.next carry //= 10 return dummy.next https://discuss.leetcode.com/topic/8909/clear-python-code-straight-forward 172ms, 15.49%, 17 July 2016 Clear python code, straight forward 123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; carry = 0 root = n = ListNode(0) while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry, 10) n.next = ListNode(val) n = n.next return root.next https://discuss.leetcode.com/topic/8909/clear-python-code-straight-forward 1234567891011121314151617class Solution:# @return a ListNodedef addTwoNumbers(self, l1, l2): carry = 0 root = n = ListNode(0) while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry, 10) n.next = ListNode(val) n = n.next return root.next https://discuss.leetcode.com/topic/14575/python-for-the-win Python for the win Python supports arbitrarily large integers, so I can safely turn the two lists into ints, add them, and turn the sum into a list. 12345678910class Solution: def addTwoNumbers(self, l1, l2): def toint(node): return node.val + 10 * toint(node.next) if node else 0 def tolist(n): node = ListNode(n % 10) if n &gt; 9: node.next = tolist(n / 10) return node return tolist(toint(l1) + toint(l2)) Iterative tolist instead of recursive: 12345678910class Solution: def addTwoNumbers(self, l1, l2): def toint(node): return node.val + 10 * toint(node.next) if node else 0 n = toint(l1) + toint(l2) first = last = ListNode(n % 10) while n &gt; 9: n /= 10 last.next = last = ListNode(n % 10) return first And a very different solution that could sum arbitrarily many addends, not just two: 1234567891011class Solution: def addTwoNumbers(self, l1, l2): addends = l1, l2 dummy = end = ListNode(0) carry = 0 while addends or carry: carry += sum(a.val for a in addends) addends = [a.next for a in addends if a.next] end.next = end = ListNode(carry % 10) carry /= 10 return dummy.next java https://leetcode.com/articles/add-two-numbers/ Time complexity : O(\max(m, n))O(max(m,n)). Assume that mm and nn represents the length of l1l1 and l2l2 respectively, the algorithm above iterates at most \max(m, n)max(m,n) times. Space complexity : O(\max(m, n))O(max(m,n)). The length of the new list is at most \max(m,n) + 1max(m,n)+1. 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next; &#125;&#125; 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode c1 = l1; ListNode c2 = l2; ListNode sentinel = new ListNode(0); ListNode d = sentinel; int sum = 0; while (c1 != null || c2 != null) &#123; sum /= 10; if (c1 != null) &#123; sum += c1.val; c1 = c1.next; &#125; if (c2 != null) &#123; sum += c2.val; c2 = c2.next; &#125; d.next = new ListNode(sum % 10); d = d.next; &#125; if (sum / 10 == 1) d.next = new ListNode(1); return sentinel.next; &#125;&#125; https://discuss.leetcode.com/topic/799/is-this-algorithm-optimal-or-what Is this Algorithm optimal or what? 12345678910111213141516171819202122232425public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode c1 = l1; ListNode c2 = l2; ListNode sentinel = new ListNode(0); ListNode d = sentinel; int sum = 0; while (c1 != null || c2 != null) &#123; sum /= 10; if (c1 != null) &#123; sum += c1.val; c1 = c1.next; &#125; if (c2 != null) &#123; sum += c2.val; c2 = c2.next; &#125; d.next = new ListNode(sum % 10); d = d.next; &#125; if (sum / 10 == 1) d.next = new ListNode(1); return sentinel.next; &#125;&#125; https://discuss.leetcode.com/topic/6220/my-accepted-java-solution My accepted Java solution Two things to make the code simple: Whenever one of the two ListNode is null, replace it with 0. Keep the while loop going when at least one of the three conditions is met. Let me know if there is something wrong. Thanks. 12345678910111213141516171819public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode prev = new ListNode(0); ListNode head = prev; int carry = 0; while (l1 != null || l2 != null || carry != 0) &#123; ListNode cur = new ListNode(0); int sum = ((l2 == null) ? 0 : l2.val) + ((l1 == null) ? 0 : l1.val) + carry; cur.val = sum % 10; carry = sum / 10; prev.next = cur; prev = cur; l1 = (l1 == null) ? l1 : l1.next; l2 = (l2 == null) ? l2 : l2.next; &#125; return head.next; &#125;&#125; https://discuss.leetcode.com/topic/39130/4ms-11lines-java-solution 4ms 11lines java solution 1234567891011121314151617public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode ln1 = l1, ln2 = l2, head = null, node = null; int carry = 0, remainder = 0, sum = 0; head = node = new ListNode(0); while(ln1 != null || ln2 != null || carry != 0) &#123; sum = (ln1 != null ? ln1.val : 0) + (ln2 != null ? ln2.val : 0) + carry; carry = sum / 10; remainder = sum % 10; node = node.next = new ListNode(remainder); ln1 = (ln1 != null ? ln1.next : null); ln2 = (ln2 != null ? ln2.next : null); &#125; return head.next; &#125;&#125; https://discuss.leetcode.com/topic/44133/java-concise-solution Java concise solution. 12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int carry = 0; ListNode p, dummy = new ListNode(0); p = dummy; while (l1 != null || l2 != null || carry != 0) &#123; if (l1 != null) &#123; carry += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; carry += l2.val; l2 = l2.next; &#125; p.next = new ListNode(carry%10); carry /= 10; p = p.next; &#125; return dummy.next;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>math</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[001. Two Sum]]></title>
    <url>%2Fp%2F6bed6d6%2F</url>
    <content type="text"><![CDATA[31.0% https://leetcode.com/problems/two-sum/ Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. 12345Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. UPDATE (2016/2/13): The return format had been changed to zero-based indices. Please read the above updated description carefully. 思路 方法一： dic, 全部都放入dic, 依次遍历，查找当前值target缺的那部分，要缺的index大于当前的index。 1234567891011121314151617181920// 面试奇虎360时曾遇到过 // beats 45.40% of cppsubmissions.class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; mapping; vector&lt;int&gt; result; for(int i = 0; i &lt; nums.size(); i++)&#123; mapping[nums[i]] = i; &#125; for(int i = 0; i &lt; nums.size(); i++)&#123; const int gap = target - nums[i]; if(mapping.find(gap) != mapping.end() &amp;&amp; mapping[gap] &gt; i)&#123; result.push_back(i); result.push_back(mapping[gap]); &#125; &#125; return result; &#125;&#125;; 方法二： 一遍遍历，一边放入dic my code: 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res; unordered_map&lt;int, int&gt; map; for(int i=0; i&lt;nums.size(); i++)&#123; int nex = target - nums[i]; if(map.find(nex)!=map.end())&#123; res.push_back(i); res.push_back(map[nex]); break; &#125;else&#123; map[nums[i]] = i; &#125; &#125; return res; &#125;&#125;; 我的代码实现： 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2, -1); unordered_map&lt;int, int&gt; map; for(int i=0; i&lt;nums.size(); i++)&#123; int gap = target - nums[i]; if(map.count(gap))&#123; res[0] = map[gap]; res[1] = i; return res; &#125;else map[nums[i]] = i; &#125; &#125;&#125;; 48ms, 59.36%, Apr.23rd, 2016 找出数组中的两个数，这两个数和为target 扫到x时看前面Hash的数里有没有target-x，然后将x也放进Hash表。 12345678910111213class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; dict = &#123;&#125; for i in range(len(nums)): if dict.get(target - nums[i], None) == None: dict[nums[i]] = i else: return (dict[target - nums[i]], i) my code 123456789101112class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; maps = &#123;&#125; for i, num in enumerate(nums): if target-num in maps: return [i, maps[target-num]] maps[num] = i 下面这个方法速度特慢，原因:对每个元素都进行了哈希，总之，无论建立还是查找都费了时间。 上面一种方法，注意，python字典有get方法 1234567891011class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; dict = &#123;n: i for i, n in enumerate(nums)&#125; for i, n in enumerate(nums): if target-n in dict.keys() and dict[target-n] != i: return [i, dict[target-n]] java https://leetcode.com/articles/two-sum/ Approach #2 (Two-pass Hash Table) [Accepted] To improve our run time complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to look up its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table. We reduce the look up time from O(n)O(n) to O(1)O(1) by trading space for speed. A hash table is built exactly for this purpose, it supports fast look up in near constant time. I say “near” because if a collision occurred, a look up could degenerate to O(n)O(n) time. But look up in hash table should be amortized O(1)O(1) time as long as the hash function was chosen carefully. A simple implementation uses two iterations. In the first iteration, we add each element’s value and its index to the table. Then, in the second iteration we check if each element’s complement (target - nums[i]target−nums[i]) exists in the table. Beware that the complement must not be nums[i]nums[i] itself!12345678910111213public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;);&#125; Complexity Analysis: Time complexity : O(n)O(n). We traverse the list containing nn elements exactly twice. Since the hash table reduces the look up time to O(1)O(1), the time complexity is O(n)O(n). Space complexity : O(n)O(n). The extra space required depends on the number of items stored in the hash table, which stores exactly nn elements. Approach #3 (One-pass Hash Table) [Accepted] It turns out we can do it in one-pass. While we iterate and inserting elements into the table, we also look back to check if current element’s complement already exists in the table. If it exists, we have found a solution and return immediately.1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;);&#125; Complexity Analysis: Time complexity : O(n)O(n). We traverse the list containing nn elements only once. Each look up in the table costs only O(1)O(1) time. Space complexity : O(n)O(n). The extra space required depends on the number of items stored in the hash table, which stores at most nn elements.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Multi-objective Learning and Mask-based Post-processing for Deep Neural Network based Speech Enhancement》阅读笔记]]></title>
    <url>%2Fp%2F719f3cc0%2F</url>
    <content type="text"><![CDATA[这是2017年Xu Yong关于使用多任务学习和使用mask做后处理做语音增强的一篇论文[1]。 同样有github源码[2]及展示demo[3,4]。 论文原文：Multi-objective Learning and Mask-based Post-processing for Deep Neural Network based Speech Enhancement 1. Abstract论文主要的学习目标是clean log-power spectra (LPS) features，因为LPS可以直接用于构造增强后的信号。作为多任务学习，使用了附加的架构，去学习比如MFCC特征，同时去学习类别信息，比如ideal binary mask (IBM)。这些特征其实也是对DNN的一种限制，潜在的能提高LPS这个首要目标的效果。 2. Introduction3. Multi-objective Learning for DNN-based Speech Enhancement多任务学习框架如下图图1所示： 输入是带噪语音信号，输出是干净音频信号。只是输入输出有时有带噪的特征，输出是干净的特征。输出有时有类别信息。 公式2是单独的dnn+LPS训练的误差函数，公式3是多输出的。 3.1 Joint Prediction of LPS with MFCC这个就是LPS和MFCC两个的多输出了。 3.2 Joint Prediction of LPS with IBM同上，LPS+IBM 3.3 IBM-based Post-processingIBM用于LPS的后处理。如公式3，如果IBM大于一定阈值，说明SNR很高，就不必做语音增强了，所以直接用原始的语音信息。如果中间就是原始信息和增强后的信息的均值。如果低于一定阈值，就是使用处理后的信息。 4. Experimental Results and Analysis 5. Conclusion本文提出了多目标学习以改善语音增强的DNN训练。 显示目标函数中添加来自MFCC或IBM等功能的约束可获得更准确的干净的LPS估计。 MFCC可以使对数频谱失真在低频下更加一致; IBM可以明确表示T-F单元的语音呈现信息，因此可以提供更高的SSNR。 此外，可以采用估计的IBM来进行后期处理，以减轻基于回归的DNN中的高估或低估问题。 基于IBM的后处理对于减少语音失真至关重要，特别是在高信噪比T-F单元。 参考资料： https://arxiv.org/abs/1703.07172 https://github.com/yongxuUSTC/sednn http://staff.ustc.edu.cn/~jundu/The%20team/yongxu/demo/SE_DNN_taslp.html http://staff.ustc.edu.cn/~jundu/The%20team/yongxu/demo/IS15.html]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>speech enhancement</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《SEGAN: Speech Enhancement Generative Adversarial Network》阅读笔记]]></title>
    <url>%2Fp%2Fbea139a%2F</url>
    <content type="text"><![CDATA[本论文是2017年的一篇使用GAN网络做单声道语音增强的论文[1]，在github上有作者的开源代码[2]，语音增强的效果有官方示例[3]。 论文原文：SEGAN: Speech Enhancement Generative Adversarial Network 1. Introduction经典的语音增强（speech enhancement）方法有谱减法（spectral subtraction）、维纳滤波（Wiener filtering）、统计模型（statistical model-based methods）和子空间算法（subspace algorithms）。 其中统计模型有最大似然、贝叶斯、MMSE及Log-MMSE。 论文给予GAN网络（Generative Adversarial Networks）提出了segan（speech enhancementGAN），segan主要优势有三点： 它提供了一个快速语音增强过程。 没有因果关系是必需的，因此没有像RNN那样的递归操作。 它基于原始音频做处理。 因此，没有提取手工特征，因此没有对原始数据做出明确的假设。 从不同的说话人和噪声类型中学习，并将它们合并到相同的共享参数中。这使得系统在这些维度上变得简单和一般化。 2. Generative Adversarial Networks这节是GAN网络的介绍。如果有GAN网络基础，可以跳过此节。 GAN网络能是一种对抗性模型，可以将样本服从Z分布的样本z映射到服从X分布的x。 来理解这句话。在我们这里，可以理解为Z为含噪声的语音的分布，z为其中的一个样本。X为纯净语音的分布，x为其中的一个样本。 GAN中，有两个单元，一个负责映射，叫做生成器G，另一个负责判别，叫做判别器D。G负责映射，G的映射负责从Z分布映射到X分布，不同于传统的输入输出映射。判别器D是一个二分类器，输出值是0-1之间的数字。 G将样本z映射为$\hat{x}$，而真实样本为$x$，G的目的是尽可能的使$\hat{x}$与$x$相似，以迷惑判别器D。而D的功能是区分真实样本$x$和G生成的样本$\hat{x}$，真实样本尽可能的判为1，G生成的尽可能的判为0。所以G的目的在于迷惑D，而D的目的是不被G迷惑。所以叫生成对抗网络。 于是就有了对抗网络的基本公式： 其中pdata(x)表示真实样本，pz(z)表示经过G之前的样本。 意义就很明显了，对于D优化的目标就是希望真实样本输出越大，生成的样本尽可能输出小，使得结果最大。对于G，希望生成的时候，尽可能的骗过D，使得目标函数最小。 下面的公式2是带额外信息的GAN。 一些论文致力于提升GAN网络生成的质量。比如，在原始的训练中，由于使用sigmoid交叉熵损失，会出现梯度消失的问题。这时，可以将损失替换为最小平方（least square）的Least Square GAN（LSGAN）方法。结果如下： 关于gan的更多解释： 有人说GAN强大之处在于可以自动的学习原始真实样本集的数据分布，不管这个分布多么的复杂，只要训练的足够好就可以学出来。针对这一点，感觉有必要好好理解一下为什么别人会这么说。 我们知道，传统的机器学习方法，我们一般都会定义一个什么模型让数据去学习。比如说假设我们知道原始数据属于高斯分布呀，只是不知道高斯分布的参数，这个时候我们定义高斯分布，然后利用数据去学习高斯分布的参数得到我们最终的模型。再比如说我们定义一个分类器，比如SVM，然后强行让数据进行东变西变，进行各种高维映射，最后可以变成一个简单的分布，SVM可以很轻易的进行二分类分开，其实SVM已经放松了这种映射关系了，但是也是给了一个模型，这个模型就是核映射（什么径向基函数等等），说白了其实也好像是你事先知道让数据该怎么映射一样，只是核映射的参数可以学习罢了。 所有的这些方法都在直接或者间接的告诉数据你该怎么映射一样，只是不同的映射方法能力不一样。那么我们再来看看GAN，生成模型最后可以通过噪声生成一个完整的真实数据（比如人脸），说明生成模型已经掌握了从随机噪声到人脸数据的分布规律了，有了这个规律，想生成人脸还不容易。然而这个规律我们开始知道吗？显然不知道，如果让你说从随机噪声到人脸应该服从什么分布，你不可能知道。这是一层层映射之后组合起来的非常复杂的分布映射规律。然而GAN的机制可以学习到，也就是说GAN学习到了真实样本集的数据分布。 再拿原论文中的一张图来解释： 这张图表明的是GAN的生成网络如何一步步从均匀分布学习到正太分布的。原始数据x服从正太分布，这个过程你也没告诉生成网络说你得用正太分布来学习，但是生成网络学习到了。假设你改一下x的分布，不管什么分布，生成网络可能也能学到。这就是GAN可以自动学习真实数据的分布的强大之处。 还有人说GAN强大之处在于可以自动的定义潜在损失函数。 什么意思呢，这应该说的是判别网络可以自动学习到一个好的判别方法，其实就是等效的理解为可以学习到好的损失函数，来比较好或者不好的判别出来结果。虽然大的loss函数还是我们人为定义的，基本上对于多数GAN也都这么定义就可以了，但是判别网络潜在学习到的损失函数隐藏在网络之中，不同的问题这个函数就不一样，所以说可以自动学习这个潜在的损失函数。 3. Speech Enhancement GAN &amp;&amp; Experimental Setup这部分是本文的而核心SEGAN。 整个网络全部是由CNN组成。 下图是生成器G，它是一个encoder-decoder。D的结构是encoder，上面接了一个降维层。将8* 1024个参数降为8个。 encoder由步长为2的1维卷积层构成。16384×1, 8192×16, 4096×32, 2048×32, 1024×64, 512×64, 256×128, 128×128, 64×256,32×256, 16×512, and 8×1024。 至于SEGAN的训练，其实跟普通的GAN很类似。如下图所示，先训练一个判别器D。D的输入为纯净信号和经过生成器增强后的信号。然后再固定判别器D，改变生成器G的参数。 其中，有一点，在初步实验中，我们发现在G的损失中增加一个次要成分是很方便的，以便将它的世代与干净的例子之间的距离减至最小。 为了测量这种距离，我们选择了L1范数，因为它已被证明在图像处理领域有效。 所以最终G的损失函数如公式6： 4. Results分为客观和主观评价两部分。 4.1 Objective Evaluation客观评价，有以下几个指标，都是越大越好： PESQ: Perceptual evaluation of speech quality, using the wide-band version recommended in ITU-T P.862.2 (from –0.5 to 4.5).主观语音质量评估，虽然叫主观，实际还是个客观的值。 CSIG: Mean opinion score (MOS) prediction of the signal distortion attending only to the speech signal(from 1to 5). CBAK: MOS prediction of the intrusiveness of background noise (from 1 to 5). COVL: MOS prediction of the overall effect(from 1 to 5). SSNR: Segmental SNR (from 0 to ∞). 结果如下图： 可以看到，segan在PESQ指标上表现稍微差一点。在所有其他指标上，这些指标更与语音失真有关系，segan都比wiener更好。segan产生更少的语音失真（CSIG）和移除噪声更有效（CBAK和SSNR）。所以，segan能在二者之间取得更好的权衡。 4.2 Subjective Evaluation主观描述，就是一段音频，给出它原始音频、wiener处理的音频、segan处理后的音频，不显示具体哪个对应哪个，让被测试者打分，1-5之间，分数越高代表越好。 16个测试者，20个句子。效果如下图。 5. Conclusions在这项工作中，端对端语音增强方法已经在生成对抗框架内实施。该模型使用编码器-解码器完全卷积结构，使得它能够快速操作来对波形块进行去噪。 结果表明，不仅该方法是可行的，而且它也可以作当前方法的有效替代。 疑惑： 对称的解卷积是如何做的？ 参考资料： https://arxiv.org/abs/1703.09452 https://github.com/santi-pdp/segan http://veu.talp.cat/segan/ https://mp.weixin.qq.com/s?__biz=MjM5ODU3OTIyOA==&amp;mid=2650668193&amp;idx=3&amp;sn=19157c2124a9731094e23e67fd846abd&amp;scene=19#wechat_redirect https://v.qq.com/x/page/m05070a168l.html https://mp.weixin.qq.com/s?__biz=MzAwNDI4ODcxNA==&amp;mid=2652247409&amp;idx=2&amp;sn=0373c6984e722dd6542e2bc8fd983936&amp;chksm=80cc8cd4b7bb05c22cb61616307525fbb7ce5846707c5289999359704ec219aff2a9968b12d6&amp;scene=0#rd]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>speech enhancement</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vultr搭建vpn（shadowsocks）翻墙并支持北邮人bt（ipv6）下载教程]]></title>
    <url>%2Fp%2Fb4d20b2d%2F</url>
    <content type="text"><![CDATA[学习本教程，主要收获会有两个。一个是科学上网，一个能够去北邮人bt上传下载资源。详细的内容见下表，如果只为了科学上网，学习1-3即可。需要支持北邮人bt看1-4，服务器管理相关的内容放在了5，章节6主要是一些问题的解决办法。内容主要是以win为例写的，mac、android的科学上网也可以跟着本教程来。内容概要： vultr购买VPS服务器 在服务器上搭建shadowsocks 在win10配置shadowsocks 配置utorrent，支持北邮人bt 服务器管理说明 Q &amp; A 1. vultr上购买VPS服务器要科学上网，需要使用到VPS服务器，本教程使用的是vultr，费用是2.5美元/月，费用是vultr收取的，跟本教程无关。除了vultr也可以使用其他的VPS，效果类似。 一些同学用的搬瓦工，跟我的可能会有些不同。我就遇到有同学的搬瓦工vps本身不支持ipv6，对于上北邮人bt就很麻烦，这是本教程力所不能及的。本教程建议使用vultr，所有使用非vultr的vps，一定要确保支持并可以开启ipv6。不支持ipv6的结果就是对上北邮人bt等ipv6站点有影响，不影响科学上网。 1.1 注册及交费这一步就非常简单了，用下面的链接注册： https://www.vultr.com/?ref=7402906 1.2 购买服务器注册完账户，并充值后。进入以下网址购买服务器。 https://my.vultr.com/deploy/ Server Location自己随意选，但是部分的确没有2.5美元/月的服务器。地区可以全都试试，目前还是能找到2.5美元/月的服务器的。Server Type自己随意，建议用centos。Server Size随意，如果只是做vpn的话，买2.5美元/月的那个就行。Additional Features中，如果想支持ipv6， 访问北邮人bt，那么Enable IPv6必选。 然后点击Deploy Now。 然后跳转或访问以下网址： https://my.vultr.com/ 就能看到自己的ip地址（IP address）、用户名（Username，通常是root）和密码（password）了。 1.3 检查ip地址是否被墙（可跳过）这一步，win系统的同学需要打开cmd输入 ping ip并按回车，检查是否被墙。其中ip需要替换为你上一步看到的ip地址。 如果没有出现time out。恭喜这个没问题。如果你不知道如何打开cmd，可以自行百度或google，或跳过此步骤。 如果是mac，cmd替换为“终端”。 2. 在服务器上搭建shadowsocks2.1 登录服务器win下，可以使用xshell来登录。 可以下载好xshell。 mac环境，使用“终端”或“iterm2”，一样的效果。 在黑窗口里输入一下代码： 1ssh root@ip 其中ip替换为你自己的ip地址。 然后会弹出弹出一个框，输入你前几步提到的密码，并回车（enter键）。 至此，你已经登陆了。 2.2 服务器上部署shadowsocks在刚才登录的xshell服务器上，输入以下代码。 123wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 安装完成后显示效果如下，可以截图保存这些信息下面配置会用的到： 12345678910Congratulations, Shadowsocks-python server install completed!Your Server IP : your ipYour Server Port : your portYour Password : your passwordYour Encryption Method: aes-256-gcm Welcome to visit:https://teddysun.com/342.htmlEnjoy it![root@vultr ~]# 至此，服务器端的配置已经完成。 3. 在windows系统配置shadowsocks3.1 下载shadowsocks客户端Windows：https://github.com/shadowsocks/shadowsocks-windows/releases Android：https://github.com/shadowsocks/shadowsocks-android/releases mac：https://github.com/shadowsocks/ShadowsocksX-NG/releases ubuntu的配置较为复杂，可以参考[4]。 3.2 配置shadowsocks客户端以win为例，下载，并解压缩后，运行。 输入ip，port，password，及encryption点击ok就可以了。 如果是mac，解压缩后运行，在上面点击那个小飞机，出现下拉栏“服务器-新服务器”-“服务器设置”。同样是输入地址、端口、加密方法、密码，并确定就可以了。 如果是Android，操作类似，请大家自行探索。 有可能需要关闭并重新打开shadowsocks的操作，有可能不需要。 打开你的浏览器，输入 https://www.google.com/ ，那么见证奇迹的时刻到了。 如果是Android，则点击右上角的较好，进去配置服务器、远程端口、密码、加密方式、路由，然后点击右上角的对号进行保存。 然后，选中刚才配置的vpn，然后点击右下角有个飞机的那个圆圈，就可以了。快来测试下吧！ 至此，电脑及手机的科学上网已经配置完成。 4. 配置utorrent，支持北邮人bt两步，第一步将北邮人bt的网址加入支持翻墙的列表，第二步配置utorrent。都很简单。 4.1 配置shadowsocks首先通过 右键Shadowsocks托盘图标 &gt;-&gt; PAC &gt;-&gt; 编辑 GFWList 的用户规则（或 Edit User rule for GFWList） 来打开user-rule.txt。（mac用户，点击小飞机，“编辑PAC用户自定规则”） 添加如下规则并保存： 1||bt.byr.cn^ 效果如下图： 此时关闭shadowsocks，并重新打开。在地址栏里输入北邮人bt的网址: https://bt.byr.cn/ 。就可以正常访问了。 4.2 配置utorrent下载并打开utorrent。这一步就不说了。 windows用户配置方法：按快捷键：“ctrl+P”，打开utorrent的设置。设置左侧找到Connection（中文应该是连接），配置如下图红圈里所示： mac用户配置方法：按快捷键：“command+,”，打开utorrent的设置。在设置上侧找到Network（中文应该是网络），配置方法跟上图类似。就是配置proxy server，address，port，配置的内容跟上图对应的一样。同时选中下面的use proxy for hostname lookups及use proxy for peer-to-peer connections。 至此就能愉快的下载了。 本章内容除了可以用于北邮人bt，也可以用于北交大的晨光pt，只要把晨光pt的网址按类似方法加进去就可以了。 试试效果？有问题欢迎留言。下面的5是对于服务器管理用的，一般用不到，可以不看，至此完成了科学上网+支持北邮人bt。 5. 服务器管理说明此内容是用于对服务器的vpn进行管理使用的，正常情况下是不需要看这个的。 5.1 卸载方法说明：使用root用户登录，运行以下命令： 1./shadowsocks.sh uninstall 5.2 配置说明：单用户配置文件示例： 配置文件路径：/etc/shadowsocks.json12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:your_server_port, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;your_password&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 多用户多端口配置文件示例： 配置文件路径：/etc/shadowsocks.json 123456789101112131415&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123; &quot;8989&quot;:&quot;password0&quot;, &quot;9001&quot;:&quot;password1&quot;, &quot;9002&quot;:&quot;password2&quot;, &quot;9003&quot;:&quot;password3&quot;, &quot;9004&quot;:&quot;password4&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 5.3 使用命令：启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 状态：/etc/init.d/shadowsocks status 6. Q &amp; A本小结是对配置有问题的一些问题的回答。 google上不去。 这是shadowsocks都没配置好。出问题的地方可能有 一、你的服务器ip被墙了。可以尝试在cmd中敲ping ip，看看是否有time out。有time out说明你连不上服务器的，我在家就经常连不上，在公司就没问题。一个办法就是销毁服务器，重新申请台服务器的ip。我换了好几个ip都没用，我感觉我是家里的网可能有问题。 二、对于很多问题，可以尝试换个浏览器、重启shadowsocks之类的看看能不能登录。 三、看报什么错。如果是500 Internal Privoxy Error。可以修改端口号、加密方式。一些端口号可能被重点关照了，建议修改为较小的端口号， 比如一千以内的。楼下也有修改加密方式解决问题的。四、自行根据error上网搜相关资料。 google能上，bt上不去问题。 google能上，说明shadowsocks配置没问题。bt相对于普通的科学上网，多的步骤就三个，一、vps支持ipv6，二、北邮人bt的网址加入到走外网名单，三、utorrent的配置。 主要检查一和二。 bt可以上网，utorrent配置找不到或下载没速度。 那就是utorrent配置的问题了，有的同学的utorrent配置和我给的有些出入，建议更新utorrent到最新版，或许就找到对应的配置地方了。 500 Internal Privoxy Error 首先看是否能上google，如果不能，尝试修改端口号、加密方式。 如果能上能上google，不能bt，就是问题2。 参考资料： https://teddysun.com/342.html https://doub.io/ss-jc43/ https://www.cnblogs.com/edward2013/p/5560836.html https://blog.csdn.net/TotoroCyx/article/details/80032556]]></content>
      <categories>
        <category>experience of life</category>
      </categories>
      <tags>
        <tag>翻墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类任务中的模型性能评估指标详解]]></title>
    <url>%2Fp%2F82f51d0e%2F</url>
    <content type="text"><![CDATA[本文主要内容有： 错误率（Error Rate）与准确率（Accuracy、ACC） 混淆矩阵（Confusion matrix） 精确率（Precision）、召回率（Recall）、F1值（F1-score） 宏精确率（macro-P）、宏召回率（marco-R）、宏F1值（macro-F1）、微精确率（micro-P）、微召回率（micro-R）、微F1值（micro-F1） ROC与AUC Mean Average Precision @ K 回归任务的评估指标 对于分类模型常用的分类指标有1-6。这些评估指标，工程和研究中都会经常遇到，需要对其有透彻的理解和对其中的差别清楚知晓。本文对这些指标进行一些总结和归纳。 1. 错误率（Error Rate）与准确率（Accuracy、ACC）准确率亦称精度。错误率与准确率是分类任务中常见的性能度量，同时适用于二分类及多分类任务。错误率是分类错误的样本数占样本总数的比例，准确率是分类正确的样本数占样本总数的比例。显然，二者的和为1。 对于样例集$D$，分类的错误率可以定义为： $$\begin{equation}E(f; D) = \frac{1}{m} \sum_{i=1}^m {I(f(x_i) \ne y_i)}\end{equation} \tag{1}$$ 其中m表示m个类别，$y_i$表示$x_i$对应的真实标签。 准确率则定义为： $$\begin{equation}\begin{split}ACC(f; D) &amp; = \frac{1}{m} \sum_{i=1}^m {I(f(x_i) = y_i)} \\&amp; = 1 - E(f; D)\end{split}\end{equation} \tag{2}$$ 对于更一般的情况，数据分布为D，概率分布为p(·)，错误率和准确率可以描述为： $$\begin{equation}E(f; D) = \int_{x \sim D} I(f(x) \ne y)p(x) {\rm d}x\end{equation} \tag{3}$$ $$\begin{equation}\begin{split}ACC(f; D) &amp; = \int_{x \sim D} I(f(x) = y)p(x) {\rm d}x \\&amp; = 1 - E(f; D)\end{split}\end{equation} \tag{4}$$ 2. 混淆矩阵（Confusion matrix）混淆矩阵是监督学习中的一种可视化工具，主要用于比较分类结果和实例的真实信息。矩阵中的每一行代表实例的预测类别，每一列代表实例的真实类别。下表是一个二分类任务的分类结果的混淆矩阵。 - 真实值为正样本P 真实值为负样本N 预测值为P True Postive(TP) False Postive(FP) 预测值为N False Negative(FN) True Negative(TN) 在混淆矩阵中，每一个实例可以划分为以下四种类型之一： 真正(True Positive , TP)：被模型预测为正的正样本 假正(False Positive , FP)：被模型预测为正的负样本 假负(False Negative , FN)：被模型预测为负的正样本 真负(True Negative , TN)：被模型预测为负的负样本 3. 真正率、假负率、假正率及真负率定义以下几个指标 真正率(True Positive Rate, TP Rate, TPR)（灵敏度sensitivity， 也是召回率）定义为$\frac{被预测为正的正样本结果数}{正样本实际数}$，即： $$\begin{equation}TPR = \frac{TP}{TP + FN}\end{equation} \tag{5}$$ 假负率(False Negative Rate, FN Rate, FNR)定义为$\frac{被预测为负的正样本结果数}{正样本实际数}$，即： $$\begin{equation}FNR = \frac{FN}{TP + FN}\end{equation} \tag{6}$$ 假正率(False Positive Rate, FP Rate, FPR) 定义为$\frac{被预测为正的负样本结果数}{负样本实际数}$，即： $$\begin{equation}FPR = \frac{FP}{FP + TN}\end{equation} \tag{7}$$ 真负率(True Negative Rate, TN Rate, TNR)（特指度specificity）定义为$\frac{被预测为负的负样本结果数}{负样本实际数}$，即： $$\begin{equation}TNR = \frac{TN}{TN + FP}\end{equation} \tag{8}$$ 可以看出，真正（TP）和假负（FN）都是实际类别是正样本，分别被判为正及负，真正率（TPR）及假负率（FNR）都是除以正样本的总个数（TP+FN）。所以TPR+FNR=1。类似的，假正（FP）和真负（TN）都是实际样本类别是负样本，分别被判为正及负，假正率（FPR）及真负率（TNR）都是除以负样本的总数（FP+TN）。所以FPR+TNR=1。 可以看出，以上四个率（Rate）都是除以他们的真实标签对应的所有与它们真实标签相同的样本的个数。TPR、FNR二者知其一，便知另外一个。FPR、TNR也只需要知道一个便知另外一个。 一个具体的例子，就是[5]。假设你正在构建一个使用麦克风来监听用户说出特定“唤醒词”，检测到“唤醒词就唤醒系统的硬件设备。例如亚马逊的Echo倾听“Alexa”，苹果siri的“Hey Siri”，安卓的“Okay Google”及百度应用的“你好，百度”。你关心的是假正率（假阳性率）及假负率（假阴性率）。假正率（假阳性率）指没有人说唤醒词系统醒来的频率，假负率（假阴性率）是当有人说唤醒词系统没有醒来的频率。一个合理的目标是在满足每运行24小时不会有一个假阳性（满足指标）的情况下，最大限度的减少假阴性率（优化指标）。 在weka里，会显示TPR和FPR两个参数。 3. 精确率（Precision）、召回率（Recall）、F1值（F1-score）二分类问题常用的评价指标有精确率（Precision）、召回率（Recall）和F1值。精确率亦称为“查准率”，召回率亦称“查全率”。 精确率定义为： $$\begin{equation}P = \frac{TP}{TP+FP}\end{equation} \tag{9}$$ 召回率定义为： $$\begin{equation}R = \frac{TP}{TP+FN}\end{equation} \tag{10}$$ F1之定义为精确率和召回率的调和平均数，即： $$\begin{equation}\frac{2}{F1} = \frac{1}{P} + \frac{1}{R}\end{equation} \tag{11}$$ 即 $$\begin{equation}\begin{split}F1 &amp; = \frac{2PR}{P+R} \\&amp; = \frac{2}{\frac{TP+FP}{TP}+\frac{TP+FN}{TP}} \\&amp; = \frac{2TP}{2TP+FP+FN}\end{split}\end{equation} \tag{12}$$ 对于一些应用，精确率和召回率重视程度不同，比如在商品推荐中，为了减少对用户的打扰，更希望推荐用户感兴趣的，此时精确率更重要。查找逃犯时，希望尽可能的减少逃犯遗漏，则召回率更重要。于是有了F1值更一般的形势$F_\beta$，定义为精确率和召回率的加权平均数： $$\begin{equation}\frac{1+\beta^2}{F_\beta} = \frac{1}{P} + \frac{\beta^2}{R}\end{equation} \tag{13}$$ 即： $$\begin{equation}F_\beta = \frac{(1+\beta^2)PR}{\beta^2P + R}\end{equation} \tag{14}$$ 其中，$\beta &gt; 0$，$\beta$度量了精确率和召回率之间的重要性，当$\beta=1$时,就是F1；当$\beta&lt;1$时，精确率更重要；当$\beta&gt;1$时，召回率更重要。这些结论可以通过观察公式（13）得出。 4. 宏精确率（macro-P）、宏召回率（marco-R）、宏F1值（macro-F1）、微精确率（micro-P）、微召回率（micro-R）、微F1值（micro-F1）很多时候我们有多个二分类混淆矩阵，例如进行多次训练/测试，每次得到一个混淆矩阵;或是在多个数据集上进行训练/测试，希望估计算法的”全局”性能;甚或是执行多分类任务，每两两类别的组合都对应一个混淆矩阵，总之，我们希望在个二分类混淆矩阵上综合考察精确率和召回率。 一种直接的做法是现在各个混淆矩阵上分别计算出精确率和召回率，记为$(P_1, R_1),(P_2,R_2),…,(P_n, R_n)$，再计算平均值，这样就得到宏精确率（macro-P）、宏召回率（marco-R）、宏F1值（macro-F1），分别定义如下： $$\begin{equation}marco-P = \frac{1}{n} \sum_{i=1}^n P_i\end{equation} \tag{15}$$ $$\begin{equation}marco-R = \frac{1}{n} \sum_{i=1}^n R_i\end{equation} \tag{16}$$ $$\begin{equation}marco-F1 = \frac{2 \times marco-P \times macro-R}{macro-P + macro-R}\end{equation} \tag{17}$$ 除此之外，还可以将各个混淆矩阵的对应元素进行平均，得到TP、FP、TN、FN的平均值，分别记为$\overline{TP}、 \overline{FP}、 \overline{TN}、 \overline{FN}$，然后再基于这些指标，计算出微精确率（micro-P）、微召回率（micro-R）、微F1值（micro-F1），分别定义如下： $$\begin{equation}mirco-P = \frac{\overline{TP}}{\overline{TP}+\overline{FP}}\end{equation} \tag{18}$$ $$\begin{equation}mirco-R = \frac{\overline{TP}}{\overline{TP}+\overline{FN}}\end{equation} \tag{19}$$ $$\begin{equation}mirco-F1 = \frac{2 \times mirco-P \times micro-R}{micro-P + micro-R}\end{equation} \tag{20}$$ 5. ROC与AUCROC全称是受试者工作特征（Receiver Operating Characteristic）。ROC曲线的纵轴是上文提到的真正率（TPR），横轴是假正率（FPR），分别对应于公式（5）和公式（7）。此处再次搬运过来。 $$\begin{equation}TPR = \frac{TP}{TP + FN}\end{equation} \tag{21}$$ $$\begin{equation}FPR = \frac{FP}{FP + TN}\end{equation} \tag{22}$$ 正如前文分析的那样，TPR的分子为分类结果中为正样本且真实标签也为正样本的个数，分母是所有样本中正样本的个数。FPR的分子为分类结果为正样本且真实样本为负样本的个数，分母是所有样本中负样本的个数。所以对于一个固定的测试集来说，TPR、FPR的分母都是固定值。一个ROC曲线图如下所示： 对上图的四个关键点进行分析： (0,0)：TP=0，FP=0，可以发现该分类器预测所有的样本都为负样本(Negative) (1,1)：TN=0，FN=0，可以发现该分类器预测所有的样本都为正样本(Positive) (0,1)：FP=0，FN=0，它将所有的样本都正确分类 (1,0)：TP=0，TN=0，它将所有的样本都错误分类 从上面的分析我们可以看到，如果ROC曲线越靠近左上方，那么分类器的效果越好。进行学习器的比较时，若一个分类器的ROC曲线完全包住另一个分类器，那么可以判断前者的性能更好。 ROC的绘图过程是：给定$m^+$个正样本和$m^-$个负样本。根据学习期预测结果对样例进行排序，然后把分类阈值设为最大，则把所有结果预测为负样本，此时真正率和假正率均为0，在坐标（0,0）处标记一个点。然后，将分类阈值一次设为每个样本的预测值，即依次将每个样例划分为正样本。设签一个标记点坐标为（x，y），当前若为正样本，则对应标记点的坐标为$(x,y+\frac{1}{m^+})$；当前若当负样本，则对应标记点的坐标为$(x+\frac{1}{m^-}, y)$，然后用线段连接相邻点即可。 在进行学习期比较时，如果一个学习期的ROC曲线被另一个学习期的曲线完全“包住”，则可以断言后者优于前者。但是如果有交叉，则一般难以断言哪个更好。此时如果一定要比较，则较为合理的判断是比较ROC曲线下的面积，即AUC（Area Under ROC Curve）。 从以上定义可知，AUC可以通过对ROC曲线下个面积求和得到。假设ROC曲线的坐标为${(x_1, y_1),(x_2, y_2),…(x_m, y_m)}的点按序连接而成$(x_1 = 0, x_m = 1)$，则AUC可以估算为： $$\begin{equation}AUC = \frac{1}{2} \sum_{i=1}^{m-1} (x_{i+1} - x_i)(y_i + y_{i+1})\end{equation} \tag{23}$$ 6. Mean Average Precision @ K在kaggle的Freesound General-Purpose Audio Tagging Challenge[7]使用的评估方法是Mean Average Precision @ 3 (MAP@3)，该问题是每个音频文件进行自动标注，每个音频实际上只对应一个标签，但是可以做出最多三个预测标签值，对应的公式是： $$\begin{equation}MAP@3 = \frac{1}{U} \sum_{u=1}^U {\sum_{k=1}^{min(n,3)} P(k)}\end{equation} \tag{24}$$ U是样本的总个数，最后是对每个样本的评价求平均，所以关键还是要Average Precision @ 3 (AP@3），所以对应的公式是： $$\begin{equation}AP@3 = \sum_{k=1}^{min(n,3)} P(k)\end{equation} \tag{25}$$ n是预测结果的总个数，也就是限制为3。比如一个真实标签为鸟叫声的音频，可以预测为：鸟叫声，门声，玻璃破碎声。则对应的结果为AP@3 = 1 * 1 + 0 * 1/2 + 0 * 1/3 = 1。也就是每一位是有权重的，越靠前权重越高，第一位权重为1，第二位1/2，第三位为1/3。如果预测为门声，玻璃破碎声，鸟叫声，则AP@3 = 0 * 1 + 0 * 1/2 + 0 * 1/3 = 1/3 。 7. 回归任务的评估指标回归任务中最常用的性能度量是均方误差（mean squared error)： $$\begin{equation}E(f; D) = \frac{1}{m} \sum_{i=1}^m (f(x_i)-y_i)^2\end{equation} \tag{26}$$ 更一般的，对于数据分布D和概率密度函数p(·)，均方误差可以如下定义： $$\begin{equation}E(f; D) = \int_{x \sim D} (f(x) - y)^2p(x) {\rm d}x\end{equation} \tag{27}$$ 8. 后续工作与其他内容一样，有内容会持续更新。 PRC Area与MCC还需要在更新。 参考资料： http://blog.sina.com.cn/s/blog_629e606f0102v7a0.html https://en.wikipedia.org/wiki/Evaluation_of_binary_classifiers 周志华《机器学习》 李航《统计学习方法》 https://yuchenchen.gitbook.io/machine-learning-yearning/9.-you-hua-he-man-zu-zhi-biao https://zhuanlan.zhihu.com/p/25528580 https://www.kaggle.com/c/freesound-audio-tagging#evaluation]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>to do</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[误差反向传播（error backpropagation）推导过程【待完成】]]></title>
    <url>%2Fp%2F55aa0f10%2F</url>
    <content type="text"><![CDATA[误差反向传播算法（error backpropagation）推导过程是每个做深度学习（deep learning）的人员必会的基本功。这里是针对前馈神经网络（Feed Forward Neural Network）或者叫多层感知机（Multi Layer Perceptron）或者叫深度神经网络（Deep Neural Network）的做一个推导。此处用到的误差函数是均方误差（Mean Squared Error）。 1. 前馈神经网络简介基本网络如图1所示，这是一个基本的神经网络，下面来解析这个网络结构。 首先，我们构造输入变量$x_1,…,x_D$的线性组合，形式为： $$\begin{equation}{a_j} = \sum_{i=1}^D {w_{ji}}^{(1)} \cdot x_i + {w_{j0}}^{(1)}\end{equation} \tag{1}$$ 其中$j=1,…,M$，M是输出的总量，且上标(1)表示对应的参数是神经网络的第一层。${w_{ji}}^{(1)}$叫做权重（weight），参数$w_{j0}$叫做偏置（bias）,$a_j$叫做激活(activation)。每个激活都使用一个非线性激活函数(activation function) $h(·)$进行变换，得： $$\begin{equation}z_j = h(a_j)\end{equation} \tag{2}$$ 非线性函数$h(a_j)$通常选用sigmoid，tanh，relu等。$z_j$为经过激活函数的值。这些值会再次线性组合，得到输出单元激活（output unit activation）： $$\begin{equation}{a_k} = \sum_{i=1}^K {w_{kj}}^{(2)} \cdot z_j + {w_{k0}}^{(2)}\end{equation} \tag{3}$$ 这个变换对应于神经网络第二层，类似于之前。最后使用一个恰当的激活函数进行变换，得到神经网络的一组输出$y_k$。对于标准回归问题，激活函数是恒等函数，从而$y_k = a_k$。对于一个二元分类问题，每个输出单元激活可以使用logistic sigmoid进行变换，即: $$\begin{equation}y_k = \sigma(a_k)\end{equation} \tag{4}$$ $\sigma(·)$函数形式这里不再给出，可以自己查看。对于多分类问题，可以使用softmax激活函数。 最后综合以上的观点，我们容易得到一个网络整体，如下: $$\begin{equation}y_k = \sigma(\sum_{i=1}^K {w_{kj}}^{(2)} \cdot h(\sum_{i=1}^D {w_{ji}}^{(1)} \cdot x_i + {w_{j0}}^{(1)}) + {w_{k0}}^{(2)})\end{equation} \tag{5}$$ 其中所有权重参数和偏置被聚集在一起，记做$\vec{w}$。因此，神经网络可以简单地认为是从输入变量$\vec{x}$到输出变量$\vec{y}$的非线性函数，映射由调节参数$\vec{w}$来控制。 具体网络结构正如图1所示。计算公式（5）的过程可以认为是信息通过网络的前向传播（forward propagation）。 通过定义额外的输入变量$x_0$讲公式(1)中的偏置参数整合进权重参数集合中，并且$x_0$被限定为1，因此公式（1）可以改写为： $$\begin{equation}{a_j} = \sum_{i=0}^D {w_{ji}}^{(1)} \cdot x_i\end{equation} \tag{6}$$ 第二层的偏置也做类似处理，最终整体网络函数可以从公式（5）变为： $$\begin{equation}y_k = \sigma(\sum_{i=0}^K {w_{kj}}^{(2)} \cdot h(\sum_{i=0}^D {w_{ji}}^{(1)} \cdot x_i))\end{equation} \tag{7}$$ 至此，一个简单的前馈神经网络已经完成了。 2. 误差反向传播算法简介我们的目标是寻找一种计算前馈神经网络的误差函数$E(w)$的梯度高效的方法。我们将会看到，可以使用局部信息传递的思想来完成这一点。在局部信息传递的思想中，信息在神经网络中交替的向前、向后传播。这种方法被称为误差反向传播（error propagation），有时被称为backprop，通常简称bp算法。 关于训练过程的本质。大部分训练算法涉及到一个迭代的步骤用于误差函数的最小化，以及通过一系列的步骤进行权重调节。在每一个这样迭代过程中，我们可以区分这两个不同的阶段。在第一个阶段，误差函数关于权重的导数必须被计算出来。正如我们稍后看到的那样，反向传播算法的一个重要贡献是提供了计算这些导数的一个高效的方法。由于正是这个阶段，误差通过网络进行传播，因此我们将专门使用反向传播这个属于来描述计算导数的过程。在第二个阶段，导数用于计算权重的调整量。最简单的方法，也是最开始由Rumelhart et al.（1986）考虑的方法，涉及到梯度下降。认识到这两个阶段属于不同的阶段是很重要的。因此，第一阶段，即为了计算导数而进行的误差在网络中的反向传播阶段，可以应用于许多不同种类的网络，而不仅仅是多层感知器。它也可以 应用于其他的误差函数，而不仅仅是简单的平方和误差函数。它也可以用于计算其他类型的导数。第二阶段，即使用计算过的导数调整权重的阶段，可以使用许多最优化方法处理，许多最优化方法本质上要比简单的梯度下降更强大。 3. 简单线性模型误差导数的计算许多实际应用中使用的误差函数，例如针对一组独立同分布的数据的最大似然方法定义的误差函数，由若干项的求和公式组成。每一项对应于训练集中的一个数据点，即： $$\begin{equation}E(w) = \sum_{n=1}^N {w}\end{equation} \tag{8}$$ 这里，我们要考虑计算$\nabla E_n(w)$的问题。这可以直接使用顺序优化的方法计算，或者使用批处理方法在训练集上进行累加。 对于一个特定的输入模式n（等价于对于一个特定的样本$\vec{x}$），误差函数形式为： $$\begin{equation}E_n = \frac{1}{2} \cdot \sum_{k} {(y_{nk}-t_{nk})}^2\end{equation} \tag{9}$$ 其中$y_{nk} = y_k(\vec{x_n}, \vec{w})$，$y_{nk}$表示对于特定输入模式的输出，$t_{nk}$表示对应的实际标签（或预测值）。这个误差函数关于权重$w_{ji}$的梯度为： $$\begin{equation}\frac{E_n}{w_{ji}} = (y_{nj} - t_{nj})x_{ni}\end{equation} \tag{10}$$ 它可以表示为与链接$w_{ji}$的输出端关联的“误差信号”$y_{nj}-t_{nj}$和与链接的输入端相关连的变量$x_{ni}$的乘积。我们现在会看到这个简单的结果如何扩展到更复杂的多层前馈神经网络中。 4. 通用前馈神经网络bp算法推导 5. 一个简单的例子参考资料： BISHOP, C, M. Pattern recognition and machine learning[M]. New York:Springer, 2006. 225-244]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>to do</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 3 读取中文文件]]></title>
    <url>%2Fp%2F6821aaf2%2F</url>
    <content type="text"><![CDATA[在windows环境下，python3 读取中文文件方法，折腾了很久，总结了下。 先找到文件编码格式。 因为读文件的时候，需要知道文件的编码格式，编码格式怎么看呢？ 我的方法是，使用windows自带的记事本打开文件，然后ctrl+shift+s，或文件-另存为，可以看到文件的编码格式。 常见的编码格式有utf-8，gbk，gb2312。我今天把这些编码格式都试了发现都不能解码，最后发现文件编码格式是Unicode big endian，然后看到Stack Overflow上说，编码就是UTF-16[1]，最终解决问题。 编写相应代码。 两种方法，方法一，使用codecs模块： 123import codecswith codecs.open(file, 'r', encoding='utf-16') as f: text = f.read() 或 12with open(file, 'rb') as f: text = f.read().decode('utf-16') 方法二： 12with open(file, 'r', encoding='UTF-16') as f: text = f.read() 自己写的时候记得修改encoding为自己文件的相应格式，同时根据自己需要修改读写。 参考资料： [1]. https://stackoverflow.com/questions/8827419/converting-utf-16-utf-8-and-remove-bom]]></content>
      <categories>
        <category>experience of code</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《A consolidated perspective on multi-microphone speech enhancement and source separation》 阅读笔记【待完成】]]></title>
    <url>%2Fp%2F9c92dc77%2F</url>
    <content type="text"><![CDATA[论文A consolidated perspective on multi-microphone speech enhancement and source separation阅读分享]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>speech enhancement</tag>
        <tag>paper</tag>
        <tag>to do</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经济学人（The Economist）EPUB，MOBI,，PDF及MP3分享下载]]></title>
    <url>%2Fp%2F1c573a7b%2F</url>
    <content type="text"><![CDATA[简介《经济学人》是一份由伦敦经济学人报纸有限公司出版的杂志，创办于1843年9月，创办人詹姆士·威尔逊。杂志的大多数文章写得机智，幽默，有力度，严肃又不失诙谐，并且注重于如何在最小的篇幅内告诉读者最多的信息。该杂志又以发明巨无霸指数闻名，是社会精英必不可少的读物。该杂志英文电子版可通过移动App、网站或者有声版阅读每周完整内容。 杂志主要关注政治和商业方面的新闻，但是每期也有一两篇针对科技和艺术的报导，以及一些书评。杂志中所有文章都不署名，而且往往带有鲜明的立场，但又处处用事实说话。主编们认为：写出了什么东西，比出自谁的手笔更重要。从2012年1月28日的那一期杂志开始《经济学人》杂志开辟了中国专栏，为有关中国的文章提供更多的版面。 近期下载链接及说明内容格式含EPUB，MOBI,，PDF及MP3。点进日期进去就到了百度网盘链接，输入后面的密码就可以了。本内容会持续更新。仅供学习交流使用，请勿用作商业用途。 20180519 密码: yd8d。 20180512 密码: 7gka。 20180505 密码: ygdx。 20180428 密码：8v3d。 20180421 密码：kdpn。 20180414 密码: u2xa。 20180407 密码: z44r。 2018年1月-4月、2017年全年、2016年全年下载链接2018年全年经济学人下载（含EPUB、MOBI、PDF、MP3） 密码: ihqw。 2017年全年经济学人下载（含EPUB、MOBI、PDF、MP3） 密码: 57z5。 2016年全年经济学人下载（含EPUB、MOBI、PDF、MP3） 密码: v2bd。]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>经济学人</tag>
        <tag>The Economist</tag>
        <tag>下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[machine-learning-yearning(by Andrew Ng) 1-22章翻译最新版]]></title>
    <url>%2Fp%2Fb706c49c%2F</url>
    <content type="text"><![CDATA[machine-learning-yearning本内容是Andrew NG的My Machine Learning Yearning 1-22章内容的翻译及其原稿，会持续更新。 Andrew表示最近每周会持续更新本书籍，我决定把它翻译出来，加深自己的印象，同时希望能对大家有点帮助，后续会持续更新。 本书官网：http://www.mlyearning.org/ Andrew Ng关于本书介绍亲爱的朋友，你是如何组织一个人工智能（AI）项目的呢？ 人工智能（AI），机器学习（Machine Leaning）和深度学习（Deep learning）正在改变众多行业。我一直在写此书——Machine Learning Yearning，来教你如何构建机器学习项目。 本书的重点不在于教授机器学习算法，而在于使机器学习算法发挥作用。一些人工智能技术会给你一个锤子，而本书教你如何使用锤子。如果你渴望成为人工智能技术的领导者并想学习如何为你的团队设定方向，这本书将会有所帮助。 阅读完Machine Learning Yearning之后，你将能够： 为人工智能项目最有前途的方向设立优先级 诊断机器学习系统中的错误 在复杂设置中构建机器学习，例如不匹配的训练集/测试集 建立一个可以人类比较或超越人类表现的机器学习项目 了解何时以及如何应用端到端学习（end-to-end learning），迁移学习（transfer learning）和多任务学习（multi-task learning） 从历史上看，学习如何制定这些“策略”决策的唯一方法是在研究生课程或公司中做多年的学徒。我正在写的Machine Learning Yearning可以帮你快速的获得这项技能，以便你可以更好地构建人工智能系统。 本书大约100页，包含很多易于阅读的1-2页的章节。如果你希望收到每章完成后的草稿，请注册邮件列表。 —— 吴恩达（Andrew Ng） 翻译版gitbook阅读地址：gitbook阅读体验更好，欢迎来点击下面链接阅读翻译版： https://yuchenchen.gitbook.io/machine-learning-yearning/ 翻译版github地址：https://github.com/yucc2018/machine-learning-yearning 英文原版pdf下载：原文原版手稿已经更新到19章，下载链接分别如下: 1-14章pdf下载（2018.04.18版） 15-19章pdf下载（2018.04.25版） 20-22章pdf下载（2018.05.02版） 我自己手动将上面两部分合并，成为1-19章的合集。想下载一个的直接点下面这个链接。 1-22章合并版pdf下载（2018.05.02更新） 翻译章节：1. 为什么是机器学习策略？ 2. 如何使用本书来帮助你的团队 3. 预备知识和表示符号 4. 规模推动机器学习进度 下一部分：设置开发和测试集 5. 你的开发集和测试集 6. 你的开发集和测试集应当来自相同的分布 7. 开发集和测试集需要多大？ 8. 为你的团队进行算法优化建立一个单数字估指标 9. 优化和满足指标 10. 使用开发集和评估指标来加速迭代 11. 何时更改开发集/测试集和评估指标 12. 小结：设置开发集和测试集 下一部分：基本错误分析 13. 快速构建你的第一个系统，然后迭代 14. 错误分析：查看开发集的例子来评估想法 15. 在错误分析中并行评估多个想法 16. 清理错误标记的开发集和测试集样例 17. 如果你有一个很大的开发集，将它分成两个，而且你只看一个 18. 眼球开发集和黑盒开发集应该多大？ 19. 基本错误分析 下一部分：偏差（Bias）和方差（Variance） 20. 偏差（Bias）和方差（Variance）：错误的两大来源 21. 偏差（Bias）和方差（variance）的例子 22. 对比最优错误率 待Andrew更新后翻译章节： Addressing Bias and Variance Bias vs. Variance tradeoff Techniques for reducing avoidable bias Techniques for reducing Variance Error analysis on the training set Diagnosing bias and variance: Learning curves Plotting training error Interpreting learning curves: High bias Interpreting learning curves: Other cases Plotting learning curves Why we compare to human-level performance How to define human-level performance Surpassing human-level performance Why train and test on different distributions Whether to use all your data Whether to include inconsistent data Weighting data Generalizing from the training set to the dev set Addressing Bias, and Variance, and Data Mismatch Addressing data mismatch Artificial data synthesis The Optimization Verification test General form of Optimization Verification test Reinforcement learning example The rise of end-to-end learning More end-to-end learning examples Pros and cons of end-to-end learning Learned sub-components Directly learning rich outputs Error Analysis by Parts Beyond supervised learning: What’s next? Building a superhero team - Get your teammates to read this Big picture Credits 联系方式：6506666@gmail.com]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>to do</tag>
        <tag>machine learning</tag>
        <tag>machine learning yearning</tag>
        <tag>Andrew Ng</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年算法工程师（机器学习方向）找实习找校招经验总结]]></title>
    <url>%2Fp%2F102faecd%2F</url>
    <content type="text"><![CDATA[写在前面，这是我去年年底（2017.12）依据自己找实习找工作经历撰写，分享在北邮人bbs上的文章，觉得还是有价值的，重新发表在这里。 2017年即将过去，今年是忙碌的一年，从2月17还没开学就来学校，到现在12月初，工作的事情终于尘埃落定，现将这一段经历写下来，希望能帮助来年找工作的学弟学妹，同时，对自己来说，也是一年的工作总结，总结经验教训，对自己一个提升。 简单介绍一下，北邮本硕，要找的岗位主要是算法工程师（机器学习方向）。算法工程师找实习的时候，最终的结果是找到了四家：亚马逊、京东、滴滴、腾讯地图。找工作的时候，主要有百度sp、滴滴sp、美团sp、新浪sp、搜狗sp、小米（没谈薪资直接拒了）等。总体而言，今年找工作相对以往还是很顺利的，各大公司都很缺人，各家开出的工资相对于去年都非常诱人，找工作的情况也出乎了我们很多人的意料。 年初的时候，大概2月28左右开学吧，我2月16就来了，开始准备找实习。简单的说一下面试的情况，有些可能已经忘记，现在说个大概情况。 各家面试情况 滴滴，实习的是在论坛招人内推的，两面，第一面是主要问了svm lr等原理，简历上的项目，svm怎么用于多分类。第二面写了一道算法题，leetcode 63. Unique Paths II。问我是否会用spark，我说不会。然后就给我介绍了他们所做的项目。后来回来的路上我想了想，当时问我是否会不会spark，我应该说我虽然不会，但是可以学的，留个好印象。没过多久，就发了实习offer。后来去了滴滴实习。实习转正三面，每面半小时，所以还是相对容易了很多。转正一面，主要问了在滴滴的实习，给我的柑橘是更偏重业务，对技术并不是太热衷，做的项目的业务的主要应用是什么，将来怎么评价之类的。一道算法题，leetcode上的，旋转数组，leetcode 59. Spiral Matrix II。转正二面，也是问了问滴滴的实习，问了下gbdt的原理，xgboost与gbdt的区别，gbdt用于分类时，分类概率的梯度体现在哪里。一道编程题，矩阵A与矩阵B相乘得到矩阵C，给定A和B，求C的秩。转正三面，三面面试官是一个研究员，对数学推导有独特的兴趣。问了svm的推导，什么是凸函数，为什么拉格朗日对偶方程成立。滴滴的offer大约10月初发。 美团。实习的时候貌似没内推，走的校招。一面，上来让写了几个算法，一个是数组全排列，一个是二叉树的非递归先序遍历，一个是反转链表。然后问了过拟合问题，l1 l2正则区别之类的。然后进入二面，二面的时候面试官先问了一个二叉树的垂直遍历，LeetCode 314. Binary Tree Vertical Order Traversal（这个题是leetcode付费的题）。没答上来，就挂了。校招时是找斜对门的美团实习的大佬内推的。共三面，一面面完告知通过接着二面，二面面完告知通过让回去等三面，三面是电话面，晚上7点三面的，晚上12点就收到录取意向书。做完笔试，过了几天，晚上9点多美团打电话过来，说明天早上10点来某某酒店面试。第二天一面问了简历上的项目，编程题问了1到n的一个排好序的数组，少了一个元素，怎么找出来。我说二分查找，时间效率logn（也可以用位运算，时间效率n）。二面问了项目，我简历上有k-means，就问了其他聚类的方法，距离有多少种，影响聚类的因素。问了编程题leetcode 198 House Robber（动态规划）。三面电话面，问了项目，问了过拟合的问题产生、解决办法，问了两个编程题，leetcode 69 Sqrt(x)，两种方法解决，一种是二分查找，一种是牛顿法。另一个编程题给忘了，想起再补充。 百度。内推实习的时候，去年毕业的师兄去了百度组，我们就找他内推的。说实话，挺后悔的，我并不喜欢他这个方向，一方面我不擅长，另一方面过了我也不会去。不该图省事找他推的。内推实习时，共二面，挂了。面试主要问的是方面的，也没什么意思，答的也不好。问了leetcode 206 Reverse Linked List，让自己定义链表，问指针，对象，指针是对象吗，对C++的考察很多。到校招实习时，没投简历。到校招开始时，我投的比较晚，所以错过了内推机会，然后到了校招。校招共三面，都是技术面，当天状态不太好，感冒了。主要问了二分类的标准有多少种，每种都是什么。struct与class的区别。线程与进程的区别，io密集，计算密集使用多线程还是多进程。一个发生器，产生0的概率是p，产生1的概率是1-p，p！=0.5，怎么使用这个产生0和1等概率的发生器（可以每次产生两个数字，0 1判为0，1 0判为1，其他的舍弃重来）。k-means聚类相关问题，svm与lr的对比与区别。编程题问了多道，最小栈leetcode 155. Min Stack，还有几道其他题目，忘了已经。 腾讯。实习投的北京微信，校招投的广州微信，然而都没找我面试。找实习时，qq空间把我捞了起来邀请我面试，我拒绝了，后来腾讯地图邀请我去面试，就去了。面试一下午，从1：40到5：20，共四面，前三个为技术面，第四个为leader面，leader也问了一些技术，未来的规划，来这里之后会干什么，反正就是泛泛的聊，还有就是你印象最深刻的一件事，最感动的，最难忘的一件事，哎，这些问题。先是40分钟一套卷子，让做题，5道编程题，3道问答题可以选择做。我当时40分钟把5道编程写完就没时间了。有一道是leetcode 300 Longest Increasing Subsequence，其他忘了，不过也不难。面试聊了项目，花了不少时间，也看了那5道编程题，怎么处理POI中的名称问题，就是说一个地点可能有很多备选的名字，怎么确定哪个更合适。爬虫相关技术。还聊了聊手头的offer情况等。到后面校招内推时，投的广州微信，但是广州微信并不怎么缺人，投的人又多，所以就没给面试机会。qq音乐把我捞了起来，但我并不想去深圳，就拒绝了。再后来校招的时候，不知道腾讯哪个部门邀请我去面试开发岗。我想了想，我并不想做开发，就拒绝了。现在看起来，腾讯我还是有很多机会的，然而我都拒绝了。哎，现在仔细想一想，虽然房价高，但是深圳其他方面都挺好的，空气质量好，各种生活还是很不错的，四个面试机会，只面了一个，其他的都自己拒绝的，感觉还是非常可惜的。 新浪。实习没有投，校招投的内推，面了四面，两面技术面，三面总监面，四面hr面。主要问了项目、gbdt与xgboost的区别、贝叶斯学派和统计学派的分歧，编程题问了反转链表leetcode206，top k大的数（剑指offer题目，第一版30题）。 搜狗。实习没有投，校招内推面了两面挂了，校招面了两面，发了offer。校招内推时，也是为了省事，找的搜狗某组的大大大师兄推的，跟百度那个类似，我也不感兴趣。面试问了项目，编程问了最小编辑距离leetcode 72 Edit Distance，剑指offer 31连续子数组的最大和（找到起始位置和最大和）。校招两面。主要是项目，二分类的评价标准有哪些、分别是什么。编程有二叉树的先序中序后续非递归遍历。二面面完说去看看领导在不在，回来说领导不在，就让回来了，说后面可能有hr面。我心想，这是委婉拒绝的套路吧，过了几天hr让我去公司面，问了下学历，问考研还是保研，有哪些offer，然后发了offer。 小米。三面技术面。面试之后，发了意向书，直到前些日子才联系我。我说我已经交其他公司三方，校招结束了。编程题问了leetcode 228. Summary Ranges， 给一个二叉树，找到最深的一个节点到最浅的一个节点之间的最小公共父节点，我的方法是层次遍历，找到最浅的节点及最深的节点，然后使用 leetcode 236 Lowest Common Ancestor of a Binary Tree中的方法去解决问题，时间效率为o（n），空间效率为o（n），面试官给的方法是保存所有路径，然后去查找。问了项目，两个项目问的非常细，使用random forest计算特征重要性，对该维特征不进行permutation，删除可以不可以。峰度、偏度的数学公式及意义。二分类中AUC的具体定义，各个分类评价方法。最后三面leader面的时候还问了两个思考问题，金融违约率，可能要房贷很长时间才能知道是否违约，数据少，实验样本回收时间长所以对于这个问题怎么处理。还有就是为何利用训练集训练，用来预测测试集可以用来预测。我说的是这是基于一个大的假设，训练样本和测试样本是基于独立同分布的，后来我想了想我觉得也可以从熵 信息增益的角度思考。 京东。 京东是实习过了，校招没邀请我面试。 校招的时候，我找的京东的师兄内推的，后来也参加了校招，笔试的挺好的，就是没邀请面试，也有一些同学跟我一样的情况，可能简历挂了吧。京东实习面试是三面，两面技术面，一面hr面。感觉比较坑的是京东的三面分别安排在了三天，为此我给我们老师请了三天假。京东用的较多的是Java，我自己是cpp Python较多。面试相对简单，问了svm原理推导，两个排好序的数组怎么合并成一个排好序的数组，双指针啊。问了一个业务题场景题，给你一些恶数据，让你对顾客对一个新商品的退单率预测，如果能预测出退单率，则可以延迟或者不发货，节约物流成本。hr面的时候问了几个问题，现在厉害的很多都是博士，你怎么看，有无读博的打算？介绍一个你的项目。 亚马逊。 亚马逊也是实习过了，校招没邀请我。亚马逊实习投的早，后来邀请去面试，共两面技术面。第一面是一个美丽的北邮学姐（我不认识），主要问了简历的项目，lstm的原理，lstm为何能长时记忆。二面有两位面试官同时面，主要是编程题，也问了项目。编程题相对都是比较容易的，主要是leetcode 1 Two Sum ，leetcode 15 3Sum，leetcode 16 3Sum Closest ，leetcode 18 4Sum。还问了一个业务场景预测题，亚马逊要销售很多商品，你如何去预测商品需要用到的货仓的体积。如果能预测出货仓体积，这样子就很容易去租赁仓库了。后面的公司都是实习和校招都没过的。有的是面试未通过，有的是没有面试，也一并写下来。 360。实习三面挂，校招内推一面挂。实习面试，是我第一次去面试，面的实习，路上还想，如果360过了，实习就结束了，可惜想法是美好的，现实是残酷。实习是三面，两面技术，一面hr。上午10点面，40分钟一场，等面完二面等下午1点半还是2点开始hr面。两面技术面的的确挺不好的，那是第一次去面试，也没看网上的面经，自己的技术也并不太好。技术主要问了，svm的原理，smo算法，lstm有什么好处，为何防止梯度爆炸和梯度消失，bp推导，编程题问了树的深度，这个简单，但是代码中竟然把==错写成了=，范了这样的错误。还有问了找出二叉树中和最大的一条路径，不必经过根节点leetcode 124. Binary Tree Maximum Path Sum。 hr面的时候问了以前的实习经历，考研还保研，我说考研，问考了多少分，有无对象，将来是打算在哪里发展。校招的时候，内推去面，一挂面。问了简历项目，问了聚类算法都有那些，算法的比较，cnn的原理各个层的作用，编程题问了二分搜索。感觉面的挺好的，然而还是挂了。很多同学都说360基本不缺人。的确实习还是校招，周围过360的很少，包括很多大牛。 阿里。 实习内推一面视频面，后来的实习校招也是一面挂，校招也是视频一面挂。实习面的时候，主要问了简历项目，问了svm的原理，svm的核函数的作用，lr能不能用核函数，为什么。校招的时候，问了多元高斯函数的期望是什么，怎么推导？熵的定义是什么？怎么理解？编程题是剑指offer 30题，最小的k个数，也是leetcode 215 Kth Largest Element in an Array，写代码并分析时间复杂度。阿里实习投的是阿里妈妈，校招投的是蚂蚁金服。除了技术需要加强之外，视频面试也表现出了两个缺点，一个是表达沟通需要大大的加强，一个是要自信，同学在旁边表示我的表达太快，太紧张了。还有一个非常重要的一点，我校招内推投的太晚了（8.8投的）以至于错过了校招内推的时间点，没人找我面试，直接到了校招了。我为什么投这么晚呢？可以记住一个时间点，大概6月底，7月初就开始互联网的内推了。我们是7月开始放实习，7.4才开始去实习公司报到，那个时候想着，简历上没有个像样的实习，刚去实习的公司，什么也不会呢，简历也不好写。所以想稍微等一等，结果8.8再投的时候，差不多快结束了，我记得校招的内推是8.18左右。所以时间节点一定要把握好，千万不要拖。 网易。实习的时候是笔试挂了，校招内推也是笔试挂了，校招的时候申的深度学习工程师，校招时二面挂。第一面是一个美女姐姐，第二面试是两位面试官一起面。主要问了项目，自己搭建网络的结构，CNN网络的结构，相关知名的cnn网络结构，编程就问了一道，一些坐标点都是（x，y）形式的让以x的大小排序，x一样的按y排序，我说很简单啊，使用sort函数写个compare函数就可以了，不知道是要考察什么，要考察现场写排序算法吗？我当时应该问问的。其实我对深度学习的了解还是太少，需要更多的学习，目前更多的是工程使用上的东西，我当时应该申机器学习工程师的，或许面试就通过了。 网易游戏。 实习的时候简历挂了，校招的时候本来申的人工智能工程师，结果给我转成了游戏研发工程师，还不能更改，我去面了，一面挂。首先可以说明一点，网易和网易游戏是分开招聘的，两家可以分别投。再有就是网易游戏有两块，一块是雷火盘古，一块是互娱。我实习投的是雷火，找了互娱的同学内推了一下，最开始不知道他们内部互不承认，结果相当于没有内推，简历就给我挂了。所以投雷火一定要找雷火的人推，投互娱一定要找互娱的人推，不然等于没有推。还有就是网易游戏实习开始的特别早，去年11月还是12月，就开始内推了，现在也是12月大家可以关注下消息。今年2月份我刚过完年来学校，我同学跟我说他网易游戏已经笔试过两批了，我顿时觉得自己落后了很多，有种别人校招都结束了，你才刚来学校的feel，何况我比学校规定的开学时候早来了十多天，当时一顿慌张，赶紧问问师兄师姐到底什么情况。再有就是校招面试，先是40分钟让写道编程题，然后再去见面试官。因为他们给我调成了开发，我自己也确实没什么经验，问的全是语言细节的，算法工程师从来不怎么问的，结果可想而知，就挂了。 今日头条。实习的时候一面挂，校招的时候也是一面挂。实习的时候问了简历，当时第一家面的360，挂了。貌似第二家面的头条，也挂了，挂了很多家，心情还是挺郁闷的当时。头条实习一面的时候先让写编程题，类似于剑指offer第一版的第7章的7.2里的题目，叫做多叉树（没有指向父节点指针）中两个节点的最低公共祖先。然后问了项目，问了svm的推导，问的非常细，问距离到底如何定义的，不可分的svm中松弛变量怎么理解，如果有个点特别异常，是否还能找到分割面，我自己当时水平也比较菜，他问一个我回答一个，我回答一个，他说一句靠（kao 四声），我心里一阵慌张。问了lr的公式推导。的确面的不好。校招的时候，找的内推，当时内推要内推码，但是内推有内推码也要笔试，但是内推码有一种是内推白金码，只有头条技术员工有，且每人只有一个，有了内推白金码，可以直接面试，免笔试，早面试。我就找人要了一个内推白金码，是头条的第一批面试，挂了。校招内推挂了，不能参加后续的校招，跟360一样的。校招一面，主要问了简历，问了项目，问了一些倒排索引，词向量及复杂度相关问题。编程是leetcode 57 Insert Interval，这是leetcode的hard题目，根据大家的反应，头条编程题问的普遍相对难一些。编程题我没答上来，挂了也是很正常的事情。 海康威视。实习没投，校招投了。共三面。先是电话一面，后是去公司面试二面和三面，而面试技术面2v1，三面是hr面。一面就是简单的聊了聊，问了问。二面是聊聊平时用什么技术，用什么网络，业内（我的研究方向）主要用什么方法，业内（我的研究方向）都在做什么，对了解多少，有无转方向的意愿。也没太多的问题，更多的是发散性的问题。hr面的时候，问了有多少offer了，因为已经很晚了，我就说我现在有7家公司发了sp offer。后来没给我发offer，我觉得可能主要在于我对方向了解甚少，我本来也不是研究那个方向，但是平时还是有很多与方向学习的机会，我都不想去学。这给我一个提示，除了技术的深度，一定要提高的自己涉猎的广度。 微策略。 先是线下笔试，然后三面技术面。微策略是先去听宣讲会，然后再线上面试。笔试面试都是全英的。笔试一小时，题目还是不太难的。面试一面，13*16 = 244，问这事几进制，答：（1x+3)(x+6) = 2x^2 + 4x + 4 =&gt; x=7。证明：n(n^2-1) 对于任何n&gt;=3的奇数都可以整除。答：可以数学归纳法，假定n=2k+1满足条件，证明（2k+3)也满足，最后得到[(2k+1)^3-(2k+1)] + 24k^2 + 48k + 24显然成立。问一个字符串的全排列，我以为是leetcode 46. Permutations，实际上是leetcode 47. Permutations II。我按照46的思路写的代码，主要差别是47是有重复的。后来他提示是否有bug，我想到了47，然后改了重复的部分，但是竟然又忘了先sort下。所以这道题答的不好。这道题答的不好，我也反思过，自己不够灵活，没考虑那么多，直接对上题号了，思想僵（jiang）化了，一定要与自己做过的题目对一起做对比，注意差别。二面。给一段代码，让找出bug，里面涉及了指针和malloc和strcpy这些，我没找出bug。编程题1，一段链表，反转前n个节点。类似于leetcode 92. Reverse Linked List II。编程题2，leetcode 25. Reverse Nodes in k-Group。 编程题3，single number问题leetcode 136. Single Number，编程题4，leetcode 137. Single Number II。三面。编程题1， 121. Best Time to Buy and Sell Stock，编程题2， leetcode 123. Best Time to Buy and Sell Stock III，编程题3，leetcode 122. Best Time to Buy and Sell Stock II，编程题4，397 Integer Replacement 。编程题 2写了两种方法，思考花了些时间。编程题4给了几种解法，但遗憾的是没有给出最优解。 商汤。实习的时候笔试过了，邀请面试，我当时有三四家都要面试，还要交ppt，听说比较难，就没去面。校招的时候笔试挂了。 face++，实习没投，校招笔试挂。 微软。实习和校招都是笔试挂了。 蘑菇街&amp;美丽说。 实习投了没理我。校招内推把我简历挂了，校招又投了一次，又挂了一次简历。 freewheel，第四范式，hulu，快手等投了校招，没消息，应该是简历挂了。看周围人都投了链家网的内推，我就投了链家网，结果链家的校招是线下笔试，我不知道，就错过了。 面试心得以上就是详细的面试部分，下面是一些自己参考别人的经验及自身的经历，总结的一些经验教训吧，希望对自己是一个总结，对学弟学妹们也希望能有所帮助吧。 把握好时间实习、校招的时间表。实习分为内推阶段和校招阶段。众所周知，互联网找工作的时间越来越早。2017年今年的情况是大部分公司在2-5月（实习包含内推和校招两阶段）。先是内推，后面就是校招。也有特别早的，比如网易游戏，去年12月左右就开始内推了。内推阶段刚走完或者没有走完就开始到了实习的校招阶段了。校招也分两个阶段，内推阶段和（正式）校招阶段。时间在6月底左右-11月。很多公司在6月底7月初就开始了，比如京东、阿里、腾讯等。京东以往貌似都是比较早的，今年也是早早的面试，早早地发了offer。除了内推和校招阶段，有的公司貌似还有提前批（京东貌似有）。我自己的教训就是，校招投的太晚，以至于错过了很多面试机会。我为什么投这么晚呢？上面也分析过，有希望能把实习经历写上去，也有自己想好好复习好好准备的因素。实习的时候我投的就非常早，结果准备的不充分，遇到了很多被拒，也算是找实习遇到的小后遗症吧。投的太晚错过了腾讯、阿里的校招内推阶段，是非常可惜的。阿里的校招内推需要重新内推，腾讯的实习的简历会直接转成校招内推的，不用再推，可以更新下自己投的部门信息就行了。我自己也没去更新简历。总之吧，自己的简历不够好看，希望能刷新下简历再投，以至于错过了时间。还有亚马逊，亚马逊写的校招开始时9.10，结果我投的晚，人家9.5就开始第2轮还是第3轮笔试了。挺可惜的错过了。 把握好内推和实习转正机会。现在大家都招内推了，然后内推跟正式的也差不多了。无论从实习还是校招的结果来看，内推会吸收很大一批人，所以留给校招的名额并不多，并且所有人都参加校招，所以竞争是非常激烈的。所以大家一定要把握好内推的机会。尤其校招的时候，很多公司的实习生都转正了，占用了很多名额，所以校招的内推和校招阶段竞争还是非常激烈的，学弟学妹们还是要加油。说是实习转正，大家要千万把握好机会。如果想在某个公司留下，我个人建议，优先去该公司实习。实习转正，尤其是实习的本部门转正是最容易的。想在哪个部门工作，实习是一个非常简单又省事的途径。内推的时候最好要找熟人内推。可以帮忙查看简历进度。腾讯的内部可以看到简历评价S级、A+、A、B、C等。也可以看到面试官的名称等信息。阿里的也可以看到面试官的名称信息，并依此判断某些信息。找熟人推，方便后续的联系。还有最好直接推到自己想去的部门。如果自己有明确的部门，可以直接推到相关部门，如果不写部门，很多都是直接进公司简历池。如果写了，相当于先在部门简历池，然后进公司简历池，相对而言，相当于多了一次机会。找熟人内推的另一个好处是，如果是投的他的部门，他可以直接把简历扔给他老大，邀请你去面试。 写好简历，讲好项目。简历肯定是特别重要的，简历是面试官对你的第一印象，一定要好好写，如实稍微修饰的写。自己的会的能讲清楚明白的都写上去，自己含糊其辞的搞不太清楚容易被问懵的就不要写了。经常更新自己的简历。我自己的简历面试完就会改一改，修一修，每次都总结一下面试，修缮一下简历。简历上的项目的细节之类的自己都要清楚地明白，一定不能给面试官问的答不出来，那面试官就很怀疑你的水平和项目是否你做的了。 提高自己的编程水平。很多人都推荐剑指offer、leetcode。的确很不错的，我看现在剑指offer都更新到第二版了。至于编程提高到什么水平，剑指offer可以都看了，都搞明白了。我自己是刷了300道leetcode，刷了两遍左右的。我看周围的同学大都在100-200左右的样子，也都找到的非常不错的工作。我这里的经验是算法工程师的，很多公司的（比如滴滴、美团、百度、阿里等）算法工程岗位的面试，一场面试都是分三块，项目介绍、机器学习相关知识、编程题。一场面试一般就一道编程题。编程写不出来就基本挂了。当然面试也没有非要按一定套路的，要看面试官的，面试官喜欢问什么，我们就答什么。有的公司非常注重编程，比如微软，面试几乎全是编程题，而且编程的要求比较高。头条的编程题问的也很不容易。要是想找一般的互联网公司，感觉看完剑指offer、刷leetcode 100-200道就差不多了。当然这是我自己的判断，仅供参考，对此不负责任。还有建议是刷题的时候，要做一下笔记，经常回头看一看，我刷题的时候，使用某笔记（电子笔记类产品，避免广告嫌疑）记录一下题目，标签，解决思路与方法等。以后方便回顾。我自己就是经常看一看自己做的笔记，比每次都重头刷，思路清晰多了。建议尝试一下。 提高机器学习相关的技术水平。算法工程师一定会问机器学习相关的知识，这一块一定要好好的搞清楚明白了。我自己是看了李航老师的统计学习方法+部分prml+一些其他的学习。对这一块内容的理解应该是决定是否发大offer的关键。一般编程题都能写出来，写不出来就挂了。你对机器学习相关的理解深入程度、好的实习经历、好的论文、好的竞赛都是面试中的亮点。如果你其他方面都不能闪光的话，就把对技术的理解深入作为切入点，好好的专研下去吧。 本贴的目的在于对自己一年工作的总结与思考，同时希望能对学弟学妹们有所帮助欢迎讨论，如有不当，望指出。最后祝学弟学妹们都能有好的实习，收割大量的offer！如需转载，注明出处。 相关问题及我的想法：1.可以简单介绍一下你简历上有几个项目(我看文章里说是2个)，以及项目的大致工作吗？我自己写简历的时候也是蛮尴尬的，项目的确非常少。我自己只有一段小公司的实习经历，而且跟算法关系不大。除此之外，因为导师严格不让实习，就没有实习经历了。相对比较好的是，我们实验室都是做算法相关的，所以我把本科毕设写了进去。研究生期间导师也没有项目，所以我把我的研究方向（就是我自己研究方向做的实验，也是研究生毕设）写了进去。之前还有参加了一个小型的竞赛，所以这样子就凑够了四个项目。一般简历上大家写3-4个就够了，写太多也没太多意义。其中我的那个小公司实习面试的时候几乎没人问，所以在面实习的时候主要是问研究生相关的那个项目，那个小竞赛，还有本科毕设。后来校招的时候就把那个小公司实习给换成了滴滴的实习，把小公司实习给删了。找工作的时候大家都会问你的实习经历。当时的本科毕设做的的确比较水，又加上本科时水平菜，做的的确就那样。研究生的毕设做的还是挺认真的，还是有进步的空间。如果重新走的话，我这些都会更认真的做，找实习找工作还是非常有有用的。研一暑假是去实习的好机会，那时我们是按校历放假的，又有时间，我没有抓住。 2.项目在面试过程中的重要性是1/3左右吗？如果给项目、机器学习知识以及编程排序，应该是怎么样的？有没有项目经历不足，但用基础知识去平衡的情况？很多同学都会问项目相关问题。面试中的确会问项目，一般一个小时一场面试，常规的是20分钟聊项目，20分钟聊机器学习相关知识，最后20分钟编程并白纸算法。时间20分钟只是估计，只能说是大概。一般一面都是技术，二面可能技术也可能会随便聊。如上文所述，我也没有特别好看的项目。都是本科毕设，研究生毕设，小竞赛这样子的。大家也可以发挥聪明的脑子想想怎么写简历。至于重要性，都是非常重要的。有的面试官喜欢全程聊项目，聊着项目穿插着机器学习相关知识的提问。之前找实习的时候，很多人阿里的一面就是拿着简历聊项目及相关知识。这也涉及一个很大的问题，就是面试到底要面什么？分解起来就是要面什么内容，想考察什么能力呢？或者说一个算法工程师对这些的要求是什么呢？很直白的，很基本的就是编程，算法的理解，工程实践能力，还会考察数学知识，脑筋急转弯等，甚至更加深入的会考察你的知识的广度，深度，还有随机应变的能力。对于编程，我认为最低要求是别让编程拖你的后腿，一般来说，每场面试都会有一个编程题，一般套路是先讲思路，再写代码。代码最好bug-free。即使没有bug-free，经过提醒想明白也是可以的。大部分都会让分析下你的算法时间复杂度，空间复杂度，并能说明为什么是这个时间复杂度。很多都会追求最优解，所以这也给刷题一个提示，刷题不是ac就可以了，而是要追求最优解。编程这块可以自己把握，千万不要只追求编程，不管其他的。这多个方面要平衡下时间和精力。我之前有一段时间整天刷题，有段时间整天看算法，感觉都不是很好。最好能平衡下来，不让任何一方面去拉后腿。很多公司来说，编程会考察，但是通过的大家都给出最优解，差别也没那么大，所以多多掌握机器学习相关的算法吧，目前我是这么看的。关于工程实践，也就项目。做的项目，都是工程实现的一部分，如果什么项目都没做过，我们是面试官，我们也会对这样的面试者不放心的。像很好的实习经历，很多实验室或导师不放实习的情况下，实习经历很多同学都没有。如果有实习机会，一定要把握住。比如研一下的暑假，那个假期如果放假时间比较长的话，可以找个短期的实习，体验一下。有些如ACM大神，可能很多人是到不了这个层次的。对于多数同学来说，的确没有太好的实习经历。解决办法是如果条件允许，就去找一段实习。如果条件不允许，可以在学校好好的学好相关的机器学习理论，做好自己的课题。有些同学参加一些竞赛，也是可以的。至于排名，肯定是越靠前越好。我自己做的那个小竞赛也没拿到太好的名次。根据我的面试来看，面试官或者hr可能会问面试排名，也可能不问。但是排名并不是重点，重点是你能讲清楚你的项目中，你做了什么工作，思考出了哪些思路，都用了哪些方法，具体的工作及收获是什么。他们看到你的项目，重点还是想通过你的项目，看清楚你的能力和实力。至于这些竞赛能不能写到简历上，当然完全是可以的。机器学习算法相关的理解。很多人说，算法工程师日常工作是调参，调模型。调参和调用模型还是要理解其中的原理，才能向正确的方向走。对算法的考察，重点会考察你基本功的理解，比如svm lr的基本原理，各种分类的评价准则，l1 l2的区别等。再拓展的就是对算法广度的理解，最基本的就是对常用的一些算法有深入的理解就够了。其他相关的，算法工程师要掌握的很多，数学相关的知识用到的很多，比如矩阵，概率论相关的。比如滴滴之前问的求A和B的乘得到的矩阵C的秩，面试官聊完告诉我，这道题的重点就是考察一下数学相关的知识，因为算法工程师日常会用到很多数学知识。再比如，美团内推面试一面的时候，还问了一个概率题，我忘了写了，是这样的。一个村子特别热爱男孩，最初村子里男女平衡，但是夫妻生孩子时，如果生到女儿就会一直生，直到生到男孩为止，问，多年后，男女比例是多少?还问了两个人轮流投硬币，直到有人投到正面为赢。问先手和后手赢的概率多少。两个题很类似。到最后，无论是聊项目，还是机器学习相关算法，都是要考察你的整个的思维能力，基本功的能力。如果没有很好的项目，就从实习、竞赛、自己的实验室项目、自己的研究课题等方面找找灵感。重点还是自己对这些知识的掌握程度还有编程的能力。 3.如果没有好看的项目，简历上如何形成项目呢？或者是在目前这个紧急的阶段，可以临时做一些什么事情补救？类似问题：你做的项目是实验室的项目吗？实验室本身不是研究机器学习方向的，没有项目怎么办呢？这个问题，跟前面的有些类似。就从实习、竞赛、自己的实验室项目、研究课题等方面找灵感。我一同学，他也是通信相关方向，转nlp。就先找了一个小一点的公司实习，然后校招去了tmd中的一家。项目不是越多越好，我之前见有人简历上写了7个项目，写满了。然而这也没太多意义。简历上除了项目，可以写一下个人技能之类的，突出下自己的优点。我自己也是项目不够多，凑的。或许其他学长学姐有独特的项目技巧，我不太知道。 4.我最近参加了一个XX的比赛，但最后的名次可能不太好（猜测前10%吧，比赛没结束，最近疯狂被超，但感觉自己已经没有思路了），这种经历可以往简历上写吗？当然可以了。如前文所述，项目竞赛之类的写上简历，如果有好看的名次，肯定是好的，没有也没关系。前10%已经很不错了。我以为，面试官更看重的还是通过这个竞赛，体现了你对哪些知识的运用，自己提供这个竞赛的解决方案和思路是什么。重点还是考察你的能力和水准在哪里。如果一个竞赛，你拿到了特别靠前的名次，但面试的时候，什么也讲不出来，都是靠随便调参得来的，没有东西可以讲，还是非常尴尬的。 刷题上，笔记也做了分析也做了，但没几天前面的就感觉一点儿也想不起来了类似：很担心编程题啊。虽然在刷题，但是感觉现场还是不一定能bug-free啊，刷题好难啊编程很多考察的还在easy，偏medium的水准。当然也看公司看部门，有些公司就是看中编程，比如微软，那你想去就好好搞好编程就好了。对于很多公司来说，编程知识考察的一部分，一般都是medium水准。也有部分公司或部门考察hard的。刷题的时候，多做笔记，经常回顾，多找同学讨论。一道题，多多的思考，多多的去讨论。思路这个东西，有时候同学的理解和见识能很大的帮助你的成长。的确会忘记，但是你可以把一类题目总结下方法，或者看别人总结的方法。这个要多练习，多总结，多交流。我也确实没特别好的方法。但是我觉得经常回顾与思考，经常练习，肯定会对编程有所提升的。我自己看了cpp primer的一半和算法导论的一半左右，基本都看了算是两边多一点吧。剑指offer倒是看了四五遍。leetcode我做的题也基本在两遍以上吧。面试的时候，除了编程，有时候也会考察cpp的基本知识（如果你用cpp的话），比如虚函数的概念，struct与class的区别，指针，static等。 从你的经历来看，无论是基础的机器学习知识还是编程题（从我刷leetcode和剑指offer来看，感觉都是medium和hard的题目）的掌握来看，感觉师兄很历害，也拿到了很多sp的offer。但是在阿里的面试仅仅是因为投的较晚的原因导致的吗？是否还有其他的因素和注意的点。因为想去杭州，所以对阿里格外的关注。不仅仅是因为投的晚。我想说的是投的晚是非常重要的一个影响因素。我投的时候，我周围的同学都已经面过二面或者三面了，也就是说基本都已经结束了。所以错过内推阶段，加上内推消耗很多名额，转正也消耗了很多名额，最后留给激烈的校招的名额不多。最根本的还是自己的简历和自己的能力不够优秀或者说不足。如果能力非常强，什么时候都有机会嘛。但是对于很多人，包括我认识一些非常牛的的大神来说，还是要把握好机会，能事半功倍。我这里的建议是把握时间和机会，提前好好准备，不要犹豫。我校招投的蚂蚁金服，蚂蚁金服相对阿里其他部门来说是非常难进的部门，今年蚂蚁金服的实习貌似容易一些，我没投蚂蚁实习，校招也不容易吧。想去杭州的话，将来实习可以直接申请阿里杭州的实习，转正直接转本部门就好了。这样的一个坏处就是将来校招的时候，你可能在杭州实习，如果来北京面试其他公司，可能会不会太方便。但是你有了那边的offer，麻烦点也就那么回事。虽然有的公司内部也可以转到杭州，我觉得还是直接转会好一点。阿里的面试，根据其他同学的反馈，除了简历、项目、编程外，也会问一些数学或脑筋急转弯的问题。关于数学概率论的简单的一道题，两个随机变量X Y都符合均匀分布，那X+Y符合什么分布呢？看你想去哪个部门，多跟那里的学长学姐交流，可以针对性的准备下。 关于项目的问题。从你分享的内容来看，感觉项目占的不是很多，这一块是否占的比例比较小。因为我在实验室没做什么项目，只是学了一些相关的大数据处理工具，所以项目这一块很缺，最近打了一些比赛，这个用来充实项目是否够。关于项目，基本每场面试都会问吧。有的我可能没写要问项目。70%的面试都会先问问项目，很多都会一个或者两个。也有的会简单的问，有的深入的问。看面试官的风格。竞赛可以充实项目。只要你的竞赛跟你要找的岗位匹配的上。 你觉得公司对 数据挖掘比赛 看重的程度怎样？除非很好很知名的比赛你拿到特别好的名词，一般来说，更注重要考察的是你的知识的理解，全局把控，提出的解决方案等相关的能力。因为我自己的竞赛比较小，所以都是谈论技术相关的。其他大神的nb竞赛我也不知道怎么样的。 补充小米还问了对于类别不平衡的样本怎么处理。搜狗，对于分类使用auc f值等，对于预测问题的标准怎么评判？新浪，问了bias-variance分解问题。美团，搜狗，xgboost调哪些参数，哪些参数有效果，训练时间，是想问下具体过程。百度，svm lr损失函数对比，对噪声敏感性。还有问为何random forest能够降低误差的。新浪还问了，先验相关的，哪种先验分别对应l1 l2，还有高斯的先验是什么。阿里，熵是什么。]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>实习</tag>
        <tag>校招</tag>
        <tag>面试经验</tag>
        <tag>面经</tag>
      </tags>
  </entry>
</search>
