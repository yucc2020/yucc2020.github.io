<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[100. Same Tree]]></title>
    <url>%2Fp%2F7dcacf8f%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[099. Recover Binary Search Tree]]></title>
    <url>%2Fp%2F3a244e25%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[098. Validate Binary Search Tree]]></title>
    <url>%2Fp%2F92064786%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[097. Interleaving String]]></title>
    <url>%2Fp%2Fa33cb2cc%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[096. Unique Binary Search Trees]]></title>
    <url>%2Fp%2Fd9eba394%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[095. Unique Binary Search Trees II]]></title>
    <url>%2Fp%2F68405e1a%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[094. Binary Tree Inorder Traversal]]></title>
    <url>%2Fp%2Fa4c01477%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[093. Restore IP Addresses]]></title>
    <url>%2Fp%2F3f3a9681%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[092. Reverse Linked List II]]></title>
    <url>%2Fp%2F7b414406%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[091. Decode Ways]]></title>
    <url>%2Fp%2F33438676%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[090. Subsets II]]></title>
    <url>%2Fp%2Ff25f3971%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[089. Gray Code]]></title>
    <url>%2Fp%2F57e82460%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[088. Merge Sorted Array]]></title>
    <url>%2Fp%2F505da9dc%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[087. Scramble String]]></title>
    <url>%2Fp%2Fae9f5ec9%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[086. Partition List]]></title>
    <url>%2Fp%2Fdc466425%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[085. Maximal Rectangle]]></title>
    <url>%2Fp%2Fba45e9ed%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[084. Largest Rectangle in Histogram]]></title>
    <url>%2Fp%2F4e21238e%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[083. Remove Duplicates from Sorted List]]></title>
    <url>%2Fp%2Ff95633fb%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[082. Remove Duplicates from Sorted List II]]></title>
    <url>%2Fp%2F89010df4%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[081. Search in Rotated Sorted Array II]]></title>
    <url>%2Fp%2Faabfef19%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[080. Remove Duplicates from Sorted Array II]]></title>
    <url>%2Fp%2F86a087%2F</url>
    <content type="text"><![CDATA[36.1% https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/ Follow up for “Remove Duplicates”: What if duplicates are allowed at most twice? 123456For example,Given sorted array nums = [1,1,1,2,2,3],Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn&apos;t matter what you leave beyond the new length. 方法一： 12345678910111213141516171819202122class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return n; int i=0, j=0; int index = 0; while(i&lt;n)&#123; j=i; while(j&lt;n &amp;&amp; nums[i]==nums[j]) j++; if(j==i+1)&#123; nums[index++] = nums[j-1]; &#125; else&#123; nums[index++] = nums[j-1]; nums[index++] = nums[j-1]; &#125; i = j; &#125; return index; &#125;&#125;; 怀疑下面的解法都是手误 cpp https://discuss.leetcode.com/topic/12892/simple-and-clear-c-recursive-solution Simple and clear c++ recursive solution 123456789101112131415161718class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (!head) return 0; if (!head-&gt;next) return head; int val = head-&gt;val; ListNode* p = head-&gt;next; if (p-&gt;val != val) &#123; head-&gt;next = deleteDuplicates(p); return head; &#125; else &#123; while (p &amp;&amp; p-&gt;val == val) p = p-&gt;next; return deleteDuplicates(p); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/7224/is-this-the-best-c-solution Is this the best C++ solution? 123456789101112131415161718192021222324class Solution &#123;public: ListNode *deleteDuplicates(ListNode *head) &#123; ListNode **runner = &amp;head; if(!head || !head-&gt;next)return head; while(*runner) &#123; if((*runner)-&gt;next &amp;&amp; (*runner)-&gt;next-&gt;val == (*runner)-&gt;val) &#123; ListNode *temp = *runner; while(temp &amp;&amp; (*runner)-&gt;val == temp-&gt;val) temp = temp-&gt;next; *runner = temp; &#125; else runner = &amp;((*runner)-&gt;next); &#125; return head; &#125;&#125;; 123456789101112131415class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int size=nums.size(); int i=0,j=0; while(i&lt;size)&#123; nums[j++]=nums[i]; while(i+2&lt;size &amp;&amp; nums[i]==nums[i+1] &amp;&amp; nums[i+1]==nums[i+2])&#123; i++; &#125; i++; &#125; return j; &#125;&#125;; python https://discuss.leetcode.com/topic/21369/python-in-place-solution-with-dummy-head-node Python in-place solution with dummy head node. 12345678910111213def deleteDuplicates(self, head): dummy = pre = ListNode(0) dummy.next = head while head and head.next: if head.val == head.next.val: while head and head.next and head.val == head.next.val: head = head.next head = head.next pre.next = head else: pre = pre.next head = head.next return dummy.next java https://discuss.leetcode.com/topic/3890/my-accepted-java-code My accepted Java code 1234567891011121314151617181920public ListNode deleteDuplicates(ListNode head) &#123; if(head==null) return null; ListNode FakeHead=new ListNode(0); FakeHead.next=head; ListNode pre=FakeHead; ListNode cur=head; while(cur!=null)&#123; while(cur.next!=null&amp;&amp;cur.val==cur.next.val)&#123; cur=cur.next; &#125; if(pre.next==cur)&#123; pre=pre.next; &#125; else&#123; pre.next=cur.next; &#125; cur=cur.next; &#125; return FakeHead.next; &#125; https://discuss.leetcode.com/topic/5206/my-recursive-java-solution My Recursive Java Solution 12345678910111213public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) return null; if (head.next != null &amp;&amp; head.val == head.next.val) &#123; while (head.next != null &amp;&amp; head.val == head.next.val) &#123; head = head.next; &#125; return deleteDuplicates(head.next); &#125; else &#123; head.next = deleteDuplicates(head.next); &#125; return head;&#125; if current node is not unique, return deleteDuplicates with head.next. If current node is unique, link it to the result of next list made by recursive call. Any improvement? https://discuss.leetcode.com/topic/24470/java-simple-and-clean-code-with-comment Java simple and clean code with comment 123456789101112131415161718192021public class Solution &#123;public ListNode deleteDuplicates(ListNode head) &#123; //use two pointers, slow - track the node before the dup nodes, // fast - to find the last node of dups. ListNode dummy = new ListNode(0), fast = head, slow = dummy; slow.next = fast; while(fast != null) &#123; while (fast.next != null &amp;&amp; fast.val == fast.next.val) &#123; fast = fast.next; //while loop to find the last node of the dups. &#125; if (slow.next != fast) &#123; //duplicates detected. slow.next = fast.next; //remove the dups. fast = slow.next; //reposition the fast pointer. &#125; else &#123; //no dup, move down both pointer. slow = slow.next; fast = fast.next; &#125; &#125; return dummy.next;&#125; &#125; https://discuss.leetcode.com/topic/11234/a-short-and-simple-java-solution A short and simple Java solution 12345678910111213141516public ListNode deleteDuplicates(ListNode head) &#123; ListNode dummy = new ListNode(0); ListNode d = dummy; while (head != null) &#123; if (head.next != null &amp;&amp; head.val == head.next.val) &#123; while (head.next != null &amp;&amp; head.val == head.next.val) head = head.next; &#125; else &#123; d.next = head; d = d.next; &#125; head = head.next; &#125; d.next = null; return dummy.next;&#125; 1-&gt;1-&gt;1-&gt;2-&gt;2-&gt;3 we skip all the 1’s and start the loop from 2 and also skip all the 2’s, and now head.val == 3; ponit d.next to the tail, end the loop]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[079. Word Search]]></title>
    <url>%2Fp%2F289213d2%2F</url>
    <content type="text"><![CDATA[26.8% https://leetcode.com/problems/word-search/ Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. 1234567891011For example,Given board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]word = &quot;ABCCED&quot;, -&gt; returns true,word = &quot;SEE&quot;, -&gt; returns true,word = &quot;ABCB&quot;, -&gt; returns false. 方法一： 我的代码实现: 123456789101112131415161718192021222324252627class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if(word.empty()) return true; if(board.size()==0 || board[0].size()==0) return false; for(int i=0; i&lt;board.size(); i++) for(int j=0; j&lt;board[0].size(); j++) if(helper(board, word, i, j, 0)) return true; return false; &#125; bool helper(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int i, int j, int k)&#123; int m=board.size(), n=board[0].size(); if(board[i][j]!=word[k]) return false; if(k==word.size()-1) return true; char c = board[i][j]; board[i][j] = '*'; bool res = false; if(j+1&lt;n) res = helper(board, word, i, j+1, k+1); if(!res &amp;&amp; i-1&gt;=0) res = helper(board, word, i-1, j, k+1); if(!res &amp;&amp; j-1&gt;=0) res = helper(board, word, i, j-1, k+1); if(!res &amp;&amp; i+1&lt;m) res = helper(board, word, i+1, j, k+1); board[i][j] = c; return res; &#125;&#125;; 典型的dfs，backtracking方法 My 19ms accepted C++ code 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt; &gt; &amp;board, string word) &#123; m=board.size(); n=board[0].size(); for(int x=0;x&lt;m;x++) for(int y=0;y&lt;n;y++) &#123; if(isFound(board,word.c_str(),x,y)) return true; &#125; return false; &#125;private: int m; int n; bool isFound(vector&lt;vector&lt;char&gt; &gt; &amp;board, const char* w, int x, int y) &#123; if(x&lt;0||y&lt;0||x&gt;=m||y&gt;=n||board[x][y]=='\0'||*w!=board[x][y]) return false; if(*(w+1)=='\0') return true; char t=board[x][y]; board[x][y]='\0'; if(isFound(board,w+1,x-1,y)||isFound(board,w+1,x+1,y)||isFound(board,w+1,x,y-1)||isFound(board,w+1,x,y+1)) return true; board[x][y]=t; return false; &#125;&#125;; My DFS + Backtracking C++ solution (16ms) Typical dfs+backtracking question. It compare board[row][col] with word[start], if they match, change board[row][col] to ‘*‘ to mark it as visited. Then move to the next one (i.e. word[start+1]) and compare it to the current neighbors ( doing it by recursion) 1234567891011121314151617181920212223242526272829class Solution &#123;private: bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, const string &amp;word, int start, int M, int N, int sLen) &#123; char curC; bool res = false; if( (curC = board[row][col]) != word[start]) return false; if(start==sLen-1) return true; board[row][col] = &apos;*&apos;; if(row&gt;0) res = dfs(board, row-1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; row &lt; M-1) res = dfs(board, row+1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; col &gt; 0) res = dfs(board, row, col-1, word, start+1, M, N, sLen); if(!res &amp;&amp; col &lt; N-1) res = dfs(board, row, col+1, word, start+1, M, N, sLen); board[row][col] = curC; return res; &#125; public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; int M,N,i,j,sLen = word.size(); if( (M=board.size()) &amp;&amp; (N=board[0].size()) &amp;&amp; sLen) &#123; for(i=0; i&lt;M; ++i) for(j=0; j&lt;N; ++j) if(dfs(board, i, j, word, 0, M, N, sLen)) return true; &#125; return false; &#125;&#125;; cpp https://discuss.leetcode.com/topic/9826/my-19ms-accepted-c-code My 19ms accepted C++ code 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt; &gt; &amp;board, string word) &#123; m=board.size(); n=board[0].size(); for(int x=0;x&lt;m;x++) for(int y=0;y&lt;n;y++) &#123; if(isFound(board,word.c_str(),x,y)) return true; &#125; return false; &#125;private: int m; int n; bool isFound(vector&lt;vector&lt;char&gt; &gt; &amp;board, const char* w, int x, int y) &#123; if(x&lt;0||y&lt;0||x&gt;=m||y&gt;=n||board[x][y]=='\0'||*w!=board[x][y]) return false; if(*(w+1)=='\0') return true; char t=board[x][y]; board[x][y]='\0'; if(isFound(board,w+1,x-1,y)||isFound(board,w+1,x+1,y)||isFound(board,w+1,x,y-1)||isFound(board,w+1,x,y+1)) return true; board[x][y]=t; return false; &#125;&#125;; https://discuss.leetcode.com/topic/19658/my-dfs-backtracking-c-solution-16ms My DFS + Backtracking C++ solution (16ms) Typical dfs+backtracking question. It compare board[row][col] with word[start], if they match, change board[row][col] to ‘*‘ to mark it as visited. Then move to the next one (i.e. word[start+1]) and compare it to the current neighbors ( doing it by recursion) 1234567891011121314151617181920212223242526272829class Solution &#123;private: bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, const string &amp;word, int start, int M, int N, int sLen) &#123; char curC; bool res = false; if( (curC = board[row][col]) != word[start]) return false; if(start==sLen-1) return true; board[row][col] = &apos;*&apos;; if(row&gt;0) res = dfs(board, row-1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; row &lt; M-1) res = dfs(board, row+1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; col &gt; 0) res = dfs(board, row, col-1, word, start+1, M, N, sLen); if(!res &amp;&amp; col &lt; N-1) res = dfs(board, row, col+1, word, start+1, M, N, sLen); board[row][col] = curC; return res; &#125; public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; int M,N,i,j,sLen = word.size(); if( (M=board.size()) &amp;&amp; (N=board[0].size()) &amp;&amp; sLen) &#123; for(i=0; i&lt;M; ++i) for(j=0; j&lt;N; ++j) if(dfs(board, i, j, word, 0, M, N, sLen)) return true; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/22788/python-dfs-solution-with-comments Python dfs solution with comments. 12345678910111213141516171819202122def exist(self, board, word): if not board: return False for i in xrange(len(board)): for j in xrange(len(board[0])): if self.dfs(board, i, j, word): return True return False# check whether can find word, start at (i,j) position def dfs(self, board, i, j, word): if len(word) == 0: # all the characters are checked return True if i&lt;0 or i&gt;=len(board) or j&lt;0 or j&gt;=len(board[0]) or word[0]!=board[i][j]: return False tmp = board[i][j] # first character is found, check the remaining part board[i][j] = &quot;#&quot; # avoid visit agian # check whether can find &quot;word&quot; along one direction res = self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i-1, j, word[1:]) \ or self.dfs(board, i, j+1, word[1:]) or self.dfs(board, i, j-1, word[1:]) board[i][j] = tmp return res https://discuss.leetcode.com/topic/12391/python-simple-dfs-solution Python simple dfs solution 1234567891011121314151617181920212223242526272829def exist(self, board, word): if not word: return True if not board: return False for i in range(len(board)): for j in range(len(board[0])): if self.exist_helper(board, word, i, j): return True return False def exist_helper(self, board, word, i, j): if board[i][j] == word[0]: if not word[1:]: return True board[i][j] = &quot; &quot; # indicate used cell # check all adjacent cells if i &gt; 0 and self.exist_helper(board, word[1:], i-1, j): return True if i &lt; len(board)-1 and self.exist_helper(board, word[1:], i+1, j): return True if j &gt; 0 and self.exist_helper(board, word[1:], i, j-1): return True if j &lt; len(board[0])-1 and self.exist_helper(board, word[1:], i, j+1): return True board[i][j] = word[0] # update the cell to its original value return False else: return False java https://discuss.leetcode.com/topic/7907/accepted-very-short-java-solution-no-additional-space Accepted very short Java solution. No additional space. Here accepted solution based on recursion. To save memory I decuded to apply bit mask for every visited cell. Please check board[y][x] ^= 256; 12345678910111213141516171819202122public boolean exist(char[][] board, String word) &#123; char[] w = word.toCharArray(); for (int y=0; y&lt;board.length; y++) &#123; for (int x=0; x&lt;board[y].length; x++) &#123; if (exist(board, y, x, w, 0)) return true; &#125; &#125; return false;&#125;private boolean exist(char[][] board, int y, int x, char[] word, int i) &#123; if (i == word.length) return true; if (y&lt;0 || x&lt;0 || y == board.length || x == board[y].length) return false; if (board[y][x] != word[i]) return false; board[y][x] ^= 256; boolean exist = exist(board, y, x+1, word, i+1) || exist(board, y, x-1, word, i+1) || exist(board, y+1, x, word, i+1) || exist(board, y-1, x, word, i+1); board[y][x] ^= 256; return exist;&#125; https://discuss.leetcode.com/topic/25591/simple-solution Simple solution 12345678910111213141516171819202122public boolean exist(char[][] board, String word) &#123; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[i].length; j++) &#123; if(exist(board, i, j, word, 0)) return true; &#125; &#125; return false;&#125;private boolean exist(char[][] board, int x, int y, String word, int start) &#123; if(start &gt;= word.length()) return true; if(x &lt; 0 || x &gt;= board.length || y &lt; 0 || y &gt;= board[0].length) return false; if (board[x][y] == word.charAt(start++)) &#123; char c = board[x][y]; board[x][y] = &apos;#&apos;; boolean res = exist(board, x + 1, y, word, start) || exist(board, x - 1, y, word, start) || exist(board, x, y + 1, word, start) || exist(board, x, y - 1, word, start); board[x][y] = c; return res; &#125; return false;&#125; https://discuss.leetcode.com/topic/21142/my-java-solution My Java solution 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; static boolean[][] visited; public boolean exist(char[][] board, String word) &#123; visited = new boolean[board.length][board[0].length]; for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[i].length; j++)&#123; if((word.charAt(0) == board[i][j]) &amp;&amp; search(board, word, i, j, 0))&#123; return true; &#125; &#125; &#125; return false; &#125; private boolean search(char[][]board, String word, int i, int j, int index)&#123; if(index == word.length())&#123; return true; &#125; if(i &gt;= board.length || i &lt; 0 || j &gt;= board[i].length || j &lt; 0 || board[i][j] != word.charAt(index) || visited[i][j])&#123; return false; &#125; visited[i][j] = true; if(search(board, word, i-1, j, index+1) || search(board, word, i+1, j, index+1) || search(board, word, i, j-1, index+1) || search(board, word, i, j+1, index+1))&#123; return true; &#125; visited[i][j] = false; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[078. Subsets]]></title>
    <url>%2Fp%2Fb92586e7%2F</url>
    <content type="text"><![CDATA[37.7% https://leetcode.com/problems/subsets/ Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. 12345678910111213For example,If nums = [1,2,3], a solution is:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 最标准解法，回溯法 位运算法，计算答案个数为2**n个，然后针对每一个，进行位运算，计算是否有相应位。 类似于动态规划，如果是0个数字，那肯定是空集。如果有一个元素，则要么是原答案空集，要么所有答案都加上这个新元素，所以每次翻倍。 方法一： my code: 回溯法：还需要再思考和理解 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs; vector&lt;int&gt; sub; genSubsets(nums, 0, sub, subs); return subs; &#125; void genSubsets(vector&lt;int&gt;&amp; nums, int start, vector&lt;int&gt;&amp; sub, vector&lt;vector&lt;int&gt;&gt;&amp; subs) &#123; subs.push_back(sub); for (int i = start; i &lt; nums.size(); i++) &#123; sub.push_back(nums[i]); genSubsets(nums, i + 1, sub, subs); sub.pop_back(); &#125; &#125;&#125;; 回溯法，我的实现 dfs表示，从0开始至n的一个回溯。 dfs(res, tmp, i+1, n, nums)表示从i+1开始的 可以看出，从start为第一个，开始，dfs一下后面的结果。 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; dfs(res, tmp, 0, nums.size(), nums); return res; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt;&amp; tmp, int start, int n, vector&lt;int&gt;&amp; nums)&#123; res.push_back(tmp); for(int i=start; i&lt;n; i++)&#123; tmp.push_back(nums[i]); dfs(res, tmp, i+1, n, nums); tmp.pop_back(); &#125; &#125;&#125;; 我的代码实现： 8.27.2017 12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; dfs(nums, res, tmp, 0); return res; &#125; void dfs(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, int k)&#123; res.push_back(tmp); if(k&gt;=nums.size()) return; for(int i=k; i&lt;nums.size(); i++)&#123; tmp.push_back(nums[i]); dfs(nums, res, tmp, i+1); tmp.pop_back(); &#125; &#125;&#125;; 方法二： 位运算： 12345678910111213141516class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int n = nums.size(); int subnum = pow(2, n); vector&lt;vector&lt;int&gt;&gt; res(subnum, vector&lt;int&gt;()); for(int i=0; i&lt;subnum; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if((i&gt;&gt;j)&amp;1) res[i].push_back(nums[j]); &#125; &#125; return res; &#125;&#125;; 方法三： 类似于dp的解法： 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs(1, vector&lt;int&gt;()); for (int i = 0; i &lt; nums.size(); i++) &#123; int n = subs.size(); for (int j = 0; j &lt; n; j++) &#123; subs.push_back(subs[j]); subs.back().push_back(nums[i]); &#125; &#125; return subs; &#125;&#125;; 下面这个discuss，很棒。 https://discuss.leetcode.com/topic/19110/c-recursive-iterative-bit-manipulation-solutions-with-explanations C++ Recursive/Iterative/Bit-Manipulation Solutions with Explanations Recursive (Backtracking) This is a typical problem that can be tackled by backtracking. Since backtracking has a more-or-less similar template, so I do not give explanations for this method. 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs; vector&lt;int&gt; sub; genSubsets(nums, 0, sub, subs); return subs; &#125; void genSubsets(vector&lt;int&gt;&amp; nums, int start, vector&lt;int&gt;&amp; sub, vector&lt;vector&lt;int&gt;&gt;&amp; subs) &#123; subs.push_back(sub); for (int i = start; i &lt; nums.size(); i++) &#123; sub.push_back(nums[i]); genSubsets(nums, i + 1, sub, subs); sub.pop_back(); &#125; &#125;&#125;; Iterative This problem can also be solved iteratively. Take [1, 2, 3] in the problem statement as an example. The process of generating all the subsets is like: Initially: [[]] Adding the first number to all the existed subsets: [[], [1]]; Adding the second number to all the existed subsets: [[], [1], [2], [1, 2]]; Adding the third number to all the existed subsets: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]. Have you got the idea :-) The code is as follows. 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs(1, vector&lt;int&gt;()); for (int i = 0; i &lt; nums.size(); i++) &#123; int n = subs.size(); for (int j = 0; j &lt; n; j++) &#123; subs.push_back(subs[j]); subs.back().push_back(nums[i]); &#125; &#125; return subs; &#125;&#125;; Bit Manipulation This is the most clever solution that I have seen. The idea is that to give all the possible subsets, we just need to exhaust all the possible combinations of the numbers. And each number has only two possibilities: either in or not in a subset. And this can be represented using a bit. There is also another a way to visualize this idea. That is, if we use the above example, 1 appears once in every two consecutive subsets, 2 appears twice in every four consecutive subsets, and 3 appears four times in every eight subsets, shown in the following (initially the 8 subsets are all empty): 1234567[], [], [], [], [], [], [], [][], [1], [], [1], [], [1], [], [1][], [1], [2], [1, 2], [], [1], [2], [1, 2][], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3] The code is as follows. 12345678910111213class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int num_subset = pow(2, nums.size()); vector&lt;vector&lt;int&gt; &gt; res(num_subset, vector&lt;int&gt;()); for (int i = 0; i &lt; nums.size(); i++) for (int j = 0; j &lt; num_subset; j++) if ((j &gt;&gt; i) &amp; 1) res[j].push_back(nums[i]); return res; &#125;&#125;; Well, just a final remark. For Python programmers, this may be an easy task in practice since the itertools package has a function combinations for it :-) https://discuss.leetcode.com/topic/19110/c-recursive-iterative-bit-manipulation-solutions-with-explanations/2 Interesting way to use the bit masks, building all subsets in parallel. I don’t think I’ve seen that before. Made me write a way to “only iterate over the 1-bits”: 1234for (int i = 0; i &lt; nums.size(); i++) for (int step = 1 &lt;&lt; i, start = 0; start &lt; num_subset; start += 2 * step) for (int j = start; j &lt; start + step; j++) res[j].push_back(nums[i]); Don’t know whether it’s faster. Overall, half of the bits are 1 anyway, so I save at most 50%. And I might have more overhead costs. Python’s combinations doesn’t quite do it, btw, it only creates subsets of a certain size. But it can be used, yes. Doesn’t help much compared to other solutions, though, as you can see here. And Ruby is even shorter :-) https://discuss.leetcode.com/topic/2764/my-solution-using-bit-manipulation My solution using bit manipulation 1234567891011121314class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt; &amp;S) &#123; sort (S.begin(), S.end()); int elem_num = S.size(); int subset_num = pow (2, elem_num); vector&lt;vector&lt;int&gt; &gt; subset_set (subset_num, vector&lt;int&gt;()); for (int i = 0; i &lt; elem_num; i++) for (int j = 0; j &lt; subset_num; j++) if ((j &gt;&gt; i) &amp; 1) subset_set[j].push_back (S[i]); return subset_set; &#125;&#125;; https://discuss.leetcode.com/topic/2764/my-solution-using-bit-manipulation/7 123456789101112131415161718192021222324252627282930313233343536This is an amazing solution.Learnt a lot.Let me try to explain this to those who didn&apos;t get the logic. Number of subsets for &#123;1 , 2 , 3 &#125; = 2^3 . why ? case possible outcomes for the set of subsets 1 -&gt; Take or dont take = 2 2 -&gt; Take or dont take = 2 3 -&gt; Take or dont take = 2 therefore , total = 2*2*2 = 2^3 = &#123; &#123; &#125; , &#123;1&#125; , &#123;2&#125; , &#123;3&#125; , &#123;1,2&#125; , &#123;1,3&#125; , &#123;2,3&#125; , &#123;1,2,3&#125; &#125;Lets assign bits to each outcome -&gt; First bit to 1 , Second bit to 2 and third bit to 3Take = 1Dont take = 0 0) 0 0 0 -&gt; Dont take 3 , Dont take 2 , Dont take 1 = &#123; &#125; 1) 0 0 1 -&gt; Dont take 3 , Dont take 2 , take 1 = &#123;1 &#125; 2) 0 1 0 -&gt; Dont take 3 , take 2 , Dont take 1 = &#123; 2 &#125; 3) 0 1 1 -&gt; Dont take 3 , take 2 , take 1 = &#123; 1 , 2 &#125; 4) 1 0 0 -&gt; take 3 , Dont take 2 , Dont take 1 = &#123; 3 &#125; 5) 1 0 1 -&gt; take 3 , Dont take 2 , take 1 = &#123; 1 , 3 &#125; 6) 1 1 0 -&gt; take 3 , take 2 , Dont take 1 = &#123; 2 , 3 &#125; 7) 1 1 1 -&gt; take 3 , take 2 , take 1 = &#123; 1 , 2 , 3 &#125; In the above logic ,Insert S[i] only if (j&gt;&gt;i)&amp;1 ==true &#123; j E &#123; 0,1,2,3,4,5,6,7 &#125; i = ith element in the input array &#125;element 1 is inserted only into those places where 1st bit of j is 1 if( j &gt;&gt; 0 &amp;1 ) ==&gt; for above above eg. this is true for sl.no.( j )= 1 , 3 , 5 , 7 element 2 is inserted only into those places where 2nd bit of j is 1 if( j &gt;&gt; 1 &amp;1 ) == for above above eg. this is true for sl.no.( j ) = 2 , 3 , 6 , 7element 3 is inserted only into those places where 3rd bit of j is 1 if( j &gt;&gt; 2 &amp; 1 ) == for above above eg. this is true for sl.no.( j ) = 4 , 5 , 6 , 7 Time complexity : O(n*2^n) , for every input element loop traverses the whole solution set length i.e. 2^n https://discuss.leetcode.com/topic/11373/c-8ms-simple-iterative-solution C++ 8ms simple iterative solution 1234567891011121314151617class Solution &#123;public:vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt; &amp;S) &#123; vector&lt;vector&lt;int&gt; &gt; res(1, vector&lt;int&gt;()); sort(S.begin(), S.end()); for (int i = 0; i &lt; S.size(); i++) &#123; int n = res.size(); for (int j = 0; j &lt; n; j++) &#123; res.push_back(res[j]); res.back().push_back(S[i]); &#125; &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/19561/python-easy-to-understand-solutions-dfs-recursively-bit-manipulation-iteratively Python easy to understand solutions (DFS recursively, Bit Manipulation, Iteratively). 12345678910# DFS recursively def subsets1(self, nums): res = [] self.dfs(sorted(nums), 0, [], res) return res def dfs(self, nums, index, path, res): res.append(path) for i in xrange(index, len(nums)): self.dfs(nums, i+1, path+[nums[i]], res) 1234567891011# Bit Manipulation def subsets2(self, nums): res = [] nums.sort() for i in xrange(1&lt;&lt;len(nums)): tmp = [] for j in xrange(len(nums)): if i &amp; 1 &lt;&lt; j: # if i &gt;&gt; j &amp; 1: tmp.append(nums[j]) res.append(tmp) return res 123456# Iterativelydef subsets(self, nums): res = [[]] for num in sorted(nums): res += [item+[num] for item in res] return res https://discuss.leetcode.com/topic/30867/simple-iteration-no-recursion-no-twiddling-explanation Simple iteration (no recursion, no twiddling) + explanation My idea was to start out with an empty subset and either take or don’t take the next element in the input array. Here’s how it goes down for input [1,2,3]: start with 1[] // empty set is always a subset then either take or not take the next element (1), this doubles the result size: 12[] // not take 1[1] // take 1 + new then take or not take the next element: 2 1234[] // not take 1, not take 2[2] // not take 1, take 2 + new[1] // take 1, not take 2[1,2] // take 1, take 2 + new and finally take or not take 3. 12345678[] // not take 1, not take 2, not take 3[3] // not take 1, not take 2, take 3 + new[2] // not take 1, take 2, not take 3[2,3] // not take 1, take 2, take 3 + new[1] // take 1, not take 2, not take 3[1,3] // take 1, not take 2, take 3 + new[1,2] // take 1, take 2, not take 3[1,2,3] // take 1, take 2, take 3 + new And we’re done, we have all 2^3 = 8 subsets generated. It is possible to generate these with a simple loop, there’s only one trick here, the variable size. It’s usually a good practice to cache method call results, but now it is cached for a different reason: because it changes in every iteration. If we don’t want to end up with an infinite loop, we have to remember how many results were available in the previous iteration, which is exactly the size() of the result at the beginning of the current iteration. 12345678910111213public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; Arrays.sort(nums); // make sure subsets are ordered List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); result.add(new ArrayList&lt;&gt;()); // start with empty set for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = 0, size = result.size(); j &lt; size; ++j) &#123; // remember List&lt;Integer&gt; subset = new ArrayList&lt;&gt;(result.get(j)); // copy a new one subset.add(nums[i]); // expand result.add(subset); // collect &#125; &#125; return result;&#125; It is also necessary to order the input to satisfy the requirement: 1Elements in a subset must be in non-descending order. Because i is increasing it means that whatever we take from nums will also be in increasing order. The other requirement: 1The solution set must not contain duplicate subsets. is automatically guaranteed by the input specification and the algorithm walking indices straight and once: 1Given a set of distinct integers, nums, return all possible subsets. [emphasis mine] java https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning) This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. Subsets : https://leetcode.com/problems/subsets/ 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Subsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Permutations : https://leetcode.com/problems/permutations/ 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/ 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum : https://leetcode.com/problems/combination-sum/ 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum II (can’t reuse same element) : https://leetcode.com/problems/combination-sum-ii/ 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Palindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/ 12345678910111213141516171819202122232425public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list;&#125;public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125;&#125;public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true;&#125; https://discuss.leetcode.com/topic/9031/simple-java-solution-with-for-each-loops Simple Java Solution with For-Each loops No messy indexing. Avoid the ConcurrentModificationException by using a temp list. 123456789101112131415161718public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] S) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); res.add(new ArrayList&lt;Integer&gt;()); Arrays.sort(S); for(int i : S) &#123; List&lt;List&lt;Integer&gt;&gt; tmp = new ArrayList&lt;&gt;(); for(List&lt;Integer&gt; sub : res) &#123; List&lt;Integer&gt; a = new ArrayList&lt;&gt;(sub); a.add(i); tmp.add(a); &#125; res.addAll(tmp); &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/10885/java-subsets-solution Java subsets solution 123456789101112131415161718192021222324public class Solution &#123;public List&lt;List&lt;Integer&gt;&gt; subsets(int[] S) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(S.length == 0)&#123; return result; &#125; Arrays.sort(S); dfs(S, 0, new ArrayList&lt;Integer&gt;(), result); return result;&#125;public void dfs(int[] s, int index, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)&#123; result.add(new ArrayList&lt;Integer&gt;(path)); for(int i = index; i &lt; s.length; i++)&#123; path.add(s[i]); dfs(s, i+1, path, result); path.remove(path.size()-1); &#125;&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[077. Combinations]]></title>
    <url>%2Fp%2F20864a35%2F</url>
    <content type="text"><![CDATA[39.6% https://leetcode.com/problems/combinations/ Given two integers n and k, return all possible combinations of k numbers out of 1 … n. 1234567891011For example,If n = 4 and k = 2, a solution is:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 方法一： 回溯法，dfs code 1： My shortest c++ solution,using dfs my idea is using backtracking ,every time I push a number into vector,then I push a bigger one into it; then i pop the latest one,and push a another bigger one… and if I has push k number into vector,I push this into result; this solution take 24 ms. 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt; &gt;res; if(n&lt;k)return res; vector&lt;int&gt; temp(0,k); combine(res,temp,0,0,n,k); return res; &#125; void combine(vector&lt;vector&lt;int&gt; &gt; &amp;res,vector&lt;int&gt; &amp;temp,int start,int num,int n ,int k)&#123; if(num==k)&#123; res.push_back(temp); return; &#125; for(int i = start;i&lt;n;i++)&#123; temp.push_back(i+1); combine(res,temp,i+1,num+1,n,k); temp.pop_back(); &#125; &#125;&#125;; code 2: 我的实现 经典的回溯法算法，一定要会。 my code： 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; if(n&lt;k) return res; dfs(res, tmp, 0, 0, n, k); return res; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, int start, int num, int n, int k)&#123; if(num==k)&#123; res.push_back(tmp); return; &#125; for(int i=start+1; i&lt;=n; i++)&#123; tmp.push_back(i); dfs(res, tmp, i, num+1, n, k); tmp.pop_back(); &#125; &#125;&#125;; code 3： https://discuss.leetcode.com/topic/22569/c-concise-recursive-solution-c-n-k-c-n-1-k-1-8ms C++ concise recursive solution C(n,k) -&gt;C(n-1,k-1) / 8ms 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; temp; combine(1,n,k,ans,temp); //call fuction to get combination of k numbers which range is 1-n return ans; &#125;private: void combine(int begin,int n, int k, vector&lt;vector&lt;int&gt;&gt; &amp;ans, vector&lt;int&gt;&amp; temp)&#123; if(k==0)&#123; ans.push_back(temp); return; &#125; //condition : n-i+1 is the range, range must greater than k for(int i=begin;n-i+1&gt;=k;i++)&#123; // for the ith iteration, get the combination of i and k-1 numbers differ from i. temp.push_back(i); combine(i+1,n,k-1,ans,temp);// get the combination of k-1 numbers which range is(i+1,n) temp.pop_back(); &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/26689/short-iterative-c-answer-8ms Short Iterative C++ Answer 8ms 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; result; int i = 0; vector&lt;int&gt; p(k, 0); while (i &gt;= 0) &#123; p[i]++; if (p[i] &gt; n) --i; else if (i == k - 1) result.push_back(p); else &#123; ++i; p[i] = p[i - 1]; &#125; &#125; return result; &#125;&#125;; 12ms, 27.43%, May.6th, 2016 https://leetcode.com/discuss/12915/my-shortest-c-solution-using-dfs My shortest c++ solution,using dfs my idea is using backtracking ,every time I push a number into vector,then I push a bigger one into it; then i pop the latest one,and push a another bigger one… and if I has push k number into vector,I push this into result; this solution take 24 ms. 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt; &gt;res; if(n&lt;k)return res; vector&lt;int&gt; temp(0,k); combine(res,temp,0,0,n,k); return res; &#125; void combine(vector&lt;vector&lt;int&gt; &gt; &amp;res,vector&lt;int&gt; &amp;temp,int start,int num,int n ,int k)&#123; if(num==k)&#123; res.push_back(temp); return; &#125; for(int i = start;i&lt;n;i++)&#123; temp.push_back(i+1); combine(res,temp,i+1,num+1,n,k); temp.pop_back(); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/22569/c-concise-recursive-solution-c-n-k-c-n-1-k-1-8ms C++ concise recursive solution C(n,k) -&gt;C(n-1,k-1) / 8ms 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; temp; combine(1,n,k,ans,temp); //call fuction to get combination of k numbers which range is 1-n return ans; &#125;private: void combine(int begin,int n, int k, vector&lt;vector&lt;int&gt;&gt; &amp;ans, vector&lt;int&gt;&amp; temp)&#123; if(k==0)&#123; ans.push_back(temp); return; &#125; //condition : n-i+1 is the range, range must greater than k for(int i=begin;n-i+1&gt;=k;i++)&#123; // for the ith iteration, get the combination of i and k-1 numbers differ from i. temp.push_back(i); combine(i+1,n,k-1,ans,temp);// get the combination of k-1 numbers which range is(i+1,n) temp.pop_back(); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/14626/1-liner-3-liner-4-liner 1-liner, 3-liner, 4-liner Library - AC in 64 ms First the obvious solution - Python already provides this functionality and it’s not forbidden, so let’s take advantage of it. 12345from itertools import combinationsclass Solution: def combine(self, n, k): return list(combinations(range(1, n+1), k)) Recursive - AC in 76 ms But doing it yourself is more interesting, and not that hard. Here’s a recursive version. 12345class Solution: def combine(self, n, k): if k == 0: return [[]] return [pre + [i] for i in range(1, n+1) for pre in self.combine(i-1, k-1)] Iterative - AC in 76 ms And here’s an iterative one. 123456class Solution: def combine(self, n, k): combs = [[]] for _ in range(k): combs = [[i] + c for c in combs for i in range(1, c[0] if c else n+1)] return combs Reduce - AC in 76 ms Same as that iterative one, but using reduce instead of a loop: 1234class Solution: def combine(self, n, k): return reduce(lambda C, _: [[i]+c for c in C for i in range(1, c[0] if c else n+1)], range(k), [[]]) https://discuss.leetcode.com/topic/25958/ac-python-backtracking-iterative-solution-60-ms AC Python backtracking iterative solution 60 ms 1234567891011121314151617181920def combine(self, n, k): ans = [] stack = [] x = 1 while True: l = len(stack) if l == k: ans.append(stack[:]) if l == k or x &gt; n - k + l + 1: if not stack: return ans x = stack.pop() + 1 else: stack.append(x) x += 1# 26 / 26 test cases passed.# Status: Accepted# Runtime: 60 ms# 98.51% Combinations is typical application for backtracking. Two conditions for back track: (1) the stack length is already k (2) the current value is too large for the rest slots to fit in since we are using ascending order to make sure the uniqueness of each combination. java https://discuss.leetcode.com/topic/11718/backtracking-solution-java Backtracking Solution Java 12345678910111213141516public static List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; combs = new ArrayList&lt;List&lt;Integer&gt;&gt;(); combine(combs, new ArrayList&lt;Integer&gt;(), 1, n, k); return combs;&#125;public static void combine(List&lt;List&lt;Integer&gt;&gt; combs, List&lt;Integer&gt; comb, int start, int n, int k) &#123; if(k==0) &#123; combs.add(new ArrayList&lt;Integer&gt;(comb)); return; &#125; for(int i=start;i&lt;=n;i++) &#123; comb.add(i); combine(combs, comb, i+1, n, k-1); comb.remove(comb.size()-1); &#125;&#125; https://discuss.leetcode.com/topic/12537/a-short-recursive-java-solution-based-on-c-n-k-c-n-1-k-1-c-n-1-k A short recursive Java solution based on C(n,k)=C(n-1,k-1)+C(n-1,k) Basically, this solution follows the idea of the mathematical formula C(n,k)=C(n-1,k-1)+C(n-1,k). Here C(n,k) is divided into two situations. Situation one, number n is selected, so we only need to select k-1 from n-1 next. Situation two, number n is not selected, and the rest job is selecting k from n-1. 123456789101112131415public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; if (k == n || k == 0) &#123; List&lt;Integer&gt; row = new LinkedList&lt;&gt;(); for (int i = 1; i &lt;= k; ++i) &#123; row.add(i); &#125; return new LinkedList&lt;&gt;(Arrays.asList(row)); &#125; List&lt;List&lt;Integer&gt;&gt; result = this.combine(n - 1, k - 1); result.forEach(e -&gt; e.add(n)); result.addAll(this.combine(n - 1, k)); return result; &#125;&#125; https://discuss.leetcode.com/topic/3943/dp-for-the-problem DP for the problem I didn’t see any DP solution for this problem, so I share mine: The idea is simple, if the combination k out of n (select k elements from [1,n]) is combine(k, n). Let’s consider how can we get combine(k, n) by adding the last element n to something we already have (combine(k - 1, n - 1) and combine(k, n - 1)). Actually, the combine(k, n) has two parts, one part is all combinations without n, it’s combine(k, n - 1), another is all combinations with n, which can be gotten by appending n to every element in combine(k - 1, n - 1). Note, the combine(i, i) is what we can get directly. Below is my code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Solution&#123; // Combine(n, n). private List&lt;Integer&gt; allContain(int n) &#123; final List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= n; ++i) &#123; result.add(i); &#125; return result; &#125; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;List&lt;Integer&gt;&gt;&gt; previous = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= n; ++i) &#123; previous.add(Collections.singletonList(Collections.&lt;Integer&gt;emptyList())); &#125; for (int i = 1; i &lt;= k; ++i) &#123; final List&lt;List&lt;List&lt;Integer&gt;&gt;&gt; current = new ArrayList&lt;&gt;(); current.add(Collections.singletonList(allContain(i))); // Combine(i, j). for (int j = i + 1; j &lt;= n; ++j) &#123; final List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Combine(i, j - 1). list.addAll(current.get(current.size() - 1)); // Comine(i - 1, j - 1). for (final List&lt;Integer&gt; item : previous.get(current.size())) &#123; final List&lt;Integer&gt; newItem = new ArrayList&lt;&gt;(item); newItem.add(j); list.add(newItem); &#125; current.add(list); &#125; previous = current; &#125; return (previous.size() == 0) ? Collections.&lt;List&lt;Integer&gt;&gt;emptyList() : previous.get(previous.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[076. Minimum Window Substring]]></title>
    <url>%2Fp%2F9aa229a6%2F</url>
    <content type="text"><![CDATA[25.7% https://leetcode.com/problems/minimum-window-substring/ Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). 1234For example,S = &quot;ADOBECODEBANC&quot;T = &quot;ABC&quot;Minimum window is &quot;BANC&quot;. Note:If there is no such window in S that covers all characters in T, return the empty string “”. If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S. Subscribe to see which companies asked this question 方法一： 我的代码实现，更容易理解逻辑，如下： 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string minWindow(string s, string t) &#123; int m = s.size(), n = t.size(); if(n&gt;m) return &quot;&quot;; vector&lt;int&gt; v(256, 0); for(int i=0; i&lt;n; i++) v[t[i]]++; int left = 0; int right = 0; int head = 0; int len = INT_MAX; int cnt = n; while(right&lt;m)&#123; if(v[s[right]]&gt;0) cnt--; v[s[right]]--; right++; while(cnt==0)&#123; // left++, 不考虑left&gt;=m 因为left不可能&gt;=m，否则cnt！=0 if(right-left&lt;len)&#123; head = left; len = right-left; &#125; if(v[s[left]]==0) cnt++; v[s[left]]++; left++; &#125; &#125; return len!=INT_MAX?s.substr(head, len):&quot;&quot;; &#125;&#125;; 重点方法，重点学习，并且带有模板 https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems 9ms, 86.18%, September 22, 2016 Here is a 10-line template that can solve most ‘substring’ problems I will first give the solution then show you the magic template. The code of solving this problem is below. It might be the shortest among all solutions provided in Discuss. 12345678910111213141516class Solution &#123;public: string minWindow(string s, string t) &#123; vector&lt;int&gt; map(128, 0); for(auto c:t) map[c]++; int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0; while(end&lt;s.size())&#123; if(map[s[end++]]--&gt;0) counter--; while(counter==0)&#123; if(end-begin&lt;d) d=end-(head=begin); if(map[s[begin++]]++==0) counter++; &#125; &#125; return d==INT_MAX?&quot;&quot;:s.substr(head, d); &#125;&#125;; Here comes the template. For most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers. The template is given below. 12345678910111213141516171819202122232425int findSubstring(string s)&#123; vector&lt;int&gt; map(128,0); int counter; // check whether the substring is valid int begin=0, end=0; //two pointers, one point to tail and one head int d; //the length of substring for() &#123; /* initialize the hash map here */ &#125; while(end&lt;s.size())&#123; if(map[s[end++]]-- ?)&#123; /* modify counter here */ &#125; while(/* counter condition */)&#123; /* update d here if finding minimum*/ //increase begin to make it invalid/valid again if(map[s[begin++]]++ ?)&#123; /*modify counter here*/ &#125; &#125; /* update d here if finding maximum*/ &#125; return d; &#125; One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop. The code of solving Longest Substring with At Most Two Distinct Characters is below: 12345678910int lengthOfLongestSubstringTwoDistinct(string s) &#123; vector&lt;int&gt; map(128, 0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++==0) counter++; while(counter&gt;2) if(map[s[begin++]]--==1) counter--; d=max(d, end-begin); &#125; return d; &#125; Longest Substring with At Most Two Distinct Characters （带锁） The code of solving Longest Substring Without Repeating Characters is below: Update 01.04.2016, thanks @weiyi3 for advise. 12345678910int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; map(128,0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++&gt;0) counter++; while(counter&gt;0) if(map[s[begin++]]--&gt;1) counter--; d=max(d, end-begin); //while valid, update d &#125; return d; &#125; I think this post deserves some upvotes! : ) code 2： 代码解读： 12345678910111213141516171819202122232425// S = &quot;ADOBECODEBANC&quot;// T = &quot;ABC&quot;class Solution &#123;public: string minWindow(string s, string t) &#123; vector&lt;int&gt; map(128, 0); for(auto c:t) map[c]++; int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0; while(end&lt;s.size())&#123; if(map[s[end++]]--&gt;0) counter--; while(counter==0)&#123; // 如果能进入count==0， 说明begin至end之间的包括t的所有字符 if(end-begin&lt;d)&#123; //简单的判断 head = begin; d = end - head; &#125; if(map[s[begin]]==0)&#123;// begin指向值的如果在此时是0，说明这个值一定是t的值，如果不是，值一定是负的，因为前面减了。 counter++; &#125; map[s[begin]]++; // 本来进入一个值是减的，减少一个值，这个map值的增加的 begin++; // 如果进入了满足counter==0状态，肯定要begin++，向前走的 &#125; &#125; return d==INT_MAX?&quot;&quot;:s.substr(head, d); &#125;&#125;; https://discuss.leetcode.com/topic/3107/accepted-o-n-solution https://oj.leetcode.com/discuss/5469/is-the-length-of-t-considered-constant-or-m Implementation of mike3’s idea 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: string minWindow(string S, string T) &#123; if (S.empty() || T.empty()) &#123; return &quot;&quot;; &#125; int count = T.size(); int require[128] = &#123;0&#125;; bool chSet[128] = &#123;false&#125;; for (int i = 0; i &lt; count; ++i) &#123; require[T[i]]++; chSet[T[i]] = true; &#125; int i = -1; int j = 0; int minLen = INT_MAX; int minIdx = 0; while (i &lt; (int)S.size() &amp;&amp; j &lt; (int)S.size()) &#123; if (count) &#123; i++; require[S[i]]--; if (chSet[S[i]] &amp;&amp; require[S[i]] &gt;= 0) &#123; count--; &#125; &#125; else &#123; if (minLen &gt; i - j + 1) &#123; minLen = i - j + 1; minIdx = j; &#125; require[S[j]]++; if (chSet[S[j]] &amp;&amp; require[S[j]] &gt; 0) &#123; count++; &#125; j++; &#125; &#125; if (minLen == INT_MAX) &#123; return &quot;&quot;; &#125; return S.substr(minIdx, minLen); &#125;&#125;; https://discuss.leetcode.com/topic/6026/sharing-my-straightforward-o-n-solution-with-explanation There are three key variables in my solution: 1unordered_map &lt;char, int&gt; map; unordered_map&lt;char, int&gt; window; int letterCounter; variable “map” is used to indicate what characters and how many characters are in T. variable “window” is to indicate what characters and how many characters are between pointer “slow” and pointer “fast”. Now let’s start. The first For loop is used to construct variable “map”. The second For loop is used to find the minimum window. The first thing we should do in the second For loop is to find a window which can cover T. I use “letterCounter” to be a monitor. If “letterCounter” is equal to T.length(), then we find this window. Before that, only the first If clause can be executed. However, after we find this window, the second If clause can also be executed. In the second If clause, we move “slow” forward in order to shrink the window size. Every time finding a smaller window, I update the result. At the end of program, I return result, which is the minimum window. 123456789101112131415161718192021222324252627282930313233string minWindow(string S, string T) &#123; string result; if(S.empty() || T.empty())&#123; return result; &#125; unordered_map&lt;char, int&gt; map; unordered_map&lt;char, int&gt; window; for(int i = 0; i &lt; T.length(); i++)&#123; map[T[i]]++; &#125; int minLength = INT_MAX; int letterCounter = 0; for(int slow = 0, fast = 0; fast &lt; S.length(); fast++)&#123; char c = S[fast]; if(map.find(c) != map.end())&#123; window[c]++; if(window[c] &lt;= map[c])&#123; letterCounter++; &#125; &#125; if(letterCounter &gt;= T.length())&#123; while(map.find(S[slow]) == map.end() || window[S[slow]] &gt; map[S[slow]])&#123; window[S[slow]]--; slow++; &#125; if(fast - slow + 1 &lt; minLength)&#123; minLength = fast - slow + 1; result = S.substr(slow, minLength); &#125; &#125; &#125; return result;&#125; python 232ms, 32.27%, September 23, 2016 12 lines Python https://discuss.leetcode.com/topic/20692/12-lines-python The current window is s[i:j] and the result window is s[I:J]. In need[c] I store how many times I need character c (can be negative) and missing tells how many characters are still missing. In the loop, first add the new character to the window. Then, if nothing is missing, remove as much as possible from the window start and then update the result.12345678910111213141516171819class Solution(object): def minWindow(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: str &quot;&quot;&quot; need, missing = collections.Counter(t), len(t) i = I = J = 0 for j, c in enumerate(s, 1): missing -= need[c] &gt; 0 need[c] -= 1 if not missing: while i&lt;j and need[s[i]] &lt; 0: need[s[i]] += 1 i += 1 if not J or j-i &lt;= J-I: I, J = i, j return s[I:J] https://discuss.leetcode.com/topic/6665/accepted-python-solution-using-hashtable Accepted Python solution using hashtable 1234567891011121314151617181920212223242526class Solution: # @return a string def minWindow(self, S, T): indices = &#123;&#125; for char in T: indices[char] = [] miss = list(T) start = 0 end = len(S) for i in range(len(S)): if S[i] in T: if S[i] not in miss and indices[S[i]] != []: indices[S[i]].pop(0) elif S[i] in miss: miss.remove(S[i]) indices[S[i]].append(i) if miss == []: maximum = max([x[-1] for x in indices.values()]) minimum = min([x[0] for x in indices.values()]) if maximum-minimum+1 &lt; end-start+1: start = minimum end = maximum if miss != []: return &quot;&quot; else: return S[start:end+1] Basically I kept a dictionary to record the index of each character of T. Each time I found a window, (when miss == []), I checked the length of this window by subtracting the maximum index and the minimum index of the characters. If this window is the smallest one so far, I record its beginning and ending index as “start” and “end.” java https://discuss.leetcode.com/topic/12492/share-my-neat-java-solution Share my neat java solution 123456789101112131415161718192021222324252627282930313233343536public String minWindow(String S, String T) &#123; if(S==null||S.isEmpty()||T==null||T.isEmpty()) return &quot;&quot;; int i=0, j=0; int[] Tmap=new int[256]; int[] Smap=new int[256]; for(int k=0; k&lt; T.length(); k++)&#123; Tmap[T.charAt(k)]++; &#125; int found=0; int length=Integer.MAX_VALUE; String res=&quot;&quot;; while(j&lt;S.length())&#123; if(found&lt;T.length())&#123; if(Tmap[S.charAt(j)]&gt;0)&#123; Smap[S.charAt(j)]++; if(Smap[S.charAt(j)]&lt;=Tmap[S.charAt(j)])&#123; found++; &#125; &#125; j++; &#125; while(found==T.length())&#123; if(j-i&lt;length)&#123; length=j-i; res=S.substring(i,j); &#125; if(Tmap[S.charAt(i)]&gt;0)&#123; Smap[S.charAt(i)]--; if(Smap[S.charAt(i)]&lt;Tmap[S.charAt(i)])&#123; found--; &#125; &#125; i++; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/21143/java-solution-using-two-pointers-hashmap Java solution. using two pointers + HashMap 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123;public String minWindow(String s, String t) &#123; if(s == null || s.length() &lt; t.length() || s.length() == 0)&#123; return &quot;&quot;; &#125; HashMap&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); for(char c : t.toCharArray())&#123; if(map.containsKey(c))&#123; map.put(c,map.get(c)+1); &#125;else&#123; map.put(c,1); &#125; &#125; int left = 0; int minLeft = 0; int minLen = s.length()+1; int count = 0; for(int right = 0; right &lt; s.length(); right++)&#123; if(map.containsKey(s.charAt(right)))&#123; map.put(s.charAt(right),map.get(s.charAt(right))-1); if(map.get(s.charAt(right)) &gt;= 0)&#123; count ++; &#125; while(count == t.length())&#123; if(right-left+1 &lt; minLen)&#123; minLeft = left; minLen = right-left+1; &#125; if(map.containsKey(s.charAt(left)))&#123; map.put(s.charAt(left),map.get(s.charAt(left))+1); if(map.get(s.charAt(left)) &gt; 0)&#123; count --; &#125; &#125; left ++ ; &#125; &#125; &#125; if(minLen&gt;s.length()) &#123; return &quot;&quot;; &#125; return s.substring(minLeft,minLeft+minLen);&#125;&#125; https://discuss.leetcode.com/topic/41308/java-4ms-bit-97-6 Java 4ms bit 97.6% Basically, there are two pointers for windows sliding. One for exploiting new matched substring, other pointer for expiring previous substring. 1234567891011121314151617181920212223242526272829303132333435363738public String minWindow(String s, String t) &#123; char[] s_array = s.toCharArray(); char[] t_array = t.toCharArray(); int[] map = new int[256]; int end = 0; int start = 0; int min_length = Integer.MAX_VALUE; for(int i = 0; i &lt; t_array.length; i++) map[t_array[i]] ++; int count = t_array.length; int min_start = 0; while(end &lt; s_array.length) &#123; if(map[s_array[end]] &gt; 0) &#123; count--; &#125; map[s_array[end]] --; while(count == 0) &#123; if((end - start + 1) &lt; min_length) &#123; min_length = end - start + 1; min_start = start; &#125; map[s_array[start]] ++; if(map[s_array[start]] &gt; 0)&#123; count ++; &#125; start++; &#125; end ++; &#125; if( min_start+min_length &gt; s_array.length) return &quot;&quot;; return s.substring(min_start, min_start+min_length); &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[075. Sort Colors]]></title>
    <url>%2Fp%2Fb84bd86e%2F</url>
    <content type="text"><![CDATA[37.0% https://leetcode.com/problems/sort-colors/ Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note:You are not suppose to use the library’s sort function for this problem. click to show follow up. Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with an one-pass algorithm using only constant space? 本题属于#三向快速排序#，可以参考#算法导论#。 方法一： 12345678910class Solution &#123;public: void sortColors(int A[], int n) &#123; int second=n-1, zero=0; for (int i=0; i&lt;=second; i++) &#123; while (A[i]==2 &amp;&amp; i&lt;second) swap(A[i], A[second--]); while (A[i]==0 &amp;&amp; i&gt;zero) swap(A[i], A[zero++]); &#125; &#125;&#125;; 我的实现： left定义为指向0的指针，right为2 i是遍历的指针指向的位置，从0开始。 如果nums[i]等于0， 则前面left指向0的尾部，left右边是1， 交换nums[i]与nums[++left]，nums[i]=1了相当于，num[++left]=0 如果nums[i]为2，则与尾部交换。由于交换后的结果不确定是几 所以此处i不增加 如果nums[i]为1，则默默增加i就行了。 left，right的初始定义值，借鉴的是算法导论里的方法。 1234567891011121314151617181920class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return; int left = -1, right = n; int i = 0; while(i&lt;right)&#123; if(nums[i]==0)&#123; swap(nums[++left], nums[i]); i++; &#125;else if(nums[i]==2)&#123; swap(nums[--right], nums[i]); &#125;else if(nums[i]==1)&#123; i++; &#125; &#125; return; &#125;&#125;; cpp https://discuss.leetcode.com/topic/5422/share-my-one-pass-constant-space-10-line-solution Share my one pass constant space 10-line solution The idea is to sweep all 0s to the left and all 2s to the right, then all 1s are left in the middle. 12345678910class Solution &#123;public: void sortColors(int A[], int n) &#123; int second=n-1, zero=0; for (int i=0; i&lt;=second; i++) &#123; while (A[i]==2 &amp;&amp; i&lt;second) swap(A[i], A[second--]); while (A[i]==0 &amp;&amp; i&gt;zero) swap(A[i], A[zero++]); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/6968/four-different-solutions Four different solutions 1234567891011121314// two pass O(m+n) spacevoid sortColors(int A[], int n) &#123; int num0 = 0, num1 = 0, num2 = 0; for(int i = 0; i &lt; n; i++) &#123; if (A[i] == 0) ++num0; else if (A[i] == 1) ++num1; else if (A[i] == 2) ++num2; &#125; for(int i = 0; i &lt; num0; ++i) A[i] = 0; for(int i = 0; i &lt; num1; ++i) A[num0+i] = 1; for(int i = 0; i &lt; num2; ++i) A[num0+num1+i] = 2;&#125; 123456789101112131415161718// one pass in place solutionvoid sortColors(int A[], int n) &#123; int n0 = -1, n1 = -1, n2 = -1; for (int i = 0; i &lt; n; ++i) &#123; if (A[i] == 0) &#123; A[++n2] = 2; A[++n1] = 1; A[++n0] = 0; &#125; else if (A[i] == 1) &#123; A[++n2] = 2; A[++n1] = 1; &#125; else if (A[i] == 2) &#123; A[++n2] = 2; &#125; &#125;&#125; 12345678910// one pass in place solutionvoid sortColors(int A[], int n) &#123; int j = 0, k = n - 1; for (int i = 0; i &lt;= k; ++i)&#123; if (A[i] == 0 &amp;&amp; i != j) swap(A[i--], A[j++]); else if (A[i] == 2 &amp;&amp; i != k) swap(A[i--], A[k--]); &#125;&#125; 12345678910// one pass in place solutionvoid sortColors(int A[], int n) &#123; int j = 0, k = n-1; for (int i=0; i &lt;= k; i++) &#123; if (A[i] == 0) swap(A[i], A[j++]); else if (A[i] == 2) swap(A[i--], A[k--]); &#125;&#125; https://discuss.leetcode.com/topic/36832/sharing-c-solution-with-good-explanation Sharing C++ solution with Good Explanation The solution requires the use of tracking 3 positions, the Low, Mid and High. We assume that the mid is the “Unknown” area that we must evaluate. If we encounter a 0, we know that it will be on the low end of the array, and if we encounter a 2, we know it will be on the high end of the array. To achieve this in one pass without preprocessing (counting), we simply traverse the unknown will generating the low and high ends. Take this example: Assume our input is: 1 0 2 2 1 0 (short for simplicity). Running the algorithm by hand would look something like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647481 0 2 2 1 0^ ^L HMMid != 0 || 2Mid++1 0 2 2 1 0^ ^ ^L M HMid == 0Swap Low and MidMid++Low++0 1 2 2 1 0 ^ ^ ^ L M HMid == 2Swap High and MidHigh--0 1 0 2 1 2 ^ ^ ^ L M HMid == 0Swap Low and MidMid++Low++0 0 1 2 1 2 ^ ^ ^ L M HMid == 2Swap High and MidHigh--0 0 1 1 2 2 ^ ^ L M HMid &lt;= High is our exit case Implemented in C++, it looks like: 123456789101112131415161718192021222324252627282930class Solution &#123; public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int tmp = 0, low = 0, mid = 0, high = nums.size() - 1; while(mid &lt;= high) &#123; if(nums[mid] == 0) &#123; tmp = nums[low]; nums[low] = nums[mid]; nums[mid] = tmp; low++; mid++; &#125; else if(nums[mid] == 1) &#123; mid++; &#125; else if(nums[mid] == 2) &#123; tmp = nums[high]; nums[high] = nums[mid]; nums[mid] = tmp; high--; &#125; &#125; &#125;&#125;; my code: 1234567891011121314151617181920212223class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int lo = 0; int hi = nums.size()-1; int i=0; while(i&lt;=hi)&#123; if(nums[i]==2)&#123; swap(nums[i], nums[hi]); hi--; &#125; if(nums[i]==0)&#123; swap(nums[i], nums[lo]); lo++; i++; &#125; if(nums[i]==1)&#123; i++; &#125; &#125; return; &#125;&#125;; python https://discuss.leetcode.com/topic/26181/ac-python-in-place-one-pass-solution-o-n-time-o-1-space-no-swap-no-count AC Python in place one pass solution O(n) time O(1) space, no swap no count 12345678910111213141516def sortColors(self, nums): i = j = 0 for k in xrange(len(nums)): v = nums[k] nums[k] = 2 if v &lt; 2: nums[j] = 1 j += 1 if v == 0: nums[i] = 0 i += 1# 86 / 86 test cases passed.# Status: Accepted# Runtime: 44 ms# 84.03% Just like the Lomuto partition algorithm usually used in quick sort. We keep a loop invariant that [0,i) [i, j) [j, k) are 0s, 1s and 2s sorted in place for [0,k). Here “)” means exclusive. We don’t need to swap because we know the values we want. java https://discuss.leetcode.com/topic/19201/java-solution-both-2-pass-and-1-pass Java solution, both 2-pass and 1-pass 2-pass 两次遍历1-pass 一次遍历 123456789101112131415161718public void sortColors(int[] nums) &#123; // 1-pass int p1 = 0, p2 = nums.length - 1, index = 0; while (index &lt;= p2) &#123; if (nums[index] == 0) &#123; nums[index] = nums[p1]; nums[p1] = 0; p1++; &#125; if (nums[index] == 2) &#123; nums[index] = nums[p2]; nums[p2] = 2; p2--; index--; &#125; index++; &#125;&#125; 1234567891011121314public void sortColors(int[] nums) &#123; // 2-pass int count0 = 0, count1 = 0, count2 = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == 0) &#123;count0++;&#125; if (nums[i] == 1) &#123;count1++;&#125; if (nums[i] == 2) &#123;count2++;&#125; &#125; for(int i = 0; i &lt; nums.length; i++) &#123; if (i &lt; count0) &#123;nums[i] = 0;&#125; else if (i &lt; count0 + count1) &#123;nums[i] = 1;&#125; else &#123;nums[i] = 2;&#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[074. Search a 2D Matrix]]></title>
    <url>%2Fp%2F5049e182%2F</url>
    <content type="text"><![CDATA[35.1% https://leetcode.com/problems/search-a-2d-matrix/ Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. 12345678910For example,Consider the following matrix:[ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]Given target = 3, return true. 方法一： 二分搜索 我的实现 12345678910111213141516171819202122class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int m = matrix.size(); if(m==0) return false; int n = matrix[0].size(); if(n==0) return false; if(target&lt;matrix[0][0] || target&gt;matrix[m-1][n-1]) return false; int left = 0, right = m*n-1; while(left&lt;=right)&#123; int mid = left + (right-left)/2; if(matrix[mid/n][mid%n]==target) return true; else if(matrix[mid/n][mid%n]&gt;target) right = mid-1; else left = mid + 1; &#125; return false; &#125;&#125;; cpp 12ms, 24.93%, June.21th, 2016 https://leetcode.com/discuss/10735/dont-treat-it-as-a-2d-matrix-just-treat-it-as-a-sorted-list 12345678910111213141516class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int target) &#123; int n = matrix.size(); int m = matrix[0].size(); int l = 0, r = m * n - 1; while (l != r)&#123; int mid = (l + r - 1) &gt;&gt; 1; if (matrix[mid / m][mid % m] &lt; target) l = mid + 1; else r = mid; &#125; return matrix[r / m][r % m] == target; &#125;&#125;; Solution Mime: 12ms, 24.93%, June.21th, 2016 123456789101112131415161718class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int target) &#123; int n = matrix.size(); int m = matrix[0].size(); int l = 0, r = m * n - 1; while (l != r)&#123; int mid = (l + r - 1) &gt;&gt; 1; if (matrix[mid / m][mid % m] &lt; target) l = mid + 1; else if(matrix[mid / m][mid % m] &gt; target) r = mid; else return true; &#125; return matrix[r / m][r % m] == target; &#125;&#125;; python Solution Mine: 52ms, 65.89%, June.21th, 2016 123456789101112class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; for i in xrange(len(matrix)): for j in xrange(len(matrix[0])): if target == matrix[i][j]: return True return False 60ms, 31.27%, June.21th, 2016 https://leetcode.com/discuss/28208/a-python-binary-search-solution-o-logn 123456789101112131415161718192021222324class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; if not matrix or target is None: return False rows, cols = len(matrix), len(matrix[0]) low, high = 0, rows * cols - 1 while low &lt;= high: mid = (low + high) / 2 num = matrix[mid / cols][mid % cols] if num == target: return True elif num &lt; target: low = mid + 1 else: high = mid - 1 return False Solution Mine: 48ms, 85.27%, June.21th, 2016 1234567891011121314151617181920212223242526class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; if not matrix or target is None: return False if target &lt; matrix[0][0] or target &gt; matrix[-1][-1]: return False rows, cols = len(matrix), len(matrix[0]) low, high = 0, rows * cols - 1 while low &lt;= high: mid = (low + high) / 2 num = matrix[mid / cols][mid % cols] if num == target: return True elif num &lt; target: low = mid + 1 else: high = mid - 1 return False java 1ms, 6.12%, June.21th, 2016 https://leetcode.com/discuss/15379/binary-search-on-an-ordered-matrix 123456789101112131415161718192021public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int row_num = matrix.length; int col_num = matrix[0].length; int begin = 0, end = row_num * col_num - 1; while(begin &lt;= end)&#123; int mid = (begin + end) / 2; int mid_value = matrix[mid / col_num][mid % col_num]; if(mid_value == target) return true; else if(mid_value &lt; target) begin = mid + 1; else end = mid - 1; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[073. Set Matrix Zeroes]]></title>
    <url>%2Fp%2F87522f31%2F</url>
    <content type="text"><![CDATA[36.0% https://leetcode.com/problems/set-matrix-zeroes/ Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. Follow up: Did you use extra space? A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? 貌似剑指offer？ 方法一： 保存所有结果到第一行和第一列，遍历非第一行，非第一列，只要有出现0的就设置为0。 至于第一行第一列要不要设置为0，可以设置两个标志来判断。 https://discuss.leetcode.com/topic/5056/any-shorter-o-1-space-solution Any shorter O(1) space solution? My idea is simple: store states of each row in the first of that row, and store states of each column in the first of that column. Because the state of row0 and the state of column0 would occupy the same cell, I let it be the state of row0, and use another variable “col0” for column0. In the first phase, use matrix elements to set states in a top-down way. In the second phase, use states to set matrix elements in a bottom-up way. 1234567891011121314151617void setZeroes(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int col0 = 1, rows = matrix.size(), cols = matrix[0].size(); for (int i = 0; i &lt; rows; i++) &#123; if (matrix[i][0] == 0) col0 = 0; for (int j = 1; j &lt; cols; j++) if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0; &#125; for (int i = rows - 1; i &gt;= 0; i--) &#123; for (int j = cols - 1; j &gt;= 1; j--) if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0; if (col0 == 0) matrix[i][0] = 0; &#125;&#125; 我的代码实现： 多个循环，第一行，第一列，非第一行第一列，三个循环，清晰明了。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return; int row0 = 1, col0 = 1; int rows = matrix.size(), cols = matrix[0].size(); for(int i=0; i&lt;cols; i++)&#123; if(matrix[0][i]==0)&#123; row0 = 0; break; &#125; &#125; for(int i=0; i&lt;rows; i++)&#123; if(matrix[i][0]==0)&#123; col0 = 0; break; &#125; &#125; for(int i=1; i&lt;rows; i++)&#123; for(int j=1; j&lt;cols; j++)&#123; if(matrix[i][j]==0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; for(int i=1; i&lt;rows; i++)&#123; for(int j=1; j&lt;cols; j++)&#123; if(matrix[i][0]==0 || matrix[0][j]==0) matrix[i][j] = 0; &#125; &#125; if(row0==0)&#123; for(int i=0; i&lt;cols; i++) matrix[0][i] = 0; &#125; if(col0==0)&#123; for(int i=0; i&lt;rows; i++) matrix[i][0] = 0; &#125; return; &#125;&#125;; https://discuss.leetcode.com/topic/7087/my-c-o-1-yoooooo My C++ O(1) yoooooo I find the last row which has 0, and use it to store the 0-collumns. Then go row by row set them to 0. Then go column by column set them to 0. Finally set the last row which has 0. It’s long but hey it’s O(1) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int H = matrix.size(); int W = matrix[0].size(); // find the last 0 row int last_0_row = -1; for (int y = H - 1; y &gt;= 0 &amp;&amp; last_0_row == -1; y--) for (int x = 0; x &lt; W; x++) if (matrix[y][x] == 0) &#123; last_0_row = y; break; &#125; if (last_0_row == -1) return; // go row by row for (int y = 0; y &lt; last_0_row; y++) &#123; bool this_is_a_0_row = false; for (int x = 0; x &lt; W; x++) &#123; if (matrix[y][x] == 0) &#123; this_is_a_0_row = true; matrix[last_0_row][x] = 0; &#125; &#125; if (this_is_a_0_row) for (int x = 0; x &lt; W; x++) &#123; matrix[y][x] = 0; &#125; &#125; // set collums to 0 for (int y = 0; y &lt; H; y++) for (int x = 0; x &lt; W; x++) &#123; if (matrix[last_0_row][x] == 0) matrix[y][x] = 0; &#125; // set the last 0 row for (int x = 0; x &lt; W; x++) &#123; matrix[last_0_row][x] = 0; &#125; &#125;&#125;; python 188ms, 49.31%, June.18th, 2016 https://leetcode.com/discuss/49003/o-1-space-solution-in-python O(1) space solution in Python 12345678910111213141516171819202122232425262728293031323334353637383940class Solution:# @param &#123;integer[][]&#125; matrix# @return &#123;void&#125; Do not return anything, modify matrix in-place instead.def setZeroes(self, matrix): m = len(matrix) if m == 0: return n = len(matrix[0]) row_zero = False for i in range(m): if matrix[i][0] == 0: row_zero = True col_zero = False for j in range(n): if matrix[0][j] == 0: col_zero = True for i in range(1, m): for j in range(1, n): if matrix[i][j] == 0: matrix[i][0] = 0 matrix[0][j] = 0 for i in range(1, m): if matrix[i][0] == 0: for j in range(1, n): matrix[i][j] = 0 for j in range(1, n): if matrix[0][j] == 0: for i in range(1, m): matrix[i][j] = 0 if col_zero: for j in range(n): matrix[0][j] = 0 if row_zero: for i in range(m): matrix[i][0] = 0 java https://discuss.leetcode.com/topic/15193/my-ac-java-o-1-solution-easy-to-read My AC java O(1) solution (easy to read) 123456789101112131415161718192021222324252627282930313233public class Solution &#123;public void setZeroes(int[][] matrix) &#123; boolean fr = false,fc = false; for(int i = 0; i &lt; matrix.length; i++) &#123; for(int j = 0; j &lt; matrix[0].length; j++) &#123; if(matrix[i][j] == 0) &#123; if(i == 0) fr = true; if(j == 0) fc = true; matrix[0][j] = 0; matrix[i][0] = 0; &#125; &#125; &#125; for(int i = 1; i &lt; matrix.length; i++) &#123; for(int j = 1; j &lt; matrix[0].length; j++) &#123; if(matrix[i][0] == 0 || matrix[0][j] == 0) &#123; matrix[i][j] = 0; &#125; &#125; &#125; if(fr) &#123; for(int j = 0; j &lt; matrix[0].length; j++) &#123; matrix[0][j] = 0; &#125; &#125; if(fc) &#123; for(int i = 0; i &lt; matrix.length; i++) &#123; matrix[i][0] = 0; &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/8807/my-java-o-1-solution-easy-to-understand My java O(1) solution (easy to understand) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Solution &#123; public void setZeroes(int[][] matrix) &#123; if(matrix==null)&#123; return; &#125; int m = matrix.length; int n = matrix[0].length; boolean rowHasZero = false; boolean colHasZero = false; for(int i=0; i&lt;n; i++)&#123; if(matrix[0][i]==0)&#123; rowHasZero = true; break; &#125; &#125; for(int i=0; i&lt;m; i++)&#123; if(matrix[i][0]==0)&#123; colHasZero = true; break; &#125; &#125; for(int i=1; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; if(matrix[i][j]==0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; for(int j=1;j&lt;n; j++)&#123; if(matrix[0][j]==0)&#123; nullifyCol(matrix, j, m, n); &#125; &#125; for(int i=1; i&lt;m; i++)&#123; if(matrix[i][0]==0)&#123; nullifyRow(matrix, i, m, n); &#125; &#125; if(rowHasZero)&#123; nullifyRow(matrix, 0, m, n); &#125; if(colHasZero)&#123; nullifyCol(matrix, 0, m, n); &#125; &#125; public void nullifyRow(int[][] matrix, int i, int m, int n)&#123; for(int col=0; col&lt;n; col++)&#123; matrix[i][col] = 0; &#125; &#125; public void nullifyCol(int[][] matrix, int j, int m, int n)&#123; for(int row=0; row&lt;m; row++)&#123; matrix[row][j] = 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[072. Edit Distance]]></title>
    <url>%2Fp%2F8e0e9f97%2F</url>
    <content type="text"><![CDATA[30.9% https://leetcode.com/problems/edit-distance/ Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) 12345You have the following 3 operations permitted on a word:a) Insert a characterb) Delete a characterc) Replace a character 方法一： 我的代码实现： 12345678910111213141516171819202122class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.size(); int n = word2.size(); if(n==0) return m; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=0; i&lt;m+1; i++) dp[i][0] = i; for(int j=0; j&lt;n+1; j++) dp[0][j] = j; for(int i=1; i&lt;m+1; i++)&#123; for(int j=1; j&lt;n+1; j++)&#123; if(word1[i-1] != word2[j-1]) dp[i][j] = min(min(dp[i][j-1], dp[i-1][j]), dp[i-1][j-1]) + 1; else dp[i][j] = dp[i-1][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; 根据题目分析问题，然后动态规划解决问题，很常规的一类 从中定义模式，两个的话，定义（m+1）*（n+1）的数组 19ms, 70.83%, September 21, 2016 https://discuss.leetcode.com/topic/17639/20ms-detailed-explained-c-solutions-o-n-space This is a classic problem of Dynamic Programming. We define the state dp[i][j] to be the minimum number of operations to convert word1[0..i - 1] to word2[0..j - 1]. The state equations have two cases: the boundary case and the general case. Note that in the above notations, both i and j take values starting from 1. For the boundary case, that is, to convert a string to an empty string, it is easy to see that the mininum number of operations to convert word1[0..i - 1] to “” requires at least i operations (deletions). In fact, the boundary case is simply: dp[i][0] = i; dp[0][j] = j. Now let’s move on to the general case, that is, convert a non-empty word1[0..i - 1] to another non-empty word2[0..j - 1]. Well, let’s try to break this problem down into smaller problems (sub-problems). Suppose we have already known how to convert word1[0..i - 2] to word2[0..j - 2], which is dp[i - 1][j - 1]. Now let’s consider word[i - 1] and word2[j - 1]. If they are euqal, then no more operation is needed and dp[i][j] = dp[i - 1][j - 1]. Well, what if they are not equal? If they are not equal, we need to consider three cases: Replace word1[i - 1] by word2[j - 1] (dp[i][j] = dp[i - 1][j - 1] + 1 (for replacement)); Delete word1[i - 1] and word1[0..i - 2] = word2[0..j - 1] (dp[i][j] = dp[i - 1][j] + 1 (for deletion)); Insert word2[j - 1] to word1[0..i - 1] and word1[0..i - 1] + word2[j - 1] = word2[0..j - 1] (dp[i][j] = dp[i][j - 1] + 1 (for insertion)). Make sure you understand the subtle differences between the equations for deletion and insertion. For deletion, we are actually converting word1[0..i - 2] to word2[0..j - 1], which costs dp[i - 1][j], and then deleting the word1[i - 1], which costs 1. The case is similar for insertion. Putting these together, we now have: dp[i][0] = i; dp[0][j] = j; dp[i][j] = dp[i - 1][j - 1], if word1[i - 1] = word2[j - 1]; dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1), otherwise. The above state equations can be turned into the following code directly. 123456789101112131415161718class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.length(), n = word2.length(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=1; i&lt;=m; i++) dp[i][0] = i; for(int j=1; j&lt;=n; j++) dp[0][j] = j; for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = min(dp[i-1][j-1]+1, min(dp[i][j-1]+1, dp[i-1][j]+1)); return dp[m][n]; &#125;&#125;; 方法二： 我的代码实现 dp[i][j],只有三条路可以走，一个是从dp[i-1][j-1]不相等替换 相等就不变， 一个是dp[i][j-1]增加或删除，一个是dp[i-1][j]增加或删除 有两个string的时候，长度分别是m和n，要特别分清到底哪个是m，哪个是n 12345678910111213141516171819class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.size(); int n = word2.size(); if(n==0) return m; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=0; i&lt;m+1; i++) dp[i][0] = i; for(int j=0; j&lt;n+1; j++) dp[0][j] = j; for(int i=1; i&lt;m+1; i++)&#123; for(int j=1; j&lt;n+1; j++)&#123; dp[i][j] = min(min(dp[i][j-1], dp[i-1][j])+1, word1[i-1]==word2[j-1]?dp[i-1][j-1]:dp[i-1][j-1]+1); &#125; &#125; return dp[m][n]; &#125;&#125;; 13ms, 86.67%, September 21, 2016 https://discuss.leetcode.com/topic/17639/20ms-detailed-explained-c-solutions-o-n-space Well, you may have noticed that each time when we update dp[i][j], we only need dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]. In fact, we need not maintain the full m*n matrix. Instead, maintaing one column is enough. The code can be optimized to O(m) or O(n) space, depending on whether you maintain a row or a column of the original matrix. The optimized code is as follows. 12345678910111213141516171819202122class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.length(), n = word2.length(); vector&lt;int&gt; cur(m+1, 0); for(int i=1; i&lt;=m; i++) cur[i] = i; for(int j=1; j&lt;=n; j++)&#123; int pre = cur[0]; cur[0] = j; for(int i=1; i&lt;=m; i++)&#123; int temp = cur[i]; if(word1[i-1] == word2[j-1]) cur[i] = pre; else cur[i] = min(pre+1, min(cur[i]+1, cur[i-1]+1)); pre = temp; &#125; &#125; return cur[m]; &#125;&#125;; Well, if you find the above code hard to understand, you may first try to write a two-column version that explicitly maintains two columns (the previous column and the current column) and then simplify the two-column version into the one-column version like the above code :-) python 256ms, 35.52%, September 21, 2016 https://discuss.leetcode.com/topic/19877/python-solutions-o-m-n-o-n-space O(m*n) space 1234567891011121314151617class Solution(object): def minDistance(self, word1, word2): &quot;&quot;&quot; :type word1: str :type word2: str :rtype: int &quot;&quot;&quot; l1, l2 = len(word1)+1, len(word2)+1 dp = [[0 for _ in xrange(l2)] for _ in xrange(l1)] for i in xrange(l1): dp[i][0] = i for j in xrange(l2): dp[0][j] = j for i in xrange(1, l1): for j in xrange(1, l2): dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+(word1[i-1]!=word2[j-1])) return dp[-1][-1] 262ms, 32.79%, September 21, 2016 https://discuss.leetcode.com/topic/19877/python-solutions-o-m-n-o-n-space O(n) space with rolling array1234567891011121314151617class Solution(object): def minDistance(self, word1, word2): &quot;&quot;&quot; :type word1: str :type word2: str :rtype: int &quot;&quot;&quot; l1, l2 = len(word1)+1, len(word2)+1 pre = [0 for _ in xrange(l2)] for j in xrange(l2): pre[j] = j for i in xrange(1, l1): cur = [i]*l2 for j in xrange(1, l2): cur[j] = min(cur[j-1]+1, pre[j]+1, pre[j-1]+(word1[i-1] != word2[j-1])) pre = cur[:] return pre[-1] java 16ms, 31.71%, September 21, 2016 https://discuss.leetcode.com/topic/20922/java-dp-solution-o-nm Let following be the function definition :- 1234567891011f(i, j) := minimum cost (or steps) required to convert first i characters of word1 to first j characters of word2Case 1: word1[i] == word2[j], i.e. the ith the jth character matches.f(i, j) = f(i - 1, j - 1)Case 2: word1[i] != word2[j], then we must either insert, delete or replace, whichever is cheaperf(i, j) = 1 + min &#123; f(i, j - 1), f(i - 1, j), f(i - 1, j - 1) &#125;1. f(i, j - 1) represents insert operation2. f(i - 1, j) represents delete operation3. f(i - 1, j - 1) represents replace operation Here, we consider any operation from word1 to word2. It means, when we say insert operation, we insert a new character after word1 that matches the jth character of word2. So, now have to match i characters of word1 to j - 1 characters of word2. Same goes for other 2 operations as well. Note that the problem is symmetric. The insert operation in one direction (i.e. from word1 to word2) is same as delete operation in other. So, we could choose any direction. Above equations become the recursive definitions for DP. Base Case: 1f(0, k) = f(k, 0) = k Below is the direct bottom-up translation of this recurrent relation. It is only important to take care of 0-based index with actual code :- Time complexity : If n is the length of word1, m of word2, because of the two indented loops, it is O(nm)123456789101112131415161718192021222324252627public class Solution &#123; public int minDistance(String word1, String word2) &#123; int m = word1.length(); int n = word2.length(); int[][] cost = new int[m+1][n+1]; for(int i=0; i&lt;=m; i++) cost[i][0] = i; for(int j=0; j&lt;=n; j++) cost[0][j] = j; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(word1.charAt(i) == word2.charAt(j)) cost[i+1][j+1] = cost[i][j]; else&#123; int a = cost[i][j]; int b = cost[i][j+1]; int c = cost[i+1][j]; cost[i+1][j+1] = a &lt; b?(a&lt;c?a:c):(b&lt;c?b:c); cost[i+1][j+1]++; &#125; &#125; &#125; return cost[m][n]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[071. Simplify Path]]></title>
    <url>%2Fp%2F6cd51db6%2F</url>
    <content type="text"><![CDATA[25.4% https://leetcode.com/problems/simplify-path/ Given an absolute path for a file (Unix-style), simplify it. 123For example,path = &quot;/home/&quot;, =&gt; &quot;/home&quot;path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot; Corner Cases: Did you consider the case where path = “/../“? In this case, you should return “/“. Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“. In this case, you should ignore redundant slashes and return “/home/foo”. 方法一： https://discuss.leetcode.com/topic/2872/my-o-n-ac-code-just-need-to-handle-two-special-cases My O(n) AC code . just need to handle two special cases. traverse the string to record each folder name. two special cases: a.double dot:pop one. b.single dot: do nothing (don`t push it). 123456789101112131415161718192021222324252627string simplifyPath(string path) &#123; vector&lt;string&gt; nameVect; string name; path.push_back(&apos;/&apos;); for(int i=0;i&lt;path.size();i++)&#123; if(path[i]==&apos;/&apos;)&#123; if(name.size()==0)continue; if(name==&quot;..&quot;)&#123; //special case 1：double dot，pop dir if(nameVect.size()&gt;0)nameVect.pop_back(); &#125;else if(name==&quot;.&quot;)&#123;//special case 2:singel dot，don`t push &#125;else&#123; nameVect.push_back(name); &#125; name.clear(); &#125;else&#123; name.push_back(path[i]);//record the name &#125; &#125; string result; if(nameVect.empty())return &quot;/&quot;; for(int i=0;i&lt;nameVect.size();i++)&#123; result.append(&quot;/&quot;+nameVect[i]); &#125; return result;&#125; 我的代码实现： string的函数clear，append，push_back 给定的字符串可以更改的 1234567891011121314151617181920212223242526class Solution &#123;public: string simplifyPath(string path) &#123; vector&lt;string&gt; v; string name = ""; path.push_back('/'); // 针对原有string的首或尾进行改变，这是一种思路 int n = path.size(); // 长度改变了，所以要在改变后求长度，否则不对的 for(int i=0; i&lt;n; i++)&#123; if(path[i]=='/')&#123; if(name=="") continue; // 下面的大括号外，不要分号的 else if(name==".")&#123;&#125; //此处不能continue，因为要清空name，才下一步 else if(name=="..") &#123; if(!v.empty()) v.pop_back();&#125; else v.push_back(name); name.clear(); // 此处学会针对string的clear &#125;else&#123; name.push_back(path[i]); &#125; &#125; string res = ""; for(int i=0; i&lt;v.size(); i++) res.append("/" + v[i]); return v.empty()? "/" : res; &#125;&#125;; cpp 6ms, September 11, 2016 https://discuss.leetcode.com/topic/8678/c-10-lines-solution C++ 10-lines solution C++ also have getline which acts like Java’s split. I guess the code can comment itself. 123456789101112131415class Solution &#123;public: string simplifyPath(string path) &#123; string res, tmp; vector&lt;string&gt; stk; stringstream ss(path); while(getline(ss, tmp, &apos;/&apos;))&#123; if(tmp == &quot;&quot; or tmp == &quot;.&quot;) continue; if(tmp == &quot;..&quot; and !stk.empty()) stk.pop_back(); else if(tmp!=&quot;..&quot;) stk.push_back(tmp); &#125; for(auto str:stk) res += &quot;/&quot; + str; return res.empty() ? &quot;/&quot; : res; &#125;&#125;; python 82ms, September 11, 2016 https://discuss.leetcode.com/topic/41158/9-line-python-solution-easy-to-understand 9-line Python solution, easy to understand 12345678910111213141516class Solution(object): def simplifyPath(self, path): &quot;&quot;&quot; :type path: str :rtype: str &quot;&quot;&quot; stack = [] for token in path.split(&apos;/&apos;): if token in (&apos;&apos;, &apos;.&apos;): pass elif token == &apos;..&apos;: if stack: stack.pop() else: stack.append(token) return &apos;/&apos; + &apos;/&apos;.join(stack) java 18ms, September 11, 2016 https://discuss.leetcode.com/topic/7675/java-10-lines-solution-with-stack Java 10-lines solution with stack Hi guys! The main idea is to push to the stack every valid file name (not in {“”,”.”,”..”}), popping only if there’s smth to pop and we met “..”. I don’t feel like the code below needs any additional comments. 12345678910111213public class Solution &#123; public String simplifyPath(String path) &#123; Deque&lt;String&gt; stack = new LinkedList&lt;&gt;(); Set&lt;String&gt; skip = new HashSet&lt;&gt;(Arrays.asList(&quot;..&quot;, &quot;.&quot;, &quot;&quot;)); for(String dir : path.split(&quot;/&quot;))&#123; if(dir.equals(&quot;..&quot;) &amp;&amp; !stack.isEmpty()) stack.pop(); else if(!skip.contains(dir)) stack.push(dir); &#125; String res = &quot;&quot;; for(String dir:stack) res = &quot;/&quot; + dir + res; return res.isEmpty()? &quot;/&quot; : res; &#125;&#125; https://discuss.leetcode.com/topic/7014/accepted-solution-using-deque Accepted solution using Deque I think using Deque is probably the most intuitive way to solve this problem. 12345678910111213141516171819202122232425262728293031323334/** * Deque of strings (directories). * iterate path: * if &quot;/&quot;, continue, * if &quot;.&quot;, conitnue, * if &quot;..&quot;, poll last, * else, add a new directory * in the end, build result from deque. */public String simplifyPath(String path) &#123; Deque&lt;String&gt; deque = new LinkedList&lt;String&gt;(); String[] splits = path.split(&quot;/&quot;); for (String split : splits) &#123; // CATCH: must use &quot;equals()&quot; instead of &quot;==&quot;, // because &apos;split&apos; is a variable! // Also, &apos;split&apos; could be empty string. if (split.equals(&quot;&quot;)) continue; else if (split.equals(&quot;.&quot;)) continue; else if (split.equals(&quot;..&quot;)) deque.pollLast(); else deque.addLast(split); &#125; StringBuilder builder = new StringBuilder(); while (!deque.isEmpty()) &#123; String s = deque.pollFirst(); builder.append(&quot;/&quot;).append(s); &#125; if (builder.length() == 0) return &quot;/&quot;; return builder.toString();&#125; https://discuss.leetcode.com/topic/12767/ac-solution-in-java AC Solution in Java 12345678910111213141516public class Solution &#123; public String simplifyPath(String path) &#123; Set&lt;String&gt; isSkip = new HashSet&lt;&gt;(Arrays.asList(&quot;&quot;, &quot;.&quot;, &quot;..&quot;)); Deque&lt;String&gt; stack = new ArrayDeque&lt;&gt;(); for (String token : path.split(&quot;/&quot;)) &#123; if (token.equals(&quot;..&quot;) &amp;&amp; !stack.isEmpty()) stack.pop(); if (isSkip.contains(token)) continue; stack.push(token); &#125; StringBuilder sb = new StringBuilder(); while (!stack.isEmpty()) &#123; sb.append(&quot;/&quot; + stack.pollLast()); &#125; return sb.length() == 0 ? &quot;/&quot; : sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[070. Climbing Stairs]]></title>
    <url>%2Fp%2Ff1d6ecb9%2F</url>
    <content type="text"><![CDATA[39.0% https://leetcode.com/problems/climbing-stairs/ You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 方法一： 12345678910111213class Solution &#123;public: int climbStairs(int n) &#123; if(n&lt;0) return 0; int a=0, b=1; while(n--)&#123; int c = a+b; a = b; b = c; &#125; return b; &#125;&#125;; 相似题： 有一楼梯共m级，刚开始时你在第一级，若每次只能跨上一级或者二级，要走上m级，共有多少走法？注：规定从一级到一级有0种走法。给定一个正整数int n，请返回一个数，代表上楼的方式数。保证n小于等于100。为了防止溢出，请返回结果Mod 1000000007的值。 测试样例： 3 返回：2 my code: 123456789101112131415class GoUpstairs &#123;public: int countWays(int n) &#123; // write code here long long a=1, b=1, i=1; long long c; while(i&lt;n)&#123; c = a; a = (a+b)%1000000007; b = (c)%1000000007; i++; &#125; return b; &#125;&#125;; 其中，要求mod值，在最终结果处会溢出，所以在中间mod。 解析https://discuss.leetcode.com/topic/17002/3-4-short-lines-in-every-language Same simple algorithm written in every offered language. Variable a tells you the number of ways to reach the current step, and b tells you the number of ways to reach the next step. So for the situation one step further up, the old b becomes the new a, and the new b is the old a+b, since that new step can be reached by climbing 1 step from what b represented or 2 steps from what a represented. Ruby wins, and “the C languages” all look the same. java 123456public int climbStairs(int n) &#123; int a = 1, b = 1; while (n-- &gt; 0) a = (b += a) - a; return a;&#125; cpp 123456int climbStairs(int n) &#123; int a = 1, b = 1; while (n--) a = (b += a) - a; return a;&#125; python 12345def climbStairs(self, n): a = b = 1 for _ in range(n): a, b = b, a + b return a 评价：n–是亮点，不必单独设置一个变量i++ https://discuss.leetcode.com/topic/5371/basically-it-s-a-fibonacci Basically it’s a fibonacci. The problem seems to be a dynamic programming one. Hint: the tag also suggests that!Here are the steps to get the solution incrementally. Base cases: if n &lt;= 0, then the number of ways should be zero. if n == 1, then there is only way to climb the stair. if n == 2, then there are two ways to climb the stairs. One solution is one step by another; the other one is two steps at one time. The key intuition to solve the problem is that given a number of stairs n, if we know the number ways to get to the points [n-1] and [n-2] respectively, denoted as n1 and n2 , then the total ways to get to the point [n] is n1 + n2. Because from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there. There is NO overlapping between these two solution sets, because we differ in the final step. Now given the above intuition, one can construct an array where each node stores the solution for each number n. Or if we look at it closer, it is clear that this is basically a fibonacci number, with the starting numbers as 1 and 2, instead of 1 and 1. The implementation in Java as follows: 1234567891011121314151617public int climbStairs(int n) &#123; // base cases if(n &lt;= 0) return 0; if(n == 1) return 1; if(n == 2) return 2; int one_step_before = 2; int two_steps_before = 1; int all_ways = 0; for(int i=2; i&lt;n; i++)&#123; all_ways = one_step_before + two_steps_before; two_steps_before = one_step_before; one_step_before = all_ways; &#125; return all_ways;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[069. Sqrt(x)]]></title>
    <url>%2Fp%2Fae863641%2F</url>
    <content type="text"><![CDATA[27.9% https://leetcode.com/problems/sqrtx/ Implement int sqrt(int x). Compute and return the square root of x. 方法一： 基本方法，二分搜索 1234567891011121314151617class Solution &#123;public: int sqrt(int x) &#123; if (0 == x) return 0; int left = 1, right = x, ans; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (mid &lt;= x / mid) &#123; left = mid + 1; ans = mid; &#125; else &#123; right = mid - 1; &#125; &#125; return ans; &#125;&#125;; 我的代码实现： 1234567891011121314151617class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return x; // 先对特殊情况判断 int left=1, right=x, ans; while(left&lt;=right)&#123; // 判断条件left&lt;=right int mid = left + (right-left)/2; if(mid&lt;=x/mid)&#123; // 如果mid*mid可能超出int范围 left = mid + 1; ans = mid; &#125;else&#123; right = mid - 1; &#125; &#125; return ans; &#125;&#125;; 方法二： 我的代码实现： 123456789101112class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return 0; double res = x; double delta = 0.0001; while(abs(pow(res, 2)-x)&gt;delta)&#123; res = (res + x/res)/2; &#125; return int(res); &#125;&#125;; 1234567891011f(x) = ans^2 - x = 0f&apos;(x) = 2*ans y = f&apos;(ans)*(nex - ans) + f(ans)y = 0=&gt; nex = ans - f(ans) / f&apos;(ans)迭代方法 Newton方法，迭代 The key point is the average result is calculate by “ans = (ans + x / ans) / 2”; 12345678int sqrt(int x) &#123; double ans = x; double delta = 0.0001; while (fabs(pow(ans, 2) - x) &gt; delta) &#123; ans = (ans + x / ans) / 2; &#125; return ans;&#125; 我的代码实现： 123456789101112class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return x; double ans = x; // 注意此处用的是double，不是int double delta = 0.0001; // 用double，而不是int while(fabs(pow(ans,2) - x)&gt;delta)&#123; ans = (ans + x/ans)/2; &#125; return ans; &#125;&#125;; 方法三： 牛顿法的另一种实现 12345678910class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return 0; long long r = x; while(r*r &gt; x) r = (r+x/r)/2; return r; &#125;&#125;; https://discuss.leetcode.com/topic/24532/3-4-short-lines-integer-newton-every-language 3-4 short lines, Integer Newton, Every Language Quite a few people used Newton already, but I didn’t see someone make it this short. Same solution in every language. Explanation under the solutions. C++ and C 1234long r = x;while (r*r &gt; x) r = (r + x/r) / 2;return r; Python 1234r = xwhile r*r &gt; x: r = (r + x/r) / 2return r Java and C# 1234long r = x;while (r*r &gt; x) r = (r + x/r) / 2;return (int) r; Explanation Apparently, using only integer division for the Newton method works. And I guessed that if I start at x, the root candidate will decrease monotonically and never get too small. The above solutions all got accepted, and in C++ I also verified it locally on my PC for all possible inputs (0 to 2147483647): 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std;int mySqrt(int x) &#123; long long r = x; while (r*r &gt; x) r = (r + x/r) / 2; return r;&#125;int main() &#123; for (long long x=0; x&lt;=INT_MAX; ++x) &#123; long long r = mySqrt(x); if (r&lt;0 || r*r &gt; x || (r+1)*(r+1) &lt;= x) cout &lt;&lt; &quot;false: &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl; if (x % 10000000 == 0) cout &lt;&lt; x &lt;&lt; endl; &#125; cout &lt;&lt; &quot;all checked&quot; &lt;&lt; endl;&#125; https://discuss.leetcode.com/topic/1225/solve-this-problem-with-binary-search Solve this problem with Binary Search 1234567891011121314151617class Solution &#123;public: int sqrt(int x) &#123; if (0 == x) return 0; int left = 1, right = x, ans; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (mid &lt;= x / mid) &#123; left = mid + 1; ans = mid; &#125; else &#123; right = mid - 1; &#125; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/8689/newton-s-iterative-method-in-c Newton’s Iterative Method in C++ 12345678int sqrt(int x) &#123; double ans = x; double delta = 0.0001; while (fabs(pow(ans, 2) - x) &gt; delta) &#123; ans = (ans + x / ans) / 2; &#125; return ans;&#125; The key point is the average result is calculate by “ans = (ans + x / ans) / 2”; For instance, when calculate sqrt(2) : 12345Guess Result Quotient Average Result 1 2 / 1 = 2 (2 + 1) / 2 = 1.5 1.5 2 / 1.5 = 1.3333 (1.3333 + 1.5) / 2 = 1.4167 1.4167 2 / 1.4167 = 1.4118 (1.4167 + 1.4118) / 2 = 1.4142 ... ... https://discuss.leetcode.com/topic/19698/my-clean-c-code-8ms My clean C++ code 8ms Binary search and high is always converged to the one that 1 larger than the result. 123456789101112131415class Solution &#123;public: int mySqrt(int x) &#123; int low = 0, high = x, mid; if(x&lt;2) return x; // to avoid mid = 0 while(low&lt;high) &#123; mid = (low + high)/2; if(x/mid &gt;= mid) low = mid+1; else high = mid; &#125; return high-1; &#125;&#125;; python https://discuss.leetcode.com/topic/5472/newton-method-accepted-solution Newton method, accepted solution. 1234567891011class Solution:# @param x, an integer# @return an integerdef sqrt(self, x): i=1.0; while(True): j=(i+x/i)/2.0; if(abs(i-j)&lt; 0.000000000005): break; i=j; return int(j); java https://discuss.leetcode.com/topic/8680/a-binary-search-solution A Binary Search Solution Instead of using fancy Newton’s method, this plain binary search approach also works. 123456789101112131415public int sqrt(int x) &#123; if (x == 0) return 0; int left = 1, right = Integer.MAX_VALUE; while (true) &#123; int mid = left + (right - left)/2; if (mid &gt; x/mid) &#123; right = mid - 1; &#125; else &#123; if (mid + 1 &gt; x/(mid + 1)) return mid; left = mid + 1; &#125; &#125;&#125; https://discuss.leetcode.com/topic/2671/share-my-o-log-n-solution-using-bit-manipulation Share my O(log n) Solution using bit manipulation Basic Idea: Since sqrt(x) is composed of binary bits, I calculate sqrt(x) by deciding every bit from the most significant to least significant. Since an integer n can have O(log n) bits with each bit decided within constant time, this algorithm has time limit O(log n), actually, because an Integer can have at most 32 bits, I can also say this algorithm takes O(32)=O(1) time. 12345678910111213141516public int sqrt(int x) &#123; if(x==0) return 0; int h=0; while((long)(1&lt;&lt;h)*(long)(1&lt;&lt;h)&lt;=x) // firstly, find the most significant bit h++; h--; int b=h-1; int res=(1&lt;&lt;h); while(b&gt;=0)&#123; // find the remaining bits if((long)(res | (1&lt;&lt;b))*(long)(res |(1&lt;&lt;b))&lt;=x) res|=(1&lt;&lt;b); b--; &#125; return res;&#125; https://discuss.leetcode.com/topic/35357/share-my-2ms-and-4lines-java-code Share my 2ms and 4lines JAVA code, My idea is, for any non-negative number N, sqrt(N) = 2/2sqrt(N) =2sqrt(1/4)sqrt(N) = 2sqrt(N/4). And for the Ns that are not multiple of 4, for example, 9, 25 or 49, the actual result should be 1+2*sqrt(N/4), because we need to take remainders into account. 123456public int mySqrt(int x) &#123; if(x &lt; 4) return x == 0 ? 0 : 1; int res = 2 * mySqrt(x/4); if((res+1) * (res+1) &lt;= x &amp;&amp; (res+1) * (res+1) &gt;= 0) return res+1; return res;&#125; Hope it helps.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>math</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[068. Text Justification]]></title>
    <url>%2Fp%2F91398cc3%2F</url>
    <content type="text"><![CDATA[19.1% https://leetcode.com/problems/text-justification/ Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly L characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. 12345678910For example,words: [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]L: 16.Return the formatted lines as:[&quot;This is an&quot;,&quot;example of text&quot;,&quot;justification. &quot;] Note: Each word is guaranteed not to exceed L in length. click to show corner cases. Corner Cases: A line other than the last line might contain only one word. What should you do in this case? In this case, that line should be left-justified. https://discuss.leetcode.com/topic/7256/what-does-this-question-aim-to-teach What does this question aim to teach? In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. As far as I understand the “idea” of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. In this question’s description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. Do you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned? https://discuss.leetcode.com/topic/7256/what-does-this-question-aim-to-teach/4 it teaches you in the real world. Programmers are always been ask to deal with dirty works. cpp https://discuss.leetcode.com/topic/4189/share-my-concise-c-solution-less-than-20-lines Share my concise c++ solution - less than 20 lines 1234567891011121314151617vector&lt;string&gt; fullJustify(vector&lt;string&gt; &amp;words, int L) &#123; vector&lt;string&gt; res; for(int i = 0, k, l; i &lt; words.size(); i += k) &#123; for(k = l = 0; i + k &lt; words.size() and l + words[i+k].size() &lt;= L - k; k++) &#123; l += words[i+k].size(); &#125; string tmp = words[i]; for(int j = 0; j &lt; k - 1; j++) &#123; if(i + k &gt;= words.size()) tmp += &quot; &quot;; else tmp += string((L - l) / (k - 1) + (j &lt; (L - l) % (k - 1)), &apos; &apos;); tmp += words[i+j+1]; &#125; tmp += string(L - tmp.size(), &apos; &apos;); res.push_back(tmp); &#125; return res;&#125; For each line, I first figure out which words can fit in. According to the code, these words are words[i] through words[i+k-1]. Then spaces are added between the words. The trick here is to use mod operation to manage the spaces that can’t be evenly distrubuted: the first (L-l) % (k-1) gaps acquire an additional space. https://discuss.leetcode.com/topic/11507/share-my-2-ms-30-lines-solution Share my 2 ms, 30 lines solution 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;string&gt; fullJustify(vector&lt;string&gt; &amp;words, int L) &#123; vector&lt;string&gt; ans; int begin = 0; while (begin &lt; words.size()) &#123; int last = begin; int linesize = words[begin++].size(); while (begin &lt; words.size() &amp;&amp; linesize + 1 + words[begin].size() &lt;= L) &#123; linesize += 1 + words[begin].size(); begin++; &#125; int spaces = 1, extra = 0; if (begin &lt; words.size() &amp;&amp; begin != last + 1) &#123; spaces = (L - linesize) / (begin - last - 1) + 1; extra = (L - linesize) % (begin - last - 1); &#125; ans.push_back(words[last++]); while (extra--) &#123; ans.back().append(spaces+1, &apos; &apos;); ans.back().append(words[last++]); &#125; while (last &lt; begin) &#123; ans.back().append(spaces, &apos; &apos;); ans.back().append(words[last++]); &#125; ans.back().append(L-ans.back().size(), &apos; &apos;); &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/6946/easy-understanding-solution Easy understanding solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546vector&lt;string&gt; fullJustify(vector&lt;string&gt; &amp;words, int L) &#123; vector&lt;string&gt; ans, vs; string str; int len = 0; for (int i = 0; i &lt; words.size(); ++i) &#123; if (len + vs.size() + words[i].size() &lt;= L) &#123; // vs not full, need to get more words in the line vs.push_back(words[i]); len += words[i].size(); &#125; else &#123; // vs full, get the whole line if (vs.size() == 1) &#123; // just one word, the left justify str = vs[0]; str.append(L - str.size(), &apos; &apos;); ans.push_back(str); &#125; else if (vs.size() &gt; 1) &#123; // the first &quot;mod&quot; words get &quot;div+1&quot; spaces // the remaining words get &quot;div&quot; spaces int div = (L - len) / (vs.size() - 1); int mod = (L - len) % (vs.size() - 1); str = vs[0]; for (int j = 1; j &lt; vs.size(); ++j) &#123; if (j &lt;= mod) str.append(div+1, &apos; &apos;); // one more space else str.append(div, &apos; &apos;); str += vs[j]; &#125; ans.push_back(str); &#125; vs.clear(); vs.push_back(words[i]); len = words[i].size(); &#125; &#125; // the last line, left justified and no extra space is inserted between words str = vs[0]; for (int j = 1; j &lt; vs.size(); ++j) str += &apos; &apos; + vs[j]; str.append(L-str.size(), &apos; &apos;); ans.push_back(str); return ans;&#125; python 58ms, 18.55%, September 23, 2016 https://discuss.leetcode.com/topic/25970/concise-python-solution-10-lines Concise python solution, 10 lines. 1234567891011def fullJustify(self, words, maxWidth): res, cur, num_of_letters = [], [], 0 for w in words: if num_of_letters + len(w) + len(cur) &gt; maxWidth: for i in range(maxWidth - num_of_letters): cur[i%(len(cur)-1 or 1)] += &apos; &apos; res.append(&apos;&apos;.join(cur)) cur, num_of_letters = [], 0 cur += [w] num_of_letters += len(w) return res + [&apos; &apos;.join(cur).ljust(maxWidth)] How does it work? Well in the question statement, the sentence “Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right” was just a really long and awkward way to say round robin. The following line implements the round robin logic: 12for i in range(maxWidth - num_of_letters): cur[i%(len(cur)-1 or 1)] += &apos; &apos; What does this line do? Once you determine that there are only k words that can fit on a given line, you know what the total length of those words is num_of_letters. Then the rest are spaces, and there are (maxWidth - num_of_letters) of spaces. The “or 1” part is for dealing with the edge case len(cur) == 1. The following is my older solution for reference, longer and less clear. The idea is the same, but I did not figure out the nice way to distribute the space at the time. 1234567891011121314151617def fullJustify(self, words, maxWidth): res, cur, num_of_letters = [], [], 0 for w in words: if num_of_letters + len(w) + len(cur) &gt; maxWidth: if len(cur) == 1: res.append( cur[0] + &apos; &apos;*(maxWidth - num_of_letters) ) else: num_spaces = maxWidth - num_of_letters space_between_words, num_extra_spaces = divmod( num_spaces, len(cur)-1) for i in range(num_extra_spaces): cur[i] += &apos; &apos; res.append( (&apos; &apos;*space_between_words).join(cur) ) cur, num_of_letters = [], 0 cur += [w] num_of_letters += len(w) res.append( &apos; &apos;.join(cur) + &apos; &apos;*(maxWidth - num_of_letters - len(cur) + 1) ) return res https://discuss.leetcode.com/topic/36136/15-line-python-solution-40ms 15-line Python solution, 40ms 123456789101112131415161718def fullJustify(self, words, maxWidth): i, N, result = 0, len(words), [] while i &lt; N: # decide how many words to be put in one line oneLine, j, currWidth, positionNum, spaceNum = [words[i]], i + 1, len(words[i]), 0, maxWidth - len(words[i]) while j &lt; N and currWidth + 1 + len(words[j]) &lt;= maxWidth: oneLine.append(words[j]) currWidth += 1 + len(words[j]) spaceNum -= len(words[j]) positionNum, j = positionNum + 1, j + 1 i = j # decide the layout of one line if i &lt; N and positionNum: spaces = [&apos; &apos; * (spaceNum / positionNum + (k &lt; spaceNum % positionNum)) for k in range(positionNum)] + [&apos;&apos;] else: # last line or the line only has one word spaces = [&apos; &apos;] * positionNum + [&apos; &apos; * (maxWidth - currWidth)] result.append(&apos;&apos;.join([s for pair in zip(oneLine, spaces) for s in pair])) return result java https://discuss.leetcode.com/topic/9147/simple-java-solution Simple Java Solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public List&lt;String&gt; fullJustify(String[] words, int L) &#123; List&lt;String&gt; lines = new ArrayList&lt;String&gt;(); int index = 0; while (index &lt; words.length) &#123; int count = words[index].length(); int last = index + 1; while (last &lt; words.length) &#123; if (words[last].length() + count + 1 &gt; L) break; count += words[last].length() + 1; last++; &#125; StringBuilder builder = new StringBuilder(); int diff = last - index - 1; // if last line or number of words in the line is 1, left-justified if (last == words.length || diff == 0) &#123; for (int i = index; i &lt; last; i++) &#123; builder.append(words[i] + &quot; &quot;); &#125; builder.deleteCharAt(builder.length() - 1); for (int i = builder.length(); i &lt; L; i++) &#123; builder.append(&quot; &quot;); &#125; &#125; else &#123; // middle justified int spaces = (L - count) / diff; int r = (L - count) % diff; for (int i = index; i &lt; last; i++) &#123; builder.append(words[i]); if (i &lt; last - 1) &#123; for (int j = 0; j &lt;= (spaces + ((i - index) &lt; r ? 1 : 0)); j++) &#123; builder.append(&quot; &quot;); &#125; &#125; &#125; &#125; lines.add(builder.toString()); index = last; &#125; return lines; &#125;&#125; 3ms, 1.45%, September 22, 2016 https://discuss.leetcode.com/topic/4189/share-my-concise-c-solution-less-than-20-lines 1234567891011121314151617181920class Solution &#123;public: vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int L) &#123; vector&lt;string&gt; res; for(int i=0, k, l; i&lt;words.size(); i+=k)&#123; for(k=l=0; i+k&lt;words.size() and l+words[i+k].size() &lt;= L-k; k++)&#123; l += words[i+k].size(); &#125; string tmp = words[i]; for(int j=0; j&lt;k-1; j++)&#123; if(i+k&gt;=words.size()) tmp += &quot; &quot;; else tmp+=string((L-l)/(k-1) + (j&lt;(L-l)%(k-1)), &apos; &apos;); tmp += words[i+j+1]; &#125; tmp += string(L-tmp.size(), &apos; &apos;); res.push_back(tmp); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[067. Add Binary]]></title>
    <url>%2Fp%2Fde93a709%2F</url>
    <content type="text"><![CDATA[32.5% https://leetcode.com/problems/add-binary/ Given two binary strings, return their sum (also a binary string). 1234For example,a = &quot;11&quot;b = &quot;1&quot;Return &quot;100&quot;. 方法一： 根据最基本的规则运算，类似于链表求和 https://discuss.leetcode.com/topic/8981/short-code-by-c Short code by c++ 12345678910111213141516171819class Solution&#123;public: string addBinary(string a, string b) &#123; string s = &quot;&quot;; int c = 0, i = a.size() - 1, j = b.size() - 1; while(i &gt;= 0 || j &gt;= 0 || c == 1) &#123; c += i &gt;= 0 ? a[i --] - &apos;0&apos; : 0; c += j &gt;= 0 ? b[j --] - &apos;0&apos; : 0; s = char(c % 2 + &apos;0&apos;) + s; c /= 2; &#125; return s; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324class Solution &#123;public: string addBinary(string a, string b) &#123; if(a.empty()) return b; if(b.empty()) return a; int carry = 0; int i = a.size()-1; int j = b.size()-1; string res = ""; while(i&gt;=0 || j&gt;=0 || carry)&#123; int l = i&gt;=0? a[i]-'0' : 0; int r = j&gt;=0 ? b[j]-'0' : 0; carry = l+r+carry; res += char(carry%2 + '0'); carry /= 2; if(i&gt;=0) i--; if(j&gt;=0) j--; &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 4ms, 30.34%, 16 July 2016 https://discuss.leetcode.com/topic/16441/short-o-n-time-o-1-space-c-solution Short O(n) time, O(1) space C++ solution I just write the sum into the longer one of the inputs. Don’t worry about modifying them, as getting string means we’re getting copies. The “O(1) space” of course refers to the space I use in addition to input and output. If the output doesn’t need to be longer than the longer input, I even only use O(1) space in addition to only the input. 12345678910111213141516class Solution &#123;public: string addBinary(string a, string b) &#123; if (a.size() &lt; b.size()) swap(a, b); int i = a.size(), j = b.size(); while (i--) &#123; if (j) a[i] += b[--j] &amp; 1; if (a[i] &gt; &apos;1&apos;) &#123; a[i] -= 2; if (i) a[i-1]++; else a = &apos;1&apos; + a; &#125; &#125; return a; &#125;&#125;; python 76ms, 34.89%, 16 July, 2016 https://discuss.leetcode.com/topic/19383/one-line-python-solution 12345678class Solution(object): def addBinary(self, a, b): &quot;&quot;&quot; :type a: str :type b: str :rtype: str &quot;&quot;&quot; return bin(eval(&apos;0b&apos;+a) + eval(&apos;0b&apos;+b))[2:] 60ms, 80.04%, 16 July 2016 https://discuss.leetcode.com/topic/12116/simple-python-solution-76ms if int() function is allowed, the following code may be more simple. :) 12345678910class Solution(object): def addBinary(self, a, b): &quot;&quot;&quot; :type a: str :type b: str :rtype: str &quot;&quot;&quot; a = int(a, 2) b = int(b, 2) return (&apos;&apos; + bin(a+b))[2:] Simple Python Solution 76ms I assume using int and str is okay, I think this is easy to understand. 12345678910111213141516def addBinary(self, a, b): result = &apos;&apos; index = 0 carry = &apos;0&apos; while index &lt; max(len(a), len(b)) or carry == &apos;1&apos;: num_a = a[-1 - index] if index &lt; len(a) else &apos;0&apos; num_b = b[-1 - index] if index &lt; len(b) else &apos;0&apos; val = int(num_a) + int(num_b) + int(carry) result = str(val % 2) + result carry = &apos;1&apos; if val &gt; 1 else &apos;0&apos; index += 1 return result update No int and str version. 123456789101112131415161718192021222324252627class Solution:# @param a, a string# @param b, a string# @return a string# 75msdef addBinary(self, a, b): result = &apos;&apos; index = 0 carry = &apos;0&apos; while index &lt; max(len(a), len(b)) or carry == &apos;1&apos;: num_a = a[-1 - index] if index &lt; len(a) else &apos;0&apos; num_b = b[-1 - index] if index &lt; len(b) else &apos;0&apos; val = self.to_int(num_a) + self.to_int(num_b) + self.to_int(carry) result = &quot;%s%s&quot; % (val % 2, result) carry = &apos;1&apos; if val &gt; 1 else &apos;0&apos; index += 1 return resultdef to_int(self, c): if c == &apos;1&apos;: return 1 elif c == &apos;0&apos;: return 0 java https://discuss.leetcode.com/topic/13698/short-ac-solution-in-java-with-explanation Short AC solution in Java with explanation Computation from string usually can be simplified by using a carry as such. 123456789101112131415public class Solution &#123; public String addBinary(String a, String b) &#123; StringBuilder sb = new StringBuilder(); int i = a.length() - 1, j = b.length() -1, carry = 0; while (i &gt;= 0 || j &gt;= 0) &#123; int sum = carry; if (j &gt;= 0) sum += b.charAt(j--) - &apos;0&apos;; if (i &gt;= 0) sum += a.charAt(i--) - &apos;0&apos;; sb.append(sum % 2); carry = sum / 2; &#125; if (carry != 0) sb.append(carry); return sb.reverse().toString(); &#125;&#125; https://discuss.leetcode.com/topic/5172/simple-accepted-java-solution Simple accepted java solution Addition bits are calculated by xor. Carry bit is calculated as simple integer addition.1234567891011121314151617181920212223242526272829public class Solution &#123; public String addBinary(String a, String b) &#123; if(a == null || a.isEmpty()) &#123; return b; &#125; if(b == null || b.isEmpty()) &#123; return a; &#125; char[] aArray = a.toCharArray(); char[] bArray = b.toCharArray(); StringBuilder stb = new StringBuilder(); int i = aArray.length - 1; int j = bArray.length - 1; int aByte; int bByte; int carry = 0; int result; while(i &gt; -1 || j &gt; -1 || carry == 1) &#123; aByte = (i &gt; -1) ? Character.getNumericValue(aArray[i--]) : 0; bByte = (j &gt; -1) ? Character.getNumericValue(bArray[j--]) : 0; result = aByte ^ bByte ^ carry; carry = ((aByte + bByte + carry) &gt;= 2) ? 1 : 0; stb.append(result); &#125; return stb.reverse().toString(); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>math</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[066. Plus One]]></title>
    <url>%2Fp%2F15c6dd1%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/plus-one/ Given a non-negative number represented as an array of digits, plus one to the number. The digits are stored such that the most significant digit is at the head of the list. https://discuss.leetcode.com/topic/987/to-avoid-confusion-please-mention-that-the-lowest-digit-is-on-the-right-end To avoid confusion, please mention that the lowest digit is on the right end The question description does not explicitly say that. I found that is the case. https://discuss.leetcode.com/topic/1264/missing-information Missing information When I started writing the solution I was thinking we were talking about binary digits, please add this information to the text of the problem. The numerical base requested. Would be cool to have a more general problem that also passes the numerical base to the function ;-) 方法一： 更改每一位，从最后一位向前走。 如果尾数是9，就改为0。 如果到某一位不是9，直接返回。 如果走到头都是9，则第一位改为1，最后加一位0. code 1： 12345678910111213141516171819void plusone(vector&lt;int&gt; &amp;digits)&#123; int n = digits.size(); for (int i = n - 1; i &gt;= 0; --i) &#123; if (digits[i] == 9) &#123; digits[i] = 0; &#125; else &#123; digits[i]++; return; &#125; &#125; digits[0] =1; digits.push_back(0); &#125; code 2： 1234567891011class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; for (int i=digits.size(); i--; digits[i] = 0) if (digits[i]++ &lt; 9) return digits; digits[0]++; digits.push_back(0); return digits; &#125;&#125;; java https://discuss.leetcode.com/topic/24288/my-simple-java-solution My Simple Java Solution 1234567891011121314151617public int[] plusOne(int[] digits) &#123; int n = digits.length; for(int i=n-1; i&gt;=0; i--) &#123; if(digits[i] &lt; 9) &#123; digits[i]++; return digits; &#125; digits[i] = 0; &#125; int[] newNumber = new int [n+1]; newNumber[0] = 1; return newNumber;&#125; https://discuss.leetcode.com/topic/19149/simple-java-solution Simple java solution 12345678910111213141516public int[] plusOne(int[] digits) &#123; for (int i = digits.length - 1; i &gt;=0; i--) &#123; if (digits[i] != 9) &#123; digits[i]++; break; &#125; else &#123; digits[i] = 0; &#125; &#125; if (digits[0] == 0) &#123; int[] res = new int[digits.length+1]; res[0] = 1; return res; &#125; return digits;&#125; https://discuss.leetcode.com/topic/41728/java-concise-solution-with-early-return Java concise solution with early return. 123456789101112public int[] plusOne(int[] digits) &#123; int carry = 1; for (int i = digits.length-1; i&gt;= 0; i--) &#123; digits[i] += carry; if (digits[i] &lt;= 9) // early return return digits; digits[i] = 0; &#125; int[] ret = new int[digits.length+1]; ret[0] = 1; return ret;&#125; 0ms, 38.09%, June.17th, 2016 http://www.itnose.net/news/172/6334216 12345678910111213141516171819202122232425public class Solution &#123; public int[] plusOne(int[] digits) &#123; int carry = 1; // 进位标志，下一位来的进位标志 int tmp; for (int i = digits.length - 1; i &gt;= 0; i--) &#123; tmp = digits[i]; digits[i] = (tmp + carry) % 10; // 计算当前位的新值 carry = (tmp + carry) / 10; // 计算新的进位 if (carry == 0) &#123; // 没有进位了就可以退出了 break; &#125; &#125; if (carry == 1) &#123; // 最后还有一个进位 int[] result = new int[digits.length + 1]; System.arraycopy(digits, 0, result, 1, digits.length); result[0] = carry;; return result; &#125; else &#123; return digits; &#125; &#125;&#125; cpp https://discuss.leetcode.com/topic/4556/is-it-a-simple-code-c Is it a simple code(C++)? 12345678910111213141516171819void plusone(vector&lt;int&gt; &amp;digits)&#123; int n = digits.size(); for (int i = n - 1; i &gt;= 0; --i) &#123; if (digits[i] == 9) &#123; digits[i] = 0; &#125; else &#123; digits[i]++; return; &#125; &#125; digits[0] =1; digits.push_back(0); &#125; https://discuss.leetcode.com/topic/9016/my-c-solution-with-few-lines My C++ Solution with few lines 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt; &amp;digits) &#123; bool carry = true; for(int i=digits.size()-1; i &gt;= 0 &amp;&amp; carry; i--) &#123; carry = (++digits[i]%=10) == 0; &#125; if(carry) &#123; digits.insert(digits.begin(), 1); &#125; return digits; &#125;&#125;; 4ms, 9.24%, June.17th, 2016 https://leetcode.com/discuss/14616/is-it-a-simple-code-c 1234567891011class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; for (int i=digits.size(); i--; digits[i] = 0) if (digits[i]++ &lt; 9) return digits; digits[0]++; digits.push_back(0); return digits; &#125;&#125;; python 46ms, 94.03%, June.17th, 2016 https://leetcode.com/discuss/18768/simple-python-solution-with-explanation-plus-one Simple Python solution with explanation (Plus One) 12345def plusOne(digits): num = 0 for i in range(len(digits)): num += digits[i] * pow(10, (len(digits)-1-i)) return [int(i) for i in str(num+1)] We’re given a list of digits, and the idea here is to convert that list to an integer, num. So each digit is multiplied by the proper place value and added to num. For example, if digits = [3, 8, 2, 5] then on the first iteration 3 is multiplied by 10 to the power of 4-1-0 = 3, so this results in 3000, which is added to num. Then 8 is multiplied by 10^2 and added to num, and so on. The last step is to add 1 to num, convert it to a list and return that list.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[065. Valid Number]]></title>
    <url>%2Fp%2Fdad046c3%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/valid-number/ Validate if a given string is numeric. 123456Some examples:&quot;0&quot; =&gt; true&quot; 0.1 &quot; =&gt; true&quot;abc&quot; =&gt; false&quot;1 a&quot; =&gt; false&quot;2e10&quot; =&gt; true Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. https://discuss.leetcode.com/topic/1095/the-worst-problem-i-have-ever-met-in-this-oj The worst problem i have ever met in this oj The description do not give a clear explantion of the definition of a valid Number, we just use more and more trick to get the right solution. It’s too bad, it’s waste of my time https://discuss.leetcode.com/topic/1095/the-worst-problem-i-have-ever-met-in-this-oj/4 +1 for the worst problem on OJ. This is definitely a valid interview question, but it requires heavy clarification through interaction. In a real interview, you have one and only one source to get all the missing information, a.k.a. your interviewer. On OJ, however, there is no interaction whatsoever except through trial and error. This, as far as I am concerned, is directly against the principle of ‘collecting all the info before implementing’. Internet searching also does not work since the word ‘numeric’ is not even defined in the question. No wonder this relatively easy (implementation-wise) problem has one of the lowest rates of acceptance. I would suggest OJ: provide all the details to let users focus on the implementation, or leave room for ambiguity but also suggest where the info can be collected, or provide an interactive applet or something like that on the page so that the user can try the string combinations that they are uncertain of before implementing. I think this is an easy thing to do, and it saves everybody’s time. java https://discuss.leetcode.com/topic/9490/clear-java-solution-with-ifs Clear Java solution with ifs All we need is to have a couple of flags so we can process the string in linear time: 123456789101112131415161718192021222324252627282930313233public boolean isNumber(String s) &#123; s = s.trim(); boolean pointSeen = false; boolean eSeen = false; boolean numberSeen = false; boolean numberAfterE = true; for(int i=0; i&lt;s.length(); i++) &#123; if(&apos;0&apos; &lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= &apos;9&apos;) &#123; numberSeen = true; numberAfterE = true; &#125; else if(s.charAt(i) == &apos;.&apos;) &#123; if(eSeen || pointSeen) &#123; return false; &#125; pointSeen = true; &#125; else if(s.charAt(i) == &apos;e&apos;) &#123; if(eSeen || !numberSeen) &#123; return false; &#125; numberAfterE = false; eSeen = true; &#125; else if(s.charAt(i) == &apos;-&apos; || s.charAt(i) == &apos;+&apos;) &#123; if(i != 0 &amp;&amp; s.charAt(i-1) != &apos;e&apos;) &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; return numberSeen &amp;&amp; numberAfterE;&#125; We start with trimming. If we see [0-9] we reset the number flags. We can only see . if we didn’t see e or .. We can only see e if we didn’t see e but we did see a number. We reset numberAfterE flag. We can only see + and - in the beginning and after an e any other character break the validation. At the and it is only valid if there was at least 1 number and if we did see an e then a number after it as well. So basically the number should match this regular expression: 1[-+]?(([0-9]+(.[0-9]*)?)|.[0-9]+)(e[-+]?[0-9]+)? https://discuss.leetcode.com/topic/8029/a-clean-design-solution-by-using-design-pattern A clean design solution By using design pattern This problem give me a good chance to convey the importance of good design. The problem is very vogue. The point here is not how you design a algorithm, it is how you handle all cases well. There is no a clear standard for whether is a number valid, is it .50 , 39. a legal float point number? Are there only valid formats given by the example? Is hex format such as 0x12ab legal? How about if we need to add another format such as roman number like “I, II , IV” as legal format. I found all solution are just plug logic into one function, there are lots of switch case, if else in there. It is problematic, easy for bugs, difficult to add new features, and of course, in-reusable, and here I propose a design to handle this problem easily and nicely. First we we can give out an interface for this problem: 1234interface NumberValidate &#123; boolean validate(String s);&#125; for any string, we call validate and it return whether the given string is a valid number. Follow we can create concrete implementation for this interface, such as IntegeValidator, FloatValidator, ScienceValidator. and then using chain of responsibility design patter (from book of GOF) , chain all those validator into a list, and feed the string to each one, if there is one validator return true, then the string is a valid number. The design has two advantages, one is easy to fix, for any corner cases or bug, we can locate the problem to specific validator, the effect of changing one validator will not sprint out to the all system, we call this as “encapsulation”. Second is easy to extend, if we need to verify hex format or roman number format , we just need to create new validator and add to the chain, we call this advantage as “close for modification open for extension”. Follow is code for the passed design: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295interface NumberValidate &#123; boolean validate(String s);&#125;abstract class NumberValidateTemplate implements NumberValidate&#123;public boolean validate(String s) &#123; if (checkStringEmpty(s)) &#123; return false; &#125; s = checkAndProcessHeader(s); if (s.length() == 0) &#123; return false; &#125; return doValidate(s); &#125; private boolean checkStringEmpty(String s) &#123; if (s.equals(&quot;&quot;)) &#123; return true; &#125; return false; &#125; private String checkAndProcessHeader(String value) &#123; value = value.trim(); if (value.startsWith(&quot;+&quot;) || value.startsWith(&quot;-&quot;)) &#123; value = value.substring(1); &#125; return value; &#125; protected abstract boolean doValidate(String s);&#125;class NumberValidator implements NumberValidate &#123; private ArrayList&lt;NumberValidate&gt; validators = new ArrayList&lt;NumberValidate&gt;(); public NumberValidator() &#123; addValidators(); &#125; private void addValidators() &#123; NumberValidate nv = new IntegerValidate(); validators.add(nv); nv = new FloatValidate(); validators.add(nv); nv = new HexValidate(); validators.add(nv); nv = new SienceFormatValidate(); validators.add(nv); &#125; @Override public boolean validate(String s) &#123; for (NumberValidate nv : validators) &#123; if (nv.validate(s) == true) &#123; return true; &#125; &#125; return false; &#125; &#125;class IntegerValidate extends NumberValidateTemplate&#123; protected boolean doValidate(String integer) &#123; for (int i = 0; i &lt; integer.length(); i++) &#123; if(Character.isDigit(integer.charAt(i)) == false) &#123; return false; &#125; &#125; return true; &#125;&#125;class HexValidate extends NumberValidateTemplate&#123; private char[] valids = new char[] &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;&#125;; protected boolean doValidate(String hex) &#123; hex = hex.toLowerCase(); if (hex.startsWith(&quot;0x&quot;)) &#123; hex = hex.substring(2); &#125; else &#123; return false; &#125; for (int i = 0; i &lt; hex.length(); i++) &#123; if (Character.isDigit(hex.charAt(i)) != true &amp;&amp; isValidChar(hex.charAt(i)) != true) &#123; return false; &#125; &#125; return true; &#125; private boolean isValidChar(char c) &#123; for (int i = 0; i &lt; valids.length; i++) &#123; if (c == valids[i]) &#123; return true; &#125; &#125; return false; &#125;&#125;class SienceFormatValidate extends NumberValidateTemplate&#123;protected boolean doValidate(String s) &#123; s = s.toLowerCase(); int pos = s.indexOf(&quot;e&quot;); if (pos == -1) &#123; return false; &#125; if (s.length() == 1) &#123; return false; &#125; String first = s.substring(0, pos); String second = s.substring(pos+1, s.length()); if (validatePartBeforeE(first) == false || validatePartAfterE(second) == false) &#123; return false; &#125; return true; &#125; private boolean validatePartBeforeE(String first) &#123; if (first.equals(&quot;&quot;) == true) &#123; return false; &#125; if (checkHeadAndEndForSpace(first) == false) &#123; return false; &#125; NumberValidate integerValidate = new IntegerValidate(); NumberValidate floatValidate = new FloatValidate(); if (integerValidate.validate(first) == false &amp;&amp; floatValidate.validate(first) == false) &#123; return false; &#125; return true; &#125; private boolean checkHeadAndEndForSpace(String part) &#123; if (part.startsWith(&quot; &quot;) || part.endsWith(&quot; &quot;)) &#123; return false; &#125; return true; &#125; private boolean validatePartAfterE(String second) &#123; if (second.equals(&quot;&quot;) == true) &#123; return false; &#125; if (checkHeadAndEndForSpace(second) == false) &#123; return false; &#125; NumberValidate integerValidate = new IntegerValidate(); if (integerValidate.validate(second) == false) &#123; return false; &#125; return true; &#125;&#125;class FloatValidate extends NumberValidateTemplate&#123; protected boolean doValidate(String floatVal) &#123; int pos = floatVal.indexOf(&quot;.&quot;); if (pos == -1) &#123; return false; &#125; if (floatVal.length() == 1) &#123; return false; &#125; NumberValidate nv = new IntegerValidate(); String first = floatVal.substring(0, pos); String second = floatVal.substring(pos + 1, floatVal.length()); if (checkFirstPart(first) == true &amp;&amp; checkFirstPart(second) == true) &#123; return true; &#125; return false; &#125; private boolean checkFirstPart(String first) &#123; if (first.equals(&quot;&quot;) == false &amp;&amp; checkPart(first) == false) &#123; return false; &#125; return true; &#125; private boolean checkPart(String part) &#123; if (Character.isDigit(part.charAt(0)) == false || Character.isDigit(part.charAt(part.length() - 1)) == false) &#123; return false; &#125; NumberValidate nv = new IntegerValidate(); if (nv.validate(part) == false) &#123; return false; &#125; return true; &#125;&#125;public class Solution &#123; public boolean isNumber(String s) &#123; NumberValidate nv = new NumberValidator(); return nv.validate(s); &#125;&#125; https://discuss.leetcode.com/topic/40983/java-logically-simple-flexible-and-clear-solution-including-rules-of-a-valid-number Java logically simple, flexible and clear solution including rules of a valid number The idea is to identify the rules of a valid number first, then set boolean variables to mark key characters and judge the validity. This solution is logically simple and easy to understand, and moreover, it is flexible to extend to the cases where a string of a valid number can accept any space appears anywhere, or/and the exponent can be a decimal number. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public boolean isNumber(String s) &#123; /** * isNumber(s)==true if and only if s=s1 or s1+&apos;e&apos;+s2, where s1, s2 * are valid strings of a number without the char &apos;e&apos;, and s2 is an * integer. * * &apos;e&apos; : valid_count=0~1; [boolean hasE] * * Valid chars in a string of a number without &apos;e&apos;: * * &apos; &apos; : valid_count=0~n; must appear at two ends * * &apos;+/-&apos; : valid_count=0~1; must be the first non-space valid char; * [boolean hasFirst] * * &apos;.&apos; : valid_count=0~1; cannot appear after &apos;e&apos;; [boolean hasDot] * * &apos;0~9&apos; : valid_count=1~n; [boolean hasDigit] */ s = s.trim(); int n = s.length(); if (n == 0) return false; boolean hasE, hasFirst, hasDot, hasDigit; hasE = hasFirst = hasDot = hasDigit = false; char c; for (int i = 0; i &lt; n; i++) &#123; c = s.charAt(i); if (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) &#123; hasFirst = hasDigit = true; continue; &#125; switch (c) &#123; /* * case &apos; &apos;: continue; */ // extend to accept any space everywhere case &apos;e&apos;: // already has &apos;e&apos; or no digit before &apos;e&apos; if (hasE || !hasDigit) return false; hasE = true; // reset for the exponential number hasFirst = hasDigit = false; hasDot = true; // the exponent must be an integer, hence // regard as if a dot exists already. Set // hasDot = false extending to accept any // (decimal) number as an exponent. continue; case &apos;+&apos;: case &apos;-&apos;: if (hasFirst) return false; hasFirst = true; continue; case &apos;.&apos;: if (hasDot) return false; hasFirst = hasDot = true; continue; default: return false; &#125; &#125; return hasDigit; &#125; https://discuss.leetcode.com/topic/2973/java-solution-with-one-line Java solution with one line 1return s.matches(&quot;(\\s*)[+-]?((\\.[0-9]+)|([0-9]+(\\.[0-9]*)?))(e[+-]?[0-9]+)?(\\s*)&quot;); cpp https://discuss.leetcode.com/topic/2710/a-simple-solution-in-cpp A simple solution in cpp The idea is pretty straightforward. A valid number is composed of the significand and the exponent (which is optional). As we go through the string, do the following things one by one: skip the leading whitespaces; check if the significand is valid. To do so, simply skip the leading sign and count the number of digits and the number of points. A valid significand has no more than one point and at least one digit. check if the exponent part is valid. We do this if the significand is followed by ‘e’. Simply skip the leading sign and count the number of digits. A valid exponent contain at least one digit. skip the trailing whitespaces. We must reach the ending 0 if the string is a valid number. 1234567891011121314151617181920212223242526272829303132bool isNumber(const char *s) &#123; int i = 0; // skip the whilespaces for(; s[i] == &apos; &apos;; i++) &#123;&#125; // check the significand if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; // skip the sign if exist int n_nm, n_pt; for(n_nm=0, n_pt=0; (s[i]&lt;=&apos;9&apos; &amp;&amp; s[i]&gt;=&apos;0&apos;) || s[i]==&apos;.&apos;; i++) s[i] == &apos;.&apos; ? n_pt++:n_nm++; if(n_pt&gt;1 || n_nm&lt;1) // no more than one point, at least one digit return false; // check the exponent if exist if(s[i] == &apos;e&apos;) &#123; i++; if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; // skip the sign int n_nm = 0; for(; s[i]&gt;=&apos;0&apos; &amp;&amp; s[i]&lt;=&apos;9&apos;; i++, n_nm++) &#123;&#125; if(n_nm&lt;1) return false; &#125; // skip the trailing whitespaces for(; s[i] == &apos; &apos;; i++) &#123;&#125; return s[i]==0; // must reach the ending 0 of the string&#125; https://discuss.leetcode.com/topic/30058/a-simple-solution-in-python-based-on-dfa A simple solution in Python based on DFA I was asked in the interview of linkedIn, writing it directly can be extremely complicated, for there are many special cases we have to deal with, and the code I wrote was messy. Then I failed to pass the interview. Here’s a clear solution. With DFA we can easily get our idea into shape and then debug, and the source code is clear and simple. 12345678910111213141516171819202122232425262728293031class Solution(object): def isNumber(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; #define a DFA state = [&#123;&#125;, &#123;&apos;blank&apos;: 1, &apos;sign&apos;: 2, &apos;digit&apos;:3, &apos;.&apos;:4&#125;, &#123;&apos;digit&apos;:3, &apos;.&apos;:4&#125;, &#123;&apos;digit&apos;:3, &apos;.&apos;:5, &apos;e&apos;:6, &apos;blank&apos;:9&#125;, &#123;&apos;digit&apos;:5&#125;, &#123;&apos;digit&apos;:5, &apos;e&apos;:6, &apos;blank&apos;:9&#125;, &#123;&apos;sign&apos;:7, &apos;digit&apos;:8&#125;, &#123;&apos;digit&apos;:8&#125;, &#123;&apos;digit&apos;:8, &apos;blank&apos;:9&#125;, &#123;&apos;blank&apos;:9&#125;] currentState = 1 for c in s: if c &gt;= &apos;0&apos; and c &lt;= &apos;9&apos;: c = &apos;digit&apos; if c == &apos; &apos;: c = &apos;blank&apos; if c in [&apos;+&apos;, &apos;-&apos;]: c = &apos;sign&apos; if c not in state[currentState].keys(): return False currentState = state[currentState][c] if currentState not in [3,5,8,9]: return False return True https://discuss.leetcode.com/topic/4219/c-my-thought-with-dfa [C++] My thought with DFA Code first 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool isNumber(string str) &#123; int state=0, flag=0; // flag to judge the special case &quot;.&quot; while(str[0]==&apos; &apos;) str.erase(0,1);//delete the prefix whitespace while(str[str.length()-1]==&apos; &apos;) str.erase(str.length()-1, 1);//delete the suffix whitespace for(int i=0; i&lt;str.length(); i++)&#123; if(&apos;0&apos;&lt;=str[i] &amp;&amp; str[i]&lt;=&apos;9&apos;)&#123; flag=1; if(state&lt;=2) state=2; else state=(state&lt;=5)?5:7; &#125; else if(&apos;+&apos;==str[i] || &apos;-&apos;==str[i])&#123; if(state==0 || state==3) state++; else return false; &#125; else if(&apos;.&apos;==str[i])&#123; if(state&lt;=2) state=6; else return false; &#125; else if(&apos;e&apos;==str[i])&#123; if(flag&amp;&amp;(state==2 || state==6 || state==7)) state=3; else return false; &#125; else return false; &#125; return (state==2 || state==5 || (flag&amp;&amp;state==6) || state==7); &#125;&#125;; DFA Thank @unknowcs, he came up with a brilliant provement in comments that making this a perfect DFA！ It’s just some states changes depend on inputs only. There 8 state in my states in my DFA.Below is my DFA transition diagram. DFA transition diagram or click picture hereDFA transition diagram There are 5 kind of inputs in my DFA: digit : number 0-9 for +,- : operator + or -(negative or positive) exp: e dot: . other: you can return false Immediately 4 final States in my DFA transition diagram : s2, s6, s7, s8 If the state change to final state at last, return true. s2 can accept digits only : +1 -23432 123 and etc s5 can accept exp expression: +2.4e+12 3e9 and etc s6 can accept decimals end with dot: 1. -42. and etc(careful, what if there exist only one dot “.” I use a variable flag judging weather there existing numbers. cause 0. and .0 is valid and . is invalid ) s7 can accept decimals: +12.23, 87., 132 It is clear how DFA works in my pictures. We just need to handle the inputs, and update the state according to DFA. https://discuss.leetcode.com/topic/17942/c-12-ms-give-some-invalid-examples-easily-understand C++ 12 ms,Give some invalid examples,easily understand 1234567891011121314151617181920212223class Solution &#123;public: bool isNumber(string s) &#123; //&quot;1 1&quot;is not valid, &quot;0x11&quot; is not valid, &quot;.&quot; is not valid, &quot;2e3.1&quot; is not valid, &quot;2e&quot; is not valid,&quot;1a&quot; is not valid,&quot;++1&quot; is not valid int n = s.size(); if(n == 0) return false; int i = 0; int count_num = 0,count_point = 0; while(s[i] == &apos; &apos;) i++; if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; while(isdigit(s[i]) || s[i] == &apos;.&apos;) s[i++] == &apos;.&apos;?count_point++:count_num++; if(count_point &gt; 1 || count_num &lt; 1) return false; if(s[i] == &apos;e&apos;)&#123; i++; count_num = 0;count_point = 0; if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; while(isdigit(s[i]) || s[i] == &apos;.&apos;) s[i++] == &apos;.&apos;?count_point++:count_num++; if(count_point &gt; 0 || count_num &lt; 1) return false; &#125; while(s[i] == &apos; &apos;) i++; return i == n; &#125;&#125;; python https://discuss.leetcode.com/topic/26746/easy-python-solution-68-ms-beats-100 Easy Python Solution 68 ms beats 100% 1234def isNumber(self, s): try: float(s) except ValueError: return False else: return True Easy Peasy :)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[064. Minimum Path Sum]]></title>
    <url>%2Fp%2Ff9fa56b2%2F</url>
    <content type="text"><![CDATA[37.5% https://leetcode.com/problems/minimum-path-sum/ Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. 方法一: 我的代码实现: 1234567891011121314151617class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(); for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(i&gt;0 &amp;&amp; j&gt;0) grid[i][j] += min(grid[i-1][j], grid[i][j-1]); else if(i==0 &amp;&amp; j&gt;0) grid[i][j] += grid[i][j-1]; else if(i&gt;0 &amp;&amp; j==0) grid[i][j] += grid[i-1][j]; &#125; &#125; return grid[m-1][n-1]; &#125;&#125;; https://discuss.leetcode.com/topic/15269/10-lines-28ms-o-n-space-dp-solution-in-c-with-explanations 10-lines 28ms O(n)-space DP solution in C++ with Explanations This is a typical DP problem. Suppose the minimum path sum of arriving at point (i, j) is S[i][j], then the state equation is S[i][j] = min(S[i - 1][j], S[i][j - 1]) + grid[i][j]. Well, some boundary conditions need to be handled. The boundary conditions happen on the topmost row (S[i - 1][j] does not exist) and the leftmost column (S[i][j - 1] does not exist). Suppose grid is like [1, 1, 1, 1], then the minimum sum to arrive at each point is simply an accumulation of previous points and the result is [1, 2, 3, 4]. Now we can write down the following (unoptimized) code. 12345678910111213141516class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); vector&lt;vector&lt;int&gt; &gt; sum(m, vector&lt;int&gt;(n, grid[0][0])); for (int i = 1; i &lt; m; i++) sum[i][0] = sum[i - 1][0] + grid[i][0]; for (int j = 1; j &lt; n; j++) sum[0][j] = sum[0][j - 1] + grid[0][j]; for (int i = 1; i &lt; m; i++) for (int j = 1; j &lt; n; j++) sum[i][j] = min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j]; return sum[m - 1][n - 1]; &#125;&#125;; 方法二: As can be seen, each time when we update sum[i][j], we only need sum[i - 1][j] (at the current column) and sum[i][j - 1] (at the left column). So we need not maintain the full m*n matrix. Maintaining two columns is enough and now we have the following code. 123456789101112131415161718class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); vector&lt;int&gt; pre(m, grid[0][0]); vector&lt;int&gt; cur(m, 0); for (int i = 1; i &lt; m; i++) pre[i] = pre[i - 1] + grid[i][0]; for (int j = 1; j &lt; n; j++) &#123; cur[0] = pre[0] + grid[0][j]; for (int i = 1; i &lt; m; i++) cur[i] = min(cur[i - 1], pre[i]) + grid[i][j]; swap(pre, cur); &#125; return pre[m - 1]; &#125;&#125;; Further inspecting the above code, it can be seen that maintaining pre is for recovering pre[i], which is simply cur[i] before its update. So it is enough to use only one vector. Now the space is further optimized and the code also gets shorter. 12345678910111213141516class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); vector&lt;int&gt; cur(m, grid[0][0]); for (int i = 1; i &lt; m; i++) cur[i] = cur[i - 1] + grid[i][0]; for (int j = 1; j &lt; n; j++) &#123; cur[0] += grid[0][j]; for (int i = 1; i &lt; m; i++) cur[i] = min(cur[i - 1], cur[i]) + grid[i][j]; &#125; return cur[m - 1]; &#125;&#125;; https://discuss.leetcode.com/topic/3403/dp-solution-linear-space DP Solution, Linear space You can only reach a cell by going from its left or top neighbor. 123456789101112131415161718192021class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) &#123; if(!grid.size())return 0; const int rows=grid.size(),cols=grid[0].size(); // r[i] == min path sum to previous row&apos;s column i. vector&lt;int&gt; r(cols,0); int i,j; r[0]=grid[0][0]; for(j=1;j&lt;cols;j++)&#123; r[j]=grid[0][j]+r[j-1]; &#125; for(i=1;i&lt;rows;i++)&#123; r[0]+=grid[i][0]; for(j=1;j&lt;cols;j++)&#123; r[j]=min(r[j-1],r[j])+grid[i][j]; &#125; &#125; return r[cols-1]; &#125;&#125;; https://discuss.leetcode.com/topic/448/minimum-path-sum-how-can-i-reduce-the-memory Minimum Path Sum ———How can I reduce the memory. Here is the idea: f[m][n] is a matrix store the min value of every location we canget. f[0][0] =grid[0][0], f[i][0]=f[i-1][0]+grid[i][0], f[0][j]=f[0][j-1]+grid[0][j] f[i][j]=min(f[i-1][j],f[i][j-1])+grid[i][j]. at last return the f[m-1][n-1] 1234567891011121314151617181920212223242526272829303132class Solution &#123; public: int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) &#123; // IMPORTANT: Please reset any member data you declared, as // the same Solution instance will be reused for each test case. int m=grid.size(); int n=grid[0].size(); int** f; f=new int*[m]; for(int i=0;i&lt;m;i)&#123; f[i]=new int[n]; &#125; f[0][0]=grid[0][0]; for(int i=1;i&lt;m;i++)&#123; f[i][0]=f[i-1][0]+grid[i][0]; &#125; for(int i=1;i&lt;n;i++)&#123; f[0][i]=f[0][i-1]+grid[0][i]; &#125; for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++) f[i][j]=min(f[i-1][j],f[i][j-1])+grid[i][j]; &#125; return f[m-1][n-1]; &#125; int min(int a,int b)&#123; if(a&gt;b) return b; else return a; &#125; &#125;; https://discuss.leetcode.com/topic/16654/c-easy-solution-using-dp-space-compexity-o-1 C++ easy solution using dp. space compexity : O(1) 123456789101112131415161718class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; a) &#123; int m=a.size(); if(m==0) return 0; int n= a[0].size(); for(int i = 0 ; i&lt;m; i++ )&#123; for(int j=0; j&lt;n ; j++)&#123; int left= (j==0) ? INT_MAX : a[i][j-1]; int up = (i==0) ? INT_MAX : a[i-1][j]; if(i==0 &amp;&amp; j==0) continue; a[i][j] += min(left, up ); &#125; &#125; return a[m-1][n-1]; &#125;&#125;; python https://leetcode.com/discuss/34905/simple-python-dp-70ms 76ms, 49.83%, June.20th, 2016 12345678910111213141516class Solution(object): def minPathSum(self, grid): &quot;&quot;&quot; :type grid: List[List[int]] :rtype: int &quot;&quot;&quot; m = len(grid) n = len(grid[0]) for i in xrange(1, n): grid[0][i] += grid[0][i-1] for i in xrange(1, m): grid[i][0] += grid[i-1][0] for i in xrange(1,m): for j in xrange(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[-1][-1] java https://discuss.leetcode.com/topic/5459/my-java-solution-using-dp-and-no-extra-space My java solution using DP and no extra space 1234567891011121314151617181920public int minPathSum(int[][] grid) &#123; int m = grid.length;// row int n = grid[0].length; // column for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == 0 &amp;&amp; j != 0) &#123; grid[i][j] = grid[i][j] + grid[i][j - 1]; &#125; else if (i != 0 &amp;&amp; j == 0) &#123; grid[i][j] = grid[i][j] + grid[i - 1][j]; &#125; else if (i == 0 &amp;&amp; j == 0) &#123; grid[i][j] = grid[i][j]; &#125; else &#123; grid[i][j] = Math.min(grid[i][j - 1], grid[i - 1][j]) + grid[i][j]; &#125; &#125; &#125; return grid[m - 1][n - 1];&#125; https://discuss.leetcode.com/topic/30575/my-8-lines-simple-solution My 8 lines simple solution 123456789int m = grid.length, n = grid[0].length;for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == 0 &amp;&amp; j != 0) grid[i][j] += grid[i][j-1]; if(i != 0 &amp;&amp; j == 0) grid[i][j] += grid[i-1][j]; if (i != 0 &amp;&amp; j != 0) grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]); &#125;&#125;return grid[m-1][n-1]; https://discuss.leetcode.com/topic/3184/ac-java-dp-solution-v-s-tle-dijstra-solution AC Java DP solution v.s. TLE Dijstra solution When I looked at this question, the first thought was the Dijkstra solution, which is a very fast algorithm to calculate the shortest path. But this solution got TLE in this question, while DP solution worked fine. I will talk about the Dijkstra solution first, as it’s the first though came into my mind, and there is already discussions on the DP solution. If you are not interested in the Dijkstra solution, you can jump to the latter part of this post, which is about the DP solution, which is accepted. DijkstraThe idea of Dijkstra algorithm is to divide the graph into 2 parts, visited and unvisited.For every node in the visited part has a dist value. Then we need to exam every edges across the visited part and the unvisited parts, which are edges that its start node is in the visited part, while its end node is in the unvisited part. What we are looking for is one edge, which has the minimum value of (dist(start node) + the edge’s value). Then we put this node into the visited part and exam the edges again. Following is the code. It uses a Java Heap, PriorityQueue to keep track of the minimum (dist(start node) + the edge’s value), but in this question, the edge value is in the node itself, which is the same for every edges ending to it, so actually the heap just keeps track of the mimimum dist(start node) of every unvisited nodes around the boarder between visited and unvisited. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Solution_dijkstra &#123;class PointComparator implements Comparator&lt;int[]&gt;&#123; int[][] dist; public PointComparator(int[][] dist)&#123; this.dist = dist; &#125; @Override public int compare(int[] o1, int[] o2) &#123; int[] point1 = (int[])o1; int[] point2 = (int[])o2; return Integer.valueOf(dist[point1[0]][point1[1]]) .compareTo(Integer.valueOf(dist[point2[0]][point2[1]])); &#125;&#125; public int minPathSum(int[][] grid) &#123; if(grid == null || grid.length == 0) return 0; int m = grid.length; int n = grid[0].length; boolean[][] visited = new boolean[m][n]; int[][] dist = new int[m][n]; for(int x = 0; x &lt; m; x++)&#123; for(int y = 0; y &lt; n; y++)&#123; dist[x][y] = Integer.MAX_VALUE; &#125; &#125; dist[0][0] = grid[0][0]; PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;( m*n, new PointComparator(dist)); pq.add(new int[]&#123;0, 0&#125;); while(!pq.isEmpty())&#123; int[] point = pq.poll(); int x = point[0]; int y = point[1]; int d = dist[x][y]; if(x == n-1 &amp;&amp; y == m-1)&#123; return d; &#125; visited[x][y] = true; if((y+1 &lt; n) &amp;&amp; !visited[x][y+1])&#123; dist[x][y+1] = min( dist[x][y+1], d + grid[x][y+1]); pq.add(new int[]&#123;x, y+1&#125;); &#125; if((x+1 &lt; m ) &amp;&amp; !visited[x+1][y])&#123; dist[x+1][y] = min( dist[x+1][y], d + grid[x+1][y]); pq.add(new int[]&#123;x+1, y&#125;); &#125; &#125; return 0; &#125;private int min(int i1, int i2)&#123; return i1 &lt; i2 ? i1 : i2;&#125;&#125; This solution got LTE error, mostly because of the priority queue and doesn’t consider the special condition here that it’s a grid and directed, which means a node can only be accessed from it’s left and upper nodes. Put all these into consideration, we have the DP solution. It’s essentially formula is dist(node) = min( dist(upper node), dist(left node)) + node’s value DPhere is the code: 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution_dp &#123;private int getDist(int[][] dist, int x, int y)&#123; if(x &lt; 0 || y &lt; 0)&#123; return Integer.MAX_VALUE; &#125; return dist[x][y]; &#125;private int min(int i1, int i2)&#123; return i1 &lt; i2 ? i1 : i2;&#125;public int minPathSum(int[][] grid) &#123; if(grid == null || grid.length == 0) return 0; int m = grid.length; int n = grid[0].length; int[][] dist = new int[m][n]; for(int x = 0; x &lt; m; x++)&#123; for(int y = 0; y &lt; n; y++)&#123; if(x == 0 &amp;&amp; y == 0)&#123; dist[0][0] = grid[0][0]; &#125;else&#123; dist[x][y] = min(getDist(dist, x-1, y), getDist(dist, x, y-1)) + grid[x][y]; &#125; &#125; &#125; return dist[m-1][n-1]; &#125;&#125; my code 1234567891011121314public class Solution &#123; public int minPathSum(int[][] grid) &#123; int m=grid.length; int n=grid[0].length; for(int i=0; i&lt;m; i++) for(int j=0; j&lt;n; j++)&#123; if(i==0 &amp;&amp; j==0) continue; if(i&gt;0 &amp;&amp; j==0) grid[i][j] += grid[i-1][j]; if(i==0 &amp;&amp; j&gt;0) grid[i][j] += grid[i][j-1]; if(i&gt;0 &amp;&amp; j&gt;0) grid[i][j] += Math.min(grid[i][j-1], grid[i-1][j]); &#125; return grid[m-1][n-1]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[063. Unique Paths II]]></title>
    <url>%2Fp%2F64df03c8%2F</url>
    <content type="text"><![CDATA[31.1% https://leetcode.com/problems/unique-paths-ii/ Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. 12345678910For example,There is one obstacle in the middle of a 3x3 grid as illustrated below.[ [0,0,0], [0,1,0], [0,0,0]]The total number of unique paths is 2. Note: m and n will be at most 100. 方法一： m*n，变为(m+1) * (n+1) ，然后（0,1）设为1，依次遍历就好了。 12345678910111213class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i = 1; i &lt;= m; ++i) for(int j = 1; j &lt;= n; ++j) if(!obstacleGrid[i-1][j-1]) dp[i][j] = dp[i-1][j] + dp[i][j-1]; return dp[m][n]; &#125;&#125;; 我的代码实现： 1234567891011121314151617class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i=1; i&lt;=m; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; if(obstacleGrid[i-1][j-1]) dp[i][j] = 0; else dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; 方法二： 上面的空间是O（mn），想法空间变为O（n）或者O（m）。 我的代码实现： Dec 7th, 2017 该方法主要是降低了空间复杂度，相对于下面的代码，这个借鉴了上面的思想，不是设置m个，而是m+1个。这样子就代码简洁和思路清晰多了。 注意代码中注释可能会犯的错。 1234567891011121314151617class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; if(obstacleGrid.empty() || obstacleGrid[0].empty()) return 0; int m = obstacleGrid[0].size(); vector&lt;int&gt; res(m+1, 0); res[1] = 1; // 不要忘了初始化 for(int i=0; i&lt;obstacleGrid.size(); i++) for(int j=0; j&lt;obstacleGrid[0].size(); j++) if(obstacleGrid[i][j]==0) //分清楚0还是1，条件 res[j+1] += res[j]; else res[j+1] = 0; return res[m];// m+1个最后一位是res[m],不是res[m+1] &#125;&#125;; 123456789101112131415161718192021222324252627class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); if(m==0 || n==0) return 0; vector&lt;int&gt; res(n, 0); if(obstacleGrid[0][0]==1) return 0; res[0] = 1; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(i==0 &amp;&amp; j==0) continue; if(i&gt;0 &amp;&amp; j==0)&#123; if(obstacleGrid[i][j]) res[j] = 0; &#125; if(j&gt;0)&#123; if(obstacleGrid[i][j]) res[j] = 0; else res[j] += res[j-1]; &#125; &#125; &#125; return res[n-1]; &#125;&#125;; cpp https://leetcode.com/discuss/13965/my-c-dp-solution-very-simple My C++ Dp solution , very simple! just use dp to find the answer , if there is a obstacle at (i,j), then dp[i][j] = 0. time is O(nm) , space is O(nm) . here is my code: 5ms, 8.13%, June.22th, 2016 12345678910111213class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i = 1; i &lt;= m; ++i) for(int j = 1; j &lt;= n; ++j) if(!obstacleGrid[i-1][j-1]) dp[i][j] = dp[i-1][j] + dp[i][j-1]; return dp[m][n]; &#125;&#125;; https://discuss.leetcode.com/topic/15267/4ms-o-n-dp-solution-in-c-with-explanations 4ms O(n) DP Solution in C++ with Explanations Well, this problem is similar to Unique Paths. The introduction of obstacles only changes the boundary conditions and make some points unreachable (simply set to 0). Denote the number of paths to arrive at point (i, j) to be P[i][j], the state equation is P[i][j] = P[i - 1][j] + P[i][j - 1] if obstacleGrid[i][j] != 1 and 0 otherwise. Now let’s finish the boundary conditions. In the Unique Paths problem, we initialize P[0][j] = 1, P[i][0] = 1 for all valid i, j. Now, due to obstacles, some boundary points are no longer reachable and need to be initialized to 0. For example, if obstacleGrid is like [0, 0, 1, 0, 0], then the last three points are not reachable and need to be initialized to be 0. The result is [1, 1, 0, 0, 0]. Now we can write down the following (unoptimized) code. Note that we pad the obstacleGrid by 1 and initialize dp[0][1] = 1 to unify the boundary cases. 12345678910111213class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt; &gt; dp(m + 1, vector&lt;int&gt; (n + 1, 0)); dp[0][1] = 1; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (!obstacleGrid[i - 1][j - 1]) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; return dp[m][n]; &#125; &#125;; Well, the code is accepted but it has some obvious redundancy. There are two major concerns: Each time when we update path[i][j], we only need path[i - 1][j] (at the same column) and path[i][j - 1] (at the left column), so it is unnecessary to maintain the full m*n matrix. Maintaining two columns is enough.There are some cases that the loop can be terminated earlier. Suppose obstacleGrid = [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]], then we can see that it is impossible to reach the bottom-right corner after updating the second column since the number of paths to reach each element in the second column is 0.Taken these into considerations, we write down the following optimized code. 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;int&gt; pre(m, 0); vector&lt;int&gt; cur(m, 0); for (int i = 0; i &lt; m; i++) &#123; if (!obstacleGrid[i][0]) pre[i] = 1; else break; &#125; for (int j = 1; j &lt; n; j++) &#123; bool flag = false; if (!obstacleGrid[0][j]) &#123; cur[0] = pre[0]; if (cur[0]) flag = true; &#125; else cur[0] = 0; for (int i = 1; i &lt; m; i++) &#123; if (!obstacleGrid[i][j]) &#123; cur[i] = cur[i - 1] + pre[i]; if (cur[i]) flag = true; &#125; else cur[i] = 0; &#125; if (!flag) return 0; swap(pre, cur); &#125; return pre[m - 1]; &#125;&#125;; Further inspecting the above code, keeping two vectors only serve for the purpose of recovering pre[i], which is simply cur[i] before its update. So we can use only one vector and the space is further optimized. 12345678910111213141516171819202122232425262728class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;int&gt; cur(m, 0); for (int i = 0; i &lt; m; i++) &#123; if (!obstacleGrid[i][0]) cur[i] = 1; else break; &#125; for (int j = 1; j &lt; n; j++) &#123; bool flag = false; if (obstacleGrid[0][j]) cur[0] = 0; else flag = true; for (int i = 1; i &lt; m; i++) &#123; if (!obstacleGrid[i][j]) &#123; cur[i] += cur[i - 1]; if (cur[i]) flag = true; &#125; else cur[i] = 0; &#125; if (!flag) return 0; &#125; return cur[m - 1]; &#125;&#125;; python https://leetcode.com/discuss/19681/accepted-simple-python-in-place-solution Accepted simple Python in-place solution As below. Any comments on how to make it shorter? Thx! 68ms, 14.48%, June.22th, 20161234567891011121314151617class Solution(object): def uniquePathsWithObstacles(self, obstacleGrid): &quot;&quot;&quot; :type obstacleGrid: List[List[int]] :rtype: int &quot;&quot;&quot; m = len(obstacleGrid) n = len(obstacleGrid[0]) ResGrid = [[0 for x in range(n+1)] for x in range(m+1)] ResGrid[0][1] = 1 for i in range(1, m+1): for j in range(1, n+1): if not obstacleGrid[i-1][j-1]: ResGrid[i][j] = ResGrid[i][j-1] + ResGrid[i-1][j] return ResGrid[m][n] java https://leetcode.com/discuss/29816/short-java-solution Short JAVA solution 1ms, 22.20%, June.22th, 20161234567891011121314public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int width = obstacleGrid[0].length; int[] dp = new int[width]; dp[0] = 1; for(int[] row:obstacleGrid) for(int j=0; j&lt;width; j++) if(row[j] == 1) dp[j] = 0; else if(j&gt;0) dp[j] += dp[j-1]; return dp[width - 1]; &#125;&#125; https://discuss.leetcode.com/topic/4987/java-solution-using-dynamic-programming-o-1-space Java Solution using Dynamic Programming, O(1) space 12345678910111213141516171819202122232425262728public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; //Empty case if(obstacleGrid.length == 0) return 0; int rows = obstacleGrid.length; int cols = obstacleGrid[0].length; for(int i = 0; i &lt; rows; i++)&#123; for(int j = 0; j &lt; cols; j++)&#123; if(obstacleGrid[i][j] == 1) obstacleGrid[i][j] = 0; else if(i == 0 &amp;&amp; j == 0) obstacleGrid[i][j] = 1; else if(i == 0) obstacleGrid[i][j] = obstacleGrid[i][j - 1] * 1;// For row 0, if there are no paths to left cell, then its 0,else 1 else if(j == 0) obstacleGrid[i][j] = obstacleGrid[i - 1][j] * 1;// For col 0, if there are no paths to upper cell, then its 0,else 1 else obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]; &#125; &#125; return obstacleGrid[rows - 1][cols - 1]; &#125;&#125; https://discuss.leetcode.com/topic/9687/easy-java-solution-in-place-dp Easy Java solution, in-place, DP The idea is simple, set all obstacles to be 0 while doing the DP. No extra space is used. 123456789101112131415161718192021public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length; int n = obstacleGrid[0].length; obstacleGrid[0][0]^=1; for(int i = 1;i&lt;m;i++)&#123; obstacleGrid[i][0]=(obstacleGrid[i][0]==1)? 0:obstacleGrid[i-1][0]; &#125; for(int j = 1;j&lt;n;j++)&#123; obstacleGrid[0][j] =(obstacleGrid[0][j]==1)? 0: obstacleGrid[0][j-1]; &#125; for(int i = 1;i&lt;m;i++)&#123; for(int j =1;j&lt;n;j++)&#123; obstacleGrid[i][j] =(obstacleGrid[i][j]==1)? 0: obstacleGrid[i-1][j]+obstacleGrid[i][j-1]; &#125; &#125; return obstacleGrid[m-1][n-1]; &#125; &#125; my code动态规划 12345678910111213141516171819202122232425public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; if(obstacleGrid.length == 0 || obstacleGrid[0].length == 0) return 0; int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[] ans = new int[n]; if(obstacleGrid[0][0]==1) return 0; ans[0] = 1; for(int i=0; i&lt;m; i++) for(int j=0; j&lt;n; j++)&#123; if(i==0 &amp;&amp; j==0) continue; if(i&gt;0 &amp;&amp; j==0)&#123; if(obstacleGrid[i][j]==1) ans[j] = 0; &#125; if(j&gt;0)&#123; if(obstacleGrid[i][j]==1) ans[j] = 0; else ans[j] += ans[j-1]; &#125; &#125; return ans[n-1]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[062. Unique Paths]]></title>
    <url>%2Fp%2F59afcf56%2F</url>
    <content type="text"><![CDATA[39.7% https://leetcode.com/problems/unique-paths/ A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 3 x 7 grid. How many possible unique paths are there? 解析 用dp算法或者使用公式，共m+n-2步，然后从中选取m-1步作为向右。 方法一： dp算法记录每一步有的方法数，以此类推。 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; if(m==0 || n==0) return 0; vector&lt;int&gt; dp(n, 1); for(int i=1; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; dp[j] += dp[j-1]; &#125; &#125; return dp[n-1]; &#125;&#125;; 类似的方法， 上面的更简单。 1234567891011121314class Solution &#123;public: int uniquePaths(int m, int n) &#123; if(m==0 || n==0) return 0; vector&lt;int&gt; dp(n, 0); dp[0] = 1; for(int i=0; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; dp[j] += dp[j-1]; &#125; &#125; return dp[n-1]; &#125;&#125;; 方法二： 使用公式的话，记得定义值的类型要为double，否则数值就会出问题。 123456789101112131415class Solution &#123; public: int uniquePaths(int m, int n) &#123; int N = n + m - 2;// how much steps we need to do int k = m - 1; // number of steps that need to go down double res = 1; // here we calculate the total possible path number // Combination(N, k) = n! / (k!(n - k)!) // reduce the numerator and denominator and get // C = ( (n - k + 1) * (n - k + 2) * ... * n ) / k! for (int i = 1; i &lt;= k; i++) res = res * (N - k + i) / i; return (int)res; &#125; &#125;; my code: 1234567891011class Solution &#123;public: int uniquePaths(int m, int n) &#123; if(m==0 || n==0) return 0; double res = 1.0; for(int i=1; i&lt;=n-1; i++)&#123; res = res * (m-1+i) / i; &#125; return (int)res; &#125;&#125;; 方法三： m+1 * n+1数组 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i=1; i&lt;=m; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; cpp https://discuss.leetcode.com/topic/15265/0ms-5-lines-dp-solution-in-c-with-explanations 0ms, 5-lines DP Solution in C++ with Explanations This is a fundamental DP problem. First of all, let’s make some observations. Since the robot can only move right and down, when it arrives at a point, there are only two possibilities: It arrives at that point from above (moving down to that point); It arrives at that point from left (moving right to that point).Thus, we have the following state equations: suppose the number of paths to arrive at a point (i, j) is denoted as P[i][j], it is easily concluded that P[i][j] = P[i - 1][j] + P[i][j - 1]. The boundary conditions of the above equation occur at the leftmost column (P[i][j - 1] does not exist) and the uppermost row (P[i - 1][j] does not exist). These conditions can be handled by initialization (pre-processing) — initialize P[0][j] = 1, P[i][0] = 1 for all valid i, j. Note the initial value is 1 instead of 0! Now we can write down the following (unoptimized) code. 123456789class Solution &#123; int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt; &gt; path(m, vector&lt;int&gt; (n, 1)); for (int i = 1; i &lt; m; i++) for (int j = 1; j &lt; n; j++) path[i][j] = path[i - 1][j] + path[i][j - 1]; return path[m - 1][n - 1]; &#125;&#125;; As can be seen, the above solution runs in O(n^2) time and costs O(m*n) space. However, you may have observed that each time when we update path[i][j], we only need path[i - 1][j] (at the same column) and path[i][j - 1] (at the left column). So it is enough to maintain two columns (the current column and the left column) instead of maintaining the full m*n matrix. Now the code can be optimized to have O(min(m, n)) space complexity. 12345678910111213class Solution &#123; int uniquePaths(int m, int n) &#123; if (m &gt; n) return uniquePaths(n, m); vector&lt;int&gt; pre(m, 1); vector&lt;int&gt; cur(m, 1); for (int j = 1; j &lt; n; j++) &#123; for (int i = 1; i &lt; m; i++) cur[i] = cur[i - 1] + pre[i]; swap(pre, cur); &#125; return pre[m - 1]; &#125;&#125;; Further inspecting the above code, we find that keeping two columns is used to recover pre[i], which is just cur[i] before its update. So there is even no need to use two vectors and one is just enough. Now the space is further saved and the code also gets much shorter. 12345678910class Solution &#123; int uniquePaths(int m, int n) &#123; if (m &gt; n) return uniquePaths(n, m); vector&lt;int&gt; cur(m, 1); for (int j = 1; j &lt; n; j++) for (int i = 1; i &lt; m; i++) cur[i] += cur[i - 1]; return cur[m - 1]; &#125;&#125;; Well, till now, I guess you may even want to optimize it to O(1) space complexity since the above code seems to rely on only cur[i] and cur[i - 1]. You may think that 2 variables is enough? Well, it is not. Since the whole cur needs to be updated for n - 1 times, it means that all of its values need to be saved for next update and so two variables is not enough. https://leetcode.com/discuss/9110/my-ac-solution-using-formula 0ms, 17.54%, June.19th, 2016 Binomial coefficient: 123456789101112131415class Solution &#123; public: int uniquePaths(int m, int n) &#123; int N = n + m - 2;// how much steps we need to do int k = m - 1; // number of steps that need to go down double res = 1; // here we calculate the total possible path number // Combination(N, k) = n! / (k!(n - k)!) // reduce the numerator and denominator and get // C = ( (n - k + 1) * (n - k + 2) * ... * n ) / k! for (int i = 1; i &lt;= k; i++) res = res * (N - k + i) / i; return (int)res; &#125; &#125;; First of all you should understand that we need to do n + m - 2 movements : m - 1 down, n - 1 right, because we start from cell (1, 1). Secondly, the path it is the sequence of movements( go down / go right), therefore we can say that two paths are different when there is i-th (1 .. m + n - 2) movement in path1 differ i-th movement in path2. So, how we can build paths. Let’s choose (n - 1) movements(number of steps to the right) from (m + n - 2), and rest (m - 1) is (number of steps down). I think now it is obvious that count of different paths are all combinations (n - 1) movements from (m + n-2). python https://leetcode.com/discuss/63819/1-line-math-solution-python 1 Line Math Solution (Python) 48ms, 54.13%, June.19th, 201612345678class Solution(object): def uniquePaths(self, m, n): &quot;&quot;&quot; :type m: int :type n: int :rtype: int &quot;&quot;&quot; return math.factorial(m+n-2) / math.factorial(m-1) / math.factorial(n-1) https://discuss.leetcode.com/topic/6440/accpeted-simple-python-dp-solution Accpeted simple Python DP solution. 12345678class Solution: # @return an integer def uniquePaths(self, m, n): aux = [[1 for x in range(n)] for x in range(m)] for i in range(1, m): for j in range(1, n): aux[i][j] = aux[i][j-1]+aux[i-1][j] return aux[-1][-1] my code 1234567891011121314151617181920212248ms, 54.13%, June.19th, 2016class Solution(object): def uniquePaths(self, m, n): &quot;&quot;&quot; :type m: int :type n: int :rtype: int &quot;&quot;&quot; if m == 1 or n == 1: return 1 p1 = max(m-1, n-1) p2 = min(m-1, n-1) p3 = m + n - 2 res1 = 1 i = p3 while i &gt; p3 - p2: res1 *= i i -= 1 res2 = 1 while p2 &gt; 0: res2 *= p2 p2 -= 1 return res1 / res2 java https://discuss.leetcode.com/topic/5623/java-dp-solution-with-complexity-o-n-m Java DP solution with complexity O(n*m) 1234567891011121314151617public class Solution &#123; public int uniquePaths(int m, int n) &#123; Integer[][] map = new Integer[m][n]; for(int i = 0; i&lt;m;i++)&#123; map[i][0] = 1; &#125; for(int j= 0;j&lt;n;j++)&#123; map[0][j]=1; &#125; for(int i = 1;i&lt;m;i++)&#123; for(int j = 1;j&lt;n;j++)&#123; map[i][j] = map[i-1][j]+map[i][j-1]; &#125; &#125; return map[m-1][n-1]; &#125;&#125; The assumptions are When (n == 0||m == 0) the function always returns 1 since the robot can’t go left or up. For all other cells. The result = uniquePaths(m-1,n)+uniquePaths(m,n-1) Therefore I populated the edges with 1 first and use DP to get the full 2-D array. Please give any suggestions on improving the code. my code 1234567891011121314public class Solution &#123; public int uniquePaths(int m, int n) &#123; if(m == 0 || n == 0) return 0; int[] ans = new int[n]; for(int i=0; i&lt;n; i++) ans[i] = 1; for(int i=1; i&lt;m; i++) for(int j=1; j&lt;n; j++) ans[j] += ans[j-1]; return ans[n-1]; &#125;&#125; 123456789100ms, 84.01%, June.19th, 2016https://leetcode.com/discuss/9110/my-ac-solution-using-formulapublic class Solution &#123; public int uniquePaths(int m, int n) &#123; double value = 1; for(int i = 1; i &lt;= n-1; i++) value *= ((double)(m+i-1)/(double)i); return (int)Math.round(value); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[061. Rotate List]]></title>
    <url>%2Fp%2F61df86e1%2F</url>
    <content type="text"><![CDATA[24.3% https://leetcode.com/problems/rotate-list/ Given a list, rotate the list to the right by k places, where k is non-negative. 123For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. 方法一： 先遍历一遍，求出长度 通过将尾节点与头结点相链接 然后向前走 len - k%len步，就可以了。 核心：一次遍历求长度，然后尾部相连 我的代码实现： Oct, 11th, 2017 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; // 是或||的关系，不是&amp;&amp; // k==0的情况要考虑到 if(!head || !head-&gt;next || k==0) return head; ListNode* p1 = head; int cnt = 1; while(p1-&gt;next)&#123; cnt++; p1 = p1-&gt;next; &#125; // 现除以cnt // 要移动的步数，需要用cnt-k k %= cnt; k = cnt -k; p1-&gt;next = head; while(k!=0)&#123; p1 = p1-&gt;next; k--; &#125; ListNode* node = p1-&gt;next; p1-&gt;next = nullptr; return node; &#125;&#125;; C++ simple algorithm with explanation Enumerate through the list to find the last node, count the size along the way. Make a loop, by connection last to first Get modulo of |k/size| - avoiding extra rotation Enumerate again size-k nodes Break the loop and return new head code: 123456789101112131415161718192021222324252627282930ListNode *rotateRight(ListNode *head, int k) &#123; if(head == NULL || head-&gt;next == NULL||k==0) return head; ListNode* node = head; int size =1; while(node-&gt;next != NULL) &#123; size++; node = node-&gt;next; &#125; //loop the list node-&gt;next=head; //handle the case of k&gt;size k = k%size; //find the node to break the loop at while(--size &gt;= k) &#123; node=node-&gt;next; &#125; ListNode* first = node-&gt;next; node-&gt;next=NULL; return first; &#125; 代码的另一种实现 My clean C++ code, quite standard (find tail and reconnect the list) There is no trick for this problem. Some people used slow/fast pointers to find the tail node but I don’t see the benefit (in the sense that it doesn’t reduce the pointer move op) to do so. So I just used one loop to find the length first. 12ms, September 11, 2016 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(!head) return head; int len=1; // number of nodes ListNode *newH, *tail; newH=tail=head; while(tail-&gt;next) // get the number of nodes in the list &#123; tail = tail-&gt;next; len++; &#125; tail-&gt;next = head; // circle the link if(k %= len) &#123; for(auto i=0; i&lt;len-k; i++) tail = tail-&gt;next; // the tail node is the (len-k)-th node (1st node is head) &#125; newH = tail-&gt;next; tail-&gt;next = NULL; return newH; &#125;&#125;; https://discuss.leetcode.com/topic/815/what-to-do-when-k-is-greater-than-size-of-list What to do when k is greater than size of list ? i am not getting that what i should do when K is greater than size of the list. https://discuss.leetcode.com/topic/815/what-to-do-when-k-is-greater-than-size-of-list/2 Let’s start with an example. Given [0,1,2], rotate 1 steps to the right -&gt; [2,0,1]. Given [0,1,2], rotate 2 steps to the right -&gt; [1,2,0]. Given [0,1,2], rotate 3 steps to the right -&gt; [0,1,2]. Given [0,1,2], rotate 4 steps to the right -&gt; [2,0,1]. So, no matter how big K, the number of steps is, the result is always the same as rotating K % n steps to the right. https://discuss.leetcode.com/topic/9161/i-think-the-description-of-this-problem-is-misleading I think the description of this problem is misleading. Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle. cpp https://discuss.leetcode.com/topic/14470/my-clean-c-code-quite-standard-find-tail-and-reconnect-the-list My clean C++ code, quite standard (find tail and reconnect the list) There is no trick for this problem. Some people used slow/fast pointers to find the tail node but I don’t see the benefit (in the sense that it doesn’t reduce the pointer move op) to do so. So I just used one loop to find the length first. 12ms, September 11, 2016 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(!head) return head; int len=1; // number of nodes ListNode *newH, *tail; newH=tail=head; while(tail-&gt;next) // get the number of nodes in the list &#123; tail = tail-&gt;next; len++; &#125; tail-&gt;next = head; // circle the link if(k %= len) &#123; for(auto i=0; i&lt;len-k; i++) tail = tail-&gt;next; // the tail node is the (len-k)-th node (1st node is head) &#125; newH = tail-&gt;next; tail-&gt;next = NULL; return newH; &#125;&#125;; https://discuss.leetcode.com/topic/7293/c-simple-algorithm-with-explanation C++ simple algorithm with explanation Enumerate through the list to find the last node, count the size along the way. Make a loop, by connection last to first Get modulo of |k/size| - avoiding extra rotation Enumerate again size-k nodes Break the loop and return new head code: 123456789101112131415161718192021222324252627282930ListNode *rotateRight(ListNode *head, int k) &#123; if(head == NULL || head-&gt;next == NULL||k==0) return head; ListNode* node = head; int size =1; while(node-&gt;next != NULL) &#123; size++; node = node-&gt;next; &#125; //loop the list node-&gt;next=head; //handle the case of k&gt;size k = k%size; //find the node to break the loop at while(--size &gt;= k) &#123; node=node-&gt;next; &#125; ListNode* first = node-&gt;next; node-&gt;next=NULL; return first; &#125; java 1ms, September 11, 2016 https://discuss.leetcode.com/topic/2861/share-my-java-solution-with-explanation Share my java solution with explanation Since n may be a large number compared to the length of list. So we need to know the length of linked list.After that, move the list after the (l-n%l )th node to the front to finish the rotation. Ex: {1,2,3} k=2 Move the list after the 1st node to the front Ex: {1,2,3} k=5, In this case Move the list after (3-5%3=1)st node to the front. So the code has three parts. Get the length Move to the (l-n%l)th node 3)Do the rotation 12345678910111213141516171819public ListNode rotateRight(ListNode head, int n) &#123; if (head==null||head.next==null) return head; ListNode dummy=new ListNode(0); dummy.next=head; ListNode fast=dummy,slow=dummy; int i; for (i=0;fast.next!=null;i++)//Get the total length fast=fast.next; for (int j=i-n%i;j&gt;0;j--) //Get the i-n%i th node slow=slow.next; fast.next=dummy.next; //Do the rotation dummy.next=slow.next; slow.next=null; return dummy.next;&#125; https://discuss.leetcode.com/topic/26364/clean-java-solution-with-brief-explanation Clean Java Solution with Brief Explanation The basic idea is to link the tail of the list with the head, make it a cycle. Then count to the rotate point and cut it. 123456789101112131415161718192021if (head == null) return head; ListNode copyHead = head; int len = 1; while (copyHead.next != null) &#123; copyHead = copyHead.next; len++; &#125; copyHead.next = head; for (int i = len - k % len; i &gt; 1; i--) head = head.next; copyHead = head.next; head.next = null; return copyHead;&#125; https://discuss.leetcode.com/topic/10991/my-short-java-solution-with-comments My short java solution with comments 1234567891011121314151617public ListNode rotateRight(ListNode head, int k) &#123; if(head==null||head.next==null||k==0) return head; //make it a cricle, break from k postion far from the head ListNode index=head; int len=1;// int len to record the length of list while(index.next!=null) &#123;index=index.next; len++;&#125; index.next=head; for(int i=0;i&lt;len-k%len;i++) &#123; index=index.next; &#125; ListNode result=index.next; index.next=null; return result;&#125; https://discuss.leetcode.com/topic/42445/java-clean-solution-only-one-pointer-used Java clean solution, only one pointer used I first used a ListNode p, and point it to the head, then move it to the end of the list, and at the same time get the length of the list. Then p.next = head; gives me a circle. At this time, by moving p for len-k times, it will be pointing to the node before the break point. Then all we need to do is record the next node as head, and break the circle with p.next = null. 12345678910111213141516171819public ListNode rotateRight(ListNode head, int k) &#123; if(head == null || k == 0) &#123; return head; &#125; ListNode p = head; int len = 1; while(p.next != null) &#123; p = p.next; len++; &#125; p.next = head; k %= len; for(int i = 0; i &lt; len - k; i++) &#123; p = p.next; &#125; head = p.next; p.next = null; return head;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[060. Permutation Sequence]]></title>
    <url>%2Fp%2F7d81a399%2F</url>
    <content type="text"><![CDATA[28.6% https://leetcode.com/problems/permutation-sequence/ The set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, 12345678We get the following sequence (ie, for n = 3):1. &quot;123&quot;2. &quot;132&quot;3. &quot;213&quot;4. &quot;231&quot;5. &quot;312&quot;6. &quot;321&quot; Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. 需要再思考 cpp https://discuss.leetcode.com/topic/3313/most-concise-c-solution-minimal-memory-required Most concise C++ solution, minimal memory required 1234567891011121314151617181920string getPermutation(int n, int k) &#123; int i,j,f=1; // left part of s is partially formed permutation, right part is the leftover chars. string s(n,&apos;0&apos;); for(i=1;i&lt;=n;i++)&#123; f*=i; s[i-1]+=i; // make s become 1234...n &#125; for(i=0,k--;i&lt;n;i++)&#123; f/=n-i; j=i+k/f; // calculate index of char to put at s[i] char c=s[j]; // remove c by shifting to cover up (adjust the right part). for(;j&gt;i;j--) s[j]=s[j-1]; k%=f; s[i]=c; &#125; return s;&#125; https://discuss.leetcode.com/topic/7002/sharing-my-straightforward-c-solution-with-explanation Sharing my straightforward C++ solution with explanation 12345678910111213141516171819202122232425string getPermutation(int n, int k) &#123; int pTable[10] = &#123;1&#125;; for(int i = 1; i &lt;= 9; i++)&#123; pTable[i] = i * pTable[i - 1]; &#125; string result; vector&lt;char&gt; numSet; numSet.push_back(&apos;1&apos;); numSet.push_back(&apos;2&apos;); numSet.push_back(&apos;3&apos;); numSet.push_back(&apos;4&apos;); numSet.push_back(&apos;5&apos;); numSet.push_back(&apos;6&apos;); numSet.push_back(&apos;7&apos;); numSet.push_back(&apos;8&apos;); numSet.push_back(&apos;9&apos;); while(n &gt; 0)&#123; int temp = (k - 1) / pTable[n - 1]; result += numSet[temp]; numSet.erase(numSet.begin() + temp); k = k - temp * pTable[n - 1]; n--; &#125; return result;&#125; In this program, pTable refers to permutation table and numSet refers to a set of numbers from 1 to 9. Before while loop, we need to initialize pTable and numSet, which is trivial. In while loop, we do these following things. 1 calculate which number we will use. 2 remove that number from numSet. 3 recalculate k. 4 n–. Finally, we return result. https://discuss.leetcode.com/topic/19181/0ms-c-12-line-concise-solution-no-recursion-no-helper-function 0ms C++ 12-line concise solution (no recursion, no helper function) Attached please find my solution. Idea: For an n-element permutation, there are (n-1)! permutations started with ‘1’, (n-1)! permutations started with ‘2’, and so forth. Therefore we can determine the value of the first element. After determining the first element, there are (n-1) candidates left. Then there are (n-2)! permutations started with the minimum element within the remaining set, and so forth. Complexities: Time complexity: O(n^2) Space complexity: O(n) 123456789101112131415161718192021222324252627class Solution &#123;public: string getPermutation(int n, int k) &#123; // initialize a dictionary that stores 1, 2, ..., n. This string will store the permutation. string dict(n, 0); iota(dict.begin(), dict.end(), &apos;1&apos;); // build up a look-up table, which stores (n-1)!, (n-2)!, ..., 1!, 0! vector&lt;int&gt; fract(n, 1); for (int idx = n - 3; idx &gt;= 0; --idx) &#123; fract[idx] = fract[idx + 1] * (n - 1 - idx); &#125; // let k be zero base --k; // the main part. string ret(n, 0); for (int idx = 0; idx &lt; n; ++idx) &#123; int select = k / fract[idx]; k %= fract[idx]; ret[idx] = dict[select]; dict.erase(next(dict.begin(), select)); // note that it is an O(n) operation &#125; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/37865/simple-0s-c-solution Simple 0s C++ solution since n will be between 1 and 9 inclusive. pre-calculate the factorials is faster. 12345678910111213141516class Solution &#123;public: string getPermutation(int n, int k) &#123; string res; string nums = &quot;123456789&quot;; int f[10] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;; --k; for (int i = n; i &gt;= 1; --i) &#123; int j = k / f[i - 1]; k %= f[i - 1]; res.push_back(nums[j]); nums.erase(nums.begin() + j); &#125; return res; &#125;&#125;; python 44ms, 90.94%, 17 July 2016 https://discuss.leetcode.com/topic/19269/share-my-python-solution-with-detailed-explanation Share my Python solution with detailed explanation The idea is as follow: For permutations of n, the first (n-1)! permutations start with 1, next (n-1)! ones start with 2, … and so on. And in each group of (n-1)! permutations, the first (n-2)! permutations start with the smallest remaining number, … take n = 3 as an example, the first 2 (that is, (3-1)! ) permutations start with 1, next 2 start with 2 and last 2 start with 3. For the first 2 permutations (123 and 132), the 1st one (1!) starts with 2, which is the smallest remaining number (2 and 3). So we can use a loop to check the region that the sequence number falls in and get the starting digit. Then we adjust the sequence number and continue. 123456789101112131415161718import mathclass Solution: # @param &#123;integer&#125; n # @param &#123;integer&#125; k # @return &#123;string&#125; def getPermutation(self, n, k): numbers = range(1, n+1) permutation = &apos;&apos; k -= 1 while n &gt; 0: n -= 1 # get the index of current digit index, k = divmod(k, math.factorial(n)) permutation += str(numbers[index]) # remove handled number numbers.remove(numbers[index]) return permutation https://discuss.leetcode.com/topic/1746/does-anyone-have-a-better-idea-share-my-accepted-python-code-here Does anyone have a better idea? Share my accepted python code here It’s obvious that if we try to come up with n! solutions one by one until it reach kth element - O(k), it will exceed the time limit. Therefore, I tried to implement a mathematical solution as follows: 1234567891011121314151617181920212223242526272829class Solution: # @return a string def getPermutation(self, n, k): ll = [str(i) for i in range(1,n+1)] # build a list of [&quot;1&quot;,&quot;2&quot;,...&quot;n&quot;] divisor = 1 for i in range(1,n): # calculate 1*2*3*...*(n-1) divisor *= i answer = &quot;&quot; while k&gt;0 and k&lt;=divisor*n: # there are only (divisor*n) solutions in total group_num = k/divisor k %= divisor if k&gt;0: # it&apos;s kth element of (group_num+1)th group choose = ll.pop(group_num) answer += choose else: # it&apos;s last element of (group_num)th group choose = ll.pop(group_num-1) answer += choose ll.reverse() # reverse the list to get DESC order for the last element to_add = &quot;&quot;.join(ll) answer += to_add break divisor/=len(ll) return answer Briefly take (n,k) = (4,21) for example, in the first iteration we divide the solution set into 4 groups: “1xxx”, “2xxx”, “3xxx”, and “4xxx”, while each group has 3! = 6 members. From 21/6 = 3…3, we know that the 21th element is the 3rd element in the (3+1)th group. In this group, we can divide it into 3 sub-groups again: “41xx”, “42xx” and “43xx”, and each group has 2!=2 members. Then, we calculate 3/2 and get 1…1, so it’s the 1st element of (1+1)nd sub-group - “421x”, and now it reach the base case with only one possibility - “4213”. Anyone pass the problem with different ideas? java https://discuss.leetcode.com/topic/17348/explain-like-i-m-five-java-solution-in-o-n “Explain-like-I’m-five” Java Solution in O(n) I’m sure somewhere can be simplified so it’d be nice if anyone can let me know. The pattern was that: say n = 4, you have {1, 2, 3, 4} If you were to list out all the permutations you have 1 + (permutations of 2, 3, 4) 2 + (permutations of 1, 3, 4) 3 + (permutations of 1, 2, 4) 4 + (permutations of 1, 2, 3) We know how to calculate the number of permutations of n numbers… n! So each of those with permutations of 3 numbers means there are 6 possible permutations. Meaning there would be a total of 24 permutations in this particular one. So if you were to look for the (k = 14) 14th permutation, it would be in the 3 + (permutations of 1, 2, 4) subset. To programmatically get that, you take k = 13 (subtract 1 because of things always starting at 0) and divide that by the 6 we got from the factorial, which would give you the index of the number you want. In the array {1, 2, 3, 4}, k/(n-1)! = 13/(4-1)! = 13/3! = 13/6 = 2. The array {1, 2, 3, 4} has a value of 3 at index 2. So the first number is a 3. Then the problem repeats with less numbers. The permutations of {1, 2, 4} would be: 1 + (permutations of 2, 4) 2 + (permutations of 1, 4) 4 + (permutations of 1, 2) But our k is no longer the 14th, because in the previous step, we’ve already eliminated the 12 4-number permutations starting with 1 and 2. So you subtract 12 from k.. which gives you 1. Programmatically that would be… k = k - (index from previous) (n-1)! = k - 2(n-1)! = 13 - 2*(3)! = 1 In this second step, permutations of 2 numbers has only 2 possibilities, meaning each of the three permutations listed above a has two possibilities, giving a total of 6. We’re looking for the first one, so that would be in the 1 + (permutations of 2, 4) subset. Meaning: index to get number from is k / (n - 2)! = 1 / (4-2)! = 1 / 2! = 0.. from {1, 2, 4}, index 0 is 1 so the numbers we have so far is 3, 1… and then repeating without explanations. {2, 4} k = k - (index from pervious) (n-2)! = k - 0 (n - 2)! = 1 - 0 = 1; third number’s index = k / (n - 3)! = 1 / (4-3)! = 1/ 1! = 1… from {2, 4}, index 1 has 4 Third number is 4 {2} k = k - (index from pervious) (n - 3)! = k - 1 (4 - 3)! = 1 - 1 = 0; third number’s index = k / (n - 4)! = 0 / (4-4)! = 0/ 1 = 0… from {2}, index 0 has 2 Fourth number is 2 Giving us 3142. If you manually list out the permutations using DFS method, it would be 3142. Done! It really was all about pattern finding. 12345678910111213141516171819202122232425262728293031323334public class Solution &#123;public String getPermutation(int n, int k) &#123; int pos = 0; List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); int[] factorial = new int[n+1]; StringBuilder sb = new StringBuilder(); // create an array of factorial lookup int sum = 1; factorial[0] = 1; for(int i=1; i&lt;=n; i++)&#123; sum *= i; factorial[i] = sum; &#125; // factorial[] = &#123;1, 1, 2, 6, 24, ... n!&#125; // create a list of numbers to get indices for(int i=1; i&lt;=n; i++)&#123; numbers.add(i); &#125; // numbers = &#123;1, 2, 3, 4&#125; k--; for(int i = 1; i &lt;= n; i++)&#123; int index = k/factorial[n-i]; sb.append(String.valueOf(numbers.get(index))); numbers.remove(index); k-=index*factorial[n-i]; &#125; return String.valueOf(sb);&#125;&#125; 4ms, 3.65%, 17 July 2016 https://discuss.leetcode.com/topic/5081/an-iterative-solution-for-reference An iterative solution for reference Recursion will use more memory, while this problem can be solved by iteration. I solved this problem before, but I didn’t realize that using k = k-1 would avoid dealing with case k%(n-1)!==0. Rewrote this code, should be pretty concise now. Only thing is that I have to use a list to store the remaining numbers, neither linkedlist nor arraylist are very efficient, anyone has a better idea? The logic is as follows: for n numbers the permutations can be divided to (n-1)! groups, for n-1 numbers can be divided to (n-2)! groups, and so on. Thus k/(n-1)! indicates the index of current number, and k%(n-1)! denotes remaining index for the remaining n-1 numbers.We keep doing this until n reaches 0, then we get n numbers permutations that is kth. 12345678910111213141516public String getPermutation(int n, int k) &#123; List&lt;Integer&gt; num = new LinkedList&lt;Integer&gt;(); for (int i = 1; i &lt;= n; i++) num.add(i); int[] fact = new int[n]; // factorial fact[0] = 1; for (int i = 1; i &lt; n; i++) fact[i] = i*fact[i-1]; k = k-1; StringBuilder sb = new StringBuilder(); for (int i = n; i &gt; 0; i--)&#123; int ind = k/fact[i-1]; k = k%fact[i-1]; sb.append(num.get(ind)); num.remove(ind); &#125; return sb.toString(); &#125; https://discuss.leetcode.com/topic/5081/an-iterative-solution-for-reference/2 Thanks for your post and explanation. I think linkedlist is as efficient as you can get in order to store the remaining numbers. Linkedlist may require counting index to get to the number, but it is more efficient than an array for removing elements. I haven’t seen a better solution yet. We can reduce the memory usage for factorial a little by using just one integer, since we are going down in factorial anyway. I think you meant “permutations can be divided into n groups with (n - 1)! elements in each group”. Thus, k / (n - 1)! is the index among current n groups, and k % (n - 1)! is the index for next iteration. 123456789101112131415public String getPermutation(int n, int k) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int i = 1; i &lt;= n; i++) list.add(i); int fact = 1; for (int i = 2; i &lt;= n; i++) fact *= i; // factorial StringBuilder strBuilder = new StringBuilder(); for (k--; n &gt; 0; n--) &#123; fact /= n; strBuilder.append(list.remove(k / fact)); k %= fact; &#125; return strBuilder.toString();&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[059. Spiral Matrix II]]></title>
    <url>%2Fp%2F3551638a%2F</url>
    <content type="text"><![CDATA[38.4% https://leetcode.com/problems/spiral-matrix-ii/ Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. 123456789For example,Given n = 3,You should return the following matrix:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 方法一: 借鉴54题的思想，类似的代码 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; if(n==0) return &#123;&#125;; if(n==1) return &#123;&#123;1&#125;&#125;; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n)); int i=1, up=0, down=n-1, left=0, right=n-1; while(true)&#123; for(int col=left; col&lt;=right; col++) res[up][col] = i++; if(++up&gt;down) break; for(int row=up; row&lt;=down; row++) res[row][right] = i++; if(--right&lt;left) break; for(int col=right; col&gt;=left; col--) res[down][col] = i++; if(--down&lt;up) break; for(int row=down; row&gt;=up; row--) res[row][left] = i++; if(++left&gt;right) break; &#125; return res; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; int cnt = 0; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); int left = 0, right = n-1, up = 0, down = n-1; while(true)&#123; for(int i=left; i&lt;=right; i++) res[up][i] = ++cnt; up++; if(up&gt;down) break; for(int j=up; j&lt;=down; j++) res[j][right] = ++cnt; right--; if(left&gt;right) break; for(int k=right; k&gt;=left; k--) res[down][k] = ++cnt; down--; if(up&gt;down) break; for(int l=down; l&gt;=up; l--) res[l][left] = ++cnt; left++; if(left&gt;right) break; &#125; return res; &#125;&#125;; cpp 4ms, 13.71%, June.19th, 2016 https://leetcode.com/discuss/21677/simple-c-solution-with-explaination 12345678910111213141516171819202122232425class Solution &#123; public: vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt; &gt; ret( n, vector&lt;int&gt;(n) ); int k = 1, i = 0; while( k &lt;= n * n ) &#123; int j = i; // four steps while( j &lt; n - i ) // 1. horizonal, left to right ret[i][j++] = k++; j = i + 1; while( j &lt; n - i ) // 2. vertical, top to bottom ret[j++][n-i-1] = k++; j = n - i - 2; while( j &gt; i ) // 3. horizonal, right to left ret[n-i-1][j--] = k++; j = n - i - 1; while( j &gt; i ) // 4. vertical, bottom to top ret[j--][i] = k++; i++; // next loop &#125; return ret; &#125; &#125;; 方法二： 修改判断条件在while条件里，不必每次都去判断是否跳出循环 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; int cnt = 0; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); int left = 0, right = n-1, up = 0, down = n-1; while(up&lt;=down &amp;&amp; left&lt;=right)&#123; for(int i=left; i&lt;=right; i++) res[up][i] = ++cnt; up++; for(int j=up; j&lt;=down; j++) res[j][right] = ++cnt; right--; for(int k=right; k&gt;=left; k--) res[down][k] = ++cnt; down--; for(int l=down; l&gt;=up; l--) res[l][left] = ++cnt; left++; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/2736/my-ac-solution-with-using-direction-variable My AC solution with using direction variable 12345678910111213141516171819202122232425vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) &#123; int dir = 0; vector&lt; vector&lt;int&gt; &gt; matrix(n, vector&lt;int&gt; (n, 0)); int i = 0, j = 0, k = 1; while (k &lt;= n * n) &#123; matrix[i][j] = k++; if (dir == 0)&#123; j++; if (j == n || matrix[i][j] != 0) dir = 1, j--, i++; &#125; else if (dir == 1) &#123; i++; if (i == n || matrix[i][j] != 0) dir = 2, i--, j--; &#125; else if (dir == 2) &#123; j--; if (j &lt; 0 || matrix[i][j] != 0) dir = 3, j++, i--; &#125; else if (dir == 3) &#123; i--; if (i &lt; 0 || matrix[i][j] != 0) dir = 0, i++, j++; &#125; &#125; return matrix; &#125; https://discuss.leetcode.com/topic/11317/simple-c-solution Simple C++ solution 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt; &gt; vv(n, vector&lt;int&gt;(n)); int rowStart = 0, rowEnd = n - 1; int colStart = 0, colEnd = n - 1; int cnt = 1; while(rowStart &lt;= rowEnd &amp;&amp; colStart &lt;= colEnd) &#123; for(int i = colStart; i&lt;= colEnd; i++) vv[rowStart][i] = cnt++; rowStart++; for(int i = rowStart; i&lt;= rowEnd; i++) vv[i][colEnd] = cnt++; colEnd--; for(int i = colEnd; i&gt;= colStart; i--) vv[rowEnd][i] = cnt++; rowEnd--; for(int i = rowEnd; i&gt;= rowStart; i--) vv[i][colStart] = cnt++; colStart++; &#125; return vv; &#125;&#125;; https://discuss.leetcode.com/topic/30057/c-concise-solution C++ concise solution. 1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt; (n, 1)); int left, right, top, down, index; left = top = index = 0, right = down = n-1; while (left &lt;= right &amp;&amp; top &lt;= down) &#123; for (unsigned int j = left; j &lt;= right; j++) res[top][j] = ++index; top++; for (unsigned int i = top; i &lt;= down; i++) res[i][right] = ++index; right--; for (int j = right; j &gt;= left; j--) res[down][j] = ++index; down--; for (int i = down; i &gt;= top; i--) res[i][left] = ++index; left++; &#125; return res;&#125; python 56ms, 49.97%, June.19th, 2016 https://leetcode.com/discuss/46720/4-9-lines-python-solutions 4-9 lines Python solutions Solution 1: Build it inside-out - 44 ms, 5 lines Start with the empty matrix, add the numbers in reverse order until we added the number 1. Always rotate the matrix clockwise and add a top row: 123|| =&gt; |9| =&gt; |8| |6 7| |4 5| |1 2 3| |9| =&gt; |9 8| =&gt; |9 6| =&gt; |8 9 4| |8 7| |7 6 5| The code: 123456def generateMatrix(self, n): A, lo = [], n*n+1 while lo &gt; 1: lo, hi = lo - len(A), lo A = [range(lo, hi)] + zip(*A[::-1]) return A While this isn’t O(n^2), it’s actually quite fast, presumably due to me not doing much in Python but relying on zip and range and + being fast. I got it accepted in 44 ms, matching the fastest time for recent Python submissions (according to the submission detail page). Solution 2: Ugly inside-out - 48 ms, 4 lines Same as solution 1, but without helper variables. Saves a line, but makes it ugly. Also, because I access A[0][0], I had to handle the n=0 case differently. 12345def generateMatrix(self, n): A = [[n*n]] while A[0][0] &gt; 1: A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1]) return A * (n&gt;0) Solution 3: Walk the spiral - 52 ms, 9 lines Initialize the matrix with zeros, then walk the spiral path and write the numbers 1 to n*n. Make a right turn when the cell ahead is already non-zero. 12345678910def generateMatrix(self, n): A = [[0] * n for _ in range(n)] i, j, di, dj = 0, 0, 0, 1 for k in xrange(n*n): A[i][j] = k + 1 if A[(i+di)%n][(j+dj)%n]: di, dj = dj, -di i += di j += dj return A https://discuss.leetcode.com/topic/7739/if-we-can-t-write-data-to-the-matrix-we-change-the-direction-a-simple-python-solution If we can’t write data to the matrix, we change the direction,a simple python solution 1234567891011121314151617class Solution:# @return a list of lists of integerdef generateMatrix(self, n): matrix = [[0]*n for _ in range(n)] directions = ((0, 1), (1, 0), (0, -1), (-1, 0)) d = 0 y, x = 0, 0 for i in range(1, n*n+1): matrix[y][x] = i dy, dx = directions[d % 4] if -1 &lt; y+dy &lt; n and -1 &lt; x+dx &lt; n and matrix[y+dy][x+dx] == 0: y, x = y+dy, x+dx else: d += 1 dy, dx = directions[d % 4] y, x = y+dy, x+dx return matrix Change the direction If the we can’t write to the matrix java https://discuss.leetcode.com/topic/4362/my-super-simple-solution-can-be-used-for-both-spiral-matrix-i-and-ii My Super Simple Solution. Can be used for both Spiral Matrix I and II This is my solution for Spiral Matrix I, https://oj.leetcode.com/discuss/12228/super-simple-and-easy-to-understand-solution. If you can understand that, this one is a no brainer :) Guess what? I just made several lines of change (with comment “//change”) from that and I have the following AC code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public int[][] generateMatrix(int n) &#123; // Declaration int[][] matrix = new int[n][n]; // Edge Case if (n == 0) &#123; return matrix; &#125; // Normal Case int rowStart = 0; int rowEnd = n-1; int colStart = 0; int colEnd = n-1; int num = 1; //change while (rowStart &lt;= rowEnd &amp;&amp; colStart &lt;= colEnd) &#123; for (int i = colStart; i &lt;= colEnd; i ++) &#123; matrix[rowStart][i] = num ++; //change &#125; rowStart ++; for (int i = rowStart; i &lt;= rowEnd; i ++) &#123; matrix[i][colEnd] = num ++; //change &#125; colEnd --; for (int i = colEnd; i &gt;= colStart; i --) &#123; if (rowStart &lt;= rowEnd) matrix[rowEnd][i] = num ++; //change &#125; rowEnd --; for (int i = rowEnd; i &gt;= rowStart; i --) &#123; if (colStart &lt;= colEnd) matrix[i][colStart] = num ++; //change &#125; colStart ++; &#125; return matrix; &#125;&#125; Obviously, you could merge colStart and colEnd into rowStart and rowEnd because it is a square matrix. But this is easily extensible to matrices that are m*n. Hope this helps :) 0ms, 17.235, June.19th, 2016 https://leetcode.com/discuss/38659/share-my-java-solution Share my java solution 123456789101112131415161718192021222324252627public class Solution &#123; public static int[][] generateMatrix(int n) &#123; int[][] ret = new int[n][n]; int left = 0,top = 0; int right = n -1,down = n - 1; int count = 1; while (left &lt;= right) &#123; for (int j = left; j &lt;= right; j ++) &#123; ret[top][j] = count++; &#125; top ++; for (int i = top; i &lt;= down; i ++) &#123; ret[i][right] = count ++; &#125; right --; for (int j = right; j &gt;= left; j --) &#123; ret[down][j] = count ++; &#125; down --; for (int i = down; i &gt;= top; i --) &#123; ret[i][left] = count ++; &#125; left ++; &#125; return ret; &#125;&#125; https://discuss.leetcode.com/topic/9299/share-my-simple-solution-with-graphical-explanation-java Share my simple solution with graphical explanation - Java If n is odd, only the first direction will cover it (top left -&gt; right, shown as # in the graph), because the other three direction all start from the next position( +1 or -1). 1234567891011121314151617181920212223242526272829303132333435363738/** * -&gt; -&gt; -&gt; * ^ | * | | * &lt;- &lt;-- V * * # # # # * % $ * % $ * &amp; &amp; &amp; $ * */ public static int[][] generateMatrix(int n) &#123; int[][] res = new int[n][n]; int num = 1; int level = (int) Math.ceil(n / 2.); for(int i = 0; i &lt; level; i++) &#123; // top left -&gt; right, shown as # for(int j = i; j &lt; n - i; j++) res[i][j] = num++; // top right + 1 -&gt; bot, shown as $ for(int j = i + 1; j &lt; n - i; j++) res[j][n - i - 1] = num++; // bot right - 1 -&gt; left, shown as &amp; for(int j = n - i - 2; j &gt;= i; j--) res[n - i - 1][j] = num++; // bot left -1 -&gt; top + 1, shown as % for(int j = n - i - 2; j &gt; i; j--) res[j][i] = num++; &#125; return res; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[058. Length of Last Word]]></title>
    <url>%2Fp%2Fe32fb410%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/length-of-last-word/ Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. 123For example, Given s = &quot;Hello World&quot;,return 5. 方法一： code 1： 核心思想，从后向前遍历，从后遍历，这个想法很好。 很多时候从前向后可能有一定的麻烦，但是从后向前的遍历， 会收到很好的效果。 或许这就是所谓的逆向思维吧。 https://discuss.leetcode.com/topic/17312/7-lines-4ms-c-solution 7-lines 4ms C++ Solution Well, the basic idea is very simple. Start from the tail of s and move backwards to find the first non-space character. Then from this character, move backwards and count the number of non-space characters until we pass over the head of s or meet a space character. The count will then be the length of the last word. 123456789101112class Solution &#123;public: int lengthOfLastWord(string s) &#123; int len = 0, tail = s.length() - 1; while (tail &gt;= 0 &amp;&amp; s[tail] == &apos; &apos;) tail--; while (tail &gt;= 0 &amp;&amp; s[tail] != &apos; &apos;) &#123; len++; tail--; &#125; return len; &#125;&#125;; code 2: 12345678910111213141516class Solution &#123;public: int lengthOfLastWord(string s) &#123; if(s.empty()) return 0; int n = s.size(); int len = 0; int tail = n-1; while(tail&gt;=0 &amp;&amp; s[tail]==&apos; &apos;) tail--; while(tail&gt;=0 &amp;&amp; s[tail]!=&apos; &apos;)&#123; len++; tail--; &#125; return len; &#125;&#125;; python Solution mine: 40ms, 88.34%, June.23th, 2016 1234567class Solution(object): def lengthOfLastWord(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; return len(s.strip().split(&apos; &apos;)[-1]) https://discuss.leetcode.com/topic/7733/one-line-python-solution One line Python solution12def lengthOfLastWord(self, s): return len(s.rstrip(&apos; &apos;).split(&apos; &apos;)[-1]) java 1ms, 41.25%, June.23th, 2016 https://leetcode.com/discuss/18670/a-single-line-of-code-in-java A single line of Code in Java12345public class Solution &#123; public int lengthOfLastWord(String s) &#123; return s.trim().length()-s.trim().lastIndexOf(&quot; &quot;)-1; &#125;&#125; https://discuss.leetcode.com/topic/27201/my-3-line-0-ms-java-solution My 3 line 0 ms java solution12345public int lengthOfLastWord(String s) &#123; s = s.trim(); int lastIndex = s.lastIndexOf(&apos; &apos;) + 1; return s.length() - lastIndex; &#125; https://discuss.leetcode.com/topic/17762/228ms-java-solution 228ms Java Solution 1 - Use 2 loops. One to locate the last non-space character, one to count. 123456789101112131415161718public int lengthOfLastWord(String s) &#123; //228ms int lenIndex = s.length()-1; int len = 0; /*can also use while here, resulting in 264ms while (lenIndex&gt;=0 &amp;&amp; s.charAt(lenIndex)==&apos; &apos;) lenIndex--;*/ /*or use trim - 324ms s = s.trim();*/ for (int i=lenIndex; i&gt;=0 &amp;&amp; s.charAt(i)==&apos; &apos;; i--) lenIndex--; for (int i=lenIndex; i&gt;=0 &amp;&amp; s.charAt(i)!=&apos; &apos;; i--) len++; return len;&#125; 2 - Use split 1234//292ms String[] words = s.split(&quot; &quot;); if (words.length==0) return 0; else return words[words.length-1].length(); 3 - use lastIndexOf 12//308ms return s.trim().length() - s.trim().lastIndexOf(&quot; &quot;) - 1;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[057. Insert Interval]]></title>
    <url>%2Fp%2F65f5c34%2F</url>
    <content type="text"><![CDATA[26.7% https://leetcode.com/problems/insert-interval/ Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. 1234567Example 1:Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].Example 2:Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10]. 方法一： 头条代码 Easy and clean O(n) C++ solution Very easy to understand code as follows. First, put all intervals that are to the left of the inserted interval. Second, merge all intervals that intersect with the inserted interval. Finally, put all intervals that are to the right of the inserted interval. That’s it! You are done! 重点答案，简单直白高效 一个启示，未必只用一个while/for循环，可以前一段一个while，中间一个while，后面一个while，这样分开讨论的情况，很简洁，思路畅通。 针对相遇的情况，更改了newInterval的值，始终保持start最小，end最大，最后加入到结果中。 1234567891011121314151617181920class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int index = 0; while(index &lt; intervals.size() &amp;&amp; intervals[index].end &lt; newInterval.start)&#123; res.push_back(intervals[index++]); &#125; while(index &lt; intervals.size() &amp;&amp; intervals[index].start &lt;= newInterval.end)&#123; newInterval.start = min(newInterval.start, intervals[index].start); newInterval.end = max(newInterval.end, intervals[index].end); index++; &#125; res.push_back(newInterval); while(index &lt; intervals.size())&#123; res.push_back(intervals[index++]); &#125; return res; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; int n = intervals.size(); vector&lt;Interval&gt; res; int i = 0; while(i&lt;n &amp;&amp; intervals[i].end&lt;newInterval.start) res.push_back(intervals[i++]); while(i&lt;n &amp;&amp; intervals[i].start&lt;=newInterval.end)&#123; newInterval.start = min(newInterval.start, intervals[i].start); newInterval.end = max(newInterval.end, intervals[i].end); i++; &#125; res.push_back(newInterval); while(i&lt;n) res.push_back(intervals[i++]); return res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/12899/very-short-and-easy-to-understand-c-solution Very short and easy to understand C++ solution 12345678910111213141516171819vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; ret; auto it = intervals.begin(); for(; it!=intervals.end(); ++it)&#123; if(newInterval.end &lt; (*it).start) //all intervals after will not overlap with the newInterval break; else if(newInterval.start &gt; (*it).end) //*it will not overlap with the newInterval ret.push_back(*it); else&#123; //update newInterval bacause *it overlap with the newInterval newInterval.start = min(newInterval.start, (*it).start); newInterval.end = max(newInterval.end, (*it).end); &#125; &#125; // don&apos;t forget the rest of the intervals and the newInterval ret.push_back(newInterval); for(; it!=intervals.end(); ++it) ret.push_back(*it); return ret;&#125; My question is why this code need 500ms !? https://discuss.leetcode.com/topic/28015/elegant-c-stl-solution-using-equal_range-to-find-overlapped-intervals Elegant C++ STL solution, using “equal_range” to find overlapped intervals. 123456789101112131415161718class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; auto compare = [] (const Interval &amp;intv1, const Interval &amp;intv2) &#123; return intv1.end &lt; intv2.start; &#125;; auto range = equal_range(intervals.begin(), intervals.end(), newInterval, compare); auto itr1 = range.first, itr2 = range.second; if (itr1 == itr2) &#123; intervals.insert(itr1, newInterval); &#125; else &#123; itr2--; itr2-&gt;start = min(newInterval.start, itr1-&gt;start); itr2-&gt;end = max(newInterval.end, itr2-&gt;end); intervals.erase(itr1, itr2); &#125; return intervals; &#125;&#125;; https://discuss.leetcode.com/topic/24439/easy-and-clean-o-n-c-solution Easy and clean O(n) C++ solution Very easy to understand code as follows. First, put all intervals that are to the left of the inserted interval. Second, merge all intervals that intersect with the inserted interval. Finally, put all intervals that are to the right of the inserted interval. That’s it! You are done! 重点答案，简单直白高效 一个启示，未必只用一个while/for循环，可以前一段一个while，中间一个while，后面一个while，这样分开讨论的情况，很简洁，思路畅通。 针对相遇的情况，更改了newInterval的值，始终保持start最小，end最大，最后加入到结果中。 1234567891011121314151617181920class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int index = 0; while(index &lt; intervals.size() &amp;&amp; intervals[index].end &lt; newInterval.start)&#123; res.push_back(intervals[index++]); &#125; while(index &lt; intervals.size() &amp;&amp; intervals[index].start &lt;= newInterval.end)&#123; newInterval.start = min(newInterval.start, intervals[index].start); newInterval.end = max(newInterval.end, intervals[index].end); index++; &#125; res.push_back(newInterval); while(index &lt; intervals.size())&#123; res.push_back(intervals[index++]); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/17937/two-easy-o-n-c-solutions-with-explanations Two Easy O(n) C++ Solutions with Explanations By far the best solution I have seen is of O(n) time (some solutions claim to be of O(logn) turns out to be O(n)). One of the simplest ideas is to compare each interval in intervals (intervals[i]) with newInterval and then perform respective operations according to their relationships. If they overlap, merge them to newInterval; If intervals[i] is to the left of newInterval, push intervals[i] to the result vector; If newInterval is to the left of intervals[i], push newInterval and all the remaining intervals (intervals[i], …, intervals[n - 1]) to the result vector. The code is as follows. 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int n = intervals.size(); for (int i = 0; i &lt; n; i++) &#123; if (intervals[i].end &lt; newInterval.start) res.push_back(intervals[i]); else if (newInterval.end &lt; intervals[i].start) &#123; res.push_back(newInterval); for (int j = i; j &lt; n; j++) res.push_back(intervals[j]); return res; &#125; else newInterval = merge(intervals[i], newInterval); &#125; res.push_back(newInterval); return res; &#125;private: Interval merge(Interval&amp; interval1, Interval&amp; interval2) &#123; int start = min(interval1.start, interval2.start); int end = max(interval1.end, interval2.end); return Interval(start, end); &#125;&#125;; Another idea is to search for the two ends of the overlapping intervals using binary search. Then we only need to merge newInterval with the intervals at the two ends if they overlap. All the intervals within the two ends will be contained innewInterval. Let’s do the example in the problem statement: intervals = [1, 2], [3, 5], [6, 7], [8, 10], [12, 16] and newInterval = [4, 9]. We first find the rightmost interval with start smaller than that of newInterval, which is [3, 5]. Then we find the leftmost interval with end larger than that of newInterval, which is [8, 10]. Then all the intervals between them will be contained within newInterval (you may check this to convince yourself) and so can be safely ignored. We only need to check whether newInterval overlaps with the two intervals on the two ends and merge them if necessary. The complete code is as follows. 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; int n = intervals.size(), leftEnd, rightEnd, l, r; vector&lt;Interval&gt; res; // Find the rightmost interval with start smaller than that of newInterval for (l = 0, r = n - 1; l &lt;= r; ) &#123; int mid = l + ((r - l) &gt;&gt; 1); if (intervals[mid].start &gt; newInterval.start) r = mid - 1; else l = mid + 1; &#125; leftEnd = r; // Find the leftmost interval with end larger than that of newInterval for (l = 0, r = n - 1; l &lt;= r; ) &#123; int mid = l + ((r - l) &gt;&gt; 1); if (intervals[mid].end &lt; newInterval.end) l = mid + 1; else r = mid - 1; &#125; rightEnd = l; // Merge newInterval with intervals[leftEnd] and intervals[rightEnd] if necessary if (leftEnd &gt;= 0 &amp;&amp; intervals[leftEnd].end &gt;= newInterval.start) newInterval.start = intervals[leftEnd--].start; if (rightEnd &lt; n &amp;&amp; intervals[rightEnd].start &lt;= newInterval.end) newInterval.end = intervals[rightEnd++].end; // Save the intervals sequentially for (int i = 0; i &lt;= leftEnd; i++) res.push_back(intervals[i]); res.push_back(newInterval); for (int i = rightEnd; i &lt; n; i++) res.push_back(intervals[i]); return res; &#125;&#125;; python https://discuss.leetcode.com/topic/16988/7-lines-3-easy-solutions 7+ lines, 3 easy solutions Solution 1: (7 lines, 88 ms) Collect the intervals strictly left or right of the new interval, then merge the new one with the middle ones (if any) before inserting it between left and right ones. 12345678def insert(self, intervals, newInterval): s, e = newInterval.start, newInterval.end left = [i for i in intervals if i.end &lt; s] right = [i for i in intervals if i.start &gt; e] if left + right != intervals: s = min(s, intervals[len(left)].start) e = max(e, intervals[~len(right)].end) return left + [Interval(s, e)] + right Solution 2: (8 lines, 84 ms) Same algorithm as solution 1, but different implementation with only one pass and explicitly collecting the to-be-merged intervals. 123456789def insert(self, intervals, newInterval): s, e = newInterval.start, newInterval.end parts = merge, left, right = [], [], [] for i in intervals: parts[(i.end &lt; s) - (i.start &gt; e)].append(i) if merge: s = min(s, merge[0].start) e = max(e, merge[-1].end) return left + [Interval(s, e)] + right Solution 3: (11 lines, 80 ms) Same again, but collect and merge while going over the intervals once. 123456789101112def insert(self, intervals, newInterval): s, e = newInterval.start, newInterval.end left, right = [], [] for i in intervals: if i.end &lt; s: left += i, elif i.start &gt; e: right += i, else: s = min(s, i.start) e = max(e, i.end) return left + [Interval(s, e)] + right https://discuss.leetcode.com/topic/6976/o-n-python-solution O(n) Python solution 123456789101112131415161718192021class Solution: # @param intervals, a list of Intervals # @param newInterval, a Interval # @return a list of Interval def insert(self, intervals, newInterval): start = newInterval.start end = newInterval.end result = [] i = 0 while i &lt; len(intervals): if start &lt;= intervals[i].end: if end &lt; intervals[i].start: break start = min(start, intervals[i].start) end = max(end, intervals[i].end) else: result.append(intervals[i]) i += 1 result.append(Interval(start, end)) result += intervals[i:] return result 112ms, 19.91%, June.23th, 2016 123456789101112131415161718192021# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def insert(self, intervals, newInterval): &quot;&quot;&quot; :type intervals: List[Interval] :type newInterval: Interval :rtype: List[Interval] &quot;&quot;&quot; intervals.append(newInterval) rtype = [] for i in sorted(intervals, key = lambda x:x.start): if rtype and i.start &lt;= rtype[-1].end: rtype[-1].end = max(rtype[-1].end, i.end) else: rtype += i, return rtype java https://discuss.leetcode.com/topic/7808/short-and-straight-forward-java-solution Short and straight-forward Java solution Hi guys! Here’s a pretty straight-forward and concise solution below. 这个直白的解法，很喜欢，先针对intervals比较小的，未接触处理，然后进行中间相遇的处理，然后处理相遇后的。很直白，很简单。 123456789101112131415161718public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new LinkedList&lt;&gt;(); int i = 0; // add all the intervals ending before newInterval starts while (i &lt; intervals.size() &amp;&amp; intervals.get(i).end &lt; newInterval.start) result.add(intervals.get(i++)); // merge all overlapping intervals to one considering newInterval while (i &lt; intervals.size() &amp;&amp; intervals.get(i).start &lt;= newInterval.end) &#123; newInterval = new Interval( // we could mutate newInterval here also Math.min(newInterval.start, intervals.get(i).start), Math.max(newInterval.end, intervals.get(i).end)); i++; &#125; result.add(newInterval); // add the union of intervals we got // add all the rest while (i &lt; intervals.size()) result.add(intervals.get(i++)); return result;&#125; Hope it helps. https://discuss.leetcode.com/topic/12691/short-java-code Short java code 123456789101112131415161718public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new ArrayList&lt;Interval&gt;(); for (Interval i : intervals) &#123; if (newInterval == null || i.end &lt; newInterval.start) result.add(i); else if (i.start &gt; newInterval.end) &#123; result.add(newInterval); result.add(i); newInterval = null; &#125; else &#123; newInterval.start = Math.min(newInterval.start, i.start); newInterval.end = Math.max(newInterval.end, i.end); &#125; &#125; if (newInterval != null) result.add(newInterval); return result;&#125; https://discuss.leetcode.com/topic/41004/my-binary-search-approach-implementation-2ms My Binary Search Approach Implementation, 2ms I know this is a little messy. For clean and simple code, please use the O(n) approach. We have great answer here with just 3 while loops. The BS approach utilizes the ordered characteristic of the input. For me, I want to get the position of the interval that is the first to have start equal to or larger than the inserted interval’s start. Similarly, I get the position of the interval that is the first to have end equal to or larger than the new interval’s end. Then I can get the range of intervals that the new interval connects. There are some corner cases that need to be considered, i.e. when the new interval has no overlap with any of the existing intervals (smaller, larger, or the original list is empty). In these corner cases, we just don’t need to update the new interval. The code could possibly be cleaner and simpler without sacrificing the speed, or even with less time and space. Please let me know if you have any suggestions. Thank you! 123456789101112131415161718192021222324252627282930313233343536373839404142public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); if (intervals == null || newInterval == null) return result; int iStart = findStartPos(intervals, newInterval.start); int iEnd = findEndPos(intervals, newInterval.end); if (iStart &gt; 0 &amp;&amp; intervals.get(iStart - 1).end &gt;= newInterval.start) iStart--; if (iEnd == intervals.size() || intervals.get(iEnd).start &gt; newInterval.end) iEnd--; //If not in the corner cases, this condition should apply. if (iStart &lt;= iEnd) &#123; newInterval = new Interval(Math.min(newInterval.start, intervals.get(iStart).start),Math.max(newInterval.end, intervals.get(iEnd).end)); &#125; int i = 0; while (i &lt; iStart) result.add(intervals.get(i++)); result.add(newInterval); i = iEnd + 1; while (i &lt; intervals.size()) result.add(intervals.get(i++)); return result;&#125;private int findStartPos(List&lt;Interval&gt; intervals, int value) &#123; int l = 0, r = intervals.size() - 1; while (l &lt;= r) &#123; int m = (l + r) &gt;&gt; 1; if (intervals.get(m).start == value) return m; else if (intervals.get(m).start &lt; value) l = m + 1; else r = m - 1; &#125; return l;&#125;private int findEndPos(List&lt;Interval&gt; intervals, int value) &#123; int l = 0, r = intervals.size() - 1; while (l &lt;= r) &#123; int m = (l + r) &gt;&gt; 1; if (intervals.get(m).end == value) return m; else if (intervals.get(m).end &lt; value) l = m + 1; else r = m - 1; &#125; return l;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hard</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[056. Merge Intervals]]></title>
    <url>%2Fp%2F5eec50bd%2F</url>
    <content type="text"><![CDATA[28.9% https://leetcode.com/problems/merge-intervals/ Given a collection of intervals, merge all overlapping intervals. 123For example,Given [1,3],[2,6],[8,10],[15,18],return [1,6],[8,10],[15,18]. 方法一： 先排序，再一个个的处理。 重点学习： sort函数的用法 vector的back函数 max函数的用法 123456789101112131415class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; ins) &#123; if (ins.empty()) return vector&lt;Interval&gt;&#123;&#125;; vector&lt;Interval&gt; res; sort(ins.begin(), ins.end(), [](Interval a, Interval b)&#123;return a.start &lt; b.start;&#125;); res.push_back(ins[0]); for (int i = 1; i &lt; ins.size(); i++) &#123; if (res.back().end &lt; ins[i].start) res.push_back(ins[i]); else res.back().end = max(res.back().end, ins[i].end); &#125; return res; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324252627/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; int n = intervals.size(); if(n&lt;=1) return intervals; vector&lt;Interval&gt; res; sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;return a.start&lt;b.start;&#125;); res.push_back(intervals[0]); for(int i=1; i&lt;n; i++)&#123; if(intervals[i].start &gt; res.back().end)&#123; res.push_back(intervals[i]); &#125;else&#123; res.back().end = max(res.back().end, intervals[i].end); &#125; &#125; return res; &#125;&#125;; 我的代码实现: Dec 10th, 2017 1234567891011121314151617181920class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; vector&lt;Interval&gt; res; if(intervals.size()&lt;=1) return intervals; sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;if(a.start&lt;b.start || (a.start==b.start) &amp;&amp; a.end&lt;b.end) return true; return false;&#125;); int s=intervals[0].start, e = intervals[0].end; for(int i=1; i&lt;intervals.size(); i++)&#123; if(e&lt;intervals[i].start)&#123; res.push_back(Interval(s, e)); s = intervals[i].start; e = intervals[i].end; &#125;else&#123; e = max(e, intervals[i].end); &#125; &#125; res.push_back(Interval(s, e)); return res; &#125;&#125;; cpp 20ms, 28.53%, June.22th, 2016 https://leetcode.com/discuss/49276/c-10-line-solution-easing-understanding C++ 10 line solution. easing understanding 先排序，然后开始开始遍历。 重点在于排序怎么写。 关于sort函数的用法，可以参考以下链接 http://www.cplusplus.com/reference/algorithm/sort/ http://www.cplusplus.com/articles/NhA0RXSz/ 123456789101112131415161718192021222324/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; ins) &#123; if (ins.empty()) return vector&lt;Interval&gt;&#123;&#125;; vector&lt;Interval&gt; res; sort(ins.begin(), ins.end(), [](Interval a, Interval b)&#123;return a.start &lt; b.start;&#125;); res.push_back(ins[0]); for (int i = 1; i &lt; ins.size(); i++) &#123; if (res.back().end &lt; ins[i].start) res.push_back(ins[i]); else res.back().end = max(res.back().end, ins[i].end); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/5765/my-easy-c-solution My easy C++ solution 12345678910111213141516171819202122static bool comp(const Interval&amp; a, const Interval&amp; b)&#123; return a.start &lt; b.start;&#125;vector&lt;Interval&gt; merge(vector&lt;Interval&gt; &amp;intervals) &#123; vector&lt;Interval&gt; result; if(intervals.empty())&#123; return result; &#125; sort(intervals.begin(), intervals.end(), comp); result.push_back(intervals[0]); for(int i = 1; i &lt; intervals.size(); i++)&#123; if(intervals[i].start &lt;= result.back().end)&#123; Interval temp(result.back().start, max(result.back().end, intervals[i].end)); result.pop_back(); result.push_back(temp); &#125; else&#123; result.push_back(intervals[i]); &#125; &#125; return result;&#125; https://discuss.leetcode.com/topic/20628/my-c-o-nlogn-solution-580ms My C++ O(NlogN) solution 580ms Just copy the input to res and do sorting (in ascending order of start). Then try to merge the sorted interval: cur is the last processed interval and i is the current to-be-processed interval. if cur is ahead of i and no overlapping, just copy i to cur+1, and update cur to cur+1, otherwise, merge interval cur and i and move to i+1. At last, we need to resize res to remove the redundent intervals. 12345678910111213141516class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; int len = intervals.size(),i,cur; vector&lt;Interval&gt; res(intervals); if(len&gt;1) &#123; std::sort(res.begin(), res.end(), [](Interval i, Interval j)&#123;return i.start&lt;j.start;&#125;); for(cur=0, i=1;i&lt;len; ++i) if(res[cur].end&lt;res[i].start) res[++cur] = res[i]; // no overlapping, copy to cur+1, else res[cur].end = max(res[cur].end, res[i].end); // cur and i overlap with each other, merge res.resize(cur+1); // resize to remove redundant intervals &#125; return res; &#125;&#125;; python 88ms, 81.79%, June.22th, 2016 https://leetcode.com/discuss/42344/7-lines-easy-python 7 lines, easy, Python Just go through the intervals sorted by start coordinate and either combine the current interval with the previous one if they overlap, or add it to the output by itself if they don’t. 12345678910111213141516171819# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def merge(self, intervals): &quot;&quot;&quot; :type intervals: List[Interval] :rtype: List[Interval] &quot;&quot;&quot; out = [] for i in sorted(intervals, key = lambda i: i.start): if out and i.start &lt;= out[-1].end: out[-1].end = max(out[-1].end, i.end) else: out += i, return out https://discuss.leetcode.com/topic/27383/short-python-solution Short python solution Sort the list first. Check if the new interval overlaps with the previous one in the output list. If yes, update it. Otherwise, append the new one. 12345678910111213class Solution(object): def merge(self, intervals): &quot;&quot;&quot; :type intervals: List[Interval] :rtype: List[Interval] &quot;&quot;&quot; if len(intervals) == 0: return [] intervals = sorted(intervals, key = lambda x: x.start) res = [intervals[0]] for n in intervals[1:]: if n.start &lt;= res[-1].end: res[-1].end = max(n.end, res[-1].end) else: res.append(n) return res java https://discuss.leetcode.com/topic/4319/a-simple-java-solution A simple Java solution The idea is to sort the intervals by their starting points. Then, we take the first interval and compare its end with the next intervals starts. As long as they overlap, we update the end to be the max end of the overlapping intervals. Once we find a non overlapping interval, we can add the previous “extended” interval and start over. Sorting takes O(n log(n)) and merging the intervals takes O(n). So, the resulting algorithm takes O(n log(n)). I used an anonymous comparator and a for-each loop to try to keep the code clean and simple. 123456789101112131415161718192021222324252627282930public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; if (intervals.size() &lt;= 1) return intervals; // Sort by ascending starting point using an anonymous Comparator Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval i1, Interval i2) &#123; return Integer.compare(i1.start, i2.start); &#125; &#125;); List&lt;Interval&gt; result = new LinkedList&lt;Interval&gt;(); int start = intervals.get(0).start; int end = intervals.get(0).end; for (Interval interval : intervals) &#123; if (interval.start &lt;= end) // Overlapping intervals, move the end if needed end = Math.max(end, interval.end); else &#123; // Disjoint intervals, add the previous one and reset bounds result.add(new Interval(start, end)); start = interval.start; end = interval.end; &#125; &#125; // Add the last interval result.add(new Interval(start, end)); return result;&#125; https://discuss.leetcode.com/topic/12788/a-clean-java-solution A clean java solution 1234567891011121314151617181920212223public class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; Collections.sort(intervals, new Comparator&lt;Interval&gt;()&#123; @Override public int compare(Interval obj0, Interval obj1) &#123; return obj0.start - obj1.start; &#125; &#125;); List&lt;Interval&gt; ret = new ArrayList&lt;&gt;(); Interval prev = null; for (Interval inter : intervals) &#123; if ( prev==null || inter.start&gt;prev.end ) &#123; ret.add(inter); prev = inter; &#125; else if (inter.end&gt;prev.end) &#123; // Modify the element already in list prev.end = inter.end; &#125; &#125; return ret; &#125;&#125; https://discuss.leetcode.com/topic/38628/beat-98-java-sort-start-end-respectively Beat 98% Java. Sort start &amp; end respectively. The idea is that for the result distinct Interval, the latter one’s start must &gt; previous one’s end. 123456789101112131415161718192021public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; // sort start&amp;end int n = intervals.size(); int[] starts = new int[n]; int[] ends = new int[n]; for (int i = 0; i &lt; n; i++) &#123; starts[i] = intervals.get(i).start; ends[i] = intervals.get(i).end; &#125; Arrays.sort(starts); Arrays.sort(ends); // loop through List&lt;Interval&gt; res = new ArrayList&lt;Interval&gt;(); for (int i = 0, j = 0; i &lt; n; i++) &#123; // j is start of interval. if (i == n - 1 || starts[i + 1] &gt; ends[i]) &#123; res.add(new Interval(starts[j], ends[i])); j = i + 1; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/8571/fast-ana-simple-java-code Fast ana simple java code The idea is to sort intervals based on start and iterate all itervals to merge them if: 1curr.end &gt;= iter.start The time complexity is : sort nO(logn)+ merge: O(n) = nO(logn) No Extra space except necessary result : ) 1234567891011121314151617181920212223public class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; res = new LinkedList&lt;Interval&gt;(); if(intervals.size()&lt;2) return intervals; Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval o1, Interval o2) &#123; return o1.start-o2.start; &#125; &#125;); Interval curr = intervals.get(0); for(Interval iter: intervals) &#123; if(curr.end &gt;= iter.start) &#123; curr.end = Math.max(curr.end,iter.end); &#125;else &#123; res.add(curr); curr = iter; &#125; &#125; res.add(curr); return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[055. Jump Game]]></title>
    <url>%2Fp%2F5ad5dd79%2F</url>
    <content type="text"><![CDATA[29.5% https://leetcode.com/problems/jump-game/ Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. 1234For example:A = [2,3,1,1,4], return true.A = [3,2,1,0,4], return false. 方法一： code 1： 12345678910class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int i = 0; for(int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + nums[i], reach); return i == n; &#125;&#125;; code 2： 我的实现 12345678910class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int i = 0; for(int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + nums[i], reach); return i == n; &#125;&#125;; cpp https://leetcode.com/discuss/15567/linear-and-simple-solution-in-c 12ms, 98.85%, June.22th, 2016 12345678910class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int i = 0; for(int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + nums[i], reach); return i == n; &#125;&#125;; https://discuss.leetcode.com/topic/4911/linear-and-simple-solution-in-c Linear and simple solution in C++ I just iterate and update the maximal index that I can reach 123456bool canJump(int A[], int n) &#123; int i = 0; for (int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + A[i], reach); return i == n;&#125; https://discuss.leetcode.com/topic/3443/simplest-o-n-solution-with-constant-space Simplest O(N) solution with constant space Idea is to work backwards from the last index. Keep track of the smallest index that can “jump” to the last index. Check whether the current index can jump to this smallest index. 1234567bool canJump(int A[], int n) &#123; int last=n-1,i,j; for(i=n-2;i&gt;=0;i--)&#123; if(i+A[i]&gt;=last)last=i; &#125; return last&lt;=0;&#125; https://discuss.leetcode.com/topic/21062/c-elegant-solution-o-n-time C++, elegant solution, O(n) time. 123456789101112bool canJump(vector&lt;int&gt;&amp; nums) &#123; int size=nums.size(); int step=nums[0]; for(int i=1;i&lt;size;++i)&#123; step--; if(step&lt;0) return false; if(nums[i]&gt;step) step=nums[i]; &#125; return true;&#125; my code 12345678910111213class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int m = 0; int cur_max = 1; while(m &lt; cur_max &amp;&amp; cur_max &lt; n)&#123; cur_max = max(nums[m]+m+1, cur_max); m += 1; &#125; return cur_max &gt; n-1; &#125;&#125;; my code 123456789101112131415class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return true; int loc = 0; for(int i=0; i&lt;n-1; i++)&#123; if(i&lt;=loc) loc = max(i+nums[i], loc); if(i&gt;loc) return false; &#125; return loc &gt;= n-1; &#125;&#125;; python https://leetcode.com/discuss/41420/1-6-lines-o-n-time-o-1-space 68ms, 46.69%, June.22th, 2016123456789101112class Solution(object): def canJump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; m = 0 for i, n in enumerate(nums): if i &gt; m: return False m = max(m, i+n) return True https://discuss.leetcode.com/topic/16704/1-6-lines-o-n-time-o-1-space 1-6 lines, O(n) time, O(1) space Solution 1 Going forwards. m tells the maximum index we can reach so far. 1234567def canJump(self, nums): m = 0 for i, n in enumerate(nums): if i &gt; m: return False m = max(m, i+n) return True Solution 2 One-liner version: 12def canJump(self, nums): return reduce(lambda m, (i, n): max(m, i+n) * (i &lt;= m), enumerate(nums, 1), 1) &gt; 0 Solution 3 Going backwards, most people seem to do that, here’s my version. 123456def canJump(self, nums): goal = len(nums) - 1 for i in range(len(nums))[::-1]: if i + nums[i] &gt;= goal: goal = i return not goal Solution 4 C version. 1234567bool canJump(int* nums, int n) &#123; int goal=n-1, i; for (i=n; i--;) if (i+nums[i] &gt;= goal) goal=i; return !goal;&#125; Solution mine: 96ms, 10.22%, June.22th, 2016 1234567891011121314class Solution(object): def canJump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; i = 0 max = 0 while i &lt; len(nums) and i &lt;= max: tmp = i + nums[i] if tmp &gt; max: max = tmp i += 1 return max &gt;= len(nums) - 1 Solution mine: 60ms, 79.56%, June.22th, 2016 12345678910111213class Solution(object): def canJump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; i = 0 m = 0 n = len(nums) while i &lt; n and i &lt;= m: m = max(i+nums[i], m) i += 1 return m &gt;= len(nums) -1 java https://leetcode.com/discuss/22560/java-solution-easy-to-understand 3ms, 26.71%, June.22th, 2016 Java Solution easy to understand 12345678910public class Solution &#123; public boolean canJump(int[] nums) &#123; int max = 0; for(int i = 0; i&lt; nums.length; i++)&#123; if(i &gt; max) return false; max = Math.max(nums[i] + i, max); &#125; return true; &#125;&#125; https://discuss.leetcode.com/topic/19931/6-line-java-solution-in-o-n 6 line java solution in O(n) The basic idea is this: at each step, we keep track of the furthest reachable index. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable. Hence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable. 12345678public boolean canJump(int[] nums) &#123; int reachable = 0; for (int i=0; i&lt;nums.length; ++i) &#123; if (i &gt; reachable) return false; reachable = Math.max(reachable, i + nums[i]); &#125; return true;&#125; https://discuss.leetcode.com/topic/36578/java-98-percentile-solution Java 98% Percentile Solution The easiest way to think about this problem is to ask are the elements with a 0 value avoidable? this is the algorithm that I constructed to answer this question.Starting from the second to last element in the array we continue to decrement towards the start of the array. Only stopping if we hit an element with a value of 0; in this case we evaluate if there exist an element somewhere at the start of the array which has a jump value large enough to jump over this 0 value element. 1234567891011121314151617public class Solution &#123; public boolean canJump(int[] nums) &#123; if(nums.length &lt; 2) return true; for(int curr = nums.length-2; curr&gt;=0;curr--)&#123; if(nums[curr] == 0)&#123; int neededJumps = 1; while(neededJumps &gt; nums[curr])&#123; neededJumps++; curr--; if(curr &lt; 0) return false; &#125; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[054. Spiral Matrix]]></title>
    <url>%2Fp%2F50cae0bf%2F</url>
    <content type="text"><![CDATA[25.1% https://leetcode.com/problems/spiral-matrix/ Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. 123456789For example,Given the following matrix:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]You should return [1,2,3,6,9,8,7,4,5]. 方法一： 设置四个变量，up，down， left， right，控制边界，直到要跳出循环。 剑指offer，20题。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return &#123;&#125;; int m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; spiral(m * n); int u = 0, d = m - 1, l = 0, r = n - 1, k = 0; while (true) &#123; // up for (int col = l; col &lt;= r; col++) spiral[k++] = matrix[u][col]; if (++u &gt; d) break; // right for (int row = u; row &lt;= d; row++) spiral[k++] = matrix[row][r]; if (--r &lt; l) break; // down for (int col = r; col &gt;= l; col--) spiral[k++] = matrix[d][col]; if (--d &lt; u) break; // left for (int row = d; row &gt;= u; row--) spiral[k++] = matrix[row][l]; if (++l &gt; r) break; &#125; return spiral; &#125;&#125;; 我的代码实现； 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; if(matrix.empty() || matrix[0].empty()) return res; // right = matrix[0].size()-1 而不是matrix[0]-1 我们要的是index int left = 0, right = matrix[0].size()-1, up = 0, down = matrix.size()-1; // 这里设置为永远为true while(true)&#123; for(int i=left; i&lt;=right; i++) res.push_back(matrix[up][i]); up++; // 需要在这里判断一下是否跳出循环 if(up&gt;down) break; for(int j=up; j&lt;=down; j++) res.push_back(matrix[j][right]); right--; if(left&gt;right) break; for(int k=right; k&gt;=left; k--) res.push_back(matrix[down][k]); down--; if(up&gt;down) break; for(int l=down; l&gt;=up; l--) res.push_back(matrix[l][left]); left++; if(left&gt;right) break; &#125; return res; &#125;&#125;; 0ms, 15.19%, June.25th, 2016 https://leetcode.com/discuss/38974/a-concise-c-implementation-based-on-directions A concise C++ implementation based on Directions When traversing the matrix in the spiral order, at any time we follow one out of the following four directions: RIGHT DOWN LEFT UP. Suppose we are working on a 5 x 3 matrix as such: 0 1 2 3 4 56 7 8 9 1011 12 13 14 15 Imagine a cursor starts off at (0, -1), i.e. the position at ‘0’, then we can achieve the spiral order by doing the following: Go right 5 times Go down 2 times Go left 4 times Go up 1 times. Go right 3 times Go down 0 times -&gt; quit Notice that the directions we choose always follow the order ‘right-&gt;down-&gt;left-&gt;up’, and for horizontal movements, the number of shifts follows:{5, 4, 3}, and vertical movements follows {2, 1, 0}. Thus, we can make use of a direction matrix that records the offset for all directions, then an array of two elements that stores the number of shifts for horizontal and vertical movements, respectively. This way, we really just need one for loop instead of four. Another good thing about this implementation is that: If later we decided to do spiral traversal on a different direction (e.g. Counterclockwise), then we only need to change the Direction matrix; the main loop does not need to be touched. 1234567891011121314151617181920vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;vector&lt;int&gt; &gt; dirs&#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; vector&lt;int&gt; res; int nr = matrix.size(); if (nr == 0) return res; int nc = matrix[0].size(); if (nc == 0) return res; vector&lt;int&gt; nSteps&#123;nc, nr-1&#125;; int iDir = 0; // index of direction. int ir = 0, ic = -1; // initial position while (nSteps[iDir%2]) &#123; for (int i = 0; i &lt; nSteps[iDir%2]; ++i) &#123; ir += dirs[iDir][0]; ic += dirs[iDir][1]; res.push_back(matrix[ir][ic]); &#125; nSteps[iDir%2]--; iDir = (iDir + 1) % 4; &#125; return res;&#125; https://discuss.leetcode.com/topic/21090/0ms-clear-c-solution 0ms Clear C++ Solution The idea is just to add the elements in the spiral order. First the up-most row (u), then the right-most column (r), then the down-most row (d), and finally the left-most column (l). After finishing a row or a column, update the corresponding variable to continue the process. The code is as follows. 简单直接 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return &#123;&#125;; int m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; spiral(m * n); int u = 0, d = m - 1, l = 0, r = n - 1, k = 0; while (true) &#123; // up for (int col = l; col &lt;= r; col++) spiral[k++] = matrix[u][col]; if (++u &gt; d) break; // right for (int row = u; row &lt;= d; row++) spiral[k++] = matrix[row][r]; if (--r &lt; l) break; // down for (int col = r; col &gt;= l; col--) spiral[k++] = matrix[d][col]; if (--d &lt; u) break; // left for (int row = d; row &gt;= u; row--) spiral[k++] = matrix[row][l]; if (++l &gt; r) break; &#125; return spiral; &#125;&#125;; my code: 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.size()==0 || matrix[0].size()==0) return &#123;&#125;; int m = matrix.size(); int n = matrix[0].size(); vector&lt;int&gt; spiral(m*n, 0); int up=0, down=m-1, left=0, right=n-1, i=0; while(true)&#123; for(int col=left; col&lt;=right; col++) spiral[i++] = matrix[up][col]; if(++up&gt;down) break; for(int row=up; row&lt;=down; row++) spiral[i++] = matrix[row][right]; if(--right&lt;left) break; for(int col=right; col&gt;=left; col--) spiral[i++] = matrix[down][col]; if(--down&lt;up) break; for(int row=down; row&gt;=up; row--) spiral[i++] = matrix[row][left]; if(++left&gt;right) break; &#125; return spiral; &#125;&#125;; https://discuss.leetcode.com/topic/19034/1-liner-in-python 1-liner in Python Take the first row plus the spiral order of the rotated remaining matrix. Inefficient for large matrices, but here I got it accepted in 40 ms, one of the fastest Python submissions. 12def spiralOrder(self, matrix): return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1]) 52ms, 35.84%, June.25th, 2016 https://leetcode.com/discuss/17818/simple-python-solution-by-mutating-the-matrix Simple Python solution by mutating the matrix The con is mutating the matrix, if this is not allowed, we can make a deep copy of the matrix first. And of course it comes with the additional memory usage. 123456789101112131415161718class Solution(object): def spiralOrder(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: List[int] &quot;&quot;&quot; ret = [] while matrix: ret += matrix.pop(0) if matrix and matrix[0]: for row in matrix: ret.append(row.pop()) if matrix: ret += matrix.pop()[::-1] if matrix and matrix[0]: for row in matrix[::-1]: ret.append(row.pop(0)) return ret https://discuss.leetcode.com/topic/26242/ac-python-32ms-solution AC Python 32ms solution 1234567891011121314151617181920212223def spiralOrder(self, matrix): if not matrix or not matrix[0]: return [] ans = [] m, n = len(matrix), len(matrix[0]) u, d, l, r = 0, m - 1, 0, n - 1 while l &lt; r and u &lt; d: ans.extend([matrix[u][j] for j in xrange(l, r)]) ans.extend([matrix[i][r] for i in xrange(u, d)]) ans.extend([matrix[d][j] for j in xrange(r, l, -1)]) ans.extend([matrix[i][l] for i in xrange(d, u, -1)]) u, d, l, r = u + 1, d - 1, l + 1, r - 1 if l == r: ans.extend([matrix[i][r] for i in xrange(u, d + 1)]) elif u == d: ans.extend([matrix[u][j] for j in xrange(l, r + 1)]) return ans# 22 / 22 test cases passed.# Status: Accepted# Runtime: 32 ms# 100% https://discuss.leetcode.com/topic/3713/super-simple-and-easy-to-understand-solution Super Simple and Easy to Understand Solution This is a very simple and easy to understand solution. I traverse right and increment rowBegin, then traverse down and decrement colEnd, then I traverse left and decrement rowEnd, and finally I traverse up and increment colBegin. The only tricky part is that when I traverse left or up I have to check whether the row or col still exists to prevent duplicates. If anyone can do the same thing without that check, please let me know! Any comments greatly appreciated. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (matrix.length == 0) &#123; return res; &#125; int rowBegin = 0; int rowEnd = matrix.length-1; int colBegin = 0; int colEnd = matrix[0].length - 1; while (rowBegin &lt;= rowEnd &amp;&amp; colBegin &lt;= colEnd) &#123; // Traverse Right for (int j = colBegin; j &lt;= colEnd; j ++) &#123; res.add(matrix[rowBegin][j]); &#125; rowBegin++; // Traverse Down for (int j = rowBegin; j &lt;= rowEnd; j ++) &#123; res.add(matrix[j][colEnd]); &#125; colEnd--; if (rowBegin &lt;= rowEnd) &#123; // Traverse Left for (int j = colEnd; j &gt;= colBegin; j --) &#123; res.add(matrix[rowEnd][j]); &#125; &#125; rowEnd--; if (colBegin &lt;= colEnd) &#123; // Traver Up for (int j = rowEnd; j &gt;= rowBegin; j --) &#123; res.add(matrix[j][colBegin]); &#125; &#125; colBegin ++; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/22270/elegant-and-fast-java-solution-240ms Elegant and fast Java solution (240ms) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;List&lt;Integer&gt; spiralList = new ArrayList&lt;&gt;();if(matrix == null || matrix.length == 0) return spiralList;// declare indicesint top = 0;int bottom = matrix.length - 1;int left = 0;int right = matrix[0].length - 1;while(true)&#123; // 1. print top row for(int j=left; j &lt;=right;j++)&#123; spiralList.add(matrix[top][j]); &#125; top++; if(boundriesCrossed(left,right,bottom,top)) break; // 2. print rightmost column for(int i=top; i &lt;= bottom; i++)&#123; spiralList.add(matrix[i][right]); &#125; right--; if(boundriesCrossed(left,right,bottom,top)) break; // 3. print bottom row for(int j=right; j &gt;=left; j--)&#123; spiralList.add(matrix[bottom][j]); &#125; bottom--; if(boundriesCrossed(left,right,bottom,top)) break; // 4. print leftmost column for(int i=bottom; i &gt;= top; i--)&#123; spiralList.add(matrix[i][left]); &#125; left++; if(boundriesCrossed(left,right,bottom,top)) break; &#125;// end while truereturn spiralList;&#125;private boolean boundriesCrossed(int left,int right,int bottom,int top)&#123;if(left&gt;right || bottom&lt;top) return true;else return false;&#125; https://discuss.leetcode.com/topic/44784/clean-java-readable-human-friendly-code Clean Java, readable, human friendly code 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(matrix.length == 0 || matrix[0].length == 0) return res; int top = 0; int bottom = matrix.length-1; int left = 0; int right = matrix[0].length-1; while(true)&#123; for(int i = left; i &lt;= right; i++) res.add(matrix[top][i]); top++; if(left &gt; right || top &gt; bottom) break; for(int i = top; i &lt;= bottom; i++) res.add(matrix[i][right]); right--; if(left &gt; right || top &gt; bottom) break; for(int i = right; i &gt;= left; i--) res.add(matrix[bottom][i]); bottom--; if(left &gt; right || top &gt; bottom) break; for(int i = bottom; i &gt;= top; i--) res.add(matrix[i][left]); left++; if(left &gt; right || top &gt; bottom) break; &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[053. Maximum Subarray]]></title>
    <url>%2Fp%2Fe4eaff71%2F</url>
    <content type="text"><![CDATA[39.0% https://leetcode.com/problems/maximum-subarray/ Find the contiguous subarray within an array (containing at least one number) which has the largest sum. 12For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. click to show more practice. More practice: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 方法一： 动态规划 dp[n] 保存以nums[n]结尾的最大值，ans保存当前到n所有表中的最大值。 1234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; vector&lt;int&gt; dp(nums.size(), 0); dp[0] = nums[0]; int ans = nums[0]; for(int i=1; i&lt;nums.size(); i++)&#123; dp[i] = nums[i] + (dp[i-1]&gt;0?dp[i-1]:0); ans = max(ans, dp[i]); &#125; return ans; &#125;&#125;; 方法二： 与上面逻辑其实是类似的，保存一个当前最大值cur_sum，表示第i个位置之前，从i-1向前所能取得的最大值，并且以i-1结尾的， 全局最大值 max_sum表示0至i-1之前的最大值。到达第i位时，先更新当前最大值，再更新全局的。 1234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;0) return 0; int cur_sum = 0; int max_sum = INT_MIN; for(auto num:nums)&#123; cur_sum = max(cur_sum, 0) + num; max_sum = max(cur_sum, max_sum); &#125; return max_sum; &#125;&#125;; 我的代码实现： 通过初始化为第0位，避免了使用INT_MIN。 12345678910111213class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;1) return n; int cur_max = nums[0], all_max = nums[0]; for(int i=1; i&lt;n; i++)&#123; cur_max = max(cur_max+nums[i], nums[i]); all_max = max(all_max, cur_max); &#125; return all_max; &#125;&#125;; 我的代码实现: 123456789101112131415161718class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;1) return 0; if(n==1) return nums[0]; int cur_max = nums[0], res = nums[0]; int i=1; while(i&lt;n)&#123; // 仔细思考，这里是 max(nums[i], cur_max+nums[i]) // 而不是max(cur_max, cur_max+nums[i]); cur_max = max(nums[i], cur_max+nums[i]); res = max(res, cur_max); i++; &#125; return res; &#125;&#125;; cpp https://leetcode.com/discuss/11288/simplest-and-fastest-o-n-c-solution 8ms, 72.20%, June.18th, 2016 Simplest and fastest O(n) C++ solution Idea is very simple. Basically, keep adding each integer to the sequence until the sum drops below 0. If sum is negative, then should reset the sequence. 123456789101112class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int ans = nums[0], sum = 0; for(int i=0; i &lt; nums.size();i++)&#123; sum += nums[i]; ans = max(ans, sum); sum = max(sum, 0); &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/4175/share-my-solutions-both-greedy-and-divide-and-conquer Share my solutions - both greedy and divide and conquer greedy: 123456789101112class Solution &#123;public: int maxSubArray(int A[], int n) &#123; int sum = 0, min = 0, res = A[0]; for(int i = 0; i &lt; n; i++) &#123; sum += A[i]; if(sum - min &gt; res) res = sum - min; if(sum &lt; min) min = sum; &#125; return res; &#125;&#125;; The idea is to find the largest difference between the sums when you summing up the array from left to right. The largest difference corresponds to the sub-array with largest sum. I worked it out independently although It is very close to lucastan’s solution https://oj.leetcode.com/discuss/11288/simple-o-n-c-solution-no-dp-no-divide-and-conquer divide and conquer: 12345678910111213141516171819202122struct val &#123; int l, m, r, s; val(int l, int m, int r, int s):l(l), m(m), r(r), s(s)&#123;&#125;&#125;;class Solution &#123;public: val dac(int A[], int n) &#123; if(n == 1) return val(A[0], A[0], A[0], A[0]); val v1 = dac(A, n / 2), v2 = dac(A + n / 2, n - n / 2); int l, m, r, s; l = max(v1.l, v1.s + v2.l); m = max(v1.r + v2.l, max(v1.m, v2.m)); r = max(v2.r, v1.r + v2.s); s = v1.s + v2.s; return val(l, m, r, s); &#125; int maxSubArray(int A[], int n) &#123; val v = dac(A, n); return v.m; &#125;&#125;; the idea is: for each sub array we calculate 4 values in O(1) time based on the return values of its two halves. The meaning of the values: l: the sum of the sub array with largest sum starting from the first element m: the sum of the sub array with largest sum r: the sum of the sub array with largest sum ending at the last element s: the sum of the whole array the recursive relation is clear in the code. https://discuss.leetcode.com/topic/25396/c-an-clear-o-n-divide-and-conquer-solution-with-comments [C++] An clear O(n) divide and conquer solution with comments For each subarray, calculate four attributes: 1234mx (largest sum of this subarray), lmx(largest sum starting from the left most element), rmx(largest sum ending with the right most element), sum(the sum of the total subarray). The recurrence is: T(n) = 2T(n / 2) + O(1). So the running time of this algorithm is O(n). 123456789101112131415161718192021222324252627class Solution &#123;public: void maxSubArray(vector&lt;int&gt;&amp; nums, int l, int r, int&amp; mx, int&amp; lmx, int&amp; rmx, int&amp; sum) &#123; if (l == r) &#123; mx = lmx = rmx = sum = nums[l]; &#125; else &#123; int m = (l + r) / 2; int mx1, lmx1, rmx1, sum1; int mx2, lmx2, rmx2, sum2; maxSubArray(nums, l, m, mx1, lmx1, rmx1, sum1); maxSubArray(nums, m + 1, r, mx2, lmx2, rmx2, sum2); mx = max(max(mx1, mx2), rmx1 + lmx2); lmx = max(lmx1, sum1 + lmx2); rmx = max(rmx2, sum2 + rmx1); sum = sum1 + sum2; &#125; &#125; int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) &#123; return 0; &#125; int mx, lmx, rmx, sum; maxSubArray(nums, 0, nums.size() - 1, mx, lmx, rmx, sum); return mx; &#125;&#125;; https://discuss.leetcode.com/topic/426/how-to-solve-maximum-subarray-by-using-the-divide-and-conquer-approach How to solve “Maximum Subarray” by using the divide and conquer approach ? I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach. I cannot figure out how to do it with divide and conquer. You guys have ideas? https://discuss.leetcode.com/topic/426/how-to-solve-maximum-subarray-by-using-the-divide-and-conquer-approach/2 Step1. Select the middle element of the array. So the maximum subarray may contain that middle element or not. Step 2.1 If the maximum subarray does not contain the middle element, then we can apply the same algorithm to the the subarray to the left of the middle element and the subarray to the right of the middle element. Step 2.2 If the maximum subarray does contain the middle element, then the result will be simply the maximum suffix subarray of the left subarray plus the maximum prefix subarray of the right subarray Step 3 return the maximum of those three answer. Here is a sample code for divide and conquer solution. Please try to understand the algorithm before look at the code 1234567891011121314151617181920212223242526272829class Solution &#123;public: int maxSubArray(int A[], int n) &#123; // IMPORTANT: Please reset any member data you declared, as // the same Solution instance will be reused for each test case. if(n==0) return 0; return maxSubArrayHelperFunction(A,0,n-1); &#125; int maxSubArrayHelperFunction(int A[], int left, int right) &#123; if(right == left) return A[left]; int middle = (left+right)/2; int leftans = maxSubArrayHelperFunction(A, left, middle); int rightans = maxSubArrayHelperFunction(A, middle+1, right); int leftmax = A[middle]; int rightmax = A[middle+1]; int temp = 0; for(int i=middle;i&gt;=left;i--) &#123; temp += A[i]; if(temp &gt; leftmax) leftmax = temp; &#125; temp = 0; for(int i=middle+1;i&lt;=right;i++) &#123; temp += A[i]; if(temp &gt; rightmax) rightmax = temp; &#125; return max(max(leftans, rightans),leftmax+rightmax); &#125;&#125;; python https://leetcode.com/discuss/29296/a-python-solution 64ms, 49.06%, June.18th, 201612345678910111213class Solution(object): def maxSubArray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if not nums: return 0 cursum = maxsum = nums[0] for num in nums[1:]: cursum = max(num, num+cursum) maxsum = max(cursum, maxsum) return maxsum java https://discuss.leetcode.com/topic/6413/dp-solution-some-thoughts Analysis of this problem: Apparently, this is a optimization problem, which can be usually solved by DP. So when it comes to DP, the first thing for us to figure out is the format of the sub problem(or the state of each sub problem). The format of the sub problem can be helpful when we are trying to come up with the recursive relation. At first, I think the sub problem should look like: maxSubArray(int A[], int i, int j), which means the maxSubArray for A[i: j]. In this way, our goal is to figure out what maxSubArray(A, 0, A.length - 1) is. However, if we define the format of the sub problem in this way, it’s hard to find the connection from the sub problem to the original problem(at least for me). In other words, I can’t find a way to divided the original problem into the sub problems and use the solutions of the sub problems to somehow create the solution of the original one. So I change the format of the sub problem into something like: maxSubArray(int A[], int i), which means the maxSubArray for A[0:i ] which must has A[i] as the end element. Note that now the sub problem’s format is less flexible and less powerful than the previous one because there’s a limitation that A[i] should be contained in that sequence and we have to keep track of each solution of the sub problem to update the global optimal value. However, now the connect between the sub problem &amp; the original one becomes clearer: 1maxSubArray(A, i) = maxSubArray(A, i - 1) &gt; 0 ? maxSubArray(A, i - 1) : 0 + A[i]; And here’s the code 123456789101112131415public class Solution &#123; public int maxSubArray(int[] nums) &#123; int n = nums.length; int[] dp = new int[n]; dp[0] = nums[0]; int max = dp[0]; for(int i=1; i&lt;n; i++)&#123; dp[i] = nums[i] + (dp[i-1]&gt;0?dp[i-1]:0); max = Math.max(max, dp[i]); &#125; return max; &#125;&#125; https://leetcode.com/discuss/15805/accepted-o-n-solution-in-java 1ms, 69.50%, June.18th, 2016 Accepted O(n) solution in java this problem was discussed by Jon Bentley (Sep. 1984 Vol. 27 No. 9 Communications of the ACM P885) the paragraph below was copied from his paper (with a little modifications) algorithm that operates on arrays: it starts at the left end (element A[1]) and scans through to the right end (element A[n]), keeping track of the maximum sum subvector seen so far. The maximum is initially A[0]. Suppose we’ve solved the problem for A[1 .. i - 1]; how can we extend that to A[1 .. i]? The maximumsum in the first I elements is either the maximum sum in the first i - 1 elements (which we’ll call MaxSoFar), or it is that of a subvector that ends in position i (which we’ll call MaxEndingHere). MaxEndingHere is either A[i] plus the previous MaxEndingHere, or just A[i], whichever is larger. 12345678public static int maxSubArray(int[] A) &#123; int maxSoFar=A[0], maxEndingHere=A[0]; for (int i=1;i&lt;A.length;++i)&#123; maxEndingHere= Math.max(maxEndingHere+A[i],A[i]); maxSoFar=Math.max(maxSoFar, maxEndingHere); &#125; return maxSoFar;&#125; https://discuss.leetcode.com/topic/7447/o-n-java-solution O(n) Java solution The catch here is that we have to take care of negative value. The solution does 1 iteration with constant space and no DP. 1234567891011121314public class Solution &#123;public int maxSubArray(int[] A) &#123; int max = Integer.MIN_VALUE, sum = 0; for (int i = 0; i &lt; A.length; i++) &#123; if (sum &lt; 0) sum = A[i]; else sum += A[i]; if (sum &gt; max) max = sum; &#125; return max;&#125;&#125; https://discuss.leetcode.com/topic/27151/my-concise-o-n-dp-java-solution My concise O(n) DP JAVA Solution Explanation Although there’re some other simplified solutions, but DP solution can make the original thought for this problem clearer. In this solution, dp[i] means the largest sum among the subarrays whose last element is A[i]. Solution1. DP Solution - O(n) time, O(n) space 12345678public int maxSubArray(int[] A) &#123; int dp[] = new int[A.length]; int max = A[0]; dp[0] = A[0]; for (int i = 1; i &lt; A.length; i++) &#123; dp[i] = Math.max(dp[i-1] + A[i] ,A[i]); max = Math.max(max, dp[i]); &#125; return max;&#125; Solution2. Simplified DP Solution - O(n) time, O(1) space - Special thanks for TWiStErRob’s smart comment The basic idea is to check previous sum, reset it to 0 if it’s less than 0. 12345678public int maxSubArray(int[] A) &#123; int res = Integer.MIN_VALUE, sum = 0; for (int i = 0; i &lt; A.length; i++) &#123; sum = Math.max(sum, 0) + A[i]; res = Math.max(res, sum); &#125; return res;&#125; Solution3. Pre-Sum Array Solution - O(n) time, O(n) space The basic idea is to use pre-sum array, max = Math.max(max, sum[i] - minSum). (minSum is the minimum sum before A[i]) 123456789101112public int maxSubArray(int[] A) &#123; if (A == null || A.length == 0) return 0; int max = A[0], minSum = Integer.MAX_VALUE; int sum[] = new int[A.length]; sum[0] = A[0]; for (int i = 1; i &lt; A.length; i++) &#123; sum[i] = sum[i-1] + A[i]; minSum = Math.min(0, Math.min(minSum, sum[i-1])); max = Math.max(max, sum[i] - minSum); &#125; return max;&#125; https://discuss.leetcode.com/topic/42213/my-divide-and-conquer-solution-in-java-under-instruction-of-clrs-o-nlogn My Divide and Conquer Solution in Java under instruction of CLRS(O(nlogn)) 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123;//divdie and conquer public int maxSubArray(int[] nums) &#123; return Subarray(nums, 0 ,nums.length -1 ); &#125; public int Subarray(int[] A,int left, int right)&#123; if(left == right)&#123;return A[left];&#125; int mid = left + (right - left) / 2; int leftSum = Subarray(A,left,mid);// left part int rightSum = Subarray(A,mid+1,right);//right part int crossSum = crossSubarray(A,left,right);// cross part if(leftSum &gt;= rightSum &amp;&amp; leftSum &gt;= crossSum)&#123;// left part is max return leftSum; &#125; if(rightSum &gt;= leftSum &amp;&amp; rightSum &gt;= crossSum)&#123;// right part is max return rightSum; &#125; return crossSum; // cross part is max &#125; public int crossSubarray(int[] A,int left,int right)&#123; int leftSum = Integer.MIN_VALUE; int rightSum = Integer.MIN_VALUE; int sum = 0; int mid = left + (right - left) / 2; for(int i = mid; i &gt;= left ; i--)&#123; sum = sum + A[i]; if(leftSum &lt; sum)&#123; leftSum = sum; &#125; &#125; sum = 0; for(int j = mid + 1; j &lt;= right; j++)&#123; sum = sum + A[j]; if(rightSum &lt; sum)&#123; rightSum = sum; &#125; &#125; return leftSum + rightSum; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>divide and conquer</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[052. N-Queens II]]></title>
    <url>%2Fp%2F8e5f0d6d%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/n-queens-ii/ Follow up for N-Queens problem. Now, instead outputting board configurations, return the total number of distinct solutions. cpp https://discuss.leetcode.com/topic/19741/c-solution-dfs-easy-understanding C++ solution - DFS - easy understanding 1234567891011121314151617181920212223int totalNQueens(int n) &#123; vector&lt;bool&gt; col(n, true); vector&lt;bool&gt; anti(2*n-1, true); vector&lt;bool&gt; main(2*n-1, true); vector&lt;int&gt; row(n, 0); int count = 0; dfs(0, row, col, main, anti, count); return count;&#125;void dfs(int i, vector&lt;int&gt; &amp;row, vector&lt;bool&gt; &amp;col, vector&lt;bool&gt;&amp; main, vector&lt;bool&gt; &amp;anti, int &amp;count) &#123; if (i == row.size()) &#123; count++; return; &#125; for (int j = 0; j &lt; col.size(); j++) &#123; if (col[j] &amp;&amp; main[i+j] &amp;&amp; anti[i+col.size()-1-j]) &#123; row[i] = j; col[j] = main[i+j] = anti[i+col.size()-1-j] = false; dfs(i+1, row, col, main, anti, count); col[j] = main[i+j] = anti[i+col.size()-1-j] = true; &#125; &#125;&#125; https://discuss.leetcode.com/topic/19741/c-solution-dfs-easy-understanding/2 Nice job!I think row is useless, delete it is ok. 123456789101112131415161718192021222324252627282930class Solution &#123;public:int totalNQueens(int n) &#123; int count = 0; vector&lt;bool&gt; cols(n, true); vector&lt;bool&gt; main(2 * n - 1, true); vector&lt;bool&gt; anti(2 * n - 1, true); helper(0, count, cols, main, anti); return count;&#125;private:void helper(int s, int&amp; count, vector&lt;bool&gt;&amp; cols, vector&lt;bool&gt;&amp; main, vector&lt;bool&gt;&amp; anti)&#123; if (s == cols.size()) &#123; count++; return; &#125; for (int i = 0; i &lt; cols.size(); i++) &#123; if (cols[i] &amp;&amp; main[s + i] &amp;&amp; anti[s + cols.size() - 1 - i]) &#123; cols[i] = main[s + i] = anti[s + cols.size() - 1 - i] = false; helper(s + 1, count, cols, main, anti); cols[i] = main[s + i] = anti[s + cols.size() - 1 - i] = true; &#125; &#125;&#125;&#125;; And I want to share my 4ms Solution. The ideas are same but the diagonal conflict checking method diffes. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public:int totalNQueens(int n) &#123; int count = 0; vector&lt;bool&gt; mark(n); vector&lt;int&gt; cols(n, -1); for (int i = 0; i &lt; n; i++) &#123; cols[0] = i; mark[i] = true; helper(1, n, count, mark, cols); cols[0] = -1; mark[i] = false; &#125; return count;&#125;private:void helper(int s, int n, int&amp; count, vector&lt;bool&gt;&amp; mark, vector&lt;int&gt;&amp; cols)&#123; if (s == n) &#123; count++; return; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!mark[i]) &#123; bool mark2 = true; for (int k = 0; k &lt; s; k++) &#123; if (abs(s - k) == abs(i - cols[k])) &#123; mark2 = false; break; &#125; &#125; if (mark2) &#123; cols[s] = i; mark[i] = true; helper(s + 1, n, count, mark, cols); cols[s] = -1; mark[i] = false; &#125; &#125; &#125;&#125;&#125;; https://discuss.leetcode.com/topic/38923/share-my-java-code-beats-97-83-run-times Share my Java code (beats 97.83% run times) 1234567891011121314151617181920212223242526272829/* 常规n-queens解法, 数答案个数. 用column标记此行之前的哪些column已经放置了queen. 棋盘坐标(row, col)对应column的第col位(LSB --&gt; MSB, 下同). 用diag标记此位置之前的哪些主对角线已经放置了queen. 棋盘坐标(row, col)对应diag的第(n - 1 + row - col)位. 用antiDiag标记此位置之前的哪些副对角线已经放置了queen. 棋盘坐标(row, col)对应antiDiag的第(row + col)位.*/public class Solution &#123; int count = 0; public int totalNQueens(int n) &#123; dfs(0, n, 0, 0, 0); return count; &#125; private void dfs(int row, int n, int column, int diag, int antiDiag) &#123; if (row == n) &#123; ++count; return; &#125; for (int i = 0; i &lt; n; ++i) &#123; boolean isColSafe = ((1 &lt;&lt; i) &amp; column) == 0; boolean isDiagSafe = ((1 &lt;&lt; (n - 1 + row - i)) &amp; diag) == 0; boolean isAntiDiagSafe = ((1 &lt;&lt; (row + i)) &amp; antiDiag) == 0; if (isColSafe &amp;&amp; isDiagSafe &amp;&amp; isAntiDiagSafe) &#123; dfs(row + 1, n, (1 &lt;&lt; i) | column, (1 &lt;&lt; (n - 1 + row - i)) | diag, (1 &lt;&lt; (row + i)) | antiDiag); &#125; &#125; &#125;&#125; cpp https://discuss.leetcode.com/topic/15329/shortest-c-solution-in-0ms Shortest C++ solution in 0ms Idea is to use vectors to keep track of invalid positions , so validity can be checked in O(1) and put a queen in each column 12345678910111213141516171819202122#include&lt;vector&gt;using namespace std;class Solution &#123;public: int find(int n, int left, int i, int r, vector&lt;int&gt;&amp;rows,vector&lt;int&gt;&amp;d1,vector&lt;int&gt;&amp;d2)&#123; if (left == 0) return 1; int j,sum=0; for (j=r; j&lt;n; j++)&#123; if (rows[j] || d1[i+j] || d2[n-1+i-j]) continue; rows[j]=d1[i+j]=d2[n-1+i-j]=1; sum += find(n, left-1, i+1, 0,rows,d1,d2 ); rows[j]=d1[i+j]=d2[n-1+i-j]=0; &#125; return sum; &#125; int totalNQueens(int n) &#123; vector&lt;int&gt; rows(n),d1(2*n-1),d2(2*n-1); return find(n,n,0,0,rows,d1,d2); &#125;&#125;; https://discuss.leetcode.com/topic/11348/my-concise-dfs-c-solution-using-three-unordered_map-int-bool My concise DFS C++ solution using three unordered_map&lt;int, bool&gt;. 1234567891011121314151617181920212223242526class Solution &#123;public: unordered_map&lt;int, bool&gt; column, obliqueLeft, obliqueRight; int total; void NQueensHelper(int row, int n) &#123; if (row == n+1) &#123; total++; return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!column[i] &amp;&amp; !obliqueLeft[i + row] &amp;&amp; !obliqueRight[i - row]) &#123; column[i] = obliqueLeft[i + row] = obliqueRight[i - row] = true; NQueensHelper(row+1, n); column[i] = obliqueLeft[i + row] = obliqueRight[i - row] = false; &#125; &#125; &#125; int totalNQueens(int n) &#123; column.clear(); obliqueLeft.clear(); obliqueRight.clear(); total = 0; NQueensHelper(1, n); return total; &#125;&#125;; Each unordered_map represents whether column/left oblique line/right oblique line is occupied before. python https://discuss.leetcode.com/topic/22294/python-recursive-dfs-solution Python recursive dfs solution. The idea here is quite similar to N-Queens while we don’t need to record the path, and as the return value is a number not a list, it’s better to use a global variable to record the result. 12345678910111213141516171819def totalNQueens(self, n): self.res = 0 self.dfs([-1]*n, 0) return self.res def dfs(self, nums, index): if index == len(nums): self.res += 1 return for i in xrange(len(nums)): nums[index] = i if self.valid(nums, index): self.dfs(nums, index+1) def valid(self, nums, n): for i in xrange(n): if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i: return False return True 72ms, 85.33%, June.17th, 2016 1234567891011121314151617class Solution(object): def totalNQueens(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; def DFS(queens, xy_dif, xy_sum): p = len(queens) if p==n: result.append(queens) return None for q in range(n): if q not in queens and p-q not in xy_dif and p+q not in xy_sum: DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q]) result = [] DFS([],[],[]) return len(result) java https://discuss.leetcode.com/topic/5962/accepted-java-solution Accepted Java Solution 123456789101112131415161718192021222324252627282930313233343536373839404142/** * don&apos;t need to actually place the queen, * instead, for each row, try to place without violation on * col/ diagonal1/ diagnol2. * trick: to detect whether 2 positions sit on the same diagnol: * if delta(col, row) equals, same diagnol1; * if sum(col, row) equals, same diagnal2. */private final Set&lt;Integer&gt; occupiedCols = new HashSet&lt;Integer&gt;();private final Set&lt;Integer&gt; occupiedDiag1s = new HashSet&lt;Integer&gt;();private final Set&lt;Integer&gt; occupiedDiag2s = new HashSet&lt;Integer&gt;();public int totalNQueens(int n) &#123; return totalNQueensHelper(0, 0, n);&#125;private int totalNQueensHelper(int row, int count, int n) &#123; for (int col = 0; col &lt; n; col++) &#123; if (occupiedCols.contains(col)) continue; int diag1 = row - col; if (occupiedDiag1s.contains(diag1)) continue; int diag2 = row + col; if (occupiedDiag2s.contains(diag2)) continue; // we can now place a queen here if (row == n-1) count++; else &#123; occupiedCols.add(col); occupiedDiag1s.add(diag1); occupiedDiag2s.add(diag2); count = totalNQueensHelper(row+1, count, n); // recover occupiedCols.remove(col); occupiedDiag1s.remove(diag1); occupiedDiag2s.remove(diag2); &#125; &#125; return count;&#125; https://discuss.leetcode.com/topic/29626/easiest-java-solution-1ms-98-22 Easiest Java Solution (1ms, 98.22%) This is a classic backtracking problem. Start row by row, and loop through columns. At each decision point, skip unsafe positions by using three boolean arrays. Start going back when we reach row n. Just FYI, if using HashSet, running time will be at least 3 times slower! 123456789101112131415161718192021222324public class Solution &#123; int count = 0; public int totalNQueens(int n) &#123; boolean[] cols = new boolean[n]; // columns | boolean[] d1 = new boolean[2 * n]; // diagonals \ boolean[] d2 = new boolean[2 * n]; // diagonals / backtracking(0, cols, d1, d2, n); return count; &#125; public void backtracking(int row, boolean[] cols, boolean[] d1, boolean []d2, int n) &#123; if(row == n) count++; for(int col = 0; col &lt; n; col++) &#123; int id1 = col - row + n; int id2 = col + row; if(cols[col] || d1[id1] || d2[id2]) continue; cols[col] = true; d1[id1] = true; d2[id2] = true; backtracking(row + 1, cols, d1, d2, n); cols[col] = false; d1[id1] = false; d2[id2] = false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[051. N-Queens]]></title>
    <url>%2Fp%2Faa0d9b9e%2F</url>
    <content type="text"><![CDATA[31.1% https://leetcode.com/problems/n-queens/ The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively. 1234567891011121314For example,There exist two distinct solutions to the 4-queens puzzle:[ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] https://discuss.leetcode.com/topic/1154/the-description-should-give-a-clear-explanation-of-the-problem-of-n-queens The description should give a clear explanation of the problem of “n-queens” queens can attack other queen in the same row, same column, but i forget the diagonal.. = 。= 方法一： https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand Accepted 4ms c++ solution use backtracking and bitmask, easy understand. In this problem, we can go row by row, and in each position, we need to check if the column, the 45° diagonal and the 135° diagonal had a queen before. Solution A: Directly check the validity of each position, 12ms: 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: std::vector&lt;std::vector&lt;std::string&gt; &gt; solveNQueens(int n) &#123; std::vector&lt;std::vector&lt;std::string&gt; &gt; res; std::vector&lt;std::string&gt; nQueens(n, std::string(n, &apos;.&apos;)); solveNQueens(res, nQueens, 0, n); return res; &#125;private: void solveNQueens(std::vector&lt;std::vector&lt;std::string&gt; &gt; &amp;res, std::vector&lt;std::string&gt; &amp;nQueens, int row, int &amp;n) &#123; if (row == n) &#123; res.push_back(nQueens); return; &#125; for (int col = 0; col != n; ++col) if (isValid(nQueens, row, col, n)) &#123; nQueens[row][col] = &apos;Q&apos;; solveNQueens(res, nQueens, row + 1, n); nQueens[row][col] = &apos;.&apos;; &#125; &#125; bool isValid(std::vector&lt;std::string&gt; &amp;nQueens, int row, int col, int &amp;n) &#123; //check if the column had a queen before. for (int i = 0; i != row; ++i) if (nQueens[i][col] == &apos;Q&apos;) return false; //check if the 45° diagonal had a queen before. for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) if (nQueens[i][j] == &apos;Q&apos;) return false; //check if the 135° diagonal had a queen before. for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j) if (nQueens[i][j] == &apos;Q&apos;) return false; return true; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; queens(n, string(n, '.')); helper(res, queens, 0, n); return res; &#125; void helper(vector&lt;vector&lt;string&gt;&gt;&amp; res, vector&lt;string&gt;&amp; queens, int row, int n)&#123; if(row==n)&#123; res.push_back(queens); return; &#125; for(int col=0; col&lt;n; col++)&#123; if(isvalid(queens, row, col, n))&#123; queens[row][col] = 'Q'; helper(res, queens, row+1, n); queens[row][col] = '.'; &#125; &#125; &#125; bool isvalid(vector&lt;string&gt;&amp; queens, int row, int col, int n)&#123; for(int i=0; i&lt;row; i++) if(queens[i][col]=='Q') return false; for(int i=row-1, j=col-1; i&gt;=0 &amp;&amp; j&gt;=0; i--, j--) if(queens[i][j]=='Q') return false; for(int i=row-1, j=col+1; i&gt;=0 &amp;&amp; j&lt;n; i--, j++) if(queens[i][j]=='Q') return false; return true; &#125;&#125;; Solution B: Use flag vectors as bitmask, 4ms: The number of columns is n, the number of 45° diagonals is 2 n - 1, the number of 135° diagonals is also 2 n - 1. When reach [row, col], the column No. is col, the 45° diagonal No. is row + col and the 135° diagonal No. is n - 1 + col - row. We can use three arrays to indicate if the column or the diagonal had a queen before, if not, we can put a queen in this position and continue. 12345678910111213141516171819202122232425262728293031323334/** | | | / / / \ \ \ * O O O O O O O O O * | | | / / / / \ \ \ \ * O O O O O O O O O * | | | / / / / \ \ \ \ * O O O O O O O O O * | | | / / / \ \ \ * 3 columns 5 45° diagonals 5 135° diagonals (when n is 3) */class Solution &#123;public: std::vector&lt;std::vector&lt;std::string&gt; &gt; solveNQueens(int n) &#123; std::vector&lt;std::vector&lt;std::string&gt; &gt; res; std::vector&lt;std::string&gt; nQueens(n, std::string(n, &apos;.&apos;)); std::vector&lt;int&gt; flag_col(n, 1), flag_45(2 * n - 1, 1), flag_135(2 * n - 1, 1); solveNQueens(res, nQueens, flag_col, flag_45, flag_135, 0, n); return res; &#125;private: void solveNQueens(std::vector&lt;std::vector&lt;std::string&gt; &gt; &amp;res, std::vector&lt;std::string&gt; &amp;nQueens, std::vector&lt;int&gt; &amp;flag_col, std::vector&lt;int&gt; &amp;flag_45, std::vector&lt;int&gt; &amp;flag_135, int row, int &amp;n) &#123; if (row == n) &#123; res.push_back(nQueens); return; &#125; for (int col = 0; col != n; ++col) if (flag_col[col] &amp;&amp; flag_45[row + col] &amp;&amp; flag_135[n - 1 + col - row]) &#123; flag_col[col] = flag_45[row + col] = flag_135[n - 1 + col - row] = 0; nQueens[row][col] = &apos;Q&apos;; solveNQueens(res, nQueens, flag_col, flag_45, flag_135, row + 1, n); nQueens[row][col] = &apos;.&apos;; flag_col[col] = flag_45[row + col] = flag_135[n - 1 + col - row] = 1; &#125; &#125;&#125;; But we actually do not need to use three arrays, we just need one. Now, when reach [row, col], the subscript of column is col, the subscript of 45° diagonal is n + row + col and the subscript of 135° diagonal is n + 2 * n - 1 + n - 1 + col - row. 123456789101112131415161718192021222324252627282930class Solution &#123;public: std::vector&lt;std::vector&lt;std::string&gt; &gt; solveNQueens(int n) &#123; std::vector&lt;std::vector&lt;std::string&gt; &gt; res; std::vector&lt;std::string&gt; nQueens(n, std::string(n, &apos;.&apos;)); /* flag[0] to flag[n - 1] to indicate if the column had a queen before. flag[n] to flag[3 * n - 2] to indicate if the 45° diagonal had a queen before. flag[3 * n - 1] to flag[5 * n - 3] to indicate if the 135° diagonal had a queen before. */ std::vector&lt;int&gt; flag(5 * n - 2, 1); solveNQueens(res, nQueens, flag, 0, n); return res; &#125;private: void solveNQueens(std::vector&lt;std::vector&lt;std::string&gt; &gt; &amp;res, std::vector&lt;std::string&gt; &amp;nQueens, std::vector&lt;int&gt; &amp;flag, int row, int &amp;n) &#123; if (row == n) &#123; res.push_back(nQueens); return; &#125; for (int col = 0; col != n; ++col) if (flag[col] &amp;&amp; flag[n + row + col] &amp;&amp; flag[4 * n - 2 + col - row]) &#123; flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 0; nQueens[row][col] = &apos;Q&apos;; solveNQueens(res, nQueens, flag, row + 1, n); nQueens[row][col] = &apos;.&apos;; flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 1; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/4007/accepted-auxillary-space-o-n-using-dfs-cpp Accepted : auxillary space O(n) , using dfs , cpp Space complexity : Instead of using a 2D array to represent the chess board, i am using a 1D array , the index of which would represent the row number and the value of arr at row index will be the column number for the correct position of the queen. i.e 12Instead of doing arr[row][col]=1i am using arr[row]=col ; where queen is positioned at (row,col); Logic : DFS for every column number ,ranging from 0 to n-1, for all the rows from 0 to n-1 and check the validity of queen position for every row,col combination(using isSafe function) isSafe function : It checks whether the queen in current position(r,c) is being attacked by any of the r-1 queens positioned in row numbers 0 through r-1. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; public: vector &lt; vector &lt;string&gt; &gt; sol; int limit; vector&lt;string&gt; toChessString(vector&lt;int&gt; arr) &#123; string s(arr.size(),&apos;.&apos;); vector&lt;string&gt; ans(arr.size(),s); for(int i=0 ; i&lt;arr.size() ; i++) ans[i][arr[i]]=&apos;Q&apos;; return ans; &#125; bool isSafe(vector&lt;int&gt; arr, int r , int c ) &#123; int check; for(int row=r-1,ldia=c-1,rdia=c+1 ; row&gt;=0 ; row--,ldia--,rdia++) &#123; check=arr[row]; if(check==c || check==ldia || check==rdia) return false; &#125; return true; &#125; void solveNqueen(vector&lt;int&gt; arr , int r , int c) &#123; if(r==limit) sol.push_back(toChessString(arr)); else &#123; for(int col=c ; col&lt;limit ; col++) &#123; arr[r]=col; if(isSafe(arr,r,col)) solveNqueen(arr,r+1,0); &#125; &#125; &#125; vector&lt;vector&lt;string&gt; &gt; solveNQueens(int n) &#123; vector&lt;int&gt; arr(n,0); limit=n; solveNqueen(arr,0,0); return sol; &#125; &#125;; https://discuss.leetcode.com/topic/7644/c-6ms-solution-use-bitmask C++ 6ms solution use bitmask 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; int n; string getNq(int p) &#123; string s(n, &apos;.&apos;); s[p] = &apos;Q&apos;; return s; &#125; void nQueens(int p, int l, int m, int r, vector&lt;vector&lt;string&gt;&gt; &amp;res) &#123; static vector&lt;string&gt; ans; if (p &gt;= n) &#123; res.push_back(ans); return ; &#125; int mask = l | m | r; for (int i = 0, b = 1; i &lt; n; ++ i, b &lt;&lt;= 1) if (!(mask &amp; b)) &#123; ans.push_back(getNq(i)); nQueens(p + 1, (l | b) &gt;&gt; 1, m | b, (r | b) &lt;&lt; 1, res); ans.pop_back(); &#125; &#125;public: vector&lt;vector&lt;string&gt; &gt; solveNQueens(int n) &#123; this-&gt;n = n; vector&lt;vector&lt;string&gt;&gt; res; nQueens(0, 0, 0, 0, res); return res; &#125;&#125;; python 108ms, 77.32%, June.16th, 2016 https://leetcode.com/discuss/49179/fast-short-and-easy-understand-python-solution-11-lines-76ms Fast, short, and easy-to-understand python solution, 11 lines, 76ms ideas: Use the DFS helper function to find solutions recursively. A solution will be found when the length of queens is equal to n ( queens is a list of the indices of the queens). In this problem, whenever a location (x, y) is occupied, any other locations (p, q ) where p + q == x + y or p - q == x - y would be invalid. We can use this information to keep track of the indicators (xy_dif and xy_sum ) of the invalid positions and then call DFS recursively with valid positions only. At the end, we convert the result (a list of lists; each sublist is the indices of the queens) into the desire format. 123456789101112def solveNQueens(self, n): def DFS(queens, xy_dif, xy_sum): p = len(queens) if p==n: result.append(queens) return None for q in range(n): if q not in queens and p-q not in xy_dif and p+q not in xy_sum: DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q]) result = [] DFS([],[],[]) return [ [&quot;.&quot;*i + &quot;Q&quot; + &quot;.&quot;*(n-i-1) for i in sol] for sol in result] https://discuss.leetcode.com/topic/9445/14-lines-python-code-dfs-solution 14 lines python code, DFS solution 1234567891011121314class Solution:# @return a list of lists of stringdef solveNQueens(self, n): stack, res = [[(0, i)] for i in range(n)], [] while stack: board = stack.pop() row = len(board) if row == n: res.append([&apos;&apos;.join(&apos;Q&apos; if i == c else &apos;.&apos; for i in range(n)) for r, c in board]) for col in range(n): if all(col != c and abs(row-r) != abs(col-c)for r, c in board): stack.append(board+[(row, col)]) return res https://discuss.leetcode.com/topic/22293/python-recursive-dfs-solution-with-comments Python recursive dfs solution with comments 123456789101112131415161718192021222324def solveNQueens(self, n): res = [] self.dfs([-1]*n, 0, [], res) return res # nums is a one-dimension array, like [1, 3, 0, 2] means# first queen is placed in column 1, second queen is placed# in column 3, etc.def dfs(self, nums, index, path, res): if index == len(nums): res.append(path) return # backtracking for i in xrange(len(nums)): nums[index] = i if self.valid(nums, index): # pruning tmp = &quot;.&quot;*len(nums) self.dfs(nums, index+1, path+[tmp[:i]+&quot;Q&quot;+tmp[i+1:]], res)# check whether nth queen can be placed in that columndef valid(self, nums, n): for i in xrange(n): if abs(nums[i]-nums[n]) == n -i or nums[i] == nums[n]: return False return True java https://discuss.leetcode.com/topic/8592/comparably-concise-java-code Comparably concise Java code Hi guys! I didn’t invent a wheel here. We just remember the busy columns and diagonals and recursively try to put the queen into the next row. But I think the code below is short enough to be reproduced in the interview. Hope it helps! 123456789101112131415161718192021222324252627public class Solution &#123; private void helper(int r, boolean[] cols, boolean[] d1, boolean[] d2, String[] board, List&lt;String[]&gt; res) &#123; if (r == board.length) res.add(board.clone()); else &#123; for (int c = 0; c &lt; board.length; c++) &#123; int id1 = r - c + board.length, id2 = 2*board.length - r - c - 1; if (!cols[c] &amp;&amp; !d1[id1] &amp;&amp; !d2[id2]) &#123; char[] row = new char[board.length]; Arrays.fill(row, &apos;.&apos;); row[c] = &apos;Q&apos;; board[r] = new String(row); cols[c] = true; d1[id1] = true; d2[id2] = true; helper(r+1, cols, d1, d2, board, res); cols[c] = false; d1[id1] = false; d2[id2] = false; &#125; &#125; &#125; &#125; public List&lt;String[]&gt; solveNQueens(int n) &#123; List&lt;String[]&gt; res = new ArrayList&lt;&gt;(); helper(0, new boolean[n], new boolean[2*n], new boolean[2*n], new String[n], res); return res; &#125;&#125; https://discuss.leetcode.com/topic/19470/my-easy-understanding-java-solution My easy understanding Java Solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; char[][] board = new char[n][n]; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) board[i][j] = &apos;.&apos;; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); dfs(board, 0, res); return res; &#125; private void dfs(char[][] board, int colIndex, List&lt;List&lt;String&gt;&gt; res) &#123; if(colIndex == board.length) &#123; res.add(construct(board)); return; &#125; for(int i = 0; i &lt; board.length; i++) &#123; if(validate(board, i, colIndex)) &#123; board[i][colIndex] = &apos;Q&apos;; dfs(board, colIndex + 1, res); board[i][colIndex] = &apos;.&apos;; &#125; &#125; &#125; private boolean validate(char[][] board, int x, int y) &#123; for(int i = 0; i &lt; board.length; i++) &#123; for(int j = 0; j &lt; y; j++) &#123; if(board[i][j] == &apos;Q&apos; &amp;&amp; (x + j == y + i || x + y == i + j || x == i)) return false; &#125; &#125; return true; &#125; private List&lt;String&gt; construct(char[][] board) &#123; List&lt;String&gt; res = new LinkedList&lt;String&gt;(); for(int i = 0; i &lt; board.length; i++) &#123; String s = new String(board[i]); res.add(s); &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/24329/share-my-java-dfs-solution-very-easy-to-understand Share my JAVA DFS solution very easy to understand 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; private Set&lt;Integer&gt; col = new HashSet&lt;Integer&gt;(); private Set&lt;Integer&gt; diag1 = new HashSet&lt;Integer&gt;(); private Set&lt;Integer&gt; diag2 = new HashSet&lt;Integer&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); dfs(res,new ArrayList&lt;String&gt;(), 0, n); return res; &#125; private void dfs(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; list, int row, int n)&#123; if (row == n)&#123; res.add(new ArrayList&lt;String&gt;(list)); return; &#125; for (int i = 0; i &lt; n; i++)&#123; if (col.contains(i) || diag1.contains(row + i) || diag2.contains(row - i)) continue; char[] charArray = new char[n]; Arrays.fill(charArray, &apos;.&apos;); charArray[i] = &apos;Q&apos;; String rowString = new String(charArray); list.add(rowString); col.add(i); diag1.add(row + i); diag2.add(row - i); dfs(res, list, row + 1, n); list.remove(list.size() - 1); col.remove(i); diag1.remove(row + i); diag2.remove(row - i); &#125; &#125;&#125; https://discuss.leetcode.com/topic/40881/93-concise-fast-and-clear-java-solution 93% concise, fast, and clear java solution The code has comment. 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; boolean[] //ocp0 = new boolean[n], //whether there&apos;s a queen ocupying nth row, I don&apos;t need it ocp90 = new boolean[n], //whether there&apos;s a queen ocupying nth column ocp45 = new boolean[2 * n - 1], // mark 45 degree occupation ocp135 = new boolean[2 * n - 1]; // mark 135 degree occupation List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;List&lt;String&gt;&gt;(); char[][] map = new char[n][n]; for (char[] tmp : map) Arrays.fill(tmp, &apos;.&apos;); //init solve(0, n, map, ans, ocp45, ocp90, ocp135); return ans; &#125; private void solve(int depth, int n, char[][] map, List&lt;List&lt;String&gt;&gt; ans, boolean[] ocp45, boolean[] ocp90, boolean[] ocp135) &#123; if (depth == n) &#123; addSolution(ans, map); return; &#125; for (int j = 0; j &lt; n; j++) if (!ocp90[j] &amp;&amp; !ocp45[depth + j] &amp;&amp; !ocp135[j - depth + n - 1]) &#123; ocp90[j] = true; ocp45[depth + j] = true; ocp135[j - depth + n - 1] = true; map[depth][j] = &apos;Q&apos;; solve(depth + 1, n, map, ans, ocp45, ocp90, ocp135); ocp90[j] = false; ocp45[depth + j] = false; ocp135[j - depth + n - 1] = false; map[depth][j] = &apos;.&apos;; &#125; &#125; private void addSolution(List&lt;List&lt;String&gt;&gt; ans, char[][] map) &#123; List&lt;String&gt; cur = new ArrayList&lt;String&gt;(); for (char[] i : map) cur.add(String.valueOf(i)); ans.add(cur); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[050. Pow(x, n)]]></title>
    <url>%2Fp%2Ff4cb4bf8%2F</url>
    <content type="text"><![CDATA[26.3% https://leetcode.com/problems/powx-n/ Implement pow(x, n). 解法如下： https://discuss.leetcode.com/topic/21837/5-different-choices-when-talk-with-interviewers After reading some good sharing solutions, I’d like to show them together. You can see different ideas in the code. nest myPow 1234567double myPow(double x, int n) &#123; if(n&lt;0) return 1/x * myPow(1/x, -(n+1)); if(n==0) return 1; if(n==2) return x*x; if(n%2==0) return myPow( myPow(x, n/2), 2); else return x*myPow( myPow(x, n/2), 2);&#125; double myPow 123456double myPow(double x, int n) &#123; if(n==0) return 1; double t = myPow(x,n/2); if(n%2) return n&lt;0 ? 1/x*t*t : x*t*t; else return t*t;&#125; double x 12345678double myPow(double x, int n) &#123; if(n==0) return 1; if(n&lt;0)&#123; n = -n; x = 1/x; &#125; return n%2==0 ? myPow(x*x, n/2) : x*myPow(x*x, n/2);&#125; iterative one 1234567891011121314double myPow(double x, int n) &#123; if(n==0) return 1; if(n&lt;0) &#123; n = -n; x = 1/x; &#125; double ans = 1; while(n&gt;0)&#123; if(n&amp;1) ans *= x; x *= x; n &gt;&gt;= 1; &#125; return ans;&#125; bit operation https://discuss.leetcode.com/topic/3636/my-answer-using-bit-operation-c-implementation In bit format and for a unsigned number, the number is represented as k02^0 + k12^1 + … +k31 2 ^31. Therefore, once we know the pow(x,2^0), pow(x,2^1), …, pow(x,2^31), we can get pow(x,n). And pow(x,2 ^ m) can be constructed easily as pow(x,2^m) = pow(x,2^(m-1)) pow(x,2^(m-1)). 123456789101112131415161718192021class Solution &#123;public: double pow(double x, int n) &#123; if(n&lt;0)&#123; x = 1.0/x; n = -n; &#125; int unsigned m = n; double tbl[32] = &#123;0&#125;; double result = 1; tbl[0] = x; for(int i=1;i&lt;32;i++)&#123; tbl[i] = tbl[i-1]*tbl[i-1]; &#125; for(int i=0;i&lt;32;i++)&#123; if( m &amp; (0x1&lt;&lt;i) ) result *= tbl[i]; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/17832/non-recursive-c-log-n-solution 1234567891011121314151617181920class Solution &#123;public: double myPow(double x, int n) &#123; double ans = 1; unsigned long long p; if (n &lt; 0) &#123; p = -n; x = 1 / x; &#125; else &#123; p = n; &#125; while (p) &#123; if (p &amp; 1) ans *= x; x *= x; p &gt;&gt;= 1; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/10572/8-lines-of-c-7-ms 123456789double pow(double x, int n) &#123; if (n==0) return 1; double t = pow(x,n/2); if (n%2) &#123; return n&lt;0 ? 1/x*t*t : x*t*t; &#125; else &#123; return t*t; &#125;&#125; python https://discuss.leetcode.com/topic/15630/shortest-python-guaranteed Surprisingly, I can just use Python’s existing pow like this: 12class Solution: myPow = pow That’s even shorter than the other more obvious “cheat”: 123class Solution: def myPow(self, x, n): return x ** n And to calm down the haters, here’s me “doing it myself”: Recursive: 123456789class Solution: def myPow(self, x, n): if not n: return 1 if n &lt; 0: return 1 / self.myPow(x, -n) if n % 2: return x * self.myPow(x, n-1) return self.myPow(x*x, n/2) Iterative: 123456789101112class Solution: def myPow(self, x, n): if n &lt; 0: x = 1 / x n = -n pow = 1 while n: if n &amp; 1: pow *= x x *= x n &gt;&gt;= 1 return pow java https://discuss.leetcode.com/topic/5425/short-and-easy-to-understand-solution 1234567891011public class Solution &#123; public double pow(double x, int n) &#123; if(n == 0) return 1; if(n&lt;0)&#123; n = -n; x = 1/x; &#125; return (n%2 == 0) ? pow(x*x, n/2) : x*pow(x*x, n/2); &#125;&#125; https://discuss.leetcode.com/topic/2836/o-logn-solution-in-java /* This is a simple solution based on divide and conquer */ 1234567891011121314151617public class Solution &#123; public double pow(double x, int m) &#123; double temp=x; if(m==0) return 1; temp=pow(x,m/2); if(m%2==0) return temp*temp; else &#123; if(m &gt; 0) return x*temp*temp; else return (temp*temp)/x; &#125; &#125; https://discuss.leetcode.com/topic/40546/iterative-log-n-solution-with-clear-explanation I couldn’t find a clear explanation for an interative Log(n) solution so here’s mine. The basic idea is to decompose the exponent into powers of 2, so that you can keep dividing the problem in half. For example, lets say N = 9 = 2^3 + 2^0 = 1001 in binary. Then: x^9 = x ^ (2 ^ 3) * x ^ (2 ^ 0) We can see that every time we encounter a 1 in the binary representation of N, we need to multiply the answer with x^(2^i) where i is the ith bit of the exponent. Thus, we can keep a running total of repeatedly squaring x - (x, x^2, x^4, x^8, etc) and multiply it by the answer when we see a 1. To handle the case where N=INTEGER_MIN we use a long (64-bit) variable. Below is solution: 123456789101112public class Solution &#123; public double MyPow(double x, int n) &#123; double ans = 1; long absN = Math.Abs((long)n); while(absN &gt; 0) &#123; if((absN&amp;1)==1) ans *= x; absN &gt;&gt;= 1; x *= x; &#125; return n &lt; 0 ? 1/ans : ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[049. Group Anagrams]]></title>
    <url>%2Fp%2F6810cb45%2F</url>
    <content type="text"><![CDATA[35.2% https://leetcode.com/problems/group-anagrams/description/ Given an array of strings, group anagrams together. 12345678For example, given: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;], Return:[ [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lower-case. 方法一： 排序号的str作为key，相应的队伍作为value的vector，然后map迭代器把这些都合并就可以了。 我的代码实现： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; vector&lt;vector&lt;string&gt;&gt; res; // 用vector&lt;string&gt; 而不是vector&lt;string&gt;() // 使用排序好string作为key unordered_map&lt;string, vector&lt;string&gt;&gt; map; for(auto str: strs)&#123; string key = helper(str); // 不管有没有key，都push_back map[key].push_back(str); &#125; // 学习map的迭代器的使用 for(auto it=map.begin(); it!=map.end(); it++)&#123; res.push_back(it-&gt;second); &#125; return res; &#125; string helper(string s)&#123; if(s.empty()) return s; int n = s.size(); vector&lt;int&gt; cnt(26, 0); for(int i=0; i&lt;n; i++) cnt[s[i]-'a']++; string t(n, 'a'); int p = 0; for(int i=0; i&lt;26; i++)&#123; for(int j=0; j&lt;cnt[i]; j++)&#123; t[p++] += i; &#125; &#125; return t; &#125;&#125;; https://discuss.leetcode.com/topic/307/what-does-it-mean-return-all-groups-but-the-return-result-is-vector-string-how-can-we-return-all-groups What does it mean “return all groups”? But the return result is vector? How can we return all groups? What does it mean “return all groups”? But the return result is vector? How can we return all groups? I mean, for example, we have such vector [“dog”,”cat”,”god”,”tac”]. What should I return? https://discuss.leetcode.com/topic/307/what-does-it-mean-return-all-groups-but-the-return-result-is-vector-string-how-can-we-return-all-groups/2 1337c0d3rReputation: 1,607UPDATE: The return type had been changed to a list of list to avoid confusion. An example would be [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”], return: 12345[ [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note that even a single word is included as a group containing a single element. And here is the original old post: It means return all group of anagrams being flatten into one single list. For the input [“dog”,”cat”,”god”,”tac”], it should return: [“dog”,”cat”,”god”,”tac”], as dog and god are one group of anagrams, and cat and tac are another group of anagrams. I will probably change the return format to a more intuitive manner sometime in the future, such as: 1234[ [&quot;dog&quot;, &quot;god&quot;], [&quot;cat&quot;, &quot;tac&quot;]] Until this change happens, you will have to deal with the slightly confusing way of returning a flatten list, which should not affect the algorithm itself. https://discuss.leetcode.com/topic/8269/why-not-list-of-list-of-strings-as-output Why not list of list of strings as output? Why the output is list and not a list of list. What If there are multiple groups of anagrams? cpp 68ms, 79.37%, September 21, 2016 https://discuss.leetcode.com/topic/21038/10-lines-76ms-easy-c-solution-updated-function-signature 10-lines 76ms Easy C++ Solution (Updated Function Signature) The function signature has been updated to return a more intuitive vector&lt;vector&gt; which treats a single string as a group of anagrams consisting of only itself. The idea is to use an unordered_map to store those strings that are anagrams. We use the sorted string as the key and the string itself as the value. The strings are stored in a multiset since there may be duplicates. Moreover, multiset will sort them by default as we desire. The code is as follows. 1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, multiset&lt;string&gt;&gt; mp; for (string s : strs) &#123; string t = s; sort(t.begin(), t.end()); mp[t].insert(s); &#125; vector&lt;vector&lt;string&gt;&gt; anagrams; for (auto m : mp) &#123; vector&lt;string&gt; anagram(m.second.begin(), m.second.end()); anagrams.push_back(anagram); &#125; return anagrams; &#125;&#125;; Update: as suggested by yswu1234 in the answer, general sort takes O(nlogn) time. In this problem, since the string only contains lower-case alphabets, we can write a sorting function using counting sort (O(n) time) to speed up the sorting process. I write a string sorting function strSort below and using it to sort the string achieves the overall running time 72ms for this problem. 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, multiset&lt;string&gt;&gt; mp; for (string s : strs) &#123; string t = strSort(s); mp[t].insert(s); &#125; vector&lt;vector&lt;string&gt;&gt; anagrams; for (auto m : mp) &#123; vector&lt;string&gt; anagram(m.second.begin(), m.second.end()); anagrams.push_back(anagram); &#125; return anagrams; &#125;private: string strSort(string&amp; s) &#123; int count[26] = &#123;0&#125;, n = s.length(); for (int i = 0; i &lt; n; i++) count[s[i] - &apos;a&apos;]++; int p = 0; string t(n, &apos;a&apos;); for (int j = 0; j &lt; 26; j++) for (int i = 0; i &lt; count[j]; i++) t[p++] += j; return t; &#125; &#125;; https://discuss.leetcode.com/topic/6053/sharing-my-very-concise-solution-with-explanation Sharing my very concise solution with explanation 1234567891011121314151617vector&lt;string&gt; anagrams(vector&lt;string&gt; &amp;strs) &#123; vector&lt;string&gt; result; vector&lt;string&gt; sortedStrs = strs; unordered_map&lt;string, vector&lt;int&gt;&gt; map; for(int i = 0; i &lt; strs.size(); i++)&#123; sort(sortedStrs[i].begin(), sortedStrs[i].end()); map[sortedStrs[i]].push_back(i); &#125; for(auto it = map.begin(); it != map.end(); it++)&#123; if(it-&gt;second.size() &gt; 1)&#123; for(int i = 0; i &lt; it-&gt;second.size(); i++)&#123; result.push_back(strs[it-&gt;second[i]]); &#125; &#125; &#125; return result;&#125; Here is basic idea for this problem. First, get a copy of “strs”. Let’s name this copy “sortedStrs”. Second, sort all strings in “sortedStrs”. And we have a hash map unordered_map&lt;string, vector&gt; map. Every string in “sortedStrs” will be recorded in this hash map with its position. In the second loop, we traverse this hash map. And find each value of which size is larger than 1. Then find the original string in “strs”. Done. https://discuss.leetcode.com/topic/26074/a-clean-c-solution-with-unordered_map A clean c++ solution with unordered_map vector&lt;vector&gt; groupAnagrams(vector&amp; strs) { 1234567891011121314unordered_map&lt;string, vector&lt;string&gt;&gt; count; int i = 0; for (auto s : strs) &#123; sort(s.begin(), s.end()); count[s].push_back(strs[i++]); &#125; vector&lt;vector&lt;string&gt;&gt; res; for (auto n : count)&#123; sort(n.second.begin(), n.second.end()); res.push_back(n.second); &#125; return res;&#125; python https://discuss.leetcode.com/topic/3297/2-line-python-solution-ac-with-350ms-some-useful-python-tricks 2-line Python solution, AC with 350ms (some useful Python tricks) 123def anagrams(self, strs): count = collections.Counter([tuple(sorted(s)) for s in strs]) return filter(lambda x: count[tuple(sorted(x))]&gt;1, strs) collections.Counter creates a counter object. A counter object is like a specific kind of dictionary where it is build for counting (objects that hashes to same value) tuple(sorted(s)) is used here so that anagrams will be hashed to the same value. tuple is used because sorted returns a list which cannot be hashed but tuples can be hashed filter: selects some elements of the list based on given function (first argument - a lambda function is given here) lambda function defined here returns True if number of anagrams of that elements is greater than 1 https://discuss.leetcode.com/topic/3297/2-line-python-solution-ac-with-350ms-some-useful-python-tricks/2 Here is another python solution which is 4-line but a little more concise and faster (~ 20ms faster) 12345def anagrams(self, strs): d = collections.defaultdict(list) for s in strs: d[tuple(sorted(s))].append(s) return [a for agram_group in d.values() if len(agram_group)&gt;1 for a in agram_group] collection.defaultdict is used instead of Counter. It is almost same as dict but you can set default value (the value when item is not found in the dictionary) list comprehension is used in the return statement in order to select anagrams which have more than 1 word and also to flatten the d.values() which is list of lists https://discuss.leetcode.com/topic/21052/1-line-ruby-python-for-updated-problem 1 line Ruby/Python for Updated Problem The problem just got updated, now asking for different results. Here are some solutions for the new version. All of them use the sorted string as the group identifier, so for example the words “leetcoder” and “electrode” both have the group identifier “cdeeelort” (or rather an array version of it), which is how I know that they’re anagrams of each other. Python solution 1 Sort and group by group identifier, then sort each group normally. 12def groupAnagrams(self, strs): return [sorted(g) for _, g in itertools.groupby(sorted(strs, key=sorted), sorted)] Or “breaking it down” to maybe make it more readable for beginners and because I just noticed that in Firefox it violates my self-imposed “no scrollbars” rule (I usually use Chrome and didn’t think it differed): 123def groupAnagrams(self, strs): groups = itertools.groupby(sorted(strs, key=sorted), sorted) return [sorted(members) for _, members in groups] Python solution 2 Using defaultdict to collect the groups. 12345def groupAnagrams(self, strs): groups = collections.defaultdict(list) for s in strs: groups[tuple(sorted(s))].append(s) return map(sorted, groups.values()) java 46ms, 4.52%, September 21, 2016 https://discuss.leetcode.com/topic/24494/share-my-short-java-solution Share my short JAVA solution 123456789101112131415public class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; if(strs == null || strs.length == 0) return new ArrayList&lt;List&lt;String&gt;&gt;(); Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); Arrays.sort(strs); for(String s: strs)&#123; char[] ca = s.toCharArray(); Arrays.sort(ca); String keyStr = String.valueOf(ca); if(!map.containsKey(keyStr)) map.put(keyStr, new ArrayList&lt;String&gt;()); map.get(keyStr).add(s); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125; https://discuss.leetcode.com/topic/45639/java-beat-100-use-prime-number Java beat 100%!!! use prime number 12345678910111213141516171819202122public static List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; int[] prime = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103&#125;;//最多10609个z List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (String s : strs) &#123; int key = 1; for (char c : s.toCharArray()) &#123; key *= prime[c - &apos;a&apos;]; &#125; List&lt;String&gt; t; if (map.containsKey(key)) &#123; t = res.get(map.get(key)); &#125; else &#123; t = new ArrayList&lt;&gt;(); res.add(t); map.put(key, res.size() - 1); &#125; t.add(s); &#125; return res; &#125; https://discuss.leetcode.com/topic/12509/o-m-n-algorithm-using-hash-without-sort O(M * N) algorithm using hash, without sort() Assign a prime number for a to z, and then multiply all prime numbers together to form a hash value. 123456789101112131415161718192021222324private static final int[] PRIMES = new int[]&#123;2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107&#125;;public List&lt;String&gt; anagrams(String[] strs) &#123; List&lt;String&gt; list = new LinkedList&lt;&gt;(); Map&lt;Integer, List&lt;String&gt;&gt; mapString = new HashMap&lt;&gt;(); int result = -1; for (int i = 0; i &lt; strs.length; i++)&#123; int mapping = 1; for (int j = 0, max = strs[i].length(); j &lt; max; j++) &#123; mapping *= PRIMES[strs[i].charAt(j) - &apos;a&apos;]; &#125; List&lt;String&gt; strings = mapString.get(mapping); if (strings == null) &#123; strings = new LinkedList&lt;&gt;(); mapString.put(mapping, strings); &#125; strings.add(strs[i]); &#125; for (List&lt;String&gt; mapList : mapString.values())&#123; if (mapList.size() &gt; 1) list.addAll(mapList); &#125; return list;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[048. Rotate Image]]></title>
    <url>%2Fp%2Ff0ab6b95%2F</url>
    <content type="text"><![CDATA[38.5% https://leetcode.com/problems/rotate-image/ You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up: Could you do this in-place? 方法一： https://leetcode.com/discuss/20589/a-common-method-to-rotate-the-image 两次反转，一次上下反转，一次侧着反转 学习revers函数 reverse(matrix.begin(), matrix.end()); A common method to rotate the image here give a common method to solve the image rotation problems. 12345678910111213141516171819202122/* * clockwise rotate * first reverse up to down, then swap the symmetry * 1 2 3 7 8 9 7 4 1 * 4 5 6 =&gt; 4 5 6 =&gt; 8 5 2 * 7 8 9 1 2 3 9 6 3*/void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; reverse(matrix.begin(), matrix.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125;/* * anticlockwise rotate * first reverse left to right, then swap the symmetry * 1 2 3 3 2 1 3 6 9 * 4 5 6 =&gt; 6 5 4 =&gt; 2 5 8 * 7 8 9 9 8 7 1 4 7*/ 1234567void anti_rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; for (auto vi : matrix) reverse(vi.begin(), vi.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125; 我的代码实现： 12345678910111213141516171819class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix.size()==0 || matrix[0].size()==0) return; int n = matrix.size(); if(n==1) return; for(int i=0; i&lt;(n+1)/2; i++)&#123; for(int j=0; j&lt;n; j++)&#123; swap(matrix[i][j], matrix[n-1-i][j]); &#125; &#125; for(int i=0; i&lt;n; i++)&#123; for(int j=i+1; j&lt;n; j++) swap(matrix[i][j], matrix[j][i]); &#125; return; &#125;&#125;; cpp 6ms, 7.71%, June.17th, 2016 https://leetcode.com/discuss/20589/a-common-method-to-rotate-the-image A common method to rotate the image here give a common method to solve the image rotation problems. 12345678910111213141516171819202122/* * clockwise rotate * first reverse up to down, then swap the symmetry * 1 2 3 7 8 9 7 4 1 * 4 5 6 =&gt; 4 5 6 =&gt; 8 5 2 * 7 8 9 1 2 3 9 6 3*/void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; reverse(matrix.begin(), matrix.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125;/* * anticlockwise rotate * first reverse left to right, then swap the symmetry * 1 2 3 3 2 1 3 6 9 * 4 5 6 =&gt; 6 5 4 =&gt; 2 5 8 * 7 8 9 9 8 7 1 4 7*/ 1234567void anti_rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; for (auto vi : matrix) reverse(vi.begin(), vi.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125; https://discuss.leetcode.com/topic/20921/4ms-few-lines-c-code-rotate-image-90-degree-for-o-1-space 4ms few lines C++ code Rotate Image 90 degree for O(1) space 1234567891011121314void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); int a = 0; int b = n-1; while(a&lt;b)&#123; for(int i=0;i&lt;(b-a);++i)&#123; swap(matrix[a][a+i], matrix[a+i][b]); swap(matrix[a][a+i], matrix[b][b-i]); swap(matrix[a][a+i], matrix[b-i][a]); &#125; ++a; --b; &#125; &#125; https://discuss.leetcode.com/topic/17645/6-lines-of-code-and-with-o-1-space-in-c 6 lines of code and with O(1) space in c++ First we transpose the matrix and then reverse every row: 12345678910void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; m) &#123; int n = m.size(); for(int i=0; i&lt;n; i++) for(int j=0; j&lt;i; j++) swap(m[i][j], m[j][i]); for(int i=0; i&lt;n; i++) reverse(m[i].begin(), m[i].end()); &#125; https://discuss.leetcode.com/topic/5564/share-my-inplace-solution Share my inplace solution 123456789101112131415161718192021class Solution &#123;public: //fold for the middle, fold for the diagnal void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; //find middle int mid = matrix.size()/2; int n = matrix.size(); //swap, i swap with matrix.size()-1-i for(int i = 0; i &lt; mid; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; swap(matrix[i][j], matrix[n-1-i][j]); &#125; &#125; //swap, i,j swap with j,i for(int i = 0; i &lt; n; i++)&#123; for(int j = i; j &lt; n; j++)&#123; swap(matrix[i][j], matrix[j][i]); &#125; &#125; &#125;&#125;; Fold matrix once to the middle line. Fold matrix one more time along the diagonal line. python https://discuss.leetcode.com/topic/15295/seven-short-solutions-1-to-7-lines Seven Short Solutions (1 to 7 lines) While these solutions are Python, I think they’re understandable/interesting for non-Python coders as well. But before I begin: No mathematician would call a matrix matrix, so I’ll use the usual A. Also, btw, the 40 ms reached by two of the solutions is I think the fastest achieved by Python solutions so far. Most Pythonic - [::-1] and zip - 44 ms The most pythonic solution is a simple one-liner using [::-1] to flip the matrix upside down and then zip to transpose it. It assigns the result back into A, so it’s “in-place” in a sense and the OJ accepts it as such, though some people might not. 123class Solution: def rotate(self, A): A[:] = zip(*A[::-1]) Most Direct - 52 ms A 100% in-place solution. It even reads and writes each matrix element only once and doesn’t even use an extra temporary variable to hold them. It walks over the “top-left quadrant” of the matrix and directly rotates each element with the three corresponding elements in the other three quadrants. Note that I’m moving the four elements in parallel and that [~ i] is way nicer than [n-1-i]. 1234567class Solution: def rotate(self, A): n = len(A) for i in range(n/2): for j in range(n-n/2): A[i][j], A[~j][i], A[~i][~j], A[j][~i] = \ A[~j][i], A[~i][~j], A[j][~i], A[i][j] Clean Most Pythonic - 56 ms While the OJ accepts the above solution, the the result rows are actually tuples, not lists, so it’s a bit dirty. To fix this, we can just apply list to every row: 123class Solution: def rotate(self, A): A[:] = map(list, zip(*A[::-1])) List Comprehension - 60 ms If you don’t like zip, you can use a nested list comprehension instead: 123class Solution: def rotate(self, A): A[:] = [[row[i] for row in A[::-1]] for i in range(len(A))] Almost as Direct - 40 ms If you don’t like the little repetitive code of the above “Most Direct” solution, we can instead do each four-cycle of elements by using three swaps of just two elements. 12345678class Solution: def rotate(self, A): n = len(A) for i in range(n/2): for j in range(n-n/2): for _ in &apos;123&apos;: A[i][j], A[~j][i], i, j = A[~j][i], A[i][j], ~j, ~i i = ~j Flip Flip - 40 ms Basically the same as the first solution, but using reverse instead of [::-1] and transposing the matrix with loops instead of zip. It’s 100% in-place, just instead of only moving elements around, it also moves the rows around. 123456class Solution: def rotate(self, A): A.reverse() for i in range(len(A)): for j in range(i): A[i][j], A[j][i] = A[j][i], A[i][j] Flip Flip, all by myself - 48 ms Similar again, but I first transpose and then flip left-right instead of upside-down, and do it all by myself in loops. This one is 100% in-place again in the sense of just moving the elements. 123456789class Solution: def rotate(self, A): n = len(A) for i in range(n): for j in range(i): A[i][j], A[j][i] = A[j][i], A[i][j] for row in A: for j in range(n/2): row[j], row[~j] = row[~j], row[j] java 0ms, 26.51%, June.17th, 2016 https://leetcode.com/discuss/27262/java-in-place-solution-with-explanation-easy-to-understand AC Java in place solution with explanation Easy to understand. The idea was firstly transpose the matrix and then flip it symmetrically. For instance, 1231 2 3 4 5 67 8 9 after transpose, it will be swap(matrix[i][j], matrix[j][i]) 1231 4 72 5 83 6 9 Then flip the matrix horizontally. (swap(matrix[i][j], matrix[i][matrix.length-1-j]) 1237 4 18 5 29 6 3 Hope this helps. 1234567891011121314151617181920public class Solution &#123; public void rotate(int[][] matrix) &#123; for(int i = 0; i&lt;matrix.length; i++)&#123; for(int j = i; j&lt;matrix[0].length; j++)&#123; int temp = 0; temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125; for(int i =0 ; i&lt;matrix.length; i++)&#123; for(int j = 0; j&lt;matrix.length/2; j++)&#123; int temp = 0; temp = matrix[i][j]; matrix[i][j] = matrix[i][matrix.length-1-j]; matrix[i][matrix.length-1-j] = temp; &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/20212/clear-java-solution Clear Java solution 12345678910111213public class Solution &#123;public void rotate(int[][] matrix) &#123; int n=matrix.length; for (int i=0; i&lt;n/2; i++) for (int j=i; j&lt;n-i-1; j++) &#123; int tmp=matrix[i][j]; matrix[i][j]=matrix[n-j-1][i]; matrix[n-j-1][i]=matrix[n-i-1][n-j-1]; matrix[n-i-1][n-j-1]=matrix[j][n-i-1]; matrix[j][n-i-1]=tmp; &#125; &#125;&#125; https://discuss.leetcode.com/topic/25989/a-simple-and-in-place-solution-in-java A Simple and In-Place Solution in Java 123456789101112131415161718192021222324public void rotate(int[][] matrix) &#123; if (matrix == null || matrix.length &lt;= 1) &#123; return; &#125; int n = matrix.length; for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &lt; n; j++) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; int head = 0; int tail = n - 1; while (head &lt; tail) &#123; int temp = matrix[i][head]; matrix[i][head] = matrix[i][tail]; matrix[i][tail] = temp; head++; tail--; &#125; &#125;&#125; For example, if the matrix is: 1 2 3 4 5 6 7 8 9 then after the first for loop, it becomes: 1 4 7 2 5 8 3 6 9 then after the second for loop, it becomes: 7 4 1 8 5 2 9 6 3]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[047. Permutations II]]></title>
    <url>%2Fp%2F94a736fc%2F</url>
    <content type="text"><![CDATA[32.8% https://leetcode.com/problems/permutations-ii/ Given a collection of numbers that might contain duplicates, return all possible unique permutations. 1234567891011For example,[1,1,2] have the following unique permutations:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 方法一： 123456789101112131415161718192021class Solution &#123;public: void recursion(vector&lt;int&gt; nums, int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp; res)&#123; if(i==j-1)&#123; res.push_back(nums); return; &#125; for(int k=i; k&lt;j; k++)&#123; if(i!=k &amp;&amp; nums[i] == nums[k]) continue; swap(nums[i], nums[k]); recursion(nums, i+1, j, res); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; recursion(nums, 0, nums.size(), res); return res; &#125;&#125;; 方法二： 此方法通不过，有疑问 错误样例 Input: [2,2,1,1] Output: [[1,1,2,2],[1,2,1,2],[1,2,2,1],[1,2,2,1],[1,2,1,2],[2,1,1,2],[2,1,2,1],[2,2,1,1],[2,1,2,1],[2,1,1,2],[2,2,1,1]] Expected: [[1,1,2,2],[1,2,1,2],[1,2,2,1],[2,1,1,2],[2,1,2,1],[2,2,1,1]] 12345678910111213141516171819202122class Solution &#123;public: void recursion(vector&lt;int&gt;&amp; nums, int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp; res)&#123; if(i==j-1)&#123; res.push_back(nums); return; &#125; for(int k=i; k&lt;j; k++)&#123; if(i!=k &amp;&amp; nums[i] == nums[k]) continue; swap(nums[i], nums[k]); recursion(nums, i+1, j, res); swap(nums[i], nums[k]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; recursion(nums, 0, nums.size(), res); return res; &#125;&#125;; cpp 23ms, 98.52%, September 21, 2016 https://discuss.leetcode.com/topic/8831/a-simple-c-solution-in-only-20-lines A simple C++ solution in only 20 lines 123456789101112131415161718192021class Solution &#123;public: void recursion(vector&lt;int&gt; nums, int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp; res)&#123; if(i==j-1)&#123; res.push_back(nums); return; &#125; for(int k=i; k&lt;j; k++)&#123; if(i!=k &amp;&amp; nums[i] == nums[k]) continue; swap(nums[i], nums[k]); recursion(nums, i+1, j, res); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; recursion(nums, 0, nums.size(), res); return res; &#125;&#125;; https://discuss.leetcode.com/topic/3194/a-non-recursive-c-implementation-with-o-1-space-cost A non-recursive C++ implementation with O(1) space cost 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permuteUnique(vector&lt;int&gt; &amp;S) &#123; // res.clear(); sort(S.begin(), S.end()); res.push_back(S); int j; int i = S.size()-1; while (1)&#123; for (i=S.size()-1; i&gt;0; i--)&#123; if (S[i-1]&lt; S[i])&#123; break; &#125; &#125; if(i == 0)&#123; break; &#125; for (j=S.size()-1; j&gt;i-1; j--)&#123; if (S[j]&gt;S[i-1])&#123; break; &#125; &#125; swap(S[i-1], S[j]); reverse(S, i, S.size()-1); res.push_back(S); &#125; return res; &#125; void reverse(vector&lt;int&gt; &amp;S, int s, int e)&#123; while (s&lt;e)&#123; swap(S[s++], S[e--]); &#125; &#125; vector&lt;vector&lt;int&gt; &gt; res;&#125;; Basically, assume we have “1234”, the idea is to increase the number in ascending order, so next is “1243”, next is “1324”, and so on. python https://discuss.leetcode.com/topic/32976/9-line-python-solution-with-1-line-to-handle-duplication-beat-99-of-others 9-line python solution with 1 line to handle duplication, beat 99% of others :-) Very similar to Permutation I, see explanations in https://leetcode.com/discuss/19510/my-ac-simple-iterative-java-python-solution. To handle duplication, just avoid inserting a number before any of its duplicates. 12345678910def permuteUnique(self, nums): ans = [[]] for n in nums: new_ans = [] for l in ans: for i in xrange(len(l)+1): new_ans.append(l[:i]+[n]+l[i:]) if i&lt;len(l) and l[i]==n: break #handles duplication ans = new_ans return ans https://discuss.leetcode.com/topic/32976/9-line-python-solution-with-1-line-to-handle-duplication-beat-99-of-others/2 Nice one! Here’s an even shorter and I think faster implementation, though. Got it accepted in 100 ms, achieving the coveted “Your runtime beats 100.00% of python submissions.” (Well, I tried five times, they were 112, 104, 100, 104 and 116 ms). 1234567def permuteUnique(self, nums): ans = [[]] for n in nums: ans = [l[:i]+[n]+l[i:] for l in ans for i in xrange((l+[n]).index(n)+1)] return ans And for fun, a one-liner version: 12def permuteUnique(self, nums): return reduce(lambda a,n:[l[:i]+[n]+l[i:]for l in a for i in xrange((l+[n]).index(n)+1)],nums,[[]]) https://discuss.leetcode.com/topic/7667/iterative-python-solution-without-using-set-111ms Iterative Python solution without using set, 111ms Duplication happens when we insert the duplicated element before and after the same element, to eliminate duplicates, just insert only after the same element. 123456789101112131415def permuteUnique(self, num): if not num: return [] num.sort() ret = [[]] for n in num: new_ret = [] l = len(ret[-1]) for seq in ret: for i in range(l, -1, -1): if i &lt; l and seq[i] == n: break new_ret.append(seq[:i] + [n] + seq[i:]) ret = new_ret return ret java https://discuss.leetcode.com/topic/31445/really-easy-java-solution-much-easier-than-the-solutions-with-very-high-vote Really easy Java solution, much easier than the solutions with very high vote Use an extra boolean array “ boolean[] used” to indicate whether the value is added to list. Sort the array “int[] nums” to make sure we can skip the same value. when a number has the same value with its previous, we can use this number only if his previous is used 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(nums==null || nums.length==0) return res; boolean[] used = new boolean[nums.length]; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Arrays.sort(nums); dfs(nums, used, list, res); return res; &#125; public void dfs(int[] nums, boolean[] used, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res)&#123; if(list.size()==nums.length)&#123; res.add(new ArrayList&lt;Integer&gt;(list)); return; &#125; for(int i=0;i&lt;nums.length;i++)&#123; if(used[i]) continue; if(i&gt;0 &amp;&amp;nums[i-1]==nums[i] &amp;&amp; !used[i-1]) continue; used[i]=true; list.add(nums[i]); dfs(nums,used,list,res); used[i]=false; list.remove(list.size()-1); &#125; &#125;&#125; https://discuss.leetcode.com/topic/5993/share-my-recursive-solution Share my recursive solution 1234567891011121314151617181920212223242526272829public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] num) &#123; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; current = new ArrayList&lt;Integer&gt;(); boolean[] visited = new boolean[num.length]; permute(result, current, num, visited); return result; &#125; private void permute(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; current, int[] num, boolean[] visited) &#123; if (current.size() == num.length) &#123; result.add(new ArrayList&lt;Integer&gt;(current)); return; &#125; for (int i=0; i&lt;visited.length; i++) &#123; if (!visited[i]) &#123; if (i &gt; 0 &amp;&amp; num[i] == num[i-1] &amp;&amp; visited[i-1]) &#123; return; &#125; visited[i] = true; current.add(num[i]); permute(result, current, num, visited); current.remove(current.size()-1); visited[i] = false; &#125; &#125; &#125;&#125; The idea to resolve duplicate is to ensure that for elements with the same value, we make sure that they are picked up in the ascending order of index. To implement this, every time we try to pick up some value, we just check if the previous element has the same value and is visited or not. If so, we just return! https://discuss.leetcode.com/topic/36221/share-my-java-code-with-detailed-explanantion Share my Java code with detailed explanantion 12345678910111213141516171819202122232425262728293031public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (nums==null || nums.length==0) &#123; return ans; &#125; permute(ans, nums, 0); return ans; &#125; private void permute(List&lt;List&lt;Integer&gt;&gt; ans, int[] nums, int index) &#123; if (index == nums.length) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for (int num: nums) &#123; temp.add(num); &#125; ans.add(temp); return; &#125; Set&lt;Integer&gt; appeared = new HashSet&lt;&gt;(); for (int i=index; i&lt;nums.length; ++i) &#123; if (appeared.add(nums[i])) &#123; swap(nums, index, i); permute(ans, nums, index+1); swap(nums, index, i); &#125; &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int save = nums[i]; nums[i] = nums[j]; nums[j] = save; &#125;&#125; https://discuss.leetcode.com/topic/12923/short-iterative-java-solution Short iterative Java solution Hi guys! Here’s an iterative solution which doesn’t use nextPermutation helper. It builds the permutations for i-1 first elements of an input array and tries to insert the ith element into all positions of each prebuilt i-1 permutation. I couldn’t come up with more effective controling of uniqueness than just using a Set. See the code below! 12345678910111213141516171819public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] num) &#123; LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); res.add(new ArrayList&lt;&gt;()); for (int i = 0; i &lt; num.length; i++) &#123; Set&lt;String&gt; cache = new HashSet&lt;&gt;(); while (res.peekFirst().size() == i) &#123; List&lt;Integer&gt; l = res.removeFirst(); for (int j = 0; j &lt;= l.size(); j++) &#123; List&lt;Integer&gt; newL = new ArrayList&lt;&gt;(l.subList(0,j)); newL.add(num[i]); newL.addAll(l.subList(j,l.size())); if (cache.add(newL.toString())) res.add(newL); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[046. Permutations]]></title>
    <url>%2Fp%2Fc83ab0f7%2F</url>
    <content type="text"><![CDATA[42.0% https://leetcode.com/problems/permutations/ Given a collection of distinct numbers, return all possible permutations. 12345678910For example,[1,2,3] have the following permutations:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 方法一：标准的回溯法 剑指offer 28 我的代码实现: 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; dfs(nums, res, 0); return res; &#125; void dfs(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; res, int k)&#123; if(k==nums.size()-1)&#123; res.push_back(nums); return; &#125; for(int i=k; i&lt;nums.size(); i++)&#123; swap(nums[k], nums[i]); dfs(nums, res, k+1); swap(nums[k], nums[i]); &#125; &#125;&#125;; 注意，倒数第三行，参数是begin+1, 不是i+1. permuteRecursive(nums, begin, result); 代表nums中0至begin-1已经排好序了，剩下的是begin至n-1 n = nums.size()-1 所以当begin = n时，则push进去。 然后，begin未排好，从begin开始，begin与后面的都交换一遍 每次交换后，调用permuteRecurive(nums, begin+1, res); 所以逻辑是很清晰的了。 My elegant recursive C++ solution with inline explanation This recursive solution is the my first response for this problem. I was surprised when I found no similar solution posted here. It is much easier to understand than DFS-based ones, at least in my opinion. Please find more explanations here. All comments are welcome. 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; result; permuteRecursive(num, 0, result); return result; &#125; // permute num[begin..end] // invariant: num[0..begin-1] have been fixed/permuted void permuteRecursive(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;result) &#123; if (begin &gt;= num.size()) &#123; // one permutation instance result.push_back(num); return; &#125; for (int i = begin; i &lt; num.size(); i++) &#123; swap(num[begin], num[i]); permuteRecursive(num, begin + 1, result); // reset swap(num[begin], num[i]); &#125; &#125;&#125;; 我的实现 经典回溯法 思考清楚过程 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; res; helper(nums, 0, n, res); return res; &#125; void helper(vector&lt;int&gt;&amp; nums, int k, int n, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(k==n)&#123; res.push_back(nums); return; &#125; for(int i=k; i&lt;n; i++)&#123; swap(nums[k], nums[i]); helper(nums, k+1, n, res); // 此处变为k+1，不是i+1 swap(nums[k], nums[i]); &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/5881/my-elegant-recursive-c-solution-with-inline-explanation My elegant recursive C++ solution with inline explanation This recursive solution is the my first response for this problem. I was surprised when I found no similar solution posted here. It is much easier to understand than DFS-based ones, at least in my opinion. Please find more explanations here. All comments are welcome. 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; result; permuteRecursive(num, 0, result); return result; &#125; // permute num[begin..end] // invariant: num[0..begin-1] have been fixed/permuted void permuteRecursive(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;result) &#123; if (begin &gt;= num.size()) &#123; // one permutation instance result.push_back(num); return; &#125; for (int i = begin; i &lt; num.size(); i++) &#123; swap(num[begin], num[i]); permuteRecursive(num, begin + 1, result); // reset swap(num[begin], num[i]); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/6740/share-my-three-different-solutions Share my three different solutions 1234567891011121314151617181920// method 1: standard backtracing solutionvector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; ans; permutation(num, 0, ans); return ans;&#125;void permutation(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;ans) &#123; if (begin &gt;= num.size()) &#123; ans.push_back(num); return; &#125; // every number chosen to be the begin once for (int i = begin; i &lt; num.size(); ++i) &#123; swap(num[begin], num[i]); permutation(num, begin+1, ans); swap(num[begin], num[i]); &#125;&#125; 12345678910// method 2: using next_permutation to iterate all the permutaionsvector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; ans; sort(num.begin(), num.end()); ans.push_back(num); while(next_permutation(num.begin(), num.end())) ans.push_back(num); return ans;&#125; 12345678910111213141516171819202122232425262728// method 3: recursive dfsvector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; ans; dfs(num, ans); return ans;&#125;void dfs(vector&lt;int&gt; &amp;num, vector&lt;vector&lt;int&gt;&gt; &amp;ans) &#123; if (num.size() == 1) &#123; vector&lt;int&gt; tmp(num.begin(), num.end()); ans.push_back(tmp); return; &#125; vector&lt;vector&lt;int&gt; &gt; ans1; vector&lt;int&gt; num1(num.begin()+1, num.end()); dfs(num1, ans); for(int i = 0; i &lt; ans.size(); ++i) &#123; for(int j = 0; j &lt;= ans[i].size(); ++j) &#123; vector&lt;int&gt; tmp = ans[i]; tmp.insert(tmp.begin()+j, num[0]); ans1.push_back(tmp); &#125; &#125; ans = ans1;&#125; 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; result; permuteRecursive(num, 0, result); return result; &#125; // permute num[begin..end] // invariant: num[0..begin-1] have been fixed/permuted void permuteRecursive(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;result) &#123; if (begin &gt;= num.size()) &#123; // one permutation instance result.push_back(num); return; &#125; for (int i = begin; i &lt; num.size(); i++) &#123; swap(num[begin], num[i]); permuteRecursive(num, begin + 1, result); // reset swap(num[begin], num[i]); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/17277/one-liners-in-python One-Liners in Python Solution 1: Recursive, take any number as first Take any number as the first number and append any permutation of the other numbers. 1234def permute(self, nums): return [[n] + p for i, n in enumerate(nums) for p in self.permute(nums[:i] + nums[i+1:])] or [[]] Solution 2: Recursive, insert first number anywhere Insert the first number anywhere in any permutation of the remaining numbers. 1234def permute(self, nums): return nums and [p[:i] + [nums[0]] + p[i:] for p in self.permute(nums[1:]) for i in range(len(nums))] or [[]] Solution 3: Reduce, insert next number anywhere Use reduce to insert the next number anywhere in the already built permutations. 1234def permute(self, nums): return reduce(lambda P, n: [p[:i] + [n] + p[i:] for p in P for i in range(len(p)+1)], nums, [[]]) Solution 4: Using the library 12def permute(self, nums): return list(itertools.permutations(nums)) That returns a list of tuples, but the OJ accepts it anyway. If needed, I could easily turn it into a list of lists: 12def permute(self, nums): return map(list, itertools.permutations(nums)) 76ms, 93.03%, June.17th, 2016 https://leetcode.com/discuss/51398/simple-python-solution-dfs 12345678910111213141516class Solution(object): def permute(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; res = [] self.dfs(nums, [], res) return res def dfs(self, nums, path, res): if not nums: res.append(path) else: for i in xrange(len(nums)): self.dfs(nums[:i] + nums[i+1:], path+[nums[i]], res) java https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partioning) This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. Subsets : https://leetcode.com/problems/subsets/ 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Subsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Permutations : https://leetcode.com/problems/permutations/ 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/ 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum : https://leetcode.com/problems/combination-sum/ 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum II (can’t reuse same element) : https://leetcode.com/problems/combination-sum-ii/ 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Palindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/ 12345678910111213141516171819202122232425public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list;&#125;public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125;&#125;public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true;&#125; https://discuss.leetcode.com/topic/6377/my-ac-simple-iterative-java-python-solution 123456789My AC simple iterative java/python solutionthe basic idea is, to permute n numbers, we can add the nth number into the resulting List&lt;List&lt;Integer&gt;&gt; from the n-1 numbers, in every possible position.For example, if the input num[] is &#123;1,2,3&#125;: First, add 1 into the initial List&lt;List&lt;Integer&gt;&gt; (let&apos;s call it &quot;answer&quot;).Then, 2 can be added in front or after 1. So we have to copy the List&lt;Integer&gt; in answer (it&apos;s just &#123;1&#125;), add 2 in position 0 of &#123;1&#125;, then copy the original &#123;1&#125; again, and add 2 in position 1. Now we have an answer of &#123;&#123;2,1&#125;,&#123;1,2&#125;&#125;. There are 2 lists in the current answer.Then we have to add 3. first copy &#123;2,1&#125; and &#123;1,2&#125;, add 3 in position 0; then copy &#123;2,1&#125; and &#123;1,2&#125;, and add 3 into position 1, then do the same thing for position 3. Finally we have 2\*3=6 lists in answer, which is what we want. 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (num.length ==0) return ans; List&lt;Integer&gt; l0 = new ArrayList&lt;Integer&gt;(); l0.add(num[0]); ans.add(l0); for (int i = 1; i&lt; num.length; ++i)&#123; List&lt;List&lt;Integer&gt;&gt; new_ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for (int j = 0; j&lt;=i; ++j)&#123; for (List&lt;Integer&gt; l : ans)&#123; List&lt;Integer&gt; new_l = new ArrayList&lt;Integer&gt;(l); new_l.add(j,num[i]); new_ans.add(new_l); &#125; &#125; ans = new_ans; &#125; return ans;&#125; python version is more concise: 123456789def permute(self, nums): perms = [[]] for n in nums: new_perms = [] for perm in perms: for i in xrange(len(perm)+1): new_perms.append(perm[:i] + [n] + perm[i:]) ###insert n perms = new_perms return perms https://discuss.leetcode.com/topic/10812/share-my-short-iterative-java-solution Share my short iterative JAVA solution 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) &#123; LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;List&lt;Integer&gt;&gt;(); res.add(new ArrayList&lt;Integer&gt;()); for (int n : num) &#123; int size = res.size(); for (; size &gt; 0; size--) &#123; List&lt;Integer&gt; r = res.pollFirst(); for (int i = 0; i &lt;= r.size(); i++) &#123; List&lt;Integer&gt; t = new ArrayList&lt;Integer&gt;(r); t.add(i, n); res.add(t); &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/23036/java-clean-code-two-recursive-solutions Java Clean Code - Two recursive solutions Bottom up? approach - 280ms 1234567891011121314151617181920212223242526public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; permutations = new ArrayList&lt;&gt;(); if (nums.length == 0) &#123; return permutations; &#125; collectPermutations(nums, 0, new ArrayList&lt;&gt;(), permutations); return permutations; &#125; private void collectPermutations(int[] nums, int start, List&lt;Integer&gt; permutation, List&lt;List&lt;Integer&gt;&gt; permutations) &#123; if (permutation.size() == nums.length) &#123; permutations.add(permutation); return; &#125; for (int i = 0; i &lt;= permutation.size(); i++) &#123; List&lt;Integer&gt; newPermutation = new ArrayList&lt;&gt;(permutation); newPermutation.add(i, nums[start]); collectPermutations(nums, start + 1, newPermutation, permutations); &#125; &#125;&#125; Code flow 123456789101112131415nums = 1,2,3start = 0, permutation = []i = 0, newPermutation = [1] start = 1, permutation = [1] i = 0, newPermutation = [2, 1] start = 2, permutation = [2, 1] i = 0, newPermutation = [3, 2, 1] i = 1, newPermutation = [2, 3, 1] i = 2, newPermutation = [2, 1, 3] i = 1, newPermutation = [1, 2] start = 2, permutation = [1, 2] i = 0, newPermutation = [3, 1, 2] i = 1, newPermutation = [1, 3, 2] i = 2, newPermutation = [1, 2, 3] Base case and build approach - 524ms 1234567891011121314151617181920212223242526272829public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; return permute(Arrays.stream(nums).boxed().collect(Collectors.toList())); &#125; private List&lt;List&lt;Integer&gt;&gt; permute(List&lt;Integer&gt; nums) &#123; List&lt;List&lt;Integer&gt;&gt; permutations = new ArrayList&lt;&gt;(); if (nums.size() == 0) &#123; return permutations; &#125; if (nums.size() == 1) &#123; List&lt;Integer&gt; permutation = new ArrayList&lt;&gt;(); permutation.add(nums.get(0)); permutations.add(permutation); return permutations; &#125; List&lt;List&lt;Integer&gt;&gt; smallPermutations = permute(nums.subList(1, nums.size())); int first = nums.get(0); for(List&lt;Integer&gt; permutation : smallPermutations) &#123; for (int i = 0; i &lt;= permutation.size(); i++) &#123; List&lt;Integer&gt; newPermutation = new ArrayList&lt;&gt;(permutation); newPermutation.add(i, first); permutations.add(newPermutation); &#125; &#125; return permutations; &#125;&#125; Code flow 12345678910111213141516171819nums = 1,2,3smallPermutations(2, 3) smallPermutations(3) return [[3]] first = 2 permutation = [3] i = 0, newPermutation = [2, 3] i = 1, newPermutation = [3, 2] return [[2, 3], [3, 2]]first = 1 permutation = [2, 3] i = 0, newPermutation = [1, 2, 3] i = 1, newPermutation = [2, 1, 3] i = 2, newPermutation = [2, 3, 1] permutation = [3, 2] i = 0, newPermutation = [1, 3, 2] i = 1, newPermutation = [3, 1, 2] i = 2, newPermutation = [3, 2, 1] 回溯法 https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning1234567891011121314151617181920public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), nums); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums)&#123; if(tempList.size() == nums.length) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i=0; i&lt;nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size()-1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[045. Jump Game II]]></title>
    <url>%2Fp%2Fded0cd97%2F</url>
    <content type="text"><![CDATA[26.2% https://leetcode.com/problems/jump-game-ii/ Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. 123456For example:Given array A = [2,3,1,1,4]The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.) Note: You can assume that you can always reach the last index. 方法一： 我的代码： lastJump，表示经过上一步之后，所能到达最远的点。 nextJump是step++之后，新的一段，能走的最远的点。 1234567891011121314151617class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==1) return 0; int lastJump = 0; int nextJump = 0; int step = 0; for(int i=0; i&lt;nums.size()-1; i++)&#123; nextJump = max(nextJump, i+nums[i]); if(lastJump == i)&#123; step++; lastJump = nextJump; &#125; &#125; return step; &#125;&#125;; my code 12345678910111213141516class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int step = 0; int e = 0; int ma = 0; for(int i=0; i&lt;nums.size()-1; i++)&#123; ma = max(i+nums[i], ma); if(i==e)&#123; step++; e = ma; &#125; &#125; return step; &#125;&#125;; cpp https://discuss.leetcode.com/topic/3191/o-n-bfs-solution O(n), BFS solution I try to change this problem to a BFS problem, where nodes in level i are all the nodes that can be reached in i-1th jump. for example. 2 3 1 1 4 , is 2|| 3 1|| 1 4 || clearly, the minimum jump of 4 is 2 since 4 is in level 3. my ac code. 1234567891011121314int jump(int A[], int n) &#123; if(n&lt;2)return 0; int level=0,currentMax=0,i=0,nextMax=0; while(currentMax-i+1&gt;0)&#123; //nodes count of current level&gt;0 level++; for(;i&lt;=currentMax;i++)&#123; //traverse current level , and update the max reach of next level nextMax=max(nextMax,A[i]+i); if(nextMax&gt;=n-1)return level; // if last element is in level+1, then the min jump=level &#125; currentMax=nextMax; &#125; return 0; &#125; https://leetcode.com/discuss/45992/10-lines-c-16ms-python-bfs-solutions-with-explanations 16ms, 22.73%, June.22th, 2016 10-lines C++ (16ms) / Python BFS Solutions with Explanations This problem has a nice BFS structure. Let’s illustrate it using the example nums = [2, 3, 1, 1, 4] in the problem statement. We are initially at position 0. Then we can move at most nums[0] steps from it. So, after one move, we may reach nums[1] = 3 or nums[2] = 1. So these nodes are reachable in 1 move. From these nodes, we can further move to nums[3] = 1 and nums[4] = 4. Now you can see that the target nums[4] = 4 is reachable in 2 moves. Putting these into codes, we keep two pointers start and end that record the current range of the starting nodes. Each time after we make a move, update start to be end + 1 and end to be the farthest index that can be reached in 1 move from the current [start, end]. To get an accepted solution, it is important to handle all the edge cases. And the following codes handle all of them in a unified way without using the unclean if statements :-) 1234567891011121314151617class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), start = 0, end = 0, step=0; while(end &lt; n - 1)&#123; step++; int maxend = end + 1; for(int i = start; i &lt; end + 1; i++)&#123; if(nums[i] + i &gt;= n - 1) return step; maxend = max(maxend, nums[i] + i); &#125; start = end + 1; end = maxend; &#125; return step; &#125;&#125;; https://discuss.leetcode.com/topic/5810/sharing-my-straightforward-c-solution Sharing my straightforward C++ solution 12345678910111213141516171819int jump(int A[], int n) &#123; if(n == 0)&#123; return 0; &#125; int maxReachPos = A[0]; int curMaxReachPos = A[0]; int curStep = 1; for(int i = 1; i &lt;= min(n, maxReachPos); i++)&#123; curMaxReachPos = max(curMaxReachPos, i + A[i]); if(i == n - 1)&#123; return curStep; &#125; if(i == maxReachPos)&#123; maxReachPos = curMaxReachPos; curStep++; &#125; &#125; return 0;&#125; The variable maxReachPos indicates the farthest reachable position and the variable curMaxReachPos indicates the current farthest reachable position. At the very beginning, both maxReachPos and curMaxReachPos are equal to A[0]. In the For loop, we keep updating curMaxReachPos while i &lt;= maxReachPos. However, if( i == n - 1), we return curStep, which is the minimum step. If i reaches the maxReachPos, we update maxReachPos with curMaxReachPos and increment curStep by one. Finally, if we can’t reach the end point, just return 0. python https://discuss.leetcode.com/topic/11761/easy-python-greedy-solution-with-explanation Easy Python Greedy solution with explanation 123456789101112131415class Solution:# @param A, a list of integers# @return an integerdef jump(self, A): last_max_reach, current_max_reach = 0 , 0 njump , i = 0 , 0 while current_max_reach &lt; len(A)-1: while i &lt;= last_max_reach: current_max_reach = max(i+A[i],current_max_reach) i+=1 if last_max_reach == current_max_reach: return -1 last_max_reach = current_max_reach njump+=1 return njump The basic thoughts underline is a greedy style. Every one more jump, you want to jump as far as possible.In Jump Game I, when you at position i, you care about what is the furthest position could be reached from i th position. but here in Jump Game II, instead you care about what would be the next furthest jump could be made when you could reach as far as ith position from last jump. So you iterate all positions could be reached from last jump till i th position to find it out. https://leetcode.com/discuss/45992/10-lines-c-16ms-python-bfs-solutions-with-explanations 86ms, 29.68%, June.22th, 201612345678910111213141516class Solution(object): def jump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n, start, end, step = len(nums), 0, 0, 0 while end &lt; n - 1: step += 1 maxend = end + 1 for i in range(start, end + 1): if i + nums[i] &gt;= n - 1: return step maxend = max(maxend, i + nums[i]) start, end = end + 1, maxend return step https://leetcode.com/discuss/45992/10-lines-c-16ms-python-bfs-solutions-with-explanations 84ms, 29.68%, June.22th, 2016 12345678910111213141516class Solution(object): def jump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n, start, end, step = len(nums), 0, 0, 0 while end &lt; n - 1: step += 1 maxend = end + 1 for i in range(start, end + 1): maxend = max(maxend, i + nums[i]) if maxend &gt;= n - 1: return step start, end = end + 1, maxend return step java https://discuss.leetcode.com/topic/11408/single-loop-simple-java-solution Single loop simple java solution 12345678910111213public int jump(int[] A) &#123; int step = 0; int e = 0; int max = 0; for(int i=0; i&lt;A.length-1; i++) &#123; max = Math.max(max, i+A[i]); if( i == e ) &#123; step++; e = max; &#125; &#125; return step;&#125; https://discuss.leetcode.com/topic/11408/single-loop-simple-java-solution/2 Very elegant method, but it took me a long time to understand. Some comment for the above: e: longest distance in current minimum step step: minimum steps for reaching e From i to e, even max is changed in a loop, it is reachable in one step. Help it will help : ) https://discuss.leetcode.com/topic/11408/single-loop-simple-java-solution/4 12345678910111213public int jump(int[] A) &#123; int step_count = 0; int last_jump_max = 0; int current_jump_max = 0; for(int i=0; i&lt;A.length-1; i++) &#123; current_jump_max = Math.max(current_jump_max, i+A[i]); if( i == last_jump_max ) &#123; step_count++; last_jump_max = current_jump_max; &#125; &#125; return step_count;&#125; https://discuss.leetcode.com/topic/4069/sharing-my-ac-java-solution Sharing My AC Java Solution Hi All, below is my AC solution: 12345678910111213141516171819public int jump(int[] A) &#123; int maxReach = A[0]; int edge = 0; int minstep = 0; for(int i = 1; i &lt; A.length; i++) &#123; if (i &gt; edge) &#123; minstep += 1; edge = maxReach; if(edge &gt; A.length - 1) return minstep; &#125; maxReach = Math.max(maxReach, A[i] + i); if (maxReach == i): return -1; &#125; return minstep;&#125; When iterate the array, I set an edge for the Search phase, which means that if I exceeds the edge, the minstep must add one and the maxReach will be update. And when the last index is within the range of the edge, output the minstep. [2, 3, 1, 1, 4] First, the edge is 0; Second, after start iterate the array, it exceeds the edge 0 when reaching the A[0] and update the edge to 2; Third, after it reach the A[2], it exceeds the edge 2 and update the new edge to the maxReach 4. Finally, end of the array is inside the edge, output the minstep. https://discuss.leetcode.com/topic/28470/concise-o-n-one-loop-java-solution-based-on-greedy Concise O(n) one loop JAVA solution based on Greedy Explanation The main idea is based on greedy. Let’s say the range of the current jump is [curBegin, curEnd], curFarthest is the farthest point that all points in [curBegin, curEnd] can reach. Once the current point reaches curEnd, then trigger another jump, and set the new curEnd with curFarthest, then keep the above steps, as the following: 1234567891011public int jump(int[] A) &#123; int jumps = 0, curEnd = 0, curFarthest = 0; for (int i = 0; i &lt; A.length - 1; i++) &#123; curFarthest = Math.max(curFarthest, i + A[i]); if (i == curEnd) &#123; jumps++; curEnd = curFarthest; &#125; &#125; return jumps;&#125; https://leetcode.com/discuss/30647/single-loop-simple-java-solution 3ms, 55.57%, June.22th, 2016123456789101112131415public class Solution &#123; public int jump(int[] nums) &#123; int sc = 0; int e = 0; int max = 0; for(int i=0; i&lt;nums.length-1; i++) &#123; max = Math.max(max, i+nums[i]); if( i == e ) &#123; sc++; e = max; &#125; &#125; return sc; &#125; &#125; my code 12345678910111213public class Solution &#123; public int jump(int[] nums) &#123; int step=0, cur=0, max=0; for(int i=0; i&lt;nums.length-1; i++)&#123; max = Math.max(max, i+nums[i]); if(i==cur)&#123; step += 1; cur = max; &#125; &#125; return step; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hard</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[044. Wildcard Matching]]></title>
    <url>%2Fp%2Fbcc0695c%2F</url>
    <content type="text"><![CDATA[20.4% https://leetcode.com/problems/wildcard-matching/ Implement wildcard pattern matching with support for ‘?’ and ‘*‘. 12345678910111213141516&apos;?&apos; Matches any single character.&apos;*&apos; Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;*&quot;) → trueisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;ab&quot;, &quot;?*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → false 方法一: 我的代码实现: 1234567891011121314151617181920212223class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.size(), n = p.size(); if(n==0) return m==0; vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=1; i&lt;=n; i++) dp[0][i] = dp[0][i-1] &amp;&amp; (p[i-1]=='*'); for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) if(p[j-1]!='*') dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]=='?'); else&#123; for(int k=i; k&gt;=0; k--)&#123; dp[i][j] = dp[i][j] || dp[k][j-1]; if(dp[i][j]==true) break; &#125; &#125; return dp[m][n]; &#125;&#125;; 方法二: 我的代码实现: 123456789101112131415161718class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.size(), n = p.size(); if(n==0) return m==0; vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=1; i&lt;=n; i++) dp[0][i] = dp[0][i-1] &amp;&amp; (p[i-1]=='*'); for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) if(p[j-1]!='*') dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]=='?'); else dp[i][j] = dp[i-1][j] || dp[i][j-1]; return dp[m][n]; &#125;&#125;; 更新迭代公式解释： https://discuss.leetcode.com/topic/7266/c-dp-solution/2 Equation 1). means that if p[j-1] is not *, f(i,j) is determined by if s[0:i-2] matches p[0:j-2] and if (s[i-1]==p[j-1] or p[j-1]==’?’). Equation 2). means that if p[j-1] is , f(i,j) is true if either f(i,j-1) is true: s[0:i-1] matches p[0:j-2] and is not used here; or f(i-1,j) is true: s[0:i-2] matches p[0:j-1] and * is used to match s[i-1]. https://discuss.leetcode.com/topic/17901/accepted-c-dp-solution-with-a-trick Accepted C++ DP Solution with a Trick 1312ms, 28.41%, September 22, 2016 Updated: Since the OJ has relaxed the time constraint, the following DP solution is now accepted without the trick :-) Well, so many people has tried to solve this problem using DP. And almost all of them get TLE (if you see a C++ DP solution that gets accepted, please let me know ^_^). Well, this post aims at providing an accpted DP solution which uses a trick to get around the largest test case, insteaed of a solution that is fully correct. So please do not give me down votes for that :-) Let’s briefly summarize the idea of DP. We define the state P[i][j] to be whether s[0..i) matches p[0..j). The state equations are as follows: 121. P[i][j] = P[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;?&apos;), if p[j - 1] != &apos;*&apos;;2. P[i][j] = P[i][j - 1] || P[i - 1][j], if p[j - 1] == &apos;*&apos;. If you feel confused with the second equation, you may refer to this link. There is an explanation in the comments. We optimize the DP code to O(m) space by recording P[i - 1][j - 1] using a single variable pre. The trick to avoid TLE is to hard-code the result for the largest test case by 1if (n &gt; 30000) return false; The complete code is as follows. 123456789101112131415161718192021class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(), n = p.length(); if (n &gt; 30000) return false; // the trick vector&lt;bool&gt; cur(m + 1, false); cur[0] = true; for (int j = 1; j &lt;= n; j++) &#123; bool pre = cur[0]; // use the value before update cur[0] = cur[0] &amp;&amp; p[j - 1] == &apos;*&apos;; for (int i = 1; i &lt;= m; i++) &#123; bool temp = cur[i]; // record the value before update if (p[j - 1] != &apos;*&apos;) cur[i] = pre &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;?&apos;); else cur[i] = cur[i - 1] || cur[i]; pre = temp; &#125; &#125; return cur[m]; &#125;&#125;; 方法三: For those interested in a fully correct solution, this link has a nice Greedy solution. And I have rewritten the code below to fit the new C++ interface (changed from char* to string). 123456789101112131415161718192021222324class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(), n = p.length(); int i = 0, j = 0, asterisk = -1, match; while (i &lt; m) &#123; if (j &lt; n &amp;&amp; p[j] == &apos;*&apos;) &#123; match = i; asterisk = j++; &#125; else if (j &lt; n &amp;&amp; (s[i] == p[j] || p[j] == &apos;?&apos;)) &#123; i++; j++; &#125; else if (asterisk &gt;= 0) &#123; i = ++match; j = asterisk + 1; &#125; else return false; &#125; while (j &lt; n &amp;&amp; p[j] == &apos;*&apos;) j++; return j == n; &#125;&#125;; https://discuss.leetcode.com/topic/21577/my-three-c-solutions-iterative-16ms-dp-180ms-modified-recursion-88ms My three C++ solutions (iterative (16ms) &amp; DP (180ms) &amp; modified recursion (88ms)) The reason that the iterative solution is much faster for this case is we only need to save (and deal with) the positions (iStar for s, jStar for p) of the last “” we met. We only need to do traceback using iStar and jStar and all the previous “” can be ignored since the last “” will cover all the traceback cases for the previous “”.What we need to do are if the current p character is ‘’ (i.e. p[j]==’’), then we update iStar and jStar with the cureent i and j values. iStar/jStar will be used for traceback. Also we do –i to start the depth first search with the case that ‘*’ represents a null string. if p[j]!=’’, then we check if mismatch occurs (i.e. p[j]!=s[i] and p[j]!=’?’), if so we check if we met a ‘’ before (iStar&gt;=0), if not, then we return false since no match can achieve. Otherwise, we traceback to the positions at which the last ‘*’ happens and do the next possible dfs search (i.e. i = iStar++; j = jStar; remember to update iStar too to save the i position to try in the next traceback). The loop will quit when we reach the end of s. At last, we need to skip all the ‘*’ in p to see if we can reach the end of p. if so, match, otherwise mismatch 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool isMatch(string s, string p) &#123; int slen = s.size(), plen = p.size(), i, j, iStar=-1, jStar=-1; for(i=0,j=0 ; i&lt;slen; ++i, ++j) &#123; if(p[j]==&apos;*&apos;) &#123; //meet a new &apos;*&apos;, update traceback i/j info iStar = i; jStar = j; --i; &#125; else &#123; if(p[j]!=s[i] &amp;&amp; p[j]!=&apos;?&apos;) &#123; // mismatch happens if(iStar &gt;=0) &#123; // met a &apos;*&apos; before, then do traceback i = iStar++; j = jStar; &#125; else return false; // otherwise fail &#125; &#125; &#125; while(p[j]==&apos;*&apos;) ++j; return j==plen; &#125;&#125;; A DP solution is also given here. It has O(N^2) time complexity and O(N) space 12345678910111213141516171819class Solution &#123;public: bool isMatch(string s, string p) &#123; int pLen = p.size(), sLen = s.size(), i, j, k, cur, prev; if(!pLen) return sLen == 0; bool matched[2][sLen+1]; fill_n(&amp;matched[0][0], 2*(sLen+1), false); matched[0][0] = true; for(i=1; i&lt;=pLen; ++i) &#123; cur = i%2, prev= 1-cur; matched[cur][0]= matched[prev][0] &amp;&amp; p[i-1]==&apos;*&apos;; if(p[i-1]==&apos;*&apos;) for(j=1; j&lt;=sLen; ++j) matched[cur][j] = matched[cur][j-1] || matched[prev][j]; else for(j=1; j&lt;=sLen; ++j) matched[cur][j] = matched[prev][j-1] &amp;&amp; (p[i-1]==&apos;?&apos; || p[i-1]==s[j-1]) ; &#125; return matched[cur][sLen]; &#125;&#125;; A recursion version. A typical recursion version will give us TLE due to too many unnecessary recursive calls. As we explained, all the traceback recursive calls at the ‘’ we met (except the last ‘’) are unneccessary and should be avoided. In the below version, we use recLevel to track the recursion level (i.e the total ‘’ we met) and we also use curLevel to save the order of ‘’ we currently process. If it is not the last ‘’ we met (i.e if(recLevel&gt;curLevel+1) ), then we will return false directly ( if(recLevel&gt;curLevel+1) return false;) to skip all unneccessary recursion call at the ‘’ before the last ‘*’. 12345678910111213141516171819202122232425262728class Solution &#123;private: bool helper(const string &amp;s, const string &amp;p, int si, int pi, int &amp;recLevel) &#123; int sSize = s.size(), pSize = p.size(), i, curLevel = recLevel; bool first=true; while(si&lt;sSize &amp;&amp; (p[pi]==s[si] || p[pi]==&apos;?&apos;)) &#123;++pi; ++si;&#125; //match as many as possible if(pi == pSize) return si == sSize; // if p reaches the end, return if(p[pi]==&apos;*&apos;) &#123; // if a star is met while(p[++pi]==&apos;*&apos;); //skip all the following stars if(pi&gt;=pSize) return true; // if the rest of p are all star, return true for(i=si; i&lt;sSize; ++i) &#123; // then do recursion if(p[pi]!= &apos;?&apos; &amp;&amp; p[pi]!=s[i]) continue; if(first) &#123;++recLevel; first = false;&#125; if(helper(s, p, i, pi, recLevel)) return true; if(recLevel&gt;curLevel+1) return false; // if the currently processed star is not the last one, return &#125; &#125; return false; &#125;public: bool isMatch(string s, string p) &#123; int recLevel = 0; return helper(s, p, 0, 0, recLevel); &#125;&#125;; https://discuss.leetcode.com/topic/7266/c-dp-solution C++ DP solution It seems that only Greedy solution can pass all test cases (sorry if I omit any DP solution that passes all test cases). My DP solution also fails to pass the s=aaaaaaaaaaaaaa………….. (lots of a’s…). However, despite this very large case my DP solution passes all other cases. The idea is: f(i,j) == whether the first i chars of s match the first j chars of p. The transition equation is: 1231). if(p[j-1]!=&apos;*&apos;) f(i, j) = f(i-1, j-1) &amp;&amp; (s[i-1]==p[j-1] || p[j-1]==&apos;?&apos;)2). if(p[j-1]==&apos;*&apos;) f(i, j) = f(i, j-1) || f(i-1, j) 12345678910111213141516171819202122bool isMatch(const char *s, const char *p) &#123; const int m = strlen(s); const int n = strlen(p); if(m&gt;30000) return false; // to skip the large test case vector&lt;bool&gt; prev(n+1,false); // to save space, just O(n) space is used prev[0]=true; for(int j=1; j&lt;=n; j++) prev[j] = prev[j-1] &amp;&amp; p[j-1]==&apos;*&apos;; for(int i=1; i&lt;=m; i++) &#123; vector&lt;bool&gt; cur(n+1,false); for(int j=1; j&lt;=n; j++) &#123; if(p[j-1]==&apos;*&apos;) &#123; cur[j] = cur[j-1] || prev[j]; &#125; else &#123; cur[j] = prev[j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]==&apos;?&apos;); &#125; &#125; prev = cur; &#125; return prev[n];&#125; 12345678Equation 1). means that if p[j-1] is not *, f(i,j) is determinedby if s[0:i-2] matches p[0:j-2] and if (s[i-1]==p[j-1] orp[j-1]==&apos;?&apos;).Equation 2). means that if p[j-1] is *, f(i,j) is true if eitherf(i,j-1) is true: s[0:i-1] matches p[0:j-2] and * is not usedhere; or f(i-1,j) is true: s[0:i-2] matches p[0:j-1] and * isused to match s[i-1]. my code: 1234567891011121314class Solution &#123;public: bool isMatch(string s, string p) &#123; int m=0, n=0, match=0, startIdx=-1; while(m&lt;s.size())&#123; if(n&lt;p.size() &amp;&amp; (p[n]==&apos;?&apos; || p[n]==s[m]))&#123;m++; n++;&#125; else if(n&lt;p.size() &amp;&amp; p[n]==&apos;*&apos;)&#123;startIdx=n; match=m; n++;&#125; else if(startIdx!=-1)&#123;n=startIdx+1; match++; m=match;&#125; else return false; &#125; while(n&lt;p.size() &amp;&amp; p[n]==&apos;*&apos;) n++; return n==p.size(); &#125;&#125;; python https://discuss.leetcode.com/topic/9350/python-dp-solution Python DP solution 12345678910111213141516class Solution:# @return a booleandef isMatch(self, s, p): length = len(s) if len(p) - p.count(&apos;*&apos;) &gt; length: return False dp = [True] + [False]*length for i in p: if i != &apos;*&apos;: for n in reversed(range(length)): dp[n+1] = dp[n] and (i == s[n] or i == &apos;?&apos;) else: for n in range(1, length+1): dp[n] = dp[n-1] or dp[n] dp[0] = dp[0] and i == &apos;*&apos; return dp[-1] dp[n] means the substring s[:n] if match the pattern i dp[0] means the empty string ‘’ or s[:0] which only match the pattern ‘*’ use the reversed builtin because for every dp[n+1] we use the previous ‘dp’ add Java O(m*n) version code 1234567891011121314151617181920212223public boolean isMatch(String s, String p) &#123; int count = 0; for (char c : p.toCharArray()) &#123; if (c == &apos;*&apos;) count++; &#125; if (p.length() - count &gt; s.length()) return false; boolean[][] dp = new boolean[p.length() + 1][s.length() + 1]; dp[0][0] = true; for (int j = 1; j &lt;= p.length(); j++) &#123; char pattern = p.charAt(j - 1); dp[j][0] = dp[j - 1][0] &amp;&amp; pattern == &apos;*&apos;; for (int i = 1; i &lt;= s.length(); i++) &#123; char letter = s.charAt(i - 1); if (pattern != &apos;*&apos;) &#123; dp[j][i] = dp[j - 1][i - 1] &amp;&amp; (pattern == &apos;?&apos; || pattern == letter); &#125; else dp[j][i] = dp[j][i - 1] || dp[j - 1][i]; &#125; &#125; return dp[p.length()][s.length()];&#125; java http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html 123456789101112131415161718192021Analysis:For each element in sIf *s==*p or *p == ? which means this is a match, then goes to next element s++ p++.If p=='*', this is also a match, but one or many chars may be available, so let us save this *'s position and the matched s position.If not match, then we check if there is a * previously showed up, if there is no *, return false; if there is an *, we set current p to the next element of *, and set current s to the next saved s position.e.g.abed?b*d**a=?, go on, b=b, go on,e=*, save * position star=3, save s position ss = 3, p++e!=d, check if there was a *, yes, ss++, s=ss; p=star+1d=d, go on, meet the end.check the rest element in p, if all are *, true, else false;Note that in char array, the last is NOT NULL, to check the end, use "*p" or "*p=='\0'". https://discuss.leetcode.com/topic/3040/linear-runtime-and-constant-space-solution 60ms, 60.11%, September 22, 2016 1234567891011121314151617181920212223242526public class Solution &#123; public boolean isMatch(String str, String pattern) &#123; int s=0, p=0, match=0, starIdx=-1; while(s&lt;str.length())&#123; if(p&lt;pattern.length() &amp;&amp; (pattern.charAt(p)==&apos;?&apos; || str.charAt(s)==pattern.charAt(p)))&#123; s++; p++; &#125; else if(p&lt;pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;)&#123; starIdx = p; match = s; p++; &#125; else if(starIdx!=-1)&#123; p = starIdx + 1; match++; s = match; &#125; else return false; &#125; while(p&lt;pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;) p++; return p == pattern.length(); &#125;&#125; https://discuss.leetcode.com/topic/3040/linear-runtime-and-constant-space-solution Linear runtime and constant space solution I found this solution from http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html The basic idea is to have one pointer for the string and one pointer for the pattern. This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step. Here is Yu’s elegant solution in C++ 12345678910111213141516171819202122232425bool isMatch(const char *s, const char *p) &#123; const char* star=NULL; const char* ss=s; while (*s)&#123; //advancing both pointers when (both characters match) or (&apos;?&apos; found in pattern) //note that *p will not advance beyond its length if ((*p==&apos;?&apos;)||(*p==*s))&#123;s++;p++;continue;&#125; // * found in pattern, track index of *, only advancing pattern pointer if (*p==&apos;*&apos;)&#123;star=p++; ss=s;continue;&#125; //current characters didn&apos;t match, last pattern pointer was *, current pattern pointer is not * //only advancing pattern pointer if (star)&#123; p = star+1; s=++ss;continue;&#125; //current pattern pointer is not star, last patter pointer was not * //characters do not match return false; &#125; //check for remaining characters in pattern while (*p==&apos;*&apos;)&#123;p++;&#125; return !*p; &#125; Here is my re-write in Java 12345678910111213141516171819202122232425262728293031boolean comparison(String str, String pattern) &#123; int s = 0, p = 0, match = 0, starIdx = -1; while (s &lt; str.length())&#123; // advancing both pointers if (p &lt; pattern.length() &amp;&amp; (pattern.charAt(p) == &apos;?&apos; || str.charAt(s) == pattern.charAt(p)))&#123; s++; p++; &#125; // * found, only advancing pattern pointer else if (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;)&#123; starIdx = p; match = s; p++; &#125; // last pattern pointer was *, advancing string pointer else if (starIdx != -1)&#123; p = starIdx + 1; match++; s = match; &#125; //current pattern pointer is not star, last patter pointer was not * //characters do not match else return false; &#125; //check for remaining characters in pattern while (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;) p++; return p == pattern.length();&#125; my code： 12345678910111213public class Solution &#123; public boolean isMatch(String s, String p) &#123; int m=0, n=0, match=0, startIdx=-1; while(m&lt;s.length())&#123; if(n&lt;p.length() &amp;&amp; (s.charAt(m)==p.charAt(n) || p.charAt(n)==&apos;?&apos;))&#123;m++; n++;&#125; else if(n&lt;p.length() &amp;&amp; p.charAt(n)==&apos;*&apos;)&#123;startIdx=n; match=m; n++;&#125; else if(startIdx!=-1)&#123;match++; m=match; n=startIdx+1;&#125; else return false; &#125; while(n&lt;p.length() &amp;&amp; p.charAt(n)==&apos;*&apos;)&#123;n++;&#125; return n==p.length(); &#125;&#125; https://discuss.leetcode.com/topic/22516/my-java-dp-solution-using-2d-table My java DP solution using 2D table 1234567891011121314151617181920212223public class Solution &#123; public boolean isMatch(String s, String p) &#123; boolean[][] match=new boolean[s.length()+1][p.length()+1]; match[s.length()][p.length()]=true; for(int i=p.length()-1;i&gt;=0;i--)&#123; if(p.charAt(i)!=&apos;*&apos;) break; else match[s.length()][i]=true; &#125; for(int i=s.length()-1;i&gt;=0;i--)&#123; for(int j=p.length()-1;j&gt;=0;j--)&#123; if(s.charAt(i)==p.charAt(j)||p.charAt(j)==&apos;?&apos;) match[i][j]=match[i+1][j+1]; else if(p.charAt(j)==&apos;*&apos;) match[i][j]=match[i+1][j]||match[i][j+1]; else match[i][j]=false; &#125; &#125; return match[0][0]; &#125;&#125; https://discuss.leetcode.com/topic/10794/my-java-dp-solution My Java DP Solution At first I cannot pass the the long ‘aaa…’ test case. Then I add more check and pass it. 123456789101112131415161718192021222324252627282930public class Solution &#123; public boolean isMatch(String s, String p) &#123; int m = s.length(), n = p.length(); int count = 0; for (int i = 0; i &lt; n; i++) &#123; if (p.charAt(i) == &apos;*&apos;) count++; &#125; if (count==0 &amp;&amp; m != n) return false; else if (n - count &gt; m) return false; boolean[] match = new boolean[m+1]; match[0] = true; for (int i = 0; i &lt; m; i++) &#123; match[i+1] = false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (p.charAt(i) == &apos;*&apos;) &#123; for (int j = 0; j &lt; m; j++) &#123; match[j+1] = match[j] || match[j+1]; &#125; &#125; else &#123; for (int j = m-1; j &gt;= 0; j--) &#123; match[j+1] = (p.charAt(i) == &apos;?&apos; || p.charAt(i) == s.charAt(j)) &amp;&amp; match[j]; &#125; match[0] = false; &#125; &#125; return match[m]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[043. Multiply Strings]]></title>
    <url>%2Fp%2Fd81212f5%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/multiply-strings/ Given two numbers represented as strings, return multiplication of the numbers as a string. Note: The numbers can be arbitrarily large and are non-negative. Converting the input string to integer is NOT allowed. You should NOT use internal library such as BigInteger. cpp 6ms, September 19, 2016 https://discuss.leetcode.com/topic/9449/brief-c-solution-using-only-strings-and-without-reversal Brief C++ solution using only strings and without reversal This is the standard manual multiplication algorithm. We use two nested for loops, working backward from the end of each input number. We pre-allocate our result and accumulate our partial result in there. One special case to note is when our carry requires us to write to our sum string outside of our for loop. At the end, we trim any leading zeros, or return 0 if we computed nothing but zeros. 123456789101112131415161718192021class Solution &#123;public: string multiply(string num1, string num2) &#123; string sum(num1.size() + num2.size(), &apos;0&apos;); for(int i = num1.size()-1; i &gt;= 0; --i)&#123; int carry = 0; for(int j = num2.size() - 1; j&gt;=0; --j)&#123; int tmp = (sum[i+j+1] -&apos;0&apos;) + (num1[i] - &apos;0&apos;)*(num2[j] - &apos;0&apos;) + carry; sum[i+j+1] = tmp%10 + &apos;0&apos;; carry = tmp/10; &#125; sum[i] += carry; &#125; size_t startpos = sum.find_first_not_of(&quot;0&quot;); if(string::npos!=startpos) return sum.substr(startpos); return &quot;0&quot;; &#125;&#125;; https://discuss.leetcode.com/topic/3456/one-easy-solution-with-c One Easy solution with C++ The key part is to use a vector to store all digits REVERSELY. after the calculation, find the rightmost NON-Zero digits and convert it to a string. 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: string multiply(string num1, string num2) &#123; unsigned int l1=num1.size(),l2=num2.size(); if (l1==0||l2==0) return &quot;0&quot;; vector&lt;int&gt; v(l1+l2,0); for (unsigned int i=0;i&lt;l1;i++)&#123; int carry=0; int n1=(int)(num1[l1-i-1]-&apos;0&apos;);//Calculate from rightmost to left for (unsigned int j=0;j&lt;l2;j++)&#123; int n2=(num2[l2-j-1]-&apos;0&apos;);//Calculate from rightmost to left int sum=n1*n2+v[i+j]+carry; carry=sum/10; v[i+j]=sum%10; &#125; if (carry&gt;0) v[i+l2]+=carry; &#125; int start=l1+l2-1; while(v[start]==0) start--; if (start==-1) return &quot;0&quot;; string s=&quot;&quot;; for (int i=start;i&gt;=0;i--) s+=(char)(v[i]+&apos;0&apos;); return s; &#125;&#125;; https://discuss.leetcode.com/topic/8500/very-concise-16-ms-c-solution Very concise 16 ms c++ solution See comments inline for explanation. 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string multiply(string num1, string num2) &#123; int i, j; int m = num1.size(), n = num2.size(); // max (m + n) digits vector&lt;int&gt; product(m + n, 0); string result; // reverse for ease of calc reverse(num1.begin(), num1.end()); reverse(num2.begin(), num2.end()); // digit i * digit j contributes to digit i + j for (i = 0; i &lt; m; i++) &#123; for (j = 0; j &lt; n; j++) &#123; product[i + j] += (num1[i] - &apos;0&apos;) * (num2[j] - &apos;0&apos;); product[i + j + 1] += product[i + j] / 10; product[i + j] %= 10; &#125; &#125; // remove leading 0; keep last 0 if all 0 for (i = m + n - 1; i &gt; 0 &amp;&amp; 0 == product[i]; i--) ; for (; i &gt;= 0; i--) result += to_string(product[i]); return result; &#125;&#125;; python 59ms, September 19, 2016 My solution 12345678class Solution(object): def multiply(self, num1, num2): &quot;&quot;&quot; :type num1: str :type num2: str :rtype: str &quot;&quot;&quot; return str(int(num1)*int(num2)) https://discuss.leetcode.com/topic/20883/simple-python-solution-18-lines Simple Python solution, 18 lines123456789101112131415161718def multiply(num1, num2): product = [0] * (len(num1) + len(num2)) pos = len(product)-1 for n1 in reversed(num1): tempPos = pos for n2 in reversed(num2): product[tempPos] += int(n1) * int(n2) product[tempPos-1] += product[tempPos]/10 product[tempPos] %= 10 tempPos -= 1 pos -= 1 pt = 0 while pt &lt; len(product)-1 and product[pt] == 0: pt += 1 return &apos;&apos;.join(map(str, product[pt:])) java 31ms, September 19, 2016 https://discuss.leetcode.com/topic/30508/easiest-java-solution-with-graph-explanation Easiest JAVA Solution with Graph Explanation Remember how we do multiplication? Start from right to left, perform multiplication on every pair of digits, and add them together. Let’s draw the process! From the following draft, we can immediately conclude: 1`num1[i] * num2[j]` will be placed at indices `[i + j`, `i + j + 1]` Here is my solution. Hope it helps! 123456789101112131415161718192021public class Solution &#123; public String multiply(String num1, String num2) &#123; int m = num1.length(), n = num2.length(); int[] pos = new int[m+n]; for(int i = m-1; i &gt;= 0; i--)&#123; for(int j = n-1; j&gt;=0; j--)&#123; int mul = (num1.charAt(i)-&apos;0&apos;) * (num2.charAt(j) -&apos;0&apos;); int p1 = i+j, p2 = i+j+1; int sum = mul + pos[p2]; pos[p1] += sum/10; pos[p2] = sum % 10; &#125; &#125; StringBuilder sb = new StringBuilder(); for(int p:pos) if(!(sb.length()==0 &amp;&amp; p==0)) sb.append(p); return sb.length() == 0?&quot;0&quot;:sb.toString(); &#125;&#125; https://discuss.leetcode.com/topic/13026/ac-solution-in-java-with-explanation AC solution in Java with explanation 1234567891011121314151617181920212223public class Solution &#123; public String multiply(String num1, String num2) &#123; int n1 = num1.length(), n2 = num2.length(); int[] products = new int[n1 + n2]; for (int i = n1 - 1; i &gt;= 0; i--) &#123; for (int j = n2 - 1; j &gt;= 0; j--) &#123; int d1 = num1.charAt(i) - &apos;0&apos;; int d2 = num2.charAt(j) - &apos;0&apos;; products[i + j + 1] += d1 * d2; &#125; &#125; int carry = 0; for (int i = products.length - 1; i &gt;= 0; i--) &#123; int tmp = (products[i] + carry) % 10; carry = (products[i] + carry) / 10; products[i] = tmp; &#125; StringBuilder sb = new StringBuilder(); for (int num : products) sb.append(num); while (sb.length() != 0 &amp;&amp; sb.charAt(0) == &apos;0&apos;) sb.deleteCharAt(0); return sb.length() == 0 ? &quot;0&quot; : sb.toString(); &#125;&#125; If we break it into steps, it will have the following steps. 1. compute products from each pair of digits from num1 and num2. 2. carry each element over. 3. output the solution. Things to note: The product of two numbers cannot exceed the sum of the two lengths. (e.g. 99 * 99 cannot be five digit) 123int d1 = num1.charAt(i) - &apos;0&apos;;int d2 = num2.charAt(j) - &apos;0&apos;;products[i + j + 1] += d1 * d2; https://discuss.leetcode.com/topic/10757/clear-java-solution-without-reversal Clear JAVA solution without reversal 123456789101112131415161718192021public String multiply(String num1, String num2) &#123; int len1 = num1.length(); int len2 = num2.length(); int[] product = new int[len1 + len2]; for (int i = len1 - 1; i &gt;= 0; i--) &#123; for (int j = len2 - 1; j &gt;= 0; j--) &#123; int index = len1 + len2 - i - j - 2; product[index] += (num1.charAt(i) - &apos;0&apos;) * (num2.charAt(j) - &apos;0&apos;); product[index + 1] += product[index] / 10; product[index] %= 10; &#125; &#125; StringBuilder stringBuilder = new StringBuilder(); for (int i = product.length - 1; i &gt; 0; i--) &#123; if (stringBuilder.length() == 0 &amp;&amp; product[i] == 0) continue; stringBuilder.append(product[i]); &#125; stringBuilder.append(product[0]); return stringBuilder.toString();&#125; https://discuss.leetcode.com/topic/21008/simple-clear-java-solution Simple &amp;&amp; clear java solution 12345678910111213141516171819202122232425public class Solution &#123; public String multiply(String num1, String num2) &#123; int len1 = num1.length(); int len2 = num2.length(); int len = len1 + len2; int[] mul = new int[len]; for (int i = len1 - 1; i &gt;= 0; i--) &#123; int a = num1.charAt(i) - &apos;0&apos;; int k = len2 + i; for (int j = len2 - 1; j &gt;= 0; j--) &#123; int b = num2.charAt(j) - &apos;0&apos;; int c = mul[k] + a * b; mul[k] = c % 10; mul[k - 1] = mul[k - 1] + c /10; k--; &#125; &#125; int i = 0; while(mul[i] == 0 &amp;&amp; i &lt; len - 1) i++; StringBuilder sb = new StringBuilder(); for (; i &lt; len; i++) sb.append(mul[i]); return sb.length() == 0 ? &quot;0&quot; : sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[042. Trapping Rain Water]]></title>
    <url>%2Fp%2F33f3f22a%2F</url>
    <content type="text"><![CDATA[36.7% https://leetcode.com/problems/trapping-rain-water/ Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. 12For example, Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! 方法一： https://discuss.leetcode.com/topic/5125/sharing-my-simple-c-code-o-n-time-o-1-space Sharing my simple c++ code: O(n) time, O(1) space Here is my idea: instead of calculating area by height*width, we can think it in a cumulative way. In other words, sum water amount of each bin(width=1). Search from left to right and maintain a max height of left and right separately, which is like a one-side wall of partial container. Fix the higher one and flow water from the lower part. For example, if current height of left is lower, we fill water in the left bin. Until left meets right, we filled the whole container. 123456789101112131415161718192021class Solution &#123;public: int trap(int A[], int n) &#123; int left=0; int right=n-1; int res=0; int maxleft=0, maxright=0; while(left&lt;=right)&#123; if(A[left]&lt;=A[right])&#123; if(A[left]&gt;=maxleft) maxleft=A[left]; else res+=maxleft-A[left]; left++; &#125; else&#123; if(A[right]&gt;=maxright) maxright= A[right]; else res+=maxright-A[right]; right--; &#125; &#125; return res; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if(n&lt;=1) return 0; int left=0, right=n-1; int maxleft = 0, maxright=0; int res = 0; while(left&lt;right)&#123; if(height[left]&lt;=height[right])&#123; if(height[left]&gt;maxleft) maxleft = height[left]; else res += maxleft - height[left]; left++; &#125;else&#123; if(height[right] &gt; maxright) maxright = height[right]; else res += maxright - height[right]; right--; &#125; &#125; return res; &#125;&#125;; 方法二： 三次遍历。 第一次遍历，查看当前位置i的从左侧看，左侧的挡板的最大值。第二次从右边向左遍历。 第三天遍历，计算当前位置有的水。 https://discuss.leetcode.com/topic/4136/a-different-o-n-approach-easy-to-understand-and-simple-code A different O(n) approach - easy to understand and simple code 123456789101112131415class Solution &#123;public: int trap(int a[], int n) &#123; int i, res = 0; if(!n) return res; vector&lt;int&gt; ltr(n, 0), rtl(n, 0); for(i = 1, ltr[0] = a[0]; i &lt; n; i++) ltr[i] = max(ltr[i-1], a[i]); for(i = n - 2, rtl[n-1] = a[n-1]; i &gt;= 0; i--) rtl[i] = max(rtl[i+1], a[i]); for(i = 0; i &lt; n; i++) res += min(ltr[i], rtl[i]) - a[i]; return res; &#125;&#125;; observation: scan A both from left to right and right to left, record the largest seen during the scan; then for each position the water level should be the min of the 2 large value. 我的代码实现： 12345678910111213141516171819class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if(n&lt;=1) return 0; vector&lt;int&gt; ltr(n, 0); vector&lt;int&gt; rtr(n, 0); int res = 0; ltr[0] = height[0]; for(int i=1; i&lt;n; i++) ltr[i] = max(ltr[i-1], height[i]); rtr[n-1] = height[n-1]; for(int j=n-2; j&gt;=0; j--) rtr[j] = max(rtr[j+1], height[j]); for(int k=0; k&lt;n; k++) res += min(ltr[k], rtr[k]) - height[k]; return res; &#125;&#125;; 官方解答 https://leetcode.com/articles/trapping-rain-water/#approach-3-using-stacks-accepted https://discuss.leetcode.com/topic/18731/7-lines-c-c 7 lines C / C++ Keep track of the already safe level and the total water so far. In each step, process and discard the lower one of the leftmost or rightmost elevation. C Changing the given parameters to discard the lower border. I’m quite fond of this one. 123456789int trap(int* height, int n) &#123; int level = 0, water = 0; while (n--) &#123; int lower = *height &lt; height[n] ? *height++ : height[n]; if (lower &gt; level) level = lower; water += level - lower; &#125; return water;&#125; Slight variation with two pointers (left and right). 123456789int trap(int* height, int n) &#123; int *L = height, *R = L+n-1, level = 0, water = 0; while (L &lt; R) &#123; int lower = *L &lt; *R ? *L++ : *R--; if (lower &gt; level) level = lower; water += level - lower; &#125; return water;&#125; C++ With left and right index. 123456789int trap(vector&lt;int&gt;&amp; height) &#123; int l = 0, r = height.size()-1, level = 0, water = 0; while (l &lt; r) &#123; int lower = height[height[l] &lt; height[r] ? l++ : r--]; level = max(level, lower); water += level - lower; &#125; return water;&#125; With left and right iterator. 12345678910int trap(vector&lt;int&gt;&amp; height) &#123; auto l = height.begin(), r = height.end() - 1; int level = 0, water = 0; while (l != r + 1) &#123; int lower = *l &lt; *r ? *l++ : *r--; level = max(level, lower); water += level - lower; &#125; return water;&#125; python https://discuss.leetcode.com/topic/18720/8-lines-c-c-java-python-solution 8-lines C/C++/Java/Python Solution Note: The following idea is in fact from the last answer in this link, which leads to a clean code. I just reorganize it and add some explanations. I hope it is Ok. The following are four solutions in C/C++/Java/Python respectively. The basic idea is that we set two pointers l and r to the left and right end of height. Then we get the minimum height (minHeight) of these pointers (similar to Container with Most Water due to the Leaking Bucket Effect) since the level of the water cannot be higher than it. Then we move the two pointers towards the center. If the coming level is less than minHeight, then it will hold some water. Fill the water until we meet some “barrier” (with height larger than minHeight) and update l and r to repeat this process in a new interval. C 1234567891011int trap(int* height, int heightSize) &#123; int l = 0, r = heightSize - 1, water = 0, minHeight = 0; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; height[l] &lt;= minHeight) water += minHeight - height[l++]; while (r &gt; l &amp;&amp; height[r] &lt;= minHeight) water += minHeight - height[r--]; minHeight = height[l] &lt;= height[r] ? height[l] : height[r]; &#125; return water;&#125; C++ 1234567891011121314class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(), l = 0, r = n - 1, water = 0, minHeight = 0; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; height[l] &lt;= minHeight) water += minHeight - height[l++]; while (r &gt; l &amp;&amp; height[r] &lt;= minHeight) water += minHeight - height[r--]; minHeight = min(height[l], height[r]); &#125; return water; &#125;&#125;; Java 12345678910111213public class Solution &#123; public int trap(int[] height) &#123; int n = height.length, l = 0, r = n - 1, water = 0, minHeight = 0; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; height[l] &lt;= minHeight) water += minHeight - height[l++]; while (r &gt; l &amp;&amp; height[r] &lt;= minHeight) water += minHeight - height[r--]; minHeight = Math.min(height[l], height[r]); &#125; return water; &#125;&#125; Python 123456789101112131415class Solution: # @param &#123;integer[]&#125; height # @return &#123;integer&#125; def trap(self, height): n = len(height) l, r, water, minHeight = 0, n - 1, 0, 0 while l &lt; r: while l &lt; r and height[l] &lt;= minHeight: water += minHeight - height[l] l += 1 while r &gt; l and height[r] &lt;= minHeight: water += minHeight - height[r] r -= 1 minHeight = min(height[l], height[r]) return water java https://discuss.leetcode.com/topic/3016/share-my-short-solution Share my short solution. Keep track of the maximum height from both forward directions backward directions, call them leftmax and rightmax. 1234567891011121314151617181920public int trap(int[] A)&#123; int a=0; int b=A.length-1; int max=0; int leftmax=0; int rightmax=0; while(a&lt;=b)&#123; leftmax=Math.max(leftmax,A[a]); rightmax=Math.max(rightmax,A[b]); if(leftmax&lt;rightmax)&#123; max+=(leftmax-A[a]); // leftmax is smaller than rightmax, so the (leftmax-A[a]) water can be stored a++; &#125; else&#123; max+=(rightmax-A[b]); b--; &#125; &#125; return max;&#125; 2ms, 20.31%, June.18th, 2016 https://leetcode.com/discuss/18022/sharing-my-java-code-o-n-time-o-1-space 12345678910111213141516171819202122public class Solution &#123; public int trap(int[] height) &#123; if(height.length &lt; 3) return 0; int ans = 0; int l = 0, r = height.length - 1; while(l &lt; r &amp;&amp; height[l] &lt; height[l+1]) l++; while(l &lt; r &amp;&amp; height[r] &lt; height[r-1]) r--; while(l &lt; r)&#123; int left = height[l]; int right = height[r]; if(left &lt;= right)&#123; while(l &lt; r &amp;&amp; left &gt; height[++l]) ans += left - height[l]; &#125;else&#123; while(l &lt; r &amp;&amp; right &gt; height[--r]) ans += right - height[r]; &#125; &#125; return ans; &#125;&#125; https://discuss.leetcode.com/topic/4939/a-stack-based-solution-for-reference-inspired-by-histogram A stack based solution for reference, inspired by Histogram Indeed this question can be solved in one pass and O(1) space, but it’s probably hard to come up with in a short interview. If you have read the stack O(n) solution for Largest Rectangle in Histogram, you will find this solution is very very similar. The main idea is : if we want to find out how much water on a bar(bot), we need to find out the left larger bar’s index (il), and right larger bar’s index(ir), so that the water is (min(A[il],A[ir])-A[bot])*(ir-il-1), use min since only the lower boundary can hold water, and we also need to handle the edge case that there is no il. To implement this we use a stack that store the indices with decreasing bar height, once we find a bar who’s height is larger, then let the top of the stack be bot, the cur bar is ir, and the previous bar is il. 1234567891011121314151617public int trap(int[] A) &#123; if (A==null) return 0; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int i = 0, maxWater = 0, maxBotWater = 0; while (i &lt; A.length)&#123; if (s.isEmpty() || A[i]&lt;=A[s.peek()])&#123; s.push(i++); &#125; else &#123; int bot = s.pop(); maxBotWater = s.isEmpty()? // empty means no il 0:(Math.min(A[s.peek()],A[i])-A[bot])*(i-s.peek()-1); maxWater += maxBotWater; &#125; &#125; return maxWater; &#125; https://discuss.leetcode.com/topic/5819/sharing-my-java-code-o-n-time-o-1-space Sharing my Java code: O(n) time, O(1) space 123456789101112131415161718192021222324252627public int trap(int[] A) &#123; if (A.length &lt; 3) return 0; int ans = 0; int l = 0, r = A.length - 1; // find the left and right edge which can hold water while (l &lt; r &amp;&amp; A[l] &lt;= A[l + 1]) l++; while (l &lt; r &amp;&amp; A[r] &lt;= A[r - 1]) r--; while (l &lt; r) &#123; int left = A[l]; int right = A[r]; if (left &lt;= right) &#123; // add volum until an edge larger than the left edge while (l &lt; r &amp;&amp; left &gt;= A[++l]) &#123; ans += left - A[l]; &#125; &#125; else &#123; // add volum until an edge larger than the right volum while (l &lt; r &amp;&amp; A[--r] &lt;= right) &#123; ans += right - A[r]; &#125; &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/7612/java-10-lines-accepted-code-o-n-time-o-1-space-is-there-a-better-solution JAVA 10 lines accepted code, O(n) time, O(1) space. Is there a better solution? Basically this solution runs two pointers from two sides to the middle, and the plank is used to record the height of the elevation within a certain range, plank height can only increase (or remain the same) from two sides to the middle. If the current pointer is pointing at a number that is less than the current plank height, the difference between plank height and the number would be the amount of water trapped. Otherwise, A[i] == plank, no water is trapped. 12345678910public class Solution &#123; public int trap(int[] A) &#123; int i = 0, j = A.length - 1, result = 0, plank = 0; while(i &lt;= j)&#123; plank = plank &lt; Math.min(A[i], A[j]) ? Math.min(A[i], A[j]) : plank; result = A[i] &gt;= A[j] ? result + (plank - A[j--]) : result + (plank - A[i++]); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
        <tag>hard</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[041. First Missing Positive]]></title>
    <url>%2Fp%2F257d685e%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/first-missing-positive/ Given an unsorted integer array, find the first missing positive integer. 123For example,Given [1,2,0] return 3,and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. 题意需要理解 答案需要思考 cpp https://discuss.leetcode.com/topic/8293/my-short-c-solution-o-1-space-and-o-n-time My short c++ solution, O(1) space, and O(n) time Put each number in its right place. For example: When we find 5, then swap it with A[4]. At last, the first place where its number is not right, return the place + 1. 12345678910111213141516class Solution&#123;public: int firstMissingPositive(int A[], int n) &#123; for(int i = 0; i &lt; n; ++ i) while(A[i] &gt; 0 &amp;&amp; A[i] &lt;= n &amp;&amp; A[A[i] - 1] != A[i]) swap(A[i], A[A[i] - 1]); for(int i = 0; i &lt; n; ++ i) if(A[i] != i + 1) return i + 1; return n + 1; &#125;&#125;; https://discuss.leetcode.com/topic/17035/my-c-solution-4-ms My c++ solution (4 ms) 12345678910111213141516class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; for(int i=0; i&lt;nums.size(); i++)&#123; if(i+1==nums[i]) continue; int x = nums[i]; while(x&gt;=1 &amp;&amp; x&lt;=nums.size() &amp;&amp; x!=nums[x-1])&#123; swap(x, nums[x-1]); &#125; &#125; for(int i=0; i&lt;nums.size(); i++)&#123; if(i+1!=nums[i]) return i+1; &#125; return nums.size()+1; &#125;&#125;; Since we can not use extra space, so thinking about using the nums vector itself to record a positive number occurred. https://discuss.leetcode.com/topic/3384/o-n-time-o-1-space-c O(n) time, O(1) space C++ Idea is to swap each positive integer you encounter to its “rightful” place at index (x-1) where x is the integer. It’s O(n) because you visit each integer in at most 2 unique loop iterations. 1234567891011121314151617181920class Solution &#123;public: int firstMissingPositive(int A[], int n) &#123; int i,j; for(i=0;i&lt;n;i++)&#123; int cur=A[i]; // if in place or non-pos or out of bounds, skip. if(cur==i+1||cur&lt;=0||cur&gt;n)continue; swap(A[i],A[cur-1]); // if not the same, then reprocess it. if(A[i]!=A[cur-1]) i--; &#125; for(i=0;i&lt;n;i++) if(A[i]!=i+1) return i+1; return n+1; &#125;&#125;; python https://discuss.leetcode.com/topic/1361/a-very-nice-solution-from-ants-aasma-stackoverflow A very nice solution (from Ants Aasma @stackoverflow) time complexity is O(N) and space complexity is O(1). Link: http://stackoverflow.com/questions/1586858/find-the-smallest-integer-not-in-a-list Posted by Ants Aasma on Oct 20 ‘09. The code is pasted here: 12345678910111213#Pass 1, move every value to the position of its valuefor cursor in range(N): target = array[cursor] while target &lt; N and target != array[target]: new_target = array[target] array[target] = target target = new_target#Pass 2, find first location where the index doesn&apos;t match the valuefor cursor in range(N): if array[cursor] != cursor: return cursorreturn N java https://discuss.leetcode.com/topic/2633/share-my-o-n-time-o-1-space-solution Share my O(n) time, O(1) space solution Share my O(n)/O(1) solution The basic idea is for any k positive numbers (duplicates allowed), the first missing positive number must be within [1,k+1]. The reason is like you put k balls into k+1 bins, there must be a bin empty, the empty bin can be viewed as the missing number. Unfortunately, there are 0 and negative numbers in the array, so firstly I think of using partition technique (used in quick sort) to put all positive numbers together in one side. This can be finished in O(n) time, O(1) space. After partition step, you get all the positive numbers lying within A[0,k-1]. Now, According to the basic idea, I infer the first missing number must be within [1,k+1]. I decide to use A[i] (0&lt;=i&lt;=k-1) to indicate whether the number (i+1) exists. But here I still have to main the original information A[i] holds. Fortunately, A[i] are all positive numbers, so I can set them to negative to indicate the existence of (i+1) and I can still use abs(A[i]) to get the original information A[i] holds. After step 2, I can again scan all elements between A[0,k-1] to find the first positive element A[i], that means (i+1) doesn’t exist, which is what I want. 12345678910111213141516171819202122232425262728293031323334353637383940public int firstMissingPositive(int[] A) &#123; int n=A.length; if(n==0) return 1; int k=partition(A)+1; int temp=0; int first_missing_Index=k; for(int i=0;i&lt;k;i++)&#123; temp=Math.abs(A[i]); if(temp&lt;=k) A[temp-1]=(A[temp-1]&lt;0)?A[temp-1]:-A[temp-1]; &#125; for(int i=0;i&lt;k;i++)&#123; if(A[i]&gt;0)&#123; first_missing_Index=i; break; &#125; &#125; return first_missing_Index+1;&#125;public int partition(int[] A)&#123; int n=A.length; int q=-1; for(int i=0;i&lt;n;i++)&#123; if(A[i]&gt;0)&#123; q++; swap(A,q,i); &#125; &#125; return q;&#125;public void swap(int[] A, int i, int j)&#123; if(i!=j)&#123; A[i]^=A[j]; A[j]^=A[i]; A[i]^=A[j]; &#125;&#125; https://discuss.leetcode.com/topic/10351/o-1-space-java-solution O(1) space Java Solution The key here is to use swapping to keep constant space and also make use of the length of the array, which means there can be at most n positive integers. So each time we encounter an valid integer, find its correct position and swap. Otherwise we continue. 12345678910111213141516171819public class Solution &#123; public int firstMissingPositive(int[] A) &#123; int i = 0; while(i &lt; A.length)&#123; if(A[i] == i+1 || A[i] &lt;= 0 || A[i] &gt; A.length) i++; else if(A[A[i]-1] != A[i]) swap(A, i, A[i]-1); else i++; &#125; i = 0; while(i &lt; A.length &amp;&amp; A[i] == i+1) i++; return i+1; &#125; private void swap(int[] A, int i, int j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125;&#125; https://discuss.leetcode.com/topic/25441/beat-100-fast-elegant-java-index-based-solution-with-explanation Beat 100% Fast Elegant Java Index-Based Solution with Explanation The basic idea is to traversal and try to move the current value to position whose index is exactly the value (swap them). Then travelsal again to find the first unusal value, which can not be corresponding to its index. 12345678910111213141516171819202122232425262728293031public int firstMissingPositive(int[] nums) &#123; int i = 0, n = nums.length; while (i &lt; n) &#123; // If the current value is in the range of (0,length) and it&apos;s not at its correct position, // swap it to its correct position. // Else just continue; if (nums[i] &gt;= 0 &amp;&amp; nums[i] &lt; n &amp;&amp; nums[nums[i]] != nums[i]) swap(nums, i, nums[i]); else i++; &#125; int k = 1; // Check from k=1 to see whether each index and value can be corresponding. while (k &lt; n &amp;&amp; nums[k] == k) k++; // If it breaks because of empty array or reaching the end. K must be the first missing number. if (n == 0 || k &lt; n) return k; else // If k is hiding at position 0, K+1 is the number. return nums[0] == k ? k + 1 : k;&#125;private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[040. Combination Sum II]]></title>
    <url>%2Fp%2F217971c0%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/combination-sum-ii/ Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. 123456789For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 方法一： 回溯法，我的代码实现 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end()); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; combination; helper(candidates, target, 0, combination, res); return res; &#125; void helper(vector&lt;int&gt;&amp; candidates, int target, int start, vector&lt;int&gt;&amp; combination, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(target==0)&#123; res.push_back(combination); return; &#125; if(target&lt;0 || start&gt;=candidates.size()) return; for(int i=start; i&lt;candidates.size(); i++)&#123; if(i!=start &amp;&amp; candidates[i]==candidates[i-1]) continue; combination.push_back(candidates[i]); helper(candidates, target-candidates[i], i+1, combination, res); // start+1 与 i+1 的区别 combination.pop_back(); &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/8916/c-backtracking-solution-with-detailed-explanation C++ backtracking solution with detailed explanation At the beginning, I stuck on this problem. After careful thought, I think this kind of backtracking contains a iterative component and a resursive component so I’d like to give more details to help beginners save time. The revursive component tries the elements after the current one and also tries duplicate elements. So we can get correct answer for cases like [1 1] 2. The iterative component checks duplicate combinations and skip it if it is. So we can get correct answer for cases like [1 1 1] 2. 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combinationSum2(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(num.begin(),num.end()); vector&lt;int&gt; local; findCombination(res, 0, target, local, num); return res; &#125; void findCombination(vector&lt;vector&lt;int&gt;&gt;&amp; res, const int order, const int target, vector&lt;int&gt;&amp; local, const vector&lt;int&gt;&amp; num) &#123; if(target==0) &#123; res.push_back(local); return; &#125; else &#123; for(int i = order;i&lt;num.size();i++) // iterative component &#123; if(num[i]&gt;target) return; if(i&amp;&amp;num[i]==num[i-1]&amp;&amp;i&gt;order) continue; // check duplicate combination local.push_back(num[i]), findCombination(res,i+1,target-num[i],local,num); // recursive componenet local.pop_back(); &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/17682/8ms-c-backtracking-easy-to-understand 8ms C++ backtracking easy to understand 12345678910111213141516171819vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; current; sort(candidates.begin(),candidates.end()); backTracking(candidates.begin(),current,res,candidates,target); return res;&#125;void backTracking(vector&lt;int&gt;::iterator n, vector&lt;int&gt;&amp; current,vector&lt;vector&lt;int&gt;&gt;&amp; res, const vector&lt;int&gt;&amp; candidates, int target)&#123; if(!target) res.push_back(current); else if(target&gt;0)&#123; for(;n!=candidates.end()&amp;&amp;*n&lt;=target;++n)&#123; current.push_back(*n); backTracking(n+1,current,res,candidates,target-*n); current.pop_back(); while(n+1!=candidates.end()&amp;&amp;*(n+1)==*n) ++n; &#125; &#125;&#125; https://discuss.leetcode.com/topic/3399/my-solution-without-using-set My solution without using set My idea is skip same number during recursion. Like Permutations II. Firstly sort num, then search from back for numbers sum to target. 1234567891011121314151617181920212223242526272829vector&lt;vector&lt;int&gt; &gt; combinationSum2(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(num.begin(), num.end()); vector&lt;int&gt; cur; find(num, target, num.size() - 1, res, cur); return res;&#125;void find(vector&lt;int&gt; &amp;num, int target, int end, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; cur)&#123; if (target == 0) &#123; res.push_back(cur); return; &#125; if (end &lt; 0 || num[end] * (end + 1) &lt; target) return; if (num[end] &lt;= target) &#123; cur.insert(cur.begin(), num[end]); find(num, target - num[end], end - 1, res, cur); cur.erase(cur.begin()); &#125; //find combinations ends at the first number different from num[end] int temp = num[end]; while (end &gt;= 0 &amp;&amp; num[end] == temp) end--; find(num, target, end, res, cur);&#125; 12ms, 57.77%, June.21th, 2016 https://leetcode.com/discuss/37071/accepted-16ms-c-solution-use-backtracking-easy-understand 1234567891011121314151617181920212223class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target) &#123; std::sort(candidates.begin(), candidates.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum2(candidates, target, res, combination, 0); return res; &#125;private: void combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin) &#123; if (!target) &#123; res.push_back(combination); return; &#125; for (int i = begin; i != candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) if (i == begin || candidates[i] != candidates[i - 1]) &#123; combination.push_back(candidates[i]); combinationSum2(candidates, target - candidates[i], res, combination, i + 1); combination.pop_back(); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/5777/dp-solution-in-python DP solution in Python I also did it with recursion, turns out the DP solution is 3~4 times faster. 12345678910def combinationSum2(self, candidates, target): candidates.sort() table = [None] + [set() for i in range(target)] for i in candidates: if i &gt; target: break for j in range(target - i, 0, -1): table[i + j] |= &#123;elt + (i,) for elt in table[j]&#125; table[i].add((i,)) return map(list, table[target]) https://discuss.leetcode.com/topic/11852/my-84ms-python-recursive-solution My 84ms python recursive solution. 1234567891011121314151617class Solution: def combinationSum2(self, candidates, target): candidates.sort() return self.search(candidates, 0 ,target) def search(self, candidates, start, target): if target==0: return [[]] res=[] for i in xrange(start,len(candidates)): if i!=start and candidates[i]==candidates[i-1]: continue if candidates[i]&gt;target: break for r in self.search(candidates, i+1, target-candidates[i]): res.append([candidates[i]]+r) return res https://discuss.leetcode.com/topic/47845/beating-98-python-solution-using-recursion-with-comments Beating 98% Python solution using recursion with comments 12345678910111213141516171819202122232425262728293031def combinationSum2(self, candidates, target): # Sorting is really helpful, se we can avoid over counting easily candidates.sort() result = [] self.combine_sum_2(candidates, 0, [], result, target) return result def combine_sum_2(self, nums, start, path, result, target): # Base case: if the sum of the path satisfies the target, we will consider # it as a solution, and stop there if not target: result.append(path) return for i in xrange(start, len(nums)): # Very important here! We don&apos;t use `i &gt; 0` because we always want # to count the first element in this recursive step even if it is the same # as one before. To avoid overcounting, we just ignore the duplicates # after the first element. if i &gt; start and nums[i] == nums[i - 1]: continue # If the current element is bigger than the assigned target, there is # no need to keep searching, since all the numbers are positive if nums[i] &gt; target: break # We change the start to `i + 1` because one element only could # be used once self.combine_sum_2(nums, i + 1, path + [nums[i]], result, target - nums[i]) java https://discuss.leetcode.com/topic/19845/java-solution-using-dfs-easy-understand Java solution using dfs, easy understand 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] cand, int target) &#123; Arrays.sort(cand); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;Integer&gt;(); dfs_com(cand, 0, target, path, res); return res;&#125;void dfs_com(int[] cand, int cur, int target, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (target == 0) &#123; res.add(new ArrayList(path)); return ; &#125; if (target &lt; 0) return; for (int i = cur; i &lt; cand.length; i++)&#123; if (i &gt; cur &amp;&amp; cand[i] == cand[i-1]) continue; path.add(path.size(), cand[i]); dfs_com(cand, i+1, target - cand[i], path, res); path.remove(path.size()-1); &#125;&#125; https://discuss.leetcode.com/topic/44037/combination-sum-i-ii-and-iii-java-solution-see-the-similarities-yourself Combination Sum I, II and III Java solution (see the similarities yourself) Combination Sum I 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(candidates); backtrack(list, new ArrayList&lt;Integer&gt;(), candidates, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] cand, int remain, int start) &#123; if (remain &lt; 0) return; /** no solution */ else if (remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for (int i = start; i &lt; cand.length; i++) &#123; tempList.add(cand[i]); backtrack(list, tempList, cand, remain-cand[i], i); tempList.remove(tempList.size()-1); &#125; &#125;&#125; Combination Sum II 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(candidates); backtrack(list, new ArrayList&lt;Integer&gt;(), candidates, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] cand, int remain, int start) &#123; if(remain &lt; 0) return; /** no solution */ else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for (int i = start; i &lt; cand.length; i++) &#123; if(i &gt; start &amp;&amp; cand[i] == cand[i-1]) continue; /** skip duplicates */ tempList.add(cand[i]); backtrack(list, tempList, cand, remain - cand[i], i+1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum III 1234567891011121314151617public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;Integer&gt;(), k, n, 1); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int k, int remain, int start) &#123; if(tempList.size() &gt; k) return; /** no solution */ else if(tempList.size() == k &amp;&amp; remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for (int i = start; i &lt;= 9; i++) &#123; tempList.add(i); backtrack(list, tempList, k, remain-i, i+1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; https://discuss.leetcode.com/topic/24059/java-short-and-recursive-clean-code Java - short and recursive, clean code. 123456789101112131415161718192021222324252627public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); List&lt;Integer&gt; comb = new ArrayList&lt;&gt;(); Arrays.sort(candidates); // need sort to make this work. combination(candidates, target, 0, comb, ans); return ans;&#125;private void combination(int[] candi, int target, int start, List&lt;Integer&gt; comb, List&lt;List&lt;Integer&gt;&gt; ans) &#123; for (int i = start; i &lt; candi.length; i++) &#123; if (i &gt; start &amp;&amp; candi[i] == candi[i - 1]) //remove duplicates. continue; if (candi[i] == target) &#123; //recursion exit. List&lt;Integer&gt; newComb = new ArrayList&lt;&gt;(comb); newComb.add(candi[i]); ans.add(newComb); &#125; else if (candi[i] &lt; target) &#123; //continue to look for the rest. List&lt;Integer&gt; newComb = new ArrayList&lt;&gt;(comb); newComb.add(candi[i]); combination(candi, target - candi[i], i + 1, newComb, ans); &#125; else break; //invalid path, return nothing. &#125;&#125; https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning 12345678910111213141516171819202122public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125; &#125; https://discuss.leetcode.com/topic/34364/java-solutions-beats-99-87 Java solutions beats 99,87% 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); calcCombinationSum2(candidates, 0, new int[candidates.length], 0, target, results); return results; &#125; private void calcCombinationSum2(int[] candidates, int cindex, int[] list, int lindex, int target, List&lt;List&lt;Integer&gt;&gt; results) &#123; if (target == 0) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; lindex; i++) &#123; result.add(list[i]); &#125; results.add(result); return; &#125; int prev = 0; for (int i = cindex; i &lt; candidates.length; i++) &#123; if (candidates[i] != prev) &#123; if (target - candidates[i] &lt; 0) &#123; break; &#125; list[lindex] = candidates[i]; calcCombinationSum2(candidates, i + 1, list, lindex + 1, target - candidates[i], results); prev = candidates[i]; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[039. Combination Sum]]></title>
    <url>%2Fp%2Ff5e0c04b%2F</url>
    <content type="text"><![CDATA[38.6% https://leetcode.com/problems/combination-sum/ Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. 1234567For example, given candidate set [2, 3, 6, 7] and target 7, A solution set is: [ [7], [2, 2, 3]] 方法一： 回溯法, 我的代码实现 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; sort(candidates.begin(), candidates.end()); helper(candidates, 0, target, tmp, res); return res; &#125; // 0至start-1之间的candidates已经用过了，只能从start开始用了 void helper(vector&lt;int&gt;&amp; candidates, int start, int target, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(target==0)&#123; res.push_back(tmp); return; &#125;else if(target&lt;0 || start&gt;=candidates.size())&#123; return; &#125; for(int i=start; i&lt;candidates.size(); i++)&#123; tmp.push_back(candidates[i]); helper(candidates, i, target-candidates[i], tmp, res); tmp.pop_back(); &#125; &#125;&#125;; cpp 16ms, 71.93%, June.21th, 2016 https://leetcode.com/discuss/37071/accepted-16ms-c-solution-use-backtracking-easy-understand Accepted 16ms c++ solution use backtracking, easy understand. Accepted 16ms c++ solution use backtracking for Combination Sum: 12345678910111213141516171819202122class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum(std::vector&lt;int&gt; &amp;candidates, int target) &#123; std::sort(candidates.begin(), candidates.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum(candidates, target, res, combination, 0); return res; &#125;private: void combinationSum(std::vector&lt;int&gt; &amp;candidates, int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin) &#123; if (!target) &#123; res.push_back(combination); return; &#125; for (int i = begin; i != candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) &#123; combination.push_back(candidates[i]); combinationSum(candidates, target - candidates[i], res, combination, i); combination.pop_back(); &#125; &#125;&#125;; Accepted 12ms c++ solution use backtracking for Combination Sum II: 1234567891011121314151617181920212223class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target) &#123; std::sort(candidates.begin(), candidates.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum2(candidates, target, res, combination, 0); return res; &#125;private: void combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin) &#123; if (!target) &#123; res.push_back(combination); return; &#125; for (int i = begin; i != candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) if (i == begin || candidates[i] != candidates[i - 1]) &#123; combination.push_back(candidates[i]); combinationSum2(candidates, target - candidates[i], res, combination, i + 1); combination.pop_back(); &#125; &#125;&#125;; Accepted 0ms c++ solution use backtracking for Combination Sum III: 1234567891011121314151617181920212223class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum3(int k, int n) &#123; std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum3(n, res, combination, 1, k); return res; &#125;private: void combinationSum3(int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin, int need) &#123; if (!target) &#123; res.push_back(combination); return; &#125; else if (!need) return; for (int i = begin; i != 10 &amp;&amp; target &gt;= i * need + need * (need - 1) / 2; ++i) &#123; combination.push_back(i); combinationSum3(target - i, res, combination, i + 1, need - 1); combination.pop_back(); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/6431/concise-backtracking-solution Concise Backtracking Solution We backtrack from successful searches as well because they are saved at the leafs of recursion tree 12345678910111213141516171819202122232425262728293031class Solution &#123;public: void search(vector&lt;int&gt;&amp; num, int next, vector&lt;int&gt;&amp; pSol, int target, vector&lt;vector&lt;int&gt; &gt;&amp; result) &#123; if(target == 0) &#123; result.push_back(pSol); return; &#125; if(next == num.size() || target - num[next] &lt; 0) return; pSol.push_back(num[next]); search(num, next, pSol, target - num[next], result); pSol.pop_back(); search(num, next + 1, pSol, target, result); &#125; vector&lt;vector&lt;int&gt; &gt; combinationSum(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt; &gt; result; sort(num.begin(), num.end()); vector&lt;int&gt; pSol; search(num, 0, pSol, target, result); return result; &#125;&#125;; https://discuss.leetcode.com/topic/4454/dynamic-programming-solution Dynamic Programming Solution It adapts the DP solution of coin change problem 12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combinationSum(vector&lt;int&gt; &amp;candidates, int target) &#123; vector&lt; vector&lt; vector&lt;int&gt; &gt; &gt; combinations(target + 1, vector&lt;vector&lt;int&gt;&gt;()); combinations[0].push_back(vector&lt;int&gt;()); for (auto&amp; score : candidates) for (int j = score; j &lt;= target; j++) if (combinations[j - score].size() &gt; 0) &#123; auto tmp = combinations[j - score]; for (auto&amp; s : tmp) s.push_back(score); combinations[j].insert(combinations[j].end(), tmp.begin(), tmp.end()); &#125; auto ret = combinations[target]; for (int i = 0; i &lt; ret.size(); i++) sort(ret[i].begin(), ret[i].end()); return ret; &#125;&#125;; python 188ms, 27.12%, June.21th, 2016 https://leetcode.com/discuss/55666/python-dfs-solution Python dfs solution. 1234567891011121314151617181920class Solution(object): def combinationSum(self, candidates, target): &quot;&quot;&quot; :type candidates: List[int] :type target: int :rtype: List[List[int]] &quot;&quot;&quot; res = [] candidates.sort() self.dfs(candidates, target, [], res, 0) return res def dfs(self, nums, target, path, res, index): if target &lt; 0: return if target == 0: res.append(path) return for i in xrange(index, len(nums)): self.dfs(nums, target - nums[i], path + [nums[i]], res, i) 100ms, 88.35%, June.21th, 2016 https://leetcode.com/discuss/55666/python-dfs-solution 1234567891011121314151617181920class Solution(object): def combinationSum(self, candidates, target): &quot;&quot;&quot; :type candidates: List[int] :type target: int :rtype: List[List[int]] &quot;&quot;&quot; res = [] candidates.sort() self.dfs(candidates, target, [], res, 0) return res def dfs(self, nums, target, path, res, index): if target == 0: res.append(path) return for i in xrange(index, len(nums)): if nums[i] &gt; target: break self.dfs(nums, target - nums[i], path + [nums[i]], res, i) java https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning) This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. Subsets : https://leetcode.com/problems/subsets/ 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Subsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Permutations : https://leetcode.com/problems/permutations/ 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/ 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum : https://leetcode.com/problems/combination-sum/ 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum II (can’t reuse same element) : https://leetcode.com/problems/combination-sum-ii/ 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Palindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/ 12345678910111213141516171819202122232425public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list;&#125;public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125;&#125;public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true;&#125; 6ms, 66.615, June.21th, 2016 https://leetcode.com/discuss/22651/java-solution-using-recursive Java solution using recursive 12345678910111213141516171819202122public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); getResult(result, new ArrayList&lt;Integer&gt;(), candidates, target, 0); return result; &#125; private void getResult(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; cur, int candidates[], int target, int start)&#123; if(target &gt; 0)&#123; for(int i = start; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++)&#123; cur.add(candidates[i]); getResult(result, cur, candidates, target - candidates[i], i); cur.remove(cur.size() - 1); &#125;//for &#125;//if else if(target == 0 )&#123; result.add(new ArrayList&lt;Integer&gt;(cur)); &#125;//else if &#125;&#125; https://discuss.leetcode.com/topic/8200/iterative-java-dp-solution Iterative Java DP solution Hi guys! The main idea reminds an approach for solving coins/knapsack problem - to store the result for all i &lt; target and create the solution from them. For that for each t from 1 to our target we try every candidate which is less or equal to t in ascending order. For each candidate “c” we run through all combinations for target t-c starting with the value greater or equal than c to avoid duplicates and store only ordered combinations. 123456789101112131415161718192021222324public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] cands, int t) &#123; Arrays.sort(cands); // sort candidates to try them in asc order List&lt;List&lt;List&lt;Integer&gt;&gt;&gt; dp = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= t; i++) &#123; // run through all targets from 1 to t List&lt;List&lt;Integer&gt;&gt; newList = new ArrayList(); // combs for curr i // run through all candidates &lt;= i for (int j = 0; j &lt; cands.length &amp;&amp; cands[j] &lt;= i; j++) &#123; // special case when curr target is equal to curr candidate if (i == cands[j]) newList.add(Arrays.asList(cands[j])); // if current candidate is less than the target use prev results else for (List&lt;Integer&gt; l : dp.get(i-cands[j]-1)) &#123; if (cands[j] &lt;= l.get(0)) &#123; List cl = new ArrayList&lt;&gt;(); cl.add(cands[j]); cl.addAll(l); newList.add(cl); &#125; &#125; &#125; dp.add(newList); &#125; return dp.get(t-1); &#125;&#125; Hope it helps! https://discuss.leetcode.com/topic/3043/a-solution-avoid-using-set A solution avoid using set Sort the candidates and we choose from small to large recursively, every time we add a candidate to our possible sub result, we subtract the target to a new smaller one. 12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(candidates); // sort the candidates // collect possible candidates from small to large to eliminate duplicates, recurse(new ArrayList&lt;Integer&gt;(), target, candidates, 0, ret); return ret;&#125;// the index here means we are allowed to choose candidates from that indexprivate void recurse(List&lt;Integer&gt; list, int target, int[] candidates, int index, List&lt;List&lt;Integer&gt;&gt; ret) &#123; if (target == 0) &#123; ret.add(list); return; &#125; for (int i = index; i &lt; candidates.length; i++) &#123; int newTarget = target - candidates[i]; if (newTarget &gt;= 0) &#123; List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(list); copy.add(candidates[i]); recurse(copy, newTarget, candidates, i, ret); &#125; else &#123; break; &#125; &#125;&#125; https://discuss.leetcode.com/topic/3043/a-solution-avoid-using-set/2 Slightly modified your solution, this will make the method run a little faster. 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(candidates); // sort the candidates // collect possible candidates from small to large to eliminate duplicates, recurse(new ArrayList&lt;Integer&gt;(), target, candidates, 0, ret); return ret;&#125;// the index here means we are allowed to choose candidates from that indexprivate void recurse(List&lt;Integer&gt; list, int target, int[] candidates, int index, List&lt;List&lt;Integer&gt;&gt; ret) &#123; if (target == 0) &#123; ret.add(list); return; &#125; for (int i = index; i &lt; candidates.length; i++) &#123; int newTarget = target - candidates[i]; if (newTarget &gt;= 0) &#123; List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(list); copy.add(candidates[i]); recurse(copy, newTarget, candidates, i, ret); &#125;else&#123;break;&#125; &#125; https://discuss.leetcode.com/topic/8364/java-solution-backtracking Java solution (backtracking) 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; solution; private List&lt;Integer&gt; curSolution; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; solution = new ArrayList&lt;List&lt;Integer&gt;&gt;(); curSolution = new ArrayList&lt;Integer&gt;(); Arrays.sort(candidates); backTrack(candidates, target, 0); return solution; &#125; private void backTrack(int[] candidates, int target, int lastIdx) &#123; if (target == 0) &#123; solution.add(new ArrayList&lt;&gt;(curSolution)); &#125; else if (target &lt; 0) &#123; return; &#125; else &#123; int i = lastIdx; while (i &lt; candidates.length) &#123; int candidate = candidates[i]; curSolution.add(candidate); backTrack(candidates, target - candidate, i); curSolution.remove(curSolution.size() - 1); while (i &lt; candidates.length &amp;&amp; candidates[i] == candidate) &#123; i++; &#125; &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/4997/non-recursive-java-solution Non-Recursive JAVA solution 12345678910111213141516171819202122232425262728293031public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); int i=0, size = candidates.length, sum=0; Stack&lt;Integer&gt; combi = new Stack&lt;&gt;(), indices = new Stack&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); while (i &lt; size) &#123; if (sum + candidates[i]&gt;= target) &#123; if (sum + candidates[i] == target) &#123; combi.push(candidates[i]); result.add(new ArrayList&lt;&gt;(combi)); combi.pop(); &#125; // indices stack and combination stack should have the same size all the time if (!indices.empty())&#123; sum -= combi.pop(); i = indices.pop(); while (i == size-1 &amp;&amp; !indices.empty()) &#123; i = indices.pop(); sum -= combi.pop(); &#125; &#125; i++; &#125; else &#123; combi.push(candidates[i]); sum +=candidates[i]; indices.push(i); &#125; &#125; return result;&#125; https://discuss.leetcode.com/topic/6994/recursive-java-solution Recursive java solution 12345678910111213141516171819202122232425262728293031323334public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); // sort the array, so the result could be increasing order List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i = 0; i &lt; candidates.length; i++)&#123; // target smaller than current number, jump the current and rest of numbers if(target &lt; candidates[i]) continue; // if target is equal to the current number,add it to a new list and add that list to result else if(target == candidates[i])&#123; List&lt;Integer&gt; set = new ArrayList&lt;Integer&gt;(); set.add(candidates[i]); result.add(set); &#125; // if the target is smaller the current number,call this function again else&#123; // use modified array which not includes those numbers that before i to eliminate the duplicates int[] array = Arrays.copyOfRange(candidates,i,candidates.length); // call this function. pass the new target and modified array. List&lt;List&lt;Integer&gt;&gt; temp = combinationSum(array, target - candidates[i]); // for each list in the return list, add current number in the front of list, then add it to result // attention that if return list is null, this enhanced for loop will not perform. for(List&lt;Integer&gt; list:temp)&#123; list.add(0,candidates[i]); result.add(list); &#125; &#125; &#125; return result;&#125; They key point is passing new target and modified array. Pass the modified array to make sure no duplicates set. If the new target could not find a match number, the return list will be null, thus this null list will not be added to the result list.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[038. Count and Say]]></title>
    <url>%2Fp%2Ff2d63f47%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/count-and-say/ 1234567The count-and-say sequence is the sequence of integers beginning as follows:1, 11, 21, 1211, 111221, ...1 is read off as &quot;one 1&quot; or 11.11 is read off as &quot;two 1s&quot; or 21.21 is read off as &quot;one 2, then one 1&quot; or 1211.Given an integer n, generate the nth sequence. Note: The sequence of integers will be represented as a string. https://discuss.leetcode.com/topic/1296/please-change-the-misleading-description Please change the misleading description It seems not only me misunderstood the question. Please modify the description, since it’s frustrating if you are solving a “different” question. Thanks. https://discuss.leetcode.com/topic/2264/examples-of-nth-sequence Examples of nth sequence At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I’m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10: 1234567891011test 1. 1 2. 11 3. 21 4. 1211 5. 111221 6. 312211 7. 13112221 8. 1113213211 9. 31131211131221 10. 13211311123113112211 From the examples you can see, the (i+1)th sequence is the “count and say” of the ith sequence! Hope this helps! https://discuss.leetcode.com/topic/2526/i-suggest-we-should-add-the-description-the-1-is-the-1st-string-and-calculate-the-n-th-string I suggest we should add the description: The “1” is the 1st string, and calculate the n th string. Because usually we start from the 0 th item, so add this description to avoid misunderstanding. java 6ms, September 19, 2016 https://discuss.leetcode.com/topic/2309/show-an-answer-in-java Show an Answer in Java I found nobody answered this question in Java. Actually I got some trouble even this question is not so hard. Maybe many other people had some trouble too. So I put my answer here. @code StringBuilder.append() is the default way to append one string to another. While I have tried String.cancate(),which is not working properly. Any comment is welcomed. 12345678910111213141516171819202122232425public class Solution &#123; public String countAndSay(int n) &#123; StringBuilder curr = new StringBuilder(&quot;1&quot;); StringBuilder prev; int count; char say; for(int i=1; i&lt;n; i++)&#123; prev = curr; curr = new StringBuilder(); count = 1; say = prev.charAt(0); for(int j=1, len=prev.length(); j&lt;len; j++)&#123; if(prev.charAt(j)!=say)&#123; curr.append(count).append(say); count = 1; say = prev.charAt(j); &#125; else count++; &#125; curr.append(count).append(say); &#125; return curr.toString(); &#125;&#125; https://discuss.leetcode.com/topic/14543/straightforward-java-solution Straightforward Java Solution 123456789101112131415161718192021222324252627282930public class Solution &#123; public String countAndSay(int n) &#123; String s = &quot;1&quot;; for(int i = 1; i &lt; n; i++)&#123; s = countIdx(s); &#125; return s; &#125; public String countIdx(String s)&#123; StringBuilder sb = new StringBuilder(); char c = s.charAt(0); int count = 1; for(int i = 1; i &lt; s.length(); i++)&#123; if(s.charAt(i) == c)&#123; count++; &#125; else &#123; sb.append(count); sb.append(c); c = s.charAt(i); count = 1; &#125; &#125; sb.append(count); sb.append(c); return sb.toString(); &#125;&#125; cpp 3ms, September 19, 2016 https://discuss.leetcode.com/topic/20195/c-solution-easy-understand C++ solution easy-understand 1234567891011121314151617181920class Solution &#123;public: string countAndSay(int n) &#123; if(n==0) return &quot;&quot;; string res = &quot;1&quot;; while(--n)&#123; string cur = &quot;&quot;; for(int i=0; i&lt;res.size(); i++)&#123; int count = 1; while((i+1&lt;res.size())&amp;&amp;(res[i] == res[i+1]))&#123; count++; i++; &#125; cur += to_string(count) + res[i]; &#125; res = cur; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/2068/how-to-proof-the-count-is-always-less-than-10 How to proof the COUNT is always less than 10? At first, I solved this problem with the considering of the cases when COUNT is greater than 9, which can not be handled using:curString +=count+’0’;, since it is more than one digit. And I solved it using itoa. But when I thinked about the problem, it seems that the COUNT is always less than 10, even 4. Then I re-writed the solution and also accepted by OJ. Can you guys help me proof it?My code: 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string countAndSay(int n) &#123; string prevString; string curString = &quot;1&quot;; for (int i = 1; i&lt;n; ++i)&#123; prevString = curString; curString = &quot;&quot;; int count = 1; char digit = prevString[0]; for (int j = 1; j&lt;prevString.length(); ++j)&#123; if (prevString[j] == digit)&#123; ++count; &#125; else&#123; curString +=count+&apos;0&apos;; //myItoa(count); curString += digit; digit = prevString[j]; count = 1; &#125; &#125; curString += count+&apos;0&apos;;//myItoa(count); curString += digit; &#125; return curString; &#125;/*private: string myItoa(int i)&#123; string str; while (i)&#123; str += i%10+&apos;0&apos;; i /=10; &#125; reverse(str.begin(), str.end()); return str; &#125;*/&#125;; https://discuss.leetcode.com/topic/2068/how-to-proof-the-count-is-always-less-than-10/2 Proof by exhaustion and contrapositive: In order for a number greater than 4 to be created, there must be a series of numbers n&gt;4 in length all the same digit. Therefore, there is a subset of that series where the count would only reach 4. Because of this, any proof for the existence of a chain resulting in a number greater than 4 is also a proof for the existence of a 4-chain. Using the proof by contrapositive, this means that if 4-chains are proved to be impossible, then any n-chain with n&gt;4 is also impossible. In order to start with a chain with numbers greater than 4, you must assume that a 4-chain is possible in the first place, which is circular reasoning, and so cannot be used as an initial point. It is further impossible to have a negative value, since the counting numbers do not include them. Therefore, the only chains able to create a 4 (at least the first one) are 0000, 1111, 2222, or 3333. 10 0 0 0 -&gt; 40 The 0000 is read zero 0, zero 0, which must come from . Since there is nothing present, it could in theory occur anywhere in the string. However, since they would be next to each other, if the 0 is repeated as would be neccessary, the zeros would add together, resulting in just zero 0, leaving only 20, not 40. 11 1 1 1 -&gt; 41 The 1111 is read one 1, one 1 (or 11), which translates to 21, not 1111. This contradicts the assumption that there is a way to get 1111, and so prevents 4 or greater from appearing. Therefore, 1s cannot reach 4. 12 2 2 2 -&gt; 42 The 2222 is read two 2, two 2 (or 22 22), which is identical to the output. Since the input maps to itself, there is no way to leave that cycle, or it already would have. If 2222 exists in the input, then 2222 must have mapped to it. It cannot reach 42. Therefore, 2s cannot reach 4. 13 3 3 3 -&gt; 43 The 3333 is read three 3, three 3 (or 333 333). This in turn would require 333 333 333. This fails in two respects. First, that the previous inputs would not merge to 63 or 93. The second, that the sequence eventually traces back to the origin, 1. Since it keeps increasing in length as the number of rounds since the start decreases, it cannot have started at 1. Therefore, 3s cannot reach 4. As every possible case has been examined, and none can reach a 4 while starting at the given beginning (1), it is not possible for a 4-chain to occur, meaning a 4 cannot appear in any valid string for this problem. Further, as stated above, since a 4-chain is impossible, so too are all n-chains with n&gt;4, so no number greater than 4 can appear either. https://discuss.leetcode.com/topic/5377/c-solution-runtime-o-n-space-o-n C++ solution, runtime O(n), space O(n) Please see the comments in the code.The solution is quite straight-forward. We generate k-th string, and from k-th string we generate k+1-th string, until we generate n-th string.We use string-helper to save temporary result,I’m sure there is a way for in-place solution also. 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: std::string countAndSay(int n) &#123; if (0 == n) return &quot;&quot;; if (1 == n) return &quot;1&quot;; std::string res=&quot;1&quot;; std::string s; for (int i = 1; i &lt; n; i++)&#123; // run from starting to generate second string int len = res.size(); //cheack all digits in the string for (int j = 0; j &lt; len; j++)&#123; int count=1; // we have at least 1 occourence of each digit // get the number of times same digit occurred (be carefull with the end of the string) while ((j + 1 &lt; len) &amp;&amp; (res[j] == res[j + 1]))&#123; count++; j++; // we need to keep increasing the index inside of the string &#125; // add to new string &quot;count&quot;+&quot;digit itself&quot; s += std::to_string(count) + res[j]; &#125; // save temporary result res = s; // clean our string-helper s.clear(); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/7800/c-iterative-solution-with-explanation-easy-to-understand C++ iterative solution with explanation, easy to understand. Renewed Solution The key point here is to find the maximum consecutive identical numbers, which means, for example: Say there is a array like this [1, 1, 2, 3, 4, 4, 5, 5, 5], we will need to divide the array into different segments like this, [1, 1], [2], [3], [4, 4], [5, 5, 5]. Only in this way, can we count the occurrence of each consecutive segments and convert them into “21 12 13 24 35”. The description of the problem is misleading and I struggled for a while, after some searching I found the right explanation. The number n has nothing to do with the algorithm directly, but but only control the number of iteration. The problem can be solved by using iterative algorithm. Code 1234567891011121314151617181920212223242526272829303132333435string countAndSay(int n)&#123; string curr_str; // The initial case, when n = 1 curr_str += &apos;1&apos;; // The iterative case, when n &gt; 1 for (int i = 0; i &lt; n - 1; i++) &#123; string buffer; // Handle the current string int index = 0; for (int index = 0; index &lt; curr_str.size(); ++index) &#123; // Count the occurance of each digit int cnt = 1; // At least one occurance while (index + 1 &lt; curr_str.size() and curr_str[index + 1] == curr_str[index]) &#123; index++; cnt++; &#125; buffer.push_back(cnt + &apos;0&apos;); buffer.push_back(curr_str[index]); &#125; // Update the current string curr_str = buffer; &#125; return curr_str;&#125; python 52ms, September 19, 2016 https://discuss.leetcode.com/topic/28084/simple-python-solution Idea here is keep track of the first letter in the sequence and count consecutive occurances. Once you encounter a new letter you add the previous count and letter to the chain. Repeat n-1 times (since we seeded the initial ‘1’ case). We always update temp after the inner loop since we will never have already added the last sequence. 12345678910111213141516171819class Solution(object): def countAndSay(self, n): &quot;&quot;&quot; :type n: int :rtype: str &quot;&quot;&quot; s = &apos;1&apos; for _ in range(n-1): let, temp, count = s[0], &apos;&apos;, 0 for l in s: if let == l: count += 1 else: temp += str(count) + let let = l count = 1 temp += str(count) + let s = temp return s https://discuss.leetcode.com/topic/28084/simple-python-solution Simple Python Solution Idea here is keep track of the first letter in the sequence and count consecutive occurances. Once you encounter a new letter you add the previous count and letter to the chain. Repeat n-1 times (since we seeded the initial ‘1’ case). We always update temp after the inner loop since we will never have already added the last sequence. 1234567891011121314def countAndSay(self, n): s = &apos;1&apos; for _ in range(n-1): let, temp, count = s[0], &apos;&apos;, 0 for l in s: if let == l: count += 1 else: temp += str(count)+let let = l count = 1 temp += str(count)+let s = temp return s https://discuss.leetcode.com/topic/32023/4-5-lines-python-solutions 4-5 lines Python solutions Solution 1 … using a regular expression 12345def countAndSay(self, n): s = &apos;1&apos; for _ in range(n - 1): s = re.sub(r&apos;(.)\1*&apos;, lambda m: str(len(m.group(0))) + m.group(1), s) return s Solution 2 … using a regular expression 123456def countAndSay(self, n): s = &apos;1&apos; for _ in range(n - 1): s = &apos;&apos;.join(str(len(group)) + digit for group, digit in re.findall(r&apos;((.)\2*)&apos;, s)) return s Solution 3 … using groupby 123456def countAndSay(self, n): s = &apos;1&apos; for _ in range(n - 1): s = &apos;&apos;.join(str(len(list(group))) + digit for digit, group in itertools.groupby(s)) return s]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[037. Sudoku Solver]]></title>
    <url>%2Fp%2Ff1a3dfa0%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/sudoku-solver/ Write a program to solve a Sudoku puzzle by filling the empty cells. Empty cells are indicated by the character ‘.’. You may assume that there will be only one unique solution. A sudoku puzzle… …and its solution numbers marked in red. https://discuss.leetcode.com/topic/2145/there-is-a-dancing-links-x-algorithm There is a Dancing Links X Algorithm Dr. Donald Knuth’s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem. NOTE:This is a very complicate solution. A Sudoku Solver in Java implementing Knuth’s Dancing Links Algorithm java 25ms, 54.00%, September 21, 2016 https://discuss.leetcode.com/topic/11327/straight-forward-java-solution-using-backtracking Straight Forward Java Solution Using Backtracking Try 1 through 9 for each cell. The time complexity should be 9 ^ m (m represents the number of blanks to be filled in), since each blank can have 9 choices. Details see comments inside code. Let me know your suggestions. Sorry for being late to answer the time complexity question 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public void solveSudoku(char[][] board) &#123; if(board == null || board.length == 0) return; solve(board); &#125; public boolean solve(char[][] board)&#123; for(int i=0; i&lt;board.length; i++)&#123; for(int j=0; j&lt;board[0].length; j++)&#123; if(board[i][j]==&apos;.&apos;)&#123; for(char c=&apos;1&apos;; c&lt;=&apos;9&apos;; c++)&#123; if(isValid(board, i, j, c))&#123; board[i][j] = c; if(solve(board)) return true; else board[i][j]=&apos;.&apos;; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; public boolean isValid(char[][] board, int i, int j, char c)&#123; for(int row = 0; row&lt;9; row++) if(board[row][j] == c) return false; for(int col = 0; col&lt;9; col++) if(board[i][col] == c) return false; for(int row = (i/3)*3; row &lt; (i/3)*3 + 3; row++) for(int col = (j/3)*3; col &lt; (j/3)*3+3; col++) if(board[row][col] == c) return false; return true; &#125;&#125; cpp https://discuss.leetcode.com/topic/7195/sharing-my-2ms-c-solution-with-comments-and-explanations Sharing my 2ms C++ solution with comments and explanations. Update: there’s a follow-up 0ms solution which is even more optimized This is one of the fastest Sudoku solvers I’ve ever written. It is compact enough - just 150 lines of C++ code with comments. I thought it’d be interesting to share it, since it combines several techniques like reactive network update propagation and backtracking with very aggressive pruning. The algorithm is online - it starts with an empty board and as you add numbers to it, it starts solving the Sudoku. Unlike in other solutions where you have bitmasks of allowed/disallowed values per row/column/square, this solution track bitmask for every(!) cell, forming a set of constraints for the allowed values for each particular cell. Once a value is written into a cell, new constraints are immediately propagated to row, column and 3x3 square of the cell. If during this process a value of other cell can be unambiguously deduced - then the value is set, new constraints are propagated, so on…. You can think about this as an implicit reactive network of cells. If we’re lucky (and we’ll be lucky for 19 of 20 of Sudokus published in magazines) then Sudoku is solved at the end (or even before!) processing of the input. Otherwise, there will be empty cells which have to be resolved. Algorithm uses backtracking for this purpose. To optimize it, algorithm starts with the cell with the smallest ambiguity. This could be improved even further by using priority queue (but it’s not implemented here). Backtracking is more or less standard, however, at each step we guess the number, the reactive update propagation comes back into play and it either quickly proves that the guess is unfeasible or significantly prunes the remaining search space. It’s interesting to note, that in this case taking and restoring snapshots of the compact representation of the state is faster than doing backtracking rollback by “undoing the moves”. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141class Solution &#123; struct cell // encapsulates a single cell on a Sudoku board &#123; uint8_t value; // cell value 1..9 or 0 if unset // number of possible (unconstrained) values for the cell uint8_t numPossibilities; // if bitset[v] is 1 then value can&apos;t be v bitset&lt;10&gt; constraints; cell() : value(0), numPossibilities(9),constraints() &#123;&#125;; &#125;; array&lt;array&lt;cell,9&gt;,9&gt; cells; // sets the value of the cell to [v] // the function also propagates constraints to other cells and deduce new values where possible bool set(int i, int j, int v) &#123; // updating state of the cell cell&amp; c = cells[i][j]; if (c.value == v) return true; if (c.constraints[v]) return false; c.constraints = bitset&lt;10&gt;(0x3FE); // all 1s c.constraints.reset(v); c.numPossibilities = 1; c.value = v; // propagating constraints for (int k = 0; k&lt;9; k++) &#123; // to the row: if (i != k &amp;&amp; !updateConstraints(k, j, v)) return false; // to the column: if (j != k &amp;&amp; !updateConstraints(i, k, v)) return false; // to the 3x3 square: int ix = (i / 3) * 3 + k / 3; int jx = (j / 3) * 3 + k % 3; if (ix != i &amp;&amp; jx != j &amp;&amp; !updateConstraints(ix, jx, v)) return false; &#125; return true; &#125; // update constraints of the cell i,j by excluding possibility of &apos;excludedValue&apos; // once there&apos;s one possibility left the function recurses back into set() bool updateConstraints(int i, int j, int excludedValue) &#123; cell&amp; c = cells[i][j]; if (c.constraints[excludedValue]) &#123; return true; &#125; if (c.value == excludedValue) &#123; return false; &#125; c.constraints.set(excludedValue); if (--c.numPossibilities &gt; 1) return true; for (int v = 1; v &lt;= 9; v++) &#123; if (!c.constraints[v]) &#123; return set(i, j, v); &#125; &#125; assert(false); &#125; // backtracking state - list of empty cells vector&lt;pair&lt;int, int&gt;&gt; bt; // find values for empty cells bool findValuesForEmptyCells() &#123; // collecting all empty cells bt.clear(); for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (!cells[i][j].value) bt.push_back(make_pair(i, j)); &#125; &#125; // making backtracking efficient by pre-sorting empty cells by numPossibilities sort(bt.begin(), bt.end(), [this](const pair&lt;int, int&gt;&amp;a, const pair&lt;int, int&gt;&amp;b) &#123; return cells[a.first][a.second].numPossibilities &lt; cells[b.first][b.second].numPossibilities; &#125;); return backtrack(0); &#125; // Finds value for all empty cells with index &gt;=k bool backtrack(int k) &#123; if (k &gt;= bt.size()) return true; int i = bt[k].first; int j = bt[k].second; // fast path - only 1 possibility if (cells[i][j].value) return backtrack(k + 1); auto constraints = cells[i][j].constraints; // slow path &gt;1 possibility. // making snapshot of the state array&lt;array&lt;cell,9&gt;,9&gt; snapshot(cells); for (int v = 1; v &lt;= 9; v++) &#123; if (!constraints[v]) &#123; if (set(i, j, v)) &#123; if (backtrack(k + 1)) return true; &#125; // restoring from snapshot, // note: computationally this is cheaper // than alternative implementation with undoing the changes cells = snapshot; &#125; &#125; return false; &#125;public: void solveSudoku(vector&lt;vector&lt;char&gt;&gt; &amp;board) &#123; cells = array&lt;array&lt;cell,9&gt;,9&gt;(); // clear array // Decoding input board into the internal cell matrix. // As we do it - constraints are propagated and even additional values are set as we go // (in the case if it is possible to unambiguously deduce them). for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != &apos;.&apos; &amp;&amp; !set(i, j, board[i][j] - &apos;0&apos;)) return; // sudoku is either incorrect or unsolvable &#125; &#125; // if we&apos;re lucky we&apos;ve already got a solution, // however, if we have empty cells we need to use backtracking to fill them if (!findValuesForEmptyCells()) return; // sudoku is unsolvable // copying the solution back to the board for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (cells[i][j].value) board[i][j] = cells[i][j].value + &apos;0&apos;; &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/13314/singapore-prime-minister-lee-hsien-loong-s-sudoku-solver-code-runs-in-1ms Singapore prime minister Lee Hsien Loong’s Sudoku Solver code runs in 1ms Singapore’s prime minister Lee Hsien Loong showcased his Sudoku Solver C code. You can read his original Facebook post here and another news reporting it here. I have made some slight modification to adapt it so it can be tested on LeetCode OJ. It passed all 6/6 test cases with a runtime of 1 ms. Pretty impressive for a prime minister, huh? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// Original author: Hsien Loong Lee (http://bit.ly/1zfIGMc)// Slight modification by @1337c0d3r to adapt to run on LeetCode OJ.// https://leetcode.com/problems/sudoku-solver/int InBlock[81], InRow[81], InCol[81];const int BLANK = 0;const int ONES = 0x3fe; // Binary 1111111110int Entry[81]; // Records entries 1-9 in the grid, as the corresponding bit set to 1int Block[9], Row[9], Col[9]; // Each int is a 9-bit arrayint SeqPtr = 0;int Sequence[81];void SwapSeqEntries(int S1, int S2)&#123; int temp = Sequence[S2]; Sequence[S2] = Sequence[S1]; Sequence[S1] = temp;&#125;void InitEntry(int i, int j, int val)&#123; int Square = 9 * i + j; int valbit = 1 &lt;&lt; val; int SeqPtr2; // add suitable checks for data consistency Entry[Square] = valbit; Block[InBlock[Square]] &amp;= ~valbit; Col[InCol[Square]] &amp;= ~valbit; // Simpler Col[j] &amp;= ~valbit; Row[InRow[Square]] &amp;= ~valbit; // Simpler Row[i] &amp;= ~valbit; SeqPtr2 = SeqPtr; while (SeqPtr2 &lt; 81 &amp;&amp; Sequence[SeqPtr2] != Square) SeqPtr2++ ; SwapSeqEntries(SeqPtr, SeqPtr2); SeqPtr++;&#125;void PrintArray(char **board)&#123; int i, j, valbit, val, Square; char ch; Square = 0; for (i = 0; i &lt; 9; i++) &#123; for (j = 0; j &lt; 9; j++) &#123; valbit = Entry[Square++]; if (valbit == 0) ch = &apos;-&apos;; else &#123; for (val = 1; val &lt;= 9; val++) if (valbit == (1 &lt;&lt; val)) &#123; ch = &apos;0&apos; + val; break; &#125; &#125; board[i][j] = ch; &#125; &#125;&#125;int NextSeq(int S)&#123; int S2, Square, Possibles, BitCount; int T, MinBitCount = 100; for (T = S; T &lt; 81; T++) &#123; Square = Sequence[T]; Possibles = Block[InBlock[Square]] &amp; Row[InRow[Square]] &amp; Col[InCol[Square]]; BitCount = 0; while (Possibles) &#123; Possibles &amp;= ~(Possibles &amp; -Possibles); BitCount++; &#125; if (BitCount &lt; MinBitCount) &#123; MinBitCount = BitCount; S2 = T; &#125; &#125; return S2;&#125;void Place(int S, char** board)&#123; if (S &gt;= 81) &#123; PrintArray(board); return; &#125; int S2 = NextSeq(S); SwapSeqEntries(S, S2); int Square = Sequence[S]; int BlockIndex = InBlock[Square], RowIndex = InRow[Square], ColIndex = InCol[Square]; int Possibles = Block[BlockIndex] &amp; Row[RowIndex] &amp; Col[ColIndex]; while (Possibles) &#123; int valbit = Possibles &amp; (-Possibles); // Lowest 1 bit in Possibles Possibles &amp;= ~valbit; Entry[Square] = valbit; Block[BlockIndex] &amp;= ~valbit; Row[RowIndex] &amp;= ~valbit; Col[ColIndex] &amp;= ~valbit; Place(S + 1, board); Entry[Square] = BLANK; // Could be moved out of the loop Block[BlockIndex] |= valbit; Row[RowIndex] |= valbit; Col[ColIndex] |= valbit; &#125; SwapSeqEntries(S, S2);&#125;void solveSudoku(char **board, int m, int n) &#123; SeqPtr = 0; int i, j, Square; for (i = 0; i &lt; 9; i++) for (j = 0; j &lt; 9; j++) &#123; Square = 9 * i + j; InRow[Square] = i; InCol[Square] = j; InBlock[Square] = (i / 3) * 3 + ( j / 3); &#125; for (Square = 0; Square &lt; 81; Square++) &#123; Sequence[Square] = Square; Entry[Square] = BLANK; &#125; for (i = 0; i &lt; 9; i++) Block[i] = Row[i] = Col[i] = ONES; for (int i = 0; i &lt; 9; ++i) for (int j = 0; j &lt; 9; ++j) &#123; if (&apos;.&apos; != board[i][j]) InitEntry(i, j, board[i][j] - &apos;0&apos;); &#125; Place(SeqPtr, board);&#125; https://discuss.leetcode.com/topic/5002/a-simple-dfs-solution A simple DFS solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) &#123; return true; &#125; void solveSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) &#123; util(board, 0); &#125; bool util(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) &#123; if (pos &gt;= 81) return true; int i = pos / 9; int j = pos % 9; if (board[i][j] != &apos;.&apos;) return util(board, pos + 1); else &#123; for (char c = &apos;1&apos;; c &lt;= &apos;9&apos;; c++) &#123; if (!isInRow(board, i,c) &amp;&amp; !isInCol(board, j, c) &amp;&amp; !isInRec(board, i, j, c)) &#123; board[i][j] = c; if (util(board, pos + 1)) return true; else board[i][j] = &apos;.&apos;; &#125; &#125; return false; &#125; &#125; bool isInRow(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, char c) &#123; vector&lt;char&gt;&amp; row = board[i]; for (int k = 0; k &lt; 9; k++) &#123; if (row[k] == c) return true; &#125; return false; &#125; bool isInCol(vector&lt;vector&lt;char&gt;&gt;&amp; board,int j, char c) &#123; for (int k = 0; k &lt; 9; k++) &#123; if (board[k][j] == c) return true; &#125; return false; &#125; bool isInRec(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, char c) &#123; int bigrow = i / 3, bigcol = j / 3; for (int m = 3 * bigrow; m &lt; 3 * (bigrow + 1); m++) &#123; for (int n = 3 * bigcol; n &lt; 3 * (bigcol + 1); n++) if (board[m][n] == c) return true; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/21103/simple-and-clean-solution-c Simple and Clean Solution / C++ 1234567891011121314151617181920212223242526272829303132bool check(vector&lt;vector&lt;char&gt;&gt; &amp;board, int i, int j, char val)&#123; int row = i - i%3, column = j - j%3; for(int x=0; x&lt;9; x++) if(board[x][j] == val) return false; for(int y=0; y&lt;9; y++) if(board[i][y] == val) return false; for(int x=0; x&lt;3; x++) for(int y=0; y&lt;3; y++) if(board[row+x][column+y] == val) return false; return true;&#125;bool solveSudoku(vector&lt;vector&lt;char&gt;&gt; &amp;board, int i, int j)&#123; if(i==9) return true; if(j==9) return solveSudoku(board, i+1, 0); if(board[i][j] != &apos;.&apos;) return solveSudoku(board, i, j+1); for(char c=&apos;1&apos;; c&lt;=&apos;9&apos;; c++) &#123; if(check(board, i, j, c)) &#123; board[i][j] = c; if(solveSudoku(board, i, j+1)) return true; board[i][j] = &apos;.&apos;; &#125; &#125; return false;&#125;public:void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;solveSudoku(board, 0, 0);&#125; https://discuss.leetcode.com/topic/27787/c-clear-solution-using-dfs-beating-90-c-coder C++ clear solution using dfs, beating 90% c++ coder. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: bool col[10][10],row[10][10],f[10][10]; bool flag = false; void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; memset(col,false,sizeof(col)); memset(row,false,sizeof(row)); memset(f,false,sizeof(f)); for(int i = 0; i &lt; 9;i++)&#123; for(int j = 0; j &lt; 9;j++)&#123; if(board[i][j] == &apos;.&apos;) continue; int temp = 3*(i/3)+j/3; int num = board[i][j]-&apos;0&apos;; col[j][num] = row[i][num] = f[temp][num] = true; &#125; &#125; dfs(board,0,0); &#125; void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,int i,int j)&#123; if(flag == true) return ; if(i &gt;= 9)&#123; flag = true; return ; &#125; if(board[i][j] != &apos;.&apos;)&#123; if(j &lt; 8) dfs(board,i,j+1); else dfs(board,i+1,0); if(flag) return; &#125; else&#123; int temp = 3*(i/3)+j/3; for(int n = 1; n &lt;= 9; n++)&#123; if(!col[j][n] &amp;&amp; !row[i][n] &amp;&amp; !f[temp][n])&#123; board[i][j] = n + &apos;0&apos;; col[j][n] = row[i][n] = f[temp][n] = true; if(j &lt; 8) dfs(board,i,j+1); else dfs(board,i+1,0); col[j][n] = row[i][n] = f[temp][n] = false; if(flag) return; &#125; &#125; board[i][j] = &apos;.&apos;; &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/18316/48ms-straitforward-python-dfs-solution-with-explanations 48ms straitforward python DFS solution with explanations It’s similar to how human solve Sudoku. create a hash table (dictionary) val to store possible values in every location. Each time, start from the location with fewest possible values, choose one value from it and then update the board and possible values at other locations. If this update is valid, keep solving (DFS). If this update is invalid (leaving zero possible values at some locations) or this value doesn’t lead to the solution, undo the updates and then choose the next value. Since we calculated val at the beginning and start filling the board from the location with fewest possible values, the amount of calculation and thus the runtime can be significantly reduced: The run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest python solutions here. The PossibleVals function may be further simplified/optimized, but it works just fine for now. (it would look less lengthy if we are allowed to use numpy array for the board lol). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556def solveSudoku(self, board): self.board = board self.val = self.PossibleVals() self.Solver()def PossibleVals(self): a = &quot;123456789&quot; d, val = &#123;&#125;, &#123;&#125; for i in xrange(9): for j in xrange(9): ele = self.board[i][j] if ele != &quot;.&quot;: d[(&quot;r&quot;, i)] = d.get((&quot;r&quot;, i), []) + [ele] d[(&quot;c&quot;, j)] = d.get((&quot;c&quot;, j), []) + [ele] d[(i//3, j//3)] = d.get((i//3, j//3), []) + [ele] else: val[(i,j)] = [] for (i,j) in val.keys(): inval = d.get((&quot;r&quot;,i),[])+d.get((&quot;c&quot;,j),[])+d.get((i/3,j/3),[]) val[(i,j)] = [n for n in a if n not in inval ] return valdef Solver(self): if len(self.val)==0: return True kee = min(self.val.keys(), key=lambda x: len(self.val[x])) nums = self.val[kee] for n in nums: update = &#123;kee:self.val[kee]&#125; if self.ValidOne(n, kee, update): # valid choice if self.Solver(): # keep solving return True self.undo(kee, update) # invalid choice or didn&apos;t solve it =&gt; undo return False def ValidOne(self, n, kee, update): self.board[kee[0]][kee[1]] = n del self.val[kee] i, j = kee for ind in self.val.keys(): if n in self.val[ind]: if ind[0]==i or ind[1]==j or (ind[0]/3,ind[1]/3)==(i/3,j/3): update[ind] = n self.val[ind].remove(n) if len(self.val[ind])==0: return False return Truedef undo(self, kee, update): self.board[kee[0]][kee[1]]=&quot;.&quot; for k in update: if k not in self.val: self.val[k]= update[k] else: self.val[k].append(update[k]) return None https://discuss.leetcode.com/topic/7475/accepted-python-solution Accepted Python solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution: # @param board, a 9x9 2D array # Solve the Sudoku by modifying the input board in-place. # Do not return any value. def solveSudoku(self, board): self.board = board self.solve() def findUnassigned(self): for row in range(9): for col in range(9): if self.board[row][col] == &quot;.&quot;: return row, col return -1, -1 def solve(self): row, col = self.findUnassigned() #no unassigned position is found, puzzle solved if row == -1 and col == -1: return True for num in [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;]: if self.isSafe(row, col, num): self.board[row][col] = num if self.solve(): return True self.board[row][col] = &quot;.&quot; return False def isSafe(self, row, col, ch): boxrow = row - row%3 boxcol = col - col%3 if self.checkrow(row,ch) and self.checkcol(col,ch) and self.checksquare(boxrow, boxcol, ch): return True return False def checkrow(self, row, ch): for col in range(9): if self.board[row][col] == ch: return False return True def checkcol(self, col, ch): for row in range(9): if self.board[row][col] == ch: return False return True def checksquare(self, row, col, ch): for r in range(row, row+3): for c in range(col, col+3): if self.board[r][c] == ch: return False return True It’s a simple backtracking solution.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[036. Valid Sudoku]]></title>
    <url>%2Fp%2F7b8b841d%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/valid-sudoku/ Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. A partially filled sudoku which is valid. Note: A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. java 38ms, 6.81%, September 20, 2016 https://discuss.leetcode.com/topic/9748/shared-my-concise-java-code Shared my concise Java code 123456789101112131415161718public class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; for(int i=0; i&lt;9; i++)&#123; HashSet&lt;Character&gt; rows = new HashSet&lt;Character&gt;(); HashSet&lt;Character&gt; columns = new HashSet&lt;Character&gt;(); HashSet&lt;Character&gt; cube = new HashSet&lt;Character&gt;(); for(int j=0; j &lt; 9; j++)&#123; if(board[i][j] != &apos;.&apos; &amp;&amp; !rows.add(board[i][j])) return false; if(board[j][i] != &apos;.&apos; &amp;&amp; !columns.add(board[j][i])) return false; int RowIndex = 3*(i/3); int ColIndex = 3*(i%3); if(board[RowIndex+j/3][ColIndex+j%3]!=&apos;.&apos; &amp;&amp; !cube.add(board[RowIndex+j/3][ColIndex+j%3])) return false; &#125; &#125; return true; &#125;&#125; https://discuss.leetcode.com/topic/5803/sharing-my-easy-understand-java-solution-using-set Sharing my easy-understand java solution using set 1234567891011121314151617181920212223public class Solution &#123;public boolean isValidSudoku(char[][] board) &#123; for (int i=0; i&lt;9; i++) &#123; if (!isParticallyValid(board,i,0,i,8)) return false; if (!isParticallyValid(board,0,i,8,i)) return false; &#125; for (int i=0;i&lt;3;i++)&#123; for(int j=0;j&lt;3;j++)&#123; if (!isParticallyValid(board,i*3,j*3,i*3+2,j*3+2)) return false; &#125; &#125; return true;&#125;private boolean isParticallyValid(char[][] board, int x1, int y1,int x2,int y2)&#123; Set singleSet = new HashSet(); for (int i= x1; i&lt;=x2; i++)&#123; for (int j=y1;j&lt;=y2; j++)&#123; if (board[i][j]!=&apos;.&apos;) if(!singleSet.add(board[i][j])) return false; &#125; &#125; return true;&#125;&#125; Each time send the coordinates to check if the board is partially valid. https://discuss.leetcode.com/topic/27436/short-simple-java-using-strings Short+Simple Java using Strings Collect the set of things we see, encoded as strings. For example: ‘4’ in row 7 is encoded as “(4)7”.‘4’ in column 7 is encoded as “7(4)”.‘4’ in the top-right block is encoded as “0(4)2”.Scream false if we ever fail to add something because it was already added (i.e., seen before). 12345678910111213public boolean isValidSudoku(char[][] board) &#123; Set seen = new HashSet(); for (int i=0; i&lt;9; ++i) &#123; for (int j=0; j&lt;9; ++j) &#123; if (board[i][j] != &apos;.&apos;) &#123; String b = &quot;(&quot; + board[i][j] + &quot;)&quot;; if (!seen.add(b + i) || !seen.add(j + b) || !seen.add(i/3 + b + j/3)) return false; &#125; &#125; &#125; return true;&#125; Edit: Just occurred to me that we can also make it really clear and self-explaining. I’m loving it. 1234567891011121314public boolean isValidSudoku(char[][] board) &#123; Set seen = new HashSet(); for (int i=0; i&lt;9; ++i) &#123; for (int j=0; j&lt;9; ++j) &#123; char number = board[i][j]; if (number != &apos;.&apos;) if (!seen.add(number + &quot; in row &quot; + i) || !seen.add(number + &quot; in column &quot; + j) || !seen.add(number + &quot; in block &quot; + i/3 + &quot;-&quot; + j/3)) return false; &#125; &#125; return true;&#125; https://discuss.leetcode.com/topic/40078/yet-another-java-2ms-solution Yet another java 2ms solution 1234567891011121314151617181920public boolean isValidSudoku(char[][] board) &#123; int [] vset = new int [9]; int [] hset = new int [9]; int [] bckt = new int [9]; int idx = 0; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != &apos;.&apos;) &#123; idx = 1 &lt;&lt; (board[i][j] - &apos;0&apos;) ; if ((hset[i] &amp; idx) &gt; 0 || (vset[j] &amp; idx) &gt; 0 || (bckt[(i / 3) * 3 + j / 3] &amp; idx) &gt; 0) return false; hset[i] |= idx; vset[j] |= idx; bckt[(i / 3) * 3 + j / 3] |= idx; &#125; &#125; &#125; return true;&#125; cpp 16ms, 34.54%, September 20, 2016 https://discuss.leetcode.com/topic/8241/my-short-solution-by-c-o-n2 My short solution by C++. O(n2) Three flags are used to check whether a number appear. used1: check each row used2: check each column used3: check each sub-boxes 1234567891011121314class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int used1[9][9] = &#123;0&#125;, used2[9][9] = &#123;0&#125;, used3[9][9] = &#123;0&#125;; for(int i = 0; i&lt;board.size(); ++i) for(int j = 0; j &lt; board[i].size(); ++j) if(board[i][j] != &apos;.&apos;)&#123; int num = board[i][j] - &apos;0&apos; - 1, k = i/3*3 + j/3; if(used1[i][num] || used2[j][num] || used3[k][num]) return false; used1[i][num] = used2[j][num] = used3[k][num] = 1; &#125; return true; &#125;&#125;; https://discuss.leetcode.com/topic/20201/c-very-simple-and-easy-understand-using-bit-operation C++ very simple and easy understand. using bit operation 1234567891011121314151617bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; vector&lt;short&gt; col(9, 0); vector&lt;short&gt; block(9, 0); vector&lt;short&gt; row(9, 0); for (int i = 0; i &lt; 9; i++) for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != &apos;.&apos;) &#123; int idx = 1 &lt;&lt; (board[i][j] - &apos;0&apos;); if (row[i] &amp; idx || col[j] &amp; idx || block[i/3 * 3 + j / 3] &amp; idx) return false; row[i] |= idx; col[j] |= idx; block[i/3 * 3 + j/3] |= idx; &#125; &#125; return true; &#125; https://discuss.leetcode.com/topic/15917/my-12-lines-c-c-solution-with-1-time-traversal-and-9x9x3-memory My 12 lines C/C++ solution with 1 time traversal and 9x9x3 memory 1234567891011121314int isValidSudoku(char** board, int boardRowSize, int boardColSize) &#123; int rows[9][9]=&#123;0&#125;; //rows[5][0] means whether number 1(&apos;0&apos;+1) in row 5 has appeared. int cols[9][9]=&#123;0&#125;; //cols[3][8] means whether number 9(&apos;8&apos;+1) in col 3 has appeared. int blocks[3][3][9]=&#123;0&#125;;//blocks[0][2][5] means whether number &apos;6&apos; in block 0,2 (row 0~2,col 6~8) has appeared. for(int r=0;r&lt;9;r++) //traverse board r,c for(int c=0;c&lt;9;c++) if(board[r][c]!=&apos;.&apos;)&#123; //skip all number &apos;.&apos; int number=board[r][c]-&apos;1&apos;; //calculate the number&apos;s index(board&apos;s number minus 1) if(rows[r][number]++) return 0; //if the number has already appeared once, return false. if(cols[c][number]++) return 0; if(blocks[r/3][c/3][number]++) return 0; &#125; return 1;&#125; python https://discuss.leetcode.com/topic/20016/1-7-lines-python-4-solutions 1-7 lines Python, 4 solutions Idea Just go through all you see (like “7 in row 3”) and check for duplicates. Solution 1 Using Counter. One logical line, seven physical lines. 12345678def isValidSudoku(self, board): return 1 == max(collections.Counter( x for i, row in enumerate(board) for j, c in enumerate(row) if c != &apos;.&apos; for x in ((c, i), (j, c), (i/3, j/3, c)) ).values() + [1]) The + [1] is only for the empty board, where max would get an empty list and complain. It’s not necessary to get it accepted here, as the empty board isn’t among the test cases, but it’s good to have. Solution 2 Using len(set). 123456def isValidSudoku(self, board): seen = sum(([(c, i), (j, c), (i/3, j/3, c)] for i, row in enumerate(board) for j, c in enumerate(row) if c != &apos;.&apos;), []) return len(seen) == len(set(seen)) Solution 3 Using any. 1234567def isValidSudoku(self, board): seen = set() return not any(x in seen or seen.add(x) for i, row in enumerate(board) for j, c in enumerate(row) if c != &apos;.&apos; for x in ((c, i), (j, c), (i/3, j/3, c))) Solution 4 Iterating a different way. 12345def isValidSudoku(self, board): seen = sum(([(c, i), (j, c), (i/3, j/3, c)] for i in range(9) for j in range(9) for c in [board[i][j]] if c != &apos;.&apos;), []) return len(seen) == len(set(seen)) https://discuss.leetcode.com/topic/20016/1-7-lines-python-4-solutions/2 Your solutions are briliant! Just another way to write Solution2: 1234567def isValidSudoku(self, board): seen = [] for i, row in enumerate(board): for j, c in enumerate(row): if c != &apos;.&apos;: seen += [(c,j),(i,c),(i/3,j/3,c)] return len(seen) == len(set(seen))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[035. Search Insert Position]]></title>
    <url>%2Fp%2F370b1fef%2F</url>
    <content type="text"><![CDATA[37.9% https://leetcode.com/problems/search-insert-position/ Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. 12345Here are few examples.[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 方法一： 评价：It’s just lower bound binary search. https://leetcode.com/discuss/39829/c-o-logn-binary-search-that-handles-duplicate C++ O(logn) Binary Search that handles duplicate If there are duplicate elements equal to target, my code will always return the one with smallest index. 1234567891011121314151617181920212223242526class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int low = 0, high = nums.size()-1; // Invariant: the desired index is between [low, high+1] while (low &lt;= high) &#123; int mid = low + (high-low)/2; if (nums[mid] &lt; target) low = mid+1; else high = mid-1; &#125; // (1) At this point, low &gt; high. That is, low &gt;= high+1 // (2) From the invariant, we know that the index is between [low, high+1], // so low &lt;= high+1. Follwing from (1), now we know low == high+1. // (3) Following from (2), the index is between [low, high+1] = [low, low], //which means that low is the desired index // Therefore, we return low as the answer. //You can also return high+1 as the result, //since low == high+1 return low; &#125;&#125;; 方法二： A simple CPP solution with lower_bound Actually, what we need here is std::lower_bound in C++ STL, which returns an iterator pointing to the first element that does not less than target. And then, things are quite simple: 123456class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; return lower_bound(nums.begin(), nums.end(), target) - nums.begin(); &#125;&#125;; Or we can implement an inline lower_bound: 123456789101112131415class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; auto first = nums.begin(), last = nums.end(); while (first &lt; last) &#123; auto mid = first + ((last - first) &gt;&gt; 1); if (*mid &lt; target) &#123; first = mid + 1; &#125; else &#123; last = mid; &#125; &#125; return first - nums.begin(); &#125;&#125;; cpp 8ms, 15.81%, June.18th, 2016 https://leetcode.com/discuss/39829/c-o-logn-binary-search-that-handles-duplicate C++ O(logn) Binary Search that handles duplicate If there are duplicate elements equal to target, my code will always return the one with smallest index. 12345678910111213141516171819202122class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int low = 0, high = nums.size()-1; // Invariant: the desired index is between [low, high+1] while (low &lt;= high) &#123; int mid = low + (high-low)/2; if (nums[mid] &lt; target) low = mid+1; else high = mid-1; &#125; // (1) At this point, low &gt; high. That is, low &gt;= high+1 // (2) From the invariant, we know that the index is between [low, high+1], so low &lt;= high+1. Follwing from (1), now we know low == high+1. // (3) Following from (2), the index is between [low, high+1] = [low, low], which means that low is the desired index // Therefore, we return low as the answer. You can also return high+1 as the result, since low == high+1 return low; &#125;&#125;; https://discuss.leetcode.com/topic/7648/my-8ms-accepted-code My 8ms accepted code. 1234567891011121314151617class Solution &#123;public: int searchInsert(int A[], int n, int target) &#123; int low = 0,high = n - 1; while (low &lt;= high)&#123; int mid = (low + high) / 2; if(A[mid]==target) return mid; else if (A[mid] &gt;target)&#123; high = mid - 1; &#125; else&#123; low = mid + 1; &#125; &#125; return low; &#125;&#125;; https://discuss.leetcode.com/topic/16628/a-simple-cpp-solution-with-lower_bound A simple CPP solution with lower_bound Actually, what we need here is std::lower_bound in C++ STL, which returns an iterator pointing to the first element that does not less than target. And then, things are quite simple: 123456class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; return lower_bound(nums.begin(), nums.end(), target) - nums.begin(); &#125;&#125;; Or we can implement an inline lower_bound: 123456789101112131415class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; auto first = nums.begin(), last = nums.end(); while (first &lt; last) &#123; auto mid = first + ((last - first) &gt;&gt; 1); if (*mid &lt; target) &#123; first = mid + 1; &#125; else &#123; last = mid; &#125; &#125; return first - nums.begin(); &#125;&#125;; https://discuss.leetcode.com/topic/20299/my-understanding-of-lower-bound-upper-bound-binary-search-in-c-thanks-to-two-post My understanding of (lower bound,upper bound) binary search, in C++, thanks to two post thanks to A simple CPP solution with lower_boundand C++ O(logn) Binary Search that handles duplicate, thanks to phu1ku ‘s answer on the second post. links for std::lower_bound and std::upper_bound 12345678910111213141516171819class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; /// return index of first one that comp(item,target)==true, or nums.size() if not found /// comp is greater or equal to for lower_bound /// comp is greater for upper_bound int first=0, last=nums.size(), mid; while (first&lt;last) &#123; mid=first+((last-first)&gt;&gt;1); // first&lt;=mid, mid&lt;last /// if comp(item,target)==false, advance first // if(nums[mid]&lt;=target) // for upper_bound if (nums[mid]&lt;target) // for lower_bound first=mid+1; // first always increases else /// else recede last last=mid; // last always decreases (even last-first==1) &#125; return first; &#125;&#125;; python https://discuss.leetcode.com/topic/25828/python-beats-98 Python beats 98% Once the left border is larger than key, than return index. Once the right border is less than key, then return index. 12345678910111213141516171819202122232425262728class Solution(object):def searchInsert(self, nums, key): if key &gt; nums[len(nums) - 1]: return len(nums) if key &lt; nums[0]: return 0 l, r = 0, len(nums) - 1 while l &lt;= r: m = (l + r)/2 if nums[m] &gt; key: r = m - 1 if r &gt;= 0: if nums[r] &lt; key: return r + 1 else: return 0 elif nums[m] &lt; key: l = m + 1 if l &lt; len(nums): if nums[l] &gt; key: return l else: return len(nums) else: return m https://discuss.leetcode.com/topic/30370/python-one-liner-48ms Python one liner 48ms 12345678class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; return len([x for x in nums if x&lt;target]) Solution Mine: 64ms, 5.76%, June.18th, 2016 123456789101112131415class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if target &lt;= nums[0]: return 0 if target &gt; nums[-1]: return len(nums) rtype = 0 while target &gt; nums[rtype]: rtype += 1 return rtype 48ms, 60.93%, June.18th, 2016 https://leetcode.com/discuss/61347/python-beats-98%25 123456789101112131415161718192021222324252627282930313233class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if target &gt; nums[len(nums) - 1]: return len(nums) if target &lt; nums[0]: return 0 l, r = 0, len(nums) - 1 while l &lt;= r: m = (l + r)/2 if nums[m] &gt; target: r = m - 1 if r &gt;= 0: if nums[r] &lt; target: return r + 1 else: return 0 elif nums[m] &lt; target: l = m + 1 if l &lt; len(nums): if nums[l] &gt; target: return l else: return len(nums) else: return m java 0ms, 17.55%, June.18h, 2016 https://leetcode.com/discuss/23076/my-8-line-java-solution My 8 line Java solution 1234567891011public class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int low = 0, high = nums.length; while(low &lt; high)&#123; int mid = low + (high-low) / 2; if(nums[mid] &gt;= target) high = mid; else low = mid + 1; &#125; return low; &#125;&#125; https://discuss.leetcode.com/topic/31499/very-concise-and-efficient-solution-in-java Very concise and efficient solution in Java I have several solutions to this problem; this is the most concise and efficient one I have. 12345678910111213public class Solution &#123;public int searchInsert(int[] nums, int target) &#123; int low = 0, high = nums.length; while(low &lt; high) &#123; int mid = low + (high - low) / 2; if(nums[mid] &lt; target) low = mid + 1; else high = mid; &#125; return low;&#125;&#125; https://discuss.leetcode.com/topic/2661/simple-binary-search-solution Simple Binary Search Solution I think the solution does not need a lot of if statement. Only two cases: if found, just return current index if not found, return next index where the search end 12345678910int search(int A[], int start, int end, int target) &#123; if (start &gt; end) return start; int mid = (start + end) / 2; if (A[mid] == target) return mid; else if (A[mid] &gt; target) return search(A, start, mid - 1, target); else return search(A, mid + 1, end, target);&#125;int searchInsert(int A[], int n, int target) &#123; return search(A, 0, n - 1, target);&#125; https://discuss.leetcode.com/topic/4764/accepted-o-logn-java-solution-binary-search Accepted O(logN) Java solution, binary search 12345678910111213141516171819202122232425262728public class Solution &#123; public int searchInsert(int[] A, int target) &#123; if(A.length == 0)return 0; int left = 0, right = A.length - 1; int mid = 0; while(left &lt;= right)&#123; if(target&lt;A[left])return left; if(target&gt;A[right])return right+1; mid = (left+right)/2; if(A[mid]==target)return mid; else if(target &lt; A[mid])&#123; right = mid-1; &#125;else&#123; left = mid +1; &#125; &#125; return -1; &#125;&#125; https://discuss.leetcode.com/topic/20133/simple-java-solution Simple Java solution 1234567public int searchInsert(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt;= target) return i; &#125; return nums.length;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[034. Search for a Range]]></title>
    <url>%2Fp%2Fffb88a9b%2F</url>
    <content type="text"><![CDATA[34.1% https://leetcode.com/problems/search-for-a-range/ Given a sorted array of integers, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. 123For example,Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. 剑指offer 38 方法一： 先找最左侧边界，然后右侧边界 我的代码实现: 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int left, right; // 这里是nums.size() 不是nums.size()-1 int l = 0, r = nums.size(); while(l&lt;r)&#123; int mid = l+(r-l)/2; if(nums[mid]&gt;=target) r = mid; else l = mid+1; &#125; left = l; l = 0, r = nums.size(); while(l&lt;r)&#123; int mid = l+(r-l)/2; if(nums[mid]&lt;=target) l = mid+1; else r = mid; &#125; right = l; // lower_bound和upper_bound相等时，一定是不等于额 &gt;= &gt;相等 一定是大于 return left==right?vector&lt;int&gt;&#123;-1, -1&#125; : vector&lt;int&gt;&#123;left, right-1&#125;; &#125;&#125;; 还有就是学一下这种写法：vector {-1,-1} The standard and clean c++ binary search implementation. Yeah, binary search is quite simple, but many people write complex and error-prone code. 123456789101112131415161718192021vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int start = 0, end = nums.size(), mid, left, right; while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt;= target) end = mid; else start = mid + 1; &#125; left = start; start = 0, end = nums.size(); while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt; target) end = mid; else start = mid + 1; &#125; right = start; return left == right ? vector&lt;int&gt; &#123;-1,-1&#125; : vector&lt;int&gt; &#123;left,right-1&#125;;&#125; 方法二: 就是lower_bound upper_bound两个函数，但是要记得他们的边界，以及相应函数使用方法 还有使用迭代器求元素的位置索引的方法，以及返回vector怎么去初始化返回 1234567891011class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; auto itlow = lower_bound(nums.begin(), nums.end(), target); auto itup = upper_bound(nums.begin(), nums.end(), target); if(itlow==nums.end() || (*itlow)!=target) return &#123;-1, -1&#125;; else return &#123;itlow-nums.begin(), itup-nums.begin()-1&#125;; &#125;&#125;; cpp 12ms, 19.84%, June.22th, 2016 https://leetcode.com/discuss/18242/clean-iterative-solution-binary-searches-with-explanation Clean iterative solution with two binary searches (with explanation) The problem can be simply broken down as two binary searches for the begining and end of the range, respectively: First let’s find the left boundary of the range. We initialize the range to [i=0, j=n-1]. In each step, calculate the middle element [mid = (i+j)/2]. Now according to the relative value of A[mid] to target, there are three possibilities: If A[mid] &lt; target, then the range must begins on the right of mid (hence i = mid+1 for the next iteration) If A[mid] &gt; target, it means the range must begins on the left of mid (j = mid-1) If A[mid] = target, then the range must begins on the left of or at mid (j= mid) Since we would move the search range to the same side for case 2 and 3, we might as well merge them as one single case so that less code is needed: 12*. If A[mid] &gt;= target, j = mid; Surprisingly, 1 and 2* are the only logic you need to put in loop while (i &lt; j). When the while loop terminates, the value of i/j is where the start of the range is. Why? No matter what the sequence originally is, as we narrow down the search range, eventually we will be at a situation where there are only two elements in the search range. Suppose our target is 5, then we have only 7 possible cases: 1234567case 1: [5 7] (A[i] = target &lt; A[j])case 2: [5 3] (A[i] = target &gt; A[j])case 3: [5 5] (A[i] = target = A[j])case 4: [3 5] (A[j] = target &gt; A[i])case 5: [3 7] (A[i] &lt; target &lt; A[j])case 6: [3 4] (A[i] &lt; A[j] &lt; target)case 7: [6 7] (target &lt; A[i] &lt; A[j]) For case 1, 2 and 3, if we follow the above rule, since mid = i =&gt; A[mid] = target in these cases, then we would set j = mid. Now the loop terminates and i and j both point to the first 5. For case 4, since A[mid] &lt; target, then set i = mid+1. The loop terminates and both i and j point to 5. For all other cases, by the time the loop terminates, A[i] is not equal to 5. So we can easily know 5 is not in the sequence if the comparison fails. In conclusion, when the loop terminates, if A[i]==target, then i is the left boundary of the range; otherwise, just return -1; For the right of the range, we can use a similar idea. Again we can come up with several rules: If A[mid] &gt; target, then the range must begins on the left of mid (j = mid-1) If A[mid] &lt; target, then the range must begins on the right of mid (hence i = mid+1 for the next iteration) If A[mid] = target, then the range must begins on the right of or at mid (i= mid) Again, we can merge condition 2 and 3 into: 12* If A[mid] &lt;= target, then i = mid; However, the terminate condition on longer works this time. Consider the following case: 1[5 7], target = 5 Now A[mid] = 5, then according to rule 2, we set i = mid. This practically does nothing because i is already equal to mid. As a result, the search range is not moved at all! The solution is by using a small trick: instead of calculating mid as mid = (i+j)/2, we now do: 1mid = (i+j)/2+1 Why does this trick work? When we use mid = (i+j)/2, the mid is rounded to the lowest integer. In other words, mid is always biased towards the left. This means we could have i == mid when j - i == mid, but we NEVER have j == mid. So in order to keep the search range moving, you must make sure the new i is set to something different than mid, otherwise we are at the risk that i gets stuck. But for the new j, it is okay if we set it to mid, since it was not equal to mid anyways. Our two rules in search of the left boundary happen to satisfy these requirements, so it works perfectly in that situation. Similarly, when we search for the right boundary, we must make sure i won’t get stuck when we set the new i to i = mid. The easiest way to achieve this is by making mid biased to the right, i.e. mid = (i+j)/2+1. All this reasoning boils down to the following simple code: 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int i = 0, j = nums.size() - 1; vector&lt;int&gt; ret(2, -1); while(i &lt; j)&#123; int mid = (i + j) / 2; if(nums[mid] &lt; target) i = mid + 1; else j = mid; &#125; if(nums[i] != target) return ret; else ret[0] = i; j = nums.size() - 1; while(i &lt; j)&#123; int mid = (i + j) / 2 + 1; if(nums[mid] &gt; target) j = mid - 1; else i = mid; &#125; ret[1] = j; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/19437/the-standard-and-clean-c-binary-search-implementation The standard and clean c++ binary search implementation. Yeah, binary search is quite simple, but many people write complex and error-prone code. 123456789101112131415161718192021vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int start = 0, end = nums.size(), mid, left, right; while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt;= target) end = mid; else start = mid + 1; &#125; left = start; start = 0, end = nums.size(); while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt; target) end = mid; else start = mid + 1; &#125; right = start; return left == right ? vector&lt;int&gt; &#123;-1,-1&#125; : vector&lt;int&gt; &#123;left,right-1&#125;;&#125; python 56ms, 46.67%, June.22th, 2016 https://leetcode.com/discuss/18242/clean-iterative-solution-binary-searches-with-explanation 123456789101112131415161718192021222324252627282930class Solution(object): def searchRange(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; l, r = 0, len(nums) - 1 res = [-1, -1] while(l &lt; r): mid = (l + r) / 2 if nums[mid] &lt; target: l = mid + 1 else: r = mid if nums[l] != target: return res else: res[0] = l r = len(nums) - 1 while(l &lt; r): mid = (l + r) / 2 + 1 if nums[mid] &gt; target: r = mid - 1 else: l = mid res[1] = r return res 52ms, 65.78%, June.22th, 2016 https://leetcode.com/discuss/18242/clean-iterative-solution-binary-searches-with-explanation 123456789101112131415161718192021222324252627282930313233class Solution(object): def searchRange(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; if not nums: return [-1, -1] l, r = 0, len(nums) - 1 res = [-1, -1] while(l &lt; r): mid = (l + r) / 2 if nums[mid] &lt; target: l = mid + 1 else: r = mid if nums[l] != target: return res else: res[0] = l r = len(nums) - 1 while(l &lt; r): mid = (l + r) / 2 + 1 if nums[mid] &gt; target: r = mid - 1 else: l = mid res[1] = r return res https://discuss.leetcode.com/topic/16486/9-11-lines-o-log-n 9-11 lines O(log n) Solution 1 : Divide and Conquer with early breaks : 56 ms The O(log n) time isn’t quite obvious, so I’ll explain it below. Or you can take the challenge and prove it yourself :-) 12345678910def searchRange(self, nums, target): def search(lo, hi): if nums[lo] == target == nums[hi]: return [lo, hi] if nums[lo] &lt;= target &lt;= nums[hi]: mid = (lo + hi) / 2 l, r = search(lo, mid), search(mid+1, hi) return max(l, r) if -1 in l+r else [l[0], r[1]] return [-1, -1] return search(0, len(nums)-1) The search helper function returns an index range just like the requested searchRange function, but only searches in nums[lo..hi]. It first compares the end points and immediately returns [lo, hi] if that whole part of nums is full of target, and immediately returns [-1, -1] if target is outside the range. The interesting case is when target can be in the range but doesn’t fill it completely. In that case, we split the range in left and right half, solve them recursively, and combine their results appropriately. Why doesn’t this explode exponentially? Well, let’s call the numbers in the left half A, …, B and the numbers in the right half C, …, D. Now if one of them immediately return their [lo, hi] or [-1, -1], then this doesn’t explode. And if neither immediately returns, that means we have A &lt;= target &lt;= B and C &lt;= target &lt;= D. And since nums is sorted, we actually have target &lt;= B &lt;= C &lt;= target, so B = C = target. The left half thus ends with target and the right half starts with it. I highlight that because it’s important. Now consider what happens further. The left half gets halved again. Call the middle elements a and b, so the left half is A, …, a, b, …, B. Then a &lt;= target and: If a &lt; target, then the call analyzing A, …, a immediately returns [-1, -1] and we only look further into b, …, B which is again a part that ends with target. If a == target, then a = b = … = B = target and thus the call analyzing b, …, B immediately returns its [lo, hi] and we only look further into A, …, a which is again a part that ends with target.Same for the right half C, …, D. So in the beginning of the search, as long as target is only in at most one of the two halves (so the other immediately stops), we have a single path. And if we ever come across the case where target is in both halves, then we split into two paths, but then each of those remains a single path. And both paths are only O(log n) long, so we have overall runtime O(log n). This is btw based on us917’s solution. 1234567891011121314Solution 2 : Two binary searches : 56 msdef searchRange(self, nums, target): def search(n): lo, hi = 0, len(nums) while lo &lt; hi: mid = (lo + hi) / 2 if nums[mid] &gt;= n: hi = mid else: lo = mid + 1 return lo lo = search(target) return [lo, search(target+1)-1] if target in nums[lo:lo+1] else [-1, -1] Here, my helper function is a simple binary search, telling me the first index where I could insert a number n into nums to keep it sorted. Thus, if nums contains target, I can find the first occurrence with search(target). I do that, and if target isn’t actually there, then I return [-1, -1]. Otherwise, I ask search(target+1), which tells me the first index where I could insert target+1, which of course is one index behind the last index containing target, so all I have left to do is subtract 1. Solution 3 : Two binary searches, using the library Binary search is so good and common that many languages have it in their standard library and you just need to figure out how to apply it to the problem at hand. Python: 123def searchRange(self, nums, target): lo = bisect.bisect_left(nums, target) return [lo, bisect.bisect(nums, target)-1] if target in nums[lo:lo+1] else [-1, -1] C++: 123456vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; auto bounds = equal_range(nums.begin(), nums.end(), target); return *bounds.first != target ? vector&lt;int&gt; &#123;-1, -1&#125; : vector&lt;int&gt; &#123;bounds.first - nums.begin(), bounds.second - nums.begin() - 1&#125;;&#125; Or: 1234567vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = lower_bound(nums.begin(), nums.end(), target) - nums.begin(); if (nums[lo] != target) return vector&lt;int&gt; &#123;-1, -1&#125;; int hi = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1; return vector&lt;int&gt; &#123;lo, hi&#125;;&#125; Java: Well, Java decided to be annoying and offer Arrays.binSearch but with “If the array contains multiple elements with the specified value, there is no guarantee which one will be found”. So it’s useless for us. I’m not good at Java, though, so maybe I’m overlooking a way to still make it work. If you manage to do so, please let me know. java https://discuss.leetcode.com/topic/6327/a-very-simple-java-solution-with-only-one-binary-search-algorithm/2 A very simple Java solution, with only one binary search algorithm 12345678910111213141516171819202122232425262728public class Solution &#123; public int[] searchRange(int[] A, int target) &#123; int start = Solution.firstGreaterEqual(A, target); if (start == A.length || A[start] != target) &#123; return new int[]&#123;-1, -1&#125;; &#125; return new int[]&#123;start, Solution.firstGreaterEqual(A, target + 1) - 1&#125;; &#125; //find the first number that is greater than or equal to target. //could return A.length if target is greater than A[A.length-1]. //actually this is the same as lower_bound in C++ STL. private static int firstGreaterEqual(int[] A, int target) &#123; int low = 0, high = A.length; while (low &lt; high) &#123; int mid = low + ((high - low) &gt;&gt; 1); //low &lt;= mid &lt; high if (A[mid] &lt; target) &#123; low = mid + 1; &#125; else &#123; //should not be mid-1 when A[mid]==target. //could be mid even if A[mid]&gt;target because mid&lt;high. high = mid; &#125; &#125; return low; &#125;&#125; https://discuss.leetcode.com/topic/10692/simple-and-strict-o-logn-solution-in-java-using-recursion Simple and strict O(logn) solution in Java using recursion 123456789101112131415161718192021222324252627public class Solution &#123; public int[] searchRange(int[] A, int target) &#123; int[] range = &#123;A.length, -1&#125;; searchRange(A, target, 0, A.length - 1, range); if (range[0] &gt; range[1]) range[0] = -1; return range; &#125; public void searchRange(int[] A, int target, int left, int right, int[] range) &#123; if (left &gt; right) return; int mid = left + (right - left) / 2; if (A[mid] == target) &#123; if (mid &lt; range[0]) &#123; range[0] = mid; searchRange(A, target, left, mid - 1, range); &#125; if (mid &gt; range[1]) &#123; range[1] = mid; searchRange(A, target, mid + 1, right, range); &#125; &#125; else if (A[mid] &lt; target) &#123; searchRange(A, target, mid + 1, right, range); &#125; else &#123; searchRange(A, target, left, mid - 1, range); &#125; &#125;&#125; https://discuss.leetcode.com/topic/21783/easy-java-o-logn-solution Easy java O(logn) solution There must be two indices in the array. Which means, we can just simply apply to binary search twice to find each index of the target element. 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123;public int[] searchRange(int[] nums, int target) &#123; int[] result = new int[2]; result[0] = findFirst(nums, target); result[1] = findLast(nums, target); return result;&#125;private int findFirst(int[] nums, int target)&#123; int idx = -1; int start = 0; int end = nums.length - 1; while(start &lt;= end)&#123; int mid = (start + end) / 2; if(nums[mid] &gt;= target)&#123; end = mid - 1; &#125;else&#123; start = mid + 1; &#125; if(nums[mid] == target) idx = mid; &#125; return idx;&#125;private int findLast(int[] nums, int target)&#123; int idx = -1; int start = 0; int end = nums.length - 1; while(start &lt;= end)&#123; int mid = (start + end) / 2; if(nums[mid] &lt;= target)&#123; start = mid + 1; &#125;else&#123; end = mid - 1; &#125; if(nums[mid] == target) idx = mid; &#125; return idx;&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[033. Search in Rotated Sorted Array]]></title>
    <url>%2Fp%2Ff6d1f394%2F</url>
    <content type="text"><![CDATA[32.1% https://leetcode.com/problems/search-in-rotated-sorted-array/ Suppose a sorted array is rotated at some pivot unknown to you beforehand. 1(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 方法一： 二分查找 面试奇虎360曾遇到过 我的代码实现，最清晰最明了。 简单易懂。就按这个来了。 设定一个左index，一个右index。肯定要用到中间的index，即mid。 在循环里面，首先算出mid的值，然后如果中间值等于target，返回结果。否则就要搜索了。 怎么搜索呢，要分情况讨论，现在有的值是left，right，mid 和target，用什么分好呢？ 用不用target？答案是不用。要用left和mid这样的值来比较，判断当前所处的环境， 即左半部分的情况，看左边是上升，还是先上升后从最小值上升。 右边是上升还是从最小值上升。 1234567891011121314151617181920212223242526class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if(n==0) return -1; int left=0, right = n-1; while(left&lt;=right)&#123; int mid = left+(right-left)/2; if(nums[mid]==target) return mid; if(nums[left]&lt;=nums[mid])&#123; // 这里是&lt;= 而不是&lt;，因为left可能=mid的情况，否则不能通过。 if(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid])&#123; right = mid-1; &#125;else&#123; left = mid+1; &#125; &#125;else&#123; if(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right]) left = mid+1; else right = mid-1; &#125; &#125; return -1; &#125;&#125;; 方法二： Revised Binary Search 这种方法较好，最后return需要判断与target的关系 1234567891011121314151617181920212223public int search(int[] A, int target) &#123; int lo = 0; int hi = A.length - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if (A[mid] == target) return mid; if (A[lo] &lt;= A[mid]) &#123; if (target &gt;= A[lo] &amp;&amp; target &lt; A[mid]) &#123; hi = mid - 1; &#125; else &#123; lo = mid + 1; &#125; &#125; else &#123; if (target &gt; A[mid] &amp;&amp; target &lt;= A[hi]) &#123; lo = mid + 1; &#125; else &#123; hi = mid - 1; &#125; &#125; &#125; return A[lo] == target ? lo : -1;&#125; cpp https://discuss.leetcode.com/topic/7711/revised-binary-search Revised Binary Search 1234567891011121314151617181920212223public int search(int[] A, int target) &#123; int lo = 0; int hi = A.length - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if (A[mid] == target) return mid; if (A[lo] &lt;= A[mid]) &#123; if (target &gt;= A[lo] &amp;&amp; target &lt; A[mid]) &#123; hi = mid - 1; &#125; else &#123; lo = mid + 1; &#125; &#125; else &#123; if (target &gt; A[mid] &amp;&amp; target &lt;= A[hi]) &#123; lo = mid + 1; &#125; else &#123; hi = mid - 1; &#125; &#125; &#125; return A[lo] == target ? lo : -1;&#125; https://discuss.leetcode.com/topic/34491/clever-idea-making-it-simple Clever idea making it simple This very nice idea is from rantos22’s solution who sadly only commented “You are not expected to understand that :)”, which I guess is the reason it’s now it’s hidden among the most downvoted solutions. I present an explanation and a more usual implementation. Explanation Let’s say nums looks like this: [12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] Because it’s not fully sorted, we can’t do normal binary search. But here comes the trick: If target is let’s say 14, then we adjust nums to this, where “inf” means infinity:[12, 13, 14, 15, 16, 17, 18, 19, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf] If target is let’s say 7, then we adjust nums to this:[-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] And then we can simply do ordinary binary search. Of course we don’t actually adjust the whole array but instead adjust only on the fly only the elements we look at. And the adjustment is done by comparing both the target and the actual element against nums[0]. Code If nums[mid] and target are “on the same side” of nums[0], we just take nums[mid]. Otherwise we use -infinity or +infinity as needed. 123456789101112131415161718int search(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, hi = nums.size(); while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; double num = (nums[mid] &lt; nums[0]) == (target &lt; nums[0]) ? nums[mid] : target &lt; nums[0] ? -INFINITY : INFINITY; if (num &lt; target) lo = mid + 1; else if (num &gt; target) hi = mid; else return mid; &#125; return -1;&#125; python https://discuss.leetcode.com/topic/13096/python-binary-search-solution-o-logn-48ms Python binary search solution - O(logn) - 48ms 123456789101112131415161718192021222324252627class Solution: # @param &#123;integer[]&#125; numss # @param &#123;integer&#125; target # @return &#123;integer&#125; def search(self, nums, target): if not nums: return -1 low, high = 0, len(nums) - 1 while low &lt;= high: mid = (low + high) / 2 if target == nums[mid]: return mid if nums[low] &lt;= nums[mid]: if nums[low] &lt;= target &lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &lt;= target &lt;= nums[high]: low = mid + 1 else: high = mid - 1 return -1 https://discuss.leetcode.com/topic/34467/pretty-short-c-java-ruby-python Pretty short C++/Java/Ruby/Python Explanation below the codes. Python: 123456789def search(self, nums, target): lo, hi = 0, len(nums) - 1 while lo &lt; hi: mid = (lo + hi) / 2 if (nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid]): lo = mid + 1 else: hi = mid return lo if target in nums[lo:lo+1] else -1 Python using bisect: 123456class Solution: def search(self, nums, target): self.__getitem__ = lambda i: \ (nums[0] &lt;= target) ^ (nums[0] &gt; nums[i]) ^ (target &gt; nums[i]) i = bisect.bisect_left(self, True, 0, len(nums)) return i if target in nums[i:i+1] else -1 C++: 1234567891011int search(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, hi = int(nums.size()) - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid])) lo = mid + 1; else hi = mid; &#125; return lo == hi &amp;&amp; nums[lo] == target ? lo : -1;&#125; Java: 1234567891011public int search(int[] nums, int target) &#123; int lo = 0, hi = nums.length - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid])) lo = mid + 1; else hi = mid; &#125; return lo == hi &amp;&amp; nums[lo] == target ? lo : -1;&#125; Explanation My solutions use binary search guided by the following thoughts: Remember the array is sorted, except it might drop at one point. 12345678If nums[0] &lt;= nums[i], then nums[0..i] is sorted (in case of &quot;==&quot; it&apos;s just one element, and in case of &quot;&lt;&quot; there must be a drop elsewhere). So we should keep searching in nums[0..i] if the target lies in this sorted range, i.e., if nums[0] &lt;= target &lt;= nums[i].If nums[i] &lt; nums[0], then nums[0..i] contains a drop, and thus nums[i+1..end] is sorted and lies strictly between nums[i] and nums[0]. So we should keep searching in nums[0..i] if the target doesn&apos;t lie strictly between them, i.e., if target &lt;= nums[i] &lt; nums[0] or nums[i] &lt; nums[0] &lt;= target Those three cases look cyclic: 123nums[0] &lt;= target &lt;= nums[i] target &lt;= nums[i] &lt; nums[0] nums[i] &lt; nums[0] &lt;= target So I have the three checks (nums[0] &lt;= target), (target &lt;= nums[i]) and (nums[i] &lt; nums[0]), and I want to know whether exactly two of them are true. They can’t all be true or all be false (check it), so I just need to distinguish between “two true” and “one true”. Parity is enough for that, so instead of adding them I xor them, which is a bit shorter and particularly helpful in Java and Ruby, because those don’t let me add booleans but do let me xor them. (Actually while developing this I thought of permutations of nums[0], target and nums[i] and the permutation parity and saw those three checks as representing inversions, but I had trouble putting that into words and now find the above explanation much better. But it helped me get there, so I wanted to mention it here.) java https://discuss.leetcode.com/topic/3538/concise-o-log-n-binary-search-solution Concise O(log N) Binary search solution 1234567891011121314151617181920212223242526class Solution &#123;public: int search(int A[], int n, int target) &#123; int lo=0,hi=n-1; // find the index of the smallest value using binary search. // Loop will terminate since mid &lt; hi, and lo or hi will shrink by at least 1. // Proof by contradiction that mid &lt; hi: if mid==hi, then lo==hi and loop would have been terminated. while(lo&lt;hi)&#123; int mid=(lo+hi)/2; if(A[mid]&gt;A[hi]) lo=mid+1; else hi=mid; &#125; // lo==hi is the index of the smallest value and also the number of places rotated. int rot=lo; lo=0;hi=n-1; // The usual binary search and accounting for rotation. while(lo&lt;=hi)&#123; int mid=(lo+hi)/2; int realmid=(mid+rot)%n; if(A[realmid]==target)return realmid; if(A[realmid]&lt;target)lo=mid+1; else hi=mid-1; &#125; return -1; &#125;&#125;; https://discuss.leetcode.com/topic/16580/java-ac-solution-using-once-binary-search Java AC Solution using once binary search The idea is that when rotating the array, there must be one half of the array that is still in sorted order.For example, 6 7 1 2 3 4 5, the order is disrupted from the point between 7 and 1. So when doing binary search, we can make a judgement that which part is ordered and whether the target is in that range, if yes, continue the search in that half, if not continue in the other half. 1234567891011121314151617181920212223242526public class Solution &#123; public int search(int[] nums, int target) &#123; int start = 0; int end = nums.length - 1; while (start &lt;= end)&#123; int mid = (start + end) / 2; if (nums[mid] == target) return mid; if (nums[start] &lt;= nums[mid])&#123; if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) end = mid - 1; else start = mid + 1; &#125; if (nums[mid] &lt;= nums[end])&#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) start = mid + 1; else end = mid - 1; &#125; &#125; return -1; &#125;&#125; https://discuss.leetcode.com/topic/8889/binary-search-java-solusion-o-log-n Binary Search, Java Solusion. O(log(n)) 1234567891011121314151617181920212223242526public int search(int[] A, int target) &#123; if (A.length == 0) return -1; int L = 0, R = A.length-1; // if (target &lt; A[L] &amp;&amp; target &gt; A[R]) return -1; while (L &lt; R) &#123; int M = (L + R)/2; if (A[M] &lt;= A[R]) &#123; if (target &gt; A[M] &amp;&amp; target &lt;= A[R]) &#123; L = M+1; &#125; else &#123; R = M; &#125; &#125; else &#123; if (target &lt;= A[M] &amp;&amp; target &gt;= A[L]) &#123; R = M; &#125; else &#123; L = M+1; &#125; &#125; &#125; if (A[L] == target) return L; else return -1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[032. Longest Valid Parentheses]]></title>
    <url>%2Fp%2F3f681304%2F</url>
    <content type="text"><![CDATA[23.1% https://leetcode.com/problems/longest-valid-parentheses/ Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring. 12345For &quot;(()&quot;, the longest valid parentheses substring is &quot;()&quot;, which has length = 2.Another example is &quot;)()())&quot;, where the longest valid parentheses substring is &quot;()()&quot;, which has length = 4. 方法一： 这种方法很巧妙，用了栈，并且栈里存储索引位置 My O(n) solution using a stack The workflow of the solution is as below. Scan the string from beginning to end. If current character is ‘(‘, push its index to the stack. If current character is ‘)’ and the character at the index of the top of stack is ‘(‘, we just find a matching pair so pop from the stack. Otherwise, we push the index of ‘)’ to the stack. After the scan is done, the stack will only contain the indices of characters which cannot be matched. Then let’s use the opposite side - substring between adjacent indices should be valid parentheses. If the stack is empty, the whole input string is valid. Otherwise, we can scan the stack to get longest valid substring as described in step 3. 123456789101112131415161718192021222324252627282930class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.length(), longest = 0; stack&lt;int&gt; st; for(int i=0; i&lt;n; i++)&#123; if(s[i]==&apos;(&apos;) st.push(i); else&#123; if(!st.empty())&#123; if(s[st.top()]==&apos;(&apos;) st.pop(); else st.push(i); &#125; else st.push(i); &#125; &#125; if(st.empty()) longest = n; else&#123; int a=n, b=0; while(!st.empty())&#123; b = st.top(); st.pop(); longest = max(longest, a-b-1); a = b; &#125; longest = max(longest, a); &#125; return longest; &#125;&#125;; 我的代码实现: 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.size(); if(n==0) return 0; // 对于字符串，stack可以保存具体的字符，也可以保存index // 保存index就是一种常见的操作，本处就是保存的index stack&lt;int&gt; stack; for(int i=0; i&lt;n; i++)&#123; if(s[i]=='(') stack.push(i); else&#123; if(!stack.empty() &amp;&amp; s[stack.top()]=='(') stack.pop(); else stack.push(i); &#125; &#125; if(stack.empty()) return n; int start = 0, end = n, res = 0; while(!stack.empty())&#123; start = stack.top(); // 别忘了将stack的值给pop出去 stack.pop(); res = max(res, end-start-1); end = start; &#125; // 不重不漏， 这一步要考虑周全 res = max(res, start); return res; &#125;&#125;; 我的代码实现二: 对上面的代码优化了一下 12345678910111213141516171819202122232425262728class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.size(); if(n==0) return 0; // 对于字符串，stack可以保存具体的字符，也可以保存index // 保存index就是一种常见的操作，本处就是保存的index stack&lt;int&gt; stack; for(int i=0; i&lt;n; i++)&#123; if(s[i]==')' &amp;&amp; !stack.empty() &amp;&amp; s[stack.top()]=='(') stack.pop(); else stack.push(i); &#125; if(stack.empty()) return n; int start = 0, end = n, res = 0; while(!stack.empty())&#123; start = stack.top(); // 别忘了将stack的值给pop出去 stack.pop(); res = max(res, end-start-1); end = start; &#125; // 不重不漏， 这一步要考虑周全 res = max(res, start); return res; &#125;&#125;; cpp September 22, 2016 https://discuss.leetcode.com/topic/2289/my-o-n-solution-using-a-stack My O(n) solution using a stack The workflow of the solution is as below. Scan the string from beginning to end. If current character is ‘(‘, push its index to the stack. If current character is ‘)’ and the character at the index of the top of stack is ‘(‘, we just find a matching pair so pop from the stack. Otherwise, we push the index of ‘)’ to the stack. After the scan is done, the stack will only contain the indices of characters which cannot be matched. Then let’s use the opposite side - substring between adjacent indices should be valid parentheses. If the stack is empty, the whole input string is valid. Otherwise, we can scan the stack to get longest valid substring as described in step 3.123456789101112131415161718192021222324252627282930class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.length(), longest = 0; stack&lt;int&gt; st; for(int i=0; i&lt;n; i++)&#123; if(s[i]==&apos;(&apos;) st.push(i); else&#123; if(!st.empty())&#123; if(s[st.top()]==&apos;(&apos;) st.pop(); else st.push(i); &#125; else st.push(i); &#125; &#125; if(st.empty()) longest = n; else&#123; int a=n, b=0; while(!st.empty())&#123; b = st.top(); st.pop(); longest = max(longest, a-b-1); a = b; &#125; longest = max(longest, a); &#125; return longest; &#125;&#125;; https://discuss.leetcode.com/topic/2426/my-dp-o-n-solution-without-using-stack My DP, O(n) solution without using stack My solution uses DP. The main idea is as follows: I construct a array longest[], for any longest[i], it stores the longest length of valid parentheses which is end at i. And the DP idea is : If s[i] is ‘(‘, set longest[i] to 0,because any string end with ‘(‘ cannot be a valid one. Else if s[i] is ‘)’ If s[i-1] is &apos;(&apos;, longest[i] = longest[i-2] + 2 Else if s[i-1] is &apos;)&apos; and s[i-longest[i-1]-1] == &apos;(&apos;, longest[i] = longest[i-1] + 2 + longest[i-longest[i-1]-2] For example, input “()(())”, at i = 5, longest array is [0,2,0,0,2,0], longest[5] = longest[4] + 2 + longest[1] = 6. 123456789101112131415161718192021int longestValidParentheses(string s) &#123; if(s.length() &lt;= 1) return 0; int curMax = 0; vector&lt;int&gt; longest(s.size(),0); for(int i=1; i &lt; s.length(); i++)&#123; if(s[i] == &apos;)&apos;)&#123; if(s[i-1] == &apos;(&apos;)&#123; longest[i] = (i-2) &gt;= 0 ? (longest[i-2] + 2) : 2; curMax = max(longest[i],curMax); &#125; else&#123; // if s[i-1] == &apos;)&apos;, combine the previous length. if(i-longest[i-1]-1 &gt;= 0 &amp;&amp; s[i-longest[i-1]-1] == &apos;(&apos;)&#123; longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 &gt;= 0)?longest[i-longest[i-1]-2]:0); curMax = max(longest[i],curMax); &#125; &#125; &#125; //else if s[i] == &apos;(&apos;, skip it, because longest[i] must be 0 &#125; return curMax; &#125; Updated: thanks to Philip0116, I have a more concise solution(though this is not as readable as the above one, but concise): 123456789101112int longestValidParentheses(string s) &#123; if(s.length() &lt;= 1) return 0; int curMax = 0; vector&lt;int&gt; longest(s.size(),0); for(int i=1; i &lt; s.length(); i++)&#123; if(s[i] == &apos;)&apos; &amp;&amp; i-longest[i-1]-1 &gt;= 0 &amp;&amp; s[i-longest[i-1]-1] == &apos;(&apos;)&#123; longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 &gt;= 0)?longest[i-longest[i-1]-2]:0); curMax = max(longest[i],curMax); &#125; &#125; return curMax; &#125; https://discuss.leetcode.com/topic/14690/my-simple-8ms-c-code My simple 8ms C++ code 1234567891011121314151617181920class Solution &#123;public: int longestValidParentheses(string s) &#123; stack&lt;int&gt; stk; stk.push(-1); int maxL=0; for(int i=0;i&lt;s.size();i++) &#123; int t=stk.top(); if(t!=-1&amp;&amp;s[i]==&apos;)&apos;&amp;&amp;s[t]==&apos;(&apos;) &#123; stk.pop(); maxL=max(maxL,i-stk.top()); &#125; else stk.push(i); &#125; return maxL; &#125;&#125;; https://discuss.leetcode.com/topic/2745/my-solution-using-one-stack-in-one-pass My solution using one stack in one pass Since any valid parentheses sequence starts from a ‘(‘ and ends at ‘)’, we can calculate new length when we meet a ‘)’. The key is to use a stack to store all the indices and the start position is always the one on top of the stack. See the code below for details. 12345678910111213141516171819202122// Using a stack. One passint longestValidParentheses(string s) &#123; vector&lt;int&gt; stack; int maxLen = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] == &apos;(&apos;) stack.push_back(i); else &#123; if (!stack.empty() &amp;&amp; s[stack.back()] == &apos;(&apos;) &#123; stack.pop_back(); int lastPos = -1; if (!stack.empty()) lastPos = stack.back(); int curLen = i - lastPos; maxLen = (maxLen &lt; curLen) ? curLen : maxLen; &#125; else stack.push_back(i); &#125; &#125; return maxLen;&#125; https://discuss.leetcode.com/topic/22287/constant-space-o-n-time-with-forward-and-backward-pass Constant space, O(n) time with forward and backward pass When right parentheses are more than left parentheses in the forward pass, we can discard previous parentheses. In the backward pass, when left parentheses are more than right parentheses, we can discard previous parentheses. 123456789101112131415161718192021222324252627282930313233343536373839404142434445int longestValidParentheses(string s) &#123; int longest = 0; int extra=0; int length=0; for(int i=0; i&lt;s.size(); i++) &#123; if(s[i] == &apos;(&apos;) &#123; extra++; length++; &#125; else &#123; if(extra&gt;0) &#123; extra--; length++; if(extra == 0) longest = max(longest, length); &#125; else &#123; extra = 0; length=0; &#125; &#125; &#125; length = 0; extra=0; for(int i=s.size()-1; i&gt;=0; i--) &#123; if(s[i] == &apos;)&apos;) &#123; extra++; length++; &#125; else &#123; if(extra&gt;0)&#123; extra--; length++; if(extra == 0) longest = max(longest, length); &#125; else &#123; extra = 0; length=0; &#125; &#125; &#125; return longest;&#125; python https://discuss.leetcode.com/topic/23559/pure-1d-dp-without-using-stack-python-with-detailed-explanation Pure 1D-DP without using stack (python) with detailed explanation 123456789101112131415161718192021222324252627class Solution(object): def longestValidParentheses(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; # use 1D DP # dp[i] records the longestValidParenthese EXACTLY ENDING at s[i] dp = [0 for x in xrange(len(s))] max_to_now = 0 for i in xrange(1,len(s)): if s[i] == &apos;)&apos;: # case 1: ()() if s[i-1] == &apos;(&apos;: # add nearest parentheses pairs + 2 dp[i] = dp[i-2] + 2 # case 2: (()) # i-dp[i-1]-1 is the index of last &quot;(&quot; not paired until this &quot;)&quot; elif i-dp[i-1]-1 &gt;= 0 and s[i-dp[i-1]-1] == &apos;(&apos;: if dp[i-1] &gt; 0: # content within current matching pair is valid # add nearest parentheses pairs + 2 + parentheses before last &quot;(&quot; dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2] else: # otherwise is 0 dp[i] = 0 max_to_now = max(max_to_now, dp[i]) return max_to_now java https://discuss.leetcode.com/topic/7234/simple-java-solution-o-n-time-one-stack Simple JAVA solution, O(n) time, one stack 12345678910111213141516171819public class Solution &#123; public int longestValidParentheses(String s) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int max=0; int left = -1; for(int j=0;j&lt;s.length();j++)&#123; if(s.charAt(j)==&apos;(&apos;) stack.push(j); else &#123; if (stack.isEmpty()) left=j; else&#123; stack.pop(); if(stack.isEmpty()) max=Math.max(max,j-left); else max=Math.max(max,j-stack.peek()); &#125; &#125; &#125; return max; &#125;&#125; https://discuss.leetcode.com/topic/7234/simple-java-solution-o-n-time-one-stack/3 Nice solution! Inspired by your solution. I changed a little to make it shorter and easier. 12345678910111213141516public class Solution &#123; public int longestValidParentheses(String s) &#123; LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); int result = 0; stack.push(-1); for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == &apos;)&apos; &amp;&amp; stack.size() &gt; 1 &amp;&amp; s.charAt(stack.peek()) == &apos;(&apos;) &#123; stack.pop(); result = Math.max(result, i - stack.peek()); &#125; else &#123; stack.push(i); &#125; &#125; return result; &#125;&#125; The idea is simple, we only update the result (max) when we find a “pair”. If we find a pair. We throw this pair away and see how big the gap is between current and previous invalid. EX: “( )( )” stack: -1, 0, when we get to index 1 “)”, the peek is “(“ so we pop it out and see what’s before “(“. In this example it’s -1. So the gap is “current_index” - (-1) = 2. The idea only update the result (max) when we find a “pair” and push -1 to stack first covered all edge cases. https://discuss.leetcode.com/topic/37982/my-easy-o-n-java-solution-with-explanation My easy O(n) java solution with explanation 1234567891011121314151617181920212223public class Solution &#123; public int longestValidParentheses(String s) &#123; int res=0; int tep=0; Stack&lt;Integer&gt; s1=new Stack&lt;&gt;(); int data[]=new int[s.length()]; for(int i=0;i&lt;s.length();i++)&#123; char c=s.charAt(i); if(c==&apos;(&apos;) s1.push(i); else&#123; if(!s1.empty())&#123; data[i]=1; data[s1.pop()]=1; &#125; &#125; &#125; for(int i:data)&#123; if(i==1) tep++; else &#123;res=Math.max(tep,res);tep=0;&#125; &#125; return Math.max(tep,res); &#125;&#125; Imaging we are coloring the original string, each substring that has valid parentheses is colored with ‘1’ and other characters are colored by ‘0’. For example “( ) ( ( ) “would become “11011”. Thus, the problem has converted to finding the longest subsequence that all elements are ‘1’, which could be easily solved. https://discuss.leetcode.com/topic/8305/simple-java-solution Simple Java solution. 123456789101112131415public int longestValidParentheses(String s) &#123; char[] S = s.toCharArray(); int[] V = new int[S.length]; int open = 0; int max = 0; for (int i=0; i&lt;S.length; i++) &#123; if (S[i] == &apos;(&apos;) open++; if (S[i] == &apos;)&apos; &amp;&amp; open &gt; 0) &#123; V[i] = 2 + V[i-1] + (i-2-V[i-1] &gt; 0 ? V[i-2-V[i-1]] : 0); open--; &#125; if (V[i] &gt; max) max = V[i]; &#125; return max;&#125; https://discuss.leetcode.com/topic/12200/explaining-solution-using-stack Explaining solution using Stack I have seen a lot of good answers but it is not immediately clear how they are achieving the result. I am going to make an attempt to explain my solution using a stack. Every time we encounter ‘(‘ we push the index onto the stack and when we encounter ‘)’ we pop the stack and use the current index minus the index at the top of the stack to be the current_length. we check against the max found so far and update if needed. Here is the code 1234567891011121314151617181920212223242526272829303132333435public static int longestValidParentheses(String s) &#123; Stack&lt;Integer&gt; bracketStack = new Stack&lt;Integer&gt;(); int max_len=0; int current_len=0; int last = -1; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == &apos;(&apos;) &#123; bracketStack.push(i); &#125; else&#123; if(!bracketStack.isEmpty()) &#123; bracketStack.pop(); if(!bracketStack.isEmpty()) current_len = i-bracketStack.peek(); else current_len=i-last; max_len = Math.max(max_len,current_len); &#125; else&#123; last = i; &#125; &#125; &#125; return max_len; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[031. Next Permutation]]></title>
    <url>%2Fp%2F3f16d422%2F</url>
    <content type="text"><![CDATA[28.8% https://leetcode.com/problems/next-permutation/ Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. 12345Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 方法一： 我的代码实现: 123456789101112131415161718192021222324252627class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return; int left = n-2; while(left&gt;=0)&#123; if(nums[left]&lt;nums[left+1]) break; left--; &#125; if(left&lt;0)&#123; reverse(nums.begin(), nums.end()); return; &#125; int right = n - 1; while(right&gt;=0)&#123; if(nums[right]&gt;nums[left]) break; right--; &#125; swap(nums[left], nums[right]); reverse(nums.begin()+left+1, nums.end()); return; &#125;&#125;; 我的代码实现: 1234567891011121314151617181920212223242526class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==1) return; int i = n-2; while(i&gt;=0)&#123; if(nums[i+1]&gt;nums[i]) break; i--; &#125; if(i&lt;0)&#123; reverse(nums.begin(), nums.end()); return; &#125; int j = n-1; while(j&gt;0)&#123; if(nums[j]&gt;nums[i]) break; j--; &#125; swap(nums[i], nums[j]); reverse(nums.begin()+i+1, nums.end()); return; &#125;&#125;; 成熟的解法 第一步，从后向前，找到一个index k，k是第一个满足当前节点值大于下一个点的值。 就是说后面的都是递减的。 (如果找不到，说明已经是最大的数组了，而且都是逆序，反转返回即可) 第二步，从后向前找，找到一个index l，l是nums[l] &gt; nums[k]，也就是l是大于nums[k]的最大索引。 第三步，交换l和k对应的值 第四步，把从k+1开始到nums末尾的数组，进行反转reverse。 A simple algorithm from Wikipedia with C++ implementation (can be used in Permutations and Permutations II) Well, in fact the problem of next permutation has been studied long ago. From the Wikipedia page, in the 14th century, a man named Narayana Pandita gives the following classic and yet quite simple algorithm (with minor modifications in notations to fit the problem statement): Find the largest index k such that nums[k] &lt; nums[k + 1]. If no such index exists, the permutation is sorted in descending order, just reverse it to ascending order and we are done. For example, the next permutation of [3, 2, 1] is [1, 2, 3]. Find the largest index l greater than k such that nums[k] &lt; nums[l]. Swap the value of nums[k] with that of nums[l]. Reverse the sequence from nums[k + 1] up to and including the final element nums[nums.size() - 1]. Quite simple, yeah? Now comes the following code, which is barely a translation. Well, a final note here, the above algorithm is indeed powerful — it can handle the cases of duplicates! If you have tried the problems Permutations and Permutations II, then the following function is also useful. Both of Permutations and Permutations II can be solved easily using this function. Hints: sort nums in ascending order, add it to the result of all permutations and then repeatedly generate the next permutation and add it … until we get back to the original sorted condition. If you want to learn more, please visit this solution and that solution. 123456789101112131415161718192021222324class Solution &#123; void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int k = -1; for (int i = nums.size() - 2; i &gt;= 0; i--) &#123; if (nums[i] &lt; nums[i + 1]) &#123; k = i; break; &#125; &#125; if (k == -1) &#123; reverse(nums.begin(), nums.end()); return; &#125; int l = -1; for (int i = nums.size() - 1; i &gt; k; i--) &#123; if (nums[i] &gt; nums[k]) &#123; l = i; break; &#125; &#125; swap(nums[k], nums[l]); reverse(nums.begin() + k + 1, nums.end()); &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return; int left = -1; for(int i=n-2; i&gt;=0; i--) if(nums[i]&lt;nums[i+1])&#123; left = i; break; // break不能忘 &#125; if(left == -1)&#123; reverse(nums.begin(), nums.end()); return; &#125; int right; for(int j=n-1; j&gt;left; j--) if(nums[j]&gt;nums[left])&#123; right = j; break; // break不能忘 &#125; swap(nums[left], nums[right]); reverse(nums.begin()+left+1, nums.end()); return; &#125;&#125;; cpp https://discuss.leetcode.com/topic/15216/a-simple-algorithm-from-wikipedia-with-c-implementation-can-be-used-in-permutations-and-permutations-ii A simple algorithm from Wikipedia with C++ implementation (can be used in Permutations and Permutations II) Well, in fact the problem of next permutation has been studied long ago. From the Wikipedia page, in the 14th century, a man named Narayana Pandita gives the following classic and yet quite simple algorithm (with minor modifications in notations to fit the problem statement): Find the largest index k such that nums[k] &lt; nums[k + 1]. If no such index exists, the permutation is sorted in descending order, just reverse it to ascending order and we are done. For example, the next permutation of [3, 2, 1] is [1, 2, 3]. Find the largest index l greater than k such that nums[k] &lt; nums[l]. Swap the value of nums[k] with that of nums[l]. Reverse the sequence from nums[k + 1] up to and including the final element nums[nums.size() - 1]. Quite simple, yeah? Now comes the following code, which is barely a translation. Well, a final note here, the above algorithm is indeed powerful — it can handle the cases of duplicates! If you have tried the problems Permutations and Permutations II, then the following function is also useful. Both of Permutations and Permutations II can be solved easily using this function. Hints: sort nums in ascending order, add it to the result of all permutations and then repeatedly generate the next permutation and add it … until we get back to the original sorted condition. If you want to learn more, please visit this solution and that solution. 123456789101112131415161718192021222324class Solution &#123; void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int k = -1; for (int i = nums.size() - 2; i &gt;= 0; i--) &#123; if (nums[i] &lt; nums[i + 1]) &#123; k = i; break; &#125; &#125; if (k == -1) &#123; reverse(nums.begin(), nums.end()); return; &#125; int l = -1; for (int i = nums.size() - 1; i &gt; k; i--) &#123; if (nums[i] &gt; nums[k]) &#123; l = i; break; &#125; &#125; swap(nums[k], nums[l]); reverse(nums.begin() + k + 1, nums.end()); &#125;&#125;; https://discuss.leetcode.com/topic/8508/9-lines-of-c-code-with-comments 9 Lines of C++ code with Comments 1234567891011121314151617181920212223class Solution &#123;public: void nextPermutation(vector&lt;int&gt; &amp;num) &#123; if (num.empty()) return; // in reverse order, find the first number which is in increasing trend (we call it violated number here) int i; for (i = num.size()-2; i &gt;= 0; --i) &#123; if (num[i] &lt; num[i+1]) break; &#125; // reverse all the numbers after violated number reverse(begin(num)+i+1, end(num)); // if violated number not found, because we have reversed the whole array, then we are done! if (i == -1) return; // else binary search find the first number larger than the violated number auto itr = upper_bound(begin(num)+i+1, end(num), num[i]); // swap them, done! swap(num[i], *itr); &#125;&#125;; You might need to think for a while why this would work. https://discuss.leetcode.com/topic/19264/1-4-11-lines-c 1, 4, 11 lines C++ Solution 1 Just for info: There’s a library function that does the job, even going from totally reverse sorted to sorted: 123void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; next_permutation(begin(nums), end(nums));&#125; Solution 2 Using library functions for all building blocks of the algorithm. Very nice how they all play together, notice the total lack of +1/-1, it all fits exactly. 123456void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; auto i = is_sorted_until(nums.rbegin(), nums.rend()); if (i != nums.rend()) swap(*i, *upper_bound(nums.rbegin(), i, *i)); reverse(nums.rbegin(), i);&#125; Solution 3 Doing it all on my own (except swap, let’s not be silly): 12345678910111213void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int i = nums.size() - 1, k = i; while (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i]) i--; for (int j=i; j&lt;k; j++, k--) swap(nums[j], nums[k]); if (i &gt; 0) &#123; k = i--; while (nums[k] &lt;= nums[i]) k++; swap(nums[i], nums[k]); &#125;&#125; Solution 4 Ok, let’s be silly after all and not even use swap :-) 12345678910111213void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int i = nums.size() - 1, k = i, tmp; while (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i]) i--; for (int j=i; j&lt;k; j++, k--) tmp = nums[j], nums[j] = nums[k], nums[k] = tmp; if (i &gt; 0) &#123; k = i--; while (nums[k] &lt;= nums[i]) k++; tmp = nums[i], nums[i] = nums[k], nums[k] = tmp; &#125;&#125; https://discuss.leetcode.com/topic/7138/sharing-my-really-simple-solution-with-explanation Sharing my really simple solution with explanation 123456789101112131415161718void nextPermutation(vector&lt;int&gt; &amp;num) &#123; for(int i = num.size() - 2; i &gt;= 0; i--)&#123; if(num[i] &lt; num[i + 1])&#123; int pos; int diff = INT_MAX; for(int j = i + 1; j &lt; num.size(); j++)&#123; if(num[j] &gt; num[i] &amp;&amp; abs(num[i] - num[j]) &lt; diff)&#123; diff = abs(num[i] - num[j]); pos = j; &#125; &#125; swap(num[i], num[pos]); sort(num.begin() + i + 1, num.end()); return; &#125; &#125; sort(num.begin(), num.end());&#125; For this problem, coding is not a big deal. Algorithm is! Now let’s pick a number, for example, 24387651. what is the next permutation? 24513678. How can I get the answer? First step: find the first ascending digit from the back of the number. 3 &lt; 8 &gt; 7 &gt; 6 &gt; 5 &gt; 1. Then 3 is the digit. Second step: swap that digit with the next big digit in following digits. Which one is the next big digit in 87651? 5! So swap them. Now the number becomes 24587631. Third step: sort 87631 into 13678. The final answer is 24513678. 12ms, 10.84%, April.23rd, 2016 https://github.com/haoel/leetcode/blob/master/algorithms/cpp/nextPermutation/nextPermutation.cpp 123456789101112131415161718192021222324252627282930313233343536373839/* * Take a look the following continuous permutation, can you find the patern? * * 1 2 3 4 * 1 2 4 3 * 1 3 2 4 * 1 3 4 2 * 1 4 2 3 * 1 4 3 2 * 2 1 3 4 * ... * * The pattern can be descripted as below: * * 1) from n-1 to 0, find the first place [i-1] which num[i-1] &lt; num[i] * 2) from n-1 to i, find the first number from n-1 to i which &gt;= num[i-1] * 3) swap the 2) num with the num[i-1] * 4) sort the sub-array [i, n) //actuall sort is fine as well * * For example: * * 1 4 3 2 &lt;-- 1) find the first place which num[i-1] &lt; num[i] * ^ * * 1 4 3 2 &lt;-- 2) find the first number from n-1 to i which &gt;= num[i-1] * ^ ^ * * 2 4 3 1 &lt;-- 3) swap them * ^ ^ * * 2 4 3 1 &lt;-- 4) sort * ^ ^ * * 2 1 3 4 * * Edge Case: * * 4 3 2 1, the next permutation is 1 2 3 4 */ 12345678910111213141516171819202122class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt;= 1) return; for(int i = nums.size() - 1; i &gt; 0; i--)&#123; if(nums[i-1] &lt; nums[i])&#123; int j = nums.size() - 1; while(nums[i-1] &gt;= nums[j]) j--; int tmp = nums[j]; nums[j] = nums[i-1]; nums[i-1] = tmp; reverse(nums.begin()+i, nums.end()); return; &#125; if(i == 1)&#123; reverse(nums.begin(), nums.end()); return; &#125; &#125; &#125;&#125;; 12ms, 10.84%, April.23rd, 2016 http://blog.csdn.net/m6830098/article/details/17291259 123456class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; next_permutation(nums.begin(), nums.end()); &#125;&#125;; python https://discuss.leetcode.com/topic/52275/easy-python-solution-based-on-lexicographical-permutation-algorithm Easy python solution based on lexicographical permutation algorithm For the detailed algorithm and demonstration, please go to https://www.nayuki.io/page/next-lexicographical-permutation-algorithm The steps are shown in the picture below. 123456789101112131415161718192021222324252627282930class Solution(object): def nextPermutation(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; # find longest non-increasing suffix right = len(nums)-1 while nums[right] &lt;= nums[right-1] and right-1 &gt;=0: right -= 1 if right == 0: return self.reverse(nums,0,len(nums)-1) # find pivot pivot = right-1 successor = 0 # find rightmost succesor for i in range(len(nums)-1,pivot,-1): if nums[i] &gt; nums[pivot]: successor = i break # swap pivot and successor nums[pivot],nums[successor] = nums[successor],nums[pivot] # reverse suffix self.reverse(nums,pivot+1,len(nums)-1) def reverse(self,nums,l,r): while l &lt; r: nums[l],nums[r] = nums[r],nums[l] l += 1 r -= 1 60ms, 77.71%, April.23rd, 2016 https://leetcode.com/discuss/59874/two-pointer-solution-in-python-with-detail-expalanation Two-pointer solution in python with detail expalanation Credit goes to http://blog.csdn.net/m6830098/article/details/17291259 1234567891011121314151617181920212223class Solution(object): def nextPermutation(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; # Use two-pointers: two pointers start from back # first pointer j stop at descending point # second pointer i stop at value &gt; nums[j] # swap and sort rest if not nums: return None i = len(nums)-1 j = -1 # j is set to -1 for case `4321`, so need to reverse all in following step while i &gt; 0: if nums[i-1] &lt; nums[i]: # first one violates the trend j = i-1 break i-=1 for i in xrange(len(nums)-1, -1, -1): if nums[i] &gt; nums[j]: # nums[i], nums[j] = nums[j], nums[i] # swap position nums[j+1:] = sorted(nums[j+1:]) # sort rest return java https://discuss.leetcode.com/topic/2542/share-my-o-n-time-solution Share my O(n) time solution My idea is for an array: Start from its last element, traverse backward to find the first one with index i that satisfy num[i-1] &lt; num[i]. So, elements from num[i] to num[n-1] is reversely sorted. To find the next permutation, we have to swap some numbers at different positions, to minimize the increased amount, we have to make the highest changed position as high as possible. Notice that index larger than or equal to i is not possible as num[i,n-1] is reversely sorted. So, we want to increase the number at index i-1, clearly, swap it with the smallest number between num[i,n-1] that is larger than num[i-1]. For example, original number is 121543321, we want to swap the ‘1’ at position 2 with ‘2’ at position 7. The last step is to make the remaining higher position part as small as possible, we just have to reversely sort the num[i,n-1] The following is my code: 1234567891011121314151617181920212223242526272829303132333435363738394041public void nextPermutation(int[] num) &#123; int n=num.length; if(n&lt;2) return; int index=n-1; while(index&gt;0)&#123; if(num[index-1]&lt;num[index]) break; index--; &#125; if(index==0)&#123; reverseSort(num,0,n-1); return; &#125; else&#123; int val=num[index-1]; int j=n-1; while(j&gt;=index)&#123; if(num[j]&gt;val) break; j--; &#125; swap(num,j,index-1); reverseSort(num,index,n-1); return; &#125;&#125;public void swap(int[] num, int i, int j)&#123; int temp=0; temp=num[i]; num[i]=num[j]; num[j]=temp;&#125;public void reverseSort(int[] num, int start, int end)&#123; if(start&gt;end) return; for(int i=start;i&lt;=(end+start)/2;i++) swap(num,i,start+end-i);&#125; https://discuss.leetcode.com/topic/14124/sharing-my-clean-and-easy-understand-java-code-with-explanation Sharing my clean and easy-understand java code with explanation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public void nextPermutation(int[] nums) &#123; if(nums.length&lt;=1)&#123; return; &#125; int i= nums.length-1; for(;i&gt;=1;i--)&#123; if(nums[i]&gt;nums[i-1])&#123; //find first number which is smaller than it&apos;s after number break; &#125; &#125; if(i!=0)&#123; swap(nums,i-1); //if the number exist,which means that the nums not like&#123;5,4,3,2,1&#125; &#125; reverse(nums,i); &#125; private void swap(int[] a,int i)&#123; for(int j = a.length-1;j&gt;i;j--)&#123; if(a[j]&gt;a[i])&#123; int t = a[j]; a[j] = a[i]; a[i] = t; break; &#125; &#125; &#125; private void reverse(int[] a,int i)&#123;//reverse the number after the number we have found int first = i; int last = a.length-1; while(first&lt;last)&#123; int t = a[first]; a[first] = a[last]; a[last] = t; first ++; last --; &#125; &#125; &#125; 在当前序列中，从尾端往前寻找两个相邻元素，前一个记为first，后一个记为second，并且满足first 小于 second。然后再从尾端寻找另一个元素number，如果满足first 小于number，即将第first个元素与number元素对调，并将second元素之后（包括second）的所有元素颠倒排序，即求出下一个序列 example: 6，3，4，9，8，7，1 此时 first ＝ 4，second = 9 从尾巴到前找到第一个大于first的数字，就是7 交换4和7，即上面的swap函数，此时序列变成6，3，7，9，8，4，1 再将second＝9以及以后的序列重新排序，让其从小到大排序，使得整体最小，即reverse一下（因为此时肯定是递减序列） 得到最终的结果：6，3，7，1，4，8，9 https://discuss.leetcode.com/topic/30212/easiest-java-solution Easiest JAVA Solution Using a simple example, we can derive the following steps: 123456789101112131415161718192021public void nextPermutation(int[] A) &#123; if(A == null || A.length &lt;= 1) return; int i = A.length - 2; while(i &gt;= 0 &amp;&amp; A[i] &gt;= A[i + 1]) i--; // Find 1st id i that breaks descending order if(i &gt;= 0) &#123; // If not entirely descending int j = A.length - 1; // Start from the end while(A[j] &lt;= A[i]) j--; // Find rightmost first larger id j swap(A, i, j); // Switch i and j &#125; reverse(A, i + 1, A.length - 1); // Reverse the descending sequence&#125;public void swap(int[] A, int i, int j) &#123; int tmp = A[i]; A[i] = A[j]; A[j] = tmp;&#125;public void reverse(int[] A, int i, int j) &#123; while(i &lt; j) swap(A, i++, j--);&#125; https://discuss.leetcode.com/topic/30688/readable-code-without-confusing-i-j-and-with-explanation Readable code without confusing i/j, and with explanation Implementation based on description from Project Nayuki. I cannot describe it better than them: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123;/*0*/ public void nextPermutation(int[] nums) &#123; // pivot is the element just before the non-increasing (weakly decreasing) suffix/*2*/ int pivot = indexOfLastPeak(nums) - 1; // paritions nums into [prefix pivot suffix] if (pivot != -1) &#123; int nextPrefix = lastIndexOfGreater(nums, nums[pivot]); // in the worst case it&apos;s suffix[0] // next prefix must exist because pivot &lt; suffix[0], otherwise pivot would be part of suffix/*4*/ swap(nums, pivot, nextPrefix); // this minimizes the change in prefix &#125;/*5*/ reverseSuffix(nums, pivot + 1); // reverses the whole list if there was no pivot/*6*/ &#125; /** * Find the last element which is a peak. * In case there are multiple equal peaks, return the first of those. * @return first index of last peak *//*1*/ int indexOfLastPeak(int[] nums) &#123; for (int i = nums.length - 1; 0 &lt; i; --i) &#123; if (nums[i - 1] &lt; nums[i]) return i; &#125; return 0; &#125; /** @return last index where the &#123;@code num &gt; threshold&#125; or -1 if not found *//*3*/ int lastIndexOfGreater(int[] nums, int threshold) &#123; for (int i = nums.length - 1; 0 &lt;= i; --i) &#123; if (threshold &lt; nums[i]) return i; &#125; return -1; &#125; /** Reverse numbers starting from an index till the end. */ void reverseSuffix(int[] nums, int start) &#123; int end = nums.length - 1; while (start &lt; end) &#123; swap(nums, start++, end--); &#125; &#125; void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[030. Substring with Concatenation of All Words]]></title>
    <url>%2Fp%2Ff97ee9f9%2F</url>
    <content type="text"><![CDATA[22.0% https://leetcode.com/problems/substring-with-concatenation-of-all-words/ You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. 123456For example, given:s: &quot;barfoothefoobarman&quot;words: [&quot;foo&quot;, &quot;bar&quot;]You should return the indices: [0,9].(order does not matter). 与题目 76 类似， Minimum Window Substring cpp https://discuss.leetcode.com/topic/6617/an-o-n-solution-with-detailed-explanation An O(N) solution with detailed explanation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// travel all the words combinations to maintain a window// there are wl(word len) times travel// each time, n/wl words, mostly 2 times travel for each word// one left side of the window, the other right side of the window// so, time complexity O(wl * 2 * N/wl) = O(2N)vector&lt;int&gt; findSubstring(string S, vector&lt;string&gt; &amp;L) &#123; vector&lt;int&gt; ans; int n = S.size(), cnt = L.size(); if (n &lt;= 0 || cnt &lt;= 0) return ans; // init word occurence unordered_map&lt;string, int&gt; dict; for (int i = 0; i &lt; cnt; ++i) dict[L[i]]++; // travel all sub string combinations int wl = L[0].size(); for (int i = 0; i &lt; wl; ++i) &#123; int left = i, count = 0; unordered_map&lt;string, int&gt; tdict; for (int j = i; j &lt;= n - wl; j += wl) &#123; string str = S.substr(j, wl); // a valid word, accumulate results if (dict.count(str)) &#123; tdict[str]++; if (tdict[str] &lt;= dict[str]) count++; else &#123; // a more word, advance the window left side possiablly while (tdict[str] &gt; dict[str]) &#123; string str1 = S.substr(left, wl); tdict[str1]--; if (tdict[str1] &lt; dict[str1]) count--; left += wl; &#125; &#125; // come to a result if (count == cnt) &#123; ans.push_back(left); // advance one word tdict[S.substr(left, wl)]--; count--; left += wl; &#125; &#125; // not a valid word, reset all vars else &#123; tdict.clear(); count = 0; left = j + wl; &#125; &#125; &#125; return ans;&#125; 698ms, 47.43%, September 22, 2016 https://discuss.leetcode.com/topic/17943/naive-c-solution-using-two-unordered_map-about-20-lines Naive C++ Solution using two unordered_map (about 20 lines) I think the following code is self-explanatory enough. We use an unordered_map&lt;string, int&gt; counts to record the expected times of each word and another unordered_map&lt;string, int&gt; seen to record the times we have seen. Then we check for every possible position of i. Once we meet an unexpected word or the times of some word is larger than its expected times, we stop the check. If we finish the check successfully, push i to the result indexes. 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; unordered_map&lt;string, int&gt; counts; for(string word:words) counts[word]++; int n = s.length(), num = words.size(), len = words[0].length(); vector&lt;int&gt; indexes; for(int i=0; i&lt;n-num*len+1; i++)&#123; unordered_map&lt;string, int&gt; seen; int j = 0; for(;j&lt;num; j++)&#123; string word = s.substr(i+j*len, len); if(counts.find(word)!=counts.end())&#123; seen[word]++; if(seen[word]&gt;counts[word]) break; &#125; else break; &#125; if(j==num) indexes.push_back(i); &#125; return indexes; &#125;&#125;; https://discuss.leetcode.com/topic/7552/my-ac-c-code-o-n-complexity-26ms My AC c++ code, O(n) complexity, 26ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution &#123;// The general idea:// Construct a hash function f for L, f: vector&lt;string&gt; -&gt; int, // Then use the return value of f to check whether a substring is a concatenation // of all words in L.// f has two levels, the first level is a hash function f1 for every single word in L.// f1 : string -&gt; double// So with f1, L is converted into a vector of float numbers// Then another hash function f2 is defined to convert a vector of doubles into a single int.// Finally f(L) := f2(f1(L))// To obtain lower complexity, we require f1 and f2 can be computed through moving window.// The following corner case also needs to be considered:// f2(f1([&quot;ab&quot;, &quot;cd&quot;])) != f2(f1([&quot;ac&quot;, &quot;bd&quot;]))// There are many possible options for f2 and f1. // The following code only shows one possibility (probably not the best), // f2 is the function &quot;hash&quot; in the class,// f1([a1, a2, ... , an]) := int( decimal_part(log(a1) + log(a2) + ... + log(an)) * 1000000000 )public: // The complexity of this function is O(nW). double hash(double f, double code[], string &amp;word) &#123; double result = 0.; for (auto &amp;c : word) result = result * f + code[c]; return result; &#125; vector&lt;int&gt; findSubstring(string S, vector&lt;string&gt; &amp;L) &#123; uniform_real_distribution&lt;double&gt; unif(0., 1.); default_random_engine seed; double code[128]; for (auto &amp;d : code) d = unif(seed); double f = unif(seed) / 5. + 0.8; double value = 0; // The complexity of the following for loop is O(L.size( ) * nW). for (auto &amp;str : L) value += log(hash(f, code, str)); int unit = 1e9; int key = (value-floor(value))*unit; int nS = S.size(), nL = L.size(), nW = L[0].size(); double fn = pow(f, nW-1.); vector&lt;int&gt; result; if (nS &lt; nW) return result; vector&lt;double&gt; values(nS-nW+1); string word(S.begin(), S.begin()+nW); values[0] = hash(f, code, word); // Use a moving window to hash every word with length nW in S to a float number, // which is stored in vector values[] // The complexity of this step is O(nS). for (int i=1; i&lt;=nS-nW; ++i) values[i] = (values[i-1] - code[S[i-1]]*fn)*f + code[S[i+nW-1]]; // This for loop will run nW times, each iteration has a complexity O(nS/nW) // So the overall complexity is O(nW * (nS / nW)) = O(nS) for (int i=0; i&lt;nW; ++i) &#123; int j0=i, j1=i, k=0; double sum = 0.; // Use a moving window to hash every L.size() continuous words with length nW in S. // This while loop will terminate within nS/nW iterations since the increasement of j1 is nW, // So the complexity of this while loop is O(nS / nW). while(j1&lt;=nS-nW) &#123; sum += log(values[j1]); ++k; j1 += nW; if (k==nL) &#123; int key1 = (sum-floor(sum)) * unit; if (key1==key) result.push_back(j0); sum -= log(values[j0]); --k; j0 += nW; &#125; &#125; &#125; return result; &#125;&#125;; Though theoretically it has a very small chance to fail. python https://discuss.leetcode.com/topic/3018/hash-idea-and-exception-case Hash Idea and exception case The following python code is accepted by OJ. It is based on the following idea (assumption) We know that two multisets consist of same elements and size of the multisets are equal. if sum of hashes of all elements are the same for these multisets -&gt; those multisets are identical This is not true for same very very rare cases. Please describe such a case. 12345678def findSubstring(self, S, L): n = len(L) #num words w = len(L[0]) #length of each word t = n*w # total length hashsum = sum([hash(x) for x in L]) h = [hash(S[i:i+w])*(S[i:i+w] in L) for i in xrange(len(S)-w+1)] return [i for i in xrange(len(S)-t+1) if sum(h[i:i+t:w])==hashsum] https://discuss.leetcode.com/topic/26043/ac-python-80ms-solution-dictionary-and-two-pointers AC Python 80ms solution, dictionary and two pointers 1234567891011121314151617181920212223242526272829303132333435def _findSubstring(self, l, r, n, k, t, s, req, ans): curr = &#123;&#125; while r + k &lt;= n: w = s[r:r + k] r += k if w not in req: l = r curr.clear() else: curr[w] = curr[w] + 1 if w in curr else 1 while curr[w] &gt; req[w]: curr[s[l:l + k]] -= 1 l += k if r - l == t: ans.append(l)def findSubstring(self, s, words): if not s or not words or not words[0]: return [] n = len(s) k = len(words[0]) t = len(words) * k req = &#123;&#125; for w in words: req[w] = req[w] + 1 if w in req else 1 ans = [] for i in xrange(min(k, n - t + 1)): self._findSubstring(i, i, n, k, t, s, req, ans) return ans# 169 / 169 test cases passed.# Status: Accepted# Runtime: 80 ms# 98.60% First of all consider s as several series of words with length k starting at [0, k-1]. For example “barfoothe” with k = 3, can be view as [“bar”, “foo”, “the”] for i=0 and [“arf”, “oot”] for i = 1 and [“rfo”, “oth”] for i = 2.Thus we need to check each of these series and find out the valid index by definition. For each series, we just need to check if there exist a range [l, r) where the occurrence or “spectrum” of the words in the range is the same as our given word list’s “spectrum”. We use dictionary to store the spectrum and maintain it as we loop through s. collections.Counter class may save a bit of code on updating the counts of the dictionary. However plain dict wins on the speed. https://discuss.leetcode.com/topic/13630/99ms-python-o-kmn-solution 99ms Python O(kmn) Solution The idea comes from [https://leetcode.com/discuss/20151/an-o-n-solution-with-detailed-explanation] Using a counter and a sliding window, we push the window from left to right, counting the number of valid words in the window. When the number of a word in the window is more than the times it appears in words or we meet a invalid word, push the window. 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution:# @param &#123;string&#125; s# @param &#123;string[]&#125; words# @return &#123;integer[]&#125;def findSubstring(self, s, words): if len(words) == 0: return [] # initialize d, l, ans l = len(words[0]) d = &#123;&#125; for w in words: if w in d: d[w] += 1 else: d[w] = 1 i = 0 ans = [] # sliding window(s) for k in range(l): left = k subd = &#123;&#125; count = 0 for j in xrange(k, len(s)-l+1, l): tword = s[j:j+l] # valid word if tword in d: if tword in subd: subd[tword] += 1 else: subd[tword] = 1 count += 1 while subd[tword] &gt; d[tword]: subd[s[left:left+l]] -= 1 left += l count -= 1 if count == len(words): ans.append(left) # not valid else: left = j + l subd = &#123;&#125; count = 0 return ans Assuming we have k words in words, and there are m substrings in the string, the complexity is O(kmn) because we need to adjust the window when more valid words are found. This solution runs 99ms on OJ. java 180ms, September 22, 2016 https://discuss.leetcode.com/topic/6432/simple-java-solution-with-two-pointers-and-map Simple Java Solution with Two Pointers and Map My idea is pretty simple. Just build a map for the words and their relative count in L. Then we traverse through S to check whether there is a match. 12345678910111213141516171819202122232425262728public class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(s == null || words == null || words.length == 0) return res; int len = words[0].length(); Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); for(String word:words) map.put(word, map.containsKey(word)?map.get(word)+1:1); for(int i=0; i&lt;=s.length()-len*words.length; i++)&#123; Map&lt;String, Integer&gt; copy = new HashMap&lt;String, Integer&gt;(map); for(int j = 0; j&lt;words.length; j++)&#123; String str = s.substring(i+j*len, i+j*len+len); if(copy.containsKey(str))&#123; int count = copy.get(str); if(count == 1) copy.remove(str); else copy.put(str, count-1); if(copy.isEmpty())&#123; res.add(i); break; &#125; &#125; else break; &#125; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/35676/accepted-java-solution-12ms-with-explanation Accepted Java solution 12ms with explanation It’s not too hard to find some resemblance between this problem and minimum-window-substring. Actually the main difference is the fact that we are interested at some interval length: we want intervals with fixed length K * M, where K is the number of strings in the “words” array and M the length of each target string. In order to apply the same idea we used for that problem, all we need to do is to map each string from the “words” array to something we are able to index (I prefer to use hashing for this). Also, in order to speed up the algorithm, we can find all occurrences of those strings in S (which is equivalent to do it on demand, but we will potentially do the same matching twice). Notice that, we can simply apply these occurrences as they appear because we are assured that no word is contained by some other. Finally, we use all this information to process each possibility. Notice here that, the fact that all strings has the same length, implies that we have just M (being M the length of each target string) possible starting points, hence we end up performing M linear scans over array with length O(N/M) (being N the length of S) and that makes the scanning stage of the algorithm to be linear on the length of S. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; int N = s.length(); List&lt;Integer&gt; indexes = new ArrayList&lt;Integer&gt;(s.length()); if (words.length == 0) &#123; return indexes; &#125; int M = words[0].length(); if (N &lt; M * words.length) &#123; return indexes; &#125; int last = N - M + 1; //map each string in words array to some index and compute target counters Map&lt;String, Integer&gt; mapping = new HashMap&lt;String, Integer&gt;(words.length); int [][] table = new int[2][words.length]; int failures = 0, index = 0; for (int i = 0; i &lt; words.length; ++i) &#123; Integer mapped = mapping.get(words[i]); if (mapped == null) &#123; ++failures; mapping.put(words[i], index); mapped = index++; &#125; ++table[0][mapped]; &#125; //find all occurrences at string S and map them to their current integer, -1 means no such string is in words array int [] smapping = new int[last]; for (int i = 0; i &lt; last; ++i) &#123; String section = s.substring(i, i + M); Integer mapped = mapping.get(section); if (mapped == null) &#123; smapping[i] = -1; &#125; else &#123; smapping[i] = mapped; &#125; &#125; //fix the number of linear scans for (int i = 0; i &lt; M; ++i) &#123; //reset scan variables int currentFailures = failures; //number of current mismatches int left = i, right = i; Arrays.fill(table[1], 0); //here, simple solve the minimum-window-substring problem while (right &lt; last) &#123; while (currentFailures &gt; 0 &amp;&amp; right &lt; last) &#123; int target = smapping[right]; if (target != -1 &amp;&amp; ++table[1][target] == table[0][target]) &#123; --currentFailures; &#125; right += M; &#125; while (currentFailures == 0 &amp;&amp; left &lt; right) &#123; int target = smapping[left]; if (target != -1 &amp;&amp; --table[1][target] == table[0][target] - 1) &#123; int length = right - left; //instead of checking every window, we know exactly the length we want if ((length / M) == words.length) &#123; indexes.add(left); &#125; ++currentFailures; &#125; left += M; &#125; &#125; &#125; return indexes;&#125; https://discuss.leetcode.com/topic/32038/java-12ms-beats-100 Java 12ms beats 100% The two pointers method with hashmap is known by many other solutions. The idea is to slide the scan window as far as possible, and keep throwing the impossible cases based on the length test. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; /** * Let n=s.length, k=words[0].length traverse s with indices i, i+k, * i+2k, ... for 0&lt;=i&lt;k, so that the time complexity is O(n). */ List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int n = s.length(), m = words.length, k; if (n == 0 || m == 0 || (k = words[0].length()) == 0) return res; HashMap&lt;String, Integer&gt; wDict = new HashMap&lt;String, Integer&gt;(); for (String word : words) &#123; if (wDict.containsKey(word)) wDict.put(word, wDict.get(word) + 1); else wDict.put(word, 1); &#125; int i, j, start, x, wordsLen = m * k; HashMap&lt;String, Integer&gt; curDict = new HashMap&lt;String, Integer&gt;(); String test, temp; for (i = 0; i &lt; k; i++) &#123; curDict.clear(); start = i; if (start + wordsLen &gt; n) return res; for (j = i; j + k &lt;= n; j += k) &#123; test = s.substring(j, j + k); if (wDict.containsKey(test)) &#123; if (!curDict.containsKey(test)) &#123; curDict.put(test, 1); start = checkFound(res, start, wordsLen, j, k, curDict, s); continue; &#125; // curDict.containsKey(test) x = curDict.get(test); if (x &lt; wDict.get(test)) &#123; curDict.put(test, x + 1); start = checkFound(res, start, wordsLen, j, k, curDict, s); continue; &#125; // curDict.get(test)==wDict.get(test), slide start to // the next word of the first same word as test while (!(temp = s.substring(start, start + k)).equals(test)) &#123; decreaseCount(curDict, temp); start += k; &#125; start += k; if (start + wordsLen &gt; n) break; continue; &#125; // totally failed up to index j+k, slide start and reset all start = j + k; if (start + wordsLen &gt; n) break; curDict.clear(); &#125; &#125; return res; &#125; public int checkFound(List&lt;Integer&gt; res, int start, int wordsLen, int j, int k, HashMap&lt;String, Integer&gt; curDict, String s) &#123; if (start + wordsLen == j + k) &#123; res.add(start); // slide start to the next word decreaseCount(curDict, s.substring(start, start + k)); return start + k; &#125; return start; &#125; public void decreaseCount(HashMap&lt;String, Integer&gt; curDict, String key) &#123; // remove key if curDict.get(key)==1, otherwise decrease it by 1 int x = curDict.get(key); if (x == 1) curDict.remove(key); else curDict.put(key, x - 1); &#125; https://discuss.leetcode.com/topic/6593/accepted-recursive-solution-using-trie-tree Accepted recursive solution using Trie Tree The idea is quite simple. Just use a trie tree to accelerate testing whether a substring is valid. The value of each TrieNode is used to deal with duplication and to mark whether the word is used before. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static class TrieNode &#123; int value = 0; Map&lt;Character, TrieNode&gt; children = new HashMap&lt;Character, TrieNode&gt;(); &#125; TrieNode trie;// build a trie treepublic List&lt;Integer&gt; findSubstring(String S, String[] L) &#123; trie = buildTrie(L); int length = getTotalLength(L); List&lt;Integer&gt; result = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; S.length() - length + 1; i++) &#123; if (isSubString(S, i, i + length)) result.add(i); &#125; return result;&#125;private int getTotalLength(String[] L) &#123; int sum = 0; for (String l : L) sum += l.length(); return sum;&#125;private TrieNode buildTrie(String[] L) &#123; TrieNode root = new TrieNode(); for (String l : L) addWord(root, l); return root;&#125;private void addWord(TrieNode root, String s) &#123; TrieNode node = root; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); TrieNode next = node.children.get(c); if (next == null) &#123; next = new TrieNode(); node.children.put(c, next); &#125; node = next; &#125; node.value++;&#125;private boolean isSubString(String S, int start, int end) &#123; if (start == end) return true; // search in the trie tree TrieNode node = trie; for (int i = start; i &lt; end; i++) &#123; char c = S.charAt(i); if (node.children.get(c) == null) return false; node = node.children.get(c); if (node.value &gt; 0) &#123; // leaf &amp; can be used node.value--; // mark as used if (isSubString(S, i + 1, end)) &#123; node.value++; // mark as unused return true; &#125; node.value++; // mark as unused &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[029. Divide Two Integers]]></title>
    <url>%2Fp%2Fa87eef55%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/divide-two-integers/ Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT. cpp https://discuss.leetcode.com/topic/15568/detailed-explained-8ms-c-solution Detailed Explained 8ms C++ solution In this problem, we are asked to divide two integers. However, we are not allowed to use division, multiplication and mod operations. So, what else can we use? Yeah, bit manipulations. Let’s do an example and see how bit manipulations work. Suppose we want to divide 15 by 3, so 15 is dividend and 3 is divisor. Well, division simply requires us to find how many times we can subtract the divisor from the the dividend without making the dividend negative. Let’s get started. We subtract 3 from 15 and we get 12, which is positive. Let’s try to subtract more. Well, we shift 3 to the left by 1 bit and we get 6. Subtracting 6 from 15 still gives a positive result. Well, we shift again and get 12. We subtract 12 from 15 and it is still positive. We shift again, obtaining 24 and we know we can at most subtract 12. Well, since 12 is obtained by shifting 3 to left twice, we know it is 4 times of 3. How do we obtain this 4? Well, we start from 1 and shift it to left twice at the same time. We add 4 to an answer (initialized to be 0). In fact, the above process is like 15 = 3 * 4 + 3. We now get part of the quotient (4), with a remainder 3. Then we repeat the above process again. We subtract divisor = 3 from the remaining dividend = 3 and obtain 0. We know we are done. No shift happens, so we simply add 1 &lt;&lt; 0 to the answer. Now we have the full algorithm to perform division. According to the problem statement, we need to handle some exceptions, such as overflow. Well, two cases may cause overflow: divisor = 0; dividend = INT_MIN and divisor = -1 (because abs(INT_MIN) = INT_MAX + 1). Of course, we also need to take the sign into considerations, which is relatively easy. Putting all these together, we have the following code. 123456789101112131415161718192021class Solution &#123;public: int divide(int dividend, int divisor) &#123; if (!divisor || (dividend == INT_MIN &amp;&amp; divisor == -1)) return INT_MAX; int sign = ((dividend &lt; 0) ^ (divisor &lt; 0)) ? -1 : 1; long long dvd = labs(dividend); long long dvs = labs(divisor); int res = 0; while (dvd &gt;= dvs) &#123; long long temp = dvs, multiple = 1; while (dvd &gt;= (temp &lt;&lt; 1)) &#123; temp &lt;&lt;= 1; multiple &lt;&lt;= 1; &#125; dvd -= temp; res += multiple; &#125; return sign == 1 ? res : -res; &#125;&#125;; https://discuss.leetcode.com/topic/3421/simple-o-log-n-2-c-solution Simple O((log N) ^ 2) C++ solution Long division in binary: The outer loop reduces n by at least half each iteration. So It has O(log N) iterations. The inner loop has at most log N iterations. So the overall complexity is O(( log N)^2) typedef long long ll; 123456789101112131415int divide(int n_, int d_) &#123; ll ans=0; ll n=abs((ll)n_); ll d=abs((ll)d_); while(n&gt;=d)&#123; ll a=d; ll m=1; while((a&lt;&lt;1) &lt; n)&#123;a&lt;&lt;=1;m&lt;&lt;=1;&#125; ans+=m; n-=a; &#125; if((n_&lt;0&amp;&amp;d_&gt;=0)||(n_&gt;=0&amp;&amp;d_&lt;0)) return -ans; return ans;&#125; https://discuss.leetcode.com/topic/38191/summary-of-3-c-solutions Summary of 3 C++ solutions-1- log-based solution 123456789101112131415class Solution &#123;public: int divide(int dividend, int divisor) &#123; /** a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b)) **/ if(dividend==0) return 0; if(divisor==0) return INT_MAX; double t1=log(fabs(dividend)); double t2=log(fabs(divisor)); long long result=double(exp(t1-t2)); if((dividend&lt;0) ^ (divisor&lt;0)) result=-result; if(result&gt;INT_MAX) result=INT_MAX; return result; &#125;&#125;; -2- Binary Index tree idea inspired solution, as we can decompose any result number to sum of the power of 2. Here is the C++ implementation. 123456789101112131415161718192021222324class Solution &#123;public: int divide(int dividend, int divisor) &#123; if(!divisor || (dividend==INT_MIN &amp;&amp; divisor==-1)) return INT_MAX; int sign=((dividend&lt;0)^(divisor&lt;0)) ? -1:1; long long m=labs(dividend); long long n=labs(divisor); int result=0; /** dvd &gt;= 2^k1*dvs + 2^k2*dvs ... **/ while(m&gt;=n)&#123; long long temp=n, count=1; while(m &gt;= (temp&lt;&lt;1))&#123; temp&lt;&lt;=1; count&lt;&lt;=1; &#125; m-=temp; result+=count; &#125; return sign==1?result:-result; &#125;&#125;; -3- concise version of the solution 2 1234567891011121314151617class Solution &#123;public: int divide(int dividend, int divisor) &#123; long long result=0; long long m=abs((long long)dividend); long long n=abs((long long)divisor); while(m&gt;=n)&#123; long long s=n, power=1; while((s&lt;&lt;1) &lt;= m) &#123; s&lt;&lt;=1; power&lt;&lt;=1; &#125; result+=power; m-=s; &#125; if( (dividend&gt;0) ^ (divisor&gt;0)) result = -result; return result&gt;INT_MAX ? INT_MAX:result; &#125;&#125;; python https://discuss.leetcode.com/topic/8714/clear-python-code Clear python code 12345678910111213141516class Solution:# @return an integerdef divide(self, dividend, divisor): positive = (dividend &lt; 0) is (divisor &lt; 0) dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend &gt;= divisor: temp, i = divisor, 1 while dividend &gt;= temp: dividend -= temp res += i i &lt;&lt;= 1 temp &lt;&lt;= 1 if not positive: res = -res return min(max(-2147483648, res), 2147483647) https://discuss.leetcode.com/topic/6966/15-line-easy-understand-solution-129ms 15 line easy understand solution. 129ms for example, if we want to calc (17/2) ret = 0; 17-2 ,ret+=1; left=15 15-4 ,ret+=2; left=11 11-8 ,ret+=4; left=3 3-2 ,ret+=1; left=1 ret=8; 123456789101112131415161718192021class Solution:# @return an integerdef divide(self, dividend, divisor): isMinus= ((dividend&lt;0 and divisor &gt;0) or (dividend&gt;0 and divisor &lt;0)); ret=0; dividend,divisor=abs(dividend),abs(divisor); c,sub=1,divisor; while(dividend &gt;= divisor): if(dividend&gt;=sub): dividend-=sub; ret+=c; sub=(sub&lt;&lt;1); c=(c&lt;&lt;1); else: sub=(sub&gt;&gt;1); c=(c&gt;&gt;1); if(isMinus): ret=-ret; return min(max(-2147483648,ret),2147483647); java https://discuss.leetcode.com/topic/23968/clean-java-solution-with-some-comment Clean Java solution with some comment. 12345678910111213141516171819202122232425262728293031323334353637383940public int divide(int dividend, int divisor) &#123; //Reduce the problem to positive long integer to make it easier. //Use long to avoid integer overflow cases. int sign = 1; if ((dividend &gt; 0 &amp;&amp; divisor &lt; 0) || (dividend &lt; 0 &amp;&amp; divisor &gt; 0)) sign = -1; long ldividend = Math.abs((long) dividend); long ldivisor = Math.abs((long) divisor); //Take care the edge cases. if (ldivisor == 0) return Integer.MAX_VALUE; if ((ldividend == 0) || (ldividend &lt; ldivisor)) return 0; long lans = ldivide(ldividend, ldivisor); int ans; if (lans &gt; Integer.MAX_VALUE)&#123; //Handle overflow. ans = (sign == 1)? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; else &#123; ans = (int) (sign * lans); &#125; return ans;&#125;private long ldivide(long ldividend, long ldivisor) &#123; // Recursion exit condition if (ldividend &lt; ldivisor) return 0; // Find the largest multiple so that (divisor * multiple &lt;= dividend), // whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason. // Think this as a binary search. long sum = ldivisor; long multiple = 1; while ((sum+sum) &lt;= ldividend) &#123; sum += sum; multiple += multiple; &#125; //Look for additional value for the multiple from the reminder (dividend - sum) recursively. return multiple + ldivide(ldividend - sum, ldivisor);&#125; https://discuss.leetcode.com/topic/8271/accepted-java-solution-with-comments Accepted Java solution with comments. 12345678910111213141516171819202122232425262728293031public int divide(int dividend, int divisor) &#123; long result = divideLong(dividend, divisor); return result &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)result;&#125;// It&apos;s easy to handle edge cases when// operate with long numbers rather than intpublic long divideLong(long dividend, long divisor) &#123; // Remember the sign boolean negative = dividend &lt; 0 != divisor &lt; 0; // Make dividend and divisor unsign if (dividend &lt; 0) dividend = -dividend; if (divisor &lt; 0) divisor = -divisor; // Return if nothing to divide if (dividend &lt; divisor) return 0; // Sum divisor 2, 4, 8, 16, 32 .... times long sum = divisor; long divide = 1; while ((sum+sum) &lt;= dividend) &#123; sum += sum; divide += divide; &#125; // Make a recursive call for (devided-sum) and add it to the result return negative ? -(divide + divideLong((dividend-sum), divisor)) : (divide + divideLong((dividend-sum), divisor));&#125; https://discuss.leetcode.com/topic/3631/a-readable-java-implementation A readable Java implementation At first, I used dividend / divisor, just to check. But that was cheating. Then, I implemented a solution which failed the corner cases. I solved it by using long instead of int. But I felt that was also cheating. At last, I came up with this solution. It handles all the corner cases. Running time analysis after the code. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123; public int divide(int dividend, int divisor) &#123; if (divisor == 1) // Trival case 1 return dividend; // Use negative integers to avoid integer overflow if (dividend &gt; 0) return -divide(-dividend, divisor); if (divisor &gt; 0) return -divide(dividend, -divisor); if (dividend &gt; divisor) // Trivial case 2 return 0; if ((dividend == Integer.MIN_VALUE) &amp;&amp; (divisor == -1)) // Overflow case return Integer.MAX_VALUE; // Find the highest mult = (divisor * 2^shifts) which is &lt;= dividend // by shifting mult to the left without causing an overflow. // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations. int min_divisor = Integer.MIN_VALUE &gt;&gt; 1; int mult = divisor; // = divisor * 2^shifts int shifts = 0; while ((mult &gt;= min_divisor) &amp;&amp; (mult &gt; dividend)) &#123; mult &lt;&lt;= 1; ++shifts; &#125; // Compute the result by shifting mult to the right. // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations for the outer loop. // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations for the inner loop // (in total, not per outer iteration). int result = 0; int power = 1 &lt;&lt; shifts; // = 2^shifts while (dividend &lt;= divisor) &#123; shifts = 0; while (mult &lt; dividend) &#123; mult &gt;&gt;= 1; ++shifts; &#125; dividend -= mult; power &gt;&gt;= shifts; result |= power; // Adds power to result &#125; return result; &#125;&#125; I see lots of people talking about O(log(n)) solutions. Since n is bounded by -2^31 and 2^31-1, I’m not sure the Big-Oh notation is appropriate here. Anyway, here’s a rough worst-case analysis of this code. The first loop runs (log2(|dividend|) - log2(|divisor|) + 1) times. There are 2 comparisons 1 bit shift 1 increment The second loop runs between 1 time and (log2(|dividend|) - log2(|divisor|) + 1) times. For worst-case, we take the latter. There are 1 comparison 1 assignment 1 substraction 1 bit shift 1 bitwise or The inner while loop runs (log2(|dividend|) - log2(|divisor|) + 1) times also (in total, not per outer loop iteration). There are 1 comparison 1 bit shift 1 increment So, roughly, the overall worst-case running time is 12(log2(dividend) - log2(divisor) + 1) operations. You can notice that (log2(|dividend|) - log2(|divisor|)) = log2(|result|). Thus, the running time is (worst-case) 12(log2(|result|) + 1) operations.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[028. Implement strStr()]]></title>
    <url>%2Fp%2F78eeb38d%2F</url>
    <content type="text"><![CDATA[27.5% https://leetcode.com/problems/implement-strstr/ Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 方法一：暴力法 1234567891011121314class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.size(), n = needle.size(); if(!haystack || !needle || m&lt;n) return -1; for(int i=0; ;i++)&#123; for(int j=0; ;j++)&#123; if(j==n-1) return i; if(i+j==m-1) return -1; if(haystack[i+j]!=needle[j]) break; &#125; &#125; &#125;&#125;; 我的代码实现： 123456789101112131415class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.size(), n = needle.size(); if(n==0) return 0; if(m==0 || m&lt;n) return -1; for(int i=0; ;i++)&#123; for(int j=0; ;j++)&#123; if(j==n) return i; if(i+j==m) return -1; if(haystack[i+j]!=needle[j]) break; &#125; &#125; &#125;&#125;; 方法二：KMP算法 先建立lps，然后使用kmp算法 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.length(), n = needle.length(); if (!n) return 0; vector&lt;int&gt; lps = kmpProcess(needle); for (int i = 0, j = 0; i &lt; m; ) &#123; if (haystack[i] == needle[j]) &#123; i++; j++; &#125; if (j == n) return i - j; if (i &lt; m &amp;&amp; haystack[i] != needle[j]) &#123; if (j) j = lps[j - 1]; else i++; &#125; &#125; return -1; &#125;private: vector&lt;int&gt; kmpProcess(string&amp; needle) &#123; int n = needle.length(); vector&lt;int&gt; lps(n, 0); for (int i = 1, len = 0; i &lt; n; ) &#123; if (needle[i] == needle[len]) lps[i++] = ++len; else if (len) len = lps[len - 1]; else lps[i++] = 0; &#125; return lps; &#125;&#125;; 完整实现代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// C++ program for implementation of KMP pattern searching// algorithm#include&lt;bits/stdc++.h&gt; void computeLPSArray(char *pat, int M, int *lps); // Prints occurrences of txt[] in pat[]void KMPSearch(char *pat, char *txt)&#123; int M = strlen(pat); int N = strlen(txt); // create lps[] that will hold the longest prefix suffix // values for pattern int lps[M]; // Preprocess the pattern (calculate lps[] array) computeLPSArray(pat, M, lps); int i = 0; // index for txt[] int j = 0; // index for pat[] while (i &lt; N) &#123; if (pat[j] == txt[i]) &#123; j++; i++; &#125; if (j == M) &#123; printf("Found pattern at index %d n", i-j); j = lps[j-1]; &#125; // mismatch after j matches else if (i &lt; N &amp;&amp; pat[j] != txt[i]) &#123; // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) j = lps[j-1]; else i = i+1; &#125; &#125;&#125; // Fills lps[] for given patttern pat[0..M-1]void computeLPSArray(char *pat, int M, int *lps)&#123; // length of the previous longest prefix suffix int len = 0; lps[0] = 0; // lps[0] is always 0 // the loop calculates lps[i] for i = 1 to M-1 int i = 1; while (i &lt; M) &#123; if (pat[i] == pat[len]) &#123; len++; lps[i] = len; i++; &#125; else // (pat[i] != pat[len]) &#123; // This is tricky. Consider the example. // AAACAAAA and i = 7. The idea is similar // to search step. if (len != 0) &#123; len = lps[len-1]; // Also, note that we do not increment // i here &#125; else // if (len == 0) &#123; lps[i] = 0; i++; &#125; &#125; &#125;&#125; // Driver program to test above functionint main()&#123; char *txt = "ABABDABACDABABCABAB"; char *pat = "ABABCABAB"; KMPSearch(pat, txt); return 0;&#125; 说明： http://www.cplusplus.com/reference/cstring/strstr/ 123strstrconst char * strstr ( const char * str1, const char * str2 ); char * strstr ( char * str1, const char * str2 ); Locate substring Returns a pointer to the first occurrence of str2 in str1, or a null pointer if str2 is not part of str1. The matching process does not include the terminating null-characters, but it stops there. KMP算法阅读资料 KMP on jBoxer’s blog; http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/ KMP on geeksforgeeks, with a well-commented C code. http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/ 阮一峰的博客 http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html https://discuss.leetcode.com/topic/6888/this-test-case-doesn-t-make-sense This test case doesn’t make sense. Input: “”, “”Output: -1Expected: 0 Basically there is nothing in the string, how do you get the index. If this test case is valid, then needle =””, haystack=”anything” could return any value. since empty is everywhere. cpp https://discuss.leetcode.com/topic/15569/explained-4ms-easy-c-solution Explained 4ms Easy C++ solution Well, the problem does not aim for an advanced algorithm like KMP but only a clean brute-force algorithm. So we can traverse all the possible starting points of haystack (from 0 to haystack.length() - needle.length()) and see if the following characters in haystack match those of needle. The code is as follows. 123456789101112131415class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.length(), n = needle.length(); if (!n) return 0; for (int i = 0; i &lt; m - n + 1; i++) &#123; int j = 0; for (; j &lt; n; j++) if (haystack[i + j] != needle[j]) break; if (j == n) return i; &#125; return -1; &#125;&#125;; Of course, you may challenge yourself implementing the KMP algorithm for this problem. KMP is a classic and yet notoriously hard-to-understand algorithm. However, I think the following two links give nice explanations. You may refer to them. KMP on jBoxer’s blog; http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/ KMP on geeksforgeeks, with a well-commented C code. http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/ I am sorry that I am still unable to give a personal explanation of the algorithm. I only read it from the two links above and mimic the code in the second link. My accepted C++ code using KMP is as follows. Well, it also takes 4ms -_- 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.length(), n = needle.length(); if (!n) return 0; vector&lt;int&gt; lps = kmpProcess(needle); for (int i = 0, j = 0; i &lt; m; ) &#123; if (haystack[i] == needle[j]) &#123; i++; j++; &#125; if (j == n) return i - j; if (i &lt; m &amp;&amp; haystack[i] != needle[j]) &#123; if (j) j = lps[j - 1]; else i++; &#125; &#125; return -1; &#125;private: vector&lt;int&gt; kmpProcess(string&amp; needle) &#123; int n = needle.length(); vector&lt;int&gt; lps(n, 0); for (int i = 1, len = 0; i &lt; n; ) &#123; if (needle[i] == needle[len]) lps[i++] = ++len; else if (len) len = lps[len - 1]; else lps[i++] = 0; &#125; return lps; &#125;&#125;; https://discuss.leetcode.com/topic/4340/my-c-code-that-implements-boyer-moore-string-search-got-accepted-in-12ms My c++ code that implements Boyer-Moore string search got accepted in 12ms. I implements Boyer-Moore string search algorithm and it turns out to be very efficient (accepted in 12ms). Boyer-Moore uses information gained by preprocessing the pattern string to skip as many alignments as possible. A shift is calculated by applying both rules: the bad character rule and the good suffix rule. The actual shifting offset is the maximum of the shifts calculated by these rules. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657char *strStr(char *haystack, char *needle) &#123; if(NULL==haystack||NULL==needle) return NULL; int plen = strlen(needle); int slen = strlen(haystack); if(0==plen) return haystack; else if(plen&gt;slen) return NULL; int badChar[256]; int np = 0; int i,j,k; for(i=0;i&lt;256;i++) badChar[i] = plen; while(np&lt;plen) &#123; badChar[*(needle+np)] = plen-np-1; np++; &#125; int* goodSuffix = new int[plen]; int prefix_index = plen; for(i=plen-1;i&gt;=0;i--) &#123; goodSuffix[i] = prefix_index; if(*(needle+i)==*(needle+plen-1-i)&amp;&amp;prefix_index==i+1) prefix_index = i; &#125; for(i=0;i&lt;plen-1;i++) &#123; j = plen-1, k = 0; while(k&lt;i&amp;&amp;*(needle+j)==*(needle+i-k)) &#123;j--;k++;&#125; if(*(needle+plen-1)==*(needle+i)) goodSuffix[j] = plen-1-i; &#125; goodSuffix[plen-1] = 0; int sp = 0; while(sp&lt;slen) &#123; i = plen-1; while(i&gt;=0&amp;&amp;*(haystack+sp+i)==*(needle+i)) i--; if(i&lt;0) return haystack+sp; int bj = badChar[*(haystack+sp+i)] - plen + i + 1; sp += (bj&gt;goodSuffix[i]?bj:goodSuffix[i]); &#125; delete goodSuffix; return NULL;&#125; https://discuss.leetcode.com/topic/31171/kmp-in-c-explanation-included KMP in C++, explanation included 123456789101112131415161718192021222324252627282930313233343536373839404142434445int strStr(string haystack, string needle) &#123; int nsize = needle.size(); int hsize = haystack.size(); if (nsize == 0) return 0; int *table = new int[nsize]; memset(table, 0, sizeof(int)*nsize); //building match table for (int i = 1, j = 0; i &lt; nsize - 1;)&#123; if (needle[i] != needle[j])&#123; if (j&gt;0)&#123; j = table[j - 1]; &#125; else&#123; i++; &#125; &#125; else&#123; table[i] = j + 1; i++; j++; &#125; &#125; //matching for (int i = 0, match_pos = 0; i &lt; hsize;)&#123; if (haystack[i] == needle[match_pos])&#123; if (match_pos == nsize - 1)&#123; return i - (nsize - 1); &#125; else&#123; i++; match_pos++; &#125; &#125; else&#123; if (match_pos == 0)&#123; i++; &#125; else&#123; match_pos = table[match_pos - 1]; &#125; &#125; &#125; delete[]table; return -1; &#125; I’ll talk about the basic idea behind KMP algorithm. First, some notations: Denote the pattern string as ps and the match table as table, ps and table use 0 based index. Denote substring of ps from index i to index j (i and j included) as substr(ps,i,j). Denote string1 is the same as string2 as string1==string2 The definition of my match table: table[i] when i&gt;0 means the max length of prefix of ps(0,i) which is the same as the suffix of ps(0,i). Or1table[i]=max&#123;k| substr(substr(ps,0,i),0,k-1) == substr(substr(ps,0,i),i-k+1,i), k&lt;=i&#125;. Also, we define table[i]=0. So, for string “aba”, table={0,0,1}. table[1]=0 is because no prefix equals suffix of “ab”. table[2]=1 is because prefix “a” equals suffix “a” of “aba”. for string “abcabce”, table={0,0,0,1,2,3,0}. table[4]=2 is because prefix “ab” equals suffix “ab” of “abcab” table[5]=3 is because prefix “abc” equals suffix “abc” of “abcabc” for string “aabaabaaa”, table={0,1,0,1,2,3,4,5,2}. How would this match table be helpful to string matching? Suppose we have a target string “abcabcdxxxxx” and a pattern “abcabce”.In the first round of matching, we start at first character and have 12abcabcdxxxxxabcabce We discover that ‘d’ and ‘e’ are different and string before that is the same, which is “abcabc”.if we move “abcabce” forward one character, we would be comparing 12abcabcdxxxxx abcabce let’s focus on the parts which are same in the previous round: 12abcabc abcabc we are actually comparing the suffix of length 5 of “abcabc”, which is “bcabc” and the prefix of length 5 of “abcabc”, which is “abcab”. However, table[5]==3 tells us the max length of suffix and prefix of “abcabc” which are same is 3, so suffix and prefixof length 5 can’t be the same. Thus, we can skip this round of comparing.Next, we move “abcabce” forward by another one character, we would be comparing 12abcabc abcabc Now, we are comparing suffix and prefix of length 4, since table[5]==3, we can skip this round.Next, we move “abcabce” forward by another one character, we would be comparing 12abcabc abcabc Now, we are comparing suffix and prefix of length 3, since table[5]==3, this is valid.Another property we can use to simply the matching process is that we already know the prefix and suffix of length 3 are the same, so we can start by comparing from the 4th charater in pattern, which is ‘a’, with the target string. To sum up, when the ps(pattern string) at index i(i&gt;0) failed to match ts(target string) at index j, which means substr(ps,0,i-1) matches, we start by comparing ps[table[i-1]] with ts[j]. python 35ms, 100.00%, September 6, 2016 https://discuss.leetcode.com/topic/29848/my-answer-by-python My answer by Python 1234567891011class Solution(object): def strStr(self, haystack, needle): &quot;&quot;&quot; :type haystack: str :type needle: str :rtype: int &quot;&quot;&quot; for i in range(len(haystack)-len(needle)+1): if haystack[i:i+len(needle)] == needle: return i return -1 c 0ms, 28.37%, September 6, 2016 https://discuss.leetcode.com/topic/6557/a-very-clean-solution-brute-force A very clean solution, brute-force 12345678910int strStr(char *haystack, char *needle) &#123; if (!haystack || !needle) return -1; for (int i = 0; ; ++i) &#123; for (int j = 0; ; ++j) &#123; if (needle[j] == 0) return i; if (haystack[i + j] == 0) return -1; if (haystack[i + j] != needle[j]) break; &#125; &#125; &#125; java 8ms, 28.67%, September 9, 2016 https://discuss.leetcode.com/topic/18839/elegant-java-solution Elegant Java solution 12345678910public class Solution &#123; public int strStr(String haystack, String needle) &#123; for(int i=0; ; i++) for(int j=0; ; j++)&#123; if(j == needle.length()) return i; if(i+j == haystack.length()) return -1; if(needle.charAt(j) != haystack.charAt(i+j)) break; &#125; &#125;&#125; https://discuss.leetcode.com/topic/9872/share-my-accepted-java-solution Share my accepted java solution 1234567891011121314151617public class Solution &#123; public int strStr(String haystack, String needle) &#123; int l1 = haystack.length(), l2 = needle.length(); if (l1 &lt; l2) &#123; return -1; &#125; else if (l2 == 0) &#123; return 0; &#125; int threshold = l1 - l2; for (int i = 0; i &lt;= threshold; ++i) &#123; if (haystack.substring(i,i+l2).equals(needle)) &#123; return i; &#125; &#125; return -1; &#125;&#125; https://discuss.leetcode.com/topic/3576/accepted-kmp-solution-in-java-for-reference Accepted KMP solution in java for reference 1234567891011121314151617181920212223242526272829303132333435public String strStr(String haystack, String needle) &#123; //KMP algorithms if(needle.equals(&quot;&quot;)) return haystack; if(haystack.equals(&quot;&quot;)) return null; char[] arr = needle.toCharArray(); int[] next = makeNext(arr); for(int i = 0, j = 0, end = haystack.length(); i &lt; end;)&#123; if(j == -1 || haystack.charAt(i) == arr[j])&#123; j++; i++; if(j == arr.length) return haystack.substring(i - arr.length); &#125; if(i &lt; end &amp;&amp; haystack.charAt(i) != arr[j]) j = next[j]; &#125; return null;&#125;private int[] makeNext(char[] arr)&#123; int len = arr.length; int[] next = new int[len]; next[0] = -1; for(int i = 0, j = -1; i + 1 &lt; len;)&#123; if(j == -1 || arr[i] == arr[j])&#123; next[i+1] = j+1; if(arr[i+1] == arr[j+1]) next[i+1] = next[j+1]; i++; j++; &#125; if(arr[i] != arr[j]) j = next[j]; &#125; return next;&#125; https://discuss.leetcode.com/topic/41463/java-easy-to-understand-solutions Java easy to understand solutions. 123456789101112131415161718public int strStr1(String haystack, String needle) &#123; return haystack.indexOf(needle);&#125;public int strStr(String haystack, String needle) &#123; if (haystack == null || needle == null) return -1; int l1 = haystack.length(); int l2 = needle.length(); for (int i = 0; i &lt; l1-l2+1; i++) &#123; int count = 0; while (count &lt; l2 &amp;&amp; haystack.charAt(i+count) == needle.charAt(count)) count++; if (count == l2) return i; &#125; return -1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[027. Remove Element]]></title>
    <url>%2Fp%2F98cbed82%2F</url>
    <content type="text"><![CDATA[39.1% https://leetcode.com/problems/remove-element/ Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. 1234Example:Given input array nums = [3,2,2,3], val = 3Your function should return length = 2, with the first two elements of nums being 2. Hint: Try two pointers. Did you use the property of “the order of elements can be changed”? What happens when the elements to remove are rare? 方法一： https://discuss.leetcode.com/topic/17282/very-simple-and-optimal-c-solution Very simple and optimal c++ solution. 12345678910int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int cnt = 0; for(int i = 0 ; i &lt; nums.size() ; ++i) &#123; if(nums[i] == val) cnt++; else nums[i-cnt] = nums[i]; &#125; return nums.size()-cnt;&#125; 方法二： beats 4.4%,but the other 95.6% are same to you ~ including me 4ms, 4.44%, April.23rd, 2016 123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int index = 0; for(int i = 0; i &lt; nums.size(); ++i)&#123; if(nums[i] != val)&#123; nums[index++] = nums[i]; &#125; &#125; return index; &#125;&#125;; 4ms, 4.44%, April.23rd, 2016 123456class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; return distance(nums.begin(), remove(nums.begin(), nums.end(), val)); &#125;&#125;; 4ms, 4.44%, April.23rd, 2016 123456789101112131415class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int tail = nums.size() -1; int i = 0; while(i &lt;= tail)&#123; if(nums[i] == val)&#123; nums[i] = nums[tail--]; continue; &#125; i++; &#125; return tail+1; &#125;&#125;; 我的代码实现： 123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int n = nums.size(); if(n==0) return 0; int index = -1; for(int i=0; i&lt;n; i++) if(nums[i]!=val) nums[++index] = nums[i]; return index+1; &#125;&#125;; python https://discuss.leetcode.com/topic/27777/simple-python-o-n-two-pointer-in-place-solution Simple Python O(n) two pointer in place solution Starting from the left every time we find a value that is the target value we swap it out with an item starting from the right. We decrement end each time as we know that the final item is the target value and only increment start once we know the value is ok. Once start reaches end we know all items after that point are the target value so we can stop there. 12345678def removeElement(self, nums, val): start, end = 0, len(nums) - 1 while start &lt;= end: if nums[start] == val: nums[start], nums[end], end = nums[end], nums[start], end - 1 else: start +=1 return start 48ms, 45.02%, April.23rd, 2016 12345678910class Solution(object): def removeElement(self, nums, val): &quot;&quot;&quot; :type nums: List[int] :type val: int :rtype: int &quot;&quot;&quot; while(val in nums): nums.remove(val) return len(nums) 44ms, 71.09%, April.23rd, 2016 123456789101112class Solution(object): def removeElement(self, nums, val): &quot;&quot;&quot; :type nums: List[int] :type val: int :rtype: int &quot;&quot;&quot; try: while True: nums.remove(val) except: return len(nums) java https://discuss.leetcode.com/topic/1228/my-solution-for-your-reference My solution for your reference. 12345int removeElement(int A[], int n, int elem) &#123; int begin=0; for(int i=0;i&lt;n;i++) if(A[i]!=elem) A[begin++]=A[i]; return begin;&#125; https://discuss.leetcode.com/topic/10753/accepted-java-solution Accepted java solution 123456789101112public int removeElement(int[] A, int elem) &#123; int m = 0; for(int i = 0; i &lt; A.length; i++)&#123; if(A[i] != elem)&#123; A[m] = A[i]; m++; &#125; &#125; return m;&#125; https://discuss.leetcode.com/topic/5205/9-line-java-solution 9-line java solution The basic idea is when elem is found at index i, let A[i] = the last element in the modifying array, then repeat searching until elem is not found. 123456789public int removeElement(int[] A, int elem) &#123; int len = A.length; for (int i = 0 ; i&lt; len; ++i)&#123; while (A[i]==elem &amp;&amp; i&lt; len) &#123; A[i]=A[--len]; &#125; &#125; return len;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[026. Remove Duplicates from Sorted Array]]></title>
    <url>%2Fp%2Fca4383ce%2F</url>
    <content type="text"><![CDATA[35.5% https://leetcode.com/problems/remove-duplicates-from-sorted-array/ Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. 123456For example,Given input array nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn&apos;t matter what you leave beyond the new length. 方法一： beats 35.10% of cppsubmissions 1234567891011class Solution &#123; public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n &lt; 2) return n; int id = 1; for(int i = 1; i &lt; n; ++i) if(nums[i] != nums[i-1]) nums[id++] = nums[i]; return id; &#125;&#125;; 我的代码实现： 123456789101112class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return n; int index = 0; for(int i=1; i&lt;n; i++) if(nums[i]!=nums[index]) nums[++index] = nums[i]; return index+1; &#125;&#125;; https://discuss.leetcode.com/topic/17252/5-lines-c-java-nicer-loops 5 lines C++/Java, nicer loops I don’t like old-style indexed looping. I much prefer the “enhanced” (Java) / “range-based” (C++) loops, they make things much cleaner. C++ 1234567int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int i = 0; for (int n : nums) if (!i || n &gt; nums[i-1]) nums[i++] = n; return i;&#125; And to not need the !i check in the loop: 1234567int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int i = !nums.empty(); for (int n : nums) if (n &gt; nums[i-1]) nums[i++] = n; return i;&#125; https://discuss.leetcode.com/topic/8907/share-my-clean-c-code Share my clean C++ code 123456int count = 0;for(int i = 1; i &lt; n; i++)&#123; if(A[i] == A[i-1]) count++; else A[i-count] = A[i];&#125;return n-count; https://discuss.leetcode.com/topic/25354/simple-c-o-n-solution Simple C++ O(n) solution 12345678910int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int pos = 0; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (i == 0 || nums[i] != nums[pos - 1]) nums[pos++] = nums[i]; &#125; return pos;&#125; python https://discuss.leetcode.com/topic/12672/simple-python-solution-o-n Simple Python solution - O(n) 123456789101112131415class Solution: # @param a list of integers # @return an integer def removeDuplicates(self, A): if not A: return 0 newTail = 0 for i in range(1, len(A)): if A[i] != A[newTail]: newTail += 1 A[newTail] = A[i] return newTail + 1 java https://discuss.leetcode.com/topic/3102/my-solution-time-o-n-space-o-1 My Solution : Time O(n), Space O(1) 12345678910class Solution &#123; public: int removeDuplicates(int A[], int n) &#123; if(n &lt; 2) return n; int id = 1; for(int i = 1; i &lt; n; ++i) if(A[i] != A[i-1]) A[id++] = A[i]; return id; &#125;&#125;; https://discuss.leetcode.com/topic/17252/5-lines-c-java-nicer-loops Java 1234567public int removeDuplicates(int[] nums) &#123; int i = 0; for (int n : nums) if (i == 0 || n &gt; nums[i-1]) nums[i++] = n; return i;&#125; And to not need the i == 0 check in the loop: 1234567public int removeDuplicates(int[] nums) &#123; int i = nums.length &gt; 0 ? 1 : 0; for (int n : nums) if (n &gt; nums[i-1]) nums[i++] = n; return i;&#125; https://discuss.leetcode.com/topic/10262/5-lines-java-solution 5 lines Java solution 1234567public int removeDuplicates(int[] A) &#123; if (A.length==0) return 0; int j=0; for (int i=0; i&lt;A.length; i++) if (A[i]!=A[j]) A[++j]=A[i]; return ++j;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[025. Reverse Nodes in k-Group]]></title>
    <url>%2Fp%2F6d6210c%2F</url>
    <content type="text"><![CDATA[30.0% https://leetcode.com/problems/reverse-nodes-in-k-group/ Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed. 1234567For example,Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 方法一： 此题目是25题的加强版 迭代，参考反转链表的方法 其实与206题，反转链表类似，但是多了几步。先遍历一遍，获得数目 https://discuss.leetcode.com/topic/9839/20-line-iterative-c-solution 20-line iterative C++ solution 1234567891011-1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 | | |pre cur nex -1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; 5 | | | pre cur nex -1 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5 | | | pre cur nex Above is how it works inside one group iteration(for example, k=3) 优化后的代码： Thanks to ciaoliang1992, the tmp pointer is no necessary, so the more concise solution is 12345678910111213141516171819202122232425class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;++i) &#123; cur-&gt;next=nex-&gt;next; nex-&gt;next=pre-&gt;next; pre-&gt;next=nex; nex=cur-&gt;next; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; 我的代码实现: 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if(!head || !head-&gt;next || k&lt;=1) return head; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* cur = dummy; int cnt = 0; // 有必要的时候可以遍历一遍链表，求出链表的长度 while(cur-&gt;next)&#123; cnt++; cur = cur-&gt;next; &#125; ListNode* pre = dummy, *nex; while(cnt/k)&#123; cur = pre-&gt;next; nex = cur-&gt;next; // 对于反转k个，需要的是k-1个后面的转到前面，而不是k个 for(int i=0; i&lt;k-1; i++)&#123; cur-&gt;next = nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; nex = cur-&gt;next; &#125; pre = cur; cnt -= k; &#125; return dummy-&gt;next; &#125;&#125;; 原始代码： 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *tmp, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;i++) &#123; tmp= nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; cur-&gt;next = tmp; nex = tmp; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if(!head || !head-&gt;next || k&lt;=1) return head; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* cur = dummy; int cnt = 0; // 有必要的时候可以遍历一遍链表，求出链表的长度 while(cur-&gt;next)&#123; cnt++; cur = cur-&gt;next; &#125; ListNode* pre = dummy, *nex, *tmp; while(cnt/k)&#123; cur = pre-&gt;next; nex = cur-&gt;next; // 对于反转k个，需要的是k-1个后面的转到前面，而不是k个 for(int i=0; i&lt;k-1; i++)&#123; tmp = nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; cur-&gt;next = tmp; nex = cur-&gt;next; &#125; pre = cur; cnt -= k; &#125; return dummy-&gt;next; &#125;&#125;; 方法二： 递归 C++ Elegant and Small 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: ListNode* reverse(ListNode* first, ListNode* last) &#123; ListNode* prev = last; while ( first != last ) &#123; auto tmp = first-&gt;next; first-&gt;next = prev; prev = first; first = tmp; &#125; return prev; &#125; ListNode* reverseKGroup(ListNode* head, int k) &#123; auto node=head; for (int i=0; i &lt; k; ++i) &#123; if ( ! node ) return head; // nothing to do list too sort node = node-&gt;next; &#125; auto new_head = reverse( head, node); head-&gt;next = reverseKGroup( node, k); return new_head; &#125;&#125;; 我的实现： 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; int cnt = 0; auto node = head; while(cnt&lt;k)&#123; if(node==NULL) return head; cnt++; node = node-&gt;next; &#125; auto new_head = reverse(head, k); head-&gt;next = reverseKGroup(node, k); return new_head; &#125; ListNode* reverse(ListNode* head, int k)&#123; ListNode* pre = NULL; int cnt = 0; while(cnt&lt;k)&#123; ListNode* nex = head-&gt;next; head-&gt;next = pre; pre = head; head = nex; cnt++; &#125; return pre; &#125;&#125;; cpp 其实与206题，反转链表类似，但是多了几步。先遍历一遍，获得数目 https://discuss.leetcode.com/topic/9839/20-line-iterative-c-solution 20-line iterative C++ solution 1234567891011-1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 | | | | pre cur nex tmp-1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; 5 | | | | pre cur nex tmp-1 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5 | | | | pre cur nex tmp Above is how it works inside one group iteration(for example, k=3) 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *tmp, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;i++) &#123; tmp= nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; cur-&gt;next = tmp; nex = tmp; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; Thanks to ciaoliang1992, the tmp pointer is no necessary, so the more concise solution is 12345678910111213141516171819202122232425class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;++i) &#123; cur-&gt;next=nex-&gt;next; nex-&gt;next=pre-&gt;next; pre-&gt;next=nex; nex=cur-&gt;next; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/25867/c-elegant-and-small C++ Elegant and Small 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: ListNode* reverse(ListNode* first, ListNode* last) &#123; ListNode* prev = last; while ( first != last ) &#123; auto tmp = first-&gt;next; first-&gt;next = prev; prev = first; first = tmp; &#125; return prev; &#125; ListNode* reverseKGroup(ListNode* head, int k) &#123; auto node=head; for (int i=0; i &lt; k; ++i) &#123; if ( ! node ) return head; // nothing to do list too sort node = node-&gt;next; &#125; auto new_head = reverse( head, node); head-&gt;next = reverseKGroup( node, k); return new_head; &#125;&#125;; https://discuss.leetcode.com/topic/17914/24ms-easy-c-iterative-solution-with-explanations 24ms Easy C++ Iterative Solution with Explanations Well, since the head pointer may also be modified, we create a new_head that points to it to facilitate the reverse process. For the example list 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 in the problem statement, it will become 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 (we init new_head -&gt; val to be 0). Then we set a pointer pre to new_head and another cur to head. Then we insert cur -&gt; next after pre for k - 1 times if the current node cur has at least k nodes after it (including itself). After reversing one k-group, we update pre to be cur and cur to be pre -&gt; next to reverse the next k-group. The code is as follows. 12345678910111213141516171819202122232425262728293031class Solution &#123; public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if (!hasKNodes(head, k)) return head; ListNode* new_head = new ListNode(0); new_head -&gt; next = head; ListNode* pre = new_head; ListNode* cur = head; while (hasKNodes(cur, k)) &#123; for (int i = 0; i &lt; k - 1; i++) &#123; ListNode* temp = pre -&gt; next; pre -&gt; next = cur -&gt; next; cur -&gt; next = cur -&gt; next -&gt; next; pre -&gt; next -&gt; next = temp; &#125; pre = cur; cur = pre -&gt; next; &#125; return new_head -&gt; next; &#125;private: bool hasKNodes(ListNode* node, int k) &#123; int cnt = 0; while (node) &#123; cnt++; if (cnt &gt;= k) return true; node = node -&gt; next; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/31618/succinct-iterative-python-o-n-time-o-1-space Succinct iterative Python, O(n) time O(1) space Use a dummy head, and l, r : define reversing range pre, cur : used in reversing, standard reverse linked linked list method jump : used to connect last node in previous k-group to first node in following k-group 12345678910111213141516def reverseKGroup(self, head, k): dummy = jump = ListNode(0) dummy.next = l = r = head while True: count = 0 while r and count &lt; k: # use r to locate the range r = r.next count += 1 if count == k: # if size k satisfied, reverse the inner linked list pre, cur = r, l for _ in range(k): cur.next, cur, pre = pre, cur.next, cur # standard reversing jump.next, jump, l = pre, l, r # connect two k-groups else: return dummy.next https://discuss.leetcode.com/topic/6956/simple-python-solution-one-pass-no-additional-space-109ms Simple Python solution, one pass, no additional space, 109ms The key idea is to keep track of the next_head while reversing the group, tail of the current group is always the start node of the group, once the group reversing is done, next_head is available, simply connect it to tail. 12345678910111213141516171819202122232425def reverseKGroup(self, head, k): if head is None or k &lt; 2: return head next_head = head for i in range(k - 1): next_head = next_head.next if next_head is None: return head ret = next_head current = head while next_head: tail = current prev = None for i in range(k): if next_head: next_head = next_head.next _next = current.next current.next = prev prev = current current = _next tail.next = next_head or current return ret java https://discuss.leetcode.com/topic/7126/short-but-recursive-java-code-with-comments Short but recursive Java code with comments Hi, guys! Despite the fact that the approach is recursive, the code is less than 20 lines. :) 123456789101112131415161718192021public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode curr = head; int count = 0; while (curr != null &amp;&amp; count != k) &#123; // find the k+1 node curr = curr.next; count++; &#125; if (count == k) &#123; // if k+1 node is found curr = reverseKGroup(curr, k); // reverse list with k+1 node as head // head - head-pointer to direct part, // curr - head-pointer to reversed part; while (count-- &gt; 0) &#123; // reverse current k-group: ListNode tmp = head.next; // tmp - next head in direct part head.next = curr; // preappending &quot;direct&quot; head to the reversed list curr = head; // move head of reversed part to a new node head = tmp; // move &quot;direct&quot; head to the next node in direct part &#125; head = curr; &#125; return head;&#125; Hope it helps! https://discuss.leetcode.com/topic/5604/share-my-java-solution-with-comments-in-line Share my Java Solution with comments in line 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if (head==null||head.next==null||k&lt;2) return head; ListNode dummy = new ListNode(0); dummy.next = head; ListNode tail = dummy, prev = dummy,temp; int count; while(true)&#123; count =k; while(count&gt;0&amp;&amp;tail!=null)&#123; count--; tail=tail.next; &#125; if (tail==null) break;//Has reached the end head=prev.next;//for next cycle // prev--&gt;temp--&gt;...---&gt;....---&gt;tail--&gt;.... // Delete @temp and insert to the next position of @tail // prev--&gt;...--&gt;...--&gt;tail--&gt;head--&gt;... // Assign @temp to the next node of @prev // prev--&gt;temp--&gt;...--&gt;tail--&gt;...--&gt;... // Keep doing until @tail is the next node of @prev while(prev.next!=tail)&#123; temp=prev.next;//Assign prev.next=temp.next;//Delete temp.next=tail.next; tail.next=temp;//Insert &#125; tail=head; prev=head; &#125; return dummy.next; &#125;&#125; https://discuss.leetcode.com/topic/12364/non-recursive-java-solution-and-idea Non-recursive Java solution and idea Reference: http://www.cnblogs.com/lichen782/p/leetcode_Reverse_Nodes_in_kGroup.html First, build a function reverse() to reverse the ListNode between begin and end. See the explanation below: 123456789101112131415test /** * Reverse a link list between begin and end exclusively * an example: * a linked list: * 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 * | | * begin end * after call begin = reverse(begin, end) * * 0-&gt;3-&gt;2-&gt;1-&gt;4-&gt;5-&gt;6 * | | * begin end * @return the reversed list&apos;s &apos;begin&apos; node, which is the precedence of node end */ Then walk thru the linked list and apply reverse() iteratively. See the code below. 123456789101112131415161718192021222324252627282930313233343536public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode begin; if (head==null || head.next ==null || k==1) return head; ListNode dummyhead = new ListNode(-1); dummyhead.next = head; begin = dummyhead; int i=0; while (head != null)&#123; i++; if (i%k == 0)&#123; begin = reverse(begin, head.next); head = begin.next; &#125; else &#123; head = head.next; &#125; &#125; return dummyhead.next; &#125;public ListNode reverse(ListNode begin, ListNode end)&#123; ListNode curr = begin.next; ListNode next, first; ListNode prev = begin; first = curr; while (curr!=end)&#123; next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; begin.next = prev; first.next = curr; return first;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[024. Swap Nodes in Pairs]]></title>
    <url>%2Fp%2F94079f17%2F</url>
    <content type="text"><![CDATA[38.3% https://leetcode.com/problems/swap-nodes-in-pairs/ Given a linked list, swap every two adjacent nodes and return its head. 12For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 方法一： 递归调用 Simple implementation with C++ 123456789101112131415class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(head == NULL) return NULL; if(head-&gt;next == NULL) return head; ListNode* next = head-&gt;next; head-&gt;next = swapPairs(next-&gt;next); next-&gt;next = head; return next; &#125;&#125;; 我的代码实现： 递归方法，实现起来最简单 123456789101112131415161718/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* nex = head-&gt;next; head-&gt;next = swapPairs(nex-&gt;next); nex-&gt;next = head; return nex; &#125;&#125;; 另一种实现 Very easy solution 123456789101112class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode *l=head; if(head&amp;&amp;head-&gt;next)&#123; l=head-&gt;next; head-&gt;next=swapPairs(l-&gt;next); l-&gt;next=head; &#125; return l; &#125;&#125;; 方法二： 我自己的方法，多定义几个变量，依次迭代。 12345678910111213141516class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* cur = dummy; while(cur-&gt;next!=NULL &amp;&amp; cur-&gt;next-&gt;next!=NULL)&#123; ListNode* n1=cur-&gt;next, *n2 = cur-&gt;next-&gt;next, *n3=cur-&gt;next-&gt;next-&gt;next; cur-&gt;next = n2; n2-&gt;next = n1; n1-&gt;next = n3; cur = n1; &#125; return dummy-&gt;next; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* cur = dummy, *first, *second; while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123; first = cur-&gt;next; second = cur-&gt;next-&gt;next; first-&gt;next = second-&gt;next; second-&gt;next = first; cur-&gt;next = second; cur = first; &#125; return dummy-&gt;next; &#125;&#125;; cpp 4ms, 3.56%, July 14th, 2016 https://discuss.leetcode.com/topic/18860/7-8-lines-c-python-ruby 7-8 lines C++ / Python / Ruby Three different implementations of the same algorithm, taking advantage of different strengths of the three languages. I suggest reading all three, even if you don’t know all three languages. All three of course work swap the current node with the next node by rearranging pointers, then move on to the next pair, and repeat until the end of the list. C++ Pointer-pointer pp points to the pointer to the current node. So at first, pp points to head, and later it points to the next field of ListNodes. Additionally, for convenience and clarity, pointers a and b point to the current node and the next node. We need to go from pp == a -&gt; b -&gt; (b-&gt;next) to pp == b -&gt; a -&gt; (b-&gt;next). The first three lines inside the loop do that, setting those three pointers (from right to left). The fourth line moves pp to the next pair. 12345678910ListNode* swapPairs(ListNode* head) &#123; ListNode **pp = &amp;head, *a, *b; while ((a = *pp) &amp;&amp; (b = a-&gt;next)) &#123; a-&gt;next = b-&gt;next; b-&gt;next = a; *pp = b; pp = &amp;(a-&gt;next); &#125; return head;&#125; Python Here, pre is the previous node. Since the head doesn’t have a previous node, I just use self instead. Again, a is the current node and b is the next node. To go from pre -&gt; a -&gt; b -&gt; b.next to pre -&gt; b -&gt; a -&gt; b.next, we need to change those three references. Instead of thinking about in what order I change them, I just change all three at once. 12345678def swapPairs(self, head): pre, pre.next = self, head while pre.next and pre.next.next: a = pre.next b = a.next pre.next, b.next, a.next = b, a, b.next pre = a return self.next https://discuss.leetcode.com/topic/29060/simple-implementation-with-c Simple implementation with C++ 123456789101112131415class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(head == NULL) return NULL; if(head-&gt;next == NULL) return head; ListNode* next = head-&gt;next; head-&gt;next = swapPairs(next-&gt;next); next-&gt;next = head; return next; &#125;&#125;; https://discuss.leetcode.com/topic/31626/very-easy-solution Very easy solution 123456789101112class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode *l=head; if(head&amp;&amp;head-&gt;next)&#123; l=head-&gt;next; head-&gt;next=swapPairs(l-&gt;next); l-&gt;next=head; &#125; return l; &#125;&#125;; python 4ms, 3.56%, July 14th, 2016 https://discuss.leetcode.com/topic/18860/7-8-lines-c-python-ruby 12345678910111213141516171819# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def swapPairs(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; pre, pre.next = self, head while pre.next and pre.next.next: a = pre.next b = a.next pre.next, b.next, a.next = b, a, b.next pre = a return self.next java 0ms, 6.43%, July 14th, 2016 https://discuss.leetcode.com/topic/4351/my-accepted-java-code-used-recursion My accepted java code. used recursion. 123456789101112131415161718/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if((head == null) || (head.next == null)) return head; ListNode n = head.next; head.next = swapPairs(head.next.next); n.next = head; return n; &#125;&#125; 0ms, 6.43%, July 14th, 2016 https://discuss.leetcode.com/topic/10649/my-simple-java-solution-for-share My accepted java code. used recursion. 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode current = dummy; while(current.next != null &amp;&amp; current.next.next != null)&#123; ListNode first = current.next; ListNode second = current.next.next; first.next = second.next; current.next = second; current.next.next = first; current = current.next.next; &#125; return dummy.next; &#125;&#125; https://discuss.leetcode.com/topic/41459/java-simple-recursive-solution Java simple recursive solution Starting to see that recursion is the perfect tool for (many) linked list problems (this one + merging list problem). 1234567891011121314151617181920/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode second = head.next; ListNode third = second.next; second.next = head; head.next = swapPairs(third); return second; &#125;&#125; https://discuss.leetcode.com/topic/5163/my-simple-recursive-solution My simple recursive solution My solution is quite simple. Just find the reverse job is the same for every 2 nodes. 12345678910public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode newhd = head.next; head.next = swapPairs(newhd.next); newhd.next = head; return newhd;&#125; https://discuss.leetcode.com/topic/39095/my-straight-forward-java-solution-without-recursion-or-dummy-nodes-0ms My straight-forward Java solution without recursion or dummy nodes (0ms) The idea is straightforward: use two pointers and swap a.next = b.next, b.next = a. Then continue the next pair, b = a.next.next, a=a.next Remember to check null Remember to track new head Remember to link the new pair after the prior nodes.Attached is the accepted code. 12345678910111213141516public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head==null || head.next==null) return head; ListNode newHead = head.next, a=head,b=a.next,pre = null; while(a!=null &amp;&amp; b!=null)&#123; a.next = b.next; b.next = a; if(pre!=null) pre.next = b; if(a.next==null) break; b = a.next.next; pre = a; a = a.next; &#125; return newHead; &#125;&#125; AC, 0ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[023. Merge k Sorted Lists]]></title>
    <url>%2Fp%2F32640f57%2F</url>
    <content type="text"><![CDATA[26.4% https://leetcode.com/problems/merge-k-sorted-lists/ Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 方法一： 对这个vector&lt;ListNode*&gt; 的前两个，进行合并，然后合并结果， 放入vector中，再把vector的前两个删除。只要vector的size不为1， 一直循环。 注意，vector有erase的函数，示例如下：lists.erase(lists.begin()); 123456789101112131415161718192021222324252627ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; if(lists.empty())&#123; return nullptr; &#125; while(lists.size() &gt; 1)&#123; lists.push_back(mergeTwoLists(lists[0], lists[1])); lists.erase(lists.begin()); lists.erase(lists.begin()); &#125; return lists.front();&#125;ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(l1 == nullptr)&#123; return l2; &#125; if(l2 == nullptr)&#123; return l1; &#125; if(l1-&gt;val &lt;= l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125;&#125; 我的代码实现: 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; // 考虑异常，为空时 if(lists.empty()) return NULL; while(lists.size()&gt;1)&#123; ListNode* node = helper(lists[0], lists[1]); // 学习erase的用法，里面使用的是迭代器 lists.erase(lists.begin()); lists.erase(lists.begin()); lists.push_back(node); &#125; return lists[0]; &#125; ListNode* helper(ListNode* l1, ListNode* l2)&#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = helper(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = helper(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 方法二: vector erase效率堪忧，使用deque来解决 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; int n = lists.size(); if(n==0) return NULL; if(n==1) return lists[0]; deque&lt;ListNode*&gt; dq; for(auto node:lists) dq.push_back(node); while(dq.size()&gt;1)&#123; ListNode* l1 = dq.front(); dq.pop_front(); ListNode* l2 = dq.front(); dq.pop_front(); ListNode* l3 = merge(l1, l2); dq.push_back(l3); &#125; return dq.front(); &#125; ListNode* merge(ListNode* l1, ListNode* l2)&#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = merge(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = merge(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/6882/sharing-my-straightforward-c-solution-without-data-structure-other-than-vector Sharing my straightforward C++ solution without data structure other than vector 123456789101112131415161718192021222324252627ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; if(lists.empty())&#123; return nullptr; &#125; while(lists.size() &gt; 1)&#123; lists.push_back(mergeTwoLists(lists[0], lists[1])); lists.erase(lists.begin()); lists.erase(lists.begin()); &#125; return lists.front();&#125;ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(l1 == nullptr)&#123; return l2; &#125; if(l2 == nullptr)&#123; return l1; &#125; if(l1-&gt;val &lt;= l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125;&#125; The second function is from Merge Two Sorted Lists. The basic idea is really simple. We can merge first two lists and then push it back. Keep doing this until there is only one list left in vector. Actually, we can regard this as an iterative divide-and-conquer solution. https://discuss.leetcode.com/topic/7160/brief-c-solution-with-priority_queue Brief C++ solution with priority_queue We just need to define a comparison struct for ListNodes, then managing the priority_queue is quite straightforward. After filling the priority_queue, if it is non-empty, we set the head and tail. Then we repeatedly pop the top off the queue and append that to the tail. If the next node is not null, we push it onto the queue. 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; struct compare &#123; bool operator()(const ListNode* l, const ListNode* r) &#123; return l-&gt;val &gt; r-&gt;val; &#125; &#125;; public: ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, compare&gt; q; for (auto l : lists) &#123; if (l) &#123; q.push(l); &#125; &#125; if (q.empty()) &#123; return NULL; &#125; ListNode* result = q.top(); q.pop(); if (result-&gt;next) &#123; q.push(result-&gt;next); &#125; ListNode* tail = result; while (!q.empty()) &#123; tail-&gt;next = q.top(); q.pop(); tail = tail-&gt;next; if (tail-&gt;next) &#123; q.push(tail-&gt;next); &#125; &#125; return result; &#125;&#125;; python 128ms, 79.54%, September 4, 2016 https://discuss.leetcode.com/topic/23140/108ms-python-solution-with-heapq-and-avoid-changing-heap-size 108ms python solution with heapq and avoid changing heap size 123456789101112131415def mergeKLists(self, lists): from heapq import heappush, heappop, heapreplace, heapify dummy = node = ListNode(0) h = [(n.val, n) for n in lists if n] heapify(h) while h: v, n = h[0] if n.next is None: heappop(h) #only change heap size when necessary else: heapreplace(h, (n.next.val, n.next)) node.next = n node = node.next return dummy.next https://discuss.leetcode.com/topic/33609/10-line-python-solution-with-priority-queue 10-line python solution with priority queue 12345678910111213from Queue import PriorityQueueclass Solution(object): def mergeKLists(self, lists): dummy = ListNode(None) curr = dummy q = PriorityQueue() for node in lists: if node: q.put((node.val,node)) while q.qsize()&gt;0: curr.next = q.get()[1] curr=curr.next if curr.next: q.put((curr.next.val, curr.next)) return dummy.next java https://discuss.leetcode.com/topic/2780/a-java-solution-based-on-priority-queue A java solution based on Priority Queue If someone understand how priority queue works, then it would be trivial to walk through the codes. My question: is that possible to solve this question under the same time complexity without implementing the priority queue? 123456789101112131415161718192021222324252627282930313233public class Solution &#123; public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; if (lists==null||lists.size()==0) return null; PriorityQueue&lt;ListNode&gt; queue= new PriorityQueue&lt;ListNode&gt;(lists.size(),new Comparator&lt;ListNode&gt;()&#123; @Override public int compare(ListNode o1,ListNode o2)&#123; if (o1.val&lt;o2.val) return -1; else if (o1.val==o2.val) return 0; else return 1; &#125; &#125;); ListNode dummy = new ListNode(0); ListNode tail=dummy; for (ListNode node:lists) if (node!=null) queue.add(node); while (!queue.isEmpty())&#123; tail.next=queue.poll(); tail=tail.next; if (tail.next!=null) queue.add(tail.next); &#125; return dummy.next; &#125;&#125; https://discuss.leetcode.com/topic/2780/a-java-solution-based-on-priority-queue/4 I think my code’s complexity is also O(nlogk) and not using heap or priority queue, n means the total elements and k means the size of list. The mergeTwoLists functiony in my code comes from the problem Merge Two Sorted Lists whose complexity obviously is O(n), n is the sum of length of l1 and l2. To put it simpler, assume the k is 2^x, So the progress of combination is like a full binary tree, from bottom to top. So on every level of tree, the combination complexity is n, beacause every level have all n numbers without repetition. The level of tree is x, ie logk. So the complexity is O(nlogk). 12345678910for example, 8 ListNode, and the length of every ListNode is x1, x2,x3, x4, x5, x6, x7, x8, total is n.on level 3: x1+x2, x3+x4, x5+x6, x7+x8 sum: non level 2: x1+x2+x3+x4, x5+x6+x7+x8 sum: non level 1: x1+x2+x3+x4+x5+x6+x7+x8 sum: ntotal 3n, nlog8 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; ListNode head=null; ListNode former=null; while (l1!=null&amp;&amp;l2!=null) &#123; if (l1.val&gt;l2.val) &#123; if (former==null) former=l2; else former.next=l2; if (head==null) head=former; else former=former.next; l2=l2.next; &#125; else &#123; if (former==null) former=l1; else former.next=l1; if (head==null) head=former; else former=former.next; l1=l1.next; &#125; &#125; if (l2!=null) l1=l2; former.next=l1; return head; &#125; public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; if (lists.size()==0) return null; if (lists.size()==1) return lists.get(0); if (lists.size()==2) return mergeTwoLists(lists.get(0), lists.get(1)); return mergeTwoLists(mergeKLists(lists.subList(0, lists.size()/2)), mergeKLists(lists.subList(lists.size()/2, lists.size()))); &#125;&#125; 3ms, 91.70%, September 5, 2016 https://discuss.leetcode.com/topic/26095/my-simple-java-solution-use-recursion My simple java Solution use recursion 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; return partion(lists, 0, lists.length-1); &#125; public static ListNode partion(ListNode[] lists, int s, int e)&#123; if(s==e) return lists[s]; if(s&lt;e)&#123; int q = (s+e) / 2; ListNode l1 = partion(lists, s, q); ListNode l2 = partion(lists, q+1, e); return merge(l1, l2); &#125;else return null; &#125; public static ListNode merge(ListNode l1, ListNode l2)&#123; if(l1==null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val)&#123; l1.next = merge(l1.next, l2); return l1; &#125;else&#123; l2.next = merge(l1, l2.next); return l2; &#125; &#125;&#125; https://discuss.leetcode.com/topic/31276/simple-java-merge-sort Simple Java Merge Sort For this problem, use merge sort is simple and fast, I wonder why some guys solve it use PriorityQueue. I think the complexity is k n logk. Because the recursion depth is logK, and in each level, every element will be compared. 1234567891011121314151617public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) return null; return mergeKLists(lists, 0, lists.length - 1);&#125;private ListNode mergeKLists(ListNode[] lists, int start, int end) &#123; if (start == end) &#123; return lists[start]; &#125; else if (start &lt; end)&#123; int mid = (end - start) / 2 + start; ListNode left = mergeKLists(lists, start, mid); ListNode right = mergeKLists(lists, mid + 1, end); return mergeTwoLists(left, right); &#125; else &#123; return null; &#125;&#125; mergeTwoLists is base on the Merge Two Sorted Lists problem. https://discuss.leetcode.com/topic/8949/13-lines-in-java 13-lines in Java Hi guys! The approach is standard - PriorityQueue, but I noticed that solutions presented before are kind of a bit long. So that’s the concise version. :) Hope it helps! 1234567891011121314151617public class Solution &#123; public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; Queue&lt;ListNode&gt; heap = new PriorityQueue(new Comparator&lt;ListNode&gt;()&#123; @Override public int compare(ListNode l1, ListNode l2) &#123; return l1.val - l2.val; &#125; &#125;); ListNode head = new ListNode(0), tail = head; for (ListNode node : lists) if (node != null) heap.offer(node); while (!heap.isEmpty()) &#123; tail.next = heap.poll(); tail = tail.next; if (tail.next != null) heap.offer(tail.next); &#125; return head.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>divide and conquer</tag>
        <tag>hard</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[022. Generate Parentheses]]></title>
    <url>%2Fp%2Fa9da9348%2F</url>
    <content type="text"><![CDATA[33.4% https://leetcode.com/problems/generate-parentheses/ Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 方法一： The idea is intuitive. Use two integers to count the remaining left parenthesis (n) and the right parenthesis (m) to be added. At each function call add a left parenthesis if n &gt;0 and add a right parenthesis if m&gt;0. Append the result and terminate recursive calls when both m and n are zero. https://leetcode.com/discuss/14436/concise-recursive-c-solution 123456789101112131415161718class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; addingpar(res, &quot;&quot;, n, 0); return res; &#125; void addingpar(vector&lt;string&gt; &amp;v,string str, int n, int m)&#123; if(m==0 &amp;&amp; n==0)&#123; v.push_back(str); return; &#125; if(m&gt;0) addingpar(v, str+&quot;)&quot;, n, m-1); if(n&gt;0) addingpar(v, str+&quot;(&quot;, n-1, m+1); &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/15294/6-lines-c-3-4-ms-super-easy-to-understand 6 lines c++ 3~4 ms, super easy to understand 123456789101112vector&lt;string&gt; result;void helper(string str, int left, int right)&#123; if(left == 0 &amp;&amp; right == 0) result.push_back(str); if(left!=0) helper(str+&apos;(&apos;, left-1, right); if(right!=0 &amp;&amp; right &gt; left) helper(str+&apos;)&apos;, left, right-1);&#125; vector&lt;string&gt; generateParenthesis(int n) &#123; helper(&quot;&quot;,n,n); return result;&#125; 我的代码实现： 递归， 循环调用栈,消耗内存 1234567891011121314151617class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; helper(res, n, n, ""); return res; &#125; void helper(vector&lt;string&gt;&amp; res, int left, int right, string s)&#123; if(left==0 &amp;&amp; right==0) res.push_back(s); if(left!=0) helper(res, left-1, right, s+'('); if(right!=0 &amp;&amp; right&gt;left) helper(res, left, right-1, s+')'); &#125;&#125;; 方法三； dp解法 https://discuss.leetcode.com/topic/3474/an-iterative-method My method is DP. First consider how to get the result f(n) from previous result f(0)…f(n-1).Actually, the result f(n) will be put an extra () pair to f(n-1). Let the “(“ always at the first position, to produce a valid result, we can only put “)” in a way that there will be i pairs () inside the extra () and n - 1 - i pairs () outside the extra pair. Let us consider an example to get clear view: f(0): “” f(1): “(“f(0)”)” f(2): “(“f(0)”)”f(1), “(“f(1)”)” f(3): “(“f(0)”)”f(2), “(“f(1)”)”f(1), “(“f(2)”)” So f(n) = “(“f(0)”)”f(n-1) , “(“f(1)”)”f(n-2) “(“f(2)”)”f(n-3) … “(“f(i)”)”f(n-1-i) … “(f(n-1)”)” Below is my code: 我的代码实现： 123456789101112131415161718class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; // 注意定义及初始化的问题，vector&lt;string&gt;()，而不是vector&lt;string&gt; vector&lt;vector&lt;string&gt;&gt; dp(n+1, vector&lt;string&gt;()); // 学习此处的初始化 dp[0] = vector&lt;string&gt;&#123;""&#125;; for(int i=1; i&lt;=n; i++)&#123; for(int j=0; j&lt;i; j++) for(string first:dp[j]) for(string second:dp[i-j-1])&#123; string t = '(' + first + ')' + second; dp[i].push_back(t); &#125; &#125; return dp[n]; &#125;&#125;; cpp The idea is intuitive. Use two integers to count the remaining left parenthesis (n) and the right parenthesis (m) to be added. At each function call add a left parenthesis if n &gt;0 and add a right parenthesis if m&gt;0. Append the result and terminate recursive calls when both m and n are zero. https://leetcode.com/discuss/14436/concise-recursive-c-solution123456789101112131415161718class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; addingpar(res, &quot;&quot;, n, 0); return res; &#125; void addingpar(vector&lt;string&gt; &amp;v,string str, int n, int m)&#123; if(m==0 &amp;&amp; n==0)&#123; v.push_back(str); return; &#125; if(m&gt;0) addingpar(v, str+&quot;)&quot;, n, m-1); if(n&gt;0) addingpar(v, str+&quot;(&quot;, n-1, m+1); &#125;&#125;; python https://leetcode.com/discuss/43122/4-7-lines-python 4-7 lines Python p is the parenthesis-string built so far, left and right tell the number of left and right parentheses still to add, and parens collects the parentheses. Solution 1 I used a few “tricks”… how many can you find? :-) 1234567def generateParenthesis(self, n): def generate(p, left, right, parens=[]): if left: generate(p + &apos;(&apos;, left-1, right) if right &gt; left: generate(p + &apos;)&apos;, left, right-1) if not right: parens += p, return parens return generate(&apos;&apos;, n, n) Solution 2 Here I wrote an actual Python generator. I allow myself to put the yield q at the end of the line because it’s not that bad and because in “real life” I use Python 3 where I just say yield from generate(…). 12345678def generateParenthesis(self, n): def generate(p, left, right): if right &gt;= left &gt;= 0: if not right: yield p for q in generate(p + &apos;(&apos;, left-1, right): yield q for q in generate(p + &apos;)&apos;, left, right-1): yield q return list(generate(&apos;&apos;, n, n)) Solution 3 Improved version of this. Parameter open tells the number of “already opened” parentheses, and I continue the recursion as long as I still have to open parentheses (n &gt; 0) and I haven’t made a mistake yet (open &gt;= 0). 12345def generateParenthesis(self, n, open=0): if n &gt; 0 &lt;= open: return [&apos;(&apos; + p for p in self.generateParenthesis(n-1, open+1)] + \ [&apos;)&apos; + p for p in self.generateParenthesis(n, open-1)] return [&apos;)&apos; * open] * (not n) java The idea here is to only add ‘(‘ and ‘)’ that we know will guarantee us a solution (instead of adding 1 too many close). Once we add a ‘(‘ we will then discard it and try a ‘)’ which can only close a valid ‘(‘. Each of these steps are recursively called. https://leetcode.com/discuss/25063/easy-to-understand-java-backtracking-solution 1234567891011121314151617181920public class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); backtrack(list, &quot;&quot;, 0, 0, n); return list; &#125; public void backtrack(List&lt;String&gt; list, String str, int open, int close, int max)&#123; if(str.length() == max*2)&#123; list.add(str); return; &#125; if(open&lt;max) backtrack(list, str+&quot;(&quot;, open+1, close, max); if(close&lt;open) backtrack(list, str+&quot;)&quot;, open, close+1, max); &#125; &#125; https://discuss.leetcode.com/topic/3474/an-iterative-method An iterative method. My method is DP. First consider how to get the result f(n) from previous result f(0)…f(n-1).Actually, the result f(n) will be put an extra () pair to f(n-1). Let the “(“ always at the first position, to produce a valid result, we can only put “)” in a way that there will be i pairs () inside the extra () and n - 1 - i pairs () outside the extra pair. 1234567891011Let us consider an example to get clear view:f(0): &quot;&quot;f(1): &quot;(&quot;f(0)&quot;)&quot;f(2): &quot;(&quot;f(0)&quot;)&quot;f(1), &quot;(&quot;f(1)&quot;)&quot;f(3): &quot;(&quot;f(0)&quot;)&quot;f(2), &quot;(&quot;f(1)&quot;)&quot;f(1), &quot;(&quot;f(2)&quot;)&quot;So f(n) = &quot;(&quot;f(0)&quot;)&quot;f(n-1) , &quot;(&quot;f(1)&quot;)&quot;f(n-2) &quot;(&quot;f(2)&quot;)&quot;f(n-3) ... &quot;(&quot;f(i)&quot;)&quot;f(n-1-i) ... &quot;(f(n-1)&quot;)&quot; Below is my code: 12345678910111213141516171819202122232425262728public class Solution&#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;&gt;(); lists.add(Collections.singletonList(&quot;&quot;)); for (int i = 1; i &lt;= n; ++i) &#123; final List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; i; ++j) &#123; for (final String first : lists.get(j)) &#123; for (final String second : lists.get(i - 1 - j)) &#123; list.add(&quot;(&quot; + first + &quot;)&quot; + second); &#125; &#125; &#125; lists.add(list); &#125; return lists.get(lists.size() - 1); &#125;&#125; https://discuss.leetcode.com/topic/23229/java-dfs-way-solution Java DFS way solution 1234567891011121314151617181920public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); generateOneByOne(&quot;&quot;, list, n, n); return list;&#125;public void generateOneByOne(String sublist, List&lt;String&gt; list, int left, int right)&#123; if(left &gt; right)&#123; return; &#125; if(left &gt; 0)&#123; generateOneByOne( sublist + &quot;(&quot; , list, left-1, right); &#125; if(right &gt; 0)&#123; generateOneByOne( sublist + &quot;)&quot; , list, left, right-1); &#125; if(left == 0 &amp;&amp; right == 0)&#123; list.add(sublist); return; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[021. Merge Two Sorted Lists]]></title>
    <url>%2Fp%2F149a587d%2F</url>
    <content type="text"><![CDATA[39.2% https://leetcode.com/problems/merge-two-sorted-lists/ Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 剑指offer 17题 方法一： 简单的递归就行了 我的代码实现： Oct 11， 2017 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 1234567891011121314class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(l1==NULL) return l2; if(l2==NULL) return l1; if(l1-&gt;val &lt;= l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 方法二： 我的代码实现： 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125; cur = cur-&gt;next; &#125; if(l1) cur-&gt;next = l1; if(l2) cur-&gt;next = l2; return dummy-&gt;next; &#125;&#125;; 迭代形式的写法 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; ListNode dummy(INT_MIN); ListNode *tail = &amp;dummy; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; tail-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; tail-&gt;next = l2; l2 = l2-&gt;next; &#125; tail = tail-&gt;next; &#125; tail-&gt;next = l1 ? l1 : l2; return dummy.next; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125; // cur不要忘记前向走 cur = cur-&gt;next; &#125; // 对于链表，剩下的一部分特别好处理 cur-&gt;next = l1 ? l1 : l2; return dummy-&gt;next; &#125;&#125;; cpp https://discuss.leetcode.com/topic/2513/a-recursive-solution A recursive solution 123456789101112131415class Solution &#123;public: ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(l1 == NULL) return l2; if(l2 == NULL) return l1; if(l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l2-&gt;next, l1); return l2; &#125; &#125;&#125;; This solution is not a tail-recursive, the stack will overflow while the list is too long :) http://en.wikipedia.org/wiki/Tail_call 12ms, 7.11%, June.18th, 2016 https://leetcode.com/discuss/18986/14-line-clean-c-solution 14 line clean C++ Solution 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; ListNode dummy(INT_MIN); ListNode *tail = &amp;dummy; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; tail-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; tail-&gt;next = l2; l2 = l2-&gt;next; &#125; tail = tail-&gt;next; &#125; tail-&gt;next = l1 ? l1 : l2; return dummy.next; &#125;&#125;; https://discuss.leetcode.com/topic/4480/clean-simple-o-n-m-c-solution-without-dummy-head-and-recurtion Clean, simple O(n+m) C++ Solution, without dummy head and recurtion Please refer to the comments inline. 1234567891011121314151617181920212223242526ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(NULL == l1) return l2; if(NULL == l2) return l1; ListNode* head=NULL; // head of the list to return // find first element (can use dummy node to put this part inside of the loop) if(l1-&gt;val &lt; l2-&gt;val) &#123; head = l1; l1 = l1-&gt;next; &#125; else &#123; head = l2; l2 = l2-&gt;next; &#125; ListNode* p = head; // pointer to form new list // I use &amp;&amp; to remove extra IF from the loop while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val) &#123; p-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; p-&gt;next = l2; l2 = l2-&gt;next; &#125; p=p-&gt;next; &#125; // add the rest of the tail, done! if(l1) p-&gt;next=l1; else p-&gt;next=l2; return head;&#125; python https://leetcode.com/discuss/51679/python-solutions-iteratively-recursively-iteratively-place Python solutions (iteratively, recursively, iteratively in-place). 12345678910111213# iterativelydef mergeTwoLists1(self, l1, l2): dummy = cur = ListNode(0) while l1 and l2: if l1.val &lt; l2.val: cur.next = l1 l1 = l1.next else: cur.next = l2 l2 = l2.next cur = cur.next cur.next = l1 or l2 return dummy.next 12345678910# recursively def mergeTwoLists2(self, l1, l2): if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2 123456789101112131415161718# in-place, iteratively def mergeTwoLists(self, l1, l2): if None in (l1, l2): return l1 or l2 dummy = cur = ListNode(0) dummy.next = l1 while l1 and l2: if l1.val &lt; l2.val: l1 = l1.next else: nxt = cur.next cur.next = l2 tmp = l2.next l2.next = nxt l2 = tmp cur = cur.next cur.next = l1 or l2 return dummy.next java https://discuss.leetcode.com/topic/5513/my-recursive-way-to-solve-this-problem-java-easy-understanding My recursive way to solve this problem(JAVA, easy understanding) Hello every one, here is my code, simple but works well: 123456789101112131415161718192021public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null)&#123; return l2; &#125; if(l2 == null)&#123; return l1; &#125; ListNode mergeHead; if(l1.val &lt; l2.val)&#123; mergeHead = l1; mergeHead.next = mergeTwoLists(l1.next, l2); &#125; else&#123; mergeHead = l2; mergeHead.next = mergeTwoLists(l1, l2.next); &#125; return mergeHead; &#125;&#125; https://discuss.leetcode.com/topic/45002/java-1-ms-4-lines-codes-using-recursion Java, 1 ms, 4 lines codes, using recursion 1234567891011public ListNode mergeTwoLists(ListNode l1, ListNode l2)&#123; if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val)&#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else&#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; https://discuss.leetcode.com/topic/5199/java-solution-for-reference Java solution for reference Similar to array, the difference is if any of two listnode is not null after first loop, we only need to add it as previous node’s next and no need to add them one by one. 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null &amp;&amp; l2 == null) &#123; return null; &#125; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; ListNode result = new ListNode(0); ListNode prev = result; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; prev.next = l1; l1 = l1.next; &#125; else &#123; prev.next = l2; l2 = l2.next; &#125; prev = prev.next; &#125; if (l1 != null) &#123; prev.next = l1; &#125; if (l2 != null) &#123; prev.next = l2; &#125; return result.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[020. Valid Parentheses]]></title>
    <url>%2Fp%2F44690127%2F</url>
    <content type="text"><![CDATA[32.5% https://leetcode.com/problems/valid-parentheses/ Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. 方法一： 使用栈，依次进行考虑。 My 0ms c++ solution using stack code 1： 1234567891011121314bool isValid(string s) &#123; stack&lt;char&gt; st; for(char c : s)&#123; if(c == &apos;(&apos;|| c == &apos;&#123;&apos; || c == &apos;[&apos;)&#123; st.push(c); &#125;else&#123; if(st.empty()) return false; if(c == &apos;)&apos; &amp;&amp; st.top() != &apos;(&apos;) return false; if(c == &apos;&#125;&apos; &amp;&amp; st.top() != &apos;&#123;&apos;) return false; if(c == &apos;]&apos; &amp;&amp; st.top() != &apos;[&apos;) return false; st.pop(); &#125; &#125; return st.empty(); 方法二: 我的代码实现: 12345678910111213141516171819class Solution &#123;public: bool isValid(string s) &#123; if(s.empty()) return true; stack&lt;char&gt; stack; unordered_map&lt;char, char&gt; map = &#123;&#123;'(', ')'&#125;, &#123;'[', ']'&#125;, &#123;'&#123;', '&#125;'&#125;&#125;; for(auto c:s)&#123; if(map.find(c)!=map.end()) stack.push(map[c]); else&#123; if(!stack.empty() &amp;&amp; stack.top()==c) stack.pop(); else return false; &#125; &#125; return stack.empty(); &#125;&#125;; 重点学一下，进一个map，及map的赋值操作。 1234567891011121314151617181920212223class Solution &#123; public: bool isValid(string s) &#123; map&lt;char, char&gt; parenth_dict; parenth_dict[&apos;(&apos;] = &apos;)&apos;; parenth_dict[&apos;&#123;&apos;] = &apos;&#125;&apos;; parenth_dict[&apos;[&apos;] = &apos;]&apos;; stack&lt;char&gt; aux; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos;(&apos; || s[i] == &apos;&#123;&apos; || s[i] == &apos;[&apos;) aux.push(s[i]); else if (aux.empty() || parenth_dict[aux.top()] != s[i]) return false; else aux.pop(); &#125; return aux.empty(); &#125;&#125;; java https://discuss.leetcode.com/topic/7813/my-easy-to-understand-java-solution-with-one-stack My easy to understand Java Solution with one stack 12345678910111213141516171819202122public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); // Iterate through string until empty for(int i = 0; i&lt;s.length(); i++) &#123; // Push any open parentheses onto stack if(s.charAt(i) == &apos;(&apos; || s.charAt(i) == &apos;[&apos; || s.charAt(i) == &apos;&#123;&apos;) stack.push(s.charAt(i)); // Check stack for corresponding closing parentheses, false if not valid else if(s.charAt(i) == &apos;)&apos; &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == &apos;(&apos;) stack.pop(); else if(s.charAt(i) == &apos;]&apos; &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == &apos;[&apos;) stack.pop(); else if(s.charAt(i) == &apos;&#125;&apos; &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == &apos;&#123;&apos;) stack.pop(); else return false; &#125; // return true if no open parentheses left in stack return stack.empty(); &#125;&#125; https://discuss.leetcode.com/topic/27572/short-java-solution Short java solution1234567891011121314public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c : s.toCharArray()) &#123; if (c == &apos;(&apos;) stack.push(&apos;)&apos;); else if (c == &apos;&#123;&apos;) stack.push(&apos;&#125;&apos;); else if (c == &apos;[&apos;) stack.push(&apos;]&apos;); else if (stack.isEmpty() || stack.pop() != c) return false; &#125; return stack.isEmpty();&#125; https://discuss.leetcode.com/topic/9372/12-lines-of-java 12 lines of Java 123456789101112public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Integer&gt; p = new Stack&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++) &#123; int q = &quot;()&#123;&#125;[]&quot;.indexOf(s.substring(i, i + 1)); if(q % 2 == 1) &#123; if(p.isEmpty() || p.pop() != q - 1) return false; &#125; else p.push(q); &#125; return p.isEmpty(); &#125;&#125; https://discuss.leetcode.com/topic/27768/short-easy-to-follow-8ms-java-solution Short, Easy to Follow 8ms Java Solution 123456789101112public class Solution &#123; public boolean isValid(String s) &#123; int length; do &#123; length = s.length(); s = s.replace(&quot;()&quot;, &quot;&quot;).replace(&quot;&#123;&#125;&quot;, &quot;&quot;).replace(&quot;[]&quot;, &quot;&quot;); &#125; while(length != s.length()); return s.length() == 0; &#125;&#125; In this solution you essentially can remove parentheses that you know are valid until the string is empty. If the string is not empty, that means that the parentheses were malformed. https://discuss.leetcode.com/topic/47067/java-iterative-solution-beating-97 Java iterative solution beating 97% Just implement a simple stack using a char array and check that, for each closing bracket, there is its counterpart in the top of the stack. 1234567891011121314151617181920212223242526public class Solution &#123; public boolean isValid(String s) &#123; char[] stack = new char[s.length()]; int head = 0; for(char c : s.toCharArray()) &#123; switch(c) &#123; case &apos;&#123;&apos;: case &apos;[&apos;: case &apos;(&apos;: stack[head++] = c; break; case &apos;&#125;&apos;: if(head == 0 || stack[--head] != &apos;&#123;&apos;) return false; break; case &apos;)&apos;: if(head == 0 || stack[--head] != &apos;(&apos;) return false; break; case &apos;]&apos;: if(head == 0 || stack[--head] != &apos;[&apos;) return false; break; &#125; &#125; return head == 0; &#125;&#125; my code: 1234567891011121314151617181920212223public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); if(s==null || s.length()==0) return true; for(int i=0; i&lt;s.length(); i++)&#123; char tmp = s.charAt(i); if(!stack.empty() &amp;&amp; tmp==&apos;)&apos; &amp;&amp; stack.peek()==&apos;(&apos;) stack.pop(); else if(!stack.empty() &amp;&amp; tmp==&apos;]&apos; &amp;&amp; stack.peek()==&apos;[&apos;) stack.pop(); else if(!stack.empty() &amp;&amp; tmp==&apos;&#125;&apos; &amp;&amp; stack.peek()==&apos;&#123;&apos;) stack.pop(); else if(tmp==&apos;(&apos; || tmp==&apos;[&apos; || tmp==&apos;&#123;&apos;) stack.push(tmp); else return false; &#125; if(stack.empty()) return true; else return false; &#125;&#125; cpp https://discuss.leetcode.com/topic/13231/2ms-c-sloution 2ms C++ sloution Repetitive code but I guess this is clean, and easy to understand. This solution also accepts (and ignores) any characters other than parenthesis in the string. Hence, it can be used to check if the parenthesis matches in an equation for example. 1234567891011121314151617181920#include &lt;stack&gt;class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; paren; for (char&amp; c : s) &#123; switch (c) &#123; case &apos;(&apos;: case &apos;&#123;&apos;: case &apos;[&apos;: paren.push(c); break; case &apos;)&apos;: if (paren.empty() || paren.top()!=&apos;(&apos;) return false; else paren.pop(); break; case &apos;&#125;&apos;: if (paren.empty() || paren.top()!=&apos;&#123;&apos;) return false; else paren.pop(); break; case &apos;]&apos;: if (paren.empty() || paren.top()!=&apos;[&apos;) return false; else paren.pop(); break; default: ; // pass &#125; &#125; return paren.empty() ; &#125;&#125;; https://discuss.leetcode.com/topic/32413/my-0ms-c-solution-using-stack My 0ms c++ solution using stack 1234567891011121314bool isValid(string s) &#123; stack&lt;char&gt; st; for(char c : s)&#123; if(c == &apos;(&apos;|| c == &apos;&#123;&apos; || c == &apos;[&apos;)&#123; st.push(c); &#125;else&#123; if(st.empty()) return false; if(c == &apos;)&apos; &amp;&amp; st.top() != &apos;(&apos;) return false; if(c == &apos;&#125;&apos; &amp;&amp; st.top() != &apos;&#123;&apos;) return false; if(c == &apos;]&apos; &amp;&amp; st.top() != &apos;[&apos;) return false; st.pop(); &#125; &#125; return st.empty(); https://discuss.leetcode.com/topic/7188/sharing-my-simple-cpp-code-with-2ms Sharing my simple cpp code with 2ms 1234567891011121314151617181920212223class Solution &#123; public: bool isValid(string s) &#123; map&lt;char, char&gt; parenth_dict; parenth_dict[&apos;(&apos;] = &apos;)&apos;; parenth_dict[&apos;&#123;&apos;] = &apos;&#125;&apos;; parenth_dict[&apos;[&apos;] = &apos;]&apos;; stack&lt;char&gt; aux; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos;(&apos; || s[i] == &apos;&#123;&apos; || s[i] == &apos;[&apos;) aux.push(s[i]); else if (aux.empty() || parenth_dict[aux.top()] != s[i]) return false; else aux.pop(); &#125; return aux.empty(); &#125;&#125;; python https://discuss.leetcode.com/topic/6534/simple-python-solution-with-stack Simple Python solution with stack 1234567891011121314class Solution: # @return a boolean def isValid(self, s): stack = [] dict = &#123;&quot;]&quot;:&quot;[&quot;, &quot;&#125;&quot;:&quot;&#123;&quot;, &quot;)&quot;:&quot;(&quot;&#125; for char in s: if char in dict.values(): stack.append(char) elif char in dict.keys(): if stack == [] or dict[char] != stack.pop(): return False else: return False return stack == [] https://discuss.leetcode.com/topic/40897/python-is-this-a-cheating-method-accepted-with-40ms-easy-to-understand-but [Python] is this a cheating method? accepted with 40ms, easy to understand, but 1234567891011121314151617181920class Solution(object): def isValid(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; n = len(s) if n == 0: return True if n % 2 != 0: return False while &apos;()&apos; in s or &apos;&#123;&#125;&apos; in s or &apos;[]&apos; in s: s = s.replace(&apos;&#123;&#125;&apos;,&apos;&apos;).replace(&apos;()&apos;,&apos;&apos;).replace(&apos;[]&apos;,&apos;&apos;) if s == &apos;&apos;: return True else: return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[019. Remove Nth Node From End of List]]></title>
    <url>%2Fp%2F72420d7f%2F</url>
    <content type="text"><![CDATA[33.6% https://leetcode.com/problems/remove-nth-node-from-end-of-list/ Given a linked list, remove the nth node from the end of list and return its head. 12345For example,Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Try to do this in one pass. 类似于剑指offer 15 方法一： 4ms, 37.53%, September 3, 2016 https://discuss.leetcode.com/topic/5397/my-short-c-solution My short C++ solution 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode** t1 = &amp;head, *t2 = head; for(int i=1; i&lt;n; ++i) t2 = t2-&gt;next; while(t2-&gt;next != NULL)&#123; t1 = &amp;((*t1)-&gt;next); t2 = t2 -&gt; next; &#125; *t1 = (*t1)-&gt;next; return head; &#125;&#125;; 方法二： 我的代码实现： 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; // 链表经常在头部设置一个哑变量， 针对一些特殊情况，非常有效 ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* fast = dummy, *slow = dummy; while(n&gt;0)&#123; fast = fast-&gt;next; n--; &#125; while(fast-&gt;next)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return dummy-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/7753/c-solution-easy-to-understand-with-explanations C++ solution, easy to understand with explanations. Renewed SolutionThe difference between the final node and the to_be_delete node is N. And here the assumption is that n is always valid. fast pointer points to the node which is N step away from the to_be_delete node. slow pointer points to the to_be_delete node. The algorithms is described as below: Firstly, move fast pointer N step forward. Secondly,move fast and slow pointers simultaneously one step a time forward till the fast pointer reach the end, which will cause the slow pointer points to the previous node of the to_be_delete node. Finally, slow-&gt;next = slow-&gt;next-&gt;next. 1234567891011121314151617181920212223242526ListNode *removeNthFromEnd(ListNode *head, int n) &#123; if (!head) return nullptr; ListNode new_head(-1); new_head.next = head; ListNode *slow = &amp;new_head, *fast = &amp;new_head; for (int i = 0; i &lt; n; i++) fast = fast-&gt;next; while (fast-&gt;next) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; ListNode *to_de_deleted = slow-&gt;next; slow-&gt;next = slow-&gt;next-&gt;next; delete to_be_deleted; return new_head.next;&#125; Fixed : Added code for deleting the N-th node. java 1ms, 5.49%, September 3, 2016 https://discuss.leetcode.com/topic/7031/simple-java-solution-in-one-pass Simple Java solution in one pass A one pass solution can be done using pointers. Move one pointer fast –&gt; n+1 places forward, to maintain a gap of n between the two pointers and then move both at the same speed. Finally, when the fast pointer reaches the end, the slow pointer will be n+1 places behind - just the right spot for it to be able to skip the next node. Since the question gives that n is valid, not too many checks have to be put in place. Otherwise, this would be necessary. 12345678910111213141516171819public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode start = new ListNode(0); ListNode slow = start, fast = start; slow.next = head; //Move fast in front so that the gap between slow and fast becomes n for(int i=1; i&lt;=n+1; i++) &#123; fast = fast.next; &#125; //Move fast to the end, maintaining the gap while(fast != null) &#123; slow = slow.next; fast = fast.next; &#125; //Skip the desired node slow.next = slow.next.next; return start.next;&#125; 1ms, 5.49%, September 3, 2016 https://discuss.leetcode.com/topic/20745/my-one-pass-solution My one pass solution 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode h1 = head, h2=head; while(n--&gt;0) h2 = h2.next; if(h2==null) return head.next; h2=h2.next; while(h2!=null)&#123; h1 = h1.next; h2 = h2.next; &#125; h1.next = h1.next.next; return head; &#125;&#125; https://discuss.leetcode.com/topic/42339/java-solution-1ms-%E5%AE%B9%E6%98%93%E7%90%86%E8%A7%A3 Java solution 1ms 容易理解 12345678910111213141516//还是走的快的点(fastNode)与走得慢的点(slowNode)路程差的问题 public static ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode headNode = new ListNode(9527); headNode.next = head; ListNode fastNode = headNode; ListNode slowNode = headNode; while(fastNode.next != null)&#123; if(n &lt;= 0) slowNode = slowNode.next; fastNode = fastNode.next; n--; &#125; if(slowNode.next != null) slowNode.next = slowNode.next.next; return headNode.next; &#125; https://discuss.leetcode.com/topic/12125/my-simple-java-solution-in-one-pass My simple Java solution in one pass 123456789101112131415public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy=new ListNode(0); dummy.next=head; ListNode fast=dummy; ListNode slow=dummy; int temp=n; for(;fast.next!=null;temp--)&#123; if(temp&lt;=0)&#123; //control slow=slow.next; &#125; fast=fast.next; &#125; slow.next=slow.next.next;//delete Nth return dummy.next;&#125; python 39ms, 100.00%, September 3, 2016 https://discuss.leetcode.com/topic/14692/3-short-python-solutions Value-Shifting - AC in 64 ms My first solution is “cheating” a little. Instead of really removing the nth node, I remove the nth value. I recursively determine the indexes (counting from back), then shift the values for all indexes larger than n, and then always drop the head. 1234567891011class Solution: def removeNthFromEnd(self, head, n): def index(node): if not node: return 0 i = index(node.next) + 1 if i &gt; n: node.next.val = node.val return i index(head) return head.next Index and Remove - AC in 56 ms In this solution I recursively determine the indexes again, but this time my helper function removes the nth node. It returns two values. The index, as in my first solution, and the possibly changed head of the remaining list. 12345678class Solution: def removeNthFromEnd(self, head, n): def remove(head): if not head: return 0, head i, head.next = remove(head.next) return i+1, (head, head.next)[i+1 == n] return remove(head)[1] n ahead - AC in 48 ms The standard solution, but without a dummy extra node. Instead, I simply handle the special case of removing the head right after the fast cursor got its head start. 123456789101112class Solution: def removeNthFromEnd(self, head, n): fast = slow = head for _ in range(n): fast = fast.next if not fast: return head.next while fast.next: fast = fast.next slow = slow.next slow.next = slow.next.next return head]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[018. 4Sum]]></title>
    <url>%2Fp%2F964c48a1%2F</url>
    <content type="text"><![CDATA[25.9% https://leetcode.com/problems/4sum/ Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 12345678For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 方法一： 我的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); if(n&lt;4) return res; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-3; i++)&#123; if(i!=0 &amp;&amp; nums[i]==nums[i-1]) continue; if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target) break; // 此处为break； if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]&lt;target) continue; // 此处为continue; 注意区分 for(int j=i+1; j&lt;n-2; j++)&#123; if(j!=i+1 &amp;&amp; nums[j]==nums[j-1]) continue; if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; int k=j+1, l=n-1; while(k&lt;l)&#123; int sum = nums[i]+nums[j]+nums[k]+nums[l]; if(sum==target)&#123; res.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[k], nums[l]&#125;); while(k&lt;l &amp;&amp; nums[k+1]==nums[k]) k++; while(k&lt;l &amp;&amp; nums[l-1]==nums[l]) l--; k++; l--; &#125;else if(sum&gt;target) l--; else k++; &#125; &#125; &#125; return res; &#125;&#125;; 16ms, 91.80%, April.23rd, 2016 https://leetcode.com/discuss/87769/implementation-carefully-pruning-accelerates-from-100ms First thanks to the post from @cx1992 I will just say that with out the 2 using of the 123if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; The runing time without these two lines cost 100ms. But with these lines, cost 16ms ! Here is the final implementation 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; result; int n=nums.size(); if(n&lt;4) return result; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-3; i++)&#123; if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) continue; /** cut edge to accelerate the speed **/ if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target) break; // 此处加break if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]&lt;target) continue; for(int j=i+1; j&lt;n-2; j++)&#123; if(j&gt;i+1 &amp;&amp; nums[j]==nums[j-1]) continue; /** cut edge to accelerate the speed **/ if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; /** jia bi process **/ int start=j+1, end=n-1; while(start &lt; end)&#123; int sum=nums[start]+nums[end]+nums[i]+nums[j]; if(sum&lt;target) start++; else if(sum&gt;target) end--; else&#123; result.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[start], nums[end]&#125;); start++; end--; while(nums[start-1]==nums[start] &amp;&amp; start&lt;end) start++; while(nums[end+1]==nums[end] &amp;&amp; start&lt;end) end--; &#125; &#125; &#125; &#125; return result; &#125;&#125;; 另一种代码实现： https://discuss.leetcode.com/topic/28641/my-16ms-c-code My 16ms c++ code 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; total; int n = nums.size(); if(n&lt;4) return total; sort(nums.begin(),nums.end()); for(int i=0;i&lt;n-3;i++) &#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue; if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target) break; if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]&lt;target) continue; for(int j=i+1;j&lt;n-2;j++) &#123; if(j&gt;i+1&amp;&amp;nums[j]==nums[j-1]) continue; if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; int left=j+1,right=n-1; while(left&lt;right)&#123; int sum=nums[left]+nums[right]+nums[i]+nums[j]; if(sum&lt;target) left++; else if(sum&gt;target) right--; else&#123; total.push_back(vector&lt;int&gt;&#123;nums[i],nums[j],nums[left],nums[right]&#125;); do&#123;left++;&#125;while(nums[left]==nums[left-1]&amp;&amp;left&lt;right); do&#123;right--;&#125;while(nums[right]==nums[right+1]&amp;&amp;left&lt;right); &#125; &#125; &#125; &#125; return total; &#125;&#125;; 方法二： 100ms, 45.73%, Apr.23rd, 2016 http://c4fun.cn/blog/2014/03/20/leetcode-solution-02/ 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt; &gt; ans; sort(num.begin(), num.end()); for (int i = 0; i &lt; num.size(); i++) &#123; if (i &gt; 0 &amp;&amp; num[i] == num[i-1]) continue; for (int j = i + 1; j &lt; num.size(); j++) &#123; if (j &gt; i + 1 &amp;&amp; num[j] == num[j - 1]) continue; int l = j + 1, r = num.size() - 1; while (l &lt; r) &#123; int sum = num[i] + num[j] + num[l] + num[r]; if (sum == target) &#123; ans.push_back(&#123;num[i], num[j], num[l], num[r]&#125;); while (l &lt; r &amp;&amp; num[l] == num[l + 1]) l++; l++; while (l &lt; r &amp;&amp; num[r] == num[r - 1]) r--; r--; &#125; else if (sum &lt; target) &#123; l++; &#125; else &#123; r--; &#125; &#125; &#125; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/27445/lower-bound-n-3 Lower bound n^3 Some people say their solutions are O(n2 log n) or even O(n2), but… Consider cases where nums is the n numbers from 1 to n. =&gt; There are Θ(n4) different quadruplets (nC4, to be exact, so about n4 / 24). =&gt; There are Θ(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums). =&gt; At least one sum must have Ω(n3) different quadruplets. =&gt; For that sum, we must generate those Ω(n3) quadruplets. =&gt; For these cases we have to do Ω(n3) work. =&gt; O(n2 log n) or even O(n2) are impossible. (I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.) cpp https://discuss.leetcode.com/topic/3752/my-c-solution-using-hashtable My C++ solution using hashtable My idea is to sort num first, then build a hashtable with the key as the sum of the pair and the value as a vector storing all pairs of index of num that having the same sum. In this way, all elements stored in hashtable has a order that duplicate pairs are neighbors. Therefore scanning the vector in the hashtable we only put non duplicate elements into the final answer vvi. Is this method O(n^2) ? or Does anyone can improve it to O(n^2); 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution&#123; //using hashtable, avg O(n^2)public: vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target)&#123; vector&lt;vector&lt;int&gt; &gt; vvi; int n = num.size(); if(n &lt; 4) return vvi; sort(num.begin(), num.end()); unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt; &gt; mp; for(int i = 0; i &lt; n; i++)&#123; for(int j = i + 1; j &lt; n; j++)&#123; mp[num[i]+num[j]].push_back(make_pair(i,j)); &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; if(i&gt;0 &amp;&amp; num[i] == num[i-1]) continue; for(int j = i + 1; j &lt; n; j++)&#123; if(j &gt; i + 1 &amp;&amp; num[j] == num[j-1]) continue; int res = target - num[i] - num[j]; if(mp.count(res))&#123; for(auto it = mp[res].begin(); it != mp[res].end(); it++)&#123; int k = (*it).first, l = (*it).second; if(k &gt; j)&#123; // k&gt;j make sure that the second pair has bigger values than the first pair. if(!vvi.empty() &amp;&amp; num[i]==vvi.back()[0] &amp;&amp; num[j]==vvi.back()[1] &amp;&amp; num[k]==vvi.back()[2] &amp;&amp; num[l] == vvi.back()[3])&#123; continue; //if the obtained 4 elements are the same as previous one continue to next &#125; vector&lt;int&gt; vi=&#123;num[i], num[j], num[k], num[l]&#125;; vvi.push_back(vi); &#125; // if k&gt;j &#125;//for it &#125;//if &#125;// forj &#125;//for i return vvi; &#125; &#125;; python https://discuss.leetcode.com/topic/10995/share-my-python-code-run-time-200-20ms Share my python code, run time 200+- 20ms 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution: # @return a list of lists of length 4, [[val1,val2,val3,val4]] def fourSum(self, num, target): num.sort() result = [] for i in xrange(len(num)-3): if num[i] &gt; target/4.0: break if i &gt; 0 and num[i] == num[i-1]: continue target2 = target - num[i] for j in xrange(i+1, len(num)-2): if num[j] &gt; target2/3.0: break if j &gt; i+1 and num[j] == num[j-1]: continue k = j + 1 l = len(num) - 1 target3 = target2 - num[j] # we should use continue not break # because target3 changes as j changes if num[k] &gt; target3/2.0: continue if num[l] &lt; target3/2.0: continue while k &lt; l: sum_value = num[k] + num[l] if sum_value == target3: result.append([num[i], num[j], num[k], num[l]]) kk = num[k] k += 1 while k&lt;l and num[k] == kk: k += 1 ll = num[l] l -= 1 while k&lt;l and num[l] == ll: l -= 1 elif sum_value &lt; target3: k += 1 else: l -= 1 return result We can reduce run time by adding some restrictions. https://discuss.leetcode.com/topic/9078/twosum-twosum-foursum-a-simple-python-solution TwoSum+twoSum == fourSum, a simple python solution 12345678910111213141516class Solution:# @return a list of lists of length 4, [[val1,val2,val3,val4]]def fourSum(self, num, target): two_sum = collections.defaultdict(list) res = set() for (n1, i1), (n2, i2) in itertools.combinations(enumerate(num), 2): two_sum[i1+i2].append(&#123;n1, n2&#125;) for t in list(two_sum.keys()): if not two_sum[target-t]: continue for pair1 in two_sum[t]: for pair2 in two_sum[target-t]: if pair1.isdisjoint(pair2): res.add(tuple(sorted(num[i] for i in pair1 | pair2))) del two_sum[t] return [list(r) for r in res] https://discuss.leetcode.com/topic/10556/a-conise-python-solution-based-on-ksum A conise python solution based on ksum 12345678910111213141516171819202122232425262728class Solution: # @return a list of lists of length 4, [[val1,val2,val3,val4]] def fourSum(self, num, target): num.sort() def ksum(num, k, target): i = 0 result = set() if k == 2: j = len(num) - 1 while i &lt; j: if num[i] + num[j] == target: result.add((num[i], num[j])) i += 1 elif num[i] + num[j] &gt; target: j -= 1 else: i += 1 else: while i &lt; len(num) - k + 1: newtarget = target - num[i] subresult = ksum(num[i+1:], k - 1, newtarget) if subresult: result = result | set( (num[i],) + nr for nr in subresult) i += 1 return result return [list(t) for t in ksum(num, 4, target)] 148ms, 86.46%, April.23rd, 2016 https://leetcode.com/discuss/83152/python-beats-86-07%25-may-be-better python beats 86.07% may be better make sure nums[i]!=nums[i+1] to avoid duplication and unnecessary computations and whennums[i]*4 &gt; target,It’ll be impossible to get another answer. and when nums[j]*4 &lt; target,It should turn to next loop maybe in some situations:usenums[i]+nums[i+1]+nums[i+2]+nums[i+3]wil be better.I am just for convenience.. 1234567891011121314151617181920212223242526class Solution(object): def fourSum(self, nums, target): res, n, nums, limit = [], len(nums), sorted(nums), target &gt;&gt; 2 for i in xrange(n-3): if nums[i] &gt; limit: #limit 1 break if i != 0 and nums[i] == nums[i-1]: #remove duplicate continue for j in xrange(n-1,i+2,-1): #Reverse traversal if nums[j] &lt; limit: #limit 2 break if j != n -1 and nums[j] == nums[j+1]: #remove duplicate continue lo, hi, sum2 = i + 1, j - 1, nums[i] + nums[j] limit2 = (target - sum2) &gt;&gt; 1 while lo &lt; hi and nums[lo] &lt;= limit2 and nums[hi] &gt;= limit2: #limit 3 sum = sum2 + nums[lo] + nums[hi] if sum == target: res += (nums[i], nums[lo], nums[hi], nums[j]), while lo &lt; hi and nums[hi] == nums[hi-1]: #remove duplicate hi -= 1 while lo &lt; hi and nums[lo] == nums[lo+1]: #remove duplicate lo += 1 lo += sum &lt;= target hi -= sum &gt;= target return res https://discuss.leetcode.com/topic/22705/python-140ms-beats-100-and-works-for-n-sum-n-2 Python 140ms beats 100%, and works for N-sum (N&gt;=2) The core is to implement a fast 2-pointer to solve 2-sum, and recursion to reduce the N-sum to 2-sum. Some optimization was be made knowing the list is sorted. 1234567891011121314151617181920212223242526272829303132def fourSum(self, nums, target): nums.sort() results = [] self.findNsum(nums, target, 4, [], results) return resultsdef findNsum(self, nums, target, N, result, results): if len(nums) &lt; N or N &lt; 2: return # solve 2-sum if N == 2: l,r = 0,len(nums)-1 while l &lt; r: if nums[l] + nums[r] == target: results.append(result + [nums[l], nums[r]]) l += 1 r -= 1 while l &lt; r and nums[l] == nums[l - 1]: l += 1 while r &gt; l and nums[r] == nums[r + 1]: r -= 1 elif nums[l] + nums[r] &lt; target: l += 1 else: r -= 1 else: for i in range(0, len(nums)-N+1): # careful about range if target &lt; nums[i]*N or target &gt; nums[-1]*N: # take advantages of sorted list break if i == 0 or i &gt; 0 and nums[i-1] != nums[i]: # recursively reduce N self.findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results) return Just revisited and clean the code 12345678910111213141516171819202122232425def fourSum(self, nums, target): def findNsum(nums, target, N, result, results): if len(nums) &lt; N or N &lt; 2 or target &lt; nums[0]*N or target &gt; nums[-1]*N: # early termination return if N == 2: # two pointers solve sorted 2-sum problem l,r = 0,len(nums)-1 while l &lt; r: s = nums[l] + nums[r] if s == target: results.append(result + [nums[l], nums[r]]) l += 1 while l &lt; r and nums[l] == nums[l-1]: l += 1 elif s &lt; target: l += 1 else: r -= 1 else: # recursively reduce N for i in range(len(nums)-N+1): if i == 0 or (i &gt; 0 and nums[i-1] != nums[i]): findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results) results = [] findNsum(sorted(nums), target, 4, [], results) return results java https://discuss.leetcode.com/topic/29585/7ms-java-code-win-over-100 26ms, 97.32% 7ms java code win over 100% The first time win over 100%. Basic idea is using subfunctions for 3sum and 2sum, and keeping throwing all impossible cases. O(n^3) time complexity, O(1) extra space complexity.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); int len = nums.length; if (nums == null || len &lt; 4) return res; Arrays.sort(nums); int max = nums[len - 1]; if (4 * nums[0] &gt; target || 4 * max &lt; target) return res; int i, z; for (i = 0; i &lt; len; i++) &#123; z = nums[i]; if (i &gt; 0 &amp;&amp; z == nums[i - 1])// avoid duplicate continue; if (z + 3 * max &lt; target) // z is too small continue; if (4 * z &gt; target) // z is too large break; if (4 * z == target) &#123; // z is the boundary if (i + 3 &lt; len &amp;&amp; nums[i + 3] == z) res.add(Arrays.asList(z, z, z, z)); break; &#125; threeSumForFourSum(nums, target - z, i + 1, len - 1, res, z); &#125; return res; &#125; /* * Find all possible distinguished three numbers adding up to the target * in sorted array nums[] between indices low and high. If there are, * add all of them into the ArrayList fourSumList, using * fourSumList.add(Arrays.asList(z1, the three numbers)) */ public void threeSumForFourSum(int[] nums, int target, int low, int high, ArrayList&lt;List&lt;Integer&gt;&gt; fourSumList, int z1) &#123; if (low + 1 &gt;= high) return; int max = nums[high]; if (3 * nums[low] &gt; target || 3 * max &lt; target) return; int i, z; for (i = low; i &lt; high - 1; i++) &#123; z = nums[i]; if (i &gt; low &amp;&amp; z == nums[i - 1]) // avoid duplicate continue; if (z + 2 * max &lt; target) // z is too small continue; if (3 * z &gt; target) // z is too large break; if (3 * z == target) &#123; // z is the boundary if (i + 1 &lt; high &amp;&amp; nums[i + 2] == z) fourSumList.add(Arrays.asList(z1, z, z, z)); break; &#125; twoSumForFourSum(nums, target - z, i + 1, high, fourSumList, z1, z); &#125; &#125; /* * Find all possible distinguished two numbers adding up to the target * in sorted array nums[] between indices low and high. If there are, * add all of them into the ArrayList fourSumList, using * fourSumList.add(Arrays.asList(z1, z2, the two numbers)) */ public void twoSumForFourSum(int[] nums, int target, int low, int high, ArrayList&lt;List&lt;Integer&gt;&gt; fourSumList, int z1, int z2) &#123; if (low &gt;= high) return; if (2 * nums[low] &gt; target || 2 * nums[high] &lt; target) return; int i = low, j = high, sum, x; while (i &lt; j) &#123; sum = nums[i] + nums[j]; if (sum == target) &#123; fourSumList.add(Arrays.asList(z1, z2, nums[i], nums[j])); x = nums[i]; while (++i &lt; j &amp;&amp; x == nums[i]) // avoid duplicate ; x = nums[j]; while (i &lt; --j &amp;&amp; x == nums[j]) // avoid duplicate ; &#125; if (sum &lt; target) i++; if (sum &gt; target) j--; &#125; return; &#125;&#125; https://discuss.leetcode.com/topic/12368/clean-accepted-java-o-n-3-solution-based-on-3sum Clean accepted java O(n^3) solution based on 3sum 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] num, int target) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if(num.length&lt;4)return ans; Arrays.sort(num); for(int i=0; i&lt;num.length-3; i++)&#123; if(i&gt;0&amp;&amp;num[i]==num[i-1])continue; for(int j=i+1; j&lt;num.length-2; j++)&#123; if(j&gt;i+1&amp;&amp;num[j]==num[j-1])continue; int low=j+1, high=num.length-1; while(low&lt;high)&#123; int sum=num[i]+num[j]+num[low]+num[high]; if(sum==target)&#123; ans.add(Arrays.asList(num[i], num[j], num[low], num[high])); while(low&lt;high&amp;&amp;num[low]==num[low+1])low++; while(low&lt;high&amp;&amp;num[high]==num[high-1])high--; low++; high--; &#125; else if(sum&lt;target)low++; else high--; &#125; &#125; &#125; return ans; &#125;&#125; https://discuss.leetcode.com/topic/12893/on-average-o-n-2-and-worst-case-o-n-3-java-solution-by-reducing-4sum-to-2sum On average O(n^2) and worst case O(n^3) java solution by reducing 4Sum to 2Sum Basic idea is to reduce the 4Sum problem to 2Sum one. In order to achieve that, we can use an array (size of n^2) to store the pair sums and this array will act as the array in 2Sum case (Here n is the size of the original 1D array and it turned out that we do not even need to explicitly use the n^2 sized array ). We also use a hashmap to mark if a pair sum has been visited or not (the same as in the 2Sum case). The tricky part here is that we may have multiple pairs that result in the same pair sum. So we will use a list to group these pairs together. For every pair with a particular sum, check if the pair sum that is needed to get the target has been visited. If so, further check if there is overlapping between these two pairs. If not, record the result. Time complexity to get all the pairs is O(n^2). For each pair, if the pair sum needed to get the target has been visited, the time complexity will be O(k), where k is the maximum size of the lists holding pairs with visited pair sum. Therefore the total time complexity will be O(k*n^2). Now we need to determine the range of k. Basically the more distinct pair sums we get, the smaller k will be. If all the pair sums are different from each other, k will just be 1. However, if we have many repeated elements in the original 1D array, or in some extreme cases such as the elements form an arithmetic progression, k can be of the order of n (strictly speaking, for the repeated elements case, k can go as high as n^2, but we can get rid of many of them). On average k will be some constant between 1 and n for normal elements distribution in the original 1D array. So on average our algorithm will go in O(n^2) but with worst case of O(n^3). Here is the complete code in java: 1234567891011121314151617181920212223242526272829303132333435363738394041public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] num, int target) &#123; Arrays.sort(num); Map&lt;Integer, List&lt;int[]&gt;&gt; twoSumMap = new HashMap&lt;&gt;(); // for holding visited pair sums. All pairs with the same pair sum are grouped together Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;(); // for holding the results for (int i = 0; i &lt; num.length; i++) &#123; // get rid of repeated pair sums if (i &gt; 1 &amp;&amp; num[i] == num[i - 2]) continue; for (int j = i + 1; j &lt; num.length; j++) &#123; // get rid of repeated pair sums if (j &gt; i + 2 &amp;&amp; num[j] == num[j - 2]) continue; // for each pair sum, check if the pair sum that is needed to get the target has been visited. if (twoSumMap.containsKey(target - (num[i] + num[j]))) &#123; // if so, get all the pairs that contribute to this visited pair sum. List&lt;int[]&gt; ls = twoSumMap.get(target - (num[i] + num[j])); for (int[] pair : ls) &#123; // we have two pairs: one is indicated as (pair[0], pair[1]), the other is (i, j). // we first need to check if they are overlapping with each other. int m1 = Math.min(pair[0], i); // m1 will always be the smallest index int m2 = Math.min(pair[1], j); // m2 will be one of the middle two indices int m3 = Math.max(pair[0], i); // m3 will be one of the middle two indices int m4 = Math.max(pair[1], j); // m4 will always be the largest index if (m1 == m3 || m1 == m4 || m2 == m3 || m2 == m4) continue; // two pairs are overlapping, so just ignore this case res.add(Arrays.asList(num[m1], num[Math.min(m2, m3)], num[Math.max(m2, m3)], num[m4])); // else record the result &#125; &#125; // mark that we have visited current pair and add it to the corrsponding pair sum group. // here we&apos;ve encoded the pair indices i and j into an integer array of length 2. twoSumMap.computeIfAbsent(num[i] + num[j], key -&gt; new ArrayList&lt;&gt;()).add(new int[] &#123;i, j&#125;); &#125; &#125; return new ArrayList&lt;List&lt;Integer&gt;&gt;(res);&#125; https://discuss.leetcode.com/topic/46339/my-solution-generalized-for-ksums-in-java My solution generalized for kSums in JAVA General Idea If you have already read and implement the 3sum and 4sum by using the sorting approach: reduce them into 2sum at the end, you might already got the feeling that, all ksum problem can be divided into two problems: 2sum Problem Reduce K sum problem to K – 1 sum Problem Therefore, the ideas is simple and straightforward. We could use recursive to solve this problem. Time complexity is O(N^(K-1)). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; int len = 0; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; len = nums.length; Arrays.sort(nums); return kSum(nums, target, 4, 0); &#125; private ArrayList&lt;List&lt;Integer&gt;&gt; kSum(int[] nums, int target, int k, int index) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(index &gt;= len) &#123; return res; &#125; if(k == 2) &#123; int i = index, j = len - 1; while(i &lt; j) &#123; //find a pair if(target - nums[i] == nums[j]) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); temp.add(nums[i]); temp.add(target-nums[i]); res.add(temp); //skip duplication while(i&lt;j &amp;&amp; nums[i]==nums[i+1]) i++; while(i&lt;j &amp;&amp; nums[j-1]==nums[j]) j--; i++; j--; //move left bound &#125; else if (target - nums[i] &gt; nums[j]) &#123; i++; //move right bound &#125; else &#123; j--; &#125; &#125; &#125; else&#123; for (int i = index; i &lt; len - k + 1; i++) &#123; //use current number to reduce ksum into k-1sum ArrayList&lt;List&lt;Integer&gt;&gt; temp = kSum(nums, target - nums[i], k-1, i+1); if(temp != null)&#123; //add previous results for (List&lt;Integer&gt; t : temp) &#123; t.add(0, nums[i]); &#125; res.addAll(temp); &#125; while (i &lt; len-1 &amp;&amp; nums[i] == nums[i+1]) &#123; //skip duplicated numbers i++; &#125; &#125; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/33433/java-a-little-bit-faster-than-other-common-methods-9ms-beats-95 Java a little bit faster than other common methods (9ms, beats 95%) To avoid duplicate list items, I skip unnecessary indices at two locations: one at the end of the outer loop (i-loop) the other at the end of the inner loop (j-loop). To avoid useless computations, the following is kind of critical: the function return immediately when nums[i]*4 &gt; target the inner loop break immediately when nums[j]*4 &lt; target. These two lines save quite some time due to the set up of the test cases in OJ. 12345678910111213141516171819202122232425262728public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(nums); int second = 0, third = 0, nexti = 0, nextj = 0; for(int i=0, L=nums.length; i&lt;L-3; i++) &#123; if(nums[i]&lt;&lt;2 &gt; target) return list; // return immediately for(int j=L-1; j&gt;i+2; j--) &#123; if(nums[j]&lt;&lt;2 &lt; target) break; // break immediately int rem = target-nums[i]-nums[j]; int lo = i+1, hi=j-1; while(lo&lt;hi) &#123; int sum = nums[lo] + nums[hi]; if(sum&gt;rem) --hi; else if(sum&lt;rem) ++lo; else &#123; list.add(Arrays.asList(nums[i],nums[lo],nums[hi],nums[j])); while(++lo&lt;=hi &amp;&amp; nums[lo-1]==nums[lo]) continue; // avoid duplicate results while(--hi&gt;=lo &amp;&amp; nums[hi]==nums[hi+1]) continue; // avoid duplicate results &#125; &#125; while(j&gt;=1 &amp;&amp; nums[j]==nums[j-1]) --j; // skip inner loop &#125; while(i&lt;L-1 &amp;&amp; nums[i]==nums[i+1]) ++i; // skip outer loop &#125; return list; &#125;&#125; https://discuss.leetcode.com/topic/9712/4sum-c-solution-with-explanation-and-comparison-with-3sum-problem-easy-to-understand For the reference, please have a look at my explanation of 3Sum problem because the algorithm are exactly the same. The link is as blow. My 3Sum problem answer The key idea is to downgrade the problem to a 2Sum problem eventually. And the same algorithm can be expand to NSum problem. After you had a look at my explanation of 3Sum, the code below will be extremely easy to understand. 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] num, int target) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if(num.length&lt;4)return ans; Arrays.sort(num); for(int i=0; i&lt;num.length-3; i++)&#123; if(i&gt;0&amp;&amp;num[i]==num[i-1])continue; for(int j=i+1; j&lt;num.length-2; j++)&#123; if(j&gt;i+1&amp;&amp;num[j]==num[j-1])continue; int low=j+1, high=num.length-1; while(low&lt;high)&#123; int sum=num[i]+num[j]+num[low]+num[high]; if(sum==target)&#123; ans.add(Arrays.asList(num[i], num[j], num[low], num[high])); while(low&lt;high&amp;&amp;num[low]==num[low+1])low++; while(low&lt;high&amp;&amp;num[high]==num[high-1])high--; low++; high--; &#125; else if(sum&lt;target)low++; else high--; &#125; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[017. Letter Combinations of a Phone Number]]></title>
    <url>%2Fp%2F9a201804%2F</url>
    <content type="text"><![CDATA[34.7% https://leetcode.com/problems/letter-combinations-of-a-phone-number/ Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. 12Input:Digit string &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 方法一： 迭代的方法 My iterative sollution, very simple under 15 lines This is my solution, FYI 针对新来的一个数字，比如2=“abc”，从原有的res中的所有string都取出来，针对每一个都加一个a或b或c，再放入新的vector中，再把新的赋值给res。 12345678910111213141516171819class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.size()==0) return res; string charmap[10] = &#123;&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; res.push_back(&quot;&quot;); for (int i = 0; i &lt; digits.size(); i++) &#123; vector&lt;string&gt; tempres; string chars = charmap[digits[i] - &apos;0&apos;]; for (int c = 0; c &lt; chars.size();c++) for (int j = 0; j &lt; res.size();j++) tempres.push_back(res[j]+chars[c]); res = tempres; &#125; return res; &#125;&#125;; 我的代码实现: 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.empty()) return res; // string用双引号 单双引号要仔细考虑 unordered_map&lt;char, string&gt;map = &#123;&#123;'1', ""&#125;, &#123;'2', "abc"&#125;, &#123;'3', "def"&#125;, &#123;'4', "ghi"&#125;, &#123;'5', "jkl"&#125;, &#123;'6', "mno"&#125;, &#123;'7', "pqrs"&#125;, &#123;'8', "tuv"&#125;, &#123;'9', "wxyz"&#125;&#125;; string s = ""; dfs(digits, 0, s, res, map); return res; &#125; void dfs(string&amp; digits, int k, string&amp; s, vector&lt;string&gt;&amp; res, unordered_map&lt;char, string&gt;&amp; map)&#123; if(k==digits.size())&#123; res.push_back(s); return; &#125; for(auto c:map[digits[k]])&#123; // string 的push_back，pop_back方法 s.push_back(c); dfs(digits, k+1, s, res, map); s.pop_back(); &#125; &#125;&#125;; java https://discuss.leetcode.com/topic/8125/concise-o-n-2-java-solution Concise O(N^2) Java solution Hi guys! The idea is to sort an input array and then run through all indices of a possible first element of a triplet. For each possible first element we make a standard bi-directional 2Sum sweep of the remaining part of the array. Also we want to skip equal elements to avoid duplicates in the answer without making a set or smth like that. 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) &#123; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; num.length-2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; num[i] != num[i-1])) &#123; int lo = i+1, hi = num.length-1, sum = 0 - num[i]; while (lo &lt; hi) &#123; if (num[lo] + num[hi] == sum) &#123; res.add(Arrays.asList(num[i], num[lo], num[hi])); while (lo &lt; hi &amp;&amp; num[lo] == num[lo+1]) lo++; while (lo &lt; hi &amp;&amp; num[hi] == num[hi-1]) hi--; lo++; hi--; &#125; else if (num[lo] + num[hi] &lt; sum) lo++; else hi--; &#125; &#125; &#125; return res;&#125; Have a nice coding! https://discuss.leetcode.com/topic/28857/easiest-java-solution Easiest Java Solution Sort the array, iterate through the list, and use another two pointers to approach the target. 12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i + 2 &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; // skip same result continue; &#125; int j = i + 1, k = nums.length - 1; int target = -nums[i]; while (j &lt; k) &#123; if (nums[j] + nums[k] == target) &#123; res.add(Arrays.asList(nums[i], nums[j], nums[k])); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++; // skip same result while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--; // skip same result &#125; else if (nums[j] + nums[k] &gt; target) &#123; k--; &#125; else &#123; j++; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/45491/share-my-simple-java-solution Share my simple java solution 123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(nums.length &lt; 3) return result; Arrays.sort(nums); int i = 0; while(i &lt; nums.length - 2) &#123; if(nums[i] &gt; 0) break; int j = i + 1; int k = nums.length - 1; while(j &lt; k) &#123; int sum = nums[i] + nums[j] + nums[k]; if(sum == 0) result.add(Arrays.asList(nums[i], nums[j], nums[k])); if(sum &lt;= 0) while(nums[j] == nums[++j] &amp;&amp; j &lt; k); if(sum &gt;= 0) while(nums[k--] == nums[k] &amp;&amp; j &lt; k); &#125; while(nums[i] == nums[++i] &amp;&amp; i &lt; nums.length - 2); &#125; return result; &#125;&#125; https://discuss.leetcode.com/topic/26050/simple-o-n-2-two-pointers-java-solution Simple O(n^2) two pointers Java solution Runtime = O(n^2); Space = O(1) 12345678910111213141516171819202122232425262728public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] A) &#123; List&lt;List&lt;Integer&gt;&gt;res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (A == null || A.length == 0) return res; Arrays.sort(A); for (int i = 0; i &lt; A.length; i++) &#123; if (i - 1 &gt;= 0 &amp;&amp; A[i] == A[i - 1]) continue;// Skip equal elements to avoid duplicates int left = i + 1, right = A.length - 1; while (left &lt; right) &#123;// Two Pointers int sum = A[i] + A[left] + A[right]; if (sum == 0) &#123; res.add(Arrays.asList(A[i], A[left], A[right])); while (left + 1 &lt; right &amp;&amp; A[left] == A[left+1])// Skip equal elements to avoid duplicates left++; while (right -1 &gt; left &amp;&amp; A[right] == A[right-1])// Skip equal elements to avoid duplicates right--; left++; right--; &#125; else if (sum &lt; 0) &#123; left++; &#125; else &#123; right--; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/8465/my-java-solution-with-fifo-queue My java solution with FIFO queue1234567891011121314public List&lt;String&gt; letterCombinations(String digits) &#123; LinkedList&lt;String&gt; ans = new LinkedList&lt;String&gt;(); String[] mapping = new String[] &#123;&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; ans.add(&quot;&quot;); for(int i =0; i&lt;digits.length();i++)&#123; int x = Character.getNumericValue(digits.charAt(i)); while(ans.peek().length()==i)&#123; String t = ans.remove(); for(char s : mapping[x].toCharArray()) ans.add(t+s); &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/6380/my-recursive-solution-using-java My recursive solution using Java1234567891011121314151617181920public class Solution &#123; private static final String[] KEYS = &#123; &quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot; &#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; ret = new LinkedList&lt;String&gt;(); combination(&quot;&quot;, digits, 0, ret); return ret; &#125; private void combination(String prefix, String digits, int offset, List&lt;String&gt; ret) &#123; if (offset &gt;= digits.length()) &#123; ret.add(prefix); return; &#125; String letters = KEYS[(digits.charAt(offset) - &apos;0&apos;)]; for (int i = 0; i &lt; letters.length(); i++) &#123; combination(prefix + letters.charAt(i), digits, offset + 1, ret); &#125; &#125; &#125; cpp https://discuss.leetcode.com/topic/8107/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments Share my AC C++ solution, around 50ms, O(N*N), with explanation and comments the key idea is the same as the TwoSum problem. When we fix the 1st number, the 2nd and 3rd number can be found following the same reasoning as TwoSum. The only difference is that, the TwoSum problem of LEETCODE has a unique solution. However, in ThreeSum, we have multiple duplicate solutions that can be found. Most of the OLE errors happened here because you could’ve ended up with a solution with so many duplicates. The naive solution for the duplicates will be using the STL methods like below : 12std::sort(res.begin(), res.end());res.erase(unique(res.begin(), res.end()), res.end()); But according to my submissions, this way will cause you double your time consuming almostly. A better approach is that, to jump over the number which has been scanned, no matter it is part of some solution or not. If the three numbers formed a solution, we can safely ignore all the duplicates of them. We can do this to all the three numbers such that we can remove the duplicates. Here’s my AC C++ Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; res; std::sort(num.begin(), num.end()); for (int i = 0; i &lt; num.size(); i++) &#123; int target = -num[i]; int front = i + 1; int back = num.size() - 1; while (front &lt; back) &#123; int sum = num[front] + num[back]; // Finding answer which start from number num[i] if (sum &lt; target) front++; else if (sum &gt; target) back--; else &#123; vector&lt;int&gt; triplet(3, 0); triplet[0] = num[i]; triplet[1] = num[front]; triplet[2] = num[back]; res.push_back(triplet); // Processing duplicates of Number 2 // Rolling the front pointer to the next different number forwards while (front &lt; back &amp;&amp; num[front] == triplet[1]) front++; // Processing duplicates of Number 3 // Rolling the back pointer to the next different number backwards while (front &lt; back &amp;&amp; num[back] == triplet[2]) rear--; &#125; &#125; // Processing duplicates of Number 1 while (i + 1 &lt; num.size() &amp;&amp; num[i + 1] == num[i]) i++; &#125; return res; &#125; https://discuss.leetcode.com/topic/15291/20-lines-68ms-c-solution-used-two-pointers-similar-to-2sum ~20 lines. 68ms. c++ solution. Used two pointers similar to 2sum 1234567891011121314151617181920212223242526272829303132vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt;=2) return &#123;&#125;; vector&lt;vector&lt;int&gt; &gt; rtn; sort(nums.begin(), nums.end()); for(int i =0; i &lt; nums.size();)&#123; int start = i+1, end = nums.size()-1; while(start &lt; end)&#123; if(nums[i]+nums[start]+nums[end] == 0)&#123; rtn.push_back(&#123;nums[i],nums[start],nums[end]&#125;); start++; end--; while((start &lt; end) &amp;&amp; nums[start] == nums[start-1]) start++; while((start &lt; end) &amp;&amp; nums[end] == nums[end+1]) end--; &#125;else if(nums[i]+nums[start]+nums[end]&lt;0)&#123; start++; while((start &lt; end) &amp;&amp; nums[start] == nums[start-1]) start++; &#125;else&#123; end--; while((start &lt; end) &amp;&amp; nums[end] == nums[end+1]) end--; &#125; &#125; i++; while((i &lt; nums.size()) &amp;&amp; nums[i] == nums[i-1]) i++; &#125; return rtn;&#125; Thanks to my friend Yang Li inspired me of using two pointers https://discuss.leetcode.com/topic/15291/20-lines-68ms-c-solution-used-two-pointers-similar-to-2sum/2 Excellent way to avoid duplicate triples! (I had previously collected them in a set and moved them to a vector in the end). Here’s my take on it (got it to run in 52 ms): 12345678910111213141516vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; triples; sort(nums.begin(), nums.end()); int i = 0, last = nums.size() - 1; while (i &lt; last) &#123; int a = nums[i], j = i+1, k = last; while (j &lt; k) &#123; int b = nums[j], c = nums[k], sum = a+b+c; if (sum == 0) triples.push_back(&#123;a, b, c&#125;); if (sum &lt;= 0) while (nums[j] == b &amp;&amp; j &lt; k) j++; if (sum &gt;= 0) while (nums[k] == c &amp;&amp; j &lt; k) k--; &#125; while (nums[i] == a &amp;&amp; i &lt; last) i++; &#125; return triples;&#125; https://discuss.leetcode.com/topic/3396/my-iterative-sollution-very-simple-under-15-lines My iterative sollution, very simple under 15 lines This is my solution, FYI 针对新来的一个数字，比如2=“abc”，从原有的res中的所有string都取出来，针对每一个都加一个a或b或c，再放入res。 12345678910111213141516171819class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.size()==0) return res; string charmap[10] = &#123;&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; res.push_back(&quot;&quot;); for (int i = 0; i &lt; digits.size(); i++) &#123; vector&lt;string&gt; tempres; string chars = charmap[digits[i] - &apos;0&apos;]; for (int c = 0; c &lt; chars.size();c++) for (int j = 0; j &lt; res.size();j++) tempres.push_back(res[j]+chars[c]); res = tempres; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/13160/8-line-backtracking-function-c-solution 8-line Backtracking-Function C++ Solution Most concise backtracking function, no? 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.size()==0) return res; string local; vector&lt;vector&lt;char&gt;&gt; table(2,vector&lt;char&gt;()); table.push_back(vector&lt;char&gt;&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;); // index 2 table.push_back(vector&lt;char&gt;&#123;&apos;d&apos;,&apos;e&apos;,&apos;f&apos;&#125;); // 3 table.push_back(vector&lt;char&gt;&#123;&apos;g&apos;,&apos;h&apos;,&apos;i&apos;&#125;); table.push_back(vector&lt;char&gt;&#123;&apos;j&apos;,&apos;k&apos;,&apos;l&apos;&#125;); // 5 table.push_back(vector&lt;char&gt;&#123;&apos;m&apos;,&apos;n&apos;,&apos;o&apos;&#125;); table.push_back(vector&lt;char&gt;&#123;&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;&#125;); // 7 table.push_back(vector&lt;char&gt;&#123;&apos;t&apos;,&apos;u&apos;,&apos;v&apos;&#125;); table.push_back(vector&lt;char&gt;&#123;&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;&#125;); // 9 backtracking(table,res,local,0,digits); return res; &#125; void backtracking(const vector&lt;vector&lt;char&gt;&gt;&amp; table, vector&lt;string&gt;&amp; res, string&amp; local, int index, const string&amp; digits) &#123; if(index==digits.size()) res.push_back(local); else for(int i=0;i&lt;table[digits[index]-&apos;0&apos;].size();i++) &#123; local.push_back(table[digits[index]-&apos;0&apos;][i]); backtracking(table, res, local, index+1, digits); local.pop_back(); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/22619/python-easy-to-understand-solution-o-n-n-time Python easy to understand solution (O(n*n) time). 123456789101112131415161718192021def threeSum(self, nums): res = [] nums.sort() for i in xrange(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue l, r = i+1, len(nums)-1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s &lt; 0: l +=1 elif s &gt; 0: r -= 1 else: res.append((nums[i], nums[l], nums[r])) while l &lt; r and nums[l] == nums[l+1]: l += 1 while l &lt; r and nums[r] == nums[r-1]: r -= 1 l += 1; r -= 1 return res https://discuss.leetcode.com/topic/13703/straight-forward-python-ac-o-n-2-solution-with-decent-explanation Straight forward Python AC O(n^2) solution with decent explanation 1234567891011121314151617181920212223242526272829class Solution: # @param &#123;integer[]&#125; nums # @return &#123;integer[][]&#125; def threeSum(self, nums): if len(nums) &lt;3: # deal with special input return [] elif len(nums) == 3: if sum(nums) == 0: return [sorted(nums)] nums = sorted(nums) # sorted, O(nlgn) ans = [] for i in range(len(nums) -2): j = i+1 k = len(nums) -1 # hence i &lt; j &lt; k while j&lt;k: # if not cross line temp_sum = nums[i] + nums[j] + nums[k] if temp_sum == 0: ans.append((nums[i], nums[j], nums[k])) if temp_sum &gt; 0: # which means we need smaller sum, move k backward, remember we sort the array k -= 1 else: j += 1 return list(set(tuple(ans))) # I bet this is not the best way to eliminate duplicate solutions https://discuss.leetcode.com/topic/11783/one-line-python-solution 48ms, 58.58%, September 1, 2016 123456789101112131415161718class Solution(object): def letterCombinations(self, digits): &quot;&quot;&quot; :type digits: str :rtype: List[str] &quot;&quot;&quot; if digits == &apos;&apos;: return [] kvmaps = &#123; &apos;2&apos;:&apos;abc&apos;, &apos;3&apos;:&apos;def&apos;, &apos;4&apos;:&apos;ghi&apos;, &apos;5&apos;:&apos;jkl&apos;, &apos;6&apos;:&apos;mno&apos;, &apos;7&apos;:&apos;pqrs&apos;, &apos;8&apos;:&apos;tuv&apos;, &apos;9&apos;:&apos;wxyz&apos; &#125; return reduce(lambda acc, digit:[x+y for x in acc for y in kvmaps[digit]], digits, [&apos;&apos;])]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[016. 3Sum Closest]]></title>
    <url>%2Fp%2F473b519e%2F</url>
    <content type="text"><![CDATA[30.7% https://leetcode.com/problems/3sum-closest/ Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. 123For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 方法一： 先sort，然后一个指针，从头遍历，另外两个指针。 https://discuss.leetcode.com/topic/17215/c-solution-o-n-2-using-sort C++ solution O(n^2) using sort Sort the vector and then no need to run O(N^3) algorithm as each index has a direction to move. 1234567The code starts from this formation.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678if nums[first] + nums[second] + nums[third] is smaller than the target, we know we have to increase the sum. so only choice is moving the second index forward.----------------------------------------------------^ ^ ^| | || +- second third+-first 123456789if the sum is bigger than the target, we know that we need to reduce the sum. so only choice is moving &apos;third&apos; to backward. of course if the sum equals to target, we can immediately return the sum.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678when second and third cross, the round is done so start next round by moving &apos;first&apos; and resetting second and third.---------------------------------------------------- ^ ^ ^ | | | | +- second third +-first 123456789while doing this, collect the closest sum of each stage by calculating and comparing delta. Compare abs(target-newSum) and abs(target-closest). At the end of the process the three indexes will eventually be gathered at the end of the array.---------------------------------------------------- ^ ^ ^ | | `- third | +- second +-first if no exactly matching sum has been found so far, the value in closest will be the answer. 1234567891011121314151617181920212223int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size() &lt; 3) return 0; int closest = nums[0]+nums[1]+nums[2]; sort(nums.begin(), nums.end()); for(int first = 0 ; first &lt; nums.size()-2 ; ++first) &#123; if(first &gt; 0 &amp;&amp; nums[first] == nums[first-1]) continue; int second = first+1; int third = nums.size()-1; while(second &lt; third) &#123; int curSum = nums[first]+nums[second]+nums[third]; if(curSum == target) return curSum; if(abs(target-curSum)&lt;abs(target-closest)) &#123; closest = curSum; &#125; if(curSum &gt; target) &#123; --third; &#125; else &#123; ++second; &#125; &#125; &#125; return closest;&#125; https://discuss.leetcode.com/topic/36978/12-lines-concise-and-easy-understand-c-solultion 12 lines concise and easy understand c++ solultion 1234567891011121314151617class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; nums.size() - 2; i++)&#123; int j = i + 1, k = nums.size() - 1; while(j &lt; k)&#123; int num = nums[i] + nums[j] + nums[k]; if(abs(num - target) &lt; abs(res - target)) res = num; if(num &lt; target) j++; else k--; &#125; &#125; return res; &#125;&#125;; 我的代码实现: 123456789101112131415161718192021222324class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; // res 初始化为INT_MAX可能会导致各种意外，因为res要进行加减 // 容易超范围，最好的办法是任意初始化 int res = nums[0]+nums[1]+nums[2]; int n = nums.size(); sort(nums.begin(), nums.end()); for(int first=0; first&lt;n-2; first++)&#123; int second = first+1, third = n-1; while(second&lt;third)&#123; int cur = nums[first]+nums[second]+nums[third]; // 学习使用abs函数，用于求绝对值 if(abs(cur-target)&lt;abs(res-target)) res = cur; if(cur&lt;target) second++; else third--; &#125; &#125; return res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/1978/a-n-2-solution-can-we-do-better Here is a solution in Order(N^2). I got help from this post onstackoverflow Can we improve this time complexity ? Edit:Thanks @thr for pointing out that. I have corrected it and also renamed ‘mx’ by ‘ans’. 12345678910111213141516171819202122232425262728293031323334353637383940int threeSumClosest(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;int&gt; v(num.begin(), num.end()); // I didn&apos;t wanted to disturb original array. int n = 0; int ans = 0; int sum; sort(v.begin(), v.end()); // If less then 3 elements then return their sum while (v.size() &lt;= 3) &#123; return accumulate(v.begin(), v.end(), 0); &#125; n = v.size(); /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1] * v[i] &lt;= v[j] &lt;= v[k] always, because we sorted our array. * Now, for each number, v[i] : we look for pairs v[j] &amp; v[k] such that * absolute value of (target - (v[i] + v[j] + v[k]) is minimised. * if the sum of the triplet is greater then the target it implies * we need to reduce our sum, so we do K = K - 1, that is we reduce * our sum by taking a smaller number. * Simillarly if sum of the triplet is less then the target then we * increase out sum by taking a larger number, i.e. J = J + 1. */ ans = v[0] + v[1] + v[2]; for (int i = 0; i &lt; n-2; i++) &#123; int j = i + 1; int k = n - 1; while (j &lt; k) &#123; sum = v[i] + v[j] + v[k]; if (abs(target - ans) &gt; abs(target - sum)) &#123; ans = sum; if (ans == target) return ans; &#125; (sum &gt; target) ? k-- : j++; &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/17215/c-solution-o-n-2-using-sort C++ solution O(n^2) using sort Sort the vector and then no need to run O(N^3) algorithm as each index has a direction to move. 1234567The code starts from this formation.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678if nums[first] + nums[second] + nums[third] is smaller than the target, we know we have to increase the sum. so only choice is moving the second index forward.----------------------------------------------------^ ^ ^| | || +- second third+-first 123456789if the sum is bigger than the target, we know that we need to reduce the sum. so only choice is moving &apos;third&apos; to backward. of course if the sum equals to target, we can immediately return the sum.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678when second and third cross, the round is done so start next round by moving &apos;first&apos; and resetting second and third.---------------------------------------------------- ^ ^ ^ | | | | +- second third +-first 123456789while doing this, collect the closest sum of each stage by calculating and comparing delta. Compare abs(target-newSum) and abs(target-closest). At the end of the process the three indexes will eventually be gathered at the end of the array.---------------------------------------------------- ^ ^ ^ | | `- third | +- second +-first if no exactly matching sum has been found so far, the value in closest will be the answer. 1234567891011121314151617181920212223int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size() &lt; 3) return 0; int closest = nums[0]+nums[1]+nums[2]; sort(nums.begin(), nums.end()); for(int first = 0 ; first &lt; nums.size()-2 ; ++first) &#123; if(first &gt; 0 &amp;&amp; nums[first] == nums[first-1]) continue; int second = first+1; int third = nums.size()-1; while(second &lt; third) &#123; int curSum = nums[first]+nums[second]+nums[third]; if(curSum == target) return curSum; if(abs(target-curSum)&lt;abs(target-closest)) &#123; closest = curSum; &#125; if(curSum &gt; target) &#123; --third; &#125; else &#123; ++second; &#125; &#125; &#125; return closest;&#125; https://discuss.leetcode.com/topic/36978/12-lines-concise-and-easy-understand-c-solultion 12 lines concise and easy understand c++ solultion 1234567891011121314151617class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; nums.size() - 2; i++)&#123; int j = i + 1, k = nums.size() - 1; while(j &lt; k)&#123; int num = nums[i] + nums[j] + nums[k]; if(abs(num - target) &lt; abs(res - target)) res = num; if(num &lt; target) j++; else k--; &#125; &#125; return res; &#125;&#125;; 12ms, 51.55%, Apr.23rd, 2016 https://github.com/haoel/leetcode/blob/master/algorithms/cpp/3SumClosest/3SumClosest.cpp 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int n = nums.size(); int distance = 2147483647; int result; for(int i=0; i&lt;n-2; i++)&#123; if(i&gt;0 &amp;&amp; nums[i-1]==nums[i]) continue; int a = nums[i]; int low = i+1; int high = n-1; while(low &lt; high)&#123; int b = nums[low]; int c = nums[high]; int sum = a + b + c; if(sum - target == 0) return target; else&#123; if(abs(sum - target) &lt; distance)&#123; distance = abs(sum - target); result = sum; &#125; if (sum - target &gt; 0)&#123; while(high &gt; 0 &amp;&amp; nums[high] == nums[high-1]) high--; high--; &#125;else&#123; while(low &lt; n-1 &amp;&amp; nums[low] == nums[low+1]) low++; low++; &#125; &#125; &#125; &#125; return result; &#125;&#125;; 28ms, 16.01%, Apr.23rd, 2016 https://leetcode.com/discuss/85999/12-lines-concise-and-easy-understand-c-solultion 1234567891011121314151617class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; nums.size(); i++)&#123; int j = i + 1, k = nums.size() - 1; while(j &lt; k)&#123; int num = nums[i] + nums[j] + nums[k]; if(abs(num - target) &lt; abs(res - target)) res = num; if(num &lt; target) j++; else k--; &#125; &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/9815/python-o-n-2-solution Python O(N^2) solution 123456789101112131415161718192021class Solution: # @return an integer def threeSumClosest(self, num, target): num.sort() result = num[0] + num[1] + num[2] for i in range(len(num) - 2): j, k = i+1, len(num) - 1 while j &lt; k: sum = num[i] + num[j] + num[k] if sum == target: return sum if abs(sum - target) &lt; abs(result - target): result = sum if sum &lt; target: j += 1 elif sum &gt; target: k -= 1 return result https://discuss.leetcode.com/topic/20359/python-solution-two-pointer Python solution (two-pointer). 12345678910111213141516def threeSumClosest(self, nums, target): nums.sort() res = sum(nums[:3]) for i in xrange(len(nums)): l, r = i+1, len(nums)-1 while l &lt; r: s = sum((nums[i], nums[l], nums[r])) if abs(s-target) &lt; abs(res-target): res = s if s &lt; target: l += 1 elif s &gt; target: r -= 1 else: # break early return res return res 508ms, 2.61%, Apr.23rd, 2016 http://c4fun.cn/blog/2014/03/20/leetcode-solution-02/ 求集合中3个数能够得到的距离target最近的和 和3Sum一样，而且不用处理重复解问题了。 1234567891011121314151617181920class Solution(object): def threeSumClosest(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; nums.sort() ans = None for i in range(len(nums)): l, r = i + 1, len(nums) - 1 while l &lt; r: sum = nums[l] + nums[r] + nums[i] if ans is None or abs(sum - target) &lt; abs(ans - target): ans = sum if sum &lt;= target: l = l + 1 else: r = r - 1 return ans java https://discuss.leetcode.com/topic/5192/java-solution-with-o-n2-for-reference Java solution with O(n2) for reference Similar to 3 Sum problem, use 3 pointers to point current element, next element and the last element. If the sum is less than target, it means we have to add a larger element so next element move to the next. If the sum is greater, it means we have to add a smaller element so last element move to the second last element. Keep doing this until the end. Each time compare the difference between sum and target, if it is less than minimum difference so far, then replace result with it, otherwise keep iterating. 123456789101112131415161718192021public class Solution &#123; public int threeSumClosest(int[] num, int target) &#123; int result = num[0] + num[1] + num[num.length - 1]; Arrays.sort(num); for (int i = 0; i &lt; num.length - 2; i++) &#123; int start = i + 1, end = num.length - 1; while (start &lt; end) &#123; int sum = num[i] + num[start] + num[end]; if (sum &gt; target) &#123; end--; &#125; else &#123; start++; &#125; if (Math.abs(sum - target) &lt; Math.abs(result - target)) &#123; result = sum; &#125; &#125; &#125; return result; &#125;&#125; https://discuss.leetcode.com/topic/31117/7ms-and-o-n-2-java-solution 7ms and o(n^2) java solution My solution does not need compare each sum ,just need to compare possible sum ,so can save time. 123456789101112131415161718192021222324public class Solution &#123;public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int closest=nums[0]+nums[1]+nums[2]; int low,high; for(int i=0;i&lt;nums.length-1;i++)&#123; low=i+1; high=nums.length-1; while(low&lt;high)&#123; if(nums[low]+nums[high]==target-nums[i]) return target; else if(nums[low]+nums[high]&gt;target-nums[i])&#123; while(low&lt;high&amp;&amp;nums[low]+nums[high]&gt;target-nums[i]) high--; if(Math.abs(nums[i]+nums[low]+nums[high+1]-target)&lt;Math.abs(closest-target)) closest=nums[i]+nums[low]+nums[high+1]; &#125; else&#123; while(low&lt;high&amp;&amp;nums[low]+nums[high]&lt;target-nums[i]) low++; if(Math.abs(nums[i]+nums[low-1]+nums[high]-target)&lt;Math.abs(closest-target)) closest=nums[i]+nums[low-1]+nums[high]; &#125; &#125; &#125; return closest;&#125; https://discuss.leetcode.com/topic/35892/share-my-24-line-java-code-beats-94-57-run-times Share my 24-line Java code (beats 94.57% run times) 1234567891011121314151617181920212223242526public class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int diff = Integer.MAX_VALUE, closest = 0; for (int k=0; k&lt;nums.length-2; ++k) &#123; for (int i=k+1, j=nums.length-1; i&lt;j; ) &#123; int sum = nums[k] + nums[i] + nums[j]; if (sum == target) &#123; return target; &#125; else if (sum &gt; target) &#123; if (sum-target &lt; diff) &#123; diff = sum-target; closest = sum; &#125; --j; &#125; else &#123; if (target-sum &lt; diff) &#123; diff = target-sum; closest = sum; &#125; ++i; &#125; &#125; &#125; return closest; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[015. 3Sum]]></title>
    <url>%2Fp%2F6a4c11d8%2F</url>
    <content type="text"><![CDATA[21.2% https://leetcode.com/problems/3sum/ Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 1234567For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [[-1, 0, 1],[-1, -1, 2] ] 方法一： 先排序，然后以i进行遍历，然后放j和k两个指针遍历。 重点是考虑重复的情况，所以有两处考虑了重复的问题。 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); int n = nums.size(); for(int i=0; i&lt;n-2; i++)&#123; if(i!=0 &amp;&amp; nums[i]==nums[i-1]) continue; int target = 0 - nums[i]; int j=i+1, k=n-1; while(j&lt;k)&#123; if(nums[j]+nums[k]==target)&#123; vector&lt;int&gt; tmp&#123;nums[i], nums[j], nums[k]&#125;; res.push_back(tmp); while(j&lt;k &amp;&amp; nums[j]==tmp[1]) j++; while(j&lt;k &amp;&amp; nums[k]==tmp[2]) k--; &#125;else if(nums[j]+nums[k]&gt;target)&#123; k--; &#125;else j++; &#125; &#125; return res; &#125;&#125;; 我的代码实现一： 注意其中的重点，一个是要考虑重复，一个是要考虑跳出循环 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); if(n&lt;3) return res; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-2; i++)&#123; if(i!=0 &amp;&amp; nums[i]==nums[i-1]) // 考虑重复情况 continue; int left = i+1, right = n-1; while(left&lt;right)&#123; int sum = nums[i]+nums[left]+nums[right]; if(sum==0)&#123; vector&lt;int&gt; tmp = &#123;nums[i], nums[left], nums[right]&#125;; res.push_back(tmp); while(left+1&lt;right &amp;&amp; nums[left+1]==nums[left]) left++; // 此处要跳出循环，继续寻找 while(left&lt;right-1 &amp;&amp; nums[right-1]==nums[right]) right--; left++, right--; &#125;else if(sum&lt;0) left++; else right--; &#125; &#125; return res; &#125;&#125;; 我的代码实现二: 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); if(n&lt;3) return res; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-2; i++)&#123; // 考虑重复的情况 if(i!=0 &amp;&amp; nums[i]==nums[i-1]) continue; int target = - nums[i]; int left = i+1, right = n-1; while(left&lt;right)&#123; int sum = nums[left] + nums[right]; if(sum==target)&#123; res.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;); while(left&lt;right &amp;&amp; nums[left+1]==nums[left]) left++; while(left&lt;right &amp;&amp; nums[right-1]==nums[right]) right--; left++; right--; &#125; else if(sum&lt;target) left++; else right--; &#125; &#125; return res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/8107/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments the key idea is the same as the TwoSum problem. When we fix the 1st number, the 2nd and 3rd number can be found following the same reasoning as TwoSum. The only difference is that, the TwoSum problem of LEETCODE has a unique solution. However, in ThreeSum, we have multiple duplicate solutions that can be found. Most of the OLE errors happened here because you could’ve ended up with a solution with so many duplicates. The naive solution for the duplicates will be using the STL methods like below : 12std::sort(res.begin(), res.end());res.erase(unique(res.begin(), res.end()), res.end()); But according to my submissions, this way will cause you double your time consuming almostly. A better approach is that, to jump over the number which has been scanned, no matter it is part of some solution or not. If the three numbers formed a solution, we can safely ignore all the duplicates of them. We can do this to all the three numbers such that we can remove the duplicates. Here’s my AC C++ Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; res; std::sort(num.begin(), num.end()); for (int i = 0; i &lt; num.size(); i++) &#123; int target = -num[i]; int front = i + 1; int back = num.size() - 1; while (front &lt; back) &#123; int sum = num[front] + num[back]; // Finding answer which start from number num[i] if (sum &lt; target) front++; else if (sum &gt; target) back--; else &#123; vector&lt;int&gt; triplet(3, 0); triplet[0] = num[i]; triplet[1] = num[front]; triplet[2] = num[back]; res.push_back(triplet); // Processing duplicates of Number 2 // Rolling the front pointer to the next different number forwards while (front &lt; back &amp;&amp; num[front] == triplet[1]) front++; // Processing duplicates of Number 3 // Rolling the back pointer to the next different number backwards while (front &lt; back &amp;&amp; num[back] == triplet[2]) rear--; &#125; &#125; // Processing duplicates of Number 1 while (i + 1 &lt; num.size() &amp;&amp; num[i + 1] == num[i]) i++; &#125; return res; &#125; 64ms, 23.81%, Apr.23rd, 2016 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt; vector&lt;int&gt; &gt; result; // 先排序 sort(nums.begin(), nums.end()); int n = nums.size(); for(int i=0; i&lt;n-2; i++)&#123; // 跳过重复项 if(i&gt;0 &amp;&amp; nums[i-1]==nums[i]) continue; int a = nums[i]; int low = i + 1; int high = n - 1; while(low &lt; high)&#123; int b = nums[low]; int c = nums[high]; if(a + b + c == 0)&#123; vector&lt;int&gt; v; v.push_back(a); v.push_back(b); v.push_back(c); result.push_back(v); // 继续寻找答案,忽略重复项，high，low各加1 while(low &lt; n-1 &amp;&amp; nums[low] == nums[low+1]) low++; while(high &gt; 0 &amp;&amp; nums[high] == nums[high-1]) high--; low++; high--; &#125;else if(a+b+c &gt; 0)&#123; while(high &gt; 0 &amp;&amp; nums[high] == nums[high-1]) high--; high--; &#125;else&#123; while(low &gt; 0 &amp;&amp; nums[low] == nums[low+1]) low++; low++; &#125; &#125; &#125; return result; &#125;&#125;; python 224ms, 44.36%, Apr.23rd, 2016 求3个数的和为target的所有解。 枚举第一个数，然后第二个数为这个数的后一个数，第三个数为最后一个数，如果和小于0，第二个数后移， 如大于0第三个数前移，等于0的话记录结果并且都向中间移。注意处理重复解。 123456789101112131415161718192021class Solution: # @return a list of lists of length 3, [[val1,val2,val3]] def threeSum(self, num): num.sort() ans = [] for i in range(len(num)): if (i &gt; 0 and num[i] == num[i-1]): continue l, r = i + 1, len(num) - 1 while l &lt; r: sum = num[l] + num[r] + num[i] if sum == 0: ans.append([num[i], num[l], num[r]]) while l &lt; r and num[l] == num[l + 1]: l = l + 1 while l &lt; r and num[r] == num[r - 1]: r = r - 1 l, r = l + 1, r - 1 elif sum &lt; 0: l = l + 1 else: r = r - 1 return ans java https://discuss.leetcode.com/topic/8125/concise-o-n-2-java-solution Concise O(N^2) Java solution Hi guys! The idea is to sort an input array and then run through all indices of a possible first element of a triplet. For each possible first element we make a standard bi-directional 2Sum sweep of the remaining part of the array. Also we want to skip equal elements to avoid duplicates in the answer without making a set or smth like that. Have a nice coding! 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) &#123; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; num.length-2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; num[i] != num[i-1])) &#123; int lo = i+1, hi = num.length-1, sum = 0 - num[i]; while (lo &lt; hi) &#123; if (num[lo] + num[hi] == sum) &#123; res.add(Arrays.asList(num[i], num[lo], num[hi])); while (lo &lt; hi &amp;&amp; num[lo] == num[lo+1]) lo++; while (lo &lt; hi &amp;&amp; num[hi] == num[hi-1]) hi--; lo++; hi--; &#125; else if (num[lo] + num[hi] &lt; sum) lo++; else hi--; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/28857/easiest-java-solution Easiest Java Solution Sort the array, iterate through the list, and use another two pointers to approach the target. 12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i + 2 &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; // skip same result continue; &#125; int j = i + 1, k = nums.length - 1; int target = -nums[i]; while (j &lt; k) &#123; if (nums[j] + nums[k] == target) &#123; res.add(Arrays.asList(nums[i], nums[j], nums[k])); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++; // skip same result while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--; // skip same result &#125; else if (nums[j] + nums[k] &gt; target) &#123; k--; &#125; else &#123; j++; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/45491/share-my-simple-java-solution Share my simple java solution 123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(nums.length &lt; 3) return result; Arrays.sort(nums); int i = 0; while(i &lt; nums.length - 2) &#123; if(nums[i] &gt; 0) break; int j = i + 1; int k = nums.length - 1; while(j &lt; k) &#123; int sum = nums[i] + nums[j] + nums[k]; if(sum == 0) result.add(Arrays.asList(nums[i], nums[j], nums[k])); if(sum &lt;= 0) while(nums[j] == nums[++j] &amp;&amp; j &lt; k); if(sum &gt;= 0) while(nums[k--] == nums[k] &amp;&amp; j &lt; k); &#125; while(nums[i] == nums[++i] &amp;&amp; i &lt; nums.length - 2); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[014. Longest Common Prefix]]></title>
    <url>%2Fp%2F58ae5420%2F</url>
    <content type="text"><![CDATA[31.5% https://leetcode.com/problems/longest-common-prefix/ Write a function to find the longest common prefix string amongst an array of strings. 方法一： First one: check from strs[0][0] to strs[i][0]. If matches, check strs[0][1] to strs[i][1]. Code: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=&quot;&quot;; int max=INT_MAX; for(auto&amp; s:strs) &#123; max=(max&gt;s.length())?s.length():max; &#125; for(int i=0;i&lt;max;i++) &#123; bool flag=true; char x=strs[0][i]; for(auto&amp; s:strs) &#123; if(s[i]!=x) &#123; flag=false; break; &#125; &#125; if(flag==false) return ans; ans+=x; &#125; return ans; &#125;&#125;; 代码的另一种写法： 12345678910111213class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string prefix = &quot;&quot;; for(int idx=0; strs.size()&gt;0;idx++)&#123; for(int i=0; i&lt;strs.size(); i++) if(idx&gt;=strs[i].size() || (i&gt;0&amp;&amp;strs[i][idx] != strs[i-1][idx])) return prefix; prefix+=strs[0][idx]; &#125; return prefix; &#125;&#125;; 我的代码实现： 12345678910111213141516171819class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string res = ""; int n = strs.size(); // 一定考虑是否有异常情况的可能性 if(n==0) return res; int i = 0; while(true)&#123; for(int j=0; j&lt;n; j++)&#123; if(i&gt;=strs[j].size() || j&gt;0 &amp;&amp; strs[j][i]!=strs[j-1][i])&#123; return res; &#125; &#125; res += strs[0][i]; i++; &#125; &#125;&#125;; 方法二： Second one: assume the prefix is strs[0]. Compair with strs[i], and cut the letters which don’t match. Code: 1234567891011121314151617181920212223class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=strs[0]; int max=INT_MAX; for(auto&amp; s:strs) &#123; if(s.length()==0) return &quot;&quot;; int i=0; for(i=0;i&lt;ans.length()&amp;&amp;i&lt;s.length();i++) &#123; if(s[i]!=ans[i]) break; &#125; ans=ans.substr(0,i); &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/13121/what-does-longest-common-prefix-mean What does Longest Common Prefix mean ? The problem statement is confusing and unclear. Can someone throw light on this ? Is it to find prefix between each pair of strings and return the one which is longest. Or all the strings has to have a common prefix? https://discuss.leetcode.com/topic/13121/what-does-longest-common-prefix-mean/2 It seems that it is not to check between pair of strings but on all the strings in the array. For example: {“a”,”a”,”b”} should give “” as there is nothing common in all the 3 strings. {“a”, “a”} should give “a” as a is longest common prefix in all the strings. {“abca”, “abc”} as abc {“ac”, “ac”, “a”, “a”} as a. Logic goes something like this: Pick a character at i=0th location and compare it with the character at that location in every string. If anyone doesn’t have that just return “” Else append that character in to the result. Increment i and do steps 1-3 till the length of that string. return result. Make sure proper checks are maintained to avoid index out of bounds error. cpp https://discuss.leetcode.com/topic/20991/accepted-c-6-lines-4ms Accepted c++ 6 lines 4ms 6ms, September 19, 2016 1234567891011class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string prefix = &quot;&quot;; for(int idx=0; strs.size()&gt;0;prefix+=strs[0][idx], idx++) for(int i=0; i&lt;strs.size(); i++) if(idx&gt;=strs[i].size() || (i&gt;0&amp;&amp;strs[i][idx] != strs[i-1][idx])) return prefix; return prefix; &#125;&#125;; https://discuss.leetcode.com/topic/16623/3-diffrent-c-solutions-each-one-costs-8ms 3 diffrent C++ solutions, each one costs 8ms. First one: check from strs[0][0] to strs[i][0]. If matches, check strs[0][1] to strs[i][1]. Code: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=&quot;&quot;; int max=INT_MAX; for(auto&amp; s:strs) &#123; max=(max&gt;s.length())?s.length():max; &#125; for(int i=0;i&lt;max;i++) &#123; bool flag=true; char x=strs[0][i]; for(auto&amp; s:strs) &#123; if(s[i]!=x) &#123; flag=false; break; &#125; &#125; if(flag==false) return ans; ans+=x; &#125; return ans; &#125;&#125;; Second one: assume the prefix is strs[0]. Compair with strs[i], and cut the letters which don’t match. Code: 1234567891011121314151617181920212223class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=strs[0]; int max=INT_MAX; for(auto&amp; s:strs) &#123; if(s.length()==0) return &quot;&quot;; int i=0; for(i=0;i&lt;ans.length()&amp;&amp;i&lt;s.length();i++) &#123; if(s[i]!=ans[i]) break; &#125; ans=ans.substr(0,i); &#125; return ans; &#125;&#125;; Third one: use a Trie data structure to save the strs. Search the trie, and stops when a TrieNode has more than one son. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879Code:class TrieNode&#123;public: bool val; TrieNode* next[52]; int sons; TrieNode() :val(false), sons(0) &#123; for (int i = 0; i &lt; 52; i++) next[i] = nullptr; &#125;&#125;;class Trie&#123;private: TrieNode* putst(string&amp; s, TrieNode * node, int loc, TrieNode *father) &#123; if (s.length() == 0) &#123; node-&gt;val = true; node-&gt;sons++; return node; &#125; if (node == nullptr) &#123; node = new TrieNode(); if (father != nullptr) father-&gt;sons++; &#125; if (loc == s.length()) &#123; node-&gt;val = true; return node; &#125; if (s[loc] &gt;= &apos;a&apos;) node-&gt;next[s[loc] - &apos;a&apos;] = putst(s, node-&gt;next[s[loc] - &apos;a&apos;], loc + 1, node); else node-&gt;next[s[loc] - &apos;A&apos; + 26] = putst(s, node-&gt;next[s[loc] - &apos;A&apos; + 26], loc + 1, node); return node; &#125;public: TrieNode *root; void insert(string &amp; str)&#123; putst(str, root, 0, nullptr); &#125; Trie()&#123; root = new TrieNode(); &#125;&#125;;class Solution &#123;private: string findPre(TrieNode * node) &#123; if (node == nullptr || (node != nullptr&amp;&amp;node-&gt;sons &gt; 1)) return string(&quot;&quot;); int i = 0; for (i = 0; i &lt; 52; i++) &#123; if (node-&gt;next[i] != nullptr) break; &#125; if (i == 52) return string(&quot;&quot;); char temp1 = ((i&gt;25) ? (&apos;A&apos; + i) : (&apos;a&apos; + i)); string temp; temp.insert(temp.begin(), temp1); if (node-&gt;val) &#123; return string(&quot;&quot;); &#125; else &#123; return temp + findPre(node-&gt;next[i]); &#125; &#125;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; Trie a; for (auto&amp; str : strs) a.insert(str); return findPre(a.root); &#125;&#125;; python https://discuss.leetcode.com/topic/6308/simple-python-solution Simple Python solution 62ms, September 19, 2016 Might be a bit slow, but here’s my relatively elegant Python solution: 1234567891011121314class Solution(object): def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str] :rtype: str &quot;&quot;&quot; if not strs: return &apos;&apos; for i, letter_group in enumerate(zip(*strs)): if len(set(letter_group)) &gt; 1: return strs[0][:i] return min(strs) https://discuss.leetcode.com/topic/6308/simple-python-solution/2 Nice use of zip. Here’s my version, it ran in 58 ms. I was proud of myself for using reduce() appropriately: 123456789101112131415161718class Solution: def lcp(self, str1, str2): i = 0 while (i &lt; len(str1) and i &lt; len(str2)): if str1[i] == str2[i]: i = i+1 else: break return str1[:i] # @return a string def longestCommonPrefix(self, strs): if not strs: return &apos;&apos; else: return reduce(self.lcp,strs) https://discuss.leetcode.com/topic/27094/5-line-python-with-zip-and-len-set 5 line python with zip() and len(set()) Just for fun :) 1234567891011class Solution(object): def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str]; rtype: str &quot;&quot;&quot; sz, ret = zip(*strs), &quot;&quot; # looping corrected based on @StefanPochmann&apos;s comment below for c in sz: if len(set(c)) &gt; 1: break ret += c[0] return ret https://discuss.leetcode.com/topic/21222/already-implemented-in-python Already implemented in Python 1234567import osclass Solution: # @param &#123;string[]&#125; strs # @return &#123;string&#125; def longestCommonPrefix(self, strs): return os.path.commonprefix(strs) java https://discuss.leetcode.com/topic/6987/java-code-with-13-lines Java code with 13 lines 1234567891011public String longestCommonPrefix(String[] strs) &#123; if(strs == null || strs.length == 0) return &quot;&quot;; String pre = strs[0]; int i = 1; while(i &lt; strs.length)&#123; while(strs[i].indexOf(pre) != 0) pre = pre.substring(0,pre.length()-1); i++; &#125; return pre;&#125; https://discuss.leetcode.com/topic/6987/java-code-with-13-lines/6 Since you seem to value the number of lines, why didn’t you use a for-loop? It saves three lines. 12345678public String longestCommonPrefix(String[] strs) &#123; if (strs.length == 0) return &quot;&quot;; String pre = strs[0]; for (int i = 1; i &lt; strs.length; i++) while(strs[i].indexOf(pre) != 0) pre = pre.substring(0,pre.length()-1); return pre;&#125; https://discuss.leetcode.com/topic/27913/sorted-the-array-java-solution-2-ms Sorted the array, Java solution, 2 ms Sort the array first, and then you can simply compare the first and last elements in the sorted array. 1234567891011121314151617181920public String longestCommonPrefix(String[] strs) &#123; StringBuilder result = new StringBuilder(); if (strs!= null &amp;&amp; strs.length &gt; 0)&#123; Arrays.sort(strs); char [] a = strs[0].toCharArray(); char [] b = strs[strs.length-1].toCharArray(); for (int i = 0; i &lt; a.length; i ++)&#123; if (b.length &gt; i &amp;&amp; b[i] == a[i])&#123; result.append(b[i]); &#125; else &#123; return result.toString(); &#125; &#125; return result.toString();&#125; https://discuss.leetcode.com/topic/12173/fast-and-simple-java-code-231ms Fast and simple Java code 231ms 1234567891011121314public class Solution &#123; public String longestCommonPrefix(List&lt;String&gt; strs) &#123; if(strs.size()==0) return &quot;&quot;; StringBuilder lcp=new StringBuilder(); for(int i=0;i&lt;strs.get(0).length();i++)&#123; char c=strs.get(0).charAt(i); for(String s:strs)&#123; if(s.length()&lt;i+1||c!=s.charAt(i)) return lcp.toString(); &#125; lcp.append(c); &#125; return lcp.toString(); &#125;&#125; https://discuss.leetcode.com/topic/40472/java-we-love-clear-code Java —— We Love Clear Code! 123456789101112public String longestCommonPrefix(String[] strs) &#123; if (strs == null) return null; if (strs.length == 0) return &quot;&quot;; Arrays.sort(strs); char[] first = strs[0].toCharArray(); char[] last = strs[strs.length - 1].toCharArray(); int i = 0, len = Math.min(first.length, last.length); while (i &lt; len &amp;&amp; first[i] == last[i]) i++; return strs[0].substring(0, i);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[013. Roman to Integer]]></title>
    <url>%2Fp%2F850f821a%2F</url>
    <content type="text"><![CDATA[46.0% https://leetcode.com/problems/roman-to-integer/ Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 方法一: 从后向前遍历，如果当前值大于右边，加上当前值，如果当前值小于右边，减去当前值。 https://leetcode.com/discuss/22867/clean-o-n-c-solution Clean O(n) c++ solution 80ms, 7.24%, May.4th, 2016 Problem is simpler to solve by working the string from back to front and using a map. Runtime speed is 88 ms. 12345678910111213141516class Solution &#123;public: int romanToInt(string s) &#123; unordered_map&lt;char, int&gt; T = &#123;&#123; &apos;I&apos;, 1&#125;, &#123;&apos;V&apos;, 5&#125;, &#123;&apos;X&apos;, 10&#125;, &#123;&apos;L&apos;, 50&#125;, &#123;&apos;C&apos;, 100&#125;, &#123;&apos;D&apos;, 500&#125;, &#123;&apos;M&apos;, 1000&#125;&#125;; int sum = T[s.back()]; for(int i = s.length() - 2; i &gt;= 0; --i)&#123; if(T[s[i]] &lt; T[s[i + 1]]) sum -= T[s[i]]; else sum += T[s[i]]; &#125; return sum; &#125;&#125;; 我的代码实现： 123456789101112131415161718class Solution &#123;public: int romanToInt(string s) &#123; int n = s.size(); if(n==0) return 0; // 学习map的初始化 map&lt;char, int&gt; map = &#123;&#123;'I',1&#125;, &#123;'V', 5&#125;, &#123;'X', 10&#125;, &#123;'L', 50&#125;, &#123;'C', 100&#125;, &#123;'D', 500&#125;, &#123;'M', 1000&#125;&#125;; int res = map[s[n-1]]; // 逆向思考问题，有时更容易解决 for(int i=n-2; i&gt;=0; i--) if(map[s[i]] &gt;= map[s[i+1]]) res += map[s[i]]; else res -= map[s[i]]; return res; &#125;&#125;; https://discuss.leetcode.com/topic/6127/my-easy-to-understand-c-solutions My easy-to-understand C++ solutions 1234567891011121314151617181920212223242526272829class Solution &#123;public: int romanToInt(string s) &#123; int num = 0; int size = s.size(); for (int i = 0; i &lt; size; i++) &#123; if (i &lt; (size - 1) &amp;&amp; romanCharToInt(s[i]) &lt; romanCharToInt(s[i + 1])) &#123; num -= romanCharToInt(s[i]); &#125; else &#123; num += romanCharToInt(s[i]); &#125; &#125; return num; &#125; int romanCharToInt(char c) &#123; switch (c) &#123; case &apos;I&apos;: return 1; case &apos;V&apos;: return 5; case &apos;X&apos;: return 10; case &apos;L&apos;: return 50; case &apos;C&apos;: return 100; case &apos;D&apos;: return 500; case &apos;M&apos;: return 1000; default: return 0; &#125; &#125;&#125;; The code is faster if the body of the for loop is replaced with: 12345678if (i &lt; (size - 1) &amp;&amp; ( &apos;I&apos; == s[i] &amp;&amp; (&apos;V&apos; == s[i + 1] || &apos;X&apos; == s[i + 1]) || &apos;X&apos; == s[i] &amp;&amp; (&apos;L&apos; == s[i + 1] || &apos;C&apos; == s[i + 1]) || &apos;C&apos; == s[i] &amp;&amp; (&apos;D&apos; == s[i + 1] || &apos;M&apos; == s[i + 1]) )) &#123; num -= romanCharToInt(s[i]);&#125; else &#123; num += romanCharToInt(s[i]);&#125; https://discuss.leetcode.com/topic/15224/simple-56ms-c-solution Simple 56ms C++ solution Processing the roman number from right to left turns out to be a bit easier since we can easily tell when to add or subtract: 123456789101112class Solution &#123;public: int romanToInt(string s) &#123; if (s.empty()) &#123; return 0; &#125; unordered_map&lt;char, int&gt; mp &#123; &#123;&apos;I&apos;, 1&#125;, &#123;&apos;V&apos;, 5&#125;, &#123;&apos;X&apos;, 10&#125;, &#123;&apos;L&apos;, 50&#125;, &#123;&apos;C&apos;, 100&#125;, &#123;&apos;D&apos;, 500&#125;, &#123;&apos;M&apos;, 1000&#125; &#125;; int sum = mp[s.back()]; for (int i = s.size() - 2; i &gt;= 0; --i) &#123; sum += mp[s[i]] &gt;= mp[s[i + 1]] ? mp[s[i]] : -mp[s[i]]; &#125; return sum; &#125;&#125;; https://discuss.leetcode.com/topic/30205/i-strongly-suggest-leetcode-explains-the-conversion-rule-clearer I strongly suggest leetcode explains the conversion rule clearer. It would help a lot for those who are not familiar with Roman numerals if the conversion rule is provided, or a conversion table similar to Roman Numerals Chart is given. python https://discuss.leetcode.com/topic/17110/my-straightforward-python-solution My Straightforward Python Solution 123456789101112class Solution:# @param &#123;string&#125; s# @return &#123;integer&#125;def romanToInt(self, s): roman = &#123;&apos;M&apos;: 1000,&apos;D&apos;: 500 ,&apos;C&apos;: 100,&apos;L&apos;: 50,&apos;X&apos;: 10,&apos;V&apos;: 5,&apos;I&apos;: 1&#125; z = 0 for i in range(0, len(s) - 1): if roman[s[i]] &lt; roman[s[i+1]]: z -= roman[s[i]] else: z += roman[s[i]] return z + roman[s[-1]] *Note: The trick is that the last letter is always added. Except the last one, if one letter is less than its latter one, this letter is subtracted. https://discuss.leetcode.com/topic/47179/4-lines-in-python 4 lines in Python d = {‘M’:1000, ‘D’:500, ‘C’:100, ‘L’:50, ‘X’:10, ‘V’:5, ‘I’:1} 12345def romanToInt(self, s): res, p = 0, &apos;I&apos; for c in s[::-1]: res, p = res - d[c] if d[c] &lt; d[p] else res + d[c], c return res https://leetcode.com/discuss/21888/python-solution Python solution 160ms, 85.18%, May.4th, 2016 12345678910111213141516171819class Solution(object): def romanToInt(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; romans = &#123;&apos;M&apos;:1000, &apos;D&apos;:500, &apos;C&apos;:100, &apos;L&apos;:50, &apos;X&apos;:10, &apos;V&apos;:5, &apos;I&apos;:1&#125; prev_value = running_total = 0 for i in xrange(len(s)-1, -1, -1): int_val = romans[s[i]] if int_val &lt; prev_value: running_total -= int_val else: running_total += int_val prev_value = int_val return running_total java https://discuss.leetcode.com/topic/821/my-solution-for-this-question-but-i-don-t-know-is-there-any-easier-way My solution for this question but I don’t know is there any easier way? count every Symbol and add its value to the sum, and minus the extra part of special cases. 1234567891011121314151617181920212223242526public int romanToInt(String s) &#123; int sum=0; if(s.indexOf(&quot;IV&quot;)!=-1)&#123;sum-=2;&#125; if(s.indexOf(&quot;IX&quot;)!=-1)&#123;sum-=2;&#125; if(s.indexOf(&quot;XL&quot;)!=-1)&#123;sum-=20;&#125; if(s.indexOf(&quot;XC&quot;)!=-1)&#123;sum-=20;&#125; if(s.indexOf(&quot;CD&quot;)!=-1)&#123;sum-=200;&#125; if(s.indexOf(&quot;CM&quot;)!=-1)&#123;sum-=200;&#125; char c[]=s.toCharArray(); int count=0; for(;count&lt;=s.length()-1;count++)&#123; if(c[count]==&apos;M&apos;) sum+=1000; if(c[count]==&apos;D&apos;) sum+=500; if(c[count]==&apos;C&apos;) sum+=100; if(c[count]==&apos;L&apos;) sum+=50; if(c[count]==&apos;X&apos;) sum+=10; if(c[count]==&apos;V&apos;) sum+=5; if(c[count]==&apos;I&apos;) sum+=1; &#125; return sum; &#125; https://leetcode.com/discuss/2369/solution-for-this-question-but-dont-know-there-any-easier-way/2 6ms, 97.91%, May.4th, 2016 My solution, only scan string once 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public int romanToInt(String s) &#123; int res = 0; for(int i = s.length() - 1; i &gt;= 0; i--)&#123; char c = s.charAt(i); switch(c)&#123; case &apos;I&apos;: res += (res &gt;= 5 ? -1 : 1); break; case &apos;V&apos;: res += 5; break; case &apos;X&apos;: res += 10 * (res &gt;= 50 ? -1 : 1); break; case &apos;L&apos;: res += 50; break; case &apos;C&apos;: res += 100 * (res &gt;= 500 ? -1 : 1); break; case &apos;D&apos;: res += 500; break; case &apos;M&apos;: res += 1000; break; &#125; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/821/my-solution-for-this-question-but-i-don-t-know-is-there-any-easier-way/3 My solution, scan string once from tail to head. If s[i]’s corresponding integer is no less than the previous one, add it to the result; otherwise, subtract it from the result. 1234567891011121314151617181920int romanToInt(string s) &#123; unordered_map&lt;char, int&gt; charToInt = &#123; &#123; &apos;I&apos;, 1 &#125;, &#123; &apos;V&apos;, 5 &#125;, &#123; &apos;X&apos;, 10 &#125;, &#123; &apos;L&apos;, 50 &#125;, &#123; &apos;C&apos;, 100 &#125;, &#123; &apos;D&apos;, 500 &#125;, &#123; &apos;M&apos;, 1000 &#125; &#125;; int result = 0; int index = s.length() - 1; int preInt = 0; while (index &gt;= 0) &#123; char ch = s[index]; int curInt = charToInt[ch]; if (curInt &gt;= preInt) result += curInt; else result -= curInt; preInt = curInt; index--; &#125; return result;&#125; https://discuss.leetcode.com/topic/28471/7ms-solution-in-java-easy-to-understand 7ms solution in Java. easy to understand 123456789101112131415161718192021222324252627282930313233343536public int romanToInt(String s) &#123; int nums[]=new int[s.length()]; for(int i=0;i&lt;s.length();i++)&#123; switch (s.charAt(i))&#123; case &apos;M&apos;: nums[i]=1000; break; case &apos;D&apos;: nums[i]=500; break; case &apos;C&apos;: nums[i]=100; break; case &apos;L&apos;: nums[i]=50; break; case &apos;X&apos; : nums[i]=10; break; case &apos;V&apos;: nums[i]=5; break; case &apos;I&apos;: nums[i]=1; break; &#125; &#125; int sum=0; for(int i=0;i&lt;nums.length-1;i++)&#123; if(nums[i]&lt;nums[i+1]) sum-=nums[i]; else sum+=nums[i]; &#125; return sum+nums[nums.length-1];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>math</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[012. Integer to Roman]]></title>
    <url>%2Fp%2F7da1ea45%2F</url>
    <content type="text"><![CDATA[45.0% https://leetcode.com/problems/integer-to-roman/ Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 方法一： 48ms, 15.75%, May.4th, 2016 12345678910class Solution &#123;public: string intToRoman(int num) &#123; vector&lt;string&gt;M&#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125;; vector&lt;string&gt;C&#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;; vector&lt;string&gt;X&#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;; vector&lt;string&gt;I&#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;; return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10]; &#125;&#125;; https://discuss.leetcode.com/topic/7061/sharing-my-really-simple-solution-with-explanation Sharing my really simple solution with explanation 12345678910111213141516string intToRoman(int num) &#123; string table[4][10] = &#123;&#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;, &#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;, &#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;, &#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125; &#125;; string result; int count = 0; while(num &gt; 0)&#123; int temp = num % 10; result = table[count][temp] + result; num /= 10; count++; &#125; return result;&#125; The basic idea is really simple: replace every digit in num by roman numerals. For example, we have a num: 2438. 2 –&gt; “MM” 4 –&gt; “CD” 3 –&gt; “XXX” 8 –&gt; “VIII” Then the result is “MMCDXXXVIII”. python https://discuss.leetcode.com/topic/32333/share-my-python-solution-96ms Share My Python Solution 96ms 124ms, 69.84%, May.4th, 2016 1234567891011class Solution(object): def intToRoman(self, num): &quot;&quot;&quot; :type num: int :rtype: str &quot;&quot;&quot; M = [&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;] C = [&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;] X = [&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;] I = [&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;] return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10] java https://leetcode.com/discuss/32626/simple-solution Simple Solution 10ms, 34.15%, 3999 / 3999, May.4th, 2016 123456789public class Solution &#123; public String intToRoman(int num) &#123; String M[] = &#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125;; String C[] = &#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;; String X[] = &#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;; String I[] = &#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;; return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10]; &#125;&#125; https://discuss.leetcode.com/topic/20510/my-java-solution-easy-to-understand My java solution easy to understand Reference: http://blog.csdn.net/beiyeqingteng/article/details/8547565 1234567891011121314151617public class Solution &#123;public String intToRoman(int num) &#123; int[] values = &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; String[] strs = &#123;&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;&#125;; StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;values.length;i++) &#123; while(num &gt;= values[i]) &#123; num -= values[i]; sb.append(strs[i]); &#125; &#125; return sb.toString();&#125;&#125; https://discuss.leetcode.com/topic/20510/my-java-solution-easy-to-understand/3 Your function is not really optimal because you will ALWAYS iterate until the end of your values array even if your number becomes zero! Which is not optimal at all. In addition to that you didn’t even check if the input number has a valid roman representation. You had to check that (even if the exercice assumes that the number has it already), you can do that easily with one line. Here is an improvement of your function : 12345678910111213141516171819public static String intToRoman(int num)&#123; if (num &lt; 1 || num &gt; 3999) return &quot;&quot;; StringBuilder result = new StringBuilder(); String[] roman = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;; int[] values = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;; int i = 0; //iterate until the number becomes zero, NO NEED to go until the last element in roman array while (num &gt;0) &#123; while ( num &gt;= values[i]) &#123; num -= values[i]; result.append(roman[i]); &#125; i++; &#125; return result.toString();&#125; As you see, you add just a simple line and you win an optimisation since the code will stop if the current number becomes zero (instead of doing additionnal iterations in the roman array). https://discuss.leetcode.com/topic/26543/easy-to-understand-java-solution Easy to understand Java solution 1234567891011121314151617public enum Type&#123; M(1000),CM(900),D(500),CD(400),C(100),XC(90),L(50),XL(40),X(10),IX(9),V(5),IV(4),I(1); private final int value; Type(int value) &#123; this.value = value; &#125;&#125;;public String intToRoman(int num) &#123; StringBuilder output = new StringBuilder(); for (Type t:Type.values()) &#123; while (num&gt;=t.value) &#123; output.append(t); num -= t.value; &#125; &#125; return output.toString();&#125; https://discuss.leetcode.com/topic/2858/share-my-iterative-solution Share my iterative Solution 1234567891011121314151617public String intToRoman(int num) &#123; int[] weights=&#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; String[] tokens=&#123;&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;&#125;; StringBuilder rs=new StringBuilder(&quot;&quot;); int start=0; while(num&gt;0)&#123; for(int i=start;i&lt;13;i++)&#123; if(num&gt;=weights[i])&#123; num-=weights[i]; rs.append(tokens[i]); break; &#125; start=i+1; // skip those impossible check, make it faster &#125; &#125; return rs.toString();&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[011. Container With Most Water]]></title>
    <url>%2Fp%2F971339dc%2F</url>
    <content type="text"><![CDATA[36.2% https://leetcode.com/problems/container-with-most-water/ Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container. https://discuss.leetcode.com/topic/29962/for-someone-who-is-not-so-clear-on-this-question For someone who is not so clear on this question 12345678910test y ^ | | a2 | | a3 an | a1 | | a5 | | | | | a4 | | | | | | | | .. | ---------------------------&gt; 0 1 2 3 4 5 .. n x For someone who is not clear on this question. It’s not like “https://leetcode.com/problems/trapping-rain-water/ “ Which is to get the total water for all the bars problem, It actually is to find the any 2 bars ai, aj, which hold most water together with x-axis. This post give a very good detail explanation as well. https://leetcode.com/discuss/37631/simple-and-clear-proof-explanation 方法一： 双指针 https://leetcode.com/discuss/41527/simple-and-fast-c-c-with-explanation 24ms, 61.49%, June.20th, 2016 Start by evaluating the widest container, using the first and the last line. All other possible containers are less wide, so to hold more water, they need to be higher. Thus, after evaluating that widest container, skip lines at both ends that don’t support a higher height. Then evaluate that new container we arrived at. Repeat until there are no more possible containers left. C++ 1234567891011int maxArea(vector&lt;int&gt;&amp; height) &#123; int water = 0; int i = 0, j = height.size() - 1; while (i &lt; j) &#123; int h = min(height[i], height[j]); water = max(water, (j - i) * h); while (height[i] &lt;= h &amp;&amp; i &lt; j) i++; while (height[j] &lt;= h &amp;&amp; i &lt; j) j--; &#125; return water;&#125; 我的代码实现一： 12345678910111213141516class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int left = 0, right = height.size()-1; int maxArea=0, minHeight=0; // 要设置初始值，后续有max while(left&lt;right)&#123; minHeight = min(height[right], height[left]); // 使用max， 而不是直接等于(right-left)*minHeight,因为变化之后可能变小 // 因为不满足left&lt;right的情况 maxArea = max(maxArea, (right-left)*minHeight); while(left&lt;right &amp;&amp; height[left]&lt;=minHeight) left++; while(left&lt;right &amp;&amp; height[right]&lt;=minHeight) right--; &#125; return maxArea; &#125;&#125;; 我的代码实现二： 12345678910111213141516class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if(n&lt;2) return 0; int left = 0, right = n-1; int res = 0, h = 0; while(left&lt;right)&#123; h = min(height[left], height[right]); res = max(res, h*(right-left)); while(left&lt;right &amp;&amp; height[left]&lt;=h) left++; while(left&lt;right &amp;&amp; height[right]&lt;=h) right--; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/3462/yet-another-way-to-see-what-happens-in-the-o-n-algorithm Yet another way to see what happens in the O(n) algorithm The O(n) solution with proof by contradiction doesn’t look intuitive enough to me. Before moving on, read the algorithm first if you don’t know it yet. Here’s another way to see what happens in a matrix representation: Draw a matrix where the row is the first line, and the column is the second line. For example, say n=6. In the figures below, x means we don’t need to compute the volume for that case: (1) On the diagonal, the two lines are overlapped; (2) The lower left triangle area of the matrix is symmetric to the upper right area. 123456789101112We start by computing the volume at (1,6), denoted by o. Now if the left line is shorter than the right line, then all the elements left to (1,6) on the first row have smaller volume, so we don&apos;t need to compute those cases (crossed by ---). 1 2 3 4 5 61 x ------- o2 x x3 x x x 4 x x x x5 x x x x x6 x x x x x x 1234567891011Next we move the left line and compute (2,6). Now if the right line is shorter, all cases below (2,6) are eliminated. 1 2 3 4 5 61 x ------- o2 x x o3 x x x |4 x x x x |5 x x x x x |6 x x x x x x 1234567891011And no matter how this o path goes, we end up only need to find the max value on this path, which contains n-1 cases. 1 2 3 4 5 61 x ------- o2 x x - o o o3 x x x o | |4 x x x x | |5 x x x x x |6 x x x x x x Hope this helps. I feel more comfortable seeing things this way. https://discuss.leetcode.com/topic/4552/very-simple-o-n-solution Very simple O(n) solution The idea is : to compute area, we need to take min(height[i],height[j]) as our height. Thus if height[i]&lt;height[j], then the expression min(height[i],height[j]) will always lead to at maximum height[i] for all other j(i being fixed), hence no point checking them. Similarly when height[i]&gt;height[j] then all the other i’s can be ignored for that particular j. 123456789101112131415161718class Solution &#123;public: int maxArea(vector&lt;int&gt; &amp;height) &#123; int j=height.size()-1,i=0,mx=0; while(i&lt;j) &#123; mx=max(mx,((j-i)*(min(height[i],height[j])))); if(height[i]&lt;height[j]) i++; else if(height[i]&gt;=height[j]) j--; &#125; return mx; &#125;&#125;; https://discuss.leetcode.com/topic/42122/c-o-n-solution-with-thought-process-applying-simple-bucket-theory C++ O(n) solution with thought process applying simple bucket theory The brute force solution can definitely lead us to the right answer just by doing too many redundant comparisons. When two pointer approach comes to mind, it is intuitive to set both pointers i, j at each end of this array, and move them strategically to the middle of array, update the answer during this process return the answer when we reach the end of array. Suppose now we have the scenarios below: 1237, 5, 6, 9i j When i = 1, j = 4, 1ans = min(7, 9) * (4 - 1) = 21 What’s next? Should we move i or j? We notice that to calculate the area, the height is really identified by the smaller number / shorter end between the two ends, since it’s required that you may not slant the water, so it sounds like Bucket theory: how much water a bucket can contain depends on the shortest plank. So, as to find the next potential maximum area, we disregard the shorter end by moving it to the next position. So in the above case, the next status is to move i to the left, 1237, 5, 6, 9 i j update: 12area (i, j) = area(2, 4) = min(5, 9) * (4 - 2) = 10ans = max(21, 10) = 21 You may notice that, if we move j instead, you actually get a larger area for length of 2: 1area (i, j) = area(1, 3) = min(7, 6) * (3 - 1) = 18 Does that mean this approach will not work? If you look at this way, we move pointer as to get the next potential max, so it doesn’t need to be the maximum for all combinations with length l. Even though 18 is greater than 10, it’s smaller than 21 right? So don’t worry, we can move on to find the next potential maximum result. Now we need to prove, why disregard the shorter end can safely lead us to the right answer by doing a little maths. 12Given an array: a1, a2, a3, a4, ai, ......, aj, ......, an i j Assume the maximum area so far is ans, we prove that 12&quot;By moving shorter end pointer further doesn&apos;t eliminate the final answer (with two ends at maxi, maxj respectively) in our process&quot; Suppose we have two ends at (i, j) respectively at this moment: (i) If the final answer equals what we have already achieved, it’s done! In this scenario, we must have 1maxi &lt;= i, maxj &gt;= j (ii) Otherwise, we know as we move any pointer further, the length of the next rectangle decreases, so the height needs to increase as to result in a larger area. So we have 1min(height[maxi], height[maxj]) &gt; min(height[i], height[j]) So the smaller one in height[i], height[j] won’t become any end in the maximum rectangle, so it’s safe to move forward without it. Till now, it has been proved that this approach can work in O(n) time since we advance one end towards the middle in each iteration, and update ans takes constant time in each iteration. 12345678910111213class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int ans = 0; int i = 0, j = height.size() - 1; while(i &lt; j)&#123; ans = max(ans, (j - i) * min(height[i], height[j])); height[i] &gt; height[j] ? j-- : i++; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/12843/my-short-and-easy-c-code-in-o-n My short and easy c++ code in O(n) 12345678910111213class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int i=0,j=height.size()-1,ans = 0; while(j&gt;i) &#123; ans = max(min(height[i],height[j])*(j-i),ans); if(height[i]&gt;height[j]) j--; else i++; &#125; return ans; &#125;&#125;; python https://discuss.leetcode.com/topic/14940/simple-and-clear-proof-explanation Simple and clear proof/explanation I’ve seen some “proofs” for the common O(n) solution, but I found them very confusing and lacking. Some even didn’t explain anything but just used lots of variables and equations and were like “Tada! See?”. I think mine makes more sense: Idea / Proof: The widest container (using first and last line) is a good candidate, because of its width. Its water level is the height of the smaller one of first and last line.All other containers are less wide and thus would need a higher water level in order to hold more water.The smaller one of first and last line doesn’t support a higher water level and can thus be safely removed from further consideration. Further explanation: Variables i and j define the container under consideration. We initialize them to first and last line, meaning the widest container. Variable water will keep track of the highest amount of water we managed so far. We compute j - i, the width of the current container, and min(height[i], height[j]), the water level that this container can support. Multiply them to get how much water this container can hold, and update water accordingly. Next remove the smaller one of the two lines from consideration, as justified above in “Idea / Proof”. Continue until there is nothing left to consider, then return the result. Implementation: (Python) 1234567891011class Solution: def maxArea(self, height): i, j = 0, len(height) - 1 water = 0 while i &lt; j: water = max(water, (j - i) * min(height[i], height[j])) if height[i] &lt; height[j]: i += 1 else: j -= 1 return water java https://discuss.leetcode.com/topic/25004/easy-concise-java-o-n-solution-with-proof-and-explanation Easy Concise Java O(N) Solution with Proof and Explanation AKA, the general idea to find some max is to go through all cases where max value can possibly occur and keep updating the max value. The efficiency of the scan depends on the size of cases you plan to scan.To increase efficiency, all we need to do is to find a smart way of scan to cut off the useless cases and meanwhile 100% guarantee the max value can be reached through the rest of cases. In this problem, the smart scan way is to set two pointers initialized at both ends of the array. Every time move the smaller value pointer to inner array. Then after the two pointers meet, all possible max cases have been scanned and the max situation is 100% reached somewhere in the scan. Following is a brief prove of this. Given a1,a2,a3…..an as input array. Lets assume a10 and a20 are the max area situation. We need to prove that a10 can be reached by left pointer and during the time left pointer stays at a10, a20 can be reached by right pointer. That is to say, the core problem is to prove: when left pointer is at a10 and right pointer is at a21, the next move must be right pointer to a20. Since we are always moving the pointer with the smaller value, i.e. if a10 &gt; a21, we should move pointer at a21 to a20, as we hope. Why a10 &gt;a21? Because if a21&gt;a10, then area of a10 and a20 must be less than area of a10 and a21. Because the area of a10 and a21 is at least height[a10] (21-10) while the area of a10 and a20 is at most height[a10] (20-10). So there is a contradiction of assumption a10 and a20 has the max area. So, a10 must be greater than a21, then next move a21 has to be move to a20. The max cases must be reached. 123456789101112131415public int maxArea(int[] height) &#123; int left = 0, right = height.length - 1; int maxArea = 0; while (left &lt; right) &#123; maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left)); if (height[left] &lt; height[right]) left++; else right--; &#125; return maxArea;&#125; https://discuss.leetcode.com/topic/33498/java-3ms-solution-with-step-by-step-explanations-beats-85 Java 3ms solution with step-by-step explanations (beats 85%) It took me quite some time to finally optimize my solution from 21ms to 3ms :( If you have difficulty understanding the following code, check this link for a detailed explanation. 12345678910111213141516public int maxArea(int[] height) &#123; int L = height.length, lo = 0, hi = L-1; int max = 0; while(lo&lt;hi) &#123; int loMax = height[lo], hiMax = height[hi]; int candidate = (hi-lo) * (loMax&lt;hiMax ? loMax : hiMax); max = candidate &gt; max ? candidate : max; if(height[lo]&lt;=height[hi]) while(lo&lt;hi &amp;&amp; height[lo]&lt;=loMax) ++lo; else while(hi&gt;lo &amp;&amp; height[hi]&lt;=hiMax) --hi; &#125; return max;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[010. Regular Expression Matching]]></title>
    <url>%2Fp%2F34b0b346%2F</url>
    <content type="text"><![CDATA[23.9% https://leetcode.com/problems/regular-expression-matching/ 123456789101112131415161718Implement regular expression matching with support for &apos;.&apos; and &apos;*&apos;.&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;aa&quot;, &quot;.*&quot;) → trueisMatch(&quot;ab&quot;, &quot;.*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true 方法一： 优先考虑递归 递归方法 学习string的substr的用法 My concise recursive and DP solutions with full explanation in C++ Please refer to my blog post if you have any comment. Wildcard matching problem can be solved similarly. 12345678910111213class Solution &#123;public: bool isMatch(string s, string p) &#123; if (p.empty()) return s.empty(); if (&apos;*&apos; == p[1]) // x* matches empty string or at least one character: x* -&gt; xx* // *s is to ensure s is non-empty return (isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p)); else return !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; my code: 12345678910class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.empty()) return s.empty(); if(p.size()&gt;1 &amp;&amp; p[1]==&apos;*&apos;)&#123; return isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0]==p[0] || p[0]==&apos;.&apos;) &amp;&amp; isMatch(s.substr(1), p); &#125;else return !s.empty() &amp;&amp; (s[0]==p[0] || p[0]==&apos;.&apos;) &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; 我的代码实现二: 12345678910class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.empty()) return s.empty(); if(p.size()&gt;1 &amp;&amp; p[1]=='*') return isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0]==p[0] || p[0]=='.') &amp;&amp; isMatch(s.substr(1), p); // 要检查s是否为空，不能忘记 return !s.empty() &amp;&amp; (s[0]==p[0] || p[0]=='.') &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; 方法二： dp mn 设置(m+1) (n+1)的长度，多的一行表示空的时候的结果。 经常有上述做法。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: bool isMatch(string s, string p) &#123; /** * f[i][j]: if s[0..i-1] matches p[0..j-1] * if p[j - 1] != &apos;*&apos; * f[i][j] = f[i - 1][j - 1] &amp;&amp; s[i - 1] == p[j - 1] * if p[j - 1] == &apos;*&apos;, denote p[j - 2] with x * f[i][j] is true iff any of the following is true * 1) &quot;x*&quot; repeats 0 time and matches empty: f[i][j - 2] * 2) &quot;x*&quot; repeats &gt;= 1 times and matches &quot;x*x&quot;: s[i - 1] == x &amp;&amp; f[i - 1][j] * &apos;.&apos; matches any single character */ int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; f(m + 1, vector&lt;bool&gt;(n + 1, false)); f[0][0] = true; for (int i = 1; i &lt;= m; i++) f[i][0] = false; // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is &apos;*&apos; and p[0..j - 3] matches empty for (int j = 1; j &lt;= n; j++) f[0][j] = j &gt; 1 &amp;&amp; &apos;*&apos; == p[j - 1] &amp;&amp; f[0][j - 2]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (p[j - 1] != &apos;*&apos;) f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || &apos;.&apos; == p[j - 1]); else // p[0] cannot be &apos;*&apos; so no need to check &quot;j &gt; 1&quot; here f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || &apos;.&apos; == p[j - 2]) &amp;&amp; f[i - 1][j]; return f[m][n]; &#125;&#125;; 我的代码实现 : 与方法一类似 都是每次要么增长s，要么增长p 以当前位置是否为*作为判断条件 1234567891011121314151617181920class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.empty()) return s.empty(); int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=2; i&lt;=n; i++) dp[0][i] = p[i-1]=='*' &amp;&amp; dp[0][i-2]; for(int i=1; i&lt;=m; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; if(p[j-1]=='*') dp[i][j] = dp[i][j-2] || dp[i-1][j] &amp;&amp; (s[i-1]==p[j-2] || p[j-2]=='.'); else dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]=='.'); &#125; &#125; return dp[m][n]; &#125;&#125;; 相似题目：正则表达式匹配请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 方法一： 使用递归 123456789101112131415161718192021222324class Solution &#123;public: bool match(char* str, char* pattern) &#123; if(str==NULL || pattern==NULL) return false; return helper(str, pattern); &#125; bool helper(char* str, char* pattern)&#123; if(*str==&apos;\0&apos; &amp;&amp; *pattern==&apos;\0&apos;) return true; if(*str!=&apos;\0&apos; &amp;&amp; *pattern==&apos;\0&apos;) return false; if(*(pattern+1)==&apos;*&apos;)&#123; if(*pattern==*str || (*pattern==&apos;.&apos; &amp;&amp; *str!=&apos;\0&apos;))&#123; return helper(str+1, pattern+2) || helper(str+1, pattern) || helper(str, pattern+2); &#125;else&#123; return helper(str, pattern+2); &#125; &#125; if(*str==*pattern || (*pattern==&apos;.&apos; &amp;&amp; *str!=&apos;\0&apos;)) return helper(str+1, pattern+1); return false; &#125;&#125;; https://discuss.leetcode.com/topic/6183/my-concise-recursive-and-dp-solutions-with-full-explanation-in-c My concise recursive and DP solutions with full explanation in C++ Please refer to my blog post if you have any comment. Wildcard matching problem can be solved similarly. 递归方法 12345678910111213class Solution &#123;public: bool isMatch(string s, string p) &#123; if (p.empty()) return s.empty(); if (&apos;*&apos; == p[1]) // x* matches empty string or at least one character: x* -&gt; xx* // *s is to ensure s is non-empty return (isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p)); else return !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; dp： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: bool isMatch(string s, string p) &#123; /** * f[i][j]: if s[0..i-1] matches p[0..j-1] * if p[j - 1] != &apos;*&apos; * f[i][j] = f[i - 1][j - 1] &amp;&amp; s[i - 1] == p[j - 1] * if p[j - 1] == &apos;*&apos;, denote p[j - 2] with x * f[i][j] is true iff any of the following is true * 1) &quot;x*&quot; repeats 0 time and matches empty: f[i][j - 2] * 2) &quot;x*&quot; repeats &gt;= 1 times and matches &quot;x*x&quot;: s[i - 1] == x &amp;&amp; f[i - 1][j] * &apos;.&apos; matches any single character */ int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; f(m + 1, vector&lt;bool&gt;(n + 1, false)); f[0][0] = true; for (int i = 1; i &lt;= m; i++) f[i][0] = false; // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is &apos;*&apos; and p[0..j - 3] matches empty for (int j = 1; j &lt;= n; j++) f[0][j] = j &gt; 1 &amp;&amp; &apos;*&apos; == p[j - 1] &amp;&amp; f[0][j - 2]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (p[j - 1] != &apos;*&apos;) f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || &apos;.&apos; == p[j - 1]); else // p[0] cannot be &apos;*&apos; so no need to check &quot;j &gt; 1&quot; here f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || &apos;.&apos; == p[j - 2]) &amp;&amp; f[i - 1][j]; return f[m][n]; &#125;&#125;; 16ms, 60.02%, September 21, 2016 https://discuss.leetcode.com/topic/17852/9-lines-16ms-c-dp-solutions-with-explanations 9-lines 16ms C++ DP Solutions with Explanations This problem has a typical solution using Dynamic Programming. We define the state P[i][j] to be true if s[0..i) matches p[0..j) and false otherwise. Then the state equations are: P[i][j] = P[i - 1][j - 1], if p[j - 1] != ‘*’ &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == ‘.’); P[i][j] = P[i][j - 2], if p[j - 1] == ‘*’ and the pattern repeats for 0 times; P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == ‘.’), if p[j - 1] == ‘*’ and the pattern repeats for at least 1 times. Putting these together, we will have the following code. 1234567891011121314class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(), n = p.length(); vector&lt;vector&lt;bool&gt; &gt; dp(m + 1, vector&lt;bool&gt; (n + 1, false)); dp[0][0] = true; for (int i = 0; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (p[j - 1] == &apos;*&apos;) dp[i][j] = dp[i][j - 2] || (i &gt; 0 &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == &apos;.&apos;) &amp;&amp; dp[i - 1][j]); else dp[i][j] = i &gt; 0 &amp;&amp; dp[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;.&apos;); return dp[m][n]; &#125;&#125;; https://discuss.leetcode.com/topic/2818/the-shortest-ac-code The shortest AC code. 1.’.’ is easy to handle. if p has a ‘.’, it can pass any single character in s except ‘\0’. 2.’’ is a totally different problem. if p has a ‘’ character, it can pass any length of first-match characters in s including ‘\0’. 12345678910111213141516171819class Solution &#123; public: bool matchFirst(const char *s, const char *p)&#123; return (*p == *s || (*p == &apos;.&apos; &amp;&amp; *s != &apos;\0&apos;)); &#125;bool isMatch(const char *s, const char *p) &#123; if (*p == &apos;\0&apos;) return *s == &apos;\0&apos;; //empty if (*(p + 1) != &apos;*&apos;) &#123;//without * if(!matchFirst(s,p)) return false; return isMatch(s + 1, p + 1); &#125; else &#123; //next: with a * if(isMatch(s, p + 2)) return true; //try the length of 0 while ( matchFirst(s,p) ) //try all possible lengths if (isMatch(++s, p + 2))return true; &#125;&#125;&#125;; https://discuss.leetcode.com/topic/21370/my-4ms-c-dp-solution-another-recursive-version-also-given-72ms My 4ms C++ DP solution (another recursive version also given 72ms) Just to build a DP table checked, where checked[i][j] indicates whether s[0..i-1] matches with p[0..j-1]. The recursive relationship is as below: To match with the empty string s[0..0] (i.e. to make checked[0][j]), P[0..j-1] has to meet: p[j-1]==’*’ (to cancel p[j-2]) and checked[0][j-2] == true; To match with the string s[0..i-1] (i.e. to make checked[i][j]), P[0..j-1] has to meet: if p[j-1] ==’*’, then j must be larger than 1 (j&gt;1) and checked[i][j-2] (i.e. p[j-2] cancelled by ‘*’) checked[i-1][j] &amp;&amp; (s[i-1] ==p[j-2] || p[j-2] ==’.’) (s[i-1] matches with p[j-2] or ‘.’, ) if p[j-1] !=’*’, checked[i-1][j-1] &amp;&amp; (s[i-1] ==p[j-1] || p[j-1] ==’.’)(i.e. s[i-1] matches with p[j-1] or ‘.’) 123456789101112131415161718192021class Solution &#123; public: bool isMatch(string s, string p) &#123; int sSize = s.size(), pSize = p.size(), i, j; bool checked[sSize+1][pSize+1]; // fill_n(&amp;matched[0][0], (sSize+1)*(pSize+1), false); for(j=2, checked[0][0]=true, checked[0][1]= false; j&lt;=pSize; ++j) // match s[0..0] checked[0][j] = p[j-1] == &apos;*&apos;? checked[0][j-2] : false; for(i=1; i&lt;=sSize; ++i) for(j=1, checked[i][0]=false; j&lt;=pSize; ++j) &#123; if(p[j-1]==&apos;*&apos;) // case (1) checked[i][j] = (j&gt;1) &amp;&amp; ( checked[i][j-2] || ( ( checked[i-1][j]) &amp;&amp; (s[i-1]== p[j-2] || p[j-2] == &apos;.&apos;)) ); else // case (2) checked[i][j] = checked[i-1][j-1] &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == &apos;.&apos;); &#125; return checked[sSize][pSize]; &#125; &#125;; A recursive version, divide cases into two groups (if the next p char is ‘*’ or not) 123456789101112131415161718192021222324class Solution &#123;private: bool helper(const string &amp;s, const string &amp;p, int sS, int pS) &#123; int sSize = s.size(), pSize = p.size(), i, j; if(pS==pSize) return sS ==sSize; // if p goes to its end, then only if s also goes to its end to return true; if(p[pS+1]!=&apos;*&apos;) &#123; if( sS&lt;sSize &amp;&amp; (p[pS]==s[sS] || p[pS] == &apos;.&apos;)) return helper(s, p, sS+1, pS+1); &#125; else &#123; if(helper(s, p, sS,pS+2)) return true; while(sS&lt;sSize &amp;&amp; (p[pS]==s[sS] || p[pS] == &apos;.&apos;)) if(helper(s,p, ++sS, pS+2)) return true; &#125; return false; &#125;public: bool isMatch(string s, string p) &#123; helper(s, p, 0, 0); &#125;&#125;; python https://discuss.leetcode.com/topic/22948/my-dp-approach-in-python-with-comments-and-unittest My DP approach in Python with comments and unittest I shared my DP approach with comments and provided some unit tests for it. Some statements in the approach directly affect some corner cases, for example, comment out line 22-23, then the unittest test_symbol_0 will fail. Hope this script helps us better understand the problem. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import unittestclass Solution(object): def isMatch(self, s, p): # The DP table and the string s and p use the same indexes i and j, but # table[i][j] means the match status between p[:i] and s[:j], i.e. # table[0][0] means the match status of two empty strings, and # table[1][1] means the match status of p[0] and s[0]. Therefore, when # refering to the i-th and the j-th characters of p and s for updating # table[i][j], we use p[i - 1] and s[j - 1]. # Initialize the table with False. The first row is satisfied. table = [[False] * (len(s) + 1) for _ in range(len(p) + 1)] # Update the corner case of matching two empty strings. table[0][0] = True # Update the corner case of when s is an empty string but p is not. # Since each &apos;*&apos; can eliminate the charter before it, the table is # vertically updated by the one before previous. [test_symbol_0] for i in range(2, len(p) + 1): table[i][0] = table[i - 2][0] and p[i - 1] == &apos;*&apos; for i in range(1, len(p) + 1): for j in range(1, len(s) + 1): if p[i - 1] != &quot;*&quot;: # Update the table by referring the diagonal element. table[i][j] = table[i - 1][j - 1] and \ (p[i - 1] == s[j - 1] or p[i - 1] == &apos;.&apos;) else: # Eliminations (referring to the vertical element) # Either refer to the one before previous or the previous. # I.e. * eliminate the previous or count the previous. # [test_symbol_1] table[i][j] = table[i - 2][j] or table[i - 1][j] # Propagations (referring to the horizontal element) # If p&apos;s previous one is equal to the current s, with # helps of *, the status can be propagated from the left. # [test_symbol_2] if p[i - 2] == s[j - 1] or p[i - 2] == &apos;.&apos;: table[i][j] |= table[i][j - 1] return table[-1][-1]class TestSolution(unittest.TestCase): def test_none_0(self): s = &quot;&quot; p = &quot;&quot; self.assertTrue(Solution().isMatch(s, p)) def test_none_1(self): s = &quot;&quot; p = &quot;a&quot; self.assertFalse(Solution().isMatch(s, p)) def test_no_symbol_equal(self): s = &quot;abcd&quot; p = &quot;abcd&quot; self.assertTrue(Solution().isMatch(s, p)) def test_no_symbol_not_equal_0(self): s = &quot;abcd&quot; p = &quot;efgh&quot; self.assertFalse(Solution().isMatch(s, p)) def test_no_symbol_not_equal_1(self): s = &quot;ab&quot; p = &quot;abb&quot; self.assertFalse(Solution().isMatch(s, p)) def test_symbol_0(self): s = &quot;&quot; p = &quot;a*&quot; self.assertTrue(Solution().isMatch(s, p)) def test_symbol_1(self): s = &quot;a&quot; p = &quot;ab*&quot; self.assertTrue(Solution().isMatch(s, p)) def test_symbol_2(self): # E.g. # s a b b # p 1 0 0 0 # a 0 1 0 0 # b 0 0 1 0 # * 0 1 1 1 s = &quot;abb&quot; p = &quot;ab*&quot; self.assertTrue(Solution().isMatch(s, p))if __name__ == &quot;__main__&quot;: unittest.main() https://discuss.leetcode.com/topic/6739/fast-python-solution-with-backtracking-and-caching-dp-solution Fast Python solution with backtracking and caching + DP solution Takes about 174ms: 123456789101112131415161718cache = &#123;&#125;def isMatch(self, s, p): if (s, p) in self.cache: return self.cache[(s, p)] if not p: return not s if p[-1] == &apos;*&apos;: if self.isMatch(s, p[:-2]): self.cache[(s, p)] = True return True if s and (s[-1] == p[-2] or p[-2] == &apos;.&apos;) and self.isMatch(s[:-1], p): self.cache[(s, p)] = True return True if s and (p[-1] == s[-1] or p[-1] == &apos;.&apos;) and self.isMatch(s[:-1], p[:-1]): self.cache[(s, p)] = True return True self.cache[(s, p)] = False return False DP version: 1234567891011121314def isMatch(self, s, p): dp = [[False] * (len(s) + 1) for _ in range(len(p) + 1)] dp[0][0] = True for i in range(1, len(p)): dp[i + 1][0] = dp[i - 1][0] and p[i] == &apos;*&apos; for i in range(len(p)): for j in range(len(s)): if p[i] == &apos;*&apos;: dp[i + 1][j + 1] = dp[i - 1][j + 1] or dp[i][j + 1] if p[i - 1] == s[j] or p[i - 1] == &apos;.&apos;: dp[i + 1][j + 1] |= dp[i + 1][j] else: dp[i + 1][j + 1] = dp[i][j] and (p[i] == s[j] or p[i] == &apos;.&apos;) return dp[-1][-1] https://discuss.leetcode.com/topic/40371/easy-dp-java-solution-with-detailed-explanation Easy DP Java Solution with detailed Explanation This Solution use 2D DP. beat 90% solutions, very simple. Here are some conditions to figure out, then the logic can be very straightforward. 1234567891, If p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1];2, If p.charAt(j) == &apos;.&apos; : dp[i][j] = dp[i-1][j-1];3, If p.charAt(j) == &apos;*&apos;: here are two sub conditions: 1 if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty 2 if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == &apos;.&apos;: dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a or dp[i][j] = dp[i][j-1] // in this case, a* counts as single a or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty Here is the solution 12345678910111213141516171819202122232425262728293031public boolean isMatch(String s, String p) &#123; if (s == null || p == null) &#123; return false; &#125; boolean[][] dp = new boolean[s.length()+1][p.length()+1]; dp[0][0] = true; for (int i = 0; i &lt; p.length(); i++) &#123; if (p.charAt(i) == &apos;*&apos; &amp;&amp; dp[0][i-1]) &#123; dp[0][i+1] = true; &#125; &#125; for (int i = 0 ; i &lt; s.length(); i++) &#123; for (int j = 0; j &lt; p.length(); j++) &#123; if (p.charAt(j) == &apos;.&apos;) &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == s.charAt(i)) &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == &apos;*&apos;) &#123; if (p.charAt(j-1) != s.charAt(i) &amp;&amp; p.charAt(j-1) != &apos;.&apos;) &#123; dp[i+1][j+1] = dp[i+1][j-1]; &#125; else &#123; dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]); &#125; &#125; &#125; &#125; return dp[s.length()][p.length()];&#125; https://discuss.leetcode.com/topic/12289/clean-java-solution Clean Java Solution 1234567891011121314151617181920212223public boolean isMatch(String s, String p) &#123; if (p.isEmpty()) &#123; return s.isEmpty(); &#125; if (p.length() == 1 || p.charAt(1) != &apos;*&apos;) &#123; if (s.isEmpty() || (p.charAt(0) != &apos;.&apos; &amp;&amp; p.charAt(0) != s.charAt(0))) &#123; return false; &#125; else &#123; return isMatch(s.substring(1), p.substring(1)); &#125; &#125; //P.length() &gt;=2 while (!s.isEmpty() &amp;&amp; (s.charAt(0) == p.charAt(0) || p.charAt(0) == &apos;.&apos;)) &#123; if (isMatch(s, p.substring(2))) &#123; return true; &#125; s = s.substring(1); &#125; return isMatch(s, p.substring(2));&#125; https://discuss.leetcode.com/topic/2601/my-ac-dp-solution-for-this-problem-asking-for-improvements My AC DP solution for this problem, asking for improvements. 123456789101112131415161718192021222324252627282930public boolean isMatch(String s, String p) &#123; int m = s.length(); int n = p.length(); if (s == null || p == null) &#123; return false; &#125; boolean[][] OPT = new boolean[m+1][n+1]; OPT[0][0] = true; for (int i = 1; i &lt;= m; i++) &#123; OPT[i][0] = false; &#125; for (int j = 1; j &lt;= n; j++) &#123; OPT[0][j] = (p.charAt(j-1) == &apos;*&apos;) &amp;&amp; (j-2 &gt;= 0) &amp;&amp; OPT[0][j-2]; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; OPT[i][j] = ((OPT[i-1][j-1]) &amp;&amp; equals(s, p, i-1, j-1)) || ((OPT[i-1][j] || OPT[i][j-1]) &amp;&amp; (p.charAt(j-1) == &apos;*&apos;) &amp;&amp; equals(s, p, i-1, j-2)) || ((p.charAt(j-1) == &apos;*&apos;) &amp;&amp; (j-2 &gt;= 0) &amp;&amp; OPT[i][j-2]); &#125; &#125; return OPT[m][n];&#125; private boolean equals(String s, String p, int si, int pi) { return (s.charAt(si) == p.charAt(pi) || p.charAt(pi) == ‘.’);}Basically, the OPT[i][j] means preceding substring of length i of s and length j of p. For any two substrings, the value of OPT[i][j] can be from one of following four cases: case 1: OPT[i-1][j-1] is true, and ith character of s is equal to j th character of p. Or j th character of p is ‘.’ case 2: OPT[i-1][j] is true, then my pattern now is ‘*’ and preceding character is equal to incoming character of s case 3: OPT[i][j-1] is true, then my pattern now is ‘*’ which can match an empty string case 4: OPT[i][j-2] is true, and the pattern like (a*) matches an empty stringbase case is the OPT[0][0], OPT[i][0], OPT[0][j]. https://discuss.leetcode.com/topic/2601/my-ac-dp-solution-for-this-problem-asking-for-improvements/2 I found I was using the exact algorithm as you did. So I post one for your references.It has no additional brace. It is very difficult to write a pretty code in string operations by Java due to .charAt(). By the way Your value assignment in the nested loop is indeed a pain to read(At least for me ). I do suggest you to give more lines on that part. 1234567891011121314151617181920212223242526272829303132333435363738public class RegularExpressionMatching &#123; public boolean isMatch(String s, String p) &#123; if (s==null&amp;&amp;p==null) return true; if (s.length()==0&amp;&amp;p.length()==0) return true; boolean[][] matrix = new boolean[s.length()+1][p.length()+1]; matrix[0][0]=true; for (int i=1;i&lt;=s.length();i++) matrix[i][0]=false; for (int j=1;j&lt;=p.length();j++) if (p.charAt(j-1)==&apos;*&apos;&amp;&amp;j&gt;1) matrix[0][j]=matrix[0][j-2]; else matrix[0][j]=false; for (int i=1;i&lt;=s.length();i++) for (int j=1;j&lt;=p.length();j++) if (p.charAt(j-1)==s.charAt(i-1)||p.charAt(j-1)==&apos;.&apos;) matrix[i][j]=matrix[i-1][j-1]; else if (p.charAt(j-1)==&apos;*&apos;&amp;&amp;j&gt;1) if (p.charAt(j-2)==s.charAt(i-1)||p.charAt(j-2)==&apos;.&apos;) matrix[i][j]=matrix[i-1][j]||matrix[i][j-2]||matrix[i][j-1]; //matrix[i-1][j]:abb vs ab*: depends on ab vs ab* //matrix[i][j-2] a vs ab* depends on a vs a //matrix[i][j-1] ab vs ab*: depends on ab vs ab else matrix[i][j]=matrix[i][j-2]; else matrix[i][j]=false; return matrix[s.length()][p.length()]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[009. Palindrome Number]]></title>
    <url>%2Fp%2Fc3ad93e8%2F</url>
    <content type="text"><![CDATA[35.4% https://leetcode.com/problems/palindrome-number/ Determine whether an integer is a palindrome. Do this without extra space. click to show spoilers. Some hints:Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 方法一： 先特殊情况，负数，最后一位为0且数值不等于0，排除。 然后翻转得到值 判断情况，相等，或者等于rev/10，这是因为只走了一半 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0 || x != 0 &amp;&amp; x%10 == 0) return false; int rev = 0; while(x &gt; rev)&#123; rev = rev * 10 + x % 10; x = x / 10; &#125; return (x == rev || x == rev / 10); &#125;&#125;; 我的代码实现一： 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0 || x&gt;0 &amp;&amp; x%10==0) return false; // 排除10， 100，1000这种情况 int rev = 0; while(rev&lt;x)&#123; rev = rev*10 + x%10; x /= 10; &#125; return rev == x || rev/10 == x; &#125;&#125;; 我的代码实现二： 1234567891011121314class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0 || x!=0 &amp;&amp; x%10 == 0) return false; int y = 0; while(y&lt;x)&#123; y = y*10 + x%10; x /= 10; &#125; // 注意此处该/还是% return x==y || x==y/10; &#125;&#125;; https://discuss.leetcode.com/topic/31602/this-problem-is-meanless This problem is meanless Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack. If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space. https://discuss.leetcode.com/topic/3151/2147447412-is-not-a-palindromic-number -2147447412 is not a palindromic number I am wondering how the other people got their code ACed, the testing result of “-2147447412” seems a little odd to me. Should it be a palindromic number or not? Note: I believe the range of int is [-2147483648, 2147483647] and “-2147447412” is not overflowed, plus I handled the overflow cases already (test case “-2147483648” in particular). 11499 / 11502 test cases passed. Status: Wrong Answer Input: -2147447412 Output: true Expected: false Here’s my second question: Why does the function take “int” as input instead of “unsigned int”, when we assume all negative numbers are NOT palindromic. java https://leetcode.com/discuss/23563/line-accepted-java-code-without-the-need-handling-overflow 9-line accepted Java code, without the need of handling overflow 12ms, 46.14%, May.4th, 2016 compare half of the digits in x, so don’t need to deal with overflow. 123456789public boolean isPalindrome(int x) &#123; if (x&lt;0 || (x!=0 &amp;&amp; x%10==0)) return false; int rev = 0; while (x&gt;rev)&#123; rev = rev*10 + x%10; x = x/10; &#125; return (x==rev || x==rev/10);&#125; https://discuss.leetcode.com/topic/9477/o-1-space-o-lgn-time-java-solution-no-overflow-risk O(1) space, O(lgn) time java solution, no overflow risk 123456789101112131415public boolean isPalindrome(int x) &#123; if (x &lt; 0) return false; int p = x; int q = 0; while (p &gt;= 10)&#123; q *=10; q += p%10; p /=10; &#125; return q == x / 10 &amp;&amp; p == x % 10;&#125; so the reversed version of int is always 1 time short in the factor of 10s . in case of Int16, check 63556 will finally check if (6553 == 6355 &amp;&amp; 6 == 63556%10) so there will have no concerns about the overflow. https://discuss.leetcode.com/topic/3879/neat-ac-java-code-o-n-time-complexity Neat AC java code. O(n) time complexity. 123456789public boolean isPalindrome(int x) &#123; int palindromeX = 0; int inputX = x; while(x&gt;0)&#123; palindromeX = palindromeX*10 + (x % 10); x = x/10; &#125; return palindromeX==inputX; &#125; https://discuss.leetcode.com/topic/39795/simple-java-o-1-space-solution Simple JAVA O(1) space solution 12345678910public boolean isPalindrome(int x) &#123; if(x&lt;0 || (x!=0 &amp;&amp; x%10==0)) return false; int res = 0; while(x&gt;res)&#123; res = res*10 + x%10; x = x/10; &#125; return (x==res || x==res/10);&#125; cpp https://leetcode.com/discuss/33500/an-easy-lines-code-only-reversing-till-half-and-then-compare An easy c++ 8 lines code (only reversing till half and then compare) 76ms, 65.37%, May.4th, 2016 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0 || x != 0 &amp;&amp; x%10 == 0) return false; int rev = 0; while(x &gt; rev)&#123; rev = rev * 10 + x % 10; x = x / 10; &#125; return (x == rev || x == rev / 10); &#125;&#125;; https://discuss.leetcode.com/topic/39259/7-line-simple-c-solution-beats-90-submissions-in-o-1-space-two-pointers 7 line simple C++ solution beats 90% submissions in O(1) space, two pointers Use two pointers concept, find the half point, and compare first half and 2nd half. Variable revhalf is the reversed 2nd half(x has even number of digits), or 2nd half with the middle digit(if x has odd number of digits) 12345678910111213class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0) return false; int revhalf = 0, slow = x, fast = x; while(fast)&#123; revhalf = revhalf * 10 + slow % 10; slow /= 10; fast /= 100; &#125; return slow == revhalf || slow == revhalf / 10; &#125;&#125;; https://discuss.leetcode.com/topic/18921/my-c-solution My C++ solution.. 1234567891011121314151617bool isPalindrome(int x) &#123; if(x&lt;0) return false; int num=x; int a=0; while(x) &#123; a=a*10 + x%10; x=x/10; &#125; if(a==num) return true; else return false; &#125; python 272ms, 66.06%, May.4th, 2016 https://leetcode.com/discuss/82355/5-line-python-solution-248ms 1234567891011class Solution(object): def isPalindrome(self, x): &quot;&quot;&quot; :type x: int :rtype: bool &quot;&quot;&quot; if x &lt; 0 or (x &gt; 0 and x % 10 == 0): return False half = 0 while x &gt; half: half, x = half * 10 + x % 10, x / 10 return x in (half, half / 10)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[008. String to Integer (atoi)]]></title>
    <url>%2Fp%2F7d4ee2b3%2F</url>
    <content type="text"><![CDATA[14.0% https://leetcode.com/problems/string-to-integer-atoi/ Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. spoilers alert… click to show requirements for atoi. Requirements for atoi: The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. https://discuss.leetcode.com/topic/35270/such-a-shitty-problem Such a shitty problem The description is not clear not all unless you click on the hint. What’s the point of testing all the “+-1” or “-+1” without any input spec nor any situation where input is obtained. 方法一： 如下代码，从第一个非 ‘ ‘开始，然后正负号，然后每个进行判别，考虑与最大最小值的差异。 string的函数方法find_first_not_of(‘ ‘) 1234567891011121314151617int myAtoi(string str) &#123; long result = 0; int indicator = 1; for(int i = 0; i&lt;str.size();) &#123; i = str.find_first_not_of(&apos; &apos;); if(str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) indicator = (str[i++] == &apos;-&apos;)? -1 : 1; while(&apos;0&apos;&lt;= str[i] &amp;&amp; str[i] &lt;= &apos;9&apos;) &#123; result = result*10 + (str[i++]-&apos;0&apos;); if(result*indicator &gt;= INT_MAX) return INT_MAX; if(result*indicator &lt;= INT_MIN) return INT_MIN; &#125; return result*indicator; &#125;&#125; 我优化后的代码实现： 123456789101112131415161718class Solution &#123;public: int myAtoi(string str) &#123; long result = 0; int indicator = 1; int i = 0; i = str.find_first_not_of(' '); if(str[i] == '-' || str[i] == '+') indicator = (str[i++] == '-')? -1 : 1; while('0'&lt;= str[i] &amp;&amp; str[i] &lt;= '9') &#123; result = result*10 + (str[i++]-'0'); if(result*indicator &gt;= INT_MAX) return INT_MAX; if(result*indicator &lt;= INT_MIN) return INT_MIN; &#125; return result*indicator; &#125;&#125;; 我的代码实现： 注意里面的坑，处理整数int数字，一定要注意溢出问题，所以这样的，反转的等等，一定要用long 不用int，而是用long，处理溢出问题，此处要特别注意。 123456789101112131415161718class Solution &#123;public: int myAtoi(string str) &#123; if(str.empty()) return 0; int flag = 1; int i = 0; i = str.find_first_not_of(' '); if(str[i]=='+' || str[i]=='-') flag = (str[i++]=='-') ? -1 : 1; long base = 0; // 此处一定要用long while(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9')&#123; base = base*10 + (str[i++]-'0'); if(base*flag &gt;= INT_MAX) return INT_MAX; if(base*flag &lt;= INT_MIN) return INT_MIN; &#125; return flag*base; &#125;&#125;; 我的代码实现： 对于int可能溢出的题目，就用long long 123456789101112131415161718192021class Solution &#123;public: int myAtoi(string str) &#123; long long res = 0; int i = str.find_first_not_of(' '); int flag = 1; if(str[i] == '+')&#123; flag = 1; i++; &#125;else if(str[i]=='-')&#123; flag = -1; i++; &#125; while(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9')&#123; res = res*10 + str[i++] - '0'; if(flag*res &gt; INT_MAX) return INT_MAX; if(flag*res &lt; INT_MIN) return INT_MIN; &#125; return flag*res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/15891/8ms-c-solution-easy-to-understand 8ms C++ solution, easy to understand 12ms, 15.61%, August 31, 2016 1234567891011121314151617int myAtoi(string str) &#123; long result = 0; int indicator = 1; for(int i = 0; i&lt;str.size();) &#123; i = str.find_first_not_of(&apos; &apos;); if(str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) indicator = (str[i++] == &apos;-&apos;)? -1 : 1; while(&apos;0&apos;&lt;= str[i] &amp;&amp; str[i] &lt;= &apos;9&apos;) &#123; result = result*10 + (str[i++]-&apos;0&apos;); if(result*indicator &gt;= INT_MAX) return INT_MAX; if(result*indicator &lt;= INT_MIN) return INT_MIN; &#125; return result*indicator; &#125;&#125; https://discuss.leetcode.com/topic/29207/8-line-c-concise-solution 8 line C++ concise solution 12345678910int myAtoi(string str) &#123; int ret = 0, sign = 1, i = str.find_first_not_of(&apos; &apos;), base = INT_MAX / 10; if (str[i] == &apos;+&apos; || str[i] == &apos;-&apos;) sign = str[i++] == &apos;+&apos; ?: -1; while (isdigit(str[i])) &#123; if (ret &gt; base || (ret == base &amp;&amp; str[i] - &apos;0&apos; &gt; 7)) return sign &gt; 0 ? INT_MAX : INT_MIN; ret = 10 * ret + (str[i++] - &apos;0&apos;); &#125; return sign * ret;&#125; https://discuss.leetcode.com/topic/32966/c-10-lines-solution-easy-understanding-clean-code C++ 10 lines solution, easy understanding, clean code 12345678910111213int myAtoi(string str) &#123; if (str.empty()) return 0; int i = 0, sign = 1; while (i + 1 &lt; str.size() &amp;&amp; isspace(str[i])) ++i; long res = 0; if (str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) sign = 44 - str[i++]; while (i &lt; str.size()) &#123; if (isdigit(str[i])) res = 10 * res + str[i++] - &apos;0&apos;; else return res * sign; if (res &gt; INT_MAX) return sign == -1 ? INT_MIN : INT_MAX; &#125; return res * sign;&#125; python https://discuss.leetcode.com/topic/10740/python-solution-based-on-regex Python solution based on RegEx 123456789101112131415161718class Solution: # @return an integer def atoi(self, str): str = str.strip() str = re.findall(&apos;(^[\+\-0]*\d+)\D*&apos;, str) try: result = int(&apos;&apos;.join(str)) MAX_INT = 2147483647 MIN_INT = -2147483648 if result &gt; MAX_INT &gt; 0: return MAX_INT elif result &lt; MIN_INT &lt; 0: return MIN_INT else: return result except: return 0 https://discuss.leetcode.com/topic/26920/60ms-python-solution-oj-says-this-beats-100-python-submissions 60ms python solution; OJ says this beats 100% python submissions 12345678910111213141516171819class Solution(object): def myAtoi(self, s): &quot;&quot;&quot; :type str: str :rtype: int &quot;&quot;&quot; ###better to do strip before sanity check (although 8ms slower): #ls = list(s.strip()) #if len(ls) == 0 : return 0 if len(s) == 0 : return 0 ls = list(s.strip()) sign = -1 if ls[0] == &apos;-&apos; else 1 if ls[0] in [&apos;-&apos;,&apos;+&apos;] : del ls[0] ret, i = 0, 0 while i &lt; len(ls) and ls[i].isdigit() : ret = ret*10 + ord(ls[i]) - ord(&apos;0&apos;) i += 1 return max(-2**31, min(sign * ret,2**31-1)) java https://discuss.leetcode.com/topic/2666/my-simple-solution My simple solution I think we only need to handle four cases: discards all leading whitespaces sign of the number overflow invalid input Is there any better solution? Thanks for pointing out! 123456789101112131415int atoi(const char *str) &#123; int sign = 1, base = 0, i = 0; while (str[i] == &apos; &apos;) &#123; i++; &#125; if (str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) &#123; sign = 1 - 2 * (str[i++] == &apos;-&apos;); &#125; while (str[i] &gt;= &apos;0&apos; &amp;&amp; str[i] &lt;= &apos;9&apos;) &#123; if (base &gt; INT_MAX / 10 || (base == INT_MAX / 10 &amp;&amp; str[i] - &apos;0&apos; &gt; 7)) &#123; if (sign == 1) return INT_MAX; else return INT_MIN; &#125; base = 10 * base + (str[i++] - &apos;0&apos;); &#125; return base * sign;&#125; https://discuss.leetcode.com/topic/12473/java-solution-with-4-steps-explanations 3ms, August 31, 2016 Java Solution with 4 steps explanations 1234567891011121314151617181920212223242526272829public int myAtoi(String str) &#123; int index = 0, sign = 1, total = 0; //1. Empty string if(str.length() == 0) return 0; //2. Remove Spaces while(str.charAt(index) == &apos; &apos; &amp;&amp; index &lt; str.length()) index ++; //3. Handle signs if(str.charAt(index) == &apos;+&apos; || str.charAt(index) == &apos;-&apos;)&#123; sign = str.charAt(index) == &apos;+&apos; ? 1 : -1; index ++; &#125; //4. Convert number and avoid overflow while(index &lt; str.length())&#123; int digit = str.charAt(index) - &apos;0&apos;; if(digit &lt; 0 || digit &gt; 9) break; //check if total will be overflow after 10 times and add digit if(Integer.MAX_VALUE/10 &lt; total || Integer.MAX_VALUE/10 == total &amp;&amp; Integer.MAX_VALUE %10 &lt; digit) return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; total = 10 * total + digit; index ++; &#125; return total * sign;&#125; https://discuss.leetcode.com/topic/33142/java-easy-version-to-understand JAVA——-Easy Version To Understand!!!!!!!!!! 1234567891011121314151617181920212223242526public static int myAtoi(String str) &#123; if (str == null || str.length() == 0) return 0;// str = str.trim(); char firstChar = str.charAt(0); int sign = 1, start = 0, len = str.length(); long sum = 0; if (firstChar == &apos;+&apos;) &#123; sign = 1; start++; &#125; else if (firstChar == &apos;-&apos;) &#123; sign = -1; start++; &#125; for (int i = start; i &lt; len; i++) &#123; if (!Character.isDigit(str.charAt(i))) return (int) sum * sign; sum = sum * 10 + str.charAt(i) - &apos;0&apos;; if (sign == 1 &amp;&amp; sum &gt; Integer.MAX_VALUE) return Integer.MAX_VALUE; if (sign == -1 &amp;&amp; (-1) * sum &lt; Integer.MIN_VALUE) return Integer.MIN_VALUE; &#125; return (int) sum * sign;&#125; https://discuss.leetcode.com/topic/37311/my-nice-java-code-3ms My Nice Java Code 3ms 123456789101112131415161718192021public class Solution &#123; public int myAtoi(String str) &#123; if (str.isEmpty()) return 0; str = str.trim(); int i = 0, ans = 0, sign = 1, len = str.length(); if (str.charAt(i) == &apos;-&apos; || str.charAt(i) == &apos;+&apos;) sign = str.charAt(i++) == &apos;+&apos; ? 1 : -1; for (; i &lt; len; ++i) &#123; int tmp = str.charAt(i) - &apos;0&apos;; if (tmp &lt; 0 || tmp &gt; 9) break; if (ans &gt; Integer.MAX_VALUE / 10 || (ans == Integer.MAX_VALUE / 10 &amp;&amp; Integer.MAX_VALUE % 10 &lt; tmp)) return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; else ans = ans * 10 + tmp; &#125; return sign * ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[007. Reverse Integer]]></title>
    <url>%2Fp%2Ff2b740bb%2F</url>
    <content type="text"><![CDATA[23.8% https://leetcode.com/problems/reverse-integer/ Reverse digits of an integer. 12Example1: x = 123, return 321Example2: x = -123, return -321 click to show spoilers. Have you thought about this? Here are some good questions to ask before coding. Bonus points for you if you have already thought through this! If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100. Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases? For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Update (2014-11-10): Test cases had been added to test the overflow behavior. 如果为负数，是怎么样的情形呢？ 1234567-78 / 10 = -7 -78 % 10 = -8-78 / 100 = 0-78 % 100 = 78-9 / 10 = 0-9 % 10 = -9 方法一： 考虑负数和0的情况 Shortest code possible in c++ long long make res a 64 bit number, the overflow is checked. 1234567891011class Solution &#123;public: int reverse(int x) &#123; long long res = 0; while(x) &#123; res = res*10 + x%10; x /= 10; &#125; return (res&lt;INT_MIN || res&gt;INT_MAX) ? 0 : res; &#125;&#125;; 我的代码实现及注意事项 1234567891011class Solution &#123;public: int reverse(int x) &#123; long long res = 0; // 此处要用long long，因为int会溢出 while(x)&#123; res = res*10 + x%10; x /= 10; &#125; return (res&lt;INT_MIN || res&gt;INT_MAX)?0:res; // 括号最好不要省略，不然可能会出问题 &#125;&#125;; 我的代码实现二: 1234567891011121314class Solution &#123;public: int reverse(int x) &#123; // 用到大数的时候一定要记得用long long // 虽然给的是int，但是我们依然要用long long long long res = 0; while(x!=0)&#123; res = res*10 + x%10; x /= 10; &#125; // 下面最好加括号，以示区分，虽然不要括号也能正确运行 return (res&lt;INT_MIN || res&gt;INT_MAX) ? 0 : res; &#125;&#125;; 方法二： 边走边检查边界 8 ms simple C++ solution which checks overflow 8ms, 49.31%, 17 July 2016 123456789101112131415class Solution &#123;public: int reverse(int x) &#123; int ans = 0; while(x)&#123; int temp = ans * 10 + x % 10; if(temp / 10 != ans) return 0; ans = temp; x /= 10; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/6005/shortest-code-possible-in-c Shortest code possible in c++ long long make res a 64 bit number, the overflow is checked. 1234567891011class Solution &#123;public: int reverse(int x) &#123; long long res = 0; while(x) &#123; res = res*10 + x%10; x /= 10; &#125; return (res&lt;INT_MIN || res&gt;INT_MAX) ? 0 : res; &#125;&#125;; https://discuss.leetcode.com/topic/34506/8-ms-simple-c-solution-which-checks-overflow 8 ms simple C++ solution which checks overflow 8ms, 49.31%, 17 July 2016 123456789101112131415class Solution &#123;public: int reverse(int x) &#123; int ans = 0; while(x)&#123; int temp = ans * 10 + x % 10; if(temp / 10 != ans) return 0; ans = temp; x /= 10; &#125; return ans; &#125;&#125;; python https://discuss.leetcode.com/topic/15832/golfing-in-python Golfing in Python Get the sign, get the reversed absolute integer, and return their product if r didn’t “overflow”. 1234def reverse(self, x): s = cmp(x, 0) r = int(`s*x`[::-1]) return s*r * (r &lt; 2**31) As compressed one-liner, for potential comparison: 12def reverse(self, x): s=cmp(x,0);r=int(`s*x`[::-1]);return(r&lt;2**31)*s*r Anybody got something shorter? 12345678910111268ms, 50.07%, 17 July 2016class Solution(object): def reverse(self, x): &quot;&quot;&quot; :type x: int :rtype: int &quot;&quot;&quot; x = (-1 if x &lt; 0 else 1) * int(str(abs(x))[::-1]) if (x &lt; 2**31 - 1) and (x &gt; -2**31 + 1): return x else: return 0 c https://discuss.leetcode.com/topic/12975/a-simple-c-solution-with-5ms A simple C solution with 5ms 12345678910int reverse(int x) &#123; long long val = 0; do &#123; val = val * 10 + x % 10; x /= 10; &#125; while (x); return (val &gt; INT_MAX || val &lt; INT_MIN) ? 0 : val;&#125; java https://discuss.leetcode.com/topic/6104/my-accepted-15-lines-of-code-for-java My accepted 15 lines of code for Java Only 15 lines. If overflow exists, the new result will not equal previous one. No flags needed. No hard code like 0xf7777777 needed. Sorry for my bad english. 12345678910111213141516public int reverse(int x)&#123; int result = 0; while (x != 0) &#123; int tail = x % 10; int newResult = result * 10 + tail; if ((newResult - tail) / 10 != result) &#123; return 0; &#125; result = newResult; x = x / 10; &#125; return result;&#125; https://discuss.leetcode.com/topic/15134/very-short-7-lines-and-elegant-solution Very Short (7 lines) and Elegant Solution 2ms, 48.43%, 17 July 2016 123456789101112public class Solution &#123; public int reverse(int x) &#123; long rev= 0; while( x != 0)&#123; rev= rev*10 + x % 10; x= x/10; if( rev &gt; Integer.MAX_VALUE || rev &lt; Integer.MIN_VALUE) return 0; &#125; return (int) rev; &#125;&#125; https://discuss.leetcode.com/topic/8941/simple-java-solution-o-n-time-and-o-1-space Simple Java Solution O(N) time and O(1) space. Simply just modulo the input by 10, add it to a long-integer variable as the result. Repeat. When the result is &gt; max integer or &lt; min integer, return 0. Hence, return the result as an integer 123456789101112131415public class Solution &#123; public int reverse(int x) &#123; long result =0; while(x != 0) &#123; result = (result*10) + (x%10); if(result &gt; Integer.MAX_VALUE) return 0; if(result &lt; Integer.MIN_VALUE) return 0; x = x/10; &#125; return (int)result; &#125;&#125; https://discuss.leetcode.com/topic/41683/might-be-helpful-to-you-my-2ms-11-lines-java-solution Might be helpful to you: my 2ms 11 lines Java solution 1234567891011public int reverse(int x) &#123; long result = 0; while (x != 0) &#123; result = result * 10 + x%10; if (result &gt; Integer.MAX_VALUE || result &lt; Integer.MIN_VALUE) &#123; return 0; &#125; x = x / 10; &#125; return (int)result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[006. ZigZag Conversion]]></title>
    <url>%2Fp%2F6cbc5e00%2F</url>
    <content type="text"><![CDATA[26.3% https://leetcode.com/problems/zigzag-conversion/ 123456789101112The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P A H NA P L S I I GY I RAnd then read line by line: &quot;PAHNAPLSIIGYIR&quot;Write the code that will take a string and make this conversion given a number of rows:string convert(string text, int nRows);convert(&quot;PAYPALISHIRING&quot;, 3) should return &quot;PAHNAPLSIIGYIR&quot;. 方法一： 最好的一点是使用了空间，分成了n个组，每个组都是string，最后合并。 https://discuss.leetcode.com/topic/4502/share-simple-c-solution 28ms, 23.79%, August 31, 2016 The problem statement itself is unclear for many. Especially for 2-row case. “ABCD”, 2 –&gt; “ACBD”. The confusion most likely is from the character placement. I would like to extend it a little bit to make ZigZag easy understood. 设了一个数组，每一组代表一行的值，然后将他们串联到一起 The example can be written as follow: P…….A……..H…….N ..A..P….L..S….I…I….G ….Y………I……..R Therefore, &lt;ABCD, 2&gt; can be arranged as: A….C …B….D My simple accepted code: 12345678910111213141516171819202122232425262728class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows &lt;= 1) return s; const int len = (int)s.length(); string *str = new string[numRows]; int row = 0, step=1; for(int i = 0; i &lt; len; ++i)&#123; str[row].push_back(s[i]); if(row==0) step = 1; else if(row == numRows - 1) step = -1; row += step; &#125; s.clear(); for(int j= 0; j &lt; numRows; ++j) s.append(str[j]); delete[] str; return s; &#125;&#125;; 我的代码实现： 可以学习上一段代码中的clear，append，delete函数 123456789101112131415161718192021class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows&lt;=1) return s; // 此处要初始化为v(numRows) vector&lt;string&gt; v(numRows); int pos = 0, flag = 1; for(int i=0; i&lt;s.size(); i++)&#123; v[pos] += s[i]; if(pos==0) flag = 1; else if(pos==numRows-1) flag = -1; pos += flag; &#125; string t = ""; for(int i=0; i&lt;numRows; i++) t.append(v[i]); return t; &#125;&#125;; https://discuss.leetcode.com/topic/22925/if-you-are-confused-with-zigzag-pattern-come-and-see If you are confused with zigzag pattern,come and see! 123456789/*n=numRowsΔ=2n-2 1 2n-1 4n-3Δ= 2 2n-2 2n 4n-4 4n-2Δ= 3 2n-3 2n+1 4n-5 .Δ= . . . . .Δ= . n+2 . 3n .Δ= n-1 n+1 3n-3 3n-1 5n-5Δ=2n-2 n 3n-2 5n-4*/ that’s the zigzag pattern the question asked!Be careful with nR=1 &amp;&amp; nR=2 my 16ms code in c++: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string convert(string s, int numRows) &#123; string result=""; if(numRows==1) return s; int step1,step2; int len=s.size(); for(int i=0;i&lt;numRows;++i)&#123; step1=(numRows-i-1)*2; step2=(i)*2; int pos=i; if(pos&lt;len) result+=s.at(pos); while(1)&#123; pos+=step1; if(pos&gt;=len) break; if(step1) result+=s.at(pos); pos+=step2; if(pos&gt;=len) break; if(step2) result+=s.at(pos); &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/22925/if-you-are-confused-with-zigzag-pattern-come-and-see1234567891011/*n=numRowsΔ=2n-2 1 2n-1 4n-3Δ= 2 2n-2 2n 4n-4 4n-2Δ= 3 2n-3 2n+1 4n-5 .Δ= . . . . .Δ= . n+2 . 3n .Δ= n-1 n+1 3n-3 3n-1 5n-5Δ=2n-2 n 3n-2 5n-4*/that&apos;s the zigzag pattern the question asked!Be careful with nR=1 &amp;&amp; nR=2 my 16ms code in c++: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string convert(string s, int numRows) &#123; string result=&quot;&quot;; if(numRows==1) return s; int step1,step2; int len=s.size(); for(int i=0;i&lt;numRows;++i)&#123; step1=(numRows-i-1)*2; step2=(i)*2; int pos=i; if(pos&lt;len) result+=s.at(pos); while(1)&#123; pos+=step1; if(pos&gt;=len) break; if(step1) result+=s.at(pos); pos+=step2; if(pos&gt;=len) break; if(step2) result+=s.at(pos); &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/21196/a-10-lines-one-pass-o-n-time-o-1-space-accepted-solution-with-detailed-explantation A 10-lines one-pass o(n)-time o(1)-space accepted solution with detailed explantation The distribution of the elements is period. 123P A H NA P L S I I GY I R For example, the following has 4 periods(cycles): 123P | A | H | NA P | L S | I I | GY | I | R | The size of every period is defined as “cycle” 1cycle = (2*nRows - 2), except nRows == 1. In this example, (2*nRows - 2) = 4. In every period, every row has 2 elements, except the first row and the last row. Suppose the current row is i, the index of the first element is j: 1j = i + cycle*k, k = 0, 1, 2, ... The index of the second element is secondJ: 1secondJ = (j - i) + cycle - i (j-i) is the start of current period, (j-i) + cycle is the start of next period. 12345678910111213141516string convert(string s, int nRows) &#123; if(nRows &lt;= 1) return s; string result = &quot;&quot;; //the size of a cycle(period) int cycle = 2 * nRows - 2; for(int i = 0; i &lt; nRows; ++i) &#123; for(int j = i; j &lt; s.length(); j = j + cycle)&#123; result = result + s[j]; int secondJ = (j - i) + cycle - i; if(i != 0 &amp;&amp; i != nRows-1 &amp;&amp; secondJ &lt; s.length()) result = result + s[secondJ]; &#125; &#125; return result; &#125; python https://discuss.leetcode.com/topic/34573/python-o-n-solution-in-96ms-99-43 Python O(n) Solution in 96ms (99.43%) 12345678910111213141516171819202122class Solution(object): def convert(self, s, numRows): &quot;&quot;&quot; :type s: str :type numRows: int :rtype: str &quot;&quot;&quot; if numRows == 1 or numRows &gt;= len(s): return s L = [&apos;&apos;] * numRows index, step = 0, 1 for x in s: L[index] += x if index == 0: step = 1 elif index == numRows -1: step = -1 index += step return &apos;&apos;.join(L) https://discuss.leetcode.com/topic/10330/a-simple-python-solution-97ms-8-lines A simple python solution, 97ms, 8 lines 12345678910111213141516def convert(self, s, nRows): if nRows==1: return s period= 2*(nRows -1) lines=[&quot;&quot; for i in range(nRows)] d=&#123;&#125; # dict remainder:line for i in xrange(period): if i&lt;nRows: d[i]=i else: d[i]=period-i for i in xrange(len(s)): lines[ d[i%period] ] +=s[i] return &quot;&quot;.join(lines) The idea is to use the remainder (index%period) to determine which line the character at the given index will be. The period is calculated first based on nRows. A dictionary with remainder:line as key:value is then created (this can also be done with a list or a tuple). Once these are done, we simply go through s, assign each character to its new line, and then combine these lines to get the converted string. The code can be further shortened to 8 lines by using dict comprehension: 1d=&#123;i:i if i&lt;nRows else (period-i) for i in xrange(period)&#125; 1234567891011def convert(self, s, nRows): if nRows==1: return s period= 2*(nRows -1) lines=[&quot;&quot; for i in range(nRows)] d=&#123;i:i if i&lt;nRows else (period-i) for i in xrange(period)&#125; for i in xrange(len(s)): lines[ d[i%period] ] +=s[i] return &quot;&quot;.join(lines) java https://discuss.leetcode.com/topic/3162/easy-to-understand-java-solution Easy to understand Java solution Create nRows StringBuffers, and keep collecting characters from original string to corresponding StringBuffer. Just take care of your index to keep them in bound. 1234567891011121314151617public String convert(String s, int nRows) &#123; char[] c = s.toCharArray(); int len = c.length; StringBuffer[] sb = new StringBuffer[nRows]; for (int i = 0; i &lt; sb.length; i++) sb[i] = new StringBuffer(); int i = 0; while (i &lt; len) &#123; for (int idx = 0; idx &lt; nRows &amp;&amp; i &lt; len; idx++) // vertically down sb[idx].append(c[i++]); for (int idx = nRows-2; idx &gt;= 1 &amp;&amp; i &lt; len; idx--) // obliquely up sb[idx].append(c[i++]); &#125; for (int idx = 1; idx &lt; sb.length; idx++) sb[0].append(sb[idx]); return sb[0].toString();&#125; https://discuss.leetcode.com/topic/41037/java-solution-easy-and-clear-interesting-approach JAVA solution–easy and clear ( interesting approach ) 12345678910111213141516171819202122public class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows&lt;=1)return s; StringBuilder[] sb=new StringBuilder[numRows]; for(int i=0;i&lt;sb.length;i++)&#123; sb[i]=new StringBuilder(&quot;&quot;); //init every sb element **important step!!!! &#125; int incre=1; int index=0; for(int i=0;i&lt;s.length();i++)&#123; sb[index].append(s.charAt(i)); if(index==0)&#123;incre=1;&#125; if(index==numRows-1)&#123;incre=-1;&#125; index+=incre; &#125; String re=&quot;&quot;; for(int i=0;i&lt;sb.length;i++)&#123; re+=sb[i]; &#125; return re.toString(); &#125;&#125; https://discuss.leetcode.com/topic/3305/two-ways-of-o-n-solutions-one-follows-the-order-of-input-string-and-other-follows-the-order-of-output-string Two ways of O(n) solutions one follows the order of input string and other follows the order of output string Both the algorithms are of O(n) time complexity as every character in the input string is traversed only once.In the first version of algorithm, the output string’s string buffer get populated based on the output string order i.e, string builder gets populated incrementally from 0 to size-1. 12345670 6 12 181 5 7 11 13 17 192 4 8 10 14 16 203 9 15 21 In the above sample case the number of rows is 4, when the first iteration is completed the locations 0,1,2,3 of the string builder gets filled with the locations 0,6,12,18 of the input string it goes on further for other three rows. 123456789101112131415161718192021222324252627282930public class Solution &#123; public String convert(String s, int nRows) &#123; if (nRows == 1) return s; StringBuilder strBuilder = new StringBuilder(); int borderRowStep = 2 * nRows - 2; for (int i = 0; i &lt; nRows; i++) &#123; if (i == 0 || i == nRows - 1) &#123; for (int j = i; j &lt; s.length(); j = j + borderRowStep) &#123; strBuilder.append(s.charAt(j)); &#125; &#125; else &#123; int j = i; boolean flag = true; int insideRowLargeStep = 2 * (nRows - 1 - i); int insideRowSmallStep = borderRowStep - insideRowLargeStep; while (j &lt; s.length()) &#123; strBuilder.append(s.charAt(j)); if (flag) j = j + insideRowLargeStep; else j = j + insideRowSmallStep; flag = !flag; &#125; &#125; &#125; return strBuilder.toString(); &#125;&#125; In the second version of algorithm string buffer is filled in the order of input string i.e, the string buffer gets filled in the zig zag order, when the first iteration of the outer while loop completes the locations 0,5,11,17 in string builder gets filled with the locations 0,1,2,3, from the input string 123456789101112131415161718class Solution&#123;public String convert(String s, int nRows) &#123; char[] c = s.toCharArray(); int len = c.length; StringBuffer[] sb = new StringBuffer[nRows]; for (int z=0; z &lt; sb.length; z++) sb[z] = new StringBuffer(); int k=0; while (k &lt; len) &#123; for (int zigZagIndex = 0; zigZagIndex &lt; nRows &amp;&amp; k &lt; len; zigZagIndex++) // vertically down sb[zigZagIndex].append(c[k++]); for (int zigZagIndex = nRows-2; zigZagIndex &gt;= 1 &amp;&amp; k &lt; len; zigZagIndex--) // obliquely up sb[zigZagIndex].append(c[k++]); &#125; for (int index = 1; index &lt; sb.length; index++) sb[0].append(sb[index]); return sb[0].toString();&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[005. Longest Palindromic Substring]]></title>
    <url>%2Fp%2Fa8573ae4%2F</url>
    <content type="text"><![CDATA[25.0% https://leetcode.com/problems/longest-palindromic-substring/ Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. 1234567Example:Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. 12345Example:Input: &quot;cbbd&quot;Output: &quot;bb&quot; 方法一： 依次遍历，遍历至i时，从i开始向左向右移动，找到最大长度。 12345678910111213141516171819202122232425class Solution &#123; int start, longest;public: string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; for(int i=0; i&lt;n-1; i++)&#123; helper(s, i, i); helper(s, i, i+1); &#125; return s.substr(start, longest); &#125; void helper(string&amp; s, int i, int j)&#123; while(i&gt;=0 &amp;&amp; j&lt;s.size() &amp;&amp; s[i]==s[j])&#123; i--; j++; &#125; if(longest&lt;j-i-1)&#123; start = i+1; longest = j-i-1; &#125; return; &#125;&#125;; 我的代码实现一： 1234567891011121314151617181920212223242526class Solution &#123;public: int head = 0; int l = 0; string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; for(int i=0; i&lt;n-1; i++)&#123; helper(i, i, s); helper(i, i+1, s); &#125; return s.substr(head, l); &#125; void helper(int left, int right, string &amp; s)&#123; int n = s.size(); while(left&gt;=0 &amp;&amp; right&lt;n &amp;&amp; s[left]==s[right])&#123; left--; right++; &#125; if(right-left-1&gt;l)&#123; head = left+1; l = right-left-1; &#125; &#125;&#125;; 我的代码实现二： 12345678910111213141516171819202122232425class Solution &#123;public: string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; int head = 0, d = 0; for(int i=0; i&lt;n-1; i++)&#123; helper(s, i, i, head, d); helper(s, i, i+1, head, d); &#125; return s.substr(head, d); &#125; void helper(string s, int left, int right, int&amp; head, int&amp; d)&#123; while(left&gt;=0 &amp;&amp; right&lt;s.size() &amp;&amp; s[left]==s[right])&#123; left--; right++; &#125; if(right-left-1&gt;d)&#123; head = left+1; d = right-left-1; &#125; return; &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/16317/accepted-4ms-c-solution Accepted 4ms c++ solution. 核心逻辑点： 1 5 5 5 5 6 7 8 遍历到某一个核心如 5 5时，一定要把5全部放中间才是最长的，不然肯定遇见一个不对称的5 然后下一个核心是6，同时当前位置距离末尾小于最长长度时要停止，进一步优化了算法 1234567891011121314151617181920212223class Solution &#123;public: std::string longestPalindrome(std::string s) &#123; if (s.size() &lt; 2) return s; int len = s.size(), max_left = 0, max_len = 1, left, right; for (int start = 0; start &lt; len &amp;&amp; len - start &gt; max_len / 2;) &#123; left = right = start; while (right &lt; len - 1 &amp;&amp; s[right + 1] == s[right]) ++right; start = right + 1; while (right &lt; len - 1 &amp;&amp; left &gt; 0 &amp;&amp; s[right + 1] == s[left - 1]) &#123; ++right; --left; &#125; if (max_len &lt; right - left + 1) &#123; max_left = left; max_len = right - left + 1; &#125; &#125; return s.substr(max_left, max_len); &#125;&#125;; 我的代码实现： 两点优化 3ms，94.75% 123456789101112131415161718192021222324class Solution &#123;public: string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; int head = 0, d = 0; int left = 0, right = 0; for(int i=0; i&lt;n-d/2; )&#123; left = right = i; while(right+1&lt;n &amp;&amp; s[right+1]==s[right]) right++; i = right+1; while(left-1&gt;=0 &amp;&amp; right+1&lt;n &amp;&amp; s[left-1]==s[right+1])&#123; left--; right++; &#125; if(right-left+1&gt;d)&#123; head = left; d = right-left+1; &#125; &#125; return s.substr(head, d); &#125;&#125;; https://discuss.leetcode.com/topic/12187/simple-c-solution-8ms-13-lines Simple C++ solution (8ms, 13 lines) 123456789101112131415string longestPalindrome(string s) &#123; if (s.empty()) return &quot;&quot;; if (s.size() == 1) return s; int min_start = 0, max_len = 1; for (int i = 0; i &lt; s.size();) &#123; if (s.size() - i &lt;= max_len / 2) break; int j = i, k = i; while (k &lt; s.size()-1 &amp;&amp; s[k+1] == s[k]) ++k; // Skip duplicate characters. i = k+1; while (k &lt; s.size()-1 &amp;&amp; j &gt; 0 &amp;&amp; s[k + 1] == s[j - 1]) &#123; ++k; --j; &#125; // Expand. int new_len = k - j + 1; if (new_len &gt; max_len) &#123; min_start = j; max_len = new_len; &#125; &#125; return s.substr(min_start, max_len);&#125; python https://discuss.leetcode.com/topic/7144/python-o-n-2-method-with-some-optimization-88ms 14ms, 79.15%, 23 July 2016 maxLen是长度，i为当前位置，判断，i-maxLen至i之间是否对称 Basic thought is simple. when you increase s by 1 character, you could only increase maxPalindromeLen by 1 or 2, and that new maxPalindrome includes this new character. Proof: if on adding 1 character, maxPalindromeLen increased by 3 or more, say the new maxPalindromeLen is Q, and the old maxPalindromeLen is P, and Q&gt;=P+3. Then it would mean, even without this new character, there would be a palindromic substring ending in the last character, whose length is at least Q-2. Since Q-2 would be &gt;P, this contradicts the condition that P is the maxPalindromeLen without the additional character. So, it becomes simple, you only need to scan from beginning to the end, adding one character at a time, keeping track of maxPalindromeLen, and for each added character, you check if the substrings ending with this new character, with length P+1 or P+2, are palindromes, and update accordingly. Now, this is O(n^2) as taking substrings and checking palindromicity seem O(n) time. We can speed up it by realizing that strings are immutable, and there are memory slicing tricks will help to speed these operations up. comparing string equality with “==” is O(1), and using slicing to substring and reverse is ̶a̶l̶s̶o̶ ̶O̶(̶1̶)̶ ̶(̶n̶o̶t̶ ̶t̶o̶t̶a̶l̶l̶y̶ ̶s̶u̶r̶e̶ ̶a̶b̶o̶u̶t̶ ̶t̶h̶e̶ ̶s̶l̶i̶c̶i̶n̶g̶ ̶t̶h̶o̶u̶g̶h̶.̶ ̶ ̶I̶ ̶t̶h̶i̶n̶k̶ ̶i̶t̶ ̶i̶s̶ ̶O̶(̶1̶)̶,̶ ̶b̶u̶t̶ ̶c̶o̶u̶l̶d̶ ̶n̶o̶t̶ ̶f̶i̶n̶d̶ ̶a̶n̶y̶ ̶s̶o̶l̶i̶d̶ ̶l̶i̶t̶e̶r̶a̶t̶u̶r̶e̶ ̶a̶b̶o̶u̶t̶ ̶i̶t̶.̶ O(n) (thanks to ChuntaoLu). But as slicing is optimized by the interpreter’s C code, it should run pretty fast. I’m pretty new to Python. Would appreciate you would give more insights or further optimization. Thus, here is the O(n) method: 123456789101112131415161718class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; if len(s) == 0: return 0 maxLen = 1 start = 0 for i in xrange(len(s)): if i - maxLen &gt;= 1 and s[i-maxLen - 1: i+1] == s[i - maxLen-1:i+1][::-1]: start = i-maxLen -1 maxLen+= 2 continue if i - maxLen &gt;= 0 and s[i-maxLen:i+1] == s[i-maxLen:i+1][::-1]: start = i - maxLen maxLen += 1 return s[start:start+maxLen] https://discuss.leetcode.com/topic/20844/python-easy-to-understand-solution-with-comments-from-middle-to-two-ends Python easy to understand solution with comments (from middle to two ends). 12345678910111213141516171819def longestPalindrome(self, s): res = &quot;&quot; for i in xrange(len(s)): # odd case, like &quot;aba&quot; tmp = self.helper(s, i, i) if len(tmp) &gt; len(res): res = tmp # even case, like &quot;abba&quot; tmp = self.helper(s, i, i+1) if len(tmp) &gt; len(res): res = tmp return res # get the longest palindrome, l, r are the middle indexes # from inner to outerdef helper(self, s, l, r): while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]: l -= 1; r += 1 return s[l+1:r] java https://discuss.leetcode.com/topic/23498/very-simple-clean-java-solution The performance is pretty good, surprisingly. 12345678910111213141516171819202122232425public class Solution &#123;private int lo, maxLen;public String longestPalindrome(String s) &#123; int len = s.length(); if (len &lt; 2) return s; for (int i = 0; i &lt; len-1; i++) &#123; extendPalindrome(s, i, i); //assume odd length, try to extend Palindrome as possible extendPalindrome(s, i, i+1); //assume even length. &#125; return s.substring(lo, lo + maxLen);&#125;private void extendPalindrome(String s, int j, int k) &#123; while (j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k)) &#123; j--; k++; &#125; if (maxLen &lt; k - j - 1) &#123; lo = j + 1; maxLen = k - j - 1; &#125;&#125;&#125; https://discuss.leetcode.com/topic/21848/ac-relatively-short-and-very-clear-java-solution (AC) relatively short and very clear Java solution Key idea, every time we move to right, we only need to consider whether using this new character as tail could produce new palindrome string of length (current length +1) or (current length +2) 12345678910111213141516171819202122232425public class Solution &#123; public String longestPalindrome(String s) &#123; String res = &quot;&quot;; int currLength = 0; for(int i=0;i&lt;s.length();i++)&#123; if(isPalindrome(s,i-currLength-1,i))&#123; res = s.substring(i-currLength-1,i+1); currLength = currLength+2; &#125; else if(isPalindrome(s,i-currLength,i))&#123; res = s.substring(i-currLength,i+1); currLength = currLength+1; &#125; &#125; return res; &#125; public boolean isPalindrome(String s, int begin, int end)&#123; if(begin&lt;0) return false; while(begin&lt;end)&#123; if(s.charAt(begin++)!=s.charAt(end--)) return false; &#125; return true; &#125;&#125; For friends who are confused about the key idea to check only new palindrome with length = current length +2 or +1, I add some more explanation here. 12345678910Example: &quot;xxxbcbxxxxxa&quot;, (x is random character, not all x are equal) now we are dealing with the last character &apos;a&apos;. The current longest palindrome is &quot;bcb&quot; with length 3.1. check &quot;xxxxa&quot; so if it is palindrome we could get a new palindrome of length 5.2. check &quot;xxxa&quot; so if it is palindrome we could get a new palindrome of length 4.3. do NOT check &quot;xxa&quot; or any shorter string since the length of the new string is no bigger than current longest length.4. do NOT check &quot;xxxxxa&quot; or any longer string because if &quot;xxxxxa&quot; is palindrome then &quot;xxxx&quot; got from cutting off the head and tail is also palindrom. It has length &gt; 3 which is impossible.&apos; https://discuss.leetcode.com/topic/25500/share-my-java-solution-using-dynamic-programming Share my Java solution using dynamic programming dp(i, j) represents whether s(i … j) can form a palindromic substring, dp(i, j) is true when s(i) equals to s(j) and s(i+1 … j-1) is a palindromic substring. When we found a palindrome, check if it’s the longest one. Time complexity O(n^2). 123456789101112131415161718public String longestPalindrome(String s) &#123; int n = s.length(); String res = null; boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i; j &lt; n; j++) &#123; dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; 3 || dp[i + 1][j - 1]); if (dp[i][j] &amp;&amp; (res == null || j - i + 1 &gt; res.length())) &#123; res = s.substring(i, j + 1); &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/23498/very-simple-clean-java-solution 14ms, 79.15%, 23 July 2016 第一遍循环，针对每个索引，开始向两遍扩展，直到不能扩展为止。 123456789101112131415161718192021222324252627public class Solution &#123; private int lo, maxLen; public String longestPalindrome(String s) &#123; int len = s.length(); if(len &lt; 2) return s; for(int i=0; i&lt;len-1;i++)&#123; // assume odd length, try to extend Palindrome as possible extenPalindrome(s, i, i); //assume even length. extenPalindrome(s, i, i+1); &#125; return s.substring(lo, lo + maxLen); &#125; private void extenPalindrome(String s, int j, int k)&#123; while(j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k))&#123; j--; k++; &#125; if(maxLen &lt; k - j - 1)&#123; lo = j + 1; maxLen = k - j - 1; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[004. Median of Two Sorted Arrays]]></title>
    <url>%2Fp%2F82de9929%2F</url>
    <content type="text"><![CDATA[21.0% https://leetcode.com/problems/median-of-two-sorted-arrays/ There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 12345Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0 12345Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 cpp https://discuss.leetcode.com/topic/16797/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation Very concise O(log(min(M,N))) iterative solution with detailed explanation This problem is notoriously hard to implement due to all the corner cases. Most implementations consider odd-lengthed and even-lengthed arrays as two different cases and treat them separately. As a matter of fact, with a little mind twist. These two cases can be combined as one, leading to a very simple solution where (almost) no special treatment is needed. First, let’s see the concept of ‘MEDIAN’ in a slightly unconventional way. That is: 123&quot;if we cut the sorted array to two halves of EQUAL LENGTHS, thenmedian is the AVERAGE OF Max(lower_half) and Min(upper_half), i.e. thetwo numbers immediately next to the cut&quot;. For example, for [2 3 5 7], we make the cut between 3 and 5: 1[2 3 / 5 7] then the median = (3+5)/2. Note that I’ll use ‘/‘ to represent a cut, and (number / number) to represent a cut made through a number in this article. for [2 3 4 5 6], we make the cut right through 4 like this: [2 3 (4/4) 5 7] Since we split 4 into two halves, we say now both the lower and upper subarray contain 4. This notion also leads to the correct answer: (4 + 4) / 2 = 4; For convenience, let’s use L to represent the number immediately left to the cut, and R the right counterpart. In [2 3 5 7], for instance, we have L = 3 and R = 5, respectively. We observe the index of L and R have the following relationship with the length of the array N: 123456789N Index of L / R1 0 / 02 0 / 13 1 / 1 4 1 / 2 5 2 / 26 2 / 37 3 / 38 3 / 4 It is not hard to conclude that index of L = (N-1)/2, and R is at N/2. Thus, the median can be represented as 1(L + R)/2 = (A[(N-1)/2] + A[N/2])/2 To get ready for the two array situation, let’s add a few imaginary ‘positions’ (represented as #’s) in between numbers, and treat numbers as ‘positions’ as well. 12345[6 9 13 18] -&gt; [# 6 # 9 # 13 # 18 #] (N = 4)position index 0 1 2 3 4 5 6 7 8 (N_Position = 9) [6 9 11 13 18]-&gt; [# 6 # 9 # 11 # 13 # 18 #] (N = 5)position index 0 1 2 3 4 5 6 7 8 9 10 (N_Position = 11) As you can see, there are always exactly 2*N+1 ‘positions’ regardless of length N. Therefore, the middle cut should always be made on the Nth position (0-based). Since index(L) = (N-1)/2 and index(R) = N/2 in this situation, we can infer that index(L) = (CutPosition-1)/2, index(R) = (CutPosition)/2. Now for the two-array case: 123A1: [# 1 # 2 # 3 # 4 # 5 #] (N1 = 5, N1_positions = 11)A2: [# 1 # 1 # 1 # 1 #] (N2 = 4, N2_positions = 9) Similar to the one-array problem, we need to find a cut that divides the two arrays each into two halves such that 12&quot;any number in the two left halves&quot; &lt;= &quot;any number in the two righthalves&quot;. We can also make the following observations： There are 2N1 + 2N2 + 2 position altogether. Therefore, there must be exactly N1 + N2 positions on each side of the cut, and 2 positions directly on the cut. Therefore, when we cut at position C2 = K in A2, then the cut position in A1 must be C1 = N1 + N2 - k. For instance, if C2 = 2, then we must have C1 = 4 + 5 - C2 = 7. 123[# 1 # 2 # 3 # (4/4) # 5 #] [# 1 / 1 # 1 # 1 #] When the cuts are made, we’d have two L’s and two R’s. They are L1 = A1[(C1-1)/2]; R1 = A1[C1/2];L2 = A2[(C2-1)/2]; R2 = A2[C2/2];In the above example, 12L1 = A1[(7-1)/2] = A1[3] = 4; R1 = A1[7/2] = A1[3] = 4;L2 = A2[(2-1)/2] = A2[0] = 1; R2 = A1[2/2] = A1[1] = 1; Now how do we decide if this cut is the cut we want? Because L1, L2 are the greatest numbers on the left halves and R1, R2 are the smallest numbers on the right, we only need 1L1 &lt;= R1 &amp;&amp; L1 &lt;= R2 &amp;&amp; L2 &lt;= R1 &amp;&amp; L2 &lt;= R2 to make sure that any number in lower halves &lt;= any number in upper halves. As a matter of fact, sinceL1 &lt;= R1 and L2 &lt;= R2 are naturally guaranteed because A1 and A2 are sorted, we only need to make sure: L1 &lt;= R2 and L2 &lt;= R1. Now we can use simple binary search to find out the result. 12345678If we have L1 &gt; R1, it means there are too many large numbers on the left half of A1, then we must move C1 to the left (i.e. move C2 to the right); If L2 &gt; R1, then there are too many large numbers on the left half of A2, and we must move C2 to the left.Otherwise, this cut is the right one. After we find the cut, the medium can be computed as (max(L1, L2) + min(R1, R2)) / 2; Two side notes: A. since C1 and C2 can be mutually determined from each other, we might as well select the shorter array (say A2) and only move C2 around, and calculate C1 accordingly. That way we can achieve a run-time complexity of O(log(min(N1, N2))) B. The only edge case is when a cut falls on the 0th(first) or the 2Nth(last) position. For instance, if C2 = 2N2, then R2 = A2[2*N2/2] = A2[N2], which exceeds the boundary of the array. To solve this problem, we can imagine that both A1 and A2 actually have two extra elements, INT_MAX at A[-1] and INT_MAX at A[N]. These additions don’t change the result, but make the implementation easier: If any L falls out of the left boundary of the array, then L = INT_MIN, and if any R falls out of the right boundary, then R = INT_MAX. I know that was not very easy to understand, but all the above reasoning eventually boils down to the following concise code: 1234567891011121314151617181920212223double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int N1 = nums1.size(); int N2 = nums2.size(); if (N1 &lt; N2) return findMedianSortedArrays(nums2, nums1); // Make sure A2 is the shorter one. if (N2 == 0) return ((double)nums1[(N1-1)/2] + (double)nums1[N1/2])/2; // If A2 is empty int lo = 0, hi = N2 * 2; while (lo &lt;= hi) &#123; int mid2 = (lo + hi) / 2; // Try Cut 2 int mid1 = N1 + N2 - mid2; // Calculate Cut 1 accordingly double L1 = (mid1 == 0) ? INT_MIN : nums1[(mid1-1)/2]; // Get L1, R1, L2, R2 respectively double L2 = (mid2 == 0) ? INT_MIN : nums2[(mid2-1)/2]; double R1 = (mid1 == N1 * 2) ? INT_MAX : nums1[(mid1)/2]; double R2 = (mid2 == N2 * 2) ? INT_MAX : nums2[(mid2)/2]; if (L1 &gt; R2) lo = mid2 + 1; // A1&apos;s lower half is too big; need to move C1 left (C2 right) else if (L2 &gt; R1) hi = mid2 - 1; // A2&apos;s lower half too big; need to move C2 left. else return (max(L1,L2) + min(R1, R2)) / 2; // Otherwise, that&apos;s the right cut. &#125; return -1;&#125; If you have any suggestions to make the logic and implementation even more cleaner. Please do let me know! https://discuss.leetcode.com/topic/2778/share-my-simple-o-log-m-n-solution-for-your-reference Share my simple O(log(m+n)) solution for your reference Binary search. Call 2 times getkth and k is about half of (m + n). Every time call getkth can reduce the scale k to its half. So the time complexity is log(m + n). 12345678910111213141516171819202122232425class Solution &#123;public: int getkth(int s[], int m, int l[], int n, int k)&#123; // let m &lt;= n if (m &gt; n) return getkth(l, n, s, m, k); if (m == 0) return l[k - 1]; if (k == 1) return min(s[0], l[0]); int i = min(m, k / 2), j = min(n, k / 2); if (s[i - 1] &gt; l[j - 1]) return getkth(s, m, l + j, n - j, k - j); else return getkth(s + i, m - i, l, n, k - i); return 0; &#125; double findMedianSortedArrays(int A[], int m, int B[], int n) &#123; int l = (m + n + 1) &gt;&gt; 1; int r = (m + n + 2) &gt;&gt; 1; return (getkth(A, m ,B, n, l) + getkth(A, m, B, n, r)) / 2.0; &#125;&#125;; https://discuss.leetcode.com/topic/5728/share-one-divide-and-conquer-o-log-m-n-method-with-clear-description Share one divide and conquer O(log(m+n)) method with clear description // using divide and conquer idea, each time find the mid of both arrays 12345678910111213141516171819202122232425262728293031323334353637383940414243double findMedianSortedArrays(int A[], int m, int B[], int n) &#123; /* A[0, 1, 2, ..., n-1, n] */ /* A[0, 1, 2, ..., m-1, m] */ int k = (m + n + 1) / 2; double v = (double)FindKth(A, 0, m - 1, B, 0, n - 1, k); if ((m+n) % 2 == 0) &#123; int k2 = k+1; double v2 = (double)FindKth(A, 0, m - 1, B, 0, n - 1, k2); v = (v + v2) / 2; &#125; return v; &#125; // find the kth element int the two sorted arrays // let us say: A[aMid] &lt;= B[bMid], x: mid len of a, y: mid len of b, then wen can know // // (1) there will be at least (x + 1 + y) elements before bMid // (2) there will be at least (m - x - 1 + n - y) = m + n - (x + y +1) elements after aMid // therefore // if k &lt;= x + y + 1, find the kth element in a and b, but unconsidering bMid and its suffix // if k &gt; x + y + 1, find the k - (x + 1) th element in a and b, but unconsidering aMid and its prefix int FindKth(int A[], int aL, int aR, int B[], int bL, int bR, int k) &#123; if (aL &gt; aR) return B[bL + k - 1]; if (bL &gt; bR) return A[aL + k - 1]; int aMid = (aL + aR) / 2; int bMid = (bL + bR) / 2; if (A[aMid] &lt;= B[bMid]) &#123; if (k &lt;= (aMid - aL) + (bMid - bL) + 1) return FindKth(A, aL, aR, B, bL, bMid - 1, k); else return FindKth(A, aMid + 1, aR, B, bL, bR, k - (aMid - aL) - 1); &#125; else &#123; // A[aMid] &gt; B[bMid] if (k &lt;= (aMid - aL) + (bMid - bL) + 1) return FindKth(A, aL, aMid - 1, B, bL, bR, k); else return FindKth(A, aL, aR, B, bMid + 1, bR, k - (bMid - bL) - 1); &#125; &#125; https://discuss.leetcode.com/topic/11478/o-lg-m-n-c-solution-using-kth-smallest-number O(lg(m+n)) c++ solution using kth smallest number 1234567891011121314151617181920212223class Solution &#123;public: int kth(int a[], int m, int b[], int n, int k) &#123; if (m &lt; n) return kth(b,n,a,m,k); if (n==0) return a[k-1]; if (k==1) return min(a[0],b[0]); int j = min(n,k/2); int i = k-j; if (a[i-1] &gt; b[j-1]) return kth(a,i,b+j,n-j,k-j); return kth(a+i,m-i,b,j,k-i); &#125; double findMedianSortedArrays(int a[], int m, int b[], int n) &#123; int k = (m+n)/2; int m1 = kth(a,m,b,n,k+1); if ((m+n)%2==0) &#123; int m2 = kth(a,m,b,n,k); return ((double)m1+m2)/2.0; &#125; return m1; &#125;&#125;; https://discuss.leetcode.com/topic/26926/another-simple-and-neat-solution-binary-search-non-recursion-3-rows-of-core-code-o-log-min-m-n Another simple and neat solution, binary search, non-recursion, 3 rows of core code, O(log(min(m, n))) If you solve the k-th minmum value of two sorted arrays, you solve this problem.This is a classical problem of “Divide and conquer”. Here is another more simple and more neat solution. Cosider chosing first x numbers from A and k - x numbers from B.if these k numbers are the k minmum numbers of A and B, x must satisfies that A[x + 1] &gt;= B[k - x] and B[k - x + 1] &gt;= A[x] (for better explanation index is base-1). So this x is what we want. Obviously, if A[x + 1] &lt; B[k - x + 1] then x must be smaller, else if B[k - x] &lt; A[x] then x must be greater. A nice two-value definition for binary search :) To simplify edge cases, we cosider each array indefinite, with value of INTMIN when index &lt; 1 and INTMAX when index &gt; n. Here is the solution of c++ version: 12345678910111213141516171819202122232425typedef vector&lt;int&gt; vi;const int inf = 0x7fffffff, ninf = 0x80000000;class Solution &#123; int kth_min(vi&amp; a, vi&amp; b, int k, int n, int m)&#123; #define A(i) (i &lt; 1 ? ninf : (i &gt; n ? inf : a[i - 1])) #define B(i) (i &lt; 1 ? ninf : (i &gt; m ? inf : b[i - 1])) int l = 0, r = n + 1, x; while(l &lt;= r)&#123; x = (l + r) &gt;&gt; 1; if(A(x) &gt; B(k - x + 1)) r = x - 1; else if(B(k - x) &gt; A(x + 1)) l = x + 1; else return max(A(x), B(k - x)); &#125; return 0; //never execute , just to hide the warning :) #undef A #undef B &#125;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123; int n = a.size(), m = b.size(); if(n &gt; m) return findMedianSortedArrays(b, a); //make sure that a.size() &lt;= b.size() if((m + n) &amp; 1) return kth_min(a, b, (m + n + 1) &gt;&gt; 1, n, m); return (0.0 + kth_min(a, b, (m + n + 1) &gt;&gt; 1, n, m) + kth_min(a, b, ((m + n) &gt;&gt; 1) + 1, n, m)) * 0.5; &#125;&#125;; python https://discuss.leetcode.com/topic/4996/share-my-o-log-min-m-n-solution-with-explanation To solve this problem, we need to understand “What is the use of median”. In statistics, the median is used for dividing a set into two equal length subsets, that one subset is always greater than the other. If we understand the use of median for dividing, we are very close to the answer.1234First let&apos;s cut A into two parts at a random position i: left_A | right_AA[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] Since A has m elements, so there are m+1 kinds of cutting( i = 0 ~ m ). And we know: len(left_A) = i, len(right_A) = m - i . Note: when i = 0 , left_A is empty, and when i = m , right_A is empty.1234With the same way, cut B into two parts at a random position j: left_B | right_BB[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] Put left_A and left_B into one set, and put right_A and right_B into another set.1234Let&apos;s name them left_part and right_part : left_part | right_partA[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1]B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] If we can ensure:121) len(left_part) == len(right_part)2) max(left_part) &lt;= min(right_part) then we divide all elements in {A, B} into two parts with equal length, and one part is always greater than the other. Then median = (max(left_part) + min(right_part))/2. To ensure these two conditions, we just need to ensure:123(1) i + j == m - i + n - j (or: m - i + n - j + 1) if n &gt;= m, we just need to set: i = 0 ~ m, j = (m + n + 1)/2 - i(2) B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j] (For simplicity, I presume A[i-1],B[j-1],A[i],B[j] are always valid even if i=0/i=m/j=0/j=n . I will talk about how to deal with these edge values at last.) So, all we need to do is:12Searching i in [0, m], to find an object `i` that: B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j], ( where j = (m + n + 1)/2 - i ) And we can do a binary search following steps described below:123456789101112131415161718192021222324&lt;1&gt; Set imin = 0, imax = m, then start searching in [imin, imax]&lt;2&gt; Set i = (imin + imax)/2, j = (m + n + 1)/2 - i&lt;3&gt; Now we have len(left_part)==len(right_part). And there are only 3 situations that we may encounter: &lt;a&gt; B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j] Means we have found the object `i`, so stop searching. &lt;b&gt; B[j-1] &gt; A[i] Means A[i] is too small. We must `ajust` i to get `B[j-1] &lt;= A[i]`. Can we `increase` i? Yes. Because when i is increased, j will be decreased. So B[j-1] is decreased and A[i] is increased, and `B[j-1] &lt;= A[i]` may be satisfied. Can we `decrease` i? `No!` Because when i is decreased, j will be increased. So B[j-1] is increased and A[i] is decreased, and B[j-1] &lt;= A[i] will be never satisfied. So we must `increase` i. That is, we must ajust the searching range to [i+1, imax]. So, set imin = i+1, and goto &lt;2&gt;. &lt;c&gt; A[i-1] &gt; B[j] Means A[i-1] is too big. And we must `decrease` i to get `A[i-1]&lt;=B[j]`. That is, we must ajust the searching range to [imin, i-1]. So, set imax = i-1, and goto &lt;2&gt;. When the object i is found, the median is:12max(A[i-1], B[j-1]) (when m + n is odd) 注释 odd 奇数or (max(A[i-1], B[j-1]) + min(A[i], B[j]))/2 (when m + n is even) Now let’s consider the edges values i=0,i=m,j=0,j=n where A[i-1],B[j-1],A[i],B[j] may not exist. Actually this situation is easier than you think. What we need to do is ensuring that max(left_part) &lt;= min(right_part). So, if i and j are not edges values(means A[i-1],B[j-1],A[i],B[j] all exist), then we must check both B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]. But if some of A[i-1],B[j-1],A[i],B[j] don’t exist, then we don’t need to check one(or both) of these two conditions. For example, if i=0, then A[i-1] doesn’t exist, then we don’t need to check A[i-1] &lt;= B[j]. So, what we need to do is:123456789101112131415Searching i in [0, m], to find an object `i` that: (j == 0 or i == m or B[j-1] &lt;= A[i]) and (i == 0 or j == n or A[i-1] &lt;= B[j]) where j = (m + n + 1)/2 - iAnd in a searching loop, we will encounter only three situations:&lt;a&gt; (j == 0 or i == m or B[j-1] &lt;= A[i]) and (i == 0 or j = n or A[i-1] &lt;= B[j]) Means i is perfect, we can stop searching.&lt;b&gt; j &gt; 0 and i &lt; m and B[j - 1] &gt; A[i] Means i is too small, we must increase it.&lt;c&gt; i &gt; 0 and j &lt; n and A[i - 1] &gt; B[j] Means i is too big, we must decrease it. Thank @Quentin.chen , him pointed out that: i &lt; m ==&gt; j &gt; 0 and i &gt; 0 ==&gt; j &lt; n . Because:12m &lt;= n, i &lt; m ==&gt; j = (m+n+1)/2 - i &gt; (m+n+1)/2 - m &gt;= (2*m+1)/2 - m &gt;= 0 m &lt;= n, i &gt; 0 ==&gt; j = (m+n+1)/2 - i &lt; (m+n+1)/2 &lt;= (2*n+1)/2 &lt;= n So in situation and , we don’t need to check whether j &gt; 0 and whether j &lt; n. Below is the accepted code:1234567891011121314151617181920212223242526272829303132def median(A, B): m, n = len(A), len(B) if m &gt; n: A, B, m, n = B, A, n, m if n == 0: raise ValueError imin, imax, half_len = 0, m, (m + n + 1) / 2 while imin &lt;= imax: i = (imin + imax) / 2 j = half_len - i if i &lt; m and B[j-1] &gt; A[i]: # i is too small, must increase it imin = i + 1 elif i &gt; 0 and A[i-1] &gt; B[j]: # i is too big, must decrease it imax = i - 1 else: # i is perfect if i == 0: max_of_left = B[j-1] elif j == 0: max_of_left = A[i-1] else: max_of_left = max(A[i-1], B[j-1]) if (m + n) % 2 == 1: return max_of_left if i == m: min_of_right = B[j] elif j == n: min_of_right = A[i] else: min_of_right = min(A[i], B[j]) return (max_of_left + min_of_right) / 2.0 https://leetcode.com/discuss/15790/share-my-o-log-min-m-n-solution-with-explanation 120ms, 86.12%, June.25th, 2016 12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def findMedianSortedArrays(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: float &quot;&quot;&quot; m, n = len(nums1), len(nums2) if m &gt; n: nums1, nums2, m, n = nums2, nums1, n, m if n == 0: raise ValueError imin, imax, half_len = 0, m, (m + n + 1) / 2 while imin &lt;= imax: i = (imin + imax) / 2 j = half_len - i if j &gt; 0 and i &lt; m and nums2[j-1] &gt; nums1[i]: # i is too small, must increase it imin = i + 1 elif i &gt; 0 and j &lt; n and nums1[i-1] &gt; nums2[j]: # i is too big, must decrease it imax = i - 1 else: # i is perfect if i == 0: max_of_left = nums2[j-1] elif j == 0: max_of_left = nums1[i-1] else: max_of_left = max(nums1[i-1], nums2[j-1]) if (m + n) % 2 == 1: return max_of_left if i == m: min_of_right = nums2[j] elif j == n: min_of_right = nums1[i] else: min_of_right = min(nums1[i], nums2[j]) return (max_of_left + min_of_right) / 2.0 https://leetcode.com/discuss/20897/intuitive-python-solution-smallest-two-sorted-arrays-252ms Intuitive Python O(log (m+n)) solution, by kth smallest in the two sorted arrays, 252ms 144ms, 30.79%, June.25th, 2016 The idea is in the comment: 12345678910111213141516171819202122232425262728293031class Solution(object): def findMedianSortedArrays(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: float &quot;&quot;&quot; l = len(nums1) + len(nums2) if l % 2 == 1: return self.kth(nums1, nums2, l // 2) else: return (self.kth(nums1, nums2, l // 2) + self.kth(nums1, nums2, l // 2 - 1)) / 2. def kth(self, a, b, k): if not a: return b[k] if not b: return a[k] ia, ib = len(a) // 2, len(b) // 2 ma, mb = a[ia], b[ib] if ia + ib &lt; k: if ma &gt; mb: return self.kth(a, b[ib + 1:], k - ib - 1) else: return self.kth(a[ia + 1:], b, k -ia - 1) else: if ma &gt; mb: return self.kth(a[:ia], b, k) else: return self.kth(a, b[:ib], k) https://discuss.leetcode.com/topic/22406/python-o-log-min-m-n-solution Python O(log(min(m,n)) solution It’s guaranteed to be O(log(min(m,n)) because every time the findKth function cuts the shorter array by half of its size. 123456789101112131415161718192021class Solution: # @return a float def findMedianSortedArrays(self, A, B): l=len(A)+len(B) return self.findKth(A,B,l//2) if l%2==1 else (self.findKth(A,B,l//2-1)+self.findKth(A,B,l//2))/2.0 def findKth(self,A,B,k): if len(A)&gt;len(B): A,B=B,A if not A: return B[k] if k==len(A)+len(B)-1: return max(A[-1],B[-1]) i=len(A)//2 j=k-i if A[i]&gt;B[j]: #Here I assume it is O(1) to get A[:i] and B[j:]. In python, it&apos;s not but in cpp it is. return self.findKth(A[:i],B[j:],i) else: return self.findKth(A[i:],B[:j],j) java https://discuss.leetcode.com/topic/3367/share-my-iterative-solution-with-o-log-min-n-m Share my iterative solution with O(log(min(n, m))) This is my iterative solution using binary search. The main idea is to find the approximate location of the median and compare the elements around it to get the final result. do binary search. suppose the shorter list is A with length n. the runtime is O(log(n)) which means no matter how large B array is, it only depends on the size of A. It makes sense because if A has only one element while B has 100 elements, the median must be one of A[0], B[49], and B[50] without check everything else. If A[0] &lt;= B[49], B[49] is the answer; if B[49] &lt; A[0] &lt;= B[50], A[0] is the answer; else, B[50] is the answer. After binary search, we get the approximate location of median. Now we just need to compare at most 4 elements to find the answer. This step is O(1). the same solution can be applied to find kth element of 2 sorted arrays. Here is the code: 123456789101112131415161718192021222324252627282930313233343536public double findMedianSortedArrays(int A[], int B[]) &#123;int n = A.length;int m = B.length;// the following call is to make sure len(A) &lt;= len(B).// yes, it calls itself, but at most once, shouldn&apos;t be// consider a recursive solutionif (n &gt; m) return findMedianSortedArrays(B, A);// now, do binary searchint k = (n + m - 1) / 2;int l = 0, r = Math.min(k, n); // r is n, NOT n-1, this is important!!while (l &lt; r) &#123; int midA = (l + r) / 2; int midB = k - midA; if (A[midA] &lt; B[midB]) l = midA + 1; else r = midA;&#125;// after binary search, we almost get the median because it must be between// these 4 numbers: A[l-1], A[l], B[k-l], and B[k-l+1] // if (n+m) is odd, the median is the larger one between A[l-1] and B[k-l].// and there are some corner cases we need to take care of.int a = Math.max(l &gt; 0 ? A[l - 1] : Integer.MIN_VALUE, k - l &gt;= 0 ? B[k - l] : Integer.MIN_VALUE);if (((n + m) &amp; 1) == 1) return (double) a;// if (n+m) is even, the median can be calculated by // median = (max(A[l-1], B[k-l]) + min(A[l], B[k-l+1]) / 2.0// also, there are some corner cases to take care of.int b = Math.min(l &lt; n ? A[l] : Integer.MAX_VALUE, k - l + 1 &lt; m ? B[k - l + 1] : Integer.MAX_VALUE);return (a + b) / 2.0;&#125; I’m lazy to type. But I found a very good pdf to explain my algorithm: http://ocw.alfaisal.edu/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/30C68118-E436-4FE3-8C79-6BAFBB07D935/0/ps9sol.pdf BTW: Thanks to xdxiaoxin. I’ve removed the check “midB &gt; k”. https://discuss.leetcode.com/topic/28602/concise-java-solution-based-on-binary-search Concise JAVA solution based on Binary Search Explanation The key point of this problem is to ignore half part of A and B each step recursively by comparing the median of remaining A and B: 123if (aMid &lt; bMid) Keep [aRight + bLeft]else Keep [bRight + aLeft] As the following: time=O(log(m + n)) 123456789101112131415161718192021public double findMedianSortedArrays(int[] A, int[] B) &#123; int m = A.length, n = B.length; int l = (m + n + 1) / 2; int r = (m + n + 2) / 2; return (getkth(A, 0, B, 0, l) + getkth(A, 0, B, 0, r)) / 2.0; &#125;public double getkth(int[] A, int aStart, int[] B, int bStart, int k) &#123; if (aStart &gt; A.length - 1) return B[bStart + k - 1]; if (bStart &gt; B.length - 1) return A[aStart + k - 1]; if (k == 1) return Math.min(A[aStart], B[bStart]); int aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE; if (aStart + k/2 - 1 &lt; A.length) aMid = A[aStart + k/2 - 1]; if (bStart + k/2 - 1 &lt; B.length) bMid = B[bStart + k/2 - 1]; if (aMid &lt; bMid) return getkth(A, aStart + k/2, B, bStart, k - k/2);// Check: aRight + bLeft else return getkth(A, aStart, B, bStart + k/2, k - k/2);// Check: bRight + aLeft&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>divide and conquer</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[003. Longest Substring Without Repeating Characters]]></title>
    <url>%2Fp%2Ff34c3115%2F</url>
    <content type="text"><![CDATA[23.9% https://leetcode.com/problems/longest-substring-without-repeating-characters/ Given a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. leetcode 3 leetcode 76 leetcode 159 相似，模板相似，学习一下 方法一： 使用哈希表维护值和值的index 方法二： 既然是对数字的哈希，不如使用数组来的方便。 我的代码实现一： 实现效果最好。 最开始index都指向-1，指向开始索引的前一个位置，就是-1。 然后start就是指向索引的前一个位置。 一个end从0开始遍历至最后，start指向前一个位置。 更新时，先更新start，然后是length，最后更新索引，end++。 1234567891011121314151617class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.size(); if(n&lt;=1) return n; vector&lt;int&gt; indexs(256, -1); int start = -1, end = 0, length=0; while(end &lt; n)&#123; start = max(start, indexs[s[end]]); length = max(length, end-start); indexs[s[end]] = end; end++; &#125; return length; &#125;&#125;; 我的代码实现二： 实现逻辑清晰，但是不如上面代码。 字符要用256位，不要用26位。 12345678910111213141516171819class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int res = 0; int start = 0; vector&lt;int&gt; v(256, -1); for(int i=0; i&lt;s.size(); i++)&#123; if(v[s[i]]!=-1)&#123; start = max(start, v[s[i]]+1); res = max(res, i-start+1); v[s[i]] = i; &#125;else&#123; res = max(res, i-start+1); v[s[i]] = i; &#125; &#125; return res; &#125;&#125;; 我的代码实现: 123456789101112131415class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; indexs(256, -1); int length = 0, start = -1, end = 0; int n = s.size(); while(end&lt;n)&#123; start = max(start, indexs[s[end]]); length = max(length, end-start); indexs[s[end]] = end; end++; &#125; return length; &#125;&#125;; code 1： https://discuss.leetcode.com/topic/4083/shortest-o-n-dp-solution-with-explanations Shortest O(n) DP solution with explanations 12345678910111213141516171819202122232425262728293031323334/** * Solution (DP, O(n)): * * Assume L[i] = s[m...i], denotes the longest substring without repeating * characters that ends up at s[i], and we keep a hashmap for every * characters between m ... i, while storing &lt;character, index&gt; in the * hashmap. * We know that each character will appear only once. * Then to find s[i+1]: * 1) if s[i+1] does not appear in hashmap * we can just add s[i+1] to hash map. and L[i+1] = s[m...i+1] * 2) if s[i+1] exists in hashmap, and the hashmap value (the index) is k * let m = max(m, k), then L[i+1] = s[m...i+1], we also need to update * entry in hashmap to mark the latest occurency of s[i+1]. * * Since we scan the string for only once, and the &apos;m&apos; will also move from * beginning to end for at most once. Overall complexity is O(n). * * If characters are all in ASCII, we could use array to mimic hashmap. */int lengthOfLongestSubstring(string s) &#123; // for ASCII char sequence, use this as a hashmap vector&lt;int&gt; charIndex(256, -1); int longest = 0, m = 0; for (int i = 0; i &lt; s.length(); i++) &#123; m = max(charIndex[s[i]] + 1, m); // automatically takes care of -1 case charIndex[s[i]] = i; longest = max(longest, i - m + 1); &#125; return longest;&#125; code 2： start 表示最长字符串起始的位置。 i表示终止的位置，或者说当前到达的位置。 1234567891011121314class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; dict(256, -1); int maxLen = 0, start = -1; for (int i = 0; i != s.length(); i++) &#123; if (dict[s[i]] &gt; start) start = dict[s[i]]; dict[s[i]] = i; maxLen = max(maxLen, i - start); &#125; return maxLen; &#125;&#125;; 方法三： 我的代码实现： 12345678910111213141516171819202122class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int start = 0, length = 0, end = 0, cnt = 0; vector&lt;int&gt; v(256, 0); int n = s.size(); while(end&lt;n)&#123; if(v[s[end]]==1) cnt++; v[s[end]]++; end++; while(cnt&gt;0)&#123; if(v[s[start]]==2) cnt--; v[s[start]]--; start++; &#125; length = max(length, end-start); &#125; return length; &#125;&#125;; 有模板的，下面是详情 12345678910int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; map(128,0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++&gt;0) counter++; while(counter&gt;0) if(map[s[begin++]]--&gt;1) counter--; d=max(d, end-begin); //while valid, update d &#125; return d; &#125; 我的代码实现一： 1234567891011121314151617181920212223class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.size(); if(n&lt;=1) return n; vector&lt;int&gt; indexs(256, 0); int left = 0, right = 0, counter = 0, length = 0; while(right&lt;n)&#123; if(indexs[s[right]]&gt;0) counter++; indexs[s[right]]++; right++; while(counter&gt;0)&#123; if(indexs[s[left]]&gt;1) counter--; indexs[s[left]]--; left++; &#125; length = max(length, right-left); &#125; return length; &#125;&#125;; 我的代码实现二： 1234567891011121314151617181920212223class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; if(s.empty()) return 0; int head = 0, end = 0, d = 0, cnt = 0; vector&lt;int&gt; v(256, 0); while(end &lt; s.size())&#123; if(v[s[end]]!=0) cnt++; v[s[end]]++; end++; while(cnt&gt;0)&#123; if(v[s[head]]&gt;1) cnt--; v[s[head]]--; head++; &#125; d = max(d, end - head); &#125; return d; &#125;&#125;; 学习区： https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems I will first give the solution then show you the magic template. The code of solving this problem is below. It might be the shortest among all solutions provided in Discuss. Minimum Window Substring 12345678910111213string minWindow(string s, string t) &#123; vector&lt;int&gt; map(128,0); for(auto c: t) map[c]++; int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0; while(end&lt;s.size())&#123; if(map[s[end++]]--&gt;0) counter--; //in t while(counter==0)&#123; //valid if(end-begin&lt;d) d=end-(head=begin); if(map[s[begin++]]++==0) counter++; //make it invalid &#125; &#125; return d==INT_MAX? &quot;&quot;:s.substr(head, d); &#125; Here comes the template. For most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers. The template is given below. 12345678910111213141516171819202122232425int findSubstring(string s)&#123; vector&lt;int&gt; map(128,0); int counter; // check whether the substring is valid int begin=0, end=0; //two pointers, one point to tail and one head int d; //the length of substring for() &#123; /* initialize the hash map here */ &#125; while(end&lt;s.size())&#123; if(map[s[end++]]-- ?)&#123; /* modify counter here */ &#125; while(/* counter condition */)&#123; /* update d here if finding minimum*/ //increase begin to make it invalid/valid again if(map[s[begin++]]++ ?)&#123; /*modify counter here*/ &#125; &#125; /* update d here if finding maximum*/ &#125; return d; &#125; One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop. The code of solving Longest Substring with At Most Two Distinct Characters is below: 12345678910int lengthOfLongestSubstringTwoDistinct(string s) &#123; vector&lt;int&gt; map(128, 0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++==0) counter++; while(counter&gt;2) if(map[s[begin++]]--==1) counter--; d=max(d, end-begin); &#125; return d; &#125; The code of solving Longest Substring Without Repeating Characters is below: Update 01.04.2016, thanks @weiyi3 for advise. 12345678910int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; map(128,0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++&gt;0) counter++; while(counter&gt;0) if(map[s[begin++]]--&gt;1) counter--; d=max(d, end-begin); //while valid, update d &#125; return d; &#125; I think this post deserves some upvotes! : ) https://discuss.leetcode.com/topic/24739/c-code-in-9-lines 16ms, 62.39%, 23 July 2016 1234567891011121314class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; dict(256, -1); int maxLen = 0, start = -1; for (int i = 0; i != s.length(); i++) &#123; if (dict[s[i]] &gt; start) start = dict[s[i]]; dict[s[i]] = i; maxLen = max(maxLen, i - start); &#125; return maxLen; &#125;&#125;; https://discuss.leetcode.com/topic/1914/my-o-n-solution My O(n) Solution if only use DP, it’s an O(n*n) solution, adding a map to get O(n). 1234567891011121314151617181920class Solution &#123; public: int lengthOfLongestSubstring(string s) &#123; if(s.size()&lt;2) return s.size(); int d=1, maxLen=1; unordered_map&lt;char,int&gt; map; map[s[0]]=0; for(int i=1;i&lt;s.size();i++) &#123; if(map.count(s[i])==0 || map[s[i]]&lt;i-d) d++; else d= i- map[s[i]]; map[s[i]]=i; if(d&gt;maxLen) maxLen = d; &#125; return maxLen; &#125; &#125;; python https://discuss.leetcode.com/topic/11632/a-python-solution-85ms-o-n 104ms, 84.17%, 23 July 2016 1234567891011121314151617class Solution(object): def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; start = maxLength = 0 usedChar = &#123;&#125; for i in range(len(s)): if s[i] in usedChar and start &lt;= usedChar[s[i]]: start = usedChar[s[i]] + 1 else: maxLength = max(maxLength, i - start + 1) usedChar[s[i]] = i return maxLength java https://discuss.leetcode.com/topic/8232/11-line-simple-java-solution-o-n-with-explanation 11-line simple Java solution, O(n) with explanation the basic idea is, keep a hashmap which stores the characters in string as keys and their positions as values, and keep two pointers which define the max substring. move the right pointer to scan through the string , and meanwhile update the hashmap. If the character is already in the hashmap, then move the left pointer to the right of the same character last found. Note that the two pointers can only move forward. 12345678910111213public int lengthOfLongestSubstring(String s) &#123; if (s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max=0; for (int i=0, j=0; i&lt;s.length(); ++i)&#123; if (map.containsKey(s.charAt(i)))&#123; j = Math.max(j,map.get(s.charAt(i))+1); &#125; map.put(s.charAt(i),i); max = Math.max(max,i-j+1); &#125; return max;&#125; https://discuss.leetcode.com/topic/25499/share-my-java-solution-using-hashset Share my Java solution using HashSet The idea is use a hash set to track the longest substring without repeating characters so far, use a fast pointer j to see if character j is in the hash set or not, if not, great, add it to the hash set, move j forward and update the max length, otherwise, delete from the head by using a slow pointer i until we can put character j to the hash set. 123456789101112131415public int lengthOfLongestSubstring(String s) &#123; int i = 0, j = 0, max = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); while (j &lt; s.length()) &#123; if (!set.contains(s.charAt(j))) &#123; set.add(s.charAt(j++)); max = Math.max(max, set.size()); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return max;&#125; https://leetcode.com/articles/longest-substring-without-repeating-characters/ 思路：双指针，j在前，i在后，如果s[j]不包含，则添加进哈希表，如果包含，则去掉i，i向后走。123456789101112131415161718public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int ans = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) &#123; // try to extend the range [i, j] if (!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans, j - i); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return ans; &#125;&#125; 思路：建立map，不仅存字符还存字符的位置 123456789101112131415public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) &#123; if (map.containsKey(s.charAt(j))) &#123; i = Math.max(map.get(s.charAt(j)), i); &#125; ans = Math.max(ans, j - i + 1); map.put(s.charAt(j), j + 1); &#125; return ans; &#125;&#125; 与上一段代码思路相同 一个是length为0，return 0，检查特殊情况。 一个是做一个hashmap，存入获取的操作要好好看看。 22ms, 31.97%, 23 July 2016 https://discuss.leetcode.com/topic/8232/11-line-simple-java-solution-o-n-with-explanation/11234567891011121314public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max = 0; for(int i=0, j=0; i &lt; s.length(); ++i)&#123; if(map.containsKey(s.charAt(i))) j = Math.max(j, map.get(s.charAt(i))+1); map.put(s.charAt(i), i); max = Math.max(max, i-j+1); &#125; return max; &#125;&#125; The previous implements all have no assumption on the charset of the string s. If we know that the charset is rather small, we can replace the Map with an integer array as direct access table. Commonly used tables are: 123int[26] for Letters &apos;a&apos; - &apos;z&apos; or &apos;A&apos; - &apos;Z&apos;int[128] for ASCIIint[256] for Extended ASCII 12345678910111213public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; int[] index = new int[128]; // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) &#123; i = Math.max(index[s.charAt(j)], i); ans = Math.max(ans, j - i + 1); index[s.charAt(j)] = j + 1; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[002. Add Two Numbers]]></title>
    <url>%2Fp%2F7dbbe8ef%2F</url>
    <content type="text"><![CDATA[26.7% https://leetcode.com/problems/add-two-numbers/ You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. 12Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 方法一： 12345678910111213141516class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while(l1 || l2 || extra)&#123; int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + extra; extra = sum / 10; p-&gt;next = new ListNode(sum % 10); p = p-&gt;next; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; &#125; return preHead.next; &#125;&#125;; How about this? 123456789101112ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while (l1 || l2 || extra) &#123; if (l1) extra += l1-&gt;val, l1 = l1-&gt;next; if (l2) extra += l2-&gt;val, l2 = l2-&gt;next; p-&gt;next = new ListNode(extra % 10); extra /= 10; p = p-&gt;next; &#125; return preHead.next;&#125; 我的代码实现一： 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; if(!l1) return l2; else if(!l2) return l1; int carry = 0; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 || l2 || carry)&#123; carry += l1 ? l1-&gt;val : 0; carry += l2 ? l2-&gt;val : 0; cur-&gt;next = new ListNode(carry%10); cur = cur-&gt;next; carry /= 10; l1 = l1 ? l1-&gt;next : 0; l2 = l2 ? l2-&gt;next : 0; &#125; return dummy-&gt;next; &#125;&#125;; 我的代码实现二： 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); int carry = 0; ListNode* cur = dummy; while(l1 || l2 || carry)&#123; carry += l1 ? l1-&gt;val : 0; carry += l2 ? l2-&gt;val : 0; cur-&gt;next = new ListNode(carry%10); carry /= 10; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; cur = cur-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/5905/c-sharing-my-11-line-c-solution-can-someone-make-it-even-more-concise 40ms, 24.98%, 17 July 2016 12345678910111213141516class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while(l1 || l2 || extra)&#123; int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + extra; extra = sum / 10; p-&gt;next = new ListNode(sum % 10); p = p-&gt;next; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; &#125; return preHead.next; &#125;&#125;; https://discuss.leetcode.com/topic/5905/c-sharing-my-11-line-c-solution-can-someone-make-it-even-more-concise/4 How about this? 123456789101112ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while (l1 || l2 || extra) &#123; if (l1) extra += l1-&gt;val, l1 = l1-&gt;next; if (l2) extra += l2-&gt;val, l2 = l2-&gt;next; p-&gt;next = new ListNode(extra % 10); extra /= 10; p = p-&gt;next; &#125; return preHead.next;&#125; python https://discuss.leetcode.com/topic/21192/python-concise-solution 188ms, 7.15%, 17 July 2016 Python concise solution. 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; dummy = cur = ListNode(0) carry = 0 while l1 or l2 or carry: if l1: carry += l1.val l1 = l1.next if l2: carry += l2.val l2 = l2.next cur.next = ListNode(carry%10) cur = cur.next carry //= 10 return dummy.next https://discuss.leetcode.com/topic/8909/clear-python-code-straight-forward 172ms, 15.49%, 17 July 2016 Clear python code, straight forward 123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; carry = 0 root = n = ListNode(0) while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry, 10) n.next = ListNode(val) n = n.next return root.next https://discuss.leetcode.com/topic/8909/clear-python-code-straight-forward 1234567891011121314151617class Solution:# @return a ListNodedef addTwoNumbers(self, l1, l2): carry = 0 root = n = ListNode(0) while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry, 10) n.next = ListNode(val) n = n.next return root.next https://discuss.leetcode.com/topic/14575/python-for-the-win Python for the win Python supports arbitrarily large integers, so I can safely turn the two lists into ints, add them, and turn the sum into a list. 12345678910class Solution: def addTwoNumbers(self, l1, l2): def toint(node): return node.val + 10 * toint(node.next) if node else 0 def tolist(n): node = ListNode(n % 10) if n &gt; 9: node.next = tolist(n / 10) return node return tolist(toint(l1) + toint(l2)) Iterative tolist instead of recursive: 12345678910class Solution: def addTwoNumbers(self, l1, l2): def toint(node): return node.val + 10 * toint(node.next) if node else 0 n = toint(l1) + toint(l2) first = last = ListNode(n % 10) while n &gt; 9: n /= 10 last.next = last = ListNode(n % 10) return first And a very different solution that could sum arbitrarily many addends, not just two: 1234567891011class Solution: def addTwoNumbers(self, l1, l2): addends = l1, l2 dummy = end = ListNode(0) carry = 0 while addends or carry: carry += sum(a.val for a in addends) addends = [a.next for a in addends if a.next] end.next = end = ListNode(carry % 10) carry /= 10 return dummy.next java https://leetcode.com/articles/add-two-numbers/ Time complexity : O(\max(m, n))O(max(m,n)). Assume that mm and nn represents the length of l1l1 and l2l2 respectively, the algorithm above iterates at most \max(m, n)max(m,n) times. Space complexity : O(\max(m, n))O(max(m,n)). The length of the new list is at most \max(m,n) + 1max(m,n)+1. 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next; &#125;&#125; 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode c1 = l1; ListNode c2 = l2; ListNode sentinel = new ListNode(0); ListNode d = sentinel; int sum = 0; while (c1 != null || c2 != null) &#123; sum /= 10; if (c1 != null) &#123; sum += c1.val; c1 = c1.next; &#125; if (c2 != null) &#123; sum += c2.val; c2 = c2.next; &#125; d.next = new ListNode(sum % 10); d = d.next; &#125; if (sum / 10 == 1) d.next = new ListNode(1); return sentinel.next; &#125;&#125; https://discuss.leetcode.com/topic/799/is-this-algorithm-optimal-or-what Is this Algorithm optimal or what? 12345678910111213141516171819202122232425public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode c1 = l1; ListNode c2 = l2; ListNode sentinel = new ListNode(0); ListNode d = sentinel; int sum = 0; while (c1 != null || c2 != null) &#123; sum /= 10; if (c1 != null) &#123; sum += c1.val; c1 = c1.next; &#125; if (c2 != null) &#123; sum += c2.val; c2 = c2.next; &#125; d.next = new ListNode(sum % 10); d = d.next; &#125; if (sum / 10 == 1) d.next = new ListNode(1); return sentinel.next; &#125;&#125; https://discuss.leetcode.com/topic/6220/my-accepted-java-solution My accepted Java solution Two things to make the code simple: Whenever one of the two ListNode is null, replace it with 0. Keep the while loop going when at least one of the three conditions is met. Let me know if there is something wrong. Thanks. 12345678910111213141516171819public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode prev = new ListNode(0); ListNode head = prev; int carry = 0; while (l1 != null || l2 != null || carry != 0) &#123; ListNode cur = new ListNode(0); int sum = ((l2 == null) ? 0 : l2.val) + ((l1 == null) ? 0 : l1.val) + carry; cur.val = sum % 10; carry = sum / 10; prev.next = cur; prev = cur; l1 = (l1 == null) ? l1 : l1.next; l2 = (l2 == null) ? l2 : l2.next; &#125; return head.next; &#125;&#125; https://discuss.leetcode.com/topic/39130/4ms-11lines-java-solution 4ms 11lines java solution 1234567891011121314151617public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode ln1 = l1, ln2 = l2, head = null, node = null; int carry = 0, remainder = 0, sum = 0; head = node = new ListNode(0); while(ln1 != null || ln2 != null || carry != 0) &#123; sum = (ln1 != null ? ln1.val : 0) + (ln2 != null ? ln2.val : 0) + carry; carry = sum / 10; remainder = sum % 10; node = node.next = new ListNode(remainder); ln1 = (ln1 != null ? ln1.next : null); ln2 = (ln2 != null ? ln2.next : null); &#125; return head.next; &#125;&#125; https://discuss.leetcode.com/topic/44133/java-concise-solution Java concise solution. 12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int carry = 0; ListNode p, dummy = new ListNode(0); p = dummy; while (l1 != null || l2 != null || carry != 0) &#123; if (l1 != null) &#123; carry += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; carry += l2.val; l2 = l2.next; &#125; p.next = new ListNode(carry%10); carry /= 10; p = p.next; &#125; return dummy.next;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[001. Two Sum]]></title>
    <url>%2Fp%2F6bed6d6%2F</url>
    <content type="text"><![CDATA[31.0% https://leetcode.com/problems/two-sum/ Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. 12345Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. UPDATE (2016/2/13): The return format had been changed to zero-based indices. Please read the above updated description carefully. 思路 方法一： dic, 全部都放入dic, 依次遍历，查找当前值target缺的那部分，要缺的index大于当前的index。 1234567891011121314151617181920// 面试奇虎360时曾遇到过 // beats 45.40% of cppsubmissions.class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; mapping; vector&lt;int&gt; result; for(int i = 0; i &lt; nums.size(); i++)&#123; mapping[nums[i]] = i; &#125; for(int i = 0; i &lt; nums.size(); i++)&#123; const int gap = target - nums[i]; if(mapping.find(gap) != mapping.end() &amp;&amp; mapping[gap] &gt; i)&#123; result.push_back(i); result.push_back(mapping[gap]); &#125; &#125; return result; &#125;&#125;; 方法二： 一遍遍历，一边放入dic my code: 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res; unordered_map&lt;int, int&gt; map; for(int i=0; i&lt;nums.size(); i++)&#123; int nex = target - nums[i]; if(map.find(nex)!=map.end())&#123; res.push_back(i); res.push_back(map[nex]); break; &#125;else&#123; map[nums[i]] = i; &#125; &#125; return res; &#125;&#125;; 我的代码实现： 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2, -1); unordered_map&lt;int, int&gt; map; for(int i=0; i&lt;nums.size(); i++)&#123; int gap = target - nums[i]; if(map.count(gap))&#123; res[0] = map[gap]; res[1] = i; return res; &#125;else map[nums[i]] = i; &#125; &#125;&#125;; 48ms, 59.36%, Apr.23rd, 2016 找出数组中的两个数，这两个数和为target 扫到x时看前面Hash的数里有没有target-x，然后将x也放进Hash表。 12345678910111213class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; dict = &#123;&#125; for i in range(len(nums)): if dict.get(target - nums[i], None) == None: dict[nums[i]] = i else: return (dict[target - nums[i]], i) my code 123456789101112class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; maps = &#123;&#125; for i, num in enumerate(nums): if target-num in maps: return [i, maps[target-num]] maps[num] = i 下面这个方法速度特慢，原因:对每个元素都进行了哈希，总之，无论建立还是查找都费了时间。 上面一种方法，注意，python字典有get方法 1234567891011class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; dict = &#123;n: i for i, n in enumerate(nums)&#125; for i, n in enumerate(nums): if target-n in dict.keys() and dict[target-n] != i: return [i, dict[target-n]] java https://leetcode.com/articles/two-sum/ Approach #2 (Two-pass Hash Table) [Accepted] To improve our run time complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to look up its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table. We reduce the look up time from O(n)O(n) to O(1)O(1) by trading space for speed. A hash table is built exactly for this purpose, it supports fast look up in near constant time. I say “near” because if a collision occurred, a look up could degenerate to O(n)O(n) time. But look up in hash table should be amortized O(1)O(1) time as long as the hash function was chosen carefully. A simple implementation uses two iterations. In the first iteration, we add each element’s value and its index to the table. Then, in the second iteration we check if each element’s complement (target - nums[i]target−nums[i]) exists in the table. Beware that the complement must not be nums[i]nums[i] itself!12345678910111213public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;);&#125; Complexity Analysis: Time complexity : O(n)O(n). We traverse the list containing nn elements exactly twice. Since the hash table reduces the look up time to O(1)O(1), the time complexity is O(n)O(n). Space complexity : O(n)O(n). The extra space required depends on the number of items stored in the hash table, which stores exactly nn elements. Approach #3 (One-pass Hash Table) [Accepted] It turns out we can do it in one-pass. While we iterate and inserting elements into the table, we also look back to check if current element’s complement already exists in the table. If it exists, we have found a solution and return immediately.1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;);&#125; Complexity Analysis: Time complexity : O(n)O(n). We traverse the list containing nn elements only once. Each look up in the table costs only O(1)O(1) time. Space complexity : O(n)O(n). The extra space required depends on the number of items stored in the hash table, which stores at most nn elements.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Multi-objective Learning and Mask-based Post-processing for Deep Neural Network based Speech Enhancement》阅读笔记]]></title>
    <url>%2Fp%2F719f3cc0%2F</url>
    <content type="text"><![CDATA[这是2017年Xu Yong关于使用多任务学习和使用mask做后处理做语音增强的一篇论文[1]。 同样有github源码[2]及展示demo[3,4]。 论文原文：Multi-objective Learning and Mask-based Post-processing for Deep Neural Network based Speech Enhancement 1. Abstract论文主要的学习目标是clean log-power spectra (LPS) features，因为LPS可以直接用于构造增强后的信号。作为多任务学习，使用了附加的架构，去学习比如MFCC特征，同时去学习类别信息，比如ideal binary mask (IBM)。这些特征其实也是对DNN的一种限制，潜在的能提高LPS这个首要目标的效果。 2. Introduction3. Multi-objective Learning for DNN-based Speech Enhancement多任务学习框架如下图图1所示： 输入是带噪语音信号，输出是干净音频信号。只是输入输出有时有带噪的特征，输出是干净的特征。输出有时有类别信息。 公式2是单独的dnn+LPS训练的误差函数，公式3是多输出的。 3.1 Joint Prediction of LPS with MFCC这个就是LPS和MFCC两个的多输出了。 3.2 Joint Prediction of LPS with IBM同上，LPS+IBM 3.3 IBM-based Post-processingIBM用于LPS的后处理。如公式3，如果IBM大于一定阈值，说明SNR很高，就不必做语音增强了，所以直接用原始的语音信息。如果中间就是原始信息和增强后的信息的均值。如果低于一定阈值，就是使用处理后的信息。 4. Experimental Results and Analysis 5. Conclusion本文提出了多目标学习以改善语音增强的DNN训练。 显示目标函数中添加来自MFCC或IBM等功能的约束可获得更准确的干净的LPS估计。 MFCC可以使对数频谱失真在低频下更加一致; IBM可以明确表示T-F单元的语音呈现信息，因此可以提供更高的SSNR。 此外，可以采用估计的IBM来进行后期处理，以减轻基于回归的DNN中的高估或低估问题。 基于IBM的后处理对于减少语音失真至关重要，特别是在高信噪比T-F单元。 参考资料： https://arxiv.org/abs/1703.07172 https://github.com/yongxuUSTC/sednn http://staff.ustc.edu.cn/~jundu/The%20team/yongxu/demo/SE_DNN_taslp.html http://staff.ustc.edu.cn/~jundu/The%20team/yongxu/demo/IS15.html]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>speech enhancement</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《SEGAN: Speech Enhancement Generative Adversarial Network》阅读笔记]]></title>
    <url>%2Fp%2Fbea139a%2F</url>
    <content type="text"><![CDATA[本论文是2017年的一篇使用GAN网络做单声道语音增强的论文[1]，在github上有作者的开源代码[2]，语音增强的效果有官方示例[3]。 论文原文：SEGAN: Speech Enhancement Generative Adversarial Network 1. Introduction经典的语音增强（speech enhancement）方法有谱减法（spectral subtraction）、维纳滤波（Wiener filtering）、统计模型（statistical model-based methods）和子空间算法（subspace algorithms）。 其中统计模型有最大似然、贝叶斯、MMSE及Log-MMSE。 论文给予GAN网络（Generative Adversarial Networks）提出了segan（speech enhancementGAN），segan主要优势有三点： 它提供了一个快速语音增强过程。 没有因果关系是必需的，因此没有像RNN那样的递归操作。 它基于原始音频做处理。 因此，没有提取手工特征，因此没有对原始数据做出明确的假设。 从不同的说话人和噪声类型中学习，并将它们合并到相同的共享参数中。这使得系统在这些维度上变得简单和一般化。 2. Generative Adversarial Networks这节是GAN网络的介绍。如果有GAN网络基础，可以跳过此节。 GAN网络能是一种对抗性模型，可以将样本服从Z分布的样本z映射到服从X分布的x。 来理解这句话。在我们这里，可以理解为Z为含噪声的语音的分布，z为其中的一个样本。X为纯净语音的分布，x为其中的一个样本。 GAN中，有两个单元，一个负责映射，叫做生成器G，另一个负责判别，叫做判别器D。G负责映射，G的映射负责从Z分布映射到X分布，不同于传统的输入输出映射。判别器D是一个二分类器，输出值是0-1之间的数字。 G将样本z映射为$\hat{x}$，而真实样本为$x$，G的目的是尽可能的使$\hat{x}$与$x$相似，以迷惑判别器D。而D的功能是区分真实样本$x$和G生成的样本$\hat{x}$，真实样本尽可能的判为1，G生成的尽可能的判为0。所以G的目的在于迷惑D，而D的目的是不被G迷惑。所以叫生成对抗网络。 于是就有了对抗网络的基本公式： 其中pdata(x)表示真实样本，pz(z)表示经过G之前的样本。 意义就很明显了，对于D优化的目标就是希望真实样本输出越大，生成的样本尽可能输出小，使得结果最大。对于G，希望生成的时候，尽可能的骗过D，使得目标函数最小。 下面的公式2是带额外信息的GAN。 一些论文致力于提升GAN网络生成的质量。比如，在原始的训练中，由于使用sigmoid交叉熵损失，会出现梯度消失的问题。这时，可以将损失替换为最小平方（least square）的Least Square GAN（LSGAN）方法。结果如下： 关于gan的更多解释： 有人说GAN强大之处在于可以自动的学习原始真实样本集的数据分布，不管这个分布多么的复杂，只要训练的足够好就可以学出来。针对这一点，感觉有必要好好理解一下为什么别人会这么说。 我们知道，传统的机器学习方法，我们一般都会定义一个什么模型让数据去学习。比如说假设我们知道原始数据属于高斯分布呀，只是不知道高斯分布的参数，这个时候我们定义高斯分布，然后利用数据去学习高斯分布的参数得到我们最终的模型。再比如说我们定义一个分类器，比如SVM，然后强行让数据进行东变西变，进行各种高维映射，最后可以变成一个简单的分布，SVM可以很轻易的进行二分类分开，其实SVM已经放松了这种映射关系了，但是也是给了一个模型，这个模型就是核映射（什么径向基函数等等），说白了其实也好像是你事先知道让数据该怎么映射一样，只是核映射的参数可以学习罢了。 所有的这些方法都在直接或者间接的告诉数据你该怎么映射一样，只是不同的映射方法能力不一样。那么我们再来看看GAN，生成模型最后可以通过噪声生成一个完整的真实数据（比如人脸），说明生成模型已经掌握了从随机噪声到人脸数据的分布规律了，有了这个规律，想生成人脸还不容易。然而这个规律我们开始知道吗？显然不知道，如果让你说从随机噪声到人脸应该服从什么分布，你不可能知道。这是一层层映射之后组合起来的非常复杂的分布映射规律。然而GAN的机制可以学习到，也就是说GAN学习到了真实样本集的数据分布。 再拿原论文中的一张图来解释： 这张图表明的是GAN的生成网络如何一步步从均匀分布学习到正太分布的。原始数据x服从正太分布，这个过程你也没告诉生成网络说你得用正太分布来学习，但是生成网络学习到了。假设你改一下x的分布，不管什么分布，生成网络可能也能学到。这就是GAN可以自动学习真实数据的分布的强大之处。 还有人说GAN强大之处在于可以自动的定义潜在损失函数。 什么意思呢，这应该说的是判别网络可以自动学习到一个好的判别方法，其实就是等效的理解为可以学习到好的损失函数，来比较好或者不好的判别出来结果。虽然大的loss函数还是我们人为定义的，基本上对于多数GAN也都这么定义就可以了，但是判别网络潜在学习到的损失函数隐藏在网络之中，不同的问题这个函数就不一样，所以说可以自动学习这个潜在的损失函数。 3. Speech Enhancement GAN &amp;&amp; Experimental Setup这部分是本文的而核心SEGAN。 整个网络全部是由CNN组成。 下图是生成器G，它是一个encoder-decoder。D的结构是encoder，上面接了一个降维层。将8* 1024个参数降为8个。 encoder由步长为2的1维卷积层构成。16384×1, 8192×16, 4096×32, 2048×32, 1024×64, 512×64, 256×128, 128×128, 64×256,32×256, 16×512, and 8×1024。 至于SEGAN的训练，其实跟普通的GAN很类似。如下图所示，先训练一个判别器D。D的输入为纯净信号和经过生成器增强后的信号。然后再固定判别器D，改变生成器G的参数。 其中，有一点，在初步实验中，我们发现在G的损失中增加一个次要成分是很方便的，以便将它的世代与干净的例子之间的距离减至最小。 为了测量这种距离，我们选择了L1范数，因为它已被证明在图像处理领域有效。 所以最终G的损失函数如公式6： 4. Results分为客观和主观评价两部分。 4.1 Objective Evaluation客观评价，有以下几个指标，都是越大越好： PESQ: Perceptual evaluation of speech quality, using the wide-band version recommended in ITU-T P.862.2 (from –0.5 to 4.5).主观语音质量评估，虽然叫主观，实际还是个客观的值。 CSIG: Mean opinion score (MOS) prediction of the signal distortion attending only to the speech signal(from 1to 5). CBAK: MOS prediction of the intrusiveness of background noise (from 1 to 5). COVL: MOS prediction of the overall effect(from 1 to 5). SSNR: Segmental SNR (from 0 to ∞). 结果如下图： 可以看到，segan在PESQ指标上表现稍微差一点。在所有其他指标上，这些指标更与语音失真有关系，segan都比wiener更好。segan产生更少的语音失真（CSIG）和移除噪声更有效（CBAK和SSNR）。所以，segan能在二者之间取得更好的权衡。 4.2 Subjective Evaluation主观描述，就是一段音频，给出它原始音频、wiener处理的音频、segan处理后的音频，不显示具体哪个对应哪个，让被测试者打分，1-5之间，分数越高代表越好。 16个测试者，20个句子。效果如下图。 5. Conclusions在这项工作中，端对端语音增强方法已经在生成对抗框架内实施。该模型使用编码器-解码器完全卷积结构，使得它能够快速操作来对波形块进行去噪。 结果表明，不仅该方法是可行的，而且它也可以作当前方法的有效替代。 疑惑： 对称的解卷积是如何做的？ 参考资料： https://arxiv.org/abs/1703.09452 https://github.com/santi-pdp/segan http://veu.talp.cat/segan/ https://mp.weixin.qq.com/s?__biz=MjM5ODU3OTIyOA==&amp;mid=2650668193&amp;idx=3&amp;sn=19157c2124a9731094e23e67fd846abd&amp;scene=19#wechat_redirect https://v.qq.com/x/page/m05070a168l.html https://mp.weixin.qq.com/s?__biz=MzAwNDI4ODcxNA==&amp;mid=2652247409&amp;idx=2&amp;sn=0373c6984e722dd6542e2bc8fd983936&amp;chksm=80cc8cd4b7bb05c22cb61616307525fbb7ce5846707c5289999359704ec219aff2a9968b12d6&amp;scene=0#rd]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>speech enhancement</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vultr搭建vpn（shadowsocks）翻墙并支持北邮人bt（ipv6）下载教程]]></title>
    <url>%2Fp%2Fb4d20b2d%2F</url>
    <content type="text"><![CDATA[学习本教程，主要收获会有两个。一个是科学上网，一个能够去北邮人bt上传下载资源。详细的内容见下表，如果只为了科学上网，学习1-3即可。需要支持北邮人bt看1-4，服务器管理相关的内容放在了5，章节6主要是一些问题的解决办法。内容主要是以win为例写的，mac、android的科学上网也可以跟着本教程来。内容概要： vultr购买VPS服务器 在服务器上搭建shadowsocks 在win10配置shadowsocks 配置utorrent，支持北邮人bt 服务器管理说明 Q &amp; A 1. vultr上购买VPS服务器要科学上网，需要使用到VPS服务器，本教程使用的是vultr，费用是2.5美元/月，费用是vultr收取的，跟本教程无关。除了vultr也可以使用其他的VPS，效果类似。 一些同学用的搬瓦工，跟我的可能会有些不同。我就遇到有同学的搬瓦工vps本身不支持ipv6，对于上北邮人bt就很麻烦，这是本教程力所不能及的。本教程建议使用vultr，所有使用非vultr的vps，一定要确保支持并可以开启ipv6。不支持ipv6的结果就是对上北邮人bt等ipv6站点有影响，不影响科学上网。 1.1 注册及交费这一步就非常简单了，用下面的链接注册： https://www.vultr.com/?ref=7402906 1.2 购买服务器注册完账户，并充值后。进入以下网址购买服务器。 https://my.vultr.com/deploy/ Server Location自己随意选，但是部分的确没有2.5美元/月的服务器。地区可以全都试试，目前还是能找到2.5美元/月的服务器的。Server Type自己随意，建议用centos。Server Size随意，如果只是做vpn的话，买2.5美元/月的那个就行。Additional Features中，如果想支持ipv6， 访问北邮人bt，那么Enable IPv6必选。 然后点击Deploy Now。 然后跳转或访问以下网址： https://my.vultr.com/ 就能看到自己的ip地址（IP address）、用户名（Username，通常是root）和密码（password）了。 1.3 检查ip地址是否被墙（可跳过）这一步，win系统的同学需要打开cmd输入 ping ip并按回车，检查是否被墙。其中ip需要替换为你上一步看到的ip地址。 如果没有出现time out。恭喜这个没问题。如果你不知道如何打开cmd，可以自行百度或google，或跳过此步骤。 如果是mac，cmd替换为“终端”。 2. 在服务器上搭建shadowsocks2.1 登录服务器win下，可以使用xshell来登录。 可以下载好xshell。 mac环境，使用“终端”或“iterm2”，一样的效果。 在黑窗口里输入一下代码： 1ssh root@ip 其中ip替换为你自己的ip地址。 然后会弹出弹出一个框，输入你前几步提到的密码，并回车（enter键）。 至此，你已经登陆了。 2.2 服务器上部署shadowsocks在刚才登录的xshell服务器上，输入以下代码。 123wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 安装完成后显示效果如下，可以截图保存这些信息下面配置会用的到： 12345678910Congratulations, Shadowsocks-python server install completed!Your Server IP : your ipYour Server Port : your portYour Password : your passwordYour Encryption Method: aes-256-gcm Welcome to visit:https://teddysun.com/342.htmlEnjoy it![root@vultr ~]# 至此，服务器端的配置已经完成。 3. 在windows系统配置shadowsocks3.1 下载shadowsocks客户端Windows：https://github.com/shadowsocks/shadowsocks-windows/releases Android：https://github.com/shadowsocks/shadowsocks-android/releases mac：https://github.com/shadowsocks/ShadowsocksX-NG/releases ubuntu的配置较为复杂，可以参考[4]。 3.2 配置shadowsocks客户端以win为例，下载，并解压缩后，运行。 输入ip，port，password，及encryption点击ok就可以了。 如果是mac，解压缩后运行，在上面点击那个小飞机，出现下拉栏“服务器-新服务器”-“服务器设置”。同样是输入地址、端口、加密方法、密码，并确定就可以了。 如果是Android，操作类似，请大家自行探索。 有可能需要关闭并重新打开shadowsocks的操作，有可能不需要。 打开你的浏览器，输入 https://www.google.com/ ，那么见证奇迹的时刻到了。 如果是Android，则点击右上角的较好，进去配置服务器、远程端口、密码、加密方式、路由，然后点击右上角的对号进行保存。 然后，选中刚才配置的vpn，然后点击右下角有个飞机的那个圆圈，就可以了。快来测试下吧！ 至此，电脑及手机的科学上网已经配置完成。 4. 配置utorrent，支持北邮人bt两步，第一步将北邮人bt的网址加入支持翻墙的列表，第二步配置utorrent。都很简单。 4.1 配置shadowsocks首先通过 右键Shadowsocks托盘图标 &gt;-&gt; PAC &gt;-&gt; 编辑 GFWList 的用户规则（或 Edit User rule for GFWList） 来打开user-rule.txt。（mac用户，点击小飞机，“编辑PAC用户自定规则”） 添加如下规则并保存： 1||bt.byr.cn^ 效果如下图： 此时关闭shadowsocks，并重新打开。在地址栏里输入北邮人bt的网址: https://bt.byr.cn/ 。就可以正常访问了。 4.2 配置utorrent下载并打开utorrent。这一步就不说了。 windows用户配置方法：按快捷键：“ctrl+P”，打开utorrent的设置。设置左侧找到Connection（中文应该是连接），配置如下图红圈里所示： mac用户配置方法：按快捷键：“command+,”，打开utorrent的设置。在设置上侧找到Network（中文应该是网络），配置方法跟上图类似。就是配置proxy server，address，port，配置的内容跟上图对应的一样。同时选中下面的use proxy for hostname lookups及use proxy for peer-to-peer connections。 至此就能愉快的下载了。 本章内容除了可以用于北邮人bt，也可以用于北交大的晨光pt，只要把晨光pt的网址按类似方法加进去就可以了。 试试效果？有问题欢迎留言。下面的5是对于服务器管理用的，一般用不到，可以不看，至此完成了科学上网+支持北邮人bt。 5. 服务器管理说明此内容是用于对服务器的vpn进行管理使用的，正常情况下是不需要看这个的。 5.1 卸载方法说明：使用root用户登录，运行以下命令： 1./shadowsocks.sh uninstall 5.2 配置说明：单用户配置文件示例： 配置文件路径：/etc/shadowsocks.json12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:your_server_port, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;your_password&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 多用户多端口配置文件示例： 配置文件路径：/etc/shadowsocks.json 123456789101112131415&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123; &quot;8989&quot;:&quot;password0&quot;, &quot;9001&quot;:&quot;password1&quot;, &quot;9002&quot;:&quot;password2&quot;, &quot;9003&quot;:&quot;password3&quot;, &quot;9004&quot;:&quot;password4&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 5.3 使用命令：启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 状态：/etc/init.d/shadowsocks status 6. Q &amp; A本小结是对配置有问题的一些问题的回答。 google上不去。 这是shadowsocks都没配置好。出问题的地方可能有 一、你的服务器ip被墙了。可以尝试在cmd中敲ping ip，看看是否有time out。有time out说明你连不上服务器的，我在家就经常连不上，在公司就没问题。一个办法就是销毁服务器，重新申请台服务器的ip。我换了好几个ip都没用，我感觉我是家里的网可能有问题。 二、对于很多问题，可以尝试换个浏览器、重启shadowsocks之类的看看能不能登录。 三、看报什么错。如果是500 Internal Privoxy Error。可以修改端口号、加密方式。一些端口号可能被重点关照了，建议修改为较小的端口号， 比如一千以内的。楼下也有修改加密方式解决问题的。四、自行根据error上网搜相关资料。 google能上，bt上不去问题。 google能上，说明shadowsocks配置没问题。bt相对于普通的科学上网，多的步骤就三个，一、vps支持ipv6，二、北邮人bt的网址加入到走外网名单，三、utorrent的配置。 主要检查一和二。 bt可以上网，utorrent配置找不到或下载没速度。 那就是utorrent配置的问题了，有的同学的utorrent配置和我给的有些出入，建议更新utorrent到最新版，或许就找到对应的配置地方了。 500 Internal Privoxy Error 首先看是否能上google，如果不能，尝试修改端口号、加密方式。 如果能上能上google，不能bt，就是问题2。 参考资料： https://teddysun.com/342.html https://doub.io/ss-jc43/ https://www.cnblogs.com/edward2013/p/5560836.html https://blog.csdn.net/TotoroCyx/article/details/80032556]]></content>
      <categories>
        <category>experience of life</category>
      </categories>
      <tags>
        <tag>翻墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类任务中的模型性能评估指标详解]]></title>
    <url>%2Fp%2F82f51d0e%2F</url>
    <content type="text"><![CDATA[本文主要内容有： 错误率（Error Rate）与准确率（Accuracy、ACC） 混淆矩阵（Confusion matrix） 精确率（Precision）、召回率（Recall）、F1值（F1-score） 宏精确率（macro-P）、宏召回率（marco-R）、宏F1值（macro-F1）、微精确率（micro-P）、微召回率（micro-R）、微F1值（micro-F1） ROC与AUC Mean Average Precision @ K 回归任务的评估指标 对于分类模型常用的分类指标有1-6。这些评估指标，工程和研究中都会经常遇到，需要对其有透彻的理解和对其中的差别清楚知晓。本文对这些指标进行一些总结和归纳。 1. 错误率（Error Rate）与准确率（Accuracy、ACC）准确率亦称精度。错误率与准确率是分类任务中常见的性能度量，同时适用于二分类及多分类任务。错误率是分类错误的样本数占样本总数的比例，准确率是分类正确的样本数占样本总数的比例。显然，二者的和为1。 对于样例集$D$，分类的错误率可以定义为： $$\begin{equation}E(f; D) = \frac{1}{m} \sum_{i=1}^m {I(f(x_i) \ne y_i)}\end{equation} \tag{1}$$ 其中m表示m个类别，$y_i$表示$x_i$对应的真实标签。 准确率则定义为： $$\begin{equation}\begin{split}ACC(f; D) &amp; = \frac{1}{m} \sum_{i=1}^m {I(f(x_i) = y_i)} \\&amp; = 1 - E(f; D)\end{split}\end{equation} \tag{2}$$ 对于更一般的情况，数据分布为D，概率分布为p(·)，错误率和准确率可以描述为： $$\begin{equation}E(f; D) = \int_{x \sim D} I(f(x) \ne y)p(x) {\rm d}x\end{equation} \tag{3}$$ $$\begin{equation}\begin{split}ACC(f; D) &amp; = \int_{x \sim D} I(f(x) = y)p(x) {\rm d}x \\&amp; = 1 - E(f; D)\end{split}\end{equation} \tag{4}$$ 2. 混淆矩阵（Confusion matrix）混淆矩阵是监督学习中的一种可视化工具，主要用于比较分类结果和实例的真实信息。矩阵中的每一行代表实例的预测类别，每一列代表实例的真实类别。下表是一个二分类任务的分类结果的混淆矩阵。 - 真实值为正样本P 真实值为负样本N 预测值为P True Postive(TP) False Postive(FP) 预测值为N False Negative(FN) True Negative(TN) 在混淆矩阵中，每一个实例可以划分为以下四种类型之一： 真正(True Positive , TP)：被模型预测为正的正样本 假正(False Positive , FP)：被模型预测为正的负样本 假负(False Negative , FN)：被模型预测为负的正样本 真负(True Negative , TN)：被模型预测为负的负样本 3. 真正率、假负率、假正率及真负率定义以下几个指标 真正率(True Positive Rate, TP Rate, TPR)（灵敏度sensitivity， 也是召回率）定义为$\frac{被预测为正的正样本结果数}{正样本实际数}$，即： $$\begin{equation}TPR = \frac{TP}{TP + FN}\end{equation} \tag{5}$$ 假负率(False Negative Rate, FN Rate, FNR)定义为$\frac{被预测为负的正样本结果数}{正样本实际数}$，即： $$\begin{equation}FNR = \frac{FN}{TP + FN}\end{equation} \tag{6}$$ 假正率(False Positive Rate, FP Rate, FPR) 定义为$\frac{被预测为正的负样本结果数}{负样本实际数}$，即： $$\begin{equation}FPR = \frac{FP}{FP + TN}\end{equation} \tag{7}$$ 真负率(True Negative Rate, TN Rate, TNR)（特指度specificity）定义为$\frac{被预测为负的负样本结果数}{负样本实际数}$，即： $$\begin{equation}TNR = \frac{TN}{TN + FP}\end{equation} \tag{8}$$ 可以看出，真正（TP）和假负（FN）都是实际类别是正样本，分别被判为正及负，真正率（TPR）及假负率（FNR）都是除以正样本的总个数（TP+FN）。所以TPR+FNR=1。类似的，假正（FP）和真负（TN）都是实际样本类别是负样本，分别被判为正及负，假正率（FPR）及真负率（TNR）都是除以负样本的总数（FP+TN）。所以FPR+TNR=1。 可以看出，以上四个率（Rate）都是除以他们的真实标签对应的所有与它们真实标签相同的样本的个数。TPR、FNR二者知其一，便知另外一个。FPR、TNR也只需要知道一个便知另外一个。 一个具体的例子，就是[5]。假设你正在构建一个使用麦克风来监听用户说出特定“唤醒词”，检测到“唤醒词就唤醒系统的硬件设备。例如亚马逊的Echo倾听“Alexa”，苹果siri的“Hey Siri”，安卓的“Okay Google”及百度应用的“你好，百度”。你关心的是假正率（假阳性率）及假负率（假阴性率）。假正率（假阳性率）指没有人说唤醒词系统醒来的频率，假负率（假阴性率）是当有人说唤醒词系统没有醒来的频率。一个合理的目标是在满足每运行24小时不会有一个假阳性（满足指标）的情况下，最大限度的减少假阴性率（优化指标）。 在weka里，会显示TPR和FPR两个参数。 3. 精确率（Precision）、召回率（Recall）、F1值（F1-score）二分类问题常用的评价指标有精确率（Precision）、召回率（Recall）和F1值。精确率亦称为“查准率”，召回率亦称“查全率”。 精确率定义为： $$\begin{equation}P = \frac{TP}{TP+FP}\end{equation} \tag{9}$$ 召回率定义为： $$\begin{equation}R = \frac{TP}{TP+FN}\end{equation} \tag{10}$$ F1之定义为精确率和召回率的调和平均数，即： $$\begin{equation}\frac{2}{F1} = \frac{1}{P} + \frac{1}{R}\end{equation} \tag{11}$$ 即 $$\begin{equation}\begin{split}F1 &amp; = \frac{2PR}{P+R} \\&amp; = \frac{2}{\frac{TP+FP}{TP}+\frac{TP+FN}{TP}} \\&amp; = \frac{2TP}{2TP+FP+FN}\end{split}\end{equation} \tag{12}$$ 对于一些应用，精确率和召回率重视程度不同，比如在商品推荐中，为了减少对用户的打扰，更希望推荐用户感兴趣的，此时精确率更重要。查找逃犯时，希望尽可能的减少逃犯遗漏，则召回率更重要。于是有了F1值更一般的形势$F_\beta$，定义为精确率和召回率的加权平均数： $$\begin{equation}\frac{1+\beta^2}{F_\beta} = \frac{1}{P} + \frac{\beta^2}{R}\end{equation} \tag{13}$$ 即： $$\begin{equation}F_\beta = \frac{(1+\beta^2)PR}{\beta^2P + R}\end{equation} \tag{14}$$ 其中，$\beta &gt; 0$，$\beta$度量了精确率和召回率之间的重要性，当$\beta=1$时,就是F1；当$\beta&lt;1$时，精确率更重要；当$\beta&gt;1$时，召回率更重要。这些结论可以通过观察公式（13）得出。 4. 宏精确率（macro-P）、宏召回率（marco-R）、宏F1值（macro-F1）、微精确率（micro-P）、微召回率（micro-R）、微F1值（micro-F1）很多时候我们有多个二分类混淆矩阵，例如进行多次训练/测试，每次得到一个混淆矩阵;或是在多个数据集上进行训练/测试，希望估计算法的”全局”性能;甚或是执行多分类任务，每两两类别的组合都对应一个混淆矩阵，总之，我们希望在个二分类混淆矩阵上综合考察精确率和召回率。 一种直接的做法是现在各个混淆矩阵上分别计算出精确率和召回率，记为$(P_1, R_1),(P_2,R_2),…,(P_n, R_n)$，再计算平均值，这样就得到宏精确率（macro-P）、宏召回率（marco-R）、宏F1值（macro-F1），分别定义如下： $$\begin{equation}marco-P = \frac{1}{n} \sum_{i=1}^n P_i\end{equation} \tag{15}$$ $$\begin{equation}marco-R = \frac{1}{n} \sum_{i=1}^n R_i\end{equation} \tag{16}$$ $$\begin{equation}marco-F1 = \frac{2 \times marco-P \times macro-R}{macro-P + macro-R}\end{equation} \tag{17}$$ 除此之外，还可以将各个混淆矩阵的对应元素进行平均，得到TP、FP、TN、FN的平均值，分别记为$\overline{TP}、 \overline{FP}、 \overline{TN}、 \overline{FN}$，然后再基于这些指标，计算出微精确率（micro-P）、微召回率（micro-R）、微F1值（micro-F1），分别定义如下： $$\begin{equation}mirco-P = \frac{\overline{TP}}{\overline{TP}+\overline{FP}}\end{equation} \tag{18}$$ $$\begin{equation}mirco-R = \frac{\overline{TP}}{\overline{TP}+\overline{FN}}\end{equation} \tag{19}$$ $$\begin{equation}mirco-F1 = \frac{2 \times mirco-P \times micro-R}{micro-P + micro-R}\end{equation} \tag{20}$$ 5. ROC与AUCROC全称是受试者工作特征（Receiver Operating Characteristic）。ROC曲线的纵轴是上文提到的真正率（TPR），横轴是假正率（FPR），分别对应于公式（5）和公式（7）。此处再次搬运过来。 $$\begin{equation}TPR = \frac{TP}{TP + FN}\end{equation} \tag{21}$$ $$\begin{equation}FPR = \frac{FP}{FP + TN}\end{equation} \tag{22}$$ 正如前文分析的那样，TPR的分子为分类结果中为正样本且真实标签也为正样本的个数，分母是所有样本中正样本的个数。FPR的分子为分类结果为正样本且真实样本为负样本的个数，分母是所有样本中负样本的个数。所以对于一个固定的测试集来说，TPR、FPR的分母都是固定值。一个ROC曲线图如下所示： 对上图的四个关键点进行分析： (0,0)：TP=0，FP=0，可以发现该分类器预测所有的样本都为负样本(Negative) (1,1)：TN=0，FN=0，可以发现该分类器预测所有的样本都为正样本(Positive) (0,1)：FP=0，FN=0，它将所有的样本都正确分类 (1,0)：TP=0，TN=0，它将所有的样本都错误分类 从上面的分析我们可以看到，如果ROC曲线越靠近左上方，那么分类器的效果越好。进行学习器的比较时，若一个分类器的ROC曲线完全包住另一个分类器，那么可以判断前者的性能更好。 ROC的绘图过程是：给定$m^+$个正样本和$m^-$个负样本。根据学习期预测结果对样例进行排序，然后把分类阈值设为最大，则把所有结果预测为负样本，此时真正率和假正率均为0，在坐标（0,0）处标记一个点。然后，将分类阈值一次设为每个样本的预测值，即依次将每个样例划分为正样本。设签一个标记点坐标为（x，y），当前若为正样本，则对应标记点的坐标为$(x,y+\frac{1}{m^+})$；当前若当负样本，则对应标记点的坐标为$(x+\frac{1}{m^-}, y)$，然后用线段连接相邻点即可。 在进行学习期比较时，如果一个学习期的ROC曲线被另一个学习期的曲线完全“包住”，则可以断言后者优于前者。但是如果有交叉，则一般难以断言哪个更好。此时如果一定要比较，则较为合理的判断是比较ROC曲线下的面积，即AUC（Area Under ROC Curve）。 从以上定义可知，AUC可以通过对ROC曲线下个面积求和得到。假设ROC曲线的坐标为${(x_1, y_1),(x_2, y_2),…(x_m, y_m)}的点按序连接而成$(x_1 = 0, x_m = 1)$，则AUC可以估算为： $$\begin{equation}AUC = \frac{1}{2} \sum_{i=1}^{m-1} (x_{i+1} - x_i)(y_i + y_{i+1})\end{equation} \tag{23}$$ 6. Mean Average Precision @ K在kaggle的Freesound General-Purpose Audio Tagging Challenge[7]使用的评估方法是Mean Average Precision @ 3 (MAP@3)，该问题是每个音频文件进行自动标注，每个音频实际上只对应一个标签，但是可以做出最多三个预测标签值，对应的公式是： $$\begin{equation}MAP@3 = \frac{1}{U} \sum_{u=1}^U {\sum_{k=1}^{min(n,3)} P(k)}\end{equation} \tag{24}$$ U是样本的总个数，最后是对每个样本的评价求平均，所以关键还是要Average Precision @ 3 (AP@3），所以对应的公式是： $$\begin{equation}AP@3 = \sum_{k=1}^{min(n,3)} P(k)\end{equation} \tag{25}$$ n是预测结果的总个数，也就是限制为3。比如一个真实标签为鸟叫声的音频，可以预测为：鸟叫声，门声，玻璃破碎声。则对应的结果为AP@3 = 1 * 1 + 0 * 1/2 + 0 * 1/3 = 1。也就是每一位是有权重的，越靠前权重越高，第一位权重为1，第二位1/2，第三位为1/3。如果预测为门声，玻璃破碎声，鸟叫声，则AP@3 = 0 * 1 + 0 * 1/2 + 0 * 1/3 = 1/3 。 7. 回归任务的评估指标回归任务中最常用的性能度量是均方误差（mean squared error)： $$\begin{equation}E(f; D) = \frac{1}{m} \sum_{i=1}^m (f(x_i)-y_i)^2\end{equation} \tag{26}$$ 更一般的，对于数据分布D和概率密度函数p(·)，均方误差可以如下定义： $$\begin{equation}E(f; D) = \int_{x \sim D} (f(x) - y)^2p(x) {\rm d}x\end{equation} \tag{27}$$ 8. 后续工作与其他内容一样，有内容会持续更新。 PRC Area与MCC还需要在更新。 参考资料： http://blog.sina.com.cn/s/blog_629e606f0102v7a0.html https://en.wikipedia.org/wiki/Evaluation_of_binary_classifiers 周志华《机器学习》 李航《统计学习方法》 https://yuchenchen.gitbook.io/machine-learning-yearning/9.-you-hua-he-man-zu-zhi-biao https://zhuanlan.zhihu.com/p/25528580 https://www.kaggle.com/c/freesound-audio-tagging#evaluation]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>machine learning</tag>
        <tag>to do</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[误差反向传播（error backpropagation）推导过程【待完成】]]></title>
    <url>%2Fp%2F55aa0f10%2F</url>
    <content type="text"><![CDATA[误差反向传播算法（error backpropagation）推导过程是每个做深度学习（deep learning）的人员必会的基本功。这里是针对前馈神经网络（Feed Forward Neural Network）或者叫多层感知机（Multi Layer Perceptron）或者叫深度神经网络（Deep Neural Network）的做一个推导。此处用到的误差函数是均方误差（Mean Squared Error）。 1. 前馈神经网络简介基本网络如图1所示，这是一个基本的神经网络，下面来解析这个网络结构。 首先，我们构造输入变量$x_1,…,x_D$的线性组合，形式为： $$\begin{equation}{a_j} = \sum_{i=1}^D {w_{ji}}^{(1)} \cdot x_i + {w_{j0}}^{(1)}\end{equation} \tag{1}$$ 其中$j=1,…,M$，M是输出的总量，且上标(1)表示对应的参数是神经网络的第一层。${w_{ji}}^{(1)}$叫做权重（weight），参数$w_{j0}$叫做偏置（bias）,$a_j$叫做激活(activation)。每个激活都使用一个非线性激活函数(activation function) $h(·)$进行变换，得： $$\begin{equation}z_j = h(a_j)\end{equation} \tag{2}$$ 非线性函数$h(a_j)$通常选用sigmoid，tanh，relu等。$z_j$为经过激活函数的值。这些值会再次线性组合，得到输出单元激活（output unit activation）： $$\begin{equation}{a_k} = \sum_{i=1}^K {w_{kj}}^{(2)} \cdot z_j + {w_{k0}}^{(2)}\end{equation} \tag{3}$$ 这个变换对应于神经网络第二层，类似于之前。最后使用一个恰当的激活函数进行变换，得到神经网络的一组输出$y_k$。对于标准回归问题，激活函数是恒等函数，从而$y_k = a_k$。对于一个二元分类问题，每个输出单元激活可以使用logistic sigmoid进行变换，即: $$\begin{equation}y_k = \sigma(a_k)\end{equation} \tag{4}$$ $\sigma(·)$函数形式这里不再给出，可以自己查看。对于多分类问题，可以使用softmax激活函数。 最后综合以上的观点，我们容易得到一个网络整体，如下: $$\begin{equation}y_k = \sigma(\sum_{i=1}^K {w_{kj}}^{(2)} \cdot h(\sum_{i=1}^D {w_{ji}}^{(1)} \cdot x_i + {w_{j0}}^{(1)}) + {w_{k0}}^{(2)})\end{equation} \tag{5}$$ 其中所有权重参数和偏置被聚集在一起，记做$\vec{w}$。因此，神经网络可以简单地认为是从输入变量$\vec{x}$到输出变量$\vec{y}$的非线性函数，映射由调节参数$\vec{w}$来控制。 具体网络结构正如图1所示。计算公式（5）的过程可以认为是信息通过网络的前向传播（forward propagation）。 通过定义额外的输入变量$x_0$讲公式(1)中的偏置参数整合进权重参数集合中，并且$x_0$被限定为1，因此公式（1）可以改写为： $$\begin{equation}{a_j} = \sum_{i=0}^D {w_{ji}}^{(1)} \cdot x_i\end{equation} \tag{6}$$ 第二层的偏置也做类似处理，最终整体网络函数可以从公式（5）变为： $$\begin{equation}y_k = \sigma(\sum_{i=0}^K {w_{kj}}^{(2)} \cdot h(\sum_{i=0}^D {w_{ji}}^{(1)} \cdot x_i))\end{equation} \tag{7}$$ 至此，一个简单的前馈神经网络已经完成了。 2. 误差反向传播算法简介我们的目标是寻找一种计算前馈神经网络的误差函数$E(w)$的梯度高效的方法。我们将会看到，可以使用局部信息传递的思想来完成这一点。在局部信息传递的思想中，信息在神经网络中交替的向前、向后传播。这种方法被称为误差反向传播（error propagation），有时被称为backprop，通常简称bp算法。 关于训练过程的本质。大部分训练算法涉及到一个迭代的步骤用于误差函数的最小化，以及通过一系列的步骤进行权重调节。在每一个这样迭代过程中，我们可以区分这两个不同的阶段。在第一个阶段，误差函数关于权重的导数必须被计算出来。正如我们稍后看到的那样，反向传播算法的一个重要贡献是提供了计算这些导数的一个高效的方法。由于正是这个阶段，误差通过网络进行传播，因此我们将专门使用反向传播这个属于来描述计算导数的过程。在第二个阶段，导数用于计算权重的调整量。最简单的方法，也是最开始由Rumelhart et al.（1986）考虑的方法，涉及到梯度下降。认识到这两个阶段属于不同的阶段是很重要的。因此，第一阶段，即为了计算导数而进行的误差在网络中的反向传播阶段，可以应用于许多不同种类的网络，而不仅仅是多层感知器。它也可以 应用于其他的误差函数，而不仅仅是简单的平方和误差函数。它也可以用于计算其他类型的导数。第二阶段，即使用计算过的导数调整权重的阶段，可以使用许多最优化方法处理，许多最优化方法本质上要比简单的梯度下降更强大。 3. 简单线性模型误差导数的计算许多实际应用中使用的误差函数，例如针对一组独立同分布的数据的最大似然方法定义的误差函数，由若干项的求和公式组成。每一项对应于训练集中的一个数据点，即： $$\begin{equation}E(w) = \sum_{n=1}^N {w}\end{equation} \tag{8}$$ 这里，我们要考虑计算$\nabla E_n(w)$的问题。这可以直接使用顺序优化的方法计算，或者使用批处理方法在训练集上进行累加。 对于一个特定的输入模式n（等价于对于一个特定的样本$\vec{x}$），误差函数形式为： $$\begin{equation}E_n = \frac{1}{2} \cdot \sum_{k} {(y_{nk}-t_{nk})}^2\end{equation} \tag{9}$$ 其中$y_{nk} = y_k(\vec{x_n}, \vec{w})$，$y_{nk}$表示对于特定输入模式的输出，$t_{nk}$表示对应的实际标签（或预测值）。这个误差函数关于权重$w_{ji}$的梯度为： $$\begin{equation}\frac{E_n}{w_{ji}} = (y_{nj} - t_{nj})x_{ni}\end{equation} \tag{10}$$ 它可以表示为与链接$w_{ji}$的输出端关联的“误差信号”$y_{nj}-t_{nj}$和与链接的输入端相关连的变量$x_{ni}$的乘积。我们现在会看到这个简单的结果如何扩展到更复杂的多层前馈神经网络中。 4. 通用前馈神经网络bp算法推导 5. 一个简单的例子参考资料： BISHOP, C, M. Pattern recognition and machine learning[M]. New York:Springer, 2006. 225-244]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>to do</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 3 读取中文文件]]></title>
    <url>%2Fp%2F6821aaf2%2F</url>
    <content type="text"><![CDATA[在windows环境下，python3 读取中文文件方法，折腾了很久，总结了下。 先找到文件编码格式。 因为读文件的时候，需要知道文件的编码格式，编码格式怎么看呢？ 我的方法是，使用windows自带的记事本打开文件，然后ctrl+shift+s，或文件-另存为，可以看到文件的编码格式。 常见的编码格式有utf-8，gbk，gb2312。我今天把这些编码格式都试了发现都不能解码，最后发现文件编码格式是Unicode big endian，然后看到Stack Overflow上说，编码就是UTF-16[1]，最终解决问题。 编写相应代码。 两种方法，方法一，使用codecs模块： 123import codecswith codecs.open(file, 'r', encoding='utf-16') as f: text = f.read() 或 12with open(file, 'rb') as f: text = f.read().decode('utf-16') 方法二： 12with open(file, 'r', encoding='UTF-16') as f: text = f.read() 自己写的时候记得修改encoding为自己文件的相应格式，同时根据自己需要修改读写。 参考资料： [1]. https://stackoverflow.com/questions/8827419/converting-utf-16-utf-8-and-remove-bom]]></content>
      <categories>
        <category>experience of code</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《A consolidated perspective on multi-microphone speech enhancement and source separation》 阅读笔记【待完成】]]></title>
    <url>%2Fp%2F9c92dc77%2F</url>
    <content type="text"><![CDATA[论文A consolidated perspective on multi-microphone speech enhancement and source separation阅读分享]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>to do</tag>
        <tag>speech enhancement</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经济学人（The Economist）EPUB，MOBI,，PDF及MP3分享下载]]></title>
    <url>%2Fp%2F1c573a7b%2F</url>
    <content type="text"><![CDATA[简介《经济学人》是一份由伦敦经济学人报纸有限公司出版的杂志，创办于1843年9月，创办人詹姆士·威尔逊。杂志的大多数文章写得机智，幽默，有力度，严肃又不失诙谐，并且注重于如何在最小的篇幅内告诉读者最多的信息。该杂志又以发明巨无霸指数闻名，是社会精英必不可少的读物。该杂志英文电子版可通过移动App、网站或者有声版阅读每周完整内容。 杂志主要关注政治和商业方面的新闻，但是每期也有一两篇针对科技和艺术的报导，以及一些书评。杂志中所有文章都不署名，而且往往带有鲜明的立场，但又处处用事实说话。主编们认为：写出了什么东西，比出自谁的手笔更重要。从2012年1月28日的那一期杂志开始《经济学人》杂志开辟了中国专栏，为有关中国的文章提供更多的版面。 近期下载链接及说明内容格式含EPUB，MOBI,，PDF及MP3。点进日期进去就到了百度网盘链接，输入后面的密码就可以了。本内容会持续更新。仅供学习交流使用，请勿用作商业用途。 20180519 密码: yd8d。 20180512 密码: 7gka。 20180505 密码: ygdx。 20180428 密码：8v3d。 20180421 密码：kdpn。 20180414 密码: u2xa。 20180407 密码: z44r。 2018年1月-4月、2017年全年、2016年全年下载链接2018年全年经济学人下载（含EPUB、MOBI、PDF、MP3） 密码: ihqw。 2017年全年经济学人下载（含EPUB、MOBI、PDF、MP3） 密码: 57z5。 2016年全年经济学人下载（含EPUB、MOBI、PDF、MP3） 密码: v2bd。]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>经济学人</tag>
        <tag>The Economist</tag>
        <tag>下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[machine-learning-yearning(by Andrew Ng) 1-22章翻译最新版]]></title>
    <url>%2Fp%2Fb706c49c%2F</url>
    <content type="text"><![CDATA[machine-learning-yearning本内容是Andrew NG的My Machine Learning Yearning 1-22章内容的翻译及其原稿，会持续更新。 Andrew表示最近每周会持续更新本书籍，我决定把它翻译出来，加深自己的印象，同时希望能对大家有点帮助，后续会持续更新。 本书官网：http://www.mlyearning.org/ Andrew Ng关于本书介绍亲爱的朋友，你是如何组织一个人工智能（AI）项目的呢？ 人工智能（AI），机器学习（Machine Leaning）和深度学习（Deep learning）正在改变众多行业。我一直在写此书——Machine Learning Yearning，来教你如何构建机器学习项目。 本书的重点不在于教授机器学习算法，而在于使机器学习算法发挥作用。一些人工智能技术会给你一个锤子，而本书教你如何使用锤子。如果你渴望成为人工智能技术的领导者并想学习如何为你的团队设定方向，这本书将会有所帮助。 阅读完Machine Learning Yearning之后，你将能够： 为人工智能项目最有前途的方向设立优先级 诊断机器学习系统中的错误 在复杂设置中构建机器学习，例如不匹配的训练集/测试集 建立一个可以人类比较或超越人类表现的机器学习项目 了解何时以及如何应用端到端学习（end-to-end learning），迁移学习（transfer learning）和多任务学习（multi-task learning） 从历史上看，学习如何制定这些“策略”决策的唯一方法是在研究生课程或公司中做多年的学徒。我正在写的Machine Learning Yearning可以帮你快速的获得这项技能，以便你可以更好地构建人工智能系统。 本书大约100页，包含很多易于阅读的1-2页的章节。如果你希望收到每章完成后的草稿，请注册邮件列表。 —— 吴恩达（Andrew Ng） 翻译版gitbook阅读地址：gitbook阅读体验更好，欢迎来点击下面链接阅读翻译版： https://yuchenchen.gitbook.io/machine-learning-yearning/ 翻译版github地址：https://github.com/yucc2018/machine-learning-yearning 英文原版pdf下载：原文原版手稿已经更新到19章，下载链接分别如下: 1-14章pdf下载（2018.04.18版） 15-19章pdf下载（2018.04.25版） 20-22章pdf下载（2018.05.02版） 我自己手动将上面两部分合并，成为1-19章的合集。想下载一个的直接点下面这个链接。 1-22章合并版pdf下载（2018.05.02更新） 翻译章节：1. 为什么是机器学习策略？ 2. 如何使用本书来帮助你的团队 3. 预备知识和表示符号 4. 规模推动机器学习进度 下一部分：设置开发和测试集 5. 你的开发集和测试集 6. 你的开发集和测试集应当来自相同的分布 7. 开发集和测试集需要多大？ 8. 为你的团队进行算法优化建立一个单数字估指标 9. 优化和满足指标 10. 使用开发集和评估指标来加速迭代 11. 何时更改开发集/测试集和评估指标 12. 小结：设置开发集和测试集 下一部分：基本错误分析 13. 快速构建你的第一个系统，然后迭代 14. 错误分析：查看开发集的例子来评估想法 15. 在错误分析中并行评估多个想法 16. 清理错误标记的开发集和测试集样例 17. 如果你有一个很大的开发集，将它分成两个，而且你只看一个 18. 眼球开发集和黑盒开发集应该多大？ 19. 基本错误分析 下一部分：偏差（Bias）和方差（Variance） 20. 偏差（Bias）和方差（Variance）：错误的两大来源 21. 偏差（Bias）和方差（variance）的例子 22. 对比最优错误率 待Andrew更新后翻译章节： Addressing Bias and Variance Bias vs. Variance tradeoff Techniques for reducing avoidable bias Techniques for reducing Variance Error analysis on the training set Diagnosing bias and variance: Learning curves Plotting training error Interpreting learning curves: High bias Interpreting learning curves: Other cases Plotting learning curves Why we compare to human-level performance How to define human-level performance Surpassing human-level performance Why train and test on different distributions Whether to use all your data Whether to include inconsistent data Weighting data Generalizing from the training set to the dev set Addressing Bias, and Variance, and Data Mismatch Addressing data mismatch Artificial data synthesis The Optimization Verification test General form of Optimization Verification test Reinforcement learning example The rise of end-to-end learning More end-to-end learning examples Pros and cons of end-to-end learning Learned sub-components Directly learning rich outputs Error Analysis by Parts Beyond supervised learning: What’s next? Building a superhero team - Get your teammates to read this Big picture Credits 联系方式：6506666@gmail.com]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>machine learning</tag>
        <tag>to do</tag>
        <tag>machine learning yearning</tag>
        <tag>Andrew Ng</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年算法工程师（机器学习方向）找实习找校招经验总结]]></title>
    <url>%2Fp%2F102faecd%2F</url>
    <content type="text"><![CDATA[写在前面，这是我去年年底（2017.12）依据自己找实习找工作经历撰写，分享在北邮人bbs上的文章，觉得还是有价值的，重新发表在这里。 2017年即将过去，今年是忙碌的一年，从2月17还没开学就来学校，到现在12月初，工作的事情终于尘埃落定，现将这一段经历写下来，希望能帮助来年找工作的学弟学妹，同时，对自己来说，也是一年的工作总结，总结经验教训，对自己一个提升。 简单介绍一下，北邮本硕，要找的岗位主要是算法工程师（机器学习方向）。算法工程师找实习的时候，最终的结果是找到了四家：亚马逊、京东、滴滴、腾讯地图。找工作的时候，主要有百度sp、滴滴sp、美团sp、新浪sp、搜狗sp、小米（没谈薪资直接拒了）等。总体而言，今年找工作相对以往还是很顺利的，各大公司都很缺人，各家开出的工资相对于去年都非常诱人，找工作的情况也出乎了我们很多人的意料。 年初的时候，大概2月28左右开学吧，我2月16就来了，开始准备找实习。简单的说一下面试的情况，有些可能已经忘记，现在说个大概情况。 各家面试情况 滴滴，实习的是在论坛招人内推的，两面，第一面是主要问了svm lr等原理，简历上的项目，svm怎么用于多分类。第二面写了一道算法题，leetcode 63. Unique Paths II。问我是否会用spark，我说不会。然后就给我介绍了他们所做的项目。后来回来的路上我想了想，当时问我是否会不会spark，我应该说我虽然不会，但是可以学的，留个好印象。没过多久，就发了实习offer。后来去了滴滴实习。实习转正三面，每面半小时，所以还是相对容易了很多。转正一面，主要问了在滴滴的实习，给我的柑橘是更偏重业务，对技术并不是太热衷，做的项目的业务的主要应用是什么，将来怎么评价之类的。一道算法题，leetcode上的，旋转数组，leetcode 59. Spiral Matrix II。转正二面，也是问了问滴滴的实习，问了下gbdt的原理，xgboost与gbdt的区别，gbdt用于分类时，分类概率的梯度体现在哪里。一道编程题，矩阵A与矩阵B相乘得到矩阵C，给定A和B，求C的秩。转正三面，三面面试官是一个研究员，对数学推导有独特的兴趣。问了svm的推导，什么是凸函数，为什么拉格朗日对偶方程成立。滴滴的offer大约10月初发。 美团。实习的时候貌似没内推，走的校招。一面，上来让写了几个算法，一个是数组全排列，一个是二叉树的非递归先序遍历，一个是反转链表。然后问了过拟合问题，l1 l2正则区别之类的。然后进入二面，二面的时候面试官先问了一个二叉树的垂直遍历，LeetCode 314. Binary Tree Vertical Order Traversal（这个题是leetcode付费的题）。没答上来，就挂了。校招时是找斜对门的美团实习的大佬内推的。共三面，一面面完告知通过接着二面，二面面完告知通过让回去等三面，三面是电话面，晚上7点三面的，晚上12点就收到录取意向书。做完笔试，过了几天，晚上9点多美团打电话过来，说明天早上10点来某某酒店面试。第二天一面问了简历上的项目，编程题问了1到n的一个排好序的数组，少了一个元素，怎么找出来。我说二分查找，时间效率logn（也可以用位运算，时间效率n）。二面问了项目，我简历上有k-means，就问了其他聚类的方法，距离有多少种，影响聚类的因素。问了编程题leetcode 198 House Robber（动态规划）。三面电话面，问了项目，问了过拟合的问题产生、解决办法，问了两个编程题，leetcode 69 Sqrt(x)，两种方法解决，一种是二分查找，一种是牛顿法。另一个编程题给忘了，想起再补充。 百度。内推实习的时候，去年毕业的师兄去了百度组，我们就找他内推的。说实话，挺后悔的，我并不喜欢他这个方向，一方面我不擅长，另一方面过了我也不会去。不该图省事找他推的。内推实习时，共二面，挂了。面试主要问的是方面的，也没什么意思，答的也不好。问了leetcode 206 Reverse Linked List，让自己定义链表，问指针，对象，指针是对象吗，对C++的考察很多。到校招实习时，没投简历。到校招开始时，我投的比较晚，所以错过了内推机会，然后到了校招。校招共三面，都是技术面，当天状态不太好，感冒了。主要问了二分类的标准有多少种，每种都是什么。struct与class的区别。线程与进程的区别，io密集，计算密集使用多线程还是多进程。一个发生器，产生0的概率是p，产生1的概率是1-p，p！=0.5，怎么使用这个产生0和1等概率的发生器（可以每次产生两个数字，0 1判为0，1 0判为1，其他的舍弃重来）。k-means聚类相关问题，svm与lr的对比与区别。编程题问了多道，最小栈leetcode 155. Min Stack，还有几道其他题目，忘了已经。 腾讯。实习投的北京微信，校招投的广州微信，然而都没找我面试。找实习时，qq空间把我捞了起来邀请我面试，我拒绝了，后来腾讯地图邀请我去面试，就去了。面试一下午，从1：40到5：20，共四面，前三个为技术面，第四个为leader面，leader也问了一些技术，未来的规划，来这里之后会干什么，反正就是泛泛的聊，还有就是你印象最深刻的一件事，最感动的，最难忘的一件事，哎，这些问题。先是40分钟一套卷子，让做题，5道编程题，3道问答题可以选择做。我当时40分钟把5道编程写完就没时间了。有一道是leetcode 300 Longest Increasing Subsequence，其他忘了，不过也不难。面试聊了项目，花了不少时间，也看了那5道编程题，怎么处理POI中的名称问题，就是说一个地点可能有很多备选的名字，怎么确定哪个更合适。爬虫相关技术。还聊了聊手头的offer情况等。到后面校招内推时，投的广州微信，但是广州微信并不怎么缺人，投的人又多，所以就没给面试机会。qq音乐把我捞了起来，但我并不想去深圳，就拒绝了。再后来校招的时候，不知道腾讯哪个部门邀请我去面试开发岗。我想了想，我并不想做开发，就拒绝了。现在看起来，腾讯我还是有很多机会的，然而我都拒绝了。哎，现在仔细想一想，虽然房价高，但是深圳其他方面都挺好的，空气质量好，各种生活还是很不错的，四个面试机会，只面了一个，其他的都自己拒绝的，感觉还是非常可惜的。 新浪。实习没有投，校招投的内推，面了四面，两面技术面，三面总监面，四面hr面。主要问了项目、gbdt与xgboost的区别、贝叶斯学派和统计学派的分歧，编程题问了反转链表leetcode206，top k大的数（剑指offer题目，第一版30题）。 搜狗。实习没有投，校招内推面了两面挂了，校招面了两面，发了offer。校招内推时，也是为了省事，找的搜狗某组的大大大师兄推的，跟百度那个类似，我也不感兴趣。面试问了项目，编程问了最小编辑距离leetcode 72 Edit Distance，剑指offer 31连续子数组的最大和（找到起始位置和最大和）。校招两面。主要是项目，二分类的评价标准有哪些、分别是什么。编程有二叉树的先序中序后续非递归遍历。二面面完说去看看领导在不在，回来说领导不在，就让回来了，说后面可能有hr面。我心想，这是委婉拒绝的套路吧，过了几天hr让我去公司面，问了下学历，问考研还是保研，有哪些offer，然后发了offer。 小米。三面技术面。面试之后，发了意向书，直到前些日子才联系我。我说我已经交其他公司三方，校招结束了。编程题问了leetcode 228. Summary Ranges， 给一个二叉树，找到最深的一个节点到最浅的一个节点之间的最小公共父节点，我的方法是层次遍历，找到最浅的节点及最深的节点，然后使用 leetcode 236 Lowest Common Ancestor of a Binary Tree中的方法去解决问题，时间效率为o（n），空间效率为o（n），面试官给的方法是保存所有路径，然后去查找。问了项目，两个项目问的非常细，使用random forest计算特征重要性，对该维特征不进行permutation，删除可以不可以。峰度、偏度的数学公式及意义。二分类中AUC的具体定义，各个分类评价方法。最后三面leader面的时候还问了两个思考问题，金融违约率，可能要房贷很长时间才能知道是否违约，数据少，实验样本回收时间长所以对于这个问题怎么处理。还有就是为何利用训练集训练，用来预测测试集可以用来预测。我说的是这是基于一个大的假设，训练样本和测试样本是基于独立同分布的，后来我想了想我觉得也可以从熵 信息增益的角度思考。 京东。 京东是实习过了，校招没邀请我面试。 校招的时候，我找的京东的师兄内推的，后来也参加了校招，笔试的挺好的，就是没邀请面试，也有一些同学跟我一样的情况，可能简历挂了吧。京东实习面试是三面，两面技术面，一面hr面。感觉比较坑的是京东的三面分别安排在了三天，为此我给我们老师请了三天假。京东用的较多的是Java，我自己是cpp Python较多。面试相对简单，问了svm原理推导，两个排好序的数组怎么合并成一个排好序的数组，双指针啊。问了一个业务题场景题，给你一些恶数据，让你对顾客对一个新商品的退单率预测，如果能预测出退单率，则可以延迟或者不发货，节约物流成本。hr面的时候问了几个问题，现在厉害的很多都是博士，你怎么看，有无读博的打算？介绍一个你的项目。 亚马逊。 亚马逊也是实习过了，校招没邀请我。亚马逊实习投的早，后来邀请去面试，共两面技术面。第一面是一个美丽的北邮学姐（我不认识），主要问了简历的项目，lstm的原理，lstm为何能长时记忆。二面有两位面试官同时面，主要是编程题，也问了项目。编程题相对都是比较容易的，主要是leetcode 1 Two Sum ，leetcode 15 3Sum，leetcode 16 3Sum Closest ，leetcode 18 4Sum。还问了一个业务场景预测题，亚马逊要销售很多商品，你如何去预测商品需要用到的货仓的体积。如果能预测出货仓体积，这样子就很容易去租赁仓库了。后面的公司都是实习和校招都没过的。有的是面试未通过，有的是没有面试，也一并写下来。 360。实习三面挂，校招内推一面挂。实习面试，是我第一次去面试，面的实习，路上还想，如果360过了，实习就结束了，可惜想法是美好的，现实是残酷。实习是三面，两面技术，一面hr。上午10点面，40分钟一场，等面完二面等下午1点半还是2点开始hr面。两面技术面的的确挺不好的，那是第一次去面试，也没看网上的面经，自己的技术也并不太好。技术主要问了，svm的原理，smo算法，lstm有什么好处，为何防止梯度爆炸和梯度消失，bp推导，编程题问了树的深度，这个简单，但是代码中竟然把==错写成了=，范了这样的错误。还有问了找出二叉树中和最大的一条路径，不必经过根节点leetcode 124. Binary Tree Maximum Path Sum。 hr面的时候问了以前的实习经历，考研还保研，我说考研，问考了多少分，有无对象，将来是打算在哪里发展。校招的时候，内推去面，一挂面。问了简历项目，问了聚类算法都有那些，算法的比较，cnn的原理各个层的作用，编程题问了二分搜索。感觉面的挺好的，然而还是挂了。很多同学都说360基本不缺人。的确实习还是校招，周围过360的很少，包括很多大牛。 阿里。 实习内推一面视频面，后来的实习校招也是一面挂，校招也是视频一面挂。实习面的时候，主要问了简历项目，问了svm的原理，svm的核函数的作用，lr能不能用核函数，为什么。校招的时候，问了多元高斯函数的期望是什么，怎么推导？熵的定义是什么？怎么理解？编程题是剑指offer 30题，最小的k个数，也是leetcode 215 Kth Largest Element in an Array，写代码并分析时间复杂度。阿里实习投的是阿里妈妈，校招投的是蚂蚁金服。除了技术需要加强之外，视频面试也表现出了两个缺点，一个是表达沟通需要大大的加强，一个是要自信，同学在旁边表示我的表达太快，太紧张了。还有一个非常重要的一点，我校招内推投的太晚了（8.8投的）以至于错过了校招内推的时间点，没人找我面试，直接到了校招了。我为什么投这么晚呢？可以记住一个时间点，大概6月底，7月初就开始互联网的内推了。我们是7月开始放实习，7.4才开始去实习公司报到，那个时候想着，简历上没有个像样的实习，刚去实习的公司，什么也不会呢，简历也不好写。所以想稍微等一等，结果8.8再投的时候，差不多快结束了，我记得校招的内推是8.18左右。所以时间节点一定要把握好，千万不要拖。 网易。实习的时候是笔试挂了，校招内推也是笔试挂了，校招的时候申的深度学习工程师，校招时二面挂。第一面是一个美女姐姐，第二面试是两位面试官一起面。主要问了项目，自己搭建网络的结构，CNN网络的结构，相关知名的cnn网络结构，编程就问了一道，一些坐标点都是（x，y）形式的让以x的大小排序，x一样的按y排序，我说很简单啊，使用sort函数写个compare函数就可以了，不知道是要考察什么，要考察现场写排序算法吗？我当时应该问问的。其实我对深度学习的了解还是太少，需要更多的学习，目前更多的是工程使用上的东西，我当时应该申机器学习工程师的，或许面试就通过了。 网易游戏。 实习的时候简历挂了，校招的时候本来申的人工智能工程师，结果给我转成了游戏研发工程师，还不能更改，我去面了，一面挂。首先可以说明一点，网易和网易游戏是分开招聘的，两家可以分别投。再有就是网易游戏有两块，一块是雷火盘古，一块是互娱。我实习投的是雷火，找了互娱的同学内推了一下，最开始不知道他们内部互不承认，结果相当于没有内推，简历就给我挂了。所以投雷火一定要找雷火的人推，投互娱一定要找互娱的人推，不然等于没有推。还有就是网易游戏实习开始的特别早，去年11月还是12月，就开始内推了，现在也是12月大家可以关注下消息。今年2月份我刚过完年来学校，我同学跟我说他网易游戏已经笔试过两批了，我顿时觉得自己落后了很多，有种别人校招都结束了，你才刚来学校的feel，何况我比学校规定的开学时候早来了十多天，当时一顿慌张，赶紧问问师兄师姐到底什么情况。再有就是校招面试，先是40分钟让写道编程题，然后再去见面试官。因为他们给我调成了开发，我自己也确实没什么经验，问的全是语言细节的，算法工程师从来不怎么问的，结果可想而知，就挂了。 今日头条。实习的时候一面挂，校招的时候也是一面挂。实习的时候问了简历，当时第一家面的360，挂了。貌似第二家面的头条，也挂了，挂了很多家，心情还是挺郁闷的当时。头条实习一面的时候先让写编程题，类似于剑指offer第一版的第7章的7.2里的题目，叫做多叉树（没有指向父节点指针）中两个节点的最低公共祖先。然后问了项目，问了svm的推导，问的非常细，问距离到底如何定义的，不可分的svm中松弛变量怎么理解，如果有个点特别异常，是否还能找到分割面，我自己当时水平也比较菜，他问一个我回答一个，我回答一个，他说一句靠（kao 四声），我心里一阵慌张。问了lr的公式推导。的确面的不好。校招的时候，找的内推，当时内推要内推码，但是内推有内推码也要笔试，但是内推码有一种是内推白金码，只有头条技术员工有，且每人只有一个，有了内推白金码，可以直接面试，免笔试，早面试。我就找人要了一个内推白金码，是头条的第一批面试，挂了。校招内推挂了，不能参加后续的校招，跟360一样的。校招一面，主要问了简历，问了项目，问了一些倒排索引，词向量及复杂度相关问题。编程是leetcode 57 Insert Interval，这是leetcode的hard题目，根据大家的反应，头条编程题问的普遍相对难一些。编程题我没答上来，挂了也是很正常的事情。 海康威视。实习没投，校招投了。共三面。先是电话一面，后是去公司面试二面和三面，而面试技术面2v1，三面是hr面。一面就是简单的聊了聊，问了问。二面是聊聊平时用什么技术，用什么网络，业内（我的研究方向）主要用什么方法，业内（我的研究方向）都在做什么，对了解多少，有无转方向的意愿。也没太多的问题，更多的是发散性的问题。hr面的时候，问了有多少offer了，因为已经很晚了，我就说我现在有7家公司发了sp offer。后来没给我发offer，我觉得可能主要在于我对方向了解甚少，我本来也不是研究那个方向，但是平时还是有很多与方向学习的机会，我都不想去学。这给我一个提示，除了技术的深度，一定要提高的自己涉猎的广度。 微策略。 先是线下笔试，然后三面技术面。微策略是先去听宣讲会，然后再线上面试。笔试面试都是全英的。笔试一小时，题目还是不太难的。面试一面，13*16 = 244，问这事几进制，答：（1x+3)(x+6) = 2x^2 + 4x + 4 =&gt; x=7。证明：n(n^2-1) 对于任何n&gt;=3的奇数都可以整除。答：可以数学归纳法，假定n=2k+1满足条件，证明（2k+3)也满足，最后得到[(2k+1)^3-(2k+1)] + 24k^2 + 48k + 24显然成立。问一个字符串的全排列，我以为是leetcode 46. Permutations，实际上是leetcode 47. Permutations II。我按照46的思路写的代码，主要差别是47是有重复的。后来他提示是否有bug，我想到了47，然后改了重复的部分，但是竟然又忘了先sort下。所以这道题答的不好。这道题答的不好，我也反思过，自己不够灵活，没考虑那么多，直接对上题号了，思想僵（jiang）化了，一定要与自己做过的题目对一起做对比，注意差别。二面。给一段代码，让找出bug，里面涉及了指针和malloc和strcpy这些，我没找出bug。编程题1，一段链表，反转前n个节点。类似于leetcode 92. Reverse Linked List II。编程题2，leetcode 25. Reverse Nodes in k-Group。 编程题3，single number问题leetcode 136. Single Number，编程题4，leetcode 137. Single Number II。三面。编程题1， 121. Best Time to Buy and Sell Stock，编程题2， leetcode 123. Best Time to Buy and Sell Stock III，编程题3，leetcode 122. Best Time to Buy and Sell Stock II，编程题4，397 Integer Replacement 。编程题 2写了两种方法，思考花了些时间。编程题4给了几种解法，但遗憾的是没有给出最优解。 商汤。实习的时候笔试过了，邀请面试，我当时有三四家都要面试，还要交ppt，听说比较难，就没去面。校招的时候笔试挂了。 face++，实习没投，校招笔试挂。 微软。实习和校招都是笔试挂了。 蘑菇街&amp;美丽说。 实习投了没理我。校招内推把我简历挂了，校招又投了一次，又挂了一次简历。 freewheel，第四范式，hulu，快手等投了校招，没消息，应该是简历挂了。看周围人都投了链家网的内推，我就投了链家网，结果链家的校招是线下笔试，我不知道，就错过了。 面试心得以上就是详细的面试部分，下面是一些自己参考别人的经验及自身的经历，总结的一些经验教训吧，希望对自己是一个总结，对学弟学妹们也希望能有所帮助吧。 把握好时间实习、校招的时间表。实习分为内推阶段和校招阶段。众所周知，互联网找工作的时间越来越早。2017年今年的情况是大部分公司在2-5月（实习包含内推和校招两阶段）。先是内推，后面就是校招。也有特别早的，比如网易游戏，去年12月左右就开始内推了。内推阶段刚走完或者没有走完就开始到了实习的校招阶段了。校招也分两个阶段，内推阶段和（正式）校招阶段。时间在6月底左右-11月。很多公司在6月底7月初就开始了，比如京东、阿里、腾讯等。京东以往貌似都是比较早的，今年也是早早的面试，早早地发了offer。除了内推和校招阶段，有的公司貌似还有提前批（京东貌似有）。我自己的教训就是，校招投的太晚，以至于错过了很多面试机会。我为什么投这么晚呢？上面也分析过，有希望能把实习经历写上去，也有自己想好好复习好好准备的因素。实习的时候我投的就非常早，结果准备的不充分，遇到了很多被拒，也算是找实习遇到的小后遗症吧。投的太晚错过了腾讯、阿里的校招内推阶段，是非常可惜的。阿里的校招内推需要重新内推，腾讯的实习的简历会直接转成校招内推的，不用再推，可以更新下自己投的部门信息就行了。我自己也没去更新简历。总之吧，自己的简历不够好看，希望能刷新下简历再投，以至于错过了时间。还有亚马逊，亚马逊写的校招开始时9.10，结果我投的晚，人家9.5就开始第2轮还是第3轮笔试了。挺可惜的错过了。 把握好内推和实习转正机会。现在大家都招内推了，然后内推跟正式的也差不多了。无论从实习还是校招的结果来看，内推会吸收很大一批人，所以留给校招的名额并不多，并且所有人都参加校招，所以竞争是非常激烈的。所以大家一定要把握好内推的机会。尤其校招的时候，很多公司的实习生都转正了，占用了很多名额，所以校招的内推和校招阶段竞争还是非常激烈的，学弟学妹们还是要加油。说是实习转正，大家要千万把握好机会。如果想在某个公司留下，我个人建议，优先去该公司实习。实习转正，尤其是实习的本部门转正是最容易的。想在哪个部门工作，实习是一个非常简单又省事的途径。内推的时候最好要找熟人内推。可以帮忙查看简历进度。腾讯的内部可以看到简历评价S级、A+、A、B、C等。也可以看到面试官的名称等信息。阿里的也可以看到面试官的名称信息，并依此判断某些信息。找熟人推，方便后续的联系。还有最好直接推到自己想去的部门。如果自己有明确的部门，可以直接推到相关部门，如果不写部门，很多都是直接进公司简历池。如果写了，相当于先在部门简历池，然后进公司简历池，相对而言，相当于多了一次机会。找熟人内推的另一个好处是，如果是投的他的部门，他可以直接把简历扔给他老大，邀请你去面试。 写好简历，讲好项目。简历肯定是特别重要的，简历是面试官对你的第一印象，一定要好好写，如实稍微修饰的写。自己的会的能讲清楚明白的都写上去，自己含糊其辞的搞不太清楚容易被问懵的就不要写了。经常更新自己的简历。我自己的简历面试完就会改一改，修一修，每次都总结一下面试，修缮一下简历。简历上的项目的细节之类的自己都要清楚地明白，一定不能给面试官问的答不出来，那面试官就很怀疑你的水平和项目是否你做的了。 提高自己的编程水平。很多人都推荐剑指offer、leetcode。的确很不错的，我看现在剑指offer都更新到第二版了。至于编程提高到什么水平，剑指offer可以都看了，都搞明白了。我自己是刷了300道leetcode，刷了两遍左右的。我看周围的同学大都在100-200左右的样子，也都找到的非常不错的工作。我这里的经验是算法工程师的，很多公司的（比如滴滴、美团、百度、阿里等）算法工程岗位的面试，一场面试都是分三块，项目介绍、机器学习相关知识、编程题。一场面试一般就一道编程题。编程写不出来就基本挂了。当然面试也没有非要按一定套路的，要看面试官的，面试官喜欢问什么，我们就答什么。有的公司非常注重编程，比如微软，面试几乎全是编程题，而且编程的要求比较高。头条的编程题问的也很不容易。要是想找一般的互联网公司，感觉看完剑指offer、刷leetcode 100-200道就差不多了。当然这是我自己的判断，仅供参考，对此不负责任。还有建议是刷题的时候，要做一下笔记，经常回头看一看，我刷题的时候，使用某笔记（电子笔记类产品，避免广告嫌疑）记录一下题目，标签，解决思路与方法等。以后方便回顾。我自己就是经常看一看自己做的笔记，比每次都重头刷，思路清晰多了。建议尝试一下。 提高机器学习相关的技术水平。算法工程师一定会问机器学习相关的知识，这一块一定要好好的搞清楚明白了。我自己是看了李航老师的统计学习方法+部分prml+一些其他的学习。对这一块内容的理解应该是决定是否发大offer的关键。一般编程题都能写出来，写不出来就挂了。你对机器学习相关的理解深入程度、好的实习经历、好的论文、好的竞赛都是面试中的亮点。如果你其他方面都不能闪光的话，就把对技术的理解深入作为切入点，好好的专研下去吧。 本贴的目的在于对自己一年工作的总结与思考，同时希望能对学弟学妹们有所帮助欢迎讨论，如有不当，望指出。最后祝学弟学妹们都能有好的实习，收割大量的offer！如需转载，注明出处。 相关问题及我的想法：1.可以简单介绍一下你简历上有几个项目(我看文章里说是2个)，以及项目的大致工作吗？我自己写简历的时候也是蛮尴尬的，项目的确非常少。我自己只有一段小公司的实习经历，而且跟算法关系不大。除此之外，因为导师严格不让实习，就没有实习经历了。相对比较好的是，我们实验室都是做算法相关的，所以我把本科毕设写了进去。研究生期间导师也没有项目，所以我把我的研究方向（就是我自己研究方向做的实验，也是研究生毕设）写了进去。之前还有参加了一个小型的竞赛，所以这样子就凑够了四个项目。一般简历上大家写3-4个就够了，写太多也没太多意义。其中我的那个小公司实习面试的时候几乎没人问，所以在面实习的时候主要是问研究生相关的那个项目，那个小竞赛，还有本科毕设。后来校招的时候就把那个小公司实习给换成了滴滴的实习，把小公司实习给删了。找工作的时候大家都会问你的实习经历。当时的本科毕设做的的确比较水，又加上本科时水平菜，做的的确就那样。研究生的毕设做的还是挺认真的，还是有进步的空间。如果重新走的话，我这些都会更认真的做，找实习找工作还是非常有有用的。研一暑假是去实习的好机会，那时我们是按校历放假的，又有时间，我没有抓住。 2.项目在面试过程中的重要性是1/3左右吗？如果给项目、机器学习知识以及编程排序，应该是怎么样的？有没有项目经历不足，但用基础知识去平衡的情况？很多同学都会问项目相关问题。面试中的确会问项目，一般一个小时一场面试，常规的是20分钟聊项目，20分钟聊机器学习相关知识，最后20分钟编程并白纸算法。时间20分钟只是估计，只能说是大概。一般一面都是技术，二面可能技术也可能会随便聊。如上文所述，我也没有特别好看的项目。都是本科毕设，研究生毕设，小竞赛这样子的。大家也可以发挥聪明的脑子想想怎么写简历。至于重要性，都是非常重要的。有的面试官喜欢全程聊项目，聊着项目穿插着机器学习相关知识的提问。之前找实习的时候，很多人阿里的一面就是拿着简历聊项目及相关知识。这也涉及一个很大的问题，就是面试到底要面什么？分解起来就是要面什么内容，想考察什么能力呢？或者说一个算法工程师对这些的要求是什么呢？很直白的，很基本的就是编程，算法的理解，工程实践能力，还会考察数学知识，脑筋急转弯等，甚至更加深入的会考察你的知识的广度，深度，还有随机应变的能力。对于编程，我认为最低要求是别让编程拖你的后腿，一般来说，每场面试都会有一个编程题，一般套路是先讲思路，再写代码。代码最好bug-free。即使没有bug-free，经过提醒想明白也是可以的。大部分都会让分析下你的算法时间复杂度，空间复杂度，并能说明为什么是这个时间复杂度。很多都会追求最优解，所以这也给刷题一个提示，刷题不是ac就可以了，而是要追求最优解。编程这块可以自己把握，千万不要只追求编程，不管其他的。这多个方面要平衡下时间和精力。我之前有一段时间整天刷题，有段时间整天看算法，感觉都不是很好。最好能平衡下来，不让任何一方面去拉后腿。很多公司来说，编程会考察，但是通过的大家都给出最优解，差别也没那么大，所以多多掌握机器学习相关的算法吧，目前我是这么看的。关于工程实践，也就项目。做的项目，都是工程实现的一部分，如果什么项目都没做过，我们是面试官，我们也会对这样的面试者不放心的。像很好的实习经历，很多实验室或导师不放实习的情况下，实习经历很多同学都没有。如果有实习机会，一定要把握住。比如研一下的暑假，那个假期如果放假时间比较长的话，可以找个短期的实习，体验一下。有些如ACM大神，可能很多人是到不了这个层次的。对于多数同学来说，的确没有太好的实习经历。解决办法是如果条件允许，就去找一段实习。如果条件不允许，可以在学校好好的学好相关的机器学习理论，做好自己的课题。有些同学参加一些竞赛，也是可以的。至于排名，肯定是越靠前越好。我自己做的那个小竞赛也没拿到太好的名次。根据我的面试来看，面试官或者hr可能会问面试排名，也可能不问。但是排名并不是重点，重点是你能讲清楚你的项目中，你做了什么工作，思考出了哪些思路，都用了哪些方法，具体的工作及收获是什么。他们看到你的项目，重点还是想通过你的项目，看清楚你的能力和实力。至于这些竞赛能不能写到简历上，当然完全是可以的。机器学习算法相关的理解。很多人说，算法工程师日常工作是调参，调模型。调参和调用模型还是要理解其中的原理，才能向正确的方向走。对算法的考察，重点会考察你基本功的理解，比如svm lr的基本原理，各种分类的评价准则，l1 l2的区别等。再拓展的就是对算法广度的理解，最基本的就是对常用的一些算法有深入的理解就够了。其他相关的，算法工程师要掌握的很多，数学相关的知识用到的很多，比如矩阵，概率论相关的。比如滴滴之前问的求A和B的乘得到的矩阵C的秩，面试官聊完告诉我，这道题的重点就是考察一下数学相关的知识，因为算法工程师日常会用到很多数学知识。再比如，美团内推面试一面的时候，还问了一个概率题，我忘了写了，是这样的。一个村子特别热爱男孩，最初村子里男女平衡，但是夫妻生孩子时，如果生到女儿就会一直生，直到生到男孩为止，问，多年后，男女比例是多少?还问了两个人轮流投硬币，直到有人投到正面为赢。问先手和后手赢的概率多少。两个题很类似。到最后，无论是聊项目，还是机器学习相关算法，都是要考察你的整个的思维能力，基本功的能力。如果没有很好的项目，就从实习、竞赛、自己的实验室项目、自己的研究课题等方面找找灵感。重点还是自己对这些知识的掌握程度还有编程的能力。 3.如果没有好看的项目，简历上如何形成项目呢？或者是在目前这个紧急的阶段，可以临时做一些什么事情补救？类似问题：你做的项目是实验室的项目吗？实验室本身不是研究机器学习方向的，没有项目怎么办呢？这个问题，跟前面的有些类似。就从实习、竞赛、自己的实验室项目、研究课题等方面找灵感。我一同学，他也是通信相关方向，转nlp。就先找了一个小一点的公司实习，然后校招去了tmd中的一家。项目不是越多越好，我之前见有人简历上写了7个项目，写满了。然而这也没太多意义。简历上除了项目，可以写一下个人技能之类的，突出下自己的优点。我自己也是项目不够多，凑的。或许其他学长学姐有独特的项目技巧，我不太知道。 4.我最近参加了一个XX的比赛，但最后的名次可能不太好（猜测前10%吧，比赛没结束，最近疯狂被超，但感觉自己已经没有思路了），这种经历可以往简历上写吗？当然可以了。如前文所述，项目竞赛之类的写上简历，如果有好看的名次，肯定是好的，没有也没关系。前10%已经很不错了。我以为，面试官更看重的还是通过这个竞赛，体现了你对哪些知识的运用，自己提供这个竞赛的解决方案和思路是什么。重点还是考察你的能力和水准在哪里。如果一个竞赛，你拿到了特别靠前的名次，但面试的时候，什么也讲不出来，都是靠随便调参得来的，没有东西可以讲，还是非常尴尬的。 刷题上，笔记也做了分析也做了，但没几天前面的就感觉一点儿也想不起来了类似：很担心编程题啊。虽然在刷题，但是感觉现场还是不一定能bug-free啊，刷题好难啊编程很多考察的还在easy，偏medium的水准。当然也看公司看部门，有些公司就是看中编程，比如微软，那你想去就好好搞好编程就好了。对于很多公司来说，编程知识考察的一部分，一般都是medium水准。也有部分公司或部门考察hard的。刷题的时候，多做笔记，经常回顾，多找同学讨论。一道题，多多的思考，多多的去讨论。思路这个东西，有时候同学的理解和见识能很大的帮助你的成长。的确会忘记，但是你可以把一类题目总结下方法，或者看别人总结的方法。这个要多练习，多总结，多交流。我也确实没特别好的方法。但是我觉得经常回顾与思考，经常练习，肯定会对编程有所提升的。我自己看了cpp primer的一半和算法导论的一半左右，基本都看了算是两边多一点吧。剑指offer倒是看了四五遍。leetcode我做的题也基本在两遍以上吧。面试的时候，除了编程，有时候也会考察cpp的基本知识（如果你用cpp的话），比如虚函数的概念，struct与class的区别，指针，static等。 从你的经历来看，无论是基础的机器学习知识还是编程题（从我刷leetcode和剑指offer来看，感觉都是medium和hard的题目）的掌握来看，感觉师兄很历害，也拿到了很多sp的offer。但是在阿里的面试仅仅是因为投的较晚的原因导致的吗？是否还有其他的因素和注意的点。因为想去杭州，所以对阿里格外的关注。不仅仅是因为投的晚。我想说的是投的晚是非常重要的一个影响因素。我投的时候，我周围的同学都已经面过二面或者三面了，也就是说基本都已经结束了。所以错过内推阶段，加上内推消耗很多名额，转正也消耗了很多名额，最后留给激烈的校招的名额不多。最根本的还是自己的简历和自己的能力不够优秀或者说不足。如果能力非常强，什么时候都有机会嘛。但是对于很多人，包括我认识一些非常牛的的大神来说，还是要把握好机会，能事半功倍。我这里的建议是把握时间和机会，提前好好准备，不要犹豫。我校招投的蚂蚁金服，蚂蚁金服相对阿里其他部门来说是非常难进的部门，今年蚂蚁金服的实习貌似容易一些，我没投蚂蚁实习，校招也不容易吧。想去杭州的话，将来实习可以直接申请阿里杭州的实习，转正直接转本部门就好了。这样的一个坏处就是将来校招的时候，你可能在杭州实习，如果来北京面试其他公司，可能会不会太方便。但是你有了那边的offer，麻烦点也就那么回事。虽然有的公司内部也可以转到杭州，我觉得还是直接转会好一点。阿里的面试，根据其他同学的反馈，除了简历、项目、编程外，也会问一些数学或脑筋急转弯的问题。关于数学概率论的简单的一道题，两个随机变量X Y都符合均匀分布，那X+Y符合什么分布呢？看你想去哪个部门，多跟那里的学长学姐交流，可以针对性的准备下。 关于项目的问题。从你分享的内容来看，感觉项目占的不是很多，这一块是否占的比例比较小。因为我在实验室没做什么项目，只是学了一些相关的大数据处理工具，所以项目这一块很缺，最近打了一些比赛，这个用来充实项目是否够。关于项目，基本每场面试都会问吧。有的我可能没写要问项目。70%的面试都会先问问项目，很多都会一个或者两个。也有的会简单的问，有的深入的问。看面试官的风格。竞赛可以充实项目。只要你的竞赛跟你要找的岗位匹配的上。 你觉得公司对 数据挖掘比赛 看重的程度怎样？除非很好很知名的比赛你拿到特别好的名词，一般来说，更注重要考察的是你的知识的理解，全局把控，提出的解决方案等相关的能力。因为我自己的竞赛比较小，所以都是谈论技术相关的。其他大神的nb竞赛我也不知道怎么样的。 补充小米还问了对于类别不平衡的样本怎么处理。搜狗，对于分类使用auc f值等，对于预测问题的标准怎么评判？新浪，问了bias-variance分解问题。美团，搜狗，xgboost调哪些参数，哪些参数有效果，训练时间，是想问下具体过程。百度，svm lr损失函数对比，对噪声敏感性。还有问为何random forest能够降低误差的。新浪还问了，先验相关的，哪种先验分别对应l1 l2，还有高斯的先验是什么。阿里，熵是什么。]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>实习</tag>
        <tag>校招</tag>
        <tag>面试经验</tag>
        <tag>面经</tag>
      </tags>
  </entry>
</search>
