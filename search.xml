<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[300. Longest Increasing Subsequence]]></title>
    <url>%2Fp%2F71a6e0e6%2F</url>
    <content type="text"><![CDATA[38.4% https://leetcode.com/problems/longest-increasing-subsequence/ Given an unsorted array of integers, find the length of longest increasing subsequence. 1234For example,Given [10, 9, 2, 5, 3, 7, 101, 18],The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? è…¾è®¯åœ°å›¾é¢è¯•é¢˜ æ–¹æ³•ä¸€ï¼š dpç®—æ³• æ•ˆçŽ‡n**2 æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int n = nums.size(); // dp[i]è¡¨ç¤ºä»¥nums[i]ç»“å°¾çš„æœ€é•¿åºåˆ—çš„ä¸ªæ•° vector&lt;int&gt; dp(n, 1); for(int i=1; i&lt;n; i++) for(int j=i-1; j&gt;=0; j--) if(nums[i]&gt;nums[j]) dp[i] = max(dp[i], dp[j]+1); // dp[n-1]ä¸æ˜¯æœ€å¤§çš„ï¼Œè¦æŠŠæ‰€æœ‰éåŽ†æ‰èƒ½æ‰¾å‡ºæ¥ int res = 1; for(int i=0; i&lt;n; i++) res = max(dp[i], res); return res; &#125;&#125;; åŠ¨æ€è§„åˆ’ï¼Œè®¾å®šä¸€ä¸ªvector é•¿åº¦ä¸ºnï¼Œæ¯ä¸€ä½ä¿å­˜çš„æ˜¯ä»¥ç¬¬iä½ä¸ºç»“å°¾çš„æœ€é•¿åºåˆ—çš„é•¿åº¦ï¼Œä¾æ¬¡æ›´æ–°ã€‚ æœ€åŽdpçš„vectorä¸­çš„æœ€å¤§å€¼ä¸ºç»“æžœã€‚ ç©ºé—´æ•ˆçŽ‡ nï¼Œæ—¶é—´æ•ˆçŽ‡n**2 æˆ‘çš„ä»£ç å®žçŽ°: Dec 8th, 2017 123456789101112131415161718class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int n = nums.size(); vector&lt;int&gt; dp(n, 1); for(int i=1; i&lt;n; i++)&#123; for(int j=i-1; j&gt;=0; j--)&#123; if(nums[i]&gt;nums[j]) dp[i] = max(dp[i], dp[j]+1); &#125; &#125; int res = 0; for(int i=0; i&lt;n; i++) res = max(res, dp[i]); return res; &#125;&#125;; This is a classic problem and here is a DP solution for reference Please note a NLogN solution can be found in the following link Geek for Geek 123456789101112131415161718192021class Solution &#123;public: // There&apos;s a typical DP solution with O(N^2) Time and O(N) space // DP[i] means the result ends at i // So for dp[i], dp[i] is max(dp[j]+1), for all j &lt; i and nums[j] &lt; nums[i] int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; const int size = nums.size(); if (size == 0) &#123; return 0; &#125; vector&lt;int&gt; dp(size, 1); int res = 1; for (int i = 1; i &lt; size; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[j] &lt; nums[i]) &#123; dp[i] = max(dp[i], dp[j]+1); &#125; &#125; res = max (res, dp[i]); &#125; return res; &#125;&#125;; æˆ‘çš„å®žçŽ° dp[k]å®šä¹‰ä¸ºï¼Œä»¥num[k]ç»“å°¾çš„æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦ ç„¶åŽåˆå§‹å€¼éƒ½è®¾ä¸º1 æœ€åŽè¦éåŽ†ä¸€éï¼Œæ‰èƒ½å¾—å‡ºresï¼Œå› ä¸ºæ¯ä¸ªç»“å°¾å¹¶ä¸ä¸€æ · 1234567891011121314151617181920class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; if(n==1) return 1; vector&lt;int&gt; dp(n, 1); for(int i=1; i&lt;n; i++)&#123; for(int j=0; j&lt;i; j++)&#123; if(nums[i]&gt;nums[j]) dp[i] = max(dp[i], dp[j]+1); &#125; &#125; int res = 0; for(int k=0; k&lt;n; k++)&#123; res = max(res, dp[k]); &#125; return res; &#125;&#125;; æ–¹æ³•äºŒï¼š ä»Žç¬¬ä¸€ç§è§£æ³•å¯ä»¥çœ‹å‡ºï¼Œæœ€å…³é”®çš„æ˜¯æœ€åŽä¸€ä½ã€‚è¿™é‡Œä¿å­˜é•¿åº¦ä¸ºkçš„å­—ç¬¦ä¸²çš„æœ€åŽä¸€ä½ã€‚ å¦ä¸€ç§é«˜æ•ˆè§£æ³•ï¼Œæ—¶é—´æ•ˆçŽ‡:nlogn æˆ‘çš„ä»£ç å®žçŽ°ï¼š Dec 8th, 2017 123456789101112131415class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; vector&lt;int&gt; dp; for(auto num:nums)&#123; auto it = lower_bound(dp.begin(), dp.end(), num); if(it==dp.end()) dp.push_back(num); else *it = num; &#125; return dp.size(); &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; vector&lt;int&gt; v; for(size_t i = 0; i&lt;nums.size(); i++)&#123; auto it = lower_bound(v.begin(), v.end(), nums[i]); if(it==v.end()) v.push_back(nums[i]); else *it = nums[i]; &#125; return v.size(); &#125;&#125;; 9 lines C++ code with O(NlogN) complexity Inspired by http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/ 123456789101112class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; for(int i=0; i&lt;nums.size(); i++)&#123; auto it = std::lower_bound(res.begin(), res.end(), nums[i]); if(it==res.end()) res.push_back(nums[i]); else *it = nums[i]; &#125; return res.size(); &#125;&#125;; å…³äºŽlower_bound and upper_bound lower_bound: â€˜ &gt;= val â€˜ Return value Iterator pointing to the first element that is not less than value, or last if no such element is found. upper_bound: â€˜ &gt; val â€˜ Return value iterator pointing to the first element that is greater than value, or last if no such element is found. http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/ Longest Increasing Subsequence Size (N log N) Given an array of random numbers. Find longest increasing subsequence (LIS) in the array. I know many of you might have read recursive and dynamic programming (DP) solutions. There are few requests for O(N log N) algo in the forum posts. Recommended: Please solve it on â€œPRACTICE â€ first, before moving on to the solution.For the time being, forget about recursive and DP solutions. Let us take small samples and extend the solution to large instances. Even though it may look complex at first time, once if we understood the logic, coding is simple. Consider an input array A = {2, 5, 3}. I will extend the array during explanation. By observation we know that the LIS is either {2, 3} or {2, 5}. Note that I am considering only strictly increasing sequences. Let us add two more elements, say 7, 11 to the array. These elements will extend the existing sequences. Now the increasing sequences are {2, 3, 7, 11} and {2, 5, 7, 11} for the input array {2, 5, 3, 7, 11}. Further, we add one more element, say 8 to the array i.e. input array becomes {2, 5, 3, 7, 11, 8}. Note that the latest element 8 is greater than smallest element of any active sequence (will discuss shortly about active sequences). How can we extend the existing sequences with 8? First of all, can 8 be part of LIS? If yes, how? If we want to add 8, it should come after 7 (by replacing 11). Since the approach is offline (what we mean by offline?), we are not sure whether adding 8 will extend the series or not. Assume there is 9 in the input array, say {2, 5, 3, 7, 11, 8, 7, 9 â€¦}. We can replace 11 with 8, as there is potentially best candidate (9) that can extend the new series {2, 3, 7, 8} or {2, 5, 7, 8}. Our observation is, assume that the end element of largest sequence is E. We can add (replace) current element A[i] to the existing sequence if there is an element A[j] (j &gt; i) such that E &lt; A[i] &lt; A[j] or (E &gt; A[i] &lt; A[j] â€“ for replace). In the above example, E = 11, A[i] = 8 and A[j] = 9. In case of our original array {2, 5, 3}, note that we face same situation when we are adding 3 to increasing sequence {2, 5}. I just created two increasing sequences to make explanation simple. Instead of two sequences, 3 can replace 5 in the sequence {2, 5}. I know it will be confusing, I will clear it shortly! The question is, when will it be safe to add or replace an element in the existing sequence? Let us consider another sample A = {2, 5, 3}. Say, the next element is 1. How can it extend the current sequences {2,3} or {2, 5}. Obviously, it canâ€™t extend either. Yet, there is a potential that the new smallest element can be start of an LIS. To make it clear, consider the array is {2, 5, 3, 1, 2, 3, 4, 5, 6}. Making 1 as new sequence will create new sequence which is largest. The observation is, when we encounter new smallest element in the array, it can be a potential candidate to start new sequence. From the observations, we need to maintain lists of increasing sequences. In general, we have set of active lists of varying length. We are adding an element A[i] to these lists. We scan the lists (for end elements) in decreasing order of their length. We will verify the end elements of all the lists to find a list whose end element is smaller than A[i] (floor value). Our strategy determined by the following conditions, 12345678910111. If A[i] is smallest among all end candidates of active lists, we will start new active list of length 1.2. If A[i] is largest among all end candidates of active lists, we will clone the largest active list, and extend it by A[i].3. If A[i] is in between, we will find a list with largest end element that is smaller than A[i]. Clone and extend this list by A[i]. We will discard all other lists of same length as that of this modified list. Note that at any instance during our construction of active lists, the following condition is maintained. 1â€œend element of smaller list is smaller than end elements of larger listsâ€. It will be clear with an example, let us take example from wiki {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101A[0] = 0. Case 1. There are no active lists, create one.0.-----------------------------------------------------------------------------A[1] = 8. Case 2. Clone and extend.0.0, 8.-----------------------------------------------------------------------------A[2] = 4. Case 3. Clone, extend and discard.0.0, 4.0, 8. Discarded-----------------------------------------------------------------------------A[3] = 12. Case 2. Clone and extend.0.0, 4.0, 4, 12.-----------------------------------------------------------------------------A[4] = 2. Case 3. Clone, extend and discard.0.0, 2.0, 4. Discarded.0, 4, 12.-----------------------------------------------------------------------------A[5] = 10. Case 3. Clone, extend and discard.0.0, 2.0, 2, 10.0, 4, 12. Discarded.-----------------------------------------------------------------------------A[6] = 6. Case 3. Clone, extend and discard.0.0, 2.0, 2, 6.0, 2, 10. Discarded.-----------------------------------------------------------------------------A[7] = 14. Case 2. Clone and extend.0.0, 2.0, 2, 6.0, 2, 6, 14.-----------------------------------------------------------------------------A[8] = 1. Case 3. Clone, extend and discard.0.0, 1.0, 2. Discarded.0, 2, 6.0, 2, 6, 14.-----------------------------------------------------------------------------A[9] = 9. Case 3. Clone, extend and discard.0.0, 1.0, 2, 6.0, 2, 6, 9.0, 2, 6, 14. Discarded.-----------------------------------------------------------------------------A[10] = 5. Case 3. Clone, extend and discard.0.0, 1.0, 1, 5.0, 2, 6. Discarded.0, 2, 6, 9.-----------------------------------------------------------------------------A[11] = 13. Case 2. Clone and extend.0.0, 1.0, 1, 5.0, 2, 6, 9.0, 2, 6, 9, 13.-----------------------------------------------------------------------------A[12] = 3. Case 3. Clone, extend and discard.0.0, 1.0, 1, 3.0, 1, 5. Discarded.0, 2, 6, 9.0, 2, 6, 9, 13.-----------------------------------------------------------------------------A[13] = 11. Case 3. Clone, extend and discard.0.0, 1.0, 1, 3.0, 2, 6, 9.0, 2, 6, 9, 11.0, 2, 6, 9, 13. Discarded.-----------------------------------------------------------------------------A[14] = 7. Case 3. Clone, extend and discard.0.0, 1.0, 1, 3.0, 1, 3, 7.0, 2, 6, 9. Discarded.0, 2, 6, 9, 11.----------------------------------------------------------------------------A[15] = 15. Case 2. Clone and extend.0.0, 1.0, 1, 3.0, 1, 3, 7.0, 2, 6, 9, 11.0, 2, 6, 9, 11, 15. &lt;-- LIS List---------------------------------------------------------------------------- It is required to understand above strategy to devise an algorithm. Also, ensure we have maintained the condition, â€œend element of smaller list is smaller than end elements of larger listsâ€œ. Try with few other examples, before reading further. It is important to understand what happening to end elements. Algorithm: Querying length of longest is fairly easy. Note that we are dealing with end elements only. We need not to maintain all the lists. We can store the end elements in an array. Discarding operation can be simulated with replacement, and extending a list is analogous to adding more elements to array. We will use an auxiliary array to keep end elements. The maximum length of this array is that of input. In the worst case the array divided into N lists of size one (note that it doesâ€™t lead to worst case complexity). To discard an element, we will trace ceil value of A[i] in auxiliary array (again observe the end elements in your rough work), and replace ceil value with A[i]. We extend a list by adding element to auxiliary array. We also maintain a counter to keep track of auxiliary array length. Bonus: You have learnt Patience Sorting technique partially ðŸ™‚ Here is a proverb, â€œTell me and I will forget. Show me and I will remember. Involve me and I will understand.â€ So, pick a suit from deck of cards. Find the longest increasing sub-sequence of cards from the shuffled suit. You will never forget the approach. ðŸ™‚ Update â€“ 17 July, 2016: Quite impressive reponses from the readers and few sites referring the post, feeling happy as my hardwork helping others. It looks like readers are not doing any homework prior to posting comments. Requesting to run through some examples after reading the article, and please do your work on paper (donâ€™t use editor/compiler). The request is to help yourself. Profess to â€˜knowâ€™ is different from real understanding (no disrespect). Given below was my personal experience. Initial content preparation took roughly 6 hours to me. But, it was a good lesson. I finished initial code in an hour. When I start writing content to explain the reader, I realized I didnâ€™t understand the cases. Took my note book (I have habit of maintaining binded note book to keep track of my rough work), and after few hours I filled nearly 15 pages of rough work. Whatever the content you are seeing in the gray colored example is from these pages. All the thought process for the solution triggered by a note in the book â€˜Introduction to Algorithms by Udi Manberâ€™, I strongly recommend to practice the book. I suspect, many readers might not get the logic behind CeilIndex (binary search). I leave it as an exercise to the reader to understand how it works. Run through few examples on paper. I realized I have already covered the algorithm in another post. Update â€“ 5th August, 2016: The following link worth referring after you do your work. I got to know the link via my recently created Disqus profile. The link has explanation of approach mentioned in the Wiki. http://stackoverflow.com/questions/2631726/how-to-determine-the-longest-increasing-subsequence-using-dynamic-programming Given below is code to find length of LIS (updated to C++11 code, no C-style arrays), C++ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt; // Binary search (note boundaries in the caller)int CeilIndex(std::vector&lt;int&gt; &amp;v, int l, int r, int key) &#123; while (r-l &gt; 1) &#123; int m = l + (r-l)/2; if (v[m] &gt;= key) r = m; else l = m; &#125; return r;&#125; int LongestIncreasingSubsequenceLength(std::vector&lt;int&gt; &amp;v) &#123; if (v.size() == 0) return 0; std::vector&lt;int&gt; tail(v.size(), 0); int length = 1; // always points empty slot in tail tail[0] = v[0]; for (size_t i = 1; i &lt; v.size(); i++) &#123; if (v[i] &lt; tail[0]) // new smallest value tail[0] = v[i]; else if (v[i] &gt; tail[length-1]) // v[i] extends largest subsequence tail[length++] = v[i]; else // v[i] will become end candidate of an existing subsequence or // Throw away larger elements in all LIS, to make room for upcoming grater elements than v[i] // (and also, v[i] would have already appeared in one of LIS, identify the location and replace it) tail[CeilIndex(tail, -1, length-1, v[i])] = v[i]; &#125; return length;&#125; int main() &#123; std::vector&lt;int&gt; v&#123; 2, 5, 3, 7, 11, 8, 10, 13, 6 &#125;; std::cout &lt;&lt; "Length of Longest Increasing Subsequence is " &lt;&lt; LongestIncreasingSubsequenceLength(v) &lt;&lt; 'n'; return 0;&#125; Output: Length of Longest Increasing Subsequence is 6 Complexity: The loop runs for N elements. In the worst case (what is worst case input?), we may end up querying ceil value using binary search (log i) for many A[i]. Therefore, T(n) &lt; O( log N! ) = O(N log N). Analyse to ensure that the upper and lower bounds are also O( N log N ). The complexity is THETA (N log N). Exercises: Design an algorithm to construct the longest increasing list. Also, model your solution using DAGs. Design an algorithm to construct all increasing lists of equal longest size. Is the above algorithm an online algorithm? Design an algorithm to construct the longest decreasing list.. â€” Venki. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above. cpp https://discuss.leetcode.com/topic/28696/9-lines-c-code-with-o-nlogn-complexity 3ms, September 10, 2016 9 lines C++ code with O(NlogN) complexity Inspired by http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/ 123456789101112class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; for(int i=0; i&lt;nums.size(); i++)&#123; auto it = std::lower_bound(res.begin(), res.end(), nums[i]); if(it==res.end()) res.push_back(nums[i]); else *it = nums[i]; &#125; return res.size(); &#125;&#125;; https://discuss.leetcode.com/topic/28685/c-typical-dp-n-2-solution-and-nlogn-solution-from-geekforgeek [C++] Typical DP N^2 solution and NLogN solution from GeekForGeek This is a classic problem and here is a DP solution for reference Please note a NLogN solution can be found in the following link Geek for Geek 123456789101112131415161718192021class Solution &#123;public: // There&apos;s a typical DP solution with O(N^2) Time and O(N) space // DP[i] means the result ends at i // So for dp[i], dp[i] is max(dp[j]+1), for all j &lt; i and nums[j] &lt; nums[i] int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; const int size = nums.size(); if (size == 0) &#123; return 0; &#125; vector&lt;int&gt; dp(size, 1); int res = 1; for (int i = 1; i &lt; size; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[j] &lt; nums[i]) &#123; dp[i] = max(dp[i], dp[j]+1); &#125; &#125; res = max (res, dp[i]); &#125; return res; &#125;&#125;; http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/ Longest Increasing Subsequence Size (N log N) After few months of gap posting an algo. The current post is pending from long time, and many readers (e.g. here, here, here may be few more, I am not keeping track of all) are posting requests for explanation of the below problem. Given an array of random numbers. Find longest increasing subsequence (LIS) in the array. I know many of you might have read recursive and dynamic programming (DP) solutions. There are few requests for O(N log N) algo in the forum posts. For the time being, forget about recursive and DP solutions. Let us take small samples and extend the solution to large instances. Even though it may look complex at first time, once if we understood the logic, coding is simple. Consider an input array A = {2, 5, 3}. I will extend the array during explanation. By observation we know that the LIS is either {2, 3} or {2, 5}. Note that I am considering only strictly increasing sequences. Let us add two more elements, say 7, 11 to the array. These elements will extend the existing sequences. Now the increasing sequences are {2, 3, 7, 11} and {2, 5, 7, 11} for the input array {2, 5, 3, 7, 11}. Further, we add one more element, say 8 to the array i.e. input array becomes {2, 5, 3, 7, 11, 8}. Note that the latest element 8 is greater than smallest element of any active sequence (will discuss shortly about active sequences). How can we extend the existing sequences with 8? First of all, can 8 be part of LIS? If yes, how? If we want to add 8, it should come after 7 (by replacing 11). Since the approach is offline (what we mean by offline?), we are not sure whether adding 8 will extend the series or not. Assume there is 9 in the input array, say {2, 5, 3, 7, 11, 8, 7, 9 â€¦}. We can replace 11 with 8, as there is potentially best candidate (9) that can extend the new series {2, 3, 7, 8} or {2, 5, 7, 8}. Our observation is, assume that the end element of largest sequence is E. We can add (replace) current element A[i] to the existing sequence if there is an element A[j] (j &gt; i) such that E &lt; A[i] &lt; A[j] or (E &gt; A[i] &lt; A[j] â€“ for replace). In the above example, E = 11, A[i] = 8 and A[j] = 9. In case of our original array {2, 5, 3}, note that we face same situation when we are adding 3 to increasing sequence {2, 5}. I just created two increasing sequences to make explanation simple. Instead of two sequences, 3 can replace 5 in the sequence {2, 5}. I know it will be confusing, I will clear it shortly! The question is, when will it be safe to add or replace an element in the existing sequence? Let us consider another sample A = {2, 5, 3}. Say, the next element is 1. How can it extend the current sequences {2,3} or {2, 5}. Obviously, it canâ€™t extend either. Yet, there is a potential that the new smallest element can be start of an LIS. To make it clear, consider the array is {2, 5, 3, 1, 2, 3, 4, 5, 6}. Making 1 as new sequence will create new sequence which is largest. The observation is, when we encounter new smallest element in the array, it can be a potential candidate to start new sequence. From the observations, we need to maintain lists of increasing sequences. In general, we have set of active lists of varying length. We are adding an element A[i] to these lists. We scan the lists (for end elements) in decreasing order of their length. We will verify the end elements of all the lists to find a list whose end element is smaller than A[i] (floor value). Our strategy determined by the following conditions, 1231. If A[i] is smallest among all end candidates of active lists, we will start new active list of length 1. 1232. If A[i] is largest among all end candidates of active lists, we will clone the largest active list, and extend it by A[i]. 12343. If A[i] is in between, we will find a list with largest end element that is smaller than A[i]. Clone and extend this list by A[i]. We will discard all other lists of same length as that of this modified list. Note that at any instance during our construction of active lists, the following condition is maintained. â€œend element of smaller list is smaller than end elements of larger listsâ€. It will be clear with an example, let us take example from wiki {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101A[0] = 0. Case 1. There are no active lists, create one.0.-----------------------------------------------------------------------------A[1] = 8. Case 2. Clone and extend.0.0, 8.-----------------------------------------------------------------------------A[2] = 4. Case 3. Clone, extend and discard.0.0, 4.0, 8. Discarded-----------------------------------------------------------------------------A[3] = 12. Case 2. Clone and extend.0.0, 4.0, 4, 12.-----------------------------------------------------------------------------A[4] = 2. Case 3. Clone, extend and discard.0.0, 2.0, 4. Discarded.0, 4, 12.-----------------------------------------------------------------------------A[5] = 10. Case 3. Clone, extend and discard.0.0, 2.0, 2, 10.0, 4, 12. Discarded.-----------------------------------------------------------------------------A[6] = 6. Case 3. Clone, extend and discard.0.0, 2.0, 2, 6.0, 2, 10. Discarded.-----------------------------------------------------------------------------A[7] = 14. Case 2. Clone and extend.0.0, 2.0, 2, 6.0, 2, 6, 14.-----------------------------------------------------------------------------A[8] = 1. Case 3. Clone, extend and discard.0.0, 1.0, 2. Discarded.0, 2, 6.0, 2, 6, 14.-----------------------------------------------------------------------------A[9] = 9. Case 3. Clone, extend and discard.0.0, 1.0, 2, 6.0, 2, 6, 9.0, 2, 6, 14. Discarded.-----------------------------------------------------------------------------A[10] = 5. Case 3. Clone, extend and discard.0.0, 1.0, 1, 5.0, 2, 6. Discarded.0, 2, 6, 9.-----------------------------------------------------------------------------A[11] = 13. Case 2. Clone and extend.0.0, 1.0, 1, 5.0, 2, 6, 9.0, 2, 6, 9, 13.-----------------------------------------------------------------------------A[12] = 3. Case 3. Clone, extend and discard.0.0, 1.0, 1, 3.0, 1, 5. Discarded.0, 2, 6, 9.0, 2, 6, 9, 13.-----------------------------------------------------------------------------A[13] = 11. Case 3. Clone, extend and discard.0.0, 1.0, 1, 3.0, 2, 6, 9.0, 2, 6, 9, 11.0, 2, 6, 9, 13. Discarded.-----------------------------------------------------------------------------A[14] = 7. Case 3. Clone, extend and discard.0.0, 1.0, 1, 3.0, 1, 3, 7.0, 2, 6, 9. Discarded.0, 2, 6, 9, 11.----------------------------------------------------------------------------A[15] = 15. Case 2. Clone and extend.0.0, 1.0, 1, 3.0, 1, 3, 7.0, 2, 6, 9, 11.0, 2, 6, 9, 11, 15. &lt;-- LIS List---------------------------------------------------------------------------- It is required to understand above strategy to devise an algorithm. Also, ensure we have maintained the condition, â€œend element of smaller list is smaller than end elements of larger listsâ€œ. Try with few other examples, before reading further. It is important to understand what happening to end elements. Algorithm: Querying length of longest is fairly easy. Note that we are dealing with end elements only. We need not to maintain all the lists. We can store the end elements in an array. Discarding operation can be simulated with replacement, and extending a list is analogous to adding more elements to array. We will use an auxiliary array to keep end elements. The maximum length of this array is that of input. In the worst case the array divided into N lists of size one (note that it doesâ€™t lead to worst case complexity). To discard an element, we will trace ceil value of A[i] in auxiliary array (again observe the end elements in your rough work), and replace ceil value with A[i]. We extend a list by adding element to auxiliary array. We also maintain a counter to keep track of auxiliary array length. Bonus: You have learnt Patience Sorting technique partially ðŸ™‚ Here is a proverb, â€œTell me and I will forget. Show me and I will remember. Involve me and I will understand.â€ So, pick a suit from deck of cards. Find the longest increasing sub-sequence of cards from the shuffled suit. You will never forget the approach. ðŸ™‚ Update â€“ 17 July, 2016: Quite impressive reponses from the readers and few sites referring the post, feeling happy as my hardwork helping others. It looks like readers are not doing any homework prior to posting comments. Requesting to run through some examples after reading the article, and please do your work on paper (donâ€™t use editor/compiler). The request is to help yourself. Profess to â€˜knowâ€™ is different from real understanding (no disrespect). Given below was my personal experience. Initial content preparation took roughly 6 hours to me. But, it was a good lesson. I finished initial code in an hour. When I start writing content to explain the reader, I realized I didnâ€™t understand the cases. Took my note book (I have habit of maintaining binded note book to keep track of my rough work), and after few hours I filled nearly 15 pages of rough work. Whatever the content you are seeing in the gray colored example is from these pages. All the thought process for the solution triggered by a note in the book â€˜Introduction to Algorithms by Udi Manberâ€™, I strongly recommend to practice the book. I suspect, many readers might not get the logic behind CeilIndex (binary search). I leave it as an exercise to the reader to understand how it works. Run through few examples on paper. I realized I have already covered the algorithm in another post. Update â€“ 5th August, 2016: The following link worth referring after you do your work. I got to know the link via my recently created Disqus profile. The link has explanation of approach mentioned in the Wiki. http://stackoverflow.com/questions/2631726/how-to-determine-the-longest-increasing-subsequence-using-dynamic-programming Given below is code to find length of LIS (updated to C++11 code, no C-style arrays), cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt; // Binary search (note boundaries in the caller)int CeilIndex(std::vector&lt;int&gt; &amp;v, int l, int r, int key) &#123; while (r-l &gt; 1) &#123; int m = l + (r-l)/2; if (v[m] &gt;= key) r = m; else l = m; &#125; return r;&#125; int LongestIncreasingSubsequenceLength(std::vector&lt;int&gt; &amp;v) &#123; if (v.size() == 0) return 0; std::vector&lt;int&gt; tail(v.size(), 0); int length = 1; // always points empty slot in tail tail[0] = v[0]; for (size_t i = 1; i &lt; v.size(); i++) &#123; if (v[i] &lt; tail[0]) // new smallest value tail[0] = v[i]; else if (v[i] &gt; tail[length-1]) // v[i] extends largest subsequence tail[length++] = v[i]; else // v[i] will become end candidate of an existing subsequence or // Throw away larger elements in all LIS, to make room for upcoming grater elements than v[i] // (and also, v[i] would have already appeared in one of LIS, identify the location and replace it) tail[CeilIndex(tail, -1, length-1, v[i])] = v[i]; &#125; return length;&#125; int main() &#123; std::vector&lt;int&gt; v&#123; 2, 5, 3, 7, 11, 8, 10, 13, 6 &#125;; std::cout &lt;&lt; &quot;Length of Longest Increasing Subsequence is &quot; &lt;&lt; LongestIncreasingSubsequenceLength(v) &lt;&lt; &apos;\n&apos;; return 0;&#125; java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Java program to find length of longest increasing subsequence// in O(n Log n) timeimport java.io.*;import java.util.*;import java.lang.Math; class LIS&#123; // Binary search (note boundaries in the caller) // A[] is ceilIndex in the caller static int CeilIndex(int A[], int l, int r, int key) &#123; while (r - l &gt; 1) &#123; int m = l + (r - l)/2; if (A[m]&gt;=key) r = m; else l = m; &#125; return r; &#125; static int LongestIncreasingSubsequenceLength(int A[], int size) &#123; // Add boundary case, when array size is one int[] tailTable = new int[size]; int len; // always points empty slot tailTable[0] = A[0]; len = 1; for (int i = 1; i &lt; size; i++) &#123; if (A[i] &lt; tailTable[0]) // new smallest value tailTable[0] = A[i]; else if (A[i] &gt; tailTable[len-1]) // A[i] wants to extend largest subsequence tailTable[len++] = A[i]; else // A[i] wants to be current end candidate of an existing // subsequence. It will replace ceil value in tailTable tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i]; &#125; return len; &#125; // Driver program to test above function public static void main(String[] args) &#123; int A[] = &#123; 2, 5, 3, 7, 11, 8, 10, 13, 6 &#125;; int n = A.length; System.out.println(&quot;Length of Longest Increasing Subsequence is &quot;+ LongestIncreasingSubsequenceLength(A, n)); &#125;&#125;/* This code is contributed by Devesh Agrawal*/ Output: 1Length of Longest Increasing Subsequence is 6 Complexity: The loop runs for N elements. In the worst case (what is worst case input?), we may end up querying ceil value using binary search (log i) for many A[i]. Therefore, T(n) &lt; O( log N! ) = O(N log N). Analyse to ensure that the upper and lower bounds are also O( N log N ). The complexity is THETA (N log N). Exercises: Design an algorithm to construct the longest increasing list. Also, model your solution using DAGs. Design an algorithm to construct all increasing lists of equal longest size. Is the above algorithm an online algorithm? Design an algorithm to construct the longest decreasing list.. â€” Venki. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above. python https://discuss.leetcode.com/topic/28738/java-python-binary-search-o-nlogn-time-with-explanation 42ms, September 10, 2016 12345678910111213141516171819class Solution(object): def lengthOfLIS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; tails = [0] * len(nums) size = 0 for x in nums: i, j = 0, size while i != j: m = (i + j) / 2 if tails[m] &lt; x: i = m + 1 else: j = m tails[i] = x size = max(i+1, size) return size java https://discuss.leetcode.com/topic/28719/short-java-solution-using-dp-o-n-log-n Short Java solution using DP O(n log n) 123456789101112131415public class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int[] dp = new int[nums.length]; int len = 0; for(int x : nums) &#123; int i = Arrays.binarySearch(dp, 0, len, x); if(i &lt; 0) i = -(i + 1); dp[i] = x; if(i == len) len++; &#125; return len; &#125;&#125; https://discuss.leetcode.com/topic/28738/java-python-binary-search-o-nlogn-time-with-explanation 2ms, September 10, 2016 Java/Python Binary search O(nlogn) time with explanation tails is an array storing the smallest tail of all increasing subsequences with length i+1 in tails[i].For example, say we have nums = [4,5,6,3], then all the available increasing subsequences are: 123len = 1 : [4], [5], [6], [3] =&gt; tails[0] = 3len = 2 : [4, 5], [5, 6] =&gt; tails[1] = 5len = 3 : [4, 5, 6] =&gt; tails[2] = 6 We can easily prove that tails is a increasing array. Therefore it is possible to do a binary search in tails array to find the one needs update. Each time we only do one of the two: 12(1) if x is larger than all tails, append it, increase the size by 1(2) if tails[i-1] &lt; x &lt;= tails[i], update tails[i] Doing so will maintain the tails invariant. The the final answer is just the size. 12345678910111213141516171819public class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int[] tails = new int[nums.length]; int size = 0; for(int x:nums)&#123; int i=0, j = size; while(i != j)&#123; int m = (i+j) /2; if(tails[m] &lt; x) i = m + 1; else j = m; &#125; tails[i] = x; if(i==size) ++size; &#125; return size; &#125;&#125; https://discuss.leetcode.com/topic/30721/my-easy-to-understand-o-n-2-solution-using-dp-with-video-explanation My easy to understand O(n^2) solution using DP with video explanation This solution is taken from this great guy - https://www.youtube.com/watch?v=CE2b_-XfVDk 123456789101112131415161718192021222324252627282930313233343536373839public int lengthOfLIS(int[] nums) &#123; // Base case if(nums.length &lt;= 1) return nums.length; // This will be our array to track longest sequence length int T[] = new int[nums.length]; // Fill each position with value 1 in the array for(int i=0; i &lt; nums.length; i++) T[i] = 1; // Mark one pointer at i. For each i, start from j=0. for(int i=1; i &lt; nums.length; i++) &#123; for(int j=0; j &lt; i; j++) &#123; // It means next number contributes to increasing sequence. if(nums[j] &lt; nums[i]) &#123; // But increase the value only if it results in a larger value of the sequence than T[i] // It is possible that T[i] already has larger value from some previous j&apos;th iteration if(T[j] + 1 &gt; T[i]) &#123; T[i] = T[j] + 1; &#125; &#125; &#125; &#125; // Find the maximum length from the array that we just generated int longest = 0; for(int i=0; i &lt; T.length; i++) longest = Math.max(longest, T[i]); return longest;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[299. Bulls and Cows]]></title>
    <url>%2Fp%2Fee81c67e%2F</url>
    <content type="text"><![CDATA[33.8% https://leetcode.com/problems/bulls-and-cows/#/description You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called â€œbullsâ€) and how many digits match the secret number but locate in the wrong position (called â€œcowsâ€). Your friend will use successive guesses and hints to eventually derive the secret number. 1234For example:Secret number: &quot;1807&quot;Friend&apos;s guess: &quot;7810&quot; Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.) Write a function to return a hint according to the secret number and friendâ€™s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return â€œ1A3Bâ€. Please note that both secret number and friendâ€™s guess may contain duplicate digits, for example: 12Secret number: &quot;1123&quot;Friend&apos;s guess: &quot;0111&quot; In this case, the 1st 1 in friendâ€™s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return â€œ1A1Bâ€. You may assume that the secret number and your friendâ€™s guess only contain digits, and their lengths are always equal. javahttps://discuss.leetcode.com/topic/28463/one-pass-java-solution The idea is to iterate over the numbers in secret and in guess and count all bulls right away. For cows maintain an array that stores count of the number appearances in secret and in guess. Increment cows when either number from secret was already seen in guest or vice versa. ä¸€ä¸ªæ˜¯secret ä¸€ä¸ªæ˜¯guessï¼Œsecretä¸åŒäºŽguessæ—¶ï¼Œæ¯ä¸€ä¸ªsecretåŠ ä¸€ï¼Œæ¯ä¸€ä¸ªguesså‡ä¸€ï¼Œsecretçš„æŸä¸€ä¸ªå€¼æ¥æ—¶ï¼Œè¯¥å€¼ä¸ªæ•°å°äºŽ0ï¼Œåˆ™æ„å‘³ç€guessçš„è¯¥å€¼å¤šäºŽ0ä¸ªï¼Œcows++ï¼Œå¦ä¸€ä¸ªåŒç†ã€‚ 1234567891011121314151617public String getHint(String secret, String guess) &#123; int bulls = 0; int cows = 0; int[] numbers = new int[10]; for (int i = 0; i&lt;secret.length(); i++) &#123; int s = Character.getNumericValue(secret.charAt(i)); int g = Character.getNumericValue(guess.charAt(i)); if (s == g) bulls++; else &#123; if (numbers[s] &lt; 0) cows++; if (numbers[g] &gt; 0) cows++; numbers[s] ++; numbers[g] --; &#125; &#125; return bulls + &quot;A&quot; + cows + &quot;B&quot;;&#125; 4ms, 62.60%, 151 / 151, May.3rd, 2016 https://leetcode.com/discuss/67031/one-pass-java-solution 123456789101112131415public class Solution &#123; public String getHint(String secret, String guess) &#123; int bulls = 0; int cows = 0; int[] numbers = new int[10]; for(int i = 0; i &lt; secret.length(); i++)&#123; if(secret.charAt(i) == guess.charAt(i)) bulls++; else&#123; if(numbers[secret.charAt(i) - &apos;0&apos;]++ &lt; 0) cows++; if(numbers[guess.charAt(i) - &apos;0&apos;]-- &gt; 0) cows++; &#125; &#125; return bulls + &quot;A&quot; + cows + &quot;B&quot;; &#125;&#125; cpp4ms, 54.70%, 151 / 151, May.3rd, 2016 https://leetcode.com/discuss/66999/c-4ms-straight-forward-solution-two-pass-o-n-time 123456789101112131415161718192021class Solution &#123;public: string getHint(string secret, string guess) &#123; if(secret.empty()) return &quot;0A0B&quot;; int aCnt = 0, bCnt = 0; vector&lt;int&gt; sVec(10, 0), gVec(10, 0); for(int i = 0; i &lt; secret.size(); ++i)&#123; char c1 = secret[i]; char c2 = guess[i]; if(c1 == c2) ++aCnt; else&#123; ++sVec[c1 - &apos;0&apos;]; ++gVec[c2 - &apos;0&apos;]; &#125; &#125; for(int i = 0; i &lt; sVec.size(); ++i)&#123; bCnt += min(sVec[i], gVec[i]); &#125; return to_string(aCnt) + &apos;A&apos; + to_string(bCnt) + &apos;B&apos;; &#125;&#125;; my code 123456789101112131415161718192021class Solution &#123;public: string getHint(string secret, string guess) &#123; int len = secret.size(); int m=0, n=0; vector&lt;int&gt; temp_1(10, 0); vector&lt;int&gt; temp_2(10, 0); for(int i=0; i&lt;len; i++)&#123; if(secret[i]==guess[i]) m++; else&#123; temp_1[secret[i]-&apos;0&apos;]++; temp_2[guess[i]-&apos;0&apos;]++; &#125; &#125; for(int i=0; i&lt;10; i++)&#123; n += min(temp_1[i], temp_2[i]); &#125; return to_string(m)+&apos;A&apos;+to_string(n)+&apos;B&apos;; &#125;&#125;; python84ms, 38.96%, May.3rd, 2016https://leetcode.com/discuss/67037/python-3-lines-solution 12345678910class Solution(object): def getHint(self, secret, guess): &quot;&quot;&quot; :type secret: str :type guess: str :rtype: str &quot;&quot;&quot; s, g = collections.Counter(secret), collections.Counter(guess) a = sum(i == j for i, j in zip(secret, guess)) return &apos;%sA%sB&apos; % (a, sum((s &amp; g).values()) - a)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[297. Serialize and Deserialize Binary Tree]]></title>
    <url>%2Fp%2Fcf7c0855%2F</url>
    <content type="text"><![CDATA[32.4% Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. 1234567For example, you may serialize the following tree 1 / \ 2 3 / \ 4 5 as â€œ[1,2,3,null,null,4,5]â€, just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. å‰‘æŒ‡offer 62 é¢˜ https://discuss.leetcode.com/topic/28041/recursive-preorder-python-and-c-o-n Recursive preorder, Python and C++, O(n) Python 12345678910111213141516171819202122232425class Codec: def serialize(self, root): def doit(node): if node: vals.append(str(node.val)) doit(node.left) doit(node.right) else: vals.append(&apos;#&apos;) vals = [] doit(root) return &apos; &apos;.join(vals) def deserialize(self, data): def doit(): val = next(vals) if val == &apos;#&apos;: return None node = TreeNode(int(val)) node.left = doit() node.right = doit() return node vals = iter(data.split()) return doit() C++ 12345678910111213141516171819202122232425262728293031323334353637class Codec &#123;public: string serialize(TreeNode* root) &#123; ostringstream out; serialize(root, out); return out.str(); &#125; TreeNode* deserialize(string data) &#123; istringstream in(data); return deserialize(in); &#125;private: void serialize(TreeNode* root, ostringstream&amp; out) &#123; if (root) &#123; out &lt;&lt; root-&gt;val &lt;&lt; &apos; &apos;; serialize(root-&gt;left, out); serialize(root-&gt;right, out); &#125; else &#123; out &lt;&lt; &quot;# &quot;; &#125; &#125; TreeNode* deserialize(istringstream&amp; in) &#123; string val; in &gt;&gt; val; if (val == &quot;#&quot;) return nullptr; TreeNode* root = new TreeNode(stoi(val)); root-&gt;left = deserialize(in); root-&gt;right = deserialize(in); return root; &#125;&#125;; https://discuss.leetcode.com/topic/32470/clean-c-solution Clean C++ solution 12345678910111213141516171819202122232425262728293031class Codec &#123;public: // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; if (root == nullptr) return &quot;#&quot;; return to_string(root-&gt;val)+&quot;,&quot;+serialize(root-&gt;left)+&quot;,&quot;+serialize(root-&gt;right); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; return mydeserialize(data); &#125; TreeNode* mydeserialize(string&amp; data) &#123; if (data[0]==&apos;#&apos;) &#123; if(data.size() &gt; 1) data = data.substr(2); return nullptr; &#125; else &#123; TreeNode* node = new TreeNode(helper(data)); node-&gt;left = mydeserialize(data); node-&gt;right = mydeserialize(data); return node; &#125; &#125;private: int helper(string&amp; data) &#123; int pos = data.find(&apos;,&apos;); int val = stoi(data.substr(0,pos)); data = data.substr(pos+1); return val; &#125;&#125;; https://discuss.leetcode.com/topic/28011/c-accepted-o-n-easy-solution C++ Accepted O(n) Easy Solution Idea: Level-order traversal. Use â€˜#â€™ to denote a nullptr. User â€˜,â€™ to separate entries. The output is very similar to Leetcodeâ€™s default deserialization logic. Time Complexities: O(n) to serialize and O(n) to deserialize Space Complexities: O(n) to serialize and O(n) to deserialize 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Codec &#123;public: // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; q.push(root); string str; while (!q.empty()) &#123; if (q.front() == nullptr) &#123; str = str + &quot;#,&quot;; &#125; else &#123; q.push(q.front()-&gt;left); q.push(q.front()-&gt;right); str = str + to_string(q.front()-&gt;val) + &quot;,&quot;; &#125; q.pop(); &#125; return str; &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; TreeNode* root = nullptr; queue&lt;TreeNode**&gt; q; q.push(&amp;root); string::iterator first = data.begin(); while (first != data.end()) &#123; TreeNode** pp = q.front(); if (*first == &apos;#&apos;) &#123; // *pp = nullptr; advance(first, 2); &#125; else &#123; string::iterator last = find(first, data.end(), &apos;,&apos;); int val = stoi(string(first, last)); *pp = new TreeNode(val); q.push(&amp;((*pp)-&gt;left)); q.push(&amp;((*pp)-&gt;right)); first = next(last); &#125; q.pop(); &#125; return root; &#125;&#125;;// Your Codec object will be instantiated and called as such:// Codec codec;// codec.deserialize(codec.serialize(root)); https://discuss.leetcode.com/topic/28092/python-preorder-recursive-traversal Python preorder recursive traversal 123456789101112131415161718192021222324252627282930def serialize(self, root): preorder = &apos;&apos; if not root: preorder += &apos;,None&apos; return preorder preorder += &apos;,&apos;+str(root.val) preorder += self.serialize(root.left) preorder += self.serialize(root.right) return preorderdef deserialize(self, encode_data): pos = -1 data = encode_data[1:].split(&apos;,&apos;) for i in xrange(len(data)): if data[i] == &apos;None&apos;: data[i] = None else: data[i] = int(data[i]) root, count = self.buildTree(data, pos) return root def buildTree(self, data, pos): pos += 1 if pos &gt;= len(data) or data[pos]==None: return None, pos root = TreeNode(data[pos]) root.left, pos = self.buildTree(data, pos) root.right, pos = self.buildTree(data, pos) return root, pos 24ms, 70.13%, October 18, 2016 https://discuss.leetcode.com/topic/28029/easy-to-understand-java-solution 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Codec &#123; private static final String spliter = &quot;,&quot;; private static final String NN = &quot;X&quot;; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); buildString(root, sb); return sb.toString(); &#125; private void buildString(TreeNode node, StringBuilder sb)&#123; if(node == null) sb.append(NN).append(spliter); else&#123; sb.append(node.val).append(spliter); buildString(node.left, sb); buildString(node.right, sb); &#125; &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; Deque&lt;String&gt; nodes = new LinkedList&lt;&gt;(); nodes.addAll(Arrays.asList(data.split(spliter))); return buildTree(nodes); &#125; private TreeNode buildTree(Deque&lt;String&gt; nodes)&#123; String val = nodes.remove(); if(val.equals(NN)) return null; else&#123; TreeNode node = new TreeNode(Integer.valueOf(val)); node.left = buildTree(nodes); node.right = buildTree(nodes); return node; &#125; &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.deserialize(codec.serialize(root)); python239ms, 43.88%, October 18, 2016 https://discuss.leetcode.com/topic/28041/recursive-preorder-python-and-c-o-n 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Codec: def serialize(self, root): &quot;&quot;&quot;Encodes a tree to a single string. :type root: TreeNode :rtype: str &quot;&quot;&quot; def doit(node): if node: vals.append(str(node.val)) doit(node.left) doit(node.right) else: vals.append(&apos;#&apos;) vals = [] doit(root) return &apos; &apos;.join(vals) def deserialize(self, data): &quot;&quot;&quot;Decodes your encoded data to tree. :type data: str :rtype: TreeNode &quot;&quot;&quot; def doit(): val = next(vals) if val == &apos;#&apos;: return None node = TreeNode(int(val)) node.left = doit() node.right = doit() return node vals = iter(data.split()) return doit()# Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>tree</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[295. Find Median from Data Stream]]></title>
    <url>%2Fp%2F4e6b5bd8%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/find-median-from-data-stream/#/description Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. 1234Examples: [2,3,4] , the median is 3[2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far. 1234567For example:addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3) findMedian() -&gt; 2 https://discuss.leetcode.com/topic/27521/short-simple-java-c-python-o-log-n-o-1 Short simple Java/C++/Python, O(log n) + O(1) I keep two heaps (or priority queues): Max-heap small has the smaller half of the numbers. Min-heap large has the larger half of the numbers. This gives me direct access to the one or two middle values (theyâ€™re the tops of the heaps), so getting the median takes O(1) time. And adding a number takes O(log n) time. Supporting both min- and max-heap is more or less cumbersome, depending on the language, so I simply negate the numbers in the heap in which I want the reverse of the default order. To prevent this from causing a bug with -231 (which negated is itself, when using 32-bit ints), I use integer types larger than 32 bits. Using larger integer types also prevents an overflow error when taking the mean of the two middle numbers. I think almost all solutions posted previously have that bug. Update: These are pretty short already, but by now I wrote even shorter ones. Java 123456789101112131415161718class MedianFinder &#123; private Queue&lt;Long&gt; small = new PriorityQueue(), large = new PriorityQueue(); public void addNum(int num) &#123; large.add((long) num); small.add(-large.poll()); if (large.size() &lt; small.size()) large.add(-small.poll()); &#125; public double findMedian() &#123; return large.size() &gt; small.size() ? large.peek() : (large.peek() - small.peek()) / 2.0; &#125;&#125;; Props to larrywang2014â€™s solution for making me aware that I can use Queue in the declaration instead of PriorityQueue (thatâ€™s all I got from him, though (just saying because I just saw he changed his previously longer addNum and itâ€™s now equivalent to mine)). C++ 1234567891011121314151617181920class MedianFinder &#123; priority_queue&lt;long&gt; small, large;public: void addNum(int num) &#123; small.push(num); large.push(-small.top()); small.pop(); if (small.size() &lt; large.size()) &#123; small.push(-large.top()); large.pop(); &#125; &#125; double findMedian() &#123; return small.size() &gt; large.size() ? small.top() : (small.top() - large.top()) / 2.0; &#125;&#125;; Big thanks to jianchao.li.fighter for telling me that C++â€™s priority_queue is a max-queue (see comments below). Python 123456789101112131415161718from heapq import *class MedianFinder: def __init__(self): self.heaps = [], [] def addNum(self, num): small, large = self.heaps heappush(small, -heappushpop(large, num)) if len(large) &lt; len(small): heappush(large, -heappop(small)) def findMedian(self): small, large = self.heaps if len(large) &gt; len(small): return float(large[0]) return (large[0] - small[0]) / 2.0 https://discuss.leetcode.com/topic/27522/java-python-two-heap-solution-o-log-n-add-o-1-find Java/Python two heap solution, O(log n) add, O(1) find The invariant of the algorithm is two heaps, small and large, each represent half of the current list. The length of smaller half is kept to be n / 2 at all time and the length of the larger half is either n / 2 or n / 2 + 1 depend on nâ€™s parity. This way we only need to peek the two heapsâ€™ top number to calculate median. Any time before we add a new number, there are two scenarios, (total n numbers, k = n / 2): 12(1) length of (small, large) == (k, k)(2) length of (small, large) == (k, k + 1) After adding the number, total (n + 1) numbers, they will become: 12(1) length of (small, large) == (k, k + 1)(2) length of (small, large) == (k + 1, k + 1) Here we take the first scenario for example, we know the large will gain one more item and small will remain the same size, but we cannot just push the item into large. What we should do is we push the new number into small and pop the maximum item from small then push it into large (all the pop and push here are heappop and heappush). By doing this kind of operations for the two scenarios we can keep our invariant. Therefore to add a number, we have 3 O(log n) heap operations. Luckily the heapq provided us a function â€œheappushpopâ€ which saves some time by combine two into one. The document says: Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop(). Alltogether, the add operation is O(logn), The findMedian operation is O(1). Note that the heapq in python is a min heap, thus we need to invert the values in the smaller half to mimic a â€œmax heapâ€. A further observation is that the two scenarios take turns when adding numbers, thus it is possible to combine the two into one. For this please see stefanâ€™s post Java 123456789101112131415161718192021private PriorityQueue&lt;Integer&gt; small = new PriorityQueue&lt;&gt;(Collections.reverseOrder());private PriorityQueue&lt;Integer&gt; large = new PriorityQueue&lt;&gt;();private boolean even = true;public double findMedian() &#123; if (even) return (small.peek() + large.peek()) / 2.0; else return small.peek();&#125;public void addNum(int num) &#123; if (even) &#123; large.offer(num); small.offer(large.poll()); &#125; else &#123; small.offer(num); large.offer(small.poll()); &#125; even = !even;&#125; Python 1234567891011121314151617181920212223from heapq import *class MedianFinder: def __init__(self): self.small = [] # the smaller half of the list, max heap (invert min-heap) self.large = [] # the larger half of the list, min heap def addNum(self, num): if len(self.small) == len(self.large): heappush(self.large, -heappushpop(self.small, -num)) else: heappush(self.small, -heappushpop(self.large, num)) def findMedian(self): if len(self.small) == len(self.large): return float(self.large[0] - self.small[0]) / 2.0 else: return float(self.large[0])# 18 / 18 test cases passed.# Status: Accepted# Runtime: 388 ms https://discuss.leetcode.com/topic/27541/very-short-o-log-n-o-1 Very Short, O(log n) + O(1) Same idea as before, but really exploiting the symmetry of the two heaps by switching them whenever a number is added. Still O(log n) for adding and O(1) for median. Partially inspired by peisiâ€™s updated solution. Update: Added a new Java version (the first one). Java 1234567891011121314class MedianFinder &#123; Queue&lt;Integer&gt; q = new PriorityQueue(), z = q, t, Q = new PriorityQueue(Collections.reverseOrder()); public void addNum(int num) &#123; (t=Q).add(num); (Q=q).add((q=t).poll()); &#125; public double findMedian() &#123; return (Q.peek() + z.peek()) / 2.; &#125;&#125;; Or: 1234567891011121314class MedianFinder &#123; Queue[] q = &#123;new PriorityQueue(), new PriorityQueue(Collections.reverseOrder())&#125;; int i = 0; public void addNum(int num) &#123; q[i].add(num); q[i^=1].add(q[i^1].poll()); &#125; public double findMedian() &#123; return ((int)(q[1].peek()) + (int)(q[i].peek())) / 2.0; &#125;&#125;; Python 1234567891011121314from heapq import *class MedianFinder: def __init__(self): self.heaps = None, [], [] self.i = 1 def addNum(self, num): heappush(self.heaps[-self.i], -heappushpop(self.heaps[self.i], num * self.i)) self.i *= -1 def findMedian(self): return (self.heaps[self.i][0] * self.i - self.heaps[-1][0]) / 2.0 Or: 123456789101112131415from heapq import *class MedianFinder: def __init__(self): self.data = 1, [], [] def addNum(self, num): sign, h1, h2 = self.data heappush(h2, -heappushpop(h1, num * sign)) self.data = -sign, h2, h1 def findMedian(self): sign, h1, h2 = d = self.data return (h1[0] * sign - d[-sign][0]) / 2.0 https://discuss.leetcode.com/topic/27613/my-c-priority_queue-based-solution-140-ms My C++ priority_queue based solution (140 ms) The idea is to use two heaps (one max heap, one mn heap) to save the input data. firstQ is a max_heap to save the first half of the data with smaller values, and secQ is a min_heap to save the second half of the data with bigger values. Everytime when inserting a new value, we first compare if it is smaller than the top of firstQ (the largest value of the first half), if so, insert into firstQ. Otherwise, it belongs to the second half. After inserting, we have to balance the first half and the second half to make sure either they have the same length or the length difference is only 1.The median will be the mean of two top elements (when they have the same length) or the top element of the queue with a larger length. 1234567891011121314151617181920212223242526272829class MedianFinder &#123;private: priority_queue&lt;int&gt; firstQ; // max_heap for the first half priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; secQ; // min_heap for the second halfpublic: // Adds a number into the data structure. void addNum(int num) &#123; if(firstQ.empty() || (firstQ.top()&gt;num)) firstQ.push(num); // if it belongs to the smaller half else secQ.push(num); // rebalance the two halfs to make sure the length difference is no larger than 1 if(firstQ.size() &gt; (secQ.size()+1)) &#123; secQ.push(firstQ.top()); firstQ.pop(); &#125; else if(firstQ.size()+1&lt;secQ.size()) &#123; firstQ.push(secQ.top()); secQ.pop(); &#125; &#125; // Returns the median of current data stream double findMedian() &#123; if(firstQ.size() == secQ.size()) return firstQ.empty()?0:( (firstQ.top()+secQ.top())/2.0); else return (firstQ.size() &gt; secQ.size())? firstQ.top():secQ.top(); &#125;&#125;; https://discuss.leetcode.com/topic/27598/solution-using-binary-search-tree Solution using Binary Search Tree As the input numbers are random, so the height of the binary search tree is O(logN) We maintain every single nodeâ€™s childrenâ€™s size and itâ€™s easy to implement because it just has add operation. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465struct BST &#123; struct node &#123; int val; int size; node* left, *right; node(int v) : size(1), val(v) &#123;&#125;; &#125; *Null, *root; BST() &#123; Null = new node(0); Null -&gt; size = 0; root = Null; &#125; void add(int val, node*&amp; R) &#123; if(R == Null) &#123; R = new node(val); R -&gt; left = R -&gt; right = Null; return; &#125; if(R-&gt;val &lt;= val) add(val, R-&gt;left); else add(val, R-&gt;right); R-&gt;size = R-&gt;left-&gt;size + R-&gt;right-&gt;size + 1; &#125; int rank(int k) &#123; node* t = root; while(true) &#123; int leftSize = t -&gt; left -&gt; size; if(leftSize == k) return t -&gt; val; if(leftSize &gt; k) &#123; t = t -&gt; left; &#125; else &#123; k = k - leftSize - 1; t = t -&gt; right; &#125; &#125; return -1; &#125;&#125;;class MedianFinder &#123;public: BST* bst; MedianFinder() &#123; bst = new BST(); &#125; // Adds a number into the data structure. void addNum(int num) &#123; bst-&gt;add(num, bst-&gt;root); &#125; // Returns the median of current data stream double findMedian() &#123; int sz = bst -&gt; root -&gt; size; if(sz % 2 == 0) &#123; return 1.0 * (bst -&gt; rank(sz / 2) + bst -&gt; rank(sz / 2 - 1)) / 2; &#125; else return bst-&gt;rank(sz / 2); &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>heap</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[292. Nim Game]]></title>
    <url>%2Fp%2Fb77dfaa9%2F</url>
    <content type="text"><![CDATA[54.9% https://leetcode.com/problems/nim-game/#/description You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. Hint: If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner? https://discuss.leetcode.com/topic/26999/theorem-all-4s-shall-be-false Theorem: all 4s shall be false Theorem: The first one who got the number that is multiple of 4 (i.e. n % 4 == 0) will lost, otherwise he/she will win. Proof: the base case: when n = 4, as suggested by the hint from the problem, no matter which number that that first player, the second player would always be able to pick the remaining number. For 1 4 &lt; n &lt; 2 4, (n = 5, 6, 7), the first player can reduce the initial number into 4 accordingly, which will leave the death number 4 to the second player. i.e. The numbers 5, 6, 7 are winning numbers for any player who got it first. Now to the beginning of the next cycle, n = 8, no matter which number that the first player picks, it would always leave the winning numbers (5, 6, 7) to the second player. Therefore, 8 % 4 == 0, again is a death number. Following the second case, for numbers between (24 = 8) and (34=12), which are 9, 10, 11, are winning numbers for the first player again, because the first player can always reduce the number into the death number 8. Following the above theorem and proof, the solution could not be simpler: 123public boolean canWinNim(int n) &#123; return n % 4 != 0 ;&#125; https://discuss.leetcode.com/topic/27109/one-line-o-1-solution-and-explanation One line O(1) solution and explanation suppose there are x stones left for first player (A), he can take 1,2,3 stones away, so second player B will have three cases to deal with (x -1), (x-2), (x-3). after he pick the stones, there will be 9 cases left for A. 123B (x-1) -&gt; A: (x-2), (x-3), (x-4)B (x-2) -&gt; A: (x-3), (x-4), (x-5)B (x-3) -&gt; A: (x-4), (x-5), (x-6) Now, if A can guarantee he win at either of three groups, then he can force B to into that one of the three states and A can end up in that particular group after Bâ€™s move. 1f(x) = (f(x-2)&amp;&amp;f(x-3)&amp;&amp;f(x-4)) || (f(x-3)&amp;&amp;f(x-4)&amp;&amp;f(x-5)) || (f(x-4)&amp;&amp;f(x-5)&amp;&amp;f(x-6)) if we examine the equation a little closer, we can find f(x - 4) is a critical point, if f(x-4) is false, then f(x) will be always false. we can also find out the initial conditions, f(1), f(2), f(3) will be true (A always win), and f(4) will be false. so based on previous equation and initial conditions f(5) = f(6) = f(7) = true, f(8) = false; obviously, f(1), f(2), f(3) can make all f(4n + 1), f(4n + 2), f(4n + 3) to be true, only f(4n) will be false then. so here we go our one line solution: 1return (n % 4 != 0); https://discuss.leetcode.com/topic/28437/1-liner-with-explanations 1 liner with explanations 1234567891011121314class Solution(object): def canWinNim(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; # strategy: the one with 4 remaining must loose # A, B players # if n == 4k, then at each round B can make A+B both take 4, # eventually leave 4 to A, A lose # if n == 4k + i (i &lt;= 3), then A can always take i first and B will # finanly lose as he faces above scenario like A return bool(n%4!=0) https://discuss.leetcode.com/topic/27696/1-line-0-ms-c-solution-with-explanation 1 line 0 ms C++ solution with explanation Explanation: At first this problem might seems a bit tough but it is easy and has a pattern which is as follow. I have applied the bottom up dynamic programming approach to fill the array and noticed that only number divisible by 4 are the positions where player1(playing first chance) is losing. 123456class Solution &#123;public: bool canWinNim(int n) &#123; return n%4 ; &#125;&#125;; Base case : If the numbers of stones are 1,2 or 3, then player 1 will win. If the numbers of stones are 4, then player 1 will lose irrespective of the number of stones he/she remove So lookup table will look like this : W[1]-&gt;W[2]-&gt;W[3]-&gt;L[4]. For num_stones=5, the player can either remove 1,2 or 3 stones i.e. the other player (player 2) will win if the number of stones left are 1,2 or 3 and will lose only when the number of stones left are 4 ( see the lookup table in step 1) . So, if Player1 remove 1 stone, the number of stones left will be 4, which will defeat player2. So, now the lookup entry for num_stones=5 will be W. Lookup now will look like this : W-&gt;W-&gt;W-&gt;L-&gt;W (for player 1-&gt; who is taking the first chance). Likewise, we can fill the complete lookup table by looking at the values at last three index. If anyone of them is L =&gt; Player 1 will win the game as he will remove only that many number of stones which will bring player 2 to the L position In the end, you will notice that only positions 4-&gt;8-&gt;12-&gt;16 will contain L for player 1 thus answer is simple n%4. https://discuss.leetcode.com/topic/30789/if-i-m-a-interviewer-i-prefer-the-candidates-using-burte-force-instead-of-math-method If Iâ€™m a interviewer, I prefer the candidates using burte force instead of math method. Because it is a â€œcoding interviewâ€, not acm/icpc or other competitions. Similar to Josephus Cycle, I prefer LinkedList Cycle than Mod-Method during interviews. Hereâ€™s a backtraking-dp solution. 12345678910111213141516171819202122232425262728public class Solution &#123; public boolean canWinNim(int n) &#123; if(n&gt;=134882061)&#123;//I have no any other ways,please forgive my unchastity(æ— èŠ‚æ“)! return n%4 != 0; &#125; int[] array=new int[n+1]; return dfs(n, array); &#125; public boolean dfs(int n,int[] array)&#123; if(array[n]!=0)&#123; return array[n]==1?true:false; &#125; if(n&lt;=3)&#123; array[n]=1; return true; &#125;else&#123; for(int i=1;i&lt;=3;i++)&#123; if(!dfs(n-i,array))&#123; array[n-i]=-1; array[n]=1; return true; &#125; &#125; array[n]=-1; return false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>brainteser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[290. Word Pattern]]></title>
    <url>%2Fp%2F1836af6%2F</url>
    <content type="text"><![CDATA[32.5% https://leetcode.com/problems/word-pattern/#/description Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Examples: pattern = â€œabbaâ€, str = â€œdog cat cat dogâ€ should return true. pattern = â€œabbaâ€, str = â€œdog cat cat fishâ€ should return false. pattern = â€œaaaaâ€, str = â€œdog cat cat dogâ€ should return false. pattern = â€œabbaâ€, str = â€œdog dog dog dogâ€ should return false. Notes: You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. https://discuss.leetcode.com/topic/26376/short-c-read-words-on-the-fly Short C++, read words on the fly I think all previous C++ solutions read all words into a vector at the start. Here I read them on the fly. 123456789101112bool wordPattern(string pattern, string str) &#123; map&lt;char, int&gt; p2i; map&lt;string, int&gt; w2i; istringstream in(str); int i = 0, n = pattern.size(); for (string word; in &gt;&gt; word; ++i) &#123; if (i == n || p2i[pattern[i]] != w2i[word]) return false; p2i[pattern[i]] = w2i[word] = i + 1; &#125; return i == n;&#125; https://discuss.leetcode.com/topic/26316/short-in-python Short in Python This problem is pretty much equivalent to Isomorphic Strings. Let me reuse two old solutions. From here: 1234def wordPattern(self, pattern, str): s = pattern t = str.split() return map(s.find, s) == map(t.index, t) Improved version also from there: 123def wordPattern(self, pattern, str): f = lambda s: map(&#123;&#125;.setdefault, s, range(len(s))) return f(pattern) == f(str.split()) From here: 1234def wordPattern(self, pattern, str): s = pattern t = str.split() return len(set(zip(s, t))) == len(set(s)) == len(set(t)) and len(s) == len(t) Thanks to zhang38 for pointing out the need to check len(s) == len(t) here. https://discuss.leetcode.com/topic/26313/0ms-c-solution-using-istringstream-and-double-maps 0ms C++ solution using istringstream and double maps 123456789101112131415161718bool wordPattern(string pattern, string str) &#123; istringstream strcin(str); string s; vector&lt;string&gt; vs; while(strcin &gt;&gt; s) vs.push_back(s); if (pattern.size() != vs.size()) return false; map&lt;string, char&gt; s2c; map&lt;char, string&gt; c2s; for (int i = 0; i &lt; vs.size(); ++i) &#123; if (s2c[vs[i]] == 0 &amp;&amp; c2s[pattern[i]] == &quot;&quot;) &#123; s2c[vs[i]] = pattern[i]; c2s[pattern[i]] = vs[i]; continue; &#125; if (s2c[vs[i]] != pattern[i]) return false; &#125; return true;&#125; https://discuss.leetcode.com/topic/36612/my-solution-in-python My solution in python 1234567891011class Solution(object): def wordPattern(self, pattern, str): &quot;&quot;&quot; :type pattern: str :type str: str :rtype: bool &quot;&quot;&quot; x = str.split(&apos; &apos;) lsp = len(set(pattern)) lsx = len(set(x)) return len(x)==len(pattern) and lsx==lsp and lsp== len(set(zip(pattern, x))) please point out if thereâ€™s anything i should improve 2ms, 51.78%, October 18, 2016 https://discuss.leetcode.com/topic/26339/8-lines-simple-java 123456789101112public class Solution &#123; public boolean wordPattern(String pattern, String str) &#123; String[] words = str.split(&quot; &quot;); if(words.length!=pattern.length()) return false; Map index = new HashMap(); for(Integer i=0; i&lt;words.length; ++i) if(index.put(pattern.charAt(i), i) != index.put(words[i], i)) return false; return true; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[289. Game of Life]]></title>
    <url>%2Fp%2F4d6d4f2b%2F</url>
    <content type="text"><![CDATA[36.5% https://leetcode.com/problems/game-of-life/#/description According to the Wikipediaâ€™s article: â€œThe Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.â€ Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Write a function to compute the next state (after one update) of the board given its current state. Follow up: Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems? https://discuss.leetcode.com/topic/26112/c-o-1-space-o-mn-time C++ O(1) space, O(mn) time Since the board has ints but only the 1-bit is used, I use the 2-bit to store the new state. At the end, replace the old state with the new state by shifting all values one bit to the right. 12345678910111213141516void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; int m = board.size(), n = m ? board[0].size() : 0; for (int i=0; i&lt;m; ++i) &#123; for (int j=0; j&lt;n; ++j) &#123; int count = 0; for (int I=max(i-1, 0); I&lt;min(i+2, m); ++I) for (int J=max(j-1, 0); J&lt;min(j+2, n); ++J) count += board[I][J] &amp; 1; if (count == 3 || count - board[i][j] == 3) board[i][j] |= 2; &#125; &#125; for (int i=0; i&lt;m; ++i) for (int j=0; j&lt;n; ++j) board[i][j] &gt;&gt;= 1;&#125; Note that the above count counts the live ones among a cellâ€™s neighbors and the cell itself. Starting with int count = -board[i][j] counts only the live neighbors and allows the neat 1if ((count | board[i][j]) == 3) test. Thanks to aileenbai for showing that one in the comments. https://discuss.leetcode.com/topic/26176/c-ac-code-o-1-space-o-mn-time C++ AC Code O(1) space, O(mn) time 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Game of Life/*çŠ¶æ€: å‰ä¸€ä½è¡¨ç¤ºä¸‹ä¸€ä»£çš„çŠ¶æ€,åŽä¸€ä½è¡¨ç¤ºå½“å‰çš„çŠ¶æ€00: æ­»-&gt;æ­»10: æ­»-&gt;æ´»01: æ´»-&gt;æ­»11: æ´»-&gt;æ´»*/class Solution &#123;public: void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; int d[][2] = &#123;&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;&#125;; for(int i = 0; i &lt; board.size(); i++)&#123; for(int j = 0; j &lt; board[0].size(); j++)&#123; int live = 0; for(int k = 0; k &lt; 8; k++)&#123; int x = d[k][0] + i; int y = d[k][1] + j; if(x &lt; 0 || x &gt;= board.size() || y &lt; 0 || y &gt;= board[0].size()) &#123; continue; &#125; if(board[x][y] &amp; 1) &#123; live++; &#125; &#125; // æ­»çš„ if(board[i][j] == 0) &#123; if(live == 3)&#123; board[i][j] = 2; // 2 : (10) &#125; &#125; // æ´»çš„ else &#123; if(live &lt; 2 || live &gt; 3)&#123; board[i][j] = 1; // 1 : (01) &#125;else&#123; board[i][j] = 3; // 3 : (11) &#125; &#125; &#125; &#125; for(int i = 0; i &lt; board.size(); i++)&#123; for(int j=0; j &lt; board[0].size(); j++)&#123; board[i][j] &gt;&gt;=1; &#125; &#125; &#125;&#125;;enter code here https://discuss.leetcode.com/topic/26236/infinite-board-solution Infinite board solution For the second follow-up question, hereâ€™s a solution for an infinite board. Instead of a two-dimensional array of ones and zeros, I represent the board as a set of live cell coordinates. 123456789def gameOfLifeInfinite(self, live): ctr = collections.Counter((I, J) for i, j in live for I in range(i-1, i+2) for J in range(j-1, j+2) if I != i or J != j) return &#123;ij for ij in ctr if ctr[ij] == 3 or ctr[ij] == 2 and ij in live&#125; And hereâ€™s a wrapper that uses the above infinite board solution to solve the problem we have here at the OJ (submitted together, this gets accepted): 123456def gameOfLife(self, board): live = &#123;(i, j) for i, row in enumerate(board) for j, live in enumerate(row) if live&#125; live = self.gameOfLifeInfinite(live) for i, row in enumerate(board): for j in range(len(row)): row[j] = int((i, j) in live) https://discuss.leetcode.com/topic/27167/c-o-mn-time-o-1-space-sol C++ O(mn)-time, O(1)-space sol First this solution does not involve bit-manipulation and only involves addition of integers. The idea is to go through the matrix from top-left corner to the bottom-right corner, and check only 4 cells (â€œaccumulateâ€ scores â€œfor both cellsâ€ if the other cell is originally a 1). Graphically speaking, it is like this: 123O O O O @ XX X X where the @ cell is the one that you are working on, 0 cells are those you have gone through (donâ€™t work on them again!), and the X cells are those you have not gone through and should work on. For example, if one X cell is originally a 1, you should add C (a constant) to @ cell, and simultaneously if @ cell is originally a 1, you add C to that X cell. The constant C can be 2. If it is 2 then when you will find that after done working on the current cell if itâ€™s value is 5 or 7 (cell @ is originally a 1 and have 2 or 3 neighbours) or 6 (cell @ is originally a 0 and have 3 neighbours), then you should reset it to be 1 (live), otherwise reset it to be zero (dead). And when accumulating scores, you know a cell is originally a 1 if it has odd-numbered score, and it is originally a 0 if it has even-numbered score. The code is 1234567891011121314151617181920212223242526class Solution &#123;public: void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; if(board.empty()) return; const int m = board.size(); const int n = board[0].size(); for(int i=0; i&lt;m; i++) &#123; for(int j=0; j&lt;n; j++) &#123; check(board,i,j,i+1,j-1); check(board,i,j,i+1,j); check(board,i,j,i+1,j+1); check(board,i,j,i,j+1); if(board[i][j]&gt;=5 &amp;&amp; board[i][j]&lt;=7) board[i][j]=1; else board[i][j]=0; &#125; &#125; &#125;private: void check(vector&lt;vector&lt;int&gt;&gt;&amp; board, int i, int j, int a, int b) &#123; const int m = board.size(); const int n = board[0].size(); if(a&gt;=m || b&lt;0 || b&gt;=n) return; if(board[i][j]%2!=0) board[a][b]+=2; if(board[a][b]%2!=0) board[i][j]+=2; &#125; &#125;; https://discuss.leetcode.com/topic/27098/python-solution-easy-to-understand Python solution, easy to understand.. 1234567891011121314151617181920212223242526272829300,2 are &quot;dead&quot;, and &quot;dead-&gt;live&quot;1,3 are &quot;live&quot;, and &quot;live-&gt;dead&quot;def gameOfLife(self, board): m,n = len(board), len(board[0]) for i in range(m): for j in range(n): if board[i][j] == 0 or board[i][j] == 2: if self.nnb(board,i,j) == 3: board[i][j] = 2 else: if self.nnb(board,i,j) &lt; 2 or self.nnb(board,i,j) &gt;3: board[i][j] = 3 for i in range(m): for j in range(n): if board[i][j] == 2: board[i][j] = 1 if board[i][j] == 3: board[i][j] = 0 def nnb(self, board, i, j): m,n = len(board), len(board[0]) count = 0 if i-1 &gt;= 0 and j-1 &gt;= 0: count += board[i-1][j-1]%2 if i-1 &gt;= 0: count += board[i-1][j]%2 if i-1 &gt;= 0 and j+1 &lt; n: count += board[i-1][j+1]%2 if j-1 &gt;= 0: count += board[i][j-1]%2 if j+1 &lt; n: count += board[i][j+1]%2 if i+1 &lt; m and j-1 &gt;= 0: count += board[i+1][j-1]%2 if i+1 &lt; m: count += board[i+1][j]%2 if i+1 &lt; m and j+1 &lt; n: count += board[i+1][j+1]%2 return count https://discuss.leetcode.com/topic/26117/ac-python-40-ms-solution-o-mn-time-o-1-extra-space AC Python 40 ms solution O(mn) time O(1) extra space 123456789101112131415161718192021222324def update(self, board, m, n, i, j): live = 0 for p in xrange(max(i - 1, 0), min(i + 2, m)): for q in xrange(max(j - 1, 0), min(j + 2, n)): live += board[p][q] &amp; 1 if live == 3 or live == board[i][j] + 3: board[i][j] += 2def gameOfLife(self, board): if not board or not board[0]: return m = len(board) n = len(board[0]) for i in xrange(m): for j in xrange(n): self.update(board, m, n, i, j) for i in xrange(m): for j in xrange(n): board[i][j] &gt;&gt;= 1# 22 / 22 test cases passed.# Status: Accepted# Runtime: 40 ms Everyone knows how to update this board if another m * n array is allowed. The O(1) space solution is just using the wasted bits in the original array. Instead of only 0 and 1 we now need the second bit for the updated value. The living condition is just by definition. Of course, writing everything together will save several lines of code. However, implement things like this, readability and expandability counts. As of the follow up question.For example your 3 * 3 initial board is the following: 1231 1 11 0 11 1 1 In the case of only 3 * 3 the next generation is: 1231 0 1 0 0 0 1 0 1 However in the case of a infinite board the next generation is: 123450 0 1 0 0 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 0 0 1 0 0 Question is how to you implement this expandable board. One solution of the infinity situation is using a upper level grid, a grid of grids, instead of only one grid of cells. Note that we can be lazy. We only initialize (allocate the memory for real) a certain grid if any cell in it is activated. The rest of the unused grid can be pointer only. 1ms, 11.45%, October 18, 2016 https://discuss.leetcode.com/topic/29054/easiest-java-solution-with-explanation 12345678910111213141516171819202122232425262728public class Solution &#123; public void gameOfLife(int[][] board) &#123; if(board == null || board.length == 0) return; int m = board.length, n = board[0].length; for(int i=0; i&lt;m; i++) for(int j=0; j&lt;n; j++)&#123; int lives = liveNeighbors(board, m, n, i, j); if(board[i][j] == 1 &amp;&amp; lives&gt;=2 &amp;&amp; lives &lt;= 3) board[i][j] = 3; if(board[i][j] == 0 &amp;&amp; lives == 3) board[i][j] = 2; &#125; for(int i=0; i&lt;m; i++) for(int j=0; j&lt;n; j++) board[i][j] &gt;&gt;= 1; &#125; public int liveNeighbors(int[][] board, int m, int n, int i, int j)&#123; int lives = 0; for(int x=Math.max(i-1, 0); x&lt;=Math.min(i+1, m-1); x++) for(int y=Math.max(j-1, 0); y&lt;=Math.min(j+1, n-1); y++) lives += board[x][y] &amp; 1; lives -= board[i][j] &amp; 1; return lives; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[284. Peeking Iterator]]></title>
    <url>%2Fp%2F8f8ef073%2F</url>
    <content type="text"><![CDATA[35.2% https://leetcode.com/problems/peeking-iterator/#/description Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation â€“ it essentially peek() at the element that will be returned by the next call to next(). Here is an example. Assume that the iterator is initialized to the beginning of the list: [1, 2, 3]. Call next() gets you 1, the first element in the list. Now you call peek() and it returns 2, the next element. Calling next() after that still return 2. You call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false. Hint: Think of â€œlooking aheadâ€. You want to cache the next element. Is one variable sufficient? Why or why not? Test your design with call order of peek() before next() vs next() before peek(). For a clean implementation, check out Googleâ€™s guava library source code. Follow up: How would you extend your design to be generic and work with all types, not just integer? 3ms, 3.96%, October 15, 2016 https://discuss.leetcode.com/topic/24909/simple-c-solution-1-line-per-method-without-extra-member-variables Simple C++ solution (1 line per method) without extra member variables Since Iterator has a copy constructor, we can just use it: 12345678910111213141516171819202122class PeekingIterator : public Iterator&#123;public: PeekingIterator(const vector&lt;int&gt; &amp;nums) : Iterator(nums) &#123; &#125; int peek() &#123; return Iterator(*this).next(); &#125; int next() &#123; return Iterator::next(); &#125; bool hasNext() const &#123; return Iterator::hasNext(); &#125;&#125;; https://discuss.leetcode.com/topic/25875/another-c-solution-with-one-line-in-peek-and-hasnext-ac Another C++ solution with one line in peek() and hasNext(), AC 12345678910111213141516171819202122232425class PeekingIterator : public Iterator &#123;private: int m_next; bool m_hasnext;public: PeekingIterator(const vector&lt;int&gt;&amp; nums) : Iterator(nums) &#123; m_hasnext = Iterator::hasNext(); if (m_hasnext) m_next = Iterator::next(); &#125; int peek() &#123; return m_next; &#125; int next() &#123; int t = m_next; m_hasnext = Iterator::hasNext(); if (m_hasnext) m_next = Iterator::next(); return t; &#125; bool hasNext() const &#123; return m_hasnext; &#125;&#125;; https://discuss.leetcode.com/topic/26190/my-4ms-c-supper-easy-solution My 4ms c++ supper easy solution 123456789101112131415161718192021222324252627class PeekingIterator : public Iterator &#123; public: PeekingIterator(const vector&lt;int&gt;&amp; nums) : Iterator(nums) &#123; // Initialize any member here. // **DO NOT** save a copy of nums and manipulate it directly. // You should only use the Iterator interface methods.&#125;// Returns the next element in the iteration without advancing the iterator.int peek() &#123; if(hasNext())&#123; Iterator it(*this); return it.next(); &#125;&#125;// hasNext() and next() should behave the same as in the Iterator interface.// Override them if needed.int next() &#123; Iterator::next();&#125;bool hasNext() const &#123; Iterator::hasNext();&#125;&#125;; https://discuss.leetcode.com/topic/24857/10-line-c-and-14-line-java-implementation 10-line C++ and 14-line Java Implementation 123456789101112131415161718192021222324class PeekingIterator : public Iterator &#123; bool hasPeeked; int peekedElem;public: PeekingIterator(const vector&lt;int&gt;&amp; num) : Iterator(num) &#123; hasPeeked = false; &#125; int peek() &#123; peekedElem = hasPeeked?peekedElem:Iterator::next(); hasPeeked = true; return peekedElem; &#125; int next() &#123; int nextElem = hasPeeked?peekedElem:Iterator::next(); hasPeeked = false; return nextElem; &#125; bool hasNext() const &#123; return hasPeeked||Iterator::hasNext(); &#125;&#125;; Java implementation, inspired by Googleâ€™s guava library source code. 123456789101112131415161718192021222324252627282930class PeekingIterator implements Iterator&lt;Integer&gt; &#123; private final Iterator&lt;Integer&gt; iterator; private boolean hasPeeked; private Integer peekedElement; public PeekingIterator(Iterator&lt;Integer&gt; iterator) &#123; if(iterator==null) throw new NullPointerException(); else this.iterator = iterator; &#125; public Integer peek() &#123; peekedElement = hasPeeked?peekedElement:iterator.next(); hasPeeked = true; return peekedElement; &#125; @Override public Integer next() &#123; int nextElem = hasPeeked?peekedElement:iterator.next(); hasPeeked = false; return nextElem; &#125; @Override public boolean hasNext() &#123; return hasPeeked || iterator.hasNext(); &#125;&#125; https://discuss.leetcode.com/topic/25308/simple-python-solution Simple Python Solution Store the next value outside the iterator. When next is called return the stored value and populate with next value from iterator. 123456789101112131415class PeekingIterator(object): def __init__(self, iterator): self.iter = iterator self.temp = self.iter.next() if self.iter.hasNext() else None def peek(self): return self.temp def next(self): ret = self.temp self.temp = self.iter.next() if self.iter.hasNext() else None return ret def hasNext(self): return self.temp is not None 111ms, 45.64%, October 15, 2016 https://discuss.leetcode.com/topic/24883/concise-java-solution 1234567891011121314151617181920212223242526272829303132// Java Iterator interface reference:// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.htmlclass PeekingIterator implements Iterator&lt;Integer&gt; &#123; private Integer next = null; private Iterator&lt;Integer&gt; iter; public PeekingIterator(Iterator&lt;Integer&gt; iterator) &#123; // initialize any member here. iter = iterator; if(iter.hasNext()) next = iter.next(); &#125; // Returns the next element in the iteration without advancing the iterator. public Integer peek() &#123; return next; &#125; // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. @Override public Integer next() &#123; Integer res = next; next = iter.hasNext() ? iter.next() : null; return res; &#125; @Override public boolean hasNext() &#123; return next != null; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[283. Move Zeroes]]></title>
    <url>%2Fp%2F59f0159a%2F</url>
    <content type="text"><![CDATA[48.7% https://leetcode.com/problems/move-zeroes/#/description Given an array nums, write a function to move all 0â€™s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 17ï¼Œ 2017 12345678910111213class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int j=0; for(int i=0; i&lt;n; i++) if(nums[i]!=0) nums[j++] = nums[i]; for(;j&lt;n; j++) nums[j] = 0; return; &#125;&#125;; https://discuss.leetcode.com/topic/32632/my-simple-c-solution My simple C++ solution 123456789101112131415class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int j = 0; // move all the nonzero elements advance for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] != 0) &#123; nums[j++] = nums[i]; &#125; &#125; for (;j &lt; nums.size(); j++) &#123; nums[j] = 0; &#125; &#125;&#125;; æ–¹æ³•äºŒï¼š ç±»ä¼¼äºŽå¿«æŽ’partitionçš„ç”¨æ³• æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 21ï¼Œ 2017 12345678910class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int pos = -1; for(int i=0; i&lt;nums.size(); i++) if(nums[i]!=0) swap(nums[++pos], nums[i]); return; &#125;&#125;; https://discuss.leetcode.com/topic/24745/c-accepted-code C++ Accepted Code 123456789101112void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int last = 0, cur = 0; while(cur &lt; nums.size()) &#123; if(nums[cur] != 0) &#123; swap(nums[last], nums[cur]); last++; &#125; cur++; &#125;&#125; https://discuss.leetcode.com/topic/25077/one-line-c-code-20ms One line c++ code, 20ms The idea comes from the c++ erase/remove idiom. 123456class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; fill(remove(nums.begin(), nums.end(),0), nums.end(), 0); &#125;&#125;; https://discuss.leetcode.com/topic/25163/c-1-line-or-3-lines-clean-code C++ 1 line (or 3 lines) clean code 123456789void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; for (int i = 0, j = 0; i &lt; nums.size(); i++) if(nums[i] != 0) swap(nums[i], nums[j++]);&#125; void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; for (int i = 0, j = 0; i &lt; nums.size(); i++) &#123; if (nums[i] != 0) swap(nums[i], nums[j++]); &#125;&#125; https://discuss.leetcode.com/topic/28941/very-simple-python-solutions Very simple python solutions Solution 1: traverse and swap last 0 and last non 0 1234567891011class Solution(object): def moveZeroes(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; last0 = 0 for i in range(0,len(nums)): if (nums[i]!=0): nums[i],nums[last0] = nums[last0],nums[i] last0+=1 Solution 2 : one-liner from @toontong: use sort() with customized compare function 1234567class Solution(object): def moveZeroes(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; nums.sort(cmp=lambda a,b: 0 if b else -1)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[282. Expression Add Operators]]></title>
    <url>%2Fp%2F2290fe4%2F</url>
    <content type="text"><![CDATA[29.1% https://leetcode.com/problems/expression-add-operators/#/description Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value. 123456Examples: &quot;123&quot;, 6 -&gt; [&quot;1+2+3&quot;, &quot;1*2*3&quot;] &quot;232&quot;, 8 -&gt; [&quot;2*3+2&quot;, &quot;2+3*2&quot;]&quot;105&quot;, 5 -&gt; [&quot;1*0+5&quot;,&quot;10-5&quot;]&quot;00&quot;, 0 -&gt; [&quot;0+0&quot;, &quot;0-0&quot;, &quot;0*0&quot;]&quot;3456237490&quot;, 9191 -&gt; [] https://discuss.leetcode.com/topic/24478/17-lines-solution-dfs-c 17 lines solution, dfs (C++) 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;private: // cur: &#123;string&#125; expression generated so far. // pos: &#123;int&#125; current visiting position of num. // cv: &#123;long&#125; cumulative value so far. // pv: &#123;long&#125; previous operand value. // op: &#123;char&#125; previous operator used. void dfs(std::vector&lt;string&gt;&amp; res, const string&amp; num, const int target, string cur, int pos, const long cv, const long pv, const char op) &#123; if (pos == num.size() &amp;&amp; cv == target) &#123; res.push_back(cur); &#125; else &#123; for (int i=pos+1; i&lt;=num.size(); i++) &#123; string t = num.substr(pos, i-pos); long now = stol(t); if (to_string(now).size() != t.size()) continue; dfs(res, num, target, cur+&apos;+&apos;+t, i, cv+now, now, &apos;+&apos;); dfs(res, num, target, cur+&apos;-&apos;+t, i, cv-now, now, &apos;-&apos;); dfs(res, num, target, cur+&apos;*&apos;+t, i, (op == &apos;-&apos;) ? cv+pv - pv*now : ((op == &apos;+&apos;) ? cv-pv + pv*now : pv*now), pv*now, op); &#125; &#125; &#125;public: vector&lt;string&gt; addOperators(string num, int target) &#123; vector&lt;string&gt; res; if (num.empty()) return res; for (int i=1; i&lt;=num.size(); i++) &#123; string s = num.substr(0, i); long cur = stol(s); if (to_string(cur).size() != s.size()) continue; dfs(res, num, target, s, i, cur, cur, &apos;#&apos;); // no operator defined. &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/24487/accepted-c-solution Accepted C++ Solution 1234567891011121314151617181920212223242526272829void addOperators(vector&lt;string&gt;&amp; result, string nums, string t, long long last, long long curVal, int target) &#123; if (nums.length() == 0) &#123; if (curVal == target) result.push_back(t); return; &#125; for (int i = 1; i&lt;=nums.length(); i++) &#123; string num = nums.substr(0, i); if(num.length() &gt; 1 &amp;&amp; num[0] == &apos;0&apos;) return; string nextNum = nums.substr(i); if (t.length() &gt; 0) &#123; addOperators(result, nextNum, t + &quot;+&quot; + num, stoll(num), curVal + stoll(num), target); addOperators(result, nextNum, t + &quot;-&quot; + num, -stoll(num), curVal - stoll(num), target); addOperators(result, nextNum, t + &quot;*&quot; + num, last * stoll(num), (curVal - last) + (last * stoll(num)), target); &#125; else addOperators(result, nextNum, num, stoll(num), stoll(num), target); &#125;&#125;vector&lt;string&gt; addOperators(string num, int target) &#123; vector&lt;string&gt; result; addOperators(result, num, &quot;&quot;, 0, 0, target); return result;&#125; https://discuss.leetcode.com/topic/35751/recommend-for-beginners-clean-c-implementation-with-detailed-explanation [recommend for beginners]clean C++ implementation with detailed explanation 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;string&gt; addOperators(string num, int target) &#123; vector&lt;string&gt; result; if(num.size()==0) return result; help(result, &quot;&quot;, num, target, 0, 0, 0); return result; &#125; void help(vector&lt;string&gt; &amp;result, string path, string num, int target, int pos, long cur, long prev)&#123; if(pos==num.size())&#123; if(cur==target) result.push_back(path); return; &#125; for(int i=pos; i&lt;num.size(); i++)&#123; /*** corner-case-added-code ***/ if(num[pos]==&apos;0&apos; &amp;&amp; i&gt;pos) break; string _str=num.substr(pos, i-pos+1); long _value=stol(_str); if(pos==0) &#123; help(result, path+_str, num, target, i+1, _value, _value); &#125; else&#123; help(result, path+&quot;+&quot;+_str, num, target, i+1, cur+_value, _value); help(result, path+&quot;-&quot;+_str, num, target, i+1, cur-_value, -_value); help(result, path+&quot;*&quot;+_str, num, target, i+1, cur-prev+prev*_value, prev*_value); &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/24688/16ms-c-solution 16ms C++ solution The idea is to cut a value from the left of the string and then for each of operations â€˜+â€™, â€˜-â€˜, â€˜*â€˜ repeat the procedure recursively. The trick is to pass the sum of all left summands and the product of rightmost factors. This allows to calculate the left sum and the right product on the next step depending on the next chosen operation. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; typedef long long int i64; string myS; const char* s; i64 target; int slen; public: vector&lt;string&gt; addOperators(const string&amp; num, int t) &#123; myS = num; slen = myS.size(); s = myS.c_str(); target = t; vector&lt;string&gt; res; char buf[slen*2+1]; int lmax = (s[0] == &apos;0&apos; ? 1 : slen); i64 v = 0; for (int l=1; l&lt;=lmax; ++l) &#123; int c = s[l-1]; v = v*10 + (c-&apos;0&apos;); // add next digit buf[l-1] = c; // only need to append the last digit processTail(0, v, l, buf, l, res); &#125; return res; &#125; void processTail(i64 prevsum, i64 last, int pos, char* buf, int bufpos, vector&lt;string&gt;&amp; res) &#123; if (pos == slen) &#123; // end of string // check the value and save if (prevsum+last == target) &#123; buf[bufpos] = 0; res.push_back(buf); &#125; return; &#125; int lmax = (s[pos] == &apos;0&apos; ? 1 : slen-pos); // don&apos;t allow multichar intergers starting from a &apos;0&apos; i64 v = 0; for (int l=1; l&lt;=lmax; ++l) &#123; int c = s[pos+l-1]; v = v*10 + (c-&apos;0&apos;); // add next digit to v buf[bufpos] = &apos;+&apos;; buf[bufpos+l] = c; // only need to append the last digit of v processTail(prevsum+last, v, pos+l, buf, bufpos+l+1, res); buf[bufpos] = &apos;-&apos;; processTail(prevsum+last, -v, pos+l, buf, bufpos+l+1, res); buf[bufpos] = &apos;*&apos;; processTail(prevsum, last*v, pos+l, buf, bufpos+l+1, res); &#125; &#125;&#125;; 2509ms, 25,85%, October 18, 2016 https://discuss.leetcode.com/topic/30089/clean-python-dfs-with-comments Clean Python DFS with comments dfs() parameters: num: remaining num string temp: temporally string with operators added cur: current result of â€œtempâ€ string last: last multiply-level number in â€œtempâ€. if next operator is â€œmultiplyâ€, â€œcurâ€ and â€œlastâ€ will be updated res: result to return 123456789101112131415161718def addOperators(self, num, target): res, self.target = [], target for i in range(1,len(num)+1): if i == 1 or (i &gt; 1 and num[0] != &quot;0&quot;): # prevent &quot;00*&quot; as a number self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res) # this step put first number in the string return resdef dfs(self, num, temp, cur, last, res): if not num: if cur == self.target: res.append(temp) return for i in range(1, len(num)+1): val = num[:i] if i == 1 or (i &gt; 1 and num[0] != &quot;0&quot;): # prevent &quot;00*&quot; as a number self.dfs(num[i:], temp + &quot;+&quot; + val, cur+int(val), int(val), res) self.dfs(num[i:], temp + &quot;-&quot; + val, cur-int(val), -int(val), res) self.dfs(num[i:], temp + &quot;*&quot; + val, cur-last+last*int(val), last*int(val), res) 282ms, 23.05%, October 18, 2016 https://discuss.leetcode.com/topic/24523/java-standard-backtrace-ac-solutoin-short-and-clear 12345678910111213141516171819202122232425262728public class Solution &#123; public List&lt;String&gt; addOperators(String num, int target) &#123; List&lt;String&gt; rst = new ArrayList&lt;String&gt;(); if(num==null || num.length() == 0) return rst; helper(rst, &quot;&quot;, num, target, 0, 0, 0); return rst; &#125; public void helper(List&lt;String&gt; rst, String path, String num, int target, int pos, long eval, long multed)&#123; if(pos == num.length())&#123; if(target == eval) rst.add(path); return; &#125; for(int i=pos; i&lt;num.length(); i++)&#123; if(i != pos &amp;&amp; num.charAt(pos) == &apos;0&apos;) break; long cur = Long.parseLong(num.substring(pos, i+1)); if(pos == 0) helper(rst, path+cur, num, target, i+1, cur, cur); else&#123; helper(rst, path + &quot;+&quot; + cur, num, target, i+1, eval+cur, cur); helper(rst, path + &quot;-&quot; + cur, num, target, i+1, eval-cur, -cur); helper(rst, path + &quot;*&quot; + cur, num, target, i+1, eval-multed+multed*cur, multed*cur); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>divide and conquer</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[279. Perfect Squares]]></title>
    <url>%2Fp%2F81d53cb4%2F</url>
    <content type="text"><![CDATA[35.8% https://leetcode.com/problems/perfect-squares/#/description Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, â€¦) which sum to n. For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9. https://discuss.leetcode.com/topic/24255/summary-of-4-different-solutions-bfs-dp-static-dp-and-mathematics Summary of 4 different solutions (BFS, DP, static DP and mathematics) Came up with the 2 solutions of breadth-first search and dynamic programming. Also â€œcopiedâ€ StefanPochmannâ€™s static dynamic programming solution (https://leetcode.com/discuss/56993/static-dp-c-12-ms-python-172-ms-ruby-384-ms) and davidtan1890â€™s mathematical solution (https://leetcode.com/discuss/57066/4ms-c-code-solve-it-mathematically) here with minor style changes and some comments. Thank Stefan and David for posting their nice solutions! 1.Dynamic Programming: 440ms 12345678910111213141516171819202122232425262728class Solution &#123;public: int numSquares(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; // cntPerfectSquares[i] = the least number of perfect square numbers // which sum to i. Note that cntPerfectSquares[0] is 0. vector&lt;int&gt; cntPerfectSquares(n + 1, INT_MAX); cntPerfectSquares[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; // For each i, it must be the sum of some number (i - j*j) and // a perfect square number (j*j). for (int j = 1; j*j &lt;= i; j++) &#123; cntPerfectSquares[i] = min(cntPerfectSquares[i], cntPerfectSquares[i - j*j] + 1); &#125; &#125; return cntPerfectSquares.back(); &#125;&#125;; 2.Static Dynamic Programming: 12ms 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int numSquares(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; // cntPerfectSquares[i] = the least number of perfect square numbers // which sum to i. Since cntPerfectSquares is a static vector, if // cntPerfectSquares.size() &gt; n, we have already calculated the result // during previous function calls and we can just return the result now. static vector&lt;int&gt; cntPerfectSquares(&#123;0&#125;); // While cntPerfectSquares.size() &lt;= n, we need to incrementally // calculate the next result until we get the result for n. while (cntPerfectSquares.size() &lt;= n) &#123; int m = cntPerfectSquares.size(); int cntSquares = INT_MAX; for (int i = 1; i*i &lt;= m; i++) &#123; cntSquares = min(cntSquares, cntPerfectSquares[m - i*i] + 1); &#125; cntPerfectSquares.push_back(cntSquares); &#125; return cntPerfectSquares[n]; &#125;&#125;; 3.Mathematical Solution: 4ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; private: int is_square(int n) &#123; int sqrt_n = (int)(sqrt(n)); return (sqrt_n*sqrt_n == n); &#125; public: // Based on Lagrange&apos;s Four Square theorem, there // are only 4 possible results: 1, 2, 3, 4. int numSquares(int n) &#123; // If n is a perfect square, return 1. if(is_square(n)) &#123; return 1; &#125; // The result is 4 if and only if n can be written in the // form of 4^k*(8*m + 7). Please refer to // Legendre&apos;s three-square theorem. while ((n &amp; 3) == 0) // n%4 == 0 &#123; n &gt;&gt;= 2; &#125; if ((n &amp; 7) == 7) // n%8 == 7 &#123; return 4; &#125; // Check whether 2 is the result. int sqrt_n = (int)(sqrt(n)); for(int i = 1; i &lt;= sqrt_n; i++) &#123; if (is_square(n - i*i)) &#123; return 2; &#125; &#125; return 3; &#125; &#125;; 4.Breadth-First Search: 80ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class Solution &#123;public: int numSquares(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; // perfectSquares contain all perfect square numbers which // are smaller than or equal to n. vector&lt;int&gt; perfectSquares; // cntPerfectSquares[i - 1] = the least number of perfect // square numbers which sum to i. vector&lt;int&gt; cntPerfectSquares(n); // Get all the perfect square numbers which are smaller than // or equal to n. for (int i = 1; i*i &lt;= n; i++) &#123; perfectSquares.push_back(i*i); cntPerfectSquares[i*i - 1] = 1; &#125; // If n is a perfect square number, return 1 immediately. if (perfectSquares.back() == n) &#123; return 1; &#125; // Consider a graph which consists of number 0, 1,...,n as // its nodes. Node j is connected to node i via an edge if // and only if either j = i + (a perfect square number) or // i = j + (a perfect square number). Starting from node 0, // do the breadth-first search. If we reach node n at step // m, then the least number of perfect square numbers which // sum to n is m. Here since we have already obtained the // perfect square numbers, we have actually finished the // search at step 1. queue&lt;int&gt; searchQ; for (auto&amp; i : perfectSquares) &#123; searchQ.push(i); &#125; int currCntPerfectSquares = 1; while (!searchQ.empty()) &#123; currCntPerfectSquares++; int searchQSize = searchQ.size(); for (int i = 0; i &lt; searchQSize; i++) &#123; int tmp = searchQ.front(); // Check the neighbors of node tmp which are the sum // of tmp and a perfect square number. for (auto&amp; j : perfectSquares) &#123; if (tmp + j == n) &#123; // We have reached node n. return currCntPerfectSquares; &#125; else if ((tmp + j &lt; n) &amp;&amp; (cntPerfectSquares[tmp + j - 1] == 0)) &#123; // If cntPerfectSquares[tmp + j - 1] &gt; 0, this is not // the first time that we visit this node and we should // skip the node (tmp + j). cntPerfectSquares[tmp + j - 1] = currCntPerfectSquares; searchQ.push(tmp + j); &#125; else if (tmp + j &gt; n) &#123; // We don&apos;t need to consider the nodes which are greater ] // than n. break; &#125; &#125; searchQ.pop(); &#125; &#125; return 0; &#125;&#125;; https://discuss.leetcode.com/topic/23808/o-sqrt-n-in-ruby-c-c O(sqrt(n)) in Ruby, C++, C These solutions use some number theory (see explanation further down). C++ solution 123456789101112131415161718int numSquares(int n) &#123; while (n % 4 == 0) n /= 4; if (n % 8 == 7) return 4; bool min2 = false; for (int i=2; i&lt;=n; ++i) &#123; if (i &gt; n/i) i = n; int e = 0; while (n % i == 0) n /= i, ++e; if (e % 2 &amp;&amp; i % 4 == 3) return 3; min2 |= e % 2; &#125; return 1 + min2;&#125; C solution Inspired by kevin36â€™s solution. We donâ€™t really need to compute the prime factorization. Knowing that four squares always suffice and using the three-squares test is enough. Single-square and sum-of-two-squares cases can be done simpler. 123456789101112int numSquares(int n) &#123; while (n % 4 == 0) n /= 4; if (n % 8 == 7) return 4; for (int a=0; a*a&lt;=n; ++a) &#123; int b = sqrt(n - a*a); if (a*a + b*b == n) return 1 + !!a; &#125; return 3;&#125; Explanation I happen to have given a little talk about just this topic a while back in a number theory seminar. This problem is completely solved, in the sense of being reduced to simple checks of a numberâ€™s prime factorization. A natural number isâ€¦ â€¦ a square if and only if each prime factor occurs to an even power in the numberâ€™s prime factorization. â€¦ a sum of two squares if and only if each prime factor thatâ€™s 3 modulo 4 occurs to an even power in the numberâ€™s prime factorization. â€¦ a sum of three squares if and only if itâ€™s not of the form 4a(8b+7) with integers a and b. â€¦ a sum of four squares. Period. No condition. You never need more than four. Of course single squares can also be identified by comparing a given number with the square of the rounded root of the number. The problem statement says â€œ1, 4, 9, 16, â€¦â€, for some reason apparently excluding 0, but it really is a perfect square and the above theorems do consider it one. With that, you can for example always extend a sum of two squares a2+b2 to the sum of three squares a2+b2+02. Put differently, if n isnâ€™t a sum of three squares, then it also isnâ€™t a sum of two squares. So you can read the above statements as â€œâ€¦ a sum of m (or fewer) squaresâ€. Thanks to ruben3 for asking about this in the comments. In my above solutions, I first divide the given number by 4 as often as possible and then do the three-squares check. Dividing by 4 doesnâ€™t affect the other checks, and the n % 8 == 7 is cheaper than the prime factorization, so this saves time in cases where we do need four squares. Armed with just the knowledge that you never need more than four squares, itâ€™s also easy to write O(n) solutions, e.g.: 1234567891011int numSquares(int n) &#123; int ub = sqrt(n); for (int a=0; a&lt;=ub; ++a) &#123; for (int b=a; b&lt;=ub; ++b) &#123; int c = sqrt(n - a*a - b*b); if (a*a + b*b + c*c == n) return !!a + !!b + !!c; &#125; &#125; return 4;&#125; https://discuss.leetcode.com/topic/23812/static-dp-c-12-ms-python-172-ms-ruby-384-ms/2 Static DP, C++ 12 ms, Python 172 ms, Ruby 384 ms There are so many â€œlargeâ€ test cases that itâ€™s worthwhile to keep data between test cases rather than recomputing from scratch all the time. At least in the slower languages. My dp tells the numbers of squares needed for the first integers, and when asked about a new n, I extend dp just as much as necessary. C++ â€¦ 28 ms 12345678910int numSquares(int n) &#123; static vector&lt;int&gt; dp &#123;0&#125;; while (dp.size() &lt;= n) &#123; int m = dp.size(), squares = INT_MAX; for (int i=1; i*i&lt;=m; ++i) squares = min(squares, dp[m-i*i] + 1); dp.push_back(squares); &#125; return dp[n];&#125; C++ â€¦ 12 ms Switching the loops makes it less nice but faster: 12345678910int numSquares(int n) &#123; static vector&lt;int&gt; dp &#123;0&#125;; int m = dp.size(); dp.resize(max(m, n+1), INT_MAX); for (int i=1, i2; (i2 = i*i)&lt;=n; ++i) for (int j=max(m, i2); j&lt;=n; ++j) if (dp[j] &gt; dp[j-i2] + 1) dp[j] = dp[j-i2] + 1; return dp[n];&#125; Python â€¦ 172 ms 1234567class Solution(object): _dp = [0] def numSquares(self, n): dp = self._dp while len(dp) &lt;= n: dp += min(dp[-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1, return dp[n] Thereâ€™s probably a cleaner way than using a global variable, but Iâ€™m new to Ruby and donâ€™t know one. https://discuss.leetcode.com/topic/26262/short-python-solution-using-bfs/2 Short Python solution using BFS 1234567891011121314151617181920212223def numSquares(self, n): if n &lt; 2: return n lst = [] i = 1 while i * i &lt;= n: lst.append( i * i ) i += 1 cnt = 0 toCheck = &#123;n&#125; while toCheck: cnt += 1 temp = set() for x in toCheck: for y in lst: if x == y: return cnt if x &lt; y: break temp.add(x-y) toCheck = temp return cnt The basic idea of this solution is a BSF search for shortest path, take 12 as an example, as shown below, the shortest path is 12-8-4-0: https://discuss.leetcode.com/topic/23846/4ms-c-code-solve-it-mathematically 4ms C++ code - Solve it mathematically 123456789101112131415161718class Solution &#123; public: int is_square(int n)&#123; int temp = (int) sqrt(n); return temp * temp == n; &#125; int numSquares(int n) &#123; while ((n &amp; 3) == 0) //n%4 == 0 n &gt;&gt;= 2; if ((n &amp; 7) == 7) return 4; //n % 8 == 7 if(is_square(n)) return 1; int sqrt_n = (int) sqrt(n); for(int i = 1; i&lt;= sqrt_n; i++)&#123; if (is_square(n-i*i)) return 2; &#125; return 3; &#125; &#125;; UPDATE: in order to understand, I suggest u read: here is the Lagrangeâ€™s Four Square theorem - Limit the result to &lt;= 4: https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem And this article, in which you can also find the way to present a number as a sum of four squares: http://www.alpertron.com.ar/4SQUARES.HTM https://discuss.leetcode.com/topic/23906/o-sqrt-n-about-0-034-ms-and-0-018-ms/2 O(sqrt(n)), about 0.034 ms (and 0.018 ms) For better measurement, I wrapped the actual solution in a 10000-loop. This got accepted in 344 ms (every time in three submits), so without the wrapper it should take about 0.0344 ms. I tried a few variations and this is the fastest I managed to do. (Update: After qgambit2â€™s challenge, I optimized my my original approach and now thatâ€™s my fastest, with about 180 ms.) First I use the fact that four squares always suffice and the fact that four squares are only needed for numbers of the form 4a(8b+7). After that part, I know that the answer is 1, 2 or 3, and I try to build n as sum of one or two squares. For that, I use a kind of two-pointers-approach. Instead of going through squares a2 and checking whether n-a2 is a square (which would involve computing lots of square roots), imagine you start with a=02 and b=floor(sqrt(n))2 and as long as a&lt;=b, either make a the next larger square or make b the next smaller square, depending on whether the sum of the two squares is too small or too large (or return 2, if itâ€™s exactly right). But in order to improve speed further, I use that squares are sums of consecutive odd numbers starting at 1 (for example, 25=1+3+5+7+9), and my a and b arenâ€™t squares but the corresponding odd numbers. And instead of computing the sum of the two squares, I just add to or subtract from n, trying to reach zero. This way, my main part doesnâ€™t even have multiplications. Just simple addition/subtraction and comparisons. The solution: 123456789101112131415161718int numSquaresReal(int n) &#123; while (n % 4 == 0) n /= 4; if (n % 8 == 7) return 4; int a = -1, b = sqrt(n); n -= b * b; b += b + 1; while (a &lt;= b) &#123; if (n &lt; 0) n += b -= 2; else if (n &gt; 0) n -= a += 2; else return a &lt; 0 ? 1 : 2; &#125; return 3;&#125; The wrapper for better time measurement: 123456int numSquares(int n) &#123; int sum = 0; for (int i=0; i&lt;10000; i++) sum += numSquaresReal(n); return sum / 10000;&#125; 488ms, 26.95%, June.15th, 2016 https://leetcode.com/discuss/62229/short-python-solution-using-bfs 12345678910111213141516171819202122232425262728class Solution(object): def numSquares(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n &lt; 2: return n lst = [] i = 1 while i * i &lt;= n: lst.append( i * i ) i += 1 cnt = 0 toCheck = &#123;n&#125; while toCheck: cnt += 1 temp = set() for x in toCheck: for y in lst: if x == y: return cnt if x &lt; y: break temp.add(x-y) toCheck = temp return cnt Solution 2: 208ms, 60.99%, June.15th, 2016 https://leetcode.com/discuss/56993/static-dp-c-12-ms-python-172-ms-ruby-384-ms 1234567891011class Solution(object): _dp = [0] def numSquares(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = self._dp while len(dp) &lt;= n: dp += min(dp[-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1, return dp[n]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[278. First Bad Version]]></title>
    <url>%2Fp%2F7b51cdf3%2F</url>
    <content type="text"><![CDATA[24.7% https://leetcode.com/problems/first-bad-version/#/description You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, â€¦, n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. æ–¹æ³•ä¸€: äºŒåˆ†æŸ¥æ‰¾ æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 13th, 2017 12345678910111213141516171819// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int l=1, r=n; if(isBadVersion(l)) return l; while(l&lt;r)&#123; int mid = l+(r-l)/2; if(isBadVersion(mid)) r = mid; else l = mid+1; &#125; return l; &#125;&#125;; https://discuss.leetcode.com/topic/38135/a-good-warning-to-me-to-use-start-end-start-2-to-avoid-overflow A good warning to me to use start+(end-start)/2 to avoid overflow Before this problem, I have always use 1mid = (start+end)) / 2; To get the middle value, but this can caused OVERFLOW ! when start and end are all about INT_MAX , then (start+end) of course will be overflow ! To avoid the problem we can use 1mid = start+(end-start)/2; Here is the AC implementation 1234567891011121314151617// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int start=0, end=n; cout&lt;&lt;end-start&lt;&lt;end; while(end-start&gt;1)&#123; int mid=start+(end-start)/2; /** mid = (start+end)) / 2; **/ if(isBadVersion(mid)) end=mid; else start=mid; &#125; return end; &#125;&#125;; https://discuss.leetcode.com/topic/25845/time-limit-exceed Time limit exceed Is there any difference between â€œ ( low + high ) / 2 â€œ and â€œ low + ( high - low ) / 2 â€œ? When I use the first one, it told me â€œtime limit exceedâ€ but if I use the second one, it worked! https://discuss.leetcode.com/topic/23597/short-c-answer-and-minimize-api-calls Short C++ answer and minimize API calls 123456789101112class Solution &#123;public: int firstBadVersion(int n) &#123; int lower = 1, upper = n, mid; while(lower &lt; upper) &#123; mid = lower + (upper - lower) / 2; if(!isBadVersion(mid)) lower = mid + 1; /* Only one call to API */ else upper = mid; &#125; return lower; /* Because there will alway be a bad version, return lower here */ &#125;&#125;; https://discuss.leetcode.com/topic/23617/what-s-the-difference-between-left-right-2-and-left-right-left-2 Whatâ€™s the difference between â€œ(left + right) / 2â€ and â€œleft + (right - left) / 2â€? Below is my code, it got TLE. But I canâ€™t see the difference between my code and this one except for how I calculated mid. So is there any difference between â€œ(left + right) / 2â€ and â€œleft + (right - left) / 2â€? 1234567891011121314151617181920bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int left = 1; int right = n; int mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(isBadVersion(mid)) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left; &#125;&#125;; https://discuss.leetcode.com/topic/23607/1-liner-in-ruby-python 1-liner in Ruby / Python Python In Python I was only able to do it with a rather ugly wrapper: 12def firstBadVersion(self, n): return bisect.bisect(type(&apos;&apos;, (), &#123;&apos;__getitem__&apos;: lambda self, i: isBadVersion(i)&#125;)(), False, 0, n) Nicer, more readable version: 12345def firstBadVersion(self, n): class Wrap: def __getitem__(self, i): return isBadVersion(i) return bisect.bisect(Wrap(), False, 0, n) https://discuss.leetcode.com/topic/27365/python-understand-easily-from-binary-search-idea Python, understand (easily from Binary search idea) 123456789101112131415class Solution(object):def firstBadVersion(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; r = n-1 l = 0 while(l&lt;=r): mid = l + (r-l)/2 if isBadVersion(mid)==False: l = mid+1 else: r = mid-1 return l https://discuss.leetcode.com/topic/24175/my-0ms-c-solution-with-o-logn-time-and-o-1-space My 0ms c++ solution with O(logn) time and O(1) space 0ms, September 11, 2016 https://discuss.leetcode.com/topic/23597/short-c-answer-and-minimize-api-calls 123456789101112131415// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int lower = 1, upper = n, mid; while(lower &lt; upper)&#123; mid = lower + (upper - lower) / 2; if(!isBadVersion(mid)) lower = mid + 1; else upper = mid; &#125; return lower; &#125;&#125;; 35ms, September 11, 2016 my solution 12345678910111213141516171819# The isBadVersion API is already defined for you.# @param version, an integer# @return a bool# def isBadVersion(version):class Solution(object): def firstBadVersion(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; l, r = 1, n while l &lt; r: mid = l + (r-l)/2 if isBadVersion(mid) == False: l = mid + 1 else: r = mid return l 17ms, September 11, 2016 https://discuss.leetcode.com/topic/26272/o-lgn-simple-java-solution 1234567891011121314/* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int start = 1, end = n; while(start &lt; end)&#123; int mid = start + (end - start) / 2; if(!isBadVersion(mid)) start = mid + 1; else end = mid; &#125; return start; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[275. H-Index II]]></title>
    <url>%2Fp%2F79619e9a%2F</url>
    <content type="text"><![CDATA[34.4% https://leetcode.com/problems/h-index-ii/ Follow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm? Hint: Expected runtime complexity is in O(log n) and the input is sorted. æ–¹æ³•ä¸€ï¼š äºŒåˆ†æŸ¥æ‰¾ 1234567891011121314151617class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; if(citations.empty()) return 0; int n = citations.size(); int left = 0, right = n-1; while(left&lt;=right)&#123; // &lt;= ä¸æ˜¯ &lt; int mid = left + (right-left)/2; if(citations[mid]&gt;=n-mid)&#123; // &gt;= è€Œä¸æ˜¯&gt; right = mid-1; &#125;else&#123; left = mid+1; &#125; &#125; return n-left; &#125;&#125;; cpp124ms, 60.19%, May.4th, 2016 https://leetcode.com/discuss/56109/space-easy-solution-with-detailed-explanations-java-python 1234567891011121314151617181920212223class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; int size = citations.size(); int first = 0; int mid; int count = size; int step; while(count &gt; 0)&#123; step = count / 2; mid = first + step; if(citations[mid] &lt; size - mid)&#123; first = mid + 1; count -= (step + 1); &#125; else count = step; &#125; return size - first; &#125;&#125;; python124ms, 60.19%, 82 / 82, May.4th, 2016 https://leetcode.com/discuss/56119/binary-search-in-python 123456789101112131415class Solution(object): def hIndex(self, citations): &quot;&quot;&quot; :type citations: List[int] :rtype: int &quot;&quot;&quot; N = len(citations) low, high = 0, N - 1 while low &lt;= high: mid = (low + high) / 2 if N - mid &gt; citations[mid]: low = mid + 1 else: high = mid - 1 return N - low 132ms, 46.76%, May.4th, 2016 https://leetcode.com/discuss/56109/space-easy-solution-with-detailed-explanations-java-python 123456789101112131415161718192021class Solution(object): def hIndex(self, citations): &quot;&quot;&quot; :type citations: List[int] :rtype: int &quot;&quot;&quot; length = len(citations) first = 0 count = length while count &gt; 0: step = count / 2 mid = first + step if citations[mid] &lt; length - mid: first = mid + 1 count -= (step + 1) else: count = step return length - first java12ms, 46.91%, May.4th, 2016 https://leetcode.com/discuss/56109/space-easy-solution-with-detailed-explanations-java-python 123456789101112131415161718192021222324public class Solution &#123; public int hIndex(int[] citations) &#123; int len = citations.length; int first = 0; int mid; int count = len; int step; while (count &gt; 0) &#123; step = count / 2; mid = first + step; if (citations[mid] &lt; len - mid) &#123; first = mid + 1; count -= (step + 1); &#125; else &#123; count = step; &#125; &#125; return len - first; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[274. H-Index]]></title>
    <url>%2Fp%2F1b8dbba0%2F</url>
    <content type="text"><![CDATA[32.8% https://leetcode.com/problems/h-index/#/description Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcherâ€™s h-index. According to the definition of h-index on Wikipedia: â€œA scientist has index h if h of his/her N papers have at least h citations each, and the other N âˆ’ h papers have no more than h citations each.â€ For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Hint: An easy approach is to sort the array first. What are the possible values of h-index? A faster approach is to use extra space. æ–¹æ³•ä¸€ï¼š May.4th https://leetcode.com/discuss/55969/o-n-time-c-solution-using-hash-table Line 20: control reaches end of non-void function [-Werror=return-type] ä½¿ç”¨vectorï¼Œindexä¸ºå¼•ç”¨é‡ï¼Œå€¼ä¸ºç¯‡æ•°ã€‚æ—¶é—´æ•ˆçŽ‡Oï¼ˆnï¼‰ æ³¨æ„ä¸‹é¢æœ‰ä¸€å¤„æ˜¯iâ€“, ä¸è¦ä¹ æƒ¯æ€§çš„å†™æˆi++ æ ¹æ®é•¿åº¦nï¼Œæœ€å¤§çš„ä¸ºnï¼Œç”±nä¾æ¬¡é€’å‡æŸ¥æ‰¾ï¼ŒOï¼ˆnï¼‰è§£æ³• 123456789101112131415161718192021class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; if(citations.empty()) return 0; int n = citations.size(); vector&lt;int&gt; hash(n + 1, 0); for(int i = 0; i &lt; n; ++i)&#123; if(citations[i] &gt;= n) hash[n]++; else hash[citations[i]]++; &#125; int paper = 0; for(int i = n; i &gt;= 0; --i)&#123; paper += hash[i]; if(paper &gt;= i) return i; &#125; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; if(citations.empty()) return 0; int n = citations.size(); vector&lt;int&gt; v(n+1, 0); for(auto citation:citations)&#123; if(citation&gt;=n) v[n]++; else v[citation]++; &#125; int paper = 0; for(int i=n; i&gt;=0; i--)&#123; paper += v[i]; if(paper&gt;=i) return i; &#125; &#125;&#125;; æ–¹æ³•äºŒï¼š ç›´æŽ¥æŒ‰å®šä¹‰æ¥ï¼Œå…ˆæŽ’åºï¼Œå†ä¾æ¬¡åˆ¤æ–­ æˆ‘çš„å®žçŽ° 1234567891011121314class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; if(citations.empty()) return 0; sort(citations.begin(), citations.end(), [](int a, int b)&#123;return a&gt;b;&#125;); int paper = 0; int n = citations.size(); for(; paper&lt;n; paper++)&#123; if(citations[paper]&lt;paper+1) return paper-1; &#125; return paper; &#125;&#125;; python Mine Solution: 48ms, 30.68%, May.4th, 2016 12345678910111213class Solution(object): def hIndex(self, citations): &quot;&quot;&quot; :type citations: List[int] :rtype: int &quot;&quot;&quot; if not citations: return 0 citations.sort(reverse = True) for key, value in enumerate(citations): if key + 1 &gt; value: return value elif key + 1 == len(citations) or key + 1 &gt;= citations[key + 1]: return key + 1 https://discuss.leetcode.com/topic/23810/python-o-n-lgn-time-with-sort-o-n-time-with-o-n-space Python O(n lgn) time with sort, O(n) time with O(n) space Sort 1234567def hIndex(self, citations): citations.sort() n = len(citations) for i in xrange(n): if citations[i] &gt;= (n-i): return n-i return 0 O(n) space, O(n) time 12345678910111213141516def hIndex(self, citations): n = len(citations) citeCount = [0] * (n+1) for c in citations: if c &gt;= n: citeCount[n] += 1 else: citeCount[c] += 1 i = n-1 while i &gt;= 0: citeCount[i] += citeCount[i+1] if citeCount[i+1] &gt;= i+1: return i+1 i -= 1 return 0 java4ms, 9.28%, 81 / 81, May.4th, 2016 https://leetcode.com/discuss/55958/my-easy-solution 123456789public class Solution &#123; public int hIndex(int[] citations) &#123; Arrays.sort(citations); int len = citations.length; for(int i=0; i&lt;len; i++) if(citations[i] &gt;= len - i) return len-i; return 0; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>medium</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[273. Integer to English Words]]></title>
    <url>%2Fp%2F17e7ae89%2F</url>
    <content type="text"><![CDATA[21.5% https://leetcode.com/problems/integer-to-english-words/#/description Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1. 1234For example,123 -&gt; &quot;One Hundred Twenty Three&quot;12345 -&gt; &quot;Twelve Thousand Three Hundred Forty Five&quot;1234567 -&gt; &quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&quot; Hint: Did you see a pattern in dividing the number into chunk of words? For example, 123 and 123000. Group the number by thousands (3 digits). You can write a helper function that takes a number less than 1000 and convert just that chunk to words. There are many edge cases. What are some good test cases? Does your code work with input such as 0? Or 1000010? (middle chunk is zero and should not be printed out) https://discuss.leetcode.com/topic/24112/fairly-clear-4ms-c-solution Fairly Clear 4ms C++ solution 1234567891011121314151617181920212223class Solution &#123;public: static string numberToWords(int n) &#123; if(n == 0) return &quot;Zero&quot;; else return int_string(n).substr(1); &#125;private: static const char * const below_20[]; static const char * const below_100[]; static string int_string(int n) &#123; if(n &gt;= 1000000000) return int_string(n / 1000000000) + &quot; Billion&quot; + int_string(n - 1000000000 * (n / 1000000000)); else if(n &gt;= 1000000) return int_string(n / 1000000) + &quot; Million&quot; + int_string(n - 1000000 * (n / 1000000)); else if(n &gt;= 1000) return int_string(n / 1000) + &quot; Thousand&quot; + int_string(n - 1000 * (n / 1000)); else if(n &gt;= 100) return int_string(n / 100) + &quot; Hundred&quot; + int_string(n - 100 * (n / 100)); else if(n &gt;= 20) return string(&quot; &quot;) + below_100[n / 10 - 2] + int_string(n - 10 * (n / 10)); else if(n &gt;= 1) return string(&quot; &quot;) + below_20[n - 1]; else return &quot;&quot;; &#125; &#125;&#125;;const char * const Solution::below_20[] = &#123;&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;,&quot;Five&quot;,&quot;Six&quot;,&quot;Seven&quot;,&quot;Eight&quot;,&quot;Nine&quot;,&quot;Ten&quot;, &quot;Eleven&quot;,&quot;Twelve&quot;,&quot;Thirteen&quot;,&quot;Fourteen&quot;,&quot;Fifteen&quot;,&quot;Sixteen&quot;,&quot;Seventeen&quot;,&quot;Eighteen&quot;,&quot;Nineteen&quot;&#125;;const char * const Solution::below_100[] = &#123;&quot;Twenty&quot;, &quot;Thirty&quot;, &quot;Forty&quot;, &quot;Fifty&quot;, &quot;Sixty&quot;, &quot;Seventy&quot;, &quot;Eighty&quot;, &quot;Ninety&quot;&#125;; https://discuss.leetcode.com/topic/22949/c-solution-4ms C++ solution 4ms 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//8msstring helper(int&amp; num)&#123; const static char* less_ten[] = &#123; &quot;&quot;, &quot; One&quot;, &quot; Two&quot;, &quot; Three&quot;, &quot; Four&quot;, &quot; Five&quot;, &quot; Six&quot;, &quot; Seven&quot;, &quot; Eight&quot;, &quot; Nine&quot; &#125;; const static char* less_twenty[] = &#123; &quot; Ten&quot;, &quot; Eleven&quot;, &quot; Twelve&quot;, &quot; Thirteen&quot;, &quot; Fourteen&quot;, &quot; Fifteen&quot;, &quot; Sixteen&quot;, &quot; Seventeen&quot;, &quot; Eighteen&quot;, &quot; Nineteen&quot; &#125;; const static char* less_hundred[] = &#123; &quot;&quot;, &quot;&quot;, &quot; Twenty&quot;, &quot; Thirty&quot;, &quot; Forty&quot;, &quot; Fifty&quot;, &quot; Sixty&quot;, &quot; Seventy&quot;, &quot; Eighty&quot;, &quot; Ninety&quot; &#125;; int less_thousand = num % 1000; num /= 1000; string s; if (less_thousand != 0)&#123; int hundred = less_thousand / 100; less_thousand %= 100; int tenth = less_thousand / 10; int single = less_thousand % 10; if (hundred) s = s + less_ten[hundred] + &quot; Hundred&quot;; if (tenth)&#123; if (tenth == 1)&#123; s += less_twenty[single]; return s; &#125; else s += less_hundred[tenth]; &#125; if (single) s += less_ten[single]; &#125; return s; &#125; string numberToWords(int num) &#123; const static char* unit[] = &#123; &quot;&quot;, &quot; Thousand&quot;, &quot; Million&quot;, &quot; Billion&quot;, &quot; Triliion&quot; &#125;; string s; int i = 0; while (num)&#123; string part = helper(num); if(i++ == 0)&#123; s = part; &#125; else if (part.size()) s = part + unit[i] + s; &#125; s = s.size() ? s.substr(1) : &quot;Zero&quot;; return s; &#125; A faster version and maybe easier to understand (4ms): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647string helper(int num)&#123; const static char* less_ten[] = &#123; &quot;&quot;, &quot; One&quot;, &quot; Two&quot;, &quot; Three&quot;, &quot; Four&quot;, &quot; Five&quot;, &quot; Six&quot;, &quot; Seven&quot;, &quot; Eight&quot;, &quot; Nine&quot; &#125;; const static char* less_twenty[] = &#123; &quot; Ten&quot;, &quot; Eleven&quot;, &quot; Twelve&quot;, &quot; Thirteen&quot;, &quot; Fourteen&quot;, &quot; Fifteen&quot;, &quot; Sixteen&quot;, &quot; Seventeen&quot;, &quot; Eighteen&quot;, &quot; Nineteen&quot; &#125;; const static char* less_hundred[] = &#123; &quot;&quot;, &quot;&quot;, &quot; Twenty&quot;, &quot; Thirty&quot;, &quot; Forty&quot;, &quot; Fifty&quot;, &quot; Sixty&quot;, &quot; Seventy&quot;, &quot; Eighty&quot;, &quot; Ninety&quot; &#125;; string s; if (num != 0)&#123; //get hundredth, tenth, and single digit int hundred = num / 100; num %= 100; int tenth = num / 10; int single = num % 10; if (hundred) s = s + less_ten[hundred] + &quot; Hundred&quot;; if (tenth)&#123; if (tenth == 1)&#123; //special handling, choose from less_twenty based on value of single s += less_twenty[single]; return s; &#125; else s += less_hundred[tenth]; &#125; if (single) s += less_ten[single]; &#125; return s;&#125;string numberToWords(int num) &#123; const static char* unit[] = &#123; &quot;&quot;, &quot; Thousand&quot;, &quot; Million&quot;, &quot; Billion&quot; &#125;; int parts[4] = &#123;0&#125;; for(int i = 0; i &lt; 4; ++i)&#123; parts[i] = num % 1000; num /= 1000; &#125; string s; for(int i = 0; i &lt; 4; ++i)&#123; if(parts[i] == 0) continue; s = helper(parts[i]) + unit[i] + s; &#125; s = s.size() ? s.substr(1) : &quot;Zero&quot;; return s;&#125; https://discuss.leetcode.com/topic/22959/short-clean-c-code-with-explanation Short clean C++ code, with explanation Function hundredStr() produces a string from integer less than 100. And in numberToWords() it uses a for loop to set â€œThousandâ€,â€Millionâ€,â€Billionâ€. 1234567891011121314151617181920212223class Solution &#123;public: string hundredStr(int num)&#123; vector&lt;string&gt; arr1=&#123;&quot;&quot;,&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;,&quot;Four&quot;,&quot;Five&quot;,&quot;Six&quot;,&quot;Seven&quot;,&quot;Eight&quot;,&quot;Nine&quot;,&quot;Ten&quot;, &quot;Eleven&quot;,&quot;Twelve&quot;,&quot;Thirteen&quot;,&quot;Fourteen&quot;,&quot;Fifteen&quot;,&quot;Sixteen&quot;,&quot;Seventeen&quot;,&quot;Eighteen&quot;,&quot;Nineteen&quot;&#125;; vector&lt;string&gt; arr2=&#123;&quot;&quot;,&quot;&quot;,&quot;Twenty&quot;,&quot;Thirty&quot;,&quot;Forty&quot;,&quot;Fifty&quot;,&quot;Sixty&quot;,&quot;Seventy&quot;,&quot;Eighty&quot;,&quot;Ninety&quot;&#125;; string ret; ret=num%100&lt;20?arr1[num%100]:arr2[(num%100)/10]+(num%10?&quot; &quot;+arr1[num%10]:&quot;&quot;); if(num&gt;99)ret=arr1[num/100]+&quot; Hundred&quot;+(num%100?&quot; &quot;+ret:&quot;&quot;); return ret; &#125; string numberToWords(int num) &#123; string ret; vector&lt;string&gt; strarr=&#123;&quot;Thousand&quot;,&quot;Million&quot;,&quot;Billion&quot;&#125;; ret=hundredStr(num%1000); for(int i=0;i&lt;3;i++)&#123; num/=1000; ret=num%1000?hundredStr(num%1000)+&quot; &quot;+strarr[i]+&quot; &quot;+ ret:ret; &#125; while(ret.back()==&apos; &apos;)ret.pop_back(); return ret.empty()?&quot;Zero&quot;:ret; &#125;&#125;; https://discuss.leetcode.com/topic/23061/recursive-python Recursive Python 123456789101112131415def numberToWords(self, num): to19 = &apos;One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve &apos; \ &apos;Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen&apos;.split() tens = &apos;Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety&apos;.split() def words(n): if n &lt; 20: return to19[n-1:n] if n &lt; 100: return [tens[n/10-2]] + words(n%10) if n &lt; 1000: return [to19[n/100-1]] + [&apos;Hundred&apos;] + words(n%100) for p, w in enumerate((&apos;Thousand&apos;, &apos;Million&apos;, &apos;Billion&apos;), 1): if n &lt; 1000**(p+1): return words(n/1000**p) + [w] + words(n%1000**p) return &apos; &apos;.join(words(num)) or &apos;Zero&apos; https://discuss.leetcode.com/topic/39814/python-clean-solution Python Clean Solution 123456789101112131415161718192021222324def __init__(self): self.lessThan20 = [&quot;&quot;,&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;,&quot;Four&quot;,&quot;Five&quot;,&quot;Six&quot;,&quot;Seven&quot;,&quot;Eight&quot;,&quot;Nine&quot;,&quot;Ten&quot;,&quot;Eleven&quot;,&quot;Twelve&quot;,&quot;Thirteen&quot;,&quot;Fourteen&quot;,&quot;Fifteen&quot;,&quot;Sixteen&quot;,&quot;Seventeen&quot;,&quot;Eighteen&quot;,&quot;Nineteen&quot;] self.tens = [&quot;&quot;,&quot;Ten&quot;,&quot;Twenty&quot;,&quot;Thirty&quot;,&quot;Forty&quot;,&quot;Fifty&quot;,&quot;Sixty&quot;,&quot;Seventy&quot;,&quot;Eighty&quot;,&quot;Ninety&quot;] self.thousands = [&quot;&quot;,&quot;Thousand&quot;,&quot;Million&quot;,&quot;Billion&quot;]def numberToWords(self, num): if num == 0: return &quot;Zero&quot; res = &quot;&quot; for i in range(len(self.thousands)): if num % 1000 != 0: res = self.helper(num%1000) + self.thousands[i] + &quot; &quot; + res num /= 1000 return res.strip()def helper(self, num): if num == 0: return &quot;&quot; elif num &lt; 20: return self.lessThan20[num] + &quot; &quot; elif num &lt; 100: return self.tens[num/10] + &quot; &quot; + self.helper(num%10) else: return self.lessThan20[num/100] + &quot; Hundred &quot; + self.helper(num%100) 8ms, 26.68%, 17 July 2016 https://discuss.leetcode.com/topic/49124/the-simplest-recursive-solution-ever-yet-efficient-enough-in-c 123456789101112131415class Solution &#123;private: const vector&lt;string&gt; numerals&#123;&quot;Billion&quot;, &quot;Million&quot;, &quot;Thousand&quot;, &quot;Hundred&quot;, &quot;Ninety&quot;,&quot;Eighty&quot;, &quot;Seventy&quot;,&quot;Sixty&quot;, &quot;Fifty&quot;, &quot;Forty&quot;, &quot;Thirty&quot;, &quot;Twenty&quot;, &quot;Nineteen&quot;, &quot;Eighteen&quot;, &quot;Seventeen&quot;, &quot;Sixteen&quot;, &quot;Fifteen&quot;, &quot;Fourteen&quot;, &quot;Thirteen&quot;, &quot;Twelve&quot;,&quot;Eleven&quot;, &quot;Ten&quot;,&quot;Nine&quot;, &quot;Eight&quot;, &quot;Seven&quot;, &quot;Six&quot;, &quot;Five&quot;, &quot;Four&quot;, &quot;Three&quot;,&quot;Two&quot;, &quot;One&quot;&#125;; const vector&lt;int&gt; units = &#123;1000000000, 1000000, 1000, 100, 90, 80, 70, 60,50, 40,30,20,19, 18, 17, 16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1&#125;;public: string numberToWords(int num) &#123; if(num == 0) return &quot;Zero&quot;; int i = 0; for(; num &lt; units[i]; ++i) ; int upper = num/units[i]; int lower = num%units[i]; return (i&lt;4? numberToWords(upper) + &quot; &quot; : &quot;&quot;) + numerals[i] + (lower? &quot; &quot; + numberToWords(lower) : &quot;&quot;); &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>string</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[268. Missing Number]]></title>
    <url>%2Fp%2F4176e3e5%2F</url>
    <content type="text"><![CDATA[43.9% https://leetcode.com/problems/missing-number/#/description Given an array containing n distinct numbers taken from 0, 1, 2, â€¦, n, find the one that is missing from the array. 12For example,Given nums = [0, 1, 3] return 2. Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? æ–¹æ³•ä¸€ï¼š ä½è¿ç®— ç¾Žå›¢é¢è¯•é‡åˆ°è¿‡ æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int res = 0; for(int i=1; i&lt;=n; i++)&#123; res ^= nums[i-1]; res ^= i; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/22313/c-solution-using-bit-manipulation C++ solution using bit manipulation 123456789101112131415class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int result = nums.size(); int i=0; for(int num:nums)&#123; result ^= num; result ^= i; i++; &#125; return result; &#125;&#125;; There are several similar problems in the problem list. https://discuss.leetcode.com/topic/22305/1-lines-ruby-python-java-c 1+ lines Ruby, Python, Java, C++ Several different solutions, some with O(1) extra space, some with O(n). Sum of 0..n minus sum of the given numbers is the missing one. These only use O(1) extra space. Python 123def missingNumber(self, nums): n = len(nums) return n * (n+1) / 2 - sum(nums) Java 1234public int missingNumber(int[] nums) &#123; long n = nums.length; return (int) (n * (n+1) / 2 - IntStream.of(nums).sum());&#125; C++ 1234int missingNumber(vector&lt;int&gt;&amp; nums) &#123; long n = nums.size(); return n * (n+1) / 2 - accumulate(begin(nums), end(nums), 0);&#125; Using long for Java and C++ to prevent overflow (the n*(n+1) overflows ints already for n=46341, and then the /2 causes an actual wrong result). Xor-ing the given numbers and 0..n. These use O(n) extra space, but I like them anyway. Python 12def missingNumber(self, nums): return reduce(operator.xor, nums + range(len(nums)+1)) Xor-ing with O(1) space Saw this from ts before. Xoring 0..n results in [n, 1, n+1, 0][n % 4]. You can also spot the pattern by looking at xors of such ranges, and itâ€™s easy to explain as well. Python 123def missingNumber(self, nums): n = len(nums) return reduce(operator.xor, nums) ^ [n, 1, n+1, 0][n % 4] Sum, without formula. Java and C++: 1234int miss = 0, i = 0;for (int num : nums) miss += ++i - num;return miss; In Java I believe this is safe, overflow might happen but not cause a wrong result (because another overflow will fix it). In C++ I believe itâ€™s probably safe in the same way, except that that behavior isnâ€™t defined in the standard(s) but is a de-facto standard anyway. In any case, I could just use 64-bit ints again to be safe. Set/array difference Donâ€™t know about Rubyâ€™s runtime, might not be linear. Pythonâ€™s sets are hash sets and the difference is linear time on average. Donâ€™t know about its worst case, and apparently neither does the TimeComplexity page. Python 12def missingNumber(self, nums): return (set(range(len(nums)+1)) - set(nums)).pop() https://discuss.leetcode.com/topic/25998/clear-c-solution-that-can-avoid-overflow Clear C++ solution that can avoid overflow 123456789class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int result = 0; for (int i = 0; i &lt; nums.size(); i++) result ^= nums[i]^(i+1); return result; &#125;&#125;; https://discuss.leetcode.com/topic/22366/simple-c-codes Simple C++ codes Using bit XOR operatons, just like the â€œfind missing number (all elements except one occur twice, find the one that occurs once)â€ one The reason I didnâ€™t use sum[1..n] - sum(nums) is that calculating sum has potential to cause overflow. XOR bit operation is much safer. 123456789class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int missing =0; for(int i=0; i&lt;nums.size();++i) missing ^= ((i+1)^nums[i]); return missing; &#125;&#125;; https://discuss.leetcode.com/topic/42439/1-line-python-solution 1 line Python Solution 123class Solution(object): def missingNumber(self, nums): return sum(range(len(nums)+1)) - sum(nums)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>math</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[264. Ugly Number II]]></title>
    <url>%2Fp%2Fff8ccd53%2F</url>
    <content type="text"><![CDATA[32.0% https://leetcode.com/problems/ugly-number-ii Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note that 1 is typically treated as an ugly number, and n does not exceed 1690. Hint: The naive approach is to call isUgly for every number until you reach the nth one. Most numbers are not ugly. Try to focus your effort on generating only the ugly ones. An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number. The key is how to maintain the order of the ugly numbers. Try a similar approach of merging from three sorted lists: L1, L2, and L3. Assume you have Uk, the kth ugly number. Then Uk+1 must be Min(L1 2, L2 3, L3 * 5). æ–¹æ³•ä¸€: my codeï¼š 123456789101112131415161718192021class Solution &#123;public: int nthUglyNumber(int n) &#123; if(n==1) return 1; vector&lt;int&gt; nums = &#123;1&#125;; int two=0, three=0, five=0; int i=1; while(i&lt;n)&#123; int cur = min(nums[five]*5, min(nums[three]*3, nums[two]*2)); nums.push_back(cur); if(cur==nums[two]*2) two++; if(cur==nums[three]*3) three++; if(cur==nums[five]*5) five++; i++; &#125; return nums[n-1]; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415class Solution &#123;public: int nthUglyNumber(int n) &#123; vector&lt;int&gt; res(n, 1); int i2=0, i3=0, i5=0; for(int i=1; i&lt;n; i++)&#123; int cur = min(res[i2]*2, min(res[i3]*3, res[i5]*5)); res[i] = cur; if(res[i2]*2==cur) i2++; if(res[i3]*3==cur) i3++; if(res[i5]*5==cur) i5++; &#125; return res[n-1]; &#125;&#125;; æ–¹æ³•äºŒ: 36ms, 28.93%, May.3rd, 2016 https://leetcode.com/discuss/58186/elegant-c-solution-o-n-space-time-with-detailed-explanation 1234567891011121314class Solution &#123;public: int nthUglyNumber(int n) &#123; vector &lt;int&gt; results(1, 1); int i = 0, j = 0, k = 0; while(results.size() &lt; n)&#123; results.push_back(min(results[i] * 2, min(results[j] * 3, results[k] * 5))); if(results.back() == results[i] * 2) ++i; if(results.back() == results[j] * 3) ++j; if(results.back() == results[k] * 5) ++k; &#125; return results.back(); &#125;&#125;; cpp 20ms, 44.77%, May.3rd, 2016 123456789101112131415161718class Solution &#123;public: int nthUglyNumber(int n) &#123; if(n &lt;= 0) return false; // get rid of corner cases if(n == 1) return true; // base case int t2 = 0, t3 = 0, t5 = 0; //pointers for 2, 3, 5 vector&lt;int&gt; k(n); k[0] = 1; for(int i = 1; i &lt; n ; i ++) &#123; k[i] = min(k[t2]*2,min(k[t3]*3,k[t5]*5)); if(k[i] == k[t2]*2) t2++; if(k[i] == k[t3]*3) t3++; if(k[i] == k[t5]*5) t5++; &#125; return k[n-1]; &#125;&#125;; 20ms, 44.77%, May.3rd, 2016 https://leetcode.com/discuss/53225/c-one-pass-simple-solution 12345678910111213141516class Solution &#123;public: int nthUglyNumber(int n) &#123; if(n&lt;1) return 0; int id2 = 0, id3 = 0, id5 = 0, rst = 1; vector&lt;int&gt; buf; while(--n)&#123; buf.push_back(rst); int v2 = 2 * (buf[id2]), v3 = 3 * (buf[id3]), v5 = 5 * (buf[id5]); rst = min(v2, min(v3, v5)); id2 += (rst == v2), id3 += (rst == v3), id5 += (rst == v5); &#125; return rst; &#125;&#125;; python212ms, 67.75%, May.3rd, 2016 https://leetcode.com/discuss/57156/my-expressive-python-solution 1234567891011121314151617181920class Solution(object): def nthUglyNumber(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; ugly = [1] i2, i3, i5 = 0, 0, 0 while n &gt; 1: u2, u3, u5 = 2 * ugly[i2], 3 * ugly[i3], 5 * ugly[i5] umin = min((u2, u3, u5)) if umin == u2: i2 += 1 if umin == u3: i3 += 1 if umin == u5: i5 += 1 ugly.append(umin) n -= 1 return ugly[-1] javaThe idea of this solution is from this page:http://www.geeksforgeeks.org/ugly-numbers/ The ugly-number sequence is 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, â€¦because every number can only be divided by 2, 3, 5, one way to look at the sequence is to split the sequence to three groups as below: 123(1) 1Ã—2, 2Ã—2, 3Ã—2, 4Ã—2, 5Ã—2, â€¦(2) 1Ã—3, 2Ã—3, 3Ã—3, 4Ã—3, 5Ã—3, â€¦(3) 1Ã—5, 2Ã—5, 3Ã—5, 4Ã—5, 5Ã—5, â€¦ We can find that every subsequence is the ugly-sequence itself (1, 2, 3, 4, 5, â€¦) multiply 2, 3, 5. Then we use similar merge method as merge sort, to get every ugly number from the three subsequence. Every step we choose the smallest one, and move one step after,including nums with same value. Thanks for this author about this brilliant idea. Here is my java solution 12345678910111213141516171819public class Solution &#123; public int nthUglyNumber(int n) &#123; int[] ugly = new int[n]; ugly[0] = 1; int index2 = 0, index3 = 0, index5 = 0; int factor2 = 2, factor3 = 3, factor5 = 5; for(int i=1;i&lt;n;i++)&#123; int min = Math.min(Math.min(factor2,factor3),factor5); ugly[i] = min; if(factor2 == min) factor2 = 2*ugly[++index2]; if(factor3 == min) factor3 = 3*ugly[++index3]; if(factor5 == min) factor5 = 5*ugly[++index5]; &#125; return ugly[n-1]; &#125;&#125; my code 12345678910111213141516171819public class Solution &#123; public int nthUglyNumber(int n) &#123; int i=0, j=0, k=0; int[] ugly = new int[n]; ugly[0] = 1; int idx=0; for(int l=1; l&lt;n; l++)&#123; int min = Math.min(ugly[i]*2, Math.min(ugly[j]*3, ugly[k]*5)); ugly[l] = min; if(min==ugly[i]*2) i++; if(min==ugly[j]*3) j++; if(min==ugly[k]*5) k++; &#125; return ugly[n-1]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[263. Ugly Number]]></title>
    <url>%2Fp%2F2e99b71d%2F</url>
    <content type="text"><![CDATA[38.7% https://leetcode.com/problems/ugly-number/#/description Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. Credits: è€ƒè™‘è¦å‘¨å…¨ï¼Œé¢˜ç›®è¦æ±‚ä¸‘æ•°å¿…é¡»ä¸ºæ­£æ•°ï¼Œæ‰€ä»¥å…ˆé™¤æŽ‰å°äºŽ0çš„æ•°å­—ï¼Œä¸è¦å¿˜äº†ã€‚ num%2 num&amp;1 num/2 num&gt;&gt;1 é™¤ä»¥2çš„æ—¶å€™ï¼Œå°½é‡ç”¨ä½è¿ç®—ä»£æ›¿ï¼Œæ•ˆçŽ‡è¾ƒé«˜ æ–¹æ³•ä¸€ï¼š c / c++1234for (int i=2; i&lt;6 &amp;&amp; num; i++) while (num % i == 0) num /= i;return num == 1; æ–¹æ³•äºŒï¼š 8ms, 5.25%, May.2nd, 2016 https://leetcode.com/discuss/55542/4ms-short-c-solution 1234567891011class Solution &#123;public: bool isUgly(int num) &#123; if(num == 1) return true; if(num &lt;= 0) return false; while(num % 2 == 0) num /= 2; while(num % 3 == 0) num /= 3; while(num % 5 == 0) num /= 5; return num == 1; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213class Solution &#123;public: bool isUgly(int num) &#123; if(num&lt;=0) return false; while(num%2==0) num /= 2; while(num%3==0) num /= 3; while(num%5==0) num /= 5; return num==1; &#125;&#125;; æ–¹æ³•ä¸‰ï¼š 8ms, 5.25%, May.2nd, 2016 https://leetcode.com/discuss/52703/2-4-lines-every-language 123456789class Solution &#123;public: bool isUgly(int num) &#123; for(int i=2; i&lt;6 &amp;&amp; num; i++) while(num % i == 0) num /= i; return num == 1; &#125;&#125;; python https://discuss.leetcode.com/topic/27421/my-python-solution 1234567891011def isUgly(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; if num &lt;= 0: return False for x in [2, 3, 5]: while num % x == 0: num = num / x return num == 1 Mine Solution: 64ms, 22.53%, May.2nd, 2016 123456789101112131415class Solution(object): def isUgly(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; if num &lt;= 0: return False while not (num % 2): num = num / 2 while not (num % 3): num = num / 3 while not (num % 5): num = num / 5 return True if num == 1 else False Solution 1: 68ms, 14.68%, May.2nd, 2016 https://leetcode.com/discuss/52703/2-4-lines-every-language 12345678910class Solution(object): def isUgly(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; for p in 2, 3, 5: while num % p == 0 &lt; num: num /= p return num == 1 Solution 2: 68ms, 14.68%, May.2nd, 2016 https://leetcode.com/discuss/97377/python-1-line-solution 12345678class Solution(object): def isUgly(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; #n = (2**30)*(3**20)*(5**13) = 4570198050078720000000000000L return False if num &lt; 1 or (4570198050078720000000000000L)%num != 0 else True Solution 3: 80ms, 4.65%, May.2nd, 2016 https://leetcode.com/discuss/64640/my-python-solution 123456789101112class Solution(object): def isUgly(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; if num &lt;= 0: return False for x in [2, 3, 5]: while num % x == 0: num /= x return num == 1 javahttps://discuss.leetcode.com/topic/25616/my-2ms-java-solution12345678public boolean isUgly(int num) &#123; if(num==1) return true; if(num==0) return false; while(num%2==0) num=num&gt;&gt;1; while(num%3==0) num=num/3; while(num%5==0) num=num/5; return num==1;&#125; https://discuss.leetcode.com/topic/21873/simple-java-solution-with-explanation idea: (1) basic cases: &lt;= 0 and == 1 (2) other cases: since the number can contain the factors of 2, 3, 5, I just remove those factors. So now, I have a number without any factors of 2, 3, 5. (3) after the removing, the number (new number) can contain a) the factor that is prime and meanwhile it is &gt;= 7, or b) the factor that is not the prime and the factor is not comprised of 2, 3 or 5. In both cases, it is false (not ugly number). For example, new number can be 11, 23 â€“&gt; not ugly number (case a)). new number also can be 49, 121 â€“&gt; not ugly number (case b)) 1234567891011121314public boolean isUgly(int num) &#123; if (num &lt;= 0) &#123;return false;&#125; if (num == 1) &#123;return true;&#125; if (num % 2 == 0) &#123; return isUgly(num/2); &#125; if (num % 3 == 0) &#123; return isUgly(num/3); &#125; if (num % 5 == 0) &#123; return isUgly(num/5); &#125; return false;&#125; https://discuss.leetcode.com/topic/33389/java-solution-greatest-divide-by-2-3-5 clean solution to greatest divide the num using 2, 3, and 5.12345678910111213141516public class Solution &#123; public static boolean isUgly(int num) &#123; if (num &lt;= 0) &#123; return false; &#125; int[] divisors = &#123;2, 3, 5&#125;; for(int d : divisors) &#123; while (num % d == 0) &#123; num /= d; &#125; &#125; return num == 1; &#125;&#125; my code: 123456789101112public class Solution &#123; public boolean isUgly(int num) &#123; if(num&lt;=0) return false; while(num%2 == 0) num /= 2; while(num%3 == 0) num /= 3; while(num%5 == 0) num /= 5; return num==1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[260. Single Number III]]></title>
    <url>%2Fp%2Fc6227aad%2F</url>
    <content type="text"><![CDATA[49.9% https://leetcode.com/problems/single-number-iii/?tab=Description Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. 123For example:Given nums = [1, 2, 1, 3, 2, 5], return [3, 5]. Note: The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity? å‰‘æŒ‡offer 40 æ–¹æ³•ä¸€ï¼š æ±‚ç¬¬ä¸€ä½éž0ï¼Œ diff &amp;= -diff. -diffæ±‚çš„ç›¸åçš„æ•°å­—ï¼Œå­˜å‚¨æ˜¯è¡¥ç ï¼Œ å–ååŠ 1. diff = 110 diff &amp; (-diffï¼‰ = 010 https://discuss.leetcode.com/topic/21605/accepted-c-java-o-n-time-o-1-space-easy-solution-with-detail-explanations Accepted C++/Java O(n)-time O(1)-space Easy Solution with Detail Explanations Once again, we need to use XOR to solve this problem. But this time, we need to do it in two passes: In the first pass, we XOR all elements in the array, and get the XOR of the two numbers we need to find. Note that since the two numbers are distinct, so there must be a set bit (that is, the bit with value â€˜1â€™) in the XOR result. Find out an arbitrary set bit (for example, the rightmost set bit). In the second pass, we divide all numbers into two groups, one with the aforementioned bit set, another with the aforementinoed bit unset. Two different numbers we need to find must fall into thte two distrinct groups. XOR numbers in each group, we can find a number in either group. Complexity: Time: O (n) Space: O (1) A Corner Case: When diff == numeric_limits::min(), -diff is also numeric_limits::min(). Therefore, the value of diff after executing diff &amp;= -diff is still numeric_limits::min(). The answer is still correct.C++: 123456789101112131415161718192021222324252627class Solution&#123;public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; // Pass 1 : // Get the XOR of the two numbers we need to find int diff = accumulate(nums.begin(), nums.end(), 0, bit_xor&lt;int&gt;()); // Get its last set bit diff &amp;= -diff; // Pass 2 : vector&lt;int&gt; rets = &#123;0, 0&#125;; // this vector stores the two numbers we will return for (int num : nums) &#123; if ((num &amp; diff) == 0) // the bit is not set &#123; rets[0] ^= num; &#125; else // the bit is set &#123; rets[1] ^= num; &#125; &#125; return rets; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š æ³¨æ„ç”¨&amp;è¿˜æ˜¯ç”¨^ 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; int flag = 0; for(auto num:nums) flag ^= num; flag = flag&amp;-flag; int num1 = 0, num2 = 0; for(auto num:nums)&#123; if(num&amp;flag) num1 ^= num; else num2 ^= num; &#125; res.push_back(num1); res.push_back(num2); return res; &#125;&#125;; Thanks for reading :) Acknowledgements: Thank @jianchao.li.fighter for introducing this problem and for your encouragement. Thank @StefanPochmann for your valuable suggestions and comments. Your idea of diff &amp;= -diff is very elegent! And yes, it does not need to XOR for both group in the second pass. XOR for one group suffices. I revise my code accordingly. Thank @Nakagawa_Kanon for posting this question and presenting the same idea in a previous thread (prior to this thread). Thank @caijun for providing an interesting test case. æ–¹æ³•äºŒï¼š int lastBit = (aXorb &amp; (aXorb - 1)) ^ aXorb; https://discuss.leetcode.com/topic/21984/c-solution-o-n-time-and-o-1-space-easy-understaning-with-simple-explanation C++ solution O(n) time and O(1) space, easy-understaning with simple explanation 123456789101112vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; int aXorb = 0; // the result of a xor b; for (auto item : nums) aXorb ^= item; int lastBit = (aXorb &amp; (aXorb - 1)) ^ aXorb; // the last bit that a diffs b int intA = 0, intB = 0; for (auto item : nums) &#123; // based on the last bit, group the items into groupA(include a) and groupB if (item &amp; lastBit) intA = intA ^ item; else intB = intB ^ item; &#125; return vector&lt;int&gt;&#123;intA, intB&#125;; &#125; https://discuss.leetcode.com/topic/25382/sharing-explanation-of-the-solution Sharing explanation of the solution If you were stuck by this problem, itâ€™s easy to find a solution in the discussion. However, usually, the solution lacks some explanations. Iâ€™m sharing my understanding here: The two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. One important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. Letâ€™s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1. Thus, all the numbers can be partitioned into two groups according to their bits at location i.the first group consists of all numbers whose bits at i is 0.the second group consists of all numbers whose bits at i is 1. Notice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group. by XoRing all numbers in the first group, we can get the first number. by XoRing all numbers in the second group, we can get the second number. https://discuss.leetcode.com/topic/43805/bit-manipulation-beats-99-62 Bit manipulation beats 99.62% Find the rightmost set bit, divide numbers into two groups. Each group will end up being one unique number. 12345678910111213141516171819202122232425262728public int[] singleNumber(int[] nums) &#123; int result[] = new int[2]; int xor = nums[0]; for (int i=1; i&lt;nums.length; i++) &#123; xor ^= nums[i]; &#125; int bit = xor &amp; ~(xor-1); int num1 = 0; int num2 = 0; for (int num : nums) &#123; if ((num &amp; bit) &gt; 0) &#123; num1 ^= num; &#125; else &#123; num2 ^= num; &#125; &#125; result[0] = num1; result[1] = num2; return result;&#125; https://discuss.leetcode.com/topic/34545/share-my-c-solution Share my C++ solution, assume that A and B are the two elements which we want to find; use XOR for all elements,the result is : r = A^B,we just need to distinguish A from B next step; if we can find a bit â€˜1â€™ in r,then the bit in corresponding position in A and B must be different.We can use {last = r &amp; (~(r-1))} to get the last bit 1 int r; we use last to divide all numbers into two groups,then A and B must fall into the two distrinct groups.XOR elements in eash group,get the A and B. 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; int r = 0, n = nums.size(), i = 0, last = 0; vector&lt;int&gt; ret(2, 0); for (i = 0; i &lt; n; ++i) r ^= nums[i]; last = r &amp; (~(r - 1)); for (i = 0; i &lt; n; ++i) &#123; if ((last &amp; nums[i]) != 0) ret[0] ^= nums[i]; else ret[1] ^= nums[i]; &#125; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/21883/my-java-solution-adapted-from-the-commonest-solution-here My Java solution adapted from the commonest solution here I read @zhiqing_xiao â€˜s post to get an idea about the solution. His solution is really smart and elegant, but it took me a while to get understand how â€œdiff &amp;= -diffâ€ works. I changed it a little bit to make it better understood, but it is totally based on his solution. Instead of using the right-most â€œ1â€ of diff, I used the left-most â€œ1â€ to divide groups. This should also do the trick. 123456789101112131415161718192021public class Solution &#123; public int[] singleNumber(int[] nums) &#123; int diff = 0; for(int num: nums)&#123; diff^=num; &#125; diff = Integer.highestOneBit(diff); int[] result = new int[2]; Arrays.fill(result,0); for(int num: nums)&#123; if((diff &amp; num) == 0)&#123; result[0] ^= num; &#125; else&#123; result[1] ^= num; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[258. Add Digits]]></title>
    <url>%2Fp%2F3ec955c1%2F</url>
    <content type="text"><![CDATA[50.6% Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. 123For example:Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime? Hint: A naive implementation of the above process is trivial. Could you come up with other methods? What are all the possible results? How do they occur, periodically or randomly? You may find this Wikipedia article useful. https://discuss.leetcode.com/topic/21498/accepted-c-o-1-time-o-1-space-1-line-solution-with-detail-explanations/2 Accepted C++ O(1)-time O(1)-space 1-Line Solution with Detail Explanations The problem, widely known as digit root problem, has a congruence formula: https://en.wikipedia.org/wiki/Digital_root#Congruence_formula For base b (decimal case b = 10), the digit root of an integer is: dr(n) = 0 if n == 0 dr(n) = (b-1) if n != 0 and n % (b-1) == 0 dr(n) = n mod (b-1) if n % (b-1) != 0 or dr(n) = 1 + (n - 1) % 9 Note here, when n = 0, since (n - 1) % 9 = -1, the return value is zero (correct). From the formula, we can find that the result of this problem is immanently periodic, with period (b-1). Output sequence for decimals (b = 10): ~ input: 0 1 2 3 4 â€¦ output: 0 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 â€¦. Henceforth, we can write the following code, whose time and space complexities are both O(1). 123456class Solution &#123;public: int addDigits(int num) &#123; return 1 + (num - 1) % 9; &#125;&#125;; Thanks for reading. :) https://discuss.leetcode.com/topic/36921/c-3-lines-implementation C++ 3 lines implementation 12345678class Solution &#123;public: int addDigits(int num) &#123; if(num%9 == 0 &amp;&amp; num!=0) return 9; return (num%9); &#125;&#125;; https://discuss.leetcode.com/topic/28791/3-methods-for-python-with-explains 3 methods for python with explains Iteration method 12345678910111213class Solution(object):def addDigits(self, num):&quot;&quot;&quot;:type num: int:rtype: int&quot;&quot;&quot;while(num &gt;= 10): temp = 0 while(num &gt; 0): temp += num % 10 num /= 10 num = tempreturn num Digital Rootthis method depends on the truth: N=(a[0] 1 + a[1] 10 + â€¦a[n] * 10 ^n),and a[0]â€¦a[n] are all between [0,9] we set M = a[0] + a[1] + ..a[n] and another truth is that: 1 % 9 = 1 10 % 9 = 1 100 % 9 = 1 so N % 9 = a[0] + a[1] + ..a[n] means N % 9 = M so N = M (% 9) as 9 % 9 = 0,so we can make (n - 1) % 9 + 1 to help us solve the problem when n is 9.as N is 9, ( 9 - 1) % 9 + 1 = 9 12345678class Solution(object):def addDigits(self, num): &quot;&quot;&quot; :type num: int :rtype: int &quot;&quot;&quot; if num == 0 : return 0 else:return (num - 1) % 9 + 1 https://discuss.leetcode.com/topic/21834/o-1-solution-with-mod-operation O(1) solution with mod operation If an integer is like 100a+10b+c, then (100a+10b+c)%9=(a+99a+b+9b+c)%9=(a+b+c)%9 1234567class Solution: # @param &#123;integer&#125; num # @return &#123;integer&#125; def addDigits(self, num): if num==0: return 0 return num%9 if num%9!=0 else 9 https://discuss.leetcode.com/topic/30490/no-loop-recursion-o-1-runtime-just-one-line-python-code No loop/recursion, O(1) runtime, just one line python code 123class Solution(object): def addDigits(self, num): return num if num == 0 else num % 9 or 9]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[257. Binary Tree Paths]]></title>
    <url>%2Fp%2F900d76e0%2F</url>
    <content type="text"><![CDATA[36.4% Given a binary tree, return all root-to-leaf paths. 12345678910For example, given the following binary tree: 1 / \2 3 \ 5All root-to-leaf paths are:[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;] æ–¹æ³•ä¸€ï¼› https://discuss.leetcode.com/topic/21447/c-simple-4ms-recursive-solution C++ simple 4ms recursive solution 1234567891011121314151617void binaryTreePaths(vector&lt;string&gt;&amp; result, TreeNode* root, string t) &#123; if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123; result.push_back(t); return; &#125; if(root-&gt;left) binaryTreePaths(result, root-&gt;left, t + &quot;-&gt;&quot; + to_string(root-&gt;left-&gt;val)); if(root-&gt;right) binaryTreePaths(result, root-&gt;right, t + &quot;-&gt;&quot; + to_string(root-&gt;right-&gt;val));&#125;vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; result; if(!root) return result; binaryTreePaths(result, root, to_string(root-&gt;val)); return result;&#125; æ–¹æ³•äºŒï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; res; if(!root) return res; vector&lt;int&gt; s = &#123;root-&gt;val&#125;; helper(root, res, s); return res; &#125; void helper(TreeNode* root, vector&lt;string&gt;&amp; res, vector&lt;int&gt;&amp; s)&#123; if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123; string t = to_string(s[0]); for(int i=1; i&lt;s.size(); i++) t += "-&gt;" + to_string(s[i]); res.push_back(t); return; &#125; if(root-&gt;left)&#123; s.push_back(root-&gt;left-&gt;val); helper(root-&gt;left, res, s); s.pop_back(); &#125; if(root-&gt;right)&#123; s.push_back(root-&gt;right-&gt;val); helper(root-&gt;right, res, s); s.pop_back(); &#125; s.pop_back(); &#125;&#125;; https://discuss.leetcode.com/topic/22133/my-java-and-c-solution-c-4ms My java and c++ solution,c++ 4ms this is a simple dfs+tree question,using preorder to visit tree will be fine. c++: 1234567891011121314151617181920212223class Solution &#123; public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; v; if(root) preorder(v,root,&quot;&quot;); return v; &#125; void preorder(vector&lt;string&gt;&amp; v,TreeNode* r,string t)&#123; if(!r) return; if(!t.empty()) t+=(&quot;-&gt;&quot;+to_string(r-&gt;val)); else t+=to_string(r-&gt;val); if(r-&gt;left||r-&gt;right)&#123; preorder(v,r-&gt;left,t); preorder(v,r-&gt;right,t); &#125;else&#123; v.push_back(t); &#125; &#125; &#125;; my java: 12345678910111213141516171819public class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; l=new ArrayList&lt;&gt;(); if(root!=null) pre(l,root,&quot;&quot;); return l; &#125; void pre(List&lt;String&gt; l,TreeNode r,String s)&#123; if(r==null)return; if(s.isEmpty()) s+=r.val; else s+=(&quot;-&gt;&quot;+r.val); if(r.left!=null||r.right!=null)&#123; pre(l,r.left,s); pre(l,r.right,s); &#125;else l.add(s); &#125;&#125; https://discuss.leetcode.com/topic/21559/python-solutions-dfs-stack-bfs-queue-dfs-recursively Python solutions (dfs+stack, bfs+queue, dfs recursively). 1234567891011121314# dfs + stackdef binaryTreePaths1(self, root): if not root: return [] res, stack = [], [(root, &quot;&quot;)] while stack: node, ls = stack.pop() if not node.left and not node.right: res.append(ls+str(node.val)) if node.right: stack.append((node.right, ls+str(node.val)+&quot;-&gt;&quot;)) if node.left: stack.append((node.left, ls+str(node.val)+&quot;-&gt;&quot;)) return res 1234567891011121314# bfs + queuedef binaryTreePaths2(self, root): if not root: return [] res, queue = [], collections.deque([(root, &quot;&quot;)]) while queue: node, ls = queue.popleft() if not node.left and not node.right: res.append(ls+str(node.val)) if node.left: queue.append((node.left, ls+str(node.val)+&quot;-&gt;&quot;)) if node.right: queue.append((node.right, ls+str(node.val)+&quot;-&gt;&quot;)) return res 123456789101112131415# dfs recursivelydef binaryTreePaths(self, root): if not root: return [] res = [] self.dfs(root, &quot;&quot;, res) return resdef dfs(self, root, ls, res): if not root.left and not root.right: res.append(ls+str(root.val)) if root.left: self.dfs(root.left, ls+str(root.val)+&quot;-&gt;&quot;, res) if root.right: self.dfs(root.right, ls+str(root.val)+&quot;-&gt;&quot;, res) 48ms, 64.24%, May.3rd, 2016 https://leetcode.com/discuss/52020/5-lines-recursive-python 5 lines recursive Python 123456def binaryTreePaths(self, root): if not root: return [] return [str(root.val) + &apos;-&gt;&apos; + path for kid in (root.left, root.right) if kid for path in self.binaryTreePaths(kid)] or [str(root.val)] 69ms, 5.30%, 209 / 209, May.3rd, 2016 https://leetcode.com/discuss/59288/8-lines-in-python-48ms 8 lines in python,48ms 12345678def binaryTreePaths(self, root): if not root: return [] if not root.left and not root.right: return [str(root.val)] treepaths = [str(root.val)+&apos;-&gt;&apos;+path for path in self.binaryTreePaths(root.left)] treepaths += [str(root.val)+&apos;-&gt;&apos;+path for path in self.binaryTreePaths(root.right)] return treepaths]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[242. Valid Anagram]]></title>
    <url>%2Fp%2Fda56d9f0%2F</url>
    <content type="text"><![CDATA[45.4% https://leetcode.com/problems/valid-anagram/?tab=Description Given two strings s and t, write a function to determine if t is an anagram of s. 123For example,s = &quot;anagram&quot;, t = &quot;nagaram&quot;, return true.s = &quot;rat&quot;, t = &quot;car&quot;, return false. Note: You may assume the string contains only lowercase alphabets. https://discuss.leetcode.com/topic/20303/2-c-solutions-with-explanations 2 C++ Solutions with Explanations æ–¹æ³•ä¸€: Hash Table This idea uses a hash table to record the times of appearances of each letter in the two strings s and t. For each letter in s, it increases the counter by 1 while for each letter in t, it decreases the counter by 1. Finally, all the counters will be 0 if they two are anagrams of each other. The first implementation uses the built-in unordered_map and takes 36 ms. 123456789101112131415class Solution &#123;public: bool isAnagram(string s, string t) &#123; if (s.length() != t.length()) return false; int n = s.length(); unordered_map&lt;char, int&gt; counts; for (int i = 0; i &lt; n; i++) &#123; counts[s[i]]++; counts[t[i]]--; &#125; for (auto count : counts) if (count.second) return false; return true; &#125;&#125;; æ–¹æ³•äºŒï¼š Since the problem statement says that â€œthe string contains only lowercase alphabetsâ€, we can simply use an array to simulate the unordered_map and speed up the code. The following implementation takes 12 ms. 123456789101112131415class Solution &#123;public: bool isAnagram(string s, string t) &#123; if (s.length() != t.length()) return false; int n = s.length(); int counts[26] = &#123;0&#125;; for (int i = 0; i &lt; n; i++) &#123; counts[s[i] - &apos;a&apos;]++; counts[t[i] - &apos;a&apos;]--; &#125; for (int i = 0; i &lt; 26; i++) if (counts[i]) return false; return true; &#125;&#125;; æˆ‘çš„å®žçŽ°ï¼š 1234567891011121314151617class Solution &#123;public: bool isAnagram(string s, string t) &#123; int m = s.size(); int n = t.size(); if(n&lt;m) return false; vector&lt;int&gt; tmp(26, 0); for(auto str:s) tmp[str-&apos;a&apos;]++; for(auto str:t)&#123; if(tmp[str-&apos;a&apos;]--==0) return false; &#125; return true; &#125;&#125;; æ–¹æ³•ä¸‰ï¼š Sorting For two anagrams, once they are sorted in a fixed order, they will become the same. This code is much shorter (this idea can be done in just 1 line using Python as here). However, it takes much longer time â€” 76 ms in C++. 12345678class Solution &#123;public: bool isAnagram(string s, string t) &#123; sort(s.begin(), s.end()); sort(t.begin(), t.end()); return s == t; &#125;&#125;; https://discuss.leetcode.com/topic/20831/python-solutions-sort-and-dictionary Python solutions (sort and dictionary). 1234567def isAnagram1(self, s, t): dic1, dic2 = &#123;&#125;, &#123;&#125; for item in s: dic1[item] = dic1.get(item, 0) + 1 for item in t: dic2[item] = dic2.get(item, 0) + 1 return dic1 == dic2 1234567def isAnagram2(self, s, t): dic1, dic2 = [0]*26, [0]*26 for item in s: dic1[ord(item)-ord(&apos;a&apos;)] += 1 for item in t: dic2[ord(item)-ord(&apos;a&apos;)] += 1 return dic1 == dic2 12def isAnagram3(self, s, t): return sorted(s) == sorted(t) https://discuss.leetcode.com/topic/23973/0ms-c-solution-o-n-time 0ms C++solution,O(n)time 1234567891011bool isAnagram(string s, string t) &#123; int alp[26]=&#123;&#125;; for (int i = 0; i &lt; s.length(); i++) alp[s.at(i) - &apos;a&apos;]++; for (int i = 0; i &lt; t.length(); i++) alp[t.at(i) - &apos;a&apos;]--; for (int i=0;i&lt;26;i++) if (alp[i] != 0) return false; return true;&#125; https://discuss.leetcode.com/topic/20485/share-my-java-solution Share my java solution 123456789101112131415161718public class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length()!=t.length())&#123; return false; &#125; int[] count = new int[26]; for(int i=0;i&lt;s.length();i++)&#123; count[s.charAt(i)-&apos;a&apos;]++; count[t.charAt(i)-&apos;a&apos;]--; &#125; for(int i:count)&#123; if(i!=0)&#123; return false; &#125; &#125; return true; &#125;&#125; https://discuss.leetcode.com/topic/20314/accepted-java-o-n-solution-in-5-lines Accepted Java O(n) solution in 5 lines The idea is simple. It creates a size 26 int arrays as buckets for each letter in alphabet. It increments the bucket value with String s and decrement with string t. So if they are anagrams, all buckets should remain with initial value which is zero. So just checking that and return 123456789public class Solution &#123; public boolean isAnagram(String s, String t) &#123; int[] alphabet = new int[26]; for (int i = 0; i &lt; s.length(); i++) alphabet[s.charAt(i) - &apos;a&apos;]++; for (int i = 0; i &lt; t.length(); i++) alphabet[t.charAt(i) - &apos;a&apos;]--; for (int i : alphabet) if (i != 0) return false; return true; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[241. Different Ways to Add Parentheses]]></title>
    <url>%2Fp%2F58bae46e%2F</url>
    <content type="text"><![CDATA[42.2% https://leetcode.com/problems/different-ways-to-add-parentheses/#/description Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. 123456Example 1Input: &quot;2-1-1&quot;.((2-1)-1) = 0(2-(1-1)) = 2Output: [0, 2] 123456789Example 2Input: &quot;2*3-4*5&quot;(2*(3-(4*5))) = -34((2*3)-(4*5)) = -14((2*(3-4))*5) = -10(2*((3-4)*5)) = -10(((2*3)-4)*5) = 10Output: [-34, -14, -10, -10, 10] https://discuss.leetcode.com/topic/19906/c-4ms-recursive-dp-solution-with-brief-explanation æ–¹æ³•ä¸€ï¼š C++ 4ms Recursive &amp; DP solution with brief explanation Here is the basic recursive solution ä¸€ä¸ªæ˜¯åˆ†æ²»æ³• å­¦ä¹ ä¸€ä¸‹atoi(input.c_str())ï¼Œ atoiå‡½æ•°Convert string to integer substr(0, i) 0è¡¨ç¤ºå¼€å§‹ä½ç½®çš„indexï¼Œiè¡¨ç¤ºå¼€indexå¼€å§‹åŽçš„ä¸ªæ•°ã€‚ substr(i+1)ï¼Œè¡¨ç¤ºä»Ži+1å¼€å§‹è‡³å­—ç¬¦ä¸²ç»“å°¾ã€‚ 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; result; int size = input.size(); for (int i = 0; i &lt; size; i++) &#123; char cur = input[i]; if (cur == &apos;+&apos; || cur == &apos;-&apos; || cur == &apos;*&apos;) &#123; // Split input string into two parts and solve them recursively vector&lt;int&gt; result1 = diffWaysToCompute(input.substr(0, i)); vector&lt;int&gt; result2 = diffWaysToCompute(input.substr(i+1)); for (auto n1 : result1) &#123; for (auto n2 : result2) &#123; if (cur == &apos;+&apos;) result.push_back(n1 + n2); else if (cur == &apos;-&apos;) result.push_back(n1 - n2); else result.push_back(n1 * n2); &#125; &#125; &#125; &#125; // if the input string contains only numberï¼Œè¿™ç§æƒ…å†µè¦è€ƒè™‘åˆ° if (result.empty()) result.push_back(atoi(input.c_str())); return result; &#125;&#125;; æ–¹æ³•äºŒï¼š ç±»ä¼¼äºŽåˆ†æ²»æ³•ï¼Œä½†æ˜¯ç”¨åˆ°äº†dpï¼Œä¿å­˜éƒ¨åˆ†ç»“æžœåˆ°ä¸€ä¸ªmapé‡Œï¼Œæ–¹ä¾¿æŸ¥è¯¢ï¼ŒèŠ‚çº¦äº†è®¡ç®—ã€‚ There are many repeating subquestions in this recursive method, therefore, we could use dynamic programming to avoid this situation by saving the results for subquestions. Here is the DP solution. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; unordered_map&lt;string, vector&lt;int&gt;&gt; dpMap; // æ³¨æ„æ­¤å¤„mapçš„å®šä¹‰ï¼Œkeyä¸ºstringï¼Œvalueä¸ºvector&lt;int&gt; return computeWithDP(input, dpMap); &#125; vector&lt;int&gt; computeWithDP(string input, unordered_map&lt;string, vector&lt;int&gt;&gt; &amp;dpMap) &#123; vector&lt;int&gt; result; int size = input.size(); for (int i = 0; i &lt; size; i++) &#123; char cur = input[i]; if (cur == &apos;+&apos; || cur == &apos;-&apos; || cur == &apos;*&apos;) &#123; // Split input string into two parts and solve them recursively vector&lt;int&gt; result1, result2; string substr = input.substr(0, i); // check if dpMap has the result for substr if (dpMap.find(substr) != dpMap.end()) result1 = dpMap[substr]; else result1 = computeWithDP(substr, dpMap); substr = input.substr(i + 1); if (dpMap.find(substr) != dpMap.end()) // å­¦ä¹ å­—å…¸çš„æŸ¥æ‰¾å†™æ³• result2 = dpMap[substr]; else result2 = computeWithDP(substr, dpMap); for (auto n1 : result1) &#123; for (auto n2 : result2) &#123; if (cur == &apos;+&apos;) result.push_back(n1 + n2); else if (cur == &apos;-&apos;) result.push_back(n1 - n2); else result.push_back(n1 * n2); &#125; &#125; &#125; &#125; // if the input string contains only number if (result.empty()) result.push_back(atoi(input.c_str())); // è¿™ä¸€æ­¥å€¼å¾—å­¦ä¹  // save to dpMap dpMap[input] = result; // ä¸è¦å¿˜è®°è¿™ä¸€æ­¥ return result; &#125;&#125;; https://discuss.leetcode.com/topic/19894/1-11-lines-python-9-lines-c 1-11 lines Python, 9 lines C++ Just doing itâ€¦ Solution 1 â€¦ 48 ms 123456789101112def diffWaysToCompute(self, input): tokens = re.split(&apos;(\D)&apos;, input) nums = map(int, tokens[::2]) ops = map(&#123;&apos;+&apos;: operator.add, &apos;-&apos;: operator.sub, &apos;*&apos;: operator.mul&#125;.get, tokens[1::2]) def build(lo, hi): if lo == hi: return [nums[lo]] return [ops[i](a, b) for i in xrange(lo, hi) for a in build(lo, i) for b in build(i + 1, hi)] return build(0, len(nums) - 1) Solution 2 â€¦ 168 ms One-liner inspired by Soba. 12345def diffWaysToCompute(self, input): return [eval(`a`+c+`b`) for i, c in enumerate(input) if c in &apos;+-*&apos; for a in self.diffWaysToCompute(input[:i]) for b in self.diffWaysToCompute(input[i+1:])] or [int(input)] Solution 3 â€¦ 64 ms Faster version of solution 2. 12345def diffWaysToCompute(self, input): return [a+b if c == &apos;+&apos; else a-b if c == &apos;-&apos; else a*b for i, c in enumerate(input) if c in &apos;+-*&apos; for a in self.diffWaysToCompute(input[:i]) for b in self.diffWaysToCompute(input[i+1:])] or [int(input)] Solution 4 â€¦ 188 ms A code golf version of solution 2. 12diffWaysToCompute=d=lambda s,t:[eval(`a`+c+`b`)for i,c in enumerate(t)ifc&lt;&apos;0&apos;for a in s.d(t[:i])for b in s.d(t[i+1:])]or[int(t)] C++ â€¦ 8 ms C++ version of solution 3. 1234567891011vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; output; for (int i=0; i&lt;input.size(); i++) &#123; char c = input[i]; if (ispunct(c)) for (int a : diffWaysToCompute(input.substr(0, i))) for (int b : diffWaysToCompute(input.substr(i+1))) output.push_back(c==&apos;+&apos; ? a+b : c==&apos;-&apos; ? a-b : a*b); &#125; return output.size() ? output : vector&lt;int&gt;&#123;stoi(input)&#125;;&#125; https://discuss.leetcode.com/topic/22179/python-easy-to-understand-solution-divide-and-conquer Python easy to understand solution (divide and conquer). 1234567891011121314151617181920def diffWaysToCompute(self, input): if input.isdigit(): return [int(input)] res = [] for i in xrange(len(input)): if input[i] in &quot;-+*&quot;: res1 = self.diffWaysToCompute(input[:i]) res2 = self.diffWaysToCompute(input[i+1:]) for j in res1: for k in res2: res.append(self.helper(j, k, input[i])) return res def helper(self, m, n, op): if op == &quot;+&quot;: return m+n elif op == &quot;-&quot;: return m-n else: return m*n https://discuss.leetcode.com/topic/27532/14-line-c-solution 14-line c++ solution 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; ans; bool pureNum=true; for (int i=0; i&lt;input.length(); i++) if (input[i]&lt;&apos;0&apos; || input[i]&gt;&apos;9&apos;) &#123; pureNum=false; vector&lt;int&gt; L=diffWaysToCompute(input.substr(0, i)), R=diffWaysToCompute(input.substr(i+1, input.length()-i-1)); for (auto l : L) for (auto r : R) if (input[i]==&apos;+&apos;) ans.push_back(l+r); else if (input[i]==&apos;-&apos;) ans.push_back(l-r); else if (input[i]==&apos;*&apos;) ans.push_back(l*r); &#125; if (pureNum) ans.push_back(atoi(input.c_str())); return ans; &#125;&#125;; https://discuss.leetcode.com/topic/20516/c-solution-using-dp-easy-understanding C++ solution, using dp, easy understanding 123456789101112131415161718192021222324252627282930vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; data; vector&lt;char&gt; ops; int num = 0; char op = &apos; &apos;; istringstream ss(input + &quot;+&quot;); while(ss &gt;&gt; num &amp;&amp; ss &gt;&gt; op) &#123; data.push_back(num); ops.push_back(op); &#125; const int size_i = data.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(size_i, vector&lt;vector&lt;int&gt;&gt;(size_i, vector&lt;int&gt;())); for (int i = 0; i &lt; size_i; i += 1) for (int j = i; j &gt;= 0; j -= 1) &#123; if (i == j) &#123;dp[j][i].push_back(data[i]); continue;&#125; for (int k = j; k &lt; i; k += 1) &#123; for (auto left : dp[j][k]) for (auto right : dp[k+1][i]) &#123; int val = 0; switch(ops[k]) &#123; case &apos;+&apos;: val = left + right; break; case &apos;-&apos;: val = left - right; break; case &apos;*&apos;: val = left * right; break; &#125; dp[j][i].push_back(val); &#125; &#125; &#125; return dp[0][size_i-1];&#125; https://discuss.leetcode.com/topic/20814/python-solution-use-dp Python solution use dp First I extracted the numbers and operators in the expression. Assume there are d numbers and d-1 operators. dp[ i ][ j ] is all possible results of expression contains num[ i : j+1 ]. So the first loop we calculate expressions only have 2 numbers, then 3 numbers, then 4 numbersâ€¦. Letâ€™s say we want to get the result of expression contains L numbers started from num[ j ] , we divide it by two half, the first one contains k numbers, and the second half contains L-k numbers. The result of the first half is dp[ j ][ j+k-1 ] and the second half is dp[j+k-1][ j+l-1]. dp[ i ][ j ] contains all combinations of x from dp[ j ][ j+k-1 ] and y from dp[ j+k-1: j+l-1 ], and k is from 1 to l-1. 1234567891011121314151617import reclass Solution: # @param &#123;string&#125; input # @return &#123;integer[]&#125; def diffWaysToCompute(self, input): num=re.split(&apos;\+|-|\*&apos;,input) opr=re.findall(r&apos;\+|-|\*&apos;,input) d=len(num) dp=[[[]for i in range(d)] for j in range(d)] op=&#123;&apos;+&apos;:lambda x,y:x+y, &apos;-&apos;:lambda x,y:x-y, &apos;*&apos;:lambda x,y:x*y&#125; for i in range(d): dp[i][i].append(int(num[i])) for l in range(2,d+1): for j in range(d+1-l): dp[j][j+l-1]=[op[opr[j+k-1]](x,y) for k in range(1,l) for x in dp[j][j+k-1] for y in dp[j+k][j+l-1]] return dp[0][d-1] 10ms, 15.08%, October 15, 2016 https://discuss.leetcode.com/topic/19901/a-recursive-java-solution-284-ms 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; List&lt;Integer&gt; ret = new LinkedList&lt;Integer&gt;(); for(int i=0; i&lt;input.length(); i++)&#123; if(input.charAt(i) == &apos;-&apos; || input.charAt(i) == &apos;*&apos; || input.charAt(i) == &apos;+&apos;)&#123; String part1 = input.substring(0, i); String part2 = input.substring(i+1); List&lt;Integer&gt; part1Ret = diffWaysToCompute(part1); List&lt;Integer&gt; part2Ret = diffWaysToCompute(part2); for(Integer p1 : part1Ret)&#123; for(Integer p2:part2Ret)&#123; int c = 0; switch(input.charAt(i))&#123; case &apos;+&apos;: c = p1+p2; break; case &apos;-&apos;:c = p1-p2; break; case &apos;*&apos;: c = p1*p2; break; &#125; ret.add(c); &#125; &#125; &#125; &#125; if(ret.size() == 0) ret.add(Integer.valueOf(input)); return ret; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>divide and conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[240. Search a 2D Matrix II]]></title>
    <url>%2Fp%2Fac205ce%2F</url>
    <content type="text"><![CDATA[38.0% https://leetcode.com/problems/search-a-2d-matrix-ii/#/description Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. 1234567891011121314For example,Consider the following matrix:[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]Given target = 5, return true.Given target = 20, return false. æ–¹æ³•ä¸€ï¼š å‰‘æŒ‡offer 3 æˆ‘çš„ä»£ç å®žçŽ°ï¼š ä»Žå³ä¸Šè§’å¼€å§‹æœç´¢ 1234567891011121314151617181920212223class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; // int m = matrix.size(); // if(m==0) return false; // int n = matrix[0].size(); // if(n==0) return false; if(matrix.size()==0 || matrix[0].size()==0) return false; int m=matrix.size(), n=matrix[0].size(); if(target&lt;matrix[0][0] || target&gt;matrix[m-1][n-1]) return false; int i=0, j=n-1; while(i&lt;m &amp;&amp; j&gt;=0)&#123; if(target==matrix[i][j]) return true; else if(target&lt;matrix[i][j]) j--; else i++; &#125; return false; &#125;&#125;; æ³¨æ„ä»£ç ä¸­ 123if(matrix.size()==0 || matrix[0].size()==0) return false;int m=matrix.size(), n=matrix[0].size(); æ›¿ä»£ 1234int m = matrix.size();if(m==0) return false;int n = matrix[0].size();if(n==0) return false; å¯¹äºŽçŸ©é˜µæ˜¯å¥½ç”¨çš„ 184ms, 78.57%, June.23th, 2016 https://leetcode.com/discuss/47528/c-with-o-m-n-complexity 12345678910111213141516171819class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int m = matrix.size(); if(m == 0) return false; int n = matrix[0].size(); int i = 0, j = n - 1; while(i &lt; m &amp;&amp; j &gt;= 0)&#123; if(matrix[i][j] == target) return true; else if(matrix[i][j] &gt; target) j--; else i++; &#125; return false; &#125;&#125;; Solution mine: 720ms, 10.08%, June.23th, 2016 123456789101112class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; for i in xrange(len(matrix)): for j in xrange(len(matrix[0])): if matrix[i][j] == target: return True return False Solution 1: 184ms, 40.60%, June.23th, 2016 https://leetcode.com/discuss/47571/4-lines-c-6-lines-ruby-7-lines-python-1-liners 12345678class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; return any(target in row for row in matrix) Solution 2: 124ms, 59.95%, June.23th, 2016 https://leetcode.com/discuss/47571/4-lines-c-6-lines-ruby-7-lines-python-1-liners 1234567891011121314class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; j = -1 for row in matrix: while j + len(row) and row[j] &gt; target: j -= 1 if row[j] == target: return True return False 13ms, 53.66%, June.23th, 2016 https://leetcode.com/discuss/48852/my-concise-o-m-n-java-solution 123456789101112131415161718public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if(matrix == null || matrix.length &lt; 1 || matrix[0].length &lt; 1) return false; int col = matrix[0].length - 1; int row = 0; while(col &gt;= 0 &amp;&amp; row &lt;= matrix.length - 1)&#123; if(target == matrix[row][col]) return true; else if(target &lt; matrix[row][col]) col--; else row++; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>divide and conquer</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[239. Sliding Window Maximum]]></title>
    <url>%2Fp%2Fd8741db0%2F</url>
    <content type="text"><![CDATA[32.0% https://leetcode.com/problems/sliding-window-maximum/#/description Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. 123456789101112For example,Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7Therefore, return the max sliding window as [3,3,5,5,6,7]. Note: You may assume k is always valid, ie: 1 â‰¤ k â‰¤ input arrayâ€™s size for non-empty array. Follow up: Could you solve it in linear time? Hint: How about using a data structure such as deque (double-ended queue)? The queue size need not be the same as the windowâ€™s size. Remove redundant elements and the queue should store only elements that need to be considered. å‰‘æŒ‡offer 65 æ–¹æ³•ä¸€ï¼š ä½¿ç”¨å‰‘æŒ‡offer æ–¹æ³•ï¼Œä½¿ç”¨äº†ä¸€ä¸ªdequeï¼ŒåŒç«¯å¼€å£çš„é˜Ÿåˆ— dequeçš„æ–¹æ³•æœ‰pop_back, pop_front, front, back. 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; int n = nums.size(); if(k&lt;=0 || n&lt;1 || k&gt;n) return res; deque&lt;int&gt; dq; for(int i=0; i&lt;k; i++)&#123; while(!dq.empty() &amp;&amp; nums[i]&gt;nums[dq.back()]) dq.pop_back(); dq.push_back(i); &#125; for(int i=k; i&lt;n; i++)&#123; res.push_back(nums[dq.front()]); while(!dq.empty() &amp;&amp; nums[dq.back()]&lt;nums[i]) dq.pop_back(); if(!dq.empty() &amp;&amp; (i-dq.front())&gt;=k) //ç”¨ifè€Œä¸æ˜¯whileï¼Œå› ä¸ºæ¯æ¬¡è¿›æ¥ä¸€ä¸ªæœ€å¤šåªéœ€è¦popä¸€ä¸ª dq.pop_front(); dq.push_back(i); &#125; res.push_back(nums[dq.front()]); return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; int n = nums.size(); if(n==0 || k&lt;=0 || n&lt;k) return res; deque&lt;int&gt; dq; for(int i=0; i&lt;k; i++)&#123; while(!dq.empty() &amp;&amp; nums[dq.back()]&lt;=nums[i]) dq.pop_back(); dq.push_back(i); &#125; for(int i=k; i&lt;n; i++)&#123; res.push_back(nums[dq.front()]); while(!dq.empty() &amp;&amp; nums[dq.back()]&lt;=nums[i]) dq.pop_back(); // è¦æ£€æŸ¥dqæ˜¯å¦ä¸ºç©º if(!dq.empty() &amp;&amp; dq.front()+k&lt;=i) dq.pop_front(); dq.push_back(i); &#125; if(!dq.empty()) res.push_back(nums[dq.front()]); return res; &#125;&#125;; æ–¹æ³•äºŒï¼š å¯¹æ–¹æ³•ä¸€ä»£ç è¿›è¡Œäº†ä¼˜åŒ– Clean C++ O(n) solution using a deque The data structure used is know as Monotonic Queue. Click here for more information. You can also view more solution on Github 123456789101112131415class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt; dq; vector&lt;int&gt; ans; for (int i=0; i&lt;nums.size(); i++) &#123; if (!dq.empty() &amp;&amp; dq.front() == i-k) dq.pop_front(); while (!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i]) dq.pop_back(); dq.push_back(i); if (i&gt;=k-1) ans.push_back(nums[dq.front()]); &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/19067/clean-c-o-n-solution-using-a-deque é™„æ³¨ï¼š ç‰›å®¢ç½‘ https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&amp;tqId=11217&amp;tPage=4&amp;rp=4&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size) &#123; deque&lt;int&gt; dq; vector&lt;int&gt; res; for(int i=0; i&lt;num.size(); i++)&#123; if(!dq.empty() &amp;&amp; (i-dq.front())&gt;=size) dq.pop_front(); while(!dq.empty() &amp;&amp; num[i]&gt;=num[dq.back()]) dq.pop_back(); dq.push_back(i); if(i&gt;=size-1) res.push_back(num[dq.front()]); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/19297/this-is-a-typical-monotonic-queue-problem This is a typical monotonic queue problem Sliding window minimum/maximum = monotonic queue. I smelled the solution just when I read the title. This is essentially same idea as othersâ€™ deque solution, but this is much more standardized and modulized. If you ever need to use it in your real product, this code is definitely more preferable. What does Monoqueue do here: It has three basic options: push: push an element into the queue; O (1) (amortized) pop: pop an element out of the queue; O(1) (pop = remove, it canâ€™t report this element) max: report the max element in queue;O(1) It takes only O(n) time to process a N-size sliding window minimum/maximum problem. Note: different from a priority queue (which takes O(nlogk) to solve this problem), it doesnâ€™t pop the max element: It pops the first element (in original order) in queue. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Monoqueue&#123; deque&lt;pair&lt;int, int&gt;&gt; m_deque; //pair.first: the actual value, //pair.second: how many elements were deleted between it and the one before it. public: void push(int val) &#123; int count = 0; while(!m_deque.empty() &amp;&amp; m_deque.back().first &lt; val) &#123; count += m_deque.back().second + 1; m_deque.pop_back(); &#125; m_deque.emplace_back(val, count); &#125;; int max() &#123; return m_deque.front().first; &#125; void pop () &#123; if (m_deque.front().second &gt; 0) &#123; m_deque.front().second --; return; &#125; m_deque.pop_front(); &#125;&#125;;struct Solution &#123; vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; results; Monoqueue mq; k = min(k, (int)nums.size()); int i = 0; for (;i &lt; k - 1; ++i) //push first k - 1 numbers; &#123; mq.push(nums[i]); &#125; for (; i &lt; nums.size(); ++i) &#123; mq.push(nums[i]); // push a new element to queue; results.push_back(mq.max()); // report the current max in queue; mq.pop(); // pop first element in queue; &#125; return results; &#125;&#125;; https://discuss.leetcode.com/topic/19199/my-c-o-n-deque-based-solution-with-explanation My C++ O(n) deque based solution with explanation The basic idea is to use a deque (buffer) to save all currently potential â€œmaximumâ€ elements (i.e. the element in the current k-element window [i-k+1, i], and it is larger than the elements after itself). So for each i, we first pop up the elements that are no larger than nums[i] from buffer until we find one that is larger than nums[i] or the buffer is empty since those elements will be covered by nums[i] and can not be a maximum of any k-element window. Then we put nums[i] in the buffer. If i&gt;=k-1, we need to ouput the maximum for window [i-k+1, i], which is the front element of buffer. At last, we will check if the front element is nums[i-k+1], if so, we have to pop it up since it will be out of the window [i-k+2, i+1] in the next iteration. Since all the elements will be pushed into/ popped out of the buffer only once, so the time complexity is O(N). 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt; buffer; vector&lt;int&gt; res; for(auto i=0; i&lt;nums.size();++i) &#123; while(!buffer.empty() &amp;&amp; nums[i]&gt;=nums[buffer.back()]) buffer.pop_back(); buffer.push_back(i); if(i&gt;=k-1) res.push_back(nums[buffer.front()]); if(buffer.front()&lt;= i-k + 1) buffer.pop_front(); &#125; return res; &#125; https://discuss.leetcode.com/topic/23020/a-clear-solution-using-deque-c A clear solution using deque (C++) 12345678910111213141516171819class Solution &#123;public:vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt; q; vector&lt;int&gt; maxs; if(nums.empty()||k&lt;=0) return maxs; for(int i=0;i&lt;nums.size();i++)&#123; while(!q.empty()&amp;&amp;nums[q.back()]&lt;=nums[i]) q.pop_back(); q.push_back(i); if(q.front()&lt;=i-k) q.pop_front(); if(i&gt;=k-1) maxs.push_back(nums[q.front()]); &#125; return maxs;&#125;&#125;; https://discuss.leetcode.com/topic/19099/3-c-solutions 3 C++ Solutions O(NlogK) 12345678910111213vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; result; if (k == 0) return result; multiset&lt;int&gt; w; for (int i = 0, n = (int)nums.size(); i &lt; n; i++) &#123; if (i &gt;= k) w.erase(w.find(nums[i-k])); w.insert(nums[i]); if (i &gt;= k-1) result.push_back(*w.rbegin()); &#125; return result;&#125; O(NlogN) 12345678910111213vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; result; if (k == 0) return result; priority_queue&lt;pair&lt;int, int&gt;&gt; w; for (int i = 0, n = (int)nums.size(); i &lt; n; i++) &#123; while (!w.empty() &amp;&amp; w.top().second &lt;= i-k) w.pop(); w.push(make_pair(nums[i],i)); if (i &gt;= k-1) result.push_back(w.top().first); &#125; return result;&#125; O(N) 123456789101112131415vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; result; if (k == 0) return result; deque&lt;int&gt; w; for (int i = 0, n = (int)nums.size(); i &lt; n; i++) &#123; while (!w.empty() &amp;&amp; w.front() &lt;= i-k) w.pop_front(); while (!w.empty() &amp;&amp; nums[w.back()] &lt;= nums[i]) w.pop_back(); w.push_back(i); if (i &gt;= k-1) result.push_back(nums[w.front()]); &#125; return result;&#125; https://discuss.leetcode.com/topic/31686/a-concise-solution-using-deque A concise solution using deque 1234567891011121314151617vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; if (k &lt;= 0) return &#123;&#125;; vector&lt;int&gt; ans(nums.size() - k + 1); deque&lt;int&gt; dq; for (int i = 0; i &lt; nums.size(); ++i) &#123; // delete those nodes whose value less than the current value while (!dq.empty() &amp;&amp; nums[i] &gt; nums[dq.back()]) dq.pop_back(); dq.push_back(i); // delete the node pass the start of the window if (i - dq.front() + 1 &gt; k) dq.pop_front(); // assign result value if (i &gt;= k - 1) ans[i - k + 1] = nums[dq.front()]; &#125; return ans;&#125; https://discuss.leetcode.com/topic/19059/9-lines-ruby-11-lines-python-o-n 9 lines Ruby, 11 lines Python, O(n) Keep indexes of good candidates in deque d. The indexes in d are from the current window, theyâ€™re increasing, and their corresponding nums are decreasing. Then the first deque element is the index of the largest window value. For each index i: Pop (from the end) indexes of smaller elements (theyâ€™ll be useless). Append the current index. Pop (from the front) the index i - k, if itâ€™s still in the deque (it falls out of the window). If our window has reached size k, append the current window maximum to the output. Ruby Apparently Ruby doesnâ€™t have a deque, so I simulate one with an array, where s tells the start index of the queue in the array. 1234567891011def max_sliding_window(nums, k) d, s = [], 0 out = [] nums.each_index&#123; |i| d.pop while d[s] &amp;&amp; nums[d[-1]] &lt; nums[i] d &lt;&lt; i s += 1 if d[s] == i - k out &lt;&lt; nums[d[s]] if i &gt;= k - 1 &#125; outend Python 123456789101112def maxSlidingWindow(self, nums, k): d = collections.deque() out = [] for i, n in enumerate(nums): while d and nums[d[-1]] &lt; n: d.pop() d += i, if d[0] == i - k: d.popleft() if i &gt;= k - 1: out += nums[d[0]], return out Last three lines could be this, but for relatively large k it would waste space: 12out += nums[d[0]], return out[k-1:] 27ms, 31.12%, October 14, 2016 https://discuss.leetcode.com/topic/19055/java-o-n-solution-using-deque-with-explanation 123456789101112131415161718192021public class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; if(nums==null || k&lt;=0) return new int[0]; int n = nums.length; int[] r = new int[n-k+1]; int ri = 0; Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for(int i=0; i&lt;nums.length; i++)&#123; while(!q.isEmpty() &amp;&amp; q.peek() &lt; i-k+1) q.poll(); while(!q.isEmpty()&amp;&amp;nums[q.peekLast()]&lt;nums[i]) q.pollLast(); q.offer(i); if(i&gt;=k-1) r[ri++] = nums[q.peek()]; &#125; return r; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[238. Product of Array Except Self]]></title>
    <url>%2Fp%2F8baaef8d%2F</url>
    <content type="text"><![CDATA[48.0% https://leetcode.com/problems/product-of-array-except-self/#/description Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). 1For example, given [1,2,3,4], return [24,12,8,6]. Follow up: Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.) å‰‘æŒ‡offer 52 https://discuss.leetcode.com/topic/20434/o-n-time-and-o-1-space-c-solution-with-explanation O(n) time and O(1) space C++ solution with explanation æ–¹æ³•ä¸€ï¼š First, consider O(n) time and O(n) space solution. 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(); vector&lt;int&gt; fromBegin(n); fromBegin[0]=1; vector&lt;int&gt; fromLast(n); fromLast[0]=1; for(int i=1;i&lt;n;i++)&#123; fromBegin[i]=fromBegin[i-1]*nums[i-1]; fromLast[i]=fromLast[i-1]*nums[n-i]; &#125; vector&lt;int&gt; res(n); for(int i=0;i&lt;n;i++)&#123; res[i]=fromBegin[i]*fromLast[n-1-i]; &#125; return res; &#125;&#125;; æ–¹æ³•äºŒï¼š ç©ºé—´ä»Žoï¼ˆnï¼‰é™ä½Žåˆ°oï¼ˆ1ï¼‰ å¯¹ä»Žå‰è‡³åŽçš„éƒ¨åˆ†è€ƒè™‘ä¿ç•™å‰ä¸€ä¸ªå€¼ï¼Œå¾—åˆ°ç»“æžœã€‚ å¾ˆå·§å¦™åœ°æ–¹æ³•ï¼ŒèŠ‚çœäº†ç©ºé—´ã€‚ We just need to change the two vectors to two integers and note that we should do multiplying operations for two related elements of the results vector in each loop. 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(); int fromBegin=1; int fromLast=1; vector&lt;int&gt; res(n,1); for(int i=0;i&lt;n;i++)&#123; res[i]*=fromBegin; fromBegin*=nums[i]; res[n-1-i]*=fromLast; fromLast*=nums[n-1-i]; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/37927/how-from-o-n-to-o-1 How from O(N) to O(1) Here is the O(N) based C++ implementation 12345678910111213class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int len=nums.size(); vector&lt;int&gt; left(len, 1); vector&lt;int&gt; right(len, 1); vector&lt;int&gt; result(len, 0); for(int i=1; i&lt;len; i++) left[i]=left[i-1]*nums[i-1]; for(int i=len-2; i&gt;=0; i--) right[i]=right[i+1]*nums[i+1]; for(int i=0; i&lt;len; i++) result[i]=left[i]*right[i]; return result; &#125;&#125;; How to use O(1) ? By observing the above code, we can just for every position multiply it to its right position. Just the idea to think reversly ! 123456789101112131415class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(); int left=1, right=1; vector&lt;int&gt; result(n, 1); for(int i=0; i&lt;n; i++)&#123; result[i]*=left; result[n-1-i]*=right; left*=nums[i]; right*=nums[n-1-i]; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/18877/my-c-solution-o-n-time-with-no-extra-space My C++ solution, O(n) time with no extra space 1234567891011121314151617vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int N = nums.size(); vector&lt;int&gt; res(N,1); for(int i=0; i&lt;N; i++)&#123; if (i==0) res[i] = 1; else res[i] = res[i-1]*nums[i-1]; &#125; int r_prod = 1; for(int i=N-1; i&gt;=0; i--)&#123; res[i] *= r_prod; r_prod *= nums[i]; &#125; return res;&#125; https://discuss.leetcode.com/topic/18983/python-solution-accepted-o-n-time-o-1-space Python solution (Accepted), O(n) time, O(1) space 123456789101112131415class Solution: # @param &#123;integer[]&#125; nums # @return &#123;integer[]&#125; def productExceptSelf(self, nums): p = 1 n = len(nums) output = [] for i in range(0,n): output.append(p) p = p * nums[i] p = 1 for i in range(n-1,-1,-1): output[i] = output[i] * p p = p * nums[i] return output https://discuss.leetcode.com/topic/30115/very-easy-two-passes-solution Very easy two passes solution 1234567891011121314151617// two passes, O(2n)vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; ans(n, 1); for (int i = 1; i &lt; n; ++i) &#123; ans[i] = ans[i-1] * nums[i-1]; &#125; int m = 1; for (int i = n-1; i &gt;= 0; --i) &#123; ans[i] *= m; m *= nums[i]; &#125; return ans;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[237. Delete Node in a Linked List]]></title>
    <url>%2Fp%2Ffec895cd%2F</url>
    <content type="text"><![CDATA[45.8% Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function. Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4after calling your function. æ–¹æ³•ä¸€ï¼š We canâ€™t really delete the node, but we can kinda achieve the same effect by instead removing the next node after copying its data into the node that we were asked to delete. 1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void deleteNode(ListNode* node) &#123; *node = *node-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/18752/1-3-lines-c-java-python-c-c-javascript-ruby é“¾è¡¨åŸºæœ¬æ“ä½œï¼Œè®°å¾…åˆ é™¤èŠ‚ç‚¹ä¸ºnodeä»¤node.val = node.next.valï¼Œnode.next = node.next.nextå³å¯pythonï¼š 1234567891011121314# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = None class Solution(object): def deleteNode(self, node): &quot;&quot;&quot; :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. &quot;&quot;&quot; node.val = node.next.val node.next = node.next.next cpp: 1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void deleteNode(ListNode* node) &#123; *node = *node-&gt;next; &#125;&#125;; javaï¼š 1234567891011121314/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[236. Lowest Common Ancestor of a Binary Tree]]></title>
    <url>%2Fp%2Fda126211%2F</url>
    <content type="text"><![CDATA[29.6% https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/#/description Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: â€œThe lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).â€ 12345678tmp _______3______ / \ ___5__ ___1__ / \ / \ 6 _2 0 8 / \ 7 4 For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. è¿™é“é¢˜ï¼Œè¿˜æœ‰å…¶ä»–è§£æ³•ï¼Œå¯ä»¥æ€è€ƒæ–¹æ³•äºŒä¸­çš„ä»£ç  é‡ç‚¹é¢˜ç›® è§£æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š Dec 10th, 2017 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root==nullptr || root==p || root==q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if(left &amp;&amp; right) return root; return left!=nullptr?left:right; &#125;&#125;; 123456789101112class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root == NULL || root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if (left &amp;&amp; right) return root; return left? left:right; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root==NULL || root==p || root==q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if(left &amp;&amp; right) return root; return left?left:right; &#125;&#125;; æ–¹æ³•äºŒ: http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/ https://discuss.leetcode.com/topic/18561/4-lines-c-java-python-ruby 4 lines C++/Java/Python/Ruby Same solution in several languages. Itâ€™s recursive and expands the meaning of the function. If the current (sub)tree contains both p and q, then the function result is their LCA. If only one of them is in that subtree, then the result is that one of them. If neither are in that subtree, the result is null/None/nil. Update: I also wrote two iterative solutions now, one of them being a version of the solution here. Theyâ€™re more complicated than this simple recursive solution, but I do find them interesting. C++ 123456TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (!root || root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); return !left ? right : !right ? left : root;&#125; Python 12345def lowestCommonAncestor(self, root, p, q): if root in (None, p, q): return root left, right = (self.lowestCommonAncestor(kid, p, q) for kid in (root.left, root.right)) return root if left and right else left or right Or using that None is considered smaller than any node: 12345def lowestCommonAncestor(self, root, p, q): if root in (None, p, q): return root subs = [self.lowestCommonAncestor(kid, p, q) for kid in (root.left, root.right)] return root if all(subs) else max(subs) Ruby 123456def lowest_common_ancestor(root, p, q) return root if [nil, p, q].index root left = lowest_common_ancestor(root.left, p, q) right = lowest_common_ancestor(root.right, p, q) left &amp;&amp; right ? root : left || rightend Java 123456public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); return left == null ? right : right == null ? left : root;&#125; https://discuss.leetcode.com/topic/27479/java-python-iterative-solution Java/Python iterative solution Python 1234567891011121314151617181920212223def lowestCommonAncestor(self, root, p, q): stack = [root] parent = &#123;root: None&#125; while p not in parent or q not in parent: node = stack.pop() if node.left: parent[node.left] = node stack.append(node.left) if node.right: parent[node.right] = node stack.append(node.right) ancestors = set() while p: ancestors.add(p) p = parent[p] while q not in ancestors: q = parent[q] return q# 31 / 31 test cases passed.# Status: Accepted# Runtime: 108 ms# 99.14% Java 12345678910111213141516171819202122232425262728public class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; Map&lt;TreeNode, TreeNode&gt; parent = new HashMap&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); parent.put(root, null); stack.push(root); while (!parent.containsKey(p) || !parent.containsKey(q)) &#123; TreeNode node = stack.pop(); if (node.left != null) &#123; parent.put(node.left, node); stack.push(node.left); &#125; if (node.right != null) &#123; parent.put(node.right, node); stack.push(node.right); &#125; &#125; Set&lt;TreeNode&gt; ancestors = new HashSet&lt;&gt;(); while (p != null) &#123; ancestors.add(p); p = parent.get(p); &#125; while (!ancestors.contains(q)) q = parent.get(q); return q; &#125;&#125; To find the lowest common ancestor, we need to find where is p and q and a way to track their ancestors. A parent pointer for each node found is good for the job. After we found both p and q, we create a set of pâ€™s ancestors. Then we travel through qâ€™s ancestors, the first one appears in pâ€™s is our answer. https://discuss.leetcode.com/topic/18652/iterative-solutions-in-python-c Iterative Solutions in Python/C++ Solution 1 Same algorithm as my recursive solution (look there if you want some explanation), but iterative. I do a post-order traversal with a stack. Each stack element at first is a [node, parent] pair, where parent is the stack element of the nodeâ€™s parent node. When the children of a parent get finished, their results are appended to their parentâ€™s stack element. So when a parent gets finished, we have the results of its children/subtrees available (its stack element at that point is [node, parent, resultForLeftSubtree, resultForRightSubtree]). 12345678910111213def lowestCommonAncestor(self, root, p, q): answer = [] stack = [[root, answer]] while stack: top = stack.pop() (node, parent), subs = top[:2], top[2:] if node in (None, p, q): parent += node, elif not subs: stack += top, [node.right, top], [node.left, top] else: parent += node if all(subs) else max(subs), return answer[0] Solution 2 Here I find the paths to p and q and then find the last node where the paths match. I just came up with the path-building technique for this, and I find it quite neat and maybe it could be useful elsewhere. 1234567891011121314def lowestCommonAncestor(self, root, p, q): def path(root, goal): path, stack = [], [root] while True: node = stack.pop() if node: if node not in path[-1:]: path += node, if node == goal: return path stack += node, node.right, node.left else: path.pop() return next(a for a, b in zip(path(root, p), path(root, q))[::-1] if a == b) C++ version of Solution 1 I donâ€™t use C++ much, so maybe thereâ€™s room for improvement with stuff that I donâ€™t know. 1234567891011121314151617181920212223242526272829class Solution &#123; struct Frame &#123; TreeNode* node; Frame* parent; vector&lt;TreeNode*&gt; subs; &#125;;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; Frame answer; stack&lt;Frame&gt; stack; stack.push(&#123;root, &amp;answer&#125;); while (stack.size()) &#123; Frame *top = &amp;stack.top(), *parent = top-&gt;parent; TreeNode *node = top-&gt;node; if (!node || node == p || node == q) &#123; parent-&gt;subs.push_back(node); stack.pop(); &#125; else if (top-&gt;subs.empty()) &#123; stack.push(&#123;node-&gt;right, top&#125;); stack.push(&#123;node-&gt;left, top&#125;); &#125; else &#123; TreeNode *left = top-&gt;subs[0], *right = top-&gt;subs[1]; parent-&gt;subs.push_back(!left ? right : !right ? left : node); stack.pop(); &#125; &#125; return answer.subs[0]; &#125;&#125;; https://discuss.leetcode.com/topic/20063/accepted-24ms-dfs-c-solution-only-3-lines Accepted 24ms DFS c++ solution, only 3 lines. 12345678class Solution &#123;public: TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) &#123; if (root == p || root == q || root == NULL) return root; TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q), *right = lowestCommonAncestor(root-&gt;right, p, q); return left &amp;&amp; right ? root : left ? left : right; &#125;&#125;; https://discuss.leetcode.com/topic/18786/very-simple-dfs-c-solution-only-10-lines Very simple dfs c++ solution , only 10 lines 123456789101112131415TreeNode * dfsTraverse(TreeNode * root, TreeNode * p , TreeNode * q)&#123; if( root == p || root == q || root == NULL) return root; TreeNode * parent1 = dfsTraverse(root-&gt;left, p, q); TreeNode * parent2 = dfsTraverse(root-&gt;right, p, q); if( parent1 &amp;&amp; parent2) return root; else return parent1 ? parent1:parent2;&#125;TreeNode * lowestCommonAncestor(TreeNode * root, TreeNode * p, TreeNode * q)&#123; return dfsTraverse(root, p, q);&#125; https://discuss.leetcode.com/topic/26396/short-and-clean-c-solution Short and clean C++ solution Want to share my solution. 12345678910111213141516171819TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (!root || !p || !q) &#123; return NULL; &#125; if (root == p || root == q) &#123; return root; &#125; TreeNode* l = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* r = lowestCommonAncestor(root-&gt;right, p, q); if (l &amp;&amp; r) &#123; return root; &#125; return l? l : r;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[235. Lowest Common Ancestor of a Binary Search Tree]]></title>
    <url>%2Fp%2F6e0230a7%2F</url>
    <content type="text"><![CDATA[38.4% https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/#/description Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: â€œThe lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).â€ 12345678tmp _______6______ / \ ___2__ ___8__ / \ / \ 0 _4 7 9 / \ 3 5 For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. https://discuss.leetcode.com/topic/18614/easy-c-recursive-and-iterative-solutions Easy C++ Recursive and Iterative Solutions æ–¹æ³•ä¸€ï¼š Well, remember to take advantage of the property of binary search trees, which is, node -&gt; left -&gt; val &lt; node -&gt; val &lt; node -&gt; right -&gt; val. Moreover, both p and q will be the descendants of the root of the subtree that contains both of them. And the root with the largest depth is just the lowest common ancestor. This idea can be turned into the following simple recursive code. 12345678910class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (p -&gt; val &lt; root -&gt; val &amp;&amp; q -&gt; val &lt; root -&gt; val) return lowestCommonAncestor(root -&gt; left, p, q); if (p -&gt; val &gt; root -&gt; val &amp;&amp; q -&gt; val &gt; root -&gt; val) return lowestCommonAncestor(root -&gt; right, p, q); return root; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) return lowestCommonAncestor(root-&gt;left, p, q); if(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) return lowestCommonAncestor(root-&gt;right, p, q); return root; &#125;&#125;; æ–¹æ³•äºŒï¼š Of course, we can also solve it iteratively. 12345678910111213class Solution &#123; public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; TreeNode* cur = root; while (true) &#123; if (p -&gt; val &lt; cur -&gt; val &amp;&amp; q -&gt; val &lt; cur -&gt; val) cur = cur -&gt; left; else if (p -&gt; val &gt; cur -&gt; val &amp;&amp; q -&gt; val &gt; cur -&gt; val) cur = cur -&gt; right; else return cur; &#125; &#125;&#125;; æ–¹æ³•ä¸‰ï¼š ä½¿ç”¨236çš„æ–¹æ³• 1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root==NULL || root==p || root==q) return root; TreeNode* l = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* r = lowestCommonAncestor(root-&gt;right, p, q); if(l &amp;&amp; r) return root; return l?l:r; &#125;&#125;; 3 lines with O(1) space, 1-Liners, Alternatives Just walk down from the whole treeâ€™s root as long as both p and q are in the same subtree (meaning their values are both smaller or both larger than rootâ€™s). This walks straight from the root to the LCA, not looking at the rest of the tree, so itâ€™s pretty much as fast as it gets. A few ways to do it: Iterative, O(1) space Python 1234def lowestCommonAncestor(self, root, p, q): while (root.val - p.val) * (root.val - q.val) &gt; 0: root = (root.left, root.right)[p.val &gt; root.val] return root Java 12345public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; while ((root.val - p.val) * (root.val - q.val) &gt; 0) root = p.val &lt; root.val ? root.left : root.right; return root;&#125; (in case of overflow, Iâ€™d do (root.val - (long)p.val) * (root.val - (long)q.val)) Different Python 12345def lowestCommonAncestor(self, root, p, q): a, b = sorted([p.val, q.val]) while not a &lt;= root.val &lt;= b: root = (root.left, root.right)[a &gt; root.val] return root â€œLongâ€ Python, maybe easiest to understand 12345678def lowestCommonAncestor(self, root, p, q): while root: if p.val &lt; root.val &gt; q.val: root = root.left elif p.val &gt; root.val &lt; q.val: root = root.right else: return root Recursive Python 1234def lowestCommonAncestor(self, root, p, q): next = p.val &lt; root.val &gt; q.val and root.left or \ p.val &gt; root.val &lt; q.val and root.right return self.lowestCommonAncestor(next, p, q) if next else root Python One-Liner 123def lowestCommonAncestor(self, root, p, q): return root if (root.val - p.val) * (root.val - q.val) &lt; 1 else \ self.lowestCommonAncestor((root.left, root.right)[p.val &gt; root.val], p, q) Java One-Liner 1234public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; return (root.val - p.val) * (root.val - q.val) &lt; 1 ? root : lowestCommonAncestor(p.val &lt; root.val ? root.left : root.right, p, q);&#125; â€œLongâ€ Python, maybe easiest to understand 123456def lowestCommonAncestor(self, root, p, q): if p.val &lt; root.val &gt; q.val: return self.lowestCommonAncestor(root.left, p, q) if p.val &gt; root.val &lt; q.val: return self.lowestCommonAncestor(root.right, p, q) return root https://discuss.leetcode.com/topic/22095/c-solution-40ms C++ solution . 40ms 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(!root)&#123; return NULL; &#125; // check if the current value is larger than both nodes , go left if(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)&#123; lowestCommonAncestor(root-&gt;left , p , q); // go right &#125;else if(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)&#123; lowestCommonAncestor(root-&gt;right , p , q); &#125;// my LCA else&#123; return root; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/18438/python-iterative-solution Python Iterative Solution 12345678910class Solution:def lowestCommonAncestor(self, root, p, q): while root: if root.val &gt; p.val and root.val &gt; q.val: root = root.left elif root.val &lt; p.val and root.val &lt; q.val: root = root.right else: return root https://discuss.leetcode.com/topic/19536/my-python-recursive-solution My Python recursive solution 1234567891011121314class Solution: # @param &#123;TreeNode&#125; root # @param &#123;TreeNode&#125; p # @param &#123;TreeNode&#125; q # @return &#123;TreeNode&#125; def lowestCommonAncestor(self, root, p, q): if not root or not p or not q: return None if (max(p.val, q.val) &lt; root.val): return self.lowestCommonAncestor(root.left, p, q) elif (min(p.val, q.val) &gt; root.val): return self.lowestCommonAncestor(root.right, p, q) else: return root]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[234. Palindrome Linked List]]></title>
    <url>%2Fp%2F8fba543e%2F</url>
    <content type="text"><![CDATA[32.0% https://leetcode.com/problems/palindrome-linked-list/#/description Given a singly linked list, determine if it is a palindrome. Follow up: Could you do it in O(n) time and O(1) space? æ–¹æ³•ä¸€ï¼š å°†åŽåŠéƒ¨åˆ†è¿›è¡Œåè½¬é“¾è¡¨ï¼Œåˆ™ä¸Žå‰åŠéƒ¨åˆ†åº”è¯¥æ˜¯ç›¸åŒçš„ã€‚ æ‰€ä»¥ç¬¬ä¸€æ­¥æ‰¾åˆ°ä¸­é—´ç‚¹ï¼Œç¬¬äºŒæ­¥åè½¬ï¼Œç¬¬ä¸‰æ­¥è¿›è¡Œæ¯”è¾ƒã€‚ https://discuss.leetcode.com/topic/18304/share-my-c-solution-o-n-time-and-o-1-memory Share my C++ solution, O(n) time and O(1) memory 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; if(head==NULL||head-&gt;next==NULL) return true; ListNode* slow=head; ListNode* fast=head; while(fast-&gt;next!=NULL&amp;&amp;fast-&gt;next-&gt;next!=NULL)&#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; &#125; slow-&gt;next=reverseList(slow-&gt;next); slow=slow-&gt;next; while(slow!=NULL)&#123; if(head-&gt;val!=slow-&gt;val) return false; head=head-&gt;next; slow=slow-&gt;next; &#125; return true; &#125; ListNode* reverseList(ListNode* head) &#123; ListNode* pre=NULL; ListNode* next=NULL; while(head!=NULL)&#123; next=head-&gt;next; head-&gt;next=pre; pre=head; head=next; &#125; return pre; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ° 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; if(!head || !head-&gt;next) return true; ListNode* fast = head, *slow = head; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; ListNode* cur = slow-&gt;next; slow-&gt;next = NULL; while(cur)&#123; ListNode* nex = cur-&gt;next; cur-&gt;next = slow-&gt;next; slow-&gt;next = cur; cur = nex; &#125; fast = head; slow = slow-&gt;next; while(slow)&#123; if(fast-&gt;val != slow-&gt;val) return false; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return true; &#125;&#125;; https://discuss.leetcode.com/topic/27605/my-easy-understand-c-solution My easy understand C++ solution 123456789101112131415class Solution &#123;public: ListNode* temp; bool isPalindrome(ListNode* head) &#123; temp = head; return check(head); &#125; bool check(ListNode* p) &#123; if (NULL == p) return true; bool isPal = check(p-&gt;next) &amp; (temp-&gt;val == p-&gt;val); temp = temp-&gt;next; return isPal; &#125;&#125;; https://discuss.leetcode.com/topic/18533/reversing-a-list-is-not-considered-o-1-space Reversing a list is not considered â€œO(1) spaceâ€ It is a common misunderstanding that the space complexity of a program is just how much the size of additional memory space being used besides input. An important prerequisite is neglected the above definition: the input has to be read-only. By definition, changing the input and change it back is not allowed (or the input size should be counted when doing so). Another way of determining the space complexity of a program is to simply look at how much space it has written to. Reversing a singly linked list requires writing to O(n) memory space, thus the space complexities for all â€œreverse-the-listâ€-based approaches are O(n), not O(1). Solving this problem in O(1) space is theoretically impossible due to two simple facts: (1) a program using O(1) space is computationally equivalent to a finite automata, or a regular expression checker; (2) the pumping lemma states that the set of palindrome strings does not form a regular set. Please change the incorrect problem statement. https://discuss.leetcode.com/topic/18293/11-lines-12-with-restore-o-n-time-o-1-space/2 11 lines, 12 with restore, O(n) time, O(1) space O(n) time, O(1) space. The second solution restores the list after changing it. Solution 1: Reversed first half == Second half? Phase 1: Reverse the first half while finding the middle. Phase 2: Compare the reversed first half with the second half. 123456789101112def isPalindrome(self, head): rev = None slow = fast = head while fast and fast.next: fast = fast.next.next rev, rev.next, slow = slow, rev, slow.next if fast: slow = slow.next while rev and rev.val == slow.val: slow = slow.next rev = rev.next return not rev Solution 2: Play Nice Same as the above, but while comparing the two halves, restore the list to its original state by reversing the first half back. Not that the OJ or anyone else cares. 12345678910111213def isPalindrome(self, head): rev = None fast = head while fast and fast.next: fast = fast.next.next rev, rev.next, head = head, rev, head.next tail = head.next if fast else head isPali = True while rev: isPali = isPali and rev.val == tail.val head, head.next, rev = rev, head, rev.next tail = tail.next return isPali https://discuss.leetcode.com/topic/18952/python-easy-to-understand-solution-with-comments-operate-nodes-directly Python easy to understand solution with comments (operate nodes directly). 1234567891011121314151617181920def isPalindrome(self, head): fast = slow = head # find the mid node while fast and fast.next: fast = fast.next.next slow = slow.next # reverse the second half node = None while slow: nxt = slow.next slow.next = node node = slow slow = nxt # compare the first and second half nodes while node: # while node and head: if node.val != head.val: return False node = node.next head = head.next return True https://discuss.leetcode.com/topic/18301/5-lines-python-o-n-time-and-space 5 lines Python, O(n) time and space I just realized that the O(1) space is only a follow-up, so hereâ€™s the obvious one without that. 123456def isPalindrome(self, head): vals = [] while head: vals += head.val, head = head.next return vals == vals[::-1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>linked list</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[233. Number of Digit One]]></title>
    <url>%2Fp%2Fbb8f353e%2F</url>
    <content type="text"><![CDATA[28.5% https://leetcode.com/problems/number-of-digit-one/#/description Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. 123For example:Given n = 13,Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13. Hint: Beware of overflow. å‰‘æŒ‡offer 52 æ–¹æ³•ä¸€ï¼š https://discuss.leetcode.com/topic/41642/easy-to-understand-c-0ms-solution-with-detailed-explanation Easy to understand C++ 0ms solution with detailed explanation We start from basics: 12345f(9) = 1;f(99) = f(9) * 10 + 10(contributed by the most significant digit in range [10, 19]) = 20 f(999) = f(99) * 10 + 100(contributed by the most significant digit in range [100, 199]) = 300f(9999) = f(999) * 10 + 1000(contributed by the most significant digit in range [1000, 1999]) = 10 * 300 + 1000 = 4000... ... How about 23? 123 = [0, 9] + [10, 19] + [20, 23] [10, 19] can be reduced to solve f(9) + 10, because its most significant digit is 1. And [20, 23] can be reduced to solve f(3) + 0, because the most significant digit is 2, so this digit doesnâ€™t contribute to final result.So now we know 1f(23) = f(9) * 2 + 10 + f(3) So now when we look at a number n (e.g. 2356), we look at the most significant digit(2), its divisor with highest 10â€™s power (1000), and its remainder (356), try to reduce to a smaller number iteratively. (1) Since most significant digit is 2, so we know range [0, 999], [1000, 1999] are included, so we add 2 * f(999). (2) Also, since we have [1000, 1999] covered, we should add extra 1000. (3) Then we look at range [2000, 2356], try to reduce it to [0, 356] by dropping most significant digit 2, it doesnâ€™t impact the final result since most significant digit is 2 not 1. (4) Finally, we add f(356) So eventually, we have 1234f(2356) += (2356 / 1000) * f(1000 - 1) = 2 * f(999);f(2356) += (2356 / 1000 &gt; 1 ? 1000 : 0); f(2356) += (2356 / 1000 == 1 ? 356 + 1 : 0);f(2356) += f(356); Below is the code: 1234567891011121314151617181920212223242526class Solution &#123;public: int countDigitOne(int n) &#123; int ans = 0; if(n &lt;= 0) return 0; if(n &lt;= 9) return 1; unordered_map&lt;int, int&gt; mp; mp[9] = 1; for(int i = 9; i &lt;= (INT_MAX - 9) / 10; i = i * 10 + 9)&#123; mp[i*10 + 9] = mp[i] * 10 + (i + 1); // mp[99], mp[999], mp[9999], ... ... &#125; int nn = n, divisor = 1; while(nn / 10)&#123; nn /= 10; divisor *= 10; &#125; ans += (n / divisor) * mp[divisor - 1]; ans += (n / divisor &gt; 1) ? divisor : 0; ans += (n / divisor == 1) ? n % divisor + 1 : 0; ans += countDigitOne(n % divisor); return ans; &#125;&#125;; https://discuss.leetcode.com/topic/18054/4-lines-o-log-n-c-java-python 4+ lines, O(log n), C++/Java/Python Go through the digit positions one at a time, find out how often a â€œ1â€ appears at each position, and sum those up. C++ solution 123456int countDigitOne(int n) &#123; int ones = 0; for (long long m = 1; m &lt;= n; m *= 10) ones += (n/m + 8) / 10 * m + (n/m % 10 == 1) * (n%m + 1); return ones;&#125; Explanation Let me use variables a and b to make the explanation a bit nicer. 12345678int countDigitOne(int n) &#123; int ones = 0; for (long long m = 1; m &lt;= n; m *= 10) &#123; int a = n/m, b = n%m; ones += (a + 8) / 10 * m + (a % 10 == 1) * (b + 1); &#125; return ones;&#125; Go through the digit positions by using position multiplier m with values 1, 10, 100, 1000, etc. For each position, split the decimal representation into two parts, for example split n=3141592 into a=31415 and b=92 when weâ€™re at m=100 for analyzing the hundreds-digit. And then we know that the hundreds-digit of n is 1 for prefixes â€œâ€ to â€œ3141â€, i.e., 3142 times. Each of those times is a streak, though. Because itâ€™s the hundreds-digit, each streak is 100 long. So (a / 10 + 1) * 100 times, the hundreds-digit is 1. Consider the thousands-digit, i.e., when m=1000. Then a=3141 and b=592. The thousands-digit is 1 for prefixes â€œâ€ to â€œ314â€, so 315 times. And each time is a streak of 1000 numbers. However, since the thousands-digit is a 1, the very last streak isnâ€™t 1000 numbers but only 593 numbers, for the suffixes â€œ000â€ to â€œ592â€. So (a / 10 * 1000) + (b + 1) times, the thousands-digit is 1. The case distincton between the current digit/position being 0, 1 and &gt;=2 can easily be done in one expression. With (a + 8) / 10 you get the number of full streaks, and a % 10 == 1 tells you whether to add a partial streak. Java version 123456public int countDigitOne(int n) &#123; int ones = 0; for (long m = 1; m &lt;= n; m *= 10) ones += (n/m + 8) / 10 * m + (n/m % 10 == 1 ? n%m + 1 : 0); return ones;&#125; Python version 123456def countDigitOne(self, n): ones, m = 0, 1 while m &lt;= n: ones += (n/m + 8) / 10 * m + (n/m % 10 == 1) * (n%m + 1) m *= 10 return ones Using sum or recursion it can also be a one-liner. Old solution Go through the digit positions from back to front. I found it ugly to explain, so I made up that above new solution instead. The n here is the new solutionâ€™s a, and the r here is the new solutionâ€™s b+1. Python 123456789def countDigitOne(self, n): ones = 0 m = r = 1 while n &gt; 0: ones += (n + 8) / 10 * m + (n % 10 == 1) * r r += n % 10 * m m *= 10 n /= 10 return ones Java 12345678910public int countDigitOne(int n) &#123; int ones = 0, m = 1, r = 1; while (n &gt; 0) &#123; ones += (n + 8) / 10 * m + (n % 10 == 1 ? r : 0); r += n % 10 * m; m *= 10; n /= 10; &#125; return ones;&#125; C++ 12345678910int countDigitOne(int n) &#123; int ones = 0, m = 1, r = 1; while (n &gt; 0) &#123; ones += (n + 8) / 10 * m + (n % 10 == 1) * r; r += n % 10 * m; m *= 10; n /= 10; &#125; return ones;&#125; https://discuss.leetcode.com/topic/27565/java-python-one-pass-solution-easy-to-understand Java/Python one pass solution easy to understand The idea is to calculate occurrence of 1 on every digit. There are 3 scenarios, for example 1if n = xyzdabc and we are considering the occurrence of one on thousand, it should be: 123(1) xyz * 1000 if d == 0(2) xyz * 1000 + abc + 1 if d == 1(3) xyz * 1000 + 1000 if d &gt; 1 iterate through all digits and sum them all will give the final answer Java 12345678910111213141516171819public int countDigitOne(int n) &#123; if (n &lt;= 0) return 0; int q = n, x = 1, ans = 0; do &#123; int digit = q % 10; q /= 10; ans += q * x; if (digit == 1) ans += n % x + 1; if (digit &gt; 1) ans += x; x *= 10; &#125; while (q &gt; 0); return ans;&#125;// 40 / 40 test cases passed.// Status: Accepted// Runtime: 0 ms Python 12345678910111213141516171819def countDigitOne(self, n): if n &lt;= 0: return 0 q, x, ans = n, 1, 0 while q &gt; 0: digit = q % 10 q /= 10 ans += q * x if digit == 1: ans += n % x + 1 elif digit &gt; 1: ans += x x *= 10 return ans# 40 / 40 test cases passed.# Status: Accepted# Runtime: 32 ms# 97.59% https://discuss.leetcode.com/topic/18068/0ms-o-lgn-accepted-c-solution-using-counting-principle-with-explanation 0ms o(lgn) accepted c++ solution using counting principle with explanation For every digit in n (Suppose n = 240315, the digits are 2, 4, 0, 3, 1, 5)ï¼ŒI respectively count the number of digit 1 assuming the position of current digit is 1 and other digits of n is arbitrary. For example, I select 3 in n as the current digit, and I suppose the position of 3 is 1. The highn is the number composed with the digits before the current digit. In the example, highn = 240; The lown is the number composed with the digits after the current digit. In the example, lown = 15. The lowc = 10 ^ (the number of lower digits). In the example, lowc = 100; As curn = 3 and curn &gt; 1, (highn 10 + 1) must be less than (highn 10 + curn). Then the higher part can be 0 ~ highn, the lower part can be 0 ~ (lowc-1), and the current result = (highn + 1) * lowc. 12345678910111213141516171819202122232425int countDigitOne(int n) &#123; long long int res(0); int highn(n), lowc(1), lown(0); while(highn &gt; 0)&#123; int curn = highn % 10; highn = highn / 10; if(1 == curn)&#123; //higher: 0~(highn-1); lower: 0 ~ (lowc-1) res += highn * lowc; //higher: highn ~ highn; lower:0~lown res += lown + 1; &#125;else if(0 == curn)&#123; //curn &lt; 1 //higher: 0~(highn-1); lower: 0 ~ (lowc-1) res += highn * lowc; &#125;else&#123; //curn &gt; 1 res += (highn + 1) * lowc; &#125; //update lown and lowc lown = curn * lowc + lown; lowc = lowc * 10; &#125; return res; &#125; https://discuss.leetcode.com/topic/22441/0-ms-recursive-solution 0 ms recursive solution 1234567891011121314int countDigitOne(int n) &#123; if(n&lt;1) return 0; if(n&gt;=1 &amp;&amp; n&lt;10) return 1; // x: first digit int y=1, x=n; while(!(x&lt;10))&#123; x/=10; y*=10; &#125; if(x==1) return n-y+1+countDigitOne(y-1)+countDigitOne(n%y); else return y+x*countDigitOne(y-1)+countDigitOne(n%y);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[232. Implement Queue using Stacks]]></title>
    <url>%2Fp%2F567717e2%2F</url>
    <content type="text"><![CDATA[35.6% https://leetcode.com/problems/implement-queue-using-stacks/#/description Implement the following operations of a queue using stacks. push(x) â€“ Push element x to the back of queue. pop() â€“ Removes the element from in front of queue. peek() â€“ Get the front element. empty() â€“ Return whether the queue is empty. Notes: You must use only standard operations of a stack â€“ which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). æ–¹æ³•ä¸€ï¼šä½¿ç”¨ä¸¤ä¸ªæ ˆï¼Œæ¨¡æ‹Ÿé˜Ÿåˆ—ï¼Œstack1å­˜å‚¨æ–°æ¥çš„æ•°æ®ï¼Œå½“ä½¿ç”¨peekæ—¶ï¼Œå°†stack1çš„æ•°æ®éƒ½åŽ‹å…¥stack2ï¼Œå†æ±‚stack2çš„topå°±æ˜¯peekæ•°æ®ï¼Œå½“éœ€è¦popæ—¶ï¼Œåªè¦å…ˆpeekï¼Œç„¶åŽå†pop stack2å°±å¯ä»¥äº†ï¼Œemptyåˆ™æœ€ç®€å•ã€‚ æ³¨æ„çš„åœ°æ–¹ï¼Œåœ¨pop()è°ƒç”¨peek()ï¼Œç›´æŽ¥å†™ peek()å°±å¯ä»¥äº†ã€‚ popè°ƒç”¨peekå¾—åˆ°è¿”å›žçš„å€¼ï¼Œç„¶åŽéœ€è¦stack2å†popä¸€ä¸‹ï¼Œä¸è¦å¿˜äº†ã€‚ ç–‘é—®ï¼šå¦‚æžœéƒ½æ˜¯ç©ºçš„ï¼Œè°ƒç”¨popä¼šå‘ç”Ÿä»€ä¹ˆæƒ…å†µï¼Œè¾“å‡ºæ ˆçš„errorè¿˜æ˜¯ä¸ä½œå¤„ç†å‘¢ï¼Ÿæ ˆç›´æŽ¥popï¼Œæ˜¯errorè¿˜æ˜¯ä»€ä¹ˆï¼Ÿ æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 10th, 2017 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MyQueue &#123;public: stack&lt;int&gt; st1, st2; /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; st1.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; int val = peek(); st2.pop(); return val; &#125; /** Get the front element. */ int peek() &#123; if(st2.empty())&#123; while(st1.size())&#123; int val = st1.top(); st2.push(val); st1.pop(); &#125; &#125; int val = st2.top(); return val; &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return st1.empty() &amp;&amp; st2.empty(); &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * bool param_4 = obj.empty(); */ 12345678910111213141516171819202122232425262728293031323334353637383940class MyQueue &#123;stack&lt;int&gt; stack1;stack&lt;int&gt; stack2;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; stack1.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; peek(); int val = stack2.top(); stack2.pop(); return val; &#125; /** Get the front element. */ int peek() &#123; if(stack2.empty())&#123; while(stack1.size()&gt;0)&#123; int val = stack1.top(); stack2.push(val); stack1.pop(); &#125; &#125; return stack2.top(); &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return stack1.empty() &amp;&amp; stack2.empty(); &#125;&#125;; https://discuss.leetcode.com/topic/17974/short-o-1-amortized-c-java-ruby Short O(1) amortized, C++ / Java / Ruby I have one input stack, onto which I push the incoming elements, and one output stack, from which I peek/pop. I move elements from input stack to output stack when needed, i.e., when I need to peek/pop but the output stack is empty. When that happens, I move all elements from input to output stack, thereby reversing the order so itâ€™s the correct order for peek/pop. The loop in peek does the moving from input to output stack. Each element only ever gets moved like that once, though, and only after we already spent time pushing it, so the overall amortized cost for each operation is O(1). Java 12345678910111213141516171819202122232425class MyQueue &#123; Stack&lt;Integer&gt; input = new Stack(); Stack&lt;Integer&gt; output = new Stack(); public void push(int x) &#123; input.push(x); &#125; public void pop() &#123; peek(); output.pop(); &#125; public int peek() &#123; if (output.empty()) while (!input.empty()) output.push(input.pop()); return output.peek(); &#125; public boolean empty() &#123; return input.empty() &amp;&amp; output.empty(); &#125;&#125; C++ 123456789101112131415161718192021222324class Queue &#123; stack&lt;int&gt; input, output;public: void push(int x) &#123; input.push(x); &#125; void pop(void) &#123; peek(); output.pop(); &#125; int peek(void) &#123; if (output.empty()) while (input.size()) output.push(input.top()), input.pop(); return output.top(); &#125; bool empty(void) &#123; return input.empty() &amp;&amp; output.empty(); &#125;&#125;; https://discuss.leetcode.com/topic/19152/0-ms-c-solution-using-one-stack-w-explanation 0 ms C++ solution using one Stack w/ explanation. You can implement queue using just one stack by either making push process costlier or pop costlier. Since we have two functions (top() and pop()) which require the top element of the stack, well make the push() function costlier - that is, for pushing a new element, we recursively pop the stack till it is empty and push it at the bottom of the stack, and take advantage of the recursive call to push back in the popped elements once the recursive call hits the base condition and returns. This implementation makes pop() and peek() functions easier. pop() is just going to pop off the top element in stack and peek() will return the top most element. 12345678910111213141516171819202122232425262728293031323334353637class Queue &#123;public: stack&lt;int&gt; s; // Push element x to the back of queue. void push(int x) &#123; pushHelper(x); &#125; void pushHelper(int x)&#123; if(s.size()==0)&#123; s.push(x); return; &#125; int data; data = s.top(); s.pop(); pushHelper(x); s.push(data); return; &#125; // Removes the element from in front of queue. void pop(void) &#123; s.pop(); &#125; // Get the front element. int peek(void) &#123; return s.top(); &#125; // Return whether the queue is empty. bool empty(void) &#123; return (s.size()==0); &#125;&#125;; https://discuss.leetcode.com/topic/26163/share-my-python-solution-32ms Share my python solution (32ms) The idea is to simulate a queue using two stacks (same as previous posts). I use python list as the underlying data structure for stack and add a â€œmove()â€ method to simplify code: it moves all elements of the â€œinStackâ€ to the â€œoutStackâ€ when the â€œoutStackâ€ is empty. Here is the code 1234567891011121314151617181920212223242526272829303132333435363738394041class Queue(object): def __init__(self): &quot;&quot;&quot; initialize your data structure here. &quot;&quot;&quot; self.inStack, self.outStack = [], [] def push(self, x): &quot;&quot;&quot; :type x: int :rtype: nothing &quot;&quot;&quot; self.inStack.append(x) def pop(self): &quot;&quot;&quot; :rtype: nothing &quot;&quot;&quot; self.move() self.outStack.pop() def peek(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; self.move() return self.outStack[-1] def empty(self): &quot;&quot;&quot; :rtype: bool &quot;&quot;&quot; return (not self.inStack) and (not self.outStack) def move(self): &quot;&quot;&quot; :rtype nothing &quot;&quot;&quot; if not self.outStack: while self.inStack: self.outStack.append(self.inStack.pop()) https://discuss.leetcode.com/topic/17984/accepted-0ms-c-solution-with-two-std-stack-easy-understand Accepted 0ms c++ solution with two std::stack, easy understand. 1234567891011121314151617181920212223242526272829class Queue &#123;public: // Push element x to the back of queue. void push(int x) &#123; while (!nums.empty()) &#123; helper.push(nums.top()); nums.pop(); &#125; nums.push(x); while (!helper.empty()) &#123; nums.push(helper.top()); helper.pop(); &#125; &#125; // Removes the element from in front of queue. void pop(void) &#123; nums.pop(); &#125; // Get the front element. int peek(void) &#123; return nums.top(); &#125; // Return whether the queue is empty. bool empty(void) &#123; return nums.empty(); &#125;private: std::stack&lt;int&gt; helper, nums;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[231. Power of Two]]></title>
    <url>%2Fp%2F79f66f39%2F</url>
    <content type="text"><![CDATA[39.6% https://leetcode.com/problems/power-of-two/#/description Given an integer, write a function to determine if it is a power of two. æ–¹æ³•ä¸€ï¼š https://discuss.leetcode.com/topic/17857/using-n-n-1-trick Using n&amp;(n-1) trick Power of 2 means only one bit of n is â€˜1â€™, so use the trick n&amp;(n-1)==0 to judge whether that is the case 1234567class Solution &#123;public: bool isPowerOfTwo(int n) &#123; if(n&lt;=0) return false; return !(n&amp;(n-1)); &#125;&#125;; æ–¹æ³•äºŒï¼š https://discuss.leetcode.com/topic/19772/one-line-of-c One line of C++ I used n&amp;(n-1), but, attention the 0. 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; !(n&amp;(n-1)); &#125;&#125;; https://discuss.leetcode.com/topic/47195/4-different-ways-to-solve-iterative-recursive-bit-operation-math 4 different ways to solve â€“ Iterative / Recursive / Bit operation / Math This question is not an difficult one, and there are many ways to solve it. Method 1: Iterative check if n can be divided by 2. If yes, divide n by 2 and check it repeatedly. 123if(n==0) return false;while(n%2==0) n/=2;return (n==1); Time complexity = O(log n) Method 2: Recursive 1return n&gt;0 &amp;&amp; (n==1 || (n%2==0 &amp;&amp; isPowerOfTwo(n/2))); Time complexity = O(log n) Method 3: Bit operation If n is the power of two: n = 2 ^ 0 = 1 = 0b0000â€¦00000001, and (n - 1) = 0 = 0b0000â€¦0000. n = 2 ^ 1 = 2 = 0b0000â€¦00000010, and (n - 1) = 1 = 0b0000â€¦0001. n = 2 ^ 2 = 4 = 0b0000â€¦00000100, and (n - 1) = 3 = 0b0000â€¦0011. n = 2 ^ 3 = 8 = 0b0000â€¦00001000, and (n - 1) = 7 = 0b0000â€¦0111. we have n &amp; (n-1) == 0b0000â€¦0000 == 0 Otherwise, n &amp; (n-1) != 0. For example, n =14 = 0b0000â€¦1110, and (n - 1) = 13 = 0b0000â€¦1101. 1return n&gt;0 &amp;&amp; ((n &amp; (n-1)) == 0); Time complexity = O(1) Method 4: Math derivation Because the range of an integer = -2147483648 (-2^31) ~ 2147483647 (2^31-1), the max possible power of two = 2^30 = 1073741824. (1) If n is the power of two, let n = 2^k, where k is an integer. We have 2^30 = (2^k) * 2^(30-k), which means (2^30 % 2^k) == 0. (2) If n is not the power of two, let n = j*(2^k), where k is an integer and j is an odd number. We have (2^30 % j*(2^k)) == (2^(30-k) % j) != 0. 1return n&gt;0 &amp;&amp; (1073741824 % n == 0); Time complexity = O(1) https://discuss.leetcode.com/topic/26374/share-my-one-line-c Share my one line C++ 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return n&gt;0 &amp;&amp; !(n&amp;(n-1)); &#125;&#125;; https://discuss.leetcode.com/topic/27934/python-one-line-solution Python one line solution 1234567class Solution(object): def isPowerOfTwo(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; return n &gt; 0 and not (n &amp; n-1)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>math</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[230. Kth Smallest Element in a BST]]></title>
    <url>%2Fp%2F589d7851%2F</url>
    <content type="text"><![CDATA[42.7% https://leetcode.com/problems/kth-smallest-element-in-a-bst/#/description Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note: You may assume k is always valid, 1 â‰¤ k â‰¤ BSTâ€™s total elements. Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? Hint: Try to utilize the property of a BST. What if you could modify the BST nodeâ€™s structure? The optimal runtime complexity is O(height of BST). ä¸­åºéåŽ†åŽï¼ŒBSTçš„ç»“æžœæ˜¯ä»Žå°è‡³å¤§æŽ’åˆ—çš„ã€‚ æ–¹æ³•ä¸€ï¼šä¸­åºéåŽ†ï¼Œä¿å­˜è‡³æ•°ç»„ï¼Œç„¶åŽå–ç¬¬kä¸ªã€‚ 12345678910111213141516class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; vector&lt;int&gt; res; inorder(root, res); return res[k-1]; &#125; void inorder(TreeNode* root, vector&lt;int&gt;&amp; res)&#123; if(root)&#123; inorder(root-&gt;left, res); res.push_back(root-&gt;val); inorder(root-&gt;right, res); &#125; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; vector&lt;int&gt; res; inorder(root, res); if(k&lt;0 || k&gt;res.size()) return -1; return res[k-1]; &#125; void inorder(TreeNode* root, vector&lt;int&gt;&amp; res)&#123; if(root)&#123; inorder(root-&gt;left, res); res.push_back(root-&gt;val); inorder(root-&gt;right, res); &#125; &#125;&#125;; æ–¹æ³•äºŒï¼š ä¼ å…¥å‚æ•°å¼•ç”¨ï¼Œ ä¸€æ¬¡éåŽ†ã€‚ 123456789int kthSmallest(TreeNode* root, int k) &#123; return find(root, k);&#125;int find(TreeNode* root, int&amp; k) &#123; if (root) &#123; int x = find(root-&gt;left, k); return !k ? x : !--k ? root-&gt;val : find(root-&gt;right, k); &#125;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; return helper(root, k); // helerå‡½æ•°å°±æ˜¯æ‰¾åˆ°ç¬¬kä¸ªå¹¶è¿”å›ž &#125; int helper(TreeNode* root, int&amp; k)&#123; if(root)&#123; int x = helper(root-&gt;left, k); if(k==0) return x; else if(--k==0) return root-&gt;val; else return helper(root-&gt;right, k); &#125; return -1; &#125;&#125;; https://discuss.leetcode.com/topic/17573/4-lines-in-c 4 Lines in C++. Go inorder and decrease k at each node. Stop the whole search as soon as k is zero, and then the k-th element is immediately returned all the way to the recursion top and to the original caller. Try the left subtree first. If that made k zero, then its answer is the overall answer and we return it right away. Otherwise, decrease k for the current node, and if that made k zero, then we return the current nodeâ€™s value right away. Otherwise try the right subtree and return whatever comes back from there. 123456int kthSmallest(TreeNode* root, int&amp; k) &#123; if (root) &#123; int x = kthSmallest(root-&gt;left, k); return !k ? x : !--k ? root-&gt;val : kthSmallest(root-&gt;right, k); &#125;&#125; You might notice that I changed k from int to int&amp; because I didnâ€™t feel like adding a helper just for that and the OJ doesnâ€™t mind. Oh well, here is that now: 123456789int kthSmallest(TreeNode* root, int k) &#123; return find(root, k);&#125;int find(TreeNode* root, int&amp; k) &#123; if (root) &#123; int x = find(root-&gt;left, k); return !k ? x : !--k ? root-&gt;val : find(root-&gt;right, k); &#125;&#125; https://discuss.leetcode.com/topic/18689/share-my-c-iterative-alg Share my C++ iterative ALG. 1234567891011121314151617181920class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; stack&lt;TreeNode *&gt; st; TreeNode *p = root; while(p || !st.empty()) &#123; while(p) &#123; st.push(p); p = p-&gt;left; &#125; p = st.top(); if(--k == 0) return p-&gt;val; st.pop(); p = p-&gt;right; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/17577/c-solution-using-in-order-traversal C++ solution using in order traversal 12345678910111213141516171819class Solution &#123;public: void inorder(TreeNode* root, vector&lt;int&gt; &amp;res)&#123; if(!root) return; inorder(root-&gt;left, res); res.push_back(root-&gt;val); inorder(root-&gt;right,res); &#125; int kthSmallest(TreeNode* root, int k) &#123; if(!root) return -1; vector&lt;int&gt; arr; inorder(root, arr); return arr[k-1]; &#125;&#125;; 108ms, 27.49%, June.17th, 2016 https://leetcode.com/discuss/44731/pythonic-approach-with-generator Pythonic approach with generator With generator in python, one very straightforward solution might be: 123456789101112131415161718class Solution: # @param &#123;TreeNode&#125; root # @param &#123;integer&#125; k # @return &#123;integer&#125; def kthSmallest(self, root, k): for val in self.inorder(root): if k == 1: return val else: k -= 1 def inorder(self, root): if root is not None: for val in self.inorder(root.left): yield val yield root.val for val in self.inorder(root.right): yield val https://discuss.leetcode.com/topic/37222/python-easy-iterative-and-recursive-solution Python Easy Iterative and Recursive Solution Recursive: 123456789101112131415def kthSmallest(self, root, k): self.k = k self.res = None self.helper(root) return self.resdef helper(self, node): if not node: return self.helper(node.left) self.k -= 1 if self.k == 0: self.res = node.val return self.helper(node.right) Iterative: 1234567891011def kthSmallest(root, k): stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() k -= 1 if k == 0: return root.val root = root.right https://discuss.leetcode.com/topic/17583/python-solution-using-iteration Python Solution using iteration 1234567891011121314151617class Solution: # @param &#123;TreeNode&#125; root # @param &#123;integer&#125; k # @return &#123;integer&#125; def kthSmallest(self, root, k): i=0 stack=[] node=root while node or stack: while node: stack.append(node) node=node.left node=stack.pop() i+=1 if i==k: return node.val node=node.right For the follow up question, I think we could add a variable to the TreeNode to record the size of the left subtree. When insert or delete a node in the left subtree, we increase or decrease it by 1. So we could know whether the kth smallest element is in the left subtree or in the right subtree by compare the size with k.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[229. Majority Element II]]></title>
    <url>%2Fp%2Fb53b72f4%2F</url>
    <content type="text"><![CDATA[28.0% https://leetcode.com/problems/majority-element-ii/description/ Given an integer array of size n, find all elements that appear more than âŒŠ n/3 âŒ‹ times. The algorithm should run in linear time and in O(1) space. Hint: How many majority elements could it possibly have? Do you have a better hint? Suggest it! è¿˜æ²¡æœ‰è§£å†³ï¼Œéœ€è¦å­¦ä¹ ä¸‹è¿™ä¸ªè§£æ³• https://discuss.leetcode.com/topic/17564/boyer-moore-majority-vote-algorithm-and-my-elaboration Boyer-Moore Majority Vote algorithm and my elaboration For those who arenâ€™t familiar with Boyer-Moore Majority Vote algorithm,I found a great article (http://goo.gl/64Nams) that helps me to understand this fantastic algorithm!!Please check it out! The essential concepts is you keep a counter for the majority number X. If you find a number Y that is not X, the current counter should deduce 1. The reason is that if there is 5 X and 4 Y, there would be one (5-4) more X than Y. This could be explained as â€œ4 X being paired out by 4 Yâ€. And since the requirement is finding the majority for more than ceiling of [n/3], the answer would be less than or equal to two numbers.So we can modify the algorithm to maintain two counters for two majorities. Followings are my sample Python code: 1234567891011121314151617181920class Solution:# @param &#123;integer[]&#125; nums# @return &#123;integer[]&#125;def majorityElement(self, nums): if not nums: return [] count1, count2, candidate1, candidate2 = 0, 0, 0, 1 for n in nums: if n == candidate1: count1 += 1 elif n == candidate2: count2 += 1 elif count1 == 0: candidate1, count1 = n, 1 elif count2 == 0: candidate2, count2 = n, 1 else: count1, count2 = count1 - 1, count2 - 1 return [n for n in (candidate1, candidate2) if nums.count(n) &gt; len(nums) // 3] https://discuss.leetcode.com/topic/17396/boyer-moore-majority-vote-algorithm-generalization Boyer-Moore Majority Vote algorithm generalization Boyer-Moore Majority Vote algorithm generalization to elements appear more than floor(n/k) times 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt; &amp;a) &#123; int y = 0, z = 1, cy = 0, cz = 0; for (auto x: a) &#123; if (x == y) cy++; else if (x == z) cz++; else if (! cy) y = x, cy = 1; else if (! cz) z = x, cz = 1; else cy--, cz--; &#125; cy = cz = 0; for (auto x: a) if (x == y) cy++; else if (x == z) cz++; vector&lt;int&gt; r; if (cy &gt; a.size()/3) r.push_back(y); if (cz &gt; a.size()/3) r.push_back(z); return r; &#125;&#125;; https://discuss.leetcode.com/topic/17721/my-c-solution My C++ Solution 1234567891011121314151617181920212223242526272829303132333435vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; int cnt1 = 0, cnt2 = 0, a=0, b=1; for(auto n: nums)&#123; if (a==n)&#123; cnt1++; &#125; else if (b==n)&#123; cnt2++; &#125; else if (cnt1==0)&#123; a = n; cnt1 = 1; &#125; else if (cnt2 == 0)&#123; b = n; cnt2 = 1; &#125; else&#123; cnt1--; cnt2--; &#125; &#125; cnt1 = cnt2 = 0; for(auto n: nums)&#123; if (n==a) cnt1++; else if (n==b) cnt2++; &#125; vector&lt;int&gt; res; if (cnt1 &gt; nums.size()/3) res.push_back(a); if (cnt2 &gt; nums.size()/3) res.push_back(b); return res;&#125; https://discuss.leetcode.com/topic/23689/my-o-n-time-solution-20ms/3 My O(n) time solution ,20ms My idea comes from Majority Vote algroithm,http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html.Now we vote two numbers simultaneously. if the next number is differents from them both.then the two numbersâ€™ votes minus one. If some numberâ€™s vote comes zero,then vote the next number.Every time vote minus,it is the same that we remove the three numbers from the array.And the majority elemnts of original still are the majority elements in the end. So check t1 and t2 are the majority elements of original array at last. 12345678910111213141516171819202122vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; int t1,t2,n1=0,n2=0; //numbers t1 and t2,votes&apos; numbers n1,and n2. for(int i=0;i&lt;nums.size();++i) &#123; if(n1!=0&amp;&amp;t1==nums[i])&#123;++n1;continue;&#125; if(n2!=0&amp;&amp;t2==nums[i])&#123;++n2;continue;&#125; if(n1==0)&#123; t1=nums[i];++n1;continue;&#125; if(n2==0)&#123; t2=nums[i];++n2;continue;&#125; --n1;--n2; &#125; int z1=0,z2=0; for(int i=0;i&lt;nums.size();++i) &#123; if(n1&gt;0)&#123; if(nums[i]==t1) ++z1;&#125; if(n2&gt;0) &#123;if(nums[i]==t2) ++z2;&#125; &#125; vector&lt;int&gt; ret; //check t1 and t2. if(z1&gt;nums.size()/3) ret.push_back(t1); if(z2&gt;nums.size()/3) ret.push_back(t2); return ret; &#125; https://discuss.leetcode.com/topic/17409/6-lines-general-case-o-n-time-and-o-k-space 6 lines, general case O(N) time and O(k) space Solution I keep up to two candidates in my counter, so this fulfills the O(N) time and O(1) space requirements. 1234567def majorityElement(self, nums): ctr = collections.Counter() for n in nums: ctr[n] += 1 if len(ctr) == 3: ctr -= collections.Counter(set(ctr)) return [n for n in ctr if nums.count(n) &gt; len(nums)/3] Explanation Think of it this way: Find three different votes and hide them. Repeat until there arenâ€™t three different votes left. A number that originally had more than one third of the votes now still has at least one vote, because to hide all of its votes you wouldâ€™ve had to hide more than three times one third of the votes - more votes than there were. You can easily have false positives, though, so in the end check whether the remaining up to two candidates actually had more than one third of the votes. My code does just that: Collect (count) the votes for every number, but remove triples of three different votes on the fly, as soon as we have such a triple. Generalization to âŒŠN/kâŒ‹, still O(N) time but O(k) space For the general problem, looking for elements appearing more than âŒŠN/kâŒ‹ times for some positive integer k, I just have to change my 3 to k. Then it already works and takes takes O(k) space and O(kN) time. The O(kN) time does not come from the main loop, though. Yes, each ctr -= â€¦ does cost k, but I only have to do it at most N/k times. To put it in terms of the above explanation, I canâ€™t hide a vote more than once. No, the culprit is my last line, counting each remaining candidate separately. If I count them at the same time, I get O(N) again. Hereâ€™s the full generalized code: 12345678def majorityElement(self, nums, k): ctr = collections.Counter() for n in nums: ctr[n] += 1 if len(ctr) == k: ctr -= collections.Counter(set(ctr)) ctr = collections.Counter(n for n in nums if n in ctr) return [n for n in ctr if ctr[n] &gt; len(nums)/k] https://discuss.leetcode.com/topic/17473/c-solution-for-elements-appear-more-than-floor-n-k-times C++ solution for elements appear more than floor(n/k) times 12345678910111213141516171819202122232425vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; return majorityElement(nums, 3);&#125;vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums, const int k) &#123; const int size_n = nums.size(); vector&lt;int&gt; result; unordered_map&lt;int, int&gt; cand; for (int i = 0; i &lt; size_n; i++) &#123; cand[nums[i]]++; if (cand.size() == k) &#123; for (auto it = cand.begin(); it != cand.end(); ) &#123; if (--(it-&gt;second) == 0) it = cand.erase(it); else it++; &#125; &#125; &#125; for (auto&amp; item : cand) item.second = 0; for (auto&amp; item : nums) &#123; if (cand.count(item) &gt; 0) cand[item]++; &#125; for (auto&amp; item : cand) &#123; if (item.second &gt; size_n / k) result.emplace_back(item.first); &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[228. Summary Ranges]]></title>
    <url>%2Fp%2F62fcefb8%2F</url>
    <content type="text"><![CDATA[28.7% https://leetcode.com/problems/summary-ranges/description/ Given a sorted integer array without duplicates, return the summary of its ranges. 123456Example 1:Input: [0,1,2,4,5,7]Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]Example 2:Input: [0,2,3,4,6,8,9]Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;] æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920class Solution &#123;public: vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123; vector&lt;string&gt; res; int i=0, n=nums.size(); while(i&lt;n)&#123; int j = i; while(j+1&lt;n &amp;&amp; nums[j+1]==nums[j]+1) j++; if(j==i) res.push_back(to_string(nums[i])); else&#123; string s = to_string(nums[i]) + "-&gt;" + to_string(nums[j]); res.push_back(s); &#125; i = j+1; &#125; return res; &#125;&#125;; 0ms, 14.20%, June.18th, 2016 https://leetcode.com/discuss/42229/10-line-c-easy-understand 10 line c++ easy understand 12345678910111213vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123; const int size_n = nums.size(); vector&lt;string&gt; res; if ( 0 == size_n) return res; for (int i = 0; i &lt; size_n;) &#123; int start = i, end = i; while (end + 1 &lt; size_n &amp;&amp; nums[end+1] == nums[end] + 1) end++; if (end &gt; start) res.push_back(to_string(nums[start]) + &quot;-&gt;&quot; + to_string(nums[end])); else res.push_back(to_string(nums[start])); i = end+1; &#125; return res;&#125; https://discuss.leetcode.com/topic/17154/9-lines-c-0ms-solution 9 lines, c++, 0ms solution 1234567891011vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123; int i = 0, size = nums.size(); vector&lt;string&gt; result; while(i &lt; size)&#123; int j = 1; while(i + j &lt; size &amp;&amp; nums[i + j] - nums[i] == j) ++j; result.push_back(j &lt;= 1 ? to_string(nums[i]) : to_string(nums[i]) + &quot;-&gt;&quot; + to_string(nums[i + j - 1])); i += j; &#125; return result; &#125; https://discuss.leetcode.com/topic/17177/idea-1-liner-group-by-number-index Idea + 1-Liner: Group by number-index The Idea The difference between a number and its index identifies the range. Consider the given example input: 123numbers: [0, 1, 2, 4, 5, 7]indexes: [0, 1, 2, 3, 4, 5]subtract: [0, 0, 0, 1, 1, 2] You can see I have three differences (0, 1 and 2), corresponding to the three ranges. That can then be used to group the elements. Solution 1 Ruby and Python can exploit it particularly well, thanks to their groupby functions: Python: 123def summaryRanges(self, nums): return [re.sub(&apos;-&gt;.*&gt;&apos;, &apos;-&gt;&apos;, &apos;-&gt;&apos;.join(`n` for i, n in g)) for _, g in itertools.groupby(enumerate(nums), lambda (i, n): n-i)] Solution 2 Here I build two dicts, telling me the first and last number of each range. For the given example I get: 12first = &#123;0: 0, 1: 4, 2: 7&#125;last = &#123;0: 2, 1: 5, 2: 7&#125; The code: 1234def summaryRanges(self, nums): diff = [(n-i, n) for i, n in enumerate(nums)] first, last = dict(diff[::-1]), dict(diff) return [`n` + (&apos;-&gt;&apos;+`last[d]`)*(n&lt;last[d]) for d, n in sorted(first.items())] Solution 3 Storing [first, last] for each range in a dict (last being optional). 12345def summaryRanges(self, nums): ranges = collections.defaultdict(list) for i, n in enumerate(nums): ranges[n-i][1:] = n, return [&apos;-&gt;&apos;.join(map(str, r)) for r in sorted(ranges.values())] https://discuss.leetcode.com/topic/17094/6-lines-in-python 6 lines in Python Three versions of the same algorithm, all take O(n) time. Solution 1 Just collect the ranges, then format and return them. 1234567def summaryRanges(self, nums): ranges = [] for n in nums: if not ranges or n &gt; ranges[-1][-1] + 1: ranges += [], ranges[-1][1:] = n, return [&apos;-&gt;&apos;.join(map(str, r)) for r in ranges] Solution 2 A variation of solution 1, holding the current range in an extra variable r to make things easier. Note that r contains at most two elements, so the in-check takes constant time. 12345678def summaryRanges(self, nums): ranges, r = [], [] for n in nums: if n-1 not in r: r = [] ranges += r, r[1:] = n, return [&apos;-&gt;&apos;.join(map(str, r)) for r in ranges] Solution 3 A tricky short version. 12345678def summaryRanges(self, nums): ranges = r = [] for n in nums: if `n-1` not in r: r = [] ranges += r, r[1:] = `n`, return map(&apos;-&gt;&apos;.join, ranges) About the commas :-) Three people asked about them in the comments, so Iâ€™ll also explain it here as well. I have these two basic cases: 12ranges += [],r[1:] = n, Why the trailing commas? Because it turns the right hand side into a tuple and I get the same effects as these more common alternatives: 12345ranges += [[]]orranges.append([])r[1:] = [n] Without the comma, â€¦ ranges += [] wouldnâ€™t add [] itself but only its elements, i.e., nothing. r[1:] = n wouldnâ€™t work, because my n is not an iterable. Why do it this way instead of the more common alternatives I showed above? Because itâ€™s shorter and faster (according to tests I did a while back). https://discuss.leetcode.com/topic/17934/my-easy-to-understand-python-solution My easy to understand Python solution 1234567891011121314151617def summaryRanges(self, nums): if not nums: return [] res, i, start = [], 0, 0 while i &lt; len(nums)-1: if nums[i]+1 != nums[i+1]: res.append(self.printRange(nums[start], nums[i])) start = i+1 i += 1 res.append(self.printRange(nums[start], nums[i])) return resdef printRange(self, l, r): if l == r: return str(l) else: return str(l) + &quot;-&gt;&quot; + str(r) Solution Mine: 40ms, 84.94%, June.18th, 2016 123456789101112131415161718192021222324252627class Solution(object): def summaryRanges(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[str] &quot;&quot;&quot; if not nums: return [] if len(nums)==1: return [str(nums[0])] rtype = [] p1 = 0 p2 = 0 n = len(nums) while p1 &lt; n-1: while p2 &lt; n-1 and nums[p2] + 1 == nums[p2+1]: p2 += 1 if p1 == p2: rtype.append(str(nums[p1])) else: tmp = str(nums[p1]) + &apos;-&gt;&apos; + str(nums[p2]) rtype.append(tmp) p2 += 1 p1 = p2 if p1 == n-1: rtype.append(str(nums[-1])) return rtype Solution 1: 48ms, 38.46%, June.18th, 2016 https://leetcode.com/discuss/42199/6-lines-in-python 123456789101112class Solution(object): def summaryRanges(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[str] &quot;&quot;&quot; ranges = [] for n in nums: if not ranges or n &gt; ranges[-1][-1] + 1: ranges += [], ranges[-1][1:] = n, return [&apos;-&gt;&apos;.join(map(str, i)) for i in ranges] 1ms, 5.00%, June.18th, 2016 https://leetcode.com/discuss/42290/accepted-java-solution-easy-to-understand 1234567891011121314151617public class Solution &#123; public List&lt;String&gt; summaryRanges(int[] nums) &#123; List&lt;String&gt; list = new ArrayList(); if(nums.length == 1)&#123; list.add(nums[0] + &quot;&quot;); return list; &#125; for(int i=0; i &lt; nums.length; i++)&#123; int a = nums[i]; while(i+1&lt;nums.length &amp;&amp; nums[i+1] - nums[i] ==1) i++; if(a != nums[i]) list.add(a + &quot;-&gt;&quot; + nums[i]); else list.add(a+&quot;&quot;); &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[227. Basic Calculator II]]></title>
    <url>%2Fp%2Fec140a05%2F</url>
    <content type="text"><![CDATA[28.5% https://leetcode.com/problems/basic-calculator-ii/#/description Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero. You may assume that the given expression is always valid. 1234Some examples:&quot;3+2*2&quot; = 7&quot; 3/2 &quot; = 1&quot; 3+5 / 2 &quot; = 5 Note: Do not use the eval built-in library function. æ–¹æ³•ä¸€ï¼š å­¦ä¹ ä¸€ä¸ªstrçš„æ–¹æ³•ï¼Œfind_first_not_of find_first_not_of() isdigitå‡½æ•°ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºæ•°å­— https://discuss.leetcode.com/topic/17323/my-16-ms-no-stack-one-pass-short-c-solution My 16 ms No stack One pass short C++ solution 12345678910111213141516171819202122232425262728class Solution &#123;public: int calculate(string s) &#123; int result = 0, cur_res = 0; char op = &apos;+&apos;; for(int pos = s.find_first_not_of(&apos; &apos;); pos &lt; s.size(); pos = s.find_first_not_of(&apos; &apos;, pos)) &#123; if(isdigit(s[pos])) &#123; int tmp = s[pos] - &apos;0&apos;; while(++pos &lt; s.size() &amp;&amp; isdigit(s[pos])) tmp = tmp*10 + (s[pos] - &apos;0&apos;); switch(op) &#123; case &apos;+&apos; : cur_res += tmp; break; case &apos;-&apos; : cur_res -= tmp; break; case &apos;*&apos; : cur_res *= tmp; break; case &apos;/&apos; : cur_res /= tmp; break; &#125; &#125; else &#123; if(s[pos] == &apos;+&apos; || s[pos] == &apos;-&apos;) &#123; result += cur_res; cur_res = 0; &#125; op = s[pos++]; &#125; &#125; return result + cur_res; &#125;&#125;; https://discuss.leetcode.com/topic/30568/c-stack-solution C++ stack solution. 12345678910111213141516171819202122232425262728293031int calculate(string s) &#123; stack&lt;int&gt; myStack; char sign = &apos;+&apos;; int res = 0, tmp = 0; for (unsigned int i = 0; i &lt; s.size(); i++) &#123; if (isdigit(s[i])) tmp = 10*tmp + s[i]-&apos;0&apos;; if (!isdigit(s[i]) &amp;&amp; !isspace(s[i]) || i == s.size()-1) &#123; if (sign == &apos;-&apos;) myStack.push(-tmp); else if (sign == &apos;+&apos;) myStack.push(tmp); else &#123; int num; if (sign == &apos;*&apos; ) num = myStack.top()*tmp; else num = myStack.top()/tmp; myStack.pop(); myStack.push(num); &#125; sign = s[i]; tmp = 0; &#125; &#125; while (!myStack.empty()) &#123; res += myStack.top(); myStack.pop(); &#125; return res;&#125; https://discuss.leetcode.com/topic/16807/17-lines-c-easy-20-ms 17 lines C++, easy, 20 ms If you donâ€™t like the 44 - op ASCII trick, you can use op == â€˜+â€™ ? 1 : -1 instead. And wow, I didnâ€™t know C++ has or. Iâ€™m a Python guy and wrote that out of habit and only realized it after getting this accepted :-) 12345678910111213141516171819int calculate(string s) &#123; istringstream in(&apos;+&apos; + s + &apos;+&apos;); long long total = 0, term = 0, n; char op; while (in &gt;&gt; op) &#123; if (op == &apos;+&apos; or op == &apos;-&apos;) &#123; total += term; in &gt;&gt; term; term *= 44 - op; &#125; else &#123; in &gt;&gt; n; if (op == &apos;*&apos;) term *= n; else term /= n; &#125; &#125; return total;&#125; https://discuss.leetcode.com/topic/17213/my-28ms-c-code-with-two-stacks-one-for-op-one-for-oprand-extension-to-cover-also-given My 28ms C++ code with two stacks (one for op, one for oprand), extension to cover â€˜(â€˜ &amp; â€˜)â€™ also given Use two stacks : one to save operators, one to save oprands. Every time, if we get a digit, then update curNum, if we get an operator, then it means we get a complete oprand, which is saved in curNum; if the last operator is * or /, then calculate it, otherwise, just save curNum and s[i] (new operator) in the stacks. At last, the opS stack has only â€œ+â€ &amp; â€œ-â€œ, which are the sign of the corresponding operands saved in numS. Then we do sum to get the result. 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int calculate(string s) &#123; stack&lt;char&gt; opS; stack&lt;int&gt; numS; s.push_back(&apos;)&apos;); // to make sure the last operand will be saved in the stack e.g. 1+2*3), 2*3 will be calculated and push in the stack opS.push(&apos;+&apos;); // sign for the first operand int i, curNum, len = s.size(), res =0; for(i=0,curNum=0; i&lt;len; ++i) &#123; if(isdigit(s[i])) curNum = curNum*10 + s[i] -&apos;0&apos;; // digit, recover the oprand else if(isspace(s[i])) continue; // skip the space else &#123; switch(opS.top()) &#123; case &apos;*&apos;: // if the last operator is * / , do calculation case &apos;/&apos;: curNum = opS.top()==&apos;/&apos;?numS.top()/curNum : numS.top()*curNum; opS.pop(); numS.pop(); &#125; numS.push(curNum); / curNum = 0; opS.push(s[i]); &#125; &#125; opS.pop(); // skip the &quot;)&quot; while(!opS.empty()) &#123;res += (opS.top()==&apos;-&apos;)? -numS.top(): numS.top(); opS.pop(); numS.pop();&#125; return res; &#125;&#125;; The below version covers both +-*/ and () 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: int calculate(string s) &#123; stack&lt;char&gt; opS; stack&lt;int&gt; numS; s = &apos;(&apos; + s + &apos;)&apos;; int i, curNum = 0, len = s.size(); for(i=0; i&lt;len; ++i) &#123; if(isdigit(s[i])) curNum = curNum*10 + s[i] -&apos;0&apos;; else if(isspace(s[i])) continue; else if(s[i] == &apos;(&apos;) &#123; opS.push(&apos;(&apos;); opS.push(&apos;+&apos;); &#125; else &#123; switch(opS.top()) &#123; case &apos;*&apos;: case &apos;/&apos;: curNum = opS.top()==&apos;/&apos;?numS.top()/curNum : numS.top()*curNum; opS.pop(); numS.pop(); &#125; switch(s[i]) &#123; case &apos;)&apos;: if(&apos;-&apos;== opS.top()) curNum = -curNum; opS.pop(); while(opS.top()!=&apos;(&apos;) &#123; curNum += (opS.top()==&apos;-&apos;)? -numS.top(): numS.top(); opS.pop(); numS.pop(); &#125; opS.pop(); // skip &apos;(&apos; break; default: //+,-,*,/ opS.push(s[i]); numS.push(curNum); curNum = 0; &#125; &#125; &#125; return curNum; &#125;&#125;; https://discuss.leetcode.com/topic/22170/python-short-solution-with-stack Python short solution with stack. 212ms, 79.87%, September 22, 2016 1234567891011121314151617181920212223def calculate(self, s): if not s: return &quot;0&quot; stack, num, sign = [], 0, &quot;+&quot; for i in xrange(len(s)): if s[i].isdigit(): num = num*10+ord(s[i])-ord(&quot;0&quot;) if (not s[i].isdigit() and not s[i].isspace()) or i == len(s)-1: if sign == &quot;-&quot;: stack.append(-num) elif sign == &quot;+&quot;: stack.append(num) elif sign == &quot;*&quot;: stack.append(stack.pop()*num) else: tmp = stack.pop() if tmp//num &lt; 0 and tmp%num != 0: stack.append(tmp//num+1) else: stack.append(tmp//num) sign = s[i] num = 0 return sum(stack) https://discuss.leetcode.com/topic/16803/easy-7-12-lines-three-solutions Easy 7-12 lines, Three solutions Three quite different Python solutions. Solution 1: Split the splits (10 lines, 520 ms) Split the expression into terms on + and -. Split each term into numbers on * and /. 1234567891011def calculate(self, s): total = 0 outer = iter([&apos;+&apos;] + re.split(&apos;([+-])&apos;, s)) for addsub in outer: inner = iter([&apos;*&apos;] + re.split(&apos;([*/])&apos;, next(outer))) term = 1 for muldiv in inner: n = int(next(inner)) term = term*n if muldiv == &apos;*&apos; else term/n total += term if addsub == &apos;+&apos; else -term return total Solution 2: Process tokens from left to right (12 lines, 224 ms): Iterate over the tokens (numbers and operators), keeping track of the current total, the current term sign (+1 or -1), and the current term value. 12345678910111213def calculate(self, s): tokens = iter(re.findall(&apos;\d+|\S&apos;, s)) total, sign = 0, 1 for token in tokens: if token in &apos;+-&apos;: total += sign * term sign = &apos; +&apos;.find(token) elif token in &apos;*/&apos;: n = int(next(tokens)) term = term*n if token == &apos;*&apos; else term/n else: term = int(token) return total + sign * term I could make that one more space-efficient with 1tokens = (m.group() for m in re.finditer(&apos;\d+|\S&apos;, s)) but thatâ€™s less pretty and it actually increased the runtime by about 100 ms. Also, I could add + to the input (i.e., findall(â€¦, s + â€˜+â€™)), then I could just return total and wouldnâ€™t have to add the final term there. Pretty much doesnâ€™t change the runtime. Solution 3: First or second operation, repeatâ€¦ (7 lines, 244 ms) As long as there is any operation left to do, do either the first or the second operation, depending on what they are. Implemented by putting the tokens in a list in reverse order, because making a change at the end of the list is O(1) and making a change at the start would be O(n). 12345678def calculate(self, s): t = re.findall(&apos;\d+|\S&apos;, s + &apos;+0&apos;)[::-1] t[::2] = map(int, t[::2]) while len(t) &gt; 3: i = len(t) - 5 + 2 * (t[-2] in &apos;*/&apos; or t[-4] not in &apos;*/&apos;) b, op, a = t[i:i+3] t[i:i+3] = a+b if op==&apos;+&apos; else a-b if op==&apos;-&apos; else a*b if op==&apos;*&apos; else a/b, return t[2]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[226. Invert Binary Tree]]></title>
    <url>%2Fp%2Ff3118605%2F</url>
    <content type="text"><![CDATA[51.8% https://leetcode.com/problems/invert-binary-tree/#/description 12345678910111213Invert a binary tree. 4 / \ 2 7 / \ / \1 3 6 9to 4 / \ 7 2 / \ / \9 6 3 1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you canâ€™t invert a binary tree on a whiteboard so fuck off. å¯¹åº”å‰‘æŒ‡offer 19é¢˜ ä¸‰ç§æ–¹æ³•ï¼šé€’å½’ã€DFSã€BFS æ–¹æ³•ä¸€ï¼šé€’å½’ 1234567891011121314public class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; final TreeNode left = root.left, right = root.right; root.left = invertTree(right); root.right = invertTree(left); return root; &#125;&#125; æˆ‘çš„å®žçŽ°ï¼š 1234567891011class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(root==NULL) return root; TreeNode* left = invertTree(root-&gt;left); TreeNode* right = invertTree(root-&gt;right); root-&gt;left = right; root-&gt;right = left; return root; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return root; TreeNode* left = invertTree(root-&gt;left); TreeNode* right = invertTree(root-&gt;right); root-&gt;right = left; root-&gt;left = right; return root; &#125;&#125;; æ–¹æ³•äºŒï¼šDFSï¼Œä½¿ç”¨æ ˆä½œä¸ºè¾…åŠ©ï¼Œä½¿ç”¨æ ˆçš„æ–¹æ³•æ˜¯æŠŠrootåŽ‹å…¥æ ˆï¼Œæ ˆä¸ä¸ºç©ºæ—¶ï¼Œå¼¹å‡ºå½“å‰æ ˆé¡¶ï¼Œé’ˆå¯¹æ ˆé¡¶çš„å·¦å³èŠ‚ç‚¹è¿›è¡Œåè½¬ï¼Œè‹¥å·¦éžç©ºï¼Œå·¦åŽ‹å…¥ï¼Œå³éžç©ºï¼Œå³åŽ‹å…¥ 1234567891011121314151617181920212223242526public class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; final Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) &#123; final TreeNode node = stack.pop(); final TreeNode left = node.left; node.left = node.right; node.right = left; if(node.left != null) &#123; stack.push(node.left); &#125; if(node.right != null) &#123; stack.push(node.right); &#125; &#125; return root; &#125;&#125; æ–¹æ³•ä¸‰ï¼š BFSï¼Œå±‚åºéåŽ†çš„æ–¹æ³•ï¼Œæ³¨æ„ï¼Œè¦æŠŠå±‚åºå½“åšå…ˆåºï¼Œä¸­åºï¼ŒåŽç»­éåŽ†ä¸€æ ·æ™®é€šå’Œå®¹æ˜“æƒ³åˆ°çš„æ–¹æ³•ã€‚ å±‚åºéåŽ†ï¼Œå…·ä½“cppå®žçŽ°ï¼Œè¿˜éœ€è¦å†æ€è€ƒã€‚ 1234567891011121314151617181920212223242526public class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; final Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()) &#123; final TreeNode node = queue.poll(); final TreeNode left = node.left; node.left = node.right; node.right = left; if(node.left != null) &#123; queue.offer(node.left); &#125; if(node.right != null) &#123; queue.offer(node.right); &#125; &#125; return root; &#125;&#125; https://discuss.leetcode.com/topic/16138/recursive-and-non-recursive-c-both-4ms/3 Recursive and non-recursive C++ both 4ms Recursive 12345678TreeNode* invertTree(TreeNode* root) &#123; if (root) &#123; invertTree(root-&gt;left); invertTree(root-&gt;right); std::swap(root-&gt;left, root-&gt;right); &#125; return root;&#125; Non-Recursive 123456789101112131415TreeNode* invertTree(TreeNode* root) &#123; std::stack&lt;TreeNode*&gt; stk; stk.push(root); while (!stk.empty()) &#123; TreeNode* p = stk.top(); stk.pop(); if (p) &#123; stk.push(p-&gt;left); stk.push(p-&gt;right); std::swap(p-&gt;left, p-&gt;right); &#125; &#125; return root;&#125; https://discuss.leetcode.com/topic/16062/3-4-lines-python/4 3-4 lines Python 1234def invertTree(self, root): if root: root.left, root.right = self.invertTree(root.right), self.invertTree(root.left) return root Maybe make it four lines for better readability: 12345def invertTree(self, root): if root: invert = self.invertTree root.left, root.right = invert(root.right), invert(root.left) return root And an iterative version using my own stack: 12345678def invertTree(self, root): stack = [root] while stack: node = stack.pop() if node: node.left, node.right = node.right, node.left stack += node.left, node.right return root https://discuss.leetcode.com/topic/21271/python-solutions-recursively-dfs-bfs Python solutions (recursively, dfs, bfs). 1234567891011121314151617181920212223242526# recursivelydef invertTree1(self, root): if root: root.left, root.right = self.invertTree(root.right), self.invertTree(root.left) return root # BFSdef invertTree2(self, root): queue = collections.deque([(root)]) while queue: node = queue.popleft() if node: node.left, node.right = node.right, node.left queue.append(node.left) queue.append(node.right) return root # DFSdef invertTree(self, root): stack = [root] while stack: node = stack.pop() if node: node.left, node.right = node.right, node.left stack.extend([node.right, node.left]) return root https://discuss.leetcode.com/topic/16039/straightforward-dfs-recursive-iterative-bfs-solutions/3 Straightforward DFS recursive, iterative, BFS solutions As in many other cases this problem has more than one possible solutions: Lets start with straightforward - recursive DFS - itâ€™s easy to write and pretty much concise. 1234567891011121314public class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; final TreeNode left = root.left, right = root.right; root.left = invertTree(right); root.right = invertTree(left); return root; &#125;&#125; The above solution is correct, but it is also bound to the application stack, which means that itâ€™s no so much scalable - (you can find the problem size that will overflow the stack and crash your application), so more robust solution would be to use stack data structure. 1234567891011121314151617181920212223242526public class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; final Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) &#123; final TreeNode node = stack.pop(); final TreeNode left = node.left; node.left = node.right; node.right = left; if(node.left != null) &#123; stack.push(node.left); &#125; if(node.right != null) &#123; stack.push(node.right); &#125; &#125; return root; &#125;&#125; Finally we can easly convert the above solution to BFS - or so called level order traversal. 1234567891011121314151617181920212223242526public class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; final Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()) &#123; final TreeNode node = queue.poll(); final TreeNode left = node.left; node.left = node.right; node.right = left; if(node.left != null) &#123; queue.offer(node.left); &#125; if(node.right != null) &#123; queue.offer(node.right); &#125; &#125; return root; &#125;&#125; If I can write this code, does it mean I can get job at Google? ;)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[225. Implement Stack using Queues]]></title>
    <url>%2Fp%2Fdb897a5%2F</url>
    <content type="text"><![CDATA[31.7% https://leetcode.com/problems/implement-stack-using-queues/#/description Implement the following operations of a stack using queues. push(x) â€“ Push element x onto stack. pop() â€“ Removes the element on top of the stack. top() â€“ Get the top element. empty() â€“ Return whether the stack is empty. Notes: You must use only standard operations of a queue â€“ which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). æ–¹æ³•ä¸€: ä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ—ï¼Œå½“pushæ—¶ï¼Œpushè¿›åŽ»ï¼Œç„¶åŽå°†é˜Ÿåˆ—ä¸­å‰é¢çš„éƒ½æ”¾åˆ°æ–°æ¥çš„åŽé¢ï¼Œè¿™æ ·å°†æ¥topè´§popæ—¶ï¼Œå°±å¯ä»¥åªç”¨è°ƒç”¨frontå’Œpopå‡½æ•°äº†ã€‚ æ³¨æ„queueçš„å‡½æ•°ï¼ŒåŒ…æ‹¬frontï¼Œpopï¼Œpushï¼Œsizeç­‰ã€‚å°¤å…¶æ³¨æ„å¯ä»¥ç”¨size()å‡½æ•°ã€‚ å‰‘æŒ‡ offerç¬¬7é¢˜ æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 10th, 2017 1234567891011121314151617181920212223242526272829303132333435363738394041424344class MyStack &#123;public: queue&lt;int&gt; que; /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; que.push(x); int n = que.size(); for(int i=0; i&lt;n-1; i++)&#123; int val = que.front(); que.pop(); que.push(val); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int val = que.front(); que.pop(); return val; &#125; /** Get the top element. */ int top() &#123; return que.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return que.empty(); &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * bool param_4 = obj.empty(); */ 12345678910111213141516171819202122232425262728293031323334class MyStack &#123; queue&lt;int&gt; que;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; que.push(x); for(int i=0; i&lt;que.size()-1; i++)&#123; que.push(que.front()); que.pop(); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int val = que.front(); que.pop(); return val; &#125; /** Get the top element. */ int top() &#123; return que.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return que.empty(); &#125;&#125;; 0ms, 11.57%, 20 July 2016 https://discuss.leetcode.com/topic/19227/a-simple-c-solution 123456789101112131415161718192021222324252627class Stack &#123;public: queue&lt;int&gt; que; // Push element x onto stack. void push(int x) &#123; que.push(x); for(int i=0; i&lt;que.size()-1; ++i)&#123; que.push(que.front()); que.pop(); &#125; &#125; // Removes the element on top of the stack. void pop() &#123; que.pop(); &#125; // Get the top element. int top() &#123; return que.front(); &#125; // Return whether the stack is empty. bool empty() &#123; return que.empty(); &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[224. Basic Calculator]]></title>
    <url>%2Fp%2Fe3f3672e%2F</url>
    <content type="text"><![CDATA[26.0% https://leetcode.com/problems/basic-calculator/?tab=Description Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces . You may assume that the given expression is always valid. 1234Some examples:&quot;1 + 1&quot; = 2&quot; 2-1 + 2 &quot; = 3&quot;(1+(4+5+2)-3)+(6+8)&quot; = 23 Note: Do not use the eval built-in library function. éœ€è¦ç»§ç»­å­¦ä¹  æ–¹æ³•ä¸€ï¼š https://discuss.leetcode.com/topic/22359/16-ms-solution-in-c-with-stacks 16 ms solution in C++ with stacks 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int calculate(string s) &#123; stack &lt;int&gt; nums, ops; int num = 0; int rst = 0; int sign = 1; for (char c : s) &#123; if (isdigit(c)) &#123; num = num * 10 + c - &apos;0&apos;; &#125; else &#123; rst += sign * num; num = 0; if (c == &apos;+&apos;) sign = 1; if (c == &apos;-&apos;) sign = -1; if (c == &apos;(&apos;) &#123; nums.push(rst); ops.push(sign); rst = 0; sign = 1; &#125; if (c == &apos;)&apos; &amp;&amp; ops.size()) &#123; rst = ops.top() * rst + nums.top(); ops.pop(); nums.pop(); &#125; &#125; &#125; rst += sign * num; return rst; &#125;&#125;; æ–¹æ³•äºŒï¼š 26ms, September 13, 2016 https://discuss.leetcode.com/topic/15806/easy-18-lines-c-16-lines-python Easy 18 lines C++, 16 lines Python Keep a global running total and a stack of signs (+1 or -1), one for each open scope. The â€œglobalâ€ outermost sign is +1. Each number consumes a sign. Each + and - causes a new sign. Each ( duplicates the current sign so it can be used for the first term inside the new scope. Thatâ€™s also why I start with [1, 1] - the global sign 1 and a duplicate to be used for the first term, since expressions start like 3â€¦ or (â€¦, not like +3â€¦ or +(â€¦. Each ) closes the current scope and thus drops the current sign. Also see the example trace below my programs. C++: 1234567891011121314151617181920int calculate(string s) &#123; int total = 0; vector&lt;int&gt; signs(2, 1); for (int i=0; i&lt;s.size(); i++) &#123; char c = s[i]; if (c &gt;= &apos;0&apos;) &#123; int number = 0; while (i &lt; s.size() &amp;&amp; s[i] &gt;= &apos;0&apos;) number = 10 * number + s[i++] - &apos;0&apos;; total += signs.back() * number; signs.pop_back(); i--; &#125; else if (c == &apos;)&apos;) signs.pop_back(); else if (c != &apos; &apos;) signs.push_back(signs.back() * (c == &apos;-&apos; ? -1 : 1)); &#125; return total;&#125; Python: 1234567891011121314151617def calculate(self, s): total = 0 i, signs = 0, [1, 1] while i &lt; len(s): c = s[i] if c.isdigit(): start = i while i &lt; len(s) and s[i].isdigit(): i += 1 total += signs.pop() * int(s[start:i]) continue if c in &apos;+-(&apos;: signs += signs[-1] * (1, -1)[c == &apos;-&apos;], elif c == &apos;)&apos;: signs.pop() i += 1 return total Example trace: 123456789101112131415Here&apos;s an example trace for input 3-(2+(9-4)). remaining sign stack total3-(2+(9-4)) [1, 1] 0 -(2+(9-4)) [1] 3 (2+(9-4)) [1, -1] 3 2+(9-4)) [1, -1, -1] 3 +(9-4)) [1, -1] 1 (9-4)) [1, -1, -1] 1 9-4)) [1, -1, -1, -1] 1 -4)) [1, -1, -1] -8 4)) [1, -1, -1, 1] -8 )) [1, -1, -1] -4 ) [1, -1] -4 [1] -4 If you want to see traces for other examples, you can add this at the start inside the loop and after the loop (thatâ€™s for the Python solution, where itâ€™s all easier): 1print &apos;%11s %-16s %2d&apos; % (s[i:], signs, total) https://discuss.leetcode.com/topic/15775/simple-c-in-24-ms Simple c++ in 24 ms 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int calculate(string s) &#123; // the given expression is always valid!!! // only + and - !!! // every + and - can be flipped base on it&apos;s depth in (). stack&lt;int&gt; signs; int sign = 1; int num = 0; int ans = 0; // always transform s into ( s ) signs.push(1); for (auto c : s) &#123; if (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) &#123; num = 10 * num + c - &apos;0&apos;; &#125; else if (c == &apos;+&apos; || c == &apos;-&apos;) &#123; ans = ans + signs.top() * sign * num; num = 0; sign = (c == &apos;+&apos; ? 1 : -1); &#125; else if (c == &apos;(&apos;) &#123; signs.push(sign * signs.top()); sign = 1; &#125; else if (c == &apos;)&apos;) &#123; ans = ans + signs.top() * sign * num; num = 0; signs.pop(); sign = 1; &#125; &#125; if (num) &#123; ans = ans + signs.top() * sign * num; &#125; return ans; &#125;&#125;; python https://discuss.leetcode.com/topic/25775/python-concise-solution-with-stack Python concise solution with stack. 12345678910111213141516171819def calculate(self, s): res, num, sign, stack = 0, 0, 1, [] for ss in s: if ss.isdigit(): num = 10*num + int(ss) elif ss in [&quot;-&quot;, &quot;+&quot;]: res += sign*num num = 0 sign = [-1, 1][ss==&quot;+&quot;] elif ss == &quot;(&quot;: stack.append(res) stack.append(sign) sign, res = 1, 0 elif ss == &quot;)&quot;: res += sign*num res *= stack.pop() res += stack.pop() num = 0 return res + num*sign https://discuss.leetcode.com/topic/37951/python-with-stack Python with stack This solution uses stack to store previous result and sign when encounter a â€œ(â€œ For this problem storing sign is enough, and will be faster. 1234567891011121314151617def calculate(self, s): res, num, sign, stack = 0, 0, 1, [1] for i in s+&quot;+&quot;: if i.isdigit(): num = 10*num + int(i) elif i in &quot;+-&quot;: res += num * sign * stack[-1] sign = 1 if i==&quot;+&quot; else -1 num = 0 elif i == &quot;(&quot;: stack.append(sign * stack[-1]) sign = 1 elif i == &quot;)&quot;: res += num * sign * stack[-1] num = 0 stack.pop() return res https://discuss.leetcode.com/topic/15932/ac-python-solution AC Python Solution 123456789101112131415161718class Solution:def calculate(self, s): s = &apos;+(+&apos; + s + &apos;)&apos; s = s.replace(&apos;+-&apos;, &apos;-&apos;).replace(&apos;++&apos;, &apos;+&apos;) # for the corner case &apos;-5&apos;, &apos;+5&apos; stack = [] for i in s: if i == &apos;)&apos;: total = 0 while stack[-1] != &apos;(&apos;: total += int(stack.pop()) stack.pop() sign = 1 if stack.pop() == &apos;+&apos; else -1 stack.append(sign * total) elif i.isdigit() and stack[-1][-1] in &apos;+-0123456789&apos;: stack[-1] += i elif i != &apos; &apos;: stack.append(i) return stack[0] java https://discuss.leetcode.com/topic/15816/iterative-java-solution-with-stack Iterative Java solution with stack Simple iterative solution by identifying characters one by one. One important thing is that the input is valid, which means the parentheses are always paired and in order. Only 5 possible input we need to pay attention: digit: it should be one digit from the current number â€˜+â€™: number is over, we can add the previous number and start a new number â€˜-â€˜: same as above â€˜(â€˜: push the previous result and the sign into the stack, set result to 0, just calculate the new result within the parenthesis. â€˜)â€™: pop out the top two numbers from stack, first one is the sign before this pair of parenthesis, second is the temporary result before this pair of parenthesis. We add them together. Finally if there is only one number, from the above solution, we havenâ€™t add the number to the result, so we do a check see if the number is zero. 1234567891011121314151617181920212223242526272829303132333435public int calculate(String s) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int result = 0; int number = 0; int sign = 1; for(int i = 0; i &lt; s.length(); i++)&#123; char c = s.charAt(i); if(Character.isDigit(c))&#123; number = 10 * number + (int)(c - &apos;0&apos;); &#125;else if(c == &apos;+&apos;)&#123; result += sign * number; number = 0; sign = 1; &#125;else if(c == &apos;-&apos;)&#123; result += sign * number; number = 0; sign = -1; &#125;else if(c == &apos;(&apos;)&#123; //we push the result first, then sign; stack.push(result); stack.push(sign); //reset the sign and result for the value in the parenthesis sign = 1; result = 0; &#125;else if(c == &apos;)&apos;)&#123; result += sign * number; number = 0; result *= stack.pop(); //stack.pop() is the sign before the parenthesis result += stack.pop(); //stack.pop() now is the result calculated before the parenthesis &#125; &#125; if(number != 0) result += sign * number; return result;&#125; https://discuss.leetcode.com/topic/15816/iterative-java-solution-with-stack/2 +1 for your concise and clean code. My solution seems to be really different from others.First I reformed the input expression by rules of: remove all â€˜(â€˜, â€˜)â€™, â€˜ â€˜; reverse the express string; add â€˜+â€™ or â€˜-â€˜ to the end of the express.By this approach, the reformed expression will be easy to handled. 1234&quot;1 + 1&quot; =&gt; &quot;1+1+&quot;&quot; 2-1 + 2 &quot; =&gt; &quot;2+1-2+&quot;&quot;(1+(4+5+2)-3)+(6+8)&quot; =&gt; &quot;8+6+3-2+5+4+1+&quot;&quot;2-(5-6)&quot; =&gt; &quot;6+5-2+&quot; Java code: 1234567891011121314151617181920212223242526272829303132333435363738public int calculate(String s) &#123; if(s == null) return 0; s = reform(s); int result = 0, num = 0, base = 1; for(char c: s.toCharArray()) switch(c)&#123; case &apos;+&apos;: result += num; num = 0; base = 1; break; case &apos;-&apos;: result -= num; num = 0; base = 1; break; default: num += (c - &apos;0&apos;) * base; base *= 10; &#125; return result;&#125;private String reform(String s) &#123; StringBuilder sb = new StringBuilder(); Stack&lt;Boolean&gt; stack = new Stack&lt;&gt;(); stack.push(true); boolean add = true; for(char c: s.toCharArray()) switch(c)&#123; case &apos; &apos;: break; case &apos;(&apos;: stack.push(add); break; case &apos;)&apos;: stack.pop(); break; case &apos;+&apos;: add = stack.peek(); sb.append(stack.peek() ? &apos;+&apos; : &apos;-&apos;); break; case &apos;-&apos;: add = !stack.peek(); sb.append(stack.peek() ? &apos;-&apos; : &apos;+&apos;); break; default: sb.append(c); &#125; if(sb.charAt(0) != &apos;+&apos; || sb.charAt(0) != &apos;-&apos;) sb.insert(0, &apos;+&apos;); return sb.reverse().toString();&#125; https://discuss.leetcode.com/topic/33044/java-easy-version-to-understand JAVAâ€”â€”â€”â€“Easy Version To Understand!!!!! 123456789101112131415161718192021222324252627public static int calculate(String s) &#123; int len = s.length(), sign = 1, result = 0; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for (int i = 0; i &lt; len; i++) &#123; if (Character.isDigit(s.charAt(i))) &#123; int sum = s.charAt(i) - &apos;0&apos;; while (i + 1 &lt; len &amp;&amp; Character.isDigit(s.charAt(i + 1))) &#123; sum = sum * 10 + s.charAt(i + 1) - &apos;0&apos;; i++; &#125; result += sum * sign; &#125; else if (s.charAt(i) == &apos;+&apos;) sign = 1; else if (s.charAt(i) == &apos;-&apos;) sign = -1; else if (s.charAt(i) == &apos;(&apos;) &#123; stack.push(result); stack.push(sign); result = 0; sign = 1; &#125; else if (s.charAt(i) == &apos;)&apos;) &#123; result = result * stack.pop() + stack.pop(); &#125; &#125; return result;&#125; java28ms, September 13, 2016 https://discuss.leetcode.com/topic/33044/java-easy-version-to-understand 123456789101112131415161718192021222324252627public class Solution &#123; public int calculate(String s) &#123; int len = s.length(), sign = 1, result = 0; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for(int i = 0; i &lt; len; i++)&#123; if(Character.isDigit(s.charAt(i)))&#123; int sum = s.charAt(i) - &apos;0&apos;; while(i + 1 &lt; len &amp;&amp; Character.isDigit(s.charAt(i+1)))&#123; sum = sum * 10 + s.charAt(i+1) - &apos;0&apos;; i++; &#125; result += sum * sign; &#125;else if(s.charAt(i) == &apos;+&apos;) sign = 1; else if(s.charAt(i) == &apos;-&apos;) sign = -1; if(s.charAt(i)== &apos;(&apos;)&#123; stack.push(result); stack.push(sign); result = 0; sign = 1; &#125;else if(s.charAt(i) == &apos;)&apos;) result = result * stack.pop() + stack.pop(); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>hard</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[223. Rectangle Area]]></title>
    <url>%2Fp%2Ff73f178%2F</url>
    <content type="text"><![CDATA[32.3% https://leetcode.com/problems/rectangle-area/ Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure. Assume that the total area is never beyond the maximum possible value of int. éœ€è¦æ€è€ƒ cppsolution 1: 36ms, 20.98%, July 16th, 2016 https://discuss.leetcode.com/topic/17534/if-you-want-to-laugh-look-at-my-solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123;public: int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int area1 = (D - B)*(C - A); int area2 = (H - F)*(G - E); int area3; if (area1 == 0) &#123; return area2; &#125; if (area2 == 0) &#123; return area1; &#125; if ((A == D) &amp;&amp; (B == F) &amp;&amp; (C == G) &amp;&amp; (D == H)) &#123; return area1; &#125; if ((E &gt;= C) | (G &lt;= A) | (H &lt;= B) | (D &lt;= F)) &#123; //not overlapping return (area1 + area2); &#125; if (((G - E) &lt;= (C - A)) &amp;&amp; ((H - F) &lt;= (D - B)) &amp;&amp; (E &gt;= A) &amp;&amp; (F &gt;= B) &amp;&amp; (G &lt;= C) &amp;&amp; (D &gt;= H)) &#123; //rect2 is inside rect1 return area1; &#125; if (((C - A) &lt;= (G - E)) &amp;&amp; ((D - B) &lt;= (H - F)) &amp;&amp; (E &lt;= A) &amp;&amp; (B &gt;= F) &amp;&amp; (G &gt;= C) &amp;&amp; (H &gt;= D)) &#123; //rect1 is inside rect2 return area2; &#125; if ((F &gt;= B) &amp;&amp; (E &gt;= A) &amp;&amp; (G &gt;= C) &amp;&amp; (H &gt;= D)) &#123; //overlapping upper right corner area3 = (C - E)*(D - F); &#125; else if ((F &gt;= B) &amp;&amp; (E &lt;= A) &amp;&amp; (G &lt;= C) &amp;&amp; (H &gt;= D)) &#123; //overlapping upper left corner area3 = (G - A)*(D - F); &#125; else if ((F &lt;= B) &amp;&amp; (E &lt;= A) &amp;&amp; (G &lt;= C) &amp;&amp; (H &lt;= D)) &#123; //overlapping bottom left corner area3 = (G - A)*(H - B); &#125; else if ((F &lt;= B) &amp;&amp; (E &gt;= A) &amp;&amp; (G &gt;= C) &amp;&amp; (H &lt;= D)) &#123; //overlapping bottom right corner area3 = (H - B)*(C - E); &#125; else if (((C - A) &lt;= (G - E)) &amp;&amp; (H &lt;= D) &amp;&amp; (G &gt;= C) &amp;&amp; (E &lt;= A) &amp;&amp; (F &lt;= B)) &#123; //overlapping bottom side area3 = (C - A)*(H - B); &#125; else if (((C - A) &lt;= (G - E)) &amp;&amp; (H &gt;= D) &amp;&amp; (G &gt;= C) &amp;&amp; (E &lt;= A) &amp;&amp; (F &gt;= B)) &#123; //overlapping top side area3 = (C - A)*(D - F); &#125; else if (((D - B) &lt;= (H - F)) &amp;&amp; (E &lt;= A) &amp;&amp; (F &lt;= B) &amp;&amp; (H &gt;= D) &amp;&amp; (G &lt;= C)) &#123; //overlapping left side area3 = (G - A)*(D - B); &#125; else if (((D - B) &lt;= (H - F)) &amp;&amp; (E &gt;= A) &amp;&amp; (F &lt;= B) &amp;&amp; (H &gt;= D) &amp;&amp; (G &gt;= C)) &#123; //overlapping right side area3 = (C - E)*(D - B); &#125; else if (((C - A) &gt;= (G - E)) &amp;&amp; (E &gt;= A) &amp;&amp; (F &gt;= B) &amp;&amp; (C &gt;= G) &amp;&amp; (D &lt;= H)) &#123; //overlapping part of top side area3 = (G - E)*(D - F); &#125; else if (((C - A) &gt;= (G - E)) &amp;&amp; (A &lt;= E) &amp;&amp; (B &gt;= F) &amp;&amp; (G &lt;= C) &amp;&amp; (D &gt;= H)) &#123; //overlapping part of bottom side area3 = (G - E)*(H - B); &#125; else if (((D - B) &gt;= (H - F)) &amp;&amp; (E &lt;= A) &amp;&amp; (F &gt;= B) &amp;&amp; (G &lt;= C) &amp;&amp; (H &lt;= D)) &#123; //overlapping part of left side area3 = (G - A)*(H - F); &#125; else if (((D - B) &gt;= (H - F)) &amp;&amp; (E &gt;= A) &amp;&amp; (F &gt;= B) &amp;&amp; (G &gt;= C) &amp;&amp; (H &lt;= D)) &#123; //overlapping part of right side area3 = (C - E)*(H - F); &#125; else if (((G - E) &lt;= (C - A)) &amp;&amp; (E &gt;= A) &amp;&amp; (F &lt;= B) &amp;&amp; (G &lt;= C) &amp;&amp; (H &gt;= D)) &#123; //overlapping top and bottom area3 = (G - E)*(D - B); &#125; else if (((H - F) &lt;= (D - B)) &amp;&amp; (E &lt;= A) &amp;&amp; (F &gt;= B) &amp;&amp; (C &lt;= G) &amp;&amp; (D &gt;= H)) &#123; //overlapping left and right area3 = (C - A)*(H - F); &#125; return (area1 + area2 - area3); &#125;&#125;; pythonsolution 1: 136ms, 58.33%, 16 July 2016 https://discuss.leetcode.com/topic/22452/python-concise-solution 123456789101112131415class Solution(object): def computeArea(self, A, B, C, D, E, F, G, H): &quot;&quot;&quot; :type A: int :type B: int :type C: int :type D: int :type E: int :type F: int :type G: int :type H: int :rtype: int &quot;&quot;&quot; overlap = max(min(C, G) - max(A, E), 0) * max(min(D, H) - max(B, F), 0) return (A - C) * (B - D) + (E - G) * (F - H) - overlap javasolution 1: 5ms, 14.77%, 16 July 2016 https://discuss.leetcode.com/topic/15733/my-java-solution-sum-of-areas-overlapped-area 1234567891011121314151617public class Solution &#123; public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int areaOfSqrA = (C - A) * (D - B); int areaOfSqrB = (G - E) * (H - F); int left = Math.max(A, E); int right = Math.min(G, C); int bottom = Math.max(F, B); int top = Math.min(D, H); int overlap = 0; if(right &gt; left &amp;&amp; top &gt; bottom) overlap = (right - left) * (top - bottom); return areaOfSqrA + areaOfSqrB - overlap; &#125;&#125; solution 2: 6ms, 6.25%, 16 July 2016 https://discuss.leetcode.com/topic/17705/just-another-short-way 1234567public class Solution &#123; public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int left = Math.max(A, E), right = Math.max(Math.min(C, G), left); int bottom = Math.max(B, F), top = Math.max(Math.min(D, H), bottom); return (C - A) * (D - B) - (right - left) * (top - bottom) + (G - E) * (H - F); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[222. Count Complete Tree Nodes]]></title>
    <url>%2Fp%2Fada3754a%2F</url>
    <content type="text"><![CDATA[27.1% Given a complete binary tree, count the number of nodes. Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. æ–¹æ³•ä¸€ï¼š æœ¬é¢˜æ˜¯æ±‚å®Œå…¨äºŒå‰æ ‘èŠ‚ç‚¹çš„ä¸ªæ•°ã€‚å®Œå…¨äºŒå‰æ ‘ï¼Œå°±æ˜¯å¦‚æžœæ·±åº¦ä¸ºdï¼Œé‚£ä¹ˆd-1å±‚è‡³0å±‚éƒ½æ˜¯æ»¡äºŒå‰æ ‘ï¼Œdå±‚ä»Žå·¦å‘å³æŽ’åˆ—ã€‚å®Œå…¨äºŒå‰æ ‘ï¼Œå°±æ˜¯då±‚æ˜¯æ»¡çš„ã€‚ é«˜åº¦ä¸ºhçš„å®Œå…¨äºŒå‰æ ‘ï¼ŒèŠ‚ç‚¹æ•°ä¸º12^h - 1 ï¼Œå¦‚æžœå®Œå…¨äºŒå‰æ ‘æ˜¯æ»¡äºŒå‰æ ‘ï¼Œå°±åªè¿™ä¸ªç»“æžœã€‚å¦‚æžœä¸æ˜¯ï¼Œå°±é€’å½’ï¼Œä¸¤ä¸ªç›¸åŠ ã€‚ æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; if(!root) return 0; int hl = 0, hr = 0; TreeNode* left = root, * right = root; while(left)&#123; hl++; left = left-&gt;left; &#125; while(right)&#123; hr++; right = right-&gt;right; &#125; if(hl == hr) return pow(2, hl)-1; return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right); &#125;&#125;; https://discuss.leetcode.com/topic/15515/easy-short-c-recursive-solution Easy short c++ recursive solution 1234567891011121314151617181920212223class Solution &#123;public: int countNodes(TreeNode* root) &#123; if(!root) return 0; int hl=0, hr=0; TreeNode *l=root, *r=root; while(l) &#123;hl++;l=l-&gt;left;&#125; while(r) &#123;hr++;r=r-&gt;right;&#125; if(hl==hr) return pow(2,hl)-1; return 1+countNodes(root-&gt;left)+countNodes(root-&gt;right); &#125;&#125;; https://discuss.leetcode.com/topic/31457/a-very-clear-recursive-solution-isn-t-it A very clear recursive solution, isnâ€™t it? 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; if(!root) return 0; int lh = height(root-&gt;left); int rh = height(root-&gt;right); if(lh == rh) return (1 &lt;&lt; lh) + countNodes(root-&gt;right); /*1(æ ¹èŠ‚ç‚¹) + (1&lt;&lt;lh)-1(å®Œå…¨å·¦å­æ ‘) + # of rightNode */ else return (1 &lt;&lt; rh) + countNodes(root-&gt;left); /*1(æ ¹èŠ‚ç‚¹) + (1&lt;&lt;rh)-1(å®Œå…¨å³å­æ ‘) + # of leftNode*/ &#125;private: int height(TreeNode *root)&#123; //get the height of a complete binary tree. if(!root) return 0; return 1 + height(root-&gt;left); &#125;&#125;; https://discuss.leetcode.com/topic/19215/simple-c-recursive-solution Simple C++ recursive solution 1234567891011121314151617181920int getLeftHeight(TreeNode* root) &#123; int height = 0; while(root) &#123; root = root-&gt;left; height++; &#125; return height;&#125;int countNodes(TreeNode* root) &#123; if(!root) return 0; int left_height = getLeftHeight(root-&gt;left); int right_height = getLeftHeight(root-&gt;right); if(left_height == right_height) return pow(2, left_height) + countNodes(root-&gt;right); return pow(2, right_height) + countNodes(root-&gt;left);&#125; https://discuss.leetcode.com/topic/23830/68ms-c-solution-using-binary-search-with-brief-explanation 68ms C++ solution using binary search with brief explanation. The thought is simple. We just consider the lowest level of the tree. The left child and right child just divide the tree lower than the current node to 2 part. So what this code do is first check the right most child of the current nodeâ€™s left child. If this child is exist, we know that there may be more nodes on the right side of the tree. So we move the current node to itâ€™s right child. And repeat until we reach the lowest level. 123456789101112131415161718192021222324int countNodes(TreeNode* root) &#123; if(!root) return 0; TreeNode *temp = root; int height = 0, count = 0, level; while(temp) &#123; temp = temp-&gt;left; height ++; &#125; temp = root; level = height - 2; while(level &gt;= 0) &#123; TreeNode *left = temp-&gt;left; for(int i = 0;i &lt; level;i ++) &#123; left = left-&gt;right; &#125; if(left) &#123; temp = temp-&gt;right; count += (1 &lt;&lt; level); &#125; else temp = temp-&gt;left; level --; &#125; if(temp) count ++; return (1 &lt;&lt; (height - 1)) + count - 1;&#125; https://discuss.leetcode.com/topic/17971/my-python-solution-in-o-lgn-lgn-time My python solution in O(lgn * lgn) time compare the depth between left sub tree and right sub tree. A, If it is equal, it means the left sub tree is a full binary tree B, It it is not , it means the right sub tree is a full binary tree 1234567891011121314151617class Solution: # @param &#123;TreeNode&#125; root # @return &#123;integer&#125; def countNodes(self, root): if not root: return 0 leftDepth = self.getDepth(root.left) rightDepth = self.getDepth(root.right) if leftDepth == rightDepth: return pow(2, leftDepth) + self.countNodes(root.right) else: return pow(2, rightDepth) + self.countNodes(root.left) def getDepth(self, root): if not root: return 0 return 1 + self.getDepth(root.left)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[221. Maximal Square]]></title>
    <url>%2Fp%2F9ceb5f12%2F</url>
    <content type="text"><![CDATA[27.8% https://leetcode.com/problems/maximal-square/ Given a 2D binary matrix filled with 0â€™s and 1â€™s, find the largest square containing only 1â€™s and return its area. 1234567For example, given the following matrix:1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Return 4. éœ€è¦æ€è€ƒ https://discuss.leetcode.com/topic/15328/easy-dp-solution-in-c-with-detailed-explanations-8ms-o-n-2-time-and-o-n-space Easy DP solution in C++ with detailed explanations (8ms, O(n^2) time and O(n) space) Well, this problem desires for the use of dynamic programming. They key to any DP problem is to come up with the state equation. In this problem, we define the state to be the maximal size of the square that can be achieved at point (i, j), denoted as P[i][j]. Remember that we use size instead of square as the state (square = size^2). Now letâ€™s try to come up with the formula for P[i][j]. First, it is obvious that for the topmost row (i = 0) and the leftmost column (j = 0), P[i][j] = matrix[i][j]. This is easily understood. Letâ€™s suppose that the topmost row of matrix is like [1, 0, 0, 1]. Then we can immediately know that the first and last point can be a square of size 1 while the two middle points cannot make any square, giving a size of 0. Thus, P = [1, 0, 0, 1], which is the same as matrix. The case is similar for the leftmost column. Till now, the boundary conditions of this DP problem are solved. Letâ€™s move to the more general case for P[i][j] in which i &gt; 0 and j &gt; 0. First of all, letâ€™s see another simple case in which matrix[i][j] = 0. It is obvious that P[i][j] = 0 too. Why? Well, since matrix[i][j] = 0, no square will contain matrix[i][j]. According to our definition of P[i][j], P[i][j] is also 0. Now we are almost done. The only unsolved case is matrix[i][j] = 1. Letâ€™s see an example. Suppose matrix = [[0, 1], [1, 1]], it is obvious that P[0][0] = 0, P[0][1] = P[1][0] = 1, what about P[1][1]? Well, to give a square of size larger than 1 in P[1][1], all of its three neighbors (left, up, left-up) should be non-zero, right? In this case, the left-up neighbor P[0][0] = 0, so P[1][1] can only be 1, which means that it contains the square of itself. Now you are near the solution. In fact, P[i][j] = min(P[i - 1][j], P[i][j - 1], P[i - 1][j - 1]) + 1 in this case. Taking all these together, we have the following state equations. P[0][j] = matrix[0][j] (topmost row); P[i][0] = matrix[i][0] (leftmost column); For i &gt; 0 and j &gt; 0: if matrix[i][j] = 0, P[i][j] = 0; if matrix[i][j] = 1, P[i][j] = min(P[i - 1][j], P[i][j - 1], P[i - 1][j - 1]) + 1. Putting them into codes, and maintain a variable maxsize to record the maximum size of the square we have seen, we have the following (unoptimized) solution. 123456789101112131415161718192021222324int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; int m = matrix.size(); if (!m) return 0; int n = matrix[0].size(); vector&lt;vector&lt;int&gt; &gt; size(m, vector&lt;int&gt;(n, 0)); int maxsize = 0; for (int j = 0; j &lt; n; j++) &#123; size[0][j] = matrix[0][j] - &apos;0&apos;; maxsize = max(maxsize, size[0][j]); &#125; for (int i = 1; i &lt; m; i++) &#123; size[i][0] = matrix[i][0] - &apos;0&apos;; maxsize = max(maxsize, size[i][0]); &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (matrix[i][j] == &apos;1&apos;) &#123; size[i][j] = min(size[i - 1][j - 1], min(size[i - 1][j], size[i][j - 1])) + 1; maxsize = max(maxsize, size[i][j]); &#125; &#125; &#125; return maxsize * maxsize;&#125; Now letâ€™s try to optimize the above solution. As can be seen, each time when we update size[i][j], we only need size[i][j - 1], size[i - 1][j - 1] (at the previous left column) and size[i - 1][j] (at the current column). So we do not need to maintain the full m*n matrix. In fact, keeping two columns is enough. Now we have the following optimized solution. 12345678910111213141516171819202122232425int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; int m = matrix.size(); if (!m) return 0; int n = matrix[0].size(); vector&lt;int&gt; pre(m, 0); vector&lt;int&gt; cur(m, 0); int maxsize = 0; for (int i = 0; i &lt; m; i++) &#123; pre[i] = matrix[i][0] - &apos;0&apos;; maxsize = max(maxsize, pre[i]); &#125; for (int j = 1; j &lt; n; j++) &#123; cur[0] = matrix[0][j] - &apos;0&apos;; maxsize = max(maxsize, cur[0]); for (int i = 1; i &lt; m; i++) &#123; if (matrix[i][j] == &apos;1&apos;) &#123; cur[i] = min(cur[i - 1], min(pre[i - 1], pre[i])) + 1; maxsize = max(maxsize, cur[i]); &#125; &#125; swap(pre, cur); fill(cur.begin(), cur.end(), 0); &#125; return maxsize * maxsize;&#125; Now you see the solution is finished? In fact, it can still be optimized! In fact, we need not maintain two vectors and one is enough. If you want to explore this idea, please refer to the answers provided by @stellari below. Moreover, in the code above, we distinguish between the 0-th row and other rows since the 0-th row has no row above it. In fact, we can make all the m rows the same by padding a 0 row on the top (in the following code, we pad a 0 on top of dp). Finally, we will have the following short code :) If you find it hard to understand, try to run it using your pen and paper and notice how it realizes what the two-vector solution does using only one vector. 123456789101112131415161718int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return 0; int m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; dp(m + 1, 0); int maxsize = 0, pre = 0; for (int j = 0; j &lt; n; j++) &#123; for (int i = 1; i &lt;= m; i++) &#123; int temp = dp[i]; if (matrix[i - 1][j] == &apos;1&apos;) &#123; dp[i] = min(dp[i], min(dp[i - 1], pre)) + 1; maxsize = max(maxsize, dp[i]); &#125; else dp[i] = 0; pre = temp; &#125; &#125; return maxsize * maxsize;&#125; This solution, since posted, has been suggested various improvements by kind people. For a more comprehensive collection of the solutions, please visit my technical blog. https://discuss.leetcode.com/topic/22185/clear-c-solution-no-extra-space-12-ms Clear C++ solution, no extra space, 12 ms. A square with â€˜1â€™ means any â€˜0â€™ will interrupt counting of itâ€™s right/down/right-down, and â€˜1â€™ will â€˜inheritâ€™ the existing counting result. Sine the target is a square, we shall take the smallest counting result from up/left/up-left. So for each element â€˜0â€™, it doesnâ€™t inherit previous accumulated counting; And for each element â€˜1â€™, it takes the smallest number from left/up/left-up and add 1 to it 1234567891011121314151617int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; int rst = 0; for(int ii=0; ii&lt;matrix.size(); ++ii) &#123; for(int jj=0; jj&lt;matrix[0].size(); ++jj) &#123; int a = (ii&amp;&amp;jj) ? matrix[ii-1][jj-1] : 0; int b = (ii) ? matrix[ii-1][jj] : 0; int c = (jj) ? matrix[ii][jj-1] : 0; matrix[ii][jj] = (matrix[ii][jj]&gt;&apos;0&apos;) ? (min(a, min(b, c))+1) : 0; rst = max(rst, matrix[ii][jj]*matrix[ii][jj]); &#125; &#125; return rst;&#125; https://discuss.leetcode.com/topic/29332/20-lines-c-solution-using-dynamic-programming 20 lines C++ solution using dynamic programming 12345678910111213141516171819202122class Solution &#123;public:int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.size()==0) return 0; int maxSq=0; int nRow=matrix.size(); int nCol=matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(nRow+1,vector&lt;int&gt;(nCol+1,0)); //dp[i][j] represents max square ending at position (i-1, j-1) for(int i=1;i&lt;=nRow;++i)&#123; for(int j=1;j&lt;=nCol;++j)&#123; if(matrix[i-1][j-1]==&apos;1&apos;)&#123; dp[i][j]=min(min(dp[i-1][j-1],dp[i-1][j]),dp[i][j-1])+1; maxSq=max(maxSq,dp[i][j]); &#125; &#125; &#125; return maxSq*maxSq;&#125;&#125;; https://discuss.leetcode.com/topic/15373/6-lines-visual-explanation-o-mn 6 lines, Visual Explanation, O(mn) Explanation Whatâ€™s the largest (full-of-ones-)square ending at (i,j), meaning lower right corner in row i, column j? Imagine there are 4x4 squares above, above-left and left of it: 1234567above above-left left 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 * * 1111* Clearly, if cell (i,j) itself is 1 as well, then thereâ€™s a 5x5 square ending at (i,j). And if there were 5x5 squares above, above-left and left of it, then weâ€™d have a 6x6. So to find the largest square ending at (i,j), we just take the minimum size of squares ending at (i-1,j), (i-1,j-1) and (i,j-1), and add 1. Implementation - 164 ms I write the maximum sizes directly into the input matrix A. Cell A[i][j] will tell the side length of the largest square ending at (i,j). I go top to bottom and left to right, so (i-1,j), (i-1,j-1) and (i,j-1) have all been handled already. First thing I do for each cell is turn it into an integer, and then if itâ€™s 1 and itâ€™s not on the top or left border of the matrix, I determine its largest-square size as explained above. In the end, I return 0 for the empty matrix and otherwise the area of the largest square ending anywhere. 12345678class Solution: def maximalSquare(self, A): for i in range(len(A)): for j in range(len(A[i])): A[i][j] = int(A[i][j]) if A[i][j] and i and j: A[i][j] = min(A[i-1][j], A[i-1][j-1], A[i][j-1]) + 1 return len(A) and max(map(max, A)) ** 2 Smaller Version - 132 ms This version is a bit smaller and faster due to using more of Python and some â€œtricksâ€: 12345678class Solution: def maximalSquare(self, A): for i, r in enumerate(A): r = A[i] = map(int, r) for j, c in enumerate(r): if i * j * c: r[j] = min(A[i-1][j], r[j-1], A[i-1][j-1]) + 1 return max(map(max, A + [[0]])) ** 2 O(n) Extra Space - 128 ms Hereâ€™s a version that doesnâ€™t overwrite the input matrix but uses two integer lists: s tells the sizes of the squares ending it the current row and p does the same for the previous row. 123456789101112class Solution: def maximalSquare(self, A): area = 0 if A: p = [0] * len(A[0]) for row in A: s = map(int, row) for j, c in enumerate(s[1:], 1): s[j] *= min(p[j-1], p[j], s[j-1]) + 1 area = max(area, max(s) ** 2) p = s return area Note that in Python with its integer and string objects, Iâ€™m not sure this actually saves space. But in other languages, overwriting the input array might not even be possible, and if itâ€™s possible, it might take more space than a â€œO(n) Extra Spaceâ€ variant. https://discuss.leetcode.com/topic/15381/my-c-code-8ms-dp-o-n-2-time-o-n-space My C++ code, 8ms (DP, O(n^2)time, O(n) space) The basic idea is to do DP: scan the matrix row by row (top down) and colume by colume (left to right) and for the position [i][j], the maximum square with the bottom-right corner sitting at [i][j] will have the edge length of 12area[i][j] = 0 if matrix[i][j] = &apos;0&apos; = min(area[i-1][j-1], area[i][j-1], area[i-1][j]) + 1 if matrix[i][j] = &apos;1&apos; For the case that matrix[i][j] = â€˜1â€™, the algorithm tries to grow the square sitting at [i-1][j-1], area[i-1][j-1] by 1. However, it is also limitted by the bottom edge at row i and right edge at col j, which was represented by area[i][j-1] and area[i-1][j] repectively. We have to choose the min of those three values. The DP table works on a ping-pong mode to save memory since the area recursive equation only relys on i and i-1 rows. 1234567891011121314151617181920212223242526class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; int maxA = 0; const int m = matrix.size(); if(!m) return maxA; const int n = matrix[0].size(); if(!n) return maxA; int area[2][n]; // DP table to save the maximum square (with bottom-right corner at [i][j]) edge length int cur = 0, next =1; // ping-pog switch index fill_n(area[0],n,0); int i, j; for(i=0;i&lt;m;i++) &#123; area[next][0] = matrix[i][0] == &apos;1&apos;; // the first colume for(j=1; j&lt;n; j++) area[next][j] = matrix[i][j]==&apos;1&apos;? (min(area[cur][j-1],min(area[next][j-1],area[cur][j])) + 1):0; //DP update for(j=0; j&lt;n &amp;&amp; maxA&lt;=i; j++) if(maxA&lt;area[next][j]) maxA = area[next][j]; // find the maximum square for the current row cur = next; next = 1-cur; &#125; return maxA * maxA; &#125;&#125;; https://discuss.leetcode.com/topic/16851/share-my-concise-python-solution Share my concise python solution 123456789101112131415class Solution:# @param &#123;character[][]&#125; matrix# @return &#123;integer&#125;def maximalSquare(self, matrix): if not matrix: return 0 m , n = len(matrix),len(matrix[0]) dp = [[0 if matrix[i][j]==&apos;0&apos; else 1for j in xrange(n)]for i in xrange(m)] for i in xrange(1,m): for j in xrange(1,n): if matrix[i][j] ==&apos;1&apos;: dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1 else: dp[i][j] = 0 ans = max([max(i) for i in dp]) return ans ** 2]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[220. Contains Duplicate III]]></title>
    <url>%2Fp%2F86f6637a%2F</url>
    <content type="text"><![CDATA[19.3% https://leetcode.com/problems/contains-duplicate-iii/?tab=Description Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. éœ€è¦æ€è€ƒ æ–¹æ³•ä¸€ï¼š å› ä¸ºéœ€è¦æœ‰åºï¼Œæ‰€ä»¥ä½¿ç”¨çš„setï¼Œsetä¹Ÿæœ‰lower_boundç›¸å…³å‡½æ•° å­¦ä¹ setï¼ŒæŽ’åºçš„setï¼Œå­¦ä¹ low_boundå‡½æ•°ä½¿ç”¨ æ¯”è¾ƒç›´æŽ¥ï¼Œä½¿ç”¨äº†lower_bound, upper_bound å¦‚æžœè¦å­˜åœ¨ï¼Œè‚¯å®šåœ¨ä¸¤è€…ä¹‹é—´ æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021class Solution &#123;public: bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123; if(nums.empty() || k&lt;=0 || t&lt;0) return false; // å¯¹äºŽintï¼Œç»å¸¸å‡ºçŽ°æº¢å‡ºï¼Œä¸å¦‚long long set&lt;long long&gt; set; for(int i=0; i&lt;nums.size(); i++)&#123; long long num = nums[i]; auto itlow = set.lower_bound(num-t); auto itup = set.upper_bound(num+t); // æ­¤å¤„çš„è¿­ä»£å™¨æ²¡æœ‰ &lt; if(itlow!=itup) return true; set.insert(num); if(set.size()==k+1) set.erase(nums[i-k]); &#125; return false; &#125;&#125;; ä¸‹é¢çš„ç®—æ³•æœ‰ä¸€å®šçš„å…¬å¼æŽ¨å¯¼ï¼Œä½†æ˜¯ä¹Ÿæ¯”è¾ƒç®€å•ï¼ŒåŽŸç†æ˜¯ä¸€è‡´çš„ã€‚ https://discuss.leetcode.com/topic/18453/c-using-set-less-10-lines-with-simple-explanation C++ using set (less 10 lines), with simple explanation. 123456789101112bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123; set&lt;int&gt; window; // set is ordered automatically for (int i = 0; i &lt; nums.size(); i++) &#123; if (i &gt; k) window.erase(nums[i-k-1]); // keep the set contains nums i j at most k // |x - nums[i]| &lt;= t ==&gt; -t &lt;= x - nums[i] &lt;= t; auto pos = window.lower_bound(nums[i] - t); // x-nums[i] &gt;= -t ==&gt; x &gt;= nums[i]-t // x - nums[i] &lt;= t ==&gt; |x - nums[i]| &lt;= t if (pos != window.end() &amp;&amp; *pos - nums[i] &lt;= t) return true; window.insert(nums[i]); &#125; return false;&#125; https://discuss.leetcode.com/topic/15468/i-finally-got-ac-in-c I finally got AC in C++ Using a set container to keep the k+1-length array,which all elements are distinct.Before the containerâ€™s size reached k+1, we just find the first element that is not less than [nums[i]-t] and judge the elementâ€™s value whether it is less than [nums[i]+t]. Starting to move forward by erasing the head and adding element at the backend after the containerâ€™s size reached k+1. The existence of the first element ,which is not less than [nums[i]-t] and less than [nums[i]+t], is the prerequisite of existing other eligible elements. 123456789101112131415161718bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123; if (!k || t&lt;0 || nums.size()&lt;2) return false; set&lt;int&gt;record; auto nLen = nums.size(); for (int i = 0; i &lt; nLen;++i) &#123; if (i&gt;k) record.erase(nums[i - k - 1]); set&lt;int&gt;::iterator lower = record.lower_bound(nums[i] - t); if (lower != record.end() &amp;&amp; abs(nums[i] - *lower) &lt;= t) return true; record.insert(nums[i]); &#125; return false; &#125; https://discuss.leetcode.com/topic/15172/accept-c-solution Accept C++ Solution My idea is to preserve a sliding window containing nearest k numbers, and check if next number collides to the numbers in the window. 123456789101112131415161718192021222324class Solution &#123;public: bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123; if (nums.size() &lt; 2 || k == 0) return false; deque&lt;int&gt; windows_deq; multiset&lt;long&gt; windows; for (int i = 0; i &lt; nums.size(); i++) &#123; if (windows.size() &gt; k) &#123; int num = windows_deq.front(); windows_deq.pop_front(); windows.erase(windows.find(num)); &#125; auto it = windows.lower_bound((long)nums[i] - (long)t); if (it == windows.end() || *it &gt; (long)nums[i] + (long)t) &#123; // not found windows_deq.push_back(nums[i]); windows.insert(nums[i]); &#125; else return true; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/27608/java-python-one-pass-solution-o-n-time-o-n-space-using-buckets The idea is like the bucket sort algorithm. Suppose we have consecutive buckets covering the range of nums with each bucket a width of (t+1). If there are two item with difference &lt;= t, one of the two will happen: 12(1) the two in the same bucket(2) the two in neighbor buckets For detailed explanation see my blog here Python 12345678910111213141516171819202122def containsNearbyAlmostDuplicate(self, nums, k, t): if t &lt; 0: return False n = len(nums) d = &#123;&#125; w = t + 1 for i in xrange(n): m = nums[i] / w if m in d: return True if m - 1 in d and abs(nums[i] - d[m - 1]) &lt; w: return True if m + 1 in d and abs(nums[i] - d[m + 1]) &lt; w: return True d[m] = nums[i] if i &gt;= k: del d[nums[i - k] / w] return False# 30 / 30 test cases passed.# Status: Accepted# Runtime: 56 ms# 93.81% Java 123456789101112131415161718192021private long getID(long i, long w) &#123; return i &lt; 0 ? (i + 1) / w - 1 : i / w;&#125;public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; if (t &lt; 0) return false; Map&lt;Long, Long&gt; d = new HashMap&lt;&gt;(); long w = (long)t + 1; for (int i = 0; i &lt; nums.length; ++i) &#123; long m = getID(nums[i], w); if (d.containsKey(m)) return true; if (d.containsKey(m - 1) &amp;&amp; Math.abs(nums[i] - d.get(m - 1)) &lt; w) return true; if (d.containsKey(m + 1) &amp;&amp; Math.abs(nums[i] - d.get(m + 1)) &lt; w) return true; d.put(m, (long)nums[i]); if (i &gt;= k) d.remove(getID(nums[i - k], w)); &#125; return false;&#125; https://discuss.leetcode.com/topic/19991/o-n-python-using-buckets-with-explanation-10-lines O(n) Python using buckets with explanation, 10 lines. 12345678910111213141516171819def containsNearbyAlmostDuplicate(self, nums, k, t): # Bucket sort. Each bucket has size of t. For each number, the possible # candidate can only be in the same bucket or the two buckets besides. # Keep as many as k buckets to ensure that the difference is at most k. buckets = &#123;&#125; for i, v in enumerate(nums): # t == 0 is a special case where we only have to check the bucket # that v is in. bucketNum, offset = (v / t, 1) if t else (v, 0) for idx in xrange(bucketNum - offset, bucketNum + offset + 1): if idx in buckets and abs(buckets[idx] - nums[i]) &lt;= t: return True buckets[bucketNum] = nums[i] if len(buckets) &gt; k: # Remove the bucket which is too far away. Beware of zero t. del buckets[nums[i - k] / t if t else nums[i - k]] return False https://discuss.leetcode.com/topic/15190/python-ordereddict Python OrderedDict 123456789101112131415class Solution:def containsNearbyAlmostDuplicate(self, nums, k, t): if k &lt; 1 or t &lt; 0: return False dic = collections.OrderedDict() for n in nums: key = n if not t else n // t for m in (dic.get(key - 1), dic.get(key), dic.get(key + 1)): if m is not None and abs(n - m) &lt;= t: return True if len(dic) == k: dic.popitem(False) dic[key] = n return False java https://discuss.leetcode.com/topic/15199/ac-o-n-solution-in-java-using-buckets-with-explanation AC O(N) solution in Java using buckets with explanation As a followup question, it naturally also requires maintaining a window of size k. When t == 0, it reduces to the previous question so we just reuse the solution. Since there is now a constraint on the range of the values of the elements to be considered duplicates, it reminds us of doing a range check which is implemented in tree data structure and would take O(LogN) if a balanced tree structure is used, or doing a bucket check which is constant time. We shall just discuss the idea using bucket here. Bucketing means we map a range of values to the a bucket. For example, if the bucket size is 3, we consider 0, 1, 2 all map to the same bucket. However, if t == 3, (0, 3) is a considered duplicates but does not map to the same bucket. This is fine since we are checking the buckets immediately before and after as well. So, as a rule of thumb, just make sure the size of the bucket is reasonable such that elements having the same bucket is immediately considered duplicates or duplicates must lie within adjacent buckets. So this actually gives us a range of possible bucket size, i.e. t and t + 1. We just choose it to be t and a bucket mapping to be num / t. Another complication is that negative ints are allowed. A simple num / t just shrinks everything towards 0. Therefore, we can just reposition every element to start from Integer.MIN_VALUE. 1234567891011121314151617181920public class Solution &#123; public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; if (k &lt; 1 || t &lt; 0) return false; Map&lt;Long, Long&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; long remappedNum = (long) nums[i] - Integer.MIN_VALUE; long bucket = remappedNum / ((long) t + 1); if (map.containsKey(bucket) || (map.containsKey(bucket - 1) &amp;&amp; remappedNum - map.get(bucket - 1) &lt;= t) || (map.containsKey(bucket + 1) &amp;&amp; map.get(bucket + 1) - remappedNum &lt;= t)) return true; if (map.entrySet().size() &gt;= k) &#123; long lastBucket = ((long) nums[i - k] - Integer.MIN_VALUE) / ((long) t + 1); map.remove(lastBucket); &#125; map.put(bucket, remappedNum); &#125; return false; &#125;&#125; Edits: Actually, we can use t + 1 as the bucket size to get rid of the case when t == 0. It simplifies the code. The above code is therefore the updated version. https://discuss.leetcode.com/topic/15191/java-o-n-lg-k-solution Java O(N lg K) solution This problem requires to maintain a window of size k of the previous values that can be queried for value ranges. The best data structure to do that is Binary Search Tree. As a result maintaining the tree of size k will result in time complexity O(N lg K). In order to check if there exists any value of range abs(nums[i] - nums[j]) to simple queries can be executed both of time complexity O(lg K) Here is the whole solution using TreeMap. 12345678910111213141516171819202122232425public class Solution &#123; public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; if (nums == null || nums.length == 0 || k &lt;= 0) &#123; return false; &#125; final TreeSet&lt;Integer&gt; values = new TreeSet&lt;&gt;(); for (int ind = 0; ind &lt; nums.length; ind++) &#123; final Integer floor = values.floor(nums[ind] + t); final Integer ceil = values.ceiling(nums[ind] - t); if ((floor != null &amp;&amp; floor &gt;= nums[ind]) || (ceil != null &amp;&amp; ceil &lt;= nums[ind])) &#123; return true; &#125; values.add(nums[ind]); if (ind &gt;= k) &#123; values.remove(nums[ind - k]); &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>binary search tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[219. Contains Duplicate II]]></title>
    <url>%2Fp%2F4c1e3175%2F</url>
    <content type="text"><![CDATA[31.8% https://leetcode.com/problems/contains-duplicate-ii/ Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. æ–¹æ³•ä¸€ï¼š ä½¿ç”¨unordered_setï¼Œå‡½æ•°erase, insert æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415class Solution &#123;public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123; if(k==0 || nums.empty()) return false; unordered_set&lt;int&gt; set; for(int i=0; i&lt;nums.size(); i++)&#123; if(set.find(nums[i])!=set.end()) return true; set.insert(nums[i]); if(set.size()==k+1) set.erase(nums[i-k]); &#125; return false; &#125;&#125;; 32ms, 47.64%, May.6th, 2016 https://leetcode.com/discuss/37851/c-solution-with-unordered_set 12345678910111213141516class Solution &#123;public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_set&lt;int&gt; s; if(k &lt;= 0) return false; if(k &gt;= nums.size()) k = nums.size() - 1; for(int i = 0; i &lt; nums.size(); i++)&#123; if(i &gt; k) s.erase(nums[i - k - 1]); if(s.find(nums[i]) != s.end()) return true; s.insert(nums[i]); &#125; return false; &#125;&#125;; python 52ms, 56.23%, May.6th, 2016 https://leetcode.com/discuss/54123/python-concise-solution-with-dictionary 12345678910111213class Solution(object): def containsNearbyDuplicate(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: bool &quot;&quot;&quot; dic = &#123;&#125; for i, v in enumerate(nums): if v in dic and i - dic[v] &lt;= k: return True dic[v] = i return False java 13ms, 44.06%, May.6th, 2016 https://leetcode.com/discuss/38445/simple-java-solution 12345678910public class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; if(i &gt; k) set.remove(nums[i-k-1]); if(!set.add(nums[i])) return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[218. The Skyline Problem]]></title>
    <url>%2Fp%2Fb0846169%2F</url>
    <content type="text"><![CDATA[26.2% https://leetcode.com/problems/the-skyline-problem/?tab=Description A cityâ€™s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B). The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 â‰¤ Li, Ri â‰¤ INT_MAX, 0 &lt; Hi â‰¤ INT_MAX, and Ri - Li &gt; 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] . The output is a list of â€œkey pointsâ€ (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], â€¦ ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour. For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]. Notes: The number of buildings in any input list is guaranteed to be in the range [0, 10000]. The input list is already sorted in ascending order by the left x position Li. The output list must be sorted by the x position. There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [â€¦[2 3], [4 5], [7 5], [11 5], [12 7]â€¦] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [â€¦[2 3], [4 5], [12 7], â€¦] éœ€è¦æ€è€ƒ æ–¹æ³•ä¸€ï¼š https://discuss.leetcode.com/topic/39416/guaranteed-really-detailed-and-good-perfect-explanation-of-the-skyline-problem https://briangordon.github.io/2014/08/the-skyline-problem.html https://discuss.leetcode.com/topic/14939/my-c-code-using-one-priority-queue-812-ms My C++ code using one priority queue (812 ms) The idea is to do line sweep and just process the buildings only at the start and end points. The key is to use a priority queue to save all the buildings that are still â€œaliveâ€. The queue is sorted by its height and end time (the larger height first and if equal height, the one with a bigger end time first). For each iteration, we first find the current process time, which is either the next new building start time or the end time of the top entry of the live queue. If the new building start time is larger than the top one end time, then process the one in the queue first (pop them until it is empty or find the first one that ends after the new building); otherswise, if the new building starts before the top one ends, then process the new building (just put them in the queue). After processing, output it to the resulting vector if the height changes. Complexity is the worst case O(NlogN) Not sure why my algorithm is so slow considering othersâ€™ Python solution can achieve 160ms, any commments? 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123; vector&lt;pair&lt;int, int&gt;&gt; res; int cur=0, cur_X, cur_H =-1, len = buildings.size(); priority_queue&lt; pair&lt;int, int&gt;&gt; liveBlg; // first: height, second, end time while(cur&lt;len || !liveBlg.empty()) &#123; // if either some new building is not processed or live building queue is not empty cur_X = liveBlg.empty()? buildings[cur][0]:liveBlg.top().second; // next timing point to process if(cur&gt;=len || buildings[cur][0] &gt; cur_X) &#123; //first check if the current tallest building will end before the next timing point // pop up the processed buildings, i.e. those have height no larger than cur_H and end before the top one while(!liveBlg.empty() &amp;&amp; ( liveBlg.top().second &lt;= cur_X) ) liveBlg.pop(); &#125; else &#123; // if the next new building starts before the top one ends, process the new building in the vector cur_X = buildings[cur][0]; while(cur&lt;len &amp;&amp; buildings[cur][0]== cur_X) // go through all the new buildings that starts at the same point &#123; // just push them in the queue liveBlg.push(make_pair(buildings[cur][2], buildings[cur][1])); cur++; &#125; &#125; cur_H = liveBlg.empty()?0:liveBlg.top().first; // outut the top one if(res.empty() || (res.back().second != cur_H) ) res.push_back(make_pair(cur_X, cur_H)); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/14939/my-c-code-using-one-priority-queue-812-ms/2 Very nice idea, keeping smaller buildings alive under larger ones even though they ended already. You have a few unnecessary things, though. If Iâ€™m not mistaken, mycompare just does the default ordering, vector is the default container for priority_queue, the if(len&gt;0) doesnâ€™t help, and you donâ€™t need a private section. I think removing that stuff would make your solution even better than it already is. About Python being faster: Yeah thatâ€™s right, Python is faster now. Deal with it :-P. More seriously, hereâ€™s the probable explanation. https://discuss.leetcode.com/topic/16511/share-my-divide-and-conquer-java-solution-464-ms Share my divide and conquer java solution, 464 ms Detailed explanation: http://www.geeksforgeeks.org/divide-and-conquer-set-7-the-skyline-problem/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Solution &#123; public List&lt;int[]&gt; getSkyline(int[][] buildings) &#123; if (buildings.length == 0) return new LinkedList&lt;int[]&gt;(); return recurSkyline(buildings, 0, buildings.length - 1); &#125; private LinkedList&lt;int[]&gt; recurSkyline(int[][] buildings, int p, int q) &#123; if (p &lt; q) &#123; int mid = p + (q - p) / 2; return merge(recurSkyline(buildings, p, mid), recurSkyline(buildings, mid + 1, q)); &#125; else &#123; LinkedList&lt;int[]&gt; rs = new LinkedList&lt;int[]&gt;(); rs.add(new int[] &#123; buildings[p][0], buildings[p][2] &#125;); rs.add(new int[] &#123; buildings[p][1], 0 &#125;); return rs; &#125; &#125; private LinkedList&lt;int[]&gt; merge(LinkedList&lt;int[]&gt; l1, LinkedList&lt;int[]&gt; l2) &#123; LinkedList&lt;int[]&gt; rs = new LinkedList&lt;int[]&gt;(); int h1 = 0, h2 = 0; while (l1.size() &gt; 0 &amp;&amp; l2.size() &gt; 0) &#123; int x = 0, h = 0; if (l1.getFirst()[0] &lt; l2.getFirst()[0]) &#123; x = l1.getFirst()[0]; h1 = l1.getFirst()[1]; h = Math.max(h1, h2); l1.removeFirst(); &#125; else if (l1.getFirst()[0] &gt; l2.getFirst()[0]) &#123; x = l2.getFirst()[0]; h2 = l2.getFirst()[1]; h = Math.max(h1, h2); l2.removeFirst(); &#125; else &#123; x = l1.getFirst()[0]; h1 = l1.getFirst()[1]; h2 = l2.getFirst()[1]; h = Math.max(h1, h2); l1.removeFirst(); l2.removeFirst(); &#125; if (rs.size() == 0 || h != rs.getLast()[1]) &#123; rs.add(new int[] &#123; x, h &#125;); &#125; &#125; rs.addAll(l1); rs.addAll(l2); return rs; &#125;&#125; https://discuss.leetcode.com/topic/25794/17-line-o-n-log-n-time-o-n-space-c-accepted-easy-solution-w-explanations 17-Line O(n log n)-time O(n)-space C++ Accepted Easy Solution w/ Explanations General idea: Step 1: Use a multimap to sort all boundary points. For a start point of an interval, let the height be positive; otherwise, let the height be negative. Time complexity: O(n log n) Step 2: Use a multiset (rather than a heap/priority_queue) to maintain the current set of heights to be considered. If a new start point is met, insert the height into the set, otherwise, delete the height. The current max height is the back() element of the multiset. For each point, the time complexity is O(log n). The overall time complexity is O(n log n). Step 3: Delete the points with equal heights. Time: O(n) Time Complexity: O(n log n) Space Complexity: O(n) C++ 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123; // Step 1: multimap&lt;int, int&gt; coords; for (const vector&lt;int&gt; &amp; building : buildings) &#123; coords.emplace(building[0], building[2]); coords.emplace(building[1], -building[2]); &#125; // Step 2: multiset&lt;int&gt; heights = &#123; 0 &#125;; map&lt;int, int&gt; corners; for (const pair&lt;int, int&gt; &amp; p : coords) &#123; if (p.second &gt; 0) &#123; heights.insert(p.second); &#125; else &#123; heights.erase(heights.find(-p.second)); &#125; int cur_y = *heights.rbegin(); corners[p.first] = cur_y; &#125; // Step 3: function&lt;bool(pair&lt;int, int&gt; l, pair&lt;int, int&gt; r)&gt; eq2nd = [](pair&lt;int, int&gt; l, pair&lt;int, int&gt; r)&#123; return l.second == r.second; &#125;; vector&lt;pair&lt;int, int&gt;&gt; results; unique_copy(corners.begin(), corners.end(), back_insert_iterator&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;(results), eq2nd); return results; &#125;&#125;; In fact, the last two steps can be merged together: Yet another solution (C++): 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123; multimap&lt;int, int&gt; coords; for (const vector&lt;int&gt; &amp; building : buildings) &#123; coords.emplace(building[0], building[2]); coords.emplace(building[1], -building[2]); &#125; multiset&lt;int&gt; heights = &#123; 0 &#125;; vector&lt;pair&lt;int, int&gt;&gt; corners; int x = -1; int y = 0; for (const pair&lt;int, int&gt; &amp; p : coords) &#123; if ((x &gt;= 0) &amp;&amp; (p.first != x) &amp;&amp; (corners.empty() || (corners.rbegin()-&gt;second != y))) &#123; corners.emplace_back(x, y); &#125; if (p.second &gt;= 0) &#123; heights.insert(p.second); &#125; else &#123; heights.erase(heights.find(-p.second)); &#125; x = p.first; y = *heights.rbegin(); &#125; if (!corners.empty()) &#123; corners.emplace_back(x, 0); &#125; return corners; &#125;&#125;; https://discuss.leetcode.com/topic/14987/108-ms-17-lines-body-explained 108 ms, 17 lines body, explained This is a Python version of my modification of dong.wang.1694â€™s brilliant C++ solution. It sweeps from left to right. But it doesnâ€™t only keep heights of â€œalive buildingsâ€ in the priority queue and it doesnâ€™t remove them as soon as their building is left behind. Instead, (height, right) pairs are kept in the priority queue and they stay in there as long as thereâ€™s a larger height in there, not just until their building is left behind. In each loop, we first check what has the smaller x-coordinate: adding the next building from the input, or removing the next building from the queue. In case of a tie, adding buildings wins, as that guarantees correctness (think about it :-). We then either add all input buildings starting at that x-coordinate or we remove all queued buildings ending at that x-coordinate or earlier (remember we keep buildings in the queue as long as theyâ€™re â€œunder the roofâ€ of a larger actually alive building). And then, if the current maximum height in the queue differs from the last in the skyline, we add it to the skyline. 123456789101112131415161718192021from heapq import *class Solution: def getSkyline(self, LRH): skyline = [] i, n = 0, len(LRH) liveHR = [] while i &lt; n or liveHR: if not liveHR or i &lt; n and LRH[i][0] &lt;= -liveHR[0][1]: x = LRH[i][0] while i &lt; n and LRH[i][0] == x: heappush(liveHR, (-LRH[i][2], -LRH[i][1])) i += 1 else: x = -liveHR[0][1] while liveHR and -liveHR[0][1] &lt;= x: heappop(liveHR) height = len(liveHR) and -liveHR[0][0] if not skyline or height != skyline[-1][1]: skyline += [x, height], return skyline https://discuss.leetcode.com/topic/35817/recommend-for-beginners-clean-c-implementation-with-detailed-explanation [recommend for beginners]clean C++ implementation with detailed explanation 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123; vector&lt;pair&lt;int, int&gt;&gt; edges; int left, right, height; for(int i=0; i&lt;buildings.size(); i++)&#123; left=buildings[i][0]; right=buildings[i][1]; height=buildings[i][2]; /*** make sure : for the same left point we use the bigger height ***/ edges.push_back(make_pair(left, -height)); edges.push_back(make_pair(right, height)); &#125; sort(edges.begin(), edges.end()); vector&lt;pair&lt;int, int&gt;&gt; result; /*** use the multiset to store the max height util current pos ***/ multiset&lt;int&gt; m; /*** left most height ***/ m.insert(0); int pre=0, cur=0; for(int i=0; i&lt;edges.size(); i++)&#123; pair&lt;int, int&gt; e=edges[i]; if(e.second &lt; 0) m.insert(-e.second); else m.erase(m.find(e.second)); cur=*(m.rbegin()); if(cur!=pre)&#123; result.push_back(make_pair(e.first, cur)); pre=cur; &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/26420/14-line-python-code-straightforward-easy-to-understand 14 line python code, straightforward &amp; easy to understand 123456789101112131415161718192021222324252627282930313233343536class Solution(object):def getSkyline(self, buildings): &quot;&quot;&quot; :type buildings: List[List[int]] :rtype: List[List[int]] &quot;&quot;&quot; def addsky(pos, hei): if sky[-1][1] != hei: sky.append([pos, hei]) sky = [[-1,0]] # possible corner positions position = set([b[0] for b in buildings] + [b[1] for b in buildings]) # live buildings live = [] i = 0 for t in sorted(position): # add the new buildings whose left side is lefter than position t while i &lt; len(buildings) and buildings[i][0] &lt;= t: heappush(live, (-buildings[i][2], buildings[i][1])) i += 1 # remove the past buildings whose right side is lefter than position t while live and live[0][1] &lt;= t: heappop(live) # pick the highest existing building at this moment h = -live[0][0] if live else 0 addsky(t, h) return sky[1:] https://discuss.leetcode.com/topic/34119/10-line-python-solution-104-ms 10-line Python solution, 104 ms Use an infinite vertical line x to scan from left to right. If max height changes, record [x, height] in res. Online judge is using Python 2.7.9 and thereâ€™s no max heapâ€™s push and pop method, so we can use a min heap hp storing -H as â€œmax heapâ€. Thanks to this discussion, set comprehension is faster and shorter than list(set((R, 0, None) for L, R, H in buildings)). 1234567891011def getSkyline(self, buildings): events = sorted([(L, -H, R) for L, R, H in buildings] + list(&#123;(R, 0, None) for _, R, _ in buildings&#125;)) res, hp = [[0, 0]], [(0, float(&quot;inf&quot;))] for x, negH, R in events: while x &gt;= hp[0][1]: heapq.heappop(hp) if negH: heapq.heappush(hp, (negH, R)) if res[-1][1] + hp[0][0]: res += [x, -hp[0][0]], return res[1:] https://discuss.leetcode.com/topic/22482/short-java-solution Short Java solution 1234567891011121314151617181920212223242526272829public List&lt;int[]&gt; getSkyline(int[][] buildings) &#123; List&lt;int[]&gt; result = new ArrayList&lt;&gt;(); List&lt;int[]&gt; height = new ArrayList&lt;&gt;(); for(int[] b:buildings) &#123; height.add(new int[]&#123;b[0], -b[2]&#125;); height.add(new int[]&#123;b[1], b[2]&#125;); &#125; Collections.sort(height, (a, b) -&gt; &#123; if(a[0] != b[0]) return a[0] - b[0]; return a[1] - b[1]; &#125;); Queue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; (b - a)); pq.offer(0); int prev = 0; for(int[] h:height) &#123; if(h[1] &lt; 0) &#123; pq.offer(-h[1]); &#125; else &#123; pq.remove(h[1]); &#125; int cur = pq.peek(); if(prev != cur) &#123; result.add(new int[]&#123;h[0], cur&#125;); prev = cur; &#125; &#125; return result;&#125; https://discuss.leetcode.com/topic/28482/once-for-all-explanation-with-clean-java-code-o-n-2-time-o-n-space Once for all, explanation with clean Java code(O(n^2)time, O(n) space) Though I came up with a solution using PriorityQueue and BST, this problems still confuses me. To make it more clear, I went through it several times and investigated several good solutions on this forum. Here is my explanation which tries to make understanding this easier and may help you write a bug-free solution quickly. When visiting all start points and end points in order: Observations: 12345678If a position is shadowed by other buildings 1. height of that building is larger than the building to which current position belong; 2. the start point of that building must be smaller(or equal to) than this position; 3. the end point of that building must be larger(or equal to) than this position; Tus we have: 12345671. when you reach a start point, the height of current building immediately takes effect which means it could possibly affect the contour or shadow others when mixed with other following buildings;2. when you reach a end point, the height of current building will stop its influences;3. our target exists at the position where height change happens and there is nothing above it shadowing it; Obviously, to implement the idea that â€˜current height takes effectâ€™ and â€˜find out whether current height is shadowed by other buildingsâ€™, we need a mechanism to store current taking effect heights, meanwhile, figure out which one is the maximum, delete it if needed efficiently, which hints us to use a priority queue or BST. Thus, our algorithm could be summarised in following pseudo code: 12345678for position in sorted(all start points and all end points) if this position is a start point add its height else if this position is a end point delete its height compare current max height with previous max height, if different, add current position together with this new max height to our result, at the same time, update previous max height to current max height; To implement this algorithm, here are some concrete examples: In my implementation, I use a PriorityQueue to store end point values when visiting a start point, and store the [height, end point value] into a TreeMap. Thus: 1. when moving to next start point value, I can compare the next start point value with elements in PriorityQueue, thus achieving visiting all start points and end points in order(exploits the fact that start points are already sorted); 2. Meantime, I can get current max height from TreeMap in O(logn); 3. However, to delete a height when visiting a end point, I have to use &apos;map.values.remove()&apos; which is a method defined in Collection interface and tends to be slower(O(n) is this case, plz correct me if I&apos;m wrong); My code can be found at https://leetcode.com/discuss/62617/short-and-clean-java-solution-heap-and-treemap Following is wujinâ€™s implementation(plz refer to https://leetcode.com/discuss/54201/short-java-solution). This one is quite straightforward, clean and clever.Firstly, please notice what we need to achieve: 12341. visit all start points and all end points in order;2. when visiting a point, we need to know whether it is a start point or a end point, based on which we can add a height or delete a height from our data structure; To achieve this, his implementation: 12341. use a int[][] to collect all [start point, - height] and [end point, height] for every building;2. sort it, firstly based on the first value, then use the second to break ties; Thus, 12341. we can visit all points in order;2. when points have the same value, higher height will shadow the lower one;3. we know whether current point is a start point or a end point based on the sign of its height; His code is as follows(clear and concise) as reference with my comment(again, https://leetcode.com/discuss/54201/short-java-solution): 123456789101112131415161718192021222324252627282930313233343536373839404142434445public List&lt;int[]&gt; getSkyline(int[][] buildings) &#123; List&lt;int[]&gt; result = new ArrayList&lt;&gt;(); List&lt;int[]&gt; height = new ArrayList&lt;&gt;(); for(int[] b:buildings) &#123; // start point has negative height value height.add(new int[]&#123;b[0], -b[2]&#125;); // end point has normal height value height.add(new int[]&#123;b[1], b[2]&#125;); &#125; // sort $height, based on the first value, if necessary, use the second to // break ties Collections.sort(height, (a, b) -&gt; &#123; if(a[0] != b[0]) return a[0] - b[0]; return a[1] - b[1]; &#125;); // Use a maxHeap to store possible heights Queue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; (b - a)); // Provide a initial value to make it more consistent pq.offer(0); // Before starting, the previous max height is 0; int prev = 0; // visit all points in order for(int[] h:height) &#123; if(h[1] &lt; 0) &#123; // a start point, add height pq.offer(-h[1]); &#125; else &#123; // a end point, remove height pq.remove(h[1]); &#125; int cur = pq.peek(); // current max height; // compare current max height with previous max height, update result and // previous max height if necessary if(prev != cur) &#123; result.add(new int[]&#123;h[0], cur&#125;); prev = cur; &#125; &#125; return result;&#125; Hopefully now, you can write a good solution in a blink with good understandingâ€¦]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>divide and conquer</tag>
        <tag>hard</tag>
        <tag>heap</tag>
        <tag>binary indexed tree</tag>
        <tag>segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[217. Contains Duplicate]]></title>
    <url>%2Fp%2F4dd031de%2F</url>
    <content type="text"><![CDATA[44.4% https://leetcode.com/problems/contains-duplicate/ Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. æ–¹æ³•ä¸€ï¼š 58ms, 31.23%, July 13th, 2016 123456class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; return nums.size() &gt; set&lt;int&gt;(nums.begin(), nums.end()).size(); &#125;&#125;; æ–¹æ³•äºŒï¼š https://discuss.leetcode.com/topic/16706/basic-48ms-c-solution-with-unordered_map Basic 48ms C++ solution with unordered_map 12345678910111213class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) &#123; return false; &#125; unordered_map&lt;int,int&gt; mp; for (int i : nums) &#123; if (++mp[i] &gt; 1) &#123; return true; &#125; &#125; return false; &#125;&#125;; æ–¹æ³•ä¸‰ï¼š ä½¿ç”¨unordered_set 1234567891011121314class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return false; unordered_set&lt;int&gt; set; for(auto num:nums)&#123; if(set.find(num)!=set.end()) return true; set.insert(num); &#125; return false; &#125;&#125;; python 1234567class Solution(object): def containsDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; return len(nums) != len(set(nums)) java solution 1: 6ms, 79.29%, July 13th, 2016 123456789public class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; Arrays.sort(nums); for(int ind = 1; ind &lt; nums.length; ind++) if(nums[ind] == nums[ind-1]) return true; return false; &#125;&#125; solution 2: 15ms, 30.86%, July 13th, 2016 12345678910111213public class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; Set&lt;Integer&gt; distinct = new HashSet&lt;Integer&gt;(); for(int num : nums) &#123; if(distinct.contains(num)) &#123; return true; &#125; distinct.add(num); &#125; return false; &#125;&#125; solution 3: 10ms, 54.48%, July 13th, 2016 123456789public class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i : nums) if(!set.add(i)) return true; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[216. Combination Sum III]]></title>
    <url>%2Fp%2F76a270b0%2F</url>
    <content type="text"><![CDATA[43.2% https://leetcode.com/problems/combination-sum-iii/description/ Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. 1234567Example 1:Input: k = 3, n = 7Output:[[1,2,4]] 1234567Example 2:Input: k = 3, n = 9Output:[[1,2,6], [1,3,5], [2,3,4]] æ–¹æ³•ä¸€ï¼š å›žæº¯æ³•ï¼Œæˆ‘çš„ä»£ç å®žçŽ° 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; combination; helper(k, n, 1, combination, res); return res; &#125; void helper(int k, int target, int start, vector&lt;int&gt;&amp; combination, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(target==0 &amp;&amp; k==0)&#123; res.push_back(combination); return; &#125; if(k&lt;=0 || target&lt;0) return; for(int i=start; i&lt;10; i++)&#123; combination.push_back(i); helper(k-1, target-i, i+1, combination, res); combination.pop_back(); &#125; &#125;&#125;; Use backtrack c++ solution, easy to understand. ä¸‹æ®µä»£ç å€¼å¾—å€Ÿé‰´çš„æ˜¯backtrackçš„åˆ¤æ–­æ¡ä»¶ i&lt;=10-k &amp;&amp; i&lt;=target 123456789101112131415161718vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; backtrack(result, path, 1, k, n); return result;&#125;void backtrack(vector&lt;vector&lt;int&gt;&gt; &amp;result, vector&lt;int&gt; &amp;path, int start, int k, int target)&#123; if(target==0&amp;&amp;k==0)&#123; result.push_back(path); return; &#125; for(int i=start;i&lt;=10-k&amp;&amp;i&lt;=target;i++)&#123; path.push_back(i); backtrack(result,path,i+1,k-1,target-i); path.pop_back(); &#125;&#125; https://discuss.leetcode.com/topic/14641/my-c-solution-backtracking My C++ solution, backtracking. 123456789101112131415161718192021class Solution &#123;public: void combination(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; sol, int k, int n) &#123; if (sol.size() == k &amp;&amp; n == 0) &#123; result.push_back(sol); return ; &#125; if (sol.size() &lt; k) &#123; for (int i = sol.empty() ? 1 : sol.back() + 1; i &lt;= 9; ++i) &#123; if (n - i &lt; 0) break; sol.push_back(i); combination(result, sol, k, n - i); sol.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; sol; combination(result, sol, k, n); return result; &#125;&#125;; https://discuss.leetcode.com/topic/25351/use-backtrack-c-solution-easy-to-understand Use backtrack c++ solution, easy to understand. 123456789101112131415161718vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; backtrack(result, path, 1, k, n); return result;&#125;void backtrack(vector&lt;vector&lt;int&gt;&gt; &amp;result, vector&lt;int&gt; &amp;path, int start, int k, int target)&#123; if(target==0&amp;&amp;k==0)&#123; result.push_back(path); return; &#125; for(int i=start;i&lt;=10-k&amp;&amp;i&lt;=target;i++)&#123; path.push_back(i); backtrack(result,path,i+1,k-1,target-i); path.pop_back(); &#125;&#125; 52ms, 43.32%, June.18th, 2016 https://leetcode.com/discuss/38132/concise-python-solution-using-dfs Concise python solution using DFS 1234567891011121314151617181920212223242526class Solution: # @param &#123;integer&#125; k # @param &#123;integer&#125; n # @return &#123;integer[][]&#125; def combinationSum3(self, k, n): if n &gt; sum([i for i in range(1, 11)]): return [] res = [] self.sum_help(k, n, 1, [], res) return res def sum_help(self, k, n, curr, arr, res): if len(arr) == k: if sum(arr) == n: res.append(list(arr)) return if len(arr) &gt; k or curr &gt; 9: return for i in range(curr, 10): arr.append(i) self.sum_help(k, n, i + 1, arr, res) arr.pop() https://discuss.leetcode.com/topic/14702/clean-1-6-7-liners-ac Clean 1/6/7-liners (AC) Batteries Included AC in 44ms First the obligatory â€œuse the darn libraryâ€ solution. Create all k-combinations of digits and keep those with sum n: 12345from itertools import combinationsclass Solution: def combinationSum3(self, k, n): return [c for c in combinations(range(1, 10), k) if sum(c) == n] Recursive AC in 48 ms But itâ€™s more interesting to do it on your own. Here I use a recursive helper function getting the same k and n as the main function, and an additional cap under which all the numbers have to be: 123456789class Solution: def combinationSum3(self, k, n): def combs(k, n, cap): if not k: return [[]] * (not n) return [comb + [last] for last in range(1, cap) for comb in combs(k-1, n-last, last)] return combs(k, n, 10) Iterative AC in 56 ms And an iterative version doing pretty much the same thing, except this time I prepend elements on the left, and use the first element of a partial combination as the cap. 12345678class Solution: def combinationSum3(self, k, n): combs = [[]] for _ in range(k): combs = [[first] + comb for comb in combs for first in range(1, comb[0] if comb else 10)] return [c for c in combs if sum(c) == n] Reduce AC in 44 ms And hereâ€™s a â€œone-linerâ€ version of the iterative solution using reduce instead of the loop: 12345678class Solution: def combinationSum3(self, k, n): return [c for c in reduce(lambda combs, _: [[first] + comb for comb in combs for first in range(1, comb[0] if comb else 10)], range(k), [[]]) if sum(c) == n] I note that all these solutions also correctly solve the cases with k=0 and/or n=0 (but leetcode sadly doesnâ€™t test those). https://discuss.leetcode.com/topic/19100/easy-to-understand-python-solution-backtracking Easy to understand Python solution (backtracking). 123456789101112def combinationSum3(self, k, n): res = [] self.dfs(xrange(1,10), k, n, 0, [], res) return res def dfs(self, nums, k, n, index, path, res): if k &lt; 0 or n &lt; 0: # backtracking return if k == 0 and n == 0: res.append(path) for i in xrange(index, len(nums)): self.dfs(nums, k-1, n-nums[i], i+1, path+[nums[i]], res)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[215. Kth Largest Element in an Array]]></title>
    <url>%2Fp%2F85bb0f40%2F</url>
    <content type="text"><![CDATA[38.2% https://leetcode.com/problems/kth-largest-element-in-an-array/#/description Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. 12For example,Given [3,2,1,5,6,4] and k = 2, return 5. Note: You may assume k is always valid, 1 â‰¤ k â‰¤ arrayâ€™s length. æ€»ç»“ï¼š æ–¹æ³•ä¸€ : å…ˆæŽ’åºï¼ŒåŽé€‰å‡ºç¬¬kå¤§çš„æ•°å­—ã€‚é¢è¯•è‚¯å®šæ²¡å•¥ç”¨ã€‚ æ³¨æ„ï¼Œå¯¹numsæŽ’åºæ˜¯ï¼Œsort(nums.begin(), nums.end()), ä¸æ˜¯sort(nums) 12345678class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); sort(nums.begin(), nums.end()); return nums[n - k]; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°: 12345678class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); int n = nums.size(); return nums[n-k]; &#125;&#125;; æ–¹æ³•äºŒ: æ±‚æœ€å¤§kå€¼ï¼Œå»ºæœ€å°å †ï¼Œæ•ˆçŽ‡O(nlogk)ï¼Œç¬¬ä¸€æ¬¡å»ºå †kï¼Œæ¯æ¬¡æŽ’é™¤ä¸€ä¸ªå¤´éƒ¨ï¼Œå¹¶é‡æ–°ç»´æŠ¤å †æ€§è´¨logkã€‚ å­¦ä¹ å¦‚ä½•å»ºå †ï¼Œé»˜è®¤å»ºæœ€å¤§å †ï¼Œå¦‚ä½•å»ºç«‹æœ€å°å †ã€‚åŒæ—¶make_heap(res.begin(), res.end())ï¼Œè€Œä¸æ˜¯make_heap(res)ï¼Œ ç±»ä¼¼äºŽsortã€‚ å­¦ä¹ å¦‚ä½•è®¾ç½®cmpå‡½æ•°ã€‚ 123456789101112131415161718class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); vector&lt;int&gt; res(nums.begin(), nums.begin() + k); make_heap(res.begin(), res.end(), [](int&amp; a, int&amp; b) &#123; return a&gt;b; &#125;); for (int i = k; i&lt;n; i++) &#123; if (nums[i]&gt;res[0]) &#123; pop_heap(res.begin(), res.end(), [](int&amp; a, int&amp; b) &#123; return a&gt;b; &#125;); res.pop_back(); res.push_back(nums[i]); push_heap(res.begin(), res.end(), [](int&amp; a, int&amp; b) &#123; return a&gt;b; &#125;); &#125; &#125; sort_heap(res.begin(), res.end(), [](int&amp; a, int&amp; b) &#123; return a&gt;b; &#125;); return res[k-1]; &#125;&#125;; æˆ‘çš„å®žçŽ° éœ€è¦å…ˆå»ºæœ€å°å †ï¼Œ ç„¶åŽä»Žkè‡³æœ€åŽéåŽ† å¦‚æžœå¤§äºŽæœ€å°å€¼ï¼Œæ›¿æ¢äº†ï¼Œç„¶åŽç»´æŠ¤æœ€å°å †çš„æ€§è´¨ éåŽ†åˆ°æœ€åŽï¼Œå †é‡Œé¢æ˜¯æœ€å¤§çš„kä¸ªï¼Œå †çš„rootæ˜¯ç¬¬kå¤§çš„å€¼ã€‚ è¿”å›žres[0]å°±å¥½ã€‚ 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; if(nums.size()&lt;k) return -1; // make heap vector&lt;int&gt; res(nums.begin(), nums.begin()+k); for(int i=(k-2)/2; i&gt;=0; i--)&#123; minHeapify(res, i, k-1); &#125; for(int i=k; i&lt;nums.size(); i++)&#123; if(nums[i]&gt;res[0])&#123; res[0] = nums[i]; minHeapify(res, 0, k-1); &#125; &#125; return res[0]; &#125; void minHeapify(vector&lt;int&gt;&amp; nums, int start, int end)&#123; if(start&gt;=end) return; int parent = start; int child = 2*parent+1; while(child&lt;=end)&#123; if(child+1&lt;=end &amp;&amp; nums[child+1]&lt;nums[child])&#123; child += 1; &#125; if(nums[child]&lt;nums[parent])&#123; swap(nums[child], nums[parent]); parent = child; child = 2*parent+1; &#125;else&#123; break; &#125; &#125; return; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°: 123456789101112131415161718192021222324252627282930class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; v(nums.begin(), nums.begin()+k); for(int i=(k-2)/2; i&gt;=0; i--) miniheapify(v, i, k-1); for(int i=k; i&lt;nums.size(); i++) if(nums[i]&gt;v[0])&#123; v[0] = nums[i]; miniheapify(v, 0, k-1); &#125; return v[0]; &#125; void miniheapify(vector&lt;int&gt;&amp; v, int start, int end)&#123; if(start&gt;=end) return; int parent = start, child = 2*parent+1; while(child&lt;=end)&#123; if(child+1&lt;=end &amp;&amp; v[child+1]&lt;v[child]) child += 1; if(v[child]&lt;v[parent])&#123; swap(v[child], v[parent]); parent = child; child = 2*parent+1; &#125;else break; &#125; &#125;&#125;; æ–¹æ³•ä¸‰: ä½¿ç”¨å¿«æŽ’é‡Œçš„patitionæ–¹æ³•ï¼Œç›´åˆ°åˆ†é…åˆ°ä¸€éçš„æ˜¯kä¸ªï¼Œå¹¶ä¸”å¯¹æ­¤è¿›è¡ŒæŽ’åºã€‚ 12345678910111213141516171819202122232425class Solution &#123; public: int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int pivot = nums[left]; int l = left + 1, r = right; while (l &lt;= r) &#123; if (nums[l] &lt; pivot &amp;&amp; nums[r] &gt; pivot) swap(nums[l++], nums[r--]); if (nums[l] &gt;= pivot) l++; if (nums[r] &lt;= pivot) r--; &#125; swap(nums[left], nums[r]); return r; &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int left = 0, right = nums.size() - 1; while (true) &#123; int pos = partition(nums, left, right); if (pos == k - 1) return nums[pos]; if (pos &gt; k - 1) right = pos - 1; else left = pos + 1; &#125; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int left=0, right = nums.size()-1; int index = partition(nums, left, right); while(index!=k-1)&#123; // è¿™é‡Œæ˜¯k-1ï¼Œè€Œä¸æ˜¯kï¼Œæ±‚ç¬¬kï¼Œå°±æ˜¯index==k-1 if(index&lt;k-1)&#123; left = index+1; &#125;else&#123; right = index-1; &#125; index = partition(nums, left, right); &#125; return nums[k-1]; &#125; int partition(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if(left == right) return left; int pos = left-1; for(int i=left; i &lt; right; i++)&#123; if(nums[i]&gt;=nums[right])&#123; pos++; swap(nums[pos], nums[i]); &#125; &#125; pos++; swap(nums[pos], nums[right]); return pos; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); int left = 0, right = n-1; int pos = partition(nums, left, right); while(pos!=n-k)&#123; if(pos&lt;n-k) left = pos+1; else right = pos-1; pos = partition(nums, left, right); &#125; return nums[n-k]; &#125; int partition(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if(left&gt;=right) return left; int pos = left-1; for(int i=left; i&lt;right; i++) if(nums[i]&lt;=nums[right]) swap(nums[i], nums[++pos]); swap(nums[right], nums[++pos]); return pos; &#125;&#125;; èµ„æ–™ï¼Œå¦‚ä½•è®¾ç½®æœ€å°å †çš„æ¯”è¾ƒå‡½æ•° http://stackoverflow.com/questions/14016921/comparator-for-min-heap-in-c 123456789101112131415161718192021222324252627#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;struct greater1&#123; bool operator()(const long&amp; a,const long&amp; b) const&#123; return a&gt;b; &#125;&#125;;int main() &#123; std::vector&lt;long&gt; humble; humble.push_back(15); humble.push_back(15); humble.push_back(9); humble.push_back(25); std::make_heap(humble.begin(), humble.end(), greater1()); while (humble.size()) &#123; std::pop_heap(humble.begin(),humble.end(),greater1()); long min = humble.back(); humble.pop_back(); std::cout &lt;&lt; min &lt;&lt; std::endl; &#125; return 0;&#125; cpp https://discuss.leetcode.com/topic/15256/4-c-solutions-using-partition-max-heap-priority_queue-and-multiset-respectively 4 C++ Solutions using Partition, Max-Heap, priority_queue and multiset respectively Well, this problem has a naive solution, which is to sort the array in descending order and return the k-1-th element. 1234567class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); return nums[k - 1]; &#125;&#125;; However, sorting algorithm gives O(nlogn) complexity. Suppose n = 10000 and k = 2, then we are doing a lot of unnecessary operations. In fact, this problem has at least two simple and faster solutions. Well, the faster solution has no mystery. It is also closely related to sorting. I will give two algorithms for this problem below, one using quicksort(specifically, the partition subroutine) and the other using heapsort. Quicksort In quicksort, in each iteration, we need to select a pivot and then partition the array into three parts: Elements smaller than the pivot; Elements equal to the pivot; Elements larger than the pivot. Now, letâ€™s do an example with the array [3, 2, 1, 5, 4, 6] in the problem statement. Letâ€™s assume in each time we select the leftmost element to be the pivot, in this case, 3. We then use it to partition the array into the above 3 parts, which results in [1, 2, 3, 5, 4, 6]. Now 3 is in the third position and we know that it is the third smallest element. Now, do you recognize that this subroutine can be used to solve this problem? In fact, the above partition puts elements smaller than the pivot before the pivot and thus the pivot will then be the k-th smallest element if it is at the k-1-th position. Since the problem requires us to find the k-th largest element, we can simply modify the partition to put elements larger than the pivot before the pivot. That is, after partition, the array becomes [5, 6, 4, 3, 1, 2]. Now we know that 3 is the 4-th largest element. If we are asked to find the 2-th largest element, then we know it is left to 3. If we are asked to find the 5-th largest element, then we know it is right to 3. So, in the average sense, the problem is reduced to approximately half of its original size, giving the recursion T(n) = T(n/2) + O(n) in which O(n) is the time for partition. This recursion, once solved, gives T(n) = O(n) and thus we have a linear time solution. Note that since we only need to consider one half of the array, the time complexity is O(n). If we need to consider both the two halves of the array, like quicksort, then the recursion will be T(n) = 2T(n/2) + O(n) and the complexity will be O(nlogn). Of course, O(n) is the average time complexity. In the worst case, the recursion may become T(n) = T(n - 1) + O(n) and the complexity will be O(n^2). Now letâ€™s briefly write down the algorithm before writing our codes. Initialize left to be 0 and right to be nums.size() - 1; Partition the array, if the pivot is at the k-1-th position, return it (we are done); If the pivot is right to the k-1-th position, update right to be the left neighbor of the pivot; Else update left to be the right neighbor of the pivot. Repeat 2. Now letâ€™s turn it into code. 12345678910111213141516171819202122232425class Solution &#123; public: int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int pivot = nums[left]; int l = left + 1, r = right; while (l &lt;= r) &#123; if (nums[l] &lt; pivot &amp;&amp; nums[r] &gt; pivot) swap(nums[l++], nums[r--]); if (nums[l] &gt;= pivot) l++; if (nums[r] &lt;= pivot) r--; &#125; swap(nums[left], nums[r]); return r; &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int left = 0, right = nums.size() - 1; while (true) &#123; int pos = partition(nums, left, right); if (pos == k - 1) return nums[pos]; if (pos &gt; k - 1) right = pos - 1; else left = pos + 1; &#125; &#125;&#125;; Heapsort Well, this problem still has a tag â€œheapâ€. If you are familiar with heapsort, you can solve this problem using the following idea: Build a max-heap for nums, set heap_size to be nums.size(); Swap nums[0] (after buding the max-heap, it will be the largest element) with nums[heap_size - 1] (currently the last element). Then decrease heap_size by 1 and max-heapify nums (recovering its max-heap property) at index 0; Repeat 2 for k times and the k-th largest element will be stored finally at nums[heap_size]. Now I paste my code below. If you find it tricky, I suggest you to read the Heapsort chapter of Introduction to Algorithms, which has a nice explanation of the algorithm. My code simply translates the pseudo code in that book :-) 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: inline int left(int idx) &#123; return (idx &lt;&lt; 1) + 1; &#125; inline int right(int idx) &#123; return (idx &lt;&lt; 1) + 2; &#125; void max_heapify(vector&lt;int&gt;&amp; nums, int idx) &#123; int largest = idx; int l = left(idx), r = right(idx); if (l &lt; heap_size &amp;&amp; nums[l] &gt; nums[largest]) largest = l; if (r &lt; heap_size &amp;&amp; nums[r] &gt; nums[largest]) largest = r; if (largest != idx) &#123; swap(nums[idx], nums[largest]); max_heapify(nums, largest); &#125; &#125; void build_max_heap(vector&lt;int&gt;&amp; nums) &#123; heap_size = nums.size(); for (int i = (heap_size &gt;&gt; 1) - 1; i &gt;= 0; i--) max_heapify(nums, i); &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; build_max_heap(nums); for (int i = 0; i &lt; k; i++) &#123; swap(nums[0], nums[heap_size - 1]); heap_size--; max_heapify(nums, 0); &#125; return nums[heap_size]; &#125;private: int heap_size;&#125; If we are allowed to use the built-in priority_queue, the code will be much more shorter :-) 123456789class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int&gt; pq(nums.begin(), nums.end()); for (int i = 0; i &lt; k - 1; i++) pq.pop(); return pq.top(); &#125;&#125;; Well, the priority_queue can also be replaced by multiset :-) 12345678910111213class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; multiset&lt;int&gt; mset; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; mset.insert(nums[i]); if (mset.size() &gt; k) mset.erase(mset.begin()); &#125; return *mset.begin(); &#125;&#125;; https://discuss.leetcode.com/topic/16970/4ms-c-solution-straightforward-to-find-largest-k-kind-like-a-partition-version 4ms c++ solution. straightforward to find largest k. kind like a partition version. 12345678910111213141516class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int cur=nums[k-1]; vector&lt;int&gt; bigger; vector&lt;int&gt; smaller; for(size_t i=0; i&lt;nums.size(); ++i)&#123; if(i==k-1) continue; if(nums[i]&gt;=cur) bigger.push_back(nums[i]); else smaller.push_back(nums[i]); &#125; if(bigger.size()==k-1) return cur; if(bigger.size()&gt;k-1) return findKthLargest(bigger,k); if(bigger.size()&lt;k-1) return findKthLargest(smaller,k-bigger.size()-1); &#125;&#125;; https://discuss.leetcode.com/topic/22159/python-different-solutions-with-comments-bubble-sort-selection-sort-heap-sort-and-quick-sort Python different solutions with comments (bubble sort, selection sort, heap sort and quick sort). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# O(nlgn) timedef findKthLargest1(self, nums, k): return sorted(nums, reverse=True)[k-1] # O(nk) time, bubble sort idea, TLEdef findKthLargest2(self, nums, k): for i in xrange(k): for j in xrange(len(nums)-i-1): if nums[j] &gt; nums[j+1]: # exchange elements, time consuming nums[j], nums[j+1] = nums[j+1], nums[j] return nums[len(nums)-k] # O(nk) time, selection sort ideadef findKthLargest3(self, nums, k): for i in xrange(len(nums), len(nums)-k, -1): tmp = 0 for j in xrange(i): if nums[j] &gt; nums[tmp]: tmp = j nums[tmp], nums[i-1] = nums[i-1], nums[tmp] return nums[len(nums)-k] # O(k+(n-k)lgk) time, min-heapdef findKthLargest4(self, nums, k): heap = [] for num in nums: heapq.heappush(heap, num) for _ in xrange(len(nums)-k): heapq.heappop(heap) return heapq.heappop(heap)# O(k+(n-k)lgk) time, min-heap def findKthLargest5(self, nums, k): return heapq.nlargest(k, nums)[k-1] # O(n) time, quick selectiondef findKthLargest(self, nums, k): # convert the kth largest to smallest return self.findKthSmallest(nums, len(nums)+1-k) def findKthSmallest(self, nums, k): if nums: pos = self.partition(nums, 0, len(nums)-1) if k &gt; pos+1: return self.findKthSmallest(nums[pos+1:], k-pos-1) elif k &lt; pos+1: return self.findKthSmallest(nums[:pos], k) else: return nums[pos] # choose the right-most element as pivot def partition(self, nums, l, r): low = l while l &lt; r: if nums[l] &lt; nums[r]: nums[l], nums[low] = nums[low], nums[l] low += 1 l += 1 nums[low], nums[r] = nums[r], nums[low] return low https://discuss.leetcode.com/topic/20740/share-my-python-solution-with-quickselect-idea Share my Python solution with QuickSelect idea 12345678910111213141516171819class Solution:# @param &#123;integer[]&#125; nums# @param &#123;integer&#125; k# @return &#123;integer&#125;def findKthLargest(self, nums, k): # QuickSelect idea: AC in 52 ms # --------------------------- # pivot = nums[0] left = [l for l in nums if l &lt; pivot] equal = [e for e in nums if e == pivot] right = [r for r in nums if r &gt; pivot] if k &lt;= len(right): return self.findKthLargest(right, k) elif (k - len(right)) &lt;= len(equal): return equal[0] else: return self.findKthLargest(left, k - len(right) - len(equal)) cppSolution 1: 20ms, 53,47%, June.18th, 2016 https://leetcode.com/discuss/38336/solutions-partition-priority_queue-multiset-respectively 12345678class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int N = nums.size(); sort(nums.begin(), nums.end()); return nums[N-k]; &#125;&#125;; pythonSolution Mine: 52ms, 88.30%, June.18th, 2016 123456789class Solution(object): def findKthLargest(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; nums.sort() return nums[-k] Solution 1: 3164ms, 7.6%, June.18th, 2016 https://leetcode.com/discuss/50389/share-my-python-solution-with-quickselect-idea 123456789101112131415161718class Solution(object): def findKthLargest(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; pivot = nums[0] left = [i for i in nums if i &lt; pivot] equal = [i for i in nums if i == pivot] right = [i for i in nums if i &gt; pivot] if k &lt;= len(right): return self.findKthLargest(right, k) elif k &lt;= len(right) + len(equal): return equal[0] else: return self.findKthLargest(left, k - len(right)-len(equal)) Solution 2: 60ms, 75.44%, June.18th, 2016 https://leetcode.com/discuss/53530/python-different-solutions-comments-bubble-selection-quick 12345678class Solution(object): def findKthLargest(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; return heapq.nlargest(k, nums)[k-1] 6ms, 72.82%, June.18th, 2016 12345678https://leetcode.com/discuss/36966/solution-explainedpublic class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; final int N = nums.length; Arrays.sort(nums); return nums[N-k]; &#125;&#125; java https://discuss.leetcode.com/topic/14597/solution-explained Solution explained This problem is well known and quite often can be found in various text books. You can take a couple of approaches to actually solve it: O(N lg N) running time + O(1) memory The simplest approach is to sort the entire input array and then access the element by itâ€™s index (which is O(1)) operation: 12345public int findKthLargest(int[] nums, int k) &#123; final int N = nums.length; Arrays.sort(nums); return nums[N - k];&#125; O(N lg K) running time + O(K) memory Other possibility is to use a min oriented priority queue that will store the K-th largest values. The algorithm iterates over the whole input and maintains the size of priority queue. 123456789101112public int findKthLargest(int[] nums, int k) &#123; final PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(); for(int val : nums) &#123; pq.offer(val); if(pq.size() &gt; k) &#123; pq.poll(); &#125; &#125; return pq.peek();&#125; O(N) best case / O(N^2) worst case running time + O(1) memory The smart approach for this problem is to use the selection algorithm (based on the partion method - the same one as used in quicksort). 12345678910111213141516171819202122232425262728293031323334353637383940414243public int findKthLargest(int[] nums, int k) &#123; k = nums.length - k; int lo = 0; int hi = nums.length - 1; while (lo &lt; hi) &#123; final int j = partition(nums, lo, hi); if(j &lt; k) &#123; lo = j + 1; &#125; else if (j &gt; k) &#123; hi = j - 1; &#125; else &#123; break; &#125; &#125; return nums[k]; &#125; private int partition(int[] a, int lo, int hi) &#123; int i = lo; int j = hi + 1; while(true) &#123; while(i &lt; hi &amp;&amp; less(a[++i], a[lo])); while(j &gt; lo &amp;&amp; less(a[lo], a[--j])); if(i &gt;= j) &#123; break; &#125; exch(a, i, j); &#125; exch(a, lo, j); return j; &#125; private void exch(int[] a, int i, int j) &#123; final int tmp = a[i]; a[i] = a[j]; a[j] = tmp; &#125; private boolean less(int v, int w) &#123; return v &lt; w; &#125; O(N) guaranteed running time + O(1) space So how can we improve the above solution and make it O(N) guaranteed? The answer is quite simple, we can randomize the input, so that even when the worst case input would be provided the algorithm wouldnâ€™t be affected. So all what it is needed to be done is to shuffle the input. 123456789101112131415161718192021222324252627public int findKthLargest(int[] nums, int k) &#123; shuffle(nums); k = nums.length - k; int lo = 0; int hi = nums.length - 1; while (lo &lt; hi) &#123; final int j = partition(nums, lo, hi); if(j &lt; k) &#123; lo = j + 1; &#125; else if (j &gt; k) &#123; hi = j - 1; &#125; else &#123; break; &#125; &#125; return nums[k]; &#125;private void shuffle(int a[]) &#123; final Random random = new Random(); for(int ind = 1; ind &lt; a.length; ind++) &#123; final int r = random.nextInt(ind + 1); exch(a, ind, r); &#125; &#125; There is also worth mentioning the Blum-Floyd-Pratt-Rivest-Tarjan algorithm that has a guaranteed O(N) running time.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>divide and conquer</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[214. Shortest Palindrome]]></title>
    <url>%2Fp%2Fd81a1f9f%2F</url>
    <content type="text"><![CDATA[23.5% https://leetcode.com/problems/shortest-palindrome/#/description Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. 12345For example:Given &quot;aacecaaa&quot;, return &quot;aaacecaaa&quot;.Given &quot;abcd&quot;, return &quot;dcbabcd&quot;. æ­¤å¤„éœ€è¦æ€è€ƒ https://discuss.leetcode.com/topic/14526/c-8-ms-kmp-based-o-n-time-o-n-memory-solution C++ 8 ms KMP-based O(n) time &amp; O(n) memory solution We can construct the following string and run KMP algorithm on it: (s) + (some symbol not present in s) + (reversed string) After running KMP on that string as result we get a vector p with values of a prefix function for each character (for definition of a prefix function see KMP algorithm description). We are only interested in the last value because it shows us the largest suffix of the reversed string that matches the prefix of the original string. So basically all we left to do is to add the first k characters of the reversed string to the original string, where k is a difference between original string size and the prefix function for the last character of a constructed string. 123456789101112131415161718class Solution &#123;public: string shortestPalindrome(string s) &#123; string rev_s = s; reverse(rev_s.begin(), rev_s.end()); string l = s + &quot;#&quot; + rev_s; vector&lt;int&gt; p(l.size(), 0); for (int i = 1; i &lt; l.size(); i++) &#123; int j = p[i - 1]; while (j &gt; 0 &amp;&amp; l[i] != l[j]) j = p[j - 1]; p[i] = (j += l[i] == l[j]); &#125; return rev_s.substr(0, s.size() - p[l.size() - 1]) + s; &#125;&#125;; https://discuss.leetcode.com/topic/14770/my-easily-understandable-but-time-consuming-c-solution My easily understandable but time consuming C++ solution The key idea is to first reverse the string, then check the max length from n to 0 1234567891011121314class Solution &#123;public: string shortestPalindrome(string s) &#123; string s2=s; reverse(s2.begin(),s2.end()); int n=s.size(),l; for(l=n;l&gt;=0;l--) &#123; if(s.substr(0,l)==s2.substr(n-l)) break; &#125; return s2.substr(0,n-l)+s; &#125;&#125;; https://discuss.leetcode.com/topic/16275/accepted-4ms-c-solution-different-with-kmp-based-solution-and-easy-understand/2 Accepted 4ms c++ solution, different with KMP-based solution and easy understand. For this problem, KMP-based solution is a very typical and classic O(n) solution. Here is a different solution, itâ€™s also O(n), and I think it is more easy to understand. In order to slove this problem, the key is to get the length of the longest palindromic prefix substring. if the length of s is len, and the length of the longest palindromic prefix substring is longest, the remaining substring will be s.substr(longest, len - longest), than we should reverse the remaining substring and adding it in front of s. For example, if s is â€œabacbbcdaâ€, so the longest palindromic prefix substring is â€œabaâ€(not â€œcbbcâ€ because itâ€™s not prefix string), and the remaining substring is â€œcbbcdaâ€, we reverse the remaining substring and get â€œadcbbcâ€, so the result is â€œadcbbcâ€ + â€œabacbbcdaâ€. The follow is my c++ solution, only 4ms. Please note that the condition in for loop is begin &lt;= len / 2 instead of begin &lt; len, because if begin &gt; len / 2, the substring can not be prefix string, so there is no need to continue. Update: I made wrong analysis, the complexity is O(N^2) but not O(N). Thanks very much for Sammaxâ€™s reminder. 123456789101112131415161718192021222324252627class Solution &#123;public: std::string shortestPalindrome(std::string s) &#123; int len = s.length(); if (len &lt; 2) return s; // calculate the length of the longest palindromic prefix substring. int longest = 1, start, end; for (int begin = 0; begin &lt;= len / 2;) &#123; start = end = begin; while (end &lt; len - 1 &amp;&amp; s[end + 1] == s[end]) ++end; begin = end + 1; while (end &lt; len - 1 &amp;&amp; start &gt; 0 &amp;&amp; s[end + 1] == s[start - 1]) &#123; ++end; --start; &#125; // start == 0 means the palindromic substring is also prefix string. if (start == 0 &amp;&amp; longest &lt; end - start + 1) longest = end - start + 1; &#125; // reverse the remaining substring and adding it in front of s. std::string remaining = s.substr(longest, len - longest); std::reverse(remaining.begin(), remaining.end()); return remaining + s; &#125;&#125;; 262ms, 29.90%, October 14, 2016 https://discuss.leetcode.com/topic/14542/ac-in-288-ms-simple-brute-force AC in 288 ms, simple brute force 12345def shortestPalindrome(self, s): r = s[::-1] for i in range(len(s) + 1): if s.startswith(r[i:]): return r[:i] + s Example: s = dedcba. Then r = abcded and I try these overlays (the part in (â€¦) is the prefix I cut off, I just include it in the display for better understanding): 12345s dedcbar[0:] abcded Nope...r[1:] (a)bcded Nope...r[2:] (ab)cded Nope...r[3:] (abc)ded Yes! Return abc + dedcba 7ms, 69.02%, October 14, 2016 https://discuss.leetcode.com/topic/21068/my-7-lines-recursive-java-solution 123456789101112public class Solution &#123; public String shortestPalindrome(String s) &#123; int j = 0; for(int i = s.length() - 1; i&gt;=0; i--)&#123; if(s.charAt(i) == s.charAt(j)) j += 1; &#125; if(j == s.length()) return s; String suffix = s.substring(j); return new StringBuffer(suffix).reverse().toString() + shortestPalindrome(s.substring(0,j)) + suffix; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[213. House Robber II]]></title>
    <url>%2Fp%2Ff35c89e6%2F</url>
    <content type="text"><![CDATA[33.4% https://leetcode.com/problems/house-robber-ii/#/description Note: This is an extension of House Robber. After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. æ–¹æ³•ä¸€ï¼š ä¸Žhouse robber i ç±»ä¼¼ï¼Œä½†æ˜¯è¿™ä¸ªå¯ä»¥çœ‹åšä¸¤ä¸ªï¼Œä¸€ä¸ªæ˜¯nums[2:],ä¸€ä¸ªæ˜¯nums[:-1]è¿™ä¸¤ä¸ªå·ç›—æƒ…å†µã€‚è¿™æ ·å°±å¯ä»¥éšæ„åƒä¸€ä¸ªé‚£ä¹ˆå·äº†ã€‚ https://discuss.leetcode.com/topic/14504/9-lines-0ms-o-1-space-c-solution 9-lines 0ms O(1)-Space C++ solution This problem is a little tricky at first glance. However, if you have finished the House Robber problem, this problem can simply be decomposed into two House Robber problems.Suppose there are n houses, since house 0 and n - 1 are now neighbors, we cannot rob them together and thus the solution is now the maximum of Rob houses 0 to n - 2; Rob houses 1 to n - 1. The code is as follows. Some edge cases (n &lt; 2) are handled explicitly. 123456789101112131415161718class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt; 2) return n ? nums[0] : 0; return max(robber(nums, 0, n - 2), robber(nums, 1, n - 1)); &#125;private: int robber(vector&lt;int&gt;&amp; nums, int l, int r) &#123; int pre = 0, cur = 0; for (int i = l; i &lt;= r; i++) &#123; int temp = max(pre + nums[i], cur); pre = cur; cur = temp; &#125; return cur; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; if(n==1) return nums[0]; int first = helper(nums, 0, n-2); int second = helper(nums, 1, n-1); return max(first, second); &#125; int helper(vector&lt;int&gt;&amp; nums, int start, int end)&#123; int r1 = 0, r2 = 0; int res = 0; for(int i=start; i&lt;=end; i++)&#123; res = max(r2, r1+nums[i]); r1 = r2; r2 = res; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/14325/twice-pass-solution-c Twice pass solution, C++ Twice pass: not rob nums[n-1] not rob nums[0] and the other is same as House Robber. 12345678910111213141516171819202122232425int rob(vector&lt;int&gt;&amp; nums)&#123; if(nums.size() == 0) return 0; if(nums.size() == 1) return nums[0]; int pre1 = 0, cur1 = 0; for(int i = 0; i &lt; nums.size() - 1; ++ i) &#123; int temp = pre1; pre1 = cur1; cur1 = max(temp + nums[i], pre1); &#125; int pre2 = 0, cur2 = 0; for(int i = 1; i &lt; nums.size(); ++ i) &#123; int temp = pre2; pre2 = cur2; cur2 = max(temp + nums[i], pre2); &#125; return max(cur1, cur2);&#125; https://discuss.leetcode.com/topic/20770/c-super-simple-0ms-solution-with-explanation [C++] Super Simple 0ms solution with explanation Since you cannot rob both the first and last house, just create two separate vectors, one excluding the first house, and another excluding the last house. The best solution generated from these two vectors using the original House Robber DP algorithm is the optimal one. 12345678910111213141516171819202122232425class Solution &#123;public: int robOriginal(vector&lt;int&gt;&amp; nums) &#123; int a = 0, b = 0, res = 0; for(int i = 0; i &lt; nums.size(); ++i)&#123; res = max(b + nums[i], a); b = a; a = res; &#125; return res; &#125; int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; if(nums.size() == 1) return nums[0]; vector&lt;int&gt; numsA(nums.begin() + 1, nums.end()); vector&lt;int&gt; numsB(nums.begin(), nums.end()-1); return max(robOriginal(numsA), robOriginal(numsB)); &#125;&#125;; https://discuss.leetcode.com/topic/18123/0ms-o-n-time-o-1-space-c-solution 0ms O(N) time O(1) space C++ solution This solution is based on house robber 1. The idea is that either the first house or the last house is not robbed. The final solution is max of (house robber without last element) and (house robber without the first element). Note endIndex is not inclusive in the second rob function. 1234567891011121314151617181920class Solution &#123;public:int rob(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; return max(rob(nums, 0, nums.size()-1), rob(nums, 1, 0));&#125;int rob(vector&lt;int&gt;&amp; nums, int startIndex, int endIndex) &#123; int p = 0, q = 0; for (int i = startIndex; i != endIndex; /* do nothing */) &#123; int tmp = p; p = max(p, q + nums[i]); q = tmp; i = (i + 1) % nums.size(); &#125; return p;&#125;&#125;; https://discuss.leetcode.com/topic/28279/simple-and-easy-c-solution-modified-from-the-best-solution-of-house-robber-easy Simple and easy C++ solution modified from the best solution of House Robber (Easy) 12345678910111213141516171819int rob_line(vector&lt;int&gt;&amp; nums, int start, int end) &#123; int odd_sum=0; int even_sum=0; for(int i=start; i&lt;end; i++) &#123; if(i%2) odd_sum = max(even_sum, odd_sum+nums[i]); else even_sum = max(odd_sum, even_sum+nums[i]); &#125; return max(odd_sum, even_sum);&#125;int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; else if(nums.size()==1) return nums[0]; else return max(rob_line(nums,0,nums.size()-1), rob_line(nums,1,nums.size()));&#125; 12345678910111213141516# Solution mine:# 48ms, 20.23%, 74/74, April.25th, 2016class Solution(object): def rob_ori(self, num): num = [0, 0] + num for i, n in enumerate(num[2:], start = 2) : num[i] = max(num[i-2] + n, num[i-1]) return num[-1] def rob(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if not nums: return 0 if len(nums) == 1: return nums[0] return max(self.rob_ori(nums[1:]), self.rob_ori(nums[:-1]))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[212. Word Search II]]></title>
    <url>%2Fp%2Fd7166e68%2F</url>
    <content type="text"><![CDATA[22.8% Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where â€œadjacentâ€ cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. 12345678910For example,Given words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] and board =[ [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;], [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;], [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;], [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]Return [&quot;eat&quot;,&quot;oath&quot;]. Note: You may assume that all inputs are consist of lowercase letters a-z. https://discuss.leetcode.com/topic/14301/my-c-trie-backtrace-based-solution-48-ms My C++ Trie + Backtrace based solution (48 ms) The idea is to use a Trie to build a prefix tree for words to simplify the search and do DFS to search all the possible strings. For Trie, 26 pointers to point the sub-strings and a bool leaf to indicate whether the current node is a leaf (i.e. a string in words) and also idx is used to save the index of words for the current node. For DFS, just check if the current position is visited before (board[i][j]==â€™Xâ€™), if so, return, check if there is a string with such prefix (nullptr == root-&gt;children[words[idx][pos]-â€˜aâ€™]), if not, return; otherwise, check if the current searched string is a leaf of the trie (a string in words), if so, save it to res and set leaf of the trie node to false to indicate such string is already found. At last, move to its neighbors to continue the search. Remember to recover the char [i][j] at the end. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123; class Trie&#123; public: Trie *children[26]; // pointers to its substrings starting with &apos;a&apos; to &apos;z&apos; bool leaf; // if the node is a leaf, or if there is a word stopping at here int idx; // if it is a leaf, the string index of the array words Trie() &#123; this-&gt;leaf = false; this-&gt;idx = 0; fill_n(this-&gt;children, 26, nullptr); &#125; &#125;; public: void insertWords(Trie *root, vector&lt;string&gt;&amp; words, int idx) &#123; int pos = 0, len = words[idx].size(); while(pos&lt;len) &#123; if(nullptr == root-&gt;children[words[idx][pos]-&apos;a&apos;]) root-&gt;children[words[idx][pos]-&apos;a&apos;] = new Trie(); root = root-&gt;children[words[idx][pos++]-&apos;a&apos;]; &#125; root-&gt;leaf = true; root-&gt;idx = idx; &#125; Trie *buildTrie(vector&lt;string&gt;&amp; words) &#123; Trie *root = new Trie(); int i; for(i=0; i&lt;words.size();i++) insertWords(root, words, i); return root; &#125; void checkWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, int row, int col, Trie *root, vector&lt;string&gt; &amp;res, vector&lt;string&gt;&amp; words) &#123; char temp; if(board[i][j]==&apos;X&apos;) return; // visited before; if(nullptr == root-&gt;children[board[i][j]-&apos;a&apos;]) return ; // no string with such prefix else &#123; temp = board[i][j]; if(root-&gt;children[temp-&apos;a&apos;]-&gt;leaf) // if it is a leaf &#123; res.push_back(words[root-&gt;children[temp-&apos;a&apos;]-&gt;idx]); root-&gt;children[temp-&apos;a&apos;]-&gt;leaf = false; // set to false to indicate that we found it already &#125; board[i][j]=&apos;X&apos;; //mark the current position as visited// check all the possible neighbors if(i&gt;0) checkWords(board, i-1, j, row, col, root-&gt;children[temp-&apos;a&apos;], res, words); if((i+1)&lt;row) checkWords(board, i+1, j, row, col, root-&gt;children[temp-&apos;a&apos;], res, words); if(j&gt;0) checkWords(board, i, j-1, row, col, root-&gt;children[temp-&apos;a&apos;], res, words); if((j+1)&lt;col) checkWords(board, i, j+1, row, col, root-&gt;children[temp-&apos;a&apos;], res, words); board[i][j] = temp; // recover the current position &#125; &#125; vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123; vector&lt;string&gt; res; int row = board.size(); if(0==row) return res; int col = board[0].size(); if(0==col) return res; int wordCount = words.size(); if(0==wordCount) return res; Trie *root = buildTrie(words); int i,j; for(i =0 ; i&lt;row; i++) &#123; for(j=0; j&lt;col &amp;&amp; wordCount &gt; res.size(); j++) &#123; checkWords(board, i, j, row, col, root, res, words); &#125; &#125; return res; &#125; &#125;; Based on the comments received. I created another version with Trie node counter (thanks, zhiqing_xiao and gxyeecspku). However, for the current test set, it doesnâ€™t help too much. Anyway, my version with Trie node counter. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123;private:class Trie&#123;public: Trie * children[26]; bool isLeaf; int wordIdx; int prefixCount; Trie() &#123; isLeaf = false; wordIdx = 0; prefixCount = 0; fill_n(children, 26, nullptr); &#125; ~Trie() &#123; for(auto i=0; i&lt;26; ++i) delete children[i]; &#125;&#125;; void insertWord(Trie *root, const vector&lt;string&gt;&amp; words, int idx) &#123; int i, childID, len = words[idx].size(); for(i=0, root-&gt;prefixCount++ ; i&lt;len; ++i) &#123; childID = words[idx][i]-&apos;a&apos;; if(!root-&gt;children[childID]) root-&gt;children[childID] = new Trie(); root = root-&gt;children[childID]; ++root-&gt;prefixCount; &#125; root-&gt;isLeaf = true; root-&gt;wordIdx = idx; &#125; Trie *buildTrie(const vector&lt;string&gt; &amp;words) &#123; Trie *root = new Trie(); for(int i=0; i &lt; words.size(); ++i) insertWord(root, words, i); return root; &#125; int dfs_Trie(vector&lt;string&gt; &amp;res, Trie *root, vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words, int row, int col) &#123; int detected = 0; if(root-&gt;isLeaf) &#123; ++detected; root-&gt;isLeaf = false; res.push_back(words[root-&gt;wordIdx]); &#125; if( row&lt;0 || row&gt;=board.size() || col&lt;0 || col&gt;=board[0].size() || board[row][col]==&apos;*&apos; || !root-&gt;children[ board[row][col]-&apos;a&apos;] || root-&gt;children[ board[row][col]-&apos;a&apos;]-&gt;prefixCount &lt;= 0 ) return detected; int curC = board[row][col] - &apos;a&apos;; board[row][col] = &apos;*&apos;; detected += dfs_Trie(res, root-&gt;children[curC], board, words, row-1, col) + dfs_Trie(res, root-&gt;children[curC], board, words, row+1, col) + dfs_Trie(res, root-&gt;children[curC], board, words, row, col - 1) + dfs_Trie(res, root-&gt;children[curC], board, words, row, col + 1) ; root-&gt;prefixCount -=detected; board[row][col] = curC+&apos;a&apos;; return detected; &#125; public: vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123; int M, N, wordNum = words.size(); vector&lt;string&gt; res; if( !(M = board.size()) || !(N = board[0].size()) || !wordNum) return res; Trie *root = buildTrie(words); for(auto i=0; i&lt;M &amp;&amp; root-&gt;prefixCount; ++i) for(auto j=0; j&lt;N; ++j) dfs_Trie(res, root, board, words, i, j); delete root; return res; &#125;&#125;; https://discuss.leetcode.com/topic/20210/my-ac-very-clean-c-code My AC very clean C++ code The idea is start from every position of the board, and then see if we can find a word starting from this position with checking if is_end is true in TrieNode structure 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class TrieNode&#123;public: bool is_end; vector&lt;TrieNode*&gt; children; TrieNode()&#123; is_end=false; children=vector&lt;TrieNode*&gt;(26, NULL); &#125; &#125;;class Trie&#123;public: TrieNode* getRoot()&#123;return root;&#125; Trie(vector&lt;string&gt;&amp; words)&#123; root=new TrieNode(); for(int i=0; i&lt;words.size(); ++i) addWord(words[i]); &#125; void addWord(const string&amp; word)&#123; TrieNode* cur=root; for(int i=0; i&lt;word.size(); ++i)&#123; int index=word[i]-&apos;a&apos;; if(cur-&gt;children[index]==NULL) cur-&gt;children[index]=new TrieNode(); cur=cur-&gt;children[index]; &#125; cur-&gt;is_end=true; &#125;private: TrieNode* root;&#125;;class Solution &#123;public: vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123; Trie* trie = new Trie(words); TrieNode* root=trie-&gt;getRoot(); set&lt;string&gt; result_set; for(int x=0; x&lt;board.size(); ++x) for(int y=0; y&lt;board[0].size(); ++y) findWords(board, x, y, root, &quot;&quot;, result_set); vector&lt;string&gt; result; for(auto it:result_set) result.push_back(it); return result; &#125;private: void findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, TrieNode* root, string word, set&lt;string&gt;&amp; result)&#123; if(x&lt;0||x&gt;=board.size()||y&lt;0||y&gt;=board[0].size() || board[x][y]==&apos; &apos;) return; if(root-&gt;children[board[x][y]-&apos;a&apos;] != NULL)&#123; word=word+board[x][y]; root=root-&gt;children[board[x][y]-&apos;a&apos;]; if(root-&gt;is_end) result.insert(word); char c=board[x][y]; board[x][y]=&apos; &apos;; findWords(board, x+1, y, root, word, result); findWords(board, x-1, y, root, word, result); findWords(board, x, y+1, root, word, result); findWords(board, x, y-1, root, word, result); board[x][y]=c; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/14307/27-lines-uses-complex-numbers 27 lines, uses complex numbers I first build the tree of words with root root and also represent the board a different way, namely as one-dimensional dictionary where the keys are complex numbers representing the row/column indexes. That makes further work with it easier. Looping over all board positions is just for z in board, the four neighbors of a board position z are just z + 1j**k (for k in 0 to 3), and I donâ€™t need to check borders because board.get just returns â€œNoneâ€ if I request an invalid position. After this preparation, I just take the tree and recursively dive with it into each board position. Similar to how youâ€™d search a single word, but with the tree instead. 123456789101112131415161718192021222324252627class Solution: def findWords(self, board, words): root = &#123;&#125; for word in words: node = root for c in word: node = node.setdefault(c, &#123;&#125;) node[None] = True board = &#123;i + 1j*j: c for i, row in enumerate(board) for j, c in enumerate(row)&#125; found = [] def search(node, z, word): if node.pop(None, None): found.append(word) c = board.get(z) if c in node: board[z] = None for k in range(4): search(node[c], z + 1j**k, word + c) board[z] = c for z in board: search(root, z, &apos;&apos;) return found https://discuss.leetcode.com/topic/16782/python-code-use-trie-and-dfs-380ms Python code use trie and dfs 380ms 123456789101112131415161718192021222324252627282930313233class Solution: # @param &#123;character[][]&#125; board # @param &#123;string[]&#125; words # @return &#123;string[]&#125; def findWords(self, board, words): #make trie trie=&#123;&#125; for w in words: t=trie for c in w: if c not in t: t[c]=&#123;&#125; t=t[c] t[&apos;#&apos;]=&apos;#&apos; self.res=set() self.used=[[False]*len(board[0]) for _ in range(len(board))] for i in range(len(board)): for j in range(len(board[0])): self.find(board,i,j,trie,&apos;&apos;) return list(self.res) def find(self,board,i,j,trie,pre): if &apos;#&apos; in trie: self.res.add(pre) if i&lt;0 or i&gt;=len(board) or j&lt;0 or j&gt;=len(board[0]): return if not self.used[i][j] and board[i][j] in trie: self.used[i][j]=True self.find(board,i+1,j,trie[board[i][j]],pre+board[i][j]) self.find(board,i,j+1,trie[board[i][j]],pre+board[i][j]) self.find(board,i-1,j,trie[board[i][j]],pre+board[i][j]) self.find(board,i,j-1,trie[board[i][j]],pre+board[i][j]) self.used[i][j]=False https://discuss.leetcode.com/topic/22858/python-dfs-solution-directly-use-trie-implemented Python dfs solution (directly use Trie implemented). Here is an implementation based on Implement Trie in LeetCode. TrieNode, Trie, Solution are treated as seperated classes. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class TrieNode(): def __init__(self): self.children = collections.defaultdict(TrieNode) self.isWord = False class Trie(): def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for w in word: node = node.children[w] node.isWord = True def search(self, word): node = self.root for w in word: node = node.children.get(w) if not node: return False return node.isWord class Solution(object): def findWords(self, board, words): res = [] trie = Trie() node = trie.root for w in words: trie.insert(w) for i in xrange(len(board)): for j in xrange(len(board[0])): self.dfs(board, node, i, j, &quot;&quot;, res) return res def dfs(self, board, node, i, j, path, res): if node.isWord: res.append(path) node.isWord = False if i &lt; 0 or i &gt;= len(board) or j &lt; 0 or j &gt;= len(board[0]): return tmp = board[i][j] node = node.children.get(tmp) if not node: return board[i][j] = &quot;#&quot; self.dfs(board, node, i+1, j, path+tmp, res) self.dfs(board, node, i-1, j, path+tmp, res) self.dfs(board, node, i, j-1, path+tmp, res) self.dfs(board, node, i, j+1, path+tmp, res) board[i][j] = tmp 19ms, 90.34%, September 23, 2016 https://discuss.leetcode.com/topic/9826/my-19ms-accepted-c-code 123456789101112131415161718192021222324252627class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; m = board.size(); n = board[0].size(); for(int x=0; x&lt;m; x++) for(int y=0; y&lt;n; y++) if(isFound(board, word.c_str(), x, y)) return true; return false; &#125; private: int m; int n; bool isFound(vector&lt;vector&lt;char&gt;&gt;&amp; board, const char* w, int x, int y)&#123; if(x&lt;0||y&lt;0||x&gt;=m||y&gt;=n||board[x][y]==&apos;\0&apos;||*w!=board[x][y]) return false; if(*(w+1)==&apos;\0&apos;) return true; char t = board[x][y]; board[x][y] = &apos;\0&apos;; if(isFound(board, w+1, x-1, y)||isFound(board, w+1, x+1, y)||isFound(board, w+1, x, y-1)||isFound(board, w+1, x, y+1)) return true; board[x][y] = t; return false; &#125;&#125;; 47ms, September 23, 2016 https://discuss.leetcode.com/topic/7907/accepted-very-short-java-solution-no-additional-space 12345678910111213141516171819202122public class Solution &#123; public boolean exist(char[][] board, String word) &#123; char[] w= word.toCharArray(); for(int y=0; y&lt;board.length; y++) for(int x=0; x&lt;board[y].length; x++) if(exist(board, y, x, w, 0)) return true; return false; &#125; private boolean exist(char[][] board, int y, int x, char[] word, int i)&#123; if(i==word.length) return true; if(y&lt;0||x&lt;0||y==board.length||x==board[y].length) return false; if(board[y][x] != word[i]) return false; board[y][x] ^= 256; boolean exist = exist(board, y, x+1, word, i+1) || exist(board, y, x-1, word, i+1) || exist(board, y+1, x, word, i+1) || exist(board, y-1, x, word, i+1); board[y][x] ^= 256; return exist; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[211. Add and Search Word - Data structure design]]></title>
    <url>%2Fp%2F7bf4b9ae%2F</url>
    <content type="text"><![CDATA[21.1% Design a data structure that supports the following two operations: 12void addWord(word)bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. 123456789For example:addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true Note:You may assume that all words are consist of lowercase letters a-z. click to show hint. You should be familiar with how a Trie works. If not, please work on this problem: Implement Trie (Prefix Tree) first. https://discuss.leetcode.com/topic/15581/80ms-clear-c-code-with-detailed-explanations 80ms Clear C++ Code with Detailed Explanations This problem is an application of the Trie data structure. In the following, it is assumed that you have solved Implement Trie (Prefix Tree). Now, letâ€™s first look at the TrieNode class. I define it as follows. 12345678class TrieNode &#123;public: bool isKey; TrieNode* children[26]; TrieNode(): isKey(false) &#123; memset(children, NULL, sizeof(TrieNode*) * 26); &#125;&#125;; The field isKey is to label whether the string comprised of characters starting from root to the current node is a key (word that has been added). In this problem, only lower-case letters a - z need to be considered, so each TrieNode has at most 26 children. I store it in an array of TrieNode*: children[i] corresponds to letter â€˜aâ€™ + i. The remaining code defines the constructor of the TrieNode class. Adding a word can be done in the same way as in Implement Trie (Prefix Tree). The basic idea is to create a TrieNode corresponding to each letter in the word. When we are done, label the last node to be a key (set isKey = true). The code is as follows. 123456789void addWord(string word) &#123; TrieNode* run = root; for (char c : word) &#123; if (!(run -&gt; children[c - &apos;a&apos;])) run -&gt; children[c - &apos;a&apos;] = new TrieNode(); run = run -&gt; children[c - &apos;a&apos;]; &#125; run -&gt; isKey = true;&#125; By the way, root is defined as private data of WordDictionary: 12private: TrieNode* root; And the WordDictionary class has a constructor to initialize root: 123WordDictionary() &#123; root = new TrieNode();&#125; Now we are left only with search. Letâ€™s do it. The basic idea is still the same as typical search operations in a Trie. The critical part is how to deal with the dots .. Well, my solution is very naive in this place. Each time when we reach a ., just traverse all the children of the current node and recursively search the remaining substring in word starting from that children. So I define a helper function query for search that takes in a string and a starting node. And the initial call to query is like query(word, root). By the way, I pass a char* instead of string to query and it greatly speeds up the code. So the initial call to query is actually query(word.c_str(), root). Now I put all the codes together below. Hope it to be useful! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class TrieNode &#123;public: bool isKey; TrieNode* children[26]; TrieNode(): isKey(false) &#123; memset(children, NULL, sizeof(TrieNode*) * 26); &#125;&#125;;class WordDictionary &#123;public: WordDictionary() &#123; root = new TrieNode(); &#125; // Adds a word into the data structure. void addWord(string word) &#123; TrieNode* run = root; for (char c : word) &#123; if (!(run -&gt; children[c - &apos;a&apos;])) run -&gt; children[c - &apos;a&apos;] = new TrieNode(); run = run -&gt; children[c - &apos;a&apos;]; &#125; run -&gt; isKey = true; &#125; // Returns if the word is in the data structure. A word could // contain the dot character &apos;.&apos; to represent any one letter. bool search(string word) &#123; return query(word.c_str(), root); &#125;private: TrieNode* root; bool query(const char* word, TrieNode* node) &#123; TrieNode* run = node; for (int i = 0; word[i]; i++) &#123; if (run &amp;&amp; word[i] != &apos;.&apos;) run = run -&gt; children[word[i] - &apos;a&apos;]; else if (run &amp;&amp; word[i] == &apos;.&apos;) &#123; TrieNode* tmp = run; for (int j = 0; j &lt; 26; j++) &#123; run = tmp -&gt; children[j]; if (query(word + i + 1, run)) return true; &#125; &#125; else break; &#125; return run &amp;&amp; run -&gt; isKey; &#125;&#125;;// Your WordDictionary object will be instantiated and called as such:// WordDictionary wordDictionary;// wordDictionary.addWord(&quot;word&quot;);// wordDictionary.search(&quot;pattern&quot;); https://discuss.leetcode.com/topic/18578/c-using-trie-and-dfs-for-search-easy-understand-solution C++ using Trie and DFS for search. easy understand solution 12345678910111213141516171819202122232425262728293031323334struct Trie &#123; vector&lt;Trie *&gt; child; bool isWord; Trie() : isWord(false), child(vector&lt;Trie *&gt;(26, nullptr)) &#123;&#125; &#125;; Trie *root; WordDictionary() : root(new Trie()) &#123;&#125;void addWord(string word) &#123; const int size_w = word.size(); Trie *cur = root; for (int i = 0; i &lt; size_w; i++) &#123; int index = word[i] - &apos;a&apos;; if (!cur-&gt;child[index]) cur-&gt;child[index] = new Trie(); cur = cur-&gt;child[index]; &#125; cur-&gt;isWord = true;&#125;bool search(string word) &#123; return search(word.c_str(), root);&#125;bool search(const char *ch, TrieNode *cur) &#123; if (!cur) return false; if (*ch == &apos;\0&apos;) return cur-&gt;isWord; if (*ch != &apos;.&apos;) &#123; return search(ch+1, cur-&gt;child[*ch - &apos;a&apos;]); &#125; else &#123; for (int i = 0; i &lt;= 25; i++) &#123; if (search(ch+1, cur-&gt;child[i])) return true; &#125; return false; &#125;&#125; https://discuss.leetcode.com/topic/29809/python-168ms-beat-100-solution Python 168ms-beat-100% solution 12345678910111213141516171819202122class WordDictionary(object): def __init__(self): self.word_dict = collections.defaultdict(list) def addWord(self, word): if word: self.word_dict[len(word)].append(word) def search(self, word): if not word: return False if &apos;.&apos; not in word: return word in self.word_dict[len(word)] for v in self.word_dict[len(word)]: # match xx.xx.x with yyyyyyy for i, ch in enumerate(word): if ch != v[i] and ch != &apos;.&apos;: break else: return True return False The search function could be done in a more pythonic way, but I see that performance has suffered so I just wrote the raw logic by myself. https://discuss.leetcode.com/topic/14216/tree-solutions-18-20-lines Tree solutions, 18-20 lines 1234567891011121314151617181920class WordDictionary: def __init__(self): self.root = &#123;&#125; def addWord(self, word): node = self.root for char in word: node = node.setdefault(char, &#123;&#125;) node[None] = None def search(self, word): def find(word, node): if not word: return None in node char, word = word[0], word[1:] if char != &apos;.&apos;: return char in node and find(word, node[char]) return any(find(word, kid) for kid in node.values() if kid) return find(word, self.root) An iterative alternative for the search method: 12345678def search(self, word): nodes = [self.root] for char in word: nodes = [kid for node in nodes for key, kid in node.items() if char in (key, &apos;.&apos;) and kid] return any(None in node for node in nodes) And one thatâ€™s a bit longer but faster: 1234567def search(self, word): nodes = [self.root] for char in word: nodes = [kid for node in nodes for kid in ([node[char]] if char in node else filter(None, node.values()) if char == &apos;.&apos; else [])] return any(None in node for node in nodes) And a neat version where I append my end-marker to the word to simplify the final check: 123456789101112131415161718class WordDictionary: def __init__(self): self.root = &#123;&#125; def addWord(self, word): node = self.root for char in word: node = node.setdefault(char, &#123;&#125;) node[&apos;$&apos;] = None def search(self, word): nodes = [self.root] for char in word + &apos;$&apos;: nodes = [kid for node in nodes for kid in ([node[char]] if char in node else filter(None, node.values()) if char == &apos;.&apos; else [])] return bool(nodes) https://discuss.leetcode.com/topic/26944/python-solution-recursive-version-dfs Python solution recursive version (DFS) 123456789101112131415161718192021222324252627282930313233class TrieNode(object):def __init__(self): self.word = False self.children = &#123;&#125;class WordDictionary(object):def __init__(self): self.root = TrieNode()def addWord(self, word): node = self.root for c in word: if c not in node.children: node.children[c] = TrieNode() node = node.children[c] node.word = Truedef search(self, word): return self.searchFrom(self.root, word)def searchFrom(self, node, word): for i in xrange(len(word)): c = word[i] if c == &apos;.&apos;: for k in node.children: if self.searchFrom(node.children[k], word[i+1:]): return True return False elif c not in node.children: return False node = node.children[c] return node.word]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
        <tag>design</tag>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[210. Course Schedule II]]></title>
    <url>%2Fp%2Fe6c1d8e3%2F</url>
    <content type="text"><![CDATA[26.5% There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. 123For example:2, [[1,0]] There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] 14, [[1,0],[2,0],[3,1],[3,2]] There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3]. Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites. Hints: This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses. Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort. Topological sort could also be done via BFS. https://discuss.leetcode.com/topic/17276/20-lines-c-bfs-dfs-solutions 20+ lines C++ BFS/DFS Solutions Well, this problem is spiritually similar to to Course Schedule. You only need to store the nodes in the order you visit into a vector during BFS or DFS. Well, for DFS, a final reversal is required. BFS 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph = make_graph(numCourses, prerequisites); vector&lt;int&gt; degrees = compute_indegree(graph); queue&lt;int&gt; zeros; for (int i = 0; i &lt; numCourses; i++) if (!degrees[i]) zeros.push(i); vector&lt;int&gt; toposort; for (int i = 0; i &lt; numCourses; i++) &#123; if (zeros.empty()) return &#123;&#125;; int zero = zeros.front(); zeros.pop(); toposort.push_back(zero); for (int neigh : graph[zero]) &#123; if (!--degrees[neigh]) zeros.push(neigh); &#125; &#125; return toposort; &#125;private: vector&lt;unordered_set&lt;int&gt;&gt; make_graph(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph(numCourses); for (auto pre : prerequisites) graph[pre.second].insert(pre.first); return graph; &#125; vector&lt;int&gt; compute_indegree(vector&lt;unordered_set&lt;int&gt;&gt;&amp; graph) &#123; vector&lt;int&gt; degrees(graph.size(), 0); for (auto neighbors : graph) for (int neigh : neighbors) degrees[neigh]++; return degrees; &#125;&#125;; DFS 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph = make_graph(numCourses, prerequisites); vector&lt;int&gt; toposort; vector&lt;bool&gt; onpath(numCourses, false), visited(numCourses, false); for (int i = 0; i &lt; numCourses; i++) if (!visited[i] &amp;&amp; dfs(graph, i, onpath, visited, toposort)) return &#123;&#125;; reverse(toposort.begin(), toposort.end()); return toposort; &#125;private: vector&lt;unordered_set&lt;int&gt;&gt; make_graph(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph(numCourses); for (auto pre : prerequisites) graph[pre.second].insert(pre.first); return graph; &#125; bool dfs(vector&lt;unordered_set&lt;int&gt;&gt;&amp; graph, int node, vector&lt;bool&gt;&amp; onpath, vector&lt;bool&gt;&amp; visited, vector&lt;int&gt;&amp; toposort) &#123; if (visited[node]) return false; onpath[node] = visited[node] = true; for (int neigh : graph[node]) if (onpath[neigh] || dfs(graph, neigh, onpath, visited, toposort)) return true; toposort.push_back(node); return onpath[node] = false; &#125;&#125;; https://discuss.leetcode.com/topic/23925/python-dfs-bfs-solutions-with-comments Python dfs, bfs solutions with comments. BFS 123456789101112131415161718def findOrder1(self, numCourses, prerequisites): dic = &#123;i: set() for i in xrange(numCourses)&#125; neigh = collections.defaultdict(set) for i, j in prerequisites: dic[i].add(j) neigh[j].add(i) # queue stores the courses which have no prerequisites queue = collections.deque([i for i in dic if not dic[i]]) count, res = 0, [] while queue: node = queue.popleft() res.append(node) count += 1 for i in neigh[node]: dic[i].remove(node) if not dic[i]: queue.append(i) return res if count == numCourses else [] DFS 1234567891011121314151617def findOrder(self, numCourses, prerequisites): dic = collections.defaultdict(set) neigh = collections.defaultdict(set) for i, j in prerequisites: dic[i].add(j) neigh[j].add(i) stack = [i for i in xrange(numCourses) if not dic[i]] res = [] while stack: node = stack.pop() res.append(node) for i in neigh[node]: dic[i].remove(node) if not dic[i]: stack.append(i) dic.pop(node) return res if not dic else [] https://discuss.leetcode.com/topic/13982/c-using-3-colored-approach [C++] Using 3 colored approach Here, i have used 3 colored approach. Here w -&gt; represent white means vertex yet not visited.g -&gt; gray , it means it is under DFS recursion and we again found the same node. This means cycle exists and return false. b -&gt; black node when DFS is done visiting the node. This method checks cycle as well as keeps storing answer in stack in case cycle doesnâ€™t exists. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Graph &#123; public: int v; list &lt;int&gt; *adj; Graph(int v) &#123; this-&gt;v=v; adj = new list&lt;int&gt; [v]; &#125; void addedges(int src , int dest) &#123; adj[dest].push_back(src); &#125; &#125;;class Solution &#123;public: stack &lt;int&gt; st; vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; Graph g(numCourses); for (int i=0 ; i &lt; prerequisites.size() ; i++) g.addedges(prerequisites[i].first , prerequisites[i].second); vector &lt;int&gt; ans; if(!courseScheduleCheck(g)) return ans; while(!st.empty()) &#123; ans.push_back(st.top()); st.pop(); &#125; return ans; &#125; bool courseScheduleCheck(Graph g) &#123; int v = g.v; vector &lt;char&gt; visit(v,&apos;w&apos;); for(int i=0 ; i&lt;v;i++) &#123; if(visit[i]== &apos;w&apos;) if(iscycle(g,i,visit)) return false; &#125; return true; &#125; bool iscycle(Graph g , int i, vector &lt;char&gt; &amp; visit) &#123; list &lt;int&gt; ::iterator it; for(it = g.adj[i].begin() ; it!=g.adj[i].end() ; it++) &#123; if(visit[*it]== &apos;g&apos;) return true; else &#123; if(visit[*it] != &apos;b&apos;) &#123; visit[*it] = &apos;g&apos;; if(iscycle(g,*it,visit)) return true; &#125; &#125; &#125; visit[i]=&apos;b&apos;; st.push(i); return false; &#125; &#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>depth first search</tag>
        <tag>graph</tag>
        <tag>breath first search</tag>
        <tag>topological sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[209. Minimum Size Subarray Sum]]></title>
    <url>%2Fp%2Fcf54181a%2F</url>
    <content type="text"><![CDATA[29.4% https://leetcode.com/problems/minimum-size-subarray-sum/ Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum â‰¥ s. If there isnâ€™t one, return 0 instead. 12For example, given the array [2,3,1,2,4,3] and s = 7,the subarray [4,3] has the minimal length under the problem constraint. More practice: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; int res = INT_MAX; int i=-1, j=0, sum=0; while(j&lt;n)&#123; sum += nums[j++]; while(sum&gt;=s)&#123; res = min(res, j-i-1); sum -= nums[++i]; &#125; &#125; return res==INT_MAX? 0 : res; &#125;&#125;; 8ms, 14.16%, June.24th, 2016 https://leetcode.com/discuss/42143/4ms-o-n-8ms-o-nlogn-c 1234567891011121314class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), start = 0, sum = 0, minlen = INT_MAX; for (int i = 0; i &lt; n; i++) &#123; sum += nums[i]; while (sum &gt;= s) &#123; minlen = min(minlen, i - start + 1); sum -= nums[start++]; &#125; &#125; return minlen == INT_MAX ? 0 : minlen; &#125;&#125;; å­¦ä¹ åŒºï¼š https://discuss.leetcode.com/topic/37844/o-n-template-for-minimum-size-subarray-sum-minimum-window-substring-longest-substring-without-repeating-characters O(N) template for Minimum Size Subarray Sum &amp; Minimum Window Substring &amp; Longest Substring Without Repeating Characters First , I will show you the solution of this problem, 123456789101112131415161718class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int start=0, end=0; int minLen=INT_MAX, sum=0; while(end&lt;nums.size())&#123; if(sum&lt;s) sum+=nums[end]; end++; while(sum&gt;=s)&#123; if(end-start&lt;minLen) minLen=end-start; sum-=nums[start]; start++; &#125; &#125; return minLen==INT_MAX ? 0 : minLen; &#125;&#125;; Next, let me show you the solution to the problem â€œMinimum Window Substringâ€ 12345678910111213141516171819202122232425class Solution &#123;public: string minWindow(string s, string t) &#123; vector&lt;int&gt; v(128, 0); for(auto c:t) v[c]++; int start=0, end=0, counter=t.size(); int m_start=0, m_len=INT_MAX; while(end&lt;s.size())&#123; if(v[s[end]]&gt;0) counter--; v[s[end]]--; end++; /** loop from start to check whether we can find more short string **/ while(counter==0)&#123; if(m_len&gt;end-start)&#123; m_start=start; m_len=end-start; &#125; v[s[start]]++; if(v[s[start]]&gt;0) counter++; start++; &#125; &#125; return m_len==INT_MAX ? &quot;&quot; : s.substr(m_start, m_len); &#125;&#125;; The solution for the problem â€œLongest Substring Without Repeating Charactersâ€ can also be solved in the same pattern . Here is the solution for â€œLongest Substring Without Repeating Charactersâ€ 123456789101112131415161718class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; v(128, 0); int start=0, end=0; int m_len=INT_MIN; while(end&lt;s.size())&#123; if(v[s[end]]==0) m_len=max(m_len, end-start+1); v[s[end]]++; end++; while(v[s[end]]&gt;0)&#123; v[s[start]]--; start++; &#125; &#125; return m_len==INT_MIN ? 0 : m_len; &#125;&#125;; As you can see, they all follow the same pattern ! This post deserves your up vote! 1ms, 16.03%, June.24th, 2016 https://leetcode.com/discuss/45449/accepted-clean-java-o-n-solution-two-pointers 12345678910111213141516171819public class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; if(nums == null || nums.length == 0) return 0; int i = 0, j = 0, sum = 0, min = Integer.MAX_VALUE; while(j &lt; nums.length)&#123; sum += nums[j++]; while(sum &gt;= s)&#123; min = Math.min(min, j - i); sum -= nums[i++]; &#125; &#125; return min == Integer.MAX_VALUE ? 0 : min; &#125;&#125; 47ms, 96.87%, June.24th, 2016 https://leetcode.com/discuss/36384/python-o-n-and-o-n-log-n-solution 12345678910111213141516class Solution(object): def minSubArrayLen(self, s, nums): &quot;&quot;&quot; :type s: int :type nums: List[int] :rtype: int &quot;&quot;&quot; total = left = 0 result = len(nums) + 1 for right, n in enumerate(nums): total += n while total &gt;= s: result = min(result, right - left + 1) total -= nums[left] left += 1 return result if result &lt;= len(nums) else 0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[208. Implement Trie (Prefix Tree)]]></title>
    <url>%2Fp%2Fb78a563d%2F</url>
    <content type="text"><![CDATA[26.6% https://leetcode.com/problems/implement-trie-prefix-tree/#/description Implement a trie with insert, search, and startsWith methods. Note: You may assume that all inputs are consist of lowercase letters a-z. http://blog.csdn.net/lisonglisonglisong/article/details/45584721 å…³äºŽå‰ç¼€æ ‘ï¼Œå¯ä»¥å‚è€ƒä»¥ä¸Šæ–‡ç« ã€‚ ä¸€ã€ä»€ä¹ˆæ˜¯Trieæ ‘ Trieæ ‘ï¼Œåˆå«å­—å…¸æ ‘ã€å‰ç¼€æ ‘ï¼ˆPrefix Treeï¼‰ã€å•è¯æŸ¥æ‰¾æ ‘ æˆ– é”®æ ‘ï¼Œæ˜¯ä¸€ç§å¤šå‰æ ‘ç»“æž„ã€‚å¦‚ä¸‹å›¾ï¼š ä¸Šå›¾æ˜¯ä¸€æ£µTrieæ ‘ï¼Œè¡¨ç¤ºäº†å…³é”®å­—é›†åˆ{â€œaâ€, â€œtoâ€, â€œteaâ€, â€œtedâ€, â€œtenâ€, â€œiâ€, â€œinâ€, â€œinnâ€} ã€‚ä»Žä¸Šå›¾å¯ä»¥å½’çº³å‡ºTrieæ ‘çš„åŸºæœ¬æ€§è´¨ï¼š æ ¹èŠ‚ç‚¹ä¸åŒ…å«å­—ç¬¦ï¼Œé™¤æ ¹èŠ‚ç‚¹å¤–çš„æ¯ä¸€ä¸ªå­èŠ‚ç‚¹éƒ½åŒ…å«ä¸€ä¸ªå­—ç¬¦ã€‚ ä»Žæ ¹èŠ‚ç‚¹åˆ°æŸä¸€ä¸ªèŠ‚ç‚¹ï¼Œè·¯å¾„ä¸Šç»è¿‡çš„å­—ç¬¦è¿žæŽ¥èµ·æ¥ï¼Œä¸ºè¯¥èŠ‚ç‚¹å¯¹åº”çš„å­—ç¬¦ä¸²ã€‚ æ¯ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹åŒ…å«çš„å­—ç¬¦äº’ä¸ç›¸åŒã€‚ é€šå¸¸åœ¨å®žçŽ°çš„æ—¶å€™ï¼Œä¼šåœ¨èŠ‚ç‚¹ç»“æž„ä¸­è®¾ç½®ä¸€ä¸ªæ ‡å¿—ï¼Œç”¨æ¥æ ‡è®°è¯¥ç»“ç‚¹å¤„æ˜¯å¦æž„æˆä¸€ä¸ªå•è¯ï¼ˆå…³é”®å­—ï¼‰ã€‚ å¯ä»¥çœ‹å‡ºï¼ŒTrieæ ‘çš„å…³é”®å­—ä¸€èˆ¬éƒ½æ˜¯å­—ç¬¦ä¸²ï¼Œè€Œä¸”Trieæ ‘æŠŠæ¯ä¸ªå…³é”®å­—ä¿å­˜åœ¨ä¸€æ¡è·¯å¾„ä¸Šï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç»“ç‚¹ä¸­ã€‚å¦å¤–ï¼Œä¸¤ä¸ªæœ‰å…¬å…±å‰ç¼€çš„å…³é”®å­—ï¼Œåœ¨Trieæ ‘ä¸­å‰ç¼€éƒ¨åˆ†çš„è·¯å¾„ç›¸åŒï¼Œæ‰€ä»¥Trieæ ‘åˆå«åšå‰ç¼€æ ‘ï¼ˆPrefix Treeï¼‰ã€‚ äºŒã€Trieæ ‘çš„ä¼˜ç¼ºç‚¹ Trieæ ‘çš„æ ¸å¿ƒæ€æƒ³æ˜¯ç©ºé—´æ¢æ—¶é—´ï¼Œåˆ©ç”¨å­—ç¬¦ä¸²çš„å…¬å…±å‰ç¼€æ¥å‡å°‘æ— è°“çš„å­—ç¬¦ä¸²æ¯”è¾ƒä»¥è¾¾åˆ°æé«˜æŸ¥è¯¢æ•ˆçŽ‡çš„ç›®çš„ã€‚ ä¼˜ç‚¹ æ’å…¥å’ŒæŸ¥è¯¢çš„æ•ˆçŽ‡å¾ˆé«˜ï¼Œéƒ½ä¸ºO(m)ï¼Œå…¶ä¸­ m æ˜¯å¾…æ’å…¥/æŸ¥è¯¢çš„å­—ç¬¦ä¸²çš„é•¿åº¦ã€‚ -å…³äºŽæŸ¥è¯¢ï¼Œä¼šæœ‰äººè¯´ hash è¡¨æ—¶é—´å¤æ‚åº¦æ˜¯O(1)ä¸æ˜¯æ›´å¿«ï¼Ÿä½†æ˜¯ï¼Œå“ˆå¸Œæœç´¢çš„æ•ˆçŽ‡é€šå¸¸å–å†³äºŽ hash å‡½æ•°çš„å¥½åï¼Œè‹¥ä¸€ä¸ªåçš„ hash å‡½æ•°å¯¼è‡´å¾ˆå¤šçš„å†²çªï¼Œæ•ˆçŽ‡å¹¶ä¸ä¸€å®šæ¯”Trieæ ‘é«˜ã€‚ Trieæ ‘ä¸­ä¸åŒçš„å…³é”®å­—ä¸ä¼šäº§ç”Ÿå†²çªã€‚ Trieæ ‘åªæœ‰åœ¨å…è®¸ä¸€ä¸ªå…³é”®å­—å…³è”å¤šä¸ªå€¼çš„æƒ…å†µä¸‹æ‰æœ‰ç±»ä¼¼hashç¢°æ’žå‘ç”Ÿã€‚ Trieæ ‘ä¸ç”¨æ±‚ hash å€¼ï¼Œå¯¹çŸ­å­—ç¬¦ä¸²æœ‰æ›´å¿«çš„é€Ÿåº¦ã€‚é€šå¸¸ï¼Œæ±‚hashå€¼ä¹Ÿæ˜¯éœ€è¦éåŽ†å­—ç¬¦ä¸²çš„ã€‚ Trieæ ‘å¯ä»¥å¯¹å…³é”®å­—æŒ‰å­—å…¸åºæŽ’åºã€‚ ç¼ºç‚¹ å½“ hash å‡½æ•°å¾ˆå¥½æ—¶ï¼ŒTrieæ ‘çš„æŸ¥æ‰¾æ•ˆçŽ‡ä¼šä½ŽäºŽå“ˆå¸Œæœç´¢ã€‚ ç©ºé—´æ¶ˆè€—æ¯”è¾ƒå¤§ã€‚ ä¸‰ã€Trieæ ‘çš„åº”ç”¨ å­—ç¬¦ä¸²æ£€ç´¢ æ£€ç´¢/æŸ¥è¯¢åŠŸèƒ½æ˜¯Trieæ ‘æœ€åŽŸå§‹çš„åŠŸèƒ½ã€‚æ€è·¯å°±æ˜¯ä»Žæ ¹èŠ‚ç‚¹å¼€å§‹ä¸€ä¸ªä¸€ä¸ªå­—ç¬¦è¿›è¡Œæ¯”è¾ƒï¼š å¦‚æžœæ²¿è·¯æ¯”è¾ƒï¼Œå‘çŽ°ä¸åŒçš„å­—ç¬¦ï¼Œåˆ™è¡¨ç¤ºè¯¥å­—ç¬¦ä¸²åœ¨é›†åˆä¸­ä¸å­˜åœ¨ã€‚å¦‚æžœæ‰€æœ‰çš„å­—ç¬¦å…¨éƒ¨æ¯”è¾ƒå®Œå¹¶ä¸”å…¨éƒ¨ç›¸åŒï¼Œè¿˜éœ€åˆ¤æ–­æœ€åŽä¸€ä¸ªèŠ‚ç‚¹çš„æ ‡å¿—ä½ï¼ˆæ ‡è®°è¯¥èŠ‚ç‚¹æ˜¯å¦ä»£è¡¨ä¸€ä¸ªå…³é”®å­—ï¼‰ã€‚ 12345struct trie_node&#123; bool isKey; // æ ‡è®°è¯¥èŠ‚ç‚¹æ˜¯å¦ä»£è¡¨ä¸€ä¸ªå…³é”®å­— trie_node *children[26]; // å„ä¸ªå­èŠ‚ç‚¹ &#125;; è¯é¢‘ç»Ÿè®¡ Trieæ ‘å¸¸è¢«æœç´¢å¼•æ“Žç³»ç»Ÿç”¨äºŽæ–‡æœ¬è¯é¢‘ç»Ÿè®¡ ã€‚ 12345struct trie_node&#123; int count; // è®°å½•è¯¥èŠ‚ç‚¹ä»£è¡¨çš„å•è¯çš„ä¸ªæ•° trie_node *children[26]; // å„ä¸ªå­èŠ‚ç‚¹ &#125;; æ€è·¯ï¼šä¸ºäº†å®žçŽ°è¯é¢‘ç»Ÿè®¡ï¼Œæˆ‘ä»¬ä¿®æ”¹äº†èŠ‚ç‚¹ç»“æž„ï¼Œç”¨ä¸€ä¸ªæ•´åž‹å˜é‡countæ¥è®¡æ•°ã€‚å¯¹æ¯ä¸€ä¸ªå…³é”®å­—æ‰§è¡Œæ’å…¥æ“ä½œï¼Œè‹¥å·²å­˜åœ¨ï¼Œè®¡æ•°åŠ 1ï¼Œè‹¥ä¸å­˜åœ¨ï¼Œæ’å…¥åŽcountç½®1ã€‚ æ³¨æ„ï¼šç¬¬ä¸€ã€ç¬¬äºŒç§åº”ç”¨ä¹Ÿéƒ½å¯ä»¥ç”¨ hash table æ¥åšã€‚ å­—ç¬¦ä¸²æŽ’åº Trieæ ‘å¯ä»¥å¯¹å¤§é‡å­—ç¬¦ä¸²æŒ‰å­—å…¸åºè¿›è¡ŒæŽ’åºï¼Œæ€è·¯ä¹Ÿå¾ˆç®€å•ï¼šéåŽ†ä¸€æ¬¡æ‰€æœ‰å…³é”®å­—ï¼Œå°†å®ƒä»¬å…¨éƒ¨æ’å…¥trieæ ‘ï¼Œæ ‘çš„æ¯ä¸ªç»“ç‚¹çš„æ‰€æœ‰å„¿å­å¾ˆæ˜¾ç„¶åœ°æŒ‰ç…§å­—æ¯è¡¨æŽ’åºï¼Œç„¶åŽå…ˆåºéåŽ†è¾“å‡ºTrieæ ‘ä¸­æ‰€æœ‰å…³é”®å­—å³å¯ã€‚ å‰ç¼€åŒ¹é… ä¾‹å¦‚ï¼šæ‰¾å‡ºä¸€ä¸ªå­—ç¬¦ä¸²é›†åˆä¸­æ‰€æœ‰ä»¥abå¼€å¤´çš„å­—ç¬¦ä¸²ã€‚æˆ‘ä»¬åªéœ€è¦ç”¨æ‰€æœ‰å­—ç¬¦ä¸²æž„é€ ä¸€ä¸ªtrieæ ‘ï¼Œç„¶åŽè¾“å‡ºä»¥a-&gt;b-&gt;å¼€å¤´çš„è·¯å¾„ä¸Šçš„å…³é”®å­—å³å¯ã€‚ trieæ ‘å‰ç¼€åŒ¹é…å¸¸ç”¨äºŽæœç´¢æç¤ºã€‚å¦‚å½“è¾“å…¥ä¸€ä¸ªç½‘å€ï¼Œå¯ä»¥è‡ªåŠ¨æœç´¢å‡ºå¯èƒ½çš„é€‰æ‹©ã€‚å½“æ²¡æœ‰å®Œå…¨åŒ¹é…çš„æœç´¢ç»“æžœï¼Œå¯ä»¥è¿”å›žå‰ç¼€æœ€ç›¸ä¼¼çš„å¯èƒ½ã€‚ ä½œä¸ºå…¶ä»–æ•°æ®ç»“æž„å’Œç®—æ³•çš„è¾…åŠ©ç»“æž„ å¦‚åŽç¼€æ ‘ï¼ŒACè‡ªåŠ¨æœºç­‰ã€‚ https://discuss.leetcode.com/topic/13463/maybe-the-code-is-not-too-much-by-using-next-26-c Maybe the code is not too much by using â€œnext[26]â€, C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class TrieNode&#123;public: TrieNode *next[26]; bool is_word; // Initialize your data structure here. TrieNode(bool b = false) &#123; memset(next, 0, sizeof(next)); is_word = b; &#125;&#125;;class Trie&#123; TrieNode *root;public: Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. void insert(string s) &#123; TrieNode *p = root; for(int i = 0; i &lt; s.size(); ++ i) &#123; if(p -&gt; next[s[i] - &apos;a&apos;] == NULL) p -&gt; next[s[i] - &apos;a&apos;] = new TrieNode(); p = p -&gt; next[s[i] - &apos;a&apos;]; &#125; p -&gt; is_word = true; &#125; // Returns if the word is in the trie. bool search(string key) &#123; TrieNode *p = find(key); return p != NULL &amp;&amp; p -&gt; is_word; &#125; // Returns if there is any word in the trie // that starts with the given prefix. bool startsWith(string prefix) &#123; return find(prefix) != NULL; &#125;private: TrieNode* find(string key) &#123; TrieNode *p = root; for(int i = 0; i &lt; key.size() &amp;&amp; p != NULL; ++ i) p = p -&gt; next[key[i] - &apos;a&apos;]; return p; &#125;&#125;; https://discuss.leetcode.com/topic/13623/c-my-solution-easy-to-understand C++, My solution, easy to understand:) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** ** author: cxq ** weibo: http://weibo.com/chenxq1992 **/ class TrieNode &#123;public: char content; // the character included bool isend; // if the node is the end of a word int shared; // the number of the node shared ,convenient to implement delete(string key), not necessary in this problem vector&lt;TrieNode*&gt; children; // the children of the node // Initialize your data structure here. TrieNode():content(&apos; &apos;), isend(false), shared(0) &#123;&#125; TrieNode(char ch):content(ch), isend(false), shared(0) &#123;&#125; TrieNode* subNode(char ch) &#123; if (!children.empty()) &#123; for (auto child : children) &#123; if (child-&gt;content == ch) return child; &#125; &#125; return nullptr; &#125; ~TrieNode() &#123; for (auto child : children) delete child; &#125;&#125;;class Trie &#123;public: Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. void insert(string s) &#123; if (search(s)) return; TrieNode* curr = root; for (auto ch : s) &#123; TrieNode* child = curr-&gt;subNode(ch); if (child != nullptr) &#123; curr = child; &#125; else &#123; TrieNode *newNode = new TrieNode(ch); curr-&gt;children.push_back(newNode); curr = newNode; &#125; ++curr-&gt;shared; &#125; curr-&gt;isend = true; &#125; // Returns if the word is in the trie. bool search(string key) &#123; TrieNode* curr = root; for (auto ch : key) &#123; curr = curr-&gt;subNode(ch); if (curr == nullptr) return false; &#125; return curr-&gt;isend == true; &#125; // Returns if there is any word in the trie // that starts with the given prefix. bool startsWith(string prefix) &#123; TrieNode* curr = root; for (auto ch : prefix) &#123; curr = curr-&gt;subNode(ch); if (curr == nullptr) return false; &#125; return true; &#125; ~Trie() &#123; delete root; &#125;private: TrieNode* root;&#125;; https://discuss.leetcode.com/topic/14202/ac-python-solution AC Python Solution 1234567891011121314151617181920212223242526272829303132class TrieNode:# Initialize your data structure here.def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = Falseclass Trie:def __init__(self): self.root = TrieNode()def insert(self, word): current = self.root for letter in word: current = current.children[letter] current.is_word = Truedef search(self, word): current = self.root for letter in word: current = current.children.get(letter) if current is None: return False return current.is_worddef startsWith(self, prefix): current = self.root for letter in prefix: current = current.children.get(letter) if current is None: return False return True https://discuss.leetcode.com/topic/20375/my-python-solution My python solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class TrieNode: # Initialize your data structure here. def __init__(self): self.word=False self.children=&#123;&#125; class Trie: def __init__(self): self.root = TrieNode() # @param &#123;string&#125; word # @return &#123;void&#125; # Inserts a word into the trie. def insert(self, word): node=self.root for i in word: if i not in node.children: node.children[i]=TrieNode() node=node.children[i] node.word=True # @param &#123;string&#125; word # @return &#123;boolean&#125; # Returns if the word is in the trie. def search(self, word): node=self.root for i in word: if i not in node.children: return False node=node.children[i] return node.word # @param &#123;string&#125; prefix # @return &#123;boolean&#125; # Returns if there is any word in the trie # that starts with the given prefix. def startsWith(self, prefix): node=self.root for i in prefix: if i not in node.children: return False node=node.children[i] return True # Your Trie object will be instantiated and called as such: # trie = Trie() # trie.insert(&quot;somestring&quot;) # trie.search(&quot;key&quot;) https://discuss.leetcode.com/topic/41687/compact-python-solution Compact Python solution 12345678910111213141516171819202122232425class TrieNode(object): def __init__(self): self.is_word = False self.children = collections.defaultdict(TrieNode)class Trie(object): def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for c in word: node = node.children[c] node.is_word = True def search(self, word, is_word=True): node = self.root for c in word: if c not in node.children: return False node = node.children[c] return node.is_word if is_word else True def startsWith(self, prefix): return self.search(prefix, False)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>design</tag>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[207. Course Schedule]]></title>
    <url>%2Fp%2F9a622bea%2F</url>
    <content type="text"><![CDATA[31.0% There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? 123For example:2, [[1,0]] There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. 12, [[1,0],[0,1]] There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites. Hints: This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses. Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort. Topological sort could also be done via BFS. https://discuss.leetcode.com/topic/17273/18-22-lines-c-bfs-dfs-solutions 18-22 lines C++ BFS/DFS Solutions As suggested by the hints, this problem is equivalent to detecting a cycle in the graph represented by prerequisites. Both BFS and DFS can be used to solve it using the idea of topological sort. If you find yourself unfamiliar with these concepts, you may refer to their wikipedia pages. Specifically, you may only need to refer to the link in the third hint to solve this problem. Since pair&lt;int, int&gt; is inconvenient for the implementation of graph algorithms, we first transform it to a graph. If course u is a prerequisite of course v, we will add a directed edge from node u to node v. BFS BFS uses the indegrees of each node. We will first try to find a node with 0 indegree. If we fail to do so, there must be a cycle in the graph and we return false. Otherwise we have found one. We set its indegree to be -1 to prevent from visiting it again and reduce the indegrees of all its neighbors by 1. This process will be repeated for n (number of nodes) times. If we have not returned false, we will return true. 12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph = make_graph(numCourses, prerequisites); vector&lt;int&gt; degrees = compute_indegree(graph); for (int i = 0; i &lt; numCourses; i++) &#123; int j = 0; for (; j &lt; numCourses; j++) if (!degrees[j]) break; if (j == numCourses) return false; degrees[j] = -1; for (int neigh : graph[j]) degrees[neigh]--; &#125; return true; &#125;private: vector&lt;unordered_set&lt;int&gt;&gt; make_graph(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph(numCourses); for (auto pre : prerequisites) graph[pre.second].insert(pre.first); return graph; &#125; vector&lt;int&gt; compute_indegree(vector&lt;unordered_set&lt;int&gt;&gt;&amp; graph) &#123; vector&lt;int&gt; degrees(graph.size(), 0); for (auto neighbors : graph) for (int neigh : neighbors) degrees[neigh]++; return degrees; &#125;&#125;; DFS For DFS, it will first visit a node, then one neighbor of it, then one neighbor of this neighborâ€¦ and so on. If it meets a node which was visited in the current process of DFS visit, a cycle is detected and we will return false. Otherwise it will start from another unvisited node and repeat this process till all the nodes have been visited. Note that you should make two records: one is to record all the visited nodes and the other is to record the visited nodes in the current DFS visit. The code is as follows. We use a vector visited to record all the visited nodes and another vector onpath to record the visited nodes of the current DFS visit. Once the current visit is finished, we reset the onpath value of the starting node to false. 1234567891011121314151617181920212223242526class Solution &#123;public: bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph = make_graph(numCourses, prerequisites); vector&lt;bool&gt; onpath(numCourses, false), visited(numCourses, false); for (int i = 0; i &lt; numCourses; i++) if (!visited[i] &amp;&amp; dfs_cycle(graph, i, onpath, visited)) return false; return true; &#125;private: vector&lt;unordered_set&lt;int&gt;&gt; make_graph(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph(numCourses); for (auto pre : prerequisites) graph[pre.second].insert(pre.first); return graph; &#125; bool dfs_cycle(vector&lt;unordered_set&lt;int&gt;&gt;&amp; graph, int node, vector&lt;bool&gt;&amp; onpath, vector&lt;bool&gt;&amp; visited) &#123; if (visited[node]) return false; onpath[node] = visited[node] = true; for (int neigh : graph[node]) if (onpath[neigh] || dfs_cycle(graph, neigh, onpath, visited)) return true; return onpath[node] = false; &#125;&#125;; https://discuss.leetcode.com/topic/13441/bfs-topological-sort-and-dfs-finding-cycle-by-c BFS(Topological Sort) and DFS(Finding cycle) by C++ BFS(Topological Sort) 12345678910111213141516171819202122232425bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites)&#123; vector&lt;unordered_set&lt;int&gt;&gt; matrix(numCourses); // save this directed graph for(int i = 0; i &lt; prerequisites.size(); ++ i) matrix[prerequisites[i][1]].insert(prerequisites[i][0]); vector&lt;int&gt; d(numCourses, 0); // in-degree for(int i = 0; i &lt; numCourses; ++ i) for(auto it = matrix[i].begin(); it != matrix[i].end(); ++ it) ++ d[*it]; for(int j = 0, i; j &lt; numCourses; ++ j) &#123; for(i = 0; i &lt; numCourses &amp;&amp; d[i] != 0; ++ i); // find a node whose in-degree is 0 if(i == numCourses) // if not find return false; d[i] = -1; for(auto it = matrix[i].begin(); it != matrix[i].end(); ++ it) -- d[*it]; &#125; return true;&#125; DFS(Finding cycle) 123456789101112131415161718192021222324bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites)&#123; vector&lt;unordered_set&lt;int&gt;&gt; matrix(numCourses); // save this directed graph for(int i = 0; i &lt; prerequisites.size(); ++ i) matrix[prerequisites[i][1]].insert(prerequisites[i][0]); unordered_set&lt;int&gt; visited; vector&lt;bool&gt; flag(numCourses, false); for(int i = 0; i &lt; numCourses; ++ i) if(!flag[i]) if(DFS(matrix, visited, i, flag)) return false; return true;&#125;bool DFS(vector&lt;unordered_set&lt;int&gt;&gt; &amp;matrix, unordered_set&lt;int&gt; &amp;visited, int b, vector&lt;bool&gt; &amp;flag)&#123; flag[b] = true; visited.insert(b); for(auto it = matrix[b].begin(); it != matrix[b].end(); ++ it) if(visited.find(*it) != visited.end() || DFS(matrix, visited, *it, flag)) return true; visited.erase(b); return false;&#125; https://discuss.leetcode.com/topic/18734/c-clean-code-for-dfs-solution-with-simple-comments C++ clean code for DFS solution with simple comments 12345678910111213141516171819202122bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prer) &#123; vector&lt;vector&lt;int&gt;&gt; gragh(numCourses); vector&lt;int&gt; visited(numCourses, 0); // White at initialization for (int i = 0; i &lt; prer.size(); i++) &#123; gragh[prer[i].second].push_back(prer[i].first); &#125; bool cycle = false; for (int i = 0; i &lt; numCourses; i++) &#123; if (cycle) return false; if (visited[i] == 0) dfs_top(i, gragh, visited, cycle); &#125; return !cycle;&#125;void dfs_top(int node, vector&lt;vector&lt;int&gt;&gt; &amp;gragh, vector&lt;int&gt; &amp;visited, bool &amp;cycle) &#123; if (visited[node] == 1) &#123;cycle = true; return;&#125; // cycle occurs, break the dfs chain and all return visited[node] = 1; //Gray, searching for (int i = 0; i &lt; gragh[node].size(); i++) &#123; dfs_top(gragh[node][i], gragh, visited, cycle); if (cycle) return; // do some pruning here &#125; visited[node] = 2; //Black Once finished.&#125; https://discuss.leetcode.com/topic/13412/python-20-lines-dfs-solution-sharing-with-explanation Python 20 lines DFS solution sharing with explanation 1234567891011121314151617181920def canFinish(self, numCourses, prerequisites): graph = [[] for _ in xrange(numCourses)] visit = [0 for _ in xrange(numCourses)] for x, y in prerequisites: graph[x].append(y) def dfs(i): if visit[i] == -1: return False if visit[i] == 1: return True visit[i] = -1 for j in graph[i]: if not dfs(j): return False visit[i] = 1 return True for i in xrange(numCourses): if not dfs(i): return False return True if node v has not been visited, then mark it as 0. if node v is being visited, then mark it as -1. If we find a vertex marked as -1 in DFS, then their is a ring. if node v has been visited, then mark it as 1. If a vertex was marked as 1, then no ring contains v or its successors. References: daoluan.net https://discuss.leetcode.com/topic/25964/ac-python-topological-sort-52-ms-solution-o-v-e-time-and-o-v-e-space AC Python topological sort 52 ms solution, O(V + E) time and O(V + E) space 1234567891011121314151617181920212223242526def canFinish(self, n, pres): from collections import deque ind = [[] for _ in xrange(n)] # indegree oud = [0] * n # outdegree for p in pres: oud[p[0]] += 1 ind[p[1]].append(p[0]) dq = deque() for i in xrange(n): if oud[i] == 0: dq.append(i) k = 0 while dq: x = dq.popleft() k += 1 for i in ind[x]: oud[i] -= 1 if oud[i] == 0: dq.append(i) return k == n# 34 / 34 test cases passed.# Status: Accepted# Runtime: 52 ms# 99.68% The topological sort is natural for this problem. We always take the courses with no unstudied prereqs and so on until no more courses we can take. The oud[i] is the number of prereqs for course i and indegree keep a list of courses require course i.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>depth first search</tag>
        <tag>breadth first search</tag>
        <tag>graph</tag>
        <tag>topogical sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[206. Reverse Linked List]]></title>
    <url>%2Fp%2Fc9c8233c%2F</url>
    <content type="text"><![CDATA[44.1% https://leetcode.com/problems/reverse-linked-list Reverse a singly linked list. click to show more hints. Hint: A linked list can be reversed either iteratively or recursively. Could you implement both? Subscribe to see which companies asked this question å‰‘æŒ‡offer 16 å¯ä»¥é€’å½’ å¯ä»¥è¿­ä»£ æ–¹æ³•ä¸€ï¼š ä½¿ç”¨è¿­ä»£çš„æ–¹æ³•ï¼Œä¿å­˜ä¸‰ä¸ªæŒ‡é’ˆã€‚æ–°å»ºä¸€ä¸ªnew_headï¼Œ 12345678910111213141516class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* new_head = new ListNode(0); new_head -&gt; next = head; ListNode* pre = new_head; ListNode* cur = head; while (cur &amp;&amp; cur -&gt; next) &#123; ListNode* temp = pre -&gt; next; pre -&gt; next = cur -&gt; next; cur -&gt; next = cur -&gt; next -&gt; next; pre -&gt; next -&gt; next = temp; &#125; return new_head -&gt; next; &#125;&#125;; æ–¹æ³•äºŒï¼š è¿­ä»£ æˆ‘çš„ä»£ç å®žçŽ°: Dec 7th, 2017 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* new_head = nullptr; while(head!=nullptr)&#123; ListNode* nex = head-&gt;next; head-&gt;next = new_head; new_head = head; head = nex; &#125; return new_head; &#125;&#125;; ä¿å­˜ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªéåŽ†çš„å½“å‰ä½ç½®çš„æŒ‡é’ˆï¼Œä¸€ä¸ªé€†è½¬çš„é“¾è¡¨çš„å¤´æŒ‡é’ˆã€‚åœ¨ä¸­é—´éåŽ†çš„æ—¶å€™éœ€è¦ä¸€ä¸ªä¸´æ—¶æŒ‡é’ˆã€‚ 12345678910111213class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* pre = NULL; while (head) &#123; ListNode* next = head -&gt; next; head -&gt; next = pre; pre = head; head = next; &#125; return pre; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ° ä¸€ä¸ªä¿å­˜æœªæ¥rootçš„æŒ‡é’ˆï¼Œ ä¸€ä¸ªçŽ°åœ¨éåŽ†åˆ°çš„èŠ‚ç‚¹çš„æŒ‡é’ˆ.éåŽ†æ—¶ï¼Œä¿å­˜ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚ 1234567891011121314class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head==NULL || head-&gt;next==NULL) return head; ListNode* pre=NULL; while(head)&#123; ListNode* nex = head-&gt;next; head-&gt;next = pre; pre = head; head = nex; &#125; return pre; &#125;&#125;; æ–¹æ³•ä¸‰ï¼š é€’å½’ æˆ‘çš„ä»£ç å®žçŽ°ï¼š Dec 7th, 2017 12345678910111213141516171819/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head==nullptr || head-&gt;next==nullptr) return head; ListNode* new_head = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return new_head; &#125;&#125;; ä½¿ç”¨é€’å½’çš„æ–¹æ³•ï¼Œå…¶ä¸­head-&gt;next-&gt;nextæ˜¯å°†head-&gt;nextå°±æ˜¯headçš„ä¸‹ä¸€ä½ï¼Œæ˜¯åè½¬åŽçš„æœ€åŽä¸€ä½çš„æŒ‡é’ˆæŒ‡å‘headï¼Œç„¶åŽï¼Œheadçš„ä¸‹ä¸€ä½è®¾ç½®ä¸ºNULLï¼Œå°±å®Œæˆäº†ã€‚ 12345678910class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (!head || !(head -&gt; next)) return head; ListNode* node = reverseList(head -&gt; next); head -&gt; next -&gt; next = head; head -&gt; next = NULL; return node; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š é€’å½’ç‰ˆ 12345678910class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head==NULL || head-&gt;next==NULL) return head; ListNode* pre = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return pre; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼› 123456789101112131415161718/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* node = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return node; &#125;&#125;; å‰ä¸¤ç§æ˜¯è¿­ä»£ï¼ŒåŽä¸€ç§æ˜¯é€’å½’ã€‚ cpp https://discuss.leetcode.com/topic/17916/8ms-c-iterative-and-recursive-solutions-with-explanations 8ms C++ Iterative and Recursive Solutions with Explanations xWell, since the head pointer may also be modified, we create a new_head that points to it to facilitate the reverse process. For the example list 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 in the problem statement, it will become 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 (we init new_head -&gt; val to be 0). Then we set a pointer pre to new_head and another cur to head. Then we keep inserting cur -&gt; next after pre until cur becomes the last node. The code is follows. 12345678910111213141516class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* new_head = new ListNode(0); new_head -&gt; next = head; ListNode* pre = new_head; ListNode* cur = head; while (cur &amp;&amp; cur -&gt; next) &#123; ListNode* temp = pre -&gt; next; pre -&gt; next = cur -&gt; next; cur -&gt; next = cur -&gt; next -&gt; next; pre -&gt; next -&gt; next = temp; &#125; return new_head -&gt; next; &#125;&#125;; This link provides a more concise solution without using the new_head. The idea is to reverse one node at a time for the beginning of the list. The rewritten code is as follows. 12345678910111213class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* pre = NULL; while (head) &#123; ListNode* next = head -&gt; next; head -&gt; next = pre; pre = head; head = next; &#125; return pre; &#125;&#125;; Well, both of the above solutions are iterative. The hint has also suggested us to use recursion. In fact, the above link has a nice recursive solution, whose rewritten code is as follows. 12345678910class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (!head || !(head -&gt; next)) return head; ListNode* node = reverseList(head -&gt; next); head -&gt; next -&gt; next = head; head -&gt; next = NULL; return node; &#125;&#125;; The basic idea of this recursive solution is to reverse all the following nodes after head. Then we need to set head to be the final node in the reversed list. We simply set its next node in the original list (head -&gt; next) to point to it and sets its next to be NULL. https://discuss.leetcode.com/topic/16162/c-solution-very-easy C++ solution .. very easy.. 12345678910111213class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *temp = NULL , *nextNode = NULL; while(head)&#123; nextNode = head-&gt;next; head-&gt;next = temp; temp = head; head = nextNode; &#125; return temp; &#125;&#125;; my code: 1234567891011121314class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* new_head = new ListNode(0); new_head-&gt;next = NULL; while(head)&#123; ListNode* next = head-&gt;next; head-&gt;next = new_head-&gt;next; new_head-&gt;next = head; head = next; &#125; return new_head-&gt;next; &#125;&#125;; python https://discuss.leetcode.com/topic/14043/python-iterative-and-recursive-solution Python Iterative and Recursive Solution 1234567891011class Solution:# @param &#123;ListNode&#125; head# @return &#123;ListNode&#125;def reverseList(self, head): prev = None while head: curr = head head = head.next curr.next = prev prev = curr return prev Recursion 123456789101112class Solution:# @param &#123;ListNode&#125; head# @return &#123;ListNode&#125;def reverseList(self, head): return self._reverse(head)def _reverse(self, node, prev=None): if not node: return prev n = node.next node.next = prev return self._reverse(n, node) 12345678910111213141516171819# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ pre = None while head: next = head.next head.next = pre pre = head head = next return pre]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[204. Count Primes]]></title>
    <url>%2Fp%2F99ef7c25%2F</url>
    <content type="text"><![CDATA[26.2% https://leetcode.com/problems/count-primes/?tab=Description Description: Count the number of prime numbers less than a non-negative number, n. Hint: Letâ€™s start with a isPrime function. To determine if a number is prime, we need to check if it is not divisible by any number less than n. The runtime complexity of isPrime function would be O(n) and hence counting the total prime numbers up to n would be O(n2). Could we do better? As we know the number must not be divisible by any number &gt; n / 2, we can immediately cut the total iterations half by dividing only up to n / 2. Could we still do better? Letâ€™s write down all of 12â€™s factors: 12342 Ã— 6 = 123 Ã— 4 = 124 Ã— 3 = 126 Ã— 2 = 12 As you can see, calculations of 4 Ã— 3 and 6 Ã— 2 are not necessary. Therefore, we only need to consider factors up to âˆšn because, if n is divisible by some number p, then n = p Ã— q and since p â‰¤ q, we could derive that p â‰¤ âˆšn. Our total runtime has now improved to O(n1.5), which is slightly better. Is there a faster approach? The Sieve of Eratosthenes is one of the most efficient ways to find all prime numbers up to n. But donâ€™t let that name scare you, I promise that the concept is surprisingly simple. Sieve of Eratosthenes: algorithm steps for primes below 121. â€œSieve of Eratosthenes Animationâ€œ by SKopp is licensed under CC BY 2.0. We start off with a table of n numbers. Letâ€™s look at the first number, 2. We know all multiples of 2 must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, all multiples of 3 such as 3 Ã— 2 = 6, 3 Ã— 3 = 9, â€¦ must not be primes, so we mark them off as well. Now we look at the next number, 4, which was already marked off. What does this tell you? Should you mark off all multiples of 4 as well? 4 is not a prime because it is divisible by 2, which means all multiples of 4 must also be divisible by 2 and were already marked off. So we can skip 4 immediately and go to the next number, 5. Now, all multiples of 5 such as 5 Ã— 2 = 10, 5 Ã— 3 = 15, 5 Ã— 4 = 20, 5 Ã— 5 = 25, â€¦ can be marked off. There is a slight optimization here, we do not need to start from 5 Ã— 2 = 10. Where should we start marking off? In fact, we can mark off multiples of 5 starting at 5 Ã— 5 = 25, because 5 Ã— 2 = 10 was already marked off by multiple of 2, similarly 5 Ã— 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is p, we can always mark off multiples of p starting at p2, then in increments of p: p2 + p, p2 + 2p, â€¦ Now what should be the terminating loop condition? It is easy to say that the terminating loop condition is p &lt; n, which is certainly correct but not efficient. Do you still remember Hint #3? Yes, the terminating loop condition can be p &lt; âˆšn, as all non-primes â‰¥ âˆšn must have already been marked off. When the loop terminates, all the numbers in the table that are non-marked are prime. The Sieve of Eratosthenes uses an extra O(n) memory and its runtime complexity is O(n log log n). For the more mathematically inclined readers, you can read more about its algorithm complexity on Wikipedia. å¯¹äºŽéžè´¨æ•°ï¼Œå¯ä»¥åˆ†è§£ä¸ºå¤šä¸ªè´¨æ•°çš„ä¹˜ç§¯ï¼Œæ‰€ä»¥ä¿å­˜å‰é¢çš„è´¨æ•°ï¼Œé‡åˆ°ä¸‹ä¸€ä¸ªï¼Œåªè¦æ£€æŸ¥æ˜¯å¦èƒ½è¢«å‰é¢ä¿å­˜çš„è´¨æ•°æ•´é™¤å°±å¯ä»¥åˆ¤æ–­æ˜¯å¦ä¸ºè´¨æ•°äº†ã€‚ æ–¹æ³•ä¸€ï¼š 1234567891011121314151617public int countPrimes(int n) &#123; int count = 0; for (int i = 1; i &lt; n; i++) &#123; if (isPrime(i)) count++; &#125; return count;&#125;private boolean isPrime(int num) &#123; if (num &lt;= 1) return false; // Loop&apos;s ending condition is i * i &lt;= num instead of i &lt;= sqrt(num) // to avoid repeatedly calling an expensive function sqrt(). for (int i = 2; i * i &lt;= num; i++) &#123; if (num % i == 0) return false; &#125; return true;&#125; æ–¹æ³•äºŒï¼š 12345678910111213141516171819public int countPrimes(int n) &#123; boolean[] isPrime = new boolean[n]; for (int i = 2; i &lt; n; i++) &#123; isPrime[i] = true; &#125; // Loop&apos;s ending condition is i * i &lt; n instead of i &lt; sqrt(n) // to avoid repeatedly calling an expensive function sqrt(). for (int i = 2; i * i &lt; n; i++) &#123; if (!isPrime[i]) continue; for (int j = i * i; j &lt; n; j += i) &#123; // æ­¤å¤„æ–¹æ³•ä¸é”™ï¼Œj = i*i; j&lt;n; j += i isPrime[j] = false; &#125; &#125; int count = 0; for (int i = 2; i &lt; n; i++) &#123; if (isPrime[i]) count++; &#125; return count;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718class Solution &#123;public: int countPrimes(int n) &#123; if(n&lt;=1) return 0; vector&lt;int&gt; v(n+1, 1); for(int i=2; i*i&lt;=n; i++)&#123; if(v[i]==0) continue; for(int j=i*i; j&lt;n; j+=i)&#123; v[j] = 0; &#125; &#125; int res = 0; for(int i=2; i&lt;n; i++) res += v[i]==1; return res; &#125;&#125;; å¦ä¸€ç§å®žçŽ°: å­¦ä¹ ä¸€ä¸ªæ˜¯ä½¿ç”¨boolç±»åž‹ï¼Œ vector ä¸€ä¸ªæ˜¯countçš„ä½¿ç”¨return count(prime.begin(), prime.end(), true) https://discuss.leetcode.com/topic/17034/short-c-sieve-of-eratosthenes-solution Short C++ Sieve of Eratosthenes solution 123456789101112131415class Solution &#123;public: int countPrimes(int n) &#123; vector&lt;bool&gt; prime(n, true); prime[0] = false, prime[1] = false; for (int i = 0; i &lt; sqrt(n); ++i) &#123; if (prime[i]) &#123; for (int j = i*i; j &lt; n; j += i) &#123; prime[j] = false; &#125; &#125; &#125; return count(prime.begin(), prime.end(), true); &#125;&#125;; æ–¹æ³•ä¸‰ï¼š https://discuss.leetcode.com/topic/12910/my-easy-one-round-c-code My easy one round c++ code ç‰¹åˆ«æ³¨æ„ if(i&gt;upper) continue;è¿™å¥è¯ï¼Œä¸åŠ è¿™å¥è¯ä¼šè¶…æ—¶ã€‚å¯¹äºŽå¤§äºŽsqrtï¼ˆnï¼‰çš„ä¸å¿…å†æ±‚ã€‚ 1234567891011121314151617int countPrimes(int n) &#123; if (n&lt;=2) return 0; vector&lt;bool&gt; passed(n, false); int sum = 1; int upper = sqrt(n); for (int i=3; i&lt;n; i+=2) &#123; if (!passed[i]) &#123; sum++; //avoid overflow if (i&gt;upper) continue; for (int j=i*i; j&lt;n; j+=i) &#123; passed[j] = true; &#125; &#125; &#125; return sum;&#125; https://discuss.leetcode.com/topic/20525/simple-16-ms-10-line-c-solution-1-use-new-bool-array-2-only-traverse-odd-numbers-3-count-and-sieve-at-the-same-time Simple 16 ms,10 line C++ solution. 1.use new bool array 2. only traverse odd numbers 3.count and sieve at the same time use new bool array. 2. only traverse odd numbers. 3. count and sieve at the same time. trick 1, thanks to 27ms,16 lines, C++ solution trick 2, for the inspiration, thanks to my C solutions in 13ms,use Sieve of Eratosthenes and only test 6n-1 and 6n+1 trick 3, thanks to my C solutions in 44ms, time nearly O(n), and space nearly O(n) and my easy one round c++ code 123456789101112int countPrimes(int n) &#123; if (n &lt;= 2) return 0; int res=n&gt;&gt;1, m=sqrt(n-1); // intilize res to n/2, removes all even number(not 2) and 1 bool *table=new bool[n]; for(int i=3,j,step;i&lt;=m;i+=2) if(!table[i]) &#123; // i is an odd prime for(step=i&lt;&lt;1, j=i*i;j&lt;n;j+=step) // step=i*2, ignore even numbers if(!table[j]) &#123; table[j]=1; --res; &#125; &#125; delete []table; return res;&#125; python https://discuss.leetcode.com/topic/14036/fast-python-solution Fast Python Solution 123456789101112class Solution:# @param &#123;integer&#125; n# @return &#123;integer&#125;def countPrimes(self, n): if n &lt; 3: return 0 primes = [True] * n primes[0] = primes[1] = False for i in range(2, int(n ** 0.5) + 1): if primes[i]: primes[i * i: n: i] = [False] * len(primes[i * i: n: i]) return sum(primes)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[203. Remove Linked List Elements]]></title>
    <url>%2Fp%2F8392dc6%2F</url>
    <content type="text"><![CDATA[31.4% https://leetcode.com/problems/remove-linked-list-elements/#/description Remove all elements from a linked list of integers that have value val. 123ExampleGiven: 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, val = 6Return: 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5 æ–¹æ³•ä¸€ï¼š å‰é¢è®¾ç½®ä¸€ä¸ªå“‘å˜é‡ å­¦ä¹ ä¸€ä¸‹ 12ListNode *pseudo_head = new ListNode(0);pseudo_head-&gt;next = head; Concise C++ solution with pseudo ListHead 12345678910111213class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode *pseudo_head = new ListNode(0); pseudo_head-&gt;next = head; ListNode *cur = pseudo_head; while(cur)&#123; if(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next; else cur = cur-&gt;next; &#125; return pseudo_head-&gt;next; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ° 1234567891011121314151617class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode* prehead = new ListNode(0); prehead-&gt;next = head; ListNode* cur = prehead; while(cur &amp;&amp; cur-&gt;next)&#123; ListNode* nex = cur-&gt;next; while(nex!=NULL &amp;&amp; nex-&gt;val==val) nex = nex-&gt;next; if(cur-&gt;next != nex) cur-&gt;next = nex; cur = nex; &#125; return prehead-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/19529/simple-and-elegant-solution-in-c Simple and elegant solution in C++ 123456789101112131415161718ListNode *removeElements(ListNode *head, int val)&#123; ListNode **list = &amp;head; while (*list != nullptr) &#123; if ((*list)-&gt;val == val) &#123; *list = (*list)-&gt;next; &#125; else &#123; list = &amp;(*list)-&gt;next; &#125; &#125; return head;&#125; Original recursive version: 123456789101112131415void removeHelper(ListNode *&amp;head, int val)&#123; if (head == nullptr) &#123; return; &#125; else if (head-&gt;val == val) &#123; head = head-&gt;next; &#125; else &#123; removeHelper(head-&gt;next, val); &#125;&#125; https://discuss.leetcode.com/topic/17550/concise-c-solution-with-pseudo-listhead Concise C++ solution with pseudo ListHead 12345678910111213class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode *pseudo_head = new ListNode(0); pseudo_head-&gt;next = head; ListNode *cur = pseudo_head; while(cur)&#123; if(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next; else cur = cur-&gt;next; &#125; return pseudo_head-&gt;next; &#125;&#125;; 2ms, 5.21%, October 15, 2016 https://discuss.leetcode.com/topic/12580/3-line-recursive-solution 1234567public class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if(head == null) return null; head.next = removeElements(head.next, val); return head.val == val ? head.next : head; &#125;&#125; 1ms, 48.64%, October 15, 2016 https://discuss.leetcode.com/topic/12725/ac-java-solution 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; ListNode fakeHead = new ListNode(-1); fakeHead.next = head; ListNode curr = head, prev = fakeHead; while(curr != null)&#123; if(curr.val == val) prev.next = curr.next; else prev = prev.next; curr = curr.next; &#125; return fakeHead.next; &#125;&#125; python116ms, 68.55%, October 15, 2016 https://discuss.leetcode.com/topic/12640/python-solution 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def removeElements(self, head, val): &quot;&quot;&quot; :type head: ListNode :type val: int :rtype: ListNode &quot;&quot;&quot; dummy = ListNode(-1) dummy.next = head next = dummy while next != None and next.next != None: if next.next.val == val: next.next = next.next.next else: next = next.next return dummy.next]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[202. Happy Number]]></title>
    <url>%2Fp%2Ff91a3fae%2F</url>
    <content type="text"><![CDATA[39.8% https://leetcode.com/problems/happy-number/description/ Write an algorithm to determine if a number is â€œhappyâ€. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 12345671^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1 æ–¹æ³•ä¸€ï¼š ä»Žå¼€å§‹ï¼ŒéåŽ†è¿‡çš„æ”¾å…¥setï¼Œå¦‚æžœå†å‡ºçŽ°ä¸€æ¬¡ï¼Œåˆ™è‚¯å®šä¸ºfalseï¼Œå¦‚æžœåˆ°1ï¼Œè¿”å›žtrueã€‚ 123456789101112131415161718192021class Solution &#123;public: bool isHappy(int n) &#123; if(n&lt;=0) return false; if(n==1) return true; unordered_set&lt;int&gt; set; set.insert(n); while(n!=1)&#123; int sum = 0; while(n!=0)&#123; sum = sum + pow(n%10, 2); n /= 10; &#125; if(set.find(sum)!=set.end()) return false; set.insert(sum); n = sum; &#125; return true; &#125;&#125;; å¦ä¸€ç§å®žçŽ°ï¼š æŠŠä¸€æ ·æ”¾å…¥tableé‡Œï¼Œå¦‚æžœå‡ºçŽ°è¿‡ï¼Œå°±åˆ¤æ–­æ˜¯å¦ç­‰äºŽ1. 1çš„ä¸‹ä¸€ä¸ªè¿˜æ˜¯1. 1234567891011121314151617181920class Solution &#123;public: bool isHappy(int n) &#123; int num=0; unordered_map&lt;int,bool&gt; table; table[n]=1; while(n!=1) &#123; while(n) &#123; num += (n%10) * (n%10); n/=10; &#125; if(table[num]) break; else table[num]=1; n=num;num=0; &#125; return 1==n; &#125;&#125;; æ–¹æ³•äºŒï¼š æ¯”æ–¹æ³•ä¸€å·®ä¸€äº›ï¼Œå› ä¸ºæ²¡æœ‰ä¿å­˜ï¼Œæ¯æ¬¡éƒ½åŽ»åˆ¤æ–­ 12345678910111213bool isHappy(int n) &#123; int num=0; while(n!=1&amp;&amp;n!=4) &#123; while(n) &#123; num += (n%10) * (n%10); n/=10; &#125; n=num;num=0; &#125; return 1==n; &#125; https://discuss.leetcode.com/topic/30520/explanation-of-why-those-posted-algorithms-are-mathematically-valid Earlier posts gave the algorithm but did not explain why it is valid mathematically, and this is what this post is about: present a â€œshortâ€ mathematical proof. First of all, it is easy to argue that starting from a number I, if some value - say a - appears again during the process after k steps, the initial number I cannot be a happy number. Because a will continuously become a after every k steps. Therefore, as long as we can show that there is a loop after running the process continuously, the number is not a happy number. There is another detail not clarified yet: For any non-happy number, will it definitely end up with a loop during the process? This is important, because it is possible for a non-happy number to follow the process endlessly while having no loop. To show that a non-happy number will definitely generate a loop, we only need to show that for any non-happy number, all outcomes during the process are bounded by some large but finite integer N. If all outcomes can only be in a finite set (2,N], and since there are infinitely many outcomes for a non-happy number, there has to be at least one duplicate, meaning a loop! Suppose after a couple of processes, we end up with a large outcome O1 with D digits where D is kind of large, say D&gt;=4, i.e., O1 &gt; 999 (If we cannot even reach such a large outcome, it means all outcomes are bounded by 999 ==&gt; loop exists). We can easily see that after processing O1, the new outcome O2 can be at most 9^2D &lt; 100D, meaning that O2 can have at most 2+d(D) digits, where d(D) is the number of digits D have. It is obvious that 2+d(D) &lt; D. We can further argue that O1 is the maximum (or boundary) of all outcomes afterwards. This can be shown by contradictory: Suppose after some steps, we reach another large number O3 &gt; O1. This means we process on some number W &lt;= 999 that yields O3. However, this cannot happen because the outcome of W can be at most 9^23 &lt; 300 &lt; O1. Done. Please leave your comment if any question or suggestion. cpphttps://discuss.leetcode.com/topic/38728/0ms-c-solution-beats-97-4-perhaps-the-most-easy-one-to-understand I use three solutions: 1. hash table(8ms) 2. List circle detect method(4ms) 3.circle 1 and circle 4.Here is the url:https://en.wikipedia.org/wiki/Happy_number Based on the fact that circle of 1 is happy, circle of 4 is unhappy. Solution3: 12345678910111213bool isHappy(int n) &#123; int num=0; while(n!=1&amp;&amp;n!=4) &#123; while(n) &#123; num += (n%10) * (n%10); n/=10; &#125; n=num;num=0; &#125; return 1==n; &#125; Solution1: 1234567891011121314151617181920class Solution &#123;public: bool isHappy(int n) &#123; int num=0; unordered_map&lt;int,bool&gt; table; table[n]=1; while(n!=1) &#123; while(n) &#123; num += (n%10) * (n%10); n/=10; &#125; if(table[num]) break; else table[num]=1; n=num;num=0; &#125; return 1==n; &#125;&#125;; Solution2: 123456789101112131415161718192021222324class Solution &#123;public: bool isHappy(int n) &#123; int slow,fast; slow=fast=n; do&#123; slow = compute(slow); fast=compute(fast); fast=compute(fast); &#125;while(slow!=fast); return 1==slow; &#125;private: int compute(int n) &#123; int num=0; while(n) &#123; num += (n%10) * (n%10); n/=10; &#125; return num; &#125;&#125;; pythonSolution 1: 64ms, 42.28%, June.17th, 2016 https://leetcode.com/discuss/47623/my-python-solution 1234567891011121314class Solution(object): def isHappy(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; mem = set() while n != 1: n = sum([int(i)**2 for i in str(n)]) if n not in mem: mem.add(n) else: return False return True cSolution 1: 0ms, 44.72%, June.17th, 2016 https://leetcode.com/discuss/33014/4ms-5-line-c-code Using fact all numbers in [2, 6] are not happy (and all not happy numbers end on a cycle that hits this interval): 1234567891011bool isHappy(int n) &#123; while(n&gt;6)&#123; int next = 0; while(n)&#123; next += (n%10) * (n%10); n = n / 10; &#125; n = next; &#125; return n == 1;&#125; https://discuss.leetcode.com/topic/12587/my-solution-in-c-o-1-space-and-no-magic-math-property-involved I see the majority of those posts use hashset to record values. Actually, we can simply adapt the Floyd Cycle detection algorithm. I believe that many people have seen this in the Linked List Cycle detection problem. The following is my code: 123456789101112131415161718192021int digitSquareSum(int n) &#123; int sum = 0, tmp; while (n) &#123; tmp = n % 10; sum += tmp * tmp; n /= 10; &#125; return sum;&#125;bool isHappy(int n) &#123; int slow, fast; slow = fast = n; do &#123; slow = digitSquareSum(slow); fast = digitSquareSum(fast); fast = digitSquareSum(fast); &#125; while(slow != fast); if (slow == 1) return 1; else return 0;&#125; javahttps://discuss.leetcode.com/topic/25026/beat-90-fast-easy-understand-java-solution-with-brief-explanation The idea is to use one hash set to record sum of every digit square of every number occurred. Once the current sum cannot be added to set, return false; once the current sum equals 1, return true; 1234567891011121314151617181920public class Solution &#123; public boolean isHappy(int n) &#123; Set&lt;Integer&gt; inLoop = new HashSet&lt;Integer&gt;(); int squareSum,remain; while (inLoop.add(n)) &#123; squareSum = 0; while (n &gt; 0) &#123; remain = n%10; squareSum += remain*remain; n /= 10; &#125; if (squareSum == 1) return true; else n = squareSum; &#125; return false; &#125;&#125; https://discuss.leetcode.com/topic/12742/o-1-space-java-solution 123456789101112131415161718192021222324public class Solution &#123; public boolean isHappy(int n) &#123; int x = n; int y = n; while(x&gt;1)&#123; x = cal(x) ; if(x==1) return true ; y = cal(cal(y)); if(y==1) return true ; if(x==y) return false; &#125; return true ; &#125; public int cal(int n)&#123; int x = n; int s = 0; while(x&gt;0)&#123; s = s+(x%10)*(x%10); x = x/10; &#125; return s ; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[201. Bitwise AND of Numbers Range]]></title>
    <url>%2Fp%2Fee620e%2F</url>
    <content type="text"><![CDATA[33.3% https://leetcode.com/problems/bitwise-and-of-numbers-range/ Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. 1For example, given the range [5, 7], you should return 4. æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112class Solution &#123;public: int rangeBitwiseAnd(int m, int n) &#123; int cnt = 0; while(m!=n)&#123; m &gt;&gt;= 1; n &gt;&gt;= 1; cnt++; &#125; return m&lt;&lt;cnt; &#125;&#125;; 9ms, 44.28%, October 15, 2016 https://discuss.leetcode.com/topic/12133/bit-operation-solution-java Bit operation solution(JAVA) The idea is very simple: last bit of (odd number &amp; even number) is 0. when m != n, There is at least an odd number and an even number, so the last bit position result is 0. Move m and n rigth a position. Keep doing step 1,2,3 until m equal to n, use a factor to record the iteration time. 12345678910111213public class Solution &#123; public int rangeBitwiseAnd(int m, int n) &#123; if(m==0) return 0; int moveFactor = 1; while(m!=n)&#123; m &gt;&gt;= 1; n &gt;&gt;= 1; moveFactor &lt;&lt;= 1; &#125; return m * moveFactor; &#125;&#125; cpp 32ms, 64.35%, October 15, 2016 https://discuss.leetcode.com/topic/13508/one-line-c-solution One line C++ solution Consider the bits from low to high. if n &gt; m, the lowest bit will be 0, and then we could transfer the problem to sub-problem: rangeBitwiseAnd(m&gt;&gt;1, n&gt;&gt;1). 123456class Solution &#123;public: int rangeBitwiseAnd(int m, int n) &#123; return (n&gt;m) ? (rangeBitwiseAnd(m/2, n/2)&lt;&lt;1) : m; &#125;&#125;; https://discuss.leetcode.com/topic/17491/fast-three-line-c-solution-and-explanation-with-no-loops-or-recursion-and-one-extra-variable Fast three line C++ solution and explanation with no loops or recursion and one extra variable Whenever a bit changes when counting from m to n, that bit will be 0 in the AND of the range. So we consider the XOR x of m and n. The leftmost 1 bit in x is the last bit that changes at some point when counting from m to n. This bit and the bits to the right of it are all 0 in the AND of the range. We can easily fill all the bits to the right of that bit with 1s using the OR operations below to create a mask. This technique â€œsmearsâ€ the 1 bits in x to the right. Then itâ€™s just a matter of returning the rest of m excluding those bits (the bits in m that did not change when counting up to n), which is precisely the AND of the range from m to n. 12345678class Solution &#123;public: int rangeBitwiseAnd(int m, int n) &#123; unsigned int x = m ^ n; x |= x &gt;&gt; 1, x |= x &gt;&gt; 2, x |= x &gt;&gt; 4, x |= x &gt;&gt; 8, x |= x &gt;&gt; 16; return m &amp; ~x; &#125;&#125;; my code: æ³¨æ„æœ€åŽä¸€è¡Œ n&lt;&lt; iï¼Œ ä¸èƒ½ä¸º1&lt;&lt; i; è€ƒè™‘m néƒ½ä¸º0çš„æƒ…å†µã€‚ 123456789101112class Solution &#123;public: int rangeBitwiseAnd(int m, int n) &#123; int i = 0; while(m!=n)&#123; m&gt;&gt;=1; n&gt;&gt;=1; i++; &#125; return n&lt;&lt;i; &#125;&#125;; python 122ms, 75.44%, October 15, 2016 https://discuss.leetcode.com/topic/28538/java-python-easy-solution-with-explanation 12345678910111213class Solution(object): def rangeBitwiseAnd(self, m, n): &quot;&quot;&quot; :type m: int :type n: int :rtype: int &quot;&quot;&quot; i = 0 while m != n: m &gt;&gt;= 1 n &gt;&gt;= 1 i += 1 return n &lt;&lt; i]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[200. Number of Islands]]></title>
    <url>%2Fp%2Fa61d2ad8%2F</url>
    <content type="text"><![CDATA[33.0% https://leetcode.com/problems/number-of-islands/?tab=Description Given a 2d grid map of â€˜1â€™s (land) and â€˜0â€™s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. 1234567Example 1:11110110101100000000Answer: 1 1234567Example 2:11000110000010000011Answer: 3 æ–¹æ³•ä¸€ï¼š æ·±åº¦ä¼˜å…ˆéåŽ† æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627282930class Solution &#123;public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; if(grid.empty() || grid[0].empty()) return 0; int res = 0; for(int i=0; i&lt;grid.size(); i++)&#123; for(int j=0; j&lt;grid[0].size(); j++)&#123; if(grid[i][j]=='1')&#123; res++; helper(grid, i, j); &#125; &#125; &#125; return res; &#125; void helper(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j)&#123; // æ­¤å¤„æ˜¯=ï¼Œè€Œä¸æ˜¯==ï¼ŒåŒºåˆ† = ä¸Ž == grid[i][j] = '0'; if(i-1&gt;=0 &amp;&amp; grid[i-1][j]=='1') helper(grid, i-1, j); if(i+1&lt;grid.size() &amp;&amp; grid[i+1][j]=='1') helper(grid, i+1, j); if(j-1&gt;=0 &amp;&amp; grid[i][j-1]=='1') helper(grid, i, j-1); if(j+1&lt;grid[0].size() &amp;&amp; grid[i][j+1]=='1') helper(grid, i, j+1); &#125; &#125;; helperå‡½æ•°ä¸­çš„å‘å·¦éåŽ†å’Œå‘ä¸‹éåŽ†ï¼Œä¸èƒ½çœç•¥ å¦åˆ™å¯¹äºŽæ ·ä¾‹ï¼Œ111,010, 111é€šä¸è¿‡ï¼Œåº”è¯¥ä¸º1ï¼Œè¾“å‡ºå´ä¸º2 https://discuss.leetcode.com/topic/11589/dfs-and-bfs-in-c DFS and BFS in C++ When we met a â€˜1â€™, the answer add 1, we also need to search all â€˜1â€™ which connected to it directly or indirectly, and change it to â€˜0â€™. And we can use DFS or BFS to search. DFS 1234567891011121314151617181920212223242526272829303132class Solution&#123;public:int numIslands(vector&lt;vector&lt;char&gt;&gt; &amp;grid)&#123;if(grid.size() == 0 || grid[0].size() == 0)return 0; int res = 0; for(int i = 0; i &lt; grid.size(); ++ i) for(int j = 0; j &lt; grid[0].size(); ++ j) if(grid[i][j] == &apos;1&apos;) &#123; ++ res; DFS(grid, i, j); &#125; return res; &#125;private:void DFS(vector&lt;vector&lt;char&gt;&gt; &amp;grid, int x, int y)&#123; grid[x][y] = &apos;0&apos;; if(x &gt; 0 &amp;&amp; grid[x - 1][y] == &apos;1&apos;) DFS(grid, x - 1, y); if(x &lt; grid.size() - 1 &amp;&amp; grid[x + 1][y] == &apos;1&apos;) DFS(grid, x + 1, y); if(y &gt; 0 &amp;&amp; grid[x][y - 1] == &apos;1&apos;) DFS(grid, x, y - 1); if(y &lt; grid[0].size() - 1 &amp;&amp; grid[x][y + 1] == &apos;1&apos;) DFS(grid, x, y + 1);&#125;&#125;; BFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution&#123;public:int numIslands(vector&lt;vector&lt;char&gt;&gt; &amp;grid)&#123;if(grid.size() == 0 || grid[0].size() == 0)return 0; int res = 0; for(int i = 0; i &lt; grid.size(); ++ i) for(int j = 0; j &lt; grid[0].size(); ++ j) if(grid[i][j] == &apos;1&apos;) &#123; ++ res; BFS(grid, i, j); &#125; return res; &#125;private:void BFS(vector&lt;vector&lt;char&gt;&gt; &amp;grid, int x, int y)&#123;queue&lt;vector&lt;int&gt;&gt; q;q.push(&#123;x, y&#125;);grid[x][y] = &apos;0&apos;; while(!q.empty()) &#123; x = q.front()[0], y = q.front()[1]; q.pop(); if(x &gt; 0 &amp;&amp; grid[x - 1][y] == &apos;1&apos;) &#123; q.push(&#123;x - 1, y&#125;); grid[x - 1][y] = &apos;0&apos;; &#125; if(x &lt; grid.size() - 1 &amp;&amp; grid[x + 1][y] == &apos;1&apos;) &#123; q.push(&#123;x + 1, y&#125;); grid[x + 1][y] = &apos;0&apos;; &#125; if(y &gt; 0 &amp;&amp; grid[x][y - 1] == &apos;1&apos;) &#123; q.push(&#123;x, y - 1&#125;); grid[x][y - 1] = &apos;0&apos;; &#125; if(y &lt; grid[0].size() - 1 &amp;&amp; grid[x][y + 1] == &apos;1&apos;) &#123; q.push(&#123;x, y + 1&#125;); grid[x][y + 1] = &apos;0&apos;; &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/13045/my-accepted-c-solution-may-be-trivial My accepted c++ solution (may be trivial) 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: void contaminate(vector&lt;vector&lt;char&gt; &gt; &amp;grid, int i, int j)&#123; if(i&gt;0&amp;&amp;grid[i-1][j]==&apos;1&apos;)&#123; grid[i-1][j]=&apos;0&apos;; contaminate(grid, i-1, j); &#125; if(j&gt;0&amp;&amp;grid[i][j-1]==&apos;1&apos;)&#123; grid[i][j-1]=&apos;0&apos;; contaminate(grid, i, j-1); &#125; if(i&lt;grid.size()-1&amp;&amp;grid[i+1][j]==&apos;1&apos;)&#123; grid[i+1][j]=&apos;0&apos;; contaminate(grid, i+1, j); &#125; if(j&lt;grid[0].size()-1&amp;&amp;grid[i][j+1]==&apos;1&apos;)&#123; grid[i][j+1]=&apos;0&apos;; contaminate(grid, i, j+1); &#125; &#125; int numIslands(vector&lt;vector&lt;char&gt;&gt; &amp;grid) &#123; int n=grid.size(); if(n==0) return 0; int m=grid[0].size(); int cnt=0; for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;m; j++)&#123; if(grid[i][j]==&apos;1&apos;)&#123; cnt++; contaminate(grid, i, j); &#125; &#125; &#125; return cnt; &#125;&#125;; python 202ms, 15.49%, October 18, 2016 https://discuss.leetcode.com/topic/16749/7-lines-python-14-lines-java 7 lines Python, ~ 14 lines Java Sink and count the islands. Python Solution 12345678def numIslands(self, grid): def sink(i, j): if 0 &lt;= i &lt; len(grid) and 0 &lt;= j &lt; len(grid[i]) and grid[i][j] == &apos;1&apos;: grid[i][j] = &apos;0&apos; map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1)) return 1 return 0 return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[i]))) Java Solution 1 123456789101112131415161718public class Solution &#123; char[][] g; public int numIslands(char[][] grid) &#123; int islands = 0; g = grid; for (int i=0; i&lt;g.length; i++) for (int j=0; j&lt;g[i].length; j++) islands += sink(i, j); return islands; &#125; int sink(int i, int j) &#123; if (i &lt; 0 || i == g.length || j &lt; 0 || j == g[i].length || g[i][j] == &apos;0&apos;) return 0; g[i][j] = &apos;0&apos;; sink(i+1, j); sink(i-1, j); sink(i, j+1); sink(i, j-1); return 1; &#125;&#125; Java Solution 2 123456789101112131415161718public class Solution &#123; public int numIslands(char[][] grid) &#123; int islands = 0; for (int i=0; i&lt;grid.length; i++) for (int j=0; j&lt;grid[i].length; j++) islands += sink(grid, i, j); return islands; &#125; int sink(char[][] grid, int i, int j) &#123; if (i &lt; 0 || i == grid.length || j &lt; 0 || j == grid[i].length || grid[i][j] == &apos;0&apos;) return 0; grid[i][j] = &apos;0&apos;; for (int k=0; k&lt;4; k++) sink(grid, i+d[k], j+d[k+1]); return 1; &#125; int[] d = &#123;0, 1, 0, -1, 0&#125;;&#125; java https://discuss.leetcode.com/topic/13248/very-concise-java-ac-solution Very concise Java AC solution 1234567891011121314151617181920212223242526272829public class Solution &#123;private int n;private int m;public int numIslands(char[][] grid) &#123; int count = 0; n = grid.length; if (n == 0) return 0; m = grid[0].length; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++) if (grid[i][j] == &apos;1&apos;) &#123; DFSMarking(grid, i, j); ++count; &#125; &#125; return count;&#125;private void DFSMarking(char[][] grid, int i, int j) &#123; if (i &lt; 0 || j &lt; 0 || i &gt;= n || j &gt;= m || grid[i][j] != &apos;1&apos;) return; grid[i][j] = &apos;0&apos;; DFSMarking(grid, i + 1, j); DFSMarking(grid, i - 1, j); DFSMarking(grid, i, j + 1); DFSMarking(grid, i, j - 1);&#125;&#125; https://discuss.leetcode.com/topic/11590/simple-java-solution Simple Java Solution 12345678910111213141516171819202122232425public class NumberofIslands &#123; static int[] dx = &#123;-1,0,0,1&#125;; static int[] dy = &#123;0,1,-1,0&#125;; public static int numIslands(char[][] grid) &#123; if(grid==null || grid.length==0) return 0; int islands = 0; for(int i=0;i&lt;grid.length;i++) &#123; for(int j=0;j&lt;grid[i].length;j++) &#123; if(grid[i][j]==&apos;1&apos;) &#123; explore(grid,i,j); islands++; &#125; &#125; &#125; return islands; &#125; public static void explore(char[][] grid, int i, int j) &#123; grid[i][j]=&apos;x&apos;; for(int d=0;d&lt;dx.length;d++) &#123; if(i+dy[d]&lt;grid.length &amp;&amp; i+dy[d]&gt;=0 &amp;&amp; j+dx[d]&lt;grid[0].length &amp;&amp; j+dx[d]&gt;=0 &amp;&amp; grid[i+dy[d]][j+dx[d]]==&apos;1&apos;) &#123; explore(grid,i+dy[d],j+dx[d]); &#125; &#125; &#125;&#125; The algorithm works as follow: Scan each cell in the grid. If the cell value is â€˜1â€™ explore that island. Mark the explored island cells with â€˜xâ€™. Once finished exploring that island, increment islands counter. The arrays dx[], dy[] store the possible moves from the current cell. Two land cells [â€˜1â€™] are considered from the same island if they are horizontally or vertically adjacent (possible moves (-1,0),(0,1),(0,-1),(1,0)). Two â€˜1â€™ diagonally adjacent are not considered from the same island. https://discuss.leetcode.com/topic/20080/clear-easy-java-solution Clear &amp; Easy Java Solution 1234567891011121314151617181920212223242526public class Solution &#123; public int numIslands(char[][] grid) &#123; int count = 0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[i].length; j++) &#123; if (grid[i][j] == &apos;1&apos;) &#123; count++; clearRestOfLand(grid, i, j); &#125; &#125; &#125; return count; &#125; private void clearRestOfLand(char[][] grid, int i, int j) &#123; if (i &lt; 0 || j &lt; 0 || i &gt;= grid.length || j &gt;= grid[i].length || grid[i][j] == &apos;0&apos;) return; grid[i][j] = &apos;0&apos;; clearRestOfLand(grid, i+1, j); clearRestOfLand(grid, i-1, j); clearRestOfLand(grid, i, j+1); clearRestOfLand(grid, i, j-1); return; &#125;&#125; https://discuss.leetcode.com/topic/11705/simple-dfs-sulotion Simple DFS sulotion Dont need the extra space, and O(mn) 12345678910111213141516171819202122232425public int numIslands(char[][] grid) &#123; int islands = 0; if (grid != null &amp;&amp; grid.length != 0 &amp;&amp; grid[0].length != 0) &#123; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if (grid[i][j] == &apos;1&apos;) &#123; dfs(grid, i, j); islands++; &#125; &#125; &#125; &#125; return islands;&#125;private void dfs(char[][] grid, int x, int y) &#123; if (x &lt; 0 || grid.length &lt;= x || y &lt; 0 || grid[0].length &lt;= y || grid[x][y] != &apos;1&apos;) &#123; return; &#125; grid[x][y] = &apos;x&apos;; dfs(grid, x + 1, y); dfs(grid, x - 1, y); dfs(grid, x, y + 1); dfs(grid, x, y - 1);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>depth first search</tag>
        <tag>breadth first search</tag>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[199. Binary Tree Right Side View]]></title>
    <url>%2Fp%2Ffe12b283%2F</url>
    <content type="text"><![CDATA[39.5% https://leetcode.com/problems/binary-tree-right-side-view/#/description Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. 12345678For example:Given the following binary tree, 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;---You should return [1, 3, 4]. æ–¹æ³•ä¸€ï¼š å±‚åºéåŽ†/å¹¿åº¦ä¼˜å…ˆæœç´¢ o(N)æ—¶é—´ o(N)ç©ºé—´ 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; que; que.push(root); while(que.size())&#123; int n = que.size(); for(int i=0; i&lt;n; i++)&#123; TreeNode* cur = que.front(); que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); if(i==n-1) res.push_back(cur-&gt;val); &#125; &#125; return res; &#125;&#125;; æ–¹æ³•äºŒï¼š é€’å½’ï¼Œä»Žå…ˆåºéåŽ†æ”¹é€ è€Œæ¥ https://discuss.leetcode.com/topic/11310/my-c-solution-modified-preorder-traversal My C++ solution, modified preorder traversal 12345678910111213141516class Solution &#123;public: void recursion(TreeNode *root, int level, vector&lt;int&gt; &amp;res) &#123; if(root==NULL) return ; if(res.size()&lt;level) res.push_back(root-&gt;val); recursion(root-&gt;right, level+1, res); recursion(root-&gt;left, level+1, res); &#125; vector&lt;int&gt; rightSideView(TreeNode *root) &#123; vector&lt;int&gt; res; recursion(root, 1, res); return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; res; helper(root, res, 0); return res; &#125; void helper(TreeNode* root, vector&lt;int&gt;&amp; res, int level)&#123; if(!root) return; if(res.size()==level) res.push_back(root-&gt;val); helper(root-&gt;right, res, level+1); helper(root-&gt;left, res, level+1); &#125;&#125;; https://discuss.leetcode.com/topic/23030/simple-c-solution-btw-i-like-clean-codes Simple C++ solution (BTW: I like clean codes) 123456789101112131415class Solution &#123;public: void dfs(TreeNode* root, int lv, vector&lt;int&gt; &amp;res)&#123; if(!root) return; if(lv&gt;=res.size()) res.push_back(root-&gt;val); dfs(root-&gt;right,lv+1,res); dfs(root-&gt;left,lv+1,res); &#125; vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; res; dfs(root, 0, res); return res; &#125;&#125;; https://discuss.leetcode.com/topic/11303/9ms-c-bfs-o-n-time-concise-with-explanation 9ms C++ BFS, O(n) time, concise with explanation 9ms C++ iterative, concise code with explanation Using a queue mQ to perform level order traversal. In the beginning of a level traversal, the last element is pushed into result array ret. The core idea is similar with Binary Tree Level Order Traversal O(n) time, O(logn) space 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode *root) &#123; queue&lt;TreeNode*&gt;mQ; vector&lt;int&gt; ret; if(!root)return ret; mQ.push(root); while(!mQ.empty())&#123; ret.push_back(mQ.back()-&gt;val); for(int i=mQ.size();i&gt;0;i--)&#123; TreeNode *tn=mQ.front(); mQ.pop(); if(tn-&gt;left)mQ.push(tn-&gt;left); if(tn-&gt;right)mQ.push(tn-&gt;right); &#125; &#125; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/16164/5-9-lines-python-48-ms 5-9 Lines Python, 48+ ms Solution 1: Recursive, combine right and left: 5 lines, 56 ms Compute the right view of both right and left left subtree, then combine them. For very unbalanced trees, this can be O(n^2), though. 123456def rightSideView(self, root): if not root: return [] right = self.rightSideView(root.right) left = self.rightSideView(root.left) return [root.val] + right + left[len(right):] Solution 2: Recursive, first come first serve: 9 lines, 48 ms DFS-traverse the tree right-to-left, add values to the view whenever we first reach a new record depth. This is O(n). 12345678910def rightSideView(self, root): def collect(node, depth): if node: if depth == len(view): view.append(node.val) collect(node.right, depth+1) collect(node.left, depth+1) view = [] collect(root, 0) return view Solution 3: Iterative, level-by-level: 7 lines, 48 ms Traverse the tree level by level and add the last value of each level to the view. This is O(n). 12345678def rightSideView(self, root): view = [] if root: level = [root] while level: view += level[-1].val, level = [kid for node in level for kid in (node.left, node.right) if kid] return view 1ms, 82.64%, July 14th, 2016 https://discuss.leetcode.com/topic/11768/my-simple-accepted-solution-java My simple accepted solution(JAVA) The core idea of this algorithm: Each depth of the tree only select one node. View depth is current size of result list. Here is the code: 1234567891011121314151617181920public class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); rightView(root, result, 0); return result; &#125; public void rightView(TreeNode curr, List&lt;Integer&gt; result, int currDepth)&#123; if(curr == null)&#123; return; &#125; if(currDepth == result.size())&#123; result.add(curr.val); &#125; rightView(curr.right, result, currDepth + 1); rightView(curr.left, result, currDepth + 1); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[198. House Robber]]></title>
    <url>%2Fp%2Fb015b294%2F</url>
    <content type="text"><![CDATA[37.9% https://leetcode.com/problems/house-robber/#/description You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. ç¾Žå›¢ç‚¹è¯„ é¢è¯• æ–¹æ³•ä¸€ï¼š rob(i)è¡¨ç¤ºå·äº†ç¬¬iå®¶ï¼Œnotrob(i) ä¸å·ç¬¬iå®¶ã€‚ rob(i) = rob(i-1)+nums[i] ,notrob(i) = max(rob(i-1), notrob(i-1)) æˆ‘çš„ä»£ç å®žçŽ°ï¼š æ›´æ–°å…¬å¼ rob(i) = max(rob(i-1), notrob(i-1)+nums[i]); notrob(i) = max(rob(i-1), notrob(i-1)); 123456789101112131415161718class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; if(n==1) return nums[0]; int rob = nums[0], notrob = 0; for(int i=1; i&lt;n; i++)&#123; int new_rob = max(rob, notrob+nums[i]); int new_notrob = max(rob, notrob); rob = new_rob; notrob = new_notrob; &#125; return max(rob, notrob); &#125;&#125;; æ–¹æ³•äºŒï¼š ç”±æ–¹æ³•ä¸€è¿›è¡ŒæŽ¨è®ºå¯ä»¥å¾—åˆ° f(i+1) è¡¨ç¤ºå·åˆ°ç¬¬iå®¶çš„æœ€å¤§åˆ©ç›Š, f(0) = 0, f(1) = nums[1] åˆ™f(i+1) = max(f(i), f(i-1)+nums[i]) https://discuss.leetcode.com/topic/32215/c-dp-solution-with-thinking-process-explanation C++ DP solution with thinking process explanation Following the same logic described in a post about Best Time to Buy and Sell Stock with Cooldown, we could try to solve this problem with DP. Define the following variables rob[i] means max profit for any robbing sequence before house i ending with rob rest[i] mean max profit for any robbing sequence before house i ending with rest We could get the following relationship, 12rob[i] = max(rob[i-1], rest[i-1] + value)rest[i] = max(rest[i-1], rob[i-1]) Furthermore, we always gain more profit when robbing the house. As a result, 12rob[i] &gt; rest[i]rest[i] = rob[i-1] substitute these into the original equations, we get 1rob[i] = max(rob[i-1], rob[i-2] + value) So we only need two values to keep track of the max profit. 12345678910111213class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; auto best = 0, prev_best = 0; for(auto num : nums) &#123; auto pbest = best; best = max(best, prev_best + num); prev_best = pbest; &#125; return best; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; int r1 = 0, r2 = 0; int r3 = 0; for(auto num:nums)&#123; r3 = max(r2, r1+num); r1 = r2; r2 = r3; &#125; return r3; &#125;&#125;; https://discuss.leetcode.com/topic/28369/the-correct-dp-solution The correct DP solution Here is the DP formula that leads to the right answer: M(k) = money at the kth house P(0) = 0 P(1) = M(1) P(k) = max(P(kâˆ’2) + M(k), P(kâˆ’1)) https://discuss.leetcode.com/topic/11110/c-1ms-o-1-space-very-simple-solution C 1ms, O(1)space, very simple solution 12345678910111213141516171819#define max(a, b) ((a)&gt;(b)?(a):(b))int rob(int num[], int n) &#123; int a = 0; int b = 0; for (int i=0; i&lt;n; i++) &#123; if (i%2==0) &#123; a = max(a+num[i], b); &#125; else &#123; b = max(a, b+num[i]); &#125; &#125; return max(a, b);&#125; https://discuss.leetcode.com/topic/17199/python-solution-3-lines Python solution, 3 lines. Based on the recursive formula: f(0) = nums[0] f(1) = max(num[0], num[1]) f(k) = max( f(k-2) + nums[k], f(k-1) ) 123456789class Solution: def rob(self, nums): last, now = 0, 0 for i in nums: last, now = now, max(last + i, now) return now https://discuss.leetcode.com/topic/12735/c-my-solution-dp C++,My solution,DP 123456789101112131415class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; const int n = nums.size(); if (n == 0) return 0; if (n == 1) return nums[0]; if (n == 2) return max(nums[0], nums[1]); vector&lt;int&gt; f(n, 0); f[0] = nums[0]; f[1] = max(nums[0], nums[1]); for (int i = 2; i &lt; n; ++i) f[i] = max(f[i-2] + nums[i], f[i-1]); return f[n-1]; &#125;&#125;; 44ms, 31.77%, 69/69, April.25, 2016 https://leetcode.com/discuss/76958/3-line-python-solution Python solution, 3 lines. Based on the recursive formula: 123f(0) = nums[0]f(1) = max(num[0], num[1])f(k) = max( f(k-2) + nums[k], f(k-1) ) 123456789class Solution: def rob(self, nums): last, now = 0, 0 for i in nums: last, now = now, max(last + i, now) return now my code rob[i] = notrob[i-1] + nums[i] notrob[i] = max(rob[i-1], notrob[i-1]) 12345678910111213class Solution(object): def rob(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if not nums: return 0 rob, notrob = 0, 0 for num in nums: temp = rob rob = notrob + num notrob = max(temp, notrob) return max(rob, notrob)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[191. Number of 1 Bits]]></title>
    <url>%2Fp%2F1f95eca1%2F</url>
    <content type="text"><![CDATA[38.8% https://leetcode.com/problems/number-of-1-bits/?tab=Description Write a function that takes an unsigned integer and returns the number of â€™1â€™ bits it has (also known as the Hamming weight). 12For example, the 32-bit integer â€™11&apos; has binary representation00000000000000000000000000001011, so the function should return 3. æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 14ï¼Œ 2017 1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cnt = 0; while(n)&#123; n &amp;= n-1; cnt++; &#125; return cnt; &#125;&#125;; https://discuss.leetcode.com/topic/9915/short-code-of-c-o-m-by-time-m-is-the-count-of-1-s-and-another-several-method-of-o-1-time 12345678910int hammingWeight(uint32_t n)&#123; int res = 0; while(n) &#123; n &amp;= n - 1; ++ res; &#125; return res;&#125; my code 1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int res = 0; while(n)&#123; res += 1; n = n&amp;(n-1); &#125; return res; &#125;&#125;; java https://discuss.leetcode.com/topic/11385/simple-java-solution-bit-shifting 12345678public static int hammingWeight(int n) &#123; int ones = 0; while(n!=0) &#123; ones = ones + (n &amp; 1); n = n&gt;&gt;&gt;1; &#125; return ones;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[190. Reverse Bits]]></title>
    <url>%2Fp%2F60d7c33e%2F</url>
    <content type="text"><![CDATA[29.5% https://leetcode.com/problems/reverse-bits/?tab=Description Reverse bits of a given 32 bits unsigned integer. For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000). Follow up: If this function is called many times, how would you optimize it? Related problem: Reverse Integer æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š å¯¹äºŽå¤§æ•°ï¼Œè¦ç”¨long long 1234567891011121314class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; long long res = 0; long long cur = 1; for(int i=0; i&lt;32; i++)&#123; res &lt;&lt;= 1; if(cur&amp;n) res |= 1; cur &lt;&lt;= 1; &#125; return res; &#125;&#125;; æ³¨æ„ï¼š32ä½ï¼Œä¸è¦ä½¿ç”¨while(n) 12345678910114ms, 51.95%, July 14th, 2016https://discuss.leetcode.com/topic/10298/the-concise-c-solution-9msclass Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; uint32_t result = 0; for(int i=0; i&lt;32; i++) result = (result&lt;&lt;1) + (n&gt;&gt;i &amp; 1); //æ­¤å¤„+å¯ä»¥æ¢æˆ | return result; &#125;&#125;; my code æ³¨æ„ä¼˜å…ˆçº§ï¼Œ â€˜+â€™ &gt; â€˜&gt;&gt;â€™ &gt; â€˜&amp;â€™ &gt; â€˜|â€™ 1234567891011class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; uint32_t res = 0; for(int i=0; i&lt;32; i++)&#123; res = (res&lt;&lt;1) | (n&amp;1); // &apos;|&apos;å¯ä»¥ä¸º&apos;+&apos;ï¼Œä½†æ˜¯å¦‚æžœæ²¡æœ‰æ‹¬å·ï¼Œè¦æ³¨æ„ä¼˜å…ˆçº§ n &gt;&gt;= 1; &#125; return res; &#125;&#125;; my code: 123456789101112class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; uint32_t res = 0; for(int i=0; i&lt;32; i++)&#123; res &lt;&lt;= 1; res |= n &amp; 1; n &gt;&gt;= 1; &#125; return res; &#125;&#125;; python 1234567891011112ms, 2.09%, July 14th, 2016https://discuss.leetcode.com/topic/10069/python-ac-with-63ms-3linesclass Solution(object): def reverseBits(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; oribin = &apos;&#123;0:032b&#125;&apos;.format(n) reversebin = oribin[::-1] return int(reversebin, 2) java 123456789101112132ms, 50.87%, July 14th, 2016https://discuss.leetcode.com/topic/12236/concise-java-solutionpublic class Solution &#123; // you need treat n as an unsigned value public int reverseBits(int n) &#123; int result = 0; for(int i=0; i &lt; 32; ++i)&#123; result = result &lt;&lt; 1 | (n &amp; 1); n &gt;&gt;&gt;= 1; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[189. Rotate Array]]></title>
    <url>%2Fp%2Fde5421e%2F</url>
    <content type="text"><![CDATA[23.8% https://leetcode.com/problems/rotate-array/ Rotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Hint: Could you do it in-place with O(1) extra space? Related problem: Reverse Words in a String II https://discuss.leetcode.com/topic/9237/3-line-using-reverse æ–¹æ³•ä¸€ï¼šä¸‰æ¬¡åè½¬ ç¬¬ä¸€æ¬¡ å…¨éƒ¨åè½¬ï¼› ç¬¬äºŒæ¬¡åè½¬å·¦è¾¹çš„kä¸ªï¼› ç¬¬ä¸‰æ¬¡å³è¾¹çš„n-kä¸ªã€‚ æ³¨æ„ï¼Œcppçš„å†…ç½®reverseå‡½æ•° æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 14ï¼Œ 2017 123456789101112class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); if(n==0 || k==0) return; reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin()+k%n); reverse(nums.begin()+k%n, nums.end()); return; &#125;&#125;; å› ä¸ºæ˜¯å‘å³ç§»kä½ï¼Œå½“ç§»åŠ¨nums.size()çš„æ—¶å€™ï¼Œå°±ä¸Žä¸ç§»åŠ¨nums.size()æ˜¯ä¸€æ ·çš„ï¼Œæ‰€ä»¥k%=n 123456789class Solution &#123;public: void rotate(vector&lt;int&gt; &amp; nums, int k) &#123; int n = nums.size(); reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin()+k%n); reverse(nums.begin()+k%n, nums.end()); &#125;&#125;; https://discuss.leetcode.com/topic/9406/3-lines-of-c-in-one-pass-using-swap Every swap will put one number into its correct position, so the running time is O(n) For example, at first, nums[] is [1,2,3,4,5,6,7], n is 7, k is 3 after first outer loop, nums[] is [4,1,2,3], n is 4, k is 3 after second outer loop, nums[] is [4], n is 1, k is 0 loop ends. æ–¹æ³•äºŒï¼šå‰kä¸ªä¸Žæœ€åŽkä¸ªäº’æ¢ï¼Œå‰kä¸ªæ­£ä½äº†ã€‚å†å¤„ç†k+1è‡³æœ€åŽä¸€ä½ï¼Œä¸Žå‰ä¸€é—®é¢˜ç›¸åŒï¼Œç»§ç»­å‰é¢çš„æ–¹æ³•å¤„ç†ã€‚12345678910class Solution &#123;public: void rotate(vector&lt;int&gt;&amp;nums, int k) &#123; int n = nums.size(); int start = 0; for (; k %= n; n -= k, start+=k) for (int i = 0; i &lt; k; i++) swap(nums[start+i], nums[start + n - k + i]); &#125;&#125;; https://discuss.leetcode.com/topic/9801/summary-of-c-solutions Make an extra copy and then rotate. Time complexity: O(n). Space complexity: O(n). 123456789101112131415class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); if(n==0 || k&lt;=0) return; vector&lt;int&gt; mycopy(n); for(int i=0; i&lt;n; i++) mycopy[i] = nums[i]; for(int i=0; i&lt;n; i++) nums[(i+k)%n] = mycopy[i]; &#125;&#125;; python236ms, 3.89%, June.22th, 2016 https://leetcode.com/discuss/29657/my-simple-python-code pythonå†…ç½®æ–¹æ³• 12345678910class Solution(object): def rotate(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; while k &gt; 0: nums.insert(0, nums.pop()) k -= 1 javahttps://discuss.leetcode.com/topic/14341/easy-to-read-java-solution 123456789101112131415161718public class Solution &#123; public void rotate(int[] nums, int k) &#123; k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); &#125; public void reverse(int[] nums, int start, int end) &#123; while (start &lt; end) &#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[188. Best Time to Buy and Sell Stock IV]]></title>
    <url>%2Fp%2F96f6f6%2F</url>
    <content type="text"><![CDATA[24.0% https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/ Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). java https://discuss.leetcode.com/topic/8984/a-concise-dp-solution-in-java A Concise DP Solution in Java The general idea is DP, while I had to add a â€œquickSolveâ€ function to tackle some corner cases to avoid TLE. DP: t(i,j) is the max profit for up to i transactions by time j (0&lt;=i&lt;=K, 0&lt;=j&lt;=T). 1234567891011121314151617181920212223public int maxProfit(int k, int[] prices) &#123; int len = prices.length; if (k &gt;= len / 2) return quickSolve(prices); int[][] t = new int[k + 1][len]; for (int i = 1; i &lt;= k; i++) &#123; int tmpMax = -prices[0]; for (int j = 1; j &lt; len; j++) &#123; t[i][j] = Math.max(t[i][j - 1], prices[j] + tmpMax); tmpMax = Math.max(tmpMax, t[i - 1][j - 1] - prices[j]); &#125; &#125; return t[k][len - 1];&#125;private int quickSolve(int[] prices) &#123; int len = prices.length, profit = 0; for (int i = 1; i &lt; len; i++) // as long as there is a price gap, we gain a profit. if (prices[i] &gt; prices[i - 1]) profit += prices[i] - prices[i - 1]; return profit;&#125; https://discuss.leetcode.com/topic/26169/clean-java-dp-solution-with-comment Clean Java DP solution with comment 123456789101112131415161718192021222324252627282930313233/** * dp[i, j] represents the max profit up until prices[j] using at most i transactions. * dp[i, j] = max(dp[i, j-1], prices[j] - prices[jj] + dp[i-1, jj]) &#123; jj in range of [0, j-1] &#125; * = max(dp[i, j-1], prices[j] + max(dp[i-1, jj] - prices[jj])) * dp[0, j] = 0; 0 transactions makes 0 profit * dp[i, 0] = 0; if there is only one price data point you can&apos;t make any transaction. */public int maxProfit(int k, int[] prices) &#123; int n = prices.length; if (n &lt;= 1) return 0; //if k &gt;= n/2, then you can make maximum number of transactions. if (k &gt;= n/2) &#123; int maxPro = 0; for (int i = 1; i &lt; n; i++) &#123; if (prices[i] &gt; prices[i-1]) maxPro += prices[i] - prices[i-1]; &#125; return maxPro; &#125; int[][] dp = new int[k+1][n]; for (int i = 1; i &lt;= k; i++) &#123; int localMax = dp[i-1][0] - prices[0]; for (int j = 1; j &lt; n; j++) &#123; dp[i][j] = Math.max(dp[i][j-1], prices[j] + localMax); localMax = Math.max(localMax, dp[i-1][j] - prices[j]); &#125; &#125; return dp[k][n-1];&#125; https://discuss.leetcode.com/topic/24079/easy-understanding-and-can-be-easily-modified-to-different-situations-java-solution Easy understanding and can be easily modified to different situations Java Solution The basic idea is to create two tables. hold and unhold. hold[i][j] means the maximum profit with at most j transaction for 0 to i-th day. hold means you have a stock in your hand. unhold[i][j] means the maximum profit with at most j transaction for 0 to i-th day. unhold means you donâ€™t have a stock in your hand. The equation is 123hold[i][j] = Math.max(unhold[i-1][j]-prices[i],hold[i-1][j]);unhold[i][j] = Math.max(hold[i-1][j-1]+prices[i],unhold[i-1][j]); when you sell your stock this is a transaction but when you buy a stock, it is not considered as a full transaction. so this is why the two equation look a little different. And we have to initiate hold table when k = 0. When the situation is you can not buy a new stock at the same day when you sell it. For example you can only buy a new stock after one day you sell it. The same idea. Another situation is when you have to pay a transaction fee for each transaction, just make a modification when you sell it, So just change the unhold equation a little. 12345678910111213141516171819202122232425262728public class Solution &#123; //hold[i][k] ith day k transaction have stock and maximum profit //unhold[i][k] ith day k transaction do not have stock at hand and maximum profit public int maxProfit(int k, int[] prices) &#123; if(k&gt;prices.length/2) return maxP(prices); int[][] hold = new int[prices.length][k+1]; int[][] unhold = new int[prices.length][k+1]; hold[0][0] = -prices[0]; for(int i=1;i&lt;prices.length;i++) hold[i][0] = Math.max(hold[i-1][0],-prices[i]); for(int j=1;j&lt;=k;j++) hold[0][j] = -prices[0]; for(int i=1;i&lt;prices.length;i++)&#123; for(int j=1;j&lt;=k;j++)&#123; hold[i][j] = Math.max(unhold[i-1][j]-prices[i],hold[i-1][j]); unhold[i][j] = Math.max(hold[i-1][j-1]+prices[i],unhold[i-1][j]); &#125; &#125; return Math.max(hold[prices.length-1][k],unhold[prices.length-1][k]); &#125; public int maxP(int[] prices)&#123; int res =0; for(int i=0;i&lt;prices.length;i++)&#123; if(i&gt;0 &amp;&amp; prices[i] &gt; prices[i-1])&#123; res += prices[i]-prices[i-1]; &#125; &#125; return res; &#125;&#125; cpp https://discuss.leetcode.com/topic/9522/c-solution-with-o-n-klgn-time-using-max-heap-and-stack C++ Solution with O(n + klgn) time using Max Heap and Stack We can find all adjacent valley/peak pairs and calculate the profits easily. Instead of accumulating all these profits like Buy&amp;Sell Stock II, we need the highest k ones. The key point is when there are two v/p pairs (v1, p1) and (v2, p2), satisfying v1 &lt;= v2 and p1 &lt;= p2, we can either make one transaction at [v1, p2], or make two at both [v1, p1] and [v2, p2]. The trick is to treat [v1, p2] as the first transaction, and [v2, p1] as the second. Then we can guarantee the right max profits in both situations, p2 - v1 for one transaction and p1 - v1 + p2 - v2 for two. Finding all v/p pairs and calculating the profits takes O(n) since there are up to n/2 such pairs. And extracting k maximums from the heap consumes another O(klgn). 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt; &amp;prices) &#123; int n = (int)prices.size(), ret = 0, v, p = 0; priority_queue&lt;int&gt; profits; stack&lt;pair&lt;int, int&gt; &gt; vp_pairs; while (p &lt; n) &#123; // find next valley/peak pair for (v = p; v &lt; n - 1 &amp;&amp; prices[v] &gt;= prices[v+1]; v++); for (p = v + 1; p &lt; n &amp;&amp; prices[p] &gt;= prices[p-1]; p++); // save profit of 1 transaction at last v/p pair, if current v is lower than last v while (!vp_pairs.empty() &amp;&amp; prices[v] &lt; prices[vp_pairs.top().first]) &#123; profits.push(prices[vp_pairs.top().second-1] - prices[vp_pairs.top().first]); vp_pairs.pop(); &#125; // save profit difference between 1 transaction (last v and current p) and 2 transactions (last v/p + current v/p), // if current v is higher than last v and current p is higher than last p while (!vp_pairs.empty() &amp;&amp; prices[p-1] &gt;= prices[vp_pairs.top().second-1]) &#123; profits.push(prices[vp_pairs.top().second-1] - prices[v]); v = vp_pairs.top().first; vp_pairs.pop(); &#125; vp_pairs.push(pair&lt;int, int&gt;(v, p)); &#125; // save profits of the rest v/p pairs while (!vp_pairs.empty()) &#123; profits.push(prices[vp_pairs.top().second-1] - prices[vp_pairs.top().first]); vp_pairs.pop(); &#125; // sum up first k highest profits for (int i = 0; i &lt; k &amp;&amp; !profits.empty(); i++) &#123; ret += profits.top(); profits.pop(); &#125; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/12250/share-my-c-dp-solution-with-o-kn-time-o-k-space-10ms Share my C++ DP solution with O(kn) time O(k) space, 10ms This is my DP solution: 123456789101112131415161718192021222324252627282930class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt; &amp;prices) &#123; int len = prices.size(); if (len&lt;2) return 0; if (k&gt;len/2)&#123; // simple case int ans = 0; for (int i=1; i&lt;len; ++i)&#123; ans += max(prices[i] - prices[i-1],0); &#125; return ans; &#125; int hold[k+1]; int rele[k+1]; for (int i=0;i&lt;=k;++i)&#123; hold[i] = INT_MIN; rele[i] = 0; &#125; int cur; for (int i=0; i&lt;len; ++i)&#123; cur = prices[i]; for(int j=k; j&gt;0; --j)&#123; rele[j] = max(rele[j],hold[j] + cur); hold[j] = max(hold[j],rele[j-1] - cur); &#125; &#125; return rele[k]; &#125;&#125;; Inspired by weijiac in Best Time to Buy and Sell Stock III https://leetcode.com/discuss/18330/is-it-best-solution-with-o-n-o-1 https://discuss.leetcode.com/topic/30242/o-n-time-8ms-accepted-solution-with-detailed-explanation-c O(n)-time 8ms Accepted Solution with Detailed Explanation (C++) The idea of this thread was originally proposed by @yishiluo in https://leetcode.com/discuss/26745/c-solution-with-o-n-klgn-time-using-max-heap-and-stack General idea: We use the term â€œvalleyâ€ to denote a local minimum index of prices, and the term â€œpeakâ€ to denote a local maximum index of prices. Let (v1, p1) and (v2, p2) denote two successive valley-peak pairs of the prices, respectively. Consider the two cases: Case 1: prices[v1] &lt;= prices[v2] and prices[p1] &lt;= prices[p2]. In this case, if we can conduct one transaction, we will use (v1, p2). If we can conduct two transactions, we will use (v1, p1) and (v2, p2). Equivalently, we can consider (v1, p2) as one transaction opportunity, and (v2, p1) as another transaction opportunity. The key idea is that these two original valley-peak pairs provide two transaction opportunities: (v1, p2) and (v2, p1). Case 2: prices[v1] &gt;= prices[v2] or prices[p1] &gt;= prices[p2]. In this case, if we can conduct one transaction, we will use either (v1, p1) or (v2, p2). If we can conduct two transactions, we will use both (v1, p1) and (v2, p2). That is, these two valley-peak pairs provides two transaction opportunities: (v1, p1) and (v2, p2). The algorithm consists of two steps: Step 1: Find all transaction opportunities and record their profits. We use a stack vps to store the valley-peak pairs of the stock prices, wherein the valley value is sorted in ascending order. (The valley value at the top of the stack is the largest.) The profit of all transaction opportunities are recorded in the vector profits. The time complexity of this step is O(n). Step 2: Find the k most profitable transaction opportunities. The maximum profit we can get is the summation of the k opportunity. The time complexity of this step is O(n), too. Overall complexity: Time: O(n) Space: worse-case O(n) C++ code (Accepted 8ms) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; // Step 1: Find out all profit opportunities vector&lt;int&gt; profits; stack&lt;pair&lt;int, int&gt;&gt; vps; // valley-peak pairs int v; int p = -1; for (;;) &#123; // find next valley-peak pair for (v = p+1; (v+1 &lt; prices.size()) &amp;&amp; (prices[v] &gt;= prices[v+1]); ++v); for (p = v ; (p+1 &lt; prices.size()) &amp;&amp; (prices[p] &lt;= prices[p+1]); ++p); if (v == p) &#123; // v==p means that both v and p reach the end of the array break; &#125; // Consider two transactions (v1, p1) (back of the stack) and (v2, p2) (the new-found). // If prices[v1] &gt;= prices[v2], // it is meaningless to combine the two transactions. // Save of profit of (v1, p1), and pop it out of the record. while ((!vps.empty()) &amp;&amp; (prices[v] &lt;= prices[vps.top().first])) &#123; profits.push_back(prices[vps.top().second] - prices[vps.top().first]); vps.pop(); &#125; // If prices[v1]&lt;prices[v2] and prices[p1]&lt;prices[p2], // then it is meaningful to combine the two transactions // update (v1, p1) to (v1, p2), and save the profit of (v2, p1) while ((!vps.empty()) &amp;&amp; (prices[p] &gt;= prices[vps.top().second])) &#123; profits.push_back(prices[vps.top().second] - prices[v]); v = vps.top().first; vps.pop(); &#125; // save the new-found valley-peak pair vps.emplace(v, p); &#125; // save all remaining profits while (!vps.empty()) &#123; profits.push_back(prices[vps.top().second] - prices[vps.top().first]); vps.pop(); &#125; // Step 2: Calculate the k highest profits int ret; if (profits.size() &lt;= k) &#123; ret = accumulate(profits.begin(), profits.end(), 0); &#125; else &#123; nth_element(profits.begin(), profits.end() - k, profits.end()); ret = accumulate(profits.end() - k, profits.end(), 0); &#125; return ret; &#125;&#125;; python https://discuss.leetcode.com/topic/22245/well-explained-python-dp-with-comments Well explained Python DP with comments I think the general idea has been thoroughly explained by other brilliant leetcoders. All of the solutions are beautiful and concise. However, most of the them donâ€™t look obvious to me, so I wrote this and hope it looks more straight forward.Itâ€™s O(kn), apparently not optimal. I name the key variables as local profit and global profit to make things much understandable (well, at least , to me). Performance is not too bad though. 1234567891011121314151617181920212223242526272829303132def maxProfit4(self, k, prices): n = len(prices) if n &lt; 2: return 0 # k is big enougth to cover all ramps. if k &gt;= n / 2: return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j &gt; 0) globalMax = [[0] * n for _ in xrange(k + 1)] for i in xrange(1, k + 1): # The max profit with i transations and selling stock on day j. localMax = [0] * n for j in xrange(1, n): profit = prices[j] - prices[j - 1] localMax[j] = max( # We have made max profit with (i - 1) transations in # (j - 1) days. # For the last transation, we buy stock on day (j - 1) # and sell it on day j. globalMax[i - 1][j - 1] + profit, # We have made max profit with (i - 1) transations in # (j - 1) days. # For the last transation, we buy stock on day j and # sell it on the same day, so we have 0 profit, apparently # we do not have to add it. globalMax[i - 1][j - 1], # + 0, # We have made profit in (j - 1) days. # We want to cancel the day (j - 1) sale and sell it on # day j. localMax[j - 1] + profit) globalMax[i][j] = max(globalMax[i][j - 1], localMax[j]) return globalMax[k][-1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[187. Repeated DNA Sequences]]></title>
    <url>%2Fp%2F11769ba3%2F</url>
    <content type="text"><![CDATA[30.1% All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: â€œACGAATTCCGâ€. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. 123456For example,Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",Return:["AAAAACCCCC", "CCCCCAAAAA"]. æ–¹æ³•ä¸€: æˆ‘çš„ä»£ç å®žçŽ°: 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; vector&lt;string&gt; res; if(s.size()&lt;10) return res; unordered_set&lt;int&gt; set1, set2; unordered_map&lt;char, int&gt; map = &#123;&#123;'A', 0&#125;, &#123;'C', 1&#125;, &#123;'G', 2&#125;, &#123;'T', 3&#125;&#125;; for(int i=0; i&lt;=s.size()-10; i++)&#123; int k=0; for(int j=i; j&lt;i+10; j++)&#123; k &lt;&lt;= 2; k |= map[s[j]]; &#125; if(set1.find(k)!=set1.end() &amp;&amp; set2.find(k)==set2.end())&#123; res.push_back(s.substr(i, 10)); set2.insert(k); &#125; set1.insert(k); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/8894/clean-java-solution-hashmap-bits-manipulation Clean Java solution (hashmap + bits manipulation) 12345678910111213141516171819202122public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123; Set&lt;Integer&gt; words = new HashSet&lt;&gt;(); Set&lt;Integer&gt; doubleWords = new HashSet&lt;&gt;(); List&lt;String&gt; rv = new ArrayList&lt;&gt;(); char[] map = new char[26]; //map[&apos;A&apos; - &apos;A&apos;] = 0; map[&apos;C&apos; - &apos;A&apos;] = 1; map[&apos;G&apos; - &apos;A&apos;] = 2; map[&apos;T&apos; - &apos;A&apos;] = 3; for(int i = 0; i &lt; s.length() - 9; i++) &#123; int v = 0; for(int j = i; j &lt; i + 10; j++) &#123; v &lt;&lt;= 2; v |= map[s.charAt(j) - &apos;A&apos;]; &#125; if(!words.add(v) &amp;&amp; doubleWords.add(v)) &#123; rv.add(s.substring(i, i + 10)); &#125; &#125; return rv;&#125; https://discuss.leetcode.com/topic/8487/i-did-it-in-10-lines-of-c I did it in 10 lines of C++ The main idea is to store the substring as int in map to bypass the memory limits. There are only four possible character A, C, G, and T, but I want to use 3 bits per letter instead of 2. Why? Itâ€™s easier to code. A is 0x41, C is 0x43, G is 0x47, T is 0x54. Still donâ€™t see it? Let me write it in octal. A is 0101, C is 0103, G is 0107, T is 0124. The last digit in octal are different for all four letters. Thatâ€™s all we need! We can simply use s[i] &amp; 7 to get the last digit which are just the last 3 bits, itâ€™s much easier than lookup table or switch or a bunch of if and else, right? We donâ€™t really need to generate the substring from the int. While counting the number of occurrences, we can push the substring into result as soon as the count becomes 2, so there wonâ€™t be any duplicates in the result. 1234567891011vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; unordered_map&lt;int, int&gt; m; vector&lt;string&gt; r; int t = 0, i = 0, ss = s.size(); while (i &lt; 9) t = t &lt;&lt; 3 | s[i++] &amp; 7; while (i &lt; ss) if (m[t = t &lt;&lt; 3 &amp; 0x3FFFFFFF | s[i++] &amp; 7]++ == 1) r.push_back(s.substr(i - 10, 10)); return r;&#125; BTW, the OJ doesnâ€™t seems to have test cases which the given string length is smaller than 9, so I didnâ€™t check it to make the code simpler. Any suggestions? Update: I realised that I can use s[i] &gt;&gt; 1 &amp; 3 to get 2 bits, but then I wonâ€™t be able to remove the first loop as 1337c0d3r suggested. https://discuss.leetcode.com/topic/8487/i-did-it-in-10-lines-of-c/2 Neat idea. The additional 1 bit per letter still encode each substring in 10x3 = 30 bits, just under 4 bytes for a 32-bit integer. Your code could be further simplified. By observing that s[i] &amp; 7 is never 0, each of the first nine substrings with length &lt; 10 will have unique hash key and will never collide with other 10-letter long sequences. Therefore the first loop could be removed and be compacted into a single loop. 12345678vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; unordered_map&lt;int, int&gt; m; vector&lt;string&gt; r; for (int t = 0, i = 0; i &lt; s.size(); i++) if (m[t = t &lt;&lt; 3 &amp; 0x3FFFFFFF | s[i] &amp; 7]++ == 1) r.push_back(s.substr(i - 9, 10)); return r;&#125; Another observation is the mapped value need not be an integer counter, and could simply be a boolean to further save space. This requires some extra logic though: 12345678910111213141516vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; unordered_map&lt;int, bool&gt; m; vector&lt;string&gt; r; for (int t = 0, i = 0; i &lt; s.size(); i++) &#123; t = t &lt;&lt; 3 &amp; 0x3FFFFFFF | s[i] &amp; 7; if (m.find(t) != m.end()) &#123; if (m[t]) &#123; r.push_back(s.substr(i - 9, 10)); m[t] = false; &#125; &#125; else &#123; m[t] = true; &#125; &#125; return r;&#125; PS: OJ does have test cases which the given string has length that is less than 9. https://discuss.leetcode.com/topic/8487/i-did-it-in-10-lines-of-c/3 Concise solution! A little longer but more readable solution base on your idea. 1234567891011121314int str2int(string s) &#123; int str=0; for (int i = 0; i &lt; s.size(); ++i) str = (str&lt;&lt;3) +(s[i]&amp;7); return str;&#125;vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; vector&lt;string&gt; res; unordered_map&lt;int,int&gt; coll; for (int i = 0; i+10 &lt;= s.size(); ++i) if (coll[str2int(s.substr(i,10))]++ == 1) res.push_back(s.substr(i,10)); return res;&#125; https://discuss.leetcode.com/topic/27517/7-lines-simple-java-o-n 7 lines simple Java, O(n) 123456789public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123; Set seen = new HashSet(), repeated = new HashSet(); for (int i = 0; i + 9 &lt; s.length(); i++) &#123; String ten = s.substring(i, i + 10); if (!seen.add(ten)) repeated.add(ten); &#125; return new ArrayList(repeated);&#125; https://discuss.leetcode.com/topic/8539/short-java-rolling-hash-solution Short Java â€œrolling-hashâ€ solution Hi guys! The idea is to use rolling hash technique or in case of string search also known as Rabin-Karp algorithm. As our alphabet A consists of only 4 letters we can be not afraid of collisions. The hash for a current window slice could be found in a constant time by subtracting the former first character times size of the A in the power of 9 and updating remaining hash by the standard rule: hash = hash*A.size() + curr_char. Check out the Java code below. Hope it helps! 12345678910111213141516public class Solution &#123; private static final Map&lt;Character, Integer&gt; A = new HashMap&lt;&gt;(); static &#123; A.put(&apos;A&apos;,0); A.put(&apos;C&apos;,1); A.put(&apos;G&apos;,2); A.put(&apos;T&apos;,3); &#125; private final int A_SIZE_POW_9 = (int) Math.pow(A.size(), 9); public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123; Set&lt;String&gt; res = new HashSet&lt;&gt;(); Set&lt;Integer&gt; hashes = new HashSet&lt;&gt;(); for (int i = 0, rhash = 0; i &lt; s.length(); i++) &#123; if (i &gt; 9) rhash -= A_SIZE_POW_9 * A.get(s.charAt(i-10)); rhash = A.size() * rhash + A.get(s.charAt(i)); if (i &gt; 8 &amp;&amp; !hashes.add(rhash)) res.add(s.substring(i-9,i+1)); &#125; return new ArrayList&lt;&gt;(res); &#125;&#125; https://discuss.leetcode.com/topic/18263/10-lines-c-code-8-ms-passed 10 lines C++ code, 8 ms passed! 123456789101112vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; char hashMap[1048576] = &#123;0&#125;; vector&lt;string&gt; ans; int len = s.size(),hashNum = 0; if (len &lt; 11) return ans; for (int i = 0;i &lt; 9;++i) hashNum = hashNum &lt;&lt; 2 | (s[i] - &apos;A&apos; + 1) % 5; for (int i = 9;i &lt; len;++i) if (hashMap[hashNum = (hashNum &lt;&lt; 2 | (s[i] - &apos;A&apos; + 1) % 5) &amp; 0xfffff]++ == 1) ans.push_back(s.substr(i-9,10)); return ans;&#125; https://discuss.leetcode.com/topic/10880/11ms-solution-with-unified-hash-fxn ~ 11ms Solution with Unified Hash Fxn Appricate for advice. 123456789101112131415161718192021222324252627282930313233343536373839404142vector&lt;string&gt; findRepeatedDnaSequences(string s)&#123; vector&lt;string&gt; ret; if ( s.length() &lt; 11 ) &#123; return ret; &#125; char table[1048576] = &quot;&quot;; unsigned int hash = 0U; for ( size_t i = 0; i &lt; 10; ++i ) &#123; /** &apos;A&apos; - &apos;A&apos; + 1 = 1 = 1 (mod 5) * &apos;C&apos; - &apos;A&apos; + 1 = 3 = 3 (mod 5) * &apos;G&apos; - &apos;A&apos; + 1 = 7 = 2 (mod 5) * &apos;T&apos; - &apos;A&apos; + 1 = 20 = 0 (mod 5) */ hash = ( hash &lt;&lt; 2 ) | ( ( s[i] - &apos;A&apos; + 1 ) % 5 ); &#125; table[hash] = 1; for ( size_t i = 10; i &lt; s.length(); ++i ) &#123; hash = ( ( hash &lt;&lt; 2 ) ^ ( ( s[ i - 10 ] - &apos;A&apos; + 1 ) % 5 ) &lt;&lt; 20 ) | ( ( s[i] - &apos;A&apos; + 1 ) % 5 ); if ( table[hash] == 0 ) &#123; table[hash] = 1; &#125; else if ( table[hash] == 1 ) &#123; table[hash] = 2; ret.push_back( string( s, i - 9, 10 ) ); &#125; &#125; return ret;&#125; https://discuss.leetcode.com/topic/31640/20-ms-solution-c-with-explanation 20 ms solution (C++) with explanation One obvious way to do this is to use a hash table mapping strings to counts. (e.g. H[â€œAAAAAAAAAAâ€] represents the number of times we have seen AAAAAAAAAA. This will work in O(n) time, but its useful to discuss why this is not a good solution: Runtime constant (from hashing): When using a hash table, there is a runtime hit for hashing the string. In this case, converting the string to a table index. That will presumably mean looking at each character of the string. Since each character is part of 10 different substrings (other than the end characters), that means 10n character reads. Still linear, but we can do better on the constant. Memory (values): There isnâ€™t any reason to store a count. Each possible string has only 3 states we need to track: â€œnever been seenâ€, â€œbeen seen onceâ€, and â€œbeen seen more than onceâ€. This requires only two bits to track â€“ not the 4-8 bytes needed for an integer. Memory (keys): A hash table needs to store each key (to resolve collisions). At 10 bytes per key, thats 10*n bytes â€“ a potential problem if n is every large, and completely unnecessary. Here is how we address the three problems: Hashing: We compute the hash ourselves, but take advantage of the overlapping. We treat each letter as a two-bit number. (Arbitrarily, A=0, C=1, G=2, T=3.) We treat ten consecutive letters as a 20-bit integer. We can calculate the first one with: 123int val = 0;for (int i=0; i &lt; 10; i++) val = (val &lt;&lt; 2) | char2val(s[i]); Now, to compute the next string: 1val = ((val &lt;&lt; 2) &amp; mask) | char2val(s[10]); Where: mask: 20 consecutive bits ((1 &lt;&lt; 21) -1). ((val &lt;&lt; 2) &amp; mask: shift everything over two bits, and get rid of the most significant bits. ((val &lt;&lt; 2) &amp; mask) | char2val(s[10]): Replace the right-most two bits with the character code.Much faster than looking at every character 10 times. Hash table: We instead use two bit-sets. There are 2^{21}-1 possible strings. We need a bit in each set for each possible string. The first set (S1) tells us if the string has been seen once or not. The second set (S2) tell us whether the string has been seen more than once. Code: 1234567891011121314151617181920212223242526272829303132333435363738vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; if (s.size() &lt;= 10) return vector&lt;string&gt;(); vector&lt;string&gt; R; bitset&lt;1&lt;&lt;20&gt; S1; bitset&lt;1&lt;&lt;20&gt; S2; int val = 0; for (int i=0; i &lt; 10; i++) // Calc. the has value for the first string. val = (val &lt;&lt; 2) | char2val(s[i]); S1.set(val); cout &lt;&lt; val &lt;&lt; &quot; | &quot;; int mask = (1 &lt;&lt; 20) - 1; for (int i=10; i &lt; s.size(); i++) &#123; // Calc the hash value for the string ending at position i. val = ((val &lt;&lt; 2) &amp; mask) | char2val(s[i]); if (S2[val]) continue; if (S1[val]) &#123; R.push_back(s.substr(i-10+1, 10)); S2.set(val); &#125; else S1.set(val); &#125; return R;&#125;int char2val(char c) &#123; switch (c) &#123; case &apos;A&apos;: return 0; case &apos;C&apos;: return 1; case &apos;G&apos;: return 2; case &apos;T&apos;: return 3; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>medium</tag>
        <tag>bitmanipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[179. Largest Number]]></title>
    <url>%2Fp%2F7dd5a2b3%2F</url>
    <content type="text"><![CDATA[21.8% https://leetcode.com/problems/largest-number/?tab=Description Given a list of non negative integers, arrange them such that they form the largest number. 1For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330. Note: The result may be very large, so you need to return a string instead of an integer. æ–¹æ³•ä¸€ï¼š å‰‘æŒ‡offer 33 æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end(), [](int a, int b)&#123;return to_string(a)+to_string(b)&gt;to_string(b)+to_string(a);&#125;); string res; for(int i=0; i&lt;nums.size(); i++)z res += to_string(nums[i]); // å­¦ä¹ eraseçš„ç”¨æ³• erase(pos, len) while(res.size()&gt;1 &amp;&amp; res[0]=='0') res.erase(0, 1); return res; &#125;&#125;; è½¬æ¢æˆstringï¼Œç„¶åŽæ¯”è¾ƒï¼Œç›¸åŠ ï¼Œè€ƒè™‘ç¬¬ä¸€ä¸ªå€¼ä¸º0çš„æƒ…å†µ https://discuss.leetcode.com/topic/7286/a-simple-c-solution A simple C++ solution å…ˆå˜æˆå­—ç¬¦ä¸²æŽ’åºï¼Œç„¶åŽç´¯åŠ ï¼Œå†è¿›è¡Œåˆ é™¤å‰é¢çš„0 ç®€å•ç›´æŽ¥ æ­¤å¤„å­¦ä¹ to_string çš„ç”¨æ³•ï¼Œè¿˜æœ‰eraseçš„ç”¨æ³•ã€‚ stringæ­¤å¤„ç”¨çš„begin(arr),ä¸åŒäºŽvectorçš„arr.begin() åŽé¢çš„æ¯”è¾ƒä¹Ÿæ˜¯å¼•ç”¨ erase(0, 1) erase(start, end), å…¶ä¸­åˆ é™¤å…³ç³»[start, end) 123456789101112131415class Solution &#123;public: string largestNumber(vector&lt;int&gt; &amp;num) &#123; vector&lt;string&gt; arr; for(auto i:num) arr.push_back(to_string(i)); sort(begin(arr), end(arr), [](string &amp;s1, string &amp;s2)&#123; return s1+s2&gt;s2+s1; &#125;); string res; for(auto s:arr) res+=s; while(res[0]==&apos;0&apos; &amp;&amp; res.length()&gt;1) res.erase(0,1); return res; &#125;&#125;; erase çš„ç”¨æ³• iterator erase (iterator position); iterator erase (iterator first, iterator last); position Iterator pointing to a single element to be removed from the vector. Member types iterator and const_iterator are random access iterator types that point to elements. first, last Iterators specifying a range within the vector] to be removed: [first,last). i.e., the range includes all the elements between first and last, including the element pointed by first but not the one pointed by last. Member types iterator and const_iterator are random access iterator types that point to elements. å‰‘æŒ‡offer 33æŠŠæ•°ç»„æŽ’æˆæœ€å°çš„æ•° è¾“å…¥ä¸€ä¸ªæ­£æ•´æ•°æ•°ç»„ï¼ŒæŠŠæ•°ç»„é‡Œæ‰€æœ‰æ•°å­—æ‹¼æŽ¥èµ·æ¥æŽ’æˆä¸€ä¸ªæ•°ï¼Œæ‰“å°èƒ½æ‹¼æŽ¥å‡ºçš„æ‰€æœ‰æ•°å­—ä¸­æœ€å°çš„ä¸€ä¸ªã€‚ä¾‹å¦‚è¾“å…¥æ•°ç»„{3ï¼Œ32ï¼Œ321}ï¼Œåˆ™æ‰“å°å‡ºè¿™ä¸‰ä¸ªæ•°å­—èƒ½æŽ’æˆçš„æœ€å°æ•°å­—ä¸º321323ã€‚ æ–¹æ³•ä¸€ï¼š é¢˜ç›®ä¸ºæ­£æ•°ï¼Œå¦‚æžœæœ‰0ï¼Œåˆ™åŠ ä¸Šä»£ç ä¸­æ³¨é‡Šçš„ä»£ç  æ•´æ•°è½¬stringçš„å‡½æ•°to_string(a) stringå¯ä»¥ç›¸åŠ  a+b å¦‚æžœæœ‰å¿…è¦ï¼Œæ£€æŸ¥è¾¹ç•Œæ˜¯å¦æœ‰0çš„æƒ…å†µ 12345678910111213class Solution &#123;public: string PrintMinNumber(vector&lt;int&gt; numbers) &#123; string res = &quot;&quot;; sort(numbers.begin(), numbers.end(), [](int a, int b) &#123;return to_string(a)+to_string(b)&lt;to_string(b)+to_string(a);&#125;); for(auto num:numbers) res += to_string(num); //while(res[0]==&apos;0&apos; &amp;&amp; res.length()&gt;1) // res.erase(0,1); return res; &#125;&#125;; https://discuss.leetcode.com/topic/10920/share-a-short-code-in-c Share a short code in c++ 12345678910111213class Solution &#123;public: string largestNumber(vector&lt;int&gt; &amp;num) &#123; sort(num.begin(), num.end(), [](int a, int b)&#123; return to_string(a)+to_string(b) &gt; to_string(b)+to_string(a); &#125;); string ans; for(int i=0; i&lt;num.size(); i++)&#123; ans += to_string(num[i]); &#125; return ans[0]==&apos;0&apos; ? &quot;0&quot; : ans; &#125;&#125;; https://discuss.leetcode.com/topic/12293/simple-10-line-c-solution Simple 10-line C++ Solution 123456789101112131415class Solution &#123; public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; string ret; sort(nums.begin(),nums.end(), [](const int &amp;m,const int&amp;n)&#123; return to_string(m)+to_string(n)&gt;to_string(n)+to_string(m);&#125;); for(int i=0;i&lt;nums.size();++i)&#123; ret+=to_string(nums[i]); &#125; if(ret[0]==&apos;0&apos;) //for the case nums are all zeros return &quot;0&quot;; return ret; &#125; &#125;; https://discuss.leetcode.com/topic/7722/python-simple-solution-in-4-lines Python simple solution in 4 lines Itâ€™s all about comparison . We define a func that compares two strings a ,b. we consider a bigger than b if a+b &gt; b+a . then we sort the numbers and concatenate them . 12345678class Solution:# @param num, a list of integers# @return a stringdef largestNumber(self, num): comp=lambda a,b:1 if a+b&gt;b+a else -1 if a+b&lt;b+a else 0 num=map(str,num) num.sort(cmp=comp,reverse=True) return str(int(&quot;&quot;.join(num))) UPDATE More explanation 1-we define a function that compares two string (a,b) . we consider a bigger than b if a+b&gt;b+afor example : (a=â€2â€,b=â€11â€) a is bigger than b because â€œ211â€ &gt;â€112â€ 2-convert all elements of the list from int to string 3-sort the list descendingly using the comparing function we definedfor example sorting this list [â€œ2â€,â€11â€,â€13â€] using the function defined in step 1 would produce [â€œ2â€,â€13â€,â€11â€] 4-we concatatenate the list â€œ21311â€ https://discuss.leetcode.com/topic/7235/my-3-lines-code-in-java-and-python My 3-lines code in Java and Python The logic is pretty straightforward. Just compare number by convert it to string. Thanks for Java 8, it makes code beautiful. Java: 1234567public class Solution &#123; public String largestNumber(int[] num) &#123; String[] array = Arrays.stream(num).mapToObj(String::valueOf).toArray(String[]::new); Arrays.sort(array, (String s1, String s2) -&gt; (s2 + s1).compareTo(s1 + s2)); return Arrays.stream(array).reduce((x, y) -&gt; x.equals(&quot;0&quot;) ? y : x + y).get(); &#125;&#125; Python: class Solution: 123456# @param num, a list of integers # @return a string def largestNumber(self, num): num = [str(x) for x in num] num.sort(cmp=lambda x, y: cmp(y+x, x+y)) return &apos;&apos;.join(num).lstrip(&apos;0&apos;) or &apos;0&apos; https://discuss.leetcode.com/topic/32442/share-my-fast-java-solution-beat-98-64 Share my fast JAVA solution, beat 98.64%! 1234567891011121314151617181920212223public class Solution &#123; public String largestNumber(int[] nums) &#123; if (nums == null || nums.length == 0) return &quot;&quot;; String[] strs = new String[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; strs[i] = nums[i]+&quot;&quot;; &#125; Arrays.sort(strs, new Comparator&lt;String&gt;() &#123; @Override public int compare(String i, String j) &#123; String s1 = i+j; String s2 = j+i; return s1.compareTo(s2); &#125; &#125;); if (strs[strs.length-1].charAt(0) == &apos;0&apos;) return &quot;0&quot;; String res = new String(); for (int i = 0; i &lt; strs.length; i++) &#123; res = strs[i]+res; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/8018/my-java-solution-to-share My Java Solution to share The idea here is basically implement a String comparator to decide which String should come first during concatenation. Because when you have 2 numbers (letâ€™s convert them into String), youâ€™ll face only 2 cases: 1234567For example:String s1 = &quot;9&quot;;String s2 = &quot;31&quot;;String case1 = s1 + s2; // 931String case2 = s2 + s1; // 319 Apparently, case1 is greater than case2 in terms of value.So, we should always put s1 in front of s2. I have received many good suggestions from you in this discussion. Below is the modified version of codes based on your suggestions: 123456789101112131415161718192021222324252627282930313233public class Solution &#123; public String largestNumber(int[] num) &#123; if(num == null || num.length == 0) return &quot;&quot;; // Convert int array to String array, so we can sort later on String[] s_num = new String[num.length]; for(int i = 0; i &lt; num.length; i++) s_num[i] = String.valueOf(num[i]); // Comparator to decide which string should come first in concatenation Comparator&lt;String&gt; comp = new Comparator&lt;String&gt;()&#123; @Override public int compare(String str1, String str2)&#123; String s1 = str1 + str2; String s2 = str2 + str1; return s2.compareTo(s1); // reverse order here, so we can do append() later &#125; &#125;; Arrays.sort(s_num, comp); // An extreme edge case by lc, say you have only a bunch of 0 in your int array if(s_num[0].charAt(0) == &apos;0&apos;) return &quot;0&quot;; StringBuilder sb = new StringBuilder(); for(String s: s_num) sb.append(s); return sb.toString(); &#125;&#125; In terms of Time and Space Complexity:Letâ€™s assume:the length of input array is n,average length of Strings in s_num is k,Then, compare 2 strings will take O(k).Sorting will take O(nlgn)Appending to StringBuilder takes O(n).So total will be O(nklgnk) + O(n) = O(nklgnk). Space is pretty straight forward: O(n).]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[174. Dungeon Game]]></title>
    <url>%2Fp%2F77abb633%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/dungeon-game/ The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0â€™s) or contain magic orbs that increase the knightâ€™s health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knightâ€™s minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN. header 1 header 2 header 3 -2(K) -3 3 -5 -10 1 10 30 -5(P) Notes: The knightâ€™s health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. https://discuss.leetcode.com/topic/6906/who-can-explain-why-from-the-bottom-right-corner-to-left-top Who can explain why â€œfrom the bottom right corner to left top.â€ Why we fill the table from the bottom right corner to left top? https://discuss.leetcode.com/topic/6912/c-dp-solution C++ DP solution ç¬¬ä¸€ç‚¹ï¼Œä»Žå³ä¸‹è§’å¼€å§‹æ€è€ƒï¼Œä»Žå³ä¸‹è§’å¼€å§‹æ€è€ƒã€‚ åŒæ—¶æ³¨æ„ï¼Œknightåœ¨è·¯é€”ä¸­é—´ä¸èƒ½æ²¡æœ‰è¡€ã€‚ Use hp[i][j] to store the min hp needed at position (i, j), then do the calculation from right-bottom to left-up. Note: adding dummy row and column would make the code cleaner. 12345678910111213141516171819class Solution &#123;public: int calculateMinimumHP(vector&lt;vector&lt;int&gt; &gt; &amp;dungeon) &#123; int M = dungeon.size(); int N = dungeon[0].size(); // hp[i][j] represents the min hp needed at position (i, j) // Add dummy row and column at bottom and right side vector&lt;vector&lt;int&gt; &gt; hp(M + 1, vector&lt;int&gt;(N + 1, INT_MAX)); hp[M][N - 1] = 1; hp[M - 1][N] = 1; for (int i = M - 1; i &gt;= 0; i--) &#123; for (int j = N - 1; j &gt;= 0; j--) &#123; int need = min(hp[i + 1][j], hp[i][j + 1]) - dungeon[i][j]; hp[i][j] = need &lt;= 0 ? 1 : need; &#125; &#125; return hp[0][0]; &#125;&#125;; https://discuss.leetcode.com/topic/6912/c-dp-solution/4 We could reduce the 2-D DP matrix into 1-D 123456789101112131415class Solution &#123;public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123; int n=dungeon.size(),m=dungeon[0].size(); vector&lt;int&gt; dp(n+1,INT_MAX); dp[n-1]=1; for(int j=m-1;j&gt;=0;j--)&#123; for(int i=n-1;i&gt;=0;i--)&#123; dp[i]=min(dp[i],dp[i+1])-dungeon[i][j]; dp[i]=max(1,dp[i]); &#125; &#125; return dp[0]; &#125;&#125;; https://discuss.leetcode.com/topic/7633/best-solution-i-have-found-with-explanations Best solution I have found with explanations http://leetcodesolution.blogspot.com/2015/01/leetcode-dungeon-game.html seems pretty simpleâ€¦ and easy to understand explanationsâ€¦ It is easy to know that at grid P, since â€œ at any point his health point drops to 0 or below, he dies immediatelyâ€, the remaining health value should be at least 1, that is, initialHealth + dungeon &gt;= 1, we have initialHealth = max(1, 1 - dungeon[i][j]). (Notice, at any grid, the initial health should be at least 1 (for example, test case [1,0,0] require initial health 1 even though it has positive remaining health at grid[0][1] and grid[0][2]) Similarly, to satisfy the initial health of dungeon[i][j], the initial health of dungeon[i-1][j] (or dungeon[i][j-1]) should be at least initialHealth[i-1][j] + dungeon[i-1][j] = initialHealth[i][j], that is, initialHealth[i][j] = initialHealth[i][j] - dungeon[i-1][j]. In addition, if grid[i][j] can go both grid[i+1][j] and grid[i][j+1] to P, we should choose a path with less initial health between grid[i+1][j] and grid[i][j+1] since it require less initial health of grid[i][j].We can simply code the solution by having the dynamic programming equations. 1234567891011121314151617181920212223242526272829int calculateMinimumHP(vector &amp;dungeon) &#123; int m = dungeon.size(); int n = dungeon[0].size(); vector minInitHealth(m, vector&lt;int&gt;(n,0)); for(int i=m-1; i&gt;=0; i--) &#123; for (int j=n-1; j&gt;=0; j--) &#123; if (i == m-1 &amp;&amp; j == n-1) &#123; minInitHealth[i][j] = max(1, 1 - dungeon[i][j]); &#125; else if (i == m-1) &#123; minInitHealth[i][j] = max(1, minInitHealth[i][j+1] - dungeon[i][j]); &#125; else if (j == n-1) &#123; minInitHealth[i][j] = max(1, minInitHealth[i+1][j] - dungeon[i][j]); &#125; else &#123; minInitHealth[i][j] = max(1, min(minInitHealth[i+1][j],minInitHealth[i][j+1]) - dungeon[i][j]); &#125; &#125; &#125; return minInitHealth[0][0];&#125; https://discuss.leetcode.com/topic/7024/sharing-my-solution-with-o-n-space-o-mn-runtime Sharing my solution with O(n) space, O(mn) runtime Here is my solution using dp and rolling array â€“Dungeon Game: 12345678910111213int calculateMinimumHP(vector&lt;vector&lt;int&gt; &gt; &amp;dungeon) &#123; const int m = dungeon.size(); const int n = dungeon[0].size(); vector&lt;int&gt; dp(n + 1, INT_MAX); dp[n - 1] = 1; for(int i = m - 1; i &gt;= 0; --i) for(int j = n - 1; j &gt;= 0; --j) dp[j] = getMin(min(dp[j], dp[j + 1]) - dungeon[i][j]); return dp[0];&#125;int getMin(int n)&#123; return n &lt;= 0 ? 1 : n;&#125; Note: Update from right to left and from bottom up. https://discuss.leetcode.com/topic/19304/6-lines-16-ms-c-o-mn-time-o-n-space 6 lines, 16 ms, C++, O(mn) Time, O(n) Space, 12345678910struct Solution &#123; int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; d) &#123; vector&lt;int&gt; dp(d.size() + 1, INT_MAX); dp[d.size() - 1] = 1; for (int i = d[0].size() - 1; i &gt;= 0; --i) for (int j = d.size() - 1; j &gt;= 0; --j) dp[j] = max(1, min(dp[j + 1], dp[j]) - d[j][i]); return dp[0]; &#125;&#125;; https://discuss.leetcode.com/topic/26511/a-12-ms-c-solution-dp A 12 ms C++ solution, DP This problem is quite like #64 Minimum Path Sum. The trick is where is the Starting point. This problem ask us to find the least hp in top-left. So in the most optimistic situation, bottom-right value can be determined as 1. Then bottom-right is the starting point. 12345678910111213141516171819int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dun) &#123; if (!dun.size() || !dun[0].size()) return 1; int nrow = dun.size(); int ncol = dun[0].size(); vector&lt;int&gt; row(ncol + 1, INT_MAX); row[ncol - 1] = 1; int i, j, t; for (i = nrow - 1; i &gt;= 0; --i) &#123; for (j = ncol - 1; j &gt;= 0; --j) &#123; t = min(row[j], row[j + 1]) - dun[i][j]; row[j] = max(t, 1); //row[j]=smaller value from below and right, but no smaller than 1. &#125; &#125; return row[0];&#125; https://discuss.leetcode.com/topic/19179/6-lines-python-8-lines-ruby 6 lines Python, 8 lines Ruby Just some DP. Python 1234567def calculateMinimumHP(self, dungeon): n = len(dungeon[0]) need = [2**31] * (n-1) + [1] for row in dungeon[::-1]: for j in range(n)[::-1]: need[j] = max(min(need[j:j+2]) - row[j], 1) return need[0] Got accepted in 52 ms, faster than all other recent Python submissions (best was 56 ms, achieved by 5.7692%).]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>binary search</tag>
        <tag>dynamic programming</tag>
        <tag>aaa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[173. Binary Search Tree Iterator]]></title>
    <url>%2Fp%2F85cdceee%2F</url>
    <content type="text"><![CDATA[39.9% https://leetcode.com/problems/binary-search-tree-iterator/#/description Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class BSTIterator &#123; stack&lt;TreeNode*&gt; mystack;public: BSTIterator(TreeNode *root) &#123; push_all(root); &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return !mystack.empty(); &#125; /** @return the next smallest number */ int next() &#123; TreeNode* cur = mystack.top(); mystack.pop(); // if(cur-&gt;right) push_all(cur-&gt;right); return cur-&gt;val; &#125;private: void push_all(TreeNode* node)&#123; for(;node!=NULL; node=node-&gt;left) mystack.push(node); &#125;&#125;;/** * Your BSTIterator will be called like this: * BSTIterator i = BSTIterator(root); * while (i.hasNext()) cout &lt;&lt; i.next(); */ https://discuss.leetcode.com/topic/6575/my-solutions-in-3-languages-with-stack My solutions in 3 languages with Stack I use Stack to store directed left children from root. When next() be called, I just pop one element and process its right child as new root. The code is pretty straightforward. So this can satisfy O(h) memory, hasNext() in O(1) time, But next() is O(h) time. I canâ€™t find a solution that can satisfy both next() in O(1) time, space in O(h). Java: 1234567891011121314151617181920212223public class BSTIterator &#123; private Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); public BSTIterator(TreeNode root) &#123; pushAll(root); &#125; /** @return whether we have a next smallest number */ public boolean hasNext() &#123; return !stack.isEmpty(); &#125; /** @return the next smallest number */ public int next() &#123; TreeNode tmpNode = stack.pop(); pushAll(tmpNode.right); return tmpNode.val; &#125; private void pushAll(TreeNode node) &#123; for (; node != null; stack.push(node), node = node.left); &#125;&#125; C++: 12345678910111213141516171819202122232425class BSTIterator &#123; stack&lt;TreeNode *&gt; myStack;public: BSTIterator(TreeNode *root) &#123; pushAll(root); &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return !myStack.empty(); &#125; /** @return the next smallest number */ int next() &#123; TreeNode *tmpNode = myStack.top(); myStack.pop(); pushAll(tmpNode-&gt;right); return tmpNode-&gt;val; &#125;private: void pushAll(TreeNode *node) &#123; for (; node != NULL; myStack.push(node), node = node-&gt;left); &#125;&#125;; Python: 1234567891011121314151617181920class BSTIterator: # @param root, a binary search tree&apos;s root node def __init__(self, root): self.stack = list() self.pushAll(root) # @return a boolean, whether we have a next smallest number def hasNext(self): return self.stack # @return an integer, the next smallest number def next(self): tmpNode = self.stack.pop() self.pushAll(tmpNode.right) return tmpNode.val def pushAll(self, node): while node is not None: self.stack.append(node) node = node.left https://discuss.leetcode.com/topic/12265/my-solution-in-c-in-average-o-1-time-and-uses-o-h-memory My Solution in C++, in average O(1) time and uses O(h) memory 123456789101112131415161718192021222324252627282930313233343536class BSTIterator &#123;private: stack&lt;TreeNode*&gt; st;public: BSTIterator(TreeNode *root) &#123; find_left(root); &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; if (st.empty()) return false; return true; &#125; /** @return the next smallest number */ int next() &#123; TreeNode* top = st.top(); st.pop(); if (top-&gt;right != NULL) find_left(top-&gt;right); return top-&gt;val; &#125; /** put all the left child() of root */ void find_left(TreeNode* root) &#123; TreeNode* p = root; while (p != NULL) &#123; st.push(p); p = p-&gt;left; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/8154/morris-traverse-solution Morris traverse solution Traverse a BST from the smallest to the largest, then i solve this question simply use the inorder traversal.To implement a iterator means we should traverse the tree step by step, so just split the inorder traversal. 12345678910111213141516171819202122232425262728293031323334353637383940414243class BSTIterator &#123;public:BSTIterator(TreeNode *root) &#123; p = root;&#125;/** @return whether we have a next smallest number */bool hasNext() &#123; return p != NULL;&#125;/** @return the next smallest number */int next() &#123; TreeNode *tmp; int ret; while(p) &#123; if (p-&gt;left == NULL) &#123; ret = p-&gt;val; p = p-&gt;right; break; &#125; else &#123; tmp = p-&gt;left; while (tmp-&gt;right != NULL &amp;&amp; tmp-&gt;right != p) tmp = tmp-&gt;right; if (tmp-&gt;right == NULL) &#123; tmp-&gt;right = p; p = p-&gt;left; &#125; else &#123; ret = p-&gt;val; tmp-&gt;right = NULL; p = p-&gt;right; break; &#125; &#125; &#125; return ret;&#125;TreeNode *p;&#125;; https://discuss.leetcode.com/topic/24617/c-using-stack C++. using stack. 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class BSTIterator &#123;private: TreeNode *current = NULL; stack&lt;TreeNode*&gt; s;public: BSTIterator(TreeNode *root) &#123; // initialize the current pointer current = root; &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; while(current)&#123; s.push(current); current = current-&gt;left; &#125; if(s.empty())&#123; return false; &#125; return true; &#125; /** @return the next smallest number */ int next() &#123; TreeNode* node = s.top(); s.pop(); current = node-&gt;right; return node-&gt;val; &#125;&#125;;/** * Your BSTIterator will be called like this: * BSTIterator i = BSTIterator(root); * while (i.hasNext()) cout &lt;&lt; i.next(); */ The basic idea behind this solution is that we have to implement inorder iteratively but it will gets split into two functions i.e. hasNext and next.hasNext() will push all the left elements and check and return accordingly if elements are in the stack.next() will just pop() the top element from the stack and update the current pointer to right .For this we are taking a stack and a current pointer.But maybe I may be wrong in hasNext as the requirement of question is O(1) for hasNext() as well. Open for comments. https://discuss.leetcode.com/topic/6629/two-python-solutions-stack-and-generator Two Python solutions, stack and generator stack solution: 123456789101112131415161718def __init__(self, root): self.stack = [] while root: self.stack.append(root) root = root.left# @return a boolean, whether we have a next smallest numberdef hasNext(self): return len(self.stack) &gt; 0# @return an integer, the next smallest numberdef next(self): node = self.stack.pop() x = node.right while x: self.stack.append(x) x = x.left return node.val generator solution: 123456789101112131415161718192021222324def __init__(self, root): self.last = root while self.last and self.last.right: self.last = self.last.right self.current = None self.g = self.iterate(root)# @return a boolean, whether we have a next smallest numberdef hasNext(self): return self.current is not self.last# @return an integer, the next smallest numberdef next(self): return next(self.g) def iterate(self, node): if node is None: return for x in self.iterate(node.left): yield x self.current = node yield node.val for x in self.iterate(node.right): yield x]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>stack</tag>
        <tag>tree</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[172. Factorial Trailing Zeroes]]></title>
    <url>%2Fp%2F75ca0b86%2F</url>
    <content type="text"><![CDATA[35.3% https://leetcode.com/problems/factorial-trailing-zeroes/#/description Given an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. 4ms, 19.42%, July 15th, 2016 https://discuss.leetcode.com/topic/6516/my-one-line-solutions-in-3-languages 123456class Solution &#123;public: int trailingZeroes(int n) &#123; return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5); &#125;&#125;; 60ms, 31.23%, July 15th, 2016 https://discuss.leetcode.com/topic/6516/my-one-line-solutions-in-3-languages 1234567class Solution(object): def trailingZeroes(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; return 0 if n == 0 else n / 5 + self.trailingZeroes(n / 5) 2ms, 3.36%, July 15th, 2016 https://discuss.leetcode.com/topic/6516/my-one-line-solutions-in-3-languages 12345public class Solution &#123; public int trailingZeroes(int n) &#123; return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[169. Majority Element]]></title>
    <url>%2Fp%2Ffc93121c%2F</url>
    <content type="text"><![CDATA[45.4% https://leetcode.com/problems/majority-element/description/ Given an array of size n, find the majority element. The majority element is the element that appears more than âŒŠ n/2 âŒ‹ times. You may assume that the array is non-empty and the majority element always exist in the array. æ–¹æ³•ä¸€ï¼š å‰‘æŒ‡offer 29 åŸºäºŽpartitionçš„è§£æ³• æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 18ï¼Œ 2017 123456789101112131415161718192021222324252627282930class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; if(n==1) return nums[0]; int l = 0, r = n-1; int pos = partition(nums, l, r); while(pos!=(n-1)/2)&#123; if(pos &gt; (n-1)/2)&#123; r = pos - 1; &#125;else&#123; l = pos + 1; &#125; pos = partition(nums, l, r); &#125; return nums[pos]; &#125; int partition(vector&lt;int&gt;&amp; nums, int l, int r)&#123; if(l&gt;=r) return l; int pos = l-1; for(int i=l; i&lt;r; i++) if(nums[i]&lt;nums[r]) swap(nums[i], nums[++pos]); swap(nums[++pos], nums[r]); return pos; &#125;&#125;; æˆ‘çš„å®žçŽ° 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return -1; int n = nums.size(); int mid = n/2; int left = 0, right = n-1; int index = partition(nums, left, right); while(index!=mid)&#123; if(index&lt;mid) left = index+1; else right = index-1; index = partition(nums, left, right); &#125; return nums[mid]; &#125; int partition(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if(left==right) return left; int pos = left-1; for(int i=left; i&lt;right; i++)&#123; if(nums[i]&lt;nums[right])&#123; swap(nums[i], nums[++pos]); &#125; &#125; swap(nums[++pos], nums[right]); return pos; &#125;&#125;; æ–¹æ³•äºŒï¼š æ ¹æ®æ•°ç»„ç‰¹ç‚¹æ‰¾å‡ºO(n)çš„è§£æ³• æˆ‘çš„å®žçŽ° æ ¹æ®cntæ˜¯å¦ä¸º0ï¼Œæ¥åˆ†å¼€ã€‚ cntä¸ä¸º0ï¼Œåˆ™å°±æ ¹æ®æ˜¯å¦åŒäºŽresæ¥è¿›è¡Œå¢žå‡cntã€‚ æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 18ï¼Œ 2017 123456789101112131415161718192021class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int n = nums.size(); if(n==1) return nums.back(); int res = nums[0], cnt = 1; for(int i=1; i&lt;n; i++)&#123; if(cnt==0)&#123; cnt = 1; res = nums[i]; &#125;else&#123; if(nums[i]==res) cnt++; else cnt--; &#125; &#125; return res; &#125;&#125;; 12345678910111213141516171819202122class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return nums[0]; int res; int cnt = 0; for(int i=0; i&lt;n; i++)&#123; if(cnt==0)&#123; res = nums[i]; cnt = 1; &#125;else&#123; if(res == nums[i])&#123; cnt++; &#125;else&#123; cnt--; &#125; &#125; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/8692/o-n-time-o-1-space-fastest-solution O(n) time O(1) space fastest solution ä½¿ç”¨ä¸€ä¸ªcntæ¥è¡¨ç¤ºä¸ªæ•°ï¼Œæ˜¯ä¸ªå¾ˆä¸é”™çš„é€‰æ‹©ï¼Œå½“ä¸€æ ·æ—¶å¢žåŠ ï¼Œ ä¸åŒæ—¶å‡å°‘ã€‚ 12345678910111213141516public class Solution &#123; public int majorityElement(int[] num) &#123; int major=num[0], count = 1; for(int i=1; i&lt;num.length;i++)&#123; if(count==0)&#123; count++; major=num[i]; &#125;else if(major==num[i])&#123; count++; &#125;else count--; &#125; return major; &#125;&#125; https://discuss.leetcode.com/topic/17446/6-suggested-solutions-in-c-with-explanations 6 Suggested Solutions in C++ with Explanations Well, if you have got this problem accepted, you may have noticed that there are 7 suggested solutions for this problem. The following passage will implement 6 of them except the O(n^2) brute force algorithm. Hash Table The hash-table solution is very straightforward. We maintain a mapping from each element to its number of appearances. While constructing the mapping, we update the majority element based on the max number of appearances we have seen. Notice that we do not need to construct the full mapping when we see that an element has appeared more than n / 2 times. The code is as follows, which should be self-explanatory. 12345678910class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; counts; int n = nums.size(); for (int i = 0; i &lt; n; i++) if (++counts[nums[i]] &gt; n / 2) return nums[i]; &#125;&#125;; Sorting Since the majority element appears more than n / 2 times, the n / 2-th element in the sorted nums must be the majority element. This can be proved intuitively. Note that the majority element will take more than n / 2 positions in the sorted nums (cover more than half of nums). If the first of it appears in the 0-th position, it will also appear in the n / 2-th position to cover more than half of nums. It is similar if the last of it appears in the n - 1-th position. These two cases are that the contiguous chunk of the majority element is to the leftmost and the rightmost in nums. For other cases (imagine the chunk moves between the left and the right end), it must also appear in the n / 2-th position. The code is as follows, being very short if we use the system nth_element (thanks for @qeatzy for pointing out such a nice function). 1234567class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end()); return nums[nums.size() / 2]; &#125; &#125;; Randomization This is a really nice idea and works pretty well (16ms running time on the OJ, almost fastest among the C++ solutions). The proof is already given in the suggested solutions. The code is as follows, randomly pick an element and see if it is the majority one. 12345678910111213141516class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); srand(unsigned(time(NULL))); while (true) &#123; int idx = rand() % n; int candidate = nums[idx]; int counts = 0; for (int i = 0; i &lt; n; i++) if (nums[i] == candidate) counts++; if (counts &gt; n / 2) return candidate; &#125; &#125;&#125;; Divide and Conquer This idea is very algorithmic. However, the implementation of it requires some careful thought about the base cases of the recursion. The base case is that when the array has only one element, then it is the majority one. This solution takes 24ms. 123456789101112131415class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; return majority(nums, 0, nums.size() - 1); &#125;private: int majority(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left == right) return nums[left]; int mid = left + ((right - left) &gt;&gt; 1); int lm = majority(nums, left, mid); int rm = majority(nums, mid + 1, right); if (lm == rm) return lm; return count(nums.begin() + left, nums.begin() + right + 1, lm) &gt; count(nums.begin() + left, nums.begin() + right + 1, rm) ? lm : rm; &#125;&#125;; Moore Voting Algorithm A brilliant and easy-to-implement algorithm! It also runs very fast, about 20ms. 1234567891011121314class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int major, counts = 0, n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; if (!counts) &#123; major = nums[i]; counts = 1; &#125; else counts += (nums[i] == major) ? 1 : -1; &#125; return major; &#125;&#125;; Bit Manipulation Another nice idea! The key lies in how to count the number of 1â€™s on a specific bit. Specifically, you need a mask with a 1 on the i-the bit and 0 otherwise to get the i-th bit of each element in nums. The code is as follows. 1234567891011121314151617class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int major = 0, n = nums.size(); for (int i = 0, mask = 1; i &lt; 32; i++, mask &lt;&lt;= 1) &#123; int bitCounts = 0; for (int j = 0; j &lt; n; j++) &#123; if (nums[j] &amp; mask) bitCounts++; if (bitCounts &gt; n / 2) &#123; major |= mask; break; &#125; &#125; &#125; return major; &#125; &#125;; https://discuss.leetcode.com/topic/28601/java-solutions-sorting-hashmap-moore-voting-bit-manipulation Java solutions (sorting, hashmap, moore voting, bit manipulation). 12345// Sortingpublic int majorityElement1(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length/2];&#125; 1234567891011121314151617// Hashtable public int majorityElement2(int[] nums) &#123; Map&lt;Integer, Integer&gt; myMap = new HashMap&lt;Integer, Integer&gt;(); //Hashtable&lt;Integer, Integer&gt; myMap = new Hashtable&lt;Integer, Integer&gt;(); int ret=0; for (int num: nums) &#123; if (!myMap.containsKey(num)) myMap.put(num, 1); else myMap.put(num, myMap.get(num)+1); if (myMap.get(num)&gt;nums.length/2) &#123; ret = num; break; &#125; &#125; return ret;&#125; 12345678910111213// Moore voting algorithmpublic int majorityElement3(int[] nums) &#123; int count=0, ret = 0; for (int num: nums) &#123; if (count==0) ret = num; if (num!=ret) count--; else count++; &#125; return ret;&#125; 1234567891011121314// Bit manipulation public int majorityElement(int[] nums) &#123; int[] bit = new int[32]; for (int num: nums) for (int i=0; i&lt;32; i++) if ((num&gt;&gt;(31-i) &amp; 1) == 1) bit[i]++; int ret=0; for (int i=0; i&lt;32; i++) &#123; bit[i]=bit[i]&gt;nums.length/2?1:0; ret += bit[i]*(1&lt;&lt;(31-i)); &#125; return ret;&#125; https://discuss.leetcode.com/topic/6251/c-solution-using-moore-s-voting-algorithm-o-n-runtime-comlexity-an-no-extra-array-or-hash-table C++ solution using Mooreâ€™s voting algorithm - O(n) runtime comlexity an no extra array or hash table This can be solved by Mooreâ€™s voting algorithm. Basic idea of the algorithm is if we cancel out each occurrence of an element e with all the other elements that are different from e then e will exist till end if it is a majority element. Below code loops through each element and maintains a count of the element that has the potential of being the majority element. If next element is same then increments the count, otherwise decrements the count. If the count reaches 0 then update the potential index to the current element and sets count to 1. 123456789101112int majorityElement(vector&lt;int&gt; &amp;num) &#123; int majorityIndex = 0; for (int count = 1, i = 1; i &lt; num.size(); i++) &#123; num[majorityIndex] == num[i] ? count++ : count--; if (count == 0) &#123; majorityIndex = i; count = 1; &#125; &#125; return num[majorityIndex];&#125; https://discuss.leetcode.com/topic/6286/share-my-solution-java-count-bits Share my solution [Java] - Count bits Definitely not the fastest solution but I post it here for your reference since itâ€™s different from the rest I saw. The problem reminded me of the approach I followed at Single Number II (problem 137). We can iterate over the bits of all numbers and for every position find out if ones outnumber the zeros (among all numbers). If this is the case, the corresponding bit of the ret variable (which holds the result) is set. We essentially â€œconstructâ€ the number we look for. The following code is simple and should be easy to understand. 1234567891011121314151617public int majorityElement(int[] num) &#123; int ret = 0; for (int i = 0; i &lt; 32; i++) &#123; int ones = 0, zeros = 0; for (int j = 0; j &lt; num.length; j++) &#123; if ((num[j] &amp; (1 &lt;&lt; i)) != 0) &#123; ++ones; &#125; else ++zeros; &#125; if (ones &gt; zeros) ret |= (1 &lt;&lt; i); &#125; return ret;&#125; https://discuss.leetcode.com/topic/7684/an-easy-way-to-solve-the-problem-24ms An easy way to solve the problem ( 24ms ) Every number in the vector votes for itself, the majority number gets the most votes. Different number offsets the votes. 1234567891011121314int majorityElement(vector&lt;int&gt; &amp;num) &#123; int vote = num[0]; int count = 1; int size = num.size(); //vote from the second number for( int i = 1; i &lt; size; i++ ) &#123; if( count == 0 ) &#123; vote = num[i]; count++; &#125; else if( vote == num[i] ) count++; else count--; &#125; return vote; &#125; https://discuss.leetcode.com/topic/6287/one-line-solution-in-python One line solution in Python NOTICE that the majority element always exist in the array,so that the middle always is the answer 1return sorted(num)[len(num)/2]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>divide and conquer</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[167. Two Sum II - Input array is sorted]]></title>
    <url>%2Fp%2F360afcfa%2F</url>
    <content type="text"><![CDATA[47.6% https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/ Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. 12Input: numbers=&#123;2, 7, 11, 15&#125;, target=9Output: index1=1, index2=2 æ–¹æ³•ä¸€ï¼š åŒæŒ‡é’ˆï¼Œä¸æ–­æ”¶ç¼©æŸ¥æ‰¾èŒƒå›´ï¼Œæ¥æ‰¾åˆ°å“åº”å…ƒç´ ã€‚ 12345678910111213class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int lo=0, hi=numbers.size()-1; while(numbers[lo]+numbers[hi] != target)&#123; if(numbers[lo]+numbers[hi]&lt;target) lo++; else hi--; &#125; return vector&lt;int&gt;(&#123;lo+1, hi+1&#125;); &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; vector&lt;int&gt; res; int left = 0, right = numbers.size()-1; while(left&lt;right)&#123; int sum = numbers[left] + numbers[right]; if(sum==target)&#123; res.push_back(left+1); res.push_back(right+1); return res; &#125;else if(sum&gt;target) right--; else left++; &#125; &#125;&#125;; 6ms, September 11, 2016 https://discuss.leetcode.com/topic/12660/a-simple-o-n-solution A simple O(n) solution We only have to shrink the range to find the pair: 12345678910111213class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int lo=0, hi=numbers.size()-1; while(numbers[lo]+numbers[hi] != target)&#123; if(numbers[lo]+numbers[hi]&lt;target) lo++; else hi--; &#125; return vector&lt;int&gt;(&#123;lo+1, hi+1&#125;); &#125;&#125;; https://discuss.leetcode.com/topic/7465/a-less-efficient-way-binary-search A less efficient way (binary search) I know that the best solution is using two pointers like what is done in the previous solution sharing. However, I see the tag contains â€œbinary searchâ€. I do not know if I misunderstand but is binary search a less efficient way for this problem. Say, fix the first element A[0] and do binary search on the remaining n-1 elements. If cannot find any element which equals target-A[0], Try A[1]. That is, fix A[1] and do binary search on A[2] ~ A[n-1]. Continue this process until we have the last two elements A[n-2] and A[n-1] . Does this gives a time complexity lg(n-1) + lg(n-2) + â€¦ + lg(1) ~ O(lg(n!)) ~ O(nlgn). So it is less efficient than the O(n) solution. Am I missing something here? The code also passes OJ. 123456789101112vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; if(numbers.empty()) return &#123;&#125;; for(int i=0; i&lt;numbers.size()-1; i++) &#123; int start=i+1, end=numbers.size()-1, gap=target-numbers[i]; while(start &lt;= end) &#123; int m = start+(end-start)/2; if(numbers[m] == gap) return &#123;i+1,m+1&#125;; else if(numbers[m] &gt; gap) end=m-1; else start=m+1; &#125; &#125;&#125; https://discuss.leetcode.com/topic/7465/a-less-efficient-way-binary-search/6 My idea is to use binary search to find the largest number less than target and then use two pointers. https://discuss.leetcode.com/topic/32373/c-solution-simple-and-sweet C++ solution simple and sweet 1234567891011121314151617vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int l = 0; int r = numbers.size() -1; while(l &lt; r)&#123; if(numbers[l] + numbers[r] == target)&#123; vector&lt;int&gt; res&#123;l+1,r+1&#125;; return res; &#125; else if(numbers[l] + numbers[r] &gt; target)&#123; r--; &#125; else&#123; l++; &#125; &#125; &#125; https://discuss.leetcode.com/topic/21800/python-different-solutions-two-pointer-dictionary-binary-search Python different solutions (two-pointer, dictionary, binary search). 1234567891011# two-pointerdef twoSum1(self, numbers, target): l, r = 0, len(numbers)-1 while l &lt; r: s = numbers[l] + numbers[r] if s == target: return [l+1, r+1] elif s &lt; target: l += 1 else: r -= 1 1234567# dictionary def twoSum2(self, numbers, target): dic = &#123;&#125; for i, num in enumerate(numbers): if target-num in dic: return [dic[target-num]+1, i+1] dic[num] = i 12345678910111213# binary search def twoSum(self, numbers, target): for i in xrange(len(numbers)): l, r = i+1, len(numbers)-1 tmp = target - numbers[i] while l &lt;= r: mid = l + (r-l)//2 if numbers[mid] == tmp: return [i+1, mid+1] elif numbers[mid] &lt; tmp: l = mid+1 else: r = mid-1 my code 38ms, 89.75%, Dec.1st, 201612345678910111213141516class Solution(object): def twoSum(self, numbers, target): &quot;&quot;&quot; :type numbers: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; if len(numbers) &lt; 2: return [] i, j = 0, len(numbers)-1 while i &lt; j: if numbers[i] + numbers[j] &gt; target: j -= 1 elif numbers[i] + numbers[j] &lt; target: i += 1 else: return [i+1, j+1] 1ms, September 11, 2016 https://discuss.leetcode.com/topic/39962/java-7-line-simple-solution 1234567891011public class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int start = 0, end = numbers.length - 1; while(start &lt; end)&#123; if(numbers[start] + numbers[end] == target) break; if(numbers[start] + numbers[end] &lt; target) start++; else end--; &#125; return new int[]&#123;start+1, end+1&#125;; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[166. Fraction to Recurring Decimal]]></title>
    <url>%2Fp%2Fdff0e65f%2F</url>
    <content type="text"><![CDATA[17.1% Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. 12345For example,Given numerator = 1, denominator = 2, return &quot;0.5&quot;.Given numerator = 2, denominator = 1, return &quot;2&quot;.Given numerator = 2, denominator = 3, return &quot;0.(6)&quot;. Hint: No scary math, just apply elementary math knowledge. Still remember how to perform a long division? Try a long division on 4/9, the repeating part is obvious. Now try 4/333. Do you see a pattern? Be wary of edge cases! List out as many test cases as you can think of and test your code thoroughly. æ–¹æ³•ä¸€ï¼š ä¸€ä¸ªåŸºæœ¬ç»éªŒæ˜¯ï¼Œå¦‚æžœæ•°å­—ç‰¹åˆ«é•¿ï¼Œä¸€å®šè¦è½¬æˆlong long æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122232425262728class Solution &#123;public: string fractionToDecimal(int numerator, int denominator) &#123; string res; if(numerator==0 || denominator==0) return to_string(0); if(numerator&lt;0&amp;&amp; denominator&gt;0 || numerator&gt;0&amp;&amp;denominator&lt;0) res = res + "-"; // ä¸€ä¸ªåŸºæœ¬ç»éªŒæ˜¯ï¼Œå¦‚æžœé‡åˆ°æ•°å­—å¯èƒ½ä¼šå‡ºçŽ°ç‰¹åˆ«é•¿çš„ï¼Œä¸€å®šè¦ç”¨long long long long nu = abs((long long)numerator); long long de = abs((long long)denominator); res += to_string(nu/de); if(nu%de==0) return res; res += "."; unordered_map&lt;int, int&gt; map; for(nu %= de; nu;nu %= de)&#123; if(map.find(nu)!=map.end())&#123; res.insert(map[nu], "("); res += ")"; break; &#125; map[nu] = res.size(); nu *= 10; res += to_string(nu/de); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/6079/accepted-cpp-solution-with-explainations Accepted cpp solution, with explainations 123456789101112131415161718192021222324252627282930313233343536373839404142434445// upgraded parameter typesstring fractionToDecimal(int64_t n, int64_t d) &#123; // zero numerator if (n == 0) return &quot;0&quot;; string res; // determine the sign if (n &lt; 0 ^ d &lt; 0) res += &apos;-&apos;; // remove sign of operands n = abs(n), d = abs(d); // append integral part res += to_string(n / d); // in case no fractional part if (n % d == 0) return res; res += &apos;.&apos;; unordered_map&lt;int, int&gt; map; // simulate the division process for (int64_t r = n % d; r; r %= d) &#123; // meet a known remainder // so we reach the end of the repeating part if (map.count(r) &gt; 0) &#123; res.insert(map[r], 1, &apos;(&apos;); res += &apos;)&apos;; break; &#125; // the remainder is first seen // remember the current position for it map[r] = res.size(); r *= 10; // append the quotient digit res += to_string(r / d); &#125; return res;&#125; https://discuss.leetcode.com/topic/17071/0ms-c-solution-with-detailed-explanations 0ms C++ Solution with Detailed Explanations Well, the key to this problem is on how to identify the recurring parts. After doing some examples using pen and paper, you may find that for the decimal parts to recur, the remainders should recur. So we need to maintain the remainders we have seen. Once we see a repeated remainder, we know that we have reached the end of the recurring parts and should enclose it with a ). However, we still need to insert the ( to the correct position. So we maintain a mapping from each remainder to the position of the corresponding quotient digit of it in the recurring parts. Then we use this mapping to retrieve the starting position of the recurring parts. Now we have solved the trickiest part of this problem. There are some remaining problems to solve to achieve a bug-free solution. Pay attention to the sign of the result; Handle cases that may cause overflow like numerator = -2147483648, denominator = -1 appropriately by using long long; Handle all the cases of (1) no fractional part; (2) fractional part does not recur; and (3) fractional part recurs respectively. To handle problem 3, we divide the division process into the integral part and the fractional part. For the fractional part, if it does not recur, then the remainder will become 0 at some point and we could return. If it does recur, the method metioned in the first paragraph has already handled it. Taking all these into considerations, we have the following code, which takes 0 ms :-) 1234567891011121314151617181920212223242526272829class Solution &#123;public: string fractionToDecimal(int numerator, int denominator) &#123; if (!numerator) return &quot;0&quot;; string res; if (numerator &lt; 0 ^ denominator &lt; 0) res += &apos;-&apos;; long numer = numerator &lt; 0 ? (long)numerator * (-1) : (long)numerator; long denom = denominator &lt; 0 ? (long)denominator * (-1) : (long)denominator; long integral = numer / denom; res += to_string(integral); long rmd = numer % denom; if (!rmd) return res; res += &apos;.&apos;; rmd *= 10; unordered_map&lt;long, long&gt; mp; while (rmd) &#123; long quotient = rmd / denom; if (mp.find(rmd) != mp.end()) &#123; res.insert(mp[rmd], 1, &apos;(&apos;); res += &apos;)&apos;; break; &#125; mp[rmd] = res.size(); res += to_string(quotient); rmd = (rmd % denom) * 10; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/7699/do-not-use-python-as-cpp-here-s-a-short-version-python-code Do not use python as cpp, hereâ€™s a short version python code Though python is slow, It is easy to write 12345678910111213141516class Solution:# @return a stringdef fractionToDecimal(self, numerator, denominator): n, remainder = divmod(abs(numerator), abs(denominator)) sign = &apos;-&apos; if numerator*denominator &lt; 0 else &apos;&apos; result = [sign+str(n), &apos;.&apos;] stack = [] while remainder not in stack: stack.append(remainder) n, remainder = divmod(remainder*10, abs(denominator)) result.append(str(n)) idx = stack.index(remainder) result.insert(idx+2, &apos;(&apos;) result.append(&apos;)&apos;) return &apos;&apos;.join(result).replace(&apos;(0)&apos;, &apos;&apos;).rstrip(&apos;.&apos;) and thereâ€™s no overflow https://discuss.leetcode.com/topic/9778/python-solution Python solution 123456789101112131415161718192021222324252627class Solution:# @return a stringdef fractionToDecimal(self, numerator, denominator): res=&quot;&quot; if numerator/denominator&lt;0: res+=&quot;-&quot; elif numerator%denominator==0: return str(numerator/denominator) numerator=abs(numerator) denominator=abs(denominator) res+=str(numerator/denominator) res+=&quot;.&quot; numerator%=denominator i=len(res) table=&#123;&#125; while numerator!=0: if numerator not in table.keys(): table[numerator]=i else: i=table[numerator] res=res[:i]+&quot;(&quot;+res[i:]+&quot;)&quot; return res numerator=numerator*10 res+=str(numerator/denominator) numerator%=denominator i+=1 return res Idea is to put every remainder into the hash table as a key, and the current length of the result string as the value. When the same remainder shows again, itâ€™s circulating from the index of the value in the table.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>math</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[165. Compare Version Numbers]]></title>
    <url>%2Fp%2F74b375a4%2F</url>
    <content type="text"><![CDATA[20.1% https://leetcode.com/problems/compare-version-numbers/ Compare two version numbers version1 and version2.If version1 &gt; version2 return 1, if version1 &lt; version2 return -1, otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character.The . character does not represent a decimal point and is used to separate number sequences.For instance, 2.5 is not â€œtwo and a halfâ€ or â€œhalf way to version threeâ€, it is the fifth second-level revision of the second first-level revision. 123Here is an example of version numbers ordering:0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37 æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122class Solution &#123;public: int compareVersion(string version1, string version2) &#123; int i = 0, j = 0; int num1 = 0, num2 = 0; int n1 = version1.size(), n2 = version2.size(); while(i&lt;n1 || j&lt;n2)&#123; while(i&lt;n1 &amp;&amp; version1[i]!='.') num1 = num1*10 + version1[i++]-'0'; while(j&lt;n2 &amp;&amp; version2[j]!='.') num2 = num2*10 + version2[j++] - '0'; if(num1&gt;num2) return 1; else if(num1&lt;num2) return -1; num1 = 0; num2 = 0; i++; j++; &#125; return 0; &#125;&#125;; æŒ‰ç…§æœ€ç®€å•çš„é€»è¾‘åŽ»åšå°±è¡Œäº†ã€‚ 12345678910111213141516171819202122232425262728293031int compareVersion(string version1, string version2) &#123; int i = 0; int j = 0; int n1 = version1.size(); int n2 = version2.size(); int num1 = 0; int num2 = 0; while(i&lt;n1 || j&lt;n2) // æ­¤å¤„ç”¨ ||ï¼Œè€ƒè™‘1.0.1ä¸Ž1çš„æƒ…å†µ &#123; while(i&lt;n1 &amp;&amp; version1[i]!=&apos;.&apos;)&#123; num1 = num1*10+(version1[i]-&apos;0&apos;); i++; &#125; while(j&lt;n2 &amp;&amp; version2[j]!=&apos;.&apos;)&#123; num2 = num2*10+(version2[j]-&apos;0&apos;);; j++; &#125; if(num1&gt;num2) return 1; else if(num1 &lt; num2) return -1; num1 = 0; num2 = 0; i++; j++; &#125; return 0;&#125; cpphttps://discuss.leetcode.com/topic/11410/my-2ms-easy-solution-with-c-c 12345678910111213141516171819202122232425262728293031int compareVersion(string version1, string version2) &#123; int i = 0; int j = 0; int n1 = version1.size(); int n2 = version2.size(); int num1 = 0; int num2 = 0; while(i&lt;n1 || j&lt;n2) &#123; while(i&lt;n1 &amp;&amp; version1[i]!=&apos;.&apos;)&#123; num1 = num1*10+(version1[i]-&apos;0&apos;); i++; &#125; while(j&lt;n2 &amp;&amp; version2[j]!=&apos;.&apos;)&#123; num2 = num2*10+(version2[j]-&apos;0&apos;);; j++; &#125; if(num1&gt;num2) return 1; else if(num1 &lt; num2) return -1; num1 = 0; num2 = 0; i++; j++; &#125; return 0;&#125; https://discuss.leetcode.com/topic/6266/my-solutions-in-3-languages123456789101112131415161718192021class Solution &#123;public: int compareVersion(string version1, string version2) &#123; for (; version1 != version2; version1 = nextSubstr(version1), version2 = nextSubstr(version2)) &#123; int gap = stoi(version1) - stoi(version2); if (gap != 0) &#123; return gap &gt; 0 ? 1 : -1; &#125; &#125; return 0; &#125; string nextSubstr(string str) &#123; for (int i = 0; i &lt; str.size(); i++) &#123; if (str.at(i) == &apos;.&apos;) &#123; return str.substr(i + 1); &#125; &#125; return &quot;0&quot;; &#125;&#125;; https://discuss.leetcode.com/topic/8257/10-line-concise-solution-c This is a concise solution using stringstream to format string into int. 12345678910111213int compareVersion(string version1, string version2) &#123; for(auto&amp; w : version1) if (w == &apos;.&apos;) w=&apos; &apos;; for(auto&amp; w : version2) if (w == &apos;.&apos;) w=&apos; &apos;; istringstream s1(version1), s2(version2); while(1) &#123; int n1,n2; if (not(s1 &gt;&gt; n1) ) n1 = 0; if (not(s2 &gt;&gt; n2) ) n2 = 0; if (not s1 and not s2) return 0; if (n1&lt;n2) return -1; if (n1&gt;n2) return 1; &#125;&#125; pythonhttps://discuss.leetcode.com/topic/6266/my-solutions-in-3-languages1234567891011121314class Solution(object): def compareVersion(self, version1, version2): &quot;&quot;&quot; :type version1: str :type version2: str :rtype: int &quot;&quot;&quot; v1 = version1.split(&apos;.&apos;) v2 = version2.split(&apos;.&apos;) for i in range(max(len(v1), len(v2))): gap = (int(v1[i]) if i &lt; len(v1) else 0) - (int(v2[i]) if i &lt; len(v2) else 0) if gap != 0: return 1 if gap &gt; 0 else -1 return 0 https://discuss.leetcode.com/topic/18543/2-4-lines-python-3-different-ways Solution 1: Pad with izip_longest with fillvalue=0 123def compareVersion(self, version1, version2): splits = (map(int, v.split(&apos;.&apos;)) for v in (version1, version2)) return cmp(*zip(*itertools.izip_longest(*splits, fillvalue=0))) Solution 2: Pad with [0] * lengthDifference 1234def compareVersion(self, version1, version2): v1, v2 = (map(int, v.split(&apos;.&apos;)) for v in (version1, version2)) d = len(v2) - len(v1) return cmp(v1 + [0]*d, v2 + [0]*-d) Solution 3: Recursive, add zeros on the fly 12345def compareVersion(self, version1, version2): main1, _, rest1 = (&apos;0&apos; + version1).partition(&apos;.&apos;) main2, _, rest2 = (&apos;0&apos; + version2).partition(&apos;.&apos;) return cmp(int(main1), int(main2)) or \ len(rest1+rest2) and self.compareVersion(rest1, rest2) javahttps://discuss.leetcode.com/topic/6238/accepted-small-java-solution This code assumes that next level is zero if no mo levels in shorter version number. And than compare levels. 12345678910111213141516public int compareVersion(String version1, String version2) &#123; String[] levels1 = version1.split(&quot;\\.&quot;); String[] levels2 = version2.split(&quot;\\.&quot;); int length = Math.max(levels1.length, levels2.length); for (int i=0; i&lt;length; i++) &#123; Integer v1 = i &lt; levels1.length ? Integer.parseInt(levels1[i]) : 0; Integer v2 = i &lt; levels2.length ? Integer.parseInt(levels2[i]) : 0; int compare = v1.compareTo(v2); if (compare != 0) &#123; return compare; &#125; &#125; return 0;&#125; https://discuss.leetcode.com/topic/6266/my-solutions-in-3-languages123456789101112public class Solution &#123; public int compareVersion(String version1, String version2) &#123; String[] v1 = version1.split(&quot;\\.&quot;); String[] v2 = version2.split(&quot;\\.&quot;); for(int i=0; i&lt;Math.max(v1.length, v2.length); i++)&#123; int gap = (i &lt; v1.length ? Integer.parseInt(v1[i]) : 0) - (i &lt; v2.length ? Integer.parseInt(v2[i]) : 0); if(gap != 0) return gap &gt; 0 ? 1 : -1; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[164. Maximum Gap]]></title>
    <url>%2Fp%2F304b41e7%2F</url>
    <content type="text"><![CDATA[28.9% https://leetcode.com/problems/maximum-gap/?tab=Description Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Try to solve it in linear time/space. Return 0 if the array contains less than 2 elements. You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. æ–¹æ³•ä¸€: ç±»ä¼¼äºŽåŒæŽ’åº æŠ½å±‰åŽŸåˆ™ https://discuss.leetcode.com/topic/13172/pigeon-hole-principle Pigeon hole principle Suppose you have n pigeons with labels and you put them into m holes based on their label with each hole of the same size. Why bother putting pigeons into holes? Because you want to disregard the distance between pigeons within each one hole. Only when at least one hole is empty can we disregard the distance between pigeons within each one hole and compute the maximum gap solely by the distance between pigeons in adjacent holes. We make sure that at least one hole is empty by using m=n-1 (i.e. n-2 pigeons in n-1 holes =&gt; at least one hole is empty). 123456789101112131415161718192021int maximumGap(vector&lt;int&gt;&amp; nums) &#123; const int n = nums.size(); if(n&lt;=1) return 0; int maxE = *max_element(nums.begin(),nums.end()); int minE = *min_element(nums.begin(),nums.end()); double len = double(maxE-minE)/double(n-1); vector&lt;int&gt; maxA(n,INT_MIN); vector&lt;int&gt; minA(n,INT_MAX); for(int i=0; i&lt;n; i++) &#123; int index = (nums[i]-minE)/len; maxA[index] = max(maxA[index],nums[i]); minA[index] = min(minA[index],nums[i]); &#125; int gap = 0, prev = maxA[0]; for(int i=1; i&lt;n; i++) &#123; if(minA[i]==INT_MAX) continue; gap = max(gap,minA[i]-prev); prev = maxA[i]; &#125; return gap; &#125; https://discuss.leetcode.com/topic/13172/pigeon-hole-principle/2 Great idea, get the essence of the problem. Iâ€™ll add some more explanations. We divide the range of array into array.size() interval, where k = (maximum-minimum) / n. [minimum, minimum + k), [minimum + k, minimum + 2k), â€¦ , [minimum + (n-1)k, maximum] And we uses two extra array â€œmax_in_intervalâ€ and â€œmin_in_intervalâ€ to record the maximum and minimum of each interval. First, letâ€™s considering an uniformly distributed array of n numbers. By which I mean, [minimum, minimum + k), [minimum + k, minimum + 2k), â€¦ , [minimum + (n-1)k, maximum] n intervals each contains a single number. we could easily find the maximum gap by calculate min_in_interval[i+1] - max_in_interval[i] Now comes the most important observation. If any single interval contains more than 1 number, then there must be an empty interval, and maximum gap is larger than a single interval. By which I mean if multiple numbers appear in the same interval, we can safely ignore the numbers which lies in the middle of interval(not max_in_interval nor min_in_interval). Below comes my 16ms C++ AC solution. This is a minor defeact in it, but the test case does not catch it. I uses INT_MAX as a sentinel which should fails if the input array contains it as an element. 12345678910111213141516171819202122232425262728293031323334353637383940int maximumGap(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) return 0; int max = *max_element(nums.begin(), nums.end()); int min = *min_element(nums.begin(), nums.end()); double interval_length = double(max - min) / nums.size(); vector&lt;int&gt; max_in_interval(nums.size(), INT_MIN); vector&lt;int&gt; min_in_interval(nums.size(), INT_MAX); for (auto &amp;&amp;each : nums) &#123; size_t index = (each - min) / interval_length; // auto ceiling if (index == nums.size()) &#123; // in considering of float-point number round up index = nums.size() - 1; &#125; if (max_in_interval[index] &lt; each) &#123; max_in_interval[index] = each; &#125; if (min_in_interval[index] &gt; each) &#123; min_in_interval[index] = each; &#125; &#125; int gap = 0; int max_in_previous_interval = max_in_interval[0]; for (size_t i = 0; i &lt; nums.size() - 1; ++i) &#123; if (min_in_interval[i + 1] == INT_MAX) &#123; // skip the empty interval continue; &#125; else &#123; if (gap &lt; min_in_interval[i + 1] - max_in_previous_interval) &#123; gap = min_in_interval[i + 1] - max_in_previous_interval; &#125; max_in_previous_interval = max_in_interval[i + 1]; &#125; &#125; return gap;&#125; https://discuss.leetcode.com/topic/9986/my-c-code-12-ms-bucket-sort-o-n-time-and-space My C++ code (12 ms, â€œbucket sortâ€, O(n) time and space) The key is to use the fact that the lower bound of the gap is (maxV - minV )/ (sSize - 1). With such in mind, we can put all the num elements into different bucket with size (maxV - minV )/ (sSize - 1) (please note when such size is less than 1, then use 1 instead) and in such way, we only need to consider the min and max of each bucket and donâ€™t need to worry the numbers in between of each bucket since the gaps among those elements are smaller than the bucket size, and then the lower bound of the gap, so they can not achieve the max gap. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: int maximumGap(vector&lt;int&gt; &amp;num) &#123; int sSize = num.size(); int i, res =0; int minV, maxV; int bucket_size, bucket_num, bucket_id; int maxGap = INT_MIN; int last_max; if(sSize&gt;1) &#123; minV = maxV = num[0]; for(i=1; i&lt;sSize; i++) &#123; if(minV &gt; num[i]) minV = num[i]; else if(maxV &lt; num[i]) maxV = num[i]; &#125; bucket_size = max(1, (maxV - minV )/ (sSize - 1))); bucket_num = (maxV - minV)/bucket_size + 1; if(bucket_num &lt;=1) return (maxV - minV); vector&lt;int&gt; bucket_max(bucket_num, INT_MIN); vector&lt;int&gt; bucket_min(bucket_num, INT_MAX); vector&lt;int&gt; bucket_count(bucket_num, 0); for(i=0; i&lt;sSize; i++) &#123; bucket_id = (num[i] - minV)/bucket_size; bucket_count[bucket_id]++; bucket_min[bucket_id] = bucket_min[bucket_id] &gt; num[i]? num[i]:bucket_min[bucket_id]; bucket_max[bucket_id] = bucket_max[bucket_id] &lt; num[i]? num[i]:bucket_max[bucket_id]; &#125; last_max = minV; for(i=0; i&lt;bucket_num; i++) &#123; if(bucket_count[i]&gt;0) &#123; maxGap = max(maxGap, bucket_min[i]- last_max); last_max = bucket_max[i]; &#125; &#125; return maxGap; &#125; return 0; &#125;&#125;; https://discuss.leetcode.com/topic/5996/i-solved-it-using-radix-sort I solved it using radix sort Since linear time and space is required and all nums are non-negative, radix sort seems to be fit.Here is the implementation. Any better ideas? 1234567891011121314151617181920212223242526class Solution: # @param num, a list of integer # @return an integer def maximumGap(self, num): if len(num) &lt; 2: return 0 num = self.radixSort(num) res = 0 for i in range(1, len(num)): res = max(num[i] - num[i - 1], res) return res def radixSort(self, num): for i in range(31): onebucket = [] zerobucket = [] needle = 1 &lt;&lt; i for j in range(len(num)): if num[j] &amp; needle != 0: onebucket.append(num[j]) else: zerobucket.append(num[j]) num = [] num += zerobucket num += onebucket return num https://discuss.leetcode.com/topic/41228/beat-99-81-java-coder Beat 99.81% java coder 12345678910111213141516171819202122232425262728public int maximumGap(int[] nums) &#123; int n = nums.length; if(n &lt; 2) return 0; int min = nums[0]; int max = nums[0]; for(int i = 1;i &lt; n;i++)&#123; if(min &gt; nums[i]) min = nums[i]; if(max &lt; nums[i]) max = nums[i]; &#125; int gap = (max-min)/(n-1); if(gap == 0) gap++; int len = (max-min)/gap+1; int [] tmax = new int [len]; int [] tmin = new int [len]; for(int i = 0;i &lt; n;i++)&#123; int index = (nums[i]-min)/gap; if(nums[i] &gt; tmax[index]) tmax[index] = nums[i]; if(tmin[index] == 0 || nums[i] &lt; tmin[index]) tmin[index] = nums[i]; &#125; int myMax = 0; for(int i = 0;i &lt; len;i++)&#123; if(myMax &lt; tmin[i]-min) myMax = tmin[i]-min; if(tmax[i] != 0) min = tmax[i]; &#125; return myMax;&#125; https://discuss.leetcode.com/topic/21003/12ms-c-suggested-solution 12ms C++ Suggested Solution This problem has a naive solution using sort and linear scan. The suggested solution uses the idea of bucket sort. The following is a C++ implementation of the suggested solution. Suppose all the n elements in nums fall within [l, u], the maximum gap will not be smaller than gap = (u - l) / (n - 1). However, this gap may become 0 and so we take the maximum of it with 1 to guarantee that the gap used to create the buckets is meaningful. Then there will be at most m = (u - l) / gap + 1 buckets. For each number num, it will fall in the k = (num - l) / gap bucket. After putting all elements of nums in the corresponding buckets, we can just scan the buckets to compute the maximum gap. The maximum gap is only dependent on the maximum number of the current bucket and the minimum number of the next neighboring bucket (the bucket should not be empty). So we only store the minimum and the maximum of each bucket. Each bucket is initialized as {minimum = INT_MAX, maximum = INT_MIN} and then updated while updating the buckets. Putting these together, we can have the following solution, barely a straight-forward implementation of the suggested solution. 1234567891011121314151617181920212223242526272829class Solution &#123;public: int maximumGap(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt; 2) return 0; auto lu = minmax_element(nums.begin(), nums.end()); int l = *lu.first, u = *lu.second; int gap = max((u - l) / (n - 1), 1); int m = (u - l) / gap + 1; vector&lt;int&gt; bucketsMin(m, INT_MAX); vector&lt;int&gt; bucketsMax(m, INT_MIN); for (int num : nums) &#123; int k = (num - l) / gap; if (num &lt; bucketsMin[k]) bucketsMin[k] = num; if (num &gt; bucketsMax[k]) bucketsMax[k] = num; &#125; int i = 0, j; gap = bucketsMax[0] - bucketsMin[0]; while (i &lt; m) &#123; j = i + 1; while (j &lt; m &amp;&amp; bucketsMin[j] == INT_MAX &amp;&amp; bucketsMax[j] == INT_MIN) j++; if (j == m) break; gap = max(gap, bucketsMin[j] - bucketsMax[i]); i = j; &#125; return gap; &#125;&#125;; https://discuss.leetcode.com/topic/34414/clean-c-implementation-of-3-linear-time-sort-alg-with-detailed-explaination Clean C++ implementation of 3 linear-time-sort-alg with detailed explaination As we can see, we should grasp all the 3 typical linear-time-sorting algorithm implementation.All the following 3 implementations have been modified from the GeeksForGeeks.I have change the counting sort implementation to support negative numbers.And the bucket support any float array input. counting sort [ stable ] [ support:+/- intergers ] radix sort [ use counting sort as sub-routine] [ support onlypositive intergers] bucket sort [support float : we need to change the array to in therange [0, 1) ] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* counting sort Time O(N) Space O(N+range) *//* support : positive / negative arrays the last travese the array X : FORWARD-&gt;not stable BACKWARD-&gt;stable*/void countingSort(vector&lt;int&gt;&amp; X)&#123; int len = X.size(); int start = INT_MAX, end = INT_MIN; for (int i = 0; i &lt; len; i++)&#123; start = min(start, X[i]); end = max(end, X[i]); &#125; int range = end - start + 1; vector&lt;int&gt; count(range, 0); vector&lt;int&gt; result(len, 0); for (int i = 0; i &lt; len; i++)&#123; count[X[i]-start]++; &#125; for (int i = 1; i &lt; range; i++)&#123; count[i]=count[i-1]+count[i]; &#125; //for-ward traverse is not stable sorting //for (int i = 0; i &lt; len; i++) //back-ward traverse is stable sorting for (int i = len-1; i &gt;= 0; i--)&#123; //as we know that the count array recorded element should &apos;-1&apos; to get the index result[count[X[i] - start]-1] = X[i]; count[X[i] - start]--; &#125; for (int i = 0; i &lt; len; i++)&#123; X[i] = result[i]; &#125;&#125;/* Radix sort Time O(log(base,MAX)*(N+base)) Space O(constant) default:base=10 *//* support : only positive interger can only deal with positive integers or change the float number of the specified precision to intergers by multiplying 10^n */void countingSort(vector&lt;int&gt;&amp; X, int exp, int base)&#123; int len = X.size(); int start = INT_MAX, end = INT_MIN; for (int i = 0; i &lt; len; i++)&#123; start = min(start, (X[i] / exp)%base); end = max(end, (X[i] / exp) % base); &#125; int range = end - start + 1; vector&lt;int&gt; count(range, 0); vector&lt;int&gt; result(len, 0); for (int i = 0; i &lt; len; i++)&#123; count[(X[i] / exp) % base -start]++; &#125; for (int i = 1; i &lt; range; i++)&#123; count[i] = count[i - 1] + count[i]; &#125; //back-ward traverse is stable sorting for (int i = len - 1; i &gt;= 0; i--)&#123; //as we know that the count array recorded element should &apos;-1&apos; to get the index result[count[(X[i] / exp) % base -start] - 1] = X[i]; count[(X[i] / exp) % base - start]--; &#125; for (int i = 0; i &lt; len; i++)&#123; X[i] = result[i]; &#125;&#125;void radixSort(vector&lt;int&gt; &amp;X)&#123; int len = X.size(); int max_val = INT_MIN; int base = 10; for (int i = 0; i &lt; len; i++) max_val = max(X[i], max_val); for (int exp = 1; max_val / exp&gt;0; exp *= base)&#123; countingSort(X, exp, base); &#125;&#125;/* bubble sort Time Space *//* support : any float &amp; int numbers sort a large set of floating nubmers in range from 0.0 to 1.0 uniformly distributed across the range the key idea is : the insertion sort for all individual bucket is O(N)*/void bucketSort(vector&lt;float&gt;&amp; X)&#123; int len = X.size(); float max_val = X[0], min_val = X[0];; for (int i = 1; i &lt; len; i++) &#123; max_val = max(max_val, X[i]); min_val = min(min_val, X[i]); &#125; max_val++; vector&lt;vector&lt;float&gt;&gt; bucket(len, vector&lt;float&gt;()); for (int i = 0; i &lt; len; i++)&#123; int index = len*(X[i]-min_val)/(max_val-min_val); bucket[index].push_back(X[i]); &#125; for (int i = 0; i &lt; len; i++) sort(bucket[i].begin(), bucket[i].end()); int index = 0; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; bucket[i].size(); j++) X[index++] = bucket[i][j];&#125;/* test all the 3-linear-sorting-implementation */int main()&#123; vector&lt;int&gt; test1 = &#123; 11, -200, 14, -2000, 30, 400, 10, 22, 456 &#125;; countingSort(test1); cout &lt;&lt; endl&lt;&lt;&quot;counting Sort result: &quot;; for (int i = 0; i &lt; test1.size(); i++) cout &lt;&lt; test1[i] &lt;&lt;&quot; - &quot;; vector&lt;int&gt; test2 = &#123; 11, 200, 14, 2000, 30, 400, 10, 22, 456 &#125;; radixSort(test2); cout &lt;&lt; endl &lt;&lt; &quot;radix Sort result: &quot;; for (int i = 0; i &lt; test2.size(); i++) cout &lt;&lt; test2[i] &lt;&lt; &quot; - &quot;; vector&lt;float&gt; test3 = &#123; 11, -200, 14, -2000, 30, 400, 10, 22, 456 &#125;; bucketSort(test3); cout &lt;&lt; endl &lt;&lt; &quot;bucket Sort result: &quot;; for (int i = 0; i &lt; test3.size(); i++) cout &lt;&lt; test3[i] &lt;&lt; &quot; - &quot;; return 0;&#125; https://discuss.leetcode.com/topic/14353/my-concise-and-short-c-code-with-comment-explanation My concise and short c++ code with comment explanation 123456789101112131415161718192021222324252627int maximumGap(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if( n &lt; 2 ) return 0; int maxE = *max_element(nums.begin(),nums.end()); int minE = *min_element(nums.begin(),nums.end()); int len = maxE - minE; if( len &lt;= 1 ) return len; vector&lt;int&gt; buck_max(n, INT_MIN); vector&lt;int&gt; buck_min(n, INT_MAX); for(int i = 0; i &lt; n; i++) &#123; // note the divide and multiply order and the double cast // it&apos;s used to avoid the overflow and underflow during calculation int index = (double)( nums[i] - minE ) / len * ( n - 1 ); buck_max[index] = max(buck_max[index], nums[i]); buck_min[index] = min(buck_min[index], nums[i]); &#125; int gap = 0, pre = buck_max[0]; for(int i = 1; i &lt; n; i++) &#123; if( buck_max[i] == INT_MIN ) continue; gap = max(gap, buck_min[i] - pre); pre = buck_max[i]; &#125; return gap;&#125; https://discuss.leetcode.com/topic/5999/bucket-sort-java-solution-with-explanation-o-n-time-and-space [bucket sort] JAVA solution with explanation, O(N) time and space Suppose there are N elements in the array, the min value is min and the max value is max. Then the maximum gap will be no smaller than ceiling[(max - min ) / (N - 1)]. Let gap = ceiling[(max - min ) / (N - 1)]. We divide all numbers in the array into n-1 buckets, where k-th bucket contains all numbers in [min + (k-1)gap, min + k*gap). Since there are n-2 numbers that are not equal min or max and there are n-1 buckets, at least one of the buckets are empty. We only need to store the largest number and the smallest number in each bucket. After we put all the numbers into the buckets. We can scan the buckets sequentially and get the max gap.my blog for this problem 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public int maximumGap(int[] num) &#123; if (num == null || num.length &lt; 2) return 0; // get the max and min value of the array int min = num[0]; int max = num[0]; for (int i:num) &#123; min = Math.min(min, i); max = Math.max(max, i); &#125; // the minimum possibale gap, ceiling of the integer division int gap = (int)Math.ceil((double)(max - min)/(num.length - 1)); int[] bucketsMIN = new int[num.length - 1]; // store the min value in that bucket int[] bucketsMAX = new int[num.length - 1]; // store the max value in that bucket Arrays.fill(bucketsMIN, Integer.MAX_VALUE); Arrays.fill(bucketsMAX, Integer.MIN_VALUE); // put numbers into buckets for (int i:num) &#123; if (i == min || i == max) continue; int idx = (i - min) / gap; // index of the right position in the buckets bucketsMIN[idx] = Math.min(i, bucketsMIN[idx]); bucketsMAX[idx] = Math.max(i, bucketsMAX[idx]); &#125; // scan the buckets for the max gap int maxGap = Integer.MIN_VALUE; int previous = min; for (int i = 0; i &lt; num.length - 1; i++) &#123; if (bucketsMIN[i] == Integer.MAX_VALUE &amp;&amp; bucketsMAX[i] == Integer.MIN_VALUE) // empty bucket continue; // min value minus the previous value is the current gap maxGap = Math.max(maxGap, bucketsMIN[i] - previous); // update previous bucket value previous = bucketsMAX[i]; &#125; maxGap = Math.max(maxGap, max - previous); // updata the final max value gap return maxGap; &#125;&#125; https://discuss.leetcode.com/topic/22221/radix-sort-solution-in-java-with-explanation Radix sort solution in Java with explanation You can look at radix sort visualization here before reading the code: https://www.cs.usfca.edu/~galles/visualization/RadixSort.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123;public int maximumGap(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return 0; &#125; // m is the maximal number in nums int m = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; m = Math.max(m, nums[i]); &#125; int exp = 1; // 1, 10, 100, 1000 ... int R = 10; // 10 digits int[] aux = new int[nums.length]; while (m / exp &gt; 0) &#123; // Go through all digits from LSB to MSB int[] count = new int[R]; for (int i = 0; i &lt; nums.length; i++) &#123; count[(nums[i] / exp) % 10]++; &#125; for (int i = 1; i &lt; count.length; i++) &#123; count[i] += count[i - 1]; &#125; for (int i = nums.length - 1; i &gt;= 0; i--) &#123; aux[--count[(nums[i] / exp) % 10]] = nums[i]; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; nums[i] = aux[i]; &#125; exp *= 10; &#125; int max = 0; for (int i = 1; i &lt; aux.length; i++) &#123; max = Math.max(max, aux[i] - aux[i - 1]); &#125; return max;&#125;&#125; The first step is to find the maximum value in nums array, it will be the threshold to end while loop. Then use the radix sort algorithm to sort based on each digit from Least Significant Bit (LSB) to Most Significant Bit (MSB), thatâ€™s exactly whatâ€™s showing in the link. (nums[i] / exp) % 10 is used to get the digit, for each digit, basically the digit itself serves as the index to access the count array. Count array stores the index to access aux array which stores the numbers after sorting based on the current digit. Finally, find the maximum gap from sorted array. Time and space complexities are both O(n). (Actually time is O(10n) at worst case for Integer.MAX_VALUE 2147483647)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[162. Find Peak Element]]></title>
    <url>%2Fp%2Feb35e778%2F</url>
    <content type="text"><![CDATA[36.3% https://leetcode.com/problems/find-peak-element/?tab=Description A peak element is an element that is greater than its neighbors. Given an input array where num[i] â‰  num[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that num[-1] = num[n] = -âˆž. 1For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2. Note: Your solution should be in logarithmic complexity. æ–¹æ³•ä¸€ï¼š my code: é¢˜ç›®è¦æ±‚logå¤æ‚åº¦ï¼Œè¿™ä¸ªæ˜¯nå¤æ‚åº¦ï¼Œè‚¯å®šæ˜¯ä¸å¤Ÿçš„ã€‚logå¤æ‚åº¦è‚¯å®šæ˜¯äºŒåˆ†æœç´¢äº†ã€‚ 1234567891011121314class Solution &#123;public: int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==1) return 0; for(int i=1; i&lt;n-1; i++) if(nums[i]&gt;nums[i-1] &amp;&amp; nums[i]&gt;nums[i+1]) return i; if(nums[0]&gt;nums[1]) return 0; if(nums[n-2]&lt;nums[n-1]) return n-1; &#125;&#125;; Sequential Search: 12345678910111213class Solution &#123;public: int findPeakElement(const vector&lt;int&gt; &amp;num) &#123; for(int i = 1; i &lt; num.size(); i ++) &#123; if(num[i] &lt; num[i-1]) &#123;// &lt; return i-1; &#125; &#125; return num.size()-1; &#125;&#125;; æ–¹æ³•äºŒï¼š 8ms, 4.79%, June.21th, 2016 https://leetcode.com/discuss/17793/find-the-maximum-by-binary-search-recursion-and-iteration Consider that each local maximum is one valid peak.My solution is to find one local maximum with binary search.Binary search satisfies the O(logn) computational complexity. Binary Search: recursion 123456789101112131415161718192021class Solution &#123;public:int findPeakElement(const vector&lt;int&gt; &amp;num) &#123; return Helper(num, 0, num.size()-1);&#125;int Helper(const vector&lt;int&gt; &amp;num, int low, int high)&#123; if(low == high) return low; else &#123; int mid1 = (low+high)/2; int mid2 = mid1+1; if(num[mid1] &gt; num[mid2]) return Helper(num, low, mid1); else return Helper(num, mid2, high); &#125;&#125;&#125;; æ–¹æ³•ä¸‰ï¼š Binary Search: iteration 12345678910111213141516171819class Solution &#123;public: int findPeakElement(const vector&lt;int&gt; &amp;num) &#123; int low = 0; int high = num.size()-1; while(low &lt; high) &#123; int mid1 = (low+high)/2; int mid2 = mid1+1; if(num[mid1] &lt; num[mid2]) low = mid2; else high = mid1; &#125; return low; &#125;&#125;; cppSolution 1: 8ms, 4.79%, June.21th, 2016 https://leetcode.com/discuss/17793/find-the-maximum-by-binary-search-recursion-and-iteration 123456789class Solution &#123;public: int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; for(int i = 1; i &lt; nums.size(); i++) if(nums[i] &lt; nums[i-1]) return i-1; return nums.size() - 1; &#125;&#125;; Solution 2: 4ms, 84.77%, June.21th, 2016 https://leetcode.com/discuss/17793/find-the-maximum-by-binary-search-recursion-and-iteration 12345678910111213141516171819class Solution &#123;public: int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; return Helper(nums, 0, nums.size()-1); &#125; int Helper(const vector&lt;int&gt; &amp;nums, int low, int high)&#123; if(low == high) return low; else&#123; int mid1 = (low + high) / 2; int mid2 = mid1 + 1; if(nums[mid1] &gt; nums[mid2]) return Helper(nums, low, mid1); else return Helper(nums, mid2, high); &#125; &#125;&#125;; Solution 3: pythonSolution 1: 48ms, 82.40%, June.21th, 2016 https://leetcode.com/discuss/35744/my-clean-and-readable-python-solution 1234567891011121314151617181920class Solution(object): def findPeakElement(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; left = 0 right = len(nums)-1 while left &lt; right: mid = (left+right)/2 if nums[mid] &gt; nums[mid+1] and nums[mid] &gt; nums[mid-1]: return mid if nums[mid] &lt; nums[mid+1]: left = mid+1 else: right = mid-1 return left javaSolution 1: 0ms, 33.78%, June.21th, 2016 https://leetcode.com/discuss/18107/o-logn-solution-javacode 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public int findPeakElement(int[] num) &#123; return helper(num,0,num.length-1); &#125; public int helper(int[] num,int start,int end)&#123; if(start == end)&#123; return start; &#125;else if(start+1 == end)&#123; if(num[start] &gt; num[end]) return start; return end; &#125;else&#123; int m = (start+end)/2; if(num[m] &gt; num[m-1] &amp;&amp; num[m] &gt; num[m+1])&#123; return m; &#125;else if(num[m-1] &gt; num[m] &amp;&amp; num[m] &gt; num[m+1])&#123; return helper(num,start,m-1); &#125;else&#123; return helper(num,m+1,end); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[160. Intersection of Two Linked Lists]]></title>
    <url>%2Fp%2Fbf711257%2F</url>
    <content type="text"><![CDATA[30.2% https://leetcode.com/problems/intersection-of-two-linked-lists/description/ Write a program to find the node at which the intersection of two singly linked lists begins. 12345678For example, the following two linked lists:A: a1 â†’ a2 â†˜ c1 â†’ c2 â†’ c3 â†— B: b1 â†’ b2 â†’ b3begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. æ–¹æ³•ä¸€ï¼š å‰‘æŒ‡offer 37 Simple C++ solution (5 lines) Move cur1 (cur2) forward from headA (headB) and loop back to headB (headA), eventually cur1 and cur2 will meet at the intersection point or nullptr. æ­¤ä»£ç çš„å·§å¦™ä¹‹å¤„åœ¨äºŽï¼Œ1ï¼Œå¤´å°¾ç›¸æŽ¥ï¼Œ2ï¼Œåˆ¤æ–­æ¡ä»¶æ˜¯cur1!=cur2 12345678ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *cur1 = headA, *cur2 = headB; while(cur1 != cur2)&#123; cur1 = cur1?cur1-&gt;next:headB; cur2 = cur2?cur2-&gt;next:headA; &#125; return cur1;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if(headA==NULL || headB==NULL) return NULL; ListNode* p1 = headA, *p2 = headB; if(p1==p2) return p1; while(p1 || p2)&#123; if(p1) p1 = p1-&gt;next; else p1 = headB; if(p2) p2 = p2-&gt;next; else p2 = headA; if(p1==p2) return p1; &#125; &#125;&#125;; å¦ä¸€ç§å®žçŽ°æ–¹æ³• https://discuss.leetcode.com/topic/5527/my-accepted-simple-and-shortest-c-code-with-comments-explaining-the-algorithm-any-comments-or-improvements My accepted simple and shortest C++ code with comments explaining the algorithm. Any comments or improvements? 1234567891011121314151617181920212223242526272829ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *p1 = headA; ListNode *p2 = headB; if (p1 == NULL || p2 == NULL) return NULL; while (p1 != NULL &amp;&amp; p2 != NULL &amp;&amp; p1 != p2) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next; // // Any time they collide or reach end together without colliding // then return any one of the pointers. // if (p1 == p2) return p1; // // If one of them reaches the end earlier then reuse it // by moving it to the beginning of other list. // Once both of them go through reassigning, // they will be equidistant from the collision point. // if (p1 == NULL) p1 = headB; if (p2 == NULL) p2 = headA; &#125; return p1;&#125; cpp 46ms, 46.30%, October 15, 2016 https://discuss.leetcode.com/topic/5527/my-accepted-simple-and-shortest-c-code-with-comments-explaining-the-algorithm-any-comments-or-improvements My accepted simple and shortest C++ code with comments explaining the algorithm. Any comments or improvements? 1234567891011121314151617181920212223242526272829ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *p1 = headA; ListNode *p2 = headB; if (p1 == NULL || p2 == NULL) return NULL; while (p1 != NULL &amp;&amp; p2 != NULL &amp;&amp; p1 != p2) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next; // // Any time they collide or reach end together without colliding // then return any one of the pointers. // if (p1 == p2) return p1; // // If one of them reaches the end earlier then reuse it // by moving it to the beginning of other list. // Once both of them go through reassigning, // they will be equidistant from the collision point. // if (p1 == NULL) p1 = headB; if (p2 == NULL) p2 = headA; &#125; return p1;&#125; https://discuss.leetcode.com/topic/38444/simple-c-solution-5-lines Simple C++ solution (5 lines) Move cur1 (cur2) forward from headA (headB) and loop back to headB (headA), eventually cur1 and cur2 will meet at the intersection point or nullptr. 12345678ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *cur1 = headA, *cur2 = headB; while(cur1 != cur2)&#123; cur1 = cur1?cur1-&gt;next:headB; cur2 = cur2?cur2-&gt;next:headA; &#125; return cur1;&#125; python https://discuss.leetcode.com/topic/13419/concise-python-code-with-comments Concise python code with comments 1234567891011121314151617class Solution: # @param two ListNodes # @return the intersected ListNode def getIntersectionNode(self, headA, headB): if headA is None or headB is None: return None pa = headA # 2 pointers pb = headB while pa is not pb: # if either pointer hits the end, switch head and continue the second traversal, # if not hit the end, just move on to next pa = headB if pa is None else pa.next pb = headA if pb is None else pb.next return pa # only 2 ways to get out of the loop, they meet or the both hit the end=None the idea is if you switch head, the possible difference between length would be countered. On the second traversal, they either hit or miss. if they meet, pa or pb would be the node we are looking for, if they didnâ€™t meet, they will hit the end at the same iteration, pa == pb == None, return either one of them is the same,None my code: 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): &quot;&quot;&quot; :type head1, head1: ListNode :rtype: ListNode &quot;&quot;&quot; if headA==None or headB==None: return None l1, l2 = headA, headB while l1 and l2 and l1!=l2: l1 = l1.next l2 = l2.next if l1==l2: return l1 if l1==None: l1=headB if l2==None: l2=headA return l1 java https://discuss.leetcode.com/topic/28067/java-solution-without-knowing-the-difference-in-len Java solution without knowing the difference in len! I found most solutions here preprocess linkedlists to get the difference in len.Actually we donâ€™t care about the â€œvalueâ€ of difference, we just want to make sure two pointers reach the intersection node at the same time. We can use two iterations to do that. In the first iteration, we will reset the pointer of one linkedlist to the head of another linkedlist after it reaches the tail node. In the second iteration, we will move two pointers until they points to the same node. Our operations in first iteration will help us counteract the difference. So if two linkedlist intersects, the meeting point in second iteration must be the intersection point. If the two linked lists have no intersection at all, then the meeting pointer in second iteration must be the tail node of both lists, which is null Below is my commented Java code: 12345678910111213141516public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; //boundary check if(headA == null || headB == null) return null; ListNode a = headA; ListNode b = headB; //if a &amp; b have different len, then we will stop the loop after second iteration while( a != b)&#123; //for the end of first iteration, we just reset the pointer to the head of another linkedlist a = a == null? headB : a.next; b = b == null? headA : b.next; &#125; return a;&#125; https://discuss.leetcode.com/topic/5492/concise-java-solution-o-1-memory-o-n-time Concise JAVA solution, O(1) memory O(n) time 1, Get the length of the two lists. 2, Align them to the same start point. 3, Move them together until finding the intersection point, or the end null 123456789101112131415161718192021222324252627public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; int lenA = length(headA), lenB = length(headB); // move headA and headB to the same start point while (lenA &gt; lenB) &#123; headA = headA.next; lenA--; &#125; while (lenA &lt; lenB) &#123; headB = headB.next; lenB--; &#125; // find the intersection until end while (headA != headB) &#123; headA = headA.next; headB = headB.next; &#125; return headA;&#125;private int length(ListNode node) &#123; int length = 0; while (node != null) &#123; node = node.next; length++; &#125; return length;&#125; 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode p1=headA, p2=headB; if(p1==null || p2==null) return null; while(p1!=null &amp;&amp; p2!=null &amp;&amp; p1!=p2)&#123; p1=p1.next; p2=p2.next; if(p1==p2) return p1; if(p1==null) p1=headB; if(p2==null) p2=headA; &#125; return p1; &#125;&#125; https://discuss.leetcode.com/topic/11626/share-my-simple-java-solution-o-n-time-o-1-space Share my simple java solution O(n) time, O(1) space Scan both lists For each list once it reaches the end, continue scanning the other list Once the two runner equal to each other, return the position Time O(n+m), space O(1) 1234567891011public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if( null==headA || null==headB ) return null; ListNode curA = headA, curB = headB; while( curA!=curB)&#123; curA = curA==null?headB:curA.next; curB = curB==null?headA:curB.next; &#125; return curA; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[159.Longest Substring with At Most Two Distinct Characters]]></title>
    <url>%2Fp%2F5c6ef69c%2F</url>
    <content type="text"><![CDATA[41.1% Given a string, find the length of the longest substring T that contains at most 2 distinct characters. For example, Given s = â€œecebaâ€, T is â€œeceâ€ which its length is 3. æœ¬é¢˜ä¸Ž ç¬¬3é¢˜ï¼Œç¬¬76é¢˜éƒ½å¯ä»¥ç”¨åŒä¸€ä¸ªæ¨¡æ¿è§£å†³ã€‚ æ–¹æ³•ä¸€: 12345678910int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; map(128,0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++&gt;0) counter++; while(counter&gt;0) if(map[s[begin++]]--&gt;1) counter--; d=max(d, end-begin); //while valid, update d &#125; return d; &#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼Œè‡ªå·±é€šè¿‡æµ‹è¯•ï¼Œä½†leetcodeæœ‰é”ï¼Œæ— æ³•åˆ¤æ–­æ˜¯å¦é€šè¿‡æ‰€æœ‰æ ·ä¾‹ 123456789101112131415161718192021222324class Soulution&#123;public: int lengthOfLongestSubstringTwoDistinct(string s) &#123; int n = s.size(); if (n &lt;= 1) return n; int begin = 0, end = 0, d = 0, counter = 0; vector&lt;int&gt; indexs(256, 0); while (end &lt; n) &#123; if (indexs[s[end]] == 0) counter++; indexs[s[end]]++; end++; while (counter &gt; 2) &#123; if (indexs[s[begin]] == 1) counter--; indexs[s[begin]]--; begin++; &#125; d = max(d, end - begin); &#125; return d; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[155. Min Stack]]></title>
    <url>%2Fp%2F901eaa11%2F</url>
    <content type="text"><![CDATA[27.1% https://leetcode.com/problems/min-stack/ Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) â€“ Push element x onto stack. pop() â€“ Removes the element on top of the stack. top() â€“ Get the top element. getMin() â€“ Retrieve the minimum element in the stack. 123456789Example:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. æ–¹æ³•ä¸€ï¼š ä¸¤ä¸ªæ ˆï¼Œå…¶ä¸­ä¸€ä¸ªä¸ºè¾…åŠ©æ ˆ 123456789101112131415161718192021222324252627class MinStack &#123;private: stack&lt;int&gt; s1; stack&lt;int&gt; s2;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; s1.push(x); if(s2.empty() || x&lt;=getMin()) s2.push(x); &#125; void pop() &#123; if(s1.top() == getMin()) s2.pop(); s1.pop(); &#125; int top() &#123; return s1.top(); &#125; int getMin() &#123; return s2.top(); &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š ä¸¤ä¸ªstackï¼Œæ³¨æ„stackæœ‰pop topæ–¹æ³•ï¼Œä½†æ˜¯æ²¡æœ‰frontæ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839class MinStack &#123;public: stack&lt;int&gt; st1; stack&lt;int&gt; st2; /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; st1.push(x); if(st2.empty() || x&lt;=st2.top()) st2.push(x); &#125; void pop() &#123; int x = st1.top(); if(x==st2.top()) st2.pop(); st1.pop(); &#125; int top() &#123; return st1.top(); &#125; int getMin() &#123; return st2.top(); &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ æ–¹æ³•äºŒï¼š ä¸€ä¸ªstack ä¸€ä¸ªint min minè¡¨ç¤ºå½“å‰çš„æœ€å°å€¼ï¼Œå¦‚æžœæ–°çš„xä¸æ”¹å˜æœ€å°å€¼ï¼Œpushè¿›åŽ»ã€‚å¦‚æžœæ”¹å˜æˆ–è€…ç­‰äºŽæœ€å°å€¼ï¼Œå…ˆæŠŠminåŽ‹å…¥ï¼Œå†æŠŠminæ›´æ”¹ä¸ºxï¼ŒæŠŠxåŽ‹å…¥ã€‚ æ¯”å¦‚-2ï¼Œ0ï¼Œ-3åˆ™å¯¹åº”çš„æ˜¯ [-2], -2 [-2, 0], -2 [-2, 0, -2, -3] -3 å¼¹å‡º [-2, 0, -2, -3] -3 [-2, 0] -2 [-2] -2 è¿™ç§æ€è·¯å¥½ï¼Œåªæ˜¯å¢žåŠ äº†ä¸€äº›å­˜å‚¨ç©ºé—´è€Œå·²ã€‚ popæ—¶ï¼Œæ£€æŸ¥ä¸Žminçš„å…³ç³»ã€‚ æˆ‘çš„ä»£ç å®žçŽ°ï¼š Dec 7th, 2017 12345678910111213141516171819202122232425262728293031323334353637383940414243class MinStack &#123; int min = INT_MAX; stack&lt;int&gt; stack1;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; if(x&lt;=min)&#123; stack1.push(min); min = x; &#125; stack1.push(x); &#125; void pop() &#123; int x = top(); stack1.pop(); if(x==min)&#123; min = stack1.top(); stack1.pop(); &#125; &#125; int top() &#123; return stack1.top(); &#125; int getMin() &#123; return min; &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243class MinStack &#123;public: int min=INT_MAX; stack&lt;int&gt; st; /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; if(x&lt;=min)&#123; st.push(min); min = x; &#125; st.push(x); &#125; void pop() &#123; int x = st.top(); st.pop(); if(min == x)&#123; min = st.top(); st.pop(); &#125; &#125; int top() &#123; return st.top(); &#125; int getMin() &#123; return min; &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ æ³¨æ„è¿™æ˜¯javaä»£ç ï¼Œæ‰¾æ—¶é—´æ”¹å†™ä¸ºc++ç‰ˆæœ¬ 123456789101112131415161718192021222324252627class MinStack &#123; int min = Integer.MAX_VALUE; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); public void push(int x) &#123; // only push the old minimum value when the current // minimum value changes after pushing the new value x if(x &lt;= min)&#123; stack.push(min); min=x; &#125; stack.push(x); &#125; public void pop() &#123; // if pop operation could result in the changing of the current minimum value, // pop twice and change the current minimum value to the last minimum value. if(stack.pop() == min) min=stack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return min; &#125;&#125; æ–¹æ³•ä¸‰ï¼š ä¸€ä¸ªstackï¼Œä¸€ä¸ªint min æ­¤æ–¹æ³•ä¸­ï¼Œstackåœ¨ç©ºæ—¶ï¼Œç‰¹æ®Šå¤„ç†ã€‚ç„¶åŽï¼Œå¯¹äºŽæ–°æ¥çš„xï¼Œpushå…¶ä¸Žminçš„å·®å€¼ï¼Œç„¶åŽæ ¹æ®xä¸Žmin çš„å·®å€¼å†³å®šæ›´ä¸æ›´æ–°minã€‚popæ—¶ï¼Œç›¸åå¤„ç†ã€‚ ç›¸å¯¹äºŽä¸Šä¸€ç§æ–¹æ³•ï¼Œè¿™ç§æ€æƒ³æ›´åŠ å¤æ‚ä¸€äº›ï¼Œä½†æ˜¯stacké‡Œä¿å­˜çš„æ•°æ®æœ€å°‘ã€‚ æ³¨æ„ï¼Œjavaä»£ç ï¼Œæ‰¾æ—¶é—´æ”¹å†™ä¸ºc++ç‰ˆ 12345678910111213141516171819202122232425262728293031323334353637383940public class MinStack &#123; long min; Stack&lt;Long&gt; stack; public MinStack()&#123; stack=new Stack&lt;&gt;(); &#125; public void push(int x) &#123; if (stack.isEmpty())&#123; stack.push(0L); min=x; &#125;else&#123; stack.push(x-min);//Could be negative if min value needs to change if (x&lt;min) min=x; &#125; &#125; public void pop() &#123; if (stack.isEmpty()) return; long pop=stack.pop(); if (pop&lt;0) min=min-pop;//If negative, increase the min value &#125; public int top() &#123; long top=stack.peek(); if (top&gt;0)&#123; return (int)(top+min); &#125;else&#123; return (int)(min); &#125; &#125; public int getMin() &#123; return (int)min; &#125;&#125; 56ms, September 13, 2016 https://discuss.leetcode.com/topic/18556/c-using-two-stacks-quite-short-and-easy-to-understand C++ using two stacks, quite short and easy to understand 123456789101112131415161718192021222324252627class MinStack &#123;private: stack&lt;int&gt; s1; stack&lt;int&gt; s2;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; s1.push(x); if(s2.empty() || x&lt;=getMin()) s2.push(x); &#125; void pop() &#123; if(s1.top() == getMin()) s2.pop(); s1.pop(); &#125; int top() &#123; return s1.top(); &#125; int getMin() &#123; return s2.top(); &#125;&#125;; https://discuss.leetcode.com/topic/28435/c-o-1-solution C++ O(1) solution 1234567891011121314151617181920212223242526272829class MinStack &#123;public: vector&lt;int&gt; a; vector&lt;int&gt; min; MinStack() &#123; min.push_back(2147483647); &#125; void push(int x) &#123; a.push_back(x); if (x &lt; min.back()) &#123; min.push_back(x); &#125; else &#123; min.push_back(min.back()); &#125; &#125; void pop() &#123; a.pop_back(); min.pop_back(); &#125; int top() &#123; return a.back(); &#125; int getMin() &#123; return min.back(); &#125;&#125;; https://discuss.leetcode.com/topic/11985/my-python-solution My Python solution 1234567891011121314151617181920212223242526272829303132class MinStack:def __init__(self): self.q = []# @param x, an integer# @return an integerdef push(self, x): curMin = self.getMin() if curMin == None or x &lt; curMin: curMin = x self.q.append((x, curMin));# @return nothingdef pop(self): self.q.pop()# @return an integerdef top(self): if len(self.q) == 0: return None else: return self.q[len(self.q) - 1][0]# @return an integerdef getMin(self): if len(self.q) == 0: return None else: return self.q[len(self.q) - 1][1] https://discuss.leetcode.com/topic/4953/share-my-java-solution-with-only-one-stack Share my Java solution with ONLY ONE stack The question is ask to construct One stack. So I am using one stack. The idea is to store the gap between the min value and the current value; The problem for my solution is the cast. I have no idea to avoid the cast. Since the possible gap between the current value and the min value could be Integer.MAX_VALUE-Integer.MIN_VALUE; 12345678910111213141516171819202122232425262728293031323334353637383940public class MinStack &#123; long min; Stack&lt;Long&gt; stack; public MinStack()&#123; stack=new Stack&lt;&gt;(); &#125; public void push(int x) &#123; if (stack.isEmpty())&#123; stack.push(0L); min=x; &#125;else&#123; stack.push(x-min);//Could be negative if min value needs to change if (x&lt;min) min=x; &#125; &#125; public void pop() &#123; if (stack.isEmpty()) return; long pop=stack.pop(); if (pop&lt;0) min=min-pop;//If negative, increase the min value &#125; public int top() &#123; long top=stack.peek(); if (top&gt;0)&#123; return (int)(top+min); &#125;else&#123; return (int)(min); &#125; &#125; public int getMin() &#123; return (int)min; &#125;&#125; https://discuss.leetcode.com/topic/7020/java-accepted-solution-using-one-stack Java accepted solution using one stack 123456789101112131415161718192021222324252627class MinStack &#123; int min = Integer.MAX_VALUE; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); public void push(int x) &#123; // only push the old minimum value when the current // minimum value changes after pushing the new value x if(x &lt;= min)&#123; stack.push(min); min=x; &#125; stack.push(x); &#125; public void pop() &#123; // if pop operation could result in the changing of the current minimum value, // pop twice and change the current minimum value to the last minimum value. if(stack.pop() == min) min=stack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return min; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[154. Find Minimum in Rotated Sorted Array II]]></title>
    <url>%2Fp%2F3156a2f3%2F</url>
    <content type="text"><![CDATA[36.5% https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/#/description Follow up for â€œFind Minimum in Rotated Sorted Arrayâ€:What if duplicates are allowed? Would this affect the run-time complexity? How and why?Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. The array may contain duplicates. å‰‘æŒ‡offer 8ï¼Œ leetcode 153 æ–¹æ³•ä¸€ï¼š å‰‘æŒ‡offerè§£æ³•ï¼Œå…¨é¢è€ƒè™‘é—®é¢˜ï¼Œåªæœ‰ä¸­é—´å’Œä¸¤è¾¹ä¸‰ä¸ªå€¼éƒ½ç›¸ç­‰æ—¶ï¼Œæ‰ä¼šå‡ºçŽ°æ— æ³•åˆ¤æ–­æƒ…å†µï¼Œéœ€è¦ä»Žå¤´åˆ°å°¾éåŽ†ã€‚ 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==1) return nums[0]; int left=0, right=n-1; int mid = left; while(nums[left]&gt;=nums[right])&#123; if(right-left==1)&#123; mid = right; break; &#125; mid = left+(right-left)/2; if(nums[left]==nums[mid] &amp;&amp; nums[mid]==nums[right]) return helper(nums, left, right); if(nums[left]&lt;=nums[mid]) left = mid; else if(nums[mid]&lt;=nums[right]) right = mid; &#125; return nums[mid]; &#125; int helper(vector&lt;int&gt; nums, int left, int right)&#123; int res = nums[left]; for(int i=left+1; i&lt;right+1; i++)&#123; res = min(nums[i], res); &#125; return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526272829class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int left=0, right=nums.size()-1; if(nums.size()==1) return nums[0]; while(nums[left]&gt;=nums[right])&#123; if(right-left==1) return nums[right]; int mid = left+(right-left)/2; if(nums[left]==nums[mid] &amp;&amp; nums[left]==nums[right]) return lineSearch(nums, left, right); if(nums[left]&gt;nums[mid])&#123; right = mid; &#125;else if(nums[left]&lt;=nums[mid])&#123; left = mid + 1; &#125; &#125; return nums[left]; &#125; int lineSearch(vector&lt;int&gt;&amp; nums, int left, int right)&#123; int pos = left; for(int i=left+1; i&lt;=right; i++)&#123; if(nums[i]&lt;nums[pos]) pos=i; &#125; return nums[pos]; &#125;&#125;; æ–¹æ³•äºŒï¼š 1234567891011121314151617181920212223class Solution &#123;public: int findMin(vector&lt;int&gt; &amp;num) &#123; int lo = 0; int hi = num.size() - 1; int mid = 0; while(lo &lt; hi) &#123; mid = lo + (hi - lo) / 2; if (num[mid] &gt; num[hi]) &#123; lo = mid + 1; &#125; else if (num[mid] &lt; num[hi]) &#123; hi = mid; &#125; else &#123; // when num[mid] and num[hi] are same hi--; &#125; &#125; return num[lo]; &#125;&#125;; When num[mid] == num[hi], we couldnâ€™t sure the position of minimum in midâ€™s left or right, so just let upper bound reduce one. https://discuss.leetcode.com/topic/5182/rough-sketch-of-proof-why-o-lg-n-is-impossible Rough sketch of proof why O(lg N) is impossible Refer to this image: array config Big version here: http://postimg.org/image/asbbeo2c9/ There are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value. For non-duplicate case, you may use num[mid] &gt; num[end] to distinguish (1)&amp;(2) from (3), and thus safely eliminate half of the array, at each iteration. For dup case, it is not as straightforward (impossible?) to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration. 8ms, 20.55%, June.20th, 2016 https://leetcode.com/discuss/19746/my-pretty-simple-code-to-solve-it My pretty simple code to solve it 1234567891011121314151617181920212223class Solution &#123;public: int findMin(vector&lt;int&gt; &amp;num) &#123; int lo = 0; int hi = num.size() - 1; int mid = 0; while(lo &lt; hi) &#123; mid = lo + (hi - lo) / 2; if (num[mid] &gt; num[hi]) &#123; lo = mid + 1; &#125; else if (num[mid] &lt; num[hi]) &#123; hi = mid; &#125; else &#123; // when num[mid] and num[hi] are same hi--; &#125; &#125; return num[lo]; &#125;&#125;; When num[mid] == num[hi], we couldnâ€™t sure the position of minimum in midâ€™s left or right, so just let upper bound reduce one. https://discuss.leetcode.com/topic/4253/one-simple-and-clear-method-with-o-1-space-and-worst-o-n-time One simple and clear method with O(1) space and worst O(n) time 123456789101112131415161718192021222324252627class Solution &#123;public: int findMin(vector&lt;int&gt; &amp;num) &#123; if(num.empty()) return 0; int i=0,j=num.size()-1; while(i&lt;j) &#123; int mid=(i+j)/2; if(num[j]&lt;num[mid])&#123; i=mid+1; &#125; else if(num[mid]&lt;num[j])&#123; j=mid; &#125; else&#123;//num[mid]==num[j] if(num[i]==num[mid])&#123;//linear complexity i++; j--; &#125; else j=mid; &#125; &#125; return num[j]; &#125;&#125;; https://discuss.leetcode.com/topic/4264/my-c-solution-24ms-is-there-any-better-solution My C++ solution 24ms is there any better solution ? 1234567891011121314151617181920212223class Solution &#123;public:int findMin(vector&lt;int&gt; &amp;num) &#123; int start = 0; int end = num.size()-1; int mid; while(start&lt;end)&#123; if(num[start]&lt;num[end]) break; mid = start+(end-start)/2; if(num[mid]&gt;num[end])&#123; start = mid+1; &#125; else if(num[mid]==num[end])&#123; start++; end--; &#125; else end= mid; &#125; return num[start]; &#125;&#125;; https://discuss.leetcode.com/topic/19165/8ms-13-lines-c-solution 8ms 13-lines C++ Solution This problem is more or less the same as Find Minimum in Rotated Sorted Array. And one key difference is as stated in the solution tag. That is, due to duplicates, we may not be able to throw one half sometimes. And in this case, we could just apply linear search and the time complexity will become O(n). The idea to solve this problem is still to use invariants. We set l to be the left pointer and r to be the right pointer. Since duplicates exist, the invatiant is nums[l] &gt;= nums[r] (if it does not hold, then nums[l] will simply be the minimum). We then begin binary search by comparing nums[l], nums[r] with nums[mid]. If nums[l] = nums[r] = nums[mid], simply apply linear search within nums[l..r]. If nums[mid] &lt;= nums[r], then the mininum cannot appear right to mid, so set r = mid; If nums[mid] &gt; nums[r], then mid is in the first larger half and r is in the second smaller half, so the minimum is to the right of mid: set l = mid + 1. The code is as follows. 123456789101112131415161718192021class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int l = 0, r = nums.size() - 1; while (nums[l] &gt;= nums[r]) &#123; int mid = (l &amp; r) + ((l ^ r) &gt;&gt; 1); if (nums[l] == nums[r] &amp;&amp; nums[mid] == nums[l]) return findMinLinear(nums, l, r); if (nums[mid] &lt;= nums[r]) r = mid; else l = mid + 1; &#125; return nums[l]; &#125; private: int findMinLinear(vector&lt;int&gt;&amp; nums, int l, int r) &#123; int minnum = nums[l]; for (int p = l + 1; p &lt;= r; p++) minnum = min(minnum, nums[p]); return minnum; &#125;&#125;; https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/ Python solution. Worst case O(N) 12345678910111213141516171819def findMin(self, nums): beg = 0 end = len(nums)-1 while beg &lt;= end: while beg &lt; end and nums[beg] == nums[beg + 1]: beg += 1 while end &gt; beg and nums[end] == nums[end - 1]: end -= 1 if beg == end: return nums[beg] mid = (beg+end)/2 if nums[mid] &gt; nums[end]: beg = mid + 1 else: end = mid return nums[beg] Solution Mime: 64ms, 20.87%, June.20th, 2016 1234567891011class Solution(object): def findMin(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; rtype = nums[0] for i in xrange(len(nums)): if nums[i] &lt; rtype: rtype = nums[i] return rtype Solution Mime: 52ms, 65.53%, June.20th, 2016 12345678910111213141516171819class Solution(object): def findMin(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; l = 0 r = len(nums) - 1 while(l &lt; r): if nums[l] &lt; nums[r]: return nums[l] mid = (l + r) / 2 if nums[mid] &gt; nums[r]: l = mid + 1 elif nums[mid] &lt; nums[r]: r = mid else: l += 1 return nums[l] 1ms, 6.02%, June.20th, 2016 https://leetcode.com/discuss/60147/super-simple-and-clean-java-binary-search 12345678910111213141516public class Solution &#123; public int findMin(int[] nums) &#123; int l = 0, r = nums.length-1; while (l &lt; r) &#123; int mid = (l + r) / 2; if (nums[mid] &lt; nums[r]) &#123; r = mid; &#125; else if (nums[mid] &gt; nums[r])&#123; l = mid + 1; &#125; else &#123; r--; //nums[mid]=nums[r] no idea, but we can eliminate nums[r]; &#125; &#125; return nums[l]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>binary search</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[153. Find Minimum in Rotated Sorted Array]]></title>
    <url>%2Fp%2F64895756%2F</url>
    <content type="text"><![CDATA[39.1% https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/#/description Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. å‰‘æŒ‡offer 8 æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return -1; if(n==1) return nums[0]; int left = 0, right = n-1; int mid = left; while(nums[left]&gt;nums[right])&#123; if(right-left==1)&#123; mid = right; break; &#125; mid = left + (right-left)/2; if(nums[left]&gt;nums[mid]) right = mid; else left = mid; &#125; return nums[mid]; &#125;&#125;; å‰‘æŒ‡offerè§£æ³•ï¼Œæœ‰ä¸¤ç§æƒ…å†µï¼Œ nums[left] &lt; nums[right], è¿”å›žçš„ç»“æžœå°±æ˜¯nums[left] nums[left] &gt; nums[right]ç›¸å¯¹å¤æ‚ä¸€äº›ã€‚å¯¹äºŽæ•°ç»„é‡Œåªæœ‰ä¸¤ä¸ªçš„è¯ï¼Œåªè¦è¿”å›žç¬¬äºŒä¸ªå°±å¥½äº†ã€‚å¦åˆ™ï¼Œé’ˆå¯¹ä¸¤ç§ä¸­é—´æƒ…å†µè¿›è¡Œè®¨è®ºå°±å¥½äº†ã€‚ 123456789101112131415161718192021class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==1) return nums[0]; int left=0, right=n-1; int mid = left; while(nums[left]&gt;nums[right])&#123; if(right-left==1)&#123; mid = right; break; &#125; mid = left+(right-left)/2; if(nums[left]&lt;nums[mid]) left = mid; else if(nums[mid]&lt;nums[right]) right = mid; &#125; return nums[mid]; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int left=0, right=nums.size()-1; while(nums[left]&gt;nums[right])&#123; if(right-left==1) return nums[right]; int mid = left+(right-left)/2; if(nums[mid]&lt;nums[right]) right = mid; else left = mid+1; &#125; return nums[left]; &#125;&#125;; æ–¹æ³•äºŒï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return -1; if(n==1) return nums[0]; int left = 0, right = n-1; int mid; while(left&lt;right)&#123; if(nums[left]&lt;=nums[right]) return nums[left]; mid = left + (right-left)/2; // &lt;= æ˜¯è€ƒè™‘äº†left == midçš„æƒ…å†µ if(nums[left]&lt;=nums[mid]) left = mid+1; else right = mid; &#125; return nums[left]; &#125;&#125;; é’ˆå¯¹startå’Œendè¿›è¡Œå¾ªçŽ¯ï¼Œå¤šé‡è®¨è®ºè€Œå·²ã€‚å¦‚æžœnums{start] &lt; nums[end]ï¼Œåˆ™ä¸€å®šæ˜¯é¡ºåºçš„äº†ã€‚è¿”å›žç»“æžœã€‚å¦åˆ™æ ¹æ®ä¸­é—´èŠ‚ç‚¹ï¼Œé€‰æ‹©è®¨è®ºã€‚å¾—åˆ°ä¸¤ç§æƒ…å†µã€‚æ€è·¯æ¸…æ™°æ˜Žäº†ã€‚ 123456789101112131415161718int findMin(vector&lt;int&gt; &amp;num) &#123; int start=0,end=num.size()-1; while (start&lt;end) &#123; if (num[start]&lt;num[end]) return num[start]; int mid = (start+end)/2; if (num[mid]&gt;=num[start]) &#123; start = mid+1; &#125; else &#123; end = mid; &#125; &#125; return num[start]; &#125; æ–¹æ³•ä¸‰ï¼š çœ‹èµ·æ¥æŒºåŽ‰å®³çš„ä¸€ç§æ–¹æ³•å•Šã€‚ 12345678910111213141516171819202122class Solution &#123;public: int findMin(vector&lt;int&gt; &amp;num) &#123; int low = 0, high = num.size() - 1; // loop invariant: 1. low &lt; high // 2. mid != high and thus A[mid] != A[high] (no duplicate exists) // 3. minimum is between [low, high] // The proof that the loop will exit: after each iteration either the &apos;high&apos; decreases // or the &apos;low&apos; increases, so the interval [low, high] will always shrink. while (low &lt; high) &#123; auto mid = low + (high - low) / 2; if (num[mid] &lt; num[high]) // the mininum is in the left part high = mid; else if (num[mid] &gt; num[high]) // the mininum is in the right part low = mid + 1; &#125; return num[low]; &#125;&#125;; 4ms, 21.69%, June.19th, 2016 https://leetcode.com/discuss/13389/compact-and-clean-c-solution Compact and clean C++ solution Classic binary search problem. Looking at subarray with index [start,end]. We can find out that if the first member is less than the last member, thereâ€™s no rotation in the array. So we could directly return the first element in this subarray. If the first element is larger than the last one, then we compute the element in the middle, and compare it with the first element. If value of the element in the middle is larger than the first element, we know the rotation is at the second half of this array. Else, it is in the first half in the array. Welcome to put your comments and suggestions. 123456789101112131415161718int findMin(vector&lt;int&gt; &amp;num) &#123; int start=0,end=num.size()-1; while (start&lt;end) &#123; if (num[start]&lt;num[end]) return num[start]; int mid = (start+end)/2; if (num[mid]&gt;=num[start]) &#123; start = mid+1; &#125; else &#123; end = mid; &#125; &#125; return num[start]; &#125; Some corner cases will be discussed here https://discuss.leetcode.com/topic/14768/4ms-simple-c-code-with-explanation 4ms simple C++ code with explanation In this problem, we have only three cases. Case 1. The leftmost value is less than the rightmost value in the list: This means that the list is not rotated. e.g&gt; [1 2 3 4 5 6 7 ] Case 2. The value in the middle of the list is greater than the leftmost and rightmost values in the list. e.g&gt; [ 4 5 6 7 0 1 2 3 ] Case 3. The value in the middle of the list is less than the leftmost and rightmost values in the list. e.g&gt; [ 5 6 7 0 1 2 3 4 ] As you see in the examples above, if we have case 1, we just return the leftmost value in the list. If we have case 2, we just move to the right side of the list. If we have case 3 we need to move to the left side of the list. Following is the code that implements the concept described above. 123456789101112131415int findMin(vector&lt;int&gt;&amp; nums) &#123; int left = 0, right = nums.size() - 1; while(left &lt; right) &#123; if(nums[left] &lt; nums[right]) return nums[left]; int mid = (left + right)/2; if(nums[mid] &gt; nums[right]) left = mid + 1; else right = mid; &#125; return nums[left];&#125; https://discuss.leetcode.com/topic/5044/simplest-and-fastest-c-solution-o-lg-n-you-can-t-beat-this Simplest and fastest C++ solution O(lg N), you canâ€™t beat this! Binary search: basically eliminate the impossible elements by half each time by exploiting the sorted property. 123456789int findMin(vector&lt;int&gt; &amp;num) &#123; int lo =0, hi = num.size()-1; while(lo&lt;hi)&#123; int mid=(lo+hi)/2; if(num[mid]&gt;num[hi]) lo=mid+1; else hi=mid; &#125; return num[lo];&#125; https://discuss.leetcode.com/topic/6112/a-concise-solution-with-proof-in-the-comment A concise solution with proof in the comment 12345678910111213141516171819202122class Solution &#123;public: int findMin(vector&lt;int&gt; &amp;num) &#123; int low = 0, high = num.size() - 1; // loop invariant: 1. low &lt; high // 2. mid != high and thus A[mid] != A[high] (no duplicate exists) // 3. minimum is between [low, high] // The proof that the loop will exit: after each iteration either the &apos;high&apos; decreases // or the &apos;low&apos; increases, so the interval [low, high] will always shrink. while (low &lt; high) &#123; auto mid = low + (high - low) / 2; if (num[mid] &lt; num[high]) // the mininum is in the left part high = mid; else if (num[mid] &gt; num[high]) // the mininum is in the right part low = mid + 1; &#125; return num[low]; &#125;&#125;; https://discuss.leetcode.com/topic/26884/9-line-python-clean-code 9-line python clean code Just use binary search 123456789101112131415class Solution(object): def findMin(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; i = 0 j = len(nums) - 1 while i &lt; j: m = i + (j - i) / 2 if nums[m] &gt; nums[j]: i = m + 1 else: j = m return nums[i] Solution Mine: 52ms, 50.58%, June.19th, 2016 1234567891011class Solution(object): def findMin(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; rtype = nums[0] for i in xrange(len(nums)-1): if nums[i] &gt; nums[i+1]: rtype = nums[i+1] return rtype Solution Mine: 64ms, 18.65%, June.19th, 2016 123456789101112131415class Solution(object): def findMin(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; l = 0 r = len(nums) - 1 while(l &lt; r): mid = (l + r) / 2 if nums[mid] &lt; nums[r]: r = mid else: l = mid + 1 return nums[l] Solution 1: 56ms, 34.04%, June.19th, 2016 https://leetcode.com/discuss/63514/9-line-python-clean-code 123456789101112131415class Solution(object): def findMin(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; l = 0 r = len(nums) - 1 while(l &lt; r): mid = (l + r) / 2 if nums[mid] &gt; nums[r]: l = mid + 1 else: r = mid return nums[l]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[152. Maximum Product Subarray]]></title>
    <url>%2Fp%2Fab8f143e%2F</url>
    <content type="text"><![CDATA[24.8% https://leetcode.com/problems/maximum-product-subarray/ Find the contiguous subarray within an array (containing at least one number) which has the largest product. 12For example, given the array [2,3,-2,4],the contiguous subarray [2,3] has the largest product = 6. æ–¹æ³•ä¸€ï¼š ä¸Ž52é¢˜ç±»ä¼¼ï¼Œé‚£ä¸ªæ˜¯æ±‚å’Œï¼Œè¿™ä¸ªæ˜¯æ±‚ç§¯ æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int res = nums[0]; int imin = nums[0], imax = nums[0]; for(int i=1; i&lt;nums.size(); i++)&#123; if(nums[i]&lt;0) swap(imin, imax); imin = min(nums[i], nums[i]*imin); imax = max(nums[i], nums[i]*imax); res = max(imax, res); &#125; return res; &#125;&#125;; 12345678910111213141516171819202122232425class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; // store the result that is the max we have found so far int r = nums[0], n = nums.size(); // imax/imin stores the max/min product of // subarray that ends with the current number A[i] for (int i = 1, imax = r, imin = r; i &lt; n; i++) &#123; // multiplied by a negative makes big number smaller, small number bigger // so we redefine the extremums by swapping them if (nums[i] &lt; 0) swap(imax, imin); // max/min product for the current number is either the current number itself // or the max/min by the previous number times the current one imax = max(nums[i], imax * nums[i]); imin = min(nums[i], imin * nums[i]); // the newly computed max value is a candidate for our global result r = max(r, imax); &#125; return r; &#125;&#125;; https://discuss.leetcode.com/topic/4417/possibly-simplest-solution-with-o-n-time-complexity Possibly simplest solution with O(n) time complexity 12345678910111213141516171819202122int maxProduct(int A[], int n) &#123; // store the result that is the max we have found so far int r = A[0]; // imax/imin stores the max/min product of // subarray that ends with the current number A[i] for (int i = 1, imax = r, imin = r; i &lt; n; i++) &#123; // multiplied by a negative makes big number smaller, small number bigger // so we redefine the extremums by swapping them if (A[i] &lt; 0) swap(imax, imin); // max/min product for the current number is either the current number itself // or the max/min by the previous number times the current one imax = max(A[i], imax * A[i]); imin = min(A[i], imin * A[i]); // the newly computed max value is a candidate for our global result r = max(r, imax); &#125; return r;&#125; my code: 12345678910111213141516class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int imax=nums[0], imin=nums[0]; int res=nums[0]; int tmax, tmin; for(int i=1; i&lt;nums.size(); i++)&#123; tmax = max(imax*nums[i], max(imin*nums[i], nums[i])); tmin = min(imax*nums[i], min(imin*nums[i], nums[i])); res = max(tmax, res); imax = tmax; imin = tmin; &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/22001/in-python-can-it-be-more-concise In Python, can it be more concise? 123456def maxProduct(nums): maximum=big=small=nums[0] for n in nums[1:]: big, small=max(n, n*big, n*small), min(n, n*big, n*small) maximum=max(maximum, big) return maximum java https://discuss.leetcode.com/topic/3607/sharing-my-solution-o-1-space-o-n-running-time Sharing my solution: O(1) space, O(n) running time 12345678910111213141516171819public int maxProduct(int[] A) &#123; if (A.length == 0) &#123; return 0; &#125; int maxherepre = A[0]; int minherepre = A[0]; int maxsofar = A[0]; int maxhere, minhere; for (int i = 1; i &lt; A.length; i++) &#123; maxhere = Math.max(Math.max(maxherepre * A[i], minherepre * A[i]), A[i]); minhere = Math.min(Math.min(maxherepre * A[i], minherepre * A[i]), A[i]); maxsofar = Math.max(maxhere, maxsofar); maxherepre = maxhere; minherepre = minhere; &#125; return maxsofar;&#125; Note: Thereâ€™s no need to use O(n) space, as all that you need is a minhere and maxhere. (local max and local min), then you can get maxsofar (which is global max) from them. Thereâ€™s a chapter in Programming Pearls 2 that discussed the MaxSubArray problem, the idea is similar. https://discuss.leetcode.com/topic/5161/simple-java-code Simple Java code Loop through the array, each time remember the max and min value for the previous product, the most important thing is to update the max and min value: we have to compare among max A[i], min A[i] as well as A[i], since this is product, a negative * negative could be positive. 1234567891011121314151617public class Solution &#123; public int maxProduct(int[] A) &#123; if (A == null || A.length == 0) &#123; return 0; &#125; int max = A[0], min = A[0], result = A[0]; for (int i = 1; i &lt; A.length; i++) &#123; int temp = max; max = Math.max(Math.max(max * A[i], min * A[i]), A[i]); min = Math.min(Math.min(temp * A[i], min * A[i]), A[i]); if (max &gt; result) &#123; result = max; &#125; &#125; return result; &#125;&#125; https://discuss.leetcode.com/topic/3581/share-my-dp-code-that-got-ac Share my DP code that got AC 123456789101112131415161718public class Solution &#123; public int maxProduct(int[] A) &#123; if (A == null || A.length == 0) &#123; return 0; &#125; int[] f = new int[A.length]; int[] g = new int[A.length]; f[0] = A[0]; g[0] = A[0]; int res = A[0]; for (int i = 1; i &lt; A.length; i++) &#123; f[i] = Math.max(Math.max(f[i - 1] * A[i], g[i - 1] * A[i]), A[i]); g[i] = Math.min(Math.min(f[i - 1] * A[i], g[i - 1] * A[i]), A[i]); res = Math.max(res, f[i]); &#125; return res; &#125;&#125; f[i] means maximum product that can be achieved ending with i g[i] means minimum product that can be achieved ending with i]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[151. Reverse Words in a String]]></title>
    <url>%2Fp%2Fc9db0a7a%2F</url>
    <content type="text"><![CDATA[15.7% https://leetcode.com/problems/reverse-words-in-a-string/ Given an input string, reverse the string word by word. 123For example,Given s = &quot;the sky is blue&quot;,return &quot;blue is sky the&quot;. Update (2015-02-12): For C programmers: Try to solve it in-place in O(1) space. Clarification: What constitutes a word? A sequence of non-space characters constitutes a word. Could the input string contain leading or trailing spaces? Yes. However, your reversed string should not contain leading or trailing spaces. How about multiple spaces between two words? Reduce them to a single space in the reversed string. æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 17ï¼Œ 2017 123456789101112131415161718192021class Solution &#123;public: void reverseWords(string &amp;s) &#123; if(s.empty()) return; reverse(s.begin(), s.end()); int start = 0; int i = 0; for(; i&lt;s.size(); i++)&#123; if(s[i]!=' ')&#123; if(start!=0) s[start++] = ' '; int j = i; while(j&lt;s.size() &amp;&amp; s[j]!=' ') s[start++] = s[j++]; reverse(s.begin()+start-(j-i), s.begin()+start); i = j; &#125; &#125; // s.erase(s.begin()+start) åªä¼šåˆ é™¤æŒ‡å®šç‚¹çš„å­—ç¬¦ s.erase(s.begin()+start, s.end()); return; &#125;&#125;; 9ms, 28.03%, October 14, 2016 https://discuss.leetcode.com/topic/3298/in-place-simple-solution First, reverse the whole string, then reverse each word. æœ‰ç–‘é—®ï¼Œä¸ºä½•æœ€åŽä½¿ç”¨eraseï¼ŒåŒæ—¶ä¸­é—´ä¸ºä½•s[storeIndex++]=s[j++]? 1234567891011121314151617class Solution &#123;public: void reverseWords(string &amp;s) &#123; reverse(s.begin(), s.end()); int storeIndex = 0; for(int i=0; i&lt;s.size(); i++)&#123; if(s[i] != &apos; &apos;)&#123; if(storeIndex!=0) s[storeIndex++] = &apos; &apos;; int j = i; while(j &lt; s.size() &amp;&amp; s[j] != &apos; &apos;) s[storeIndex++] = s[j++]; reverse(s.begin()+storeIndex-(j-i), s.begin()+storeIndex); i = j; &#125; &#125; s.erase(s.begin()+storeIndex, s.end()); &#125;&#125;; https://discuss.leetcode.com/topic/5319/c-solution-in-place-runtime-o-n-memory-o-1 The idea is to ignore the extra spaces, reverse words one by one and reverse the whole string in the end.I think for the interview it is good to show that substr or istringstream can be used too.The idea is taken from here 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: // function to reverse any part of string from i to j (just one word or entire string) void reverseword(string &amp;s, int i, int j)&#123; while(i&lt;j)&#123; char t=s[i]; s[i++]=s[j]; s[j--]=t; &#125; &#125; void reverseWords(string &amp;s) &#123; int i=0, j=0; int l=0; int len=s.length(); int wordcount=0; while(true)&#123; while(i&lt;len &amp;&amp; s[i] == &apos; &apos;) i++; // skip spaces in front of the word if(i==len) break; if(wordcount) s[j++]=&apos; &apos;; l=j; while(i&lt;len &amp;&amp; s[i] != &apos; &apos;) &#123;s[j]=s[i]; j++; i++;&#125; reverseword(s,l,j-1); // reverse word in place wordcount++; &#125; s.resize(j); // resize result string reverseword(s,0,j-1); // reverse whole string &#125;&#125;; https://discuss.leetcode.com/topic/3087/accepted-simple-cpp-code-in-just-a-few-lines Accepted simple cpp code in just a few lines 1234567891011121314151617class Solution &#123;public: void reverseWords(string &amp;s) &#123; string result; int pos = 0; for (int i = 0; i &lt; s.size(); i ++)&#123; if (s[i] == &apos; &apos;)&#123; if (i &gt; pos ) result = s.substr(pos,i-pos)+ &quot; &quot; + result ; pos = i + 1; &#125; else if (i == s.size()-1) result = s.substr(pos,s.size()-pos)+&quot; &quot;+result; &#125; s = result.substr(0,result.size()-1) ; &#125;&#125;; https://discuss.leetcode.com/topic/10199/5-lines-c-using-stringstream 5 lines C++ using 1234567void reverseWords(string &amp;s) &#123; istringstream is(s); string tmp; is &gt;&gt; s; while(is &gt;&gt; tmp) s = tmp + &quot; &quot; + s; if(s[0] == &apos; &apos;) s = &quot;&quot;;&#125; javahttps://discuss.leetcode.com/topic/2742/my-accepted-java-solution Iâ€™m splitting on the regex for one-or-more whitespace, this takes care of multiple spaces/tabs/newlines/etc in the input. Since the input could have leading/trailing whitespace, which would result in empty matches, I first trim the input string. Now there could be three possibilities: The input is empty: â€œâ€, parts will contain [â€œâ€]. The for loop is skipped and â€œâ€ + â€œâ€ is returned. The input contains only one part: â€œaâ€, parts will contain [â€œaâ€]. The for loop is skipped and â€œâ€ + â€œaâ€ is returned. The input contains multiple parts: â€œa b câ€, reverse the order of all but the first part: â€œc b â€œ in the for loop and return â€œc b â€œ + â€œaâ€. Obviously this is not the fastest or most memory efficient way to solve the problem, but optimizations should only be done when they are needed. Readable code is usually more important than efficient code. How to make it efficient? Use a StringBuilder to concatenate the string parts, instead of concatenating strings directly. This will (I assume) build something like a linked-list of string parts, and only allocate the new string when you need it, instead of on each concatenation. Iterate over the string, instead of using trim/split. Store the index of the last character in the word, when you find the first character, copy the substring to the output string. Instead of using substring, insert the word-characters directly in the StringBuilder. Assuming theyâ€™re using a linked-list or tree, this could be a whole last faster. 12345678910public class Solution &#123; public String reverseWords(String s) &#123; String[] parts = s.trim().split(&quot;\\s+&quot;); String out = &quot;&quot;; for (int i = parts.length - 1; i &gt; 0; i--) &#123; out += parts[i] + &quot; &quot;; &#125; return out + parts[0]; &#125;&#125; https://discuss.leetcode.com/topic/18189/clean-java-two-pointers-solution-no-trim-no-split-no-stringbuilder Clean Java two-pointers solution (no trim( ), no split( ), no StringBuilder) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Solution &#123; public String reverseWords(String s) &#123; if (s == null) return null; char[] a = s.toCharArray(); int n = a.length; // step 1. reverse the whole string reverse(a, 0, n - 1); // step 2. reverse each word reverseWords(a, n); // step 3. clean up spaces return cleanSpaces(a, n); &#125; void reverseWords(char[] a, int n) &#123; int i = 0, j = 0; while (i &lt; n) &#123; while (i &lt; j || i &lt; n &amp;&amp; a[i] == &apos; &apos;) i++; // skip spaces while (j &lt; i || j &lt; n &amp;&amp; a[j] != &apos; &apos;) j++; // skip non spaces reverse(a, i, j - 1); // reverse the word &#125; &#125; // trim leading, trailing and multiple spaces String cleanSpaces(char[] a, int n) &#123; int i = 0, j = 0; while (j &lt; n) &#123; while (j &lt; n &amp;&amp; a[j] == &apos; &apos;) j++; // skip spaces while (j &lt; n &amp;&amp; a[j] != &apos; &apos;) a[i++] = a[j++]; // keep non spaces while (j &lt; n &amp;&amp; a[j] == &apos; &apos;) j++; // skip spaces if (j &lt; n) a[i++] = &apos; &apos;; // keep only one space &#125; return new String(a).substring(0, i); &#125; // reverse a[] from a[i] to a[j] private void reverse(char[] a, int i, int j) &#123; while (i &lt; j) &#123; char t = a[i]; a[i++] = a[j]; a[j--] = t; &#125; &#125; &#125; https://discuss.leetcode.com/topic/11785/java-3-line-builtin-solution Java 3-line builtin solution 12345public String reverseWords(String s) &#123; String[] words = s.trim().split(&quot; +&quot;); Collections.reverse(Arrays.asList(words)); return String.join(&quot; &quot;, words);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[150. Evaluate Reverse Polish Notation]]></title>
    <url>%2Fp%2F37aff2ee%2F</url>
    <content type="text"><![CDATA[26.4% Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. 123Some examples: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] -&gt; ((2 + 1) * 3) -&gt; 9 [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] -&gt; (4 + (13 / 5)) -&gt; 6 https://discuss.leetcode.com/topic/1323/6-132-0-or-1 6/ï¼ˆ-132ï¼‰= 0 or -1 when I test [â€œ10â€,â€6â€,â€9â€,â€3â€,â€+â€,â€-11â€,â€â€,â€/â€œ,â€â€,â€17â€,â€+â€,â€5â€,â€+â€], in this program, the result I got is 12, I think I am right. Because when I calculate 6/(-132) = -1, not 0, so i think the result is 12 not 22. Accepted C++ recursive solution (56 ms) with explanation. Simplest possible? Algorithm: pop string from the end of the vector if itâ€™s number, just return it if itâ€™s operation, call function recursively for 2nd operand and 1st 12345678910111213int evalRPN(vector&lt;string&gt; &amp;n) &#123;string s = n.back(); n.pop_back();if ( s== &quot;&quot; || s==&quot;/&quot; || s==&quot;+&quot; || s == &quot;-&quot; )&#123;int r2 = evalRPN(n);int r1 = evalRPN(n);if ( s==&quot;&quot;) return r1*r2;if ( s==&quot;/&quot;) return r1/r2;if ( s==&quot;+&quot;) return r1+r2;if ( s==&quot;-&quot;) return r1-r2;&#125;elsereturn atoi(s.c_str());&#125; https://discuss.leetcode.com/topic/38178/fancy-c-lambda-expression-solution Fancy C++ lambda expression solution 123456789101112131415161718192021222324class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; unordered_map&lt;string, function&lt;int (int, int) &gt; &gt; map = &#123; &#123; &quot;+&quot; , [] (int a, int b) &#123; return a + b; &#125; &#125;, &#123; &quot;-&quot; , [] (int a, int b) &#123; return a - b; &#125; &#125;, &#123; &quot;*&quot; , [] (int a, int b) &#123; return a * b; &#125; &#125;, &#123; &quot;/&quot; , [] (int a, int b) &#123; return a / b; &#125; &#125; &#125;; std::stack&lt;int&gt; stack; for (string&amp; s : tokens) &#123; if (!map.count(s)) &#123; stack.push(stoi(s)); &#125; else &#123; int op1 = stack.top(); stack.pop(); int op2 = stack.top(); stack.pop(); stack.push(map[s](op2, op1)); &#125; &#125; return stack.top(); &#125;&#125;; https://discuss.leetcode.com/topic/21965/python-solution-with-comments-don-t-use-eval-function Python solution with comments (donâ€™t use eval() function). 12345678910111213141516171819202122def evalRPN(self, tokens): stack = [] for t in tokens: if t not in [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;]: stack.append(int(t)) else: r, l = stack.pop(), stack.pop() if t == &quot;+&quot;: stack.append(l+r) elif t == &quot;-&quot;: stack.append(l-r) elif t == &quot;*&quot;: stack.append(l*r) else: # here take care of the case like &quot;1/-22&quot;, # in Python 2.x, it returns -1, while in # Leetcode it should return 0 if l*r &lt; 0 and l % r != 0: stack.append(l/r+1) else: stack.append(l/r) return stack.pop() https://discuss.leetcode.com/topic/15344/a-simple-python-solution-o-n-72ms A simple Python solution - O(n) 72ms 123456789101112131415161718192021222324class Solution: # @param &#123;string[]&#125; tokens # @return &#123;integer&#125; def __init__(self): self.operators = &#123; &apos;+&apos;: lambda y, x: x + y, &apos;-&apos;: lambda y, x: x - y, &apos;*&apos;: lambda y, x: x * y, &apos;/&apos;: lambda y, x: int(operator.truediv(x, y)) &#125; def evalRPN(self, tokens): if not tokens: return 0 stack = [] for token in tokens: if token in self.operators: stack.append(self.operators[token](stack.pop(), stack.pop())) else: stack.append(int(token)) return stack[0]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[149. Max Points on a Line]]></title>
    <url>%2Fp%2F138e238c%2F</url>
    <content type="text"><![CDATA[15.5% https://leetcode.com/problems/max-points-on-a-line/#/description Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. https://discuss.leetcode.com/topic/6028/sharing-my-simple-solution-with-explanation Sharing my simple solution with explanation 1234567891011121314151617181920212223242526int maxPoints(vector&lt;Point&gt; &amp;points) &#123; int result = 0; for(int i = 0; i &lt; points.size(); i++)&#123; int samePoint = 1; unordered_map&lt;double, int&gt; map; for(int j = i + 1; j &lt; points.size(); j++)&#123; if(points[i].x == points[j].x &amp;&amp; points[i].y == points[j].y)&#123; samePoint++; &#125; else if(points[i].x == points[j].x)&#123; map[INT_MAX]++; &#125; else&#123; double slope = double(points[i].y - points[j].y) / double(points[i].x - points[j].x); map[slope]++; &#125; &#125; int localMax = 0; for(auto it = map.begin(); it != map.end(); it++)&#123; localMax = max(localMax, it-&gt;second); &#125; localMax += samePoint; result = max(result, localMax); &#125; return result;&#125; First, letâ€™s talk about mathematics. How to determine if three points are on the same line? The answer is to see if slopes of arbitrary two pairs are the same. Second, letâ€™s see what the minimum time complexity can be. Definitely, O(n^2). Itâ€™s because you have to calculate all slopes between any two points. Then letâ€™s go back to the solution of this problem. In order to make this discussion simpler, letâ€™s pick a random point A as an example. Given point A, we need to calculate all slopes between A and other points. There will be three cases: Some other point is the same as point A. Some other point has the same x coordinate as point A, which will result to a positive infinite slope. General case. We can calculate slope. We can store all slopes in a hash table. And we find which slope shows up mostly. Then add the number of same points to it. Then we know the maximum number of points on the same line for point A. We can do the same thing to point B, point Câ€¦ Finally, just return the maximum result among point A, point B, point Câ€¦ https://discuss.leetcode.com/topic/2709/c-o-n-2-solution-for-your-reference Hint by @stellari â€œFor each point pi, calculate the slope of each line it forms with all other points with greater indices, i.e. pi+1, pi+2, â€¦, and use a map to record how many lines have the same slope (If two lines have the same slope and share a common point, then the two lines must be the same one). By doing so, you can easily find how many points are on the same line that ends at pi in O(n). Thus the amortized running time of the whole algorithm is O(n^2).â€ In order to avoid using double type(the slope k) as map key, I used pair (int a, int b) as the key where a=pj.x-pi.x, b=pj.y-pi.y, and k=b/a. Using greatest common divider of a and b to divide both a, b ensures that lines with same slope have the same key. I also handled two special cases: (1) when two points are on a vertical line (2) when two points are the same. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: int maxPoints(vector&lt;Point&gt; &amp;points) &#123; if(points.size()&lt;2) return points.size(); int result=0; for(int i=0; i&lt;points.size(); i++) &#123; map&lt;pair&lt;int, int&gt;, int&gt; lines; int localmax=0, overlap=0, vertical=0; for(int j=i+1; j&lt;points.size(); j++) &#123; if(points[j].x==points[i].x &amp;&amp; points[j].y==points[i].y) &#123; overlap++; continue; &#125; else if(points[j].x==points[i].x) vertical++; else &#123; int a=points[j].x-points[i].x, b=points[j].y-points[i].y; int gcd=GCD(a, b); a/=gcd; b/=gcd; lines[make_pair(a, b)]++; localmax=max(lines[make_pair(a, b)], localmax); &#125; localmax=max(vertical, localmax); &#125; result=max(result, localmax+overlap+1); &#125; return result; &#125;private: int GCD(int a, int b) &#123; if(b==0) return a; else return GCD(b, a%b); &#125;&#125;; https://discuss.leetcode.com/topic/12877/20-line-c-o-n-2-hashing-solution The idea is straight forward. Calculate each slope between two points and handle two special cases: 1. vertical, 2. duplicate. 1234567891011121314151617181920212223242526class Solution &#123;public: int maxPoints(vector&lt;Point&gt;&amp; points) &#123; if(points.size()&lt;=2) return points.size(); int res=0; for(int i=0;i&lt;points.size()-1;i++) &#123; int numVertical=1,local=1,duplicate=0; unordered_map&lt;double,int&gt; map; for(int j=i+1;j&lt;points.size();j++) if(points[i].x==points[j].x) // special cases if(points[i].y==points[j].y) // duplicate duplicate++; else // vertical numVertical++; else &#123; double slope=(points[i].y-points[j].y)*1.0/(points[i].x-points[j].x); map[slope]==0?map[slope]=2:map[slope]++; local=max(local,map[slope]); &#125; local=max(local+duplicate,numVertical+duplicate); res=max(res,local); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/18447/16ms-28ms-c-solutions-with-explanations 16ms/28ms C++ Solutions with Explanations This problem has a naive idea, which is to traverse all possible pairs of two points and see how many other points fall in the line determined by them. This idea is of O(n^3) time complexity and will meet TLE. Well, letâ€™s focus on lines instead of pairs of points. Could we just find out how many points fall in all possible lines? The answer is yes. Remember that a line is determined by its slope and intercept. In fact, if two lines with the same slope share a common point, then they are just the same line. So to determine a line, we need its slope and a point. Now comes the idea to solve this problem. We start from a specific point p, and compute all the slopes of the lines between p and the remaining points. Then those with the same slopes will be the same line. We can find out the maximum number of points fall on a line containing p. We exhaust all possible pâ€™s and record the largest number we have seen. This number is just answer. Well, there are still two special cases to handle: Duplicate points: a pair of duplicate points give no determined line, so we just count the number of duplicates and add them to the result. Vertical lines: the slope of these lines is infinity mathematically. We simply set it to be INT_MAX in the following code. Now we have the following code, using an unordered_map&lt;float, int&gt; slopes to record how many points fall in the line of a specific slope and containing points[i]. Since all the operations of unordered_map is O(1), this code is of O(n^2) complexity. 12345678910111213141516171819202122232425class Solution &#123;public: int maxPoints(vector&lt;Point&gt;&amp; points) &#123; unordered_map&lt;float, int&gt; slopes; int maxp = 0, n = points.size(); for (int i = 0; i &lt; n; i++) &#123; slopes.clear(); int duplicate = 1; for (int j = i + 1; j &lt; n; j++) &#123; if (points[j].x == points[i].x &amp;&amp; points[j].y == points[i].y) &#123; duplicate++; continue; &#125; float slope = (points[j].x == points[i].x) ? INT_MAX : (float)(points[j].y - points[i].y) / (points[j].x - points[i].x); slopes[slope]++; &#125; maxp = max(maxp, duplicate); for (auto slope : slopes) if (slope.second + duplicate &gt; maxp) maxp = slope.second + duplicate; &#125; return maxp; &#125;&#125;; Well, since the representation of floating point numbers is sometimes inaccurate, we may use a more safer way to represent the slope (dy / dx), which is to record dx and dy in a pair&lt;int, int&gt;. However, once we use pair&lt;int, int&gt; for the key of the map, we cannot use an unordered_map since pair&lt;int, int&gt; is unhashable. We now change to map and the time complexity becomes O(n^2logn). Also, since dy = 4, dx = 2 and dy = 8, dx = 4 represents the same slope, we need to divide both of them by their gcd first. The code is as follows. The logic is the same of the one above, just introducing pair and gcd. 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public: int maxPoints(vector&lt;Point&gt;&amp; points) &#123; map&lt;pair&lt;int, int&gt;, int&gt; slopes; int maxp = 0, n = points.size(); for (int i = 0; i &lt; n; i++) &#123; slopes.clear(); int duplicate = 1; for (int j = i + 1; j &lt; n; j++) &#123; if (points[j].x == points[i].x &amp;&amp; points[j].y == points[i].y) &#123; duplicate++; continue; &#125; int dx = points[j].x - points[i].x; int dy = points[j].y - points[i].y; int dvs = gcd(dx, dy); slopes[make_pair(dx / dvs, dy / dvs)]++; &#125; maxp = max(maxp, duplicate); for (auto slope : slopes) if (slope.second + duplicate &gt; maxp) maxp = slope.second + duplicate; &#125; return maxp; &#125;private: int gcd(int num1, int num2) &#123; while (num2) &#123; int temp = num2; num2 = num1 % num2; num1 = temp; &#125; return num1; &#125;&#125;; https://discuss.leetcode.com/topic/21896/python-68-ms-code Python 68 ms code 1234567891011121314151617def maxPoints(self, points): l = len(points) m = 0 for i in range(l): dic = &#123;&apos;i&apos;: 1&#125; same = 0 for j in range(i+1, l): tx, ty = points[j].x, points[j].y if tx == points[i].x and ty == points[i].y: same += 1 continue if points[i].x == tx: slope = &apos;i&apos; else:slope = (points[i].y-ty) * 1.0 /(points[i].x-tx) if slope not in dic: dic[slope] = 1 dic[slope] += 1 m = max(m, max(dic.values()) + same)return m https://discuss.leetcode.com/topic/2979/a-java-solution-with-notes A line is determined by two factors,say y=ax+b If two points(x1,y1) (x2,y2) are on the same line(Of course). Consider the gap between two points. We have (y2-y1)=a(x2-x1),a=(y2-y1)/(x2-x1) a is a rational, b is canceled since b is a constant If a third point (x3,y3) are on the same line. So we must have y3=ax3+b Thus,(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a Since a is a rational, there exists y0 and x0, y0/x0=(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a So we can use y0&amp;x0 to track a line; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for a point. * class Point &#123; * int x; * int y; * Point() &#123; x = 0; y = 0; &#125; * Point(int a, int b) &#123; x = a; y = b; &#125; * &#125; */public class Solution&#123; public int maxPoints(Point[] points) &#123; if (points==null) return 0; if (points.length&lt;=2) return points.length; Map&lt;Integer,Map&lt;Integer,Integer&gt;&gt; map = new HashMap&lt;Integer,Map&lt;Integer,Integer&gt;&gt;(); int result=0; for (int i=0;i&lt;points.length;i++)&#123; map.clear(); int overlap=0,max=0; for (int j=i+1;j&lt;points.length;j++)&#123; int x=points[j].x-points[i].x; int y=points[j].y-points[i].y; if (x==0&amp;&amp;y==0)&#123; overlap++; continue; &#125; int gcd=generateGCD(x,y); if (gcd!=0)&#123; x/=gcd; y/=gcd; &#125; if (map.containsKey(x))&#123; if (map.get(x).containsKey(y))&#123; map.get(x).put(y, map.get(x).get(y)+1); &#125;else&#123; map.get(x).put(y, 1); &#125; &#125;else&#123; Map&lt;Integer,Integer&gt; m = new HashMap&lt;Integer,Integer&gt;(); m.put(y, 1); map.put(x, m); &#125; max=Math.max(max, map.get(x).get(y)); &#125; result=Math.max(result, max+overlap+1); &#125; return result; &#125; private int generateGCD(int a,int b)&#123; if (b==0) return a; else return generateGCD(b,a%b); &#125;&#125; https://discuss.leetcode.com/topic/24011/accepted-java-solution-easy-to-understand1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a point. * class Point &#123; * int x; * int y; * Point() &#123; x = 0; y = 0; &#125; * Point(int a, int b) &#123; x = a; y = b; &#125; * &#125; */public class Solution &#123; public int maxPoints(Point[] points) &#123; if(points.length &lt;= 0) return 0; if(points.length &lt;= 2) return points.length; int result = 0; for(int i = 0; i &lt; points.length; i++)&#123; HashMap&lt;Double, Integer&gt; hm = new HashMap&lt;Double, Integer&gt;(); int samex = 1; int samep = 0; for(int j = 0; j &lt; points.length; j++)&#123; if(j != i)&#123; if((points[j].x == points[i].x) &amp;&amp; (points[j].y == points[i].y))&#123; samep++; &#125; if(points[j].x == points[i].x)&#123; samex++; continue; &#125; double k = (double)(points[j].y - points[i].y) / (double)(points[j].x - points[i].x); if(hm.containsKey(k))&#123; hm.put(k,hm.get(k) + 1); &#125;else&#123; hm.put(k, 2); &#125; result = Math.max(result, hm.get(k) + samep); &#125; &#125; result = Math.max(result, samex); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>math</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[148. Sort List]]></title>
    <url>%2Fp%2F41f5a08%2F</url>
    <content type="text"><![CDATA[27.7% https://leetcode.com/problems/sort-list/?tab=Description Sort a linked list in O(n log n) time using constant space complexity. å½’å¹¶æŽ’åº å¾®ä¿¡é¢è¯•é¢˜ï¼šä½¿ç”¨å¿«é€ŸæŽ’åºï¼Œå¯¹é“¾è¡¨è¿›è¡ŒæŽ’åº æ–¹æ³•ä¸€ï¼š å½’å¹¶æŽ’åº https://discuss.leetcode.com/topic/17150/clean-and-short-merge-sort-solution-in-c Clean and short Merge sort Solution in c++ 12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* merge( ListNode* head1 , ListNode * head2)&#123; ListNode* d = new ListNode (0); // dummy node ListNode* e = d; while(head1||head2)&#123; if(head1 &amp;&amp; (!head2 || head1-&gt;val &lt;= head2 -&gt; val) )&#123; e=e-&gt;next= head1 ; head1 = head1 -&gt; next; &#125; if(head2 &amp;&amp; (!head1 || head2-&gt;val &lt; head1 -&gt; val) )&#123; e=e-&gt;next= head2 ; head2 = head2 -&gt; next; &#125; &#125; e-&gt;next = NULL; return d-&gt;next; &#125; ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* slow = head; ListNode* fast =head-&gt;next; while(fast &amp;&amp; fast-&gt;next)&#123; // to find middle node fast= fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; ListNode* headb = slow-&gt;next; // headb is start of 2nd half of list slow-&gt;next = NULL; return merge(sortList(head) , sortList(headb)); &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* fast = head, *slow = head; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; ListNode* tmp = slow-&gt;next; slow-&gt;next = NULL; ListNode* head1 = sortList(head); ListNode* head2 = sortList(tmp); ListNode* node = merge(head1, head2); return node; &#125; ListNode* merge(ListNode* head1, ListNode* head2)&#123; if(head1==NULL) return head2; if(head2==NULL) return head1; if(head1-&gt;val&lt;=head2-&gt;val)&#123; head1-&gt;next = merge(head1-&gt;next, head2); return head1; &#125;else&#123; head2-&gt;next = merge(head1, head2-&gt;next); return head2; &#125; &#125;&#125;; æ–¹æ³•äºŒï¼š ä½¿ç”¨147é¢˜çš„æ’å…¥æŽ’åºï¼Œæ•ˆçŽ‡O(n^2)ä¸èƒ½æ»¡è¶³è¦æ±‚ è¶…æ—¶ æ–¹æ³•ä¸‰ï¼š å½’å¹¶æŽ’åº æˆ‘çš„ä»£ç å®žçŽ°: æœ‰bug 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* slow = head, *fast = head; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; fast = slow-&gt;next; slow-&gt;next = nullptr; sortList(head); sortList(fast); return merge(head, fast); &#125; ListNode* merge(ListNode* l1, ListNode* l2)&#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = merge(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = merge(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/10382/bottom-to-up-not-recurring-with-o-1-space-complextity-and-o-nlgn-time-complextity Bottom-to-up(not recurring) with o(1) space complextity and o(nlgn) time complextity this problem can be easily solved using recurrence and divide-and-conquer. But it consumes program stack to store the recurring function stack frame, actually it consumes o(lgn) space complexity. Recursion use up-to-bottom strategy , why not try the opposite wayâ€“bottom-to-up, luckily it works, it only consumes 0(1) space complexity and o(nlgn) time complextity. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Merge sort use bottom-up policy, * so Space Complexity is O(1) * Time Complexity is O(NlgN) * stable sort*/class Solution &#123;public: ListNode *sortList(ListNode *head) &#123; if(!head || !(head-&gt;next)) return head; //get the linked list&apos;s length ListNode* cur = head; int length = 0; while(cur)&#123; length++; cur = cur-&gt;next; &#125; ListNode dummy(0); dummy.next = head; ListNode *left, *right, *tail; for(int step = 1; step &lt; length; step &lt;&lt;= 1)&#123; cur = dummy.next; tail = &amp;dummy; while(cur)&#123; left = cur; right = split(left, step); cur = split(right,step); tail = merge(left, right, tail); &#125; &#125; return dummy.next; &#125;private: /** * Divide the linked list into two lists, * while the first list contains first n ndoes * return the second list&apos;s head */ ListNode* split(ListNode *head, int n)&#123; //if(!head) return NULL; for(int i = 1; head &amp;&amp; i &lt; n; i++) head = head-&gt;next; if(!head) return NULL; ListNode *second = head-&gt;next; head-&gt;next = NULL; return second; &#125; /** * merge the two sorted linked list l1 and l2, * then append the merged sorted linked list to the node head * return the tail of the merged sorted linked list */ ListNode* merge(ListNode* l1, ListNode* l2, ListNode* head)&#123; ListNode *cur = head; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &gt; l2-&gt;val)&#123; cur-&gt;next = l2; cur = l2; l2 = l2-&gt;next; &#125; else&#123; cur-&gt;next = l1; cur = l1; l1 = l1-&gt;next; &#125; &#125; cur-&gt;next = (l1 ? l1 : l2); while(cur-&gt;next) cur = cur-&gt;next; return cur; &#125;&#125;; https://discuss.leetcode.com/topic/3085/my-o-n-log-n-time-o-1-space-solution My O(n log n) time, O(1) space solution Nice problem. I use a non-recurisve way to write merge sort. For example, the size of ListNode is 8, Round #1 block_size = 1 (a1, a2), (a3, a4), (a5, a6), (a7, a8) Compare a1 with a2, a3 with a4 â€¦ Round #2 block_size = 2 (a1, a2, a3, a4), (a5, a6, a7, a8) merge two sorted arrays (a1, a2) and (a3, a4), then merge tow sorted arrays(a5, a6) and (a7, a8) Round #3 block_size = 4 (a1, a2, a3, a4, a5, a6, a7, a8) merge two sorted arrays (a1, a2, a3, a4), and (a5, a6, a7, a8) No need for round #4 cause block_size = 8 &gt;= n = 8 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: int count_size(ListNode *node)&#123; int n = 0; while (node != NULL)&#123; node = node-&gt;next; ++n; &#125; return n; &#125; ListNode *sortList(ListNode *head) &#123; int block_size = 1, n = count_size(head), iter = 0, i = 0, a = 0, b = 0; ListNode virtual_head(0); ListNode *last = NULL, *it = NULL, *A = NULL, *B = NULL, *tmp = NULL; virtual_head.next = head; while (block_size &lt; n)&#123; iter = 0; last = &amp;virtual_head; it = virtual_head.next; while (iter &lt; n)&#123; a = min(n - iter, block_size); b = min(n - iter - a, block_size); A = it; if (b != 0)&#123; for (i = 0; i &lt; a - 1; ++i) it = it-&gt;next; B = it-&gt;next; it-&gt;next = NULL; it = B; for (i = 0; i &lt; b - 1; ++i) it = it-&gt;next; tmp = it-&gt;next; it-&gt;next = NULL; it = tmp; &#125; while (A || B)&#123; if (B == NULL || (A != NULL &amp;&amp; A-&gt;val &lt;= B-&gt;val))&#123; last-&gt;next = A; last = last-&gt;next; A = A-&gt;next; &#125; else &#123; last-&gt;next = B; last = last-&gt;next; B = B-&gt;next; &#125; &#125; last-&gt;next = NULL; iter += a + b; &#125; block_size &lt;&lt;= 1; &#125; return virtual_head.next; &#125;&#125;; python https://discuss.leetcode.com/topic/30407/clean-python-code Clean python code 12345678910111213141516171819202122class Solution(object): def merge(self, h1, h2): dummy = tail = ListNode(None) while h1 and h2: if h1.val &lt; h2.val: tail.next, tail, h1 = h1, h1, h1.next else: tail.next, tail, h2 = h2, h2, h2.next tail.next = h1 or h2 return dummy.next def sortList(self, head): if not head or not head.next: return head pre, slow, fast = None, head, head while fast and fast.next: pre, slow, fast = slow, slow.next, fast.next.next pre.next = None return self.merge(*map(self.sortList, (head, slow))) java https://discuss.leetcode.com/topic/18100/java-merge-sort-solution Java merge sort solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public ListNode sortList(ListNode head) &#123; if (head == null || head.next == null) return head; // step 1. cut the list to two halves ListNode prev = null, slow = head, fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; prev = slow; slow = slow.next; fast = fast.next.next; &#125; prev.next = null; // step 2. sort each half ListNode l1 = sortList(head); ListNode l2 = sortList(slow); // step 3. merge l1 and l2 return merge(l1, l2); &#125; ListNode merge(ListNode l1, ListNode l2) &#123; ListNode l = new ListNode(0), p = l; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt; l2.val) &#123; p.next = l1; l1 = l1.next; &#125; else &#123; p.next = l2; l2 = l2.next; &#125; p = p.next; &#125; if (l1 != null) p.next = l1; if (l2 != null) p.next = l2; return l.next; &#125;&#125; https://discuss.leetcode.com/topic/643/i-have-a-pretty-good-mergesort-method-can-anyone-speed-up-the-run-time-or-reduce-the-memory-usage I have a pretty good MergeSort method. Can anyone speed up the run time or reduce the memory usage? 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode sortList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode f = head.next.next; ListNode p = head; while (f != null &amp;&amp; f.next != null) &#123; p = p.next; f = f.next.next; &#125; ListNode h2 = sortList(p.next); p.next = null; return merge(sortList(head), h2); &#125; public ListNode merge(ListNode h1, ListNode h2) &#123; ListNode hn = new ListNode(Integer.MIN_VALUE); ListNode c = hn; while (h1 != null &amp;&amp; h2 != null) &#123; if (h1.val &lt; h2.val) &#123; c.next = h1; h1 = h1.next; &#125; else &#123; c.next = h2; h2 = h2.next; &#125; c = c.next; &#125; if (h1 != null) c.next = h1; if (h2 != null) c.next = h2; return hn.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[147. Insertion Sort List]]></title>
    <url>%2Fp%2Fcd2ad8e1%2F</url>
    <content type="text"><![CDATA[32.2% Sort a linked list using insertion sort. æ–¹æ³•ä¸€ï¼š å¸¸è§„çš„æ’å…¥æŽ’åºï¼Œæ”¹æˆé’ˆå¯¹é“¾è¡¨æŽ’åºã€‚ æ’å…¥æŽ’åºï¼Œæ¯æ¬¡ä»ŽåŽå‘å‰èµ°ï¼Œè¿™é‡Œæ¯æ¬¡ä»Žå‰å‘åŽèµ°ï¼Œæ‰¾åˆ°æ’å…¥ä½ç½®ã€‚å› ä¸ºé“¾è¡¨æ’å…¥æ—¶O(1)ç©ºé—´ï¼Œæ‰€ä»¥ä¸€æ ·çš„ã€‚ æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 11th, 2017 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(head==nullptr || head-&gt;next==nullptr) return head; ListNode* dummy = new ListNode(-1); ListNode* p1 = head, *p2 = dummy, *p3; while(p1!=nullptr)&#123; p2 = dummy; while(p2-&gt;next!=nullptr &amp;&amp; p2-&gt;next-&gt;val &lt;= p1-&gt;val)&#123; p2 = p2-&gt;next; &#125; p3 = p1-&gt;next; p1-&gt;next = p2-&gt;next; p2-&gt;next = p1; p1 = p3; &#125; return dummy-&gt;next; &#125;&#125;; my code æ–°å»ºä¸€ä¸ªæ–°èŠ‚ç‚¹ï¼ŒListNode* dummy = new ListNode(0); 12345678910111213141516171819202122class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(head==NULL || head-&gt;next==NULL) return head; ListNode* cur; cur=head-&gt;next; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; head-&gt;next = NULL; while(cur!=NULL)&#123; ListNode* tmp = cur-&gt;next; head = dummy; while(head-&gt;next!=NULL &amp;&amp; head-&gt;next-&gt;val &lt; cur-&gt;val) head = head-&gt;next; cur-&gt;next = head-&gt;next; head-&gt;next = cur; cur = tmp; &#125; return dummy-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/8570/an-easy-and-clear-way-to-sort-o-1-space An easy and clear way to sort ( O(1) space ) 12345678910111213141516171819202122232425public ListNode insertionSortList(ListNode head) &#123; if( head == null )&#123; return head; &#125; ListNode helper = new ListNode(0); //new starter of the sorted list ListNode cur = head; //the node will be inserted ListNode pre = helper; //insert node between pre and pre.next ListNode next = null; //the next node will be inserted //not the end of input list while( cur != null )&#123; next = cur.next; //find the right place to insert while( pre.next != null &amp;&amp; pre.next.val &lt; cur.val )&#123; pre = pre.next; &#125; //insert between pre and pre.next cur.next = pre.next; pre.next = cur; pre = helper; cur = next; &#125; return helper.next; &#125; https://discuss.leetcode.com/topic/14916/explained-c-solution-24ms Explained C++ solution (24ms) Well, life gets difficult pretty soon whenever the same operation on array is transferred to linked list. First, a quick recap of insertion sort: Start from the second element (simply a[1] in array and the annoying head -&gt; next -&gt; val in linked list), each time when we see a node with val smaller than its previous node, we scan from the head and find the position that the current node should be inserted. Since a node may be inserted before head, we create a new_head that points to head. The insertion operation, however, is a little easier for linked list. Now comes the code: 1234567891011121314151617181920212223242526class Solution &#123; public: ListNode* insertionSortList(ListNode* head) &#123; ListNode* new_head = new ListNode(0); new_head -&gt; next = head; ListNode* pre = new_head; ListNode* cur = head; while (cur) &#123; if (cur -&gt; next &amp;&amp; cur -&gt; next -&gt; val &lt; cur -&gt; val) &#123; while (pre -&gt; next &amp;&amp; pre -&gt; next -&gt; val &lt; cur -&gt; next -&gt; val) pre = pre -&gt; next; /* Insert cur -&gt; next after pre.*/ ListNode* temp = pre -&gt; next; pre -&gt; next = cur -&gt; next; cur -&gt; next = cur -&gt; next -&gt; next; pre -&gt; next -&gt; next = temp; /* Move pre back to new_head. */ pre = new_head; &#125; else cur = cur -&gt; next; &#125; ListNode* res = new_head -&gt; next; delete new_head; return res; &#125;&#125;; https://discuss.leetcode.com/topic/1855/accepted-solution-using-java Accepted Solution using JAVA 12345678910111213141516public ListNode insertionSortList(ListNode head) &#123; ListNode helper=new ListNode(0); ListNode pre=helper; ListNode current=head; while(current!=null) &#123; pre=helper; while(pre.next!=null&amp;&amp;pre.next.val&lt;current.val) &#123; pre=pre.next; &#125; ListNode next=current.next; current.next=pre.next; pre.next=current; current=next; &#125; return helper.next;&#125; https://discuss.leetcode.com/topic/4932/python-time-limit-is-too-tight Python time limit is too tight I have basically the same code in python and java (see below). python got TLE, but java was accepted. I propose to relax the python time limit a little bit. Python 12345678910111213141516171819class Solution:# @param head, a ListNode# @return a ListNodedef insertionSortList(self, head): srt = None while head: node = head head = head.next node.next = None srt = self.insertTo(srt, node) return srt def insertTo(self, head, node): node.next = head head = node while node.next and node.val &gt; node.next.val: node.val, node.next.val = node.next.val, node.val node = node.next return head java 123456789101112131415161718192021222324public class Solution &#123; public ListNode insertionSortList(ListNode head) &#123; ListNode srt = null; while (head != null) &#123; ListNode node = head; head = head.next; node.next = null; srt = insertTo(srt, node); &#125; return srt; &#125; public ListNode insertTo(ListNode head, ListNode node) &#123; node.next = head; head = node; while (node.next != null &amp;&amp; node.val &gt; node.next.val) &#123; node.val = node.val ^ node.next.val; node.next.val = node.val ^ node.next.val; node.val = node.val ^ node.next.val; node = node.next; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[146. LRU Cache]]></title>
    <url>%2Fp%2F5f411b29%2F</url>
    <content type="text"><![CDATA[16.7% Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up: Could you do both operations in O(1) time complexity? 12345678910111213Example:LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 https://discuss.leetcode.com/topic/6812/c-11-code-74ms-hash-table-list C++11 code 74ms - Hash table + List There is a similar example in Java, but I wanted to share my solution using the new C++11 unordered_map and a list. The good thing about lists is that iterators are never invalidated by modifiers (unless erasing the element itself). This way, we can store the iterator to the corresponding LRU queue in the values of the hash map. Since using erase on a list with an iterator takes constant time, all operations of the LRU cache run in constant time. 12345678910111213141516171819202122232425262728293031323334353637383940class LRUCache &#123;public: LRUCache(int capacity) : _capacity(capacity) &#123;&#125; int get(int key) &#123; auto it = cache.find(key); if (it == cache.end()) return -1; touch(it); return it-&gt;second.first; &#125; void set(int key, int value) &#123; auto it = cache.find(key); if (it != cache.end()) touch(it); else &#123; if (cache.size() == _capacity) &#123; cache.erase(used.back()); used.pop_back(); &#125; used.push_front(key); &#125; cache[key] = &#123; value, used.begin() &#125;; &#125; private: typedef list&lt;int&gt; LI; typedef pair&lt;int, LI::iterator&gt; PII; typedef unordered_map&lt;int, PII&gt; HIPII; void touch(HIPII::iterator it) &#123; int key = it-&gt;first; used.erase(it-&gt;second.second); used.push_front(key); it-&gt;second.second = used.begin(); &#125; HIPII cache; LI used; int _capacity;&#125;; https://discuss.leetcode.com/topic/25792/clean-short-standard-c-solution-not-writing-c-in-c-like-all-other-lengthy-ones Clean Short Standard C++ solution â€“ NOT writing C in C++ like all other lengthy ones I saw so many (or all) â€œC++â€ solutions posted here were not written in C++ at all. For those 200-line solutions, I donâ€™t see the point in implementing a double-linked-list by themselves. If you are writing C++, please use STL! The code below is way cleaner, shorter and easier to read than most other C++ solutions posted here.And above all, it was written in a standard C++ way. 1234567891011121314151617181920212223242526272829303132class LRUCache&#123; size_t m_capacity; unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; m_map; //m_map_iter-&gt;first: key, m_map_iter-&gt;second: list iterator; list&lt;pair&lt;int, int&gt;&gt; m_list; //m_list_iter-&gt;first: key, m_list_iter-&gt;second: value;public: LRUCache(size_t capacity):m_capacity(capacity) &#123; &#125; int get(int key) &#123; auto found_iter = m_map.find(key); if (found_iter == m_map.end()) //key doesn&apos;t exist return -1; m_list.splice(m_list.begin(), m_list, found_iter-&gt;second); //move the node corresponding to key to front return found_iter-&gt;second-&gt;second; //return value of the node &#125; void set(int key, int value) &#123; auto found_iter = m_map.find(key); if (found_iter != m_map.end()) //key exists &#123; m_list.splice(m_list.begin(), m_list, found_iter-&gt;second); //move the node corresponding to key to front found_iter-&gt;second-&gt;second = value; //update value of the node return; &#125; if (m_map.size() == m_capacity) //reached capacity &#123; int key_to_del = m_list.back().first; m_list.pop_back(); //remove node in list; m_map.erase(key_to_del); //remove key in map &#125; m_list.emplace_front(key, value); //create new node in list m_map[key] = m_list.begin(); //create correspondence between key and node &#125;&#125;; https://discuss.leetcode.com/topic/4324/accepted-c-solution-296-ms Accepted C++ solution, 296 ms Solution is unusual - combination of 2 data structures - hash map and linked list.Algorithm: hash map holds iterators to linked list linked list holds key and value, key to access hash map items when item is accessed, itâ€™s promoted - moved to the tail of the list - O(1) operation when item should be removed, we remove head of the list - O(1) operation when item is not promoted long time, itâ€™s moved to the head of the list automatically get() - O(1) performance, set() - O(1) performance { 123456789101112131415161718192021222324252627282930313233343536373839404142434445class LRUCache&#123;private: struct item_t&#123; int key, val; item_t(int k, int v) :key(k), val(v)&#123;&#125; &#125;; typedef list&lt;item_t&gt; list_t; typedef unordered_map&lt;int, list_t::iterator&gt; map_t; map_t m_map; list_t m_list; int m_capacity;public: LRUCache(int capacity) : m_capacity(capacity) &#123; &#125; int get(int key) &#123; map_t::iterator i = m_map.find(key); if (i == m_map.end()) return -1; m_map[key] = promote(i-&gt;second); return m_map[key]-&gt;val; &#125; void set(int key, int value) &#123; map_t::iterator i = m_map.find(key); if (i != m_map.end())&#123; m_map[key] = promote(i-&gt;second); m_map[key]-&gt;val = value; &#125; else &#123; if (m_map.size() &lt; m_capacity)&#123; m_map[key] = m_list.insert(m_list.end(), item_t(key, value)); &#125; else &#123; m_map.erase(m_list.front().key); m_list.pop_front(); m_map[key] = m_list.insert(m_list.end(), item_t(key, value)); &#125; &#125; &#125; list_t::iterator promote(list_t::iterator i)&#123; list_t::iterator inew = m_list.insert(m_list.end(), *i); m_list.erase(i); return inew; &#125;&#125;;&#125; btw LeetCode, it was really hard to insert this code, after pressing {} button, class was improperly formatted. I inserted additional braces around class. https://discuss.leetcode.com/topic/12262/o-1-unordered_map-list-splice O(1) unordered_map + list + splice 12345678910111213141516171819202122232425262728293031323334353637383940class LRUCache &#123;private: // A list of (key, value) pairs list&lt;pair&lt;int, int&gt;&gt; items; // Map items to iterators (pointers) to list nodes unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; cache; // The capacity of the list int capacity;public: LRUCache(int capacity) : capacity(capacity) &#123;&#125; int get(int key) &#123; // If key is not found in hash map, return -1 if (cache.find(key) == cache.end()) return -1; // Move the (key, value) pair to the beginning of the list items.splice(items.begin(), items, cache[key]); return cache[key]-&gt;second; &#125; void set(int key, int value) &#123; // The key is not in the hash table if (cache.find(key) == cache.end()) &#123; // If the cache is full then delete the least recently // used item, which is at the end of the list if (items.size() == capacity) &#123; cache.erase(items.back().first); items.pop_back(); &#125; items.push_front(make_pair(key, value)); cache[key] = items.begin(); &#125; else &#123; // Update the value associated with the key cache[key]-&gt;second = value; // Move the (key, value) pair to the beginning of the list items.splice(items.begin(), items, cache[key]); &#125; &#125;&#125; https://discuss.leetcode.com/topic/14591/python-dict-double-linkedlist Python Dict + Double LinkedList 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Node:def __init__(self, k, v): self.key = k self.val = v self.prev = None self.next = Noneclass LRUCache:def __init__(self, capacity): self.capacity = capacity self.dic = dict() self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.headdef get(self, key): if key in self.dic: n = self.dic[key] self._remove(n) self._add(n) return n.val return -1def set(self, key, value): if key in self.dic: self._remove(self.dic[key]) n = Node(key, value) self._add(n) self.dic[key] = n if len(self.dic) &gt; self.capacity: n = self.head.next self._remove(n) del self.dic[n.key]def _remove(self, node): p = node.prev n = node.next p.next = n n.prev = pdef _add(self, node): p = self.tail.prev p.next = node self.tail.prev = node node.prev = p node.next = self.tail https://discuss.leetcode.com/topic/24757/python-concise-solution-with-comments-using-ordereddict Python concise solution with comments (Using OrderedDict). 1234567891011121314151617181920def __init__(self, capacity): self.dic = collections.OrderedDict() self.remain = capacitydef get(self, key): if key not in self.dic: return -1 v = self.dic.pop(key) self.dic[key] = v # set key as the newest one return vdef set(self, key, value): if key in self.dic: self.dic.pop(key) else: if self.remain &gt; 0: self.remain -= 1 else: # self.dic is full self.dic.popitem(last=False) self.dic[key] = value]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[145. Binary Tree Postorder Traversal]]></title>
    <url>%2Fp%2F4b821bfc%2F</url>
    <content type="text"><![CDATA[39.0% https://leetcode.com/problems/binary-tree-postorder-traversal/#/description Given a binary tree, return the postorder traversal of its nodesâ€™ values. 12345678For example:Given binary tree &#123;1,#,2,3&#125;, 1 \ 2 / 3return [3,2,1]. Note: Recursive solution is trivial, could you do it iteratively? æ–¹æ³•ä¸€ï¼šé€’å½’ï¼Œæ­¤æ–¹æ³•å¯ç”¨äºŽå…ˆåºã€ä¸­åºã€åŽç»­ã€‚ä½†æ˜¯é¢è¯•æ—¶è‚¯å®šæ˜¯ä¸å¤Ÿç”¨çš„ã€‚ Recursive solution æ—¶é—´ç©ºé—´å¤æ‚åº¦ ï¼š O(n) time and O(n) space (considering the spaces of function call stack); 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; helper(root, res); return res; &#125; void helper(TreeNode* root, vector&lt;int&gt;&amp; res)&#123; if(root)&#123; helper(root-&gt;left, res); helper(root-&gt;right, res); res.push_back(root-&gt;val); &#125; &#125;&#125;; æ–¹æ³•äºŒï¼šä½¿ç”¨æ ˆæ¥ä¿å­˜è¦éåŽ†çš„èŠ‚ç‚¹ï¼ŒåŽç»­æ˜¯å…ˆå·¦ï¼ŒåŽå³ï¼Œæœ€åŽæ ¹ã€‚åè¿‡æ¥ï¼Œæœ€åŽç»“æžœåè½¬ã€‚ å…ˆæ ¹èŠ‚ç‚¹ï¼Œç„¶åŽå†å…ˆå³ï¼Œå†å·¦ã€‚ å…ˆå³ï¼Œå·¦èŠ‚ç‚¹å°±éœ€è¦ä¿å­˜ä¸€ä¸‹ï¼Œæ‰€ä»¥å…ˆæŠŠå·¦èŠ‚ç‚¹åŽ‹å…¥æ ˆä¸­ï¼Œç„¶åŽæŠŠå³èŠ‚ç‚¹åŽ‹å…¥æ ˆã€‚ å–å‡ºæ—¶ï¼Œå…ˆå–å‡ºå³èŠ‚ç‚¹çš„ï¼Œè¿›è¡Œå¤„ç†ã€‚å¤„ç†å®Œæ¯•ï¼Œå†å¤„ç†åšèŠ‚ç‚¹çš„ã€‚ 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; stack&lt;TreeNode*&gt; nodeStack; vector&lt;int&gt; result; //base case if(root==NULL) return result; nodeStack.push(root); while(!nodeStack.empty()) &#123; TreeNode* node= nodeStack.top(); result.push_back(node-&gt;val); nodeStack.pop(); if(node-&gt;left) nodeStack.push(node-&gt;left); if(node-&gt;right) nodeStack.push(node-&gt;right); &#125; reverse(result.begin(),result.end()); return result; &#125;&#125;; æ€è·¯ç›¸åŒï¼Œå¦ä¸€ç§å†™æ³•å¦‚ä¸‹ï¼š ä¸Žä¸Šè¿°ä»£ç çš„ä¸åŒä¹‹å¤„åœ¨äºŽï¼Œæ²¡æœ‰åè½¬ï¼Œè€Œæ˜¯ç›´æŽ¥åœ¨vectorå‰é¢æ’å…¥ä¸€ä¸ªvalueã€‚ v.insert(v.begin(), val); 123456789101112131415161718vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; v; if (!root) return v; stack&lt;TreeNode *&gt; s; s.push(root); TreeNode *p = NULL; while(!s.empty()) &#123; p = s.top(); s.pop(); v.insert(v.begin(), p-&gt;val); if (p-&gt;left) s.push(p-&gt;left); if (p-&gt;right) s.push(p-&gt;right); &#125; return v;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; stack; stack.push(root); while(!stack.empty())&#123; TreeNode* node = stack.top(); stack.pop(); res.push_back(node-&gt;val); if(node-&gt;left) stack.push(node-&gt;left); if(node-&gt;right) stack.push(node-&gt;right); &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; æ–¹æ³•ä¸‰ï¼šIterative solution using stack â€” O(n) time and O(n) space; æˆ‘çš„ä»£ç å®žçŽ°: Dec 10th, 2017 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; while(cur!=nullptr || !stack.empty())&#123; if(cur)&#123; res.push_back(cur-&gt;val); stack.push(cur); cur = cur-&gt;right; &#125;else&#123; TreeNode* tmp = stack.top(); stack.pop(); cur = tmp-&gt;left; &#125; &#125; // æœ€åŽä¸è¦å¿˜è®°åè½¬ reverse(res.begin(), res.end()); return res; &#125;&#125;; 1234567891011121314151617181920212223vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; stack&lt;TreeNode*&gt; toVisit; TreeNode* curNode = root; TreeNode* lastNode = NULL; while (curNode || !toVisit.empty()) &#123; if (curNode) &#123; toVisit.push(curNode); curNode = curNode -&gt; left; &#125; else &#123; TreeNode* topNode = toVisit.top(); if (topNode -&gt; right &amp;&amp; lastNode != topNode -&gt; right) curNode = topNode -&gt; right; else &#123; nodes.push_back(topNode -&gt; val); lastNode = topNode; toVisit.pop(); &#125; &#125; &#125; return nodes;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; stack; while(root || stack.size())&#123; if(root)&#123; stack.push(root); res.push_back(root-&gt;val); root = root-&gt;right; &#125;else&#123; TreeNode* node = stack.top(); stack.pop(); root = node-&gt;left; &#125; &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; æ–¹æ³•å››ï¼šhttps://discuss.leetcode.com/topic/14473/0-ms-clear-c-solutions-iterative-recursive-morris-traversal-3-different-solutions Morris traversal æ—¶é—´ç©ºé—´å¤æ‚åº¦ ï¼š O(n) time and O(1) space!!! Morris traversal: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void reverseNodes(TreeNode* start, TreeNode* end) &#123; if (start == end) return; TreeNode* x = start; TreeNode* y = start -&gt; right; TreeNode* z; while (x != end) &#123; z = y -&gt; right; y -&gt; right = x; x = y; y = z; &#125;&#125;void reverseAddNodes(TreeNode* start, TreeNode* end, vector&lt;int&gt;&amp; nodes) &#123; reverseNodes(start, end); TreeNode* node = end; while (true) &#123; nodes.push_back(node -&gt; val); if (node == start) break; node = node -&gt; right; &#125; reverseNodes(end, start);&#125;vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; TreeNode* dump = new TreeNode(0); dump -&gt; left = root; TreeNode* curNode = dump; while (curNode) &#123; if (curNode -&gt; left) &#123; TreeNode* predecessor = curNode -&gt; left; while (predecessor -&gt; right &amp;&amp; predecessor -&gt; right != curNode) predecessor = predecessor -&gt; right; if (!(predecessor -&gt; right)) &#123; predecessor -&gt; right = curNode; curNode = curNode -&gt; left; &#125; else &#123; reverseAddNodes(curNode -&gt; left, predecessor, nodes); predecessor -&gt; right = NULL; curNode = curNode -&gt; right; &#125; &#125; else curNode = curNode -&gt; right; &#125; return nodes;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š æŒ‰ç…§å…ˆåºéåŽ†ï¼Œå…ˆæ ¹å†å³å†å·¦ï¼Œç„¶åŽå†å¯¹vector resè¿›è¡Œreverse è®¿é—®æ—¶ä½¿ç”¨morriséåŽ† 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; TreeNode* cur = root; while(cur)&#123; if(cur-&gt;right)&#123; TreeNode* pre = cur-&gt;right; while(pre-&gt;left &amp;&amp; pre-&gt;left!=cur) pre = pre-&gt;left; if(pre-&gt;left==cur)&#123; pre-&gt;left = NULL; cur = cur-&gt;left; &#125;else&#123; res.push_back(cur-&gt;val); pre-&gt;left = cur; cur = cur-&gt;right; &#125; &#125;else&#123; res.push_back(cur-&gt;val); cur = cur-&gt;left; &#125; &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; å…ˆåºã€ä¸­åºã€åŽåºçš„è¿­ä»£æ–¹æ³•æ€»ç»“ï¼š https://discuss.leetcode.com/topic/30632/preorder-inorder-and-postorder-iteratively-summarization Preorder, Inorder, and Postorder Iteratively Summarization Here I summarize the iterative implementation for preorder, inorder, and postorder traverse. PRE ORDER TRAVERSE 12345678910111213141516public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); TreeNode p = root; while(!stack.isEmpty() || p != null) &#123; if(p != null) &#123; stack.push(p); result.add(p.val); // Add before going to children p = p.left; &#125; else &#123; TreeNode node = stack.pop(); p = node.right; &#125; &#125; return result;&#125; IN ORDER TRAVERSE 12345678910111213141516public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); TreeNode p = root; while(!stack.isEmpty() || p != null) &#123; if(p != null) &#123; stack.push(p); p = p.left; &#125; else &#123; TreeNode node = stack.pop(); result.add(node.val); // Add after all left children p = node.right; &#125; &#125; return result;&#125; POST ORDER TRAVERSE 12345678910111213141516public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); TreeNode p = root; while(!stack.isEmpty() || p != null) &#123; if(p != null) &#123; stack.push(p); result.addFirst(p.val); // Reverse the process of preorder p = p.right; // Reverse the process of preorder &#125; else &#123; TreeNode node = stack.pop(); p = node.left; // Reverse the process of preorder &#125; &#125; return result;&#125; 0ms, 24.98%, July 14th, 2016 https://discuss.leetcode.com/topic/2919/my-accepted-code-with-explaination-does-anyone-have-a-better-idea My Accepted code with explaination. Does anyone have a better idea? å…ˆè¿›è¡Œç±»ä¼¼äºŽå…ˆåºéåŽ†ï¼Œä½†æ˜¯å…ˆè·ŸåŽå³å†å·¦ï¼Œç»“æžœåè½¬ã€‚ pre-order traversal is root-left-right, and post order is left-right-root. modify the code for pre-order to make it root-right-left, and then reverse the output so that we can get left-right-root . Create an empty stack, Push root node to the stack. Do following while stack is not empty. 2.1. pop an item from the stack and print it. 2.2. push the left child of popped item to stack. 2.3. push the right child of popped item to stack. reverse the ouput. 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; stack&lt;TreeNode*&gt; nodeStack; vector&lt;int&gt; result; //base case if(root==NULL) return result; nodeStack.push(root); while(!nodeStack.empty()) &#123; TreeNode* node= nodeStack.top(); result.push_back(node-&gt;val); nodeStack.pop(); if(node-&gt;left) nodeStack.push(node-&gt;left); if(node-&gt;right) nodeStack.push(node-&gt;right); &#125; reverse(result.begin(),result.end()); return result; &#125;&#125;; 4ms, 0.62%, July 14th, 2016 https://discuss.leetcode.com/topic/7427/a-very-concise-solution A very concise solution i have saw lots of post in this discussion, but most of them are not concise, just share mine for your reference, writing a concise code is very important 123456789101112131415161718vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; v; if (!root) return v; stack&lt;TreeNode *&gt; s; s.push(root); TreeNode *p = NULL; while(!s.empty()) &#123; p = s.top(); s.pop(); v.insert(v.begin(), p-&gt;val); if (p-&gt;left) s.push(p-&gt;left); if (p-&gt;right) s.push(p-&gt;right); &#125; return v;&#125; https://discuss.leetcode.com/topic/14473/0-ms-clear-c-solutions-iterative-recursive-morris-traversal-3-different-solutions 0 ms Clear C++ solutions â€” iterative, recursive, Morris traversal (3 different solutions!) Hi, this is a fundamental and yet classic problem. I share my three solutions here: Iterative solution using stack â€” O(n) time and O(n) space; Recursive solution â€” O(n) time and O(n) space (considering the spaces of function call stack); Morris traversal â€” O(n) time and O(1) space!!! Iterative solution using stack: 1234567891011121314151617181920212223vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; stack&lt;TreeNode*&gt; toVisit; TreeNode* curNode = root; TreeNode* lastNode = NULL; while (curNode || !toVisit.empty()) &#123; if (curNode) &#123; toVisit.push(curNode); curNode = curNode -&gt; left; &#125; else &#123; TreeNode* topNode = toVisit.top(); if (topNode -&gt; right &amp;&amp; lastNode != topNode -&gt; right) curNode = topNode -&gt; right; else &#123; nodes.push_back(topNode -&gt; val); lastNode = topNode; toVisit.pop(); &#125; &#125; &#125; return nodes;&#125; Recursive solution: 1234567891011void postorder(TreeNode* root, vector&lt;int&gt;&amp; nodes) &#123; if (!root) return; postorder(root -&gt; left, nodes); postorder(root -&gt; right, nodes); nodes.push_back(root -&gt; val);&#125;vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; postorder(root, nodes); return nodes;&#125; Morris traversal: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void reverseNodes(TreeNode* start, TreeNode* end) &#123; if (start == end) return; TreeNode* x = start; TreeNode* y = start -&gt; right; TreeNode* z; while (x != end) &#123; z = y -&gt; right; y -&gt; right = x; x = y; y = z; &#125;&#125;void reverseAddNodes(TreeNode* start, TreeNode* end, vector&lt;int&gt;&amp; nodes) &#123; reverseNodes(start, end); TreeNode* node = end; while (true) &#123; nodes.push_back(node -&gt; val); if (node == start) break; node = node -&gt; right; &#125; reverseNodes(end, start);&#125;vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; TreeNode* dump = new TreeNode(0); dump -&gt; left = root; TreeNode* curNode = dump; while (curNode) &#123; if (curNode -&gt; left) &#123; TreeNode* predecessor = curNode -&gt; left; while (predecessor -&gt; right &amp;&amp; predecessor -&gt; right != curNode) predecessor = predecessor -&gt; right; if (!(predecessor -&gt; right)) &#123; predecessor -&gt; right = curNode; curNode = curNode -&gt; left; &#125; else &#123; reverseAddNodes(curNode -&gt; left, predecessor, nodes); predecessor -&gt; right = NULL; curNode = curNode -&gt; right; &#125; &#125; else curNode = curNode -&gt; right; &#125; return nodes;&#125; 44ms, 81.02%, July 14th, 2016 https://discuss.leetcode.com/topic/17540/share-my-two-python-iterative-solutions-post-order-and-modified-preorder-then-reverse Share my two Python iterative solutions, post-order and modified preorder then reverse The first is by postorder using a flag to indicate whether the node has been visited or not. 123456789101112131415161718class Solution: # @param &#123;TreeNode&#125; root # @return &#123;integer[]&#125; def postorderTraversal(self, root): traversal, stack = [], [(root, False)] while stack: node, visited = stack.pop() if node: if visited: # add to result if visited traversal.append(node.val) else: # post-order stack.append((node, True)) stack.append((node.right, False)) stack.append((node.left, False)) return traversal The 2nd uses modified preorder (right subtree first). Then reverse the result. 123456789101112131415class Solution: # @param &#123;TreeNode&#125; root # @return &#123;integer[]&#125; def postorderTraversal(self, root): traversal, stack = [], [root] while stack: node = stack.pop() if node: # pre-order, right first traversal.append(node.val) stack.append(node.left) stack.append(node.right) # reverse result return traversal[::-1] https://discuss.leetcode.com/topic/2325/accepted-just-a-reversal-of-a-modified-pre-order-traversal Accepted â€“ Just a reversal of a modified Pre-order traversal This is my accepted code. I found out that pre-order traversal is root-left-right, and post order is left-right-root. I modified the code for pre-order a little to make it root-right-left, and then reverse the output. I think others would have thought of it already, but anyways hereâ€™s my codeâ€¦ 123456789101112131415161718class Solution:# @param root, a tree node# @return a list of integersdef postorderTraversal(self, root): traversalInt = list() if root!=None: traversal = list() traversal.append(root) while len(traversal)&gt;0: probe = traversal[0] traversalInt.append(probe.val) traversal.remove(probe) if (probe.left != None): traversal.insert(0,probe.left) if (probe.right != None): traversal.insert(0,probe.right) return traversalInt[::-1] https://discuss.leetcode.com/topic/34258/iterative-method-to-do-three-kinds-of-traversal-just-like-recursive-method-only-changing-one-line-code Iterative method to do three kinds of traversal just like recursive method only changing one line code For three different kinds of traversal, we only need to change the order of tuples in one line as weâ€™ve done this in the recursive solution which is very decent and classical. Just put (0, p[1]) in different position! For post-order traversal: 1234567def postorderTraversal(self, root): res, stack = [], [(1, root)] while stack: p = stack.pop() if not p[1]: continue stack.extend([(0, p[1]), (1, p[1].right), (1, p[1].left)]) if p[0] != 0 else res.append(p[1].val) return res For in-order traversal: 1234567def inorderTraversal(self, root): res, stack = [], [(1, root)] while stack: p = stack.pop() if not p[1]: continue stack.extend([(1, p[1].right), (0, p[1]), (1, p[1].left)]) if p[0] != 0 else res.append(p[1].val) return res For pre-order traversal: 1234567def preorderTraversal(self, root): res, stack = [], [(1, root)] while stack: p = stack.pop() if not p[1]: continue stack.extend([(1, p[1].right), (1, p[1].left), (0, p[1])]) if p[0] != 0 else res.append(p[1].val) return res https://discuss.leetcode.com/topic/44231/preorder-inorder-and-postorder-traversal-iterative-java-solution Preorder, Inorder and Postorder Traversal Iterative Java Solution Postorder traversal : Binary Tree Postorder Traversal 12345678910111213public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null) return list; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.empty())&#123; root = stack.pop(); list.add(0, root.val); if(root.left != null) stack.push(root.left); if(root.right != null) stack.push(root.right); &#125; return list;&#125; Preorder traversal : Binary Tree Preorder Traversal 12345678910111213public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null) return list; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.empty())&#123; root = stack.pop(); list.add(root.val); if(root.right != null) stack.push(root.right); if(root.left != null) stack.push(root.left); &#125; return list;&#125; Inorder traversal : Binary Tree Inorder Traversal 123456789101112131415public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null) return list; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(root != null || !stack.empty())&#123; while(root != null)&#123; stack.push(root); root = root.left; &#125; root = stack.pop(); list.add(root.val); root = root.right; &#125; return list;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>stack</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[144. Binary Tree Preorder Traversal]]></title>
    <url>%2Fp%2Fc601580f%2F</url>
    <content type="text"><![CDATA[43.8% https://leetcode.com/problems/binary-tree-preorder-traversal/#/description Given a binary tree, return the preorder traversal of its nodesâ€™ values. 12345678For example:Given binary tree &#123;1,#,2,3&#125;, 1 \ 2 / 3return [1,2,3]. Note: Recursive solution is trivial, could you do it iteratively? æ–¹æ³•ä¸€ï¼šé€’å½’ O(n)æ—¶é—´ O(n)ç©ºé—´ 123456789101112// recursive, but it&apos;s trivial...vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; preTraversal(root, v); return v;&#125;void preTraversal(TreeNode* root, vector&lt;int&gt;&amp; v)&#123; if(!root) return; v.push_back(root-&gt;val); preTraversal(root-&gt;left, v); preTraversal(root-&gt;right, v);&#125; æ–¹æ³•äºŒï¼šè¿­ä»£æ–¹æ³•ï¼Œä½¿ç”¨æ ˆï¼ŒéåŽ†å…ˆæ ¹å†å·¦åŽå³ã€‚å­˜å…¥æ ˆï¼Œå…ˆå³åŽå·¦ã€‚å¾ˆå¥½ç†è§£ã€‚ Create an empty stack, Push root node to the stack. Do following while stack is not empty. 2.1. pop an item from the stack and print it.2.2. push the right child of popped item to stack.2.3. push the left child of popped item to stack. 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; stack&lt;TreeNode*&gt; nodeStack; vector&lt;int&gt; result; //base case if(root==NULL) return result; nodeStack.push(root); while(!nodeStack.empty()) &#123; TreeNode* node= nodeStack.top(); result.push_back(node-&gt;val); nodeStack.pop(); if(node-&gt;right) nodeStack.push(node-&gt;right); if(node-&gt;left) nodeStack.push(node-&gt;left); &#125; return result; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; stack; stack.push(root); while(!stack.empty())&#123; TreeNode* node = stack.top(); stack.pop(); res.push_back(node-&gt;val); if(node-&gt;right) stack.push(node-&gt;right); if(node-&gt;left) stack.push(node-&gt;left); &#125; return res; &#125;&#125;; æ–¹æ³•ä¸‰ï¼š ä½¿ç”¨æ ˆï¼ŒæŒ‰ç…§é€’å½’çš„æ–¹æ³•éåŽ† æˆ‘çš„ä»£ç å®žçŽ°ï¼š Dec 10th, 2017 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; while(stack.size() || cur)&#123; if(cur)&#123; res.push_back(cur-&gt;val); stack.push(cur); cur = cur-&gt;left; &#125;else&#123; TreeNode* tmp = stack.top(); stack.pop(); cur = tmp-&gt;right; &#125; &#125; return res; &#125;&#125;; 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; stack; while(root || stack.size())&#123; if(root)&#123; stack.push(root); res.push_back(root-&gt;val); root = root-&gt;left; &#125;else&#123; TreeNode* node = stack.top(); stack.pop(); root = node-&gt;right; &#125; &#125; return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°äºŒ: 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; while(cur || stack.size())&#123; if(cur)&#123; stack.push(cur); res.push_back(cur-&gt;val); cur = cur-&gt;left; &#125;else&#123; cur = stack.top(); stack.pop(); cur = cur-&gt;right; &#125; &#125; return res; &#125;&#125;; æ–¹æ³•å››ï¼šmorris traversal O(1)ç©ºé—´å¤æ‚åº¦ O(n)æ—¶é—´å¤æ‚åº¦ 123456789101112131415161718192021222324// morris traversalï¼Œ O(1) spacevector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root, *prev; while(temp)&#123; if(!temp-&gt;left)&#123; v.push_back(temp-&gt;val); temp = temp-&gt;right; &#125;else&#123; prev = temp-&gt;left; while(prev-&gt;right&amp;&amp;(prev-&gt;right != temp)) prev = prev-&gt;right; if(!prev-&gt;right)&#123; v.push_back(temp-&gt;val); prev-&gt;right = temp; temp = temp-&gt;left; &#125;else&#123; prev-&gt;right = NULL; temp = temp-&gt;right; &#125; &#125; &#125;&#125; æˆ‘çš„ä»£ç å®žçŽ°: 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; TreeNode* cur = root; while(cur)&#123; if(cur-&gt;left)&#123; TreeNode* pre = cur-&gt;left; while(pre-&gt;right &amp;&amp; pre-&gt;right!=cur) pre = pre-&gt;right; if(pre-&gt;right==cur)&#123; pre-&gt;right = NULL; cur = cur-&gt;right; &#125;else&#123; res.push_back(cur-&gt;val); pre-&gt;right = cur; cur = cur-&gt;left; &#125; &#125;else&#123; res.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125; return res; &#125;&#125;; è¿­ä»£æ–¹æ³•æ€»ç»“ï¼Œå€¼å¾—å­¦ä¹  https://discuss.leetcode.com/topic/44387/preorder-inorder-postorder-iterative-solution-by-c Preorderã€inorderã€postorder iterative solution by c++ preorder: 123456789101112131415vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; std::stack&lt;TreeNode*&gt; temp; while (root || !temp.empty()) &#123; while (root) &#123; temp.push(root); res.push_back(root-&gt;val); root = root-&gt;left; &#125; root = temp.top(); temp.pop(); root = root-&gt;right; &#125; return res;&#125; inorder: 123456789101112131415vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; std::stack&lt;TreeNode*&gt; temp; while (root || !temp.empty()) &#123; while (root) &#123; temp.push(root); root = root-&gt;left; &#125; root = temp.top(); temp.pop(); res.push_back(root-&gt;val); root = root-&gt;right; &#125; return res;&#125; postorder: 123456789101112131415vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; std::stack&lt;TreeNode*&gt; temp; while (root || !temp.empty()) &#123; while (root) &#123; temp.push(root); res.insert(res.begin(),root-&gt;val); root = root-&gt;right; &#125; root = temp.top(); temp.pop(); root = root-&gt;left; &#125; return res;&#125; https://discuss.leetcode.com/topic/2917/accepted-code-explaination-with-algo Accepted code. Explaination with Algo. Create an empty stack, Push root node to the stack. Do following while stack is not empty. 2.1. pop an item from the stack and print it.2.2. push the right child of popped item to stack.2.3. push the left child of popped item to stack. 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; stack&lt;TreeNode*&gt; nodeStack; vector&lt;int&gt; result; //base case if(root==NULL) return result; nodeStack.push(root); while(!nodeStack.empty()) &#123; TreeNode* node= nodeStack.top(); result.push_back(node-&gt;val); nodeStack.pop(); if(node-&gt;right) nodeStack.push(node-&gt;right); if(node-&gt;left) nodeStack.push(node-&gt;left); &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/12515/3-different-solutions 3 Different Solutions Recursive method with List as returning value: 12345678public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; pre = new LinkedList&lt;Integer&gt;(); if(root==null) return pre; pre.add(root.val); pre.addAll(preorderTraversal(root.left)); pre.addAll(preorderTraversal(root.right)); return pre;&#125; Recursive method with Helper method to have a List as paramater, so we can modify the parameter and donâ€™t have to instantiate a new List at each recursive call: 1234567891011public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; pre = new LinkedList&lt;Integer&gt;(); preHelper(root,pre); return pre;&#125;public void preHelper(TreeNode root, List&lt;Integer&gt; pre) &#123; if(root==null) return; pre.add(root.val); preHelper(root.left,pre); preHelper(root.right,pre);&#125; Iterative method with Stack: 12345678910111213public List&lt;Integer&gt; preorderIt(TreeNode root) &#123; List&lt;Integer&gt; pre = new LinkedList&lt;Integer&gt;(); if(root==null) return pre; Stack&lt;TreeNode&gt; tovisit = new Stack&lt;TreeNode&gt;(); tovisit.push(root); while(!tovisit.empty()) &#123; TreeNode visiting = tovisit.pop(); pre.add(visiting.val); if(visiting.right!=null) tovisit.push(visiting.right); if(visiting.left!=null) tovisit.push(visiting.left); &#125; return pre;&#125; https://discuss.leetcode.com/topic/5748/easy-c-solution-using-stack Easy C++ solution using Stack 1234567891011121314151617181920212223class Solution &#123;public:vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; if (root==NULL) &#123; return vector&lt;int&gt;(); &#125; vector&lt;int&gt; result; stack&lt;TreeNode *&gt; treeStack; treeStack.push(root); while (!treeStack.empty()) &#123; TreeNode *temp = treeStack.top(); result.push_back(temp-&gt;val); treeStack.pop(); if (temp-&gt;right!=NULL) &#123; treeStack.push(temp-&gt;right); &#125; if (temp-&gt;left!=NULL) &#123; treeStack.push(temp-&gt;left); &#125; &#125; return result;&#125;&#125;; https://discuss.leetcode.com/topic/21936/4-solutions-in-c 4 solutions in c++ 123456789101112// recursive, but it&apos;s trivial...vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; preTraversal(root, v); return v;&#125;void preTraversal(TreeNode* root, vector&lt;int&gt;&amp; v)&#123; if(!root) return; v.push_back(root-&gt;val); preTraversal(root-&gt;left, v); preTraversal(root-&gt;right, v);&#125; 123456789101112131415// iterate, use stack to imitate recursivevector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root; stack&lt;TreeNode*&gt; s; s.push(root); while(!s.empty())&#123; temp = s.top(); s.pop(); v.push_back(temp-&gt;val); if(temp-&gt;right) s.push(temp-&gt;right); if(temp-&gt;left) s.push(temp-&gt;left); &#125;&#125; 12345678910111213141516vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root; stack&lt;TreeNode*&gt; s; while(true)&#123; while(temp)&#123; v.push_back(temp-&gt;val); if(temp-&gt;right) s.push(temp-&gt;right); temp = temp-&gt;left; &#125; if(s.empty()) break; temp = s.top(); s.pop(); &#125;;&#125; 123456789101112131415161718192021222324// morris traversalï¼Œ O(1) spacevector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root, *prev; while(temp)&#123; if(!temp-&gt;left)&#123; v.push_back(temp-&gt;val); temp = temp-&gt;right; &#125;else&#123; prev = temp-&gt;left; while(prev-&gt;right&amp;&amp;(prev-&gt;right != temp)) prev = prev-&gt;right; if(!prev-&gt;right)&#123; v.push_back(temp-&gt;val); prev-&gt;right = temp; temp = temp-&gt;left; &#125;else&#123; prev-&gt;right = NULL; temp = temp-&gt;right; &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/7976/very-simple-iterative-python-solution Very simple iterative Python solution Classical usage of stackâ€™s LIFO feature, very easy to grasp: 12345678910def preorderTraversal(self, root): ret = [] stack = [root] while stack: node = stack.pop() if node: ret.append(node.val) stack.append(node.right) stack.append(node.left) return ret https://discuss.leetcode.com/topic/6493/accepted-iterative-solution-in-java-using-stack Accepted iterative solution in Java using stack. Note that in this solution only right children are stored to stack. 123456789101112131415public List&lt;Integer&gt; preorderTraversal(TreeNode node) &#123; List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; rights = new Stack&lt;TreeNode&gt;(); while(node != null) &#123; list.add(node.val); if (node.right != null) &#123; rights.push(node.right); &#125; node = node.left; if (node == null &amp;&amp; !rights.isEmpty()) &#123; node = rights.pop(); &#125; &#125; return list;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>stack</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[143. Reorder List]]></title>
    <url>%2Fp%2Ffa09b9a8%2F</url>
    <content type="text"><![CDATA[24.9% https://leetcode.com/problems/reorder-list/#/description Given a singly linked list L: L0â†’L1â†’â€¦â†’Ln-1â†’Ln,reorder it to: L0â†’Lnâ†’L1â†’Ln-1â†’L2â†’Ln-2â†’â€¦ You must do this in-place without altering the nodesâ€™ values. 12For example,Given &#123;1,2,3,4&#125;, reorder it to &#123;1,4,2,3&#125;. æ–¹æ³•ä¸€ï¼š æŒ‰ç…§é¢˜æ„ï¼Œå…ˆæ‰¾ä¸€åŠå¤„ï¼ŒåŽä¸€åŠåè½¬ï¼Œç„¶åŽå¹¶å…¥å‰ä¸€æ®µã€‚ æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void reorderList(ListNode* head) &#123; if(!head || !head-&gt;next) return; ListNode* fast = head, * slow = head; while(fast-&gt;next!=NULL &amp;&amp; fast-&gt;next-&gt;next!=NULL)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; fast = slow-&gt;next; ListNode* pre = NULL; while(fast)&#123; ListNode* nex = fast-&gt;next; fast-&gt;next = pre; pre = fast; fast = nex; &#125; fast = pre; slow-&gt;next = NULL; slow = head; while(fast!=NULL)&#123; ListNode* nex = fast-&gt;next; fast-&gt;next = slow-&gt;next; slow-&gt;next = fast; slow = slow-&gt;next-&gt;next; fast = nex; &#125; return; &#125;&#125;; 49ms, September 22, 2016 https://discuss.leetcode.com/topic/7425/a-concise-o-n-time-o-1-in-place-solution A concise O(n) time, O(1) in place solution 1234567891011121314151617181920212223242526272829303132333435363738// O(N) time, O(1) space in totalvoid reorderList(ListNode *head) &#123; if (!head || !head-&gt;next) return; // find the middle node: O(n) ListNode *p1 = head, *p2 = head-&gt;next; while (p2 &amp;&amp; p2-&gt;next) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next-&gt;next; &#125; // cut from the middle and reverse the second half: O(n) ListNode *head2 = p1-&gt;next; p1-&gt;next = NULL; p2 = head2-&gt;next; head2-&gt;next = NULL; while (p2) &#123; p1 = p2-&gt;next; p2-&gt;next = head2; head2 = p2; p2 = p1; &#125; // merge two lists: O(n) for (p1 = head, p2 = head2; p1; ) &#123; auto t = p1-&gt;next; p1 = p1-&gt;next = p2; p2 = t; &#125; //for (p1 = head, p2 = head2; p2; ) &#123; // auto t = p1-&gt;next; // p1-&gt;next = p2; // p2 = p2-&gt;next; // p1 = p1-&gt;next-&gt;next = t; //&#125;&#125; https://discuss.leetcode.com/topic/4061/my-o-n-c-method-accepted My O(n) C++ Method, accepted Firstly, I split the list from the middle into two lists. One from head to middle, and the other from middle to the end. Then we reverse the second list. Finally we merge these two lists. O(n) time complexity and O(1) space complexity. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void reorderList(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL || head-&gt;next-&gt;next==NULL) return; //find the middle of the list, and split into two lists. ListNode *p=head,*q=head; while(p &amp;&amp; q &amp;&amp; q-&gt;next &amp;&amp; q-&gt;next-&gt;next)&#123; p=p-&gt;next; q=q-&gt;next-&gt;next; &#125; ListNode *mid = p-&gt;next; p-&gt;next=NULL; p=head; //reverse from the middle to the end ListNode *q1=mid, *q2,*q3; if(mid-&gt;next)&#123; q1=mid; q2=mid-&gt;next; while(q2)&#123; q3=q2-&gt;next; q2-&gt;next=q1; q1=q2; q2=q3; &#125; mid-&gt;next=NULL; &#125; q=q1; //merge these two list ListNode *s=p; p=p-&gt;next; while(p &amp;&amp; q)&#123; s-&gt;next=q; s=s-&gt;next; q=q-&gt;next; s-&gt;next=p; s=s-&gt;next; p=p-&gt;next; &#125; if(p)&#123; s-&gt;next=p; &#125; if(q)&#123; s-&gt;next=q; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/10894/share-a-consise-recursive-solution-in-c Share a consise recursive solution in C++ The recursive idea have been posted by yucheng.wang. Given a example, 1-&gt;2-&gt;3-&gt;4-&gt;5, the solution will reorder node(3), then reorder 2 and 4 to have (2-&gt;4-&gt;3), then 1 and 5 get have 1-&gt;5-&gt;2-&gt;4-&gt;3. Each call of reorderList(ListNode* head, int len) will return the last element after this reorderList() call. 123456789101112131415161718192021222324252627int getLength(ListNode *head)&#123;int len = 0;while( head != NULL )&#123;++len; head = head-&gt;next;&#125;return len;&#125;ListNode * reorderList(ListNode *head, int len)&#123; if(len == 0) return NULL; if( len == 1 ) return head; if( len == 2 ) return head-&gt;next; ListNode * tail = reorderList(head-&gt;next, len-2); ListNode * tmp = tail-&gt;next; tail-&gt;next = tail-&gt;next-&gt;next; tmp-&gt;next = head-&gt;next; head-&gt;next = tmp; return tail;&#125;void reorderList(ListNode *head) &#123; //recursive ListNode * tail = NULL; tail = reorderList(head, getLength(head));&#125; https://discuss.leetcode.com/topic/3345/a-python-solution-o-n-time-o-1-space A python solution O(n) time, O(1) space 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# Splits in place a list in two halves, the first half is &gt;= in size than the second.# @return A tuple containing the heads of the two halvesdef _splitList(head): fast = head slow = head while fast and fast.next: slow = slow.next fast = fast.next fast = fast.next middle = slow.next slow.next = None return head, middle# Reverses in place a list.# @return Returns the head of the new reversed listdef _reverseList(head): last = None currentNode = head while currentNode: nextNode = currentNode.next currentNode.next = last last = currentNode currentNode = nextNode return last# Merges in place two lists# @return The newly merged list.def _mergeLists(a, b): tail = a head = a a = a.next while b: tail.next = b tail = tail.next b = b.next if a: a, b = b, a return headclass Solution: # @param head, a ListNode # @return nothing def reorderList(self, head): if not head or not head.next: return a, b = _splitList(head) b = _reverseList(b) head = _mergeLists(a, b) https://discuss.leetcode.com/topic/13869/java-solution-with-3-steps Java solution with 3 steps This question is a combination of Reverse a linked list I &amp; II. It should be pretty straight forward to do it in 3 steps :) 1234567891011121314151617181920212223242526272829303132public void reorderList(ListNode head) &#123; if(head==null||head.next==null) return; //Find the middle of the list ListNode p1=head; ListNode p2=head; while(p2.next!=null&amp;&amp;p2.next.next!=null)&#123; p1=p1.next; p2=p2.next.next; &#125; //Reverse the half after middle 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 to 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4 ListNode preMiddle=p1; ListNode preCurrent=p1.next; while(preCurrent.next!=null)&#123; ListNode current=preCurrent.next; preCurrent.next=current.next; current.next=preMiddle.next; preMiddle.next=current; &#125; //Start reorder one by one 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4 to 1-&gt;6-&gt;2-&gt;5-&gt;3-&gt;4 p1=head; p2=preMiddle.next; while(p1!=preMiddle)&#123; preMiddle.next=p2.next; p2.next=p1.next; p1.next=p2; p1=p2.next; p2=preMiddle.next; &#125; &#125; https://discuss.leetcode.com/topic/18092/java-solution-with-3-steps Java solution with 3 steps 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; public void reorderList(ListNode head) &#123; if (head == null || head.next == null) return; // step 1. cut the list to two halves // prev will be the tail of 1st half // slow will be the head of 2nd half ListNode prev = null, slow = head, fast = head, l1 = head; while (fast != null &amp;&amp; fast.next != null) &#123; prev = slow; slow = slow.next; fast = fast.next.next; &#125; prev.next = null; // step 2. reverse the 2nd half ListNode l2 = reverse(slow); // step 3. merge the two halves merge(l1, l2); &#125; ListNode reverse(ListNode head) &#123; ListNode prev = null, curr = head, next = null; while (curr != null) &#123; next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; return prev; &#125; void merge(ListNode l1, ListNode l2) &#123; while (l1 != null) &#123; ListNode n1 = l1.next, n2 = l2.next; l1.next = l2; if (n1 == null) break; l2.next = n1; l1 = n1; l2 = n2; &#125; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[142. Linked List Cycle II]]></title>
    <url>%2Fp%2Fc5856708%2F</url>
    <content type="text"><![CDATA[31.0% https://leetcode.com/problems/linked-list-cycle-ii/?tab=Description Given a linked list, return the node where the cycle begins. If there is no cycle, return null. Note: Do not modify the linked list. Follow up: Can you solve it without using extra space? æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(!head) return NULL; ListNode* slow = head, *fast = head; // æ³¨æ„!fastè¡¨ç¤ºfastä¸ºNULLçš„æƒ…å†µä¸‹ä¸ºtrueï¼Œfastè¡¨ç¤ºfastä¸ä¸ºNULL // åŒºåˆ†!fast,fast,fast!=NULLè¿™å‡ ç§æƒ…å†µ while(fast &amp;&amp; fast-&gt;next)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(slow==fast)&#123; fast = head; while(fast!=slow)&#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return fast; &#125; &#125; return NULL; &#125;&#125;; ç±»ä¼¼ç‰ˆæœ¬ï¼š ä¸€ä¸ªé‡ç‚¹æ˜¯ï¼Œé¢˜ç›®ä¸­è¦æ±‚å¾ªçŽ¯å¼€å§‹çš„åœ°æ–¹ï¼Œæ‰€ä»¥å½“æ‰¾åˆ°ç›¸é‡çš„åœ°æ–¹æ—¶ï¼Œè¿˜è¦é€šè¿‡forå¾ªçŽ¯æ‰¾åˆ°æœ€å¼€å§‹ç›¸é‡çš„åœ°æ–¹ã€‚ 1234567891011121314151617181920212223class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head==NULL) return head; ListNode * slow, * fast; slow = head; fast = head; while(fast!=NULL &amp;&amp; fast-&gt;next!=NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow==fast)&#123; ListNode* slow2 = head; while(slow2!=slow)&#123; slow = slow-&gt;next; slow2 = slow2-&gt;next; &#125; return slow2; &#125; &#125; return NULL; &#125;&#125;; https://discuss.leetcode.com/topic/5284/concise-o-n-solution-by-using-c-with-detailed-alogrithm-description Concise O(n) solution by using C++ with Detailed Alogrithm Description Alogrithm Description:Step 1: Determine whether there is a cycle 1.1. Using a slow pointer that move forward 1 step each time 1.2. Using a fast pointer that move forward 2 steps each time 1.3. If the slow pointer and fast pointer both point to the same location after several moving steps, there is a cycle; 1.4. Otherwise, if (fast-&gt;next == NULL || fast-&gt;next-&gt;next == NULL), there has no cycle. Step 2: If there is a cycle, return the entry location of the cycle 2.1. L1 is defined as the distance between the head point and entry point 2.2. L2 is defined as the distance between the entry point and the meeting point 2.3. C is defined as the length of the cycle 2.4. n is defined as the travel times of the fast pointer around the cycle When the first encounter of the slow pointer and the fast pointer According to the definition of L1, L2 and C, we can obtain: the total distance of the slow pointer traveled when encounter is L1 + L2 the total distance of the fast pointer traveled when encounter is L1 + L2 + n * C Because the total distance the fast pointer traveled is twice as the slow pointer, Thus: 2 (L1+L2) = L1 + L2 + n C =&gt; L1 + L2 = n C =&gt; L1 = (n - 1) C + (C - L2) å¿«æŒ‡é’ˆä¸ä¼šè¶…è¿‡æ…¢æŒ‡é’ˆå¥½å‡ åœˆï¼Œå› ä¸ºå¦‚æžœå½“å‰èŠ‚ç‚¹æ²¡æœ‰ç›¸é‡ï¼Œåˆ™ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸€å®šä¼šç›¸é‡ã€‚ It can be concluded that the distance between the head location and entry location is equal to the distance between the meeting location and the entry location along the direction of forward movement. So, when the slow pointer and the fast pointer encounter in the cycle, we can define a pointer â€œentryâ€ that point to the head, this â€œentryâ€ pointer moves one step each time so as the slow pointer. When this â€œentryâ€ pointer and the slow pointer both point to the same location, this location is the node where the cycle begins. Here is the code: 123456789101112131415161718192021ListNode *detectCycle(ListNode *head) &#123; if (head == NULL || head-&gt;next == NULL) return NULL; ListNode *slow = head; ListNode *fast = head; ListNode *entry = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (slow == fast) &#123; // there is a cycle while(slow != entry) &#123; // found the entry location slow = slow-&gt;next; entry = entry-&gt;next; &#125; return entry; &#125; &#125; return NULL; // there has no cycle&#125; cpp 9ms, September 22, 2016 https://discuss.leetcode.com/topic/2975/o-n-solution-by-using-two-pointers-without-change-anything O(n) solution by using two pointers without change anything my solution is like this: using two pointers, one of them one step at a time. another pointer each take two steps. Suppose the first meet at step k,the length of the Cycle is r. so..2k-k=nr,k=nr Now, the distance between the start node of list and the start node of cycle is s. the distance between the start of list and the first meeting node is k(the pointer which wake one step at a time waked k steps).the distance between the start node of cycle and the first meeting node is m, soâ€¦s=k-m, s=nr-m=(n-1)r+(r-m),here we takes n = 1..so, using one pointer start from the start node of list, another pointer start from the first meeting node, all of them wake one step at a time, the first time they meeting each other is the start of the cycle. 12345678910111213141516171819202122232425262728class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head==NULL || head-&gt;next == NULL) return NULL; ListNode* firstp = head; ListNode* secondp = head; bool isCycle = false; while(firstp!=NULL &amp;&amp; secondp!=NULL)&#123; firstp = firstp-&gt;next; if(secondp-&gt;next==NULL) return NULL; secondp = secondp-&gt;next-&gt;next; if(firstp==secondp)&#123; isCycle = true; break; &#125; &#125; if(!isCycle) return NULL; firstp = head; while(firstp != secondp)&#123; firstp = firstp-&gt;next; secondp = secondp-&gt;next; &#125; return firstp; &#125;&#125;; https://discuss.leetcode.com/topic/33191/c-implementation-with-much-more-clear-and-strict-explanation-any-one-can-give-more-clear C++ implementation with much more clear and strict explanation ! any one can give more clear ? Just use the dummy head pointer and why first find the meeting point and then set the result-pointer at the dummy and move forward to find the result position.There are the reasons : 123456789101112131415161718192021222324252627282930set the [#cycle length = C ] [#length-from-head-to-cycle-start-point = L] [#cycle-start-point-meeting-point=S] [#meeting-point-clock-direction-to-cycle-start-point=Y] [#step needed to meeting=T]Then when they meet, we have 2 * T = T + N1 * C N1=0,1,2...so we get T = N1 * CAlso we have 2 * T = L + N2 * C + S N2=0,1,2...we can get N3 * C = L + S with C = S + Y N3 = 2 * N1 - N2so we have (N3 - 1) * C + S + Y = L + Sthen we have (N3 - 1) * C + Y = Ljust means that we can do the things that have been explained by others. We can move a node from head and node from the meeting point, then when they meet, it is the start point of the cycle. Here is the code : 123456789101112131415161718192021class Solution &#123; public: ListNode *detectCycle(ListNode *head) &#123; ListNode* dummy=new ListNode(-1); dummy-&gt;next=head; ListNode *slow=dummy, *fast=dummy; bool flag=false; while(fast &amp;&amp; fast-&gt;next)&#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(fast==slow) &#123; flag=true; break; &#125; &#125; if(!flag) return NULL; ListNode* result=dummy; while(result != slow)&#123; result=result-&gt;next; slow=slow-&gt;next;**strong text** &#125; return result; &#125; &#125;; my code: python 85ms, 51.12%, September 22, 2016 https://discuss.leetcode.com/topic/17521/share-my-python-solution-with-detailed-explanation Share my python solution with detailed explanation My solution consists of two parts. The first one checks if a cycle exists or not. The second one determines the entry of the cycle if it exists.The first part is inspired by this post. about Linked List Cycle IThe logic behind the 2nd part is like this: Consider the following linked list, where E is the cylce entry and X, the crossing point of fast and slow. 12345678H: distance from head to cycle entry ED: distance from E to XL: cycle length _____ / \head_____H______E \ \ / X_____/ If fast and slow both start at head, when fast catches slow, slow has traveled H+D and fast 2(H+D).Assume fast has traveled n loops in the cycle, we have:2H + 2D = H + D + L â€“&gt; H + D = nL â€“&gt; H = nL - DThus if two pointers start from head and X, respectively, one first reaches E, the other also reaches E.In my solution, since fast starts at head.next, we need to move slow one step forward in the beginning of part 2 123456789101112131415161718192021class Solution: # @param head, a ListNode # @return a list node def detectCycle(self, head): try: fast = head.next slow = head while fast is not slow: fast = fast.next.next slow = slow.next except: # if there is an exception, we reach the end and there is no cycle return None # since fast starts at head.next, we need to move slow one step forward slow = slow.next while head is not slow: head = head.next slow = slow.next return head https://discuss.leetcode.com/topic/5438/sharing-my-python-solution Sharing my Python solution Same idea as many other posts, just the python version: 12345678910111213def detectCycle(self, head): slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None while head != slow: slow = slow.next head = head.next return head java 1ms, September 22, 2016 https://discuss.leetcode.com/topic/19367/java-o-1-space-solution-with-detailed-explanation Java O(1) space solution with detailed explanation. Define two pointers slow and fast. Both start at head node, fast is twice as fast as slow. If it reaches the end it means there is no cycle, otherwise eventually it will eventually catch up to slow pointer somewhere in the cycle. Let the distance from the first node to the the node where cycle begins be A, and let say the slow pointer travels travels A+B. The fast pointer must travel 2A+2B to catch up. The cycle size is N. Full cycle is also how much more fast pointer has traveled than slow pointer at meeting point. 12A+B+N = 2A+2BN=A+B From our calculation slow pointer traveled exactly full cycle when it meets fast pointer, and since originally it travled A before starting on a cycle, it must travel A to reach the point where cycle begins! We can start another slow pointer at head node, and move both pointers until they meet at the beginning of a cycle. 123456789101112131415161718192021public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while (fast!=null &amp;&amp; fast.next!=null)&#123; fast = fast.next.next; slow = slow.next; if (fast == slow)&#123; ListNode slow2 = head; while (slow2 != slow)&#123; slow = slow.next; slow2 = slow2.next; &#125; return slow; &#125; &#125; return null; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[141. Linked List Cycle]]></title>
    <url>%2Fp%2F20f14e92%2F</url>
    <content type="text"><![CDATA[35.6% https://leetcode.com/problems/linked-list-cycle/description/ Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? æ–¹æ³•ä¸€ï¼š ä¸€ä¸ªå¿«æŒ‡é’ˆï¼Œä¸€ä¸ªæ…¢æŒ‡é’ˆ https://discuss.leetcode.com/topic/4218/my-faster-and-slower-runner-solution My faster and slower runner solution 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ /** use faster and lower runner solution. (2 pointers) the faster one move 2 steps, and slower one move only one step. if there&apos;s a circle, the faster one will finally &quot;catch&quot; the slower one. (the distance between these 2 pointers will decrease one every time.) if there&apos;s no circle, the faster runner will reach the end of linked list. (NULL) */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head == NULL || head -&gt; next == NULL) return false; ListNode *fast = head; ListNode *slow = head; while(fast -&gt; next &amp;&amp; fast -&gt; next -&gt; next)&#123; fast = fast -&gt; next -&gt; next; slow = slow -&gt; next; if(fast == slow) return true; &#125; return false; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ä¸€ï¼š 1234567891011121314class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head==NULL) return false; ListNode* slow, *fast; slow = head; fast = head-&gt;next; while(slow!=fast&amp;&amp;fast!=NULL &amp;&amp; fast-&gt;next!=NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow==fast; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°äºŒï¼š 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(!head || !head-&gt;next) return false; ListNode* slow = head, *fast = head-&gt;next; while(fast!=NULL &amp;&amp; fast-&gt;next!=NULL)&#123; if(slow==fast) return true; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/16098/except-ionally-fast-python Except-ionally fast Python Took 88 ms and the â€œAccepted Solutions Runtime Distributionâ€ doesnâ€™t show any faster Python submissions. The â€œtrickâ€ is to not check all the time whether we have reached the end but to handle it via an exception. â€œEasier to ask for forgiveness than permission.â€ The algorithm is of course Tortoise and hare. 12345678910def hasCycle(self, head): try: slow = head fast = head.next while slow is not fast: slow = slow.next fast = fast.next.next return True except: return False java https://discuss.leetcode.com/topic/12516/o-1-space-solution O(1) Space Solution 1234567891011public boolean hasCycle(ListNode head) &#123; if(head==null) return false; ListNode walker = head; ListNode runner = head; while(runner.next!=null &amp;&amp; runner.next.next!=null) &#123; walker = walker.next; runner = runner.next.next; if(walker==runner) return true; &#125; return false;&#125; Use two pointers, walker and runner. walker moves step by step. runner moves two steps at time. if the Linked List has a cycle walker and runner will meet at some point. 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head == null) return false; ListNode slow, fast; slow = head; fast = head; while(fast.next!=null &amp;&amp; fast.next.next != null)&#123; slow = slow.next; fast = fast.next.next; if(slow==fast) return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>linked list</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[140. Word Break II]]></title>
    <url>%2Fp%2F2ce5facb%2F</url>
    <content type="text"><![CDATA[23.3% https://leetcode.com/problems/word-break-ii/ Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words. Return all such possible sentences. 12345For example, givens = &quot;catsanddog&quot;,dict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;].A solution is [&quot;cats and dog&quot;, &quot;cat sand dog&quot;]. UPDATE (2017/1/4):The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. è¿˜éœ€è¦æ€è€ƒ æ–¹æ³•ä¸€: https://discuss.leetcode.com/topic/12997/11ms-c-solution-concise 11ms C++ solution (concise) 1234567891011121314151617181920212223242526272829class Solution &#123; unordered_map&lt;string, vector&lt;string&gt;&gt; m; vector&lt;string&gt; combine(string word, vector&lt;string&gt; prev)&#123; for(int i=0;i&lt;prev.size();++i)&#123; prev[i]+=&quot; &quot;+word; &#125; return prev; &#125;public: vector&lt;string&gt; wordBreak(string s, unordered_set&lt;string&gt;&amp; dict) &#123; if(m.count(s)) return m[s]; //take from memory vector&lt;string&gt; result; if(dict.count(s))&#123; //a whole string is a word result.push_back(s); &#125; for(int i=1;i&lt;s.size();++i)&#123; string word=s.substr(i); if(dict.count(word))&#123; string rem=s.substr(0,i); vector&lt;string&gt; prev=combine(word,wordBreak(rem,dict)); result.insert(result.end(),prev.begin(), prev.end()); &#125; &#125; m[s]=result; //memorize return result; &#125;&#125;; æ–¹æ³•äºŒï¼š https://discuss.leetcode.com/topic/35762/9-lines-python-10-lines-c 9 lines Python, 10 lines C++ 123456789101112vector&lt;string&gt; wordBreak(string s, unordered_set&lt;string&gt;&amp; wordDict) &#123; unordered_map&lt;int, vector&lt;string&gt;&gt; memo &#123;&#123;s.size(), &#123;&quot;&quot;&#125;&#125;&#125;; function&lt;vector&lt;string&gt;(int)&gt; sentences = [&amp;](int i) &#123; if (!memo.count(i)) for (int j=i+1; j&lt;=s.size(); j++) if (wordDict.count(s.substr(i, j-i))) for (string tail : sentences(j)) memo[i].push_back(s.substr(i, j-i) + (tail==&quot;&quot; ? &quot;&quot; : &apos; &apos; + tail)); return memo[i]; &#125;; return sentences(0);&#125; æ–¹æ³•ä¸‰ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š è¶…æ—¶äº† â€œaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaâ€[â€œaâ€,â€aaâ€,â€aaaâ€,â€aaaaâ€,â€aaaaaâ€,â€aaaaaaâ€,â€aaaaaaaâ€,â€aaaaaaaaâ€,â€aaaaaaaaaâ€,â€aaaaaaaaaaâ€] 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; int n = s.size(); unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); unordered_map&lt;int, vector&lt;vector&lt;string&gt;&gt;&gt; memo; vector&lt;vector&lt;string&gt;&gt; tmp&#123;vector&lt;vector&lt;string&gt;&gt;(1, vector&lt;string&gt;(1, ""))&#125;; memo[0] = tmp; for(int i=1; i&lt;=n; i++)&#123; // ä¸¥æ ¼åŒºåˆ† ++ -- vector&lt;vector&lt;string&gt;&gt; v; bool flag = false; for(int j=i-1; j&gt;=0; j--)&#123; string word = s.substr(j, i-j); if(wordSet.find(word)!=wordSet.end() &amp;&amp; memo.find(j)!=memo.end())&#123; flag = true; for(auto cur:memo[j])&#123; cur.push_back(word); v.push_back(cur); &#125; &#125; &#125; if(flag) memo[i] = v; &#125; vector&lt;string&gt; res; for(int i=0; i&lt;memo[n].size(); i++)&#123; string t = memo[n][i][1]; for(int j=2; j&lt;memo[n][i].size(); j++) t += " " + memo[n][i][j]; res.push_back(t); &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/35762/9-lines-python-10-lines-c 9 lines Python, 10 lines C++ 12345678910def wordBreak(self, s, wordDict): memo = &#123;len(s): [&apos;&apos;]&#125; def sentences(i): if i not in memo: memo[i] = [s[i:j] + (tail and &apos; &apos; + tail) for j in range(i+1, len(s)+1) if s[i:j] in wordDict for tail in sentences(j)] return memo[i] return sentences(0) java https://discuss.leetcode.com/topic/27855/my-concise-java-solution-based-on-memorized-dfs My concise JAVA solution based on memorized DFS 18ms, 34.39%, Jan.13 2017 Explanation Using DFS directly will lead to TLE, so I just used HashMap to save the previous results to prune duplicated branches, as the following: 1234567891011121314151617181920212223242526public class Solution &#123; public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123; return DFS(s, wordDict, new HashMap&lt;String, LinkedList&lt;String&gt;&gt;()); &#125; // DFS function returns an array including all substrings derived from s. List&lt;String&gt; DFS(String s, List&lt;String&gt; wordDict, HashMap&lt;String, LinkedList&lt;String&gt;&gt;map) &#123; if (map.containsKey(s)) return map.get(s); LinkedList&lt;String&gt;res = new LinkedList&lt;String&gt;(); if (s.length() == 0) &#123; res.add(&quot;&quot;); return res; &#125; for (String word : wordDict) &#123; if (s.startsWith(word)) &#123; List&lt;String&gt;sublist = DFS(s.substring(word.length()), wordDict, map); for (String sub : sublist) res.add(word + (sub.isEmpty() ? &quot;&quot; : &quot; &quot;) + sub); &#125; &#125; map.put(s, res); return res; &#125;&#125; Brilliant idea, also can be simplified like this. 1234567891011121314151617181920212223public class Solution &#123;HashMap&lt;String, LinkedList&lt;String&gt;&gt; map = new HashMap&lt;String, LinkedList&lt;String&gt;&gt;();public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; if (map.containsKey(s)) return map.get(s); LinkedList&lt;String&gt; res = new LinkedList&lt;String&gt;(); if (s.length() == 0) &#123; res.add(&quot;&quot;); return res; &#125; for (String word : wordDict) &#123; if (s.startsWith(word)) &#123; List&lt;String&gt; sublist = wordBreak(s.substring(word.length()), wordDict); for (String sub : sublist) res.add(word + (sub.isEmpty() ? &quot;&quot; : &quot; &quot;) + sub); &#125; &#125; map.put(s, res); return res;&#125;&#125; https://discuss.leetcode.com/topic/9837/my-concise-answer My concise answer. 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; dict) &#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;(); for(int j = s.length() - 1; j &gt;= 0; j--)&#123; if(dict.contains(s.substring(j))) break; else&#123; if(j == 0) return result; &#125; &#125; for(int i = 0; i &lt; s.length()-1; i++) &#123; if(dict.contains(s.substring(0,i+1))) &#123; List&lt;String&gt; strs = wordBreak(s.substring(i+1,s.length()),dict); if(strs.size() != 0) for(Iterator&lt;String&gt; it = strs.iterator();it.hasNext();) &#123; result.add(s.substring(0,i+1)+&quot; &quot;+it.next()); &#125; &#125; &#125; if(dict.contains(s)) result.add(s); return result; &#125;&#125; https://discuss.leetcode.com/topic/8178/slightly-modified-dp-java-solution Slightly modified DP Java solution Hi guys! Thereâ€™s a lot of concern in other posts about â€œaaaaâ€¦aabâ€ test case that causes TLE when we run through our string not in reverse but from start to end. Iâ€™ve thought a bit on how to add a tiny modification and make just the whole thing more effective, not only pass the TLE case. The approach is the same as before: we loop through all possible prefixes checking if it in the dictionary and caching the results. But just before jumping into recursion we could also check that the right reminder has a prefix from the dictionary, because if it hasnâ€™t then thereâ€™s no sense in splitting the reminder into sub-strings. Itâ€™s just a linear check, which I think also could be optimized with some caching but even without optimization the solution is accepted. And also the code looks quite understandable. 123456789101112131415161718192021222324252627public class Solution &#123; private final Map&lt;String, List&lt;String&gt;&gt; cache = new HashMap&lt;&gt;(); private boolean containsSuffix(Set&lt;String&gt; dict, String str) &#123; for (int i = 0; i &lt; str.length(); i++) &#123; if (dict.contains(str.substring(i))) return true; &#125; return false; &#125; public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; dict) &#123; if (cache.containsKey(s)) return cache.get(s); List&lt;String&gt; result = new LinkedList&lt;&gt;(); if (dict.contains(s)) result.add(s); for (int i = 1; i &lt; s.length(); i++) &#123; String left = s.substring(0,i), right = s.substring(i); if (dict.contains(left) &amp;&amp; containsSuffix(dict, right)) &#123; for (String ss : wordBreak(right, dict)) &#123; result.add(left + &quot; &quot; + ss); &#125; &#125; &#125; cache.put(s, result); return result; &#125;&#125; https://discuss.leetcode.com/topic/39833/java-6ms-simple-solution-beating-88 Java 6ms simple solution beating 88% 1234567891011121314151617181920212223242526272829public class Solution &#123; HashMap&lt;Integer, List&lt;String&gt;&gt; dp = new HashMap&lt;&gt;(); public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; int maxLength = -1; for(String ss : wordDict) maxLength = Math.max(maxLength, ss.length()); return addSpaces(s, wordDict, 0, maxLength); &#125; private List&lt;String&gt; addSpaces(String s, Set&lt;String&gt; wordDict, int start, int max)&#123; List&lt;String&gt; words = new ArrayList&lt;&gt;(); if(start == s.length()) &#123; words.add(&quot;&quot;); return words; &#125; for(int i = start + 1; i &lt;= max + start &amp;&amp; i &lt;= s.length(); i++)&#123; String temp = s.substring(start, i); if(wordDict.contains(temp))&#123; List&lt;String&gt; ll; if(dp.containsKey(i)) ll = dp.get(i); else ll = addSpaces(s, wordDict, i, max); for(String ss : ll) words.add(temp + (ss.equals(&quot;&quot;) ? &quot;&quot; : &quot; &quot;) + ss); &#125; &#125; dp.put(start, words); return words; &#125;&#125; https://discuss.leetcode.com/topic/3495/my-dp-solution-in-java My DP solution in JAVA Basically my idea is the following: Scan the the string from the tail Build possible solution for the current index based on DP results Return the solution when index==0 123456789101112131415161718192021222324public class Solution &#123; public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; dict) &#123; Map&lt;Integer, List&lt;String&gt;&gt; validMap = new HashMap&lt;Integer, List&lt;String&gt;&gt;(); // initialize the valid values List&lt;String&gt; l = new ArrayList&lt;String&gt;(); l.add(&quot;&quot;); validMap.put(s.length(), l); // generate solutions from the end for(int i = s.length() - 1; i &gt;= 0; i--) &#123; List&lt;String&gt; values = new ArrayList&lt;String&gt;(); for(int j = i + 1; j &lt;= s.length(); j++) &#123; if (dict.contains(s.substring(i, j))) &#123; for(String word : validMap.get(j)) &#123; values.add(s.substring(i, j) + (word.isEmpty() ? &quot;&quot; : &quot; &quot;) + word); &#125; &#125; &#125; validMap.put(i, values); &#125; return validMap.get(0); &#125;&#125; https://discuss.leetcode.com/topic/34260/java-dp-dfs-memoization-dfs-and-dp-pruning-solutions-with-analysis Java DP+DFS, Memoization+DFS, and DP Pruning Solutions with Analysis Iâ€™ve been struggling with this problem for a long time, and Iâ€™d love to share three different strategies I have tried to solve it. All of them are ACed. Method 1: DP + DFS. Very similar to Word Break I, but instead of using a boolean dp array, I used an array of Lists to maintain all of the valid start positions for every end position. Then just do classic backtracking to find all solutions. The time complexity is O(n*m) + O(n * number of solutions), where n is the length of the input string, m is the length of the longest word in the dictionary. The run time was 6ms. It is very efficient because DP is used to find out all the valid answers, and no time is wasted on doing the backtracking. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; List&lt;Integer&gt;[] starts = new List[s.length() + 1]; // valid start positions starts[0] = new ArrayList&lt;Integer&gt;(); int maxLen = getMaxLen(wordDict); for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = i - 1; j &gt;= i - maxLen &amp;&amp; j &gt;= 0; j--) &#123; if (starts[j] == null) continue; String word = s.substring(j, i); if (wordDict.contains(word)) &#123; if (starts[i] == null) &#123; starts[i] = new ArrayList&lt;Integer&gt;(); &#125; starts[i].add(j); &#125; &#125; &#125; List&lt;String&gt; rst = new ArrayList&lt;&gt;(); if (starts[s.length()] == null) &#123; return rst; &#125; dfs(rst, "", s, starts, s.length()); return rst;&#125;private void dfs(List&lt;String&gt; rst, String path, String s, List&lt;Integer&gt;[] starts, int end) &#123; if (end == 0) &#123; rst.add(path.substring(1)); return; &#125; for (Integer start: starts[end]) &#123; String word = s.substring(start, end); dfs(rst, " " + word + path, s, starts, start); &#125;&#125;private int getMaxLen(Set&lt;String&gt; wordDict) &#123; int max = 0; for (String s : wordDict) &#123; max = Math.max(max, s.length()); &#125; return max;&#125; Method 2: Memoization + Backtracking. Before I came up with Method 1, I also tried using a HashMap to memoize all the possible strings that can be formed starting from index i. I referred to this post from @Pixel_The time complexity is O(len(wordDict) ^ len(s / minWordLenInDict)) as @Pixel_ mentioned. The space complexity would be larger than other methods though. Here is my code: 1234567891011121314151617181920212223242526272829public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; HashMap&lt;Integer, List&lt;String&gt;&gt; memo = new HashMap&lt;&gt;(); // &lt;Starting index, rst list&gt; return dfs(s, 0, wordDict, memo);&#125;private List&lt;String&gt; dfs(String s, int start, Set&lt;String&gt; dict, HashMap&lt;Integer, List&lt;String&gt;&gt; memo) &#123; if (memo.containsKey(start)) &#123; return memo.get(start); &#125; List&lt;String&gt; rst = new ArrayList&lt;&gt;(); if (start == s.length()) &#123; rst.add(""); return rst; &#125; String curr = s.substring(start); for (String word: dict) &#123; if (curr.startsWith(word)) &#123; List&lt;String&gt; sublist = dfs(s, start + word.length(), dict, memo); for (String sub : sublist) &#123; rst.add(word + (sub.isEmpty() ? "" : " ") + sub); &#125; &#125; &#125; memo.put(start, rst); return rst;&#125; Method 3: DP Prunning + Backtracking. My very first solution is like this: using a boolean array to memoize whether a substring starting from position i to the end is breakable. This works well for worst cases like: s = â€œaaaaaaaaaaaabâ€, dict = [â€œaâ€, â€œaaâ€, â€œaaaâ€, â€œaaaaâ€]. However, for cases like: s = â€œaaaaaaaaaaaaaâ€, dict = [â€œaâ€, â€œaaâ€, â€œaaaâ€, â€œaaaaâ€], the time complexity is still O(2^n). Here is the code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; List&lt;String&gt; rst = new ArrayList&lt;&gt;(); if (s == null || s.length() == 0 || wordDict == null) &#123; return rst; &#125; boolean[] canBreak = new boolean[s.length()]; Arrays.fill(canBreak, true); StringBuilder sb = new StringBuilder(); dfs(rst, sb, s, wordDict, canBreak, 0); return rst;&#125;private void dfs(List&lt;String&gt; rst, StringBuilder sb, String s, Set&lt;String&gt; dict, boolean[] canBreak, int start) &#123; if (start == s.length()) &#123; rst.add(sb.substring(1)); return; &#125; if (!canBreak[start]) &#123; return; &#125; for (int i = start + 1; i &lt;= s.length(); i++) &#123; String word = s.substring(start, i); if (!dict.contains(word)) continue; int sbBeforeAdd = sb.length(); sb.append(" " + word); int rstBeforeDFS = rst.size(); dfs(rst, sb, s, dict, canBreak, i); if (rst.size() == rstBeforeDFS) &#123; canBreak[i] = false; &#125; sb.delete(sbBeforeAdd, sb.length()); &#125;&#125;private int getMaxLen(Set&lt;String&gt; wordDict) &#123; int max = 0; for (String s : wordDict) &#123; max = Math.max(max, s.length()); &#125; return max;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[139. Word Break]]></title>
    <url>%2Fp%2Fc7e5d8ed%2F</url>
    <content type="text"><![CDATA[28.9% https://leetcode.com/problems/word-break/ Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words. 12345For example, givens = &quot;leetcode&quot;,dict = [&quot;leet&quot;, &quot;code&quot;].Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;. UPDATE (2017/1/4): The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°: 1234567891011121314151617181920212223class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; int n = s.size(); if(n==0) return true; vector&lt;bool&gt; dp(n+1, false); dp[0] = true; // vector to unordered_setçš„ç”¨æ³•ï¼Œé‡ç‚¹å­¦ä¹ ä¸€ä¸‹ unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); for(int i=1; i&lt;=n; i++)&#123; for(int j=i-1; j&gt;=0; j--)&#123; if(dp[j])&#123; string word = s.substr(j, i-j); if(wordSet.find(word)!=wordSet.end())&#123; dp[i] = true; break; &#125; &#125; &#125; &#125; return dp[n]; &#125;&#125;; https://discuss.leetcode.com/topic/7299/c-dynamic-programming-simple-and-fast-solution-4ms-with-optimization 6ms, September 9, 2016 C++ Dynamic Programming simple and fast solution (4ms) with optimization We use a boolean vector dp[]. dp[i] is set to true if a valid word (word sequence) ends there. The optimization is to look from current position i back and only substring and do dictionary look up in case the preceding position j with dp[j] == true is found. 12345678910111213141516171819202122class Solution &#123;public: bool wordBreak(string s, unordered_set&lt;string&gt;&amp; wordDict) &#123; if(wordDict.size()==0) return false; vector&lt;bool&gt; dp(s.size()+1, false); dp[0]=true; for(int i=1; i&lt;=s.size(); i++)&#123; for(int j=i-1; j&gt;=0; j--)&#123; if(dp[j])&#123; string word = s.substr(j, i-j); if(wordDict.find(word)!=wordDict.end())&#123; dp[i] = true; break; &#125; &#125; &#125; &#125; return dp[s.size()]; &#125;&#125;; https://discuss.leetcode.com/topic/2545/a-solution-using-bfs A solution using BFS People have posted elegant solutions using DP. The solution I post below using BFS is no better than those. Just to share some new thoughts. We can use a graph to represent the possible solutions. The vertices of the graph are simply the positions of the first characters of the words and each edge actually represents a word. For example, the input string is â€œnightmareâ€, there are two ways to break it, â€œnight mareâ€ and â€œnightmareâ€. The graph would be 0â€“&gt;5â€“&gt;9 | _^ The question is simply to check if there is a path from 0 to 9. The most efficient way is traversing the graph using BFS with the help of a queue and a hash set. The hash set is used to keep track of the visited nodes to avoid repeating the same work. For this problem, the time complexity is O(n^2) and space complexity is O(n), the same with DP. This idea can be used to solve the problem word break II. We can simple construct the graph using BFS, save it into a map and then find all the paths using DFS. 12345678910111213141516171819202122232425262728bool wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) &#123; // BFS queue&lt;int&gt; BFS; unordered_set&lt;int&gt; visited; BFS.push(0); while(BFS.size() &gt; 0) &#123; int start = BFS.front(); BFS.pop(); if(visited.find(start) == visited.end()) &#123; visited.insert(start); for(int j=start; j&lt;s.size(); j++) &#123; string word(s, start, j-start+1); if(dict.find(word) != dict.end()) &#123; BFS.push(j+1); if(j+1 == s.size()) return true; &#125; &#125; &#125; &#125; return false;&#125; python https://discuss.leetcode.com/topic/8109/simple-dp-solution-in-python-with-description Simple DP solution in Python with description 75ms, 18.48%, September 7, 2016 The idea is the following: d is an array that contains booleans d[i] is True if there is a word in the dictionary that ends at ith index of s AND d is also True at the beginning of the word Example: s = â€œleetcodeâ€ words = [â€œleetâ€, â€œcodeâ€] d[3] is True because there is â€œleetâ€ in the dictionary that ends at 3rd index of â€œleetcodeâ€ d[7] is True because there is â€œcodeâ€ in the dictionary that ends at the 7th index of â€œleetcodeâ€ AND d[3] is True The result is the last index of d.12345678910111213class Solution(object): def wordBreak(self, s, wordDict): &quot;&quot;&quot; :type s: str :type wordDict: Set[str] :rtype: bool &quot;&quot;&quot; d = [False] * len(s) for i in range(len(s)): for w in wordDict: if w == s[i-len(w)+1:i+1] and (d[i-len(w)] or i-len(w) == -1): d[i] = True return d[-1] https://discuss.leetcode.com/topic/16701/4-lines-in-python 4 lines in Python ok[i] tells whether s[:i] can be built. 12345def wordBreak(self, s, words): ok = [True] for i in range(1, len(s)+1): ok += any(ok[j] and s[j:i] in words for j in range(i)), return ok[-1] java https://discuss.leetcode.com/topic/6156/java-implementation-using-dp-in-two-ways 12ms, September 9, 2016 Java implementation using DP in two ways 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public boolean wordBreak(String s, Set&lt;String&gt; dict) &#123; boolean[] f = new boolean[s.length() + 1]; f[0] = true; /* First DP for(int i = 1; i &lt;= s.length(); i++)&#123; for(String str: dict)&#123; if(str.length() &lt;= i)&#123; if(f[i - str.length()])&#123; if(s.substring(i-str.length(), i).equals(str))&#123; f[i] = true; break; &#125; &#125; &#125; &#125; &#125;*/ //Second DP for(int i=1; i &lt;= s.length(); i++)&#123; for(int j=0; j &lt; i; j++)&#123; if(f[j] &amp;&amp; dict.contains(s.substring(j, i)))&#123; f[i] = true; break; &#125; &#125; &#125; return f[s.length()]; &#125;&#125; https://discuss.leetcode.com/topic/9615/dfs-with-path-memorizing-java-solution DFS with Path Memorizing Java Solution I write this method by what I learned from @mahdy in his post Decode Ways Use a set to record all position that cannot find a match in dict. That cuts down the run time of DFS to O(n^2) 12345678910111213141516171819202122232425public class Solution &#123; public boolean wordBreak(String s, Set&lt;String&gt; dict) &#123; // DFS Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); return dfs(s, 0, dict, set); &#125; private boolean dfs(String s, int index, Set&lt;String&gt; dict, Set&lt;Integer&gt; set)&#123; // base case if(index == s.length()) return true; // check memory if(set.contains(index)) return false; // recursion for(int i = index+1;i &lt;= s.length();i++)&#123; String t = s.substring(index, i); if(dict.contains(t)) if(dfs(s, i, dict, set)) return true; else set.add(i); &#125; set.add(index); return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[138. Copy List with Random Pointer]]></title>
    <url>%2Fp%2F9bcae609%2F</url>
    <content type="text"><![CDATA[26.5% https://leetcode.com/problems/copy-list-with-random-pointer/#/description A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. https://discuss.leetcode.com/topic/5831/2-clean-c-algorithms-without-using-extra-array-hash-table-algorithms-are-explained-step-by-step 2 clean C++ algorithms without using extra array/hash table. Algorithms are explained step by step. 123456789101112131415161718192021222324252627282930313233343536373839//// Here&apos;s how the 1st algorithm goes.// Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.// Step 1:// Build the 2nd list by creating a new node for each node in 1st list. // While doing so, insert each new node after it&apos;s corresponding node in the 1st list.// Step 2:// The new head is the 2nd node as that was the first inserted node.// Step 3:// Fix the random pointers in the 2nd list: (Remember that l1-&gt;next is actually l2)// l2-&gt;random will be the node in 2nd list that corresponds l1-&gt;random, // which is next node of l1-&gt;random.// Step 4:// Separate the combined list into 2: Splice out nodes that are part of second list. // Return the new head that we saved in step 2.//RandomListNode *copyRandomList(RandomListNode *head) &#123; RandomListNode *newHead, *l1, *l2; if (head == NULL) return NULL; for (l1 = head; l1 != NULL; l1 = l1-&gt;next-&gt;next) &#123; l2 = new RandomListNode(l1-&gt;label); l2-&gt;next = l1-&gt;next; l1-&gt;next = l2; &#125; newHead = head-&gt;next; for (l1 = head; l1 != NULL; l1 = l1-&gt;next-&gt;next) &#123; if (l1-&gt;random != NULL) l1-&gt;next-&gt;random = l1-&gt;random-&gt;next; &#125; for (l1 = head; l1 != NULL; l1 = l1-&gt;next) &#123; l2 = l1-&gt;next; l1-&gt;next = l2-&gt;next; if (l2-&gt;next != NULL) l2-&gt;next = l2-&gt;next-&gt;next; &#125; return newHead;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//// Here&apos;s how the 2nd algorithm goes.// Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.// Step 1:// Build the 2nd list by creating a new node for each node in 1st list. // While doing so, set the next pointer of the new node to the random pointer // of the corresponding node in the 1st list. And set the random pointer of the // 1st list&apos;s node to the newly created node.// Step 2:// The new head is the node pointed to by the random pointer of the 1st list.// Step 3:// Fix the random pointers in the 2nd list: (Remember that l1-&gt;random is l2)// l2-&gt;random will be the node in 2nd list that corresponds to the node in the // 1st list that is pointed to by l2-&gt;next, // Step 4:// Restore the random pointers of the 1st list and fix the next pointers of the // 2nd list. random pointer of the node in 1st list is the next pointer of the // corresponding node in the 2nd list. This is what we had done in the // 1st step and now we are reverting back. next pointer of the node in // 2nd list is the random pointer of the node in 1st list that is pointed to // by the next pointer of the corresponding node in the 1st list.// Return the new head that we saved in step 2.//RandomListNode *copyRandomList(RandomListNode *head) &#123; RandomListNode *newHead, *l1, *l2; if (head == NULL) return NULL; for (l1 = head; l1 != NULL; l1 = l1-&gt;next) &#123; l2 = new RandomListNode(l1-&gt;label); l2-&gt;next = l1-&gt;random; l1-&gt;random = l2; &#125; newHead = head-&gt;random; for (l1 = head; l1 != NULL; l1 = l1-&gt;next) &#123; l2 = l1-&gt;random; l2-&gt;random = l2-&gt;next ? l2-&gt;next-&gt;random : NULL; &#125; for (l1 = head; l1 != NULL; l1 = l1-&gt;next) &#123; l2 = l1-&gt;random; l1-&gt;random = l2-&gt;next; l2-&gt;next = l1-&gt;next ? l1-&gt;next-&gt;random : NULL; &#125; return newHead;&#125; https://discuss.leetcode.com/topic/22194/o-n-time-o-1-space-c O(n) time O(1) Space C++ 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode * head) &#123; RandomListNode * head_cp = nullptr, * cur = head, * cur_cp = nullptr; if (head == nullptr) return nullptr; while (cur != nullptr) &#123; cur_cp = new RandomListNode (cur-&gt;label); cur_cp-&gt;next = cur-&gt;next; cur-&gt;next = cur_cp; cur = cur_cp-&gt;next; &#125; cur = head; while (cur != nullptr) &#123; cur_cp = cur-&gt;next; if (cur-&gt;random) cur_cp-&gt;random = cur-&gt;random-&gt;next; cur = cur_cp -&gt;next; &#125; cur = head; head_cp = head-&gt;next; while (cur != nullptr) &#123; cur_cp = cur-&gt;next; cur-&gt;next = cur_cp-&gt;next; cur = cur-&gt;next; if (cur) cur_cp-&gt;next = cur-&gt;next; &#125; return head_cp; &#125;&#125;; https://discuss.leetcode.com/topic/12025/c-simple-recursive-solution C++ simple recursive solution 12345678910111213141516class Solution &#123;unordered_map&lt;RandomListNode*, RandomListNode*&gt; hmap;public:RandomListNode *copyRandomList(RandomListNode *head) &#123; if (!head) return NULL; if (hmap.find(head) != hmap.end()) return hmap.find(head)-&gt;second; RandomListNode* node = new RandomListNode(head-&gt;label); hmap[head] = node; node-&gt;next = copyRandomList(head-&gt;next); node-&gt;random = copyRandomList(head-&gt;random); return node;&#125;&#125;; https://discuss.leetcode.com/topic/7594/a-solution-with-constant-space-complexity-o-1-and-linear-time-complexity-o-n A solution with constant space complexity O(1) and linear time complexity O(N) An intuitive solution is to keep a hash table for each node in the list, via which we just need to iterate the list in 2 rounds respectively to create nodes and assign the values for their random pointers. As a result, the space complexity of this solution is O(N), although with a linear time complexity. As an optimised solution, we could reduce the space complexity into constant. The idea is to associate the original node with its copy node in a single linked list. In this way, we donâ€™t need extra space to keep track of the new nodes. The algorithm is composed of the follow three steps which are also 3 iteration rounds. Iterate the original list and duplicate each node. The duplicate of each node follows its original immediately. Iterate the new list and assign the random pointer for each duplicated node. Restore the original list and extract the duplicated nodes. The algorithm is implemented as follows: 123456789101112131415161718192021222324252627282930313233343536373839404142434445public RandomListNode copyRandomList(RandomListNode head) &#123; RandomListNode iter = head, next; // First round: make copy of each node, // and link them together side-by-side in a single list. while (iter != null) &#123; next = iter.next; RandomListNode copy = new RandomListNode(iter.label); iter.next = copy; copy.next = next; iter = next; &#125; // Second round: assign random pointers for the copy nodes. iter = head; while (iter != null) &#123; if (iter.random != null) &#123; iter.next.random = iter.random.next; &#125; iter = iter.next.next; &#125; // Third round: restore the original list, and extract the copy list. iter = head; RandomListNode pseudoHead = new RandomListNode(0); RandomListNode copy, copyIter = pseudoHead; while (iter != null) &#123; next = iter.next.next; // extract the copy copy = iter.next; copyIter.next = copy; copyIter = copy; // restore the original list iter.next = next; iter = next; &#125; return pseudoHead.next;&#125; https://discuss.leetcode.com/topic/18086/java-o-n-solution Java O(n) solution 12345678910111213141516171819202122public RandomListNode copyRandomList(RandomListNode head) &#123; if (head == null) return null; Map&lt;RandomListNode, RandomListNode&gt; map = new HashMap&lt;RandomListNode, RandomListNode&gt;(); // loop 1. copy all the nodes RandomListNode node = head; while (node != null) &#123; map.put(node, new RandomListNode(node.label)); node = node.next; &#125; // loop 2. assign next and random pointers node = head; while (node != null) &#123; map.get(node).next = map.get(node.next); map.get(node).random = map.get(node.random); node = node.next; &#125; return map.get(head);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[137. Single Number II]]></title>
    <url>%2Fp%2F3b63b6e2%2F</url>
    <content type="text"><![CDATA[40.5% https://leetcode.com/problems/single-number-ii/?tab=Description Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? æ–¹æ³•ä¸€ï¼š ç»Ÿè®¡æ¯ä¸€ä½çš„ä¸ªæ•°ï¼Œæ¨¡3ï¼Œç„¶åŽå°±æ˜¯ç­”æ¡ˆäº† æ–¹æ³•äºŒï¼š https://discuss.leetcode.com/topic/2031/challenge-me-thx Challenge me , thx 12345678public int singleNumber(int[] A) &#123; int ones = 0, twos = 0; for(int i = 0; i &lt; A.length; i++)&#123; ones = (ones ^ A[i]) &amp; ~twos; twos = (twos ^ A[i]) &amp; ~ones; &#125; return ones;&#125; https://discuss.leetcode.com/topic/11877/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers Detailed explanation and generalization of the bitwise operation method for single numbers Statement of our problem: â€œGiven an array of integers, every element appears k (k &gt; 1) times except for one, which appears p times (p &gt;= 1, p % k != 0). Find that single one.â€ As others pointed out, in order to apply the bitwise operations, we should rethink how integers are represented in computers â€“ by bits. To start, letâ€™s consider only one bit for now. Suppose we have an array of 1-bit numbers (which can only be 0 or 1), weâ€™d like to count the number of 1â€™s in the array such that whenever the counted number of 1 reaches a certain value, say k, the count returns to zero and starts over (In case you are curious, this k will be the same as the one in the problem statement above). To keep track of how many 1â€™s we have encountered so far, we need a counter. Suppose the counter has m bits in binary form: xm, â€¦, x1 (from most significant bit to least significant bit). We can conclude at least the following four properties of the counter: There is an initial state of the counter, which for simplicity is zero; For each input from the array, if we hit a 0, the counter should remain unchanged; For each input from the array, if we hit a 1, the counter should increase by one; In order to cover k counts, we require 2^m &gt;= k, which implies m &gt;= logk. Here is the key part: how each bit in the counter (x1 to xm) changes as we are scanning the array. Note we are prompted to use bitwise operations. In order to satisfy the second property, recall what bitwise operations will not change the operand if the other operand is 0? Yes, you got it: x = x | 0 and x = x ^ 0. Okay, we have an expression now: x = x | i or x = x ^ i, where i is the scanned element from the array. Which one is better? We donâ€™t know yet. So, letâ€™s just do the actual counting: At the beginning, all bits of the counter is initialized to zero, i.e., xm = 0, â€¦, x1 = 0. Since we are gonna choose bitwise operations that guarantee all bits of the counter remain unchanged if we hit 0â€™s, the counter will be 0 until we hit the first 1 in the array. After we hit the first 1, we got: xm = 0, â€¦,x2 = 0, x1 = 1. Letâ€™s continue until we hit the second 1, after which we have: xm = 0, â€¦, x2 = 1, x1 = 0. Note that x1 changed from 1 to 0. For x1 = x1 | i, after the second count, x1 will still be 1. So itâ€™s clear we should use x1 = x1 ^ i. What about x2, â€¦, xm? The idea is to find the condition under which x2, â€¦, xm will change their values. Take x2 as an example. If we hit a 1 and need to change the value of x2, what must be the value of x1 right before we do the change? The answer is: x1 must be 1 otherwise we shouldnâ€™t change x2 because changing x1 from 0 to 1 will do the job. So x2 will change value only if x1 and i are both 1, or mathematically, x2 = x2 ^ (x1 &amp; i). Similarly xm will change value only when xm-1, â€¦, x1 and i are all 1: xm = xm ^ (xm-1 &amp; â€¦ &amp; x1 &amp; i). Bingo, weâ€™ve found the bitwise operations! However, you may notice that the bitwise operations found above will count from 0 until 2^m - 1, instead of k. If k &lt; 2^m - 1, we need some â€œcuttingâ€ mechanism to reinitialize the counter to 0 when the count reaches k. To this end, we apply bitwise AND to xm,â€¦, x1 with some variable called mask, i.e., xm = xm &amp; mask, â€¦, x1 = x1 &amp; mask. If we can make sure that mask will be 0 only when the count reaches k and be 1 for all other count cases, then we are done. How do we achieve that? Try to think what distinguishes the case with k count from all other count cases. Yes, itâ€™s the count of 1â€™s! For each count, we have unique values for each bit of the counter, which can be regarded as its state. If we write k in its binary form: km,â€¦, k1. we can construct mask as follows: 1mask = ~(y1 &amp; y2 &amp; ... &amp; ym), where yj = xj if kj = 1 and yj = ~xj if kj = 0 (j = 1 to m). 12345Let&apos;s do some examples:k = 3: k1 = 1, k2 = 1, mask = ~(x1 &amp; x2);k = 5: k1 = 1, k2 = 0, k3 = 1, mask = ~(x1 &amp; ~x2 &amp; x3); In summary, our algorithm will go like this: 123456789101112for (int i : array) &#123; xm ^= (xm-1 &amp; ... &amp; x1 &amp; i); xm-1 ^= (xm-2 &amp; ... &amp; x1 &amp; i); ..... x1 ^= i; mask = ~(y1 &amp; y2 &amp; ... &amp; ym) where yj = xj if kj = 1 and yj = ~xj if kj = 0 (j = 1 to m). xm &amp;= mask; ...... x1 &amp;= mask;&#125; Now itâ€™s time to generalize our results from 1-bit number case to 32-bit integers. One straightforward way would be creating 32 counters for each bit in the integer. Youâ€™ve probably already seen this in other posted codes. But if we take advantage of bitwise operations, we may be able to manage all the 32 counters â€œcollectivelyâ€. By saying â€œcollectivelyâ€ we mean using m 32-bit integers instead of 32 m-bit counters, where m is the minimum integer that satisfies m &gt;= logk. The reason is that bitwise operations apply only to each bit so operations on different bits are independent of each other(kind obvious, right?). This allows us to group the corresponding bits of the 32 counters into one 32-bit integer (for schematic steps, see comments below). Since each counter has m bits, we end up with m 32-bit integers. Therefore, in the algorithm developed above, we just need to regard x1 to xm as 32-bit integers instead of 1-bit numbers and we are done. Easy, hum? The last thing is what value we should return, or equivalently which one of x1 to xm will equal the single element. To get the correct answer, we need to understand what the m 32-bit integers x1 to xm represent. Take x1 as an example. x1 has 32 bits and letâ€™s label them as r (r = 1 to 32), After we are done scanning the input array, the value for the r-th bit of x1 will be determined by the r-th bit of all the elements in the array (more specifically, suppose the total count of 1 for the r-th bit of all the elements in the array is q, qâ€™ = q % k and in its binary form: qâ€™m,â€¦,qâ€™1, then by definition the r-th bit of x1 will be equal to qâ€™1). Now you can ask yourself this question: what does it imply if the r-th bit of x1 is 1? The answer is to find what can contribute to this 1. Will an element that appears k times contribute? No. Why? Because for an element to contribute, it has to satisfy at least two conditions at the same time: the r-th bit of this element is 1 and the number of appearance of this 1 is not an integer multiple of k. The first condition is trivial. The second comes from the fact that whenever the number of 1 hit is k, the counter will go back to zero, which means the corresponding bit in x1 will be reset to 0. For an element that appears k times, itâ€™s impossible to meet these two conditions simultaneously so it wonâ€™t contribute. At last, only the single element which appears p (p % k != 0) times will contribute. If p &gt; k, then the first k * [p/k] ([p/k]denotes the integer part of p/k) single elements wonâ€™t contribute either. Then we can always set pâ€™ = p % k and say the single element appears effectively pâ€™ times. Letâ€™s write pâ€™ in its binary form: pâ€™m, â€¦, pâ€™1. (note that pâ€™ &lt; k, so it will fit into m bits). Here I claim the condition for x1 to equal the single element is pâ€™1 = 1. Quick proof: if the r-th bit of x1 is 1, we can safely say the r-th bit of the single element is also 1. We are left to prove that if the r-th bit of x1 is 0, then the r-th bit of the single element can only be 0. Just suppose in this case the r-th bit of the single element is 1, letâ€™s see what will happen. At the end of the scan, this 1 will be counted pâ€™ times. If we write pâ€™ in its binary form: pâ€™m, â€¦, pâ€™1, then by definition the r-th bit of x1 will equal pâ€™1, which is 1. This contradicts with the presumption that the r-th bit of x1 is 0. Since this is true for all bits in x1, we can conclude x1 will equal the single element if pâ€™1 = 1. Similarly we can show xj will equal the single element if pâ€™j = 1 (j = 1 to m). Now itâ€™s clear what we should return. Just express pâ€™ = p % k in its binary form and return any of the corresponding xj as long as pâ€™j = 1. In total, the algorithm will run in O(n * logk) time and O(logk) space. Hope this helps! https://discuss.leetcode.com/topic/11877/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers/2 Here is a list of few quick examples to show how the algorithm works: k = 2, p = 1. k is 2, then m = 1, we need only one 32-bit integer(x1) as the counter. And 2^m = k so we do not even need a mask! A complete java program will look like: 1234567public int singleNumber(int[] A) &#123; int x1 = 0; for (int i : A) &#123; x1 ^= i; &#125; return x1;&#125; k = 3, p = 1. k is 3, then m = 2, we need two 32-bit integers(x2, x1) as the counter. And 2^m &gt; k so we do need a mask. Write k in its binary form: k = â€˜11â€™, then k1 = 1, k2 = 1, so we have mask = ~ (x1 &amp; x2). A complete java program will look like: 12345678910111213141516public int singleNumber(int[] A) &#123; int x1 = 0; int x2 = 0; int mask = 0; for (int i : A) &#123; x2 ^= x1 &amp; i; x1 ^= i; mask = ~(x1 &amp; x2); x2 &amp;= mask; x1 &amp;= mask; &#125; return x1; // p = 1, in binary form p = &apos;01&apos;, then p1 = 1, so we should return x1; // if p = 2, in binary form p = &apos;10&apos;, then p2 = 1, so we should return x2.&#125; k = 5, p = 3. k is 5, then m = 3, we need three 32-bit integers(x3, x2, x1) as the counter. And 2^m &gt; k so we need a mask. Write k in its binary form: k = â€˜101â€™, then k1 = 1, k2 = 0, k3 = 1, so we have mask = ~(x1 &amp; ~x2 &amp; x3). A complete java program will look like: 123456789101112131415161718192021public int singleNumber(int[] A) &#123; int x1 = 0; int x2 = 0; int x3 = 0; int mask = 0; for (int i : A) &#123; x3 ^= x2 &amp; x1 &amp; i; x2 ^= x1 &amp; i; x1 ^= i; mask = ~(x1 &amp; ~x2 &amp; x3); x3 &amp;= mask; x2 &amp;= mask; x1 &amp;= mask; &#125; return x1; // p = 3, in binary form p = &apos;011&apos;, then p1 = p2 = 1, // so we can return either x1 or x2; // But if p = 4, in binary form p = &apos;100&apos;, then only p3 = 1, // which implies we can only return x3.&#125; You can easily come up with other examples. If you have any questions about the explanation, please let me know. I would appreciate your feedback. Thanks! https://discuss.leetcode.com/topic/22821/an-general-way-to-handle-all-this-sort-of-questions An General Way to Handle All this sort of questions. this kind of question the key idea is design a counter that record state. the problem can be every one occurs K times except one occurs M times. for this question, K =3 ,M = 1(or 2) .so to represent 3 state, we need two bit. let say it is a and b, and c is the incoming bit.then we can design a table to implement the state move. 12345678current incoming nexta b c a b0 0 0 0 00 1 0 0 11 0 0 1 00 0 1 0 10 1 1 1 01 0 1 0 0 like circuit design, we can find out what the next state will be with the incoming bit.( we only need find the ones)then we have for a to be 1, we have 1234current incoming nexta b c a b1 0 0 1 00 1 1 1 0 and this is can be represented by 1a=a&amp;~b&amp;~c + ~a&amp;b&amp;c and b can do the same we , and we find that 1b= ~a&amp;b&amp;~c+~a&amp;~b&amp;c and this is the final formula of a and b and just one of the result set, because for different state move table definition, we can generate different formulas, and this one is may not the most optimised. as you may see otherâ€™s answer that have a much simple formula, and that formula also corresponding to specific state move table. (if you like ,you can reverse their formula to a state move table, just using the same way but reversely) for this questions we need to find the except one as the question donâ€™t say if the one appears one time or two time , so for ab both 1201 10 =&gt; 100 =&gt; 0 we should return a|b; this is the key idea , we can design any based counter and find the occurs any times except one . here is my code. with comment. 1234567891011121314151617181920212223public class Solution &#123; public int singleNumber(int[] nums) &#123; //we need to implement a tree-time counter(base 3) that if a bit appears three time ,it will be zero. //#curent income ouput //# ab c/c ab/ab //# 00 1/0 01/00 //# 01 1/0 10/01 //# 10 1/0 00/10 // a=~abc+a~b~c; // b=~a~bc+~ab~c; int a=0; int b=0; for(int c:nums)&#123; int ta=(~a&amp;b&amp;c)|(a&amp;~b&amp;~c); b=(~a&amp;~b&amp;c)|(~a&amp;b&amp;~c); a=ta; &#125; //we need find the number that is 01,10 =&gt; 1, 00 =&gt; 0. return a|b; &#125;&#125; this is a general solution . and it comes from the Circuit Design on course digital logic. https://discuss.leetcode.com/topic/43166/java-o-n-easy-to-understand-solution-easily-extended-to-any-times-of-occurance Java O(n) easy to understand solution, easily extended to any times of occurance The usual bit manipulation code is bit hard to get and replicate. I like to think about the number in 32 bits and just count how many 1s are there in each bit, and sum %= 3 will clear it once it reaches 3. After running for all the numbers for each bit, if we have a 1, then that 1 belongs to the single number, we can simply move it back to its spot by doing ans |= sum &lt;&lt; i; This has complexity of O(32n), which is essentially O(n) and very easy to think and implement. Plus, you get a general solution for any times of occurrence. Say all the numbers have 5 times, just do sum %= 5. 12345678910111213141516public int singleNumber(int[] nums) &#123; int ans = 0; for(int i = 0; i &lt; 32; i++) &#123; int sum = 0; for(int j = 0; j &lt; nums.length; j++) &#123; if(((nums[j] &gt;&gt; i) &amp; 1) == 1) &#123; sum++; sum %= 3; &#125; &#125; if(sum != 0) &#123; ans |= sum &lt;&lt; i; &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/2926/accepted-code-with-proper-explaination-does-anyone-have-a-better-idea Accepted code with proper Explaination. Does anyone have a better idea? The code makes use of 2 variables. ones - At any point of time, this variable holds XOR of all the elements which haveappeared â€œonlyâ€ once.twos - At any point of time, this variable holds XOR of all the elements which haveappeared â€œonlyâ€ twice. So if at any point time, A new number appears - It gets XORâ€™d to the variable â€œonesâ€. A number gets repeated(appears twice) - It is removed from â€œonesâ€ and XORâ€™d to the variable â€œtwosâ€. A number appears for the third time - It gets removed from both â€œonesâ€ and â€œtwosâ€. The final answer we want is the value present in â€œonesâ€ - coz, it holds the unique element. So if we explain how steps 1 to 3 happens in the code, we are done.Before explaining above 3 steps, lets look at last three lines of the code, common_bit_mask = ~ (ones &amp; twos) ones &amp; = common_bit_mask twos &amp; = common_bit_mask All it does is, common 1â€™s between â€œonesâ€ and â€œtwosâ€ are converted to zero. For simplicity, in all the below explanations - consider we have got only 4 elements in the array (one unique element and 3 repeated elements - in any order). Explanation for step 1 Lets say a new element(x) appears. CURRENT SITUATION - Both variables - â€œonesâ€ and â€œtwosâ€ has not recorded â€œxâ€. Observe the statement â€œtwos| = ones &amp; xâ€.Since bit representation of â€œxâ€ is not present in â€œonesâ€, AND condition yields nothing. So â€œtwosâ€ does not get bit representation of â€œxâ€.But, in next step â€œones ^= xâ€ - â€œonesâ€ ends up adding bits of â€œxâ€. Thus new element gets recorded in â€œonesâ€ but not in â€œtwosâ€. The last 3 lines of code as explained already, converts common 1â€™s b/w â€œonesâ€ and â€œtwosâ€ to zeros.Since as of now, only â€œonesâ€ has â€œxâ€ and not â€œtwosâ€ - last 3 lines does nothing. Explanation for step 2. Lets say an element(x) appears twice. CURRENT SITUATION - â€œonesâ€ has recorded â€œxâ€ but not â€œtwosâ€. Now due to the statement, â€œtwos| = ones &amp; xâ€ - â€œtwosâ€ ends up getting bits of x.But due to the statement, â€œones ^ = xâ€ - â€œonesâ€ removes â€œxâ€ from its binary representation. Again, last 3 lines of code does nothing.So ultimately, â€œtwosâ€ ends up getting bits of â€œxâ€ and â€œonesâ€ ends up losing bits of â€œxâ€. Explanation for step 3. Lets say an element(x) appears for the third time. CURRENT SITUATION - â€œonesâ€ does not have bit representation of â€œxâ€ but â€œtwosâ€ has. Though â€œones &amp; xâ€ does not yield nothing .. â€œtwosâ€ by itself has bit representation of â€œxâ€. So after this statement, â€œtwoâ€ has bit representation of â€œxâ€.Due to â€œones^=xâ€, after this step, â€œoneâ€ also ends up getting bit representation of â€œxâ€. Now last 3 lines of code removes common 1â€™s of â€œonesâ€ and â€œtwosâ€ - which is the bit representation of â€œxâ€.Thus both â€œonesâ€ and â€œtwosâ€ ends up losing bit representation of â€œxâ€. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public: // Let us take the example of &#123;3, 3, 2, 3&#125; to understand this int singleNumber(int A[], int n) &#123; int ones=0, twos =0; int common_bit_mask; for(int i=0; i&lt;n;i++) &#123; /* The expression &quot;one &amp; arr[i]&quot; gives the bits that are there in both &apos;ones&apos; and new element from arr[]. We add these bits to &apos;twos&apos; using bitwise OR Value of &apos;twos&apos; will be set as 0, 3, 3 and 1 after 1st, 2nd, 3rd and 4th iterations respectively */ twos= twos|(ones&amp;A[i]); /* XOR the new bits with previous &apos;ones&apos; to get all bits appearing odd number of times Value of &apos;ones&apos; will be set as 3, 0, 2 and 3 after 1st, 2nd, 3rd and 4th iterations respectively */ ones=ones^A[i]; /* The common bits are those bits which appear third time So these bits should not be there in both &apos;ones&apos; and &apos;twos&apos;. common_bit_mask contains all these bits as 0, so that the bits can be removed from &apos;ones&apos; and &apos;twos&apos; Value of &apos;common_bit_mask&apos; will be set as 00, 00, 01 and 10 after 1st, 2nd, 3rd and 4th iterations respectively */ common_bit_mask= ~(ones&amp;twos); /* Remove common bits (the bits that appear third time) from &apos;ones&apos; Value of &apos;ones&apos; will be set as 3, 0, 0 and 2 after 1st, 2nd, 3rd and 4th iterations respectively */ ones &amp;=common_bit_mask; /* Remove common bits (the bits that appear third time) from &apos;twos&apos; Value of &apos;twos&apos; will be set as 0, 3, 1 and 0 after 1st, 2nd, 3rd and 4th itearations respectively */ twos &amp;=common_bit_mask; &#125; return ones; &#125; &#125;; https://discuss.leetcode.com/topic/23584/a-general-c-solution-for-these-type-problems A general C++ solution for these type problems There are so many brilliant solutions for this problem used â€œ| &amp; ^ ~â€, and I have learned a lot from these solutions. Here is a general solution for who not familiar with â€œ| &amp; ^ ~â€. Q: Most elements appeared k times, except one. Find this â€œoneâ€. 12345678910111213141516171819202122232425int singleNumber(vector&lt;int&gt;&amp; s) &#123; vector&lt;int&gt; t(32);////Made a array contain 32 elements. int sz = s.size(); int i, j, n; for (i = 0; i &lt; sz; ++i) &#123; n = s[i]; for (j = 31; j &gt;= 0; --j) &#123; t[j] += n &amp; 1;//Find the last digit. n &gt;&gt;= 1; if (!n) break; &#125; &#125; int res = 0; for (j = 31; j &gt;= 0; --j) &#123; n = t[j] % 3;//&quot;3&quot; represents k times. if (n) res += 1 &lt;&lt; (31 - j); &#125; return res;&#125; https://discuss.leetcode.com/topic/34725/my-own-explanation-of-bit-manipulation-method-might-be-easier-to-understand My own explanation of bit manipulation method, might be easier to understand Consider the following fact: Write all numbers in binary form, then for any bit 1 that appeared 3*n times (n is an integer), the bit can only present in numbers that appeared 3 times e.g. 0010 0010 0010 1011 1011 1011 1000 (assuming 4-bit integers)2(0010) and 11(1011) appeared 3 times, and digit counts are: 12345Digits 3 2 1 0Counts 4 0 6 3Counts%3 1 0 0 0 Counts on 2,1,0 are all times of 3, the only digit index that has Counts % 3 != 0 is 3 Therefore, to find the number that appeared only 1 or 2 times, we only need to extract all bits that has Counts %3 != 0 Now consider how we could do this by bit manipulation since counts % 3 has only 3 states: 0(00),1(01),2(10)we could use a TWO BIT COUNTER (Two, One) to represent Counts % 3, now we could do a little research on state transitions, for each bit, let B be the input bit, we can enumerate the all possible state transitions, Two+, One+ is the new state of Two, One. (here we need to use some knowledge in Digital Logic Design) 1234567891011121314151617Two One B Two+ One+0 0 0 0 00 0 1 0 10 1 0 0 10 1 1 1 01 0 0 1 01 0 1 0 01 1 0 X X (X represents we don&apos;t care)1 1 1 X X We could then draw the Karnaugh map to analyze the logic (https://en.wikipedia.org/wiki/Karnaugh_map), and then we get: 123One+ = (One ^ B) &amp; (~Two)Two+ = (~One+) &amp; (Two ^ B) Now for int_32, we need only 2 int_32 two represent Two and One for each bit and update Two and One using the rules derived above Code is here (C++): 12345678910111213class Solution &#123; public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int counterOne = 0; int counterTwo = 0; for (int i = 0; i &lt; nums.size(); i++)&#123; counterOne = (~counterTwo) &amp; (counterOne ^ nums[i]); counterTwo = (~counterOne) &amp; (counterTwo ^ nums[i]); &#125; return counterOne; &#125;&#125;; https://discuss.leetcode.com/topic/17629/the-simplest-solution-ever-with-clear-explanation The simplest solution ever with clear explanation The key to solve this problem is the count of 1s of each bit of all numbers. Take one bit number for example: nums = [1, 1, 1, 0, 0, 0, â€¦, x] . All numbers are 0 or 1. We know that every number appears three times except for just one number. So, if the count of 1s in nums is 0, 3, 6, â€¦, 3 n, then the single number is 0. And if the count of 1s in nums is 1, 4, 7, â€¦, 3\n+1, then the single number is 1. So, for an array â€œ nums â€œ that contains only 0 or 1, the code to find the single number are: 1234count = 0for num in nums: count = (count + num) % 3return count To make â€œcountâ€ less than 3, mod â€œcountâ€ with 3 in every loop. Below is the procedure for finding the single number in [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]: 123456Table 1:++=======++===+===+===+===+===+===+===+===+===+===+===+===+===+====++|| num || | 1 | 0 | 1 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 ||++-------++---+---+---+---+---+---+---+---+---+---+---+---+---+----++|| count || 0 | 1 | 1 | 2 | 0 | 0 | 1 | 1 | 2 | 2 | 0 | 0 | 1 | 1* ||++=======++===+===+===+===+===+===+===+===+===+===+===+===+===+====++ So the single number is 1. We can write the calculate table for expression â€œcountâ€™ = (count + num) % 3â€: 12345678910111213141516Table 2:++=======+=====+========++|| count | num | count&apos; ||++-------+-----+--------++|| 0 | 0 | 0 ||++-------+-----+--------++|| 1 | 0 | 1 ||++-------+-----+--------++|| 2 | 0 | 2 ||++-------+-----+--------++|| 0 | 1 | 1 ||++-------+-----+--------++|| 1 | 1 | 2 ||++-------+-----+--------++|| 2 | 1 | 0 ||++-------+-----+--------++ To extend this algorithm to 32bits number. We need to rewrite these code to bit operation expressions. And the key is rewriting the expression â€œ countâ€™ = (count + num) % 3 â€œ to bit operation expressions. Write binary numbers of â€œ count â€œ and â€œ countâ€™ â€œ in â€œTable 2â€. And split their bits into two column: 12345678910111213141516171819Table 3:++=======+============+=====+============+========++|| | count | num | count&apos; | |||| count | (bin) | | (bin) | count&apos; |||| (dec) ++=====+=====+=====+=====+=====++ (dec) |||| || b1 | b0 | num | b1&apos; | b0&apos; || ||++-------++-----+-----+-----+-----+-----++--------++|| 0 || 0 | 0 | 0 | 0 | 0 || 0 ||++-------++-----+-----+-----+-----+-----++--------++|| 1 || 0 | 1 | 0 | 0 | 1 || 1 ||++-------++-----+-----+-----+-----+-----++--------++|| 2 || 1 | 0 | 0 | 1 | 0 || 2 ||++-------++-----+-----+-----+-----+-----++--------++|| 0 || 0 | 0 | 1 | 0 | 1 || 1 ||++-------++-----+-----+-----+-----+-----++--------++|| 1 || 0 | 1 | 1 | 1 | 0 || 2 ||++-------++-----+-----+-----+-----+-----++--------++|| 2 || 1 | 0 | 1 | 0 | 0 || 0 ||++=======++===========+=====+===========++========++ Here comes the hardest part of this solution. â€œTable 3â€ is a truth table, we need to use it to find the formulas to calculate â€œ b0â€™ â€œ and â€œ b1â€™ â€œ: 12b0&apos; = f(b1, b0, num)b1&apos; = g(b1, b0, num) With observations, guesses, experiments and even some luck. Finally I got two simple and elegant formulas: 12b0&apos; = (b0 ^ num) &amp; (~b1)b1&apos; = (b1 ^ num) &amp; (~b0&apos;) The AC code: 123456789class Solution: # @param &#123;integer[]&#125; nums # @return &#123;integer&#125; def singleNumber(self, nums): b1, b0 = 0, 0 for num in nums: b0 = (b0 ^ num) &amp; (~b1) b1 = (b1 ^ num) &amp; (~b0) return b0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[136. Single Number]]></title>
    <url>%2Fp%2F66a2ee90%2F</url>
    <content type="text"><![CDATA[53.2% https://leetcode.com/problems/single-number/?tab=Description Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? æ–¹æ³•ä¸€ï¼š æ³¨æ„ä¸‹é¢ä»£ç ä¸­res=0ï¼Œä¸èƒ½æ˜¯ int resï¼Œè¦ç»™resèµ‹ä¸€ä¸ªåˆå§‹å€¼ï¼Œå¦åˆ™å‡ºçŽ°é”™è¯¯ã€‚ 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for(auto num:nums) res ^= num; return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for(auto num:nums) res ^= num; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/19563/python-different-solutions 1234567def singleNumber1(self, nums): dic = &#123;&#125; for num in nums: dic[num] = dic.get(num, 0)+1 for key, val in dic.items(): if val == 1: return key 12345def singleNumber2(self, nums): res = 0 for num in nums: res ^= num return res 12def singleNumber3(self, nums): return 2*sum(set(nums))-sum(nums) 12def singleNumber4(self, nums): return reduce(lambda x, y: x ^ y, nums) 12def singleNumber(self, nums): return reduce(operator.xor, nums) https://discuss.leetcode.com/topic/42358/1-line-simple-python-solution 123class Solution(object): def singleNumber(self, nums): return sum(list(set(nums)))*2 - sum(nums) my code12345678910class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; res = 0 for num in nums: res ^= num return res 1234567class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; return reduce((lambda x, y : x^y), nums) java 12345678public class Solution &#123; public int singleNumber(int[] nums) &#123; int res = 0; for(int i=0; i&lt;nums.length; i++) res ^= nums[i]; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
        <tag>bin manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[135. Candy]]></title>
    <url>%2Fp%2Fd0cc5467%2F</url>
    <content type="text"><![CDATA[24.2% https://leetcode.com/problems/candy/ There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? æ–¹æ³•ä¸€ï¼š A simple solution 1234567891011121314151617181920class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int size = ratings.size(); if(size&lt;=1) return size; vector&lt;int&gt; ret(size, 1); for(int i=1; i&lt;size; i++)&#123; if(ratings[i]&gt;ratings[i-1]) ret[i] = ret[i-1]+1; &#125; for(int i=size-1; i&gt;0; i--)&#123; if(ratings[i-1]&gt;ratings[i]) ret[i-1] = max(ret[i-1], ret[i]+1); &#125; int result = 0; for(int i=0; i&lt;size; i++) result += ret[i]; return result; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; auto n = ratings.size(); if(n==1) return 1; vector&lt;int&gt; v(n, 1); for(int i=1; i&lt;n; i++)&#123; if(ratings[i]&gt;ratings[i-1]) v[i] = v[i-1]+1; &#125; for(int i=n-2; i&gt;=0; i--)&#123; if(ratings[i]&gt;ratings[i+1]) v[i] = max(v[i], v[i+1]+1); &#125; int res = 0; for(int i=0; i&lt;n; i++) res += v[i]; return res; &#125;&#125;; https://discuss.leetcode.com/topic/5243/a-simple-solution A simple solution 1234567891011121314151617181920class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int size = ratings.size(); if(size&lt;=1) return size; vector&lt;int&gt; ret(size, 1); for(int i=1; i&lt;size; i++)&#123; if(ratings[i]&gt;ratings[i-1]) ret[i] = ret[i-1]+1; &#125; for(int i=size-1; i&gt;0; i--)&#123; if(ratings[i-1]&gt;ratings[i]) ret[i-1] = max(ret[i-1], ret[i]+1); &#125; int result = 0; for(int i=0; i&lt;size; i++) result += ret[i]; return result; &#125;&#125;; https://discuss.leetcode.com/topic/17722/two-c-solutions-given-with-explanation-both-with-o-n-time-one-with-o-1-space-the-other-with-o-n-space Two C++ solutions given with explanation (both with O(N) time, one with O(1) space, the other with O(N) space) The question requires us to make sure a child with a higher rate has more candies than its left and right neighbors. One simple solution is to do two scans: one foward scan (from 1 to N-1) to make sure child i has more candies than its left neighbor if its rate is higher than its left neighbor. After the forward scan, we can guarantee that the left neighbor relationship is correct but we have to do more to make the right neighbor relationship in order; so we do the backwarad scan (from N-2 to 0) to make child i has more candies than its right neighbor i+1 if its rate is higher than its right neighbor. In the following implementation, we need a O(N) array number to save the number of candies needed for children, so it has O(N) space complexity and we do two linear scans so the time complexity is O(N) 123456789101112131415161718192021class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int len = ratings.size(), res = 0, i; if(len&gt;0) &#123; vector&lt;int&gt; number(len,0); // to save the number of candies for child[0:N-1] number[0] = 1; // forward scan to calculate how many candies needed for child i to make sure it has more candies than its left neighbor if it has a higher rate, otherwise, give one candy to it for(i=1; i&lt;len;++i) number[i] = ratings[i]&gt;ratings[i-1]?number[i-1]+1:1;// backward scan to calculate to make sure child i has more candies than its right neighbor if it has a higher rate, pick the bigger one from forward and backward scans as the final number for child i for(i=len-2, res = number[len-1]; i&gt;=0;--i) &#123; if( (ratings[i]&gt;ratings[i+1]) &amp;&amp; number[i]&lt;(number[i+1]+1) ) number[i] = number[i+1]+1; res += number[i]; &#125; &#125; return res; &#125;&#125;; Now, the question is can we do better? Do we really need two scans? If we do only forward scan, then the problem is we can not guarantee the right neighbor relationship holds. i.e. we donâ€™t know if the following order is descending (i&gt;i+1&gt;i+2&gt;â€¦). and that may cause issues. To fix that, we will detect the dips (the points at which the order switchs from increasing to decreasng). We will make sure all the local dips (minimum points) has only one candy and update its previous neighbors (which has hgher rates than its rate) accordingly. To do such update, we need to know when the decrease starts, so we use pPos to save that starting points.So the solution becomes: do the forward scan, if it is in an increasing order (child i rate &gt; child i-1 order), check if it is a local dip (neg_peak == true): if so, update the candy number to make sure child i-1 has one candy. if not, just give one more candy to child i. If it is in an decreasing order (child i rate &lt; child i-1 order), just give one less candy to i. donâ€™t forget at last, we still need to make sure child N-1 has one or more candy. So O(1) space , O(N) time 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; const int len = ratings.size(); if(len&lt;=1) return len; int i, pPos, res=1, peak=1; // peak: # candies given to the i-1 child bool neg_peak = false; // flag to indicate if it is a local dip for(i=1; i&lt;len;i++) &#123; if(ratings[i] &gt;= ratings[i-1]) &#123; // it is increasing if(neg_peak) &#123; // it is a local dip, we need to make sure i-1 has one candy res -= (peak-1) * (i-pPos - (peak&gt;0)); peak = 1; neg_peak = false; &#125; // update child i candy number, if equal, set to 1 peak = (ratings[i] == ratings[i-1])? 1:++peak; res += peak; &#125; else &#123; // decreasing, just give one less candy, if it is the starting point of a decrease, update pPos if(!neg_peak) &#123;pPos = i-1; neg_peak = true;&#125; res += --peak; &#125; &#125;// don&apos;t forget to update res, if the last one is a local dip return !neg_peak? res : res - (peak-1) * (i-pPos - (peak&gt;0)); &#125;&#125;; python https://discuss.leetcode.com/topic/21025/simple-python-solution-with-two-passes Simple python solution with two passes 1234567891011121314151617class Solution: # @param &#123;integer[]&#125; ratings # @return &#123;integer&#125; def candy(self, ratings): # use two pass scan from left to right and vice versa to keep the candy level up to now # similar to like the Trapping Rain Water question res = [1]*len(ratings) # also compatable with [] input lbase = rbase = 1 # left scan for i in xrange(1, len(ratings)): lbase = lbase + 1 if ratings[i] &gt; ratings[i-1] else 1 res[i] = lbase # right scan for i in xrange(len(ratings)-2, -1, -1): rbase = rbase + 1 if ratings[i] &gt; ratings[i+1] else 1 res[i] = max(rbase, res[i]) return sum(res) java https://discuss.leetcode.com/topic/25985/simple-o-n-java-solution-with-comments Simple O(n) Java solution with comments 12345678910111213141516public class Solution &#123; public int candy(int[] ratings) &#123; int candies[] = new int[ratings.length]; Arrays.fill(candies, 1); for(int i=1; i&lt;ratings.length; i++) if(ratings[i]&gt;ratings[i-1]) candies[i] = candies[i-1] + 1; for(int i=ratings.length-1; i&gt;0; i--) if(ratings[i-1]&gt;ratings[i]) candies[i-1] = Math.max(candies[i-1], candies[i]+1); int result = 0; for(int i=0; i&lt;ratings.length; i++) result += candies[i]; return result; &#125;&#125; 1234567891011121314151617public int candy(int[] ratings) &#123; int candies[] = new int[ratings.length]; Arrays.fill(candies, 1);// Give each child 1 candy for (int i = 1; i &lt; candies.length; i++)&#123;// Scan from left to right, to make sure right higher rated child gets 1 more candy than left lower rated child if (ratings[i] &gt; ratings[i - 1]) candies[i] = (candies[i - 1] + 1); &#125; for (int i = candies.length - 2; i &gt;= 0; i--) &#123;// Scan from right to left, to make sure left higher rated child gets 1 more candy than right lower rated child if (ratings[i] &gt; ratings[i + 1]) candies[i] = Math.max(candies[i], (candies[i + 1] + 1)); &#125; int sum = 0; for (int candy : candies) sum += candy; return sum;&#125; https://discuss.leetcode.com/topic/8208/one-pass-constant-space-java-solution One-pass constant space Java solution This solution picks each element from the input array only once. First, we give a candy to the first child. Then for each child we have three cases: His/her rating is equal to the previous one -&gt; give 1 candy. His/her rating is greater than the previous one -&gt; give him (previous + 1) candies. His/her rating is less than the previous one -&gt; donâ€™t know what to do yet, letâ€™s just count the number of such consequent cases. When we enter 1 or 2 condition we can check our count from 3. If itâ€™s not zero then we know that we were descending before and we have everything to update our total candies amount: number of children in descending sequence of raitings - coundDown, number of candies given at peak - prev (we donâ€™t update prev when descending). Total number of candies for â€œdescendingâ€ children can be found through arithmetic progression formula (1+2+â€¦+countDown). Plus we need to update our peak child if his number of candies is less then or equal to countDown. Hereâ€™s a pretty concise code below. è¯¦æƒ…å‚è€ƒä»¥ä¸‹é“¾æŽ¥ï¼šhttp://www.allenlipeng47.com/blog/index.php/2016/07/21/candy/ But there is a O(n) time, O(1) space solution, which is pretty hard to understand. Let me try to explain this O(1) space solution.123456789101112131415161718192021222324252627public static int candy(int[] ratings) &#123; int pre = 1, countDown = 0, total = 1; for (int i = 1; i &lt; ratings.length; i++) &#123; if (ratings[i] &gt;= ratings[i - 1]) &#123; if (countDown &gt; 0) &#123; total += countDown * (countDown + 1) / 2; // progression part if (countDown &gt;= pre) &#123; // check if pre is tall enough total += countDown - pre + 1; &#125; pre = 1; // when ascending and there is countDown, prev should be 1 countDown = 0; &#125; pre = ratings[i] == ratings[i - 1] ? 1 : pre + 1; // when equals to previous one, set to 1. Else set to prev + 1 total += pre; &#125; else &#123; countDown++; &#125; &#125; if (countDown &gt; 0) &#123; // check if there is countDown in the end total += countDown * (countDown + 1) / 2; if (countDown &gt;= pre) &#123; total += countDown - pre + 1; &#125; &#125; return total;&#125; https://discuss.leetcode.com/topic/37924/very-simple-java-solution-with-detail-explanation Very Simple Java Solution with detail explanation 1We take ratings array as [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1] In the given problem each student will have at least 1 candy. So distribute 1 candy to each. 12ratings: [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]candies: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] Now traverse the array from left to right. If the rating of (n+1) child is greater than (n) child then set the candy of (n+1) child as one candy more than the (n) child candies. 12ratings: [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]candies: [1, 2, 1, 1, 2, 3, 4, 1, 1, 1, 2, 1] Now traverse the array from right to left. If the (n) child rating is more than (n+1) child and (n) child candies is less than one more than (n+1) child candies then update the candies of (n) child as 1+ (n+1) candies. 12ratings: [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]candies: [1, 2, 1, 1, 2, 3, 4, 3, 2, 1, 2, 1] Total minimum candies: 23 123456789101112131415161718192021222324252627282930public int candy(int[] ratings) &#123; int sum=0; int[] a=new int[ratings.length]; for(int i=0;i&lt;a.length;i++) &#123; a[i]=1; &#125; for(int i=0;i&lt;ratings.length-1;i++) &#123; if(ratings[i+1]&gt;ratings[i]) &#123; a[i+1]=a[i]+1; &#125; &#125; for(int i=ratings.length-1;i&gt;0;i--) &#123; if(ratings[i-1]&gt;ratings[i]) &#123; if(a[i-1]&lt;(a[i]+1)) &#123; a[i-1]=a[i]+1; &#125; &#125; &#125; for(int i=0;i&lt;a.length;i++) &#123; sum+=a[i]; &#125; return sum; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>greedy</tag>
        <tag>candy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[134. Gas Station]]></title>
    <url>%2Fp%2Fb124e3aa%2F</url>
    <content type="text"><![CDATA[29.3% https://leetcode.com/problems/gas-station/ There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas stationâ€™s index if you can travel around the circuit once, otherwise return -1. Note: The solution is guaranteed to be unique. å…·ä½“åŽŸç†åŠè´ªå¿ƒç®—æ³•è¿˜éœ€è¦å†æ€è€ƒ æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°: Oct 18ï¼Œ2017 1234567891011121314151617class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int start = gas.size()-1, end = 0; int sum = gas[start] - cost[start]; while(start&gt;end)&#123; if(sum&gt;=0)&#123; sum += gas[end] - cost[end]; end++; &#125;else&#123; start--; sum += gas[start] - cost[start]; &#125; &#125; return sum&gt;=0 ? start : -1; &#125;&#125;; My AC is O(1) space O(n) running time solution. Does anybody have posted this solution? I have got one solution to this problem. I am not sure whether somebody has already posted this solution. 1234567891011121314151617181920class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123; int start = gas.size()-1; int end = 0; int sum = gas[start] - cost[start]; // æ³¨æ„æ­¤å¤„åˆå€¼çš„èµ‹å€¼ while (start &gt; end) &#123; if (sum &gt;= 0) &#123; sum += gas[end] - cost[end]; ++end; &#125; else &#123; --start; sum += gas[start] - cost[start]; &#125; &#125; return sum &gt;= 0 ? start : -1; &#125;&#125;; my code: 1234567891011121314151617181920class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int n = gas.size(), m = cost.size(); if(n!=m || m==n &amp;&amp; m==0) return -1; int start = n-1, end = 0; int cur_gas = gas[start]-cost[start]; while(end &lt;= start)&#123; if(cur_gas&gt;=0)&#123; cur_gas += gas[end] - cost[end]; end++; &#125; else&#123; start--; cur_gas += gas[start] - cost[start]; &#125; &#125; return cur_gas&gt;=0?start:-1; &#125;&#125;; cpp https://discuss.leetcode.com/topic/1344/share-some-of-my-ideas Share some of my ideas. I have thought for a long time and got two ideas: If car starts at A and can not reach B. Any station between A and B can not reach B.(B is the first station that A can not reach.) If the total number of gas is bigger than the total number of cost. There must be a solution. (Should I prove them?) Here is my solution based on those ideas: 123456789class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123; int start(0),total(0),tank(0); //if car fails at 'start', record the next station for(int i=0;i&lt;gas.size();i++) if((tank=tank+gas[i]-cost[i])&lt;0) &#123;start=i+1;total+=tank;tank=0;&#125; return (total+tank&lt;0)? -1:start; &#125;&#125;; https://discuss.leetcode.com/topic/5088/my-ac-is-o-1-space-o-n-running-time-solution-does-anybody-have-posted-this-solution My AC is O(1) space O(n) running time solution. Does anybody have posted this solution? I have got one solution to this problem. I am not sure whether somebody has already posted this solution. 1234567891011121314151617181920class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123; int start = gas.size()-1; int end = 0; int sum = gas[start] - cost[start]; while (start &gt; end) &#123; if (sum &gt;= 0) &#123; sum += gas[end] - cost[end]; ++end; &#125; else &#123; --start; sum += gas[start] - cost[start]; &#125; &#125; return sum &gt;= 0 ? start : -1; &#125;&#125;; https://discuss.leetcode.com/topic/39755/proof-of-if-total-gas-is-greater-than-total-cost-there-is-a-solution-c Proof of â€œif total gas is greater than total cost, there is a solutionâ€. C++ We prove the following statement. If sum of all gas[i]-cost[i] is greater than or equal to 0, then there is a start position you can travel the whole circle.Let i be the index such that the the partial sum 1gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i] is the smallest, then the start position should be start=i+1 ( start=0 if i=n-1). Consider any other partial sum, for example, 1gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i]+gas[i+1]-cost[i+1] Since gas[0]-cost[0]+gas[1]-cost[1]+â€¦+gas[i]-cost[i] is the smallest, we must have 1gas[i+1]-cost[i+1]&gt;=0 in order for gas[0]-cost[0]+gas[1]-cost[1]+â€¦+gas[i]-cost[i]+gas[i+1]-cost[i+1] to be greater.The same reasoning gives that 1234gas[i+1]-cost[i+1]&gt;=0gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]&gt;=0.......gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]+...+gas[n-1]-cost[n-1]&gt;=0 What about for the partial sums that wraps around? 1234gas[0]-cost[0]+gas[1]-cost[1]+...+gas[j]-cost[j] + gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1]&gt;=gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i] + gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1]&gt;=0 The last inequality is due to the assumption that the entire sum of gas[k]-cost[k] is greater than or equal to 0.So we have that all the partial sums 123456gas[i+1]-cost[i+1]&gt;=0,gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]&gt;=0,gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]+...+gas[n-1]-cost[n-1]&gt;=0,...gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1] + gas[0]-cost[0]+gas[1]-cost[1]+...+gas[j]-cost[j]&gt;=0,... Thus i+1 is the position to start. Coding using this reasoning is as follows: 123456789101112131415class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int n = gas.size(); int total(0), subsum(INT_MAX), start(0); for(int i = 0; i &lt; n; ++i)&#123; total += gas[i] - cost[i]; if(total &lt; subsum) &#123; subsum = total; start = i + 1; &#125; &#125; return (total &lt; 0) ? -1 : (start%n); &#125;&#125;; https://discuss.leetcode.com/topic/8860/fully-commented-o-n-c-solution-enabled-by-a-single-observation-of-mine Fully-commented O(n) C++ solution enabled by a single observation of mine 123456789101112131415161718192021222324252627class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123; int i, j, n = gas.size(); /* * If start from i, stop before station x -&gt; no station k from i + 1 to x - 1 can reach x. * Bcoz if so, i can reach k and k can reach x, then i reaches x. Contradiction. * Thus i can jump directly to x instead of i + 1, bringing complexity from O(n^2) to O(n). */ // start from station i for (i = 0; i &lt; n; i += j) &#123; int gas_left = 0; // forward j stations for (j = 1; j &lt;= n; j++) &#123; int k = (i + j - 1) % n; gas_left += gas[k] - cost[k]; if (gas_left &lt; 0) break; &#125; if (j &gt; n) return i; &#125; return -1; &#125;&#125;; https://discuss.leetcode.com/topic/29487/my-one-pass-solution My one pass solution. 123456789101112131415161718class Solution &#123;public:int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int size=gas.size(); int sum=0; int res=0; int total=0; for(int i=0; i&lt;size; ++i)&#123; sum+=gas[i]-cost[i]; if(sum&lt;0)&#123; total+=sum; sum=0; res=i+1; &#125; &#125; total+=sum; return total&lt;0?-1:res;&#125;&#125;; The idea is simple. Whenever the sum is negative, reset it and let the car start from next point. In the mean time, add up all of the left gas to total. If itâ€™s negative finally, return -1 since itâ€™s impossible to finish. If itâ€™s non-negative, return the last point saved in res; https://discuss.leetcode.com/topic/5088/my-ac-is-o-1-space-o-n-running-time-solution-does-anybody-have-posted-this-solution 6ms, September 20, 2016 12345678910111213141516171819class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int start = gas.size() - 1; int end = 0; int sum = gas[start] - cost[start]; while(start &gt; end)&#123; if(sum &gt;= 0)&#123; sum += gas[end] - cost[end]; ++end; &#125; else&#123; --start; sum += gas[start] - cost[start]; &#125; &#125; return sum &gt;= 0 ? start : -1; &#125;&#125;; python https://discuss.leetcode.com/topic/27760/possibly-the-most-easiest-approach-o-n-one-variable-python 55ms, 32.89%, September 20, 2016 è§£æžï¼šsumï¼ˆgasï¼‰&gt;= sumï¼ˆgasï¼‰ï¼Œèƒ½ä¿è¯å­˜åœ¨ä¸€ä¸ªä½ç½®ï¼Œå¯ä»¥ä½œä¸ºèµ·ç‚¹ã€‚å¦‚æžœä»Žä½ç½®positionå¼€å§‹è¿›è¡Œæ—…è¡Œï¼Œè¿™ä¸€æ®µåˆ°æŸä¸€ç‚¹æ²¡æœ‰æ²¹äº†ï¼Œåˆ™ä»¥positionä¸ºèµ·ç‚¹çš„è¿™ä¸€æ®µè‚¯å®šä¸å­˜åœ¨ä½œä¸ºèµ·ç‚¹çš„ä½ç½®ï¼Œå¦åˆ™èµ°ä¸å®Œè¿™ä¸€æ®µï¼Œæ‰€ä»¥postionè®¾ä¸ºä»Žä¸‹ä¸€ä¸ªä½ç½®å¼€å§‹ï¼Œå…¶ä»–çš„ç±»ä¼¼ã€‚my codeçš„æ€æƒ³ç±»ä¼¼ï¼Œä¸è¿‡æ˜¯ç§»åŠ¨èµ·ç‚¹å’Œç»ˆç‚¹çš„ä½ç½®ï¼Œå¦‚æžœå°äºŽ0ï¼Œèµ·ç‚¹å‘å‰ç§»åŠ¨ï¼Œå¦‚æžœå¤§äºŽ0ï¼Œåˆ™èµ·ç‚¹å‘åŽç§»åŠ¨ã€‚1234567891011121314151617class Solution(object): def canCompleteCircuit(self, gas, cost): &quot;&quot;&quot; :type gas: List[int] :type cost: List[int] :rtype: int &quot;&quot;&quot; if len(gas) == 0 or len(cost) == 0 or sum(gas) &lt; sum(cost): return -1 position = 0 balance = 0 for i in range(len(gas)): balance += gas[i] - cost[i] if balance &lt; 0: balance = 0 position = i+1 return position my code 1234567891011121314151617class Solution(object): def canCompleteCircuit(self, gas, cost): &quot;&quot;&quot; :type gas: List[int] :type cost: List[int] :rtype: int &quot;&quot;&quot; start, end = len(gas)-1, 0 cur = gas[start]-cost[start] while end&lt;start: if cur&lt;0: start -= 1 cur += gas[start] - cost[start] else: cur += gas[end] - cost[end] end += 1 return start if cur&gt;=0 else -1 java https://discuss.leetcode.com/topic/7247/my-o-n-time-o-1-extra-space-solution My O(N) time, O(1) extra space solution. 1234567891011121314151617181920public class Solution &#123;public int canCompleteCircuit(int[] gas, int[] cost) &#123; for(int i = 0; i &lt; gas.length; i++) &#123; gas[i] -= cost[i]; &#125; int sum = 0; int result = 0; int n = gas.length; for(int i = 0; i &lt; n * 2 - 1; i++) &#123; sum += gas[i % n]; if(sum &lt; 0) &#123; result = i + 1; if(result &gt;= n) &#123; return -1; &#125; sum = 0; &#125; &#125; return result;&#125; https://discuss.leetcode.com/topic/25289/straightforward-java-linear-solution-with-o-1-space-explanation-and-math-proof Straightforward Java Linear Solution with O(1) space, explanation and Math proof The algorithm is pretty easy to understand. Imagine we take a tour around this circle, the only condition that we can complete this trip is to have more fuel provided than costed in total. Thatâ€™s what the first loop does. If we do have more fuel provided than costed, that means we can always find a start point around this circle that we could complete the journey with an empty tank. Hence, we check from the beginning of the array, if we can gain more fuel at the current station, we will maintain the start point, else, which means we will burn out of oil before reaching to the next station, we will start over at the next station. 1234567891011121314151617181920public int canCompleteCircuit(int[] gas, int[] cost) &#123; int tank = 0; for(int i = 0; i &lt; gas.length; i++) tank += gas[i] - cost[i]; if(tank &lt; 0) return - 1; int start = 0; int accumulate = 0; for(int i = 0; i &lt; gas.length; i++)&#123; int curGain = gas[i] - cost[i]; if(accumulate + curGain &lt; 0)&#123; start = i + 1; accumulate = 0; &#125; else accumulate += curGain; &#125; return start;&#125; https://discuss.leetcode.com/topic/25990/simple-o-n-java-solution-with-comments 1ms, September 20, 2016 123456789101112131415public class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int total = 0, tank = 0, index = 0; for(int i=0; i&lt;cost.length; i++)&#123; int cur = gas[i] - cost[i]; tank += cur; if(tank&lt;0)&#123; index = i+1; tank = 0; &#125; total += cur; &#125; return total &lt; 0 ? -1:index; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[132. Palindrome Partitioning II]]></title>
    <url>%2Fp%2Fc5f750e%2F</url>
    <content type="text"><![CDATA[23.7% https://leetcode.com/problems/palindrome-partitioning-ii/#/description Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. 12For example, given s = &quot;aab&quot;,Return 1 since the palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut. 13ms, September 22, 2016 https://discuss.leetcode.com/topic/2840/my-solution-does-not-need-a-table-for-palindrome-is-it-right-it-uses-only-o-n-space My solution does not need a table for palindrome, is it right ? It uses only O(n) space. 12345678910111213141516class Solution &#123;public: int minCut(string s) &#123; int n = s.size(); vector&lt;int&gt; cut(n+1, 0); // number of cuts for the first k characters for (int i = 0; i &lt;= n; i++) cut[i] = i-1; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; i-j &gt;= 0 &amp;&amp; i+j &lt; n &amp;&amp; s[i-j]==s[i+j] ; j++) // odd length palindrome cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]); for (int j = 1; i-j+1 &gt;= 0 &amp;&amp; i+j &lt; n &amp;&amp; s[i-j+1] == s[i+j]; j++) // even length palindrome cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]); &#125; return cut[n]; &#125;&#125;; https://discuss.leetcode.com/topic/2048/my-dp-solution-explanation-and-code My DP Solution ( explanation and code) Calculate and maintain 2 DP states: pal[i][j] , which is whether s[i..j] forms a pal d[i], which is the minCut for s[i..n-1] Once we comes to a pal[i][j]==true: if j==n-1, the string s[i..n-1] is a Pal, minCut is 0, d[i]=0; else: the current cut num (first cut s[i..j] and then cut the rest s[j+1â€¦n-1]) is 1+d[j+1], compare it to the exisiting minCut num d[i], repalce if smaller. d[0] is the answer. 12345678910111213141516171819202122232425class Solution &#123; public: int minCut(string s) &#123; if(s.empty()) return 0; int n = s.size(); vector&lt;vector&lt;bool&gt;&gt; pal(n,vector&lt;bool&gt;(n,false)); vector&lt;int&gt; d(n); for(int i=n-1;i&gt;=0;i--) &#123; d[i]=n-i-1; for(int j=i;j&lt;n;j++) &#123; if(s[i]==s[j] &amp;&amp; (j-i&lt;2 || pal[i+1][j-1])) &#123; pal[i][j]=true; if(j==n-1) d[i]=0; else if(d[j+1]+1&lt;d[i]) d[i]=d[j+1]+1; &#125; &#125; &#125; return d[0]; &#125; &#125;; https://discuss.leetcode.com/topic/19298/two-c-versions-given-one-dp-28ms-one-manancher-like-algorithm-10-ms Two C++ versions given (one DP 28ms, one Manancher-like algorithm 10 ms) One typical solution is DP based. Such solution first constructs a two-dimensional bool array isPalin to indicate whether the sub-string s[i..j] is palindrome. To get such array, we need O(N^2) time complexity. Moreover, to get the minimum cuts, we need another array minCuts to do DP and minCuts[i] saves the minimum cuts found for the sub-string s[0..i-1]. minCuts[i] is initialized to i-1, which is the maximum cuts needed (cuts the string into one-letter characters) and minCuts[0] initially sets to -1, which is needed in the case that s[0..i-1] is a palindrome. When we construct isPalin array, we update minCuts everytime we found a palindrome sub-string, i.e. if s[i..j] is a palindrome, then minCuts[j+1] will be updated to the minimum of the current minCuts[j+1] and minCut[i]+1(i.e. cut s[0..j] into s[0,i-1] and s[i,j]). At last, we return minCuts[N].So the complexity is O(N^2). However, it can be further improved since as described above, we only update minCuts when we find a palindrome substring, while the DP algorithm spends lots of time to calculate isPalin, most of which is false (i.e. not a palindrome substring). If we can reduce such unnecessary calculation, then we can speed up the algorithm. This can be achieved with a Manancher-like solution, which is also given as following. 123456789101112131415161718192021222324252627// DP solutionclass Solution &#123;public: int minCut(string s) &#123; const int N = s.size(); if(N&lt;=1) return 0; int i,j; bool isPalin[N][N]; fill_n(&amp;isPalin[0][0], N*N, false); int minCuts[N+1]; for(i=0; i&lt;=N; ++i) minCuts[i] = i-1; for(j=1; j&lt;N; ++j) &#123; for(i=j; i&gt;=0; --i) &#123; if( (s[i] == s[j]) &amp;&amp; ( ( j-i &lt; 2 ) || isPalin[i+1][j-1] ) ) &#123; isPalin[i][j] = true; minCuts[j+1] = min(minCuts[j+1], 1 + minCuts[i]); &#125; &#125; &#125; return minCuts[N]; &#125;&#125;; The Manancher-like solution scan the array from left to right (for i loop) and only check those sub-strings centered at s[i]; once a non-palindrome string is found, it will stop and move to i+1. Same as the DP solution, minCUTS[i] is used to save the minimum cuts for s[0:i-1]. For each i, we do two for loops (for j loop) to check if the substrings s[i-j .. i+j] (odd-length substring) and s[i-j-1.. i+j] (even-length substring) are palindrome. By increasing j from 0, we can find all the palindrome sub-strings centered at i and update minCUTS accordingly. Once we meet one non-palindrome sub-string, we stop for-j loop since we know there no further palindrome substring centered at i. This helps us avoid unnecessary palindrome substring checks, as we did in the DP algorithm. Therefore, this version is faster. 123456789101112131415161718192021//Manancher-like solutionclass Solution &#123;public: int minCut(string s) &#123; const int N = s.size(); if(N&lt;=1) return 0; int i, j, minCUTS[N+1]; for(i=0; i&lt;=N; ++i) minCUTS[i] = i-1; for(i=1;i&lt;N;i++) &#123; for(j=0;(i-j)&gt;=0 &amp;&amp; (i+j)&lt;N &amp;&amp; s[i-j]== s[i+j]; ++j) // odd-length substrings minCUTS[i+j+1] = min(minCUTS[i+j+1], 1 + minCUTS[i-j]); for(j=0;(i-j-1)&gt;=0 &amp;&amp; (i+j)&lt;N &amp;&amp; s[i-j-1]== s[i+j]; ++j) // even-length substrings minCUTS[i+j+1] = min(minCUTS[i+j+1], 1 + minCUTS[i-j-1]); &#125; return minCUTS[N]; &#125;&#125;; https://discuss.leetcode.com/topic/22388/56-ms-python-with-explanation 56 ms python with explanation Algorithm (460 ms) credits go to: https://leetcode.com/discuss/9476/solution-does-not-need-table-palindrome-right-uses-only-space The main algorithm idea is if s[i,j] is a palindrome, then the minCut(s[:j]) is at most minCut(s[:i-1])+1. This literally needs to find out all possible palindromes in the list. The above post provides an efficient search algorithm. O(n) space and O(n^2) time complexity. Further acceleration (460 ms -&gt; 56 ms) credits go to: https://leetcode.com/discuss/43950/python-100ms-extra-dealing-super-cases-reduces-576ms-100ms The main idea for acceleration is to quickly check and exclude a few long palindrome tests.. 1234567891011121314151617181920def minCut(self, s): # acceleration if s == s[::-1]: return 0 for i in range(1, len(s)): if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]: return 1 # algorithm cut = [x for x in range(-1,len(s))] # cut numbers in worst case (no palindrome) for i in range(len(s)): r1, r2 = 0, 0 # use i as origin, and gradually enlarge radius if a palindrome exists # odd palindrome while i-r1 &gt;= 0 and i+r1 &lt; len(s) and s[i-r1] == s[i+r1]: cut[i+r1+1] = min(cut[i+r1+1], cut[i-r1]+1) r1 += 1 # even palindrome while i-r2 &gt;= 0 and i+r2+1 &lt; len(s) and s[i-r2] == s[i+r2+1]: cut[i+r2+2] = min(cut[i+r2+2], cut[i-r2]+1) r2 += 1 return cut[-1] The following code simply implements the algorithm without any optimization (1800 ms), and should be easier to understand. O(n) space and O(n^3) time complexity. 1234567def minCut(self, s): cut = [x for x in range(-1,len(s))] for i in range(0,len(s)): for j in range(i,len(s)): if s[i:j] == s[j:i:-1]: cut[j+1] = min(cut[j+1],cut[i]+1) return cut[-1] https://discuss.leetcode.com/topic/32575/easiest-java-dp-solution-97-36 Easiest Java DP Solution (97.36%) This can be solved by two points: cut[i] is the minimum of cut[j - 1] + 1 (j &lt;= i), if [j, i] is palindrome. If [j, i] is palindrome, [j + 1, i - 1] is palindrome, and c[j] == c[i]. The 2nd point reminds us of using dp (caching). 1234a b a | c c j i j-1 | [j, i] is palindrome cut(j-1) + 1 Hope it helps! 123456789101112131415161718public int minCut(String s) &#123; char[] c = s.toCharArray(); int n = c.length; int[] cut = new int[n]; boolean[][] pal = new boolean[n][n]; for(int i = 0; i &lt; n; i++) &#123; int min = i; for(int j = 0; j &lt;= i; j++) &#123; if(c[j] == c[i] &amp;&amp; (j + 1 &gt; i - 1 || pal[j + 1][i - 1])) &#123; pal[j][i] = true; min = j == 0 ? 0 : Math.min(min, cut[j - 1] + 1); &#125; &#125; cut[i] = min; &#125; return cut[n - 1];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[131. Palindrome Partitioning]]></title>
    <url>%2Fp%2F505b452c%2F</url>
    <content type="text"><![CDATA[31.6% https://leetcode.com/problems/palindrome-partitioning/#/description Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. 1234567For example, given s = &quot;aab&quot;,Return[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] https://discuss.leetcode.com/topic/10955/clean-c-backtracking-solution Clean C++ backtracking solution The Idea is simple: loop through the string, check if substr(0, i) is palindrome. If it is, recursively call dfs() on the rest of sub string: substr(i+1, length). keep the current palindrome partition so far in the â€˜pathâ€™ argument of dfs(). When reaching the end of string, add current partition in the result. 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt; &gt; ret; if(s.empty()) return ret; vector&lt;string&gt; path; dfs(0, s, path, ret); return ret; &#125; void dfs(int index, string&amp; s, vector&lt;string&gt;&amp; path, vector&lt;vector&lt;string&gt; &gt;&amp; ret) &#123; if(index == s.size()) &#123; ret.push_back(path); return; &#125; for(int i = index; i &lt; s.size(); ++i) &#123; if(isPalindrome(s, index, i)) &#123; path.push_back(s.substr(index, i - index + 1)); dfs(i+1, s, path, ret); path.pop_back(); &#125; &#125; &#125; bool isPalindrome(const string&amp; s, int start, int end) &#123; while(start &lt;= end) &#123; if(s[start++] != s[end--]) return false; &#125; return true; &#125;&#125;; https://discuss.leetcode.com/topic/15432/12ms-14-lines-c 12ms 14-lines C++ The problem has a nice structure that backtracking naturally fits in. The structure is, given a starting position idx, we search from idx till the end of the string s.length() - 1. Once we reach a position i such that the sub-string from idx to i (s.substr(idx, i - idx + 1)) is a palindrome, we add it to a temporary tmp. Then we recursively call the same function to process the remaining sub-string. Once we reach the end of the string, we add tmp into the result res of all the possible partitioning. Then, backtracking happens! Remember that at position i, we find s.substr(idx, i - idx + 1) to be a palindrome and we immediately add it to tmp. It is obvious that there may be some position j such that j &gt; i and s.substr(idx, j - idx + 1) is also a palindrome. So we need to recover to the state before adding s.substr(idx, i - idx + 1) to tmp and continue to find the next palindrome position after i. And we simply need to pop s.substr(idx, i - idx + 1) out of tmp to make things work. Putting these together, we can write down the following code, which should be self-explanatory. 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; tmp; getPartition(s, 0, tmp, res); return res; &#125;private: void getPartition(string&amp; s, int idx, vector&lt;string&gt;&amp; tmp, vector&lt;vector&lt;string&gt;&gt;&amp; res) &#123; if (idx == s.length()) &#123; res.push_back(tmp); return; &#125; for (int i = idx, n = s.length(); i &lt; n; i++) &#123; int l = idx, r = i; while (l &lt; r &amp;&amp; s[l] == s[r]) l++, r--; if (l &gt;= r) &#123; tmp.push_back(s.substr(idx, i - idx + 1)); getPartition(s, i + 1, tmp, res); tmp.pop_back(); &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/19370/1-liner-python-ruby 1-liner Python, Ruby Python: Broken into several physical lines for readability, but still one logical line and just one simple statement. 12345def partition(self, s): return [[s[:i]] + rest for i in xrange(1, len(s)+1) if s[:i] == s[i-1::-1] for rest in self.partition(s[i:])] or [[]] https://discuss.leetcode.com/topic/33425/python-recursive-iterative-backtracking-solution Python recursive/iterative backtracking solution Inspired by caikeheâ€™s solution: 123456789101112131415def partition(self, s): res = [] self.dfs(s, [], res) return resdef dfs(self, s, path, res): if not s: res.append(path) return for i in range(1, len(s)+1): if self.isPal(s[:i]): self.dfs(s[i:], path+[s[:i]], res) def isPal(self, s): return s == s[::-1] https://discuss.leetcode.com/topic/6186/java-backtracking-solution Java: Backtracking solution. if the input is â€œaabâ€, check if [0,0] â€œaâ€ is palindrome. then check [0,1] â€œaaâ€, then [0,2] â€œaabâ€.While checking [0,0], the rest of string is â€œabâ€, use ab as input to make a recursive call. in this example, in the loop of i=l+1, a recursive call will be made with input = â€œabâ€.Every time a recursive call is made, the position of l move right. How to define a correct answer? Think about DFS, if the current string to be checked (Palindrome) contains the last position, in this case â€œcâ€, this path is a correct answer, otherwise, itâ€™s a false answer. line 13: is the boundary to check if the current string contains the last element.l&gt;=s.length() 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; List&lt;List&lt;String&gt;&gt; resultLst; ArrayList&lt;String&gt; currLst; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; resultLst = new ArrayList&lt;List&lt;String&gt;&gt;(); currLst = new ArrayList&lt;String&gt;(); backTrack(s,0); return resultLst; &#125; public void backTrack(String s, int l)&#123; if(currLst.size()&gt;0 //the initial str could be palindrome &amp;&amp; l&gt;=s.length())&#123; List&lt;String&gt; r = (ArrayList&lt;String&gt;) currLst.clone(); resultLst.add(r); &#125; for(int i=l;i&lt;s.length();i++)&#123; if(isPalindrome(s,l,i))&#123; if(l==i) currLst.add(Character.toString(s.charAt(i))); else currLst.add(s.substring(l,i+1)); backTrack(s,i+1); currLst.remove(currLst.size()-1); &#125; &#125; &#125; public boolean isPalindrome(String str, int l, int r)&#123; if(l==r) return true; while(l&lt;r)&#123; if(str.charAt(l)!=str.charAt(r)) return false; l++;r--; &#125; return true; &#125;&#125; https://discuss.leetcode.com/topic/2884/my-java-dp-only-solution-without-recursion-o-n-2 My Java DP only solution without recursion. O(n^2) 12345678910111213141516171819202122232425public class Solution &#123; public static List&lt;List&lt;String&gt;&gt; partition(String s) &#123; int len = s.length(); List&lt;List&lt;String&gt;&gt;[] result = new List[len + 1]; result[0] = new ArrayList&lt;List&lt;String&gt;&gt;(); result[0].add(new ArrayList&lt;String&gt;()); boolean[][] pair = new boolean[len][len]; for (int i = 0; i &lt; s.length(); i++) &#123; result[i + 1] = new ArrayList&lt;List&lt;String&gt;&gt;(); for (int left = 0; left &lt;= i; left++) &#123; if (s.charAt(left) == s.charAt(i) &amp;&amp; (i-left &lt;= 1 || pair[left + 1][i - 1])) &#123; pair[left][i] = true; String str = s.substring(left, i + 1); for (List&lt;String&gt; r : result[left]) &#123; List&lt;String&gt; ri = new ArrayList&lt;String&gt;(r); ri.add(str); result[i + 1].add(ri); &#125; &#125; &#125; &#125; return result[len]; &#125;&#125; Here the pair is to mark a range for the substring is a Pal. if pair[i][j] is true, that means sub string from i to j is pal. The result[i], is to store from beginng until current index i (Non inclusive), all possible partitions. From the past result we can determine current result. https://discuss.leetcode.com/topic/37756/java-dp-dfs-solution Java DP + DFS solution The normal dfs backtracking will need to check each substring for palindrome, but a dp array can be used to record the possible break for palindrome before we start recursion. Edit: Sharing my thought process: first, I ask myself that how to check if a string is palindrome or not, usually a two point solution scanning from front and back. Here if you want to get all the possible palindrome partition, first a nested for loop to get every possible partitions for a string, then a scanning for all the partitions. Thatâ€™s a O(n^2) for partition and O(n^2) for the scanning of string, totaling at O(n^4) just for the partition. However, if we use a 2d array to keep track of any string we have scanned so far, with an addition pair, we can determine whether itâ€™s palindrome or not by justing looking at that pair, which is this line if(s.charAt(i) == s.charAt(j) &amp;&amp; (i - j &lt;= 2 || dp[j+1][i-1])). This way, the 2d array dp contains the possible palindrome partition among all. second, based on the prescanned palindrome partitions saved in dp array, a simple backtrack does the job. 123456789101112131415161718192021222324252627282930public class Solution &#123; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); boolean[][] dp = new boolean[s.length()][s.length()]; for(int i = 0; i &lt; s.length(); i++) &#123; for(int j = 0; j &lt;= i; j++) &#123; if(s.charAt(i) == s.charAt(j) &amp;&amp; (i - j &lt;= 2 || dp[j+1][i-1])) &#123; dp[j][i] = true; &#125; &#125; &#125; helper(res, new ArrayList&lt;&gt;(), dp, s, 0); return res; &#125; private void helper(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; path, boolean[][] dp, String s, int pos) &#123; if(pos == s.length()) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i = pos; i &lt; s.length(); i++) &#123; if(dp[pos][i]) &#123; path.add(s.substring(pos,i+1)); helper(res, path, dp, s, i+1); path.remove(path.size()-1); &#125; &#125; &#125;&#125; å›žæº¯æ³• https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/2 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list; &#125; public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125; &#125; public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[130. Surrounded Regions]]></title>
    <url>%2Fp%2F702b0957%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/surrounded-regions/?tab=Description Given a 2D board containing â€˜Xâ€™ and â€˜Oâ€™ (the letter O), capture all regions surrounded by â€˜Xâ€™. A region is captured by flipping all â€˜Oâ€™s into â€˜Xâ€™s in that surrounded region. 1234567891011For example,X X X XX O O XX X O XX O X XAfter running your function, the board should be:X X X XX X X XX X X XX O X X cpp23ms, 32.42%, October 14, 2016 https://discuss.leetcode.com/topic/17224/a-really-simple-and-readable-c-solution-only-cost-12ms A really simple and readable C++ solutionï¼Œonly cost 12ms First, check the four border of the matrix. If there is a element is â€˜Oâ€™, alter it and all its neighbor â€˜Oâ€™ elements to â€˜1â€™. Then ,alter all the â€˜Oâ€™ to â€˜Xâ€™ At last,alter all the â€˜1â€™ to â€˜Oâ€™ 123456For example: X X X X X X X X X X X X X X O X -&gt; X X O X -&gt; X X X X X O X X X 1 X X X O X X X O X X X 1 X X X O X X 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int i, j; int row = board.size(); if(!row) return; int col = board[0].size(); for(i=0; i&lt;row; i++)&#123; check(board, i, 0, row, col); if(col&gt;1) check(board, i, col-1, row, col); &#125; for(j=1; j+1&lt;col; j++)&#123; check(board, 0, j, row, col); if(row&gt;1) check(board, row-1, j, row, col); &#125; for(i=0; i&lt;row; i++) for(j=0; j&lt;col; j++) if(board[i][j]==&apos;O&apos;) board[i][j] = &apos;X&apos;; for(i=0; i&lt;row; i++) for(j=0; j&lt;col; j++) if(board[i][j] == &apos;1&apos;) board[i][j] = &apos;O&apos;; &#125; void check(vector&lt;vector&lt;char&gt;&gt; &amp;vec, int i, int j, int row, int col)&#123; if(vec[i][j] == &apos;O&apos;)&#123; vec[i][j] = &apos;1&apos;; if(i&gt;1) check(vec, i-1, j, row, col); if(j&gt;1) check(vec, i, j-1, row, col); if(i+1&lt;row) check(vec, i+1, j, row, col); if(j+1&lt;col) check(vec, i, j+1, row, col); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/1944/solve-it-using-union-find Solve it using Union Find 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class UF&#123;private: int* id; // id[i] = parent of i int* rank; // rank[i] = rank of subtree rooted at i (cannot be more than 31) int count; // number of componentspublic: UF(int N) &#123; count = N; id = new int[N]; rank = new int[N]; for (int i = 0; i &lt; N; i++) &#123; id[i] = i; rank[i] = 0; &#125; &#125; ~UF() &#123; delete [] id; delete [] rank; &#125; int find(int p) &#123; while (p != id[p]) &#123; id[p] = id[id[p]]; // path compression by halving p = id[p]; &#125; return p; &#125; int getCount() &#123; return count; &#125; bool connected(int p, int q) &#123; return find(p) == find(q); &#125; void connect(int p, int q) &#123; int i = find(p); int j = find(q); if (i == j) return; if (rank[i] &lt; rank[j]) id[i] = j; else if (rank[i] &gt; rank[j]) id[j] = i; else &#123; id[j] = i; rank[i]++; &#125; count--; &#125;&#125;;class Solution &#123;public: void solve(vector&lt;vector&lt;char&gt;&gt; &amp;board) &#123; int n = board.size(); if(n==0) return; int m = board[0].size(); UF uf = UF(n*m+1); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if((i==0||i==n-1||j==0||j==m-1)&amp;&amp;board[i][j]==&apos;O&apos;) // if a &apos;O&apos; node is on the boundry, connect it to the dummy node uf.connect(i*m+j,n*m); else if(board[i][j]==&apos;O&apos;) // connect a &apos;O&apos; node to its neighbour &apos;O&apos; nodes &#123; if(board[i-1][j]==&apos;O&apos;) uf.connect(i*m+j,(i-1)*m+j); if(board[i+1][j]==&apos;O&apos;) uf.connect(i*m+j,(i+1)*m+j); if(board[i][j-1]==&apos;O&apos;) uf.connect(i*m+j,i*m+j-1); if(board[i][j+1]==&apos;O&apos;) uf.connect(i*m+j,i*m+j+1); &#125; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(!uf.connected(i*m+j,n*m))&#123; // if a &apos;O&apos; node is not connected to the dummy node, it is captured board[i][j]=&apos;X&apos;; &#125; &#125; &#125; &#125;&#125;; Hi. So here is my accepted code using Union Find data structure. The idea comes from the observation that if a region is NOT captured, it is connected to the boundry. So if we connect all the â€˜Oâ€™ nodes on the boundry to a dummy node, and then connect each â€˜Oâ€™ node to its neighbour â€˜Oâ€™ nodes, then we can tell directly whether a â€˜Oâ€™ node is captured by checking whether it is connected to the dummy node. For more about Union Find, the first assignment in the algo1 may help: https://www.coursera.org/course/algs4partI https://discuss.leetcode.com/topic/1944/solve-it-using-union-find/2 just another version in java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123; int[] unionSet; // union find set boolean[] hasEdgeO; // whether an union has an &apos;O&apos; which is on the edge of the matrix public void solve(char[][] board) &#123; if(board.length == 0 || board[0].length == 0) return; // init, every char itself is an union int height = board.length, width = board[0].length; unionSet = new int[height * width]; hasEdgeO = new boolean[unionSet.length]; for(int i = 0;i&lt;unionSet.length; i++) unionSet[i] = i; for(int i = 0;i&lt;hasEdgeO.length; i++)&#123; int x = i / width, y = i % width; hasEdgeO[i] = (board[x][y] == &apos;O&apos; &amp;&amp; (x==0 || x==height-1 || y==0 || y==width-1)); &#125; // iterate the matrix, for each char, union it + its upper char + its right char if they equals to each other for(int i = 0;i&lt;unionSet.length; i++)&#123; int x = i / width, y = i % width, up = x - 1, right = y + 1; if(up &gt;= 0 &amp;&amp; board[x][y] == board[up][y]) union(i,i-width); if(right &lt; width &amp;&amp; board[x][y] == board[x][right]) union(i,i+1); &#125; // for each char in the matrix, if it is an &apos;O&apos; and its union doesn&apos;t has an &apos;edge O&apos;, the whole union should be setted as &apos;X&apos; for(int i = 0;i&lt;unionSet.length; i++)&#123; int x = i / width, y = i % width; if(board[x][y] == &apos;O&apos; &amp;&amp; !hasEdgeO[findSet(i)]) board[x][y] = &apos;X&apos;; &#125; &#125; private void union(int x,int y)&#123; int rootX = findSet(x); int rootY = findSet(y); // if there is an union has an &apos;edge O&apos;,the union after merge should be marked too boolean hasEdgeO = this.hasEdgeO[rootX] || this.hasEdgeO[rootY]; unionSet[rootX] = rootY; this.hasEdgeO[rootY] = hasEdgeO; &#125; private int findSet(int x)&#123; if(unionSet[x] == x) return x; unionSet[x] = findSet(unionSet[x]); return unionSet[x]; &#125;&#125; https://discuss.leetcode.com/topic/18706/9-lines-python-148-ms 9 lines, Python 148 ms Phase 1: â€œSaveâ€ every O-region touching the border, changing its cells to â€˜Sâ€™. Phase 2: Change every â€˜Sâ€™ on the board to â€˜Oâ€™ and everything else to â€˜Xâ€™. 123456789101112def solve(self, board): if not any(board): return m, n = len(board), len(board[0]) save = [ij for k in range(m+n) for ij in ((0, k), (m-1, k), (k, 0), (k, n-1))] while save: i, j = save.pop() if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and board[i][j] == &apos;O&apos;: board[i][j] = &apos;S&apos; save += (i, j-1), (i, j+1), (i-1, j), (i+1, j) board[:] = [[&apos;XO&apos;[c == &apos;S&apos;] for c in row] for row in board] In case you donâ€™t like my last line, you could do this instead: 123for row in board: for i, c in enumerate(row): row[i] = &apos;XO&apos;[c == &apos;S&apos;] https://discuss.leetcode.com/topic/2982/my-bfs-solution-c-28ms My BFS solution (C++ 28ms) The algorithm is quite simple: Use BFS starting from â€˜Oâ€™s on the boundary and mark them as â€˜Bâ€™, then iterate over the whole board and mark â€˜Oâ€™ as â€˜Xâ€™ and â€˜Bâ€™ as â€˜Oâ€™. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void bfsBoundary(vector&lt;vector&lt;char&gt; &gt;&amp; board, int w, int l)&#123; int width = board.size(); int length = board[0].size(); deque&lt;pair&lt;int, int&gt; &gt; q; q.push_back(make_pair(w, l)); board[w][l] = &apos;B&apos;; while (!q.empty()) &#123; pair&lt;int, int&gt; cur = q.front(); q.pop_front(); pair&lt;int, int&gt; adjs[4] = &#123;&#123;cur.first-1, cur.second&#125;, &#123;cur.first+1, cur.second&#125;, &#123;cur.first, cur.second-1&#125;, &#123;cur.first, cur.second+1&#125;&#125;; for (int i = 0; i &lt; 4; ++i) &#123; int adjW = adjs[i].first; int adjL = adjs[i].second; if ((adjW &gt;= 0) &amp;&amp; (adjW &lt; width) &amp;&amp; (adjL &gt;= 0) &amp;&amp; (adjL &lt; length) &amp;&amp; (board[adjW][adjL] == &apos;O&apos;)) &#123; q.push_back(make_pair(adjW, adjL)); board[adjW][adjL] = &apos;B&apos;; &#125; &#125; &#125;&#125;void solve(vector&lt;vector&lt;char&gt; &gt; &amp;board) &#123; int width = board.size(); if (width == 0) //Add this to prevent run-time error! return; int length = board[0].size(); if (length == 0) // Add this to prevent run-time error! return; for (int i = 0; i &lt; length; ++i) &#123; if (board[0][i] == &apos;O&apos;) bfsBoundary(board, 0, i); if (board[width-1][i] == &apos;O&apos;) bfsBoundary(board, width-1, i); &#125; for (int i = 0; i &lt; width; ++i) &#123; if (board[i][0] == &apos;O&apos;) bfsBoundary(board, i, 0); if (board[i][length-1] == &apos;O&apos;) bfsBoundary(board, i, length-1); &#125; for (int i = 0; i &lt; width; ++i) &#123; for (int j = 0; j &lt; length; ++j) &#123; if (board[i][j] == &apos;O&apos;) board[i][j] = &apos;X&apos;; else if (board[i][j] == &apos;B&apos;) board[i][j] = &apos;O&apos;; &#125; &#125;&#125; Note that one of the test cases is when the board is empty. So if you donâ€™t check it in your code, you will encounter an run-time error. https://discuss.leetcode.com/topic/25010/java-dfs-boundary-cell-turning-solution-simple-and-clean-code-commented Java DFS + boundary cell turning solution, simple and clean code, commented. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void solve(char[][] board) &#123; if (board.length == 0 || board[0].length == 0) return; if (board.length &lt; 2 || board[0].length &lt; 2) return; int m = board.length, n = board[0].length; //Any &apos;O&apos; connected to a boundary can&apos;t be turned to &apos;X&apos;, so ... //Start from first and last column, turn &apos;O&apos; to &apos;*&apos;. for (int i = 0; i &lt; m; i++) &#123; if (board[i][0] == &apos;O&apos;) boundaryDFS(board, i, 0); if (board[i][n-1] == &apos;O&apos;) boundaryDFS(board, i, n-1); &#125; //Start from first and last row, turn &apos;0&apos; to &apos;*&apos; for (int j = 0; j &lt; n; j++) &#123; if (board[0][j] == &apos;O&apos;) boundaryDFS(board, 0, j); if (board[m-1][j] == &apos;O&apos;) boundaryDFS(board, m-1, j); &#125; //post-prcessing, turn &apos;O&apos; to &apos;X&apos;, &apos;*&apos; back to &apos;O&apos;, keep &apos;X&apos; intact. for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (board[i][j] == &apos;O&apos;) board[i][j] = &apos;X&apos;; else if (board[i][j] == &apos;*&apos;) board[i][j] = &apos;O&apos;; &#125; &#125;&#125;//Use DFS algo to turn internal however boundary-connected &apos;O&apos; to &apos;*&apos;;private void boundaryDFS(char[][] board, int i, int j) &#123; if (i &lt; 0 || i &gt; board.length - 1 || j &lt;0 || j &gt; board[0].length - 1) return; if (board[i][j] == &apos;O&apos;) board[i][j] = &apos;*&apos;; if (i &gt; 1 &amp;&amp; board[i-1][j] == &apos;O&apos;) boundaryDFS(board, i-1, j); if (i &lt; board.length - 2 &amp;&amp; board[i+1][j] == &apos;O&apos;) boundaryDFS(board, i+1, j); if (j &gt; 1 &amp;&amp; board[i][j-1] == &apos;O&apos;) boundaryDFS(board, i, j-1); if (j &lt; board[i].length - 2 &amp;&amp; board[i][j+1] == &apos;O&apos; ) boundaryDFS(board, i, j+1);&#125; https://discuss.leetcode.com/topic/6496/my-java-o-n-2-accepted-solution My Java O(n^2) accepted solution The idea is pretty simple: a â€˜Oâ€™ marked cell cannot be captured whether: It is in contact with the border of the board or It is adjacent to an unflippable cell. So the algorithm is straightforward: Go around the border of the board When a â€˜Oâ€™ cell is found mark it with â€˜Uâ€™ and perform a DFS on its adjacent cells looking for other â€˜Oâ€™ marked cells. When the entire border is processed scan again the board If a cell is marked as â€˜Oâ€™ it wasnâ€™t connected to unflippable cell. Hence capture it with â€˜Xâ€™ If a cell is marked as â€˜Xâ€™ nothing must be done. If a cell is marked as â€˜Uâ€™ mark it as â€˜Oâ€™ because it was an original â€˜Oâ€™ marked cell which satisfied one of the above conditions.On a technical side regarding the code: In the problem statement itâ€™s not specified that the board is rectangular. So different checks must performed when scanning the border. Since a pure recursive search causes stack overflow itâ€™s necessary to make the DFS iterative using a stack to simulate recursion.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Solution &#123; static class Pair &#123; public int first; public int second; public Pair(int f, int s) &#123; first = f; second = s; &#125;&#125;public void solve(char[][] board) &#123; if(board == null || board.length == 0) &#123; return ; &#125; for(int i = 0; i &lt; board[0].length; ++i) &#123; if(board[0][i] == &apos;O&apos;) &#123; markUnflippable(board,0,i); &#125; &#125; for(int i = 0; i &lt; board[board.length-1].length; ++i) &#123; if(board[board.length-1][i] == &apos;O&apos;) &#123; markUnflippable(board,board.length-1,i); &#125; &#125; for(int i = 0 ; i &lt; board.length; ++i) &#123; if(board[i][0] == &apos;O&apos;) &#123; markUnflippable(board,i,0); &#125; &#125; for(int i =0; i &lt; board.length; ++i) &#123; if(board[i][board[i].length-1] == &apos;O&apos;) &#123; markUnflippable(board,i,board[i].length-1); &#125; &#125; // modify the board for(int i = 0; i &lt; board.length; ++i) &#123; for(int j = 0; j &lt; board[i].length; ++j) &#123; if(board[i][j] == &apos;O&apos;) &#123; board[i][j] = &apos;X&apos;; &#125; else if(board[i][j] == &apos;U&apos;) &#123; board[i][j] = &apos;O&apos;; &#125; &#125; &#125;&#125;public void markUnflippable(char[][] board, int r, int c) &#123; int[] dirX = &#123;-1,0,1,0&#125;; int[] dirY = &#123;0,1,0,-1&#125;; ArrayDeque&lt;Pair&gt; stack = new ArrayDeque&lt;&gt;(); stack.push(new Pair(r,c)); while(!stack.isEmpty()) &#123; Pair p = stack.pop(); board[p.first][p.second] = &apos;U&apos;; for(int i = 0; i &lt; dirX.length; ++i) &#123; if(p.first + dirX[i] &gt;= 0 &amp;&amp; p.first + dirX[i] &lt; board.length &amp;&amp; p.second + dirY[i] &gt;= 0 &amp;&amp; p.second +dirY[i] &lt; board[p.first + dirX[i]].length &amp;&amp; board[p.first+dirX[i]][p.second+dirY[i]] == &apos;O&apos;) &#123; stack.push(new Pair(p.first+dirX[i],p.second+dirY[i])); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>breadth first search</tag>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[129. Sum Root to Leaf Numbers]]></title>
    <url>%2Fp%2Fac2bd33a%2F</url>
    <content type="text"><![CDATA[35.5% https://leetcode.com/problems/sum-root-to-leaf-numbers/?tab=Description Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. 123456789For example, 1 / \ 2 3The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13.Return the sum = 12 + 13 = 25. æ–¹æ³•ä¸€ï¼š 56ms, 46.63%, July 15th, 2016 https://discuss.leetcode.com/topic/12048/5-ms-c-code-using-dfs 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int sumNumbers(TreeNode* root) &#123; if(!root) return 0; sum = 0; DFS(root, 0); return sum; &#125; void DFS(TreeNode *&amp;node, int currentSum)&#123; currentSum = currentSum * 10 + node-&gt;val; if(!node-&gt;left &amp;&amp; !node-&gt;right) sum += currentSum; if(node-&gt;left) DFS(node-&gt;left, currentSum); if(node-&gt;right) DFS(node-&gt;right, currentSum); &#125;private: int sum;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int sumNumbers(TreeNode* root) &#123; int res = 0, cur = 0; helper(root, res, cur); return res; &#125; void helper(TreeNode* root, int&amp; res, int cur)&#123; if(!root) return; cur = cur*10 + root-&gt;val; if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123; res += cur; return; &#125; helper(root-&gt;left, res, cur); helper(root-&gt;right, res, cur); &#125;&#125;; æ–¹æ³•äºŒï¼š https://discuss.leetcode.com/topic/3025/one-of-the-easier-solution-using-preorder-traversal-recursion One of the easier solution using preorder traversal (recursion) The idea is to do a preorder traversal of the tree. In the preorder traversal, keep track of the value calculated till the current node, let this value be val. For every node, we update the val as val10 plus nodeâ€™s data.* 123456789101112131415161718192021class Solution &#123;public: int sumNumbers(TreeNode *root) &#123; return sumNumberUtil(root,0); &#125; // preorder int sumNumberUtil(struct TreeNode* node, int val) &#123; if(node==NULL) return 0; val= val*10+node-&gt;val; if(node-&gt;left==NULL &amp;&amp; node-&gt;right==NULL) &#123; return val; &#125; return sumNumberUtil(node-&gt;left,val)+sumNumberUtil(node-&gt;right, val); &#125;&#125;; python 76ms, 10.56%, July 15th, 2016 https://discuss.leetcode.com/topic/21363/python-solutions-dfs-stack-bfs-queue-dfs-recursively Python solutions (dfs+stack, bfs+queue, dfs recursively). 123456789101112131415# dfs + stackdef sumNumbers1(self, root): if not root: return 0 stack, res = [(root, root.val)], 0 while stack: node, value = stack.pop() if node: if not node.left and not node.right: res += value if node.right: stack.append((node.right, value*10+node.right.val)) if node.left: stack.append((node.left, value*10+node.left.val)) return res 123456789101112131415# bfs + queuedef sumNumbers2(self, root): if not root: return 0 queue, res = collections.deque([(root, root.val)]), 0 while queue: node, value = queue.popleft() if node: if not node.left and not node.right: res += value if node.left: queue.append((node.left, value*10+node.left.val)) if node.right: queue.append((node.right, value*10+node.right.val)) return res 12345678910111213141516# recursively def sumNumbers(self, root): self.res = 0 self.dfs(root, 0) return self.res def dfs(self, root, value): if root: #if not root.left and not root.right: # self.res += value*10 + root.val self.dfs(root.left, value*10+root.val) #if not root.left and not root.right: # self.res += value*10 + root.val self.dfs(root.right, value*10+root.val) if not root.left and not root.right: self.res += value*10 + root.val java solution 1: 1ms, 28.00%, July 15th, 2016 https://discuss.leetcode.com/topic/6731/short-java-solution-recursion 1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public int sumNumbers(TreeNode root) &#123; return sum(root, 0); &#125; public int sum(TreeNode n, int s)&#123; if(n==null) return 0; if(n.right == null &amp;&amp; n.left == null) return s*10 + n.val; return sum(n.left, s*10+n.val) + sum(n.right, s*10 + n.val); &#125;&#125; solution 2: 1ms, 28.00%, July 15th, 2016 https://discuss.leetcode.com/topic/644/can-you-improve-this-algorithm Can you improve this algorithm? 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public int sumNumbers(TreeNode root) &#123; if (root == null) return 0; return sumR(root, 0); &#125; public int sumR(TreeNode root, int x) &#123; if (root.right == null &amp;&amp; root.left == null) return 10 * x + root.val; int val = 0; if (root.left != null) val += sumR(root.left, 10 * x + root.val); if (root.right != null) val += sumR(root.right, 10 * x + root.val); return val; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[128. Longest Consecutive Sequence]]></title>
    <url>%2Fp%2Fb1f32255%2F</url>
    <content type="text"><![CDATA[35.7% https://leetcode.com/problems/longest-consecutive-sequence/?tab=Description Given an unsorted array of integers, find the length of the longest consecutive elements sequence. 123For example,Given [100, 4, 200, 1, 3, 2],The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4. Your algorithm should run in O(n) complexity. æ–¹æ³•ä¸€ï¼š æŽ’åºï¼Œä¸€ä¸ªä¸ªçš„æŸ¥æ‰¾ my code: å…ˆæŽ’åºï¼Œç„¶åŽä¾æ¬¡æŸ¥æ‰¾ï¼ŒåŒæ—¶æ³¨æ„å‡ºçŽ°ç›¸åŒæ•°å­—çš„å¤„ç†ã€‚ ä½†æ˜¯è¾¾åˆ°ä¸äº†é¢˜ç›®è¦æ±‚çš„Oï¼ˆnï¼‰ 12345678910111213141516171819202122232425class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0 || nums.size()==1) return nums.size(); sort(nums.begin(), nums.end()); int res=1; int tmp=1; int last = nums[0]; for(int i=1; i&lt;nums.size(); i++)&#123; if(nums[i]==nums[i-1]) continue; else if(nums[i]==last+1)&#123; tmp += 1; last = nums[i]; &#125; else&#123; res = max(tmp, res); tmp = 1; last = nums[i]; &#125; &#125; res = max(res, tmp); return res; &#125;&#125;; æ–¹æ³•äºŒï¼š ä½¿ç”¨setï¼Œç„¶è€Œæ•ˆçŽ‡ä»ç„¶æ˜¯oï¼ˆnlognï¼‰ https://discuss.leetcode.com/topic/16483/a-simple-c-solution-using-unordered_set-and-simple-consideration-about-this-problem A simple C++,solution using unordered_set.And simple consideration about this problem I have seen a lot of discussion about this problem.In my opinion,it is not correct to use set(which is ordered),because very time we insert an element to a ordered set,it will cost O(n),so the total complexity is O(nlogn),which violates the request of the problem.So here we use an unordered_set,and one is enough. Besides,to think about this problem,one principle issue we should realize is that usually when we want to reduce the time complexity,we have to increase the space complexity.In this case,if we want to access an element within O(1),we have to use hash table. 12345678910111213141516class Solution &#123;public: int longestConsecutive(vector&lt;int&gt; &amp;num) &#123; unordered_set&lt;int&gt; record(num.begin(),num.end()); int res = 1; for(int n : num)&#123; if(record.find(n)==record.end()) continue; record.erase(n); int prev = n-1,next = n+1; while(record.find(prev)!=record.end()) record.erase(prev--); while(record.find(next)!=record.end()) record.erase(next++); res = max(res,next-prev-1); &#125; return res; &#125;&#125;; my codeï¼š 123456789101112131415161718class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; set(nums.begin(), nums.end()); int ret = 1; for(auto &amp;n: nums) &#123; if(!set.count(n)) continue; set.erase(n); // åˆ é™¤å…ƒç´  int pre=n-1, next=n+1; while(set.count(pre)) set.erase(pre--); // set.count(n) è¿”å›žåŒ¹é…ç»™ä¸»é”®çš„å…ƒç´ çš„ä¸ªæ•° while(set.count(next)) set.erase(next++); ret = max(ret, next-pre-1); &#125; return ret; &#125;&#125;; æ–¹æ³•ä¸‰ï¼š ä½¿ç”¨hashmap m[i]è¡¨ç¤ºiä¸ºä¸­é—´å€¼çš„ä¸€æ®µçš„é•¿åº¦çš„å¤§å°ï¼Œåˆå§‹ä¸º0 https://discuss.leetcode.com/topic/5333/possibly-shortest-cpp-solution-only-6-lines Possibly shortest cpp solution, only 6 lines. use a hash map to store boundary information of consecutive sequence for each element; there 4 cases when a new element i reached: neither i+1 nor i-1 has been seen: m[i]=1; both i+1 and i-1 have been seen: extend m[i+m[i+1]] and m[i-m[i-1]] to each other; only i+1 has been seen: extend m[i+m[i+1]] and m[i] to each other; only i-1 has been seen: extend m[i-m[i-1]] and m[i] to each other. 123456789int longestConsecutive(vector&lt;int&gt; &amp;num) &#123; unordered_map&lt;int, int&gt; m; int r = 0; for (int i : num) &#123; if (m[i]) continue; r = max(r, m[i] = m[i + m[i + 1]] = m[i - m[i - 1]] = m[i + 1] + m[i - 1] + 1); &#125; return r;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; map; int res = 0; for(int num:nums)&#123; if(map[num]) continue; int len = map[num-1] + map[num+1] + 1; map[num+map[num+1]] = len; map[num-map[num-1]] = len; map[num] = len; res = max(res, len); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/6408/13-line-c-solution 13-line C++ solution Thought I would share it here. May be useful for some one. The algorithm itself is pretty straightforward. But it benefited quite much from the neat expression of C++ idioms. Comments are appreciated! 12345678910111213int longestConsecutive(const vector&lt;int&gt; &amp;num) &#123; unordered_set&lt;int&gt; s(num.begin(), num.end()), searched; int longest = 0; for (int i: num) &#123; if (searched.find(i) != searched.end()) continue; searched.insert(i); int j = i - 1, k = i + 1; while (s.find(j) != s.end()) searched.insert(j--); while (s.find(k) != s.end()) searched.insert(k++); longest = max(longest, k - 1 - j); &#125; return longest;&#125; python https://discuss.leetcode.com/topic/15383/simple-o-n-with-explanation-just-walk-each-streak Simple O(n) with Explanation - Just walk each streak First turn the input into a set of numbers. That takes O(n) and then we can ask in O(1) whether we have a certain number. Then go through the numbers. If the number x is the start of a streak (i.e., x-1 is not in the set), then test y = x+1, x+2, x+3, â€¦ and stop at the first number y not in the set. The length of the streak is then simply y-x and we update our global best with that. Since we check each streak only once, this is overall O(n). This ran in 44 ms on the OJ, one of the fastest Python submissions. 12345678910def longestConsecutive(self, nums): nums = set(nums) best = 0 for x in nums: if x - 1 not in nums: y = x + 1 while y in nums: y += 1 best = max(best, y - x) return best https://discuss.leetcode.com/topic/10678/python-o-n-solution-using-sets Python O(n) solution using sets 12345678910111213141516171819202122class Solution: # @param num, a list of integer # @return an integer def longestConsecutive(self, num): num=set(num) maxLen=0 while num: n=num.pop() i=n+1 l1=0 l2=0 while i in num: num.remove(i) i+=1 l1+=1 i=n-1 while i in num: num.remove(i) i-=1 l2+=1 maxLen=max(maxLen,l1+l2+1) return maxLen java https://discuss.leetcode.com/topic/6148/my-really-simple-java-o-n-solution-accepted My really simple Java O(n) solution - Accepted We will use HashMap. The key thing is to keep track of the sequence length and store that in the boundary points of the sequence. For example, as a result, for sequence {1, 2, 3, 4, 5}, map.get(1) and map.get(5) should both return 5. Whenever a new element n is inserted into the map, do two things: See if n - 1 and n + 1 exist in the map, and if so, it means there is an existing sequence next to n. Variables left and right will be the length of those two sequences, while 0 means there is no sequence and n will be the boundary point later. Store (left + right + 1) as the associated value to key n into the map. Use left and right to locate the other end of the sequences to the left and right of n respectively, and replace the value with the new length. Everything inside the for loop is O(1) so the total time is O(n). Please comment if you see something wrong. Thanks. 123456789101112131415161718192021222324252627public int longestConsecutive(int[] num) &#123; int res = 0; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int n : num) &#123; if (!map.containsKey(n)) &#123; int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0; int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0; // sum: length of the sequence n is in int sum = left + right + 1; map.put(n, sum); // keep track of the max length res = Math.max(res, sum); // extend the length to the boundary(s) // of the sequence // will do nothing if n has no neighbors map.put(n - left, sum); map.put(n + right, sum); &#125; else &#123; // duplicates continue; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/29286/my-java-solution-using-unionfound My Java Solution using UnionFound 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Solution &#123; public int longestConsecutive(int[] nums) &#123; UF uf = new UF(nums.length); Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); // &lt;value,index&gt; for(int i=0; i&lt;nums.length; i++)&#123; if(map.containsKey(nums[i]))&#123; continue; &#125; map.put(nums[i],i); if(map.containsKey(nums[i]+1))&#123; uf.union(i,map.get(nums[i]+1)); &#125; if(map.containsKey(nums[i]-1))&#123; uf.union(i,map.get(nums[i]-1)); &#125; &#125; return uf.maxUnion(); &#125; &#125; class UF&#123; private int[] list; public UF(int n)&#123; list = new int[n]; for(int i=0; i&lt;n; i++)&#123; list[i] = i; &#125; &#125; private int root(int i)&#123; while(i!=list[i])&#123; list[i] = list[list[i]]; i = list[i]; &#125; return i; &#125; public boolean connected(int i, int j)&#123; return root(i) == root(j); &#125; public void union(int p, int q)&#123; int i = root(p); int j = root(q); list[i] = j; &#125; // returns the maxium size of union public int maxUnion()&#123; // O(n) int[] count = new int[list.length]; int max = 0; for(int i=0; i&lt;list.length; i++)&#123; count[root(i)] ++; max = Math.max(max, count[root(i)]); &#125; return max; &#125; &#125; https://discuss.leetcode.com/topic/9088/o-n-hashmap-java-solution O(n) HashMap Java Solution Use a hashmap to map a number to its longest consecutive sequence length, each time find a new consecutive sequence, only the begin number and end number need to be modified. 12345678910111213141516171819202122public class Solution &#123; public int longestConsecutive(int[] num) &#123; int longest = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0;i &lt; num.length;i++)&#123; // if there is no duplicates, these two lines can be commented if(map.containsKey(num[i])) continue; map.put(num[i],1); int end = num[i]; int begin = num[i]; if(map.containsKey(num[i]+1)) end = num[i] + map.get(num[i]+1); if(map.containsKey(num[i]-1)) begin = num[i] - map.get(num[i]-1); longest = Math.max(longest, end-begin+1); map.put(end, end-begin+1); map.put(begin, end-begin+1); &#125; return longest; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hard</tag>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[127. Word Ladder]]></title>
    <url>%2Fp%2Ffdab0eca%2F</url>
    <content type="text"><![CDATA[19.2% https://leetcode.com/problems/word-ladder/#/description Given two words (beginWord and endWord), and a dictionaryâ€™s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. 12345678For example,Given:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,return its length 5. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. UPDATE (2017/1/20): The wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. https://discuss.leetcode.com/topic/16983/easy-76ms-c-solution-using-bfs Easy 76ms C++ Solution using BFS Well, this problem has a nice BFS structure. Letâ€™s see the example in the problem statement. 12345start = &quot;hit&quot;end = &quot;cog&quot;dict = [&quot;hot&quot;, &quot;dot&quot;, &quot;dog&quot;, &quot;lot&quot;, &quot;log&quot;] Since only one letter can be changed at a time, if we start from â€œhitâ€, we can only change to those words which have only one different letter from it, like â€œhotâ€. Putting in graph-theoretic terms, we can say that â€œhotâ€ is a neighbor of â€œhitâ€. The idea is simpy to begin from start, then visit its neighbors, then the non-visited neighbors of its neighborsâ€¦ Well, this is just the typical BFS structure. To simplify the problem, we insert end into dict. Once we meet end during the BFS, we know we have found the answer. We maintain a variable dist for the current distance of the transformation and update it by dist++ after we finish a round of BFS search (note that it should fit the definition of the distance in the problem statement). Also, to avoid visiting a word for more than once, we erase it from dict once it is visited. The code is as follows. 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int ladderLength(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordDict) &#123; wordDict.insert(endWord); queue&lt;string&gt; toVisit; addNextWords(beginWord, wordDict, toVisit); int dist = 2; while (!toVisit.empty()) &#123; int num = toVisit.size(); for (int i = 0; i &lt; num; i++) &#123; string word = toVisit.front(); toVisit.pop(); if (word == endWord) return dist; addNextWords(word, wordDict, toVisit); &#125; dist++; &#125; &#125;private: void addNextWords(string word, unordered_set&lt;string&gt;&amp; wordDict, queue&lt;string&gt;&amp; toVisit) &#123; wordDict.erase(word); for (int p = 0; p &lt; (int)word.length(); p++) &#123; char letter = word[p]; for (int k = 0; k &lt; 26; k++) &#123; word[p] = &apos;a&apos; + k; if (wordDict.find(word) != wordDict.end()) &#123; toVisit.push(word); wordDict.erase(word); &#125; &#125; word[p] = letter; &#125; &#125; &#125;; The above code can still be speeded up if we also begin from end. Once we meet the same word from start and end, we know we are done. This link provides a nice two-end search solution. I rewrite the code below for better readability. Note that the use of two pointers phead and ptail save a lot of time. At each round of BFS, depending on the relative size of head and tail, we point phead to the smaller set to reduce the running time. 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int ladderLength(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; head, tail, *phead, *ptail; head.insert(beginWord); tail.insert(endWord); int dist = 2; while (!head.empty() &amp;&amp; !tail.empty()) &#123; if (head.size() &lt; tail.size()) &#123; phead = &amp;head; ptail = &amp;tail; &#125; else &#123; phead = &amp;tail; ptail = &amp;head; &#125; unordered_set&lt;string&gt; temp; for (auto itr = phead -&gt; begin(); itr != phead -&gt; end(); itr++) &#123; string word = *itr; wordDict.erase(word); for (int p = 0; p &lt; (int)word.length(); p++) &#123; char letter = word[p]; for (int k = 0; k &lt; 26; k++) &#123; word[p] = &apos;a&apos; + k; if (ptail -&gt; find(word) != ptail -&gt; end()) return dist; if (wordDict.find(word) != wordDict.end()) &#123; temp.insert(word); wordDict.erase(word); &#125; &#125; word[p] = letter; &#125; &#125; dist++; swap(*phead, temp); &#125; return 0; &#125;&#125;; https://discuss.leetcode.com/topic/10372/share-my-two-end-bfs-in-c-80ms Share my two-end BFS in C++ 80ms. 12345678910111213141516171819202122232425262728293031323334353637383940//BFSï¼Œ two-end method//traverse the path simultaneously from start node and end node, and merge in the middle//the speed will increase (logN/2)^2 times compared with one-end methodint ladderLength(string start, string end, unordered_set&lt;string&gt; &amp;dict) &#123; unordered_set&lt;string&gt; begSet, endSet, *set1, *set2; begSet.insert(start); endSet.insert(end); int h=1, K=start.size(); while(!begSet.empty()&amp;&amp;!endSet.empty())&#123; if(begSet.size()&lt;=endSet.size())&#123; //Make the size of two sets close for optimization set1=&amp;begSet; //set1 is the forward set set2=&amp;endSet; //set2 provides the target node for set1 to search &#125; else&#123; set1=&amp;endSet; set2=&amp;begSet; &#125; unordered_set&lt;string&gt; itmSet; //intermediate Set h++; for(auto i=set1-&gt;begin();i!=set1-&gt;end();i++)&#123; string cur=*i; for(int k=0;k&lt;K;k++)&#123; //iterate the characters in string cur char temp=cur[k]; for(int l=0;l&lt;26;l++)&#123; //try all 26 alphabets cur[k]=&apos;a&apos;+l; auto f=set2-&gt;find(cur); if(f!=set2-&gt;end())return h; f=dict.find(cur); if(f!=dict.end())&#123; itmSet.insert(cur); dict.erase(f); &#125; &#125; cur[k]=temp; &#125; &#125; swap(*set1, itmSet); &#125; return 0;&#125; https://discuss.leetcode.com/topic/43246/simple-to-understand-python-solution-using-list-preprocessing-and-bfs-beats-95 Simple to understand Python solution using list preprocessing and BFS, beats 95% 1234567891011121314151617181920212223242526272829303132from collections import dequeclass Solution(object): def ladderLength(self, beginWord, endWord, wordList): def construct_dict(word_list): d = &#123;&#125; for word in word_list: for i in range(len(word)): s = word[:i] + &quot;_&quot; + word[i+1:] d[s] = d.get(s, []) + [word] return d def bfs_words(begin, end, dict_words): queue, visited = deque([(begin, 1)]), set() while queue: word, steps = queue.popleft() if word not in visited: visited.add(word) if word == end: return steps for i in range(len(word)): s = word[:i] + &quot;_&quot; + word[i+1:] neigh_words = dict_words.get(s, []) for neigh in neigh_words: if neigh not in visited: queue.append((neigh, steps + 1)) return 0 d = construct_dict(wordList | set([beginWord, endWord])) return bfs_words(beginWord, endWord, d) https://discuss.leetcode.com/topic/42623/compact-python-solution Compact Python solution 123456789101112131415class Solution(object): def ladderLength(self, beginWord, endWord, wordList): wordList.add(endWord) queue = collections.deque([[beginWord, 1]]) while queue: word, length = queue.popleft() if word == endWord: return length for i in range(len(word)): for c in &apos;abcdefghijklmnopqrstuvwxyz&apos;: next_word = word[:i] + c + word[i+1:] if next_word in wordList: wordList.remove(next_word) queue.append([next_word, length + 1]) return 0 172ms, 78.99%, June.24th, 2016 https://leetcode.com/discuss/48083/share-python-solutions-concise-160ms-optimized-solution-100ms 12345678910111213141516171819202122232425class Solution(object): def ladderLength(self, beginWord, endWord, wordList): &quot;&quot;&quot; :type beginWord: str :type endWord: str :type wordList: Set[str] :rtype: int &quot;&quot;&quot; length = 2 front, back = set([beginWord]), set([endWord]) wordList.discard(beginWord) while front: # generate all valid transformations front = wordList &amp; (set(word[:index] + ch + word[index+1:] for word in front for index in range(len(beginWord)) for ch in &apos;abcdefghijklmnopqrstuvwxyz&apos;)) if front &amp; back: # there are common elements in front and back, done return length length += 1 if len(front) &gt; len(back): # swap front and back for better performance (fewer choices in generating nextSet) front, back = back, front # remove transformations from wordList to avoid cycle wordList -= front return 0 https://discuss.leetcode.com/topic/20965/java-solution-using-dijkstra-s-algorithm-with-explanation Java Solution using Dijkstraâ€™s algorithm, with explanation 1234567891011121314151617181920212223242526public int ladderLength(String beginWord, String endWord, Set&lt;String&gt; wordDict) &#123; Set&lt;String&gt; reached = new HashSet&lt;String&gt;(); reached.add(beginWord); wordDict.add(endWord); int distance = 1; while (!reached.contains(endWord)) &#123; Set&lt;String&gt; toAdd = new HashSet&lt;String&gt;(); for (String each : reached) &#123; for (int i = 0; i &lt; each.length(); i++) &#123; char[] chars = each.toCharArray(); for (char ch = &apos;a&apos;; ch &lt;= &apos;z&apos;; ch++) &#123; chars[i] = ch; String word = new String(chars); if (wordDict.contains(word)) &#123; toAdd.add(word); wordDict.remove(word); &#125; &#125; &#125; &#125; distance++; if (toAdd.size() == 0) return 0; reached = toAdd; &#125; return distance;&#125; Basically I keep two sets of words, one set reached that represents the borders that have been reached with â€œdistanceâ€ steps; another set wordDict that has not been reached. In the while loop, for each word in the reached set, I give all variations and check if it matches anything from wordDict, if it has a match, I add that word into toAdd set, which will be my â€œreachedâ€ set in the next loop, and remove the word from wordDict because I already reached it in this step. And at the end of while loop, I check the size of toAdd, which means that if I canâ€™t reach any new String from wordDict, I wonâ€™t be able to reach the endWord, then just return 0. Finally if the endWord is in reached set, I return the current steps â€œdistanceâ€. The idea is that reached always contain only the ones we just reached in the last step, and wordDict always contain the ones that havenâ€™t been reached. This is pretty much what Dijkstraâ€™s algorithm does, or you can see this as some variation of BFS. ps: I get TLE at the first two submissions, because when I check if wordDict has any matches with reached set, I use two for loops and determine if any pair of words differ by one. Thatâ€™s a huge slow-down because itâ€™ll takes m (size of reached) n (size of wordDict) l (length of words) time, while in this solution, it takes 26 l m time. So when n is huge, this solution will be (n/26) times faster. https://discuss.leetcode.com/topic/20965/java-solution-using-dijkstra-s-algorithm-with-explanation/2 I think we can use a queue to replace the reached set, by which we can avoid duplicate check? 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int ladderLength(String beginWord, String endWord, Set&lt;String&gt; wordList) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.offer(beginWord); wordList.add(endWord); wordList.remove(beginWord); int level = 1; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0;i&lt;size;i++)&#123; String str = queue.poll(); if(str.equals(endWord))return level; for(String neighbor : neighbors(str,wordList))&#123; queue.offer(neighbor); &#125; &#125; level++; &#125; return 0; &#125; public List&lt;String&gt; neighbors(String s, Set&lt;String&gt; wordList)&#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); for(int i=0;i&lt;s.length();i++)&#123; char [] chars = s.toCharArray(); for(char ch = &apos;a&apos;; ch &lt;= &apos;z&apos;; ch++)&#123; chars[i] = ch; String word = new String(chars); if(wordList.remove(word))&#123; res.add(word); &#125; &#125; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/29303/two-end-bfs-in-java-31ms Two-end BFS in Java 31ms. Modified from Share my two-end BFS in C++ 80ms. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123;public int ladderLength(String beginWord, String endWord, Set&lt;String&gt; wordList) &#123; Set&lt;String&gt; beginSet = new HashSet&lt;String&gt;(), endSet = new HashSet&lt;String&gt;(); int len = 1; int strLen = beginWord.length(); HashSet&lt;String&gt; visited = new HashSet&lt;String&gt;(); beginSet.add(beginWord); endSet.add(endWord); while (!beginSet.isEmpty() &amp;&amp; !endSet.isEmpty()) &#123; if (beginSet.size() &gt; endSet.size()) &#123; Set&lt;String&gt; set = beginSet; beginSet = endSet; endSet = set; &#125; Set&lt;String&gt; temp = new HashSet&lt;String&gt;(); for (String word : beginSet) &#123; char[] chs = word.toCharArray(); for (int i = 0; i &lt; chs.length; i++) &#123; for (char c = &apos;a&apos;; c &lt;= &apos;z&apos;; c++) &#123; char old = chs[i]; chs[i] = c; String target = String.valueOf(chs); if (endSet.contains(target)) &#123; return len + 1; &#125; if (!visited.contains(target) &amp;&amp; wordList.contains(target)) &#123; temp.add(target); visited.add(target); &#125; chs[i] = old; &#125; &#125; &#125; beginSet = temp; len++; &#125; return 0;&#125;&#125; https://discuss.leetcode.com/topic/17890/another-accepted-java-solution-bfs Another accepted Java solution (BFS) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public int ladderLength(String start, String end, Set&lt;String&gt; dict) &#123; // Use queue to help BFS Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.add(start); queue.add(null); // Mark visited word Set&lt;String&gt; visited = new HashSet&lt;String&gt;(); visited.add(start); int level = 1; while (!queue.isEmpty()) &#123; String str = queue.poll(); if (str != null) &#123; // Modify str&apos;s each character (so word distance is 1) for (int i = 0; i &lt; str.length(); i++) &#123; char[] chars = str.toCharArray(); for (char c = &apos;a&apos;; c &lt;= &apos;z&apos;; c++) &#123; chars[i] = c; String word = new String(chars); // Found the end word if (word.equals(end)) return level + 1; // Put it to the queue if (dict.contains(word) &amp;&amp; !visited.contains(word)) &#123; queue.add(word); visited.add(word); &#125; &#125; &#125; &#125; else &#123; level++; if (!queue.isEmpty()) &#123; queue.add(null); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[126. Word Ladder II]]></title>
    <url>%2Fp%2F2dae1d4c%2F</url>
    <content type="text"><![CDATA[13.7% https://leetcode.com/problems/word-ladder-ii/#/description Given two words (beginWord and endWord), and a dictionaryâ€™s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that: Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word. 1234567891011For example,Given:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Return [ [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;], [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;] ] Note: Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. UPDATE (2017/1/20): The wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. https://discuss.leetcode.com/topic/16826/88ms-accepted-c-solution-with-two-end-bfs-68ms-for-word-ladder-and-88ms-for-word-ladder-ii 88ms! Accepted c++ solution with two-end BFS. 68ms for Word Ladder and 88ms for Word Ladder II In order to reduce the running time, we should use two-end BFS to slove the problem. Accepted 68ms c++ solution for Word Ladder. 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int ladderLength(std::string beginWord, std::string endWord, std::unordered_set&lt;std::string&gt; &amp;dict) &#123; if (beginWord == endWord) return 1; std::unordered_set&lt;std::string&gt; words1, words2; words1.insert(beginWord); words2.insert(endWord); dict.erase(beginWord); dict.erase(endWord); return ladderLengthHelper(words1, words2, dict, 1); &#125;private: int ladderLengthHelper(std::unordered_set&lt;std::string&gt; &amp;words1, std::unordered_set&lt;std::string&gt; &amp;words2, std::unordered_set&lt;std::string&gt; &amp;dict, int level) &#123; if (words1.empty()) return 0; if (words1.size() &gt; words2.size()) return ladderLengthHelper(words2, words1, dict, level); std::unordered_set&lt;std::string&gt; words3; for (auto it = words1.begin(); it != words1.end(); ++it) &#123; std::string word = *it; for (auto ch = word.begin(); ch != word.end(); ++ch) &#123; char tmp = *ch; for (*ch = &apos;a&apos;; *ch &lt;= &apos;z&apos;; ++(*ch)) if (*ch != tmp) if (words2.find(word) != words2.end()) return level + 1; else if (dict.find(word) != dict.end()) &#123; dict.erase(word); words3.insert(word); &#125; *ch = tmp; &#125; &#125; return ladderLengthHelper(words2, words3, dict, level + 1); &#125;&#125;; Accepted 88ms c++ solution for Word Ladder II. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution &#123;public: std::vector&lt;std::vector&lt;std::string&gt; &gt; findLadders(std::string beginWord, std::string endWord, std::unordered_set&lt;std::string&gt; &amp;dict) &#123; std::vector&lt;std::vector&lt;std::string&gt; &gt; paths; std::vector&lt;std::string&gt; path(1, beginWord); if (beginWord == endWord) &#123; paths.push_back(path); return paths; &#125; std::unordered_set&lt;std::string&gt; words1, words2; words1.insert(beginWord); words2.insert(endWord); std::unordered_map&lt;std::string, std::vector&lt;std::string&gt; &gt; nexts; bool words1IsBegin = false; if (findLaddersHelper(words1, words2, dict, nexts, words1IsBegin)) getPath(beginWord, endWord, nexts, path, paths); return paths; &#125;private: bool findLaddersHelper( std::unordered_set&lt;std::string&gt; &amp;words1, std::unordered_set&lt;std::string&gt; &amp;words2, std::unordered_set&lt;std::string&gt; &amp;dict, std::unordered_map&lt;std::string, std::vector&lt;std::string&gt; &gt; &amp;nexts, bool &amp;words1IsBegin) &#123; words1IsBegin = !words1IsBegin; if (words1.empty()) return false; if (words1.size() &gt; words2.size()) return findLaddersHelper(words2, words1, dict, nexts, words1IsBegin); for (auto it = words1.begin(); it != words1.end(); ++it) dict.erase(*it); for (auto it = words2.begin(); it != words2.end(); ++it) dict.erase(*it); std::unordered_set&lt;std::string&gt; words3; bool reach = false; for (auto it = words1.begin(); it != words1.end(); ++it) &#123; std::string word = *it; for (auto ch = word.begin(); ch != word.end(); ++ch) &#123; char tmp = *ch; for (*ch = &apos;a&apos;; *ch &lt;= &apos;z&apos;; ++(*ch)) if (*ch != tmp) if (words2.find(word) != words2.end()) &#123; reach = true; words1IsBegin ? nexts[*it].push_back(word) : nexts[word].push_back(*it); &#125; else if (!reach &amp;&amp; dict.find(word) != dict.end()) &#123; words3.insert(word); words1IsBegin ? nexts[*it].push_back(word) : nexts[word].push_back(*it); &#125; *ch = tmp; &#125; &#125; return reach || findLaddersHelper(words2, words3, dict, nexts, words1IsBegin); &#125; void getPath( std::string beginWord, std::string &amp;endWord, std::unordered_map&lt;std::string, std::vector&lt;std::string&gt; &gt; &amp;nexts, std::vector&lt;std::string&gt; &amp;path, std::vector&lt;std::vector&lt;std::string&gt; &gt; &amp;paths) &#123; if (beginWord == endWord) paths.push_back(path); else for (auto it = nexts[beginWord].begin(); it != nexts[beginWord].end(); ++it) &#123; path.push_back(*it); getPath(*it, endWord, nexts, path, paths); path.pop_back(); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/40902/clean-but-the-best-submission-68ms-in-c-well-commented Clean but the best-submission (68ms) in C++, well-commented 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution &#123; public: vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, unordered_set&lt;string&gt; &amp;dict) &#123; vector&lt;vector&lt;string&gt; &gt; paths; vector&lt;string&gt; path(1, beginWord); if (beginWord == endWord) //corner case; &#123; paths.push_back(path); return paths; &#125; unordered_set&lt;string&gt; forward, backward; forward.insert(beginWord); backward.insert(endWord); unordered_map&lt;string, vector&lt;string&gt; &gt; tree; bool reversed = false; //make sure the tree generating direction is consistent, since we have to start from the smaller set to accelerate; if (buildTree(forward, backward, dict, tree, reversed)) getPath(beginWord, endWord, tree, path, paths); return paths; &#125; private: bool buildTree(unordered_set&lt;string&gt; &amp;forward, unordered_set&lt;string&gt; &amp;backward, unordered_set&lt;string&gt; &amp;dict, unordered_map&lt;string, vector&lt;string&gt; &gt; &amp;tree, bool reversed) &#123; if (forward.empty()) return false; if (forward.size() &gt; backward.size()) return buildTree(backward, forward, dict, tree, !reversed); for (auto &amp;word: forward) dict.erase(word); for (auto &amp;word: backward) dict.erase(word); unordered_set&lt;string&gt; nextLevel; bool done = false; //in case of invalid further searching; for (auto &amp;it: forward) //traverse each word in the forward -&gt; the current level of the tree; &#123; string word = it; for (auto &amp;c: word) &#123; char c0 = c; //store the original; for (c = &apos;a&apos;; c &lt;= &apos;z&apos;; ++c) //try each case; &#123; if (c != c0) //avoid futile checking; &#123; if (backward.count(word)) //using count is an accelerating method; &#123; done = true; !reversed ? tree[it].push_back(word) : tree[word].push_back(it); //keep the tree generation direction consistent; &#125; else if (!done &amp;&amp; dict.count(word)) &#123; nextLevel.insert(word); !reversed ? tree[it].push_back(word) : tree[word].push_back(it); &#125; &#125; &#125; c = c0; //restore the word; &#125; &#125; return done || buildTree(nextLevel, backward, dict, tree, reversed); &#125; void getPath(string &amp;beginWord, string &amp;endWord, unordered_map&lt;string, vector&lt;string&gt; &gt; &amp;tree, vector&lt;string&gt; &amp;path, vector&lt;vector&lt;string&gt; &gt; &amp;paths) //using reference can accelerate; &#123; if (beginWord == endWord) paths.push_back(path); //till the end; else &#123; for (auto &amp;it: tree[beginWord]) &#123; path.push_back(it); getPath(it, endWord, tree, path, paths); //DFS retrieving the path; path.pop_back(); &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/43603/fast-and-clean-python-c-solution-using-double-bfs-beats-98 FAST AND CLEAN Python/C++ Solution using Double BFS, beats 98% If we know source and destination, we can build the word tree by going forward in one direction and backwards in the other. We stop when we have found that a word in the next level of BFS is in the other level, but first we need to update the tree for the words in the current level. Then we build the result by doing a DFS on the tree constructed by the BFS. The difference between normal and double BFS is that the search changes from O(k^d) to O(k^(d/2) + k^(d/2)). Same complexity class, right? Yeah, tell it to the Facebook guys that have to search in graphs with hundreds of thousands of nodes. 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): # Solution using double BFS def findLadders(self, begin, end, words_list): def construct_paths(source, dest, tree): if source == dest: return [[source]] return [[source] + path for succ in tree[source] for path in construct_paths(succ, dest, tree)] def add_path(tree, word, neigh, is_forw): if is_forw: tree[word] += neigh, else: tree[neigh] += word, def bfs_level(this_lev, oth_lev, tree, is_forw, words_set): if not this_lev: return False if len(this_lev) &gt; len(oth_lev): return bfs_level(oth_lev, this_lev, tree, not is_forw, words_set) for word in (this_lev | oth_lev): words_set.discard(word) next_lev, done = set(), False while this_lev: word = this_lev.pop() for c in string.ascii_lowercase: for index in range(len(word)): neigh = word[:index] + c + word[index+1:] if neigh in oth_lev: done = True add_path(tree, word, neigh, is_forw) if not done and neigh in words_set: next_lev.add(neigh) add_path(tree, word, neigh, is_forw) return done or bfs_level(next_lev, oth_lev, tree, is_forw, words_set) tree, path, paths = collections.defaultdict(list), [begin], [] is_found = bfs_level(set([begin]), set([end]), tree, True, words_list) return construct_paths(begin, end, tree) C++ code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283void add_to_tree(map&lt;string, vector&lt;string&gt;&gt;&amp; tree, string word, string neigh, bool forward) &#123; if (forward) tree[word].push_back(neigh); else tree[neigh].push_back(word);&#125;vector&lt;vector&lt;string&gt;&gt; construct_paths(map&lt;string, vector&lt;string&gt;&gt;&amp; tree, string start, string dest) &#123; if (start == dest) &#123; vector&lt;string&gt; res = &#123;start&#125;; vector&lt;vector&lt;string&gt;&gt; arr = &#123;res&#125;; return arr; &#125; vector&lt;vector&lt;string&gt;&gt; result; for (auto succ: tree[start]) &#123; for (auto path: construct_paths(tree, succ, dest)) &#123; path.insert(path.begin(), start); result.push_back(path); &#125; &#125; return result;&#125;bool bfs_levels(unordered_set&lt;string&gt;&amp; now, unordered_set&lt;string&gt;&amp; oth, bool&amp; forward, map&lt;string, vector&lt;string&gt;&gt;&amp; tree, unordered_set&lt;string&gt;&amp; words_list, vector&lt;char&gt;&amp; alphabet) &#123; if (not now.size()) return false; if (now.size() &gt; oth.size())&#123; forward = not forward; return bfs_levels(oth, now, forward, tree, words_list, alphabet); &#125; for (auto word: now) words_list.erase(word); for (auto word: oth) words_list.erase(word); bool done = false; unordered_set&lt;string&gt; next; for (string word: now) &#123; for (int i = 0; i &lt; word.size(); i++) &#123; for (char c: alphabet) &#123; auto neigh = word.substr(0, i) + c + word.substr(i+1); if (oth.count(neigh) &gt; 0) &#123; done = true; add_to_tree(tree, word, neigh, forward); &#125; else &#123; if (not done and words_list.count(neigh) &gt; 0) &#123; next.insert(neigh); add_to_tree(tree, word, neigh, forward); &#125; &#125; &#125; &#125; &#125; forward = not forward; return done or bfs_levels(oth, next, forward, tree, words_list, alphabet);&#125;class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, unordered_set&lt;string&gt; &amp;wordList) &#123; vector&lt;char&gt; alphabet(26); std::iota(alphabet.begin(), alphabet.end(), &apos;a&apos;); unordered_set&lt;string&gt; now = &#123;beginWord&#125;, oth = &#123;endWord&#125;; map&lt;string, vector&lt;string&gt;&gt; tree; bool forward = true; auto is_found = bfs_levels(now, oth, forward, tree, wordList, alphabet); return construct_paths(tree, beginWord, endWord); &#125;&#125;; https://discuss.leetcode.com/topic/8343/use-defaultdict-for-traceback-and-easy-writing-20-lines-python-code Use defaultdict for traceback and easy writing, 20 lines python code 1234567891011121314151617181920212223class Solution:# @param start, a string# @param end, a string# @param dict, a set of string# @return a list of lists of stringdef findLadders(self, start, end, dic): dic.add(end) level = &#123;start&#125; parents = collections.defaultdict(set) while level and end not in parents: next_level = collections.defaultdict(set) for node in level: for char in string.ascii_lowercase: for i in range(len(start)): n = node[:i]+char+node[i+1:] if n in dic and n not in parents: next_level[n].add(node) level = next_level parents.update(next_level) res = [[end]] while res and res[0][0] != start: res = [[p]+r for r in res for p in parents[r[0]]] return res Every level we use the defaultdict to get rid of the duplicates https://discuss.leetcode.com/topic/2857/share-two-similar-java-solution-that-accpted-by-oj Share two similar Java solution that Accpted by OJ. The solution contains two steps 1 Use BFS to construct a graph. 2. Use DFS to construct the paths from end to start.Both solutions got AC within 1s. The first step BFS is quite important. I summarized three tricks Using a MAP to store the min ladder of each word, or use a SET to store the words visited in current ladder, when the current ladder was completed, delete the visited words from unvisited. Thatâ€™s why I have two similar solutions. Use Character iteration to find all possible paths. Do not compare one word to all the other words and check if they only differ by one character. One word is allowed to be inserted into the queue only ONCE. See my comments. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class Solution &#123; Map&lt;String,List&lt;String&gt;&gt; map; List&lt;List&lt;String&gt;&gt; results; public List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, Set&lt;String&gt; dict) &#123; results= new ArrayList&lt;List&lt;String&gt;&gt;(); if (dict.size() == 0) return results; int min=Integer.MAX_VALUE; Queue&lt;String&gt; queue= new ArrayDeque&lt;String&gt;(); queue.add(start); map = new HashMap&lt;String,List&lt;String&gt;&gt;(); Map&lt;String,Integer&gt; ladder = new HashMap&lt;String,Integer&gt;(); for (String string:dict) ladder.put(string, Integer.MAX_VALUE); ladder.put(start, 0); dict.add(end); //BFS: Dijisktra search while (!queue.isEmpty()) &#123; String word = queue.poll(); int step = ladder.get(word)+1;//&apos;step&apos; indicates how many steps are needed to travel to one word. if (step&gt;min) break; for (int i = 0; i &lt; word.length(); i++)&#123; StringBuilder builder = new StringBuilder(word); for (char ch=&apos;a&apos;; ch &lt;= &apos;z&apos;; ch++)&#123; builder.setCharAt(i,ch); String new_word=builder.toString(); if (ladder.containsKey(new_word)) &#123; if (step&gt;ladder.get(new_word))//Check if it is the shortest path to one word. continue; else if (step&lt;ladder.get(new_word))&#123; queue.add(new_word); ladder.put(new_word, step); &#125;else;// It is a KEY line. If one word already appeared in one ladder, // Do not insert the same word inside the queue twice. Otherwise it gets TLE. if (map.containsKey(new_word)) //Build adjacent Graph map.get(new_word).add(word); else&#123; List&lt;String&gt; list= new LinkedList&lt;String&gt;(); list.add(word); map.put(new_word,list); //It is possible to write three lines in one: //map.put(new_word,new LinkedList&lt;String&gt;(Arrays.asList(new String[]&#123;word&#125;))); //Which one is better? &#125; if (new_word.equals(end)) min=step; &#125;//End if dict contains new_word &#125;//End:Iteration from &apos;a&apos; to &apos;z&apos; &#125;//End:Iteration from the first to the last &#125;//End While //BackTracking LinkedList&lt;String&gt; result = new LinkedList&lt;String&gt;(); backTrace(end,start,result); return results; &#125; private void backTrace(String word,String start,List&lt;String&gt; list)&#123; if (word.equals(start))&#123; list.add(0,start); results.add(new ArrayList&lt;String&gt;(list)); list.remove(0); return; &#125; list.add(0,word); if (map.get(word)!=null) for (String s:map.get(word)) backTrace(s,start,list); list.remove(0); &#125;&#125; Another solution using two sets. This is similar to the answer in the most viewed thread. While I found my solution more readable and efficient. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Solution &#123; List&lt;List&lt;String&gt;&gt; results; List&lt;String&gt; list; Map&lt;String,List&lt;String&gt;&gt; map; public List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, Set&lt;String&gt; dict) &#123; results= new ArrayList&lt;List&lt;String&gt;&gt;(); if (dict.size() == 0) return results; int curr=1,next=0; boolean found=false; list = new LinkedList&lt;String&gt;(); map = new HashMap&lt;String,List&lt;String&gt;&gt;(); Queue&lt;String&gt; queue= new ArrayDeque&lt;String&gt;(); Set&lt;String&gt; unvisited = new HashSet&lt;String&gt;(dict); Set&lt;String&gt; visited = new HashSet&lt;String&gt;(); queue.add(start); unvisited.add(end); unvisited.remove(start); //BFS while (!queue.isEmpty()) &#123; String word = queue.poll(); curr--; for (int i = 0; i &lt; word.length(); i++)&#123; StringBuilder builder = new StringBuilder(word); for (char ch=&apos;a&apos;; ch &lt;= &apos;z&apos;; ch++)&#123; builder.setCharAt(i,ch); String new_word=builder.toString(); if (unvisited.contains(new_word))&#123; //Handle queue if (visited.add(new_word))&#123;//Key statement,Avoid Duplicate queue insertion next++; queue.add(new_word); &#125; if (map.containsKey(new_word))//Build Adjacent Graph map.get(new_word).add(word); else&#123; List&lt;String&gt; l= new LinkedList&lt;String&gt;(); l.add(word); map.put(new_word, l); &#125; if (new_word.equals(end)&amp;&amp;!found) found=true; &#125; &#125;//End:Iteration from &apos;a&apos; to &apos;z&apos; &#125;//End:Iteration from the first to the last if (curr==0)&#123; if (found) break; curr=next; next=0; unvisited.removeAll(visited); visited.clear(); &#125; &#125;//End While backTrace(end,start); return results; &#125; private void backTrace(String word,String start)&#123; if (word.equals(start))&#123; list.add(0,start); results.add(new ArrayList&lt;String&gt;(list)); list.remove(0); return; &#125; list.add(0,word); if (map.get(word)!=null) for (String s:map.get(word)) backTrace(s,start); list.remove(0); &#125; &#125; https://discuss.leetcode.com/topic/2857/share-two-similar-java-solution-that-accpted-by-oj Share two similar Java solution that Accpted by OJ. The solution contains two steps 1 Use BFS to construct a graph. 2. Use DFS to construct the paths from end to start.Both solutions got AC within 1s. The first step BFS is quite important. I summarized three tricks Using a MAP to store the min ladder of each word, or use a SET to store the words visited in current ladder, when the current ladder was completed, delete the visited words from unvisited. Thatâ€™s why I have two similar solutions.Use Character iteration to find all possible paths. Do not compare one word to all the other words and check if they only differ by one character.One word is allowed to be inserted into the queue only ONCE. See my comments.public class Solution { Map&lt;String,List&gt; map; List&lt;List&gt; results; public List&lt;List&gt; findLadders(String start, String end, Set dict) { results= new ArrayList&lt;List&gt;(); if (dict.size() == 0) return results; int min=Integer.MAX_VALUE; Queue&lt;String&gt; queue= new ArrayDeque&lt;String&gt;(); queue.add(start); map = new HashMap&lt;String,List&lt;String&gt;&gt;(); Map&lt;String,Integer&gt; ladder = new HashMap&lt;String,Integer&gt;(); for (String string:dict) ladder.put(string, Integer.MAX_VALUE); ladder.put(start, 0); dict.add(end); //BFS: Dijisktra search while (!queue.isEmpty()) { String word = queue.poll(); int step = ladder.get(word)+1;//&apos;step&apos; indicates how many steps are needed to travel to one word. if (step&gt;min) break; for (int i = 0; i &lt; word.length(); i++){ StringBuilder builder = new StringBuilder(word); for (char ch=&apos;a&apos;; ch &lt;= &apos;z&apos;; ch++){ builder.setCharAt(i,ch); String new_word=builder.toString(); if (ladder.containsKey(new_word)) { if (step&gt;ladder.get(new_word))//Check if it is the shortest path to one word. continue; else if (step&lt;ladder.get(new_word)){ queue.add(new_word); ladder.put(new_word, step); }else;// It is a KEY line. If one word already appeared in one ladder, // Do not insert the same word inside the queue twice. Otherwise it gets TLE. if (map.containsKey(new_word)) //Build adjacent Graph map.get(new_word).add(word); else{ List&lt;String&gt; list= new LinkedList&lt;String&gt;(); list.add(word); map.put(new_word,list); //It is possible to write three lines in one: //map.put(new_word,new LinkedList&lt;String&gt;(Arrays.asList(new String[]{word}))); //Which one is better? } if (new_word.equals(end)) min=step; }//End if dict contains new_word }//End:Iteration from &apos;a&apos; to &apos;z&apos; }//End:Iteration from the first to the last }//End While //BackTracking LinkedList&lt;String&gt; result = new LinkedList&lt;String&gt;(); backTrace(end,start,result); return results; } private void backTrace(String word,String start,List&lt;String&gt; list){ if (word.equals(start)){ list.add(0,start); results.add(new ArrayList&lt;String&gt;(list)); list.remove(0); return; } list.add(0,word); if (map.get(word)!=null) for (String s:map.get(word)) backTrace(s,start,list); list.remove(0); } }Another solution using two sets. This is similar to the answer in the most viewed thread. While I found my solution more readable and efficient. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Solution &#123; List&lt;List&lt;String&gt;&gt; results; List&lt;String&gt; list; Map&lt;String,List&lt;String&gt;&gt; map; public List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, Set&lt;String&gt; dict) &#123; results= new ArrayList&lt;List&lt;String&gt;&gt;(); if (dict.size() == 0) return results; int curr=1,next=0; boolean found=false; list = new LinkedList&lt;String&gt;(); map = new HashMap&lt;String,List&lt;String&gt;&gt;(); Queue&lt;String&gt; queue= new ArrayDeque&lt;String&gt;(); Set&lt;String&gt; unvisited = new HashSet&lt;String&gt;(dict); Set&lt;String&gt; visited = new HashSet&lt;String&gt;(); queue.add(start); unvisited.add(end); unvisited.remove(start); //BFS while (!queue.isEmpty()) &#123; String word = queue.poll(); curr--; for (int i = 0; i &lt; word.length(); i++)&#123; StringBuilder builder = new StringBuilder(word); for (char ch=&apos;a&apos;; ch &lt;= &apos;z&apos;; ch++)&#123; builder.setCharAt(i,ch); String new_word=builder.toString(); if (unvisited.contains(new_word))&#123; //Handle queue if (visited.add(new_word))&#123;//Key statement,Avoid Duplicate queue insertion next++; queue.add(new_word); &#125; if (map.containsKey(new_word))//Build Adjacent Graph map.get(new_word).add(word); else&#123; List&lt;String&gt; l= new LinkedList&lt;String&gt;(); l.add(word); map.put(new_word, l); &#125; if (new_word.equals(end)&amp;&amp;!found) found=true; &#125; &#125;//End:Iteration from &apos;a&apos; to &apos;z&apos; &#125;//End:Iteration from the first to the last if (curr==0)&#123; if (found) break; curr=next; next=0; unvisited.removeAll(visited); visited.clear(); &#125; &#125;//End While backTrace(end,start); return results; &#125; private void backTrace(String word,String start)&#123; if (word.equals(start))&#123; list.add(0,start); results.add(new ArrayList&lt;String&gt;(list)); list.remove(0); return; &#125; list.add(0,word); if (map.get(word)!=null) for (String s:map.get(word)) backTrace(s,start); list.remove(0); &#125; &#125; https://discuss.leetcode.com/topic/27504/my-concise-java-solution-based-on-bfs-and-dfs My concise JAVA solution based on BFS and DFS Explanation The basic idea is: 1). Use BFS to find the shortest distance between start and end, tracing the distance of crossing nodes from start node to end node, and store nodeâ€™s next level neighbors to HashMap; 2). Use DFS to output paths with the same distance as the shortest distance from distance HashMap: compare if the distance of the next level node equals the distance of the current node + 1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, List&lt;String&gt; wordList) &#123; HashSet&lt;String&gt; dict = new HashSet&lt;String&gt;(wordList); List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();// Neighbors for every node HashMap&lt;String, Integer&gt; distance = new HashMap&lt;String, Integer&gt;();// Distance of every node from the start node ArrayList&lt;String&gt; solution = new ArrayList&lt;String&gt;(); dict.add(start); bfs(start, end, dict, nodeNeighbors, distance); dfs(start, end, dict, nodeNeighbors, distance, solution, res); return res;&#125;// BFS: Trace every node&apos;s distance from the start node (level by level).private void bfs(String start, String end, Set&lt;String&gt; dict, HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors, HashMap&lt;String, Integer&gt; distance) &#123; for (String str : dict) nodeNeighbors.put(str, new ArrayList&lt;String&gt;()); Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.offer(start); distance.put(start, 0); while (!queue.isEmpty()) &#123; int count = queue.size(); boolean foundEnd = false; for (int i = 0; i &lt; count; i++) &#123; String cur = queue.poll(); int curDistance = distance.get(cur); ArrayList&lt;String&gt; neighbors = getNeighbors(cur, dict); for (String neighbor : neighbors) &#123; nodeNeighbors.get(cur).add(neighbor); if (!distance.containsKey(neighbor)) &#123;// Check if visited distance.put(neighbor, curDistance + 1); if (end.equals(neighbor))// Found the shortest path foundEnd = true; else queue.offer(neighbor); &#125; &#125; &#125; if (foundEnd) break; &#125; &#125;// Find all next level nodes. private ArrayList&lt;String&gt; getNeighbors(String node, Set&lt;String&gt; dict) &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); char chs[] = node.toCharArray(); for (char ch =&apos;a&apos;; ch &lt;= &apos;z&apos;; ch++) &#123; for (int i = 0; i &lt; chs.length; i++) &#123; if (chs[i] == ch) continue; char old_ch = chs[i]; chs[i] = ch; if (dict.contains(String.valueOf(chs))) &#123; res.add(String.valueOf(chs)); &#125; chs[i] = old_ch; &#125; &#125; return res;&#125;// DFS: output all paths with the shortest distance.private void dfs(String cur, String end, Set&lt;String&gt; dict, HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors, HashMap&lt;String, Integer&gt; distance, ArrayList&lt;String&gt; solution, List&lt;List&lt;String&gt;&gt; res) &#123; solution.add(cur); if (end.equals(cur)) &#123; res.add(new ArrayList&lt;String&gt;(solution)); &#125; else &#123; for (String next : nodeNeighbors.get(cur)) &#123; if (distance.get(next) == distance.get(cur) + 1) &#123; dfs(next, end, dict, nodeNeighbors, distance, solution, res); &#125; &#125; &#125; solution.remove(solution.size() - 1);&#125; Solution 1: 672ms, 40.34%, June.24th, 2016 https://leetcode.com/discuss/24191/defaultdict-for-traceback-and-easy-writing-lines-python-code 12345678910111213141516171819202122232425class Solution(object): def findLadders(self, beginWord, endWord, wordlist): &quot;&quot;&quot; :type beginWord: str :type endWord: str :type wordlist: Set[str] :rtype: List[List[int]] &quot;&quot;&quot; wordlist.add(endWord) level = &#123;beginWord&#125; parents = collections.defaultdict(set) while level and endWord not in parents: next_level = collections.defaultdict(set) for node in level: for char in string.ascii_lowercase: for i in range(len(beginWord)): n = node[:i]+char+node[i+1:] if n in wordlist and n not in parents: next_level[n].add(node) level = next_level parents.update(next_level) res = [[endWord]] while res and res[0][0] != beginWord: res = [[p]+r for r in res for p in parents[r[0]]] return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>string</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[125. Valid Palindrome]]></title>
    <url>%2Fp%2Feb15f900%2F</url>
    <content type="text"><![CDATA[25.7% https://leetcode.com/problems/valid-palindrome/#/description Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. 123For example,&quot;A man, a plan, a canal: Panama&quot; is a palindrome.&quot;race a car&quot; is not a palindrome. Note: Have you consider that the string might be empty? This is a good question to ask during an interview. For the purpose of this problem, we define empty string as valid palindrome. isalnum æ˜¯å¦æ•°å­—å­—ç¬¦ isalpha æ˜¯å¦å­—æ¯å­—ç¬¦ tolower/toupper æ–¹æ³•ä¸€ï¼š Hereâ€™s a clean C++ solution 123456789bool isPalindrome(string s) &#123; for (int i = 0, j = s.size() - 1; i &lt; j; i++, j--) &#123; // Move 2 pointers from each end until they collide while (isalnum(s[i]) == false &amp;&amp; i &lt; j) i++; // Increment left pointer if not alphanumeric while (isalnum(s[j]) == false &amp;&amp; i &lt; j) j--; // Decrement right pointer if no alphanumeric if (toupper(s[i]) != toupper(s[j])) return false; // Exit and return error if not match &#125; return true;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415class Solution &#123;public: bool isPalindrome(string s) &#123; int n = s.size(); if(n==0) return true; int i = 0, j = n-1; while(i&lt;j)&#123; while(i&lt;j &amp;&amp; !isalnum(s[i])) i++; while(i&lt;j &amp;&amp; !isalnum(s[j])) j--; if(toupper(s[i])!=toupper(s[j])) return false; i++; j--; &#125; return true; &#125;&#125;; https://discuss.leetcode.com/topic/5581/here-s-a-clean-c-solution Hereâ€™s a clean C++ solution 123456789bool isPalindrome(string s) &#123; for (int i = 0, j = s.size() - 1; i &lt; j; i++, j--) &#123; // Move 2 pointers from each end until they collide while (isalnum(s[i]) == false &amp;&amp; i &lt; j) i++; // Increment left pointer if not alphanumeric while (isalnum(s[j]) == false &amp;&amp; i &lt; j) j--; // Decrement right pointer if no alphanumeric if (toupper(s[i]) != toupper(s[j])) return false; // Exit and return error if not match &#125; return true;&#125; https://discuss.leetcode.com/topic/10862/passed-clean-c-code Passed clean c++ code 1234567891011bool isPalindrome(string s) &#123; int start=0, end=s.length()-1; while(start&lt;end) &#123; if (!isalnum(s[start])) start++; else if (!isalnum(s[end])) end--; else &#123; if (tolower(s[start++])!=tolower(s[end--])) return false; &#125; &#125; return true;&#125; https://discuss.leetcode.com/topic/22479/python-in-place-two-pointer-solution Python in-place two-pointer solution. 1234567891011def isPalindrome(self, s): l, r = 0, len(s)-1 while l &lt; r: while l &lt; r and not s[l].isalnum(): l += 1 while l &lt;r and not s[r].isalnum(): r -= 1 if s[l].lower() != s[r].lower(): return False l +=1; r -= 1 return True 80ms, 78.34%, April.23rd, 2016 https://leetcode.com/discuss/11241/challenge-shortest-possible-answer-python-palindrome-python 12345678class Solution(object): def isPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; newS = [i.lower() for i in s if i.isalnum()] return newS == newS[::-1] https://discuss.leetcode.com/topic/8282/accepted-pretty-java-solution-271ms Accepted pretty Java solution(271ms) 1234567891011121314151617181920212223242526public class Solution &#123; public boolean isPalindrome(String s) &#123; if (s.isEmpty()) &#123; return true; &#125; int head = 0, tail = s.length() - 1; char cHead, cTail; while(head &lt;= tail) &#123; cHead = s.charAt(head); cTail = s.charAt(tail); if (!Character.isLetterOrDigit(cHead)) &#123; head++; &#125; else if(!Character.isLetterOrDigit(cTail)) &#123; tail--; &#125; else &#123; if (Character.toLowerCase(cHead) != Character.toLowerCase(cTail)) &#123; return false; &#125; head++; tail--; &#125; &#125; return true; &#125;&#125; Solution 2: 12ms, 40.64%, April.23rd, 2016 https://leetcode.com/discuss/80399/7-lines-concise-and-easy-understand-c-solution 12345678910111213class Solution &#123;public: bool isPalindrome(string s) &#123; int l=0, r = s.size() - 1; while(l &lt;= r)&#123; while(!isalnum(s[l]) &amp;&amp; l &lt; r) l++; while(!isalnum(s[r]) &amp;&amp; l &lt; r) r--; if(toupper(s[l]) != toupper(s[r])) return false; l++, r--; &#125; return true; &#125;&#125;; Solution 3: 16ms, 10.11%, April.23rd, 2016 1234567891011121314class Solution &#123;public: bool isPalindrome(string s) &#123; transform(s.begin(), s.end(), s.begin(), ::tolower); auto left = s.begin(), right = s.end(); while(left &lt; right)&#123; if(!::isalnum(*left)) ++left; else if(!::isalnum(*right)) --right; else if(*left != *right) return false; else&#123;left++, right--;&#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[124. Binary Tree Maximum Path Sum]]></title>
    <url>%2Fp%2Fa3afbfd3%2F</url>
    <content type="text"><![CDATA[25.3% https://leetcode.com/problems/binary-tree-maximum-path-sum/?tab=Description Given a binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. 1234567For example:Given the below binary tree, 1 / \ 2 3Return 6. é¢è¯•360æ—¶é‡åˆ°ï¼Œæ ¸å¿ƒæç¤ºï¼Œä½¿ç”¨å¸¦å‚æ•°çš„å‡½æ•°ã€‚ æ–¹æ³•ä¸€ï¼š [recommend for beginners]clean C++ implementation with detailed explanation helpå‡½æ•°ï¼Œè¡¨å¾ä»ŽrootèŠ‚ç‚¹å¼€å§‹ï¼Œè‡³å¶èŠ‚ç‚¹ä¹‹é—´çš„æœ€å¤§valueã€‚ sumé€šè¿‡èŽ·å–ï¼Œhelp(root-&gt;left), help(root-&gt;right)ï¼Œ å†åŠ ä¸Šroot-&gt;valçš„å’Œä¸ºsumï¼Œä¸Žå…ˆå‰çš„sumæ¯”è¾ƒï¼Œè¿›è¡Œæ›´æ–°ã€‚ å…¶ä¸­ï¼Œhelp(root-&gt;left)&lt;=0æ—¶ï¼Œæ­¤å¤„åº”ä¸º0ã€‚ code 1ï¼š 1234567891011121314151617181920class Solution &#123; int sum;public: int maxPathSum(TreeNode* root) &#123; sum=INT_MIN; help(root); return sum; &#125; /*** return the max-value-ended-at-root-node ***/ int help(TreeNode* root)&#123; if(!root) return 0; int left = max(0, help(root-&gt;left)); int right = max(0, help(root-&gt;right)); /*** key parts : embedding the max-value-find in the recursion process ***/ sum = max(sum, left+right+root-&gt;val); /*** get the max-value-ended-at-root ***/ return max(left, right)+root-&gt;val; &#125;&#125;; code 2ï¼š 1234567891011121314151617class Solution &#123; int maxToRoot(TreeNode *root, int &amp;re) &#123; if (!root) return 0; int l = maxToRoot(root-&gt;left, re); int r = maxToRoot(root-&gt;right, re); if (l &lt; 0) l = 0; if (r &lt; 0) r = 0; if (l + r + root-&gt;val &gt; re) re = l + r + root-&gt;val; return root-&gt;val += max(l, r); &#125;public: int maxPathSum(TreeNode *root) &#123; int max = -2147483648; maxToRoot(root, max); return max; &#125;&#125;; code 3ï¼š æˆ‘è‡ªå·±çš„ä»£ç  é€»è¾‘è¿˜æ˜¯å¾ˆç®€å•çš„ï¼Œä½†æ˜¯è¦è€ƒè™‘å‘¨å…¨ï¼Œä¸ç„¶acä¸è¿‡åŽ»ã€‚ resè¡¨ç¤ºæœ€é•¿è·¯å¾„çš„å¤§å°ï¼Œç„¶åŽåœ¨helperå‡½æ•°ä¸­ï¼Œä¼ çš„æ˜¯åœ°å€ã€‚ helperä¸­æ˜¯æ ‘çš„å…ˆåºéåŽ†ã€‚root==NULLè‡ªä¸å¿…è¯´ã€‚helperå‡½æ•°è¿”å›žå½“å‰èŠ‚ç‚¹å‡ºå‘è‡³ä¸‹é¢ä»»æ„èŠ‚ç‚¹ä¹‹é—´çš„æœ€å¤§çš„å€¼å¾—å¤§å°ã€‚å½“å‰çš„rootå¯¹åº”çš„çš„å€¼ä¸ºcurï¼Œè¦è€ƒè™‘è¿™ä¸ªå¤§å°ï¼Œå°±è¦è€ƒè™‘å·¦èŠ‚ç‚¹å‡ºå‘çš„å¤§å°ï¼Œå³èŠ‚ç‚¹çš„å¤§å°ï¼Œè¿™æ—¶ï¼Œæ›´æ–°ä¸‹resçš„å¤§å°ï¼Œé€šè¿‡å½“å‰èŠ‚ç‚¹çš„åŠ ä¸Šå·¦å³åˆ†æ”¯çš„èŠ‚ç‚¹çš„æœ€å¤§å€¼ï¼Œä¸ºcur_maxåŽ»æ›´æ–°resçš„å€¼ã€‚ç„¶åŽè¿”å›žå€¼å‘¢ï¼Œå°±æ˜¯å·¦èŠ‚ç‚¹å³èŠ‚ç‚¹çš„æœ€å¤§å€¼ä¸Ž0çš„æœ€å¤§å€¼åŠ ä¸Šcurï¼Œå› ä¸ºè¿”å›žå€¼æ˜¯é€šè¿‡å½“å‰èŠ‚ç‚¹çš„ä¸€æ¡åˆ†æ”¯çš„æœ€å¤§å€¼ã€‚ 1234567891011121314151617181920class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; if(root==NULL) return 0; int res = INT_MIN; // åˆå§‹å€¼è®¾ç½®ä¸ºINT_MINï¼Œè€Œä¸æ˜¯0ï¼Œå¦åˆ™è´Ÿæ•°ä¼šå‡ºé”™è¯¯ç»“æžœã€‚ helper(root, res); return res; &#125; int helper(TreeNode* root, int &amp; res)&#123; if(root==NULL) return 0; int cur = root-&gt;val; int left = helper(root-&gt;left, res); int right = helper(root-&gt;right, res); int cur_max = max(left,0) + max(right, 0) + cur; res = max(cur_max, res); return max(max(left, right), 0)+cur; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; int res = INT_MIN; helper(root, res); return res; &#125; int helper(TreeNode* root, int &amp; res)&#123; if(!root) return 0; int left = helper(root-&gt;left, res); int right = helper(root-&gt;right, res); left = max(left, 0); right = max(right, 0); res = max(left+right+root-&gt;val, res); return max(left, right)+root-&gt;val; &#125;&#125;; æ–¹æ³•äºŒï¼š è¿™ç§æ–¹æ³•ä¸Žä¸Šä¸€ç§é€»è¾‘ä¸Šæ˜¯ä¸€æ ·çš„ï¼Œä¸åŒçš„æ˜¯ï¼Œä¸€æ˜¯resåœ¨å…¨å±€å˜é‡ï¼ˆæ˜¯è¿™ä¸ªåå­—ï¼Ÿï¼Ÿï¼‰ï¼Œæ›´é‡è¦çš„æ˜¯å®ƒè®¾å®šäº†ä¸€ä¸ªresçš„åˆå§‹å€¼ï¼Œå°±é¿å…äº†ä½¿ç”¨INT_MINã€‚ 12345678910111213141516class Solution &#123; int res;public: int depth(TreeNode *root)&#123; if(root==NULL) return 0; int a=depth(root-&gt;left), b=depth(root-&gt;right); res=max(res,a+b+root-&gt;val);//if *root is the top node in the path return max(0,max(a, b)+root-&gt;val);//if *root is in the path, if this branch a burden or a plus &#125; int maxPathSum(TreeNode *root) &#123; if(root==NULL) return 0; res=root-&gt;val; depth(root); return res; &#125;&#125;; https://discuss.leetcode.com/topic/5508/simple-o-n-algorithm-with-one-traversal-through-the-tree Simple O(n) algorithm with one traversal through the tree 1234567891011121314151617class Solution &#123; int maxToRoot(TreeNode *root, int &amp;re) &#123; if (!root) return 0; int l = maxToRoot(root-&gt;left, re); int r = maxToRoot(root-&gt;right, re); if (l &lt; 0) l = 0; if (r &lt; 0) r = 0; if (l + r + root-&gt;val &gt; re) re = l + r + root-&gt;val; return root-&gt;val += max(l, r); &#125;public: int maxPathSum(TreeNode *root) &#123; int max = -2147483648; maxToRoot(root, max); return max; &#125;&#125;; update the val of each node of the tree bottom-up, the new val of TreeNode *x stands for the max sum started from any node in subtree x and ended in x, mataining the re for result in traversal at the same time. https://discuss.leetcode.com/topic/5508/simple-o-n-algorithm-with-one-traversal-through-the-tree/5 Good solution! Essentially same as mine, but I donâ€™t see why you update the val of each node, since each node is visited only once. In my version, I just return the maximum path ending at the root of the current tree while potentially updating the value of the global maximum with the path that links left and right. 1234567891011121314151617class Solution &#123;public: int maxPathSum(TreeNode *root) &#123; int max = numeric_limits&lt;int&gt;::min(); maxPathAndGlobalUpdate(root, &amp;max); return max; &#125;private: int maxPathAndGlobalUpdate(TreeNode *root, int* _global_max) &#123; if (root == nullptr) return 0; int&amp; global_max = *_global_max; int l = max(0, maxPathAndGlobalUpdate(root-&gt;left, &amp;global_max)); int r = max(0, maxPathAndGlobalUpdate(root-&gt;right, &amp;global_max)); global_max = max(global_max, l + r + root-&gt;val); return root-&gt;val + max(l, r); &#125;&#125;; 42ms, 15.55%, October 14, 2016 A very concise recursive solution https://discuss.leetcode.com/topic/7325/a-very-concise-recursive-solution 12345678910111213141516class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; int maxPath = INT_MIN; dfsMaxPath(root, maxPath); return maxPath; &#125; int dfsMaxPath(TreeNode *root, int &amp;maxPath)&#123; if(!root) return 0; int l = max(0, dfsMaxPath(root-&gt;left, maxPath)); int r = max(0, dfsMaxPath(root-&gt;right, maxPath)); maxPath = max(maxPath, l+r+root-&gt;val); return root-&gt;val + max(l, r); &#125;&#125;; https://discuss.leetcode.com/topic/2644/accepted-o-n-solution Accepted O(n) solution The idea is based on the solution of max sum of a sequence array, Here is the explaination of the code: Have a recursive method which traverse the binary tree, it also return the max possible sum of left branch and right branch saperately. for example, For node A, when itâ€™s left and right node recusive call returned, we will know the max possible sum of left branch, right branch. Have a CheckMax function which will compare the sequence sum and record the max history. For node A, check whether left branch + this node + right branch is the maximum, check whether left branch + this node is maxï¼Œ check whether right branch + this node is max. When recursive method return, we should only return the max sum of one path - either the left branch + this node, or the right branch + this node. So that this is still a single path and can be used to link by node Aâ€™s parent node. Itâ€™s accepted by OL. Let me know if you have any question 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public: int maxPathSum(TreeNode *root) &#123; if(!root) return 0; maxSum = root-&gt;val; recNodes(root); return maxSum; &#125; protected: int recNodes(TreeNode* node) &#123; int numl=0,numr=0; if (node-&gt;left) numl = recNodes(node-&gt;left); if (node-&gt;right) numr = recNodes(node-&gt;right); //choose the max path, either left or right int value = node-&gt;val; int sumWhole = checkMax(value,numl+numr); int sumLeft = numl&gt;0?checkMax(value,numl):value; int sumRight = numr&gt;0?checkMax(value,numr):value; return max(sumLeft,sumRight); &#125; int checkMax(int value, int sum) &#123; if(sum&gt;0) sum+=value; else sum=value; if(sum&gt;maxSum) maxSum = sum; return sum; &#125; int maxSum; &#125;; https://discuss.leetcode.com/topic/35300/recommend-for-beginners-clean-c-implementation-with-detailed-explanation [recommend for beginners]clean C++ implementation with detailed explanation 1234567891011121314151617181920class Solution &#123; int sum;public: int maxPathSum(TreeNode* root) &#123; sum=INT_MIN; help(root); return sum; &#125; /*** return the max-value-ended-at-root-node ***/ int help(TreeNode* root)&#123; if(!root) return 0; int left = max(0, help(root-&gt;left)); int right = max(0, help(root-&gt;right)); /*** key parts : embedding the max-value-find in the recursion process ***/ sum = max(sum, left+right+root-&gt;val); /*** get the max-value-ended-at-root ***/ return max(left, right)+root-&gt;val; &#125;&#125;; https://discuss.leetcode.com/topic/11112/clean-c-solution Clean c++ solution 12345678910111213141516class Solution &#123; int res;public: int depth(TreeNode *root)&#123; if(root==NULL) return 0; int a=depth(root-&gt;left), b=depth(root-&gt;right); res=max(res,a+b+root-&gt;val);//if *root is the top node in the path return max(0,max(a, b)+root-&gt;val);//if *root is in the path, if this branch a burden or a plus &#125; int maxPathSum(TreeNode *root) &#123; if(root==NULL) return 0; res=root-&gt;val; depth(root); return res; &#125;&#125;; 2ms, 42.51%, October 14, 2016 https://discuss.leetcode.com/topic/4407/accepted-short-solution-in-java 1234567891011121314151617public class Solution &#123; int maxValue; public int maxPathSum(TreeNode root) &#123; maxValue = Integer.MIN_VALUE; maxPathDown(root); return maxValue; &#125; private int maxPathDown(TreeNode node)&#123; if(node == null) return 0; int left = Math.max(0, maxPathDown(node.left)); int right = Math.max(0, maxPathDown(node.right)); maxValue = Math.max(maxValue, left+right+node.val); return Math.max(left, right) + node.val; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[123. Best Time to Buy and Sell Stock III]]></title>
    <url>%2Fp%2F3ac663d0%2F</url>
    <content type="text"><![CDATA[28.6% https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). æ–¹æ³•ä¸€ï¼š å¾®ç­–ç•¥é¢è¯•é¢˜ æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 17, 2017 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; v = &#123;INT_MIN, 0, INT_MIN, 0&#125;; for(auto price:prices)&#123; v[0] = max(v[0], -price); v[1] = max(v[1], v[0]+price); v[2] = max(v[2], v[1]-price); v[3] = max(v[3], v[2]+price); &#125; return max(v[1], v[3]); &#125;&#125;; My C++ solution (O(N) time, O(1) space, 8ms) It is similar to other buy/sell problems. just do DP and define an array of states to track the current maximum profits at different stages. For example, in the below code states[][0]: one buy states[][1]: one buy, one sell states[][2]: two buys, one sell states[][3]: two buy, two sells The states transistions occurs when buy/sell operations are executed. For example, state[][0] can move to state[][1] via one sell operation. 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int states[2][4] = &#123;INT_MIN, 0, INT_MIN, 0&#125;; // 0: 1 buy, 1: one buy/sell, 2: 2 buys/1 sell, 3, 2 buys/sells int len = prices.size(), i, cur = 0, next =1; for(i=0; i&lt;len; ++i) &#123; states[next][0] = max(states[cur][0], -prices[i]); states[next][1] = max(states[cur][1], states[cur][0]+prices[i]); states[next][2] = max(states[cur][2], states[cur][1]-prices[i]); states[next][3] = max(states[cur][3], states[cur][2]+prices[i]); swap(next, cur); &#125; return max(states[cur][1], states[cur][3]); &#125;&#125;; æ–¹æ³•äºŒï¼š é«˜æ•ˆã€ç®€ä¾¿ã€å®¹æ˜“æƒ³åˆ°çš„æ–¹æ³• 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); if(n&lt;2) return 0; vector&lt;int&gt; dp1(n, 0); vector&lt;int&gt; dp2(n, 0); int minPrice = INT_MAX; int maxProfit1 = 0; for(int i=0; i&lt;n; i++)&#123; minPrice = min(minPrice, prices[i]); maxProfit1 = max(maxProfit1, prices[i]-minPrice); dp1[i] = maxProfit1; &#125; int maxPrice = INT_MIN; int maxProfit2 = 0; for(int i=n-1; i&gt;=0; i--)&#123; maxPrice = max(maxPrice, prices[i]); maxProfit2 = max(maxProfit2, maxPrice-prices[i]); dp2[i] = maxProfit2; &#125; int maxProfit = 0; for(int i=0; i&lt;n; i++)&#123; maxProfit = max(maxProfit, dp1[i]+dp2[i]); &#125; return maxProfit; &#125;&#125;; cpp https://discuss.leetcode.com/topic/19750/my-c-solution-o-n-time-o-1-space-8ms My C++ solution (O(N) time, O(1) space, 8ms) It is similar to other buy/sell problems. just do DP and define an array of states to track the current maximum profits at different stages. For example, in the below code states[][0]: one buy states[][1]: one buy, one sell states[][2]: two buys, one sell states[][3]: two buy, two sells The states transistions occurs when buy/sell operations are executed. For example, state[][0] can move to state[][1] via one sell operation. 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int states[2][4] = &#123;INT_MIN, 0, INT_MIN, 0&#125;; // 0: 1 buy, 1: one buy/sell, 2: 2 buys/1 sell, 3, 2 buys/sells int len = prices.size(), i, cur = 0, next =1; for(i=0; i&lt;len; ++i) &#123; states[next][0] = max(states[cur][0], -prices[i]); states[next][1] = max(states[cur][1], states[cur][0]+prices[i]); states[next][2] = max(states[cur][2], states[cur][1]-prices[i]); states[next][3] = max(states[cur][3], states[cur][2]+prices[i]); swap(next, cur); &#125; return max(states[cur][1], states[cur][3]); &#125;&#125;; https://discuss.leetcode.com/topic/27426/a-solution-not-so-dynamic-programming A solution not so dynamic programming. I think the most difficult part is how to connect the first transaction to the second transaction. The final target is to get the maximum value of profit2. You must try to get money as much as possible after you buy the stock second time. Then after the second time of sell, with the as high as possible price, you get the maximum profit. 1234567891011121314151617class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int size=prices.size(); int profit1=0; int profit2=0; int o1=INT_MAX; int o2=INT_MIN; for(int i=0; i&lt;size; ++i)&#123; o1=min(o1, prices[i]); profit1=max(profit1, prices[i]-o1); o2=max(o2, profit1-prices[i]); profit2=max(profit2, prices[i]+o2); &#125; return profit2; &#125;&#125;; https://discuss.leetcode.com/topic/902/don-t-need-dp-to-solve-it-within-o-n Donâ€™t need DP to solve it within O(n) Donâ€™t need DP to solve this problem. It is still O(n) and basically use the same algorithm solving â€œStock Iâ€ four times. Get the max profit with one transaction to the full array. Keep down the start and end positions. the start and end positions will be included in the result of two transaction. It falls into two categories:A) it is one full transaction, B) they belong to two separate transactions(start belongs to first transaction and end belongs to second transaction). if A)â€“ get max profit with one transaction to subarray from 0 to start ; get max profit with one transaction to subarray from end to prices.length. if B)â€“ get the max profit with one transaction within start and end in reverse order return the max profit in those cases. https://discuss.leetcode.com/topic/41049/clear-c-solution Clear c++ solution 123456789101112int maxProfit(vector&lt;int&gt;&amp; prices) &#123; //It&apos;s wrong if you choose the minimum price for buy2 , but you can maximize the left money. // int buy1 = INT_MIN, sale1 = 0, buy2 = INT_MIN, sale2 = 0; for(int i=0; i&lt;prices.size(); i++)&#123; //the more money left, the happier you will be buy1 = max(buy1, -prices[i]); //left money after buy1 sale1 = max(sale1, prices[i] + buy1); //left money after sale1 buy2 = max(buy2, sale1 - prices[i]); //left money after buy2 sale2 = max(sale2, prices[i] + buy2); //left money after sale2 &#125; return sale2;&#125; https://discuss.leetcode.com/topic/42087/why-don-t-we-make-our-life-easier Why donâ€™t we make our life easier The idea is very basic. At most two transactions means we can break at any time point and compute the max revenue before this time point and after this time point. For every possible time point, we choose the maximum. Note that right_max start from the last time point, which is just like a mirror algorithm from the Best Time to Buy and Sell Stock I 123456789101112131415161718192021222324252627int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; left_max; vector&lt;int&gt; right_max; int n = prices.size(); if(n == 0)&#123; return 0; &#125; int cur_min = prices[0]; int max_r = 0; for(int i = 0; i &lt; n; i++)&#123; max_r = max(max_r, prices[i] - cur_min); left_max.push_back(max_r); cur_min = min(cur_min, prices[i]); &#125; int cur_max = prices[n-1]; max_r = 0; for(int i = n-1; i &gt;= 0; i--)&#123; max_r = max(max_r, cur_max - prices[i]); right_max.insert(right_max.begin(), max_r); cur_max = max(cur_max, prices[i]); &#125; int sum_max = 0; for(int i = 0; i &lt; n; i++)&#123; sum_max = max(sum_max, left_max[i] + right_max[i]); &#125; return sum_max;&#125; python https://discuss.leetcode.com/topic/6811/python-dp-solution-120ms Python DP solution, 120ms Two passes through the list, O(n) time, O(n) space: 12345678910111213141516171819202122232425def maxProfit(self, prices): if not prices: return 0 # forward traversal, profits record the max profit # by the ith day, this is the first transaction profits = [] max_profit = 0 current_min = prices[0] for price in prices: current_min = min(current_min, price) max_profit = max(max_profit, price - current_min) profits.append(max_profit) # backward traversal, max_profit records the max profit # after the ith day, this is the second transaction total_max = 0 max_profit = 0 current_max = prices[-1] for i in range(len(prices) - 1, -1, -1): current_max = max(current_max, prices[i]) max_profit = max(max_profit, current_max - prices[i]) total_max = max(total_max, max_profit + profits[i]) return total_max https://discuss.leetcode.com/topic/51468/7-liner-in-python-beats-99 7-liner in Python, beats 99% 1234567891011121314class Solution(object): def maxProfit(self, p): if not p: return 0 sell, buyd, n, minp, maxp = [0], [0], len(p), p[0], p[-1] for i in range(1, n): minp, maxp = min(minp, p[i]), max(maxp, p[n-i-1]) sell.append(max(sell[i-1], p[i] - minp)) buyd.append(max(buyd[i-1], maxp - p[n-i-1])) return max(sell[i] + buyd[n-i-1] for i in range(n))# 198 / 198 test cases passed.# Status: Accepted# Runtime: 56 ms java https://discuss.leetcode.com/topic/5934/is-it-best-solution-with-o-n-o-1 Is it Best Solution with O(n), O(1). The thinking is simple and is inspired by the best solution from Single Number II (I read through the discussion after I use DP). Assume we only have 0 money at first; 4 Variables to maintain some interested â€˜ceilingsâ€™ so far: The maximum of if weâ€™ve just buy 1st stock, if weâ€™ve just sold 1nd stock, if weâ€™ve just buy 2nd stock, if weâ€™ve just sold 2nd stock. Very simple code too and work well. I have to say the logic is simple than those in Single Number II. 12345678910111213public class Solution &#123; public int maxProfit(int[] prices) &#123; int hold1 = Integer.MIN_VALUE, hold2 = Integer.MIN_VALUE; int release1 = 0, release2 = 0; for(int i:prices)&#123; // Assume we only have 0 money at first release2 = Math.max(release2, hold2+i); // The maximum if we&apos;ve just sold 2nd stock so far. hold2 = Math.max(hold2, release1-i); // The maximum if we&apos;ve just buy 2nd stock so far. release1 = Math.max(release1, hold1+i); // The maximum if we&apos;ve just sold 1nd stock so far. hold1 = Math.max(hold1, -i); // The maximum if we&apos;ve just buy 1st stock so far. &#125; return release2; ///Since release1 is initiated as 0, so release2 will always higher than release1. &#125;&#125; https://discuss.leetcode.com/topic/4766/a-clean-dp-solution-which-generalizes-to-k-transactions A clean DP solution which generalizes to k transactions Solution is commented in the code. Time complexity is O(kn), space complexity can be O(n) because this DP only uses the result from last step. But for cleaness this solution still used O(kn) space complexity to preserve similarity to the equations in the comments. 12345678910111213141516171819202122232425class Solution &#123;public: int maxProfit(vector&lt;int&gt; &amp;prices) &#123; // f[k, ii] represents the max profit up until prices[ii] (Note: NOT ending with prices[ii]) using at most k transactions. // f[k, ii] = max(f[k, ii-1], prices[ii] - prices[jj] + f[k-1, jj]) &#123; jj in range of [0, ii-1] &#125; // = max(f[k, ii-1], prices[ii] + max(f[k-1, jj] - prices[jj])) // f[0, ii] = 0; 0 times transation makes 0 profit // f[k, 0] = 0; if there is only one price data point you can&apos;t make any money no matter how many times you can trade if (prices.size() &lt;= 1) return 0; else &#123; int K = 2; // number of max transation allowed int maxProf = 0; vector&lt;vector&lt;int&gt;&gt; f(K+1, vector&lt;int&gt;(prices.size(), 0)); for (int kk = 1; kk &lt;= K; kk++) &#123; int tmpMax = f[kk-1][0] - prices[0]; for (int ii = 1; ii &lt; prices.size(); ii++) &#123; f[kk][ii] = max(f[kk][ii-1], prices[ii] + tmpMax); tmpMax = max(tmpMax, f[kk-1][ii] - prices[ii]); maxProf = max(f[kk][ii], maxProf); &#125; &#125; return maxProf; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/4766/a-clean-dp-solution-which-generalizes-to-k-transactions/2 Brilliant solution! a small point: there is no need to track maxProf. we can simply return f[K][prices.size()-1] https://discuss.leetcode.com/topic/4766/a-clean-dp-solution-which-generalizes-to-k-transactions/9 Brilliant solution! Thanks for sharing~ Minor point, but f[kk-1][0] is just 0. Iâ€™d also explain the algorithm a little differently, something like the following: 123456// dpProfit[t][i]: maximum Profit using at most t transactions up to day i (including day i)// dpProfit[t][i] = max(dpProfit[t][i - 1], prices[i] - prices[j] + dpProfit[t - 1][j]) for all j in range [0, i - 1]// = max(dpProfit[t][i - 1], prices[i] + max(dpProfit[t - 1][j] - prices[j])) for all j in range [0, i - 1]// = max(dpProfit[t][i - 1], prices[i] + max prev [t - 1] trans profit at the corresponding j in range [0, i - 1] less price at j)// maxPreProfitLessI inside loop iterations// Note: subtracting price at j is for the last additional transaction to sell at day i https://discuss.leetcode.com/topic/39751/my-explanation-for-o-n-solution My explanation for O(N) solution! First assume that we have no money, so buy1 means that we have to borrow money from others, we want to borrow less so that we have to make our balance as max as we can(because this is negative). sell1 means we decide to sell the stock, after selling it we have price[i] money and we have to give back the money we owed, so we have price[i] - |buy1| = prices[i ] + buy1, we want to make this max. buy2 means we want to buy another stock, we already have sell1 money, so after buying stock2 we have buy2 = sell1 - price[i] money left, we want more money left, so we make it max sell2 means we want to sell stock2, we can have price[i] money after selling it, and we have buy2 money left before, so sell2 = buy2 + prices[i], we make this max. So sell2 is the most money we can have. Hope it is helpful and welcome quesions! 12345678910public int maxProfit(int[] prices) &#123; int sell1 = 0, sell2 = 0, buy1 = Integer.MIN_VALUE, buy2 = Integer.MIN_VALUE; for (int i = 0; i &lt; prices.length; i++) &#123; buy1 = Math.max(buy1, -prices[i]); sell1 = Math.max(sell1, buy1 + prices[i]); buy2 = Math.max(buy2, sell1 - prices[i]); sell2 = Math.max(sell2, buy2 + prices[i]); &#125; return sell2; &#125; https://discuss.leetcode.com/topic/32288/2ms-java-dp-solution 2ms Java DP Solution Sorry for my poor English 12345678910111213141516public int maxProfit(int[] prices) &#123; // these four variables represent your profit after executing corresponding transaction // in the beginning, your profit is 0. // when you buy a stock ,the profit will be deducted of the price of stock. int firstBuy = Integer.MIN_VALUE, firstSell = 0; int secondBuy = Integer.MIN_VALUE, secondSell = 0; for (int curPrice : prices) &#123; if (firstBuy &lt; -curPrice) firstBuy = -curPrice; // the max profit after you buy first stock if (firstSell &lt; firstBuy + curPrice) firstSell = firstBuy + curPrice; // the max profit after you sell it if (secondBuy &lt; firstSell - curPrice) secondBuy = firstSell - curPrice; // the max profit after you buy the second stock if (secondSell &lt; secondBuy + curPrice) secondSell = secondBuy + curPrice; // the max profit after you sell the second stock &#125; return secondSell; // secondSell will be the max profit after passing the prices&#125; https://discuss.leetcode.com/topic/7028/java-solution-with-just-two-traverses Java solution with just two traverses. Go from left to right and calculate max profit for each index (i). Go from right to left and calculate max profit for (i). Add max right profit for (i) and max left profit for (i-1) and check if itâ€™s max profit. 123456789101112131415161718192021222324252627public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) return 0; int lenght = prices.length; int[] leftProfit = new int[lenght]; int leftMaxProfit = 0; int leftMin = prices[0]; for (int i=0; i&lt;lenght; i++) &#123; if (prices[i] &lt; leftMin) leftMin = prices[i]; if (prices[i] - leftMin &gt; leftMaxProfit) leftMaxProfit = prices[i]-leftMin; leftProfit[i] = leftMaxProfit; &#125; int maxProfit = 0; int rightMaxProfit = 0; int rightMax = prices[lenght-1]; for (int i=lenght-1; i&gt;=0; i--) &#123; if (prices[i] &gt; rightMax) rightMax = prices[i]; if (rightMax - prices[i] &gt; rightMaxProfit) rightMaxProfit = rightMax - prices[i]; int currentProfit = rightMaxProfit + (i&gt;0 ? leftProfit[i-1] : 0); if (currentProfit &gt; maxProfit) &#123; maxProfit = currentProfit; &#125; &#125; return maxProfit;&#125; my code dp1ä¸­çš„dp[i] è¡¨ç¤ºä»Žç¬¬ä¸€å¤©è‡³ç¬¬iå¤©ï¼Œåªå–å‡ºä¸€æ¬¡çš„æœ€å¤§æ”¶ç›Šã€‚ dp2ä¸­çš„dp[i] è¡¨ç¤ºä»Žç¬¬iå¤©è‡³æœ€åŽä¸€å¤©ï¼Œåªå–å‡ºä¸€æ¬¡çš„æœ€å¤§æ”¶ç›Šã€‚ dp1ä»Žå‰å‘åŽï¼Œdp2ä»ŽåŽå‘å‰ 12345678910111213141516171819202122232425262728public class Solution &#123; public int maxProfit(int[] prices) &#123; int[] dp1 = new int[prices.length]; int[] dp2 = new int[prices.length]; int minprice = Integer.MAX_VALUE; int maxprofit = 0; for(int i=0; i&lt;prices.length; i++)&#123; if(prices[i] &lt; minprice) minprice = prices[i]; else maxprofit = Math.max(maxprofit, prices[i]-minprice); dp1[i] = maxprofit; &#125; int maxprice = Integer.MIN_VALUE; maxprofit = 0; for(int j=prices.length-1; j&gt;=0; j--)&#123; if(prices[j] &gt; maxprice) maxprice = prices[j]; else maxprofit = Math.max(maxprofit, maxprice-prices[j]); dp2[j] = maxprofit; &#125; maxprofit = 0; for(int i=0; i&lt;prices.length; i++) maxprofit = Math.max(maxprofit, dp1[i]+dp2[i]); return maxprofit; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[122. Best Time to Buy and Sell Stock II]]></title>
    <url>%2Fp%2Ffca87911%2F</url>
    <content type="text"><![CDATA[46.0% https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0; for(int i = 1; i&lt;prices.size(); i++) res += max(prices[i]-prices[i-1], 0); return res; &#125;&#125;; Second, suppose the first sequence is â€œa &lt;= b &lt;= c &lt;= dâ€, the profit is â€œd - a = (b - a) + (c - b) + (d - c)â€ without a doubt. And suppose another one is â€œa &lt;= b &gt;= bâ€™ &lt;= c &lt;= dâ€, the profit is not difficult to be figured out as â€œ(b - a) + (d - bâ€™)â€. So you just target at monotone sequences. 12345678910class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int maxprofit = 0; for(size_t i=1; i&lt;prices.size(); i++)&#123; maxprofit += max(prices[i]-prices[i-1], 0); &#125; return maxprofit; &#125;&#125;; python Basically, if tomorrowâ€™s price is higher than todayâ€™s, we buy it today and sell tomorrow. Otherwise, we donâ€™t. Here is the code: 1234567class Solution(object): def maxProfit(self, prices): &quot;&quot;&quot; :type prices: List[int] :rtype: int &quot;&quot;&quot; return sum(max(prices[i+1]-prices[i], 0) for i in range(len(prices)-1)) java Algorithm This solution follows the logic used in Approach 2 itself, but with only a slight variation. In this case, instead of looking for every peak following a valley, we can simply go on crawling over the slope and keep on adding the profit obtained from every consecutive transaction. In the end,we will be using the peaks and valleys effectively, but we need not track the costs corresponding to the peaks and valleys along with the maximum profit, but we can directly keep on adding the difference between the consecutive numbers of the array if the second number is larger than the first one, and at the total sum we obtain will be the maximum profit. This approach will simplify the solution. This can be made clearer by taking this example: [1, 7, 2, 3, 6, 7, 6, 7] The graph corresponding to this array is: If we analyze the graph, we notice that the points of interest are the consecutive valleys and peaks. Complexity Analysis Time complexity : O(n)O(n). Single pass. Space complexity : O(1)O(1). Constant space required. 12345678910111213141516171819public class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices.length==0) return 0; int i=0; int maxprofit = 0; int valley = prices[0]; int peak = prices[0]; while(i&lt;prices.length-1)&#123; while(i&lt;prices.length-1 &amp;&amp; prices[i]&gt;=prices[i+1]) i++; valley = prices[i]; while(i&lt;prices.length-1 &amp;&amp; prices[i]&lt;=prices[i+1]) i++; peak = prices[i]; maxprofit += peak - valley; &#125; return maxprofit; &#125;&#125; https://leetcode.com/articles/best-time-buy-and-sell-stock-ii/ Algorithm This solution follows the logic used in Approach 2 itself, but with only a slight variation. In this case, instead of looking for every peak following a valley, we can simply go on crawling over the slope and keep on adding the profit obtained from every consecutive transaction. In the end,we will be using the peaks and valleys effectively, but we need not track the costs corresponding to the peaks and valleys along with the maximum profit, but we can directly keep on adding the difference between the consecutive numbers of the array if the second number is larger than the first one, and at the total sum we obtain will be the maximum profit. This approach will simplify the solution. This can be made clearer by taking this example: [1, 7, 2, 3, 6, 7, 6, 7] The graph corresponding to this array is: From the above graph, we can observe that the sum A+B+CA+B+C is equal to the difference DD corresponding to the difference between the heights of the consecutive peak and valley. Complexity Analysis Time complexity : O(n)O(n). Single pass. Space complexity: O(1)O(1). Constant space needed. 12345678910public class Solution &#123; public int maxProfit(int[] prices) &#123; int maxprofit = 0; for(int i=1; i&lt;prices.length; i++)&#123; if(prices[i] - prices[i-1] &gt; 0) maxprofit += prices[i] - prices[i-1]; &#125; return maxprofit; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[121. Best Time to Buy and Sell Stock]]></title>
    <url>%2Fp%2F588afc94%2F</url>
    <content type="text"><![CDATA[40.0% https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. 123456Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) 123456Example 2:Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. ä¸¤ç§æ€è·¯ï¼š å¯»æ‰¾ä½Žè°·ä¸Žå³°å€¼ä¹‹é—´çš„å·®ã€‚è®¾ç½®ä¸€ä¸ªå˜é‡ä¸ºä½Žè°·ï¼Œvallyï¼Œå¦ä¸€ä¸ªå˜é‡ä¸ºç›®å‰æ‰¾åˆ°çš„æœ€å¤§å€¼ï¼Œmaxsofarï¼Œåˆ™ä»Žå¤´å¼€å§‹éåŽ†ï¼Œå¦‚æžœå½“å‰å€¼å°äºŽvallyï¼Œåˆ™æ­¤å€¼ä¸Žvallyçš„å·®ä¸ºè´Ÿï¼Œæ‰€ä»¥vallyæ”¹ä¸ºå½“å‰å€¼ï¼Œå¦‚æžœå½“å‰å€¼å¤§äºŽvallyï¼Œåˆ™è®¡ç®—å½“å‰å€¼ä¸Žvallyçš„å·®ã€‚ä¸€æ¬¡éåŽ†ã€‚ ç¬¬äºŒç§æ€è·¯ï¼Œé‡æ–°è®¾ç½®ä¸€ä¸ªæ•°ç»„ï¼Œè®°å½•é‚»è¿‘ä¸¤ä¸ªæ•°å­—çš„å·®ï¼Œç±»ä¼¼äºŽå¯»æ‰¾æœ€é•¿çš„æ•°ç»„ã€‚ æ–¹æ³•ä¸€ï¼š å¾®ç­–ç•¥é¢è¯•é¢˜ æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 17ï¼Œ 2017 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int minPrice = INT_MAX; int maxPro = 0; for(auto price:prices)&#123; minPrice = min(price, minPrice); maxPro = max(maxPro, price - minPrice); &#125; return maxPro; &#125;&#125;; https://discuss.leetcode.com/topic/5863/sharing-my-simple-and-clear-c-solution Sharing my simple and clear C++ solution 123456789int maxProfit(vector&lt;int&gt; &amp;prices) &#123; int maxPro = 0; int minPrice = INT_MAX; // æ­¤å¤„ä¸èƒ½ç”¨prices[0]ä»£æ›¿ï¼Œå¦‚æžœç”¨ï¼Œéœ€è¦å…ˆåˆ¤æ–­prices.size()ä¸Ž0çš„å…³ç³» for(int i = 0; i &lt; prices.size(); i++)&#123; minPrice = min(minPrice, prices[i]); maxPro = max(maxPro, prices[i] - minPrice); &#125; return maxPro;&#125; minPrice is the minimum price from day 0 to day i. And maxPro is the maximum profit we can get from day 0 to day i. How to get maxPro? Just get the larger one between current maxPro and prices[i] - minPrice. æ–¹æ³•äºŒï¼š https://discuss.leetcode.com/topic/5863/sharing-my-simple-and-clear-c-solution/5 Very nice solution! But it still can be optimized. We only need to calculate either maxProfit or minPrice not both in every loop. Running time can be dropped by 33% percent. 1234567891011121314public int maxProfit(int[] prices) &#123; if(prices == null || prices.length &lt; 2) return 0; int maxProfit = 0, minPrice = prices[0]; for(int i = 1; i &lt; prices.length; i++) &#123; if(prices[i] &gt; prices[i - 1]) &#123; maxProfit = Math.max(maxProfit, prices[i] - minPrice); &#125; else &#123; minPrice = Math.min(minPrice, prices[i]); &#125; &#125; return maxProfit;&#125; cpp https://discuss.leetcode.com/topic/5863/sharing-my-simple-and-clear-c-solution Sharing my simple and clear C++ solution 123456789int maxProfit(vector&lt;int&gt; &amp;prices) &#123; int maxPro = 0; int minPrice = INT_MAX; for(int i = 0; i &lt; prices.size(); i++)&#123; minPrice = min(minPrice, prices[i]); maxPro = max(maxPro, prices[i] - minPrice); &#125; return maxPro;&#125; minPrice is the minimum price from day 0 to day i. And maxPro is the maximum profit we can get from day 0 to day i. How to get maxPro? Just get the larger one between current maxPro and prices[i] - minPrice. https://discuss.leetcode.com/topic/5863/sharing-my-simple-and-clear-c-solution/5 Very nice solution! But it still can be optimized. We only need to calculate either maxProfit or minPrice not both in every loop. Running time can be dropped by 33% percent. 1234567891011121314public int maxProfit(int[] prices) &#123; if(prices == null || prices.length &lt; 2) return 0; int maxProfit = 0, minPrice = prices[0]; for(int i = 1; i &lt; prices.length; i++) &#123; if(prices[i] &gt; prices[i - 1]) &#123; maxProfit = Math.max(maxProfit, prices[i] - minPrice); &#125; else &#123; minPrice = Math.min(minPrice, prices[i]); &#125; &#125; return maxProfit;&#125; https://discuss.leetcode.com/topic/42716/5-line-cpp-solution 5 line CPP solution 12345678int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int maxPro = 0, minPrice = INT_MAX; for(int i = 0; i &lt; prices.size(); i++) &#123; minPrice = min(minPrice, prices[i]); maxPro = max(prices[i] - minPrice, maxPro); &#125; return maxPro;&#125; python https://discuss.leetcode.com/topic/33241/easy-o-n-python-solution Easy O(n) Python solution 1234567def maxProfit(prices): max_profit, min_price = 0, float(&apos;inf&apos;) for price in prices: min_price = min(min_price, price) profit = price - min_price max_profit = max(max_profit, profit) return max_profit java Algorithm Say the given array is: [7, 1, 5, 3, 6, 4] If we plot the numbers of the given array on a graph, we get: The points of interest are the peaks and valleys in the given graph. We need to find the largest peak following the smallest valley. We can maintain two variables - minprice and maxprofit corresponding to the smallest valley and maximum profit (maximum difference between selling price and minprice) obtained so far respectively. Complexity Analysis Time complexity : O(n)O(n). Only a single pass is needed. Space complexity : O(1)O(1). Only two variables are used. é’ˆå¯¹æ¯ä¸ªç‚¹ï¼Œä¸Žæœ€å°ç‚¹æ¯”å·®å€¼ï¼Œå¦‚æžœæœ€å°ç‚¹å°äºŽå½“å‰å€¼ï¼Œå¯ä»¥çœ‹å…¶å·®å€¼æ˜¯å¦å¯ä»¥åšæœ€å°å€¼ï¼Œå¦‚æžœæœ€å°ç‚¹å¤§äºŽå½“å‰æœ€å°å€¼ï¼Œå½“å‰å€¼å¯ä»¥ä½œä¸ºæœ€å°å€¼ã€‚ å…³é”®åœ¨äºŽå¯¹æ¯ä¸€ä¸ªå€¼éåŽ†ã€‚12345678910111213public class Solution &#123; public int maxProfit(int[] prices) &#123; int minprice = Integer.MAX_VALUE; int maxprofit = 0; for(int i=0; i&lt;prices.length; i++)&#123; if(prices[i]&lt;minprice) minprice = prices[i]; else if(prices[i] - minprice &gt; maxprofit) maxprofit = prices[i] - minprice; &#125; return maxprofit; &#125;&#125; my code: 1234567891011121314public class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices.length&lt;=1) return 0; int valley=prices[0]; int maxprofit = 0; for(int i=1; i&lt;prices.length; i++)&#123; if(prices[i-1]&gt;prices[i]) valley = Math.min(valley, prices[i]); else if(prices[i]-valley&gt;maxprofit) maxprofit = prices[i]-valley; &#125; return maxprofit; &#125;&#125; https://discuss.leetcode.com/topic/19853/kadane-s-algorithm-since-no-one-has-mentioned-about-this-so-far-in-case-if-interviewer-twists-the-input The logic to solve this problem is same as â€œmax subarray problemâ€ using Kadaneâ€™s Algorithm. Since no body has mentioned this so far, I thought itâ€™s a good thing for everybody to know. All the straight forward solution should work, but if the interviewer twists the question slightly by giving the difference array of prices, Ex: for {1, 7, 4, 11}, if he gives {0, 6, -3, 7}, you might end up being confused. Here, the logic is to calculate the difference (maxCur += prices[i] - prices[i-1]) of the original array, and find a contiguous subarray giving maximum profit. If the difference falls below 0, reset it to zero. maxCur = current maximum value maxSoFar = maximum value found so far 12345678public int maxProfit(int[] prices) &#123; int maxCur = 0, maxSoFar = 0; for(int i = 1; i &lt; prices.length; i++) &#123; maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]); maxSoFar = Math.max(maxCur, maxSoFar); &#125; return maxSoFar;&#125; https://discuss.leetcode.com/topic/19853/kadane-s-algorithm-since-no-one-has-mentioned-about-this-so-far-in-case-if-interviewer-twists-the-input/2 Please refer to this for more details on the algorithm : https://en.wikipedia.org/wiki/Maximum_subarray_problem]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[120. Triangle]]></title>
    <url>%2Fp%2F9545f0d7%2F</url>
    <content type="text"><![CDATA[32.8% https://leetcode.com/problems/triangle/?tab=Description Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. 12345678For example, given the following triangle[ [2], [3,4], [6,5,7], [4,1,8,3]]The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note:Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. C++ top-down and bottom-up solutions æ–¹æ³•ä¸€ï¼š top down 1234567891011121314// top-down int minimumTotal1(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; res(triangle.size(), triangle[0][0]); for (unsigned int i = 1; i &lt; triangle.size(); i++) for (int j = i; j &gt;= 0; j--) &#123; if (j == 0) res[0] += triangle[i][j]; else if (j == i) res[j] = triangle[i][j] + res[j-1]; else res[j] = triangle[i][j] + min(res[j-1], res[j]); &#125; return *min_element(res.begin(), res.end());&#125; æ–¹æ³•äºŒï¼š bottom up æˆ‘çš„ä»£ç å®žçŽ°: Oct 17, 2017 123456789101112class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int n = triangle.size(); if(n==0) return 0; for(int i=n-2; i&gt;=0; i--)&#123; for(int j=0; j&lt;triangle[i].size(); j++) triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]); &#125; return triangle[0][0]; &#125;&#125;; 12345678// bottom-upint minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; res = triangle.back(); for (int i = triangle.size()-2; i &gt;= 0; i--) for (unsigned int j = 0; j &lt;= i; j++) res[j] = triangle[i][j] + min(res[j], res[j+1]); return res[0];&#125; cpp https://discuss.leetcode.com/topic/1669/dp-solution-for-triangle DP Solution for Triangle This problem is quite well-formed in my opinion. The triangle has a tree-like structure, which would lead people to think about traversal algorithms such as DFS. However, if you look closely, you would notice that the adjacent nodes always share a â€˜branchâ€™. In other word, there are overlapping subproblems. Also, suppose x and y are â€˜childrenâ€™ of k. Once minimum paths from x and y to the bottom are known, the minimum path starting from k can be decided in O(1), that is optimal substructure. Therefore, dynamic programming would be the best solution to this problem in terms of time complexity. What I like about this problem even more is that the difference between â€˜top-downâ€™ and â€˜bottom-upâ€™ DP can be â€˜literallyâ€™ pictured in the input triangle. For â€˜top-downâ€™ DP, starting from the node on the very top, we recursively find the minimum path sum of each node. When a path sum is calculated, we store it in an array (memoization); the next time we need to calculate the path sum of the same node, just retrieve it from the array. However, you will need a cache that is at least the same size as the input triangle itself to store the pathsum, which takes O(N^2) space. With some clever thinking, it might be possible to release some of the memory that will never be used after a particular point, but the order of the nodes being processed is not straightforwardly seen in a recursive solution, so deciding which part of the cache to discard can be a hard job. â€˜Bottom-upâ€™ DP, on the other hand, is very straightforward: we start from the nodes on the bottom row; the min pathsums for these nodes are the values of the nodes themselves. From there, the min pathsum at the ith node on the kth row would be the lesser of the pathsums of its two children plus the value of itself, i.e.: 1minpath[k][i] = min( minpath[k+1][i], minpath[k+1][i+1]) + triangle[k][i]; Or even better, since the row minpath[k+1] would be useless after minpath[k] is computed, we can simply set minpath as a 1D array, and iteratively update itself: 12For the kth level:minpath[i] = min( minpath[i], minpath[i+1]) + triangle[k][i]; Thus, we have the following solution 12345678910111213int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) &#123; int n = triangle.size(); vector&lt;int&gt; minlen(triangle.back()); for (int layer = n-2; layer &gt;= 0; layer--) // For each layer &#123; for (int i = 0; i &lt;= layer; i++) // Check its every &apos;node&apos; &#123; // Find the lesser of its two children, and sum the current value in the triangle with it. minlen[i] = min(minlen[i], minlen[i+1]) + triangle[layer][i]; &#125; &#125; return minlen[0];&#125; https://discuss.leetcode.com/topic/6671/bottom-up-5-line-c-solution Bottom Up 5 line C++ Solution 1234567891011class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) &#123; vector&lt;int&gt; mini = triangle[triangle.size()-1]; for ( int i = triangle.size() - 2; i&gt;= 0 ; --i ) for ( int j = 0; j &lt; triangle[i].size() ; ++ j ) mini[j] = triangle[i][j] + min(mini[j],mini[j+1]); return mini[0]; &#125;&#125;; https://discuss.leetcode.com/topic/29834/c-top-down-and-bottom-up-solutions C++ top-down and bottom-up solutions 1234567891011121314// top-down int minimumTotal1(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; res(triangle.size(), triangle[0][0]); for (unsigned int i = 1; i &lt; triangle.size(); i++) for (int j = i; j &gt;= 0; j--) &#123; if (j == 0) res[0] += triangle[i][j]; else if (j == i) res[j] = triangle[i][j] + res[j-1]; else res[j] = triangle[i][j] + min(res[j-1], res[j]); &#125; return *min_element(res.begin(), res.end());&#125; 12345678// bottom-upint minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; res = triangle.back(); for (int i = triangle.size()-2; i &gt;= 0; i--) for (unsigned int j = 0; j &lt;= i; j++) res[j] = triangle[i][j] + min(res[j], res[j+1]); return res[0];&#125; https://discuss.leetcode.com/topic/19834/my-c-code-bottom-up-dp-8ms My C++ code (Bottom up DP, 8ms) Just do bottom up DP, it is easier and cleaner than top-down DP. 12345678910class Solution &#123; public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; for(int i= triangle.size()-2; i&gt;=0; --i) for(int j=0; j&lt;triangle[i].size();++j) triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1]); return triangle[0][0]; &#125; &#125;; 123456789101112// another version, without modifying the input arrayclass Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; res(triangle[triangle.size()-1]); for(int i= triangle.size()-2; i&gt;=0; --i) for(int j=0; j&lt;triangle[i].size();++j) res[j] = triangle[i][j] + min(res[j],res[j+1]); return res[0]; &#125;&#125;; my code: 12345678910111213141516171819class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; if(triangle.size()==0) return 0; if(triangle.size()==1) return triangle[0][0]; for(int i=1; i&lt;triangle.size(); i++)&#123; for(int j=0; j&lt;triangle[i].size(); j++)&#123; if(j==0) triangle[i][j] += triangle[i-1][j]; else if(j==triangle[i].size()-1) triangle[i][j] += triangle[i-1][j-1]; else triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j]); &#125; &#125; int res = triangle[triangle.size()-1][0]; for(auto num:triangle[triangle.size()-1])&#123; res = min(res, num); &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/19754/python-easy-to-understand-solutions-top-down-bottom-up Python easy to understand solutions (top-down, bottom-up). 123456789101112131415# O(n*n/2) space, top-down def minimumTotal1(self, triangle): if not triangle: return res = [[0 for i in xrange(len(row))] for row in triangle] res[0][0] = triangle[0][0] for i in xrange(1, len(triangle)): for j in xrange(len(triangle[i])): if j == 0: res[i][j] = res[i-1][j] + triangle[i][j] elif j == len(triangle[i])-1: res[i][j] = res[i-1][j-1] + triangle[i][j] else: res[i][j] = min(res[i-1][j-1], res[i-1][j]) + triangle[i][j] return min(res[-1]) 12345678910111213# Modify the original triangle, top-downdef minimumTotal2(self, triangle): if not triangle: return for i in xrange(1, len(triangle)): for j in xrange(len(triangle[i])): if j == 0: triangle[i][j] += triangle[i-1][j] elif j == len(triangle[i])-1: triangle[i][j] += triangle[i-1][j-1] else: triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j]) return min(triangle[-1]) 12345678# Modify the original triangle, bottom-updef minimumTotal3(self, triangle): if not triangle: return for i in xrange(len(triangle)-2, -1, -1): for j in xrange(len(triangle[i])): triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]) return triangle[0][0] 123456789# bottom-up, O(n) spacedef minimumTotal(self, triangle): if not triangle: return res = triangle[-1] for i in xrange(len(triangle)-2, -1, -1): for j in xrange(len(triangle[i])): res[j] = min(res[j], res[j+1]) + triangle[i][j] return res[0] https://discuss.leetcode.com/topic/13970/one-liner-in-python One-liner in Python Solution 12def minimumTotal(self, t): return reduce(lambda a,b:[f+min(d,e)for d,e,f in zip(a,a[1:],b)],t[::-1])[0] Explanation Starting with the bottom row, I move upwards, always combining the current row and the next upper row. At the end, I have combined everything into the top row and simply return its only element. Hereâ€™s a longer version with meaningful variable names: 123456def minimumTotal(self, triangle): def combine_rows(lower_row, upper_row): return [upper + min(lower_left, lower_right) for upper, lower_left, lower_right in zip(upper_row, lower_row, lower_row[1:])] return reduce(combine_rows, triangle[::-1])[0] Solution mine: 60ms, 57.14%, June.22th, 2016 1234567891011121314class Solution(object): def minimumTotal(self, triangle): &quot;&quot;&quot; :type triangle: List[List[int]] :rtype: int &quot;&quot;&quot; if not triangle: return 0 for i in xrange(1, len(triangle)): triangle[i][0] += triangle[i-1][0] triangle[i][-1] += triangle[i-1][-1] for j in xrange(1, i): triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j]) return min(triangle[-1]) java https://discuss.leetcode.com/topic/8077/my-8-line-dp-java-code-4-meaningful-lines-with-o-1-space My 8 line DP Java code(4 meaningful lines) with O(1) space 12345678public class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; for(int i = triangle.size() - 2; i &gt;= 0; i--) for(int j = 0; j &lt;= i; j++) triangle.get(i).set(j, triangle.get(i).get(j) + Math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1))); return triangle.get(0).get(0); &#125;&#125; The idea is simple. Go from bottom to top. We start form the row above the bottom row [size()-2]. Each number add the smaller number of two numbers that below it. And finally we get to the top we the smallest sum. https://discuss.leetcode.com/topic/22254/7-lines-neat-java-solution 7 lines neat Java Solution 123456789public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int[] A = new int[triangle.size()+1]; for(int i=triangle.size()-1;i&gt;=0;i--)&#123; for(int j=0;j&lt;triangle.get(i).size();j++)&#123; A[j] = Math.min(A[j],A[j+1])+triangle.get(i).get(j); &#125; &#125; return A[0];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[119. Pascal's Triangle II]]></title>
    <url>%2Fp%2Ffb36f4c4%2F</url>
    <content type="text"><![CDATA[35.5% https://leetcode.com/problems/pascals-triangle-ii/?tab=Description Given an index k, return the kth row of the Pascalâ€™s triangle. 12For example, given k = 3,Return [1,3,3,1]. Note: Could you optimize your algorithm to use only O(k) extra space? æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 17, 2017 12345678910class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; res(rowIndex+1, 1); for(int i=2; i&lt;=rowIndex; i++) for(int j=i-1; j&gt;0; j--) res[j] = res[j] + res[j-1]; return res; &#125;&#125;; 1234567891011class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; A(rowIndex+1, 0); A[0] = 1; for(int i=1; i&lt;rowIndex+1; i++) for(int j=i; j&gt;=1; j--) A[j] += A[j-1]; return A; &#125;&#125;; my code: æ ¹æ®è§„åˆ™ï¼ŒåŒæ—¶ä»ŽåŽå‘å‰åŠ ï¼Œå°±å®Œæˆäº†ã€‚ 12345678910111213class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; res(rowIndex+1, 0); res[0] = 1; for(int i=0; i&lt;rowIndex; i++)&#123; for(int j=i+1; j&gt;0; j--)&#123; res[j] += res[j-1]; &#125; &#125; return res; &#125;&#125;; java 3ms, 23.13%, June.21th, 2016 https://leetcode.com/discuss/40144/my-8-lines-java-solution-use-arraylist 123456789101112public class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); for(int i = 0;i&lt;rowIndex+1;i++) &#123; res.add(1); for(int j=i-1;j&gt;0;j--) &#123; res.set(j, res.get(j-1)+res.get(j)); &#125; &#125; return res; &#125;&#125; cpp 0ms, 21.63%, June.21th, 2016 https://leetcode.com/discuss/8364/here-is-my-brief-o-k-solution 1234567891011class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; A(rowIndex+1, 0); A[0] = 1; for(int i=1; i&lt;rowIndex+1; i++) for(int j=i; j&gt;=1; j--) A[j] += A[j-1]; return A; &#125;&#125;; my code: æ ¹æ®è§„åˆ™ï¼ŒåŒæ—¶ä»ŽåŽå‘å‰åŠ ï¼Œå°±å®Œæˆäº†ã€‚ 12345678910111213class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; res(rowIndex+1, 0); res[0] = 1; for(int i=0; i&lt;rowIndex; i++)&#123; for(int j=i+1; j&gt;0; j--)&#123; res[j] += res[j-1]; &#125; &#125; return res; &#125;&#125;; python Solution 1: 40ms, 94.22%, June.21th, 2016 https://leetcode.com/discuss/38977/very-simple-python-solution 12345678910class Solution(object): def getRow(self, rowIndex): &quot;&quot;&quot; :type rowIndex: int :rtype: List[int] &quot;&quot;&quot; row = [1] for i in range(1, rowIndex+1): row = list(map(lambda x, y: x+y, [0]+row, row +[0])) return row]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[118. Pascal's Triangle]]></title>
    <url>%2Fp%2Fe2b46218%2F</url>
    <content type="text"><![CDATA[37.2% https://leetcode.com/problems/pascals-triangle/ Given numRows, generate the first numRows of Pascalâ€™s triangle. 12345678910For example, given numRows = 5,Return[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š October 17ï¼Œ 2017 1234567891011121314class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; if(numRows==0) return vector&lt;vector&lt;int&gt;&gt;(); vector&lt;vector&lt;int&gt;&gt; res(numRows, vector&lt;int&gt;(1, 1)); for(int i=2; i&lt;=numRows; i++)&#123; res[i-1].resize(i); res[i-1][0] = res[i-1][i-1] = 1; for(int j=0; j&lt;i-2; j++) res[i-1][j+1] = res[i-2][j] + res[i-2][j+1]; &#125; return res; &#125;&#125;; resizeè¿™ä¸ªå‡½æ•°å¥½ç”¨ï¼ŒåŒæ—¶æƒ³æ˜Žç™½é€»è¾‘r[i][j] = r[i-1][j-1] + r[i-1][j]ï¼Œå°±å¯ä»¥å®žçŽ°äº†ã€‚ 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; r(numRows); for(int i = 0; i&lt;numRows; i++)&#123; r[i].resize(i+1); r[i][0] = r[i][i] = 1; for(int j=1; j&lt;i; j++) r[i][j] = r[i-1][j-1] + r[i-1][j]; &#125; return r; &#125;&#125;; 2ms, 3.04%, June.21th, 2016 https://leetcode.com/discuss/20606/my-concise-solution-in-java 12345678910111213141516public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; allrows = new ArrayList&lt;List&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; row = new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;numRows;i++) &#123; row.add(0, 1); for(int j=1;j&lt;row.size()-1;j++) row.set(j, row.get(j)+row.get(j+1)); allrows.add(new ArrayList&lt;Integer&gt;(row)); &#125; return allrows; &#125;&#125; 0ms, 26.23%, June.21th, 2016 https://leetcode.com/discuss/13921/maybe-shortest-c-solution resizeè¿™ä¸ªå‡½æ•°å¥½ç”¨ï¼ŒåŒæ—¶æƒ³æ˜Žç™½é€»è¾‘r[i][j] = r[i-1][j-1] + r[i-1][j]ï¼Œå°±å¯ä»¥å®žçŽ°äº†ã€‚ 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; r(numRows); for(int i = 0; i&lt;numRows; i++)&#123; r[i].resize(i+1); r[i][0] = r[i][i] = 1; for(int j=1; j&lt;i; j++) r[i][j] = r[i-1][j-1] + r[i-1][j]; &#125; return r; &#125;&#125;; 68ms, 9.44%, June.21th, 2016 https://leetcode.com/discuss/54525/python-4-lines-short-solution-using-map 123456789101112class Solution(object): def generate(self, numRows): &quot;&quot;&quot; :type numRows: int :rtype: List[List[int]] &quot;&quot;&quot; if numRows == 0: return [] res = [[1]] for i in range(1, numRows): res += [map(lambda x, y:x+y, res[-1] + [0], [0] + res[-1])] return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[117. Populating Next Right Pointers in Each Node II]]></title>
    <url>%2Fp%2Fb4ed2826%2F</url>
    <content type="text"><![CDATA[38.6% https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/#/description Follow up for problem â€œPopulating Next Right Pointers in Each Nodeâ€. What if the given tree could be any binary tree? Would your previous solution still work? Note: You may only use constant extra space. 12345678910111213For example,Given the following binary tree, 1 / \ 2 3 / \ \ 4 5 7After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ \ 4-&gt; 5 -&gt; 7 -&gt; NULL æ–¹æ³•ä¸€ï¼š Simple 40ms c++ o(n) ,o(1) solution with only one while loop Thanks for liji94188 for adding the explanation: Itâ€™s a BFS traversal. now pointer is the current level traveler and head is the left most element at next level and the tail is the right most element at next level till now. We move now pointer at current level and populate the the next-link at its children level. (Here the gist is we can move now to its next because this relationship was already populated in the previous round). ä¸‰ä¸ªæŒ‡é’ˆï¼ŒnowæŒ‡å‘å½“å‰ä½ç½®ï¼Œé’ˆå¯¹nowçš„ä¸‹ä¸€å±‚è¿›è¡Œåšè¿ç®—ï¼Œå…¶ä¸­ï¼ŒheadæŒ‡é’ˆæŒ‡å‘nowä¸‹ä¸€ä½çš„é¦–ä½ï¼ŒtailæŒ‡é’ˆä»Žheadå¼€å§‹ç§»åŠ¨ï¼Œåœ¨ç§»åŠ¨ä¸­å®Œæˆäº†é“¾æŽ¥æ“ä½œï¼Œæœ€ç»ˆç§»åŠ¨è‡³nowä¸‹ä¸€å±‚çš„å°¾éƒ¨ã€‚ç„¶åŽå°†nowæŒ‡å‘headï¼Œheadå’Œtailç½®NULLã€‚ 1234567891011121314151617181920void connect(TreeLinkNode *root) &#123; TreeLinkNode *now, *tail, *head; now = root; head = tail = NULL; while(now) &#123; if (now-&gt;left) if (tail) tail = tail-&gt;next =now-&gt;left; else head = tail = now-&gt;left; if (now-&gt;right) if (tail) tail = tail-&gt;next =now-&gt;right; else head = tail = now-&gt;right; if(!(now = now-&gt;next)) &#123; now = head; head = tail=NULL; &#125; &#125;&#125; æˆ‘è‡ªå·±çš„å®žçŽ°ï¼Œè·Ÿä¸Šé¢ä»£ç æ˜¯ä¸€æ ·çš„ï¼Œåˆ†å¼€å†™ï¼Œæ›´å®¹æ˜“ç†è§£ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(root==NULL) return; TreeLinkNode* now=root, *head=NULL, *tail=NULL; while(now)&#123; if(now-&gt;left)&#123; if(tail)&#123; tail-&gt;next = now-&gt;left; tail = tail-&gt;next; &#125;else&#123; tail = now-&gt;left; head = tail; &#125; &#125; if(now-&gt;right)&#123; if(tail)&#123; tail-&gt;next = now-&gt;right; tail = tail-&gt;next; &#125;else&#123; tail = now-&gt;right; head = tail; &#125; &#125; now = now-&gt;next; if(!now)&#123; now = head; head = NULL; tail = NULL; &#125; &#125; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°: 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return; TreeLinkNode* now = root, *head = NULL, *tail=NULL; while(now)&#123; if(now-&gt;left)&#123; if(!tail)&#123; head = now-&gt;left; tail = head; &#125;else&#123; tail-&gt;next = now-&gt;left; tail = tail-&gt;next; &#125; &#125; if(now-&gt;right)&#123; if(!tail)&#123; head = now-&gt;right; tail = head; &#125;else&#123; tail-&gt;next = now-&gt;right; tail = tail-&gt;next; &#125; &#125; now = now-&gt;next; if(!now)&#123; now = head; head = NULL; tail = NULL; &#125; &#125; &#125;&#125;; æ–¹æ³•äºŒï¼š ä½¿ç”¨å±‚åºéåŽ†ï¼Œqueue 123456789101112131415161718192021222324252627282930313233/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return; queue&lt;TreeLinkNode*&gt; que; if(root-&gt;left) que.push(root-&gt;left); if(root-&gt;right) que.push(root-&gt;right); while(que.size()&gt;0)&#123; int n = que.size(); TreeLinkNode* lastNode = que.front(); que.pop(); if(lastNode-&gt;left) que.push(lastNode-&gt;left); if(lastNode-&gt;right) que.push(lastNode-&gt;right); for(int i=1; i&lt;n; i++)&#123; TreeLinkNode* cur = que.front(); lastNode-&gt;next = cur; que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); lastNode = cur; &#125; &#125; return; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°: 12345678910111213141516171819202122232425262728293031323334/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return; // ç”¨é˜Ÿåˆ—è¿˜æ˜¯æ ˆï¼Œè¦ä»”ç»†æ€è€ƒï¼Œè¿™é‡Œä½¿ç”¨é˜Ÿåˆ— queue&lt;TreeLinkNode*&gt; que; que.push(root); while(que.size())&#123; int n = que.size(); TreeLinkNode* pre = que.front(); que.pop(); if(pre-&gt;left) que.push(pre-&gt;left); if(pre-&gt;right) que.push(pre-&gt;right); for(int i=1; i&lt;n; i++)&#123; TreeLinkNode* cur = que.front(); que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); pre-&gt;next = cur; pre = cur; &#125; &#125; return; &#125;&#125;; https://discuss.leetcode.com/topic/18119/simple-40ms-c-o-n-o-1-solution-with-only-one-while-loop Simple 40ms c++ o(n) ,o(1) solution with only one while loop Thanks for liji94188 for adding the explanation: Itâ€™s a BFS traversal. now pointer is the current level traveler and head is the left most element at next level and the tail is the right most element at next level till now. We move now pointer at current level and populate the the next-link at its children level. (Here the gist is we can move now to its next because this relationship was already populated in the previous round). ä¸‰ä¸ªæŒ‡é’ˆï¼ŒnowæŒ‡å‘å½“å‰ä½ç½®ï¼Œé’ˆå¯¹nowçš„ä¸‹ä¸€å±‚è¿›è¡Œåšè¿ç®—ï¼Œå…¶ä¸­ï¼ŒheadæŒ‡é’ˆæŒ‡å‘nowä¸‹ä¸€ä½çš„é¦–ä½ï¼ŒtailæŒ‡é’ˆä»Žheadå¼€å§‹ç§»åŠ¨ï¼Œåœ¨ç§»åŠ¨ä¸­å®Œæˆäº†é“¾æŽ¥æ“ä½œï¼Œæœ€ç»ˆç§»åŠ¨è‡³nowä¸‹ä¸€å±‚çš„å°¾éƒ¨ã€‚ç„¶åŽå°†nowæŒ‡å‘headï¼Œheadå’Œtailç½®NULLã€‚ 1234567891011121314151617181920void connect(TreeLinkNode *root) &#123; TreeLinkNode *now, *tail, *head; now = root; head = tail = NULL; while(now) &#123; if (now-&gt;left) if (tail) tail = tail-&gt;next =now-&gt;left; else head = tail = now-&gt;left; if (now-&gt;right) if (tail) tail = tail-&gt;next =now-&gt;right; else head = tail = now-&gt;right; if(!(now = now-&gt;next)) &#123; now = head; head = tail=NULL; &#125; &#125;&#125; https://discuss.leetcode.com/topic/9735/just-convert-common-bfs-solution-to-o-1-space-a-simple-python-code Just convert common BFS solution to O(1) space, a simple python code common BFS 12345678910111213141516class Solution:# @param root, a tree link node# @return nothingdef connect(self, root): if not root: return queue, level = collections.deque([root]), collections.deque() while queue: node = queue.popleft() if node.left: level.append(node.left) if node.right: level.append(node.right) node.next = queue[0] if queue else None if not queue and level: queue, level = level, queue O(1) space 123456789101112131415161718192021class Solution:# @param root, a tree link node# @return nothingdef connect(self, root): queue, level, curr = root, None, None while queue: if queue.left: if not level: level = curr = queue.left else: curr.next = queue.left curr = curr.next if queue.right: if not level: level = curr = queue.right else: curr.next = queue.right curr = curr.next queue = queue.next if not queue and level: queue, level, curr = level, None, None Use a fake head can save a few lines https://discuss.leetcode.com/topic/27792/ac-python-o-1-space-solution-12-lines-and-easy-to-understand AC Python O(1) space solution 12 lines and easy to understand The algorithm is a BFS or level order traversal. We go through the tree level by level. node is the pointer in the parent level, tail is the tail pointer in the child level.The parent level can be view as a singly linked list or queue, which we can traversal easily with a pointer.Connect the tail with every one of the possible nodes in child level, update it only if the connected node is not nil.Do this one level by one level. The whole thing is quite straightforward. Python 12345678910111213141516171819def connect(self, node): tail = dummy = TreeLinkNode(0) while node: tail.next = node.left if tail.next: tail = tail.next tail.next = node.right if tail.next: tail = tail.next node = node.next if not node: tail = dummy node = dummy.next# 61 / 61 test cases passed.# Status: Accepted# Runtime: 100 ms# 95.26% https://discuss.leetcode.com/topic/1106/o-1-space-o-n-complexity-iterative-solution O(1) space O(n) complexity Iterative Solution Just share my iterative solution with O(1) space and O(n) Time complexity 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; //based on level order traversal public void connect(TreeLinkNode root) &#123; TreeLinkNode head = null; //head of the next level TreeLinkNode prev = null; //the leading node on the next level TreeLinkNode cur = root; //current node of current level while (cur != null) &#123; while (cur != null) &#123; //iterate on the current level //left child if (cur.left != null) &#123; if (prev != null) &#123; prev.next = cur.left; &#125; else &#123; head = cur.left; &#125; prev = cur.left; &#125; //right child if (cur.right != null) &#123; if (prev != null) &#123; prev.next = cur.right; &#125; else &#123; head = cur.right; &#125; prev = cur.right; &#125; //move to next node cur = cur.next; &#125; //move to next level cur = head; head = null; prev = null; &#125; &#125;&#125; https://discuss.leetcode.com/topic/8447/simple-solution-using-constant-space Simple solution using constant space The idea is simple: level-order traversal. You can see the following code: 123456789101112131415public class Solution &#123; public void connect(TreeLinkNode root) &#123; while(root != null)&#123; TreeLinkNode tempChild = new TreeLinkNode(0); TreeLinkNode currentChild = tempChild; while(root!=null)&#123; if(root.left != null) &#123; currentChild.next = root.left; currentChild = currentChild.next;&#125; if(root.right != null) &#123; currentChild.next = root.right; currentChild = currentChild.next;&#125; root = root.next; &#125; root = tempChild.next; &#125; &#125;&#125; 1ms, 51.83%, September 25, 2016 https://discuss.leetcode.com/topic/8447/simple-solution-using-constant-space Java solution with constant space 1234567891011121314151617181920public void connect(TreeLinkNode root) &#123; TreeLinkNode dummyHead = new TreeLinkNode(0); TreeLinkNode pre = dummyHead; while (root != null) &#123; if (root.left != null) &#123; pre.next = root.left; pre = pre.next; &#125; if (root.right != null) &#123; pre.next = root.right; pre = pre.next; &#125; root = root.next; if (root == null) &#123; pre = dummyHead; root = dummyHead.next; dummyHead.next = null; &#125; &#125;&#125; https://discuss.leetcode.com/topic/36615/o-1-concise-fast-what-s-so-hard O(1). Concise. Fast. Whatâ€™s so hard? This is definitely medium, not hard. Took me about 5 minutes, and some medium problems took me a few hours! Since you have to walk the tree in BFS order and youâ€™re given extra references to help you do just that, itâ€™s intuitive, itâ€™s simple and itâ€™s fast. The first level (root) is connected already, so you connect the next level and then you just walk through the linked list youâ€™ve just created and so on. 12345678910111213141516public void connect(TreeLinkNode root) &#123; for (TreeLinkNode head = root; head != null; ) &#123; TreeLinkNode nextHead = new TreeLinkNode(0), nextTail = nextHead; for (TreeLinkNode node = head; node != null; node = node.next) &#123; if (node.left != null) &#123; nextTail.next = node.left; nextTail = node.left; &#125; if (node.right != null) &#123; nextTail.next = node.right; nextTail = node.right; &#125; &#125; head = nextHead.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[116. Populating Next Right Pointers in Each Node]]></title>
    <url>%2Fp%2F6168139a%2F</url>
    <content type="text"><![CDATA[36.9% https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ 1234567891011Given a binary tree struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; &#125;Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.Initially, all next pointers are set to NULL. Note: You may only use constant extra space. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children). 1234567891011121314For example,Given the following perfect binary tree, 1 / \ 2 3 / \ / \ 4 5 6 7After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \ 4-&gt;5-&gt;6-&gt;7 -&gt; NULL 24ms Easy Iterative and Recursive C++ Solutions æ–¹æ³•ä¸€ï¼š The idea is similar to a level-order traversal and remember to take full advantages of the prefect binary tree assumption in the problem statement. The code (iterative solution) is as follows. 1234567891011121314151617class Solution &#123;public: void connect(TreeLinkNode *root) &#123; TreeLinkNode* pre = root; TreeLinkNode* cur = NULL; while (pre) &#123; cur = pre; while (cur &amp;&amp; cur -&gt; left) &#123; cur -&gt; left -&gt; next = cur -&gt; right; if (cur -&gt; next) cur -&gt; right -&gt; next = cur -&gt; next -&gt; left; cur = cur -&gt; next; &#125; pre = pre -&gt; left; &#125; &#125; &#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526272829303132/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return; // æŽ’é™¤åªæœ‰ä¸€ä¸ªrootèŠ‚ç‚¹çš„æƒ…å†µï¼Œå‹¿å¿˜ TreeLinkNode* curhead = root; TreeLinkNode* nexhead = root-&gt;left; TreeLinkNode *tail = nexhead; while(nexhead)&#123; tail-&gt;next = curhead-&gt;right; tail = tail-&gt;next; while(curhead-&gt;next)&#123; curhead = curhead-&gt;next; tail-&gt;next = curhead-&gt;left; tail = tail-&gt;next; tail-&gt;next = curhead-&gt;right; tail = tail-&gt;next; &#125; curhead = nexhead; nexhead = nexhead-&gt;left; tail = nexhead; &#125; return; &#125;&#125;; æ–¹æ³•äºŒï¼š This problem can also be solved recursively. 12345678910111213class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (!root) return; if (root -&gt; left) &#123; root -&gt; left -&gt; next = root -&gt; right; if (root -&gt; next) root -&gt; right -&gt; next = root -&gt; next -&gt; left; &#125; connect(root -&gt; left); connect(root -&gt; right); &#125;&#125;; æ–¹æ³•ä¸‰ï¼š å±‚åºéåŽ†çš„æ–¹æ³• 1234567891011121314151617181920212223242526272829303132/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return; queue&lt;TreeLinkNode*&gt; que; que.push(root); while(que.size()&gt;0)&#123; int n = que.size(); TreeLinkNode* lastNode = que.front(); que.pop(); if(lastNode-&gt;left) que.push(lastNode-&gt;left); if(lastNode-&gt;right) que.push(lastNode-&gt;right); for(int i=1; i&lt;n; i++)&#123; TreeLinkNode* cur = que.front(); que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); lastNode-&gt;next = cur; lastNode = cur; &#125; &#125; return; &#125;&#125;; https://discuss.leetcode.com/topic/1214/hint-for-o-1-space Hint for O(1) space If you donâ€™t want a solution for O(1) space but just a hint, here it is: you need to make use of the next links that youâ€™re creating. https://discuss.leetcode.com/topic/671/you-may-only-use-constant-extra-space-so-does-it-mean-we-cannot-use-recursion â€œYou may only use constant extra space.â€ - So does it mean we cannot use recursion? Does anyone have an iteration method with constant space solution? https://discuss.leetcode.com/topic/671/you-may-only-use-constant-extra-space-so-does-it-mean-we-cannot-use-recursion/2 Here is solution from old discuss by skaugust. Thanks to skaugust! Iâ€™m confused why people are trying to use recursive solutions here. The problem states that you can only use constant space. To get to the leaf nodes, a recursive solution needs to be log2(n) calls deep, and each call has a call stack, which takes up memory. This means that a recursive solution isnâ€™t constant memory, but O(log(n)) memory. To solve this, you just replace the recursive call with a while loop wrapping all of your logic. 1234567891011121314151617181920212223/* Go through parent level by its next pointer to generate children level next pointer */public class Solution &#123; public void connect(TreeLinkNode root) &#123; TreeLinkNode leftWall = root; while (leftWall != null) &#123; TreeLinkNode across = leftWall; while (across != null) &#123; if (across.left != null) &#123; across.left.next = across.right; &#125; if (across.right != null &amp;&amp; across.next != null) &#123; across.right.next = across.next.left; &#125; across = across.next; &#125; leftWall = leftWall.left; &#125; &#125;&#125; 19ms, 80.75%, September 25, 2016 https://discuss.leetcode.com/topic/2202/a-simple-accepted-solution A simple accepted solution å¦‚æžœpre-&gt;left ä¸ºç©ºæ€Žä¹ˆåŠžï¼Ÿé¢˜ç›®å‡è®¾çš„æ˜¯æ‰€æœ‰éƒ½æœ‰å·¦å³å­æ ‘ 12345678910111213141516171819202122232425/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(root==NULL) return; TreeLinkNode* pre = root; TreeLinkNode* cur = NULL; while(pre-&gt;left)&#123; cur = pre; while(cur)&#123; cur-&gt;left-&gt;next = cur-&gt;right; if(cur-&gt;next) cur-&gt;right-&gt;next = cur-&gt;next-&gt;left; cur = cur-&gt;next; &#125; pre = pre-&gt;left; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/9579/my-simple-non-iterative-c-code-with-o-1-memory My simple non-iterative C++ code with O(1) memory 12345678910111213141516void connect(TreeLinkNode *root) &#123; if(!root) return; while(root -&gt; left) &#123; TreeLinkNode *p = root; while(p) &#123; p -&gt; left -&gt; next = p -&gt; right; if(p -&gt; next) p -&gt; right -&gt; next = p -&gt; next -&gt; left; p = p -&gt; next; &#125; root = root -&gt; left; &#125;&#125; https://discuss.leetcode.com/topic/16547/7-lines-iterative-real-o-1-space 7 lines, iterative, real O(1) space Simply do it level by level, using the next-pointers of the current level to go through the current level and set the next-pointers of the next level. I say â€œrealâ€ O(1) space because of the many recursive solutions ignoring that recursion management needs space. 12345678def connect(self, root): while root and root.left: next = root.left while root: root.left.next = root.right root.right.next = root.next and root.next.left root = root.next root = next https://discuss.leetcode.com/topic/18432/24ms-easy-iterative-and-recursive-c-solutions 24ms Easy Iterative and Recursive C++ Solutions The idea is similar to a level-order traversal and remember to take full advantages of the prefect binary tree assumption in the problem statement. The code (iterative solution) is as follows. 1234567891011121314151617class Solution &#123;public: void connect(TreeLinkNode *root) &#123; TreeLinkNode* pre = root; TreeLinkNode* cur = NULL; while (pre) &#123; cur = pre; while (cur &amp;&amp; cur -&gt; left) &#123; cur -&gt; left -&gt; next = cur -&gt; right; if (cur -&gt; next) cur -&gt; right -&gt; next = cur -&gt; next -&gt; left; cur = cur -&gt; next; &#125; pre = pre -&gt; left; &#125; &#125; &#125;; This problem can also be solved recursively. 12345678910111213class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (!root) return; if (root -&gt; left) &#123; root -&gt; left -&gt; next = root -&gt; right; if (root -&gt; next) root -&gt; right -&gt; next = root -&gt; next -&gt; left; &#125; connect(root -&gt; left); connect(root -&gt; right); &#125;&#125;; 1ms, 29.64%, September 25, 2016 https://discuss.leetcode.com/topic/6221/java-solution-with-o-1-memory-o-n-time Java solution with O(1) memory+ O(n) time 123456789101112131415public class Solution &#123; public void connect(TreeLinkNode root) &#123; TreeLinkNode level_start=root; while(level_start!=null)&#123; TreeLinkNode cur=level_start; while(cur!=null)&#123; if(cur.left!=null) cur.left.next=cur.right; if(cur.right!=null &amp;&amp; cur.next!=null) cur.right.next=cur.next.left; cur=cur.next; &#125; level_start=level_start.left; &#125; &#125;&#125; https://discuss.leetcode.com/topic/12241/my-recursive-solution-java My recursive solution(Java) 12345678910111213public void connect(TreeLinkNode root) &#123; if(root == null) return; if(root.left != null)&#123; root.left.next = root.right; if(root.next != null) root.right.next = root.next.left; &#125; connect(root.left); connect(root.right);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[115. Distinct Subsequences]]></title>
    <url>%2Fp%2F5eae1966%2F</url>
    <content type="text"><![CDATA[30.9% https://leetcode.com/problems/distinct-subsequences/?tab=Description Given a string S and a string T, count the number of distinct subsequences of T in S. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, â€œACEâ€ is a subsequence of â€œABCDEâ€ while â€œAECâ€ is not). 1234Here is an example:S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;Return 3. æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 17ï¼Œ 2017 123456789101112131415class Solution &#123;public: int numDistinct(string s, string t) &#123; int m = s.size(), n = t.size(); if(m&lt;n) return 0; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=0; i&lt;=m; i++)&#123; dp[i][0] = 1; &#125; for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) dp[i][j] = dp[i-1][j] + (s[i-1]==t[j-1]?dp[i-1][j-1]:0); return dp[m][n]; &#125;&#125;; 13ms, 55.07%, September 25, 2016 https://discuss.leetcode.com/topic/760/any-better-solution-that-takes-less-than-o-n-2-space-while-in-o-n-2-time Any better solution that takes less than O(n^2) space while in O(n^2) time? My solution is using O(n^2) space and running in O(n^2) time. I wonder is there a better way to do that which consumes less memory? I guess run time could not be improved though. Any thought/input would be highly appreciated, thanks! 123456789101112131415161718192021222324252627/** * Solution (DP): * We keep a m*n matrix and scanning through string S, while * m = T.length() + 1 and n = S.length() + 1 * and each cell in matrix Path[i][j] means the number of distinct subsequences of * T.substr(1...i) in S(1...j) * * Path[i][j] = Path[i][j-1] (discard S[j]) * + Path[i-1][j-1] (S[j] == T[i] and we are going to use S[j]) * or 0 (S[j] != T[i] so we could not use S[j]) * while Path[0][j] = 1 and Path[i][0] = 0. */int numDistinct(string S, string T) &#123; int m = T.length(); int n = S.length(); if (m &gt; n) return 0; // impossible for subsequence vector&lt;vector&lt;int&gt;&gt; path(m+1, vector&lt;int&gt;(n+1, 0)); for (int k = 0; k &lt;= n; k++) path[0][k] = 1; // initialization for (int j = 1; j &lt;= n; j++) &#123; for (int i = 1; i &lt;= m; i++) &#123; path[i][j] = path[i][j-1] + (T[i-1] == S[j-1] ? path[i-1][j-1] : 0); &#125; &#125; return path[m][n];&#125; my code: æžæ¸…æ¥šs tçš„åŒºåˆ«ï¼Œm nåˆ†åˆ«å¯¹åº”çš„å…³ç³»ï¼Œä¸è¦æžæ··äº†ã€‚ 12345678910111213141516171819class Solution &#123;public: int numDistinct(string s, string t) &#123; if(t.empty()) return 1; if(s.empty()) return 0; int m = t.size(); int n = s.size(); if(m&gt;n) return 0; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=0; i&lt;=n; i++) dp[0][i] = 1; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; dp[i+1][j+1] = dp[i+1][j] + (t[i]==s[j]?dp[i][j] : 0); &#125; &#125; return dp[m][n]; &#125;&#125;; æ–¹æ³•äºŒï¼š ä»Žä¸Šä¸€ç§æ–¹æ³•ä¸­ï¼Œå‘çŽ°éœ€è¦çš„ç©ºé—´å¤æ‚åº¦è¿˜æ˜¯å¯ä»¥é™ä½Žçš„ã€‚ https://discuss.leetcode.com/topic/19778/7-10-lines-c-solutions-with-detailed-explanations-o-m-n-time-and-o-m-space 7-10 lines C++ Solutions with Detailed Explanations (O(m*n) time and O(m) space) Well, a dynamic programming problem. Letâ€™s first define its state dp[i][j] to be the number of distinct subsequences of t[0..i - 1] in s[0..j - 1]. Then we have the following state equations: General case 1: dp[i][j] = dp[i][j - 1] if t[i - 1] != s[j - 1]; General case 2: dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1] if t[i - 1] == s[j - 1]; Boundary case 1: dp[0][j] = 1 for all j; Boundary case 2: dp[i][0] = 0 for all positive i. Now letâ€™s give brief explanations to the four equations above. If t[i - 1] != s[j - 1], the distinct subsequences will not include s[j - 1] and thus all the number of distinct subsequences will simply be those in s[0..j - 2], which corresponds to dp[i][j - 1]; If t[i - 1] == s[j - 1], the number of distinct subsequences include two parts: those with s[j - 1] and those without; An empty string will have exactly one subsequence in any string :-) Non-empty string will have no subsequences in an empty string. Putting these together, we will have the following simple codes (just like translation :-)): 123456789101112class Solution &#123;public: int numDistinct(string s, string t) &#123; int m = t.length(), n = s.length(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt; (n + 1, 0)); for (int j = 0; j &lt;= n; j++) dp[0][j] = 1; for (int j = 1; j &lt;= n; j++) for (int i = 1; i &lt;= m; i++) dp[i][j] = dp[i][j - 1] + (t[i - 1] == s[j - 1] ? dp[i - 1][j - 1] : 0); return dp[m][n]; &#125;&#125;; Notice that we keep the whole m*n matrix simply for dp[i - 1][j - 1]. So we can simply store that value in a single variable and further optimize the space complexity. The final code is as follows. 1234567891011121314151617class Solution &#123;public: int numDistinct(string s, string t) &#123; int m = t.length(), n = s.length(); vector&lt;int&gt; cur(m + 1, 0); cur[0] = 1; for (int j = 1; j &lt;= n; j++) &#123; int pre = 1; for (int i = 1; i &lt;= m; i++) &#123; int temp = cur[i]; cur[i] = cur[i] + (t[i - 1] == s[j - 1] ? pre : 0); pre = temp; &#125; &#125; return cur[m]; &#125;&#125;; java 16ms, 41.15%, September 25, 2016 https://discuss.leetcode.com/topic/9488/easy-to-understand-dp-in-java Easy to understand DP in Java The idea is the following: we will build an array mem where mem[i+1][j+1] means that S[0..j] contains T[0..i] that many times as distinct subsequences. Therefor the result will be mem[T.length()][S.length()]. we can build this array rows-by-rows: the first row must be filled with 1. Thatâ€™s because the empty string is a subsequence of any string but only 1 time. So mem[0][j] = 1 for every j. So with this we not only make our lives easier, but we also return correct value if T is an empty string. the first column of every rows except the first must be 0. This is because an empty string cannot contain a non-empty string as a substring â€“ the very first item of the array: mem[0][0] = 1, because an empty string contains the empty string 1 time. So the matrix looks like this: 12345678910test S 0123....jT +----------+ |1111111111|0 |0 |1 |0 |2 |0 |. |0 |. |0 |i |0 | From here we can easily fill the whole grid: for each (x, y), we check if S[x] == T[y] we add the previous item and the previous item in the previous row, otherwise we copy the previous item in the same row. The reason is simple: if the current character in S doesnâ€™t equal to current character T, then we have the same number of distinct subsequences as we had without the new character. if the current character in S equal to the current character T, then the distinct number of subsequences: the number we had before plus the distinct number of subsequences we had with less longer T and less longer S.An example: S: [acdabefbc] and T: [ab] first we check with a: 1234test * * S = [acdabefbc]mem[1] = [0111222222] then we check with ab: 12345test * * ] S = [acdabefbc]mem[1] = [0111222222]mem[2] = [0000022244] And the result is 4, as the distinct subsequences are: 12345test S = [a b ] S = [a b ] S = [ ab ] S = [ a b ] See the code in Java: 1234567891011121314151617181920212223public int numDistinct(String S, String T) &#123; // array creation int[][] mem = new int[T.length()+1][S.length()+1]; // filling the first row: with 1s for(int j=0; j&lt;=S.length(); j++) &#123; mem[0][j] = 1; &#125; // the first column is 0 by default in every other rows but the first, which we need. for(int i=0; i&lt;T.length(); i++) &#123; for(int j=0; j&lt;S.length(); j++) &#123; if(T.charAt(i) == S.charAt(j)) &#123; mem[i+1][j+1] = mem[i][j] + mem[i+1][j]; &#125; else &#123; mem[i+1][j+1] = mem[i+1][j]; &#125; &#125; &#125; return mem[T.length()][S.length()];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[114. Flatten Binary Tree to Linked List]]></title>
    <url>%2Fp%2Fad56aabd%2F</url>
    <content type="text"><![CDATA[34.1% https://leetcode.com/problems/flatten-binary-tree-to-linked-list/ Given a binary tree, flatten it to a linked list in-place. 12345678910111213141516171819202122For example,Given 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 Hints: If you notice carefully in the flattened tree, each nodeâ€™s right child points to the next node of a pre-order traversal. æ–¹æ³•ä¸€ï¼š é¢˜ç›®ä¸­è¦æ±‚è½¬æ¢ä¸ºé“¾è¡¨ï¼Œå®žé™…ä¸Šæ˜¯Treeï¼Œåªä¸è¿‡è¦æ±‚å·¦åˆ†æ”¯éƒ½ä¸º0ï¼Œå³åˆ†æ”¯ä¸²è”ã€‚ è¿­ä»£ å¯¹äºŽrootï¼Œ æŠŠrootçš„å³èŠ‚ç‚¹æŽ¥ä¸Šå³èŠ‚ç‚¹åœ¨å…ˆåºéåŽ†ä¸‹çš„å‰é©±èŠ‚ç‚¹ã€‚ç„¶åŽrootå³èŠ‚ç‚¹æŒ‡å‘å·¦èŠ‚ç‚¹ï¼Œå·¦èŠ‚ç‚¹è®¾ç½®ä¸ºç©ºï¼Œç„¶åŽrootæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚ä¾æ¬¡è¿­ä»£ã€‚ Share my simple NON-recursive solution, O(1) space complexity! 123456789101112131415161718192021222324class Solution &#123;public: void flatten(TreeNode *root) &#123; TreeNode*now = root; while (now) &#123; if(now-&gt;left) &#123; //Find current node&apos;s prenode that links to current node&apos;s right subtree TreeNode* pre = now-&gt;left; while(pre-&gt;right) &#123; pre = pre-&gt;right; &#125; pre-&gt;right = now-&gt;right; //Use current node&apos;s left subtree to replace its right subtree(original right //subtree is already linked by current node&apos;s prenode now-&gt;right = now-&gt;left; now-&gt;left = NULL; &#125; now = now-&gt;right; &#125; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ° 12345678910111213141516171819class Solution &#123;public: void flatten(TreeNode* root) &#123; if(root==NULL) return; while(root)&#123; if(root-&gt;left)&#123; TreeNode* prev = root-&gt;left; while(prev-&gt;right!=NULL) prev = prev-&gt;right; prev-&gt;right = root-&gt;right; root-&gt;right = root-&gt;left; root-&gt;left = NULL; root = root-&gt;right; &#125;else&#123; root = root-&gt;right; &#125; &#125; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void flatten(TreeNode* root) &#123; if(!root || !root-&gt;left&amp;&amp;!root-&gt;right) return; TreeNode* curnode = root; while(curnode)&#123; if(curnode-&gt;left)&#123; TreeNode* pre = curnode-&gt;left; while(pre-&gt;right) pre = pre-&gt;right; pre-&gt;right = curnode-&gt;right; curnode-&gt;right = curnode-&gt;left; curnode-&gt;left = NULL; curnode = curnode-&gt;right; &#125;else&#123; curnode = curnode-&gt;right; &#125; &#125; return; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š ä¼˜åŒ–åŽçš„ä»£ç ï¼Œç›¸å¯¹äºŽä¸Šé¢ï¼Œä¼˜åŒ–äº†if elseè¯­å¥ï¼Œå¦‚æžœæœ‰cur-&gt;left,è¿›è¡Œä¸€å®šçš„å¤„ç† æ— è®ºæœ‰æ²¡æœ‰cur-&gt;leftï¼Œæœ€åŽéƒ½è¦åŽ»cur-&gt;right 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void flatten(TreeNode* root) &#123; if(!root || !root-&gt;left&amp;&amp;!root-&gt;right) return; TreeNode* curnode = root; while(curnode)&#123; if(curnode-&gt;left)&#123; TreeNode* pre = curnode-&gt;left; while(pre-&gt;right) pre = pre-&gt;right; pre-&gt;right = curnode-&gt;right; curnode-&gt;right = curnode-&gt;left; curnode-&gt;left = NULL; &#125; curnode = curnode-&gt;right; &#125; return; &#125;&#125;; https://discuss.leetcode.com/topic/3995/share-my-simple-non-recursive-solution-o-1-space-complexity Share my simple NON-recursive solution, O(1) space complexity! 123456789101112131415161718192021222324class Solution &#123;public: void flatten(TreeNode *root) &#123; TreeNode*now = root; while (now) &#123; if(now-&gt;left) &#123; //Find current node&apos;s prenode that links to current node&apos;s right subtree TreeNode* pre = now-&gt;left; while(pre-&gt;right) &#123; pre = pre-&gt;right; &#125; pre-&gt;right = now-&gt;right; //Use current node&apos;s left subtree to replace its right subtree(original right //subtree is already linked by current node&apos;s prenode now-&gt;right = now-&gt;left; now-&gt;left = NULL; &#125; now = now-&gt;right; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/14481/8ms-non-recursive-no-stack-c-solution 8ms, Non-recursive, No stack, C++ solution 123456789101112131415void flatten(TreeNode *root) &#123; while (root) &#123; if (root-&gt;left &amp;&amp; root-&gt;right) &#123; TreeNode* t = root-&gt;left; while (t-&gt;right) t = t-&gt;right; t-&gt;right = root-&gt;right; &#125; if(root-&gt;left) root-&gt;right = root-&gt;left; root-&gt;left = NULL; root = root-&gt;right; &#125;&#125; https://discuss.leetcode.com/topic/19087/my-recursive-solution-is-easy-and-clean My recursive solution is easy and clean! 1234567891011void flatten(TreeNode* root) &#123; if (!root) return; flatten(root-&gt;left); flatten(root-&gt;right); TreeNode *tmp = root-&gt;right; root-&gt;right = root-&gt;left; root-&gt;left = nullptr; while (root-&gt;right) root = root-&gt;right; root-&gt;right = tmp;&#125; https://discuss.leetcode.com/topic/9933/16-lines-iterative-c-solution 16 lines iterative c++ solution 12345678910111213141516void flatten(TreeNode *root) &#123; while(root)&#123; if(root-&gt;left == NULL) root = root-&gt;right; else &#123; if(root-&gt;right)&#123; TreeNode *l = root-&gt;left; while(l-&gt;right) l = l-&gt;right; l-&gt;right = root-&gt;right; &#125; root-&gt;right = root-&gt;left; root-&gt;left = NULL; root = root-&gt;right; &#125; &#125;&#125; Inspired by Morris traversal. https://discuss.leetcode.com/topic/10606/an-inorder-python-solution An inorder python solution 12345678910111213141516171819202122232425262728class Solution:# @param root, a tree node# @return nothing, do it in placeprev = Nonedef flatten(self, root): if not root: return self.prev = root self.flatten(root.left) temp = root.right root.right, root.left = root.left, None self.prev.right = temp self.flatten(temp) * / n / \ left right \ * * \ p The idea is very simple. Suppose n is the current visiting node, and p is the previous node of preorder traversal to n.right. We just need to do the inorder replacement: n.left -&gt; NULL n.right - &gt; n.left p-&gt;right -&gt; n.right https://discuss.leetcode.com/topic/11444/my-short-post-order-traversal-java-solution-for-share My short post order traversal Java solution for share 1234567891011private TreeNode prev = null;public void flatten(TreeNode root) &#123; if (root == null) return; flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root;&#125; https://discuss.leetcode.com/topic/9936/straightforward-java-solution Straightforward Java Solution 12345678910111213141516public void flatten(TreeNode root) &#123; if (root == null) return; TreeNode left = root.left; TreeNode right = root.right; root.left = null; flatten(left); flatten(right); root.right = left; TreeNode cur = root; while (cur.right != null) cur = cur.right; cur.right = right; &#125; This solution is based on recursion. We simply flatten left and right subtree and paste each sublist to the right child of the root. (donâ€™t forget to set left child to null) 3ms, 4.67%, September 25, 2016 https://discuss.leetcode.com/topic/5783/accepted-simple-java-solution-iterative 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public void flatten(TreeNode root) &#123; if(root==null) return; Stack&lt;TreeNode&gt; stk = new Stack&lt;TreeNode&gt;(); stk.push(root); while(!stk.isEmpty())&#123; TreeNode curr = stk.pop(); if(curr.right!=null) stk.push(curr.right); if(curr.left!=null) stk.push(curr.left); if(!stk.isEmpty()) curr.right = stk.peek(); curr.left = null; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[113. Path Sum II]]></title>
    <url>%2Fp%2F37ccb4d%2F</url>
    <content type="text"><![CDATA[32.1% https://leetcode.com/problems/path-sum-ii/?tab=Description Given a binary tree and a sum, find all root-to-leaf paths where each pathâ€™s sum equals the given sum. 1234567891011121314For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1return[ [5,4,11,2], [5,8,4,5]] æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; paths; vector&lt;int&gt; path; dfs(root, path, paths, sum); return paths; &#125; void dfs(TreeNode* root, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; paths, int sum)&#123; if(!root) return; path.push_back(root-&gt;val); if(root-&gt;val==sum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) paths.push_back(path); dfs(root-&gt;left, path, paths, sum-root-&gt;val); dfs(root-&gt;right, path, paths, sum-root-&gt;val); path.pop_back(); &#125;&#125;; å…¸åž‹çš„æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆå›žæº¯æ³•ï¼‰ï¼Œå…¸åž‹é¢˜ç›®ï¼Œéœ€è¦ç‰¢è®°æ–¹æ³•ã€‚ Well, a typical backtracking problem. The code is as follows. You may walk through it using the example in the problem statement to see how it works. 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; paths; vector&lt;int&gt; path; findPaths(root, sum, path, paths); return paths; &#125; private: void findPaths(TreeNode* node, int sum, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; paths)&#123; if(!node) return; path.push_back(node-&gt;val); if(!(node-&gt;left) &amp;&amp; !(node-&gt;right) &amp;&amp; sum == node-&gt;val) paths.push_back(path); findPaths(node-&gt;left, sum-node-&gt;val, path, paths); findPaths(node-&gt;right, sum-node-&gt;val, path, paths); path.pop_back(); &#125;&#125;; 12ms, September 21, 2016 https://discuss.leetcode.com/topic/18454/12ms-11-lines-c-solution 12ms 11-lines C++ Solution Well, a typical backtracking problem. The code is as follows. You may walk through it using the example in the problem statement to see how it works. 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; paths; vector&lt;int&gt; path; findPaths(root, sum, path, paths); return paths; &#125; private: void findPaths(TreeNode* node, int sum, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; paths)&#123; if(!node) return; path.push_back(node-&gt;val); if(!(node-&gt;left) &amp;&amp; !(node-&gt;right) &amp;&amp; sum == node-&gt;val) paths.push_back(path); findPaths(node-&gt;left, sum-node-&gt;val, path, paths); findPaths(node-&gt;right, sum-node-&gt;val, path, paths); path.pop_back(); &#125;&#125;; https://discuss.leetcode.com/topic/8919/18-ms-c-recursive-solution 18 ms c++ recursive solution 12345678910111213141516171819202122232425262728vector&lt;vector&lt;int&gt; &gt; pathSum(TreeNode *root, int sum) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; cur_path(0); pathSumRec(root, sum, result, cur_path); return result;&#125;// pass the current path as a reference and remember to pop out the last added element// this improves the performance by 5 timesvoid pathSumRec(TreeNode* root, int sum, vector&lt;vector&lt;int&gt; &gt;&amp; result, vector&lt;int&gt;&amp; cur_path) &#123; if (root == NULL) &#123; return; &#125; if (root-&gt;val == sum &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123; cur_path.push_back(root-&gt;val); result.push_back(cur_path); cur_path.pop_back(); return; &#125; int sum_left = sum - root-&gt;val; cur_path.push_back(root-&gt;val); pathSumRec(root-&gt;left, sum_left, result, cur_path); //cur_path.pop_back(); pathSumRec(root-&gt;right, sum_left, result, cur_path); cur_path.pop_back();&#125; 92ms, September 21, 2016 https://discuss.leetcode.com/topic/16607/short-python-solution Short python solution 12345678910111213141516class Solution(object): def pathSum(self, root, sum): &quot;&quot;&quot; :type root: TreeNode :type sum: int :rtype: List[List[int]] &quot;&quot;&quot; if not root: return [] if root.left == None and root.right == None: if sum == root.val: return [[root.val]] else: return [] a = self.pathSum(root.left, sum-root.val) + \ self.pathSum(root.right, sum - root.val) return [[root.val] + i for i in a] https://discuss.leetcode.com/topic/18444/python-solutions-recursively-bfs-queue-dfs-stack Python solutions (Recursively, BFS+queue, DFS+stack) 1234567891011121314151617181920212223def pathSum(self, root, sum): if not root: return [] res = [] self.dfs(root, sum, [], res) return res def dfs(self, root, sum, ls, res): if not root.left and not root.right and sum == root.val: ls.append(root.val) res.append(ls) if root.left: self.dfs(root.left, sum-root.val, ls+[root.val], res) if root.right: self.dfs(root.right, sum-root.val, ls+[root.val], res) def pathSum2(self, root, sum): if not root: return [] if not root.left and not root.right and sum == root.val: return [[root.val]] tmp = self.pathSum(root.left, sum-root.val) + self.pathSum(root.right, sum-root.val) return [[root.val]+i for i in tmp] 123456789101112131415# BFS + queue def pathSum3(self, root, sum): if not root: return [] res = [] queue = [(root, root.val, [root.val])] while queue: curr, val, ls = queue.pop(0) if not curr.left and not curr.right and val == sum: res.append(ls) if curr.left: queue.append((curr.left, val+curr.left.val, ls+[curr.left.val])) if curr.right: queue.append((curr.right, val+curr.right.val, ls+[curr.right.val])) return res 123456789101112131415# DFS + stack I def pathSum4(self, root, sum): if not root: return [] res = [] stack = [(root, sum-root.val, [root.val])] while stack: curr, val, ls = stack.pop() if not curr.left and not curr.right and val == 0: res.append(ls) if curr.right: stack.append((curr.right, val-curr.right.val, ls+[curr.right.val])) if curr.left: stack.append((curr.left, val-curr.left.val, ls+[curr.left.val])) return res 123456789101112131415# DFS + stack II def pathSum5(self, root, s): if not root: return [] res = [] stack = [(root, [root.val])] while stack: curr, ls = stack.pop() if not curr.left and not curr.right and sum(ls) == s: res.append(ls) if curr.right: stack.append((curr.right, ls+[curr.right.val])) if curr.left: stack.append((curr.left, ls+[curr.left.val])) return res https://discuss.leetcode.com/topic/5414/dfs-with-one-linkedlist-accepted-java-solution DFS with one LinkedList , accepted java solution 1234567891011121314151617181920212223public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; currentResult = new LinkedList&lt;Integer&gt;(); pathSum(root, sum, currentResult, result); return result; &#125; public void pathSum(TreeNode root, int sum, List&lt;Integer&gt; currentResult, List&lt;List&lt;Integer&gt;&gt; result)&#123; if(root == null) return; currentResult.add(new Integer(root.val)); if(root.left == null &amp;&amp; root.right == null &amp;&amp; sum == root.val)&#123; result.add(new LinkedList(currentResult)); currentResult.remove(currentResult.size() - 1); return; &#125;else&#123; pathSum(root.left, sum-root.val, currentResult, result); pathSum(root.right, sum-root.val, currentResult, result); &#125; currentResult.remove(currentResult.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[112. Path Sum]]></title>
    <url>%2Fp%2F17e12313%2F</url>
    <content type="text"><![CDATA[33.2% https://leetcode.com/problems/path-sum/description/ Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. 12345678910For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 17ï¼Œ 2017 12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(!root) return false; if(!root-&gt;left &amp;&amp; !root-&gt;right) return root-&gt;val == sum; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; code 1ï¼š ä»Žæ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œå¦‚æžœæ ¹ç­‰äºŽNULLï¼Œfalseï¼Œå¦‚æžœå·¦å³èŠ‚ç‚¹ä¸ºç©ºï¼Œå¹¶ä¸”æ ¹çš„å€¼ç­‰äºŽsumï¼Œé‚£ä¹ˆä¸ºtrueï¼Œå¦åˆ™è¿›è¡Œè¿­ä»£ã€‚ 12345678class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(root == NULL) return false; if(root-&gt;val == sum &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right ==NULL) return true; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; code 2ï¼š æˆ‘è‡ªå·±çš„ä»£ç  123456789class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(root==NULL) return false; if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return root-&gt;val == sum; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; æ–¹æ³•äºŒï¼š è¿­ä»£çš„æ–¹æ³•ï¼Œä½¿ç”¨åŽåºéåŽ†çš„æ–¹æ³• By using postorder traversal In the postorder traversal, the node will be removed from the stack only when the right sub-tree has been visited. so the path will be stored in the stack. we can keep check the SUM, the length from root to leaf node.at leaf node, if SUM == sum, OK, return true. After postorder traversal, return false. I have compared this solution with recursion solutions. In the leetcode OJ, the run time of two solutions is very near. below is my iterator code. 12345678910111213141516171819202122232425262728class Solution &#123;public: bool hasPathSum(TreeNode *root, int sum) &#123; stack&lt;TreeNode *&gt; s; TreeNode *pre = NULL, *cur = root; int SUM = 0; while (cur || !s.empty()) &#123; while (cur) &#123; s.push(cur); SUM += cur-&gt;val; cur = cur-&gt;left; &#125; cur = s.top(); if (cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL &amp;&amp; SUM == sum) &#123; return true; &#125; if (cur-&gt;right &amp;&amp; pre != cur-&gt;right) &#123; cur = cur-&gt;right; &#125; else &#123; pre = cur; s.pop(); SUM -= cur-&gt;val; cur = NULL; &#125; &#125; return false; &#125;&#125;; æ³¨æ„ï¼šæœ¬é¢˜ç­”æ¡ˆæ¥çœ‹ï¼Œåªæœ‰æ²¡æœ‰å·¦å³å­©å­èŠ‚ç‚¹çš„è·¯å¾„æ‰ç®—ä¸€æ¡å®Œæ•´è·¯å¾„ã€‚ https://discuss.leetcode.com/topic/892/why-is-the-output-of-1-2-1-is-false 1234Why is the output of &quot;&#123;1, 2&#125;, 1&quot; is false? 12 The struct is like above, and the sum of right path is 1. Why the output is false? Additional: Find another problem: the output of â€œ{1}, 1â€ is trueâ€¦â€¦ whyâ€¦.. the question is â€œdetermine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sumâ€. So the condition is there is a path from the root to a leaf. For your tree, there is only one leaf (2) cpp https://leetcode.com/discuss/27236/3-lines-of-c-solution 12ms, 22.26%, June.17th, 2016 1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(root == NULL) return false; if(root-&gt;val == sum &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right ==NULL) return true; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; https://discuss.leetcode.com/topic/2455/accepted-by-using-postorder-traversal [Accepted] By using postorder traversal In the postorder traversal, the node will be removed from the stack only when the right sub-tree has been visited. so the path will be stored in the stack. we can keep check the SUM, the length from root to leaf node.at leaf node, if SUM == sum, OK, return true. After postorder traversal, return false. I have compared this solution with recursion solutions. In the leetcode OJ, the run time of two solutions is very near. below is my iterator code. 12345678910111213141516171819202122232425262728class Solution &#123;public: bool hasPathSum(TreeNode *root, int sum) &#123; stack&lt;TreeNode *&gt; s; TreeNode *pre = NULL, *cur = root; int SUM = 0; while (cur || !s.empty()) &#123; while (cur) &#123; s.push(cur); SUM += cur-&gt;val; cur = cur-&gt;left; &#125; cur = s.top(); if (cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL &amp;&amp; SUM == sum) &#123; return true; &#125; if (cur-&gt;right &amp;&amp; pre != cur-&gt;right) &#123; cur = cur-&gt;right; &#125; else &#123; pre = cur; s.pop(); SUM -= cur-&gt;val; cur = NULL; &#125; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/26599/share-my-3-lines-c-solution Share my 3 lines c++ solution 1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(!root) return false; if((root -&gt; val == sum) &amp;&amp; ((!root -&gt; left) &amp;&amp; (!root -&gt; right))) return true; return hasPathSum(root -&gt; left, sum - root -&gt; val) || hasPathSum(root -&gt; right, sum - root -&gt; val); &#125;&#125;; python 84ms, 29.07%, June.17th, 2016 https://leetcode.com/discuss/28873/short-python-recursive-solution-o-n 123456789101112131415161718# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): &quot;&quot;&quot; :type root: TreeNode :type sum: int :rtype: bool &quot;&quot;&quot; if not root: return False if not root.left and not root.right and root.val == sum: return True sum -= root.val return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum) https://discuss.leetcode.com/topic/18433/python-solutions-dfs-recursively-dfs-stack-bfs-queue Python solutions (DFS recursively, DFS+stack, BFS+queue) 123456789101112131415# DFS Recursively def hasPathSum1(self, root, sum): res = [] self.dfs(root, sum, res) return any(res) def dfs(self, root, target, res): if root: if not root.left and not root.right: if root.val == target: res.append(True) if root.left: self.dfs(root.left, target-root.val, res) if root.right: self.dfs(root.right, target-root.val, res) 123456789101112131415# DFS with stackdef hasPathSum2(self, root, sum): if not root: return False stack = [(root, root.val)] while stack: curr, val = stack.pop() if not curr.left and not curr.right: if val == sum: return True if curr.right: stack.append((curr.right, val+curr.right.val)) if curr.left: stack.append((curr.left, val+curr.left.val)) return False 123456789101112131415# BFS with queuedef hasPathSum(self, root, sum): if not root: return False queue = [(root, sum-root.val)] while queue: curr, val = queue.pop(0) if not curr.left and not curr.right: if val == 0: return True if curr.left: queue.append((curr.left, val-curr.left.val)) if curr.right: queue.append((curr.right, val-curr.right.val)) return False java The basic idea is to subtract the value of current node from sum until it reaches a leaf node and the subtraction equals 0, then we know that we got a hit. Otherwise the subtraction at the end could not be 0. 1ms, 9.51%, June.17th, 2016 https://leetcode.com/discuss/10456/accepted-my-recursive-solution-in-java 12345678910111213141516/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null) return false; if(root.left == null &amp;&amp; root.right == null &amp;&amp; sum - root.val == 0) return true; return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[111. Minimum Depth of Binary Tree]]></title>
    <url>%2Fp%2Fb1d96f1f%2F</url>
    <content type="text"><![CDATA[32.5% https://leetcode.com/problems/minimum-depth-of-binary-tree/ Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. æ–¹æ³•ä¸€ï¼š åˆ©ç”¨æ±‚æ ‘çš„æ·±åº¦çš„æ–¹æ³•ä¹‹ä¸€ï¼Œä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ—çš„æ–¹æ³•ã€‚ bfsï¼Œå¹¿åº¦ä¼˜å…ˆæœç´¢ 1234567891011121314151617181920212223class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(root==NULL) return 0; int res = 0; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty())&#123; res++; int n = que.size(); for(int i=0; i&lt;n; i++)&#123; TreeNode* cur = que.front(); que.pop(); if(cur-&gt;left==NULL &amp;&amp; cur-&gt;right==NULL) return res; if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); &#125; &#125; &#125;&#125;; æ–¹æ³•äºŒï¼š åŒæ ·æ˜¯æ ‘çš„æ·±åº¦ï¼Œæ·±åº¦ä¼˜å…ˆéåŽ† 123456789class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; if(!root-&gt;left) return 1 + minDepth(root-&gt;right); if(!root-&gt;right) return 1 + minDepth(root-&gt;left); return 1+min(minDepth(root-&gt;left),minDepth(root-&gt;right)); &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; if(!root-&gt;left) return 1+minDepth(root-&gt;right); if(!root-&gt;right) return 1+minDepth(root-&gt;left); return min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + 1; &#125;&#125;; æ–¹æ³•ä¸‰ï¼š åˆ©ç”¨ä¸€ä¸ªhelperå‡½æ•°ï¼Œé€’å½’è°ƒç”¨ 123456789101112131415161718192021class Solution &#123;private: int depth;public: int minDepth(TreeNode* root) &#123; if(root==NULL) return 0; depth = 1; return helper(root, depth); &#125; int helper(TreeNode* root, int depth)&#123; if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return depth; else if(root-&gt;right!=NULL &amp;&amp; root-&gt;left!=NULL) return min(helper(root-&gt;left, depth+1), helper(root-&gt;right, depth+1)); else if(root-&gt;right!=NULL) return helper(root-&gt;right, depth+1); else return helper(root-&gt;left, depth+1); &#125;&#125;; cpp9ms, 41.83%, September 25, 2016 https://discuss.leetcode.com/topic/6767/my-concise-c-solution 123456789class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; if(!root-&gt;left) return 1 + minDepth(root-&gt;right); if(!root-&gt;right) return 1 + minDepth(root-&gt;left); return 1+min(minDepth(root-&gt;left),minDepth(root-&gt;right)); &#125;&#125;; my code: 123456789101112131415161718192021class Solution &#123;private: int depth;public: int minDepth(TreeNode* root) &#123; if(root==NULL) return 0; depth = 1; return helper(root, depth); &#125; int helper(TreeNode* root, int depth)&#123; if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return depth; else if(root-&gt;right!=NULL &amp;&amp; root-&gt;left!=NULL) return min(helper(root-&gt;left, depth+1), helper(root-&gt;right, depth+1)); else if(root-&gt;right!=NULL) return helper(root-&gt;right, depth+1); else return helper(root-&gt;left, depth+1); &#125;&#125;; 1ms, 15.51%, September 25, 2016 https://discuss.leetcode.com/topic/8723/my-4-line-java-solution 12345678public class Solution &#123; public int minDepth(TreeNode root) &#123; if(root==null) return 0; int left = minDepth(root.left); int right = minDepth(root.right); return(left==0||right==0)?left+right+1:Math.min(left, right)+1; &#125;&#125; 1ms, 15.51%, September 25, 2016 https://discuss.leetcode.com/topic/8723/my-4-line-java-solution 12345678public class Solution &#123; public int minDepth(TreeNode root) &#123; if(root==null) return 0; if(root.left == null) return minDepth(root.right)+1; if(root.right == null) return minDepth(root.left)+1; return Math.min(minDepth(root.left), minDepth(root.right)) + 1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[110. Balanced Binary Tree]]></title>
    <url>%2Fp%2F205e8441%2F</url>
    <content type="text"><![CDATA[36.5% https://leetcode.com/problems/balanced-binary-tree/?tab=Description Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. å‰‘æŒ‡offer 39 ç¬¬äºŒé¢˜ The bottom up O(N) solution would be better This problem is generally believed to have two solutions: the top down approach and the bottom up way. æ–¹æ³•ä¸€ï¼š æœ€ç®€å•æœ€ç›´æŽ¥ï¼Œæ ¹æ®é¢˜ç›®å®šä¹‰æ¥å†³ç­–ã€‚ ç¼ºç‚¹ï¼šå¤æ‚åº¦é«˜ï¼Œæ•ˆçŽ‡ä½Žã€‚ 1.The first method checks whether the tree is balanced strictly according to the definition of balanced binary tree: the difference between the heights of the two sub trees are not bigger than 1, and both the left sub tree and right sub tree are also balanced. With the helper function depth(), we could easily write the code; 12345678910111213141516class solution &#123;public: int depth (TreeNode *root) &#123; if (root == NULL) return 0; return max (depth(root -&gt; left), depth (root -&gt; right)) + 1; &#125; bool isBalanced (TreeNode *root) &#123; if (root == NULL) return true; int left=depth(root-&gt;left); int right=depth(root-&gt;right); return abs(left - right) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;; For the current node root, calling depth() for its left and right children actually has to access all of its children, thus the complexity is O(N). We do this for each node in the tree, so the overall complexity of isBalanced will be O(N^2). This is a top down approach. æ–¹æ³•äºŒï¼š åŸºäºŽdfsçš„æ–¹æ³•ï¼Œè‡ªåº•å‘ä¸Šçš„æ–¹æ³•ï¼Œæ¯ä¸€æ­¥ä¸€ä¸ªåˆ¤æ–­ã€‚ æœ‰ç‚¹ï¼šæ•ˆçŽ‡é«˜ã€‚ æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; return depth(root)!=-1; &#125; int depth(TreeNode* root)&#123; if(!root) return 0; int l = depth(root-&gt;left); if(l==-1) return -1; int r = depth(root-&gt;right); if(r==-1) return -1; if(abs(l-r)&gt;1) return -1; return max(l, r)+1; &#125;&#125;; 2.The second method is based on DFS. Instead of calling depth() explicitly for each child node, we return the height of the current node in DFS recursion. When the sub tree of the current node (inclusive) is balanced, the function dfsHeight() returns a non-negative value as the height. Otherwise -1 is returned. According to the leftHeight and rightHeight of the two children, the parent node could check if the sub tree is balanced, and decides its return value. 1234567891011121314151617class solution &#123;public:int dfsHeight (TreeNode *root) &#123; if (root == NULL) return 0; int leftHeight = dfsHeight (root -&gt; left); if (leftHeight == -1) return -1; int rightHeight = dfsHeight (root -&gt; right); if (rightHeight == -1) return -1; if (abs(leftHeight - rightHeight) &gt; 1) return -1; return max (leftHeight, rightHeight) + 1; &#125; bool isBalanced(TreeNode *root) &#123; return dfsHeight (root) != -1; &#125;&#125;; In this bottom up approach, each node in the tree only need to be accessed once. Thus the time complexity is O(N), better than the first solution. æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; // ä½¿ç”¨ä¸€ä¸ªdepthå‡½æ•°ï¼Œå¦‚æžœç¬¦åˆåˆ™è¿”å›žæ·±åº¦ï¼Œå¦åˆ™è¿”å›ž-1 return depth(root)!=-1; &#125; int depth(TreeNode* root)&#123; if(!root) return 0; int left = depth(root-&gt;left); if(left==-1) return -1; int right = depth(root-&gt;right); if(right==-1) return -1; if(abs(left-right)&gt;1) return -1; return max(left, right) + 1; &#125;&#125;; ä»£ç çš„å¦ä¸€ç§å®žçŽ°ï¼š 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; int depth = 0; return helper(root, &amp;depth); &#125; bool helper(TreeNode* root, int* depth)&#123; if(!root)&#123; depth = 0; return true; &#125; int left, right; if(helper(root-&gt;left, &amp;left)) return false; if(helper(root-&gt;right, &amp;right)) return false; if(abs(left-right)&gt;1) return false; * depth = max(left, right) + 1; return true; &#125;&#125;; ç†è§£å­¦ä¹ åŒº https://discuss.leetcode.com/topic/276/two-different-definitions-of-balanced-binary-tree-result-in-two-different-judgments Two different definitions of balanced binary tree result in two different judgments Input: {1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5} Output: false (based on balanced binary definition â€œno 2 leaf nodes differ in distance from the root by more than 1â€) Expected: true (base on balanced binary definition â€œtwo subtrees of every node never differ by more than 1â€ ) From the problem description, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.Below is a representation of the tree input: {1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}: 1234567891011blank ____1____ / \ 2 2 / \ / \ 3 3 3 3 /\ /\ /\ 4 4 4 4 4 4 /\5 5 Letâ€™s start with the root node (1). As you can see, left subtreeâ€™s depth is 5, while right subtreeâ€™s depth is 4. Therefore, the condition for a height-balanced binary tree holds for the root node. We continue the same comparison recursively for both left and right subtree, and we conclude that this is indeed a balanced binary tree. Additional Note: AVL Treeâ€™s height-balanced definition is exactly the same as above definition, and its height-balancedness is more rigid compared to a Red Black Tree. As quoted from Wikipediaâ€™s definition of AVL tree: In an AVL tree, the heights of the two child subtrees of any node differ by at most oneâ€¦. For lookup-intensive applications, AVL trees are faster than red-black trees because they are more rigidly balanced. https://discuss.leetcode.com/topic/7798/the-bottom-up-o-n-solution-would-be-better The bottom up O(N) solution would be better This problem is generally believed to have two solutions: the top down approach and the bottom up way. 1.The first method checks whether the tree is balanced strictly according to the definition of balanced binary tree: the difference between the heights of the two sub trees are not bigger than 1, and both the left sub tree and right sub tree are also balanced. With the helper function depth(), we could easily write the code; 12345678910111213141516class solution &#123;public: int depth (TreeNode *root) &#123; if (root == NULL) return 0; return max (depth(root -&gt; left), depth (root -&gt; right)) + 1; &#125; bool isBalanced (TreeNode *root) &#123; if (root == NULL) return true; int left=depth(root-&gt;left); int right=depth(root-&gt;right); return abs(left - right) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;; For the current node root, calling depth() for its left and right children actually has to access all of its children, thus the complexity is O(N). We do this for each node in the tree, so the overall complexity of isBalanced will be O(N^2). This is a top down approach. 2.The second method is based on DFS. Instead of calling depth() explicitly for each child node, we return the height of the current node in DFS recursion. When the sub tree of the current node (inclusive) is balanced, the function dfsHeight() returns a non-negative value as the height. Otherwise -1 is returned. According to the leftHeight and rightHeight of the two children, the parent node could check if the sub treeis balanced, and decides its return value. 1234567891011121314151617class solution &#123;public:int dfsHeight (TreeNode *root) &#123; if (root == NULL) return 0; int leftHeight = dfsHeight (root -&gt; left); if (leftHeight == -1) return -1; int rightHeight = dfsHeight (root -&gt; right); if (rightHeight == -1) return -1; if (abs(leftHeight - rightHeight) &gt; 1) return -1; return max (leftHeight, rightHeight) + 1; &#125; bool isBalanced(TreeNode *root) &#123; return dfsHeight (root) != -1; &#125;&#125;; In this bottom up approach, each node in the tree only need to be accessed once. Thus the time complexity is O(N), better than the first solution. 1ms, 69.69%, September 25, 2016 https://discuss.leetcode.com/topic/11007/java-solution-based-on-height-check-left-and-right-node-in-every-recursion-to-avoid-further-useless-search Java solution based on height, check left and right node in every recursion to avoid further useless search 1234567891011121314151617public class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if(root == null) return true; return height(root) != -1; &#125; public int height(TreeNode node)&#123; if(node==null) return 0; int LH = height(node.left); if(LH == -1) return -1; int RH = height(node.right); if(RH == -1) return -1; if(LH-RH&lt;-1 || LH-RH &gt;1) return -1; return Math.max(LH, RH)+1; &#125;&#125; https://discuss.leetcode.com/topic/3746/accepted-o-n-solution Accepted O(n) solution We determine recursively the height of the root node but when the recursion is coming upwards we return UNBALANCED instead of the actual height if we know that the tree is already known to be unbalanced. We visit each node just once thus it has linear time complexity. 1234567891011121314151617181920private static final int UNBALANCED = -99;public boolean isBalanced(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return getHeight(root) != UNBALANCED;&#125;private int getHeight(TreeNode root) &#123; if (root == null) &#123; return -1; &#125; int l = getHeight(root.left); int r = getHeight(root.right); if (l == UNBALANCED || r == UNBALANCED || Math.abs(l-r) &gt; 1) &#123; return UNBALANCED; &#125; return 1 + Math.max(l,r);&#125; https://discuss.leetcode.com/topic/42953/very-simple-python-solutions-iterative-and-recursive-both-beat-90 VERY SIMPLE Python solutions (iterative and recursive), both beat 90% 1234567891011121314151617class Solution(object): def isBalanced(self, root): def check(root): if root is None: return 0 left = check(root.left) right = check(root.right) if left == -1 or right == -1 or abs(left - right) &gt; 1: return -1 return 1 + max(left, right) return check(root) != -1# 226 / 226 test cases passed.# Status: Accepted# Runtime: 80 ms Iterative, based on postorder traversal: 123456789101112131415161718192021222324class Solution(object): def isBalanced(self, root): stack, node, last, depths = [], root, None, &#123;&#125; while stack or node: if node: stack.append(node) node = node.left else: node = stack[-1] if not node.right or last == node.right: node = stack.pop() left, right = depths.get(node.left, 0), depths.get(node.right, 0) if abs(left - right) &gt; 1: return False depths[node] = 1 + max(left, right) last = node node = None else: node = node.right return True# 226 / 226 test cases passed.# Status: Accepted# Runtime: 84 ms https://discuss.leetcode.com/topic/1278/can-we-have-a-better-solution Can we have a better solution My solution for this problem is as follows: 123456789101112131415public class Solution &#123;public boolean isBalanced(TreeNode root) &#123; if (root == null) return true; if (Math.abs(depth(root.left) - depth(root.right)) &gt;1) return false; return isBalanced(root.left) &amp;&amp; isBalanced(root.right);&#125;private int depth(TreeNode root)&#123; if (root == null) return 0; return Math.max(depth(root.left), depth(root.right)) + 1;&#125;&#125; But it has two recursions, one for depth() and one for isBalanced(). Will there be a performance issue? 109ms, 32.19%, September 25, 2016 https://discuss.leetcode.com/topic/14752/a-simple-python-recursive-solution-172ms 1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isBalanced(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if not root: return True return abs(self.getHeight(root.left)-self.getHeight(root.right))&lt;2 and self.isBalanced(root.left) and self.isBalanced(root.right) def getHeight(self, root): if not root: return 0 return 1+max(self.getHeight(root.left), self.getHeight(root.right))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[109. Convert Sorted List to Binary Search Tree]]></title>
    <url>%2Fp%2F15b352ee%2F</url>
    <content type="text"><![CDATA[33.1% https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/ Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. æ–¹æ³•ä¸€: å…ˆæ‰¾åˆ°ä¸­é—´ç‚¹ï¼Œå°†å·¦ä¾§å³ä¾§æ–­å¼€ã€‚æ–­å¼€è¿™ä¸€ç‚¹å€¼å¾—å­¦ä¹ ï¼Œæˆ‘ä»¬å¯ä»¥åŽŸæœ‰çš„æ•°æ®ç»“æž„ã€‚ æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *//** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* sortedListToBST(ListNode* head) &#123; if(!head) return nullptr; // è€ƒè™‘åªæœ‰ä¸€ä¸ªå…ƒç´ çš„æƒ…å†µ if(!head-&gt;next) return new TreeNode(head-&gt;val); ListNode* pre=head, *slow=head, *fast=head; while(fast &amp;&amp; fast-&gt;next)&#123; pre = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; TreeNode* root = new TreeNode(slow-&gt;val); pre-&gt;next = nullptr; root-&gt;left = sortedListToBST(head); root-&gt;right = sortedListToBST(slow-&gt;next); return root; &#125;&#125;; https://discuss.leetcode.com/topic/10979/clean-c-solution-recursion-o-nlogn-with-comment Clean C++ solution. Recursion. O(nlogn). With comment Recursively build tree. find midpoint by fast/slow method, use middle node as root. build left child by first half of the list build right child by second half of the list (head is midpoint-&gt;next) 12345678910111213141516171819202122232425class Solution &#123;public: TreeNode *sortedListToBST(ListNode *head) &#123; if(!head) return NULL; if(!head-&gt;next) return new TreeNode(head-&gt;val); // fast/slow pointer to find the midpoint auto slow = head; auto fast = head; auto pre = head; while(fast &amp;&amp; fast-&gt;next) &#123; pre = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; pre-&gt;next = 0; // break two halves // slow is the midpoint, use as root TreeNode* root = new TreeNode(slow-&gt;val); root-&gt;left = sortedListToBST(head); root-&gt;right = sortedListToBST(slow-&gt;next); return root; &#125;&#125;; æ–¹æ³•äºŒï¼š è¿™ç§æ–¹æ³•è¿˜éœ€è¦å†æ€è€ƒã€‚ https://discuss.leetcode.com/topic/3286/share-my-code-with-o-n-time-and-o-1-space Share my code with O(n) time and O(1) space count is a function to calculate the size of list. Key words: inorder traversal. 12345678910111213141516171819202122232425262728class Solution &#123;public: ListNode *list; int count(ListNode *node)&#123; int size = 0; while (node) &#123; ++size; node = node-&gt;next; &#125; return size; &#125; TreeNode *generate(int n)&#123; if (n == 0) return NULL; TreeNode *node = new TreeNode(0); node-&gt;left = generate(n / 2); node-&gt;val = list-&gt;val; list = list-&gt;next; node-&gt;right = generate(n - n / 2 - 1); return node; &#125; TreeNode *sortedListToBST(ListNode *head) &#123; this-&gt;list = head; return generate(count(head)); &#125;&#125;; https://discuss.leetcode.com/topic/6444/my-accepted-c-solution My Accepted C++ solution 1234567891011121314151617181920212223242526272829class Solution &#123;public: TreeNode *sortedListToBST(ListNode *head) &#123; return sortedListToBST( head, NULL ); &#125; private: TreeNode *sortedListToBST(ListNode *head, ListNode *tail) &#123; if( head == tail ) return NULL; if( head-&gt;next == tail ) // &#123; TreeNode *root = new TreeNode( head-&gt;val ); return root; &#125; ListNode *mid = head, *temp = head; while( temp != tail &amp;&amp; temp-&gt;next != tail ) // å¯»æ‰¾ä¸­é—´èŠ‚ç‚¹ &#123; mid = mid-&gt;next; temp = temp-&gt;next-&gt;next; &#125; TreeNode *root = new TreeNode( mid-&gt;val ); root-&gt;left = sortedListToBST( head, mid ); root-&gt;right = sortedListToBST( mid-&gt;next, tail ); return root; &#125;&#125;; https://discuss.leetcode.com/topic/2286/how-about-like-this How about like this? 1234567891011121314151617TreeNode *sortedListToBST(ListNode *head) &#123; if(head == NULL) return NULL; if(head-&gt;next == NULL) return new TreeNode(head-&gt;val); ListNode *step1 = head; ListNode *step2 = head-&gt;next; while(step2-&gt;next != NULL &amp;&amp; step2-&gt;next-&gt;next != NULL)&#123; step1 = step1-&gt;next; step2 = step2-&gt;next-&gt;next; &#125; TreeNode *root = new TreeNode(step1-&gt;next-&gt;val); ListNode *head2 = step1-&gt;next-&gt;next; delete step1-&gt;next; step1-&gt;next = NULL; root-&gt;left = sortedListToBST(head); root-&gt;right = sortedListToBST(head2); return root;&#125; https://discuss.leetcode.com/topic/21414/python-recursive-solution-with-detailed-comments-operate-linked-list-directly Python recursive solution with detailed comments (operate linked-list directly). recursively 12345678910111213141516171819202122def sortedListToBST(self, head): if not head: return if not head.next: return TreeNode(head.val) # here we get the middle point, # even case, like &apos;1234&apos;, slow points to &apos;2&apos;, # &apos;3&apos; is root, &apos;12&apos; belongs to left, &apos;4&apos; is right # odd case, like &apos;12345&apos;, slow points to &apos;2&apos;, &apos;12&apos; # belongs to left, &apos;3&apos; is root, &apos;45&apos; belongs to right slow, fast = head, head.next.next while fast and fast.next: fast = fast.next.next slow = slow.next # tmp points to root tmp = slow.next # cut down the left child slow.next = None root = TreeNode(tmp.val) root.left = self.sortedListToBST(head) root.right = self.sortedListToBST(tmp.next) return root https://discuss.leetcode.com/topic/35997/share-my-java-solution-1ms-very-short-and-concise Share my JAVA solution, 1ms, very short and concise. 123456789101112131415161718public TreeNode sortedListToBST(ListNode head) &#123; if(head==null) return null; return toBST(head,null);&#125;public TreeNode toBST(ListNode head, ListNode tail)&#123; ListNode slow = head; ListNode fast = head; if(head==tail) return null; while(fast!=tail&amp;&amp;fast.next!=tail)&#123; fast = fast.next.next; slow = slow.next; &#125; TreeNode thead = new TreeNode(slow.val); thead.left = toBST(head,slow); thead.right = toBST(slow.next,tail); return thead;&#125; https://discuss.leetcode.com/topic/8141/share-my-o-1-space-and-o-n-time-java-code Share my O(1) space and O(n) time Java code private ListNode node; 12345678910111213141516171819202122232425262728293031323334public TreeNode sortedListToBST(ListNode head) &#123; if(head == null)&#123; return null; &#125; int size = 0; ListNode runner = head; node = head; while(runner != null)&#123; runner = runner.next; size ++; &#125; return inorderHelper(0, size - 1);&#125;public TreeNode inorderHelper(int start, int end)&#123; if(start &gt; end)&#123; return null; &#125; int mid = start + (end - start) / 2; TreeNode left = inorderHelper(start, mid - 1); TreeNode treenode = new TreeNode(node.val); treenode.left = left; node = node.next; TreeNode right = inorderHelper(mid + 1, end); treenode.right = right; return treenode;&#125; https://discuss.leetcode.com/topic/24418/recursive-bst-construction-using-slow-fast-traversal-on-linked-list Recursive BST construction using slow-fast traversal on linked list 12345678910111213141516171819202122public TreeNode sortedListToBST(ListNode head) &#123; if(head == null) return null; ListNode fast = head; ListNode slow = head; ListNode prev =null; while(fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; prev =slow; slow=slow.next; &#125; TreeNode root = new TreeNode(slow.val); if(prev != null) prev.next = null; else head = null; root.left = sortedListToBST(head); root.right = sortedListToBST(slow.next); return root;&#125; Traverse the list to get the middle element and make that the root. left side of the list forms left sub-tree and right side of the middle element forms the right sub-tree.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[108. Convert Sorted Array to Binary Search Tree]]></title>
    <url>%2Fp%2F4e75dfe7%2F</url>
    <content type="text"><![CDATA[41.0% https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ Given an array where elements are sorted in ascending order, convert it to a height balanced BST. æ–¹æ³•ä¸€ï¼š 20ms, 24.24%, July 14th, 2016 https://discuss.leetcode.com/topic/6472/accepted-c-recursive-solution-within-a-single-method Accepted C++ recursive solution within a single method Recursively call the sortedArrayToBST() method providing new vector for each call to construct left and right children: 123456789101112131415161718class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return NULL; if(nums.size() == 1) return new TreeNode(nums[0]); int middle = nums.size()/2; TreeNode* root = new TreeNode(nums[middle]); vector&lt;int&gt; leftInts(nums.begin(), nums.begin() + middle); vector&lt;int&gt; rightInts(nums.begin()+middle+1, nums.end()); root-&gt;left = sortedArrayToBST(leftInts); root-&gt;right = sortedArrayToBST(rightInts); return root; &#125; &#125;; æ–¹æ³•äºŒ ï¼š https://discuss.leetcode.com/topic/24667/16-ms-c-solution 16 ms C++ solution 1234567891011121314class Solution &#123; TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums, int start, int end)&#123; if(end&lt;=start) return NULL; int midIdx=(end+start)/2; TreeNode* root=new TreeNode(nums[midIdx]); root-&gt;left=sortedArrayToBST(nums, start, midIdx); root-&gt;right=sortedArrayToBST(nums, midIdx+1,end); return root; &#125;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return sortedArrayToBST(nums, 0,nums.size()); &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return helper(nums, 0, nums.size()-1); &#125; TreeNode* helper(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if(left&gt;right) return NULL; int mid = left+(right-left)/2; TreeNode* root = new TreeNode(nums[mid]); root-&gt;left = helper(nums, left, mid-1); root-&gt;right = helper(nums, mid+1, right); return root; &#125;&#125;; 116ms, 24.46%, July 14th, 2016 https://discuss.leetcode.com/topic/10519/an-easy-python-solutio An easy Python solution The idea is to find the root first, then recursively build each left and right subtree 12345678910111213141516class Solution(object): def sortedArrayToBST(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: TreeNode &quot;&quot;&quot; if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid+1:]) return root 0ms, 99.14%, July 14th, 2016 https://discuss.leetcode.com/topic/3158/my-accepted-java-solution My Accepted Java Solution Hi everyone, this is my accepted recursive Java solution. I get overflow problems at first because I didnâ€™t use mid - 1 and mid + 1 as the bound. Hope this helps :) 1234567891011121314151617public class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; if(nums.length == 0) return null; TreeNode head = helper(nums, 0, nums.length-1); return head; &#125; public TreeNode helper(int[] nums, int low, int high)&#123; if(low &gt; high) return null; int mid = (low + high) / 2; TreeNode node = new TreeNode(nums[mid]); node.left = helper(nums, low, mid-1); node.right = helper(nums, mid+1, high); return node; &#125;&#125; https://discuss.leetcode.com/topic/14412/java-iterative-solution Java Iterative Solution I came up with the recursion solution first and tried to translate it into an iterative solution. It is very similar to doing a tree inorder traversal, I use three stacks - nodeStack stores the node I am going to process next, and leftIndexStack and rightIndexStack store the range where this node need to read from the nums. 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; int len = nums.length; if ( len == 0 ) &#123; return null; &#125; // 0 as a placeholder TreeNode head = new TreeNode(0); Deque&lt;TreeNode&gt; nodeStack = new LinkedList&lt;TreeNode&gt;() &#123;&#123; push(head); &#125;&#125;; Deque&lt;Integer&gt; leftIndexStack = new LinkedList&lt;Integer&gt;() &#123;&#123; push(0); &#125;&#125;; Deque&lt;Integer&gt; rightIndexStack = new LinkedList&lt;Integer&gt;() &#123;&#123; push(len-1); &#125;&#125;; while ( !nodeStack.isEmpty() ) &#123; TreeNode currNode = nodeStack.pop(); int left = leftIndexStack.pop(); int right = rightIndexStack.pop(); int mid = left + (right-left)/2; // avoid overflow currNode.val = nums[mid]; if ( left &lt;= mid-1 ) &#123; currNode.left = new TreeNode(0); nodeStack.push(currNode.left); leftIndexStack.push(left); rightIndexStack.push(mid-1); &#125; if ( mid+1 &lt;= right ) &#123; currNode.right = new TreeNode(0); nodeStack.push(currNode.right); leftIndexStack.push(mid+1); rightIndexStack.push(right); &#125; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[107. Binary Tree Level Order Traversal II]]></title>
    <url>%2Fp%2F7174bdf5%2F</url>
    <content type="text"><![CDATA[38.6% https://leetcode.com/problems/binary-tree-level-order-traversal-ii/#/description Given a binary tree, return the bottom-up level order traversal of its nodesâ€™ values. (ie, from left to right, level by level from leaf to root). 12345678910111213For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its bottom-up level order traversal as:[ [15,7], [9,20], [3]] æ–¹æ³•ä¸€ï¼š æœ¬é¢˜ç±»ä¼¼äºŽ102é¢˜ï¼Œåªæ˜¯æœ€åŽç»“æžœç»™ç¿»è½¬ä¸€ä¸‹å°±å¯ä»¥äº†ã€‚ 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty())&#123; int n = que.size(); vector&lt;int&gt; tmp; for(int i=0; i&lt;n; i++)&#123; TreeNode* cur = que.front(); que.pop(); tmp.push_back(cur-&gt;val); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); &#125; res.push_back(tmp); &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; æ–¹æ³•äºŒï¼š å±‚åºéåŽ†ï¼Œdfsï¼Œç„¶åŽæœ€åŽè¿”å›žç»“æžœä¿®æ”¹ä¸€ä¸‹é¡ºåºå°±å¯ä»¥äº†ã€‚ 6ms, 37.42%, September 25, 2016 https://discuss.leetcode.com/topic/1672/is-there-any-better-idea-than-doing-regular-level-order-traversal-and-reverse-the-result Is there any better idea than doing regular level order traversal and reverse the result? The way I see this problem is that it is EXACTLY the same as â€œLevel-Order Traversal Iâ€ except that we need to reverse the final container for output, which is trivial. Is there a better idea that fits this problem specifically? The attached is my current recursive solution. In each function call, we pass in the current node and its level. If this level does not yet exist in the output container, then we should add a new empty level. Then, we add the current node to the end of the current level, and recursively call the function passing the two children of the current node at the next level. This algorithm is really a DFS, but it saves the level information for each node and produces the same result as BFS would. 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; res; void DFS(TreeNode* root, int level) &#123; if (root == NULL) return; if (level == res.size()) // The level does not exist in output &#123; res.push_back(vector&lt;int&gt;()); // Create a new level &#125; res[level].push_back(root-&gt;val); // Add the current value to its level DFS(root-&gt;left, level+1); // Go to the next level DFS(root-&gt;right,level+1); &#125; vector&lt;vector&lt;int&gt; &gt; levelOrderBottom(TreeNode *root) &#123; DFS(root, 0); return vector&lt;vector&lt;int&gt; &gt; (res.rbegin(), res.rend()); &#125;&#125;; https://discuss.leetcode.com/topic/10903/my-neat-solution-in-c My Neat Solution in C++ 123456789101112131415161718192021222324vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt; &gt; retVal; levelOrder(root, retVal, 0); reverse(retVal.begin(), retVal.end()); return retVal;&#125;void levelOrder(TreeNode* root, vector&lt;vector&lt;int&gt; &gt; &amp;v, int currLevel) &#123; if (root == NULL) &#123; return; &#125; if (v.empty() || currLevel &gt; (v.size() - 1)) &#123; v.push_back(vector&lt;int&gt;()); &#125; v[currLevel].push_back(root-&gt;val); levelOrder(root-&gt;left, v, currLevel + 1); levelOrder(root-&gt;right, v, currLevel + 1);&#125; https://discuss.leetcode.com/topic/27413/c-4ms-solution C++ 4ms solution! First version costs 8ms: 123456789101112131415void levelOrder(vector&lt;vector&lt;int&gt;&gt; &amp;ans, TreeNode *node, int level) &#123; if (!node) return; if (level &gt;= ans.size()) ans.push_back(&#123;&#125;); ans[level].push_back(node-&gt;val); levelOrder(ans,node-&gt;left,level+1); levelOrder(ans,node-&gt;right,level+1);&#125;vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ans; levelOrder(ans,root,0); reverse(ans.begin(),ans.end()); return ans;&#125; Second version costs 4ms: 123456789101112131415161718int depth(TreeNode *root) &#123; if (!root) return 0; return max(depth(root-&gt;left),depth(root-&gt;right))+1;&#125;void levelOrder(vector&lt;vector&lt;int&gt;&gt; &amp;ans, TreeNode *node, int level) &#123; if (!node) return; ans[level].push_back(node-&gt;val); levelOrder(ans,node-&gt;left,level-1); levelOrder(ans,node-&gt;right,level-1);&#125;vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; int d = depth(root); vector&lt;vector&lt;int&gt;&gt; ans(d,vector&lt;int&gt; &#123;&#125;); levelOrder(ans,root,d-1); return ans;&#125; https://discuss.leetcode.com/topic/17702/19-line-c-8ms-solution-very-easy 19 line C++ 8ms Solution, very easy 1234567891011121314151617181920class Solution &#123;protected: vector&lt;vector&lt;int&gt;&gt; ans; void dfs(TreeNode *root, int height)&#123; if (root == NULL) return; while (ans.size() &lt;= height) ans.push_back(vector&lt;int&gt;()); ans[height].push_back(root-&gt;val); dfs(root-&gt;left, height + 1); dfs(root-&gt;right, height + 1); &#125;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; dfs(root, 0); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; https://discuss.leetcode.com/topic/21276/python-solutions-dfs-recursively-dfs-stack-bfs-queue Python solutions (dfs recursively, dfs+stack, bfs+queue). dfs recursively 123456789101112def levelOrderBottom1(self, root): res = [] self.dfs(root, 0, res) return resdef dfs(self, root, level, res): if root: if len(res) &lt; level + 1: res.insert(0, []) res[-(level+1)].append(root.val) self.dfs(root.left, level+1, res) self.dfs(root.right, level+1, res) dfs + stack 123456789101112def levelOrderBottom2(self, root): stack = [(root, 0)] res = [] while stack: node, level = stack.pop() if node: if len(res) &lt; level+1: res.insert(0, []) res[-(level+1)].append(node.val) stack.append((node.right, level+1)) stack.append((node.left, level+1)) return res bfs + queue 123456789101112def levelOrderBottom(self, root): queue, res = collections.deque([(root, 0)]), [] while queue: node, level = queue.popleft() if node: if len(res) &lt; level+1: res.insert(0, []) res[-(level+1)].append(node.val) queue.append((node.left, level+1)) queue.append((node.right, level+1)) return resreply quote https://discuss.leetcode.com/topic/7651/my-dfs-and-bfs-java-solution My DFS and BFS java solution DFS solution: 123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList&lt;List&lt;Integer&gt;&gt;(); if(root == null) return wrapList; queue.offer(root); while(!queue.isEmpty())&#123; int levelNum = queue.size(); List&lt;Integer&gt; subList = new LinkedList&lt;Integer&gt;(); for(int i=0; i&lt;levelNum; i++) &#123; if(queue.peek().left != null) queue.offer(queue.peek().left); if(queue.peek().right != null) queue.offer(queue.peek().right); subList.add(queue.poll().val); &#125; wrapList.add(0, subList); &#125; return wrapList; &#125;&#125; BFS solution: 1234567891011121314151617public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList&lt;List&lt;Integer&gt;&gt;(); levelMaker(wrapList, root, 0); return wrapList; &#125; public void levelMaker(List&lt;List&lt;Integer&gt;&gt; list, TreeNode root, int level) &#123; if(root == null) return; if(level &gt;= list.size()) &#123; list.add(0, new LinkedList&lt;Integer&gt;()); &#125; levelMaker(list, root.left, level+1); levelMaker(list, root.right, level+1); list.get(list.size()-level-1).add(root.val); &#125; &#125; 1ms, 96.03%, September 25, 2016 https://discuss.leetcode.com/topic/7489/simple-java-solution-with-linkedlist 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; LinkedList&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;List&lt;Integer&gt;&gt;(); addLevel(list, 0, root); return list; &#125; private void addLevel(LinkedList&lt;List&lt;Integer&gt;&gt; list, int level, TreeNode node) &#123; if (node == null) return; if (list.size()-1 &lt; level) list.addFirst(new LinkedList&lt;Integer&gt;()); list.get(list.size()-1-level).add(node.val); addLevel(list, level+1, node.left); addLevel(list, level+1, node.right); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[106. Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <url>%2Fp%2F6f813868%2F</url>
    <content type="text"><![CDATA[31.2% https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/?tab=Description Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. æ–¹æ³•ä¸€ï¼š æ£€æŸ¥è¾¹ç•Œæ¡ä»¶ ç±»ä¼¼105é¢˜ï¼Œå‰‘æŒ‡ offerç¬¬6é¢˜ 1234567891011121314151617181920212223class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; int n = inorder.size(); if(n&lt;=0) return NULL; TreeNode* root = helper(inorder, postorder, 0, n-1, 0, n-1); return root; &#125; TreeNode* helper(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int is, int ie, int ps, int pe)&#123; if(is&gt;ie || ps&gt;pe) return NULL; TreeNode* root = new TreeNode(postorder[pe]); int pos=is; for(;pos&lt;=ie;pos++)&#123; if(inorder[pos]==postorder[pe]) break; &#125; root-&gt;left = helper(inorder, postorder, is, pos-1, ps, pos-is+ps-1); root-&gt;right = helper(inorder, postorder, pos+1, ie, ps+pos-is, pe-1); return root; &#125;&#125;; cpp my code: å€Ÿé‰´105é¢˜ï¼Œé€’å½’æ€è·¯ã€‚ 12345678910111213141516171819202122class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return create(inorder, postorder, 0, inorder.size()-1, 0, postorder.size()-1); &#125; TreeNode* create(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int is, int ie, int ps, int pe)&#123; if(is&gt;ie || ps&gt;pe) return NULL; TreeNode* root = new TreeNode(postorder[pe]); int pos; for(int i=ie; i&gt;=is; i--)&#123; if(inorder[i]==root-&gt;val)&#123; pos = i; break; &#125; &#125; root-&gt;left = create(inorder, postorder, is, pos-1, ps, ps+pos-is-1); root-&gt;right = create(inorder, postorder, pos+1, ie, ps+pos-is, pe-1); return root; &#125;&#125;; æ–¹æ³•äºŒ: è¿­ä»£æ³• å¾…è§£å†³ https://discuss.leetcode.com/topic/4746/my-comprehension-of-o-n-solution-from-hongzhi My comprehension of O(n) solution from @hongzhi Below is the O(n) solution from @hongzhi but that discuss is closed now â€˜cause @hongzhi says little about his code. https://oj.leetcode.com/discuss/6334/here-is-my-o-n-solution-is-it-neat Iâ€™ve modified some of and tried this code and got AC. Just share about some comprehension about his code. Iâ€™ve modified vtn(vector) to stn(stack) in that stack is probably what this algs means and needs. What matters most is the meaning of stn. Only nodes whoes left side hasnâ€™t been handled will be pushed into stn. And inorder is organized as (inorder of left) root (inorder of right), And postorder is as (postorder of left) (postorder of right) root. So at the very begin, we only have root in stn and we check if inorder.back() == root-&gt;val and in most cases itâ€™s false(see Note 1). Then we make this node rootâ€™s right sub-node and push it into stn. Note 1: this is actually (inorder of right).back() == (postorder of right).back(), so if only thereâ€™s no right subtree or the answer will always be false. Note 2: we delete one node from postorder as we push one into stn. Now we have [root, rootâ€™s right] as stn and we check inorder.back() == stn.top()-&gt;val again. true means inorder.back() is the root node and needs handled left case. false means inorder.back() is the next right sub-node So when we encounter a true, we will cache stn.top() as p and delete both nodes from inorder and stn. Then we check inorder.size(), if thereâ€™s no nodes left, it means p has no left node. Else the next node in inorder could be pâ€™s left node or pâ€™s father which equals to the now stn.top() (remember we popped p from stn above). If the latter happens, it means p has no left node and we need to move on to pâ€™s father(stn.top()). If the former happens, it means p has one left node and itâ€™s postorder.back(), so we put it to pâ€™s left and delete it from the postorder and push the left node into stn â€˜cause it should be the next check node as the postorder is organized as above. Thatâ€™s all of it. The algs just build a binary tree. :) Inform me if thereâ€™s anything vague or wrong, Iâ€™m open to any suggestions. 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: TreeNode *buildTree(vector&lt;int&gt; &amp;inorder, vector&lt;int&gt; &amp;postorder) &#123; if(inorder.size() == 0)return NULL; TreeNode *p; TreeNode *root; stack&lt;TreeNode *&gt; stn; root = new TreeNode(postorder.back()); stn.push(root); postorder.pop_back(); while(true) &#123; if(inorder.back() == stn.top()-&gt;val) &#123; p = stn.top(); stn.pop(); inorder.pop_back(); if(inorder.size() == 0) break; if(stn.size() &amp;&amp; inorder.back() == stn.top()-&gt;val) continue; p-&gt;left = new TreeNode(postorder.back()); postorder.pop_back(); stn.push(p-&gt;left); &#125; else &#123; p = new TreeNode(postorder.back()); postorder.pop_back(); stn.top()-&gt;right = p; stn.push(p); &#125; &#125; return root; &#125;&#125;; https://discuss.leetcode.com/topic/5846/sharing-my-straightforward-recursive-solution Sharing my straightforward recursive solution TreeNode *buildTree(vector &amp;inorder, vector &amp;postorder) { return create(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);} TreeNode create(vector &amp;inorder, vector &amp;postorder, int is, int ie, int ps, int pe){ if(ps &gt; pe){ return nullptr; } TreeNode node = new TreeNode(postorder[pe]); int pos; for(int i = is; i &lt;= ie; i++){ if(inorder[i] == node-&gt;val){ pos = i; break; } } node-&gt;left = create(inorder, postorder, is, pos - 1, ps, ps + pos - is - 1); node-&gt;right = create(inorder, postorder, pos + 1, ie, pe - ie + pos, pe - 1); return node;}Actually, this problem is pretty similar as the previous one. Here is a like to that solution. https://discuss.leetcode.com/topic/1954/here-is-my-o-n-solution-is-it-neat Here is my O(n) solution. Is it neat? 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: TreeNode *buildTree(vector&lt;int&gt; &amp;inorder, vector&lt;int&gt; &amp;postorder) &#123; if(inorder.size() == 0)return NULL; TreeNode* p; TreeNode* root; vector&lt;int&gt; vint; vector&lt;TreeNode*&gt; vtn; root = new TreeNode(postorder.back()); vtn.push_back(root); postorder.pop_back(); while(true) &#123; if(inorder.back() == vtn.back()-&gt;val) &#123; p = vtn.back(); vtn.pop_back(); inorder.pop_back(); if(inorder.size() == 0) break; if(vtn.size()) if(inorder.back() == vtn.back()-&gt;val)continue; p-&gt;left = new TreeNode(postorder.back()); postorder.pop_back(); vtn.push_back(p-&gt;left); &#125; else &#123; p = new TreeNode(postorder.back()); postorder.pop_back(); vtn.back()-&gt;right = p; vtn.push_back(p); &#125; &#125; return root; &#125;&#125;; https://discuss.leetcode.com/topic/16861/my-c-solution My C++ Solution 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return helper(inorder,0,inorder.size(),postorder,0,postorder.size()); &#125;private: TreeNode* helper(vector&lt;int&gt;&amp; inorder,int i,int j,vector&lt;int&gt;&amp; postorder,int ii,int jj) &#123; // æ¯æ¬¡å–postorderçš„æœ€åŽä¸€ä¸ªå€¼midï¼Œå°†å…¶ä½œä¸ºæ ‘çš„æ ¹èŠ‚ç‚¹ // ç„¶åŽä»Žinroderä¸­æ‰¾åˆ°midï¼Œå°†å…¶åˆ†å‰²æˆä¸ºä¸¤éƒ¨åˆ†ï¼Œå·¦è¾¹ä½œä¸ºmidçš„å·¦å­æ ‘ï¼Œå³è¾¹ä½œä¸ºmidçš„å³å­æ ‘ // tree: 8 4 10 3 6 9 11 // Inorder [3 4 6] 8 [9 10 11] // postorder [3 6 4] [9 11 10] 8 if(i &gt;= j || ii &gt;= jj) return NULL; int mid = postorder[jj - 1]; auto f = find(inorder.begin() + i,inorder.begin() + j,mid); int dis = f - inorder.begin() - i; TreeNode* root = new TreeNode(mid); root -&gt; left = helper(inorder,i,i + dis,postorder,ii,ii + dis); root -&gt; right = helper(inorder,i + dis + 1,j,postorder,ii + dis,jj - 1); return root; &#125;&#125;; python 222ms, 30.82%, September 25, 2016 https://discuss.leetcode.com/topic/10516/a-python-recursive-solution A Python recursive solution 123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, inorder, postorder): &quot;&quot;&quot; :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode &quot;&quot;&quot; if not inorder or not postorder: return None root = TreeNode(postorder.pop()) inorderIndex = inorder.index(root.val) root.right = self.buildTree(inorder[inorderIndex+1:], postorder) root.left = self.buildTree(inorder[:inorderIndex], postorder) return root https://discuss.leetcode.com/topic/21286/python-short-solution-recursively Python short solution (recursively). 1234567def buildTree(self, inorder, postorder): if inorder: ind = inorder.index(postorder.pop()) root = TreeNode(inorder[ind]) root.right = self.buildTree(inorder[ind+1:], postorder) root.left = self.buildTree(inorder[:ind], postorder) return root java https://discuss.leetcode.com/topic/3296/my-recursive-java-code-with-o-n-time-and-o-n-space My recursive Java code with O(n) time and O(n) space The the basic idea is to take the last element in postorder array as the root, find the position of the root in the inorder array; then locate the range for left sub-tree and right sub-tree and do recursion. Use a HashMap to record the index of root in the inorder array. 123456789101112131415161718192021public TreeNode buildTreePostIn(int[] inorder, int[] postorder) &#123; if (inorder == null || postorder == null || inorder.length != postorder.length) return null; HashMap&lt;Integer, Integer&gt; hm = new HashMap&lt;Integer,Integer&gt;(); for (int i=0;i&lt;inorder.length;++i) hm.put(inorder[i], i); return buildTreePostIn(inorder, 0, inorder.length-1, postorder, 0, postorder.length-1,hm);&#125;private TreeNode buildTreePostIn(int[] inorder, int is, int ie, int[] postorder, int ps, int pe, HashMap&lt;Integer,Integer&gt; hm)&#123; if (ps&gt;pe || is&gt;ie) return null; TreeNode root = new TreeNode(postorder[pe]); int ri = hm.get(postorder[pe]); TreeNode leftchild = buildTreePostIn(inorder, is, ri-1, postorder, ps, ps+ri-is-1, hm); TreeNode rightchild = buildTreePostIn(inorder,ri+1, ie, postorder, ps+ri-is, pe-1, hm); root.left = leftchild; root.right = rightchild; return root;&#125; https://discuss.leetcode.com/topic/3296/my-recursive-java-code-with-o-n-time-and-o-n-space/2 This is my version: similar idea, but no HashMap needed! (TreeNode end is the boundary of left subtree.) 1234567891011121314151617181920212223242526272829303132int pInorder; // index of inorder arrayint pPostorder; // index of postorder arrayprivate TreeNode buildTree(int[] inorder, int[] postorder, TreeNode end) &#123; if (pPostorder &lt; 0) &#123; return null; &#125; // create root node TreeNode n = new TreeNode(postorder[pPostorder--]); // if right node exist, create right subtree if (inorder[pInorder] != n.val) &#123; n.right = buildTree(inorder, postorder, n); &#125; pInorder--; // if left node exist, create left subtree if ((end == null) || (inorder[pInorder] != end.val)) &#123; n.left = buildTree(inorder, postorder, end); &#125; return n;&#125;public TreeNode buildTree(int[] inorder, int[] postorder) &#123; pInorder = inorder.length - 1; pPostorder = postorder.length - 1; return buildTree(inorder, postorder, null);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[105. Construct Binary Tree from Preorder and Inorder Traversal]]></title>
    <url>%2Fp%2Fbf9e0006%2F</url>
    <content type="text"><![CDATA[31.1% https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?tab=Description Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. æ–¹æ³•ä¸€ï¼š æ ¹æ®preorderå’Œinorderçš„ç‰¹ç‚¹ï¼Œæ‰¾è§„å¾‹ã€‚ å‰‘æŒ‡offerï¼Œ ç¬¬6é¢˜ æ–°å»ºä¸€ä¸ªèŠ‚ç‚¹ä»£ç ï¼šTreeNode* node = new TreeNode(preorder[ps]); 1234567891011121314151617181920TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; return create(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);&#125;TreeNode* create(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int ps, int pe, int is, int ie)&#123; if(ps &gt; pe)&#123; return nullptr; &#125; TreeNode* node = new TreeNode(preorder[ps]); int pos; for(int i = is; i &lt;= ie; i++)&#123; if(inorder[i] == node-&gt;val)&#123; pos = i; break; &#125; &#125; node-&gt;left = create(preorder, inorder, ps + 1, ps + pos - is, is, pos - 1); node-&gt;right = create(preorder, inorder, pe - ie + pos + 1, pe, pos + 1, ie); return node;&#125; æ–¹æ³•äºŒï¼š https://discuss.leetcode.com/topic/10244/my-o-n-19ms-solution-without-recusion-hope-help-you My O(n)(19ms) solution without recusion. Hope help you! 12345678910111213141516171819202122232425class Solution &#123;public: TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; TreeNode *root=NULL; stack&lt;TreeNode *&gt; MyData; if(preorder.empty()) return root; root = new TreeNode(preorder[0]); MyData.push(root); int index = 0; for(int i=1; i&lt;=preorder.size(); i++) &#123; TreeNode *cur = MyData.top(); if((MyData.top()-&gt;val)!=inorder[index]) &#123; cur-&gt;left = new TreeNode(preorder[i]); MyData.push(cur-&gt;left); &#125; else &#123; while(!MyData.empty() &amp;&amp; ((MyData.top()-&gt;val)==inorder[index])) &#123; cur=MyData.top(); MyData.pop(); index++; &#125; if(index&lt;inorder.size()) &#123; cur-&gt;right = new TreeNode(preorder[i]); MyData.push(cur-&gt;right); &#125; &#125; &#125; return root; &#125;&#125;; https://discuss.leetcode.com/topic/16860/my-neat-c-solution My neat C++ solution 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: /* from Preorder and Inorder Traversal */ TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; return helper(preorder,0,preorder.size(),inorder,0,inorder.size()); &#125; TreeNode* helper(vector&lt;int&gt;&amp; preorder,int i,int j,vector&lt;int&gt;&amp; inorder,int ii,int jj) &#123; // tree 8 4 5 3 7 3 // preorder 8 [4 3 3 7] [5] // inorder [3 3 4 7] 8 [5] // æ¯æ¬¡ä»Ž preorder å¤´éƒ¨å–ä¸€ä¸ªå€¼ midï¼Œä½œä¸ºæ ‘çš„æ ¹èŠ‚ç‚¹ // æ£€æŸ¥ mid åœ¨ inorder ä¸­ çš„ä½ç½®ï¼Œåˆ™ mid å‰é¢éƒ¨åˆ†å°†ä½œä¸º æ ‘çš„å·¦å­æ ‘ï¼Œå³éƒ¨åˆ†ä½œä¸ºæ ‘çš„å³å­æ ‘ if(i &gt;= j || ii &gt;= j) return NULL; int mid = preorder[i]; auto f = find(inorder.begin() + ii,inorder.begin() + jj,mid); int dis = f - inorder.begin() - ii; TreeNode* root = new TreeNode(mid); root -&gt; left = helper(preorder,i + 1,i + 1 + dis,inorder,ii,ii + dis); root -&gt; right = helper(preorder,i + 1 + dis,j,inorder,ii + dis + 1,jj); return root; &#125;&#125;; cpp https://discuss.leetcode.com/topic/795/the-iterative-solution-is-easier-than-you-think The iterative solution is easier than you think! I dinâ€™t find iterative solutions discussed in the old Discuss. So, I thought, I will add my solution in here. The idea is as follows: Keep pushing the nodes from the preorder into a stack (and keep making the tree by adding nodes to the left of the previous node) until the top of the stack matches the inorder. At this point, pop the top of the stack until the top does not equal inorder (keep a flag to note that you have made a pop). Repeat 1 and 2 until preorder is empty. The key point is that whenever the flag is set, insert a node to the right and reset the flag. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; if(preorder.size()==0) return NULL; stack&lt;int&gt; s; stack&lt;TreeNode *&gt; st; TreeNode *t,*r,*root; int i,j,f; f=i=j=0; s.push(preorder[i]); root = new TreeNode(preorder[i]); st.push(root); t = root; i++; while(i&lt;preorder.size()) &#123; if(!st.empty() &amp;&amp; st.top()-&gt;val==inorder[j]) &#123; t = st.top(); st.pop(); s.pop(); f = 1; j++; &#125; else &#123; if(f==0) &#123; s.push(preorder[i]); t -&gt; left = new TreeNode(preorder[i]); t = t -&gt; left; st.push(t); i++; &#125; else &#123; f = 0; s.push(preorder[i]); t -&gt; right = new TreeNode(preorder[i]); t = t -&gt; right; st.push(t); i++; &#125; &#125; &#125; return root; &#125;&#125;; 33ms, 64.41%, September 25, 2016 https://discuss.leetcode.com/topic/5845/sharing-my-straightforward-recursive-solution Sharing my straightforward recursive solution é€’å½’ï¼Œç›´æŽ¥äº†å½“ 1234567891011121314151617181920TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; return create(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);&#125;TreeNode* create(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int ps, int pe, int is, int ie)&#123; if(ps &gt; pe)&#123; return nullptr; &#125; TreeNode* node = new TreeNode(preorder[ps]); int pos; for(int i = is; i &lt;= ie; i++)&#123; if(inorder[i] == node-&gt;val)&#123; pos = i; break; &#125; &#125; node-&gt;left = create(preorder, inorder, ps + 1, ps + pos - is, is, pos - 1); node-&gt;right = create(preorder, inorder, pe - ie + pos + 1, pe, pos + 1, ie); return node;&#125; The first element in preorder array can divide inorder array into two parts. Then we can divide preorder array into two parts. Make this element a node. And the left sub-tree of this node is the left part, right sub-tree of this node is the right part. This problem can be solved following this logic. python 199ms, 37.16%, September 25, 2016 https://discuss.leetcode.com/topic/21287/python-short-recursive-solution Python short recursive solution. 1234567def buildTree(self, preorder, inorder): if inorder: ind = inorder.index(preorder.pop(0)) root = TreeNode(inorder[ind]) root.left = self.buildTree(preorder, inorder[0:ind]) root.right = self.buildTree(preorder, inorder[ind+1:]) return root https://discuss.leetcode.com/topic/10474/a-python-recursive-solution A Python recursive solution The idea is to find the root first, and then recursively build each left and right subtree Only Solution 3 could pass the OJ, but theoretically they should all work â€¦ Solution 1 - clean and easy to understand, but Memory Limit Exceeded â€¦ 123456789101112131415161718192021222324# Definition for a binary tree node# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # @param preorder, a list of integers # @param inorder, a list of integers # @return a tree node # 1:59 def buildTree(self, preorder, inorder): if not preorder or not inorder: return None rootValue = preorder[0] root = TreeNode(rootValue) inorderIndex = inorder.index(rootValue) root.left = self.buildTree(preorder[1:inorderIndex+1], inorder[:inorderIndex]) root.right = self.buildTree(preorder[inorderIndex+1:], inorder[inorderIndex+1:]) return root Solution 2 - Same as solution one, but pass index instead of doing list slicing (and thus reduce the memory usage) 1234567891011121314151617181920212223class Solution: # @param preorder, a list of integers # @param inorder, a list of integers # @return a tree node # 1:59 def buildTree(self, preorder, inorder, preorderStart = 0, preorderEnd = None, inorderStart = 0, inorderEnd = None): if preorderEnd is None: preorderEnd = len(preorder) - 1 if inorderEnd is None: inorderEnd = len(inorder) - 1 if preorderStart &gt; len(preorder) - 1 or inorderStart &gt; inorderEnd: return None rootValue = preorder[preorderStart] root = TreeNode(rootValue) inorderIndex = inorder.index(rootValue) root.left = self.buildTree(preorder, inorder, preorderStart+1, inorderIndex, inorderStart, inorderIndex-1) root.right = self.buildTree(preorder, inorder, preorderStart+inorderIndex+1-inorderStart, preorderEnd, inorderIndex+1, inorderEnd) return root Solution 3 - Based on Solution 1, we donâ€™t necessary need to slice the preorder array, when we are done with the left tree, the left half of the preorder array should already be empty 123456789101112131415161718192021222324# Definition for a binary tree node# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # @param preorder, a list of integers # @param inorder, a list of integers # @return a tree node # 1:59 def buildTree(self, preorder, inorder): if not preorder or not inorder: return None rootValue = preorder.pop(0) root = TreeNode(rootValue) inorderIndex = inorder.index(rootValue) root.left = self.buildTree(preorder, inorder[:inorderIndex]) root.right = self.buildTree(preorder, inorder[inorderIndex+1:]) return root java https://discuss.leetcode.com/topic/3695/my-accepted-java-solution My Accepted Java Solution Hi guys, this is my Java solution. I read this post, which is very helpful. The basic idea is here: Say we have 2 arrays, PRE and IN. Preorder traversing implies that PRE[0] is the root node. Then we can find this PRE[0] in IN, say itâ€™s IN[5]. Now we know that IN[5] is root, so we know that IN[0] - IN[4] is on the left side, IN[6] to the end is on the right side. Recursively doing this on subarrays, we can build a tree out of it :) Hope this helps. 12345678910111213141516171819public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return helper(0, 0, inorder.length - 1, preorder, inorder);&#125;public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) &#123; if (preStart &gt; preorder.length - 1 || inStart &gt; inEnd) &#123; return null; &#125; TreeNode root = new TreeNode(preorder[preStart]); int inIndex = 0; // Index of current root in inorder for (int i = inStart; i &lt;= inEnd; i++) &#123; if (inorder[i] == root.val) &#123; inIndex = i; &#125; &#125; root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder); root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder); return root;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[104. Maximum Depth of Binary Tree]]></title>
    <url>%2Fp%2F22757163%2F</url>
    <content type="text"><![CDATA[51.2% https://leetcode.com/problems/maximum-depth-of-binary-tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. æ–¹æ³•ä¸€ï¼š æ·±åº¦ä¼˜å…ˆéåŽ† My code of C++, Depth-first-search and Breadth-first-search Depth-first-search Only one line code. 1234int maxDepth(TreeNode *root)&#123; return root == NULL ? 0 : max(maxDepth(root -&gt; left), maxDepth(root -&gt; right)) + 1;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; return root?max(maxDepth(root-&gt;left), maxDepth(root-&gt;right))+1:0; &#125;&#125;; æ–¹æ³•äºŒï¼š å¹¿åº¦ä¼˜å…ˆæœç´¢ ä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ—ï¼Œå°†root pushè¿›å–ï¼Œç„¶åŽæ¯æ¬¡å¯¹é˜Ÿåˆ—çš„é•¿åº¦è¿›è¡ŒéåŽ†ï¼Œres++ï¼› Breadth-first-search Calculate the count of the last level. æ³¨æ„ï¼šæ ˆå’Œé˜Ÿåˆ—ï¼Œåˆéƒ½push pop,æ²¡æœ‰push_back,pop_back 12345678910111213141516171819202122232425int maxDepth(TreeNode *root)&#123; if(root == NULL) return 0; int res = 0; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty()) &#123; ++ res; for(int i = 0, n = q.size(); i &lt; n; ++ i) &#123; TreeNode *p = q.front(); q.pop(); if(p -&gt; left != NULL) q.push(p -&gt; left); if(p -&gt; right != NULL) q.push(p -&gt; right); &#125; &#125; return res;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š å…¶å®žå°±æ˜¯å±‚åºéåŽ† 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(root==NULL) return 0; queue&lt;TreeNode*&gt; que; que.push(root); int res = 0; while(!que.empty())&#123; res++; int n = que.size(); for(int i=0; i&lt;n; i++)&#123; TreeNode* cur = que.front(); que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); &#125; &#125; return res; &#125;&#125;; å­¦ä¹ ä¸€ä¸‹queueçš„æˆå‘˜å‡½æ•°ï¼Œæœ‰backï¼Œpushï¼Œpopï¼Œæ²¡æœ‰push_back (constructor) Construct queue (public member function ) empty Test whether container is empty (public member function ) size Return size (public member function ) front Access next element (public member function ) back Access last element (public member function ) push Insert element (public member function ) emplace Construct and insert element (public member function ) pop Remove next element (public member function ) swap Swap contents (public member function ) å­¦ä¹ ä¸€ä¸‹æ ˆçš„æˆå‘˜å‡½æ•°ï¼Œæœ‰pop push ç­‰ï¼Œæ²¡æœ‰push_back pop_back (constructor)Construct stack (public member function )emptyTest whether container is empty (public member function )sizeReturn size (public member function )topAccess next element (public member function )pushInsert element (public member function )emplaceConstruct and insert element (public member function )popRemove top element (public member function )swapSwap contents (public member function ) https://discuss.leetcode.com/topic/10317/my-code-of-c-depth-first-search-and-breadth-first-search My code of C++, Depth-first-search and Breadth-first-search Depth-first-search Only one line code. 1234int maxDepth(TreeNode *root)&#123; return root == NULL ? 0 : max(maxDepth(root -&gt; left), maxDepth(root -&gt; right)) + 1;&#125; Breadth-first-search Calculate the count of the last level. 12345678910111213141516171819202122232425int maxDepth(TreeNode *root)&#123; if(root == NULL) return 0; int res = 0; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty()) &#123; ++ res; for(int i = 0, n = q.size(); i &lt; n; ++ i) &#123; TreeNode *p = q.front(); q.pop(); if(p -&gt; left != NULL) q.push(p -&gt; left); if(p -&gt; right != NULL) q.push(p -&gt; right); &#125; &#125; return res;&#125; python https://discuss.leetcode.com/topic/24177/1-line-ruby-and-python 1 line Ruby and Python Just a bit shorter/different than previous solutions. Python: 12def maxDepth(self, root): return 1 + max(map(self.maxDepth, (root.left, root.right))) if root else 0 java https://discuss.leetcode.com/topic/4087/simple-solution-using-java Simple solution using Java if the node does not exist, simply return 0. Otherwise, return the 1+the longer distance of its subtree. 123456public int maxDepth(TreeNode root) &#123; if(root==null)&#123; return 0; &#125; return 1+Math.max(maxDepth(root.left),maxDepth(root.right)); &#125; https://discuss.leetcode.com/topic/27017/clean-java-iterative-solution Clean Java Iterative Solution I do believe if you can think of an iterative solution, itâ€™s always better than using a recursive one. And technical y every recursive solution can be converted into a equivalent iterative one. 123456789101112131415161718192021222324public int maxDepth(TreeNode root) &#123; if (root == null) return 0; Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;(); stack.push(root); int count = 0; while (!stack.isEmpty()) &#123; int size = stack.size(); while (size-- &gt; 0) &#123; TreeNode cur = stack.pop(); if (cur.left != null) stack.addLast(cur.left); if (cur.right != null) stack.addLast(cur.right); &#125; count++; &#125; return count;&#125; https://discuss.leetcode.com/topic/33826/two-java-iterative-solution-dfs-and-bfs Two Java Iterative solution DFS and BFS This is the iterative version of finding the depth. The recursive version is trivial, so expect the interviewer to ask for the iterative version. I used two stacks for the dfs one and a queue for the level-order traversal one. Level order one is faster. DFS 1234567891011121314151617181920212223242526public int maxDepth(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; value = new Stack&lt;&gt;(); stack.push(root); value.push(1); int max = 0; while(!stack.isEmpty()) &#123; TreeNode node = stack.pop(); int temp = value.pop(); max = Math.max(temp, max); if(node.left != null) &#123; stack.push(node.left); value.push(temp+1); &#125; if(node.right != null) &#123; stack.push(node.right); value.push(temp+1); &#125; &#125; return max;&#125;// 7ms BFS 1234567891011121314151617181920212223public int maxDepth(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int count = 0; while(!queue.isEmpty()) &#123; int size = queue.size(); while(size-- &gt; 0) &#123; TreeNode node = queue.poll(); if(node.left != null) &#123; queue.offer(node.left); &#125; if(node.right != null) &#123; queue.offer(node.right); &#125; &#125; count++; &#125; return count;&#125;// 3ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[103. Binary Tree Zigzag Level Order Traversal]]></title>
    <url>%2Fp%2Fa0a3d7c5%2F</url>
    <content type="text"><![CDATA[34.8% https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/ Given a binary tree, return the zigzag level order traversal of its nodesâ€™ values. (ie, from left to right, then right to left for the next level and alternate between). 12345678910111213For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its zigzag level order traversal as:[ [3], [20,9], [15,7]] æ–¹æ³•ä¸€ï¼š å±‚åºéåŽ†ï¼Œç„¶åŽæŠŠç›¸åº”çš„åè½¬å°±å¯ä»¥äº† 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; q; // é¦–é€‰æŠŠrootåŽ‹è¿›åŽ»ï¼Œä¸è¦å¿˜äº† q.push(root); while(q.size())&#123; int n = q.size(); vector&lt;int&gt; tmp; for(int i=0; i&lt;n; i++)&#123; // queueå«frontï¼Œstackå«topï¼Œä¸è¦å¼„æ··äº† TreeNode* cur = q.front(); q.pop(); tmp.push_back(cur-&gt;val); if(cur-&gt;left) q.push(cur-&gt;left); if(cur-&gt;right) q.push(cur-&gt;right); &#125; // éåŽ†ä¸€åœˆåŽï¼ŒæŠŠç»“æžœåŽ‹å…¥ res.push_back(tmp); &#125; for(int i=0; i&lt;res.size(); i++) if(i%2) reverse(res[i].begin(), res[i].end()); return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>stack</tag>
        <tag>tree</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[102. Binary Tree Level Order Traversal]]></title>
    <url>%2Fp%2Fbeb6650a%2F</url>
    <content type="text"><![CDATA[37.7% https://leetcode.com/problems/binary-tree-level-order-traversal/?tab=Description Given a binary tree, return the level order traversal of its nodesâ€™ values. (ie, from left to right, level by level). 12345678910111213For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its level order traversal as:[ [3], [9,20], [15,7]] äºŒå‰æ ‘å±‚åºéåŽ† å¯¹äºŽäºŒå‰æ ‘çš„å…ˆåºã€ä¸­åºã€åŽç»­éåŽ†ï¼Œåº”è¯¥æŽŒæ¡çš„éžå¸¸ç‰¢é ã€‚å¯¹äºŽå±‚åºéåŽ†ï¼ŒæŽŒæ¡çš„åº”è¯¥å¦‚åŒå…ˆåºã€ä¸­åºã€åŽç»­éåŽ†ä¸€æ ·ã€‚ æ–¹æ³•ä¸€ï¼š å…ˆåºéåŽ†ï¼ŒåŒæ—¶ä¼ å…¥æ ‘çš„æ·±åº¦ï¼Œå¦‚æžœæ ‘åˆ°è¾¾æ–°çš„æ·±åº¦ï¼Œåˆ™reté‡ŒåŠ å…¥ä¸€ä¸ªæ–°çš„vector. 1234567891011121314151617vector&lt;vector&lt;int&gt;&gt; ret;void buildVector(TreeNode *root, int depth)&#123; if(root == NULL) return; if(ret.size() == depth) ret.push_back(vector&lt;int&gt;()); ret[depth].push_back(root-&gt;val); buildVector(root-&gt;left, depth + 1); buildVector(root-&gt;right, depth + 1);&#125;vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; buildVector(root, 0); return ret;&#125; æ–¹æ³•äºŒï¼š ä½¿ç”¨ä¸€ä¸ªå‡½æ•°æ¥è¾…åŠ© é€’å½’è°ƒç”¨ 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(root==NULL) return res; vector&lt;TreeNode*&gt; cur = &#123;root&#125;; helper(cur, res); return res; &#125; void helper(vector&lt;TreeNode*&gt; cur, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(cur.size()==0) return; vector&lt;int&gt; tmp; vector&lt;TreeNode*&gt; nex; for(auto root:cur)&#123; tmp.push_back(root-&gt;val); if(root-&gt;left !=NULL) nex.push_back(root-&gt;left); if(root-&gt;right!=NULL) nex.push_back(root-&gt;right); &#125; res.push_back(tmp); helper(nex, res); return; &#125;&#125;; æ–¹æ³•ä¸‰ï¼š ä½¿ç”¨é˜Ÿåˆ—ï¼Œéžé€’å½’ï¼Œä¸­é—´ä½¿ç”¨ä¸€ä¸ªmarkerï¼ŒNULLè¡¨ç¤ºé—´éš”ã€‚ æ³¨æ„é˜Ÿåˆ—é‡Œæ˜¯pushå’Œpopï¼Œæ²¡æœ‰push_backå’Œpop_back. 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt; &gt; result; if (!root) return result; queue&lt;TreeNode*&gt; q; q.push(root); q.push(NULL); vector&lt;int&gt; cur_vec; while(!q.empty()) &#123; TreeNode* t = q.front(); q.pop(); if (t==NULL) &#123; result.push_back(cur_vec); cur_vec.resize(0); if (q.size() &gt; 0) &#123; q.push(NULL); &#125; &#125; else &#123; cur_vec.push_back(t-&gt;val); if (t-&gt;left) q.push(t-&gt;left); if (t-&gt;right) q.push(t-&gt;right); &#125; &#125; return result; &#125;&#125;; æ–¹æ³•å››ï¼š ä½¿ç”¨é˜Ÿåˆ—ï¼Œé’ˆå¯¹æ¯ä¸€å±‚ï¼Œä¸€ä¸ªä¿å­˜è‡³ä¸€ä¸ªvectorä¸­ï¼ŒåŒæ—¶æ›´æ–°queue 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty())&#123; int n = que.size(); vector&lt;int&gt; tmp; for(int i=0; i&lt;n; i++)&#123; TreeNode* cur = que.front(); que.pop(); tmp.push_back(cur-&gt;val); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); &#125; res.push_back(tmp); &#125; return res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/4894/one-of-c-solutions-preorder One of C++ solutions (preorder) å…ˆåºéåŽ†ï¼ŒåŒæ—¶retåœ¨å‡½æ•°å¤–é¢ 1234567891011121314151617vector&lt;vector&lt;int&gt;&gt; ret;void buildVector(TreeNode *root, int depth)&#123; if(root == NULL) return; if(ret.size() == depth) ret.push_back(vector&lt;int&gt;()); ret[depth].push_back(root-&gt;val); buildVector(root-&gt;left, depth + 1); buildVector(root-&gt;right, depth + 1);&#125;vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; buildVector(root, 0); return ret;&#125; https://discuss.leetcode.com/topic/10469/c-solution-using-only-one-queue-use-a-marker-null C++ solution using only one queue / use a marker NULL ä½¿ç”¨é˜Ÿåˆ— å…ˆå…¥å…ˆå‡ºï¼Œæ˜Žæ˜¾è¦ä½¿ç”¨é˜Ÿåˆ— 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt; &gt; result; if (!root) return result; queue&lt;TreeNode*&gt; q; q.push(root); q.push(NULL); vector&lt;int&gt; cur_vec; while(!q.empty()) &#123; TreeNode* t = q.front(); q.pop(); if (t==NULL) &#123; result.push_back(cur_vec); cur_vec.resize(0); if (q.size() &gt; 0) &#123; q.push(NULL); &#125; &#125; else &#123; cur_vec.push_back(t-&gt;val); if (t-&gt;left) q.push(t-&gt;left); if (t-&gt;right) q.push(t-&gt;right); &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/16900/short-8ms-c-solution-with-queue Short 8ms C++ solution with queue 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; if (!root) &#123; return &#123;&#125;; &#125; vector&lt;int&gt; row; vector&lt;vector&lt;int&gt; &gt; result; queue&lt;TreeNode*&gt; q; q.push(root); int count = 1; while (!q.empty()) &#123; if (q.front()-&gt;left) &#123; q.push(q.front()-&gt;left); &#125; if (q.front()-&gt;right) &#123; q.push(q.front()-&gt;right); &#125; row.push_back(q.front()-&gt;val), q.pop(); if (--count == 0) &#123; result.emplace_back(row), row.clear(); count = q.size(); &#125; &#125; return result; &#125;&#125;; my code: å…¶ä¸€ï¼Œæ˜¯vector&lt;TeeNode*&gt; è€Œä¸æ˜¯vector 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(root==NULL) return res; vector&lt;TreeNode*&gt; cur = &#123;root&#125;; helper(cur, res); return res; &#125; void helper(vector&lt;TreeNode*&gt; cur, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(cur.size()==0) return; vector&lt;int&gt; tmp; vector&lt;TreeNode*&gt; nex; for(auto root:cur)&#123; tmp.push_back(root-&gt;val); if(root-&gt;left !=NULL) nex.push_back(root-&gt;left); if(root-&gt;right!=NULL) nex.push_back(root-&gt;right); &#125; res.push_back(tmp); helper(nex, res); return; &#125;&#125;; python https://discuss.leetcode.com/topic/26402/5-6-lines-fast-python-solution-48-ms 5-6 lines fast python solution (48 ms) level is a list of the nodes in the current level. Keep appending a list of the values of these nodes to ans and then updating level with all the nodes in the next level (kids) until it reaches an empty level. Pythonâ€™s list comprehension makes it easier to deal with many conditions in a concise manner. Solution 1, (6 lines) 1234567def levelOrder(self, root): ans, level = [], [root] while root and level: ans.append([node.val for node in level]) LRpair = [(node.left, node.right) for node in level] level = [leaf for LR in LRpair for leaf in LR if leaf] return ans Solution 2, (5 lines), same idea but use only one list comprehension in while loop to get the next level 123456def levelOrder(self, root): ans, level = [], [root] while root and level: ans.append([node.val for node in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return ans Solution 3 (10 lines), just an expansion of solution 1&amp;2 for better understanding. 1234567891011def levelOrder(self, root): if not root: return [] ans, level = [], [root] while level: ans.append([node.val for node in level]) temp = [] for node in level: temp.extend([node.left, node.right]) level = [leaf for leaf in temp if leaf] return ans 82ms, 5.83%, September 23, 2016 https://discuss.leetcode.com/topic/26402/5-6-lines-fast-python-solution-48-ms 123456789101112131415161718# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrder(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[List[int]] &quot;&quot;&quot; ans, level = [], [root] while root and level: ans.append([node.val for node in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return ans java https://discuss.leetcode.com/topic/7647/java-solution-with-a-queue-used Java solution with a queue used 123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList&lt;List&lt;Integer&gt;&gt;(); if(root == null) return wrapList; queue.offer(root); while(!queue.isEmpty())&#123; int levelNum = queue.size(); List&lt;Integer&gt; subList = new LinkedList&lt;Integer&gt;(); for(int i=0; i&lt;levelNum; i++) &#123; if(queue.peek().left != null) queue.offer(queue.peek().left); if(queue.peek().right != null) queue.offer(queue.peek().right); subList.add(queue.poll().val); &#125; wrapList.add(subList); &#125; return wrapList; &#125;&#125; https://discuss.leetcode.com/topic/7332/java-solution-using-dfs Java Solution using DFS Nothing special. Just wanna provide a different way from BFS. 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); levelHelper(res, root, 0); return res; &#125; public void levelHelper(List&lt;List&lt;Integer&gt;&gt; res, TreeNode root, int height) &#123; if (root == null) return; if (height &gt;= res.size()) &#123; res.add(new LinkedList&lt;Integer&gt;()); &#125; res.get(height).add(root.val); levelHelper(res, root.left, height+1); levelHelper(res, root.right, height+1); &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[101. Symmetric Tree]]></title>
    <url>%2Fp%2F1260a346%2F</url>
    <content type="text"><![CDATA[37.5% https://leetcode.com/problems/symmetric-tree/ Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). 1234567For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \ 3 4 4 3 123456But the following [1,2,2,null,3,null,3] is not: 1 / \ 2 2 \ \ 3 3 Note: Bonus points if you could solve it both recursively and iteratively. æ–¹æ³•ä¸€ï¼š è¿­ä»£ æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; return helper(root, root); &#125; bool helper(TreeNode* left, TreeNode* right)&#123; if(!left &amp;&amp; !right) return true; if(!left || !right) return false; return left-&gt;val == right-&gt;val &amp;&amp; helper(left-&gt;left, right-&gt;right) &amp;&amp; helper(left-&gt;right, right-&gt;left); &#125;&#125;; æ–¹æ³•äºŒï¼š 4ms, 25.42%, July 14th, 2016 ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—ï¼Œä¸€ä¸ªå…ˆrootï¼Œå†å·¦å†å³çš„å±‚åºï¼Œä¸€ä¸ªå…ˆrootï¼Œå†å³å†å·¦çš„éåŽ†ã€‚ https://discuss.leetcode.com/topic/4332/my-c-accepted-code-in-16ms-with-iteration-solution 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; TreeNode *left, *right; if(!root) return true; queue&lt;TreeNode*&gt; q1, q2; q1.push(root-&gt;left); q2.push(root-&gt;right); while(!q1.empty() &amp;&amp; !q2.empty())&#123; left = q1.front(); q1.pop(); right = q2.front(); q2.pop(); if(left == NULL &amp;&amp; right == NULL) continue; if(left == NULL || right == NULL) return false; if(left-&gt;val != right-&gt;val) return false; q1.push(left-&gt;left); q1.push(left-&gt;right); q2.push(right-&gt;right); q2.push(right-&gt;left); &#125; return true; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; queue&lt;TreeNode*&gt; q1, q2; TreeNode* left, *right; q1.push(root-&gt;left); q2.push(root-&gt;right); while(!q1.empty() &amp;&amp; !q2.empty())&#123; left = q1.front(); // ä½¿ç”¨å˜é‡å‰è¦å…ˆå®šä¹‰ï¼Œä¸è¦å¿˜äº† TreNode* right = q2.front(); q1.pop(); // è¦åœ¨ä¸‹é¢çš„åˆ¤æ–­å‰popï¼Œä¸ç„¶å°±è¿›å…¥äº†æ­»å¾ªçŽ¯äº†ã€‚ q2.pop(); if(!left &amp;&amp; !right) continue; //æ³¨æ„ï¼š æ­¤å¤„ä¸åŒäºŽé€’å½’ï¼Œä¸èƒ½ç›´æŽ¥return true; if(!left || !right || left-&gt;val != right-&gt;val) return false; q1.push(left-&gt;left); q1.push(left-&gt;right); q2.push(right-&gt;right); q2.push(right-&gt;left); &#125; return true; &#125;&#125;; 4ms, 25.42%, July 14th, 2016 https://discuss.leetcode.com/topic/9503/15-lines-of-c-solution-8-ms 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; return helper(root-&gt;left, root-&gt;right); &#125; bool helper(TreeNode* p, TreeNode* q)&#123; if(!p &amp;&amp; !q) return true; else if(!p || !q) return false; if(p-&gt;val != q-&gt;val) return false; return helper(p-&gt;left, q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left); &#125;&#125;; python 64ms, 31.10%, July 14th, 2016 https://discuss.leetcode.com/topic/8440/6line-ac-python 12345678910111213141516171819# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; def isSym(L, R): if not L and not R: return True if L and R and L.val == R.val: return isSym(L.left, R.right) and isSym(L.right, R.left) return False return isSym(root, root) my code 12345678910111213141516class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if not root: return True return self.helper(root.left, root.right) def helper(self, left, right): if not left and not right: return True if left and right: return left.val==right.val and self.helper(left.left, right.right) and self.helper(left.right, right.left) return False java 1ms, 25.80%, July 14th, 2016 https://discuss.leetcode.com/topic/28589/1ms-recursive-java-solution-easy-to-understand 123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root == null) return true; return isMirror(root.left, root.right); &#125; public boolean isMirror(TreeNode p, TreeNode q)&#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; return (p.val == q.val) &amp;&amp; isMirror(p.left, q.right) &amp;&amp; isMirror(p.right, q.left); &#125;&#125; 3ms, 5.59%, July 14th, 2016 Recursive and non-recursive solutions in Java https://discuss.leetcode.com/topic/5941/recursive-and-non-recursive-solutions-in-java Recursiveâ€“400ms: 1234567891011public boolean isSymmetric(TreeNode root) &#123; return root==null || isSymmetricHelp(root.left, root.right);&#125;private boolean isSymmetricHelp(TreeNode left, TreeNode right)&#123; if(left==null || right==null) return left==right; if(left.val!=right.val) return false; return isSymmetricHelp(left.left, right.right) &amp;&amp; isSymmetricHelp(left.right, right.left);&#125; Non-recursive(use Stack)â€“460ms: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root==null) return true; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode left, right; if(root.left!=null)&#123; if(root.right==null) return false; stack.push(root.left); stack.push(root.right); &#125; else if(root.right!=null)&#123; return false; &#125; while(!stack.empty())&#123; if(stack.size()%2!=0) return false; right = stack.pop(); left = stack.pop(); if(right.val!=left.val) return false; if(left.left!=null)&#123; if(right.right==null) return false; stack.push(left.left); stack.push(right.right); &#125; else if(right.right!=null)&#123; return false; &#125; if(left.right!=null)&#123; if(right.left==null) return false; stack.push(left.right); stack.push(right.left); &#125; else if(right.left!=null)&#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100. Same Tree]]></title>
    <url>%2Fp%2F7dcacf8f%2F</url>
    <content type="text"><![CDATA[45.6% https://leetcode.com/problems/same-tree/ Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. æ–¹æ³•ä¸€ï¼š https://discuss.leetcode.com/topic/5972/here-s-a-c-recursion-solution-in-minimal-lines-of-code 123456789101112131415161718//// Algorithm for the recursion:// 1)// If one of the node is NULL then return the equality result of p an q.// This boils down to if both are NULL then return true, // but if one of them is NULL but not the other one then return false// 2)// At this point both root nodes represent valid pointers.// Return true if the root nodes have same value and // the left tree of the roots are same (recursion)// and the right tree of the roots are same (recursion). // Otherwise return false. //bool isSameTree(TreeNode *p, TreeNode *q) &#123; if (p == NULL || q == NULL) return (p == q); return (p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right));&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if(p==NULL &amp;&amp; q==NULL) return true; return p!=NULL &amp;&amp; q!=NULL &amp;&amp; p-&gt;val==q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125;&#125;; æ–¹æ³•äºŒï¼š 1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if(!p &amp;&amp; !q) return true; if(!p || !q) return false; return p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125;&#125;; python https://discuss.leetcode.com/topic/14561/shortest-simplest-python The â€œproperâ€ way: 1234def isSameTree(self, p, q): if p and q: return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) return p is q The â€œtupleifyâ€ way: 1234def isSameTree(self, p, q): def t(n): return n and (n.val, t(n.left), t(n.right)) return t(p) == t(q) The first way as one-liner: 12def isSameTree(self, p, q): return p and q and p.val == q.val and all(map(self.isSameTree, (p.left, p.right), (q.left, q.right))) or p is q https://discuss.leetcode.com/topic/18353/python-recursive-solution-and-dfs-iterative-solution-with-stack-and-bfs-iterative-solution-with-queue Python Recursive solution and DFS Iterative solution with stack and BFS Iterative solution with queue 12345678910111213141516171819202122232425262728293031323334353637def isSameTree1(self, p, q): if p and q: return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) else: return p == q# DFS with stack def isSameTree2(self, p, q): stack = [(p, q)] while stack: node1, node2 = stack.pop() if not node1 and not node2: continue elif None in [node1, node2]: return False else: if node1.val != node2.val: return False stack.append((node1.right, node2.right)) stack.append((node1.left, node2.left)) return True # BFS with queue def isSameTree3(self, p, q): queue = [(p, q)] while queue: node1, node2 = queue.pop(0) if not node1 and not node2: continue elif None in [node1, node2]: return False else: if node1.val != node2.val: return False queue.append((node1.left, node2.left)) queue.append((node1.right, node2.right)) return True my code 12345678910class Solution(object): def isSameTree(self, p, q): &quot;&quot;&quot; :type p: TreeNode :type q: TreeNode :rtype: bool &quot;&quot;&quot; if not p and not q: return True return p!=None and q!=None and (p.val==q.val) and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) å…¶ä¸­ p!=None and q!=Noneï¼Œè¿™ä¸€æ®µï¼Œå¦‚æžœæ¢æˆp and qï¼Œåˆ™ç»“æžœä¸æ˜¯falseï¼Œè€Œæ˜¯nullã€‚ java https://discuss.leetcode.com/topic/4737/five-line-java-solution-with-recursion 123456789101112131415161718/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; if(p.val == q.val) return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); return false; &#125;&#125; https://discuss.leetcode.com/topic/9739/2-lines-java-code 12345public class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) return true; return p != null &amp;&amp; q != null &amp;&amp; p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth fisrt search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[099. Recover Binary Search Tree]]></title>
    <url>%2Fp%2F3a244e25%2F</url>
    <content type="text"><![CDATA[29.0% https://leetcode.com/problems/recover-binary-search-tree/?tab=Description Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Note: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°: ä¸­åºéåŽ†ï¼Œdfs è¿åçš„ï¼Œæ›´æ–°åˆ°firstï¼Œå¦‚æžœfirstæœ‰å€¼ï¼Œæ›´æ–°åˆ°secondã€‚ ä¸­é—´secondå¯èƒ½å¤šæ¬¡æ›´æ–°ã€‚ 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void recoverTree(TreeNode* root) &#123; TreeNode* first = nullptr, *second = nullptr; TreeNode* prev = nullptr; traverse(root, prev, first, second); swap(first-&gt;val, second-&gt;val); return; &#125; void traverse(TreeNode* root, TreeNode*&amp; prev, TreeNode*&amp; first, TreeNode*&amp; second)&#123; if(!root) return; traverse(root-&gt;left, prev, first, second); if(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val &amp;&amp; !first) first = prev; if(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val &amp;&amp; first) second = root; prev = root; // ä¸è¦å¿˜è®°æ›´æ–°prev traverse(root-&gt;right, prev, first, second); return; &#125;&#125;; https://discuss.leetcode.com/topic/35013/recommend-for-beginners-clean-c-implementation-with-detailed-explaination [recommend for beginners]clean C++ implementation with detailed explaination Just use the â€œfirstâ€ and â€œsecondâ€ pointer to find the 2 nodes that violate the order. Then change the value of the first node ad the second node by their value. 12345678910111213141516171819class Solution &#123; TreeNode* first=NULL; TreeNode* second=NULL; TreeNode* prev = new TreeNode(INT_MIN);public: void recoverTree(TreeNode* root) &#123; help(root); swp(first-&gt;val, second-&gt;val); &#125; void help(TreeNode* root)&#123; if(root==NULL) return; help(root-&gt;left); if(first==NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val) first=prev; if(first!=NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val) second=root; prev=root; help(root-&gt;right); &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; TreeNode* first = NULL; TreeNode* second = NULL; TreeNode* prev = new TreeNode(INT_MIN);public: void recoverTree(TreeNode* root) &#123; helper(root); // æ³¨æ„äº¤æ¢çš„æ˜¯first-&gt;valï¼Œsecond-&gt;val swap(first-&gt;val, second-&gt;val); &#125; void helper(TreeNode* root)&#123; if(!root) return; helper(root-&gt;left); if(first==NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val) first=prev; if(first!=NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val) second=root; prev = root; helper(root-&gt;right); &#125;&#125;; å…³äºŽç®—æ³•çš„è§£é‡Šï¼š https://discuss.leetcode.com/topic/3988/no-fancy-algorithm-just-simple-and-powerful-in-order-traversal No Fancy Algorithm, just Simple and Powerful In-Order Traversal This question appeared difficult to me but it is really just a simple in-order traversal! I got really frustrated when other people are showing off Morris Traversal which is totally not necessary here. Letâ€™s start by writing the in order traversal: 1234567private void traverse (TreeNode root) &#123; if (root == null) return; traverse(root.left); // Do some business traverse(root.right);&#125; So when we need to print the node values in order, we insert System.out.println(root.val) in the place of â€œDo some businessâ€. What is the business we are doing here?We need to find the first and second elements that are not in order right? How do we find these two elements? For example, we have the following tree that is printed as in order traversal: 6, 3, 4, 5, 2 We compare each node with its next one and we can find out that 6 is the first element to swap because 6 &gt; 3 and 2 is the second element to swap because 2 &lt; 5. Really, what we are comparing is the current node and its previous node in the â€œin order traversalâ€. Let us define three variables, firstElement, secondElement, and prevElement. Now we just need to build the â€œdo some businessâ€ logic as finding the two elements. See the code below: 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; TreeNode firstElement = null; TreeNode secondElement = null; // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized TreeNode prevElement = new TreeNode(Integer.MIN_VALUE); public void recoverTree(TreeNode root) &#123; // In order traversal to find the two elements traverse(root); // Swap the values of the two nodes int temp = firstElement.val; firstElement.val = secondElement.val; secondElement.val = temp; &#125; private void traverse(TreeNode root) &#123; if (root == null) return; traverse(root.left); // Start of &quot;do some business&quot;, // If first element has not been found, assign it to prevElement (refer to 6 in the example above) if (firstElement == null &amp;&amp; prevElement.val &gt;= root.val) &#123; firstElement = prevElement; &#125; // If first element is found, assign the second element to the root (refer to 2 in the example above) if (firstElement != null &amp;&amp; prevElement.val &gt;= root.val) &#123; secondElement = root; &#125; prevElement = root; // End of &quot;do some business&quot; traverse(root.right);&#125; And we are done, it is just that easy! https://discuss.leetcode.com/topic/19771/real-o-1-space-no-recursion-no-stack-etc-o-n-time-solution-48ms-c REAL O(1) Space (No recursion/No stack, etc) O(n) Time solution. 48ms C++ Someone complained that a recursion solution isnâ€™t really a O(1) space solution. Ok, here comes the real O(1) solution. No recursion, no stack. Pure Morris traversal. 48 ms, C++ : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; TreeNode * wrong_node0 = nullptr, * wrong_node1 = nullptr, * prev = nullptr; void verify(TreeNode * cur) &#123; if (prev != nullptr &amp;&amp; prev -&gt; val &gt; cur -&gt; val) &#123; if (wrong_node0 == nullptr) &#123; wrong_node0 = prev; wrong_node1 = cur; // in case the tree has only 2 elements. &#125; else wrong_node1 = cur; &#125; prev = cur; &#125; void morrisInorder(TreeNode * root) &#123; TreeNode * cur = root; while (cur) &#123; if (cur-&gt;left == nullptr) &#123; verify(cur); cur = cur-&gt;right; continue; &#125; TreeNode * pred = cur-&gt;left; while (pred -&gt; right != nullptr &amp;&amp; pred -&gt; right != cur) pred = pred -&gt; right; //finding predecessor if (pred -&gt; right == nullptr) &#123; pred -&gt; right = cur; cur = cur -&gt; left; &#125;else &#123;//pred -&gt; right == cur; pred -&gt; right = nullptr; verify(cur); cur = cur -&gt; right; &#125; &#125; &#125; public: void recoverTree(TreeNode* root) &#123; morrisInorder(root); swap(wrong_node0-&gt;val, wrong_node1-&gt;val); &#125; &#125;; python https://discuss.leetcode.com/topic/16600/tree-deserializer-and-visualizer-for-python Tree Deserializer and Visualizer for Python Wrote some tools for my own local testing. For example1deserialize(&apos;[1,2,3,null,null,4,null,null,5]&apos;) will turn that into a tree and return the root as explained in the FAQ. I also wrote a visualizer. Two examples: 1drawtree(deserialize(&apos;[1,2,3,null,null,4,null,null,5]&apos;)): 1drawtree(deserialize(&apos;[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]&apos;)): Hereâ€™s the code. If you save it as a Python script and run it, it should as a demo show the above two pictures in turtle windows (one after the other). And you can of course import it from other scripts and then it will only provide the class/functions and not show the demo. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def __repr__(self): return &apos;TreeNode(&#123;&#125;)&apos;.format(self.val) def deserialize(string): if string == &apos;&#123;&#125;&apos;: return None nodes = [None if val == &apos;null&apos; else TreeNode(int(val)) for val in string.strip(&apos;[]&#123;&#125;&apos;).split(&apos;,&apos;)] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return rootdef drawtree(root): def height(root): return 1 + max(height(root.left), height(root.right)) if root else -1 def jumpto(x, y): t.penup() t.goto(x, y) t.pendown() def draw(node, x, y, dx): if node: t.goto(x, y) jumpto(x, y-20) t.write(node.val, align=&apos;center&apos;, font=(&apos;Arial&apos;, 12, &apos;normal&apos;)) draw(node.left, x-dx, y-60, dx/2) jumpto(x, y-20) draw(node.right, x+dx, y-60, dx/2) import turtle t = turtle.Turtle() t.speed(0); turtle.delay(0) h = height(root) jumpto(0, 30*h) draw(root, 0, 30*h, 40*h) t.hideturtle() turtle.mainloop() if __name__ == &apos;__main__&apos;: drawtree(deserialize(&apos;[1,2,3,null,null,4,null,null,5]&apos;)) drawtree(deserialize(&apos;[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]&apos;)) java https://discuss.leetcode.com/topic/3988/no-fancy-algorithm-just-simple-and-powerful-in-order-traversal No Fancy Algorithm, just Simple and Powerful In-Order Traversal This question appeared difficult to me but it is really just a simple in-order traversal! I got really frustrated when other people are showing off Morris Traversal which is totally not necessary here. Letâ€™s start by writing the in order traversal: 1234567private void traverse (TreeNode root) &#123; if (root == null) return; traverse(root.left); // Do some business traverse(root.right);&#125; So when we need to print the node values in order, we insert System.out.println(root.val) in the place of â€œDo some businessâ€. What is the business we are doing here? We need to find the first and second elements that are not in order right? How do we find these two elements? For example, we have the following tree that is printed as in order traversal: 6, 3, 4, 5, 2 We compare each node with its next one and we can find out that 6 is the first element to swap because 6 &gt; 3 and 2 is the second element to swap because 2 &lt; 5. Really, what we are comparing is the current node and its previous node in the â€œin order traversalâ€. Let us define three variables, firstElement, secondElement, and prevElement. Now we just need to build the â€œdo some businessâ€ logic as finding the two elements. See the code below: 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; TreeNode firstElement = null; TreeNode secondElement = null; // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized TreeNode prevElement = new TreeNode(Integer.MIN_VALUE); public void recoverTree(TreeNode root) &#123; // In order traversal to find the two elements traverse(root); // Swap the values of the two nodes int temp = firstElement.val; firstElement.val = secondElement.val; secondElement.val = temp; &#125; private void traverse(TreeNode root) &#123; if (root == null) return; traverse(root.left); // Start of &quot;do some business&quot;, // If first element has not been found, assign it to prevElement (refer to 6 in the example above) if (firstElement == null &amp;&amp; prevElement.val &gt;= root.val) &#123; firstElement = prevElement; &#125; // If first element is found, assign the second element to the root (refer to 2 in the example above) if (firstElement != null &amp;&amp; prevElement.val &gt;= root.val) &#123; secondElement = root; &#125; prevElement = root; // End of &quot;do some business&quot; traverse(root.right);&#125; And we are done, it is just that easy! https://discuss.leetcode.com/topic/9305/detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer Detail Explain about How Morris Traversal Finds two Incorrect Pointer To understand this, you need to first understand Morris Traversal or Morris Threading Traversal.It take use of leaf nodesâ€™ right/left pointer to achieve O(1) space Traversal on a Binary Tree.Below is a standard Inorder Morris Traversal, referred from http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html (a Chinese Blog, while the graphs are great for illustration) 123456789101112131415161718192021222324public void morrisTraversal(TreeNode root)&#123; TreeNode temp = null; while(root!=null)&#123; if(root.left!=null)&#123; // connect threading for root temp = root.left; while(temp.right!=null &amp;&amp; temp.right != root) temp = temp.right; // the threading already exists if(temp.right!=null)&#123; temp.right = null; System.out.println(root.val); root = root.right; &#125;else&#123; // construct the threading temp.right = root; root = root.left; &#125; &#125;else&#123; System.out.println(root.val); root = root.right; &#125; &#125; &#125; In the above code, System.out.println(root.val);appear twice, which functions as outputing the Node in ascending order (BST). Since these places are in order, replace them with 12345if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123; if(first==null)&#123;first = pre;second = root;&#125; else&#123;second = root;&#125; &#125;pre = root; each time, the pre node and root are in order as System.out.println(root.val); outputs them in order. Then, come to how to specify the first wrong node and second wrong node. When they are not consecutive, the first time we meet pre.val &gt; root.val ensure us the first node is the pre node, since root should be traversal ahead of pre, pre should be at least at small as root. The second time we meet pre.val &gt; root.val ensure us the second node is the root node, since we are now looking for a node to replace with out first node, which is found before. When they are consecutive, which means the case pre.val &gt; cur.val will appear only once. We need to take case this case without destroy the previous analysis. So the first node will still be pre, and the second will be just set to root. Once we meet this case again, the first node will not be affected. Below is the updated version on Morris Traversal. 123456789101112131415161718192021222324252627282930313233343536373839404142public void recoverTree(TreeNode root) &#123; TreeNode pre = null; TreeNode first = null, second = null; // Morris Traversal TreeNode temp = null; while(root!=null)&#123; if(root.left!=null)&#123; // connect threading for root temp = root.left; while(temp.right!=null &amp;&amp; temp.right != root) temp = temp.right; // the threading already exists if(temp.right!=null)&#123; if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123; if(first==null)&#123;first = pre;second = root;&#125; else&#123;second = root;&#125; &#125; pre = root; temp.right = null; root = root.right; &#125;else&#123; // construct the threading temp.right = root; root = root.left; &#125; &#125;else&#123; if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123; if(first==null)&#123;first = pre;second = root;&#125; else&#123;second = root;&#125; &#125; pre = root; root = root.right; &#125; &#125; // swap two node values; if(first!= null &amp;&amp; second != null)&#123; int t = first.val; first.val = second.val; second.val = t; &#125; &#125; https://discuss.leetcode.com/topic/29161/share-my-solutions-and-detailed-explanation-with-recursive-iterative-in-order-traversal-and-morris-traversal Share my solutions and detailed explanation with recursive/iterative in-order-traversal and Morris-traversal In-order traversal is really useful in BST. Following in-order traversal, we should have following order: prev.val &lt; curr.val. If not, then we found at least one incorrectly placed node So the basic idea is to visit the tree with in-order traversal and search for two swapped nodes. Then swap them back. Now the problem is if we found an incorrect pair where prev.val &gt; curr.val, how do we know which node is the incorrect one? The answer is it depends on whether we have found incorrect node before. So What is that? Since we get two elements that are swapped by mistake, there must be a smaller TreeNode get a larger value and a larger TreeNode get a smaller value. Their value are swapped, but the incorrect smaller node is still in smaller tree and incorrect larger node is still in larger tree. So we will visit the incorrect smaller node first, and this node will be detected when we compare its value with next.val, i.e. when it is treated as prev node. The incorrect larger node will be detected when we compare its value with prev.val. We donâ€™t know if it is close or not close to incorrect smaller node, so we should continue search BST and update it if we found another incorrect node. Therefore if it is the first time we found an incorrect pair, the prev node must be the first incorrect node.If it is not the first time we found an incorrect pair, the curr node must be the second incorrect node, thoughwe may have corner case that two incorrect nodes are in same pair. Recursive in-order traversal based on above idea: public void recoverTree(TreeNode root) { 12345678910111213141516171819202122232425262728293031323334//use inorder traversal to detect incorrect node inOrder(root); int temp = first.val; first.val = second.val; second.val = temp;&#125;TreeNode prev = null;TreeNode first = null;TreeNode second = null;public void inOrder(TreeNode root)&#123; if(root == null) return; //search left tree inOrder(root.left); //in inorder traversal of BST, prev should always have smaller value than current value if(prev != null &amp;&amp; prev.val &gt;= root.val)&#123; //incorrect smaller node is always found as prev node if(first == null) first = prev; //incorrect larger node is always found as curr(root) node second = root; &#125; //update prev node prev = root; //search right tree inOrder(root.right);&#125; iterative in-order traversal based on above idea: 12345678910111213141516171819202122232425262728293031323334353637public void recoverTree(TreeNode root) &#123; TreeNode first = null; TreeNode second = null; TreeNode curr = root; TreeNode prev = null; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while(!stack.isEmpty() || curr != null)&#123; if(curr != null)&#123; //visit curr&apos;s left subtree stack.push(curr); curr = curr.left; &#125;else&#123; //done left subtree of curr Node curr = stack.pop(); //compare curr.val with prev.val if we have one if(prev != null &amp;&amp; curr.val &lt;= prev.val)&#123; //incorrect smaller node is always found as prev node if(first == null) first = prev; //incorrect larger node is always found as curr node second = curr; &#125; //visit curr&apos;s right subtree prev = curr; curr = curr.right; &#125; &#125; //recover swapped nodes int temp = first.val; first.val = second.val; second.val = temp;&#125; Both recursive and iterative will occupy O(n) space in worst case, in which the tree is like a LinkedList To reduce the space to constant space, we have to use Morris-traversal. Morris-traversal is similar to recursive/iterative traversal, but we need to modify the tree structure during thetraversal. before we visiting the left tree of a root, we will build a back-edge between rightmost node in left tree and the root. So we can go back to the root node after we are done with the left tree. Then we locate the rightmost node in left subtree again, cut the back-edge, recover the tree structure and start visit right subtree. The detection of two incorrect TreeNodes is similar to iterative/recursive in-order traversal.We donâ€™t use extra data structure here, so the space complexity is reduced to O(1) and the time complexity will be O(n) Morris-traversal based on above description: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void recoverTree(TreeNode root) &#123; //Morris-traversal TreeNode first = null; TreeNode second = null; TreeNode pred = null; //rightmost node in left tree TreeNode prev = null; TreeNode curr = root; while(curr != null)&#123; //for each node, we compare it with prev node as we did in in-order-traversal if(prev != null &amp;&amp; curr.val &lt;= prev.val)&#123; if(first == null) first = prev; second = curr; &#125; if(curr.left != null)&#123; //got left tree, then let&apos;s locate its rightmost node in left tree pred = curr.left; //we may have visited the left tree before, and connect the rightmost node with curr node (root node) while(pred.right != null &amp;&amp; pred.right != curr)&#123; pred = pred.right; &#125; if(pred.right == curr)&#123; //if this left tree has been visited before, then we are done with it //cut the connection with currNode and start visit curr&apos;s right tree pred.right = null; prev = curr; curr = curr.right; &#125;else&#123; //if this left tree has not been visited before, then we create a back edge from rightmost node // to curr node, so we can return to the start point after done the left tree pred.right = curr; curr = curr.left; &#125; &#125;else&#123; //no left tree, then just visit its right tree prev = curr; curr = curr.right; &#125; &#125; int temp = first.val; first.val = second.val; second.val = temp;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[098. Validate Binary Search Tree]]></title>
    <url>%2Fp%2F92064786%2F</url>
    <content type="text"><![CDATA[22.6% https://leetcode.com/problems/validate-binary-search-tree/?tab=Description Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the nodeâ€™s key. The right subtree of a node contains only nodes with keys greater than the nodeâ€™s key. Both the left and right subtrees must also be binary search trees. 12345Example 1: 2 / \ 1 3Binary tree [2,1,3], return true. 12345Example 2: 1 / \ 2 3Binary tree [1,2,3], return false. æ–¹æ³•ä¸€ï¼š å¯ä»¥ä¸­åºéåŽ†ï¼Œåˆ¤æ–­å€¼æ˜¯å¦ç”±å°åˆ°å¤§ã€‚ å…ˆä¸­åºéåŽ†ï¼Œåˆ™éåŽ†åŽå¿…å®šæ»¡è¶³æ˜¯é€’å¢žæ•°ç»„ï¼Œå¦åˆ™ä¸æ»¡è¶³ã€‚ 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if(!root) return true; vector&lt;int&gt; v; inorder(root, v); int n = v.size(); for(int i=1; i&lt;n; i++) // è¦æ±‚æ ¹å¤§äºŽå·¦è¾¹ï¼Œå°äºŽå³è¾¹ï¼Œæ‰€ä»¥æ˜¯&lt;=ï¼Œä¸æ˜¯&lt; if(v[i]&lt;=v[i-1]) return false; return true; &#125; void inorder(TreeNode* root, vector&lt;int&gt;&amp; v)&#123; if(root)&#123; inorder(root-&gt;left, v); v.push_back(root-&gt;val); inorder(root-&gt;right, v); &#125; &#125;&#125;; æ–¹æ³•äºŒï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š O(n)æ—¶é—´å’Œç©ºé—´ 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; return helper(root, nullptr, nullptr); &#125; bool helper(TreeNode* root, TreeNode* left, TreeNode* right)&#123; if(!root) return true; if(left &amp;&amp; left-&gt;val&gt;=root-&gt;val) return false; if(right &amp;&amp; right-&gt;val&lt;=root-&gt;val) return false; bool l = helper(root-&gt;left, left, root); bool r = helper(root-&gt;right, root, right); return l&amp;r; &#125;&#125;; å¯ä»¥rootå€¼å°äºŽæœ€å¤§å€¼ï¼Œå¤§äºŽæœ€å°å€¼ï¼Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹è¦æ»¡è¶³ä»¥ä¸Šäº†ä¸¤ä¸ªæ¡ä»¶ï¼Œå¹¶ä¸”å°äºŽæˆ–å¤§äºŽæ ¹çš„å€¼ã€‚ https://discuss.leetcode.com/topic/18573/c-simple-recursive-solution C++ simple recursive solution ä¸‹é¢è¿™ä¸ªæ–¹æ³•å·§å¦™ä¹‹å¤„æ˜¯ä½¿ç”¨äº†èŠ‚ç‚¹ï¼Œå¯ä»¥åˆ¤æ–­æ˜¯å¦ä¸ºNULL é€’å½’æ–¹æ³•ï¼Œåœ¨é€’å½’ä¸­å°±èƒ½ç¡®å®šç»“æžœäº†ã€‚ ä»£ç ä¸­ä½¿ç”¨äº†NULLï¼Œè€Œä¸æ˜¯ INT_MAX ï¼ŒINT_MINï¼Œè¿™æ˜¯ä¸€ä¸ªä¼˜ç‚¹ã€‚ 12345678910bool isValidBST(TreeNode* root) &#123; return isValidBST(root, NULL, NULL);&#125;bool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) &#123; if(!root) return true; if(minNode &amp;&amp; root-&gt;val &lt;= minNode-&gt;val || maxNode &amp;&amp; root-&gt;val &gt;= maxNode-&gt;val) return false; return isValidBST(root-&gt;left, minNode, root) &amp;&amp; isValidBST(root-&gt;right, root, maxNode);&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if(!root) return true; // ä½¿ç”¨INT_MINè¿‡ä¸åŽ»ï¼Œä½¿ç”¨LONG_MINå°±å¯ä»¥è¿‡åŽ»äº† return helper(root, LONG_MIN, LONG_MAX); &#125; // æ­¤å¤„ä½¿ç”¨çš„æ˜¯longç±»åž‹ bool helper(TreeNode* root, long l, long r)&#123; if(!root) return true; if(root-&gt;val &lt;= l || root-&gt;val &gt;= r) return false; bool left = helper(root-&gt;left, l, root-&gt;val); bool right = helper(root-&gt;right, root-&gt;val, r); return left &amp;&amp; right; &#125;&#125;; æ–¹æ³•ä¸‰ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; TreeNode* prev = nullptr; return helper(root, prev); &#125; bool helper(TreeNode* root, TreeNode*&amp; prev)&#123; if(!root) return true; if(!helper(root-&gt;left, prev)) return false; if(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val) return false; prev = root; return helper(root-&gt;right, prev); &#125;&#125;; åˆ¤æ–­å½“å‰èŠ‚ç‚¹ä¸Žå‰ä¸€ä¸ªèŠ‚ç‚¹ äºŒå‰æœç´¢æ ‘ä¸­åºéåŽ†åŽæ˜¯æœ‰åºçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦åˆ¤æ–­ä¸­åºéåŽ†ä¸­ï¼Œå½“å‰èŠ‚ç‚¹nodeå’Œä¸­åºéåŽ†çš„å‰ä¸€ä¸ªèŠ‚ç‚¹prevçš„å…³ç³»ï¼Œå…¨éƒ¨æ»¡è¶³æ‰æ˜¯BSTï¼Œå¦åˆ™falseã€‚ 1234567891011121314class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; TreeNode* prev = NULL; return validate(root, prev); &#125; bool validate(TreeNode* node, TreeNode* &amp;prev) &#123; if (node == NULL) return true; if (!validate(node-&gt;left, prev)) return false; if (prev != NULL &amp;&amp; prev-&gt;val &gt;= node-&gt;val) return false; prev = node; return validate(node-&gt;right, prev); &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; TreeNode* prev = NULL; return helper(root, prev); &#125; // å¼•ç”¨åœ¨åŽé¢ï¼Œè¯´æ˜Žprevé¦–å…ˆæ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œç„¶åŽæŒ‡å‘treeæŒ‡é’ˆçš„å¼•ç”¨ bool helper(TreeNode* node, TreeNode* &amp; prev)&#123; if(!node) return true; if(!helper(node-&gt;left, prev)) return false; if(prev &amp;&amp; prev-&gt;val &gt;= node-&gt;val) return false; prev = node; return helper(node-&gt;right, prev); &#125;&#125;; If we use in-order traversal to serialize a binary search tree, we can get a list of values in ascending order. It can be proved with the definition of BST. And here I use the reference of TreeNode pointer prev as a global variable to mark the address of previous node in the list. â€œIn-order Traversalâ€: https://en.wikipedia.org/wiki/Tree_traversal#In-order If you know what INT_MAX or INT_MIN is, then it is no excuse for your carelessness. python https://discuss.leetcode.com/topic/10455/python-version-based-on-inorder-traversal 136ms, 5.82%, September 23, 2016 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; output = [] self.inOrder(root, output) for i in range(1, len(output)): if output[i-1] &gt;= output[i]: return False return True def inOrder(self, root, output): if root is None: return self.inOrder(root.left, output) output.append(root.val) self.inOrder(root.right, output) java æ³¨æ„ï¼Œä¸ä»…ä»…è¦å·¦ä¾§å€¼å°äºŽæ ¹ï¼Œæ ¹å°äºŽå³ä¾§ï¼Œå…¶å®žä¸‹é¢æ‰€æœ‰å·¦ä¾§å€¼éƒ½è¦å°äºŽæ ¹ï¼Œå³ä¾§å€¼éƒ½è¦å¤§äºŽæ ¹ã€‚ java æœ€å°æœ€å¤§çš„å€¼ï¼ŒLong.MIN_VALUE, Long.MAX_VALUE. https://discuss.leetcode.com/topic/7179/my-simple-java-solution-in-3-lines My simple Java solution in 3 lines 1234567891011public class Solution &#123; public boolean isValidBST(TreeNode root) &#123; return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE); &#125; public boolean isValidBST(TreeNode root, long minVal, long maxVal) &#123; if (root == null) return true; if (root.val &gt;= maxVal || root.val &lt;= minVal) return false; return isValidBST(root.left, minVal, root.val) &amp;&amp; isValidBST(root.right, root.val, maxVal); &#125;&#125; Basically what I am doing is recursively iterating over the tree while defining interval &lt;minVal, maxVal&gt; for each node which value must fit in.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[097. Interleaving String]]></title>
    <url>%2Fp%2Fa33cb2cc%2F</url>
    <content type="text"><![CDATA[24.1% https://leetcode.com/problems/interleaving-string/ Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. 1234567For example,Given:s1 = &quot;aabcc&quot;,s2 = &quot;dbbca&quot;,When s3 = &quot;aadbbcbcac&quot;, return true.When s3 = &quot;aadbbbaccc&quot;, return false. æœ¬é¢˜æ˜¯ä¸€é“åŠ¨æ€è§„åˆ’é¢˜ç›®ï¼Œå»ºç«‹ä¸€ä¸ªs1.length * s2.lengthçš„åŠ¨æ€è§„åˆ’æ•°ç»„ã€‚ æ–¹æ³•ä¸€ï¼š 0ms, 89.51%, September 21, 2016 https://discuss.leetcode.com/topic/3532/my-dp-solution-in-c Here is some explanation: DP table represents if s3 is interleaving at (i+j)th position when s1 is at ith position, and s2 is at jth position. 0th position means empty string. So if both s1 and s2 is currently empty, s3 is empty too, and it is considered interleaving. If only s1 is empty, then if previous s2 position is interleaving and current s2 position char is equal to s3 current position char, it is considered interleaving. similar idea applies to when s2 is empty. when both s1 and s2 is not empty, then if we arrive i, j from i-1, j, then if i-1,j is already interleaving and i and current s3 position equal, it s interleaving. If we arrive i,j from i, j-1, then if i, j-1 is already interleaving and j and current s3 position equal. it is interleaving. 123456789101112131415161718192021class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if(s3.length()!=s1.length() + s2.length()) return false; bool table[s1.length()+1][s2.length()+1]; for(int i=0; i&lt;s1.length()+1; i++) for(int j=0; j&lt;s2.length()+1; j++)&#123; if(i==0&amp;&amp;j==0) table[i][j] = true; else if(i==0) table[i][j] = (table[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]); else if(j==0) table[i][j] = (table[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1]); else table[i][j] = (table[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1])||(table[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]); &#125; return table[s1.length()][s2.length()]; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if(s1.size()+s2.size()!=s3.size()) return false; // ç­‰äºŽè¿˜æ˜¯ä¸ç­‰äºŽï¼Œè¦è€ƒè™‘æ¸…æ¥š int m = s1.size(), n = s2.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=1; i&lt;n+1; i++) dp[0][i] = dp[0][i-1] &amp;&amp; s3[i-1]==s2[i-1]; for(int i=1; i&lt;m+1; i++) dp[i][0] = dp[i-1][0] &amp;&amp; s3[i-1]==s1[i-1]; for(int i=1; i&lt;m+1; i++)&#123; for(int j=1; j&lt;n+1; j++)&#123; // æ³¨æ„== ä¸Ž = çš„åŒºåˆ† dp[i][j] = (dp[i-1][j] &amp;&amp; (s3[i+j-1]==s1[i-1])) || (dp[i][j-1] &amp;&amp; (s3[i+j-1]==s2[j-1])); &#125; &#125; return dp[m][n]; // (m=1)*(n+1)çŸ©é˜µæœ€åŽä¸€ä½ç´¢å¼•mï¼Œnè€Œä¸æ˜¯m+1ï¼Œn+1 &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; int m = s1.size(), n = s2.size(), l = s3.size(); if(m+n!=l) return false; vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=1; i&lt;=n; i++) dp[0][i] = dp[0][i-1] &amp;&amp; s2[i-1]==s3[i-1]; for(int i=1; i&lt;=m; i++) dp[i][0] = dp[i-1][0] &amp;&amp; s1[i-1]==s3[i-1]; for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) dp[i][j] = dp[i-1][j] &amp;&amp; s1[i-1]==s3[i+j-1] || dp[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]; return dp[m][n]; &#125;&#125;; https://discuss.leetcode.com/topic/6562/8ms-c-solution-using-bfs-with-explanation If we expand the two strings s1 and s2 into a chessboard, then this problem can be transferred into a path seeking problem from the top-left corner to the bottom-right corner. The key is, each cell (y, x) in the board corresponds to an interval between y-th character in s1 and x-th character in s2. And adjacent cells are connected with like a grid. A BFS can then be efficiently performed to find the path. Better to illustrate with an example here: 123456789101112131415Say s1 = &quot;aab&quot; and s2 = &quot;abc&quot;. s3 = &quot;aaabcb&quot;. Then the board looks likeo--a--o--b--o--c--o| | | |a a a a| | | |o--a--o--b--o--c--o| | | |a a a a| | | |o--a--o--b--o--c--o| | | |b b b b| | | |o--a--o--b--o--c--o 123456789101112131415Each &quot;o&quot; is a cell in the board. We start from the top-left corner, and try to move right or down. If the next char in s3 matches the edge connecting the next cell, then we&apos;re able to move. When we hit the bottom-right corner, this means s3 can be represented by interleaving s1 and s2. One possible path for this example is indicated with &quot;x&quot;es below:x--a--x--b--o--c--o| | | |a a a a| | | |o--a--x--b--o--c--o| | | |a a a a| | | |o--a--x--b--x--c--x| | | |b b b b| | | |o--a--o--b--o--c--x Note if we concatenate the chars on the edges we went along, itâ€™s exactly s3. And we went through all the chars in s1 and s2, in order, exactly once. Therefore if we view this board as a graph, such path finding problem is trivial with BFS. I use an unordered_map to store the visited nodes, which makes the code look a bit complicated. But a vector should be enough to do the job. Although the worse case timeis also O(mn), typically it doesnâ€™t require us to go through every node to find a path. Therefore itâ€™s faster than regular DP than average. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct MyPoint &#123; int y, x; bool operator==(const MyPoint &amp;p) const &#123; return p.y == y &amp;&amp; p.x == x; &#125;&#125;;namespace std &#123; template &lt;&gt; struct hash&lt;MyPoint&gt; &#123; size_t operator () (const MyPoint &amp;f) const &#123; return (std::hash&lt;int&gt;()(f.x) &lt;&lt; 1) ^ std::hash&lt;int&gt;()(f.y); &#125; &#125;;&#125;class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if (s1.size() + s2.size() != s3.size()) return false; queue&lt;MyPoint&gt; q; unordered_set&lt;MyPoint&gt; visited; bool isSuccessful = false; int i = 0; q.push(MyPoint &#123; 0, 0 &#125;); q.push(MyPoint &#123; -1, -1 &#125;); while (!(1 == q.size() &amp;&amp; -1 == q.front().x)) &#123; auto p = q.front(); q.pop(); if (p.y == s1.size() &amp;&amp; p.x == s2.size()) &#123; return true; &#125; if (-1 == p.y) &#123; q.push(p); i++; continue; &#125; if (visited.find(p) != visited.end()) &#123; continue; &#125; visited.insert(p); if (p.y &lt; s1.size()) &#123; // down if (s1[p.y] == s3[i]) &#123; q.push(MyPoint &#123; p.y + 1, p.x &#125;); &#125; &#125; if (p.x &lt; s2.size()) &#123; // right if (s2[p.x] == s3[i]) &#123; q.push(MyPoint &#123; p.y, p.x + 1 &#125;); &#125; &#125; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/17059/my-dp-c-solution-is-only-10-lines-with-o-n-space My dp C++ solution is only 10 lines with O(n) space! 12345678910111213141516class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; int m = s1.size(), n = s2.size(); if(m+n != s3.size()) return false; bool c[n+1] = &#123;true&#125;; int i, j = 0; while(j &lt; n &amp;&amp; s2[j] == s3[j]) c[++j] = true; for(i = 0; i &lt; m; ++i) &#123; c[0] = c[0] &amp; (s1[i] == s3[i]); for(j = 1; j &lt;= n; ++j) c[j] = ((s1[i] == s3[i+j]) &amp; c[j]) | ((s2[j-1] == s3[i+j]) &amp; c[j-1]); &#125; return c[n]; &#125;&#125;; https://discuss.leetcode.com/topic/4695/c-sharing-my-recursive-tle-and-dp-solution-30ms-easy-to-understand [C++] Sharing my recursive (TLE) and DP solution (30ms) - easy to understand. First, Iâ€™m a big recursion person. Hereâ€™s my first attempt which is purely recursive. At an intermediate stage, we can either match one char from s1 to one char from s3 and advance one pointer at s1 and s3. Or we can do the same with s2 and s3. Iâ€™m open to suggestions to my recursive code. One improvement could come from not having to call the strcmp function? 123456789101112131415class Solution &#123;public: bool isInterleave(char* s1, char* s2, char* s3) &#123; if (*s1==&apos;\0&apos; &amp;&amp; *s2==&apos;\0&apos;) return *s3==&apos;\0&apos;? true : false; else if (*s1==&apos;\0&apos;)&#123; return strcmp(s2,s3)==0 ? true : false; &#125; else if (*s2==&apos;\0&apos;)&#123; return strcmp(s1,s3)==0 ? true : false; &#125; return (*s1==*s3 &amp;&amp; isInterleave(s1+1,s2,s3+1)) | (*s2==*s3 &amp;&amp; isInterleave(s1,s2+1,s3+1)); &#125;&#125;; Hereâ€™s the DP version (30ms) as well. Unsurprisingly the DP solution passed the judge and itâ€™s pretty efficient. The logic straightforward if you understood the recursive version since thereâ€™s 1:1 correspondence between the two code. I think itâ€™s elegant since it doesnâ€™t have any ugly if, else if shenanigans. 12345678910111213141516171819202122232425class Solution &#123;public: bool isInterleave(string s1, string s2, string s3)&#123; int n1 = s1.length(), n2 = s2.length(), n3 = s3.length(); if (n1+n2 != n3) return false; vector&lt;vector&lt;bool&gt;&gt; V(n1+1, vector&lt;bool&gt;(n2+1, false)); V[n1][n2] = (s3[n1+n2]==&apos;\0&apos;); // fill bottom for (int j=n2-1; j&gt;=0; j--) V[n1][j] = (s2[j]==s3[n1+j] &amp;&amp; V[n1][j+1]); // fill right for (int i=n1-1; i&gt;=0; i--) V[i][n2] = (s1[i]==s3[n2+i] &amp;&amp; V[i+1][n2]); // fill DP table from bottom right for (int j=n2-1; j&gt;=0; j--)&#123; for (int i=n1-1; i&gt;=0; i--)&#123; V[i][j] = (s1[i]==s3[i+j] &amp;&amp; V[i+1][j]) | (s2[j]==s3[i+j] &amp;&amp; V[i][j+1]); &#125; &#125; return V[0][0]; &#125;&#125;; python 112ms, 4.93%, September 21, 2016 https://discuss.leetcode.com/topic/19900/python-dp-solutions-o-m-n-o-n-space-bfs-dfs 12345678910111213141516171819202122# O(m*n) spaceclass Solution(object): def isInterleave(self, s1, s2, s3): &quot;&quot;&quot; :type s1: str :type s2: str :type s3: str :rtype: bool &quot;&quot;&quot; r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False dp = [[True for _ in xrange(c+1)] for _ in xrange(r+1)] for i in xrange(1, r+1): dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1] for j in xrange(1, c+1): dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1] for i in xrange(1, r+1): for j in xrange(1, c+1): dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i-1+j]) or \ (dp[i][j-1] and s2[j-1] == s3[i-1+j]) return dp[-1][-1] 123456789101112131415# O(2*n) spacedef isInterleave2(self, s1, s2, s3): l1, l2, l3 = len(s1)+1, len(s2)+1, len(s3)+1 if l1+l2 != l3+1: return False pre = [True for _ in xrange(l2)] for j in xrange(1, l2): pre[j] = pre[j-1] and s2[j-1] == s3[j-1] for i in xrange(1, l1): cur = [pre[0] and s1[i-1] == s3[i-1]] * l2 for j in xrange(1, l2): cur[j] = (cur[j-1] and s2[j-1] == s3[i+j-1]) or \ (pre[j] and s1[i-1] == s3[i+j-1]) pre = cur[:] return pre[-1] 12345678910111213# O(n) spacedef isInterleave3(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False dp = [True for _ in xrange(c+1)] for j in xrange(1, c+1): dp[j] = dp[j-1] and s2[j-1] == s3[j-1] for i in xrange(1, r+1): dp[0] = (dp[0] and s1[i-1] == s3[i-1]) for j in xrange(1, c+1): dp[j] = (dp[j] and s1[i-1] == s3[i-1+j]) or (dp[j-1] and s2[j-1] == s3[i-1+j]) return dp[-1] 123456789101112131415# DFS def isInterleave4(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False stack, visited = [(0, 0)], set((0, 0)) while stack: x, y = stack.pop() if x+y == l: return True if x+1 &lt;= r and s1[x] == s3[x+y] and (x+1, y) not in visited: stack.append((x+1, y)); visited.add((x+1, y)) if y+1 &lt;= c and s2[y] == s3[x+y] and (x, y+1) not in visited: stack.append((x, y+1)); visited.add((x, y+1)) return False 123456789101112131415# BFS def isInterleave(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False queue, visited = [(0, 0)], set((0, 0)) while queue: x, y = queue.pop(0) if x+y == l: return True if x+1 &lt;= r and s1[x] == s3[x+y] and (x+1, y) not in visited: queue.append((x+1, y)); visited.add((x+1, y)) if y+1 &lt;= c and s2[y] == s3[x+y] and (x, y+1) not in visited: queue.append((x, y+1)); visited.add((x, y+1)) return False java 4ms, 68.74%, September 21, 2016 https://discuss.leetcode.com/topic/7728/dp-solution-in-java DP Solution in Java 123456789101112131415161718192021222324public class Solution &#123; public boolean isInterleave(String s1, String s2, String s3) &#123; if((s1.length()+s2.length()) !=s3.length()) return false; boolean[][] matrix = new boolean[s2.length()+1][s1.length()+1]; matrix[0][0] = true; for(int i = 1; i &lt; matrix[0].length; i++) matrix[0][i] = matrix[0][i-1] &amp;&amp; (s1.charAt(i-1) == s3.charAt(i-1)); for(int i=1; i&lt;matrix.length; i++) matrix[i][0] = matrix[i-1][0] &amp;&amp; (s2.charAt(i-1) == s3.charAt(i-1)); for(int i=1; i&lt;matrix.length; i++)&#123; for(int j=1; j&lt;matrix[0].length; j++)&#123; matrix[i][j] = (matrix[i-1][j] &amp;&amp; (s2.charAt(i-1)==s3.charAt(i+j-1))) || (matrix[i][j-1] &amp;&amp; (s1.charAt(j-1)==s3.charAt(i+j-1))); &#125; &#125; return matrix[s2.length()][s1.length()]; &#125;&#125; https://discuss.leetcode.com/topic/3436/my-accepted-java-recursive-solution-for-interleaving-string My Accepted Java Recursive Solution for interleaving string The private method isInterleave is the recursive method. it takes additional i1, i2, i3 as the start indexes of s1, s2, s3, so it solves the substring of s1, s2, s3 with those start indexes. The recursion starting condition is i1, i2, i3 are set to 0, means it solves the whole string. in each recursion, it will just check the first character in s3 with s2 and s1, if it equals s1, it will increase i3 and i1 to solve remain, if remain return true, this recursion will also return true. Same logic for s2. The end condition is when remain of either s1 or s2 is empty, then just compare remain of s3 with remain of s1 or s2, if they are equal, it will return true. A pure recursive solution will cause time limit exceed. We can optimize it by caching the false visited solutions in the visited set. That will short circuit many repeated search path. 12345678910111213141516171819202122232425262728public class Solution &#123; private static Set&lt;Integer&gt; visited; // The combination of i1, i2 has been visited and return false public static boolean isInterleave(String s1, String s2, String s3) &#123; if(s3.length() != s1.length() + s2.length()) return false; visited = new HashSet&lt;Integer&gt;(); return isInterleave(s1, 0, s2, 0, s3, 0); &#125; private static boolean isInterleave(String s1, int i1, String s2, int i2, String s3, int i3) &#123; int hash = i1 * s3.length() + i2; if(visited.contains(hash)) return false; if(i1 == s1.length()) return s2.substring(i2).equals(s3.substring(i3)); if(i2 == s2.length()) return s1.substring(i1).equals(s3.substring(i3)); if(s3.charAt(i3) == s1.charAt(i1) &amp;&amp; isInterleave(s1, i1+1, s2, i2, s3, i3+1) || s3.charAt(i3) == s2.charAt(i2) &amp;&amp; isInterleave(s1, i1, s2, i2+1, s3, i3+1)) return true; visited.add(hash); return false; &#125;&#125; https://discuss.leetcode.com/topic/31991/1ms-tiny-dfs-beats-94-57 To solve this problem, letâ€™s look at if s1[0 ~ i] s2[0 ~ j] can be interleaved to s3[0 ~ k]. Start from indices0, 0, 0 and compare s1[i] == s3[k] or s2[j] == s3[k] Return valid only if either i or j match k and the remaining is also valid Caching is the key to performance. This is very similar to top down dp Only need to cache invalid[i][j] since most of the case s1[0 ~ i] and s2[0 ~ j] does not form s3[0 ~ k]. Also tested caching valid[i][j] the run time is also 1ms Many guys use substring but itâ€™s duplicate code since substring itself is checking char by char. We are already doing so Hope it helps! 12345678910111213141516public boolean isInterleave(String s1, String s2, String s3) &#123; char[] c1 = s1.toCharArray(), c2 = s2.toCharArray(), c3 = s3.toCharArray(); int m = s1.length(), n = s2.length(); if(m + n != s3.length()) return false; return dfs(c1, c2, c3, 0, 0, 0, new boolean[m + 1][n + 1]);&#125;public boolean dfs(char[] c1, char[] c2, char[] c3, int i, int j, int k, boolean[][] invalid) &#123; if(invalid[i][j]) return false; if(k == c3.length) return true; boolean valid = i &lt; c1.length &amp;&amp; c1[i] == c3[k] &amp;&amp; dfs(c1, c2, c3, i + 1, j, k + 1, invalid) || j &lt; c2.length &amp;&amp; c2[j] == c3[k] &amp;&amp; dfs(c1, c2, c3, i, j + 1, k + 1, invalid); if(!valid) invalid[i][j] = true; return valid;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[096. Unique Binary Search Trees]]></title>
    <url>%2Fp%2Fd9eba394%2F</url>
    <content type="text"><![CDATA[40.1% https://leetcode.com/problems/unique-binary-search-trees/ Given n, how many structurally unique BSTâ€™s (binary search trees) that store values 1â€¦n? 12345678For example,Given n = 3, there are a total of 5 unique BST&apos;s. 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 æ–¹æ³•ä¸€ï¼š ä½¿ç”¨åŠ¨æ€è§„åˆ’çš„æ–¹æ³•ï¼Œä¾æ¬¡è§‚å¯Ÿæ±‚è§£f(n)çš„ä¸ªæ•°ï¼Œè§‚å¯Ÿè§„å¾‹å’Œå…¬å¼ã€‚ https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there 0ms, September 9, 2016 https://discuss.leetcode.com/topic/17950/c-code-w-explanation C++ code w/ explanation 1234567891011121314class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; f; f.push_back(1); for (int i = 1; i &lt;= n; ++i) &#123; int t = 0; for (int j = 0; j &lt; i; ++j) t += f[j] * f[i-j-1]; f.push_back(t); &#125; return f.back(); &#125;&#125;; Consider f_i: choose 1 as the root, we have 0 node for the left tree, i-1 for the right; choose 2 as the root, we have 1 node for the left tree, i-2 for the right; â€¦ choose i as the root, we have i-1 nodes for the left tree, 0 for the right. Therefore, the recursive solution is f_i = \sum_{j=0}^{i-1} f_j f_{i-j-1} æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; v(n+1, 0); v[0] = 1; v[1] = 1; for(int i=2; i&lt;=n; i++)&#123; for(int j=0; j&lt;=i; j++) v[i] += v[j] * v[i-j-1]; &#125; return v[n]; &#125;&#125;; æ–¹æ³•äºŒï¼š ä½¿ç”¨ç›´æŽ¥è®¡ç®—å…¬å¼ï¼Œæ­¤å¤„æ˜¯ å¡ç‰¹å…°æ•° https://discuss.leetcode.com/topic/5822/it-s-catalan-number http://en.wikipedia.org/wiki/Catalan_number å¡ç‰¹å…°æ•°çš„å¦ä¸€ä¸ªå…¬å¼å¦‚ä¸‹ï¼š https://discuss.leetcode.com/topic/5673/dp-problem-10-lines-with-comments Dp problem. 10+ lines with comments 123456789101112131415161718192021222324/** * Taking 1~n as root respectively: * 1 as root: # of trees = F(0) * F(n-1) // F(0) == 1 * 2 as root: # of trees = F(1) * F(n-2) * 3 as root: # of trees = F(2) * F(n-3) * ... * n-1 as root: # of trees = F(n-2) * F(1) * n as root: # of trees = F(n-1) * F(0) * * So, the formulation is: * F(n) = F(0) * F(n-1) + F(1) * F(n-2) + F(2) * F(n-3) + ... + F(n-2) * F(1) + F(n-1) * F(0) */int numTrees(int n) &#123; int dp[n+1]; dp[0] = dp[1] = 1; for (int i=2; i&lt;=n; i++) &#123; dp[i] = 0; for (int j=1; j&lt;=i; j++) &#123; dp[i] += dp[j-1] * dp[i-j]; &#125; &#125; return dp[n];&#125; https://discuss.leetcode.com/topic/13321/a-very-simple-and-straight-ans-based-on-math-catalan-number-o-n-times-o-1-space A very simple and straight ans based on Math,Catalan Number ,O(N) times,O(1)space 123456789int numTrees(int n) &#123; //cantalanæ ‘ //C(2n,n)/(n+1) long long ans =1; for(int i=n+1;i&lt;=2*n;i++)&#123; ans = ans*i/(i-n); &#125; return ans/(n+1);&#125; python 36ms, September 9, 2016 https://discuss.leetcode.com/topic/19670/python-solutions-dp-catalan-numbers Python solutions (DP + Catalan number) 12345678# DPdef numTrees1(self, n): res = [0] * (n+1) res[0] = 1 for i in xrange(1, n+1): for j in xrange(i): res[i] += res[j] * res[i-1-j] return res[n] 123# Catalan Number (2n)!/((n+1)!*n!) def numTrees(self, n): return math.factorial(2*n)/(math.factorial(n)*math.factorial(n+1)) java 0ms, September 9, 2016 https://discuss.leetcode.com/topic/8398/dp-solution-in-6-lines-with-explanation-f-i-n-g-i-1-g-n-i DP Solution in 6 lines with explanation. F(i, n) = G(i-1) * G(n-i) The problem can be solved in a dynamic programming way. Iâ€™ll explain the intuition and formulas in the following. Given a sequence 1â€¦n, to construct a Binary Search Tree (BST) out of the sequence, we could enumerate each number i in the sequence, and use the number as the root, naturally, the subsequence 1â€¦(i-1) on its left side would lay on the left branch of the root, and similarly the right subsequence (i+1)â€¦n lay on the right branch of the root. We then can construct the subtree from the subsequence recursively. Through the above approach, we could ensure that the BST that we construct are all unique, since they have unique roots. The problem is to calculate the number of unique BST. To do so, we need to define two functions: G(n): the number of unique BST for a sequence of length n. F(i, n), 1 &lt;= i &lt;= n: the number of unique BST, where the number i is the root of BST, and the sequence ranges from 1 to n. As one can see, G(n) is the actual function we need to calculate in order to solve the problem. And G(n) can be derived from F(i, n), which at the end, would recursively refer to G(n). First of all, given the above definitions, we can see that the total number of unique BST G(n), is the sum of BST F(i) using each number i as a root.i.e. 1G(n) = F(1, n) + F(2, n) + ... + F(n, n). Particularly, the bottom cases, there is only one combination to construct a BST out of a sequence of length 1 (only a root) or 0 (empty tree).i.e. 1G(0)=1, G(1)=1. Given a sequence 1â€¦n, we pick a number i out of the sequence as the root, then the number of unique BST with the specified root F(i), is the cartesian product of the number of BST for its left and right subtrees. For example, F(3, 7): the number of unique BST tree with number 3 as its root. To construct an unique BST out of the entire sequence [1, 2, 3, 4, 5, 6, 7] with 3 as the root, which is to say, we need to construct an unique BST out of its left subsequence [1, 2] and another BST out of the right subsequence [4, 5, 6, 7], and then combine them together (i.e. cartesian product). The tricky part is that we could consider the number of unique BST out of sequence [1,2] as G(2), and the number of of unique BST out of sequence [4, 5, 6, 7] as G(4). Therefore, F(3,7) = G(2) * G(4). i.e. 1F(i, n) = G(i-1) * G(n-i) 1 &lt;= i &lt;= n Combining the above two formulas, we obtain the recursive formula for G(n). i.e. 1G(n) = G(0) * G(n-1) + G(1) * G(n-2) + â€¦ + G(n-1) * G(0) In terms of calculation, we need to start with the lower number, since the value of G(n) depends on the values of G(0) â€¦ G(n-1). With the above explanation and formulas, here is the implementation in Java. 123456789101112public int numTrees(int n) &#123; int [] G = new int[n+1]; G[0] = G[1] = 1; for(int i=2; i&lt;=n; ++i) &#123; for(int j=1; j&lt;=i; ++j) &#123; G[i] += G[j-1] * G[i-j]; &#125; &#125; return G[n];&#125; c 0ms, September 9, 2016 https://discuss.leetcode.com/topic/5673/dp-problem-10-lines-with-comments 12345678910int numTrees(int n) &#123; int dp[n+1]; dp[0] = dp[1] = 1; for(int i=2; i&lt;=n; i++)&#123; dp[i] = 0; for(int j=1; j&lt;=i; j++) dp[i] += dp[j-1] * dp[i-j]; &#125; return dp[n];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[095. Unique Binary Search Trees II]]></title>
    <url>%2Fp%2F68405e1a%2F</url>
    <content type="text"><![CDATA[30.8% https://leetcode.com/problems/unique-binary-search-trees/?tab=Description Given n, how many structurally unique BSTâ€™s (binary search trees) that store values 1â€¦n? 12345678For example,Given n = 3, there are a total of 5 unique BST&apos;s. 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 æ–¹æ³•ä¸€ï¼š æ­¤é¢˜ï¼Œä¸Ž96é¢˜çš„åŒºåˆ«åœ¨äºŽï¼Œ96é¢˜è¦æ±‚è¿”å›žä¸ªæ•°ï¼Œæ­¤é¢˜è¦æ±‚è¿”å›žæ‰€æœ‰ç»“æžœã€‚ ä½¿ç”¨é€’å½’çš„æ–¹æ³• https://discuss.leetcode.com/topic/9313/30-ms-c-solution 30 ms c++ solution 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;TreeNode *&gt; generateTrees(int n) &#123; if(n&lt;1) return vector&lt;TreeNode*&gt;(); return helper(1,n); &#125; vector&lt;TreeNode*&gt; helper(int s, int e) &#123; if (s &gt; e) &#123; return vector&lt;TreeNode*&gt;(1,NULL); &#125; vector&lt;TreeNode*&gt; result; for (int i=s; i &lt;= e; ++i) &#123; vector&lt;TreeNode*&gt; left, right; left = helper(s,i-1); right = helper(i+1,e); for (int j = 0; j &lt; left.size(); ++j) &#123; for (int k = 0; k &lt; right.size(); ++k) &#123; TreeNode* root = new TreeNode(i); root-&gt;left = left[j]; root-&gt;right = right[k]; result.push_back(root); &#125; &#125; &#125; return result; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if(n&lt;1) return vector&lt;TreeNode*&gt;(); // å¯¹äºŽå¤æ‚çš„é—®é¢˜ï¼Œå¾ˆå¤šä½¿ç”¨ä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼ŒåŒæ—¶ä½¿ç”¨é€’å½’ return helper(1, n); &#125; // æ³¨æ„åŒºåˆ†ListNode TreeNode vector&lt;TreeNode*&gt; helper(int start, int end)&#123; if(end&lt;start) return vector&lt;TreeNode*&gt;(1, NULL); if(start==end)&#123; TreeNode* node = new TreeNode(start); vector&lt;TreeNode*&gt; res; res.push_back(node); return res; &#125; vector&lt;TreeNode*&gt; result; for(int i=start; i&lt;=end; i++)&#123; vector&lt;TreeNode*&gt; left = helper(start, i-1); vector&lt;TreeNode*&gt; right = helper(i+1, end); for(int j=0; j&lt;left.size(); j++)&#123; for(int k=0; k&lt;right.size(); k++)&#123; TreeNode* root = new TreeNode(i); root-&gt;left = left[j]; root-&gt;right = right[k]; result.push_back(root); &#125; &#125; &#125; return result; &#125;&#125;; cpp 19ms, 86.97%, September 23, 2016 https://discuss.leetcode.com/topic/6711/share-a-c-dp-solution-with-o-1-space Share a C++ DP solution with O(1) space The basic idea is that we can construct the result of n node tree just from the result of n-1 node tree.Hereâ€™s how we do it: only 2 conditions: 1) The nth node is the new root, so newroot-&gt;left = oldroot; 2) the nth node is not root, we traverse the old tree, every time the node in the old tree has a right child, we can perform: old node-&gt;right = nth node, nth node -&gt;left = right child; and when we reach the end of the tree, donâ€™t forget we can also add the nth node here. One thing to notice is that every time we push a TreeNode in our result, I push the clone version of the root, and I recover what I do to the old node immediately. This is because you may use the old tree for several times. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public: TreeNode* clone(TreeNode* root)&#123; if(root == nullptr) return nullptr; TreeNode* newroot = new TreeNode(root-&gt;val); newroot-&gt;left = clone(root-&gt;left); newroot-&gt;right = clone(root-&gt;right); return newroot; &#125; vector&lt;TreeNode *&gt; generateTrees(int n) &#123; vector&lt;TreeNode *&gt; res(1,nullptr); for(int i = 1; i &lt;= n; i++)&#123; vector&lt;TreeNode *&gt; tmp; for(int j = 0; j&lt;res.size();j++)&#123; TreeNode* oldroot = res[j]; TreeNode* root = new TreeNode(i); TreeNode* target = clone(oldroot); root-&gt;left = target; tmp.push_back(root); if(oldroot!=nullptr)&#123; TreeNode* tmpold = oldroot; while(tmpold-&gt;right!=nullptr)&#123; TreeNode* nonroot = new TreeNode(i); TreeNode *tright = tmpold-&gt;right; tmpold-&gt;right = nonroot; nonroot-&gt;left = tright; TreeNode *target = clone(oldroot); tmp.push_back(target); tmpold-&gt;right = tright; tmpold = tmpold-&gt;right; &#125; tmpold-&gt;right = new TreeNode(i); TreeNode *target = clone(oldroot); tmp.push_back(target); tmpold-&gt;right = nullptr; &#125; &#125; res=tmp; &#125; return res; &#125; &#125;; https://discuss.leetcode.com/topic/4795/my-accepted-c-solution-recursive-less-than-30-lines My Accepted C++ solution (recursive, less than 30 lines) explaination: Given a tree which n nodes, it has the follwing form: (0)root(n-1) (1)root(n-2) (2)root(n-3) where (x) denotes the trees with x nodes. Now take n=3 for example. Given n=3, we have [1 2 3] in which each of them can be used as the tree root. when root=1: [1 # 2 # 3]; [1 # 3 2]; when root=2: [2 1 3]; when root=3: (similar with the situations when root=1.) Thus, if we write a recursive function who generates a group of trees in which the numbers range from f to t, we have to generate the left trees and right trees of each tree in the vector. I give the following recursive code and expect to see non-recursive ones. please! code: 123456789101112131415161718192021222324252627282930vector&lt;TreeNode *&gt; generateTree(int from, int to)&#123; vector&lt;TreeNode *&gt; ret; if(to - from &lt; 0) ret.push_back(0); if(to - from == 0) ret.push_back(new TreeNode(from)); if(to - from &gt; 0) &#123; for(int i=from; i&lt;=to; i++) &#123; vector&lt;TreeNode *&gt; l = generateTree(from, i-1); vector&lt;TreeNode *&gt; r = generateTree(i+1, to); for(int j=0; j&lt;l.size(); j++) &#123; for(int k=0; k&lt;r.size(); k++) &#123; TreeNode * h = new TreeNode (i); h-&gt;left = l[j]; h-&gt;right = r[k]; ret.push_back(h); &#125; &#125; &#125; &#125; return ret;&#125;vector&lt;TreeNode *&gt; generateTrees(int n) &#123; return generateTree(1, n);&#125; python https://discuss.leetcode.com/topic/15886/should-be-6-liner Should-be-6-Liner If only LeetCode had a TreeNode(val, left, right) constructorâ€¦ sigh. Then I wouldnâ€™t need to provide my own and my solution would be six lines instead of eleven. 123456789101112def generateTrees(self, n): def node(val, left, right): node = TreeNode(val) node.left = left node.right = right return node def trees(first, last): return [node(root, left, right) for root in range(first, last+1) for left in trees(first, root-1) for right in trees(root+1, last)] or [None] return trees(1, n) Or even just four lines, if itâ€™s not forbidden to add an optional argument: 123456789101112def node(val, left, right): node = TreeNode(val) node.left = left node.right = right return nodeclass Solution: def generateTrees(self, last, first=1): return [node(root, left, right) for root in range(first, last+1) for left in self.generateTrees(root-1, first) for right in self.generateTrees(last, root+1)] or [None] Just another version, using loops instead of list comprehension: 123456789101112def generateTrees(self, n): def generate(first, last): trees = [] for root in range(first, last+1): for left in generate(first, root-1): for right in generate(root+1, last): node = TreeNode(root) node.left = left node.right = right trees += node, return trees or [None] return generate(1, n) java https://discuss.leetcode.com/topic/3079/a-simple-recursive-solution A simple recursive solution I start by noting that 1..n is the in-order traversal for any BST with nodes 1 to n. So if I pick i-th node as my root, the left subtree will contain elements 1 to (i-1), and the right subtree will contain elements (i+1) to n. I use recursive calls to get back all possible trees for left and right subtrees and combine them in all possible ways with the root. 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; return genTrees(1,n); &#125; public List&lt;TreeNode&gt; genTrees (int start, int end) &#123; List&lt;TreeNode&gt; list = new ArrayList&lt;TreeNode&gt;(); if(start&gt;end) &#123; list.add(null); return list; &#125; if(start == end)&#123; list.add(new TreeNode(start)); return list; &#125; List&lt;TreeNode&gt; left,right; for(int i=start;i&lt;=end;i++) &#123; left = genTrees(start, i-1); right = genTrees(i+1,end); for(TreeNode lnode: left) &#123; for(TreeNode rnode: right) &#123; TreeNode root = new TreeNode(i); root.left = lnode; root.right = rnode; list.add(root); &#125; &#125; &#125; return list; &#125;&#125; https://discuss.leetcode.com/topic/2940/java-solution-with-dp Java Solution with DP Here is my java solution with DP: 123456789101112131415161718192021222324252627282930313233public static List&lt;TreeNode&gt; generateTrees(int n) &#123; List&lt;TreeNode&gt;[] result = new List[n + 1]; result[0] = new ArrayList&lt;TreeNode&gt;(); if (n == 0) &#123; return result[0]; &#125; result[0].add(null); for (int len = 1; len &lt;= n; len++) &#123; result[len] = new ArrayList&lt;TreeNode&gt;(); for (int j = 0; j &lt; len; j++) &#123; for (TreeNode nodeL : result[j]) &#123; for (TreeNode nodeR : result[len - j - 1]) &#123; TreeNode node = new TreeNode(j + 1); node.left = nodeL; node.right = clone(nodeR, j + 1); result[len].add(node); &#125; &#125; &#125; &#125; return result[n];&#125;private static TreeNode clone(TreeNode n, int offset) &#123; if (n == null) &#123; return null; &#125; TreeNode node = new TreeNode(n.val + offset); node.left = clone(n.left, offset); node.right = clone(n.right, offset); return node;&#125; result[i] stores the result until length i. For the result for length i+1, select the root node j from 0 to i, combine the result from left side and right side. Note for the right side we have to clone the nodes as the value will be offsetted by j. https://discuss.leetcode.com/topic/8410/divide-and-conquer-f-i-g-i-1-g-n-i Divide-and-conquer. F(i) = G(i-1) * G(n-i) This problem is a variant of the problem of Unique Binary Search Trees. I provided a solution along with explanation for the above problem, in the question â€œDP solution in 6 lines with explanationâ€ It is intuitive to solve this problem by following the same algorithm. Here is the code in a divide-and-conquer style. 1234567891011121314151617181920212223242526public List&lt;TreeNode&gt; generateTrees(int n) &#123; return generateSubtrees(1, n);&#125;private List&lt;TreeNode&gt; generateSubtrees(int s, int e) &#123; List&lt;TreeNode&gt; res = new LinkedList&lt;TreeNode&gt;(); if (s &gt; e) &#123; res.add(null); // empty tree return res; &#125; for (int i = s; i &lt;= e; ++i) &#123; List&lt;TreeNode&gt; leftSubtrees = generateSubtrees(s, i - 1); List&lt;TreeNode&gt; rightSubtrees = generateSubtrees(i + 1, e); for (TreeNode left : leftSubtrees) &#123; for (TreeNode right : rightSubtrees) &#123; TreeNode root = new TreeNode(i); root.left = left; root.right = right; res.add(root); &#125; &#125; &#125; return res;&#125; 5ms, 22.90%, September 23, 2016 https://discuss.leetcode.com/topic/8410/divide-and-conquer-f-i-g-i-1-g-n-i 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; List&lt;TreeNode&gt; tmp = new LinkedList&lt;TreeNode&gt;(); if(n==0) return tmp; return generateSubtrees(1, n); &#125; private List&lt;TreeNode&gt; generateSubtrees(int s, int e)&#123; List&lt;TreeNode&gt; res = new LinkedList&lt;TreeNode&gt;(); if(s&gt;e)&#123; res.add(null); return res; &#125; for(int i=s; i&lt;=e; ++i)&#123; List&lt;TreeNode&gt; leftSubtrees = generateSubtrees(s, i-1); List&lt;TreeNode&gt; rightSubtrees = generateSubtrees(i+1, e); for(TreeNode left:leftSubtrees)&#123; for(TreeNode right:rightSubtrees)&#123; TreeNode root = new TreeNode(i); root.left = left; root.right = right; res.add(root); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[094. Binary Tree Inorder Traversal]]></title>
    <url>%2Fp%2Fa4c01477%2F</url>
    <content type="text"><![CDATA[44.5% https://leetcode.com/problems/binary-tree-inorder-traversal/#/description Given a binary tree, return the inorder traversal of its nodesâ€™ values. For example:Given binary tree [1,null,2,3], 1 \ 2 / 3return [1,3,2]. Note: Recursive solution is trivial, could you do it iteratively? æ–¹æ³•ä¸€ï¼šé€’å½’ç‰ˆæœ¬ï¼Œæœ€ç®€å• Dec 10th, 2017 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; helper(root, res); return res; &#125; void helper(TreeNode* root, vector&lt;int&gt;&amp; res)&#123; if(root!=nullptr)&#123; helper(root-&gt;left, res); res.push_back(root-&gt;val); helper(root-&gt;right, res); &#125; &#125;&#125;; 1234567891011void inorder(TreeNode* root, vector&lt;int&gt;&amp; nodes) &#123; if (!root) return; inorder(root -&gt; left, nodes); nodes.push_back(root -&gt; val); inorder(root -&gt; right, nodes);&#125;vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; inorder(root, nodes); return nodes;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; vector&lt;int&gt; res;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; if(!root) return res; // è™½ç„¶æœ‰è¿”å›žå€¼ï¼Œä½†æˆ‘ä»¬ä¸ä½¿ç”¨ inorderTraversal(root-&gt;left); res.push_back(root-&gt;val); inorderTraversal(root-&gt;right); return res; &#125;&#125;; æ–¹æ³•äºŒï¼šè¿­ä»£ç‰ˆæœ¬ ä½¿ç”¨æ ˆ pCurrentæŒ‡å‘å½“å‰èŠ‚ç‚¹ã€‚ å¦‚æžœå½“å‰èŠ‚ç‚¹ä¸ä¸ºç©ºï¼ŒåŽ‹å…¥æ ˆï¼Œç„¶åŽå½“å‰èŠ‚ç‚¹æŒ‡å‘åšèŠ‚ç‚¹ã€‚ å½“å‰èŠ‚ç‚¹ä¸ºç©ºï¼Œä»Žæ ˆä¸­å–å‡ºä¸€ä¸ªèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹å€¼æ”¾å…¥vectorï¼Œå½“å‰èŠ‚ç‚¹æŒ‡å‘å³èŠ‚ç‚¹ã€‚ Dec 10th, 2017 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; // è¿™ä¸ªè¦æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶ï¼Œstackä¸ä¸ºç©ºä¸”curä¸ä¸ºnullptr while(stack.size() || cur!=nullptr)&#123; if(cur!=nullptr)&#123; stack.push(cur); cur = cur-&gt;left; &#125;else&#123; TreeNode* tmp = stack.top(); stack.pop(); res.push_back(tmp-&gt;val); cur = tmp-&gt;right; &#125; &#125; return res; &#125;&#125;; 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; vector; stack&lt;TreeNode *&gt; stack; TreeNode *pCurrent = root; while(!stack.empty() || pCurrent) &#123; if(pCurrent) &#123; stack.push(pCurrent); pCurrent = pCurrent-&gt;left; &#125; else &#123; TreeNode *pNode = stack.top(); vector.push_back(pNode-&gt;val); stack.pop(); pCurrent = pNode-&gt;right; &#125; &#125; return vector; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š å…ˆæŠŠå·¦è¾¹å…¨éƒ¨åŽ‹å…¥ï¼Œ ç„¶åŽå–å‡ºï¼Œæ”¾å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå‘ä¸Šèµ°ï¼Œå‘å³èµ°ã€‚ 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; stack; while(root || !stack.empty())&#123; if(root)&#123; stack.push(root); root = root-&gt;left; &#125;else&#123; TreeNode* node = stack.top(); stack.pop(); res.push_back(node-&gt;val); root = node-&gt;right; &#125; &#125; return res; &#125;&#125;; æ–¹æ³•ä¸‰ï¼š Morris traversal: 12345678910111213141516171819202122232425vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; TreeNode* curNode = root; vector&lt;int&gt; nodes; while (curNode) &#123; if (curNode -&gt; left) &#123; TreeNode* predecessor = curNode -&gt; left; while (predecessor -&gt; right &amp;&amp; predecessor -&gt; right != curNode) predecessor = predecessor -&gt; right; if (!(predecessor -&gt; right)) &#123; predecessor -&gt; right = curNode; curNode = curNode -&gt; left; &#125; else &#123; predecessor -&gt; right = NULL; nodes.push_back(curNode -&gt; val); curNode = curNode -&gt; right; &#125; &#125; else &#123; nodes.push_back(curNode -&gt; val); curNode = curNode -&gt; right; &#125; &#125; return nodes;&#125; æˆ‘çš„ä»£ç å®žçŽ°: 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; TreeNode* cur = root; while(cur)&#123; if(cur-&gt;left)&#123; TreeNode* pre = cur-&gt;left; while(pre-&gt;right!=NULL &amp;&amp; pre-&gt;right!=cur) pre = pre-&gt;right; if(pre-&gt;right!=cur)&#123; pre-&gt;right = cur; cur = cur-&gt;left; &#125;else&#123; pre-&gt;right = NULL; res.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125;else&#123; res.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/3288/three-methods-to-solve-c Three Methods to Solve (C++) Method 1: Using one stack and the binary tree node will be changed. Easy ,not Practical 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; vector; if(!root) return vector; stack&lt;TreeNode *&gt; stack; stack.push(root); while(!stack.empty()) &#123; TreeNode *pNode = stack.top(); if(pNode-&gt;left) &#123; stack.push(pNode-&gt;left); pNode-&gt;left = NULL; &#125; else &#123; vector.push_back(pNode-&gt;val); stack.pop(); if(pNode-&gt;right) stack.push(pNode-&gt;right); &#125; &#125; return vector; &#125;&#125;; Method 2: Using one stack and one unordered_map, this will not changed the node. Better 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; vector; if(!root) return vector; unordered_map&lt;TreeNode *, bool&gt; map;//left child has been visited:true. stack&lt;TreeNode *&gt; stack; stack.push(root); while(!stack.empty()) &#123; TreeNode *pNode = stack.top(); if(pNode-&gt;left &amp;&amp; !map[pNode]) &#123; stack.push(pNode-&gt;left); map[pNode] = true; &#125; else &#123; vector.push_back(pNode-&gt;val); stack.pop(); if(pNode-&gt;right) stack.push(pNode-&gt;right); &#125; &#125; return vector; &#125;&#125;; Method 3: Using one stack and will not changed the node. Best(at least in this three solutions) 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; vector; stack&lt;TreeNode *&gt; stack; TreeNode *pCurrent = root; while(!stack.empty() || pCurrent) &#123; if(pCurrent) &#123; stack.push(pCurrent); pCurrent = pCurrent-&gt;left; &#125; else &#123; TreeNode *pNode = stack.top(); vector.push_back(pNode-&gt;val); stack.pop(); pCurrent = pNode-&gt;right; &#125; &#125; return vector; &#125;&#125;; https://discuss.leetcode.com/topic/14475/clear-c-solutions-iterative-recursive-and-morris-traversal-3-different-solutions Clear C++ solutions â€” iterative, recursive and Morris traversal (3 different solutions!) Hi, this is a fundamental and yet classic problem. I share my three solutions here: Iterative solution using stack â€” O(n) time and O(n) space; Recursive solution â€” O(n) time and O(n) space (considering the spaces of function call stack); Morris traversal â€” O(n) time and O(1) space!!! Iterative solution using stack: 123456789101112131415161718vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; stack&lt;TreeNode*&gt; toVisit; TreeNode* curNode = root; while (curNode || !toVisit.empty()) &#123; if (curNode) &#123; toVisit.push(curNode); curNode = curNode -&gt; left; &#125; else &#123; curNode = toVisit.top(); toVisit.pop(); nodes.push_back(curNode -&gt; val); curNode = curNode -&gt; right; &#125; &#125; return nodes;&#125; Recursive solution: 1234567891011void inorder(TreeNode* root, vector&lt;int&gt;&amp; nodes) &#123; if (!root) return; inorder(root -&gt; left, nodes); nodes.push_back(root -&gt; val); inorder(root -&gt; right, nodes);&#125;vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; inorder(root, nodes); return nodes;&#125; Morris traversal: 12345678910111213141516171819202122232425vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; TreeNode* curNode = root; vector&lt;int&gt; nodes; while (curNode) &#123; if (curNode -&gt; left) &#123; TreeNode* predecessor = curNode -&gt; left; while (predecessor -&gt; right &amp;&amp; predecessor -&gt; right != curNode) predecessor = predecessor -&gt; right; if (!(predecessor -&gt; right)) &#123; predecessor -&gt; right = curNode; curNode = curNode -&gt; left; &#125; else &#123; predecessor -&gt; right = NULL; nodes.push_back(curNode -&gt; val); curNode = curNode -&gt; right; &#125; &#125; else &#123; nodes.push_back(curNode -&gt; val); curNode = curNode -&gt; right; &#125; &#125; return nodes;&#125; https://discuss.leetcode.com/topic/21942/my-3-solutions-in-c My 3 solutions in c++ 123456789// recursive, it&apos;s trivial...vector&lt;int&gt; v;vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; if(!root) return v; inorderTraversal(root-&gt;left); v.push_back(root-&gt;val); inorderTraversal(root-&gt;right); return v;&#125; 12345678910111213141516171819// iterate, use stackvector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root; stack&lt;TreeNode*&gt; s; while(true)&#123; while(temp)&#123; s.push(temp); temp = temp-&gt;left; &#125; if(s.empty()) break; temp = s.top(); s.pop(); v.push_back(temp-&gt;val); temp = temp-&gt;right; &#125; return v;&#125; 123456789101112131415161718192021222324// iterate, morris traversal, without stackvector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root, *prev; while(temp)&#123; if(!temp-&gt;left)&#123; v.push_back(temp-&gt;val); temp = temp-&gt;right; &#125;else&#123; prev = temp-&gt;left; while(prev-&gt;right&amp;&amp;(prev-&gt;right != temp)) prev = prev-&gt;right; if(!prev-&gt;right)&#123; prev-&gt;right = temp; temp = temp-&gt;left; &#125;else&#123; v.push_back(temp-&gt;val); prev-&gt;right = NULL; temp = temp-&gt;right; &#125; &#125; &#125;&#125; python https://discuss.leetcode.com/topic/21350/python-recursive-and-iterative-solutions Python recursive and iterative solutions. 1234567891011# recursivelydef inorderTraversal1(self, root): res = [] self.helper(root, res) return res def helper(self, root, res): if root: self.helper(root.left, res) res.append(root.val) self.helper(root.right, res) 123456789101112# iteratively def inorderTraversal(self, root): res, stack = [], [] while True: while root: stack.append(root) root = root.left if not stack: return res node = stack.pop() res.append(node.val) root = node.right https://discuss.leetcode.com/topic/14640/simple-python-iterative-solution-by-using-a-visited-flag-o-n-56ms Simple Python iterative solution by using a visited flag - O(n) 56ms 123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # @param &#123;TreeNode&#125; root # @return &#123;integer[]&#125; def inorderTraversal(self, root): result, stack = [], [(root, False)] while stack: cur, visited = stack.pop() if cur: if visited: result.append(cur.val) else: stack.append((cur.right, False)) stack.append((cur, True)) stack.append((cur.left, False)) return result 48ms, 57.41%, June.16th, 2016 https://leetcode.com/discuss/51816/python-recursive-and-iterative-solutions 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def inorderTraversal(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; ans = [] stack = [] while stack or root: if root: stack.append(root) root = root.left else: tmpNode = stack.pop() ans.append(tmpNode.val) root = tmpNode.right return ans java https://discuss.leetcode.com/topic/6478/iterative-solution-in-java-simple-and-readable Iterative solution in Java - simple and readable 123456789101112131415161718public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode cur = root; while(cur!=null || !stack.empty())&#123; while(cur!=null)&#123; stack.add(cur); cur = cur.left; &#125; cur = stack.pop(); list.add(cur.val); cur = cur.right; &#125; return list;&#125; https://discuss.leetcode.com/topic/3402/morris-traversal-no-recursion-no-stack Morris Traversalâ€”â€”- NO RECURSION NO STACK 12345678910111213141516171819202122232425262728293031323334public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;public class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if(root == null) return new ArrayList&lt;Integer&gt;(); List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); TreeNode pre = null; while(root != null)&#123; if(root.left == null)&#123; res.add(root.val); root = root.right; &#125;else&#123; pre = root.left; while(pre.right != null &amp;&amp; pre.right != root)&#123; pre = pre.right; &#125; if(pre.right == null)&#123; pre.right = root; root = root.left; &#125;else&#123; pre.right = null; res.add(root.val); root = root.right; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>medium</tag>
        <tag>stack</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[093. Restore IP Addresses]]></title>
    <url>%2Fp%2F3f3a9681%2F</url>
    <content type="text"><![CDATA[26.2% https://leetcode.com/problems/restore-ip-addresses/ Given a string containing only digits, restore it by returning all possible valid IP address combinations. 1234For example:Given &quot;25525511135&quot;,return [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]. (Order does not matter) æ–¹æ³•ä¸€ï¼š å­¦ä¹ stringçš„å‡½æ•°ï¼Œsubstrã€stoi intè½¬stringçš„å‡½æ•°ï¼Œto_string 0ms, 85.96%, September 22, 2016 https://discuss.leetcode.com/topic/38342/who-can-beat-this-code 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; ret; string ans; for(int a=1; a&lt;=3; a++) for(int b=1; b&lt;=3; b++) for(int c=1; c&lt;=3; c++) for(int d=1; d&lt;=3; d++) if(a+b+c+d == s.length())&#123; int A = stoi(s.substr(0, a)); int B = stoi(s.substr(a, b)); int C = stoi(s.substr(a+b, c)); int D = stoi(s.substr(a+b+c, d)); if(A&lt;=255&amp;&amp;B&lt;=255&amp;&amp;C&lt;=255&amp;&amp;D&lt;=255) if((ans=to_string(A)+&quot;.&quot;+to_string(B)+&quot;.&quot;+to_string(C)+&quot;.&quot;+ to_string(D)).length() == s.length()+3) ret.push_back(ans); &#125; return ret; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; res; // è¦æ³¨æ„æ—¶&lt;=è¿˜æ˜¯&lt; for(int i=1; i&lt;=3; i++)&#123; for(int j=1; j&lt;=3; j++)&#123; for(int k=1; k&lt;=3; k++)&#123; for(int l=1; l&lt;=3; l++)&#123; if(i+k+j+l==s.size())&#123; int a = stoi(s.substr(0, i)); int b = stoi(s.substr(i, j)); int c = stoi(s.substr(i+j, k)); int d = stoi(s.substr(i+j+k, l)); // è¦æœ‰&lt;=255è¿™ä¸ªåˆ¤æ–­ if(a&lt;=255 &amp;&amp; b&lt;=255 &amp;&amp; c&lt;=255 &amp;&amp; d&lt;=255)&#123; // æ³¨æ„ä½¿ç”¨"."è¿˜æ˜¯'.'ï¼Œå°¤å…¶æ³¨æ„c++æ—¶ string t = to_string(a)+"."+to_string(b)+"."+ to_string(c)+"."+to_string(d); if(t.size()==s.size()+3) res.push_back(t); &#125; &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125;; æ–¹æ³•äºŒï¼š dfs https://discuss.leetcode.com/topic/19274/share-0ms-neat-and-clear-c-solution-using-dfs Share 0ms neat and clear c++ solution using DFS 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; result; string ip; dfs(s,0,0,ip,result); //paras:string s,start index of s,step(from0-3),intermediate ip,final result return result; &#125; void dfs(string s,int start,int step,string ip,vector&lt;string&gt;&amp; result)&#123; if(start==s.size()&amp;&amp;step==4)&#123; ip.erase(ip.end()-1); //remove the last &apos;.&apos; from the last decimal number result.push_back(ip); return; &#125; if(s.size()-start&gt;(4-step)*3) return; if(s.size()-start&lt;(4-step)) return; int num=0; for(int i=start;i&lt;start+3;i++)&#123; num=num*10+(s[i]-&apos;0&apos;); if(num&lt;=255)&#123; ip+=s[i]; dfs(s,i+1,step+1,ip+&apos;.&apos;,result); &#125; if(num==0) break; &#125; &#125;&#125;; java 4ms, 58.66%, September 22, 2016 https://discuss.leetcode.com/topic/3919/my-code-in-java 3-loop divides the string s into 4 substring: s1, s2, s3, s4. Check if each substring is valid.In isValid, strings whose length greater than 3 or equals to 0 is not valid; or if the stringâ€™s length is longer than 1 and the first letter is â€˜0â€™ then itâ€™s invalid; or the string whose integer representation greater than 255 is invalid. 12345678910111213141516171819202122public class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); int len = s.length(); for(int i=1; i&lt;4&amp;&amp;i&lt;len-2; i++)&#123; for(int j=i+1; j&lt;i+4&amp;&amp; j&lt;len; j++)&#123; for(int k=j+1; k&lt;j+4&amp;&amp;k&lt;len; k++)&#123; String s1 = s.substring(0, i), s2 = s.substring(i, j), s3=s.substring(j,k), s4=s.substring(k,len); if(isValid(s1) &amp;&amp; isValid(s2) &amp;&amp; isValid(s3) &amp;&amp; isValid(s4)) res.add(s1+&quot;.&quot;+s2+&quot;.&quot;+s3+&quot;.&quot;+s4); &#125; &#125; &#125; return res; &#125; public boolean isValid(String s)&#123; if(s.length()&gt;3 || s.length()==0 || (s.charAt(0)==&apos;0&apos;&amp;&amp;s.length()&gt;1) || Integer.parseInt(s)&gt;255) return false; return true; &#125;&#125; https://discuss.leetcode.com/topic/4742/very-simple-dfs-solution Very simple DFS solution 1234567891011121314151617public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; solutions = new ArrayList&lt;String&gt;(); restoreIp(s, solutions, 0, &quot;&quot;, 0); return solutions;&#125;private void restoreIp(String ip, List&lt;String&gt; solutions, int idx, String restored, int count) &#123; if (count &gt; 4) return; if (count == 4 &amp;&amp; idx == ip.length()) solutions.add(restored); for (int i=1; i&lt;4; i++) &#123; if (idx+i &gt; ip.length()) break; String s = ip.substring(idx,idx+i); if ((s.startsWith(&quot;0&quot;) &amp;&amp; s.length()&gt;1) || (i==3 &amp;&amp; Integer.parseInt(s) &gt;= 256)) continue; restoreIp(ip, solutions, idx+i, restored+s+(count==3?&quot;&quot; : &quot;.&quot;), count+1); &#125;&#125; https://discuss.leetcode.com/topic/6304/my-concise-ac-java-code My concise AC java code the basic idea is to make three cuts into the string, separating it into four parts, each part contains 1 ~ 3 digits and it must be &lt; 255. 12345678910111213141516171819202122static List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; ans = new ArrayList&lt;String&gt;(); int len = s.length(); for (int i = 1; i &lt;=3; ++i)&#123; // first cut if (len-i &gt; 9) continue; for (int j = i+1; j&lt;=i+3; ++j)&#123; //second cut if (len-j &gt; 6) continue; for (int k = j+1; k&lt;=j+3 &amp;&amp; k&lt;len; ++k)&#123; // third cut int a,b,c,d; // the four int&apos;s seperated by &quot;.&quot; a = Integer.parseInt(s.substring(0,i)); b = Integer.parseInt(s.substring(i,j)); // notice that &quot;01&quot; can be parsed into 1. Need to deal with that later. c = Integer.parseInt(s.substring(j,k)); d = Integer.parseInt(s.substring(k)); if (a&gt;255 || b&gt;255 || c&gt;255 || d&gt;255) continue; String ip = a+&quot;.&quot;+b+&quot;.&quot;+c+&quot;.&quot;+d; if (ip.length()&lt;len+3) continue; // this is to reject those int&apos;s parsed from &quot;01&quot; or &quot;00&quot;-like substrings ans.add(ip); &#125; &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/20009/easy-java-code-of-backtracking-within-16-lines Easy Java code of backtracking within 16 lines 12345678910111213141516171819public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); helper(s,&quot;&quot;,res,0); return res; &#125; public void helper(String s, String tmp, List&lt;String&gt; res,int n)&#123; if(n==4)&#123; if(s.length()==0) res.add(tmp.substring(0,tmp.length()-1)); //substring here to get rid of last &apos;.&apos; return; &#125; for(int k=1;k&lt;=3;k++)&#123; if(s.length()&lt;k) continue; int val = Integer.parseInt(s.substring(0,k)); if(val&gt;255 || k!=String.valueOf(val).length()) continue; /*in the case 010 the parseInt will return len=2 where val=10, but k=3, skip this.*/ helper(s.substring(k),tmp+s.substring(0,k)+&quot;.&quot;,res,n+1); &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[092. Reverse Linked List II]]></title>
    <url>%2Fp%2F7b414406%2F</url>
    <content type="text"><![CDATA[30.0% https://leetcode.com/problems/reverse-linked-list-ii/?tab=Description Reverse a linked list from position m to n. Do it in-place and in one-pass. 1234For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. Note: Given m, n satisfy the following condition: 1 â‰¤ m â‰¤ n â‰¤ length of list. cpp 3ms, 7.08%, September 21, 2016 https://discuss.leetcode.com/topic/4980/share-my-14-lines-c-solution Share my 14 lines C++ solution 1234567891011121314151617ListNode *reverseBetween(ListNode *head, int m, int n) &#123; if(m==n)return head; n-=m; ListNode prehead(0); prehead.next=head; ListNode* pre=&amp;prehead; while(--m)pre=pre-&gt;next; ListNode* pstart=pre-&gt;next; while(n--) &#123; ListNode *p=pstart-&gt;next; pstart-&gt;next=p-&gt;next; p-&gt;next=pre-&gt;next; pre-&gt;next=p; &#125; return prehead.next;&#125; https://discuss.leetcode.com/topic/15034/12-lines-4ms-c 12-lines 4ms C++ The basic idea is as follows: (1) Create a new_head that points to head and use it to locate the immediate node before the m-th (notice that it is 1-indexed) node pre; (2) Set cur to be the immediate node after pre and at each time move the immediate node after cur (named move) to be the immediate node after pre. Repeat it for n - m times. 123456789101112131415161718class Solution &#123; public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; ListNode* new_head = new ListNode(0); new_head -&gt; next = head; ListNode* pre = new_head; for (int i = 0; i &lt; m - 1; i++) pre = pre -&gt; next; ListNode* cur = pre -&gt; next; for (int i = 0; i &lt; n - m; i++) &#123; ListNode* move = cur -&gt; next; cur -&gt; next = move -&gt; next; move -&gt; next = pre -&gt; next; pre -&gt; next = move; &#125; return new_head -&gt; next; &#125;&#125;; python 56ms, September 21, 2016 https://discuss.leetcode.com/topic/10378/python-one-pass-iterative-solution Python one pass iterative solution The idea is simple and intuitive: find linkedlist [m, n], reverse it, then connect m with n+1, connect n with m-1 1234567891011121314151617181920212223242526272829class Solution: # @param head, a ListNode # @param m, an integer # @param n, an integer # @return a ListNode def reverseBetween(self, head, m, n): if m == n: return head dummyNode = ListNode(0) dummyNode.next = head pre = dummyNode for i in range(m - 1): pre = pre.next # reverse the [m, n] nodes reverse = None cur = pre.next for i in range(n - m + 1): next = cur.next cur.next = reverse reverse = cur cur = next pre.next.next = cur pre.next = reverse return dummyNode.next https://discuss.leetcode.com/topic/27852/python-implementation-and-detailed-explanation Python implementation and detailed explanation For List with [1, 2, 3, 4, 5], supposed m == 2 and n == 4 Step1: The part I need to reversed is node 2 to node 4, which has n - m + 1 = 3 nodes. Therefore, I would like to maintain a window with n - m + 1 nodes with the windowâ€™s head whead and windowâ€™s tail wtail, then if whead is head, wtail would be the next n-m node from head. [123]45 =&gt; whead is 1 and wtail is 3 Step2: And to get to the right reversed portion we want, we need to shift the window m-1 times 1[234]5 =&gt; whead is 2 and wtail is 4 Step3: Isolate the nodes inside the window, reverse the window as Reverse Linked List Step4: combine the outside node with reversed node. To do so, I need to record the head outside the window ohead, and the tail outside the window otail ohead is 1, otail is 5 1-[432]-5 Implementation detail: Since in step 4, you need to let ohead.next = reversed_headIf you create a dummy node, you can save some lines for m == 1 cases, where ohead would be None and ohead.next would fail the program. 12345678910111213141516171819202122232425class Solution(object): def reverseBetween(self, head, m, n): if m &gt;= n: return head #Step 1# ohead = dummy = ListNode(0) whead = wtail = head dummy.next = head for i in range(n-m): wtail = wtail.next #Step 2# for i in range(m-1): ohead, whead, wtail = whead, whead.next, wtail.next #Step 3# otail, wtail.next = wtail.next, None revhead, revtail = self.reverse(whead) #Step 4# ohead.next, revtail.next = revhead, otail return dummy.next def reverse(self, head): pre, cur, tail = None, head, head while cur: cur.next, pre, cur = pre, cur, cur.next return pre, tail java 0ms, 13.07%, September 21, 2016 https://discuss.leetcode.com/topic/8976/simple-java-solution-with-clear-explanation Simple Java solution with clear explanation Simply just reverse the list along the way using 4 pointers: dummy, pre, start, then 123456789101112131415161718192021222324252627public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(head == null) return null; ListNode dummy = new ListNode(0); // create a dummy node to mark the head of this list dummy.next = head; ListNode pre = dummy; // make a pointer pre as a marker for the node before reversing for(int i = 0; i&lt;m-1; i++) pre = pre.next; ListNode start = pre.next; // a pointer to the beginning of a sub-list that will be reversed ListNode then = start.next; // a pointer to a node that will be reversed // 1 - 2 -3 - 4 - 5 ; m=2; n =4 ---&gt; pre = 1, start = 2, then = 3 // dummy-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 for(int i=0; i&lt;n-m; i++) &#123; start.next = then.next; then.next = pre.next; pre.next = then; then = start.next; &#125; // first reversing : dummy-&gt;1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4 // second reversing: dummy-&gt;1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish) return dummy.next; &#125; https://discuss.leetcode.com/topic/3250/share-my-java-code Share my Java code The basic idea is to build a sub-list when we hit Node m by adding the subsequent nodes to the head of the sub-list one by one until we hit Node n. Then connect the nodes before Node m, the sub-list and the nodes following Node n. 12345678910111213141516171819202122232425public ListNode reverseBetween(ListNode head, int m, int n) &#123; ListNode dummyhead = new ListNode(0); dummyhead.next = head; ListNode sublisthead = new ListNode(0); ListNode sublisttail = new ListNode(0); int count = 1; ListNode pre_cur = dummyhead, cur = head; while(count &lt;=n)&#123; ListNode temp = cur.next; if (count &lt; m) pre_cur = cur; else if (count == m)&#123; sublisttail = cur; sublisthead.next = cur; &#125;else if (count &gt; m)&#123; cur.next = sublisthead.next; sublisthead.next = cur; &#125; cur = temp; ++count; &#125; pre_cur.next = sublisthead.next; sublisttail.next = cur; return dummyhead.next;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[091. Decode Ways]]></title>
    <url>%2Fp%2F33438676%2F</url>
    <content type="text"><![CDATA[19.6% https://leetcode.com/problems/decode-ways/ A message containing letters from A-Z is being encoded to numbers using the following mapping: 1234&apos;A&apos; -&gt; 1&apos;B&apos; -&gt; 2...&apos;Z&apos; -&gt; 26 Given an encoded message containing digits, determine the total number of ways to decode it. For example,Given encoded message â€œ12â€, it could be decoded as â€œABâ€ (1 2) or â€œLâ€ (12). The number of ways decoding â€œ12â€ is 2. æ–¹æ³•ä¸€ï¼š ä¸¤ä¸ªä¸¤ä¸ªçš„è§£å†³ï¼Œä¸€ä¸ªä¸€ä¸ªçš„éåŽ†ï¼Œä¸¤ä¸ªä¸¤ä¸ªçš„éªŒè¯ï¼Œé˜²æ­¢100è¿™æ ·çš„æ— æ³•è§£æžçš„ã€‚ å¯¹äºŽæ•°å­—ï¼Œæœ‰ä¸¤ç§è§£ç æ–¹å¼ã€‚ ä¸€ç§æ˜¯s[i-2] + â€˜i-1, iâ€™ï¼ˆi-1,iç»„åˆæˆä¸€ä¸ªå­—æ¯ï¼‰ï¼Œä¸€ç§æ˜¯s[i-1] + â€˜iâ€™ ï¼ˆiè‡ªå·±ç»„åˆæˆä¸€ä¸ªæ–¹å¼ï¼‰ é¦–å…ˆï¼Œå¦‚æžœs[i] == â€˜0â€™è¿™ç§æƒ…å†µä¸‹ï¼Œs[i-1]è§£ç å¤±æ•ˆï¼Œè®¾å®šå€¼ä¸º0 ç„¶åŽâ€™i-1,iâ€™ç»„åˆæˆä¸€ä¸ªå­—æ¯çš„è¯ï¼Œ å°±å¯ä»¥æ›´æ–°s[i]è§£ç æ–¹å¼ä¸ºs[i-1]å’Œs[i-2]çš„å’Œäº† å¦‚æžœç»„åˆä¸æˆå­—æ¯ï¼Œåˆ™s[i] = s[i-1] 0ms, 73.36%, September 20, 2016 https://discuss.leetcode.com/topic/7025/a-concise-dp-solution 123456789101112131415161718192021class Solution &#123;public: int numDecodings(string s) &#123; if(!s.size() || s.front() == &apos;0&apos;) return 0; // r2: decode ways of s[i-2] , r1: decode ways of s[i-1] int r1 = 1, r2 = 1; for(int i=1; i&lt;s.size(); i++)&#123; // zero voids ways of the last because zero cannot be used separately if(s[i] == &apos;0&apos;) r1 = 0; // possible two-digit letter, so new r1 is sum of both while new r2 is the old r1 if(s[i-1] == &apos;1&apos; || s[i-1] == &apos;2&apos; &amp;&amp; s[i] &lt;= &apos;6&apos;)&#123; r1 = r1 + r2; r2 = r1 - r2; &#125; // one-digit letter, no new way added else r2 = r1; &#125; return r1; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š ä¸¤ä¸ªå˜é‡ï¼Œr1ï¼Œ r2ï¼Œä¸€ä¸ªæ˜¯éåŽ†åˆ°iæ—¶ï¼Œr1è¡¨ç¤ºï¼Œä»Žå¼€å§‹è‡³i-2ä½æ—¶çš„decode ways r2è¡¨ç¤ºå¼€å§‹è‡³i-1çš„decode ways æ›´æ–°æ—¶ï¼Œæ–°çš„r1æ˜¾ç„¶æ˜¯ç­‰äºŽr2ã€‚ æ–°çš„r2ï¼Œè¦ä»Žr1å’Œr2åŠä»–ä»¬åŽé¢ä¸€ä¸¤ä½çš„æƒ…å†µï¼Œæ˜¯å¦åˆæ³•åŽ»åˆ¤æ–­ã€‚ 12345678910111213141516171819class Solution &#123;public: int numDecodings(string s) &#123; // stringçš„å‡½æ•°front() if(s.empty() || s.front()=='0') return 0; int r1=1, r2=1; for(int i=1; i&lt;s.size(); i++)&#123; int nr2 = 0; if(s[i]!='0') nr2 += r2; if(s[i-1]=='1' || s[i-1]=='2'&amp;&amp;s[i]&lt;='6') nr2 += r1; r1 = r2; r2 = nr2; &#125; return r2; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°äºŒ: 1234567891011121314151617181920class Solution &#123;public: int numDecodings(string s) &#123; int n = s.size(); if(n&lt;1) return 0; // r1 i-2, r2 i-1 int r1 = 1, r2 = s[0]&gt;='1' &amp;&amp; s[1]&lt;='9' ? 1 : 0; for(int i=1; i&lt;n; i++)&#123; int nr1 = r2; int nr2 = 0; if(s[i]&gt;='1' &amp;&amp; s[i]&lt;='9') nr2 += r2; if(s[i-1]=='1' || s[i-1]=='2' &amp;&amp; s[i]&lt;='6') nr2 += r1; r1 = nr1; r2 = nr2; &#125; return r2; &#125;&#125;; æ–¹æ³•äºŒï¼š https://discuss.leetcode.com/topic/15440/my-c-0ms-dp-solution-o-n My c++ 0ms DP solution O(n) 12345678910111213141516171819202122int n = s.size(); if(n == 0 || s[0] == &apos;0&apos;) return 0; if(n == 1) return 1; int res = 0,fn_1 = 1,fn_2 = 1; for(int i = 1;i &lt; n;i++)&#123; int temp = fn_1; if(isValid(s[i])&amp;&amp;isValid(s[i-1],s[i])) res+=fn_1+fn_2; if(!isValid(s[i])&amp;&amp;isValid(s[i-1],s[i])) res+=fn_2; if(isValid(s[i])&amp;&amp;!isValid(s[i-1],s[i])) res+=fn_1; if(!isValid(s[i])&amp;&amp;!isValid(s[i-1],s[i])) return 0; fn_1 = res; fn_2 = temp; res = 0; &#125; return fn_1;&#125;bool isValid(char a,char b)&#123; return a == &apos;1&apos;||(a == &apos;2&apos; &amp;&amp; b &lt;=&apos;6&apos;);&#125;bool isValid(char a)&#123; return a != &apos;0&apos;;&#125; python62ms, 23.31%, September 20, 2016 https://discuss.leetcode.com/topic/19042/1-liner-o-1-space w tells the number of ways v tells the previous number of ways d is the current digit p is the previous digit 12345678910class Solution(object): def numDecodings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; v, w, p = 0, int(s&gt;&apos;&apos;), &apos;&apos; for d in s: v, w, p = w, (d&gt;&apos;0&apos;)*w + (9&lt;int(p+d)&lt;27)*v, d return w 12def numDecodings(self, s): return reduce(lambda(v,w,p),d:(w,(d&gt;&apos;0&apos;)*w+(9&lt;int(p+d)&lt;27)*v,d),s,(0,s&gt;&apos;&apos;,&apos;&apos;))[1]*1 java5ms, 27.87%, September 20, 2016 https://discuss.leetcode.com/topic/35840/java-clean-dp-solution-with-explanation I used a dp array of size n + 1 to save subproblem solutions. dp[0] means an empty string will have one way to decode, dp[1] means the way to decode a string of size 1. I then check one digit and two digit combination and save the results along the way. In the end, dp[n] will be the end result. 123456789101112131415161718public class Solution &#123; public int numDecodings(String s) &#123; if(s == null || s.length() == 0) return 0; int n = s.length(); int[] dp = new int[n+1]; dp[0] = 1; dp[1] = s.charAt(0) != &apos;0&apos; ? 1: 0; for(int i = 2; i&lt;=n; i++)&#123; int first = Integer.valueOf(s.substring(i-1, i)); int second = Integer.valueOf(s.substring(i-2, i)); if(first &gt;= 1 &amp;&amp; first &lt;= 9) dp[i] += dp[i-1]; if(second &gt;= 10 &amp;&amp; second &lt;= 26) dp[i] += dp[i-2]; &#125; return dp[n]; &#125;&#125; https://discuss.leetcode.com/topic/2562/dp-solution-java-for-reference DP Solution (Java) for reference 12345678910111213141516public class Solution &#123; public int numDecodings(String s) &#123; int n = s.length(); if (n == 0) return 0; int[] memo = new int[n+1]; memo[n] = 1; memo[n-1] = s.charAt(n-1) != &apos;0&apos; ? 1 : 0; for (int i = n - 2; i &gt;= 0; i--) if (s.charAt(i) == &apos;0&apos;) continue; else memo[i] = (Integer.parseInt(s.substring(i,i+2))&lt;=26) ? memo[i+1]+memo[i+2] : memo[i+1]; return memo[0]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
        <tag>dynamci programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[090. Subsets II]]></title>
    <url>%2Fp%2Ff25f3971%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/subsets-ii/ Given a collection of integers that might contain duplicates, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. 1234567891011For example,If nums = [1,2,2], a solution is:[ [2], [1], [1,2,2], [2,2], [1,2], []] æ–¹æ³•ä¸€ï¼š å›žæº¯æ³• é’ˆå¯¹é‡å¤çš„ï¼ŒåŽ»é™¤å°±å¥½äº†ã€‚ https://discuss.leetcode.com/topic/13543/accepted-10ms-c-solution-use-backtracking-only-10-lines-easy-understand Accepted 10ms c++ solution use backtracking, only 10 lines, easy understand. The characteristics of C++ reference is an outstanding tool for backtracking algorithm! let us use [1,2,3,4] as an example to explain my solution: 12345678910subsets([1,2,3,4]) = [] // push(1) [1, subsets([2,3,4])] // if push N times in subsets([2,3,4]), the pop times is also N, so vec is also [1] after backtrack. // pop(), push(2) [2, subsets([3,4])] // pop(), push(3) [3, subsets([4])] // pop(), push(4) [4, subsets([])] // pop() Accepted 10ms c++ solution use backtracking for Subsets 12345678910111213141516171819class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; subsets(std::vector&lt;int&gt; &amp;nums) &#123; std::sort(nums.begin(), nums.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; vec; subsets(res, nums, vec, 0); return res; &#125;private: void subsets(std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;nums, std::vector&lt;int&gt; &amp;vec, int begin) &#123; res.push_back(vec); for (int i = begin; i != nums.size(); ++i) &#123; vec.push_back(nums[i]); subsets(res, nums, vec, i + 1); vec.pop_back(); &#125; &#125;&#125;; Accepted 10ms c++ solution use backtracking for Subsets II 1234567891011121314151617181920class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; subsetsWithDup(std::vector&lt;int&gt; &amp;nums) &#123; std::sort(nums.begin(), nums.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; vec; subsetsWithDup(res, nums, vec, 0); return res; &#125;private: void subsetsWithDup(std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;nums, std::vector&lt;int&gt; &amp;vec, int begin) &#123; res.push_back(vec); for (int i = begin; i != nums.size(); ++i) if (i == begin || nums[i] != nums[i - 1]) &#123; vec.push_back(nums[i]); subsetsWithDup(res, nums, vec, i + 1); vec.pop_back(); &#125; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ° åŠ å…¥äº†sortï¼Œé˜²æ­¢nums={4ï¼Œ4ï¼Œ1ï¼Œ4}è¿™ç§æƒ…å†µ 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; subs; vector&lt;int&gt; sub; if(nums.empty()) return subs; sort(nums.begin(), nums.end()); dfs(subs, sub, 0, nums); return subs; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; subs, vector&lt;int&gt;&amp; sub, int k, vector&lt;int&gt;&amp; nums)&#123; subs.push_back(sub); for(int i=k; i&lt;nums.size(); i++)&#123; if(i!=k &amp;&amp; nums[i]==nums[i-1]) continue; sub.push_back(nums[i]); dfs(subs, sub, i+1, nums); sub.pop_back(); &#125; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs; vector&lt;int&gt; sub; dfs(nums, sub, subs, 0); return subs; &#125; void dfs(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; sub, vector&lt;vector&lt;int&gt;&gt;&amp; subs, int k)&#123; subs.push_back(sub); for(int i=k; i&lt;nums.size(); i++)&#123; if(i!=k &amp;&amp; nums[i]==nums[i-1]) continue; sub.push_back(nums[i]); dfs(nums, sub, subs, i+1); sub.pop_back(); &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/4661/c-solution-and-explanation C++ solution and explanation To solve this problem, it is helpful to first think how many subsets are there. If there is no duplicate element, the answer is simply 2^n, where n is the number of elements. This is because you have two choices for each element, either putting it into the subset or not. So all subsets for this no-duplicate set can be easily constructed:num of subset (1 to 2^0) empty set is the first subset (2^0+1 to 2^1) add the first element into subset from (1) (2^1+1 to 2^2) add the second element into subset (1 to 2^1) (2^2+1 to 2^3) add the third element into subset (1 to 2^2) â€¦. (2^(n-1)+1 to 2^n) add the nth element into subset(1 to 2^(n-1)) Then how many subsets are there if there are duplicate elements? We can treat duplicate element as a spacial element. For example, if we have duplicate elements (5, 5), instead of treating them as two elements that are duplicate, we can treat it as one special element 5, but this element has more than two choices: you can either NOT put it into the subset, or put ONE 5 into the subset, or put TWO 5s into the subset. Therefore, we are given an array (a1, a2, a3, â€¦, an) with each of them appearing (k1, k2, k3, â€¦, kn) times, the number of subset is (k1+1)(k2+1)â€¦(kn+1). We can easily see how to write down all the subsets similar to the approach above. 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; subsetsWithDup(vector&lt;int&gt; &amp;S) &#123; vector&lt;vector&lt;int&gt; &gt; totalset = &#123;&#123;&#125;&#125;; sort(S.begin(),S.end()); for(int i=0; i&lt;S.size();)&#123; int count = 0; // num of elements are the same while(count + i&lt;S.size() &amp;&amp; S[count+i]==S[i]) count++; int previousN = totalset.size(); for(int k=0; k&lt;previousN; k++)&#123; vector&lt;int&gt; instance = totalset[k]; for(int j=0; j&lt;count; j++)&#123; instance.push_back(S[i]); totalset.push_back(instance); &#125; &#125; i += count; &#125; return totalset; &#125;&#125;; https://discuss.leetcode.com/topic/3601/simple-iterative-solution Simple iterative solution If we want to insert an element which is a dup, we can only insert it after the newly inserted elements from last step. 123456789101112131415vector&lt;vector&lt;int&gt; &gt; subsetsWithDup(vector&lt;int&gt; &amp;S) &#123; sort(S.begin(), S.end()); vector&lt;vector&lt;int&gt;&gt; ret = &#123;&#123;&#125;&#125;; int size = 0, startIndex = 0; for (int i = 0; i &lt; S.size(); i++) &#123; startIndex = i &gt;= 1 &amp;&amp; S[i] == S[i - 1] ? size : 0; size = ret.size(); for (int j = startIndex; j &lt; size; j++) &#123; vector&lt;int&gt; temp = ret[j]; temp.push_back(S[i]); ret.push_back(temp); &#125; &#125; return ret;&#125; python https://discuss.leetcode.com/topic/8541/simple-python-solution-without-extra-space Simple python solution without extra space. 123456789101112class Solution: # @param num, a list of integer # @return a list of lists of integer def subsetsWithDup(self, S): res = [[]] S.sort() for i in range(len(S)): if i == 0 or S[i] != S[i - 1]: l = len(res) for j in range(len(res) - l, len(res)): res.append(res[j] + [S[i]]) return res if S[i] is same to S[i - 1], then it neednâ€™t to be added to all of the subset, just add it to the last l subsets which are created by adding S[i - 1] java https://discuss.leetcode.com/topic/22638/very-simple-and-fast-java-solution Very simple and fast java solution 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; each = new ArrayList&lt;&gt;(); helper(res, each, 0, nums); return res;&#125;public void helper(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; each, int pos, int[] n) &#123; if (pos &lt;= n.length) &#123; res.add(each); &#125; int i = pos; while (i &lt; n.length) &#123; each.add(n[i]); helper(res, new ArrayList&lt;&gt;(each), i + 1, n); each.remove(each.size() - 1); i++; while (i &lt; n.length &amp;&amp; n[i] == n[i - 1]) &#123;i++;&#125; &#125; return;&#125; The Basic idea is: use â€œwhile (i &lt; n.length &amp;&amp; n[i] == n[i - 1]) {i++;}â€ to avoid the duplicate. For example, the input is 2 2 2 3 4. Consider the helper function. The process is: each.add(n[i]); â€“&gt; add first 2 (index 0) helper(res, new ArrayList&lt;&gt;(each), i + 1, n); â€“&gt; go to recursion part, list each is while (i &lt; n.length &amp;&amp; n[i] == n[i - 1]) {i++;} â€“&gt; after this, i == 3, add the element as in subset I https://discuss.leetcode.com/topic/16666/standard-dfs-java-solution Standard DFS Java Solution 123456789101112131415161718public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result= new ArrayList&lt;&gt;(); dfs(nums,0,new ArrayList&lt;Integer&gt;(),result); return result; &#125; public void dfs(int[] nums,int index,List&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; result)&#123; result.add(path); for(int i=index;i&lt;nums.length;i++)&#123; if(i&gt;index&amp;&amp;nums[i]==nums[i-1]) continue; List&lt;Integer&gt; nPath= new ArrayList&lt;&gt;(path); nPath.add(nums[i]); dfs(nums,i+1,nPath,result); &#125; &#125;&#125; https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; 12345678910111213141516171819public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i=start; i&lt;nums.length; i++)&#123; if(i==start || nums[i] != nums[i-1])&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i+1); tempList.remove(tempList.size()-1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[089. Gray Code]]></title>
    <url>%2Fp%2F57e82460%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/gray-code/ The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. 123456For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:00 - 001 - 111 - 310 - 2 Note: For a given n, a gray code sequence is not uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence according to the above definition. For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that. java https://discuss.leetcode.com/topic/8557/an-accepted-three-line-solution-in-java An accepted three line solution in JAVA 12345public List&lt;Integer&gt; grayCode(int n) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; 1&lt;&lt;n; i++) result.add(i ^ i&gt;&gt;1); return result;&#125; The idea is simple. G(i) = i^ (i/2). 1ms, September 20, 2016 https://discuss.leetcode.com/topic/3021/share-my-solution Share my solution My idea is to generate the sequence iteratively. For example, when n=3, we can get the result based on n=2.00,01,11,10 -&gt; (000,001,011,010 ) (110,111,101,100). The middle two numbers only differ at their highest bit, while the rest numbers of part two are exactly symmetric of part one. It is easy to see its correctness. Code is simple: 123456789101112public class Solution &#123; public List&lt;Integer&gt; grayCode(int n) &#123; List&lt;Integer&gt; rs = new ArrayList&lt;Integer&gt;(); rs.add(0); for(int i=0; i&lt;n; i++)&#123; int size = rs.size(); for(int k=size-1; k&gt;=0; k--) rs.add(rs.get(k) | 1&lt;&lt;i); &#125; return rs; &#125;&#125; cpp 3ms, 38.18%, September 20, 2016 https://discuss.leetcode.com/topic/1011/what-is-the-best-solution-for-gray-code-problem-no-extra-space-used-and-no-recursion What is the best solution for Gray Code problem? No extra space used and no recursion? I have a solution here which takes O(1) on space and no recursion used. Is this the best possible solution? (I combined the base cases in the loop as mike3 does. Thanks mike3!) 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; result(1, 0); for(int i=0; i&lt;n; i++)&#123; int curCount = result.size(); while(curCount)&#123; curCount--; int curNum = result[curCount]; curNum += (1&lt;&lt;i); result.push_back(curNum); &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/3997/share-my-simple-way-of-this-problem-_ Share my simple way of this problem^_^ 12345678910111213class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; int N(1 &lt;&lt; n), tmp; vector&lt;int&gt; result; for(int i(0); i &lt; N; i++) &#123; tmp = i &lt;&lt; 1; result.push_back((tmp^i) &gt;&gt; 1); &#125; return result; &#125;&#125;; As we known: 1Gi = Bi+1 xor Bi For example, trans binay â€˜001â€™ to gray code: 1tmp = 001 &lt;&lt; 1 then, 1234bin 0 0 0 1tmp 0 0 1 0-xor------------ 0 0 1 1 and the gray code is: 10 0 1 1 &gt;&gt; 1 (ignore last bit) =&gt; 0 0 1 https://discuss.leetcode.com/topic/14776/4ms-simple-iterative-solution 4ms simple iterative solution 1234567891011vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; result = &#123; 0 &#125;; int t = 1; for(int i = 0; i&lt;n; i++) &#123; for(int j = result.size() - 1; j &gt;= 0; j--) result.push_back(result[j]^t); t &lt;&lt;= 1; &#125; return result;&#125; python 52ms, September 20, 2016 https://discuss.leetcode.com/topic/4883/one-liner-python-solution-with-demo-in-comments One-liner Python solution (with demo in comments) All you need is a bit of careful thought. Btw, itâ€™s extremely useful to write down your thought/demo in comments before you actually start to write the code, especially during interview. Even if you do not solve the problem finally, the interviewer at least get to know what youâ€™re thinking. And if you donâ€™t get the problem right, he/she will have a chance to correct you. 1234567891011121314151617181920class Solution: # @return a list of integers &apos;&apos;&apos; from up to down, then left to right 0 1 11 110 10 111 101 100 start: [0] i = 0: [0, 1] i = 1: [0, 1, 3, 2] i = 2: [0, 1, 3, 2, 6, 7, 5, 4] &apos;&apos;&apos; def grayCode(self, n): results = [0] for i in range(n): results += [x + pow(2, i) for x in reversed(results)] return results]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[088. Merge Sorted Array]]></title>
    <url>%2Fp%2F505da9dc%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/merge-sorted-array/ Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. æ–¹æ³•ä¸€ï¼š å¸¸è§„è§£æ³•ï¼ŒåŒæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘å°¾éƒ¨ï¼Œä»ŽåŽå‘å‰ï¼Œä¾æ¬¡è¿›è¡Œã€‚ 1234567891011121314151617class Solution &#123;public: void merge(int A[], int m, int B[], int n) &#123; int i=m-1; int j=n-1; int k = m+n-1; while(i &gt;=0 &amp;&amp; j&gt;=0) &#123; if(A[i] &gt; B[j]) A[k--] = A[i--]; else A[k--] = B[j--]; &#125; while(j&gt;=0) A[k--] = B[j--]; &#125;&#125;; æ–¹æ³•äºŒï¼š ç±»ä¼¼äºŽ1ï¼Œä½†æ˜¯è¦æ€è€ƒæ¸…æ¥šå…¶ä¸­çš„é€»è¾‘ã€‚ j&gt;=0æ˜¯å¿…è¦æ¡ä»¶ï¼Œj &lt; 0å°±ä¸è¿›è¡Œå¾ªçŽ¯äº† å¯¹äºŽi&gt;=0ï¼Œå¹¶ä¸”nums1å¤§çš„é€‰æ‹©å®ƒï¼Œå¦åˆ™nums2 123456789class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int i = m - 1, j = n - 1, tar = m + n - 1; while (j &gt;= 0) &#123; nums1[tar--] = i &gt;= 0 &amp;&amp; nums1[i] &gt; nums2[j] ? nums1[i--] : nums2[j--]; &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/2461/this-is-my-ac-code-may-help-you This is my AC code, may help you 1234567891011121314151617class Solution &#123;public: void merge(int A[], int m, int B[], int n) &#123; int i=m-1; int j=n-1; int k = m+n-1; while(i &gt;=0 &amp;&amp; j&gt;=0) &#123; if(A[i] &gt; B[j]) A[k--] = A[i--]; else A[k--] = B[j--]; &#125; while(j&gt;=0) A[k--] = B[j--]; &#125;&#125;; https://discuss.leetcode.com/topic/16946/4ms-c-solution-with-single-loop 4ms C++ solution with single loop This code relies on the simple observation that once all of the numbers from nums2 have been merged into nums1, the rest of the numbers in nums1 that were not moved are already in the correct place. 123456789class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int i = m - 1, j = n - 1, tar = m + n - 1; while (j &gt;= 0) &#123; nums1[tar--] = i &gt;= 0 &amp;&amp; nums1[i] &gt; nums2[j] ? nums1[i--] : nums2[j--]; &#125; &#125;&#125;; 4ms, 10.91%, April.23rd, 2016 12345678910class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int ia = m - 1, ib = n - 1, ic = m + n - 1; while(ia &gt;= 0 &amp;&amp; ib &gt;= 0)&#123; nums1[ic--] = nums1[ia] &gt; nums2[ib] ? nums1[ia--] : nums2[ib--]; &#125; while(ib &gt;= 0) nums1[ic--] = nums2[ib--]; &#125;&#125;; 4ms, 10.91%, April.23rd, 2016 1234567class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; for(int i=m-1, j=n-1, k=m+n-1; j&gt;=0; ) nums1[k--] = i&gt;=0 &amp;&amp; nums1[i]&gt;nums2[j]? nums1[i--]: nums2[j--]; &#125;&#125;; https://discuss.leetcode.com/topic/11508/1-line-solution 1 Line Solution 1while(n&gt;0) A[m+n-1] = (m==0||B[n-1] &gt; A[m-1]) ? B[--n] : A[--m]; https://discuss.leetcode.com/topic/35761/2-lines-very-simple-c-solution 2 lines very simple C++ solution 1234void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; for(int i=m-1, j=n-1, k=m+n-1; j&gt;=0; ) nums1[k--] = i&gt;=0 &amp;&amp; nums1[i]&gt;nums2[j]? nums1[i--]: nums2[j--];&#125; python 52ms, 33.16%, April.23rd, 2016 https://leetcode.com/discuss/47608/beautiful-python-solution Beautiful Python Solution 123456789101112131415161718class Solution(object): def merge(self, nums1, m, nums2, n): &quot;&quot;&quot; :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. &quot;&quot;&quot; while m &gt; 0 and n &gt; 0: if nums1[m-1] &gt;= nums2[n-1]: nums1[m+n-1] = nums1[m-1] m -= 1 else: nums1[m+n-1] = nums2[n-1] n -= 1 if n &gt; 0: nums1[:n] = nums2[:n] java https://discuss.leetcode.com/topic/10257/3-line-java-solution 3 line Java Solution 12345public void merge(int A[], int m, int B[], int n) &#123; int i=m-1, j=n-1, k=m+n-1; while (i&gt;-1 &amp;&amp; j&gt;-1) A[k--]= (A[i]&gt;B[j]) ? A[i--] : B[j--]; while (j&gt;-1) A[k--]=B[j--];&#125; https://discuss.leetcode.com/topic/11919/share-my-accepted-java-solution Share my accepted Java solution! 1234567891011public class Solution &#123; public void merge(int A[], int m, int B[], int n) &#123; int i = m - 1, j = n - 1, k = m + n - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; A[k--] = A[i] &gt; B[j] ? A[i--] : B[j--]; &#125; while(j &gt;= 0) &#123; A[k--] = B[j--]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[087. Scramble String]]></title>
    <url>%2Fp%2Fae9f5ec9%2F</url>
    <content type="text"><![CDATA[29.2% https://leetcode.com/problems/scramble-string/ Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. 123456789Below is one possible representation of s1 = &quot;great&quot;: great / \ gr eat / \ / \g r e at / \ a t To scramble the string, we may choose any non-leaf node and swap its two children. 12345678910For example, if we choose the node &quot;gr&quot; and swap its two children, it produces a scrambled string &quot;rgeat&quot;. rgeat / \ rg eat / \ / \r g e at / \ a tWe say that &quot;rgeat&quot; is a scrambled string of &quot;great&quot;. 12345678910Similarly, if we continue to swap the children of nodes &quot;eat&quot; and &quot;at&quot;, it produces a scrambled string &quot;rgtae&quot;. rgtae / \ rg tae / \ / \r g ta e / \ t aWe say that &quot;rgtae&quot; is a scrambled string of &quot;great&quot;. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. æ–¹æ³•ä¸€ï¼š é€’å½’ï¼Œ æ ¹æ®é¢˜æ„æ¥è¿›è¡Œåˆ¤æ–­ã€‚åˆ¤æ–­æ—¶æŽ’é™¤å­—ç¬¦ä¸ªæ•°éƒ½ä¸ç›¸åŒçš„æƒ…å†µã€‚ ç„¶åŽè€ƒè™‘å„ä¸ªå¶å­èŠ‚ç‚¹çš„äº¤æ¢ã€‚ 3ms, 85.03%, September 22, 2016 https://discuss.leetcode.com/topic/14337/share-my-4ms-c-recursive-solution Share my 4ms c++ recursive solution Assume the strings are all lower case letters 123456789101112131415161718192021222324252627class Solution &#123;public: bool isScramble(string s1, string s2) &#123; if(s1 == s2) return true; int len = s1.length(); int count[26] = &#123;0&#125;; for(int i=0; i&lt;len; i++)&#123; count[s1[i]-&apos;a&apos;]++; count[s2[i]-&apos;a&apos;]--; &#125; for(int i=0; i&lt;26; i++)&#123; if(count[i]!=0) return false; &#125; for(int i=1; i&lt;=len-1; i++)&#123; if(isScramble(s1.substr(0, i), s2.substr(0, i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i))) return true; if(isScramble(s1.substr(0, i), s2.substr(len-i)) &amp;&amp; isScramble((s1.substr(i)), s2.substr(0, len-i))) return true; &#125; return false; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526class Solution &#123;public: bool isScramble(string s1, string s2) &#123; if(s1==s2) return true; int m = s1.size(), n = s2.size(); if(m!=n) return false; vector&lt;int&gt; v(26, 0); for(int i=0; i&lt;m; i++)&#123; v[s1[i]-'a']++; v[s2[i]-'a']--; &#125; // ä¸‹é¢æ˜¯i&lt;26ä¸æ˜¯i&lt;m, ä¸è¦æ‰‹è¯¯ for(int i=0; i&lt;26; i++) if(v[i]!=0) return false; for(int i=1; i&lt;m; i++)&#123; // substr(0, i)ä»Žindex=0å¼€å§‹ï¼Œé¡ºç€iä¸ªï¼ŒåŠ0è‡³i-1ã€‚substr(i)ä»Žindex=içš„å­—ç¬¦ä¸² if(isScramble(s1.substr(0, i), s2.substr(0, i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i))) return true; // ä¸‹é¢æ˜¯m-iï¼Œè¡¨æ˜Žs1çš„å‰iä¸ªä¸Žs2çš„åŽiä¸ªæ˜¯å¦ç›¸ç­‰ if(isScramble(s1.substr(0, i), s2.substr(m-i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(0, m-i))) return true; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/20094/my-c-solutions-recursion-with-cache-dp-recursion-with-cache-and-pruning-with-explanation-4ms My C++ solutions (recursion with cache , DP, recursion with cache and pruning) with explanation (4ms) The basic idea is to divide s1(s2) into two substrings with length k and len-k and check if the two substrings s1[0..k-1] and s1[k, len-1] are the scrambles of s2[0..k-1] and s2[k,len-1] or s2[len-k, len-1] and s2[0..len-k-1] via recursion. The straigtforward recursion will be very slow due to many repeated recursive function calls. To speed up the recursion, we can use an unordered_map isScramblePair to save intermediate results. The key used here is s1+s2, but other keys are also possible (e.g. using indices) 123456789101112131415161718192021222324252627282930class Solution &#123; bool DP_helper(unordered_map&lt;string, bool&gt; &amp;isScramblePair, string s1, string s2) &#123; int i,len = s1.size(); bool res = false; if(0==len) return true; else if(1==len) return s1 == s2; else &#123; if(isScramblePair.count(s1+s2)) return isScramblePair[s1+s2]; // checked before, return intermediate result directly if(s1==s2) res=true; else&#123; for(i=1; i&lt;len &amp;&amp; !res; ++i) &#123;//check s1[0..i-1] with s2[0..i-1] and s1[i..len-1] and s2[i..len-1] res = res || (DP_helper(isScramblePair, s1.substr(0,i), s2.substr(0,i)) &amp;&amp; DP_helper(isScramblePair, s1.substr(i,len-i), s2.substr(i,len-i))); //if no match, then check s1[0..i-1] with s2[len-k.. len-1] and s1[i..len-1] and s2[0..len-i] res = res || (DP_helper(isScramblePair, s1.substr(0,i), s2.substr(len-i,i)) &amp;&amp; DP_helper(isScramblePair, s1.substr(i,len-i), s2.substr(0,len-i))); &#125; &#125; return isScramblePair[s1+s2]= res; //save the intermediate results &#125; &#125; public: bool isScramble(string s1, string s2) &#123; unordered_map&lt;string, bool&gt; isScramblePair; return DP_helper(isScramblePair, s1, s2); &#125; &#125;; The recursive version has exponential complexity. To further improve the performance, we can use bottom-up DP, which is O(N^4) complexity. Here we build a table isS[len][i][j], which indicates whether s1[i..i+len-1] is a scramble of s2[j..j+len-1]. 123456789101112131415161718192021222324252627class Solution &#123;public: bool isScramble(string s1, string s2) &#123; int sSize = s1.size(), len, i, j, k; if(0==sSize) return true; if(1==sSize) return s1==s2; bool isS[sSize+1][sSize][sSize]; for(i=0; i&lt;sSize; ++i) for(j=0; j&lt;sSize; ++j) isS[1][i][j] = s1[i] == s2[j]; for(len=2; len &lt;=sSize; ++len) for(i=0; i&lt;=sSize-len; ++i) for(j=0; j&lt;=sSize-len; ++j) &#123; isS[len][i][j] = false; for(k=1; k&lt;len &amp;&amp; !isS[len][i][j]; ++k) &#123; isS[len][i][j] = isS[len][i][j] || (isS[k][i][j] &amp;&amp; isS[len-k][i+k][j+k]); isS[len][i][j] = isS[len][i][j] || (isS[k][i+len-k][j] &amp;&amp; isS[len-k][i][j+k]); &#125; &#125; return isS[sSize][0][0]; &#125;&#125;; Furhtermore, in many cases, we found we can terminate our recursion early by pruning: i.e. by first checking if s1 and s2 have the same character set before we do recursion: if not, just terminate without recursion. This observation leads us to the following Recursion+cache+pruning version. Here the key of the cache changes to idx1sSize +idx2 + lensSize*sSize; 123456789101112131415161718192021222324252627282930313233class Solution &#123;private: bool DP_helper(string &amp;s1, string &amp;s2, int idx1, int idx2, int len, char isS[]) &#123; int sSize = s1.size(),i, j, k, hist[26] , zero_count =0; if(isS[(len*sSize+idx1)*sSize+idx2]) return isS[(len*sSize+idx1)*sSize+idx2]==1; bool res = false; fill_n(hist, 26, 0); for(k=0; k&lt;len;++k) &#123; // check if s1[idx1:idx1+len-1] and s2[idx2:idx2+len-1] have same characters zero_count += (0==hist[s1[idx1+k]-&apos;a&apos;]) - (0== ++hist[s1[idx1+k]-&apos;a&apos;]); zero_count += (0==hist[s2[idx2+k]-&apos;a&apos;]) - (0== --hist[s2[idx2+k]-&apos;a&apos;]); &#125; if(zero_count) &#123;isS[(len*sSize+idx1)*sSize+idx2] = 2; return false;&#125; //if not, return directly if(len==1) &#123;isS[(len*sSize+idx1)*sSize+idx2] = 1; return true;&#125; for(k=1;k&lt;len &amp;&amp; !res;++k) //otherwise, recursion with cache &#123; res = res || (DP_helper(s1, s2, idx1, idx2, k, isS) &amp;&amp; DP_helper(s1, s2, idx1+k, idx2+k, len-k, isS) ); res = res || (DP_helper(s1, s2, idx1+len-k, idx2, k, isS) &amp;&amp; DP_helper(s1, s2, idx1, idx2+k, len-k, isS) ); &#125; isS[(len*sSize+idx1)*sSize+idx2] = res?1:2; return res; &#125;public: bool isScramble(string s1, string s2) &#123; const int sSize = s1.size(); if(0==sSize) return true; char isS[(sSize+1)*sSize*sSize]; fill_n(isS, (sSize+1)*sSize*sSize, 0); return DP_helper(s1, s2, 0, 0, sSize, isS); &#125;&#125;; https://discuss.leetcode.com/topic/1195/any-better-solution Any better solution? My AC code is as below. I think itâ€™s not very efficient. Is there any better solution? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;private: bool anagram(string &amp;s1, string &amp;s2)&#123; if(s1.size() != s2.size()) return false; unordered_map&lt;char, int&gt; m; int n = s1.size(); for(int i = 0; i &lt; n; ++i)&#123; if(m.find(s1[i]) != m.end())&#123; ++m[s1[i]]; &#125;else&#123; m[s1[i]] = 1; &#125; &#125; for(int i = 0; i &lt; n; ++i)&#123; if(m.find(s2[i]) != m.end())&#123; --m[s2[i]]; if(m[s2[i]] &lt; 0)&#123; return false; &#125; &#125;else&#123; return false; &#125; &#125; return true; &#125;public: bool isScramble(string s1, string s2) &#123; if(s1.size() != s2.size()) return false; if(s1 == s2) return true; int n = s1.size(); for(int i = 1; i &lt; n; ++i)&#123; string s11 = s1.substr(0, i); string s12 = s1.substr(i, n - i); string s21 = s2.substr(0, i); string s22 = s2.substr(i, n - i); string s23 = s2.substr(n - i, i); string s24 = s2.substr(0, n - i); if(anagram(s11, s21) &amp;&amp; anagram(s12, s22) &amp;&amp; isScramble(s11, s21) &amp;&amp; isScramble(s12, s22) || anagram(s11, s23) &amp;&amp; anagram(s12, s24) &amp;&amp; isScramble(s11, s23) &amp;&amp; isScramble(s12, s24))&#123; return true; &#125; &#125; return false; &#125;&#125;; The main idea is: separate s1 into two parts, namely â€“s11â€“, â€”â€”â€“s12â€”â€”â€“ separate s2 into two parts, namely â€“s21â€“, â€”â€”â€“s22â€”â€”â€“, and test the corresponding part (s11 and s21 &amp;&amp; s12 and s22) with isScramble. separate s2 into two parts, namely â€”â€”â€“s23â€”â€”â€“, â€“s24â€“, and test the corresponding part (s11 and s24 &amp;&amp; s12 and s23) with isScramble. Note that before testing each sub-part with isScramble, anagram is used first to test if the corresponding parts are anagrams. If not, skip directly. https://discuss.leetcode.com/topic/8253/a-simple-solution-without-dp-in-c A simple solution without dp in C++ 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isScramble(string s1, string s2) &#123; int n = s1.length(); return judge(s1.c_str(), s2.c_str(), 0, n-1, 0, n-1); &#125; bool judge(const char* s1, const char* s2,int a,int b,int u, int v)&#123; if(b-a!=v-u) return false; if(b-a==0 &amp;&amp; s1[a]==s2[u]) return true; int cnt[256]=&#123;0&#125;; for(int i=a;i&lt;=b;++i)&#123; cnt[s1[i]]++; &#125; for(int i=u;i&lt;=v;++i)&#123; cnt[s2[i]]--; &#125; for(int i=0;i&lt;256;++i)&#123; if(cnt[i]!=0) return false; &#125; for(int i=a;i&lt;b;++i)&#123; if(judge(s1,s2,a,i,u,u+i-a) &amp;&amp; judge(s1,s2,i+1,b,v-(b-i-1),v))&#123; return true; &#125; if(judge(s1,s2,a,i,v-(i-a),v) &amp;&amp; judge(s1,s2,i+1,b,u,u+b-(i+1)))&#123; return true; &#125; &#125; return false; &#125;&#125;; Surprisingly, it runs very fast even without dynamic programming. python https://discuss.leetcode.com/topic/9726/python-recursive-solution Python recursive solution 1234567891011121314class Solution:# @return a booleandef isScramble(self, s1, s2): n, m = len(s1), len(s2) if n != m or sorted(s1) != sorted(s2): return False if n &lt; 4 or s1 == s2: return True f = self.isScramble for i in range(1, n): if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \ f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]): return True return False java 4ms, 91.08%, September 22, 2016 https://discuss.leetcode.com/topic/19158/accepted-java-solution Accepted Java solution 1234567891011121314151617181920public class Solution &#123; public boolean isScramble(String s1, String s2) &#123; if (s1.equals(s2)) return true; int[] letters = new int[26]; for (int i=0; i&lt;s1.length(); i++) &#123; letters[s1.charAt(i)-&apos;a&apos;]++; letters[s2.charAt(i)-&apos;a&apos;]--; &#125; for (int i=0; i&lt;26; i++) if (letters[i]!=0) return false; for (int i=1; i&lt;s1.length(); i++) &#123; if (isScramble(s1.substring(0,i), s2.substring(0,i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) return true; if (isScramble(s1.substring(0,i), s2.substring(s2.length()-i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(0,s2.length()-i))) return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[086. Partition List]]></title>
    <url>%2Fp%2Fdc466425%2F</url>
    <content type="text"><![CDATA[32.7% https://leetcode.com/problems/partition-list/ Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. 123For example,Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. æ–¹æ³•ä¸€ï¼š å»ºç«‹ä¸€ä¸ªå“‘ç»“ç‚¹ï¼Œè¿™æ˜¯è¿™ä¸ªæ–¹æ³•çš„é«˜æ˜Žä¹‹å¤„ã€‚ 6ms, 29.86%, September 20, 2016 https://discuss.leetcode.com/topic/7005/very-concise-one-pass-solution 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; ListNode node1(0), node2(0); ListNode *p1 = &amp;node1, *p2 = &amp;node2; while(head)&#123; if(head-&gt;val &lt; x) p1 = p1-&gt;next = head; else p2 = p2 -&gt;next = head; head = head-&gt;next; &#125; p2-&gt;next = NULL; p1-&gt;next = node2.next; return node1.next; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; ListNode node1(0), node2(0); ListNode* p1 = &amp;node1, *p2 = &amp;node2; while(head)&#123; if(head-&gt;val &lt; x)&#123; p1-&gt;next = head; p1 = p1-&gt;next; &#125;else&#123; p2-&gt;next = head; p2 = p2-&gt;next; &#125; head = head-&gt;next; &#125; p1-&gt;next = node2.next; //æ­¤å¤„ç”¨çš„æ˜¯.,è€Œä¸æ˜¯-&gt;,ä¸ºä»€ä¹ˆï¼Ÿ p2-&gt;next = NULL; return node1.next; // æ­¤å¤„ä¹Ÿæ˜¯.,ä¸æ˜¯-&gt;ï¼Œå› ä¸ºä¸æ˜¯æŒ‡é’ˆï¼Ÿ &#125;&#125;; python 65ms, September 20, 2016 https://discuss.leetcode.com/topic/21417/python-concise-solution-with-dummy-nodes 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def partition(self, head, x): &quot;&quot;&quot; :type head: ListNode :type x: int :rtype: ListNode &quot;&quot;&quot; h1 = l1 = ListNode(0) h2 = l2 = ListNode(0) while head: if head.val &lt; x: l1.next = head l1 = l1.next else: l2.next = head l2 = l2.next head = head.next l2.next = None l1.next = h2.next return h1.next java 1ms, 4.45%, September 20, 2016 https://discuss.leetcode.com/topic/7795/concise-java-code-with-explanation-one-pass 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode partition(ListNode head, int x) &#123; ListNode dummy1 = new ListNode(0), dummy2 = new ListNode(0); ListNode curr1 = dummy1, curr2 = dummy2; while(head!=null)&#123; if(head.val&lt;x)&#123; curr1.next = head; curr1 = head; &#125;else&#123; curr2.next = head; curr2 = head; &#125; head = head.next; &#125; curr2.next = null; curr1.next = dummy2.next; return dummy1.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[085. Maximal Rectangle]]></title>
    <url>%2Fp%2Fba45e9ed%2F</url>
    <content type="text"><![CDATA[26.6% https://leetcode.com/problems/maximal-rectangle/ Given a 2D binary matrix filled with 0â€™s and 1â€™s, find the largest rectangle containing only 1â€™s and return its area. 1234567For example, given the following matrix:1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Return 6. æ–¹æ³•ä¸€: 9ms, 93.96%, September 23, 2016 https://discuss.leetcode.com/topic/6650/share-my-dp-solution Share my DP solution The DP solution proceeds row by row, starting from the first row. Let the maximal rectangle area at row i and column j be computed by [right(i,j) - left(i,j)]*height(i,j). All the 3 variables left, right, and height can be determined by the information from previous row, and also information from the current row. So it can be regarded as a DP solution. The transition equations are: 1234left(i,j) = max(left(i-1,j), cur_left), cur_left can be determined from the current rowright(i,j) = min(right(i-1,j), cur_right), cur_right can be determined from the current rowheight(i,j) = height(i-1,j) + 1, if matrix[i][j]==&apos;1&apos;;height(i,j) = 0, if matrix[i][j]==&apos;0&apos; The code is as below. The loops can be combined for speed but I separate them for more clarity of the algorithm. 123456789101112131415161718192021222324252627282930class Solution &#123;public:int maximalRectangle(vector&lt;vector&lt;char&gt; &gt; &amp;matrix) &#123; if(matrix.empty()) return 0; const int m = matrix.size(); const int n = matrix[0].size(); int left[n], right[n], height[n]; fill_n(left,n,0); fill_n(right,n,n); fill_n(height,n,0); int maxA = 0; for(int i=0; i&lt;m; i++) &#123; int cur_left=0, cur_right=n; for(int j=0; j&lt;n; j++) &#123; // compute height (can do this from either side) if(matrix[i][j]==&apos;1&apos;) height[j]++; else height[j]=0; &#125; for(int j=0; j&lt;n; j++) &#123; // compute left (from left to right) if(matrix[i][j]==&apos;1&apos;) left[j]=max(left[j],cur_left); else &#123;left[j]=0; cur_left=j+1;&#125; &#125; // compute right (from right to left) for(int j=n-1; j&gt;=0; j--) &#123; if(matrix[i][j]==&apos;1&apos;) right[j]=min(right[j],cur_right); else &#123;right[j]=n; cur_right=j;&#125; &#125; // compute the area of rectangle (can do this from either side) for(int j=0; j&lt;n; j++) maxA = max(maxA,(right[j]-left[j])*height[j]); &#125; return maxA;&#125;&#125;; If you think this algorithm is not easy to understand, you can try this example: 1230 0 0 1 0 0 0 0 0 1 1 1 0 0 0 1 1 1 1 1 0 The vector â€œleftâ€ and â€œrightâ€ from row 0 to row 2 are as follows row 0: 12l: 0 0 0 3 0 0 0r: 7 7 7 4 7 7 7 row 1: 12l: 0 0 2 3 2 0 0r: 7 7 5 4 5 7 7 row 2: 12l: 0 1 2 3 2 1 0r: 7 6 5 4 5 6 7 The vector â€œleftâ€ is computing the left boundary. Take (i,j)=(1,3) for example. On current row 1, the left boundary is at j=2. However, because matrix[1][3] is 1, you need to consider the left boundary on previous row as well, which is 3. So the real left boundary at (1,3) is 3. I hope this additional explanation makes things clearer. https://discuss.leetcode.com/topic/5806/sharing-my-straightforward-c-solution-with-o-n-2-time-with-explanation Sharing my straightforward C++ solution with O(n^2) time with explanation 12345678910111213141516171819202122232425262728293031323334353637int maximalRectangle(vector&lt;vector&lt;char&gt; &gt; &amp;matrix) &#123; if(matrix.empty())&#123; return 0; &#125; int maxRec = 0; vector&lt;int&gt; height(matrix[0].size(), 0); for(int i = 0; i &lt; matrix.size(); i++)&#123; for(int j = 0; j &lt; matrix[0].size(); j++)&#123; if(matrix[i][j] == &apos;0&apos;)&#123; height[j] = 0; &#125; else&#123; height[j]++; &#125; &#125; maxRec = max(maxRec, largestRectangleArea(height)); &#125; return maxRec;&#125;int largestRectangleArea(vector&lt;int&gt; &amp;height) &#123; stack&lt;int&gt; s; height.push_back(0); int maxSize = 0; for(int i = 0; i &lt; height.size(); i++)&#123; if(s.empty() || height[i] &gt;= height[s.top()])&#123; s.push(i); &#125; else&#123; int temp = height[s.top()]; s.pop(); maxSize = max(maxSize, temp * (s.empty() ? i : i - 1 - s.top())); i--; &#125; &#125; return maxSize;&#125; In order to solve this problem, I use the solution from â€œLargest Rectangle in Histogramâ€. Now I assume you already know how to solve â€œLargest Rectangle in Histogramâ€. We can regard a matrix as many histograms. For example, given a matrix below: 1 0 1 0 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 1 From top to bottom, we can find these histograms: Number 1: 1 0 1 0 Number 2: 0 1 0 1 Number 3: 0 2 1 0 Number 4: 1 0 2 0 Number 5: 2 0 3 1 Pass all of these histograms to the function which can solve â€œLargest Rectangle in Histogramâ€. And then find the maximum one. Finally, we get the answer. https://discuss.leetcode.com/topic/1122/my-o-n-3-solution-for-your-reference My O(n^3) solution for your reference 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int maximalRectangle(vector&lt;vector&lt;char&gt; &gt; &amp;matrix) &#123; int num_i=matrix.size(); if (num_i==0) return 0; int num_j=matrix[0].size(); if (num_j==0) return 0; vector&lt;vector&lt;int&gt;&gt; max_x(num_i,vector&lt;int&gt;(num_j,0)); //number of consecutive 1s to the left of matrix[i][j], including itself int area=0; for (int i=0;i&lt;num_i;i++)&#123; for (int j=0;j&lt;num_j;j++)&#123; if (matrix[i][j]==&apos;1&apos;)&#123; if (j==0) max_x[i][j]=1; else max_x[i][j]=max_x[i][j-1]+1; int y=1; int x=num_j; while((i-y+1&gt;=0)&amp;&amp;(matrix[i-y+1][j]==&apos;1&apos;))&#123; x=min(x, max_x[i-y+1][j]); area=max(area,x*y); y++; &#125; &#125; &#125; &#125; return area; &#125;&#125;; python https://discuss.leetcode.com/topic/27844/ac-python-dp-solutioin-120ms-based-on-largest-rectangle-in-histogram AC Python DP solutioin 120ms based on largest rectangle in histogram 12345678910111213141516171819202122def maximalRectangle(self, matrix): if not matrix or not matrix[0]: return 0 n = len(matrix[0]) height = [0] * (n + 1) ans = 0 for row in matrix: for i in xrange(n): height[i] = height[i] + 1 if row[i] == &apos;1&apos; else 0 stack = [-1] for i in xrange(n + 1): while height[i] &lt; height[stack[-1]]: h = height[stack.pop()] w = i - 1 - stack[-1] ans = max(ans, h * w) stack.append(i) return ans# 65 / 65 test cases passed.# Status: Accepted# Runtime: 120 ms# 100% The solution is based on largest rectangle in histogram solution. Every row in the matrix is viewed as the ground with some buildings on it. The building height is the count of consecutive 1s from that row to above rows. The rest is then the same as this solution for largest rectangle in histogram java https://discuss.leetcode.com/topic/1634/a-o-n-2-solution-based-on-largest-rectangle-in-histogram A O(n^2) solution based on Largest Rectangle in Histogram This question is similar as [Largest Rectangle in Histogram]: You can maintain a row length of Integer array H recorded its height of â€˜1â€™s, and scan and update row by row to find out the largest rectangle of each row. For each row, if matrix[row][i] == â€˜1â€™. H[i] +=1, or reset the H[i] to zero.and accroding the algorithm of [Largest Rectangle in Histogram], to update the maximum area. 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int maximalRectangle(char[][] matrix) &#123; if (matrix==null||matrix.length==0||matrix[0].length==0) return 0; int cLen = matrix[0].length; // column length int rLen = matrix.length; // row length // height array int[] h = new int[cLen+1]; h[cLen]=0; int max = 0; for (int row=0;row&lt;rLen;row++) &#123; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); for (int i=0;i&lt;cLen+1;i++) &#123; if (i&lt;cLen) if(matrix[row][i]==&apos;1&apos;) h[i]+=1; else h[i]=0; if (s.isEmpty()||h[s.peek()]&lt;=h[i]) s.push(i); else &#123; while(!s.isEmpty()&amp;&amp;h[i]&lt;h[s.peek()])&#123; int top = s.pop(); int area = h[top]*(s.isEmpty()?i:(i-s.peek()-1)); if (area&gt;max) max = area; &#125; s.push(i); &#125; &#125; &#125; return max; &#125;&#125; https://discuss.leetcode.com/topic/21772/my-java-solution-based-on-maximum-rectangle-in-histogram-with-explanation My java solution based on Maximum Rectangle in Histogram with explanation We can apply the maximum in histogram in each row of the 2D matrix. What we need is to maintain an int array for each row, which represent for the height of the histogram. Please refer to https://leetcode.com/problems/largest-rectangle-in-histogram/ first. Suppose there is a 2D matrix like 1 1 0 1 0 1 0 1 0 0 1 1 1 1 1 1 0 1 1 1 1 1 0 1 First initiate the height array as 1 1 0 1 0 1, which is just a copy of the first row. Then we can easily calculate the max area is 2. Then update the array. We scan the second row, when the matrix[1][i] is 0, set the height[i] to 0; else height[i] += 1, which means the height has increased by 1. So the height array again becomes 0 2 0 0 1 2. The max area now is also 2. Apply the same method until we scan the whole matrix. the last height arrays is 2 4 2 2 0 2, so the max area has been found as 2 * 4 = 8. Then reason we scan the whole matrix is that the maximum value may appear in any row of the height. Code as follows: 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123;public int maximalRectangle(char[][] matrix) &#123; if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0; int[] height = new int[matrix[0].length]; for(int i = 0; i &lt; matrix[0].length; i ++)&#123; if(matrix[0][i] == &apos;1&apos;) height[i] = 1; &#125; int result = largestInLine(height); for(int i = 1; i &lt; matrix.length; i ++)&#123; resetHeight(matrix, height, i); result = Math.max(result, largestInLine(height)); &#125; return result;&#125;private void resetHeight(char[][] matrix, int[] height, int idx)&#123; for(int i = 0; i &lt; matrix[0].length; i ++)&#123; if(matrix[idx][i] == &apos;1&apos;) height[i] += 1; else height[i] = 0; &#125;&#125; public int largestInLine(int[] height) &#123; if(height == null || height.length == 0) return 0; int len = height.length; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int maxArea = 0; for(int i = 0; i &lt;= len; i++)&#123; int h = (i == len ? 0 : height[i]); if(s.isEmpty() || h &gt;= height[s.peek()])&#123; s.push(i); &#125;else&#123; int tp = s.pop(); maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - 1 - s.peek())); i--; &#125; &#125; return maxArea;&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[084. Largest Rectangle in Histogram]]></title>
    <url>%2Fp%2F4e21238e%2F</url>
    <content type="text"><![CDATA[26.6% https://leetcode.com/problems/largest-rectangle-in-histogram/ Given n non-negative integers representing the histogramâ€™s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. 123For example,Given heights = [2,1,5,6,2,3],return 10. æ–¹æ³•ä¸€: æ•ˆçŽ‡o(nlogn) æˆ‘çš„ä»£ç å®žçŽ°: 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int n = heights.size(); if(n==0) return 0; return largestArea(heights, 0, n-1); &#125; int largestArea(vector&lt;int&gt;&amp; heights, int start, int end)&#123; if(start == end) return heights[start]; int mid = start + (end-start)/2; int leftArea = largestArea(heights, start, mid); //è¿™é‡Œå¿…é¡»æ˜¯mid+1 ä¸èƒ½æ˜¯midï¼Œå¦åˆ™ä¸èƒ½ac // æƒ³ä¸€æƒ³ end = left + 1, å·¦è¾¹æ˜¯(left, left)ï¼Œ å³è¾¹æ˜¯(left, left+1) // å³è¾¹æ°¸è¿œæ— æ³•ç»“æŸ // è¿™ä¸ªåˆ†æ²»æ³•çš„é€»è¾‘åœ¨äºŽæ°›å›´ä¸¤éƒ¨åˆ†ï¼Œå·¦éƒ¨åˆ†ï¼Œå³éƒ¨åˆ†ï¼Œç©¿è¶Šä¸­é—´çš„éƒ¨åˆ† int rightArea = largestArea(heights, mid+1, end); int midArea = helper(heights, start, mid, end); return max(midArea, max(leftArea, rightArea)); &#125; int helper(vector&lt;int&gt;&amp; heights, int start, int mid, int end)&#123; int res = 0; int l = mid, r = mid+1, height = min(heights[l], heights[r]); while(l&gt;=start &amp;&amp; r&lt;=end)&#123; height = min(height, min(heights[l], heights[r])); res = max(res, height*(r-l+1)); if(l==start) r++; else if(r==end) l--; else&#123; if(heights[l-1]&gt;heights[r+1])&#123; l--; &#125;else&#123; r++; &#125; &#125; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/7491/simple-divide-and-conquer-ac-solution-without-segment-tree Simple Divide and Conquer AC solution without Segment Tree The idea is simple: for a given range of bars, the maximum area can either from left or right half of the bars, or from the area containing the middle two bars. For the last condition, expanding from the middle two bars to find a maximum area is O(n), which makes a typical Divide and Conquer solution with T(n) = 2T(n/2) + O(n). Thus the overall complexity is O(nlgn) for time and O(1) for space (or O(lgn) considering stack usage). Following is the code accepted with 44ms. I posted this because I didnâ€™t find a similar solution, but only the RMQ idea which seemed less straightforward to me. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; int maxCombineArea(const vector&lt;int&gt; &amp;height, int s, int m, int e) &#123; // Expand from the middle to find the max area containing height[m] and height[m+1] int i = m, j = m+1; int area = 0, h = min(height[i], height[j]); while(i &gt;= s &amp;&amp; j &lt;= e) &#123; h = min(h, min(height[i], height[j])); area = max(area, (j-i+1) * h); if (i == s) &#123; ++j; &#125; else if (j == e) &#123; --i; &#125; else &#123; // if both sides have not reached the boundary, // compare the outer bars and expand towards the bigger side if (height[i-1] &gt; height[j+1]) &#123; --i; &#125; else &#123; ++j; &#125; &#125; &#125; return area; &#125; int maxArea(const vector&lt;int&gt; &amp;height, int s, int e) &#123; // if the range only contains one bar, return its height as area if (s == e) &#123; return height[s]; &#125; // otherwise, divide &amp; conquer, the max area must be among the following 3 values int m = s + (e-s)/2; // 1 - max area from left half int area = maxArea(height, s, m); // 2 - max area from right half area = max(area, maxArea(height, m+1, e)); // 3 - max area across the middle area = max(area, maxCombineArea(height, s, m, e)); return area; &#125;public: int largestRectangleArea(vector&lt;int&gt; &amp;height) &#123; if (height.empty()) &#123; return 0; &#125; return maxArea(height, 0, height.size()-1); &#125;&#125;; æ–¹æ³•äºŒï¼š æ•ˆçŽ‡oï¼ˆnï¼‰ ä½¿ç”¨æ ˆä¿å­˜indexï¼Œä¿å­˜æ¯”iå°ï¼Œä½†é«˜åº¦æ¯”ID æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; // å­¦ä¹ é’ˆå¯¹æŸäº›åŽŸå§‹è¾“å…¥è¿›è¡Œä¸€å®šçš„æ›´æ”¹ï¼Œæ¯”å¦‚åŽé¢åŠ å…¥0 heights.push_back(0); int res = 0; int height = 0; stack&lt;int&gt; stack; for(int i=0; i&lt;heights.size(); i++)&#123; // stackçš„topå‡½æ•°, è¿˜æœ‰vectorçš„backå‡½æ•° // stackæœ‰topå‡½æ•°ï¼Œæ²¡æœ‰backå‡½æ•° while(stack.size() &amp;&amp; heights[stack.top()] &gt; heights[i])&#123; height = heights[stack.top()]; stack.pop(); int idx = stack.size() ? stack.top() : -1; res = max(res, (i-idx-1)*height); &#125; stack.push(i); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/3913/my-concise-c-solution-ac-90-ms My concise C++ solution, AC 90 ms I push a sentinel node back into the end of height to make the code logic more concise. 12345678910111213141516171819202122232425class Solution &#123; public: int largestRectangleArea(vector&lt;int&gt; &amp;height) &#123; int ret = 0; height.push_back(0); vector&lt;int&gt; index; for(int i = 0; i &lt; height.size(); i++) &#123; while(index.size() &gt; 0 &amp;&amp; height[index.back()] &gt;= height[i]) &#123; int h = height[index.back()]; index.pop_back(); int sidx = index.size() &gt; 0 ? index.back() : -1; if(h * (i-sidx-1) &gt; ret) ret = h * (i-sidx-1); &#125; index.push_back(i); &#125; return ret; &#125; &#125;; https://discuss.leetcode.com/topic/14406/my-concise-code-20ms-stack-based-o-n-one-trick-used My concise code (20ms, stack based, O(n)), one trick used The idea is simple, use a stack to save the index of each vector entry in a ascending order; once the current entry is smaller than the one with the index s.top(), then that means the rectangle with the height height[s.top()] ends at the current position, so calculate its area and update the maximum.The only trick I use to avoid checking whether the stack is empty (due to pop) and also avoiding emptying the stack at the end (i.e. after going through the vector, s is not empty and we have to consider those in the stack) is to put a dummy â€œ0â€ at the beginning of vector â€œheightâ€ and the end of â€œheightâ€: the first one makes sure the stack will never be empty (since all the height entries are &gt;=0) and the last one will flush all the remaining non-zero entries of the stack at the end of â€œforâ€ iteration. This trick helps us keep the code concise. 1234567891011121314151617181920212223class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; height) &#123; height.insert(height.begin(),0); // dummy &quot;0&quot; added to make sure stack s will never be empty height.push_back(0); // dummy &quot;0&quot; added to clear the stack at the end int len = height.size(); int i, res = 0, idx; stack&lt;int&gt; s; // stack to save &quot;height&quot; index s.push(0); // index to the first dummy &quot;0&quot; for(i=1;i&lt;len;i++) &#123; while(height[i]&lt;height[idx = s.top()]) // if the current entry is out of order &#123; s.pop(); res = max(res, height[idx] * (i-s.top()-1) ); // note how the width is calculated, use the previous index entry &#125; s.push(i); &#125; height.erase(height.begin()); // remove two dummy &quot;0&quot; height.pop_back(); return res; &#125;&#125;; python 92ms, 71.82%, June.24th, 2016 https://leetcode.com/discuss/65647/ac-python-clean-solution-using-stack-76ms AC Python clean solution using stack 76ms 12345678910111213141516171819def largestRectangleArea(self, height): height.append(0) stack = [-1] ans = 0 for i in xrange(len(height)): while height[i] &lt; height[stack[-1]]: h = height[stack.pop()] w = i - stack[-1] - 1 ans = max(ans, h * w) stack.append(i) height.pop() return ans# 94 / 94 test cases passed.# Status: Accepted# Runtime: 76 ms# 97.34% The stack maintain the indexes of buildings with ascending height. Before adding a new building pop the building who is taller than the new one. The building popped out represent the height of a rectangle with the new building as the right boundary and the current stack top as the left boundary. Calculate its area and update ans of maximum area. Boundary is handled using dummy buildings. java https://discuss.leetcode.com/topic/7599/o-n-stack-based-java-solution O(n) stack based JAVA solution For explanation, please see http://www.geeksforgeeks.org/largest-rectangle-under-histogram/ 123456789101112131415161718public class Solution &#123; public int largestRectangleArea(int[] height) &#123; int len = height.length; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int maxArea = 0; for(int i = 0; i &lt;= len; i++)&#123; int h = (i == len ? 0 : height[i]); if(s.isEmpty() || h &gt;= height[s.peek()])&#123; s.push(i); &#125;else&#123; int tp = s.pop(); maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - 1 - s.peek())); i--; &#125; &#125; return maxArea; &#125;&#125; https://discuss.leetcode.com/topic/2424/my-modified-answer-from-geeksforgeeks-in-java My modified answer from GeeksforGeeks, in JAVA I was stuck and took an eye on Geeks4Geeks. I got the idea and tried to figure it out by myselfâ€¦It takes me a lot of time to make it throughâ€¦. EDITED: Now it is pretty conciseâ€¦. 1234567891011121314151617181920212223242526public class Solution &#123;public int largestRectangleArea(int[] height) &#123; if (height==null) return 0;//Should throw exception if (height.length==0) return 0; Stack&lt;Integer&gt; index= new Stack&lt;Integer&gt;(); index.push(-1); int max=0; for (int i=0;i&lt;height.length;i++)&#123; //Start calculate the max value while (index.peek()&gt;-1) if (height[index.peek()]&gt;height[i])&#123; int top=index.pop(); max=Math.max(max,height[top]*(i-1-index.peek())); &#125;else break; index.push(i); &#125; while(index.peek()!=-1)&#123; int top=index.pop(); max=Math.max(max,height[top]*(height.length-1-index.peek())); &#125; return max;&#125;&#125; https://discuss.leetcode.com/topic/39151/5ms-o-n-java-solution-explained-beats-96 5ms O(n) Java solution explained (beats 96%) For any bar i the maximum rectangle is of width r - l - 1 where r - is the last coordinate of the bar to the right with height h[r] &gt;= h[i] and l - is the last coordinate of the bar to the left which height h[l] &gt;= h[i] So if for any i coordinate we know his utmost higher (or of the same height) neighbors to the right and to the left, we can easily find the largest rectangle: 1234int maxArea = 0;for (int i = 0; i &lt; height.length; i++) &#123; maxArea = Math.max(maxArea, height[i] * (lessFromRight[i] - lessFromLeft[i] - 1));&#125; The main trick is how to effectively calculate lessFromRight and lessFromLeft arrays. The trivial solution is to use O(n^2) solution and for each i element first find his left/right heighbour in the second inner loop just iterating back or forward: 123456789101112for (int i = 1; i &lt; height.length; i++) &#123; if (height[i] &gt; height[i - 1]) &#123; lessFromLeft[i] = i - 1; &#125; else &#123; int p = i - 1; while (p &gt;= 0 &amp;&amp; height[p] &gt;= height[i]) &#123; p--; &#125; lessFromLeft[i] = p; &#125; &#125; The only line change shifts this algorithm from O(n^2) to O(n) complexity: we donâ€™t need to rescan each item to the left - we can reuse results of previous calculations and â€œjumpâ€ through indices in quick manner: 123while (p &gt;= 0 &amp;&amp; height[p] &gt;= height[i]) &#123; p = lessFromLeft[p];&#125; Here is the whole solution: 12345678910111213141516171819202122232425262728293031323334353637public int largestRectangleArea(int[] height) &#123; if (height == null || height.length == 0) &#123; return 0; &#125; int[] lessFromLeft = new int[height.length]; // idx of the first bar the left that is lower than current int[] lessFromRight = new int[height.length]; // idx of the first bar the right that is lower than current lessFromRight[height.length - 1] = height.length; lessFromLeft[0] = -1; for (int i = 1; i &lt; height.length; i++) &#123; if (height[i] &gt; height[i - 1]) &#123; lessFromLeft[i] = i - 1; &#125; else &#123; int p = i - 1; while (p &gt;= 0 &amp;&amp; height[p] &gt;= height[i]) p = lessFromLeft[p]; lessFromLeft[i] = p; &#125; &#125; for (int i = height.length - 2; i &gt;= 0; i--) &#123; if (height[i] &gt; height[i + 1]) &#123; lessFromRight[i] = i + 1; &#125; else &#123; int p = i + 1; while (p &lt; height.length &amp;&amp; height[p] &gt;= height[i]) p = lessFromRight[p]; lessFromRight[i] = p; &#125; &#125; int maxArea = 0; for (int i = 0; i &lt; height.length; i++) &#123; maxArea = Math.max(maxArea, height[i] * (lessFromRight[i] - lessFromLeft[i] - 1)); &#125; return maxArea;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hard</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[083. Remove Duplicates from Sorted List]]></title>
    <url>%2Fp%2Ff95633fb%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/remove-duplicates-from-sorted-list/ Given a sorted linked list, delete all duplicates such that each element appear only once. 123For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. æ–¹æ³•ä¸€ï¼š å¯ç¤ºï¼Œåªè¦æ¯”è¾ƒè·Ÿå‰é¢çš„æ¯”è¾ƒã€‚ æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* slow = head, *fast = head-&gt;next; // è¦æ±‚slow &amp;&amp; slow-&gt;next ä¸æ˜¯slow-&gt;next // è€ƒè™‘é—®é¢˜è¦å…¨é¢ while(slow &amp;&amp; slow-&gt;next)&#123; fast = slow-&gt;next; while(fast &amp;&amp; slow-&gt;val == fast-&gt;val) fast = fast-&gt;next; // æ­¤å¤„æ˜¯fast ä¸æ˜¯fast-&gt;next // å› ä¸ºfastæŒ‡å‘çš„æ˜¯æœ€åŽä¸€ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä½ï¼Œè€Œä¸æ˜¯æœ€åŽä¸€ä¸ªå…ƒç´ äº† // æ³¨æ„åŒºåˆ† slow-&gt;next = fast; slow = slow-&gt;next; &#125; return head; &#125;&#125;; 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* cur = head; while(cur!=NULL)&#123; ListNode* nex = cur-&gt;next; while(nex!=NULL &amp;&amp; nex-&gt;val==cur-&gt;val) nex = nex-&gt;next; cur-&gt;next = nex; cur = nex; &#125; return dummy-&gt;next; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode *cur = head; while(cur)&#123; while(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) cur-&gt;next = cur-&gt;next-&gt;next; cur = cur-&gt;next; &#125; return head; &#125;&#125;; 12ms, 80.53%, July 14th, 2016 https://discuss.leetcode.com/topic/2168/concise-solution-and-memory-freeing1234567891011121314151617181920/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode * cur = head; while(cur)&#123; while(cur-&gt;next &amp;&amp; cur-&gt;val == cur -&gt; next -&gt;val) cur -&gt;next = cur -&gt;next-&gt;next; cur = cur-&gt;next; &#125; return head; &#125;&#125;; python java 1ms, 17.66%, July 14th, 2016 https://discuss.leetcode.com/topic/14775/3-line-java-recursive-solution/2 123456789101112131415/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); return head.val == head.next.val ? head.next : head; &#125;&#125; 2ms, 5.53%, July 14th, 2016 https://discuss.leetcode.com/topic/8345/my-pretty-solution-java 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode list = head; while(list != null)&#123; if(list.next == null) break; if(list.val == list.next.val) list.next = list.next.next; else list = list.next; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[082. Remove Duplicates from Sorted List II]]></title>
    <url>%2Fp%2F89010df4%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/ Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. 123For example,Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. æ–¹æ³•ä¸€ï¼š 8ms, 57.12%, July 14th, 2016 https://discuss.leetcode.com/topic/12892/simple-and-clear-c-recursive-solution/2 é€’å½’æ³• 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head) return 0; if(!head-&gt;next) return head; int val = head-&gt;val; ListNode * p = head -&gt;next; if(p-&gt;val != val)&#123; head-&gt;next = deleteDuplicates(p); return head; &#125;else&#123; while(p &amp;&amp; p-&gt;val == val) p = p-&gt;next; return deleteDuplicates(p); &#125; &#125;&#125;; æ–¹æ³•äºŒï¼š ä½¿ç”¨è¿­ä»£çš„æ–¹æ³• æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* slow = dummy, *fast; // è¦ä¿è¯slowå’Œslow-&gt;next while(slow &amp;&amp; slow-&gt;next)&#123; fast = slow-&gt;next; while(fast-&gt;next &amp;&amp; slow-&gt;next-&gt;val == fast-&gt;next-&gt;val) fast = fast-&gt;next; if(fast!=slow-&gt;next) slow-&gt;next = fast-&gt;next; else slow = slow-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* cur = dummy; while(cur-&gt;next)&#123; ListNode* nex = cur-&gt;next; while(nex-&gt;next!=NULL &amp;&amp; nex-&gt;next-&gt;val == nex-&gt;val) nex = nex-&gt;next; if(cur-&gt;next!=nex) cur-&gt;next = nex-&gt;next; else cur = cur-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; python 72ms, 44.80%, July 14th, 2016 https://discuss.leetcode.com/topic/21369/python-in-place-solution-with-dummy-head-node/2 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteDuplicates(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; dummy = pre = ListNode(0) dummy.next = head while head and head.next: if head.val == head.next.val: while head and head.next and head.val == head.next.val: head = head.next head = head.next pre.next = head else: pre = pre.next head = head.next return dummy.next java ä¸€ä¸ªpreæŒ‡é’ˆï¼Œä¸€ä¸ªcuræŒ‡é’ˆï¼Œæ¯æ¬¡curæŒ‡é’ˆåˆ¤æ–­æ˜¯å¦éœ€è¦å³ç§»ï¼Œå¦‚æžœæ²¡æœ‰ç§»åŠ¨çš„è¯ï¼Œpreå°±å‘åŽç§»åŠ¨ï¼Œå¦‚æžœç§»åŠ¨çš„è¯ï¼Œå»ºç«‹preä¸Žcur.nextçš„å…³ç³»ã€‚curè´Ÿè´£å½“å‰ä½ç½®ï¼Œpreè´Ÿè´£å‰ä¸€ä¸ªä½ç½®ï¼Œæ¯æ¬¡å¾ªçŽ¯ï¼Œè´Ÿè´£æ‰¾å‡ºpreçš„nextçš„ä½ç½®ã€‚ https://discuss.leetcode.com/topic/3890/my-accepted-java-code 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head==null) return head; ListNode FakeHead = new ListNode(0); FakeHead.next = head; ListNode pre = FakeHead; ListNode cur = head; while(cur != null)&#123; while(cur.next != null &amp;&amp; cur.val == cur.next.val) cur = cur.next; if(pre.next == cur) pre = pre.next; else pre.next = cur.next; cur = cur.next; &#125; return FakeHead.next; &#125;&#125; ä½¿ç”¨è¿­ä»£çš„æ–¹æ³• if current node is not unique, return deleteDuplicates with head.next. If current node is unique, link it to the result of next list made by recursive call. https://discuss.leetcode.com/topic/5206/my-recursive-java-solution 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head == null) return null; if(head.next != null &amp;&amp; head.next.val == head.val)&#123; while(head.next!=null &amp;&amp; head.val == head.next.val) head = head.next; return deleteDuplicates(head.next); &#125;else head.next = deleteDuplicates(head.next); return head; &#125;&#125; 1ms, 20.48%, July 14th, 2016 https://discuss.leetcode.com/topic/5206/my-recursive-java-solution 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head == null) return null; if(head.next != null &amp;&amp; head.val == head.next.val)&#123; while(head.next != null &amp;&amp; head.val == head.next.val) head = head.next; return deleteDuplicates(head.next); &#125; else head.next = deleteDuplicates(head.next); return head; &#125;&#125; 1ms, 20.48%, July 14th, 2016 https://discuss.leetcode.com/topic/3890/my-accepted-java-code/2 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head==null) return null; ListNode FakeHead=new ListNode(0); FakeHead.next=head; ListNode pre=FakeHead; ListNode cur=head; while(cur!=null)&#123; while(cur.next!=null&amp;&amp;cur.val==cur.next.val)&#123; cur=cur.next; &#125; if(pre.next==cur)&#123; pre=pre.next; &#125; else&#123; pre.next=cur.next; &#125; cur=cur.next; &#125; return FakeHead.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[081. Search in Rotated Sorted Array II]]></title>
    <url>%2Fp%2Faabfef19%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/search-in-rotated-sorted-array-ii/ Follow up for â€œSearch in Rotated Sorted Arrayâ€: What if duplicates are allowed? Would this affect the run-time complexity? How and why? Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. 1(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Write a function to determine if a given target is in the array. The array may contain duplicates. https://discuss.leetcode.com/topic/23382/medium-level-question-is-follow-up-for-a-hard-level-question Medium level question is follow up for a hard level question? It says this problem is a follow up for Search in Rotated Sorted Array. Search in Rotated Sorted Array is a hard level question. It is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions. If this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around. æ–¹æ³•ä¸€ï¼š äºŒåˆ†æŸ¥æ‰¾ é¢è¯•å¥‡è™Ž360æ›¾é‡åˆ°è¿‡ beats 12.39% of cppsubmissions æˆ‘çš„ä»£ç å®žçŽ°ï¼š å¯¹äºŽé‡å¤çš„ï¼Œè¿™ç§æ˜¯left++æ¥å®žçŽ°ã€‚ 1234567891011121314151617181920212223242526class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if(n==0) return false; int left = 0, right = n-1; while(left&lt;=right)&#123; int mid = left + (right-left)/2; if(nums[mid]==target) return true; if(nums[left]&lt;nums[mid])&#123; if(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid]) right = mid-1; else left = mid+1; &#125;else if(nums[left]&gt;nums[mid])&#123; if(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right]) left = mid+1; else right = mid-1; &#125;else left++; &#125; return false; &#125;&#125;; æœ‰å€Ÿé‰´å‰‘æŒ‡offer 8çš„è§£æ³•ï¼Œå¯¹äºŽleft mid rightä¸‰è€…ç›¸ç­‰çš„æƒ…å†µï¼Œ æ— æ³•åˆ¤æ–­ï¼Œåªèƒ½é¡ºåºæŸ¥æ‰¾ï¼Œæ‰€ä»¥å•ç‹¬é¡ºåºæŸ¥æ‰¾ã€‚ å…¶ä»–æƒ…å†µè¿˜æ˜¯äºŒåˆ†æŸ¥æ‰¾ã€‚ 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if(n==0) return false; int left = 0, right = n-1; while(left&lt;=right)&#123; int mid = left + (right-left)/2; if(nums[mid]==target) return true; if(nums[left]==nums[mid] &amp;&amp; nums[left]==nums[right])&#123; // åªèƒ½çº¿æ€§æŸ¥æ‰¾æƒ…å†µ return inorder_search(nums, left+1, right-1, target); &#125; if(nums[left]&lt;=nums[mid])&#123; if(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid]) right = mid-1; else left = mid+1; &#125;else if(nums[left]&gt;nums[mid])&#123; if(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right]) left = mid+1; else right = mid-1; &#125; &#125; return false; &#125; bool inorder_search(vector&lt;int&gt;&amp; nums, int left, int right, int target)&#123; if(left&gt;right) return false; for(int i=left; i&lt;=right; i++)&#123; if(nums[i]==target) return true; &#125; return false; &#125;&#125;; å…¶ä»–ä»£ç å®žçŽ°æ–¹æ³• 12345678910111213141516171819202122232425class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int first = 0, last = nums.size(); while(first != last)&#123; const int mid = first + (last - first) / 2; if(nums[mid] == target) return true; if(nums[first] &lt; nums[mid])&#123; if(nums[first] &lt;= target &amp;&amp; target &lt; nums[mid]) last = mid; else first = mid + 1; &#125;else if(nums[first] &gt; nums[mid])&#123; if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[last-1]) first = mid + 1; else last = mid; &#125; else // skip duplicate one first++; &#125; return false; &#125;&#125;; cpp https://discuss.leetcode.com/topic/8087/c-concise-log-n-solution C++ concise log(n) solution 12345678910111213141516171819202122class Solution &#123;public: bool search(int A[], int n, int target) &#123; int lo =0, hi = n-1; int mid = 0; while(lo&lt;hi)&#123; mid=(lo+hi)/2; if(A[mid]==target) return true; if(A[mid]&gt;A[hi])&#123; if(A[mid]&gt;target &amp;&amp; A[lo] &lt;= target) hi = mid; else lo = mid + 1; &#125;else if(A[mid] &lt; A[hi])&#123; if(A[mid]&lt;target &amp;&amp; A[hi] &gt;= target) lo = mid + 1; else hi = mid; &#125;else&#123; hi--; &#125; &#125; return A[lo] == target ? true : false; &#125;&#125;; https://discuss.leetcode.com/topic/16660/my-8ms-c-solution-o-logn-on-average-o-n-worst-case My 8ms C++ solution (o(logn) on average, o(n) worst case) The idea is the same as the previous one without duplicates 12345671) everytime check if targe == nums[mid], if so, we find it.2) otherwise, we check if the first half is in order (i.e. nums[left]&lt;=nums[mid]) and if so, go to step 3), otherwise, the second half is in order, go to step 4)3) check if target in the range of [left, mid-1] (i.e. nums[left]&lt;=target &lt; nums[mid]), if so, do search in the first half, i.e. right = mid-1; otherwise, search in the second half left = mid+1;4) check if target in the range of [mid+1, right] (i.e. nums[mid]&lt;target &lt;= nums[right]), if so, do search in the second half, i.e. left = mid+1; otherwise search in the first half right = mid-1;The only difference is that due to the existence of duplicates, we can have nums[left] == nums[mid] and in that case, the first half could be out of order (i.e. NOT in the ascending order, e.g. [3 1 2 3 3 3 3]) and we have to deal this case separately. In that case, it is guaranteed that nums[right] also equals to nums[mid], so what we can do is to check if nums[mid]== nums[left] == nums[right] before the original logic, and if so, we can move left and right both towards the middle by 1. and repeat. 123456789101112131415161718192021222324252627class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size()-1, mid; while(left&lt;=right) &#123; mid = (left + right) &gt;&gt; 1; if(nums[mid] == target) return true; // the only difference from the first one, trickly case, just updat left and right if( (nums[left] == nums[mid]) &amp;&amp; (nums[right] == nums[mid]) ) &#123;++left; --right;&#125; else if(nums[left] &lt;= nums[mid]) &#123; if( (nums[left]&lt;=target) &amp;&amp; (nums[mid] &gt; target) ) right = mid-1; else left = mid + 1; &#125; else &#123; if((nums[mid] &lt; target) &amp;&amp; (nums[right] &gt;= target) ) left = mid+1; else right = mid-1; &#125; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/19116/easy-c-solution-based-on-version-i-of-the-problem Easy C++ Solution based on Version I of the Problem For those who have already solved Search in Rotated Sorted Array, this problem can be solved similarly using codes for that problem and simply adding codes to skip the duplicates. For Search in Rotated Sorted Array, I post solutions in C/C++/Python here (C and C++ only needs 11 lines). Now, based on the above codes, you can solve this problem by simply adding two lines to skip duplicates both starting from left and right. 123456789101112131415161718192021class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size() - 1; while (l &lt;= r) &#123; while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; // skip duplicates from the left while (r &gt; l &amp;&amp; nums[r] == nums[r - 1]) r--; // skip duplicates from the right int mid = (l + r) / 2; if (nums[mid] == target) return true; if (nums[mid] &gt; target) &#123; if (nums[l] &lt;= target || nums[mid] &lt; nums[l]) r = mid - 1; else l = mid + 1; &#125; else &#123; if (nums[l] &gt; target || nums[mid] &gt;= nums[l]) l = mid + 1; else r = mid - 1; &#125; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/20593/python-easy-to-understand-solution-with-comments Python easy to understand solution (with comments). 1234567891011121314151617181920212223def search(self, nums, target): l, r = 0, len(nums)-1 while l &lt;= r: mid = l + (r-l)//2 if nums[mid] == target: return True while l &lt; mid and nums[l] == nums[mid]: # tricky part l += 1 # the first half is ordered if nums[l] &lt;= nums[mid]: # target is in the first half if nums[l] &lt;= target &lt; nums[mid]: r = mid - 1 else: l = mid + 1 # the second half is ordered else: # target is in the second half if nums[mid] &lt; target &lt;= nums[r]: l = mid + 1 else: r = mid - 1 return False java https://discuss.leetcode.com/topic/310/when-there-are-duplicates-the-worst-case-is-o-n-could-we-do-better When there are duplicates, the worst case is O(n). Could we do better? Since we will have some duplicate elements in this problem, it is a little tricky because sometimes we cannot decide whether to go to the left side or right side. So for this condition, I have to probe both left and right side simultaneously to decide which side we need to find the number. Only in this condition, the time complexity may be O(n). The rest conditions are always O(log n). For example: input: 113111111111, Looking for target 3. Is my solution correct? My code is as followed: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public boolean search(int[] A, int target) &#123; // IMPORTANT: Please reset any member data you declared, as // the same Solution instance will be reused for each test case. int i = 0; int j = A.length - 1; while(i &lt;= j)&#123; int mid = (i + j) / 2; if(A[mid] == target) return true; else if(A[mid] &lt; A[i])&#123; if(target &gt; A[j]) j = mid - 1; else if(target &lt; A[mid]) j = mid - 1; else i = mid + 1; &#125;else if(A[mid] &gt; A[i])&#123; if(target &lt; A[mid] &amp;&amp; target &gt;= A[i]) j = mid - 1; else i = mid + 1; &#125;else&#123; // A[mid] == A[i] if(A[mid] != A[j]) i = mid + 1; else&#123; boolean flag = true; for(int k = 1; mid - k &gt;= i &amp;&amp; mid + k &lt;= j; k++)&#123; if(A[mid] != A[mid - k])&#123; j = mid - k; flag = false; break; &#125;else if(A[mid] != A[mid + k])&#123; i = mid + k; flag = false; break; &#125; &#125; if(flag) return false; &#125; &#125; &#125; return false; &#125;&#125; https://discuss.leetcode.com/topic/25487/neat-java-solution-using-binary-search Neat JAVA solution using binary search 12345678910111213141516171819202122232425262728293031public boolean search(int[] nums, int target) &#123; int start = 0, end = nums.length - 1, mid = -1; while(start &lt;= end) &#123; mid = (start + end) / 2; if (nums[mid] == target) &#123; return true; &#125; //If we know for sure right side is sorted or left side is unsorted if (nums[mid] &lt; nums[end] || nums[mid] &lt; nums[start]) &#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) &#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125; //If we know for sure left side is sorted or right side is unsorted &#125; else if (nums[mid] &gt; nums[start] || nums[mid] &gt; nums[end]) &#123; if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) &#123; end = mid - 1; &#125; else &#123; start = mid + 1; &#125; //If we get here, that means nums[start] == nums[mid] == nums[end], then shifting out //any of the two sides won&apos;t change the result but can help remove duplicate from //consideration, here we just use end-- but left++ works too &#125; else &#123; end--; &#125; &#125; return false;&#125; In case anyone wonders, yes I agree that we donâ€™t need to check two parts. Itâ€™s just that Doing that can slightly boost the performance, no asymptotic difference though.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[080. Remove Duplicates from Sorted Array II]]></title>
    <url>%2Fp%2F86a087%2F</url>
    <content type="text"><![CDATA[36.1% https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/ Follow up for â€œRemove Duplicatesâ€: What if duplicates are allowed at most twice? 123456For example,Given sorted array nums = [1,1,1,2,2,3],Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn&apos;t matter what you leave beyond the new length. æ–¹æ³•ä¸€ï¼š 12345678910111213141516171819202122class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return n; int i=0, j=0; int index = 0; while(i&lt;n)&#123; j=i; while(j&lt;n &amp;&amp; nums[i]==nums[j]) j++; if(j==i+1)&#123; nums[index++] = nums[j-1]; &#125; else&#123; nums[index++] = nums[j-1]; nums[index++] = nums[j-1]; &#125; i = j; &#125; return index; &#125;&#125;; æ€€ç–‘ä¸‹é¢çš„è§£æ³•éƒ½æ˜¯æ‰‹è¯¯ cpp https://discuss.leetcode.com/topic/12892/simple-and-clear-c-recursive-solution Simple and clear c++ recursive solution 123456789101112131415161718class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (!head) return 0; if (!head-&gt;next) return head; int val = head-&gt;val; ListNode* p = head-&gt;next; if (p-&gt;val != val) &#123; head-&gt;next = deleteDuplicates(p); return head; &#125; else &#123; while (p &amp;&amp; p-&gt;val == val) p = p-&gt;next; return deleteDuplicates(p); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/7224/is-this-the-best-c-solution Is this the best C++ solution? 123456789101112131415161718192021222324class Solution &#123;public: ListNode *deleteDuplicates(ListNode *head) &#123; ListNode **runner = &amp;head; if(!head || !head-&gt;next)return head; while(*runner) &#123; if((*runner)-&gt;next &amp;&amp; (*runner)-&gt;next-&gt;val == (*runner)-&gt;val) &#123; ListNode *temp = *runner; while(temp &amp;&amp; (*runner)-&gt;val == temp-&gt;val) temp = temp-&gt;next; *runner = temp; &#125; else runner = &amp;((*runner)-&gt;next); &#125; return head; &#125;&#125;; 123456789101112131415class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int size=nums.size(); int i=0,j=0; while(i&lt;size)&#123; nums[j++]=nums[i]; while(i+2&lt;size &amp;&amp; nums[i]==nums[i+1] &amp;&amp; nums[i+1]==nums[i+2])&#123; i++; &#125; i++; &#125; return j; &#125;&#125;; python https://discuss.leetcode.com/topic/21369/python-in-place-solution-with-dummy-head-node Python in-place solution with dummy head node. 12345678910111213def deleteDuplicates(self, head): dummy = pre = ListNode(0) dummy.next = head while head and head.next: if head.val == head.next.val: while head and head.next and head.val == head.next.val: head = head.next head = head.next pre.next = head else: pre = pre.next head = head.next return dummy.next java https://discuss.leetcode.com/topic/3890/my-accepted-java-code My accepted Java code 1234567891011121314151617181920public ListNode deleteDuplicates(ListNode head) &#123; if(head==null) return null; ListNode FakeHead=new ListNode(0); FakeHead.next=head; ListNode pre=FakeHead; ListNode cur=head; while(cur!=null)&#123; while(cur.next!=null&amp;&amp;cur.val==cur.next.val)&#123; cur=cur.next; &#125; if(pre.next==cur)&#123; pre=pre.next; &#125; else&#123; pre.next=cur.next; &#125; cur=cur.next; &#125; return FakeHead.next; &#125; https://discuss.leetcode.com/topic/5206/my-recursive-java-solution My Recursive Java Solution 12345678910111213public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) return null; if (head.next != null &amp;&amp; head.val == head.next.val) &#123; while (head.next != null &amp;&amp; head.val == head.next.val) &#123; head = head.next; &#125; return deleteDuplicates(head.next); &#125; else &#123; head.next = deleteDuplicates(head.next); &#125; return head;&#125; if current node is not unique, return deleteDuplicates with head.next. If current node is unique, link it to the result of next list made by recursive call. Any improvement? https://discuss.leetcode.com/topic/24470/java-simple-and-clean-code-with-comment Java simple and clean code with comment 123456789101112131415161718192021public class Solution &#123;public ListNode deleteDuplicates(ListNode head) &#123; //use two pointers, slow - track the node before the dup nodes, // fast - to find the last node of dups. ListNode dummy = new ListNode(0), fast = head, slow = dummy; slow.next = fast; while(fast != null) &#123; while (fast.next != null &amp;&amp; fast.val == fast.next.val) &#123; fast = fast.next; //while loop to find the last node of the dups. &#125; if (slow.next != fast) &#123; //duplicates detected. slow.next = fast.next; //remove the dups. fast = slow.next; //reposition the fast pointer. &#125; else &#123; //no dup, move down both pointer. slow = slow.next; fast = fast.next; &#125; &#125; return dummy.next;&#125; &#125; https://discuss.leetcode.com/topic/11234/a-short-and-simple-java-solution A short and simple Java solution 12345678910111213141516public ListNode deleteDuplicates(ListNode head) &#123; ListNode dummy = new ListNode(0); ListNode d = dummy; while (head != null) &#123; if (head.next != null &amp;&amp; head.val == head.next.val) &#123; while (head.next != null &amp;&amp; head.val == head.next.val) head = head.next; &#125; else &#123; d.next = head; d = d.next; &#125; head = head.next; &#125; d.next = null; return dummy.next;&#125; 1-&gt;1-&gt;1-&gt;2-&gt;2-&gt;3 we skip all the 1â€™s and start the loop from 2 and also skip all the 2â€™s, and now head.val == 3; ponit d.next to the tail, end the loop]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[079. Word Search]]></title>
    <url>%2Fp%2F289213d2%2F</url>
    <content type="text"><![CDATA[26.8% https://leetcode.com/problems/word-search/ Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where â€œadjacentâ€ cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. 1234567891011For example,Given board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]word = &quot;ABCCED&quot;, -&gt; returns true,word = &quot;SEE&quot;, -&gt; returns true,word = &quot;ABCB&quot;, -&gt; returns false. æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°: 123456789101112131415161718192021222324252627class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if(word.empty()) return true; if(board.size()==0 || board[0].size()==0) return false; for(int i=0; i&lt;board.size(); i++) for(int j=0; j&lt;board[0].size(); j++) if(helper(board, word, i, j, 0)) return true; return false; &#125; bool helper(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int i, int j, int k)&#123; int m=board.size(), n=board[0].size(); if(board[i][j]!=word[k]) return false; if(k==word.size()-1) return true; char c = board[i][j]; board[i][j] = '*'; bool res = false; if(j+1&lt;n) res = helper(board, word, i, j+1, k+1); if(!res &amp;&amp; i-1&gt;=0) res = helper(board, word, i-1, j, k+1); if(!res &amp;&amp; j-1&gt;=0) res = helper(board, word, i, j-1, k+1); if(!res &amp;&amp; i+1&lt;m) res = helper(board, word, i+1, j, k+1); board[i][j] = c; return res; &#125;&#125;; å…¸åž‹çš„dfsï¼Œbacktrackingæ–¹æ³• My 19ms accepted C++ code 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt; &gt; &amp;board, string word) &#123; m=board.size(); n=board[0].size(); for(int x=0;x&lt;m;x++) for(int y=0;y&lt;n;y++) &#123; if(isFound(board,word.c_str(),x,y)) return true; &#125; return false; &#125;private: int m; int n; bool isFound(vector&lt;vector&lt;char&gt; &gt; &amp;board, const char* w, int x, int y) &#123; if(x&lt;0||y&lt;0||x&gt;=m||y&gt;=n||board[x][y]=='\0'||*w!=board[x][y]) return false; if(*(w+1)=='\0') return true; char t=board[x][y]; board[x][y]='\0'; if(isFound(board,w+1,x-1,y)||isFound(board,w+1,x+1,y)||isFound(board,w+1,x,y-1)||isFound(board,w+1,x,y+1)) return true; board[x][y]=t; return false; &#125;&#125;; My DFS + Backtracking C++ solution (16ms) Typical dfs+backtracking question. It compare board[row][col] with word[start], if they match, change board[row][col] to â€˜*â€˜ to mark it as visited. Then move to the next one (i.e. word[start+1]) and compare it to the current neighbors ( doing it by recursion) 1234567891011121314151617181920212223242526272829class Solution &#123;private: bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, const string &amp;word, int start, int M, int N, int sLen) &#123; char curC; bool res = false; if( (curC = board[row][col]) != word[start]) return false; if(start==sLen-1) return true; board[row][col] = &apos;*&apos;; if(row&gt;0) res = dfs(board, row-1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; row &lt; M-1) res = dfs(board, row+1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; col &gt; 0) res = dfs(board, row, col-1, word, start+1, M, N, sLen); if(!res &amp;&amp; col &lt; N-1) res = dfs(board, row, col+1, word, start+1, M, N, sLen); board[row][col] = curC; return res; &#125; public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; int M,N,i,j,sLen = word.size(); if( (M=board.size()) &amp;&amp; (N=board[0].size()) &amp;&amp; sLen) &#123; for(i=0; i&lt;M; ++i) for(j=0; j&lt;N; ++j) if(dfs(board, i, j, word, 0, M, N, sLen)) return true; &#125; return false; &#125;&#125;; cpp https://discuss.leetcode.com/topic/9826/my-19ms-accepted-c-code My 19ms accepted C++ code 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt; &gt; &amp;board, string word) &#123; m=board.size(); n=board[0].size(); for(int x=0;x&lt;m;x++) for(int y=0;y&lt;n;y++) &#123; if(isFound(board,word.c_str(),x,y)) return true; &#125; return false; &#125;private: int m; int n; bool isFound(vector&lt;vector&lt;char&gt; &gt; &amp;board, const char* w, int x, int y) &#123; if(x&lt;0||y&lt;0||x&gt;=m||y&gt;=n||board[x][y]=='\0'||*w!=board[x][y]) return false; if(*(w+1)=='\0') return true; char t=board[x][y]; board[x][y]='\0'; if(isFound(board,w+1,x-1,y)||isFound(board,w+1,x+1,y)||isFound(board,w+1,x,y-1)||isFound(board,w+1,x,y+1)) return true; board[x][y]=t; return false; &#125;&#125;; https://discuss.leetcode.com/topic/19658/my-dfs-backtracking-c-solution-16ms My DFS + Backtracking C++ solution (16ms) Typical dfs+backtracking question. It compare board[row][col] with word[start], if they match, change board[row][col] to â€˜*â€˜ to mark it as visited. Then move to the next one (i.e. word[start+1]) and compare it to the current neighbors ( doing it by recursion) 1234567891011121314151617181920212223242526272829class Solution &#123;private: bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, const string &amp;word, int start, int M, int N, int sLen) &#123; char curC; bool res = false; if( (curC = board[row][col]) != word[start]) return false; if(start==sLen-1) return true; board[row][col] = &apos;*&apos;; if(row&gt;0) res = dfs(board, row-1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; row &lt; M-1) res = dfs(board, row+1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; col &gt; 0) res = dfs(board, row, col-1, word, start+1, M, N, sLen); if(!res &amp;&amp; col &lt; N-1) res = dfs(board, row, col+1, word, start+1, M, N, sLen); board[row][col] = curC; return res; &#125; public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; int M,N,i,j,sLen = word.size(); if( (M=board.size()) &amp;&amp; (N=board[0].size()) &amp;&amp; sLen) &#123; for(i=0; i&lt;M; ++i) for(j=0; j&lt;N; ++j) if(dfs(board, i, j, word, 0, M, N, sLen)) return true; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/22788/python-dfs-solution-with-comments Python dfs solution with comments. 12345678910111213141516171819202122def exist(self, board, word): if not board: return False for i in xrange(len(board)): for j in xrange(len(board[0])): if self.dfs(board, i, j, word): return True return False# check whether can find word, start at (i,j) position def dfs(self, board, i, j, word): if len(word) == 0: # all the characters are checked return True if i&lt;0 or i&gt;=len(board) or j&lt;0 or j&gt;=len(board[0]) or word[0]!=board[i][j]: return False tmp = board[i][j] # first character is found, check the remaining part board[i][j] = &quot;#&quot; # avoid visit agian # check whether can find &quot;word&quot; along one direction res = self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i-1, j, word[1:]) \ or self.dfs(board, i, j+1, word[1:]) or self.dfs(board, i, j-1, word[1:]) board[i][j] = tmp return res https://discuss.leetcode.com/topic/12391/python-simple-dfs-solution Python simple dfs solution 1234567891011121314151617181920212223242526272829def exist(self, board, word): if not word: return True if not board: return False for i in range(len(board)): for j in range(len(board[0])): if self.exist_helper(board, word, i, j): return True return False def exist_helper(self, board, word, i, j): if board[i][j] == word[0]: if not word[1:]: return True board[i][j] = &quot; &quot; # indicate used cell # check all adjacent cells if i &gt; 0 and self.exist_helper(board, word[1:], i-1, j): return True if i &lt; len(board)-1 and self.exist_helper(board, word[1:], i+1, j): return True if j &gt; 0 and self.exist_helper(board, word[1:], i, j-1): return True if j &lt; len(board[0])-1 and self.exist_helper(board, word[1:], i, j+1): return True board[i][j] = word[0] # update the cell to its original value return False else: return False java https://discuss.leetcode.com/topic/7907/accepted-very-short-java-solution-no-additional-space Accepted very short Java solution. No additional space. Here accepted solution based on recursion. To save memory I decuded to apply bit mask for every visited cell. Please check board[y][x] ^= 256; 12345678910111213141516171819202122public boolean exist(char[][] board, String word) &#123; char[] w = word.toCharArray(); for (int y=0; y&lt;board.length; y++) &#123; for (int x=0; x&lt;board[y].length; x++) &#123; if (exist(board, y, x, w, 0)) return true; &#125; &#125; return false;&#125;private boolean exist(char[][] board, int y, int x, char[] word, int i) &#123; if (i == word.length) return true; if (y&lt;0 || x&lt;0 || y == board.length || x == board[y].length) return false; if (board[y][x] != word[i]) return false; board[y][x] ^= 256; boolean exist = exist(board, y, x+1, word, i+1) || exist(board, y, x-1, word, i+1) || exist(board, y+1, x, word, i+1) || exist(board, y-1, x, word, i+1); board[y][x] ^= 256; return exist;&#125; https://discuss.leetcode.com/topic/25591/simple-solution Simple solution 12345678910111213141516171819202122public boolean exist(char[][] board, String word) &#123; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[i].length; j++) &#123; if(exist(board, i, j, word, 0)) return true; &#125; &#125; return false;&#125;private boolean exist(char[][] board, int x, int y, String word, int start) &#123; if(start &gt;= word.length()) return true; if(x &lt; 0 || x &gt;= board.length || y &lt; 0 || y &gt;= board[0].length) return false; if (board[x][y] == word.charAt(start++)) &#123; char c = board[x][y]; board[x][y] = &apos;#&apos;; boolean res = exist(board, x + 1, y, word, start) || exist(board, x - 1, y, word, start) || exist(board, x, y + 1, word, start) || exist(board, x, y - 1, word, start); board[x][y] = c; return res; &#125; return false;&#125; https://discuss.leetcode.com/topic/21142/my-java-solution My Java solution 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; static boolean[][] visited; public boolean exist(char[][] board, String word) &#123; visited = new boolean[board.length][board[0].length]; for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[i].length; j++)&#123; if((word.charAt(0) == board[i][j]) &amp;&amp; search(board, word, i, j, 0))&#123; return true; &#125; &#125; &#125; return false; &#125; private boolean search(char[][]board, String word, int i, int j, int index)&#123; if(index == word.length())&#123; return true; &#125; if(i &gt;= board.length || i &lt; 0 || j &gt;= board[i].length || j &lt; 0 || board[i][j] != word.charAt(index) || visited[i][j])&#123; return false; &#125; visited[i][j] = true; if(search(board, word, i-1, j, index+1) || search(board, word, i+1, j, index+1) || search(board, word, i, j-1, index+1) || search(board, word, i, j+1, index+1))&#123; return true; &#125; visited[i][j] = false; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[078. Subsets]]></title>
    <url>%2Fp%2Fb92586e7%2F</url>
    <content type="text"><![CDATA[37.7% https://leetcode.com/problems/subsets/ Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. 12345678910111213For example,If nums = [1,2,3], a solution is:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] æœ€æ ‡å‡†è§£æ³•ï¼Œå›žæº¯æ³• ä½è¿ç®—æ³•ï¼Œè®¡ç®—ç­”æ¡ˆä¸ªæ•°ä¸º2**nä¸ªï¼Œç„¶åŽé’ˆå¯¹æ¯ä¸€ä¸ªï¼Œè¿›è¡Œä½è¿ç®—ï¼Œè®¡ç®—æ˜¯å¦æœ‰ç›¸åº”ä½ã€‚ ç±»ä¼¼äºŽåŠ¨æ€è§„åˆ’ï¼Œå¦‚æžœæ˜¯0ä¸ªæ•°å­—ï¼Œé‚£è‚¯å®šæ˜¯ç©ºé›†ã€‚å¦‚æžœæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œåˆ™è¦ä¹ˆæ˜¯åŽŸç­”æ¡ˆç©ºé›†ï¼Œè¦ä¹ˆæ‰€æœ‰ç­”æ¡ˆéƒ½åŠ ä¸Šè¿™ä¸ªæ–°å…ƒç´ ï¼Œæ‰€ä»¥æ¯æ¬¡ç¿»å€ã€‚ æ–¹æ³•ä¸€ï¼š my code: å›žæº¯æ³•ï¼šè¿˜éœ€è¦å†æ€è€ƒå’Œç†è§£ 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs; vector&lt;int&gt; sub; genSubsets(nums, 0, sub, subs); return subs; &#125; void genSubsets(vector&lt;int&gt;&amp; nums, int start, vector&lt;int&gt;&amp; sub, vector&lt;vector&lt;int&gt;&gt;&amp; subs) &#123; subs.push_back(sub); for (int i = start; i &lt; nums.size(); i++) &#123; sub.push_back(nums[i]); genSubsets(nums, i + 1, sub, subs); sub.pop_back(); &#125; &#125;&#125;; å›žæº¯æ³•ï¼Œæˆ‘çš„å®žçŽ° dfsè¡¨ç¤ºï¼Œä»Ž0å¼€å§‹è‡³nçš„ä¸€ä¸ªå›žæº¯ã€‚ dfs(res, tmp, i+1, n, nums)è¡¨ç¤ºä»Ži+1å¼€å§‹çš„ å¯ä»¥çœ‹å‡ºï¼Œä»Žstartä¸ºç¬¬ä¸€ä¸ªï¼Œå¼€å§‹ï¼Œdfsä¸€ä¸‹åŽé¢çš„ç»“æžœã€‚ 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; dfs(res, tmp, 0, nums.size(), nums); return res; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt;&amp; tmp, int start, int n, vector&lt;int&gt;&amp; nums)&#123; res.push_back(tmp); for(int i=start; i&lt;n; i++)&#123; tmp.push_back(nums[i]); dfs(res, tmp, i+1, n, nums); tmp.pop_back(); &#125; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 8.27.2017 12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; dfs(nums, res, tmp, 0); return res; &#125; void dfs(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, int k)&#123; res.push_back(tmp); if(k&gt;=nums.size()) return; for(int i=k; i&lt;nums.size(); i++)&#123; tmp.push_back(nums[i]); dfs(nums, res, tmp, i+1); tmp.pop_back(); &#125; &#125;&#125;; æ–¹æ³•äºŒï¼š ä½è¿ç®—ï¼š 12345678910111213141516class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int n = nums.size(); int subnum = pow(2, n); vector&lt;vector&lt;int&gt;&gt; res(subnum, vector&lt;int&gt;()); for(int i=0; i&lt;subnum; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if((i&gt;&gt;j)&amp;1) res[i].push_back(nums[j]); &#125; &#125; return res; &#125;&#125;; æ–¹æ³•ä¸‰ï¼š ç±»ä¼¼äºŽdpçš„è§£æ³•ï¼š 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs(1, vector&lt;int&gt;()); for (int i = 0; i &lt; nums.size(); i++) &#123; int n = subs.size(); for (int j = 0; j &lt; n; j++) &#123; subs.push_back(subs[j]); subs.back().push_back(nums[i]); &#125; &#125; return subs; &#125;&#125;; ä¸‹é¢è¿™ä¸ªdiscussï¼Œå¾ˆæ£’ã€‚ https://discuss.leetcode.com/topic/19110/c-recursive-iterative-bit-manipulation-solutions-with-explanations C++ Recursive/Iterative/Bit-Manipulation Solutions with Explanations Recursive (Backtracking) This is a typical problem that can be tackled by backtracking. Since backtracking has a more-or-less similar template, so I do not give explanations for this method. 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs; vector&lt;int&gt; sub; genSubsets(nums, 0, sub, subs); return subs; &#125; void genSubsets(vector&lt;int&gt;&amp; nums, int start, vector&lt;int&gt;&amp; sub, vector&lt;vector&lt;int&gt;&gt;&amp; subs) &#123; subs.push_back(sub); for (int i = start; i &lt; nums.size(); i++) &#123; sub.push_back(nums[i]); genSubsets(nums, i + 1, sub, subs); sub.pop_back(); &#125; &#125;&#125;; Iterative This problem can also be solved iteratively. Take [1, 2, 3] in the problem statement as an example. The process of generating all the subsets is like: Initially: [[]] Adding the first number to all the existed subsets: [[], [1]]; Adding the second number to all the existed subsets: [[], [1], [2], [1, 2]]; Adding the third number to all the existed subsets: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]. Have you got the idea :-) The code is as follows. 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs(1, vector&lt;int&gt;()); for (int i = 0; i &lt; nums.size(); i++) &#123; int n = subs.size(); for (int j = 0; j &lt; n; j++) &#123; subs.push_back(subs[j]); subs.back().push_back(nums[i]); &#125; &#125; return subs; &#125;&#125;; Bit Manipulation This is the most clever solution that I have seen. The idea is that to give all the possible subsets, we just need to exhaust all the possible combinations of the numbers. And each number has only two possibilities: either in or not in a subset. And this can be represented using a bit. There is also another a way to visualize this idea. That is, if we use the above example, 1 appears once in every two consecutive subsets, 2 appears twice in every four consecutive subsets, and 3 appears four times in every eight subsets, shown in the following (initially the 8 subsets are all empty): 1234567[], [], [], [], [], [], [], [][], [1], [], [1], [], [1], [], [1][], [1], [2], [1, 2], [], [1], [2], [1, 2][], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3] The code is as follows. 12345678910111213class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int num_subset = pow(2, nums.size()); vector&lt;vector&lt;int&gt; &gt; res(num_subset, vector&lt;int&gt;()); for (int i = 0; i &lt; nums.size(); i++) for (int j = 0; j &lt; num_subset; j++) if ((j &gt;&gt; i) &amp; 1) res[j].push_back(nums[i]); return res; &#125;&#125;; Well, just a final remark. For Python programmers, this may be an easy task in practice since the itertools package has a function combinations for it :-) https://discuss.leetcode.com/topic/19110/c-recursive-iterative-bit-manipulation-solutions-with-explanations/2 Interesting way to use the bit masks, building all subsets in parallel. I donâ€™t think Iâ€™ve seen that before. Made me write a way to â€œonly iterate over the 1-bitsâ€: 1234for (int i = 0; i &lt; nums.size(); i++) for (int step = 1 &lt;&lt; i, start = 0; start &lt; num_subset; start += 2 * step) for (int j = start; j &lt; start + step; j++) res[j].push_back(nums[i]); Donâ€™t know whether itâ€™s faster. Overall, half of the bits are 1 anyway, so I save at most 50%. And I might have more overhead costs. Pythonâ€™s combinations doesnâ€™t quite do it, btw, it only creates subsets of a certain size. But it can be used, yes. Doesnâ€™t help much compared to other solutions, though, as you can see here. And Ruby is even shorter :-) https://discuss.leetcode.com/topic/2764/my-solution-using-bit-manipulation My solution using bit manipulation 1234567891011121314class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt; &amp;S) &#123; sort (S.begin(), S.end()); int elem_num = S.size(); int subset_num = pow (2, elem_num); vector&lt;vector&lt;int&gt; &gt; subset_set (subset_num, vector&lt;int&gt;()); for (int i = 0; i &lt; elem_num; i++) for (int j = 0; j &lt; subset_num; j++) if ((j &gt;&gt; i) &amp; 1) subset_set[j].push_back (S[i]); return subset_set; &#125;&#125;; https://discuss.leetcode.com/topic/2764/my-solution-using-bit-manipulation/7 123456789101112131415161718192021222324252627282930313233343536This is an amazing solution.Learnt a lot.Let me try to explain this to those who didn&apos;t get the logic. Number of subsets for &#123;1 , 2 , 3 &#125; = 2^3 . why ? case possible outcomes for the set of subsets 1 -&gt; Take or dont take = 2 2 -&gt; Take or dont take = 2 3 -&gt; Take or dont take = 2 therefore , total = 2*2*2 = 2^3 = &#123; &#123; &#125; , &#123;1&#125; , &#123;2&#125; , &#123;3&#125; , &#123;1,2&#125; , &#123;1,3&#125; , &#123;2,3&#125; , &#123;1,2,3&#125; &#125;Lets assign bits to each outcome -&gt; First bit to 1 , Second bit to 2 and third bit to 3Take = 1Dont take = 0 0) 0 0 0 -&gt; Dont take 3 , Dont take 2 , Dont take 1 = &#123; &#125; 1) 0 0 1 -&gt; Dont take 3 , Dont take 2 , take 1 = &#123;1 &#125; 2) 0 1 0 -&gt; Dont take 3 , take 2 , Dont take 1 = &#123; 2 &#125; 3) 0 1 1 -&gt; Dont take 3 , take 2 , take 1 = &#123; 1 , 2 &#125; 4) 1 0 0 -&gt; take 3 , Dont take 2 , Dont take 1 = &#123; 3 &#125; 5) 1 0 1 -&gt; take 3 , Dont take 2 , take 1 = &#123; 1 , 3 &#125; 6) 1 1 0 -&gt; take 3 , take 2 , Dont take 1 = &#123; 2 , 3 &#125; 7) 1 1 1 -&gt; take 3 , take 2 , take 1 = &#123; 1 , 2 , 3 &#125; In the above logic ,Insert S[i] only if (j&gt;&gt;i)&amp;1 ==true &#123; j E &#123; 0,1,2,3,4,5,6,7 &#125; i = ith element in the input array &#125;element 1 is inserted only into those places where 1st bit of j is 1 if( j &gt;&gt; 0 &amp;1 ) ==&gt; for above above eg. this is true for sl.no.( j )= 1 , 3 , 5 , 7 element 2 is inserted only into those places where 2nd bit of j is 1 if( j &gt;&gt; 1 &amp;1 ) == for above above eg. this is true for sl.no.( j ) = 2 , 3 , 6 , 7element 3 is inserted only into those places where 3rd bit of j is 1 if( j &gt;&gt; 2 &amp; 1 ) == for above above eg. this is true for sl.no.( j ) = 4 , 5 , 6 , 7 Time complexity : O(n*2^n) , for every input element loop traverses the whole solution set length i.e. 2^n https://discuss.leetcode.com/topic/11373/c-8ms-simple-iterative-solution C++ 8ms simple iterative solution 1234567891011121314151617class Solution &#123;public:vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt; &amp;S) &#123; vector&lt;vector&lt;int&gt; &gt; res(1, vector&lt;int&gt;()); sort(S.begin(), S.end()); for (int i = 0; i &lt; S.size(); i++) &#123; int n = res.size(); for (int j = 0; j &lt; n; j++) &#123; res.push_back(res[j]); res.back().push_back(S[i]); &#125; &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/19561/python-easy-to-understand-solutions-dfs-recursively-bit-manipulation-iteratively Python easy to understand solutions (DFS recursively, Bit Manipulation, Iteratively). 12345678910# DFS recursively def subsets1(self, nums): res = [] self.dfs(sorted(nums), 0, [], res) return res def dfs(self, nums, index, path, res): res.append(path) for i in xrange(index, len(nums)): self.dfs(nums, i+1, path+[nums[i]], res) 1234567891011# Bit Manipulation def subsets2(self, nums): res = [] nums.sort() for i in xrange(1&lt;&lt;len(nums)): tmp = [] for j in xrange(len(nums)): if i &amp; 1 &lt;&lt; j: # if i &gt;&gt; j &amp; 1: tmp.append(nums[j]) res.append(tmp) return res 123456# Iterativelydef subsets(self, nums): res = [[]] for num in sorted(nums): res += [item+[num] for item in res] return res https://discuss.leetcode.com/topic/30867/simple-iteration-no-recursion-no-twiddling-explanation Simple iteration (no recursion, no twiddling) + explanation My idea was to start out with an empty subset and either take or donâ€™t take the next element in the input array. Hereâ€™s how it goes down for input [1,2,3]: start with 1[] // empty set is always a subset then either take or not take the next element (1), this doubles the result size: 12[] // not take 1[1] // take 1 + new then take or not take the next element: 2 1234[] // not take 1, not take 2[2] // not take 1, take 2 + new[1] // take 1, not take 2[1,2] // take 1, take 2 + new and finally take or not take 3. 12345678[] // not take 1, not take 2, not take 3[3] // not take 1, not take 2, take 3 + new[2] // not take 1, take 2, not take 3[2,3] // not take 1, take 2, take 3 + new[1] // take 1, not take 2, not take 3[1,3] // take 1, not take 2, take 3 + new[1,2] // take 1, take 2, not take 3[1,2,3] // take 1, take 2, take 3 + new And weâ€™re done, we have all 2^3 = 8 subsets generated. It is possible to generate these with a simple loop, thereâ€™s only one trick here, the variable size. Itâ€™s usually a good practice to cache method call results, but now it is cached for a different reason: because it changes in every iteration. If we donâ€™t want to end up with an infinite loop, we have to remember how many results were available in the previous iteration, which is exactly the size() of the result at the beginning of the current iteration. 12345678910111213public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; Arrays.sort(nums); // make sure subsets are ordered List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); result.add(new ArrayList&lt;&gt;()); // start with empty set for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = 0, size = result.size(); j &lt; size; ++j) &#123; // remember List&lt;Integer&gt; subset = new ArrayList&lt;&gt;(result.get(j)); // copy a new one subset.add(nums[i]); // expand result.add(subset); // collect &#125; &#125; return result;&#125; It is also necessary to order the input to satisfy the requirement: 1Elements in a subset must be in non-descending order. Because i is increasing it means that whatever we take from nums will also be in increasing order. The other requirement: 1The solution set must not contain duplicate subsets. is automatically guaranteed by the input specification and the algorithm walking indices straight and once: 1Given a set of distinct integers, nums, return all possible subsets. [emphasis mine] java https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning) This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. Subsets : https://leetcode.com/problems/subsets/ 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Subsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Permutations : https://leetcode.com/problems/permutations/ 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/ 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum : https://leetcode.com/problems/combination-sum/ 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum II (canâ€™t reuse same element) : https://leetcode.com/problems/combination-sum-ii/ 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Palindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/ 12345678910111213141516171819202122232425public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list;&#125;public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125;&#125;public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true;&#125; https://discuss.leetcode.com/topic/9031/simple-java-solution-with-for-each-loops Simple Java Solution with For-Each loops No messy indexing. Avoid the ConcurrentModificationException by using a temp list. 123456789101112131415161718public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] S) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); res.add(new ArrayList&lt;Integer&gt;()); Arrays.sort(S); for(int i : S) &#123; List&lt;List&lt;Integer&gt;&gt; tmp = new ArrayList&lt;&gt;(); for(List&lt;Integer&gt; sub : res) &#123; List&lt;Integer&gt; a = new ArrayList&lt;&gt;(sub); a.add(i); tmp.add(a); &#125; res.addAll(tmp); &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/10885/java-subsets-solution Java subsets solution 123456789101112131415161718192021222324public class Solution &#123;public List&lt;List&lt;Integer&gt;&gt; subsets(int[] S) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(S.length == 0)&#123; return result; &#125; Arrays.sort(S); dfs(S, 0, new ArrayList&lt;Integer&gt;(), result); return result;&#125;public void dfs(int[] s, int index, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)&#123; result.add(new ArrayList&lt;Integer&gt;(path)); for(int i = index; i &lt; s.length; i++)&#123; path.add(s[i]); dfs(s, i+1, path, result); path.remove(path.size()-1); &#125;&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[077. Combinations]]></title>
    <url>%2Fp%2F20864a35%2F</url>
    <content type="text"><![CDATA[39.6% https://leetcode.com/problems/combinations/ Given two integers n and k, return all possible combinations of k numbers out of 1 â€¦ n. 1234567891011For example,If n = 4 and k = 2, a solution is:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] æ–¹æ³•ä¸€ï¼š å›žæº¯æ³•ï¼Œdfs code 1ï¼š My shortest c++ solution,using dfs my idea is using backtracking ,every time I push a number into vector,then I push a bigger one into it; then i pop the latest one,and push a another bigger oneâ€¦ and if I has push k number into vector,I push this into result; this solution take 24 ms. 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt; &gt;res; if(n&lt;k)return res; vector&lt;int&gt; temp(0,k); combine(res,temp,0,0,n,k); return res; &#125; void combine(vector&lt;vector&lt;int&gt; &gt; &amp;res,vector&lt;int&gt; &amp;temp,int start,int num,int n ,int k)&#123; if(num==k)&#123; res.push_back(temp); return; &#125; for(int i = start;i&lt;n;i++)&#123; temp.push_back(i+1); combine(res,temp,i+1,num+1,n,k); temp.pop_back(); &#125; &#125;&#125;; code 2: æˆ‘çš„å®žçŽ° ç»å…¸çš„å›žæº¯æ³•ç®—æ³•ï¼Œä¸€å®šè¦ä¼šã€‚ my codeï¼š 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; if(n&lt;k) return res; dfs(res, tmp, 0, 0, n, k); return res; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, int start, int num, int n, int k)&#123; if(num==k)&#123; res.push_back(tmp); return; &#125; for(int i=start+1; i&lt;=n; i++)&#123; tmp.push_back(i); dfs(res, tmp, i, num+1, n, k); tmp.pop_back(); &#125; &#125;&#125;; code 3ï¼š https://discuss.leetcode.com/topic/22569/c-concise-recursive-solution-c-n-k-c-n-1-k-1-8ms C++ concise recursive solution C(n,k) -&gt;C(n-1,k-1) / 8ms 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; temp; combine(1,n,k,ans,temp); //call fuction to get combination of k numbers which range is 1-n return ans; &#125;private: void combine(int begin,int n, int k, vector&lt;vector&lt;int&gt;&gt; &amp;ans, vector&lt;int&gt;&amp; temp)&#123; if(k==0)&#123; ans.push_back(temp); return; &#125; //condition : n-i+1 is the range, range must greater than k for(int i=begin;n-i+1&gt;=k;i++)&#123; // for the ith iteration, get the combination of i and k-1 numbers differ from i. temp.push_back(i); combine(i+1,n,k-1,ans,temp);// get the combination of k-1 numbers which range is(i+1,n) temp.pop_back(); &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/26689/short-iterative-c-answer-8ms Short Iterative C++ Answer 8ms 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; result; int i = 0; vector&lt;int&gt; p(k, 0); while (i &gt;= 0) &#123; p[i]++; if (p[i] &gt; n) --i; else if (i == k - 1) result.push_back(p); else &#123; ++i; p[i] = p[i - 1]; &#125; &#125; return result; &#125;&#125;; 12ms, 27.43%, May.6th, 2016 https://leetcode.com/discuss/12915/my-shortest-c-solution-using-dfs My shortest c++ solution,using dfs my idea is using backtracking ,every time I push a number into vector,then I push a bigger one into it; then i pop the latest one,and push a another bigger oneâ€¦ and if I has push k number into vector,I push this into result; this solution take 24 ms. 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt; &gt;res; if(n&lt;k)return res; vector&lt;int&gt; temp(0,k); combine(res,temp,0,0,n,k); return res; &#125; void combine(vector&lt;vector&lt;int&gt; &gt; &amp;res,vector&lt;int&gt; &amp;temp,int start,int num,int n ,int k)&#123; if(num==k)&#123; res.push_back(temp); return; &#125; for(int i = start;i&lt;n;i++)&#123; temp.push_back(i+1); combine(res,temp,i+1,num+1,n,k); temp.pop_back(); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/22569/c-concise-recursive-solution-c-n-k-c-n-1-k-1-8ms C++ concise recursive solution C(n,k) -&gt;C(n-1,k-1) / 8ms 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; temp; combine(1,n,k,ans,temp); //call fuction to get combination of k numbers which range is 1-n return ans; &#125;private: void combine(int begin,int n, int k, vector&lt;vector&lt;int&gt;&gt; &amp;ans, vector&lt;int&gt;&amp; temp)&#123; if(k==0)&#123; ans.push_back(temp); return; &#125; //condition : n-i+1 is the range, range must greater than k for(int i=begin;n-i+1&gt;=k;i++)&#123; // for the ith iteration, get the combination of i and k-1 numbers differ from i. temp.push_back(i); combine(i+1,n,k-1,ans,temp);// get the combination of k-1 numbers which range is(i+1,n) temp.pop_back(); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/14626/1-liner-3-liner-4-liner 1-liner, 3-liner, 4-liner Library - AC in 64 ms First the obvious solution - Python already provides this functionality and itâ€™s not forbidden, so letâ€™s take advantage of it. 12345from itertools import combinationsclass Solution: def combine(self, n, k): return list(combinations(range(1, n+1), k)) Recursive - AC in 76 ms But doing it yourself is more interesting, and not that hard. Hereâ€™s a recursive version. 12345class Solution: def combine(self, n, k): if k == 0: return [[]] return [pre + [i] for i in range(1, n+1) for pre in self.combine(i-1, k-1)] Iterative - AC in 76 ms And hereâ€™s an iterative one. 123456class Solution: def combine(self, n, k): combs = [[]] for _ in range(k): combs = [[i] + c for c in combs for i in range(1, c[0] if c else n+1)] return combs Reduce - AC in 76 ms Same as that iterative one, but using reduce instead of a loop: 1234class Solution: def combine(self, n, k): return reduce(lambda C, _: [[i]+c for c in C for i in range(1, c[0] if c else n+1)], range(k), [[]]) https://discuss.leetcode.com/topic/25958/ac-python-backtracking-iterative-solution-60-ms AC Python backtracking iterative solution 60 ms 1234567891011121314151617181920def combine(self, n, k): ans = [] stack = [] x = 1 while True: l = len(stack) if l == k: ans.append(stack[:]) if l == k or x &gt; n - k + l + 1: if not stack: return ans x = stack.pop() + 1 else: stack.append(x) x += 1# 26 / 26 test cases passed.# Status: Accepted# Runtime: 60 ms# 98.51% Combinations is typical application for backtracking. Two conditions for back track: (1) the stack length is already k (2) the current value is too large for the rest slots to fit in since we are using ascending order to make sure the uniqueness of each combination. java https://discuss.leetcode.com/topic/11718/backtracking-solution-java Backtracking Solution Java 12345678910111213141516public static List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; combs = new ArrayList&lt;List&lt;Integer&gt;&gt;(); combine(combs, new ArrayList&lt;Integer&gt;(), 1, n, k); return combs;&#125;public static void combine(List&lt;List&lt;Integer&gt;&gt; combs, List&lt;Integer&gt; comb, int start, int n, int k) &#123; if(k==0) &#123; combs.add(new ArrayList&lt;Integer&gt;(comb)); return; &#125; for(int i=start;i&lt;=n;i++) &#123; comb.add(i); combine(combs, comb, i+1, n, k-1); comb.remove(comb.size()-1); &#125;&#125; https://discuss.leetcode.com/topic/12537/a-short-recursive-java-solution-based-on-c-n-k-c-n-1-k-1-c-n-1-k A short recursive Java solution based on C(n,k)=C(n-1,k-1)+C(n-1,k) Basically, this solution follows the idea of the mathematical formula C(n,k)=C(n-1,k-1)+C(n-1,k). Here C(n,k) is divided into two situations. Situation one, number n is selected, so we only need to select k-1 from n-1 next. Situation two, number n is not selected, and the rest job is selecting k from n-1. 123456789101112131415public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; if (k == n || k == 0) &#123; List&lt;Integer&gt; row = new LinkedList&lt;&gt;(); for (int i = 1; i &lt;= k; ++i) &#123; row.add(i); &#125; return new LinkedList&lt;&gt;(Arrays.asList(row)); &#125; List&lt;List&lt;Integer&gt;&gt; result = this.combine(n - 1, k - 1); result.forEach(e -&gt; e.add(n)); result.addAll(this.combine(n - 1, k)); return result; &#125;&#125; https://discuss.leetcode.com/topic/3943/dp-for-the-problem DP for the problem I didnâ€™t see any DP solution for this problem, so I share mine: The idea is simple, if the combination k out of n (select k elements from [1,n]) is combine(k, n). Letâ€™s consider how can we get combine(k, n) by adding the last element n to something we already have (combine(k - 1, n - 1) and combine(k, n - 1)). Actually, the combine(k, n) has two parts, one part is all combinations without n, itâ€™s combine(k, n - 1), another is all combinations with n, which can be gotten by appending n to every element in combine(k - 1, n - 1). Note, the combine(i, i) is what we can get directly. Below is my code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Solution&#123; // Combine(n, n). private List&lt;Integer&gt; allContain(int n) &#123; final List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= n; ++i) &#123; result.add(i); &#125; return result; &#125; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;List&lt;Integer&gt;&gt;&gt; previous = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= n; ++i) &#123; previous.add(Collections.singletonList(Collections.&lt;Integer&gt;emptyList())); &#125; for (int i = 1; i &lt;= k; ++i) &#123; final List&lt;List&lt;List&lt;Integer&gt;&gt;&gt; current = new ArrayList&lt;&gt;(); current.add(Collections.singletonList(allContain(i))); // Combine(i, j). for (int j = i + 1; j &lt;= n; ++j) &#123; final List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Combine(i, j - 1). list.addAll(current.get(current.size() - 1)); // Comine(i - 1, j - 1). for (final List&lt;Integer&gt; item : previous.get(current.size())) &#123; final List&lt;Integer&gt; newItem = new ArrayList&lt;&gt;(item); newItem.add(j); list.add(newItem); &#125; current.add(list); &#125; previous = current; &#125; return (previous.size() == 0) ? Collections.&lt;List&lt;Integer&gt;&gt;emptyList() : previous.get(previous.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[076. Minimum Window Substring]]></title>
    <url>%2Fp%2F9aa229a6%2F</url>
    <content type="text"><![CDATA[25.7% https://leetcode.com/problems/minimum-window-substring/ Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). 1234For example,S = &quot;ADOBECODEBANC&quot;T = &quot;ABC&quot;Minimum window is &quot;BANC&quot;. Note:If there is no such window in S that covers all characters in T, return the empty string â€œâ€. If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S. Subscribe to see which companies asked this question æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼Œæ›´å®¹æ˜“ç†è§£é€»è¾‘ï¼Œå¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string minWindow(string s, string t) &#123; int m = s.size(), n = t.size(); if(n&gt;m) return &quot;&quot;; vector&lt;int&gt; v(256, 0); for(int i=0; i&lt;n; i++) v[t[i]]++; int left = 0; int right = 0; int head = 0; int len = INT_MAX; int cnt = n; while(right&lt;m)&#123; if(v[s[right]]&gt;0) cnt--; v[s[right]]--; right++; while(cnt==0)&#123; // left++, ä¸è€ƒè™‘left&gt;=m å› ä¸ºleftä¸å¯èƒ½&gt;=mï¼Œå¦åˆ™cntï¼=0 if(right-left&lt;len)&#123; head = left; len = right-left; &#125; if(v[s[left]]==0) cnt++; v[s[left]]++; left++; &#125; &#125; return len!=INT_MAX?s.substr(head, len):&quot;&quot;; &#125;&#125;; é‡ç‚¹æ–¹æ³•ï¼Œé‡ç‚¹å­¦ä¹ ï¼Œå¹¶ä¸”å¸¦æœ‰æ¨¡æ¿ https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems 9ms, 86.18%, September 22, 2016 Here is a 10-line template that can solve most â€˜substringâ€™ problems I will first give the solution then show you the magic template. The code of solving this problem is below. It might be the shortest among all solutions provided in Discuss. 12345678910111213141516class Solution &#123;public: string minWindow(string s, string t) &#123; vector&lt;int&gt; map(128, 0); for(auto c:t) map[c]++; int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0; while(end&lt;s.size())&#123; if(map[s[end++]]--&gt;0) counter--; while(counter==0)&#123; if(end-begin&lt;d) d=end-(head=begin); if(map[s[begin++]]++==0) counter++; &#125; &#125; return d==INT_MAX?&quot;&quot;:s.substr(head, d); &#125;&#125;; Here comes the template. For most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers. The template is given below. 12345678910111213141516171819202122232425int findSubstring(string s)&#123; vector&lt;int&gt; map(128,0); int counter; // check whether the substring is valid int begin=0, end=0; //two pointers, one point to tail and one head int d; //the length of substring for() &#123; /* initialize the hash map here */ &#125; while(end&lt;s.size())&#123; if(map[s[end++]]-- ?)&#123; /* modify counter here */ &#125; while(/* counter condition */)&#123; /* update d here if finding minimum*/ //increase begin to make it invalid/valid again if(map[s[begin++]]++ ?)&#123; /*modify counter here*/ &#125; &#125; /* update d here if finding maximum*/ &#125; return d; &#125; One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop. The code of solving Longest Substring with At Most Two Distinct Characters is below: 12345678910int lengthOfLongestSubstringTwoDistinct(string s) &#123; vector&lt;int&gt; map(128, 0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++==0) counter++; while(counter&gt;2) if(map[s[begin++]]--==1) counter--; d=max(d, end-begin); &#125; return d; &#125; Longest Substring with At Most Two Distinct Characters ï¼ˆå¸¦é”ï¼‰ The code of solving Longest Substring Without Repeating Characters is below: Update 01.04.2016, thanks @weiyi3 for advise. 12345678910int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; map(128,0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++&gt;0) counter++; while(counter&gt;0) if(map[s[begin++]]--&gt;1) counter--; d=max(d, end-begin); //while valid, update d &#125; return d; &#125; I think this post deserves some upvotes! : ) code 2ï¼š ä»£ç è§£è¯»ï¼š 12345678910111213141516171819202122232425// S = &quot;ADOBECODEBANC&quot;// T = &quot;ABC&quot;class Solution &#123;public: string minWindow(string s, string t) &#123; vector&lt;int&gt; map(128, 0); for(auto c:t) map[c]++; int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0; while(end&lt;s.size())&#123; if(map[s[end++]]--&gt;0) counter--; while(counter==0)&#123; // å¦‚æžœèƒ½è¿›å…¥count==0ï¼Œ è¯´æ˜Žbeginè‡³endä¹‹é—´çš„åŒ…æ‹¬tçš„æ‰€æœ‰å­—ç¬¦ if(end-begin&lt;d)&#123; //ç®€å•çš„åˆ¤æ–­ head = begin; d = end - head; &#125; if(map[s[begin]]==0)&#123;// beginæŒ‡å‘å€¼çš„å¦‚æžœåœ¨æ­¤æ—¶æ˜¯0ï¼Œè¯´æ˜Žè¿™ä¸ªå€¼ä¸€å®šæ˜¯tçš„å€¼ï¼Œå¦‚æžœä¸æ˜¯ï¼Œå€¼ä¸€å®šæ˜¯è´Ÿçš„ï¼Œå› ä¸ºå‰é¢å‡äº†ã€‚ counter++; &#125; map[s[begin]]++; // æœ¬æ¥è¿›å…¥ä¸€ä¸ªå€¼æ˜¯å‡çš„ï¼Œå‡å°‘ä¸€ä¸ªå€¼ï¼Œè¿™ä¸ªmapå€¼çš„å¢žåŠ çš„ begin++; // å¦‚æžœè¿›å…¥äº†æ»¡è¶³counter==0çŠ¶æ€ï¼Œè‚¯å®šè¦begin++ï¼Œå‘å‰èµ°çš„ &#125; &#125; return d==INT_MAX?&quot;&quot;:s.substr(head, d); &#125;&#125;; https://discuss.leetcode.com/topic/3107/accepted-o-n-solution https://oj.leetcode.com/discuss/5469/is-the-length-of-t-considered-constant-or-m Implementation of mike3â€™s idea 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: string minWindow(string S, string T) &#123; if (S.empty() || T.empty()) &#123; return &quot;&quot;; &#125; int count = T.size(); int require[128] = &#123;0&#125;; bool chSet[128] = &#123;false&#125;; for (int i = 0; i &lt; count; ++i) &#123; require[T[i]]++; chSet[T[i]] = true; &#125; int i = -1; int j = 0; int minLen = INT_MAX; int minIdx = 0; while (i &lt; (int)S.size() &amp;&amp; j &lt; (int)S.size()) &#123; if (count) &#123; i++; require[S[i]]--; if (chSet[S[i]] &amp;&amp; require[S[i]] &gt;= 0) &#123; count--; &#125; &#125; else &#123; if (minLen &gt; i - j + 1) &#123; minLen = i - j + 1; minIdx = j; &#125; require[S[j]]++; if (chSet[S[j]] &amp;&amp; require[S[j]] &gt; 0) &#123; count++; &#125; j++; &#125; &#125; if (minLen == INT_MAX) &#123; return &quot;&quot;; &#125; return S.substr(minIdx, minLen); &#125;&#125;; https://discuss.leetcode.com/topic/6026/sharing-my-straightforward-o-n-solution-with-explanation There are three key variables in my solution: 1unordered_map &lt;char, int&gt; map; unordered_map&lt;char, int&gt; window; int letterCounter; variable â€œmapâ€ is used to indicate what characters and how many characters are in T. variable â€œwindowâ€ is to indicate what characters and how many characters are between pointer â€œslowâ€ and pointer â€œfastâ€. Now letâ€™s start. The first For loop is used to construct variable â€œmapâ€. The second For loop is used to find the minimum window. The first thing we should do in the second For loop is to find a window which can cover T. I use â€œletterCounterâ€ to be a monitor. If â€œletterCounterâ€ is equal to T.length(), then we find this window. Before that, only the first If clause can be executed. However, after we find this window, the second If clause can also be executed. In the second If clause, we move â€œslowâ€ forward in order to shrink the window size. Every time finding a smaller window, I update the result. At the end of program, I return result, which is the minimum window. 123456789101112131415161718192021222324252627282930313233string minWindow(string S, string T) &#123; string result; if(S.empty() || T.empty())&#123; return result; &#125; unordered_map&lt;char, int&gt; map; unordered_map&lt;char, int&gt; window; for(int i = 0; i &lt; T.length(); i++)&#123; map[T[i]]++; &#125; int minLength = INT_MAX; int letterCounter = 0; for(int slow = 0, fast = 0; fast &lt; S.length(); fast++)&#123; char c = S[fast]; if(map.find(c) != map.end())&#123; window[c]++; if(window[c] &lt;= map[c])&#123; letterCounter++; &#125; &#125; if(letterCounter &gt;= T.length())&#123; while(map.find(S[slow]) == map.end() || window[S[slow]] &gt; map[S[slow]])&#123; window[S[slow]]--; slow++; &#125; if(fast - slow + 1 &lt; minLength)&#123; minLength = fast - slow + 1; result = S.substr(slow, minLength); &#125; &#125; &#125; return result;&#125; python 232ms, 32.27%, September 23, 2016 12 lines Python https://discuss.leetcode.com/topic/20692/12-lines-python The current window is s[i:j] and the result window is s[I:J]. In need[c] I store how many times I need character c (can be negative) and missing tells how many characters are still missing. In the loop, first add the new character to the window. Then, if nothing is missing, remove as much as possible from the window start and then update the result.12345678910111213141516171819class Solution(object): def minWindow(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: str &quot;&quot;&quot; need, missing = collections.Counter(t), len(t) i = I = J = 0 for j, c in enumerate(s, 1): missing -= need[c] &gt; 0 need[c] -= 1 if not missing: while i&lt;j and need[s[i]] &lt; 0: need[s[i]] += 1 i += 1 if not J or j-i &lt;= J-I: I, J = i, j return s[I:J] https://discuss.leetcode.com/topic/6665/accepted-python-solution-using-hashtable Accepted Python solution using hashtable 1234567891011121314151617181920212223242526class Solution: # @return a string def minWindow(self, S, T): indices = &#123;&#125; for char in T: indices[char] = [] miss = list(T) start = 0 end = len(S) for i in range(len(S)): if S[i] in T: if S[i] not in miss and indices[S[i]] != []: indices[S[i]].pop(0) elif S[i] in miss: miss.remove(S[i]) indices[S[i]].append(i) if miss == []: maximum = max([x[-1] for x in indices.values()]) minimum = min([x[0] for x in indices.values()]) if maximum-minimum+1 &lt; end-start+1: start = minimum end = maximum if miss != []: return &quot;&quot; else: return S[start:end+1] Basically I kept a dictionary to record the index of each character of T. Each time I found a window, (when miss == []), I checked the length of this window by subtracting the maximum index and the minimum index of the characters. If this window is the smallest one so far, I record its beginning and ending index as â€œstartâ€ and â€œend.â€ java https://discuss.leetcode.com/topic/12492/share-my-neat-java-solution Share my neat java solution 123456789101112131415161718192021222324252627282930313233343536public String minWindow(String S, String T) &#123; if(S==null||S.isEmpty()||T==null||T.isEmpty()) return &quot;&quot;; int i=0, j=0; int[] Tmap=new int[256]; int[] Smap=new int[256]; for(int k=0; k&lt; T.length(); k++)&#123; Tmap[T.charAt(k)]++; &#125; int found=0; int length=Integer.MAX_VALUE; String res=&quot;&quot;; while(j&lt;S.length())&#123; if(found&lt;T.length())&#123; if(Tmap[S.charAt(j)]&gt;0)&#123; Smap[S.charAt(j)]++; if(Smap[S.charAt(j)]&lt;=Tmap[S.charAt(j)])&#123; found++; &#125; &#125; j++; &#125; while(found==T.length())&#123; if(j-i&lt;length)&#123; length=j-i; res=S.substring(i,j); &#125; if(Tmap[S.charAt(i)]&gt;0)&#123; Smap[S.charAt(i)]--; if(Smap[S.charAt(i)]&lt;Tmap[S.charAt(i)])&#123; found--; &#125; &#125; i++; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/21143/java-solution-using-two-pointers-hashmap Java solution. using two pointers + HashMap 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123;public String minWindow(String s, String t) &#123; if(s == null || s.length() &lt; t.length() || s.length() == 0)&#123; return &quot;&quot;; &#125; HashMap&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); for(char c : t.toCharArray())&#123; if(map.containsKey(c))&#123; map.put(c,map.get(c)+1); &#125;else&#123; map.put(c,1); &#125; &#125; int left = 0; int minLeft = 0; int minLen = s.length()+1; int count = 0; for(int right = 0; right &lt; s.length(); right++)&#123; if(map.containsKey(s.charAt(right)))&#123; map.put(s.charAt(right),map.get(s.charAt(right))-1); if(map.get(s.charAt(right)) &gt;= 0)&#123; count ++; &#125; while(count == t.length())&#123; if(right-left+1 &lt; minLen)&#123; minLeft = left; minLen = right-left+1; &#125; if(map.containsKey(s.charAt(left)))&#123; map.put(s.charAt(left),map.get(s.charAt(left))+1); if(map.get(s.charAt(left)) &gt; 0)&#123; count --; &#125; &#125; left ++ ; &#125; &#125; &#125; if(minLen&gt;s.length()) &#123; return &quot;&quot;; &#125; return s.substring(minLeft,minLeft+minLen);&#125;&#125; https://discuss.leetcode.com/topic/41308/java-4ms-bit-97-6 Java 4ms bit 97.6% Basically, there are two pointers for windows sliding. One for exploiting new matched substring, other pointer for expiring previous substring. 1234567891011121314151617181920212223242526272829303132333435363738public String minWindow(String s, String t) &#123; char[] s_array = s.toCharArray(); char[] t_array = t.toCharArray(); int[] map = new int[256]; int end = 0; int start = 0; int min_length = Integer.MAX_VALUE; for(int i = 0; i &lt; t_array.length; i++) map[t_array[i]] ++; int count = t_array.length; int min_start = 0; while(end &lt; s_array.length) &#123; if(map[s_array[end]] &gt; 0) &#123; count--; &#125; map[s_array[end]] --; while(count == 0) &#123; if((end - start + 1) &lt; min_length) &#123; min_length = end - start + 1; min_start = start; &#125; map[s_array[start]] ++; if(map[s_array[start]] &gt; 0)&#123; count ++; &#125; start++; &#125; end ++; &#125; if( min_start+min_length &gt; s_array.length) return &quot;&quot;; return s.substring(min_start, min_start+min_length); &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[075. Sort Colors]]></title>
    <url>%2Fp%2Fb84bd86e%2F</url>
    <content type="text"><![CDATA[37.0% https://leetcode.com/problems/sort-colors/ Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note:You are not suppose to use the libraryâ€™s sort function for this problem. click to show follow up. Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0â€™s, 1â€™s, and 2â€™s, then overwrite array with total number of 0â€™s, then 1â€™s and followed by 2â€™s. Could you come up with an one-pass algorithm using only constant space? æœ¬é¢˜å±žäºŽ#ä¸‰å‘å¿«é€ŸæŽ’åº#ï¼Œå¯ä»¥å‚è€ƒ#ç®—æ³•å¯¼è®º#ã€‚ æ–¹æ³•ä¸€ï¼š 12345678910class Solution &#123;public: void sortColors(int A[], int n) &#123; int second=n-1, zero=0; for (int i=0; i&lt;=second; i++) &#123; while (A[i]==2 &amp;&amp; i&lt;second) swap(A[i], A[second--]); while (A[i]==0 &amp;&amp; i&gt;zero) swap(A[i], A[zero++]); &#125; &#125;&#125;; æˆ‘çš„å®žçŽ°ï¼š leftå®šä¹‰ä¸ºæŒ‡å‘0çš„æŒ‡é’ˆï¼Œrightä¸º2 iæ˜¯éåŽ†çš„æŒ‡é’ˆæŒ‡å‘çš„ä½ç½®ï¼Œä»Ž0å¼€å§‹ã€‚ å¦‚æžœnums[i]ç­‰äºŽ0ï¼Œ åˆ™å‰é¢leftæŒ‡å‘0çš„å°¾éƒ¨ï¼Œleftå³è¾¹æ˜¯1ï¼Œ äº¤æ¢nums[i]ä¸Žnums[++left]ï¼Œnums[i]=1äº†ç›¸å½“äºŽï¼Œnum[++left]=0 å¦‚æžœnums[i]ä¸º2ï¼Œåˆ™ä¸Žå°¾éƒ¨äº¤æ¢ã€‚ç”±äºŽäº¤æ¢åŽçš„ç»“æžœä¸ç¡®å®šæ˜¯å‡  æ‰€ä»¥æ­¤å¤„iä¸å¢žåŠ  å¦‚æžœnums[i]ä¸º1ï¼Œåˆ™é»˜é»˜å¢žåŠ iå°±è¡Œäº†ã€‚ leftï¼Œrightçš„åˆå§‹å®šä¹‰å€¼ï¼Œå€Ÿé‰´çš„æ˜¯ç®—æ³•å¯¼è®ºé‡Œçš„æ–¹æ³•ã€‚ 1234567891011121314151617181920class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return; int left = -1, right = n; int i = 0; while(i&lt;right)&#123; if(nums[i]==0)&#123; swap(nums[++left], nums[i]); i++; &#125;else if(nums[i]==2)&#123; swap(nums[--right], nums[i]); &#125;else if(nums[i]==1)&#123; i++; &#125; &#125; return; &#125;&#125;; cpp https://discuss.leetcode.com/topic/5422/share-my-one-pass-constant-space-10-line-solution Share my one pass constant space 10-line solution The idea is to sweep all 0s to the left and all 2s to the right, then all 1s are left in the middle. 12345678910class Solution &#123;public: void sortColors(int A[], int n) &#123; int second=n-1, zero=0; for (int i=0; i&lt;=second; i++) &#123; while (A[i]==2 &amp;&amp; i&lt;second) swap(A[i], A[second--]); while (A[i]==0 &amp;&amp; i&gt;zero) swap(A[i], A[zero++]); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/6968/four-different-solutions Four different solutions 1234567891011121314// two pass O(m+n) spacevoid sortColors(int A[], int n) &#123; int num0 = 0, num1 = 0, num2 = 0; for(int i = 0; i &lt; n; i++) &#123; if (A[i] == 0) ++num0; else if (A[i] == 1) ++num1; else if (A[i] == 2) ++num2; &#125; for(int i = 0; i &lt; num0; ++i) A[i] = 0; for(int i = 0; i &lt; num1; ++i) A[num0+i] = 1; for(int i = 0; i &lt; num2; ++i) A[num0+num1+i] = 2;&#125; 123456789101112131415161718// one pass in place solutionvoid sortColors(int A[], int n) &#123; int n0 = -1, n1 = -1, n2 = -1; for (int i = 0; i &lt; n; ++i) &#123; if (A[i] == 0) &#123; A[++n2] = 2; A[++n1] = 1; A[++n0] = 0; &#125; else if (A[i] == 1) &#123; A[++n2] = 2; A[++n1] = 1; &#125; else if (A[i] == 2) &#123; A[++n2] = 2; &#125; &#125;&#125; 12345678910// one pass in place solutionvoid sortColors(int A[], int n) &#123; int j = 0, k = n - 1; for (int i = 0; i &lt;= k; ++i)&#123; if (A[i] == 0 &amp;&amp; i != j) swap(A[i--], A[j++]); else if (A[i] == 2 &amp;&amp; i != k) swap(A[i--], A[k--]); &#125;&#125; 12345678910// one pass in place solutionvoid sortColors(int A[], int n) &#123; int j = 0, k = n-1; for (int i=0; i &lt;= k; i++) &#123; if (A[i] == 0) swap(A[i], A[j++]); else if (A[i] == 2) swap(A[i--], A[k--]); &#125;&#125; https://discuss.leetcode.com/topic/36832/sharing-c-solution-with-good-explanation Sharing C++ solution with Good Explanation The solution requires the use of tracking 3 positions, the Low, Mid and High. We assume that the mid is the â€œUnknownâ€ area that we must evaluate. If we encounter a 0, we know that it will be on the low end of the array, and if we encounter a 2, we know it will be on the high end of the array. To achieve this in one pass without preprocessing (counting), we simply traverse the unknown will generating the low and high ends. Take this example: Assume our input is: 1 0 2 2 1 0 (short for simplicity). Running the algorithm by hand would look something like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647481 0 2 2 1 0^ ^L HMMid != 0 || 2Mid++1 0 2 2 1 0^ ^ ^L M HMid == 0Swap Low and MidMid++Low++0 1 2 2 1 0 ^ ^ ^ L M HMid == 2Swap High and MidHigh--0 1 0 2 1 2 ^ ^ ^ L M HMid == 0Swap Low and MidMid++Low++0 0 1 2 1 2 ^ ^ ^ L M HMid == 2Swap High and MidHigh--0 0 1 1 2 2 ^ ^ L M HMid &lt;= High is our exit case Implemented in C++, it looks like: 123456789101112131415161718192021222324252627282930class Solution &#123; public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int tmp = 0, low = 0, mid = 0, high = nums.size() - 1; while(mid &lt;= high) &#123; if(nums[mid] == 0) &#123; tmp = nums[low]; nums[low] = nums[mid]; nums[mid] = tmp; low++; mid++; &#125; else if(nums[mid] == 1) &#123; mid++; &#125; else if(nums[mid] == 2) &#123; tmp = nums[high]; nums[high] = nums[mid]; nums[mid] = tmp; high--; &#125; &#125; &#125;&#125;; my code: 1234567891011121314151617181920212223class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int lo = 0; int hi = nums.size()-1; int i=0; while(i&lt;=hi)&#123; if(nums[i]==2)&#123; swap(nums[i], nums[hi]); hi--; &#125; if(nums[i]==0)&#123; swap(nums[i], nums[lo]); lo++; i++; &#125; if(nums[i]==1)&#123; i++; &#125; &#125; return; &#125;&#125;; python https://discuss.leetcode.com/topic/26181/ac-python-in-place-one-pass-solution-o-n-time-o-1-space-no-swap-no-count AC Python in place one pass solution O(n) time O(1) space, no swap no count 12345678910111213141516def sortColors(self, nums): i = j = 0 for k in xrange(len(nums)): v = nums[k] nums[k] = 2 if v &lt; 2: nums[j] = 1 j += 1 if v == 0: nums[i] = 0 i += 1# 86 / 86 test cases passed.# Status: Accepted# Runtime: 44 ms# 84.03% Just like the Lomuto partition algorithm usually used in quick sort. We keep a loop invariant that [0,i) [i, j) [j, k) are 0s, 1s and 2s sorted in place for [0,k). Here â€œ)â€ means exclusive. We donâ€™t need to swap because we know the values we want. java https://discuss.leetcode.com/topic/19201/java-solution-both-2-pass-and-1-pass Java solution, both 2-pass and 1-pass 2-pass ä¸¤æ¬¡éåŽ†1-pass ä¸€æ¬¡éåŽ† 123456789101112131415161718public void sortColors(int[] nums) &#123; // 1-pass int p1 = 0, p2 = nums.length - 1, index = 0; while (index &lt;= p2) &#123; if (nums[index] == 0) &#123; nums[index] = nums[p1]; nums[p1] = 0; p1++; &#125; if (nums[index] == 2) &#123; nums[index] = nums[p2]; nums[p2] = 2; p2--; index--; &#125; index++; &#125;&#125; 1234567891011121314public void sortColors(int[] nums) &#123; // 2-pass int count0 = 0, count1 = 0, count2 = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == 0) &#123;count0++;&#125; if (nums[i] == 1) &#123;count1++;&#125; if (nums[i] == 2) &#123;count2++;&#125; &#125; for(int i = 0; i &lt; nums.length; i++) &#123; if (i &lt; count0) &#123;nums[i] = 0;&#125; else if (i &lt; count0 + count1) &#123;nums[i] = 1;&#125; else &#123;nums[i] = 2;&#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[074. Search a 2D Matrix]]></title>
    <url>%2Fp%2F5049e182%2F</url>
    <content type="text"><![CDATA[35.1% https://leetcode.com/problems/search-a-2d-matrix/ Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. 12345678910For example,Consider the following matrix:[ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]Given target = 3, return true. æ–¹æ³•ä¸€ï¼š äºŒåˆ†æœç´¢ æˆ‘çš„å®žçŽ° 12345678910111213141516171819202122class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int m = matrix.size(); if(m==0) return false; int n = matrix[0].size(); if(n==0) return false; if(target&lt;matrix[0][0] || target&gt;matrix[m-1][n-1]) return false; int left = 0, right = m*n-1; while(left&lt;=right)&#123; int mid = left + (right-left)/2; if(matrix[mid/n][mid%n]==target) return true; else if(matrix[mid/n][mid%n]&gt;target) right = mid-1; else left = mid + 1; &#125; return false; &#125;&#125;; cpp 12ms, 24.93%, June.21th, 2016 https://leetcode.com/discuss/10735/dont-treat-it-as-a-2d-matrix-just-treat-it-as-a-sorted-list 12345678910111213141516class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int target) &#123; int n = matrix.size(); int m = matrix[0].size(); int l = 0, r = m * n - 1; while (l != r)&#123; int mid = (l + r - 1) &gt;&gt; 1; if (matrix[mid / m][mid % m] &lt; target) l = mid + 1; else r = mid; &#125; return matrix[r / m][r % m] == target; &#125;&#125;; Solution Mime: 12ms, 24.93%, June.21th, 2016 123456789101112131415161718class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int target) &#123; int n = matrix.size(); int m = matrix[0].size(); int l = 0, r = m * n - 1; while (l != r)&#123; int mid = (l + r - 1) &gt;&gt; 1; if (matrix[mid / m][mid % m] &lt; target) l = mid + 1; else if(matrix[mid / m][mid % m] &gt; target) r = mid; else return true; &#125; return matrix[r / m][r % m] == target; &#125;&#125;; python Solution Mine: 52ms, 65.89%, June.21th, 2016 123456789101112class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; for i in xrange(len(matrix)): for j in xrange(len(matrix[0])): if target == matrix[i][j]: return True return False 60ms, 31.27%, June.21th, 2016 https://leetcode.com/discuss/28208/a-python-binary-search-solution-o-logn 123456789101112131415161718192021222324class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; if not matrix or target is None: return False rows, cols = len(matrix), len(matrix[0]) low, high = 0, rows * cols - 1 while low &lt;= high: mid = (low + high) / 2 num = matrix[mid / cols][mid % cols] if num == target: return True elif num &lt; target: low = mid + 1 else: high = mid - 1 return False Solution Mine: 48ms, 85.27%, June.21th, 2016 1234567891011121314151617181920212223242526class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; if not matrix or target is None: return False if target &lt; matrix[0][0] or target &gt; matrix[-1][-1]: return False rows, cols = len(matrix), len(matrix[0]) low, high = 0, rows * cols - 1 while low &lt;= high: mid = (low + high) / 2 num = matrix[mid / cols][mid % cols] if num == target: return True elif num &lt; target: low = mid + 1 else: high = mid - 1 return False java 1ms, 6.12%, June.21th, 2016 https://leetcode.com/discuss/15379/binary-search-on-an-ordered-matrix 123456789101112131415161718192021public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int row_num = matrix.length; int col_num = matrix[0].length; int begin = 0, end = row_num * col_num - 1; while(begin &lt;= end)&#123; int mid = (begin + end) / 2; int mid_value = matrix[mid / col_num][mid % col_num]; if(mid_value == target) return true; else if(mid_value &lt; target) begin = mid + 1; else end = mid - 1; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[073. Set Matrix Zeroes]]></title>
    <url>%2Fp%2F87522f31%2F</url>
    <content type="text"><![CDATA[36.0% https://leetcode.com/problems/set-matrix-zeroes/ Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. Follow up: Did you use extra space? A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? è²Œä¼¼å‰‘æŒ‡offerï¼Ÿ æ–¹æ³•ä¸€ï¼š ä¿å­˜æ‰€æœ‰ç»“æžœåˆ°ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—ï¼ŒéåŽ†éžç¬¬ä¸€è¡Œï¼Œéžç¬¬ä¸€åˆ—ï¼Œåªè¦æœ‰å‡ºçŽ°0çš„å°±è®¾ç½®ä¸º0ã€‚ è‡³äºŽç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—è¦ä¸è¦è®¾ç½®ä¸º0ï¼Œå¯ä»¥è®¾ç½®ä¸¤ä¸ªæ ‡å¿—æ¥åˆ¤æ–­ã€‚ https://discuss.leetcode.com/topic/5056/any-shorter-o-1-space-solution Any shorter O(1) space solution? My idea is simple: store states of each row in the first of that row, and store states of each column in the first of that column. Because the state of row0 and the state of column0 would occupy the same cell, I let it be the state of row0, and use another variable â€œcol0â€ for column0. In the first phase, use matrix elements to set states in a top-down way. In the second phase, use states to set matrix elements in a bottom-up way. 1234567891011121314151617void setZeroes(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int col0 = 1, rows = matrix.size(), cols = matrix[0].size(); for (int i = 0; i &lt; rows; i++) &#123; if (matrix[i][0] == 0) col0 = 0; for (int j = 1; j &lt; cols; j++) if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0; &#125; for (int i = rows - 1; i &gt;= 0; i--) &#123; for (int j = cols - 1; j &gt;= 1; j--) if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0; if (col0 == 0) matrix[i][0] = 0; &#125;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š å¤šä¸ªå¾ªçŽ¯ï¼Œç¬¬ä¸€è¡Œï¼Œç¬¬ä¸€åˆ—ï¼Œéžç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—ï¼Œä¸‰ä¸ªå¾ªçŽ¯ï¼Œæ¸…æ™°æ˜Žäº†ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return; int row0 = 1, col0 = 1; int rows = matrix.size(), cols = matrix[0].size(); for(int i=0; i&lt;cols; i++)&#123; if(matrix[0][i]==0)&#123; row0 = 0; break; &#125; &#125; for(int i=0; i&lt;rows; i++)&#123; if(matrix[i][0]==0)&#123; col0 = 0; break; &#125; &#125; for(int i=1; i&lt;rows; i++)&#123; for(int j=1; j&lt;cols; j++)&#123; if(matrix[i][j]==0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; for(int i=1; i&lt;rows; i++)&#123; for(int j=1; j&lt;cols; j++)&#123; if(matrix[i][0]==0 || matrix[0][j]==0) matrix[i][j] = 0; &#125; &#125; if(row0==0)&#123; for(int i=0; i&lt;cols; i++) matrix[0][i] = 0; &#125; if(col0==0)&#123; for(int i=0; i&lt;rows; i++) matrix[i][0] = 0; &#125; return; &#125;&#125;; https://discuss.leetcode.com/topic/7087/my-c-o-1-yoooooo My C++ O(1) yoooooo I find the last row which has 0, and use it to store the 0-collumns. Then go row by row set them to 0. Then go column by column set them to 0. Finally set the last row which has 0. Itâ€™s long but hey itâ€™s O(1) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int H = matrix.size(); int W = matrix[0].size(); // find the last 0 row int last_0_row = -1; for (int y = H - 1; y &gt;= 0 &amp;&amp; last_0_row == -1; y--) for (int x = 0; x &lt; W; x++) if (matrix[y][x] == 0) &#123; last_0_row = y; break; &#125; if (last_0_row == -1) return; // go row by row for (int y = 0; y &lt; last_0_row; y++) &#123; bool this_is_a_0_row = false; for (int x = 0; x &lt; W; x++) &#123; if (matrix[y][x] == 0) &#123; this_is_a_0_row = true; matrix[last_0_row][x] = 0; &#125; &#125; if (this_is_a_0_row) for (int x = 0; x &lt; W; x++) &#123; matrix[y][x] = 0; &#125; &#125; // set collums to 0 for (int y = 0; y &lt; H; y++) for (int x = 0; x &lt; W; x++) &#123; if (matrix[last_0_row][x] == 0) matrix[y][x] = 0; &#125; // set the last 0 row for (int x = 0; x &lt; W; x++) &#123; matrix[last_0_row][x] = 0; &#125; &#125;&#125;; python 188ms, 49.31%, June.18th, 2016 https://leetcode.com/discuss/49003/o-1-space-solution-in-python O(1) space solution in Python 12345678910111213141516171819202122232425262728293031323334353637383940class Solution:# @param &#123;integer[][]&#125; matrix# @return &#123;void&#125; Do not return anything, modify matrix in-place instead.def setZeroes(self, matrix): m = len(matrix) if m == 0: return n = len(matrix[0]) row_zero = False for i in range(m): if matrix[i][0] == 0: row_zero = True col_zero = False for j in range(n): if matrix[0][j] == 0: col_zero = True for i in range(1, m): for j in range(1, n): if matrix[i][j] == 0: matrix[i][0] = 0 matrix[0][j] = 0 for i in range(1, m): if matrix[i][0] == 0: for j in range(1, n): matrix[i][j] = 0 for j in range(1, n): if matrix[0][j] == 0: for i in range(1, m): matrix[i][j] = 0 if col_zero: for j in range(n): matrix[0][j] = 0 if row_zero: for i in range(m): matrix[i][0] = 0 java https://discuss.leetcode.com/topic/15193/my-ac-java-o-1-solution-easy-to-read My AC java O(1) solution (easy to read) 123456789101112131415161718192021222324252627282930313233public class Solution &#123;public void setZeroes(int[][] matrix) &#123; boolean fr = false,fc = false; for(int i = 0; i &lt; matrix.length; i++) &#123; for(int j = 0; j &lt; matrix[0].length; j++) &#123; if(matrix[i][j] == 0) &#123; if(i == 0) fr = true; if(j == 0) fc = true; matrix[0][j] = 0; matrix[i][0] = 0; &#125; &#125; &#125; for(int i = 1; i &lt; matrix.length; i++) &#123; for(int j = 1; j &lt; matrix[0].length; j++) &#123; if(matrix[i][0] == 0 || matrix[0][j] == 0) &#123; matrix[i][j] = 0; &#125; &#125; &#125; if(fr) &#123; for(int j = 0; j &lt; matrix[0].length; j++) &#123; matrix[0][j] = 0; &#125; &#125; if(fc) &#123; for(int i = 0; i &lt; matrix.length; i++) &#123; matrix[i][0] = 0; &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/8807/my-java-o-1-solution-easy-to-understand My java O(1) solution (easy to understand) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Solution &#123; public void setZeroes(int[][] matrix) &#123; if(matrix==null)&#123; return; &#125; int m = matrix.length; int n = matrix[0].length; boolean rowHasZero = false; boolean colHasZero = false; for(int i=0; i&lt;n; i++)&#123; if(matrix[0][i]==0)&#123; rowHasZero = true; break; &#125; &#125; for(int i=0; i&lt;m; i++)&#123; if(matrix[i][0]==0)&#123; colHasZero = true; break; &#125; &#125; for(int i=1; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; if(matrix[i][j]==0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; for(int j=1;j&lt;n; j++)&#123; if(matrix[0][j]==0)&#123; nullifyCol(matrix, j, m, n); &#125; &#125; for(int i=1; i&lt;m; i++)&#123; if(matrix[i][0]==0)&#123; nullifyRow(matrix, i, m, n); &#125; &#125; if(rowHasZero)&#123; nullifyRow(matrix, 0, m, n); &#125; if(colHasZero)&#123; nullifyCol(matrix, 0, m, n); &#125; &#125; public void nullifyRow(int[][] matrix, int i, int m, int n)&#123; for(int col=0; col&lt;n; col++)&#123; matrix[i][col] = 0; &#125; &#125; public void nullifyCol(int[][] matrix, int j, int m, int n)&#123; for(int row=0; row&lt;m; row++)&#123; matrix[row][j] = 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[072. Edit Distance]]></title>
    <url>%2Fp%2F8e0e9f97%2F</url>
    <content type="text"><![CDATA[30.9% https://leetcode.com/problems/edit-distance/ Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) 12345You have the following 3 operations permitted on a word:a) Insert a characterb) Delete a characterc) Replace a character æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.size(); int n = word2.size(); if(n==0) return m; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=0; i&lt;m+1; i++) dp[i][0] = i; for(int j=0; j&lt;n+1; j++) dp[0][j] = j; for(int i=1; i&lt;m+1; i++)&#123; for(int j=1; j&lt;n+1; j++)&#123; if(word1[i-1] != word2[j-1]) dp[i][j] = min(min(dp[i][j-1], dp[i-1][j]), dp[i-1][j-1]) + 1; else dp[i][j] = dp[i-1][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; æ ¹æ®é¢˜ç›®åˆ†æžé—®é¢˜ï¼Œç„¶åŽåŠ¨æ€è§„åˆ’è§£å†³é—®é¢˜ï¼Œå¾ˆå¸¸è§„çš„ä¸€ç±» ä»Žä¸­å®šä¹‰æ¨¡å¼ï¼Œä¸¤ä¸ªçš„è¯ï¼Œå®šä¹‰ï¼ˆm+1ï¼‰*ï¼ˆn+1ï¼‰çš„æ•°ç»„ 19ms, 70.83%, September 21, 2016 https://discuss.leetcode.com/topic/17639/20ms-detailed-explained-c-solutions-o-n-space This is a classic problem of Dynamic Programming. We define the state dp[i][j] to be the minimum number of operations to convert word1[0..i - 1] to word2[0..j - 1]. The state equations have two cases: the boundary case and the general case. Note that in the above notations, both i and j take values starting from 1. For the boundary case, that is, to convert a string to an empty string, it is easy to see that the mininum number of operations to convert word1[0..i - 1] to â€œâ€ requires at least i operations (deletions). In fact, the boundary case is simply: dp[i][0] = i; dp[0][j] = j. Now letâ€™s move on to the general case, that is, convert a non-empty word1[0..i - 1] to another non-empty word2[0..j - 1]. Well, letâ€™s try to break this problem down into smaller problems (sub-problems). Suppose we have already known how to convert word1[0..i - 2] to word2[0..j - 2], which is dp[i - 1][j - 1]. Now letâ€™s consider word[i - 1] and word2[j - 1]. If they are euqal, then no more operation is needed and dp[i][j] = dp[i - 1][j - 1]. Well, what if they are not equal? If they are not equal, we need to consider three cases: Replace word1[i - 1] by word2[j - 1] (dp[i][j] = dp[i - 1][j - 1] + 1 (for replacement)); Delete word1[i - 1] and word1[0..i - 2] = word2[0..j - 1] (dp[i][j] = dp[i - 1][j] + 1 (for deletion)); Insert word2[j - 1] to word1[0..i - 1] and word1[0..i - 1] + word2[j - 1] = word2[0..j - 1] (dp[i][j] = dp[i][j - 1] + 1 (for insertion)). Make sure you understand the subtle differences between the equations for deletion and insertion. For deletion, we are actually converting word1[0..i - 2] to word2[0..j - 1], which costs dp[i - 1][j], and then deleting the word1[i - 1], which costs 1. The case is similar for insertion. Putting these together, we now have: dp[i][0] = i; dp[0][j] = j; dp[i][j] = dp[i - 1][j - 1], if word1[i - 1] = word2[j - 1]; dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1), otherwise. The above state equations can be turned into the following code directly. 123456789101112131415161718class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.length(), n = word2.length(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=1; i&lt;=m; i++) dp[i][0] = i; for(int j=1; j&lt;=n; j++) dp[0][j] = j; for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = min(dp[i-1][j-1]+1, min(dp[i][j-1]+1, dp[i-1][j]+1)); return dp[m][n]; &#125;&#125;; æ–¹æ³•äºŒï¼š æˆ‘çš„ä»£ç å®žçŽ° dp[i][j],åªæœ‰ä¸‰æ¡è·¯å¯ä»¥èµ°ï¼Œä¸€ä¸ªæ˜¯ä»Ždp[i-1][j-1]ä¸ç›¸ç­‰æ›¿æ¢ ç›¸ç­‰å°±ä¸å˜ï¼Œ ä¸€ä¸ªæ˜¯dp[i][j-1]å¢žåŠ æˆ–åˆ é™¤ï¼Œä¸€ä¸ªæ˜¯dp[i-1][j]å¢žåŠ æˆ–åˆ é™¤ æœ‰ä¸¤ä¸ªstringçš„æ—¶å€™ï¼Œé•¿åº¦åˆ†åˆ«æ˜¯må’Œnï¼Œè¦ç‰¹åˆ«åˆ†æ¸…åˆ°åº•å“ªä¸ªæ˜¯mï¼Œå“ªä¸ªæ˜¯n 12345678910111213141516171819class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.size(); int n = word2.size(); if(n==0) return m; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=0; i&lt;m+1; i++) dp[i][0] = i; for(int j=0; j&lt;n+1; j++) dp[0][j] = j; for(int i=1; i&lt;m+1; i++)&#123; for(int j=1; j&lt;n+1; j++)&#123; dp[i][j] = min(min(dp[i][j-1], dp[i-1][j])+1, word1[i-1]==word2[j-1]?dp[i-1][j-1]:dp[i-1][j-1]+1); &#125; &#125; return dp[m][n]; &#125;&#125;; 13ms, 86.67%, September 21, 2016 https://discuss.leetcode.com/topic/17639/20ms-detailed-explained-c-solutions-o-n-space Well, you may have noticed that each time when we update dp[i][j], we only need dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]. In fact, we need not maintain the full m*n matrix. Instead, maintaing one column is enough. The code can be optimized to O(m) or O(n) space, depending on whether you maintain a row or a column of the original matrix. The optimized code is as follows. 12345678910111213141516171819202122class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.length(), n = word2.length(); vector&lt;int&gt; cur(m+1, 0); for(int i=1; i&lt;=m; i++) cur[i] = i; for(int j=1; j&lt;=n; j++)&#123; int pre = cur[0]; cur[0] = j; for(int i=1; i&lt;=m; i++)&#123; int temp = cur[i]; if(word1[i-1] == word2[j-1]) cur[i] = pre; else cur[i] = min(pre+1, min(cur[i]+1, cur[i-1]+1)); pre = temp; &#125; &#125; return cur[m]; &#125;&#125;; Well, if you find the above code hard to understand, you may first try to write a two-column version that explicitly maintains two columns (the previous column and the current column) and then simplify the two-column version into the one-column version like the above code :-) python 256ms, 35.52%, September 21, 2016 https://discuss.leetcode.com/topic/19877/python-solutions-o-m-n-o-n-space O(m*n) space 1234567891011121314151617class Solution(object): def minDistance(self, word1, word2): &quot;&quot;&quot; :type word1: str :type word2: str :rtype: int &quot;&quot;&quot; l1, l2 = len(word1)+1, len(word2)+1 dp = [[0 for _ in xrange(l2)] for _ in xrange(l1)] for i in xrange(l1): dp[i][0] = i for j in xrange(l2): dp[0][j] = j for i in xrange(1, l1): for j in xrange(1, l2): dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+(word1[i-1]!=word2[j-1])) return dp[-1][-1] 262ms, 32.79%, September 21, 2016 https://discuss.leetcode.com/topic/19877/python-solutions-o-m-n-o-n-space O(n) space with rolling array1234567891011121314151617class Solution(object): def minDistance(self, word1, word2): &quot;&quot;&quot; :type word1: str :type word2: str :rtype: int &quot;&quot;&quot; l1, l2 = len(word1)+1, len(word2)+1 pre = [0 for _ in xrange(l2)] for j in xrange(l2): pre[j] = j for i in xrange(1, l1): cur = [i]*l2 for j in xrange(1, l2): cur[j] = min(cur[j-1]+1, pre[j]+1, pre[j-1]+(word1[i-1] != word2[j-1])) pre = cur[:] return pre[-1] java 16ms, 31.71%, September 21, 2016 https://discuss.leetcode.com/topic/20922/java-dp-solution-o-nm Let following be the function definition :- 1234567891011f(i, j) := minimum cost (or steps) required to convert first i characters of word1 to first j characters of word2Case 1: word1[i] == word2[j], i.e. the ith the jth character matches.f(i, j) = f(i - 1, j - 1)Case 2: word1[i] != word2[j], then we must either insert, delete or replace, whichever is cheaperf(i, j) = 1 + min &#123; f(i, j - 1), f(i - 1, j), f(i - 1, j - 1) &#125;1. f(i, j - 1) represents insert operation2. f(i - 1, j) represents delete operation3. f(i - 1, j - 1) represents replace operation Here, we consider any operation from word1 to word2. It means, when we say insert operation, we insert a new character after word1 that matches the jth character of word2. So, now have to match i characters of word1 to j - 1 characters of word2. Same goes for other 2 operations as well. Note that the problem is symmetric. The insert operation in one direction (i.e. from word1 to word2) is same as delete operation in other. So, we could choose any direction. Above equations become the recursive definitions for DP. Base Case: 1f(0, k) = f(k, 0) = k Below is the direct bottom-up translation of this recurrent relation. It is only important to take care of 0-based index with actual code :- Time complexity : If n is the length of word1, m of word2, because of the two indented loops, it is O(nm)123456789101112131415161718192021222324252627public class Solution &#123; public int minDistance(String word1, String word2) &#123; int m = word1.length(); int n = word2.length(); int[][] cost = new int[m+1][n+1]; for(int i=0; i&lt;=m; i++) cost[i][0] = i; for(int j=0; j&lt;=n; j++) cost[0][j] = j; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(word1.charAt(i) == word2.charAt(j)) cost[i+1][j+1] = cost[i][j]; else&#123; int a = cost[i][j]; int b = cost[i][j+1]; int c = cost[i+1][j]; cost[i+1][j+1] = a &lt; b?(a&lt;c?a:c):(b&lt;c?b:c); cost[i+1][j+1]++; &#125; &#125; &#125; return cost[m][n]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[071. Simplify Path]]></title>
    <url>%2Fp%2F6cd51db6%2F</url>
    <content type="text"><![CDATA[25.4% https://leetcode.com/problems/simplify-path/ Given an absolute path for a file (Unix-style), simplify it. 123For example,path = &quot;/home/&quot;, =&gt; &quot;/home&quot;path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot; Corner Cases: Did you consider the case where path = â€œ/../â€œ? In this case, you should return â€œ/â€œ. Another corner case is the path might contain multiple slashes â€˜/â€˜ together, such as â€œ/home//foo/â€œ. In this case, you should ignore redundant slashes and return â€œ/home/fooâ€. æ–¹æ³•ä¸€ï¼š https://discuss.leetcode.com/topic/2872/my-o-n-ac-code-just-need-to-handle-two-special-cases My O(n) AC code . just need to handle two special cases. traverse the string to record each folder name. two special cases: a.double dot:pop one. b.single dot: do nothing (don`t push it). 123456789101112131415161718192021222324252627string simplifyPath(string path) &#123; vector&lt;string&gt; nameVect; string name; path.push_back(&apos;/&apos;); for(int i=0;i&lt;path.size();i++)&#123; if(path[i]==&apos;/&apos;)&#123; if(name.size()==0)continue; if(name==&quot;..&quot;)&#123; //special case 1ï¼šdouble dotï¼Œpop dir if(nameVect.size()&gt;0)nameVect.pop_back(); &#125;else if(name==&quot;.&quot;)&#123;//special case 2:singel dotï¼Œdon`t push &#125;else&#123; nameVect.push_back(name); &#125; name.clear(); &#125;else&#123; name.push_back(path[i]);//record the name &#125; &#125; string result; if(nameVect.empty())return &quot;/&quot;; for(int i=0;i&lt;nameVect.size();i++)&#123; result.append(&quot;/&quot;+nameVect[i]); &#125; return result;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š stringçš„å‡½æ•°clearï¼Œappendï¼Œpush_back ç»™å®šçš„å­—ç¬¦ä¸²å¯ä»¥æ›´æ”¹çš„ 1234567891011121314151617181920212223242526class Solution &#123;public: string simplifyPath(string path) &#123; vector&lt;string&gt; v; string name = ""; path.push_back('/'); // é’ˆå¯¹åŽŸæœ‰stringçš„é¦–æˆ–å°¾è¿›è¡Œæ”¹å˜ï¼Œè¿™æ˜¯ä¸€ç§æ€è·¯ int n = path.size(); // é•¿åº¦æ”¹å˜äº†ï¼Œæ‰€ä»¥è¦åœ¨æ”¹å˜åŽæ±‚é•¿åº¦ï¼Œå¦åˆ™ä¸å¯¹çš„ for(int i=0; i&lt;n; i++)&#123; if(path[i]=='/')&#123; if(name=="") continue; // ä¸‹é¢çš„å¤§æ‹¬å·å¤–ï¼Œä¸è¦åˆ†å·çš„ else if(name==".")&#123;&#125; //æ­¤å¤„ä¸èƒ½continueï¼Œå› ä¸ºè¦æ¸…ç©ºnameï¼Œæ‰ä¸‹ä¸€æ­¥ else if(name=="..") &#123; if(!v.empty()) v.pop_back();&#125; else v.push_back(name); name.clear(); // æ­¤å¤„å­¦ä¼šé’ˆå¯¹stringçš„clear &#125;else&#123; name.push_back(path[i]); &#125; &#125; string res = ""; for(int i=0; i&lt;v.size(); i++) res.append("/" + v[i]); return v.empty()? "/" : res; &#125;&#125;; cpp 6ms, September 11, 2016 https://discuss.leetcode.com/topic/8678/c-10-lines-solution C++ 10-lines solution C++ also have getline which acts like Javaâ€™s split. I guess the code can comment itself. 123456789101112131415class Solution &#123;public: string simplifyPath(string path) &#123; string res, tmp; vector&lt;string&gt; stk; stringstream ss(path); while(getline(ss, tmp, &apos;/&apos;))&#123; if(tmp == &quot;&quot; or tmp == &quot;.&quot;) continue; if(tmp == &quot;..&quot; and !stk.empty()) stk.pop_back(); else if(tmp!=&quot;..&quot;) stk.push_back(tmp); &#125; for(auto str:stk) res += &quot;/&quot; + str; return res.empty() ? &quot;/&quot; : res; &#125;&#125;; python 82ms, September 11, 2016 https://discuss.leetcode.com/topic/41158/9-line-python-solution-easy-to-understand 9-line Python solution, easy to understand 12345678910111213141516class Solution(object): def simplifyPath(self, path): &quot;&quot;&quot; :type path: str :rtype: str &quot;&quot;&quot; stack = [] for token in path.split(&apos;/&apos;): if token in (&apos;&apos;, &apos;.&apos;): pass elif token == &apos;..&apos;: if stack: stack.pop() else: stack.append(token) return &apos;/&apos; + &apos;/&apos;.join(stack) java 18ms, September 11, 2016 https://discuss.leetcode.com/topic/7675/java-10-lines-solution-with-stack Java 10-lines solution with stack Hi guys! The main idea is to push to the stack every valid file name (not in {â€œâ€,â€.â€,â€..â€}), popping only if thereâ€™s smth to pop and we met â€œ..â€. I donâ€™t feel like the code below needs any additional comments. 12345678910111213public class Solution &#123; public String simplifyPath(String path) &#123; Deque&lt;String&gt; stack = new LinkedList&lt;&gt;(); Set&lt;String&gt; skip = new HashSet&lt;&gt;(Arrays.asList(&quot;..&quot;, &quot;.&quot;, &quot;&quot;)); for(String dir : path.split(&quot;/&quot;))&#123; if(dir.equals(&quot;..&quot;) &amp;&amp; !stack.isEmpty()) stack.pop(); else if(!skip.contains(dir)) stack.push(dir); &#125; String res = &quot;&quot;; for(String dir:stack) res = &quot;/&quot; + dir + res; return res.isEmpty()? &quot;/&quot; : res; &#125;&#125; https://discuss.leetcode.com/topic/7014/accepted-solution-using-deque Accepted solution using Deque I think using Deque is probably the most intuitive way to solve this problem. 12345678910111213141516171819202122232425262728293031323334/** * Deque of strings (directories). * iterate path: * if &quot;/&quot;, continue, * if &quot;.&quot;, conitnue, * if &quot;..&quot;, poll last, * else, add a new directory * in the end, build result from deque. */public String simplifyPath(String path) &#123; Deque&lt;String&gt; deque = new LinkedList&lt;String&gt;(); String[] splits = path.split(&quot;/&quot;); for (String split : splits) &#123; // CATCH: must use &quot;equals()&quot; instead of &quot;==&quot;, // because &apos;split&apos; is a variable! // Also, &apos;split&apos; could be empty string. if (split.equals(&quot;&quot;)) continue; else if (split.equals(&quot;.&quot;)) continue; else if (split.equals(&quot;..&quot;)) deque.pollLast(); else deque.addLast(split); &#125; StringBuilder builder = new StringBuilder(); while (!deque.isEmpty()) &#123; String s = deque.pollFirst(); builder.append(&quot;/&quot;).append(s); &#125; if (builder.length() == 0) return &quot;/&quot;; return builder.toString();&#125; https://discuss.leetcode.com/topic/12767/ac-solution-in-java AC Solution in Java 12345678910111213141516public class Solution &#123; public String simplifyPath(String path) &#123; Set&lt;String&gt; isSkip = new HashSet&lt;&gt;(Arrays.asList(&quot;&quot;, &quot;.&quot;, &quot;..&quot;)); Deque&lt;String&gt; stack = new ArrayDeque&lt;&gt;(); for (String token : path.split(&quot;/&quot;)) &#123; if (token.equals(&quot;..&quot;) &amp;&amp; !stack.isEmpty()) stack.pop(); if (isSkip.contains(token)) continue; stack.push(token); &#125; StringBuilder sb = new StringBuilder(); while (!stack.isEmpty()) &#123; sb.append(&quot;/&quot; + stack.pollLast()); &#125; return sb.length() == 0 ? &quot;/&quot; : sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[070. Climbing Stairs]]></title>
    <url>%2Fp%2Ff1d6ecb9%2F</url>
    <content type="text"><![CDATA[39.0% https://leetcode.com/problems/climbing-stairs/ You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? æ–¹æ³•ä¸€ï¼š 12345678910111213class Solution &#123;public: int climbStairs(int n) &#123; if(n&lt;0) return 0; int a=0, b=1; while(n--)&#123; int c = a+b; a = b; b = c; &#125; return b; &#125;&#125;; ç›¸ä¼¼é¢˜ï¼š æœ‰ä¸€æ¥¼æ¢¯å…±mçº§ï¼Œåˆšå¼€å§‹æ—¶ä½ åœ¨ç¬¬ä¸€çº§ï¼Œè‹¥æ¯æ¬¡åªèƒ½è·¨ä¸Šä¸€çº§æˆ–è€…äºŒçº§ï¼Œè¦èµ°ä¸Šmçº§ï¼Œå…±æœ‰å¤šå°‘èµ°æ³•ï¼Ÿæ³¨ï¼šè§„å®šä»Žä¸€çº§åˆ°ä¸€çº§æœ‰0ç§èµ°æ³•ã€‚ç»™å®šä¸€ä¸ªæ­£æ•´æ•°int nï¼Œè¯·è¿”å›žä¸€ä¸ªæ•°ï¼Œä»£è¡¨ä¸Šæ¥¼çš„æ–¹å¼æ•°ã€‚ä¿è¯nå°äºŽç­‰äºŽ100ã€‚ä¸ºäº†é˜²æ­¢æº¢å‡ºï¼Œè¯·è¿”å›žç»“æžœMod 1000000007çš„å€¼ã€‚ æµ‹è¯•æ ·ä¾‹ï¼š 3 è¿”å›žï¼š2 my code: 123456789101112131415class GoUpstairs &#123;public: int countWays(int n) &#123; // write code here long long a=1, b=1, i=1; long long c; while(i&lt;n)&#123; c = a; a = (a+b)%1000000007; b = (c)%1000000007; i++; &#125; return b; &#125;&#125;; å…¶ä¸­ï¼Œè¦æ±‚modå€¼ï¼Œåœ¨æœ€ç»ˆç»“æžœå¤„ä¼šæº¢å‡ºï¼Œæ‰€ä»¥åœ¨ä¸­é—´modã€‚ è§£æžhttps://discuss.leetcode.com/topic/17002/3-4-short-lines-in-every-language Same simple algorithm written in every offered language. Variable a tells you the number of ways to reach the current step, and b tells you the number of ways to reach the next step. So for the situation one step further up, the old b becomes the new a, and the new b is the old a+b, since that new step can be reached by climbing 1 step from what b represented or 2 steps from what a represented. Ruby wins, and â€œthe C languagesâ€ all look the same. java 123456public int climbStairs(int n) &#123; int a = 1, b = 1; while (n-- &gt; 0) a = (b += a) - a; return a;&#125; cpp 123456int climbStairs(int n) &#123; int a = 1, b = 1; while (n--) a = (b += a) - a; return a;&#125; python 12345def climbStairs(self, n): a = b = 1 for _ in range(n): a, b = b, a + b return a è¯„ä»·ï¼šnâ€“æ˜¯äº®ç‚¹ï¼Œä¸å¿…å•ç‹¬è®¾ç½®ä¸€ä¸ªå˜é‡i++ https://discuss.leetcode.com/topic/5371/basically-it-s-a-fibonacci Basically itâ€™s a fibonacci. The problem seems to be a dynamic programming one. Hint: the tag also suggests that!Here are the steps to get the solution incrementally. Base cases: if n &lt;= 0, then the number of ways should be zero. if n == 1, then there is only way to climb the stair. if n == 2, then there are two ways to climb the stairs. One solution is one step by another; the other one is two steps at one time. The key intuition to solve the problem is that given a number of stairs n, if we know the number ways to get to the points [n-1] and [n-2] respectively, denoted as n1 and n2 , then the total ways to get to the point [n] is n1 + n2. Because from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there. There is NO overlapping between these two solution sets, because we differ in the final step. Now given the above intuition, one can construct an array where each node stores the solution for each number n. Or if we look at it closer, it is clear that this is basically a fibonacci number, with the starting numbers as 1 and 2, instead of 1 and 1. The implementation in Java as follows: 1234567891011121314151617public int climbStairs(int n) &#123; // base cases if(n &lt;= 0) return 0; if(n == 1) return 1; if(n == 2) return 2; int one_step_before = 2; int two_steps_before = 1; int all_ways = 0; for(int i=2; i&lt;n; i++)&#123; all_ways = one_step_before + two_steps_before; two_steps_before = one_step_before; one_step_before = all_ways; &#125; return all_ways;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[069. Sqrt(x)]]></title>
    <url>%2Fp%2Fae863641%2F</url>
    <content type="text"><![CDATA[27.9% https://leetcode.com/problems/sqrtx/ Implement int sqrt(int x). Compute and return the square root of x. æ–¹æ³•ä¸€ï¼š åŸºæœ¬æ–¹æ³•ï¼ŒäºŒåˆ†æœç´¢ 1234567891011121314151617class Solution &#123;public: int sqrt(int x) &#123; if (0 == x) return 0; int left = 1, right = x, ans; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (mid &lt;= x / mid) &#123; left = mid + 1; ans = mid; &#125; else &#123; right = mid - 1; &#125; &#125; return ans; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return x; // å…ˆå¯¹ç‰¹æ®Šæƒ…å†µåˆ¤æ–­ int left=1, right=x, ans; while(left&lt;=right)&#123; // åˆ¤æ–­æ¡ä»¶left&lt;=right int mid = left + (right-left)/2; if(mid&lt;=x/mid)&#123; // å¦‚æžœmid*midå¯èƒ½è¶…å‡ºintèŒƒå›´ left = mid + 1; ans = mid; &#125;else&#123; right = mid - 1; &#125; &#125; return ans; &#125;&#125;; æ–¹æ³•äºŒï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return 0; double res = x; double delta = 0.0001; while(abs(pow(res, 2)-x)&gt;delta)&#123; res = (res + x/res)/2; &#125; return int(res); &#125;&#125;; 1234567891011f(x) = ans^2 - x = 0f&apos;(x) = 2*ans y = f&apos;(ans)*(nex - ans) + f(ans)y = 0=&gt; nex = ans - f(ans) / f&apos;(ans)è¿­ä»£æ–¹æ³• Newtonæ–¹æ³•ï¼Œè¿­ä»£ The key point is the average result is calculate by â€œans = (ans + x / ans) / 2â€; 12345678int sqrt(int x) &#123; double ans = x; double delta = 0.0001; while (fabs(pow(ans, 2) - x) &gt; delta) &#123; ans = (ans + x / ans) / 2; &#125; return ans;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return x; double ans = x; // æ³¨æ„æ­¤å¤„ç”¨çš„æ˜¯doubleï¼Œä¸æ˜¯int double delta = 0.0001; // ç”¨doubleï¼Œè€Œä¸æ˜¯int while(fabs(pow(ans,2) - x)&gt;delta)&#123; ans = (ans + x/ans)/2; &#125; return ans; &#125;&#125;; æ–¹æ³•ä¸‰ï¼š ç‰›é¡¿æ³•çš„å¦ä¸€ç§å®žçŽ° 12345678910class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return 0; long long r = x; while(r*r &gt; x) r = (r+x/r)/2; return r; &#125;&#125;; https://discuss.leetcode.com/topic/24532/3-4-short-lines-integer-newton-every-language 3-4 short lines, Integer Newton, Every Language Quite a few people used Newton already, but I didnâ€™t see someone make it this short. Same solution in every language. Explanation under the solutions. C++ and C 1234long r = x;while (r*r &gt; x) r = (r + x/r) / 2;return r; Python 1234r = xwhile r*r &gt; x: r = (r + x/r) / 2return r Java and C# 1234long r = x;while (r*r &gt; x) r = (r + x/r) / 2;return (int) r; Explanation Apparently, using only integer division for the Newton method works. And I guessed that if I start at x, the root candidate will decrease monotonically and never get too small. The above solutions all got accepted, and in C++ I also verified it locally on my PC for all possible inputs (0 to 2147483647): 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std;int mySqrt(int x) &#123; long long r = x; while (r*r &gt; x) r = (r + x/r) / 2; return r;&#125;int main() &#123; for (long long x=0; x&lt;=INT_MAX; ++x) &#123; long long r = mySqrt(x); if (r&lt;0 || r*r &gt; x || (r+1)*(r+1) &lt;= x) cout &lt;&lt; &quot;false: &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl; if (x % 10000000 == 0) cout &lt;&lt; x &lt;&lt; endl; &#125; cout &lt;&lt; &quot;all checked&quot; &lt;&lt; endl;&#125; https://discuss.leetcode.com/topic/1225/solve-this-problem-with-binary-search Solve this problem with Binary Search 1234567891011121314151617class Solution &#123;public: int sqrt(int x) &#123; if (0 == x) return 0; int left = 1, right = x, ans; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (mid &lt;= x / mid) &#123; left = mid + 1; ans = mid; &#125; else &#123; right = mid - 1; &#125; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/8689/newton-s-iterative-method-in-c Newtonâ€™s Iterative Method in C++ 12345678int sqrt(int x) &#123; double ans = x; double delta = 0.0001; while (fabs(pow(ans, 2) - x) &gt; delta) &#123; ans = (ans + x / ans) / 2; &#125; return ans;&#125; The key point is the average result is calculate by â€œans = (ans + x / ans) / 2â€; For instance, when calculate sqrt(2) : 12345Guess Result Quotient Average Result 1 2 / 1 = 2 (2 + 1) / 2 = 1.5 1.5 2 / 1.5 = 1.3333 (1.3333 + 1.5) / 2 = 1.4167 1.4167 2 / 1.4167 = 1.4118 (1.4167 + 1.4118) / 2 = 1.4142 ... ... https://discuss.leetcode.com/topic/19698/my-clean-c-code-8ms My clean C++ code 8ms Binary search and high is always converged to the one that 1 larger than the result. 123456789101112131415class Solution &#123;public: int mySqrt(int x) &#123; int low = 0, high = x, mid; if(x&lt;2) return x; // to avoid mid = 0 while(low&lt;high) &#123; mid = (low + high)/2; if(x/mid &gt;= mid) low = mid+1; else high = mid; &#125; return high-1; &#125;&#125;; python https://discuss.leetcode.com/topic/5472/newton-method-accepted-solution Newton method, accepted solution. 1234567891011class Solution:# @param x, an integer# @return an integerdef sqrt(self, x): i=1.0; while(True): j=(i+x/i)/2.0; if(abs(i-j)&lt; 0.000000000005): break; i=j; return int(j); java https://discuss.leetcode.com/topic/8680/a-binary-search-solution A Binary Search Solution Instead of using fancy Newtonâ€™s method, this plain binary search approach also works. 123456789101112131415public int sqrt(int x) &#123; if (x == 0) return 0; int left = 1, right = Integer.MAX_VALUE; while (true) &#123; int mid = left + (right - left)/2; if (mid &gt; x/mid) &#123; right = mid - 1; &#125; else &#123; if (mid + 1 &gt; x/(mid + 1)) return mid; left = mid + 1; &#125; &#125;&#125; https://discuss.leetcode.com/topic/2671/share-my-o-log-n-solution-using-bit-manipulation Share my O(log n) Solution using bit manipulation Basic Idea: Since sqrt(x) is composed of binary bits, I calculate sqrt(x) by deciding every bit from the most significant to least significant. Since an integer n can have O(log n) bits with each bit decided within constant time, this algorithm has time limit O(log n), actually, because an Integer can have at most 32 bits, I can also say this algorithm takes O(32)=O(1) time. 12345678910111213141516public int sqrt(int x) &#123; if(x==0) return 0; int h=0; while((long)(1&lt;&lt;h)*(long)(1&lt;&lt;h)&lt;=x) // firstly, find the most significant bit h++; h--; int b=h-1; int res=(1&lt;&lt;h); while(b&gt;=0)&#123; // find the remaining bits if((long)(res | (1&lt;&lt;b))*(long)(res |(1&lt;&lt;b))&lt;=x) res|=(1&lt;&lt;b); b--; &#125; return res;&#125; https://discuss.leetcode.com/topic/35357/share-my-2ms-and-4lines-java-code Share my 2ms and 4lines JAVA code, My idea is, for any non-negative number N, sqrt(N) = 2/2sqrt(N) =2sqrt(1/4)sqrt(N) = 2sqrt(N/4). And for the Ns that are not multiple of 4, for example, 9, 25 or 49, the actual result should be 1+2*sqrt(N/4), because we need to take remainders into account. 123456public int mySqrt(int x) &#123; if(x &lt; 4) return x == 0 ? 0 : 1; int res = 2 * mySqrt(x/4); if((res+1) * (res+1) &lt;= x &amp;&amp; (res+1) * (res+1) &gt;= 0) return res+1; return res;&#125; Hope it helps.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>math</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[068. Text Justification]]></title>
    <url>%2Fp%2F91398cc3%2F</url>
    <content type="text"><![CDATA[19.1% https://leetcode.com/problems/text-justification/ Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces â€˜ â€˜ when necessary so that each line has exactly L characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. 12345678910For example,words: [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]L: 16.Return the formatted lines as:[&quot;This is an&quot;,&quot;example of text&quot;,&quot;justification. &quot;] Note: Each word is guaranteed not to exceed L in length. click to show corner cases. Corner Cases: A line other than the last line might contain only one word. What should you do in this case? In this case, that line should be left-justified. https://discuss.leetcode.com/topic/7256/what-does-this-question-aim-to-teach What does this question aim to teach? In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. As far as I understand the â€œideaâ€ of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. In this questionâ€™s description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. Do you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned? https://discuss.leetcode.com/topic/7256/what-does-this-question-aim-to-teach/4 it teaches you in the real world. Programmers are always been ask to deal with dirty works. cpp https://discuss.leetcode.com/topic/4189/share-my-concise-c-solution-less-than-20-lines Share my concise c++ solution - less than 20 lines 1234567891011121314151617vector&lt;string&gt; fullJustify(vector&lt;string&gt; &amp;words, int L) &#123; vector&lt;string&gt; res; for(int i = 0, k, l; i &lt; words.size(); i += k) &#123; for(k = l = 0; i + k &lt; words.size() and l + words[i+k].size() &lt;= L - k; k++) &#123; l += words[i+k].size(); &#125; string tmp = words[i]; for(int j = 0; j &lt; k - 1; j++) &#123; if(i + k &gt;= words.size()) tmp += &quot; &quot;; else tmp += string((L - l) / (k - 1) + (j &lt; (L - l) % (k - 1)), &apos; &apos;); tmp += words[i+j+1]; &#125; tmp += string(L - tmp.size(), &apos; &apos;); res.push_back(tmp); &#125; return res;&#125; For each line, I first figure out which words can fit in. According to the code, these words are words[i] through words[i+k-1]. Then spaces are added between the words. The trick here is to use mod operation to manage the spaces that canâ€™t be evenly distrubuted: the first (L-l) % (k-1) gaps acquire an additional space. https://discuss.leetcode.com/topic/11507/share-my-2-ms-30-lines-solution Share my 2 ms, 30 lines solution 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;string&gt; fullJustify(vector&lt;string&gt; &amp;words, int L) &#123; vector&lt;string&gt; ans; int begin = 0; while (begin &lt; words.size()) &#123; int last = begin; int linesize = words[begin++].size(); while (begin &lt; words.size() &amp;&amp; linesize + 1 + words[begin].size() &lt;= L) &#123; linesize += 1 + words[begin].size(); begin++; &#125; int spaces = 1, extra = 0; if (begin &lt; words.size() &amp;&amp; begin != last + 1) &#123; spaces = (L - linesize) / (begin - last - 1) + 1; extra = (L - linesize) % (begin - last - 1); &#125; ans.push_back(words[last++]); while (extra--) &#123; ans.back().append(spaces+1, &apos; &apos;); ans.back().append(words[last++]); &#125; while (last &lt; begin) &#123; ans.back().append(spaces, &apos; &apos;); ans.back().append(words[last++]); &#125; ans.back().append(L-ans.back().size(), &apos; &apos;); &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/6946/easy-understanding-solution Easy understanding solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546vector&lt;string&gt; fullJustify(vector&lt;string&gt; &amp;words, int L) &#123; vector&lt;string&gt; ans, vs; string str; int len = 0; for (int i = 0; i &lt; words.size(); ++i) &#123; if (len + vs.size() + words[i].size() &lt;= L) &#123; // vs not full, need to get more words in the line vs.push_back(words[i]); len += words[i].size(); &#125; else &#123; // vs full, get the whole line if (vs.size() == 1) &#123; // just one word, the left justify str = vs[0]; str.append(L - str.size(), &apos; &apos;); ans.push_back(str); &#125; else if (vs.size() &gt; 1) &#123; // the first &quot;mod&quot; words get &quot;div+1&quot; spaces // the remaining words get &quot;div&quot; spaces int div = (L - len) / (vs.size() - 1); int mod = (L - len) % (vs.size() - 1); str = vs[0]; for (int j = 1; j &lt; vs.size(); ++j) &#123; if (j &lt;= mod) str.append(div+1, &apos; &apos;); // one more space else str.append(div, &apos; &apos;); str += vs[j]; &#125; ans.push_back(str); &#125; vs.clear(); vs.push_back(words[i]); len = words[i].size(); &#125; &#125; // the last line, left justified and no extra space is inserted between words str = vs[0]; for (int j = 1; j &lt; vs.size(); ++j) str += &apos; &apos; + vs[j]; str.append(L-str.size(), &apos; &apos;); ans.push_back(str); return ans;&#125; python 58ms, 18.55%, September 23, 2016 https://discuss.leetcode.com/topic/25970/concise-python-solution-10-lines Concise python solution, 10 lines. 1234567891011def fullJustify(self, words, maxWidth): res, cur, num_of_letters = [], [], 0 for w in words: if num_of_letters + len(w) + len(cur) &gt; maxWidth: for i in range(maxWidth - num_of_letters): cur[i%(len(cur)-1 or 1)] += &apos; &apos; res.append(&apos;&apos;.join(cur)) cur, num_of_letters = [], 0 cur += [w] num_of_letters += len(w) return res + [&apos; &apos;.join(cur).ljust(maxWidth)] How does it work? Well in the question statement, the sentence â€œExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the rightâ€ was just a really long and awkward way to say round robin. The following line implements the round robin logic: 12for i in range(maxWidth - num_of_letters): cur[i%(len(cur)-1 or 1)] += &apos; &apos; What does this line do? Once you determine that there are only k words that can fit on a given line, you know what the total length of those words is num_of_letters. Then the rest are spaces, and there are (maxWidth - num_of_letters) of spaces. The â€œor 1â€ part is for dealing with the edge case len(cur) == 1. The following is my older solution for reference, longer and less clear. The idea is the same, but I did not figure out the nice way to distribute the space at the time. 1234567891011121314151617def fullJustify(self, words, maxWidth): res, cur, num_of_letters = [], [], 0 for w in words: if num_of_letters + len(w) + len(cur) &gt; maxWidth: if len(cur) == 1: res.append( cur[0] + &apos; &apos;*(maxWidth - num_of_letters) ) else: num_spaces = maxWidth - num_of_letters space_between_words, num_extra_spaces = divmod( num_spaces, len(cur)-1) for i in range(num_extra_spaces): cur[i] += &apos; &apos; res.append( (&apos; &apos;*space_between_words).join(cur) ) cur, num_of_letters = [], 0 cur += [w] num_of_letters += len(w) res.append( &apos; &apos;.join(cur) + &apos; &apos;*(maxWidth - num_of_letters - len(cur) + 1) ) return res https://discuss.leetcode.com/topic/36136/15-line-python-solution-40ms 15-line Python solution, 40ms 123456789101112131415161718def fullJustify(self, words, maxWidth): i, N, result = 0, len(words), [] while i &lt; N: # decide how many words to be put in one line oneLine, j, currWidth, positionNum, spaceNum = [words[i]], i + 1, len(words[i]), 0, maxWidth - len(words[i]) while j &lt; N and currWidth + 1 + len(words[j]) &lt;= maxWidth: oneLine.append(words[j]) currWidth += 1 + len(words[j]) spaceNum -= len(words[j]) positionNum, j = positionNum + 1, j + 1 i = j # decide the layout of one line if i &lt; N and positionNum: spaces = [&apos; &apos; * (spaceNum / positionNum + (k &lt; spaceNum % positionNum)) for k in range(positionNum)] + [&apos;&apos;] else: # last line or the line only has one word spaces = [&apos; &apos;] * positionNum + [&apos; &apos; * (maxWidth - currWidth)] result.append(&apos;&apos;.join([s for pair in zip(oneLine, spaces) for s in pair])) return result java https://discuss.leetcode.com/topic/9147/simple-java-solution Simple Java Solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public List&lt;String&gt; fullJustify(String[] words, int L) &#123; List&lt;String&gt; lines = new ArrayList&lt;String&gt;(); int index = 0; while (index &lt; words.length) &#123; int count = words[index].length(); int last = index + 1; while (last &lt; words.length) &#123; if (words[last].length() + count + 1 &gt; L) break; count += words[last].length() + 1; last++; &#125; StringBuilder builder = new StringBuilder(); int diff = last - index - 1; // if last line or number of words in the line is 1, left-justified if (last == words.length || diff == 0) &#123; for (int i = index; i &lt; last; i++) &#123; builder.append(words[i] + &quot; &quot;); &#125; builder.deleteCharAt(builder.length() - 1); for (int i = builder.length(); i &lt; L; i++) &#123; builder.append(&quot; &quot;); &#125; &#125; else &#123; // middle justified int spaces = (L - count) / diff; int r = (L - count) % diff; for (int i = index; i &lt; last; i++) &#123; builder.append(words[i]); if (i &lt; last - 1) &#123; for (int j = 0; j &lt;= (spaces + ((i - index) &lt; r ? 1 : 0)); j++) &#123; builder.append(&quot; &quot;); &#125; &#125; &#125; &#125; lines.add(builder.toString()); index = last; &#125; return lines; &#125;&#125; 3ms, 1.45%, September 22, 2016 https://discuss.leetcode.com/topic/4189/share-my-concise-c-solution-less-than-20-lines 1234567891011121314151617181920class Solution &#123;public: vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int L) &#123; vector&lt;string&gt; res; for(int i=0, k, l; i&lt;words.size(); i+=k)&#123; for(k=l=0; i+k&lt;words.size() and l+words[i+k].size() &lt;= L-k; k++)&#123; l += words[i+k].size(); &#125; string tmp = words[i]; for(int j=0; j&lt;k-1; j++)&#123; if(i+k&gt;=words.size()) tmp += &quot; &quot;; else tmp+=string((L-l)/(k-1) + (j&lt;(L-l)%(k-1)), &apos; &apos;); tmp += words[i+j+1]; &#125; tmp += string(L-tmp.size(), &apos; &apos;); res.push_back(tmp); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[067. Add Binary]]></title>
    <url>%2Fp%2Fde93a709%2F</url>
    <content type="text"><![CDATA[32.5% https://leetcode.com/problems/add-binary/ Given two binary strings, return their sum (also a binary string). 1234For example,a = &quot;11&quot;b = &quot;1&quot;Return &quot;100&quot;. æ–¹æ³•ä¸€ï¼š æ ¹æ®æœ€åŸºæœ¬çš„è§„åˆ™è¿ç®—ï¼Œç±»ä¼¼äºŽé“¾è¡¨æ±‚å’Œ https://discuss.leetcode.com/topic/8981/short-code-by-c Short code by c++ 12345678910111213141516171819class Solution&#123;public: string addBinary(string a, string b) &#123; string s = &quot;&quot;; int c = 0, i = a.size() - 1, j = b.size() - 1; while(i &gt;= 0 || j &gt;= 0 || c == 1) &#123; c += i &gt;= 0 ? a[i --] - &apos;0&apos; : 0; c += j &gt;= 0 ? b[j --] - &apos;0&apos; : 0; s = char(c % 2 + &apos;0&apos;) + s; c /= 2; &#125; return s; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324class Solution &#123;public: string addBinary(string a, string b) &#123; if(a.empty()) return b; if(b.empty()) return a; int carry = 0; int i = a.size()-1; int j = b.size()-1; string res = ""; while(i&gt;=0 || j&gt;=0 || carry)&#123; int l = i&gt;=0? a[i]-'0' : 0; int r = j&gt;=0 ? b[j]-'0' : 0; carry = l+r+carry; res += char(carry%2 + '0'); carry /= 2; if(i&gt;=0) i--; if(j&gt;=0) j--; &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 4ms, 30.34%, 16 July 2016 https://discuss.leetcode.com/topic/16441/short-o-n-time-o-1-space-c-solution Short O(n) time, O(1) space C++ solution I just write the sum into the longer one of the inputs. Donâ€™t worry about modifying them, as getting string means weâ€™re getting copies. The â€œO(1) spaceâ€ of course refers to the space I use in addition to input and output. If the output doesnâ€™t need to be longer than the longer input, I even only use O(1) space in addition to only the input. 12345678910111213141516class Solution &#123;public: string addBinary(string a, string b) &#123; if (a.size() &lt; b.size()) swap(a, b); int i = a.size(), j = b.size(); while (i--) &#123; if (j) a[i] += b[--j] &amp; 1; if (a[i] &gt; &apos;1&apos;) &#123; a[i] -= 2; if (i) a[i-1]++; else a = &apos;1&apos; + a; &#125; &#125; return a; &#125;&#125;; python 76ms, 34.89%, 16 July, 2016 https://discuss.leetcode.com/topic/19383/one-line-python-solution 12345678class Solution(object): def addBinary(self, a, b): &quot;&quot;&quot; :type a: str :type b: str :rtype: str &quot;&quot;&quot; return bin(eval(&apos;0b&apos;+a) + eval(&apos;0b&apos;+b))[2:] 60ms, 80.04%, 16 July 2016 https://discuss.leetcode.com/topic/12116/simple-python-solution-76ms if int() function is allowed, the following code may be more simple. :) 12345678910class Solution(object): def addBinary(self, a, b): &quot;&quot;&quot; :type a: str :type b: str :rtype: str &quot;&quot;&quot; a = int(a, 2) b = int(b, 2) return (&apos;&apos; + bin(a+b))[2:] Simple Python Solution 76ms I assume using int and str is okay, I think this is easy to understand. 12345678910111213141516def addBinary(self, a, b): result = &apos;&apos; index = 0 carry = &apos;0&apos; while index &lt; max(len(a), len(b)) or carry == &apos;1&apos;: num_a = a[-1 - index] if index &lt; len(a) else &apos;0&apos; num_b = b[-1 - index] if index &lt; len(b) else &apos;0&apos; val = int(num_a) + int(num_b) + int(carry) result = str(val % 2) + result carry = &apos;1&apos; if val &gt; 1 else &apos;0&apos; index += 1 return result update No int and str version. 123456789101112131415161718192021222324252627class Solution:# @param a, a string# @param b, a string# @return a string# 75msdef addBinary(self, a, b): result = &apos;&apos; index = 0 carry = &apos;0&apos; while index &lt; max(len(a), len(b)) or carry == &apos;1&apos;: num_a = a[-1 - index] if index &lt; len(a) else &apos;0&apos; num_b = b[-1 - index] if index &lt; len(b) else &apos;0&apos; val = self.to_int(num_a) + self.to_int(num_b) + self.to_int(carry) result = &quot;%s%s&quot; % (val % 2, result) carry = &apos;1&apos; if val &gt; 1 else &apos;0&apos; index += 1 return resultdef to_int(self, c): if c == &apos;1&apos;: return 1 elif c == &apos;0&apos;: return 0 java https://discuss.leetcode.com/topic/13698/short-ac-solution-in-java-with-explanation Short AC solution in Java with explanation Computation from string usually can be simplified by using a carry as such. 123456789101112131415public class Solution &#123; public String addBinary(String a, String b) &#123; StringBuilder sb = new StringBuilder(); int i = a.length() - 1, j = b.length() -1, carry = 0; while (i &gt;= 0 || j &gt;= 0) &#123; int sum = carry; if (j &gt;= 0) sum += b.charAt(j--) - &apos;0&apos;; if (i &gt;= 0) sum += a.charAt(i--) - &apos;0&apos;; sb.append(sum % 2); carry = sum / 2; &#125; if (carry != 0) sb.append(carry); return sb.reverse().toString(); &#125;&#125; https://discuss.leetcode.com/topic/5172/simple-accepted-java-solution Simple accepted java solution Addition bits are calculated by xor. Carry bit is calculated as simple integer addition.1234567891011121314151617181920212223242526272829public class Solution &#123; public String addBinary(String a, String b) &#123; if(a == null || a.isEmpty()) &#123; return b; &#125; if(b == null || b.isEmpty()) &#123; return a; &#125; char[] aArray = a.toCharArray(); char[] bArray = b.toCharArray(); StringBuilder stb = new StringBuilder(); int i = aArray.length - 1; int j = bArray.length - 1; int aByte; int bByte; int carry = 0; int result; while(i &gt; -1 || j &gt; -1 || carry == 1) &#123; aByte = (i &gt; -1) ? Character.getNumericValue(aArray[i--]) : 0; bByte = (j &gt; -1) ? Character.getNumericValue(bArray[j--]) : 0; result = aByte ^ bByte ^ carry; carry = ((aByte + bByte + carry) &gt;= 2) ? 1 : 0; stb.append(result); &#125; return stb.reverse().toString(); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>math</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[066. Plus One]]></title>
    <url>%2Fp%2F15c6dd1%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/plus-one/ Given a non-negative number represented as an array of digits, plus one to the number. The digits are stored such that the most significant digit is at the head of the list. https://discuss.leetcode.com/topic/987/to-avoid-confusion-please-mention-that-the-lowest-digit-is-on-the-right-end To avoid confusion, please mention that the lowest digit is on the right end The question description does not explicitly say that. I found that is the case. https://discuss.leetcode.com/topic/1264/missing-information Missing information When I started writing the solution I was thinking we were talking about binary digits, please add this information to the text of the problem. The numerical base requested. Would be cool to have a more general problem that also passes the numerical base to the function ;-) æ–¹æ³•ä¸€ï¼š æ›´æ”¹æ¯ä¸€ä½ï¼Œä»Žæœ€åŽä¸€ä½å‘å‰èµ°ã€‚ å¦‚æžœå°¾æ•°æ˜¯9ï¼Œå°±æ”¹ä¸º0ã€‚ å¦‚æžœåˆ°æŸä¸€ä½ä¸æ˜¯9ï¼Œç›´æŽ¥è¿”å›žã€‚ å¦‚æžœèµ°åˆ°å¤´éƒ½æ˜¯9ï¼Œåˆ™ç¬¬ä¸€ä½æ”¹ä¸º1ï¼Œæœ€åŽåŠ ä¸€ä½0. code 1ï¼š 12345678910111213141516171819void plusone(vector&lt;int&gt; &amp;digits)&#123; int n = digits.size(); for (int i = n - 1; i &gt;= 0; --i) &#123; if (digits[i] == 9) &#123; digits[i] = 0; &#125; else &#123; digits[i]++; return; &#125; &#125; digits[0] =1; digits.push_back(0); &#125; code 2ï¼š 1234567891011class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; for (int i=digits.size(); i--; digits[i] = 0) if (digits[i]++ &lt; 9) return digits; digits[0]++; digits.push_back(0); return digits; &#125;&#125;; java https://discuss.leetcode.com/topic/24288/my-simple-java-solution My Simple Java Solution 1234567891011121314151617public int[] plusOne(int[] digits) &#123; int n = digits.length; for(int i=n-1; i&gt;=0; i--) &#123; if(digits[i] &lt; 9) &#123; digits[i]++; return digits; &#125; digits[i] = 0; &#125; int[] newNumber = new int [n+1]; newNumber[0] = 1; return newNumber;&#125; https://discuss.leetcode.com/topic/19149/simple-java-solution Simple java solution 12345678910111213141516public int[] plusOne(int[] digits) &#123; for (int i = digits.length - 1; i &gt;=0; i--) &#123; if (digits[i] != 9) &#123; digits[i]++; break; &#125; else &#123; digits[i] = 0; &#125; &#125; if (digits[0] == 0) &#123; int[] res = new int[digits.length+1]; res[0] = 1; return res; &#125; return digits;&#125; https://discuss.leetcode.com/topic/41728/java-concise-solution-with-early-return Java concise solution with early return. 123456789101112public int[] plusOne(int[] digits) &#123; int carry = 1; for (int i = digits.length-1; i&gt;= 0; i--) &#123; digits[i] += carry; if (digits[i] &lt;= 9) // early return return digits; digits[i] = 0; &#125; int[] ret = new int[digits.length+1]; ret[0] = 1; return ret;&#125; 0ms, 38.09%, June.17th, 2016 http://www.itnose.net/news/172/6334216 12345678910111213141516171819202122232425public class Solution &#123; public int[] plusOne(int[] digits) &#123; int carry = 1; // è¿›ä½æ ‡å¿—ï¼Œä¸‹ä¸€ä½æ¥çš„è¿›ä½æ ‡å¿— int tmp; for (int i = digits.length - 1; i &gt;= 0; i--) &#123; tmp = digits[i]; digits[i] = (tmp + carry) % 10; // è®¡ç®—å½“å‰ä½çš„æ–°å€¼ carry = (tmp + carry) / 10; // è®¡ç®—æ–°çš„è¿›ä½ if (carry == 0) &#123; // æ²¡æœ‰è¿›ä½äº†å°±å¯ä»¥é€€å‡ºäº† break; &#125; &#125; if (carry == 1) &#123; // æœ€åŽè¿˜æœ‰ä¸€ä¸ªè¿›ä½ int[] result = new int[digits.length + 1]; System.arraycopy(digits, 0, result, 1, digits.length); result[0] = carry;; return result; &#125; else &#123; return digits; &#125; &#125;&#125; cpp https://discuss.leetcode.com/topic/4556/is-it-a-simple-code-c Is it a simple code(C++)? 12345678910111213141516171819void plusone(vector&lt;int&gt; &amp;digits)&#123; int n = digits.size(); for (int i = n - 1; i &gt;= 0; --i) &#123; if (digits[i] == 9) &#123; digits[i] = 0; &#125; else &#123; digits[i]++; return; &#125; &#125; digits[0] =1; digits.push_back(0); &#125; https://discuss.leetcode.com/topic/9016/my-c-solution-with-few-lines My C++ Solution with few lines 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt; &amp;digits) &#123; bool carry = true; for(int i=digits.size()-1; i &gt;= 0 &amp;&amp; carry; i--) &#123; carry = (++digits[i]%=10) == 0; &#125; if(carry) &#123; digits.insert(digits.begin(), 1); &#125; return digits; &#125;&#125;; 4ms, 9.24%, June.17th, 2016 https://leetcode.com/discuss/14616/is-it-a-simple-code-c 1234567891011class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; for (int i=digits.size(); i--; digits[i] = 0) if (digits[i]++ &lt; 9) return digits; digits[0]++; digits.push_back(0); return digits; &#125;&#125;; python 46ms, 94.03%, June.17th, 2016 https://leetcode.com/discuss/18768/simple-python-solution-with-explanation-plus-one Simple Python solution with explanation (Plus One) 12345def plusOne(digits): num = 0 for i in range(len(digits)): num += digits[i] * pow(10, (len(digits)-1-i)) return [int(i) for i in str(num+1)] Weâ€™re given a list of digits, and the idea here is to convert that list to an integer, num. So each digit is multiplied by the proper place value and added to num. For example, if digits = [3, 8, 2, 5] then on the first iteration 3 is multiplied by 10 to the power of 4-1-0 = 3, so this results in 3000, which is added to num. Then 8 is multiplied by 10^2 and added to num, and so on. The last step is to add 1 to num, convert it to a list and return that list.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[065. Valid Number]]></title>
    <url>%2Fp%2Fdad046c3%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/valid-number/ Validate if a given string is numeric. 123456Some examples:&quot;0&quot; =&gt; true&quot; 0.1 &quot; =&gt; true&quot;abc&quot; =&gt; false&quot;1 a&quot; =&gt; false&quot;2e10&quot; =&gt; true Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. https://discuss.leetcode.com/topic/1095/the-worst-problem-i-have-ever-met-in-this-oj The worst problem i have ever met in this oj The description do not give a clear explantion of the definition of a valid Number, we just use more and more trick to get the right solution. Itâ€™s too bad, itâ€™s waste of my time https://discuss.leetcode.com/topic/1095/the-worst-problem-i-have-ever-met-in-this-oj/4 +1 for the worst problem on OJ. This is definitely a valid interview question, but it requires heavy clarification through interaction. In a real interview, you have one and only one source to get all the missing information, a.k.a. your interviewer. On OJ, however, there is no interaction whatsoever except through trial and error. This, as far as I am concerned, is directly against the principle of â€˜collecting all the info before implementingâ€™. Internet searching also does not work since the word â€˜numericâ€™ is not even defined in the question. No wonder this relatively easy (implementation-wise) problem has one of the lowest rates of acceptance. I would suggest OJ: provide all the details to let users focus on the implementation, or leave room for ambiguity but also suggest where the info can be collected, or provide an interactive applet or something like that on the page so that the user can try the string combinations that they are uncertain of before implementing. I think this is an easy thing to do, and it saves everybodyâ€™s time. java https://discuss.leetcode.com/topic/9490/clear-java-solution-with-ifs Clear Java solution with ifs All we need is to have a couple of flags so we can process the string in linear time: 123456789101112131415161718192021222324252627282930313233public boolean isNumber(String s) &#123; s = s.trim(); boolean pointSeen = false; boolean eSeen = false; boolean numberSeen = false; boolean numberAfterE = true; for(int i=0; i&lt;s.length(); i++) &#123; if(&apos;0&apos; &lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= &apos;9&apos;) &#123; numberSeen = true; numberAfterE = true; &#125; else if(s.charAt(i) == &apos;.&apos;) &#123; if(eSeen || pointSeen) &#123; return false; &#125; pointSeen = true; &#125; else if(s.charAt(i) == &apos;e&apos;) &#123; if(eSeen || !numberSeen) &#123; return false; &#125; numberAfterE = false; eSeen = true; &#125; else if(s.charAt(i) == &apos;-&apos; || s.charAt(i) == &apos;+&apos;) &#123; if(i != 0 &amp;&amp; s.charAt(i-1) != &apos;e&apos;) &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; return numberSeen &amp;&amp; numberAfterE;&#125; We start with trimming. If we see [0-9] we reset the number flags. We can only see . if we didnâ€™t see e or .. We can only see e if we didnâ€™t see e but we did see a number. We reset numberAfterE flag. We can only see + and - in the beginning and after an e any other character break the validation. At the and it is only valid if there was at least 1 number and if we did see an e then a number after it as well. So basically the number should match this regular expression: 1[-+]?(([0-9]+(.[0-9]*)?)|.[0-9]+)(e[-+]?[0-9]+)? https://discuss.leetcode.com/topic/8029/a-clean-design-solution-by-using-design-pattern A clean design solution By using design pattern This problem give me a good chance to convey the importance of good design. The problem is very vogue. The point here is not how you design a algorithm, it is how you handle all cases well. There is no a clear standard for whether is a number valid, is it .50 , 39. a legal float point number? Are there only valid formats given by the example? Is hex format such as 0x12ab legal? How about if we need to add another format such as roman number like â€œI, II , IVâ€ as legal format. I found all solution are just plug logic into one function, there are lots of switch case, if else in there. It is problematic, easy for bugs, difficult to add new features, and of course, in-reusable, and here I propose a design to handle this problem easily and nicely. First we we can give out an interface for this problem: 1234interface NumberValidate &#123; boolean validate(String s);&#125; for any string, we call validate and it return whether the given string is a valid number. Follow we can create concrete implementation for this interface, such as IntegeValidator, FloatValidator, ScienceValidator. and then using chain of responsibility design patter (from book of GOF) , chain all those validator into a list, and feed the string to each one, if there is one validator return true, then the string is a valid number. The design has two advantages, one is easy to fix, for any corner cases or bug, we can locate the problem to specific validator, the effect of changing one validator will not sprint out to the all system, we call this as â€œencapsulationâ€. Second is easy to extend, if we need to verify hex format or roman number format , we just need to create new validator and add to the chain, we call this advantage as â€œclose for modification open for extensionâ€. Follow is code for the passed design: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295interface NumberValidate &#123; boolean validate(String s);&#125;abstract class NumberValidateTemplate implements NumberValidate&#123;public boolean validate(String s) &#123; if (checkStringEmpty(s)) &#123; return false; &#125; s = checkAndProcessHeader(s); if (s.length() == 0) &#123; return false; &#125; return doValidate(s); &#125; private boolean checkStringEmpty(String s) &#123; if (s.equals(&quot;&quot;)) &#123; return true; &#125; return false; &#125; private String checkAndProcessHeader(String value) &#123; value = value.trim(); if (value.startsWith(&quot;+&quot;) || value.startsWith(&quot;-&quot;)) &#123; value = value.substring(1); &#125; return value; &#125; protected abstract boolean doValidate(String s);&#125;class NumberValidator implements NumberValidate &#123; private ArrayList&lt;NumberValidate&gt; validators = new ArrayList&lt;NumberValidate&gt;(); public NumberValidator() &#123; addValidators(); &#125; private void addValidators() &#123; NumberValidate nv = new IntegerValidate(); validators.add(nv); nv = new FloatValidate(); validators.add(nv); nv = new HexValidate(); validators.add(nv); nv = new SienceFormatValidate(); validators.add(nv); &#125; @Override public boolean validate(String s) &#123; for (NumberValidate nv : validators) &#123; if (nv.validate(s) == true) &#123; return true; &#125; &#125; return false; &#125; &#125;class IntegerValidate extends NumberValidateTemplate&#123; protected boolean doValidate(String integer) &#123; for (int i = 0; i &lt; integer.length(); i++) &#123; if(Character.isDigit(integer.charAt(i)) == false) &#123; return false; &#125; &#125; return true; &#125;&#125;class HexValidate extends NumberValidateTemplate&#123; private char[] valids = new char[] &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;&#125;; protected boolean doValidate(String hex) &#123; hex = hex.toLowerCase(); if (hex.startsWith(&quot;0x&quot;)) &#123; hex = hex.substring(2); &#125; else &#123; return false; &#125; for (int i = 0; i &lt; hex.length(); i++) &#123; if (Character.isDigit(hex.charAt(i)) != true &amp;&amp; isValidChar(hex.charAt(i)) != true) &#123; return false; &#125; &#125; return true; &#125; private boolean isValidChar(char c) &#123; for (int i = 0; i &lt; valids.length; i++) &#123; if (c == valids[i]) &#123; return true; &#125; &#125; return false; &#125;&#125;class SienceFormatValidate extends NumberValidateTemplate&#123;protected boolean doValidate(String s) &#123; s = s.toLowerCase(); int pos = s.indexOf(&quot;e&quot;); if (pos == -1) &#123; return false; &#125; if (s.length() == 1) &#123; return false; &#125; String first = s.substring(0, pos); String second = s.substring(pos+1, s.length()); if (validatePartBeforeE(first) == false || validatePartAfterE(second) == false) &#123; return false; &#125; return true; &#125; private boolean validatePartBeforeE(String first) &#123; if (first.equals(&quot;&quot;) == true) &#123; return false; &#125; if (checkHeadAndEndForSpace(first) == false) &#123; return false; &#125; NumberValidate integerValidate = new IntegerValidate(); NumberValidate floatValidate = new FloatValidate(); if (integerValidate.validate(first) == false &amp;&amp; floatValidate.validate(first) == false) &#123; return false; &#125; return true; &#125; private boolean checkHeadAndEndForSpace(String part) &#123; if (part.startsWith(&quot; &quot;) || part.endsWith(&quot; &quot;)) &#123; return false; &#125; return true; &#125; private boolean validatePartAfterE(String second) &#123; if (second.equals(&quot;&quot;) == true) &#123; return false; &#125; if (checkHeadAndEndForSpace(second) == false) &#123; return false; &#125; NumberValidate integerValidate = new IntegerValidate(); if (integerValidate.validate(second) == false) &#123; return false; &#125; return true; &#125;&#125;class FloatValidate extends NumberValidateTemplate&#123; protected boolean doValidate(String floatVal) &#123; int pos = floatVal.indexOf(&quot;.&quot;); if (pos == -1) &#123; return false; &#125; if (floatVal.length() == 1) &#123; return false; &#125; NumberValidate nv = new IntegerValidate(); String first = floatVal.substring(0, pos); String second = floatVal.substring(pos + 1, floatVal.length()); if (checkFirstPart(first) == true &amp;&amp; checkFirstPart(second) == true) &#123; return true; &#125; return false; &#125; private boolean checkFirstPart(String first) &#123; if (first.equals(&quot;&quot;) == false &amp;&amp; checkPart(first) == false) &#123; return false; &#125; return true; &#125; private boolean checkPart(String part) &#123; if (Character.isDigit(part.charAt(0)) == false || Character.isDigit(part.charAt(part.length() - 1)) == false) &#123; return false; &#125; NumberValidate nv = new IntegerValidate(); if (nv.validate(part) == false) &#123; return false; &#125; return true; &#125;&#125;public class Solution &#123; public boolean isNumber(String s) &#123; NumberValidate nv = new NumberValidator(); return nv.validate(s); &#125;&#125; https://discuss.leetcode.com/topic/40983/java-logically-simple-flexible-and-clear-solution-including-rules-of-a-valid-number Java logically simple, flexible and clear solution including rules of a valid number The idea is to identify the rules of a valid number first, then set boolean variables to mark key characters and judge the validity. This solution is logically simple and easy to understand, and moreover, it is flexible to extend to the cases where a string of a valid number can accept any space appears anywhere, or/and the exponent can be a decimal number. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public boolean isNumber(String s) &#123; /** * isNumber(s)==true if and only if s=s1 or s1+&apos;e&apos;+s2, where s1, s2 * are valid strings of a number without the char &apos;e&apos;, and s2 is an * integer. * * &apos;e&apos; : valid_count=0~1; [boolean hasE] * * Valid chars in a string of a number without &apos;e&apos;: * * &apos; &apos; : valid_count=0~n; must appear at two ends * * &apos;+/-&apos; : valid_count=0~1; must be the first non-space valid char; * [boolean hasFirst] * * &apos;.&apos; : valid_count=0~1; cannot appear after &apos;e&apos;; [boolean hasDot] * * &apos;0~9&apos; : valid_count=1~n; [boolean hasDigit] */ s = s.trim(); int n = s.length(); if (n == 0) return false; boolean hasE, hasFirst, hasDot, hasDigit; hasE = hasFirst = hasDot = hasDigit = false; char c; for (int i = 0; i &lt; n; i++) &#123; c = s.charAt(i); if (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) &#123; hasFirst = hasDigit = true; continue; &#125; switch (c) &#123; /* * case &apos; &apos;: continue; */ // extend to accept any space everywhere case &apos;e&apos;: // already has &apos;e&apos; or no digit before &apos;e&apos; if (hasE || !hasDigit) return false; hasE = true; // reset for the exponential number hasFirst = hasDigit = false; hasDot = true; // the exponent must be an integer, hence // regard as if a dot exists already. Set // hasDot = false extending to accept any // (decimal) number as an exponent. continue; case &apos;+&apos;: case &apos;-&apos;: if (hasFirst) return false; hasFirst = true; continue; case &apos;.&apos;: if (hasDot) return false; hasFirst = hasDot = true; continue; default: return false; &#125; &#125; return hasDigit; &#125; https://discuss.leetcode.com/topic/2973/java-solution-with-one-line Java solution with one line 1return s.matches(&quot;(\\s*)[+-]?((\\.[0-9]+)|([0-9]+(\\.[0-9]*)?))(e[+-]?[0-9]+)?(\\s*)&quot;); cpp https://discuss.leetcode.com/topic/2710/a-simple-solution-in-cpp A simple solution in cpp The idea is pretty straightforward. A valid number is composed of the significand and the exponent (which is optional). As we go through the string, do the following things one by one: skip the leading whitespaces; check if the significand is valid. To do so, simply skip the leading sign and count the number of digits and the number of points. A valid significand has no more than one point and at least one digit. check if the exponent part is valid. We do this if the significand is followed by â€˜eâ€™. Simply skip the leading sign and count the number of digits. A valid exponent contain at least one digit. skip the trailing whitespaces. We must reach the ending 0 if the string is a valid number. 1234567891011121314151617181920212223242526272829303132bool isNumber(const char *s) &#123; int i = 0; // skip the whilespaces for(; s[i] == &apos; &apos;; i++) &#123;&#125; // check the significand if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; // skip the sign if exist int n_nm, n_pt; for(n_nm=0, n_pt=0; (s[i]&lt;=&apos;9&apos; &amp;&amp; s[i]&gt;=&apos;0&apos;) || s[i]==&apos;.&apos;; i++) s[i] == &apos;.&apos; ? n_pt++:n_nm++; if(n_pt&gt;1 || n_nm&lt;1) // no more than one point, at least one digit return false; // check the exponent if exist if(s[i] == &apos;e&apos;) &#123; i++; if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; // skip the sign int n_nm = 0; for(; s[i]&gt;=&apos;0&apos; &amp;&amp; s[i]&lt;=&apos;9&apos;; i++, n_nm++) &#123;&#125; if(n_nm&lt;1) return false; &#125; // skip the trailing whitespaces for(; s[i] == &apos; &apos;; i++) &#123;&#125; return s[i]==0; // must reach the ending 0 of the string&#125; https://discuss.leetcode.com/topic/30058/a-simple-solution-in-python-based-on-dfa A simple solution in Python based on DFA I was asked in the interview of linkedIn, writing it directly can be extremely complicated, for there are many special cases we have to deal with, and the code I wrote was messy. Then I failed to pass the interview. Hereâ€™s a clear solution. With DFA we can easily get our idea into shape and then debug, and the source code is clear and simple. 12345678910111213141516171819202122232425262728293031class Solution(object): def isNumber(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; #define a DFA state = [&#123;&#125;, &#123;&apos;blank&apos;: 1, &apos;sign&apos;: 2, &apos;digit&apos;:3, &apos;.&apos;:4&#125;, &#123;&apos;digit&apos;:3, &apos;.&apos;:4&#125;, &#123;&apos;digit&apos;:3, &apos;.&apos;:5, &apos;e&apos;:6, &apos;blank&apos;:9&#125;, &#123;&apos;digit&apos;:5&#125;, &#123;&apos;digit&apos;:5, &apos;e&apos;:6, &apos;blank&apos;:9&#125;, &#123;&apos;sign&apos;:7, &apos;digit&apos;:8&#125;, &#123;&apos;digit&apos;:8&#125;, &#123;&apos;digit&apos;:8, &apos;blank&apos;:9&#125;, &#123;&apos;blank&apos;:9&#125;] currentState = 1 for c in s: if c &gt;= &apos;0&apos; and c &lt;= &apos;9&apos;: c = &apos;digit&apos; if c == &apos; &apos;: c = &apos;blank&apos; if c in [&apos;+&apos;, &apos;-&apos;]: c = &apos;sign&apos; if c not in state[currentState].keys(): return False currentState = state[currentState][c] if currentState not in [3,5,8,9]: return False return True https://discuss.leetcode.com/topic/4219/c-my-thought-with-dfa [C++] My thought with DFA Code first 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool isNumber(string str) &#123; int state=0, flag=0; // flag to judge the special case &quot;.&quot; while(str[0]==&apos; &apos;) str.erase(0,1);//delete the prefix whitespace while(str[str.length()-1]==&apos; &apos;) str.erase(str.length()-1, 1);//delete the suffix whitespace for(int i=0; i&lt;str.length(); i++)&#123; if(&apos;0&apos;&lt;=str[i] &amp;&amp; str[i]&lt;=&apos;9&apos;)&#123; flag=1; if(state&lt;=2) state=2; else state=(state&lt;=5)?5:7; &#125; else if(&apos;+&apos;==str[i] || &apos;-&apos;==str[i])&#123; if(state==0 || state==3) state++; else return false; &#125; else if(&apos;.&apos;==str[i])&#123; if(state&lt;=2) state=6; else return false; &#125; else if(&apos;e&apos;==str[i])&#123; if(flag&amp;&amp;(state==2 || state==6 || state==7)) state=3; else return false; &#125; else return false; &#125; return (state==2 || state==5 || (flag&amp;&amp;state==6) || state==7); &#125;&#125;; DFA Thank @unknowcs, he came up with a brilliant provement in comments that making this a perfect DFAï¼ Itâ€™s just some states changes depend on inputs only. There 8 state in my states in my DFA.Below is my DFA transition diagram. DFA transition diagram or click picture hereDFA transition diagram There are 5 kind of inputs in my DFA: digit : number 0-9 for +,- : operator + or -(negative or positive) exp: e dot: . other: you can return false Immediately 4 final States in my DFA transition diagram : s2, s6, s7, s8 If the state change to final state at last, return true. s2 can accept digits only : +1 -23432 123 and etc s5 can accept exp expression: +2.4e+12 3e9 and etc s6 can accept decimals end with dot: 1. -42. and etc(careful, what if there exist only one dot â€œ.â€ I use a variable flag judging weather there existing numbers. cause 0. and .0 is valid and . is invalid ) s7 can accept decimals: +12.23, 87., 132 It is clear how DFA works in my pictures. We just need to handle the inputs, and update the state according to DFA. https://discuss.leetcode.com/topic/17942/c-12-ms-give-some-invalid-examples-easily-understand C++ 12 ms,Give some invalid examples,easily understand 1234567891011121314151617181920212223class Solution &#123;public: bool isNumber(string s) &#123; //&quot;1 1&quot;is not valid, &quot;0x11&quot; is not valid, &quot;.&quot; is not valid, &quot;2e3.1&quot; is not valid, &quot;2e&quot; is not valid,&quot;1a&quot; is not valid,&quot;++1&quot; is not valid int n = s.size(); if(n == 0) return false; int i = 0; int count_num = 0,count_point = 0; while(s[i] == &apos; &apos;) i++; if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; while(isdigit(s[i]) || s[i] == &apos;.&apos;) s[i++] == &apos;.&apos;?count_point++:count_num++; if(count_point &gt; 1 || count_num &lt; 1) return false; if(s[i] == &apos;e&apos;)&#123; i++; count_num = 0;count_point = 0; if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; while(isdigit(s[i]) || s[i] == &apos;.&apos;) s[i++] == &apos;.&apos;?count_point++:count_num++; if(count_point &gt; 0 || count_num &lt; 1) return false; &#125; while(s[i] == &apos; &apos;) i++; return i == n; &#125;&#125;; python https://discuss.leetcode.com/topic/26746/easy-python-solution-68-ms-beats-100 Easy Python Solution 68 ms beats 100% 1234def isNumber(self, s): try: float(s) except ValueError: return False else: return True Easy Peasy :)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[064. Minimum Path Sum]]></title>
    <url>%2Fp%2Ff9fa56b2%2F</url>
    <content type="text"><![CDATA[37.5% https://leetcode.com/problems/minimum-path-sum/ Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. æ–¹æ³•ä¸€: æˆ‘çš„ä»£ç å®žçŽ°: 1234567891011121314151617class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(); for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(i&gt;0 &amp;&amp; j&gt;0) grid[i][j] += min(grid[i-1][j], grid[i][j-1]); else if(i==0 &amp;&amp; j&gt;0) grid[i][j] += grid[i][j-1]; else if(i&gt;0 &amp;&amp; j==0) grid[i][j] += grid[i-1][j]; &#125; &#125; return grid[m-1][n-1]; &#125;&#125;; https://discuss.leetcode.com/topic/15269/10-lines-28ms-o-n-space-dp-solution-in-c-with-explanations 10-lines 28ms O(n)-space DP solution in C++ with Explanations This is a typical DP problem. Suppose the minimum path sum of arriving at point (i, j) is S[i][j], then the state equation is S[i][j] = min(S[i - 1][j], S[i][j - 1]) + grid[i][j]. Well, some boundary conditions need to be handled. The boundary conditions happen on the topmost row (S[i - 1][j] does not exist) and the leftmost column (S[i][j - 1] does not exist). Suppose grid is like [1, 1, 1, 1], then the minimum sum to arrive at each point is simply an accumulation of previous points and the result is [1, 2, 3, 4]. Now we can write down the following (unoptimized) code. 12345678910111213141516class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); vector&lt;vector&lt;int&gt; &gt; sum(m, vector&lt;int&gt;(n, grid[0][0])); for (int i = 1; i &lt; m; i++) sum[i][0] = sum[i - 1][0] + grid[i][0]; for (int j = 1; j &lt; n; j++) sum[0][j] = sum[0][j - 1] + grid[0][j]; for (int i = 1; i &lt; m; i++) for (int j = 1; j &lt; n; j++) sum[i][j] = min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j]; return sum[m - 1][n - 1]; &#125;&#125;; æ–¹æ³•äºŒ: As can be seen, each time when we update sum[i][j], we only need sum[i - 1][j] (at the current column) and sum[i][j - 1] (at the left column). So we need not maintain the full m*n matrix. Maintaining two columns is enough and now we have the following code. 123456789101112131415161718class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); vector&lt;int&gt; pre(m, grid[0][0]); vector&lt;int&gt; cur(m, 0); for (int i = 1; i &lt; m; i++) pre[i] = pre[i - 1] + grid[i][0]; for (int j = 1; j &lt; n; j++) &#123; cur[0] = pre[0] + grid[0][j]; for (int i = 1; i &lt; m; i++) cur[i] = min(cur[i - 1], pre[i]) + grid[i][j]; swap(pre, cur); &#125; return pre[m - 1]; &#125;&#125;; Further inspecting the above code, it can be seen that maintaining pre is for recovering pre[i], which is simply cur[i] before its update. So it is enough to use only one vector. Now the space is further optimized and the code also gets shorter. 12345678910111213141516class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); vector&lt;int&gt; cur(m, grid[0][0]); for (int i = 1; i &lt; m; i++) cur[i] = cur[i - 1] + grid[i][0]; for (int j = 1; j &lt; n; j++) &#123; cur[0] += grid[0][j]; for (int i = 1; i &lt; m; i++) cur[i] = min(cur[i - 1], cur[i]) + grid[i][j]; &#125; return cur[m - 1]; &#125;&#125;; https://discuss.leetcode.com/topic/3403/dp-solution-linear-space DP Solution, Linear space You can only reach a cell by going from its left or top neighbor. 123456789101112131415161718192021class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) &#123; if(!grid.size())return 0; const int rows=grid.size(),cols=grid[0].size(); // r[i] == min path sum to previous row&apos;s column i. vector&lt;int&gt; r(cols,0); int i,j; r[0]=grid[0][0]; for(j=1;j&lt;cols;j++)&#123; r[j]=grid[0][j]+r[j-1]; &#125; for(i=1;i&lt;rows;i++)&#123; r[0]+=grid[i][0]; for(j=1;j&lt;cols;j++)&#123; r[j]=min(r[j-1],r[j])+grid[i][j]; &#125; &#125; return r[cols-1]; &#125;&#125;; https://discuss.leetcode.com/topic/448/minimum-path-sum-how-can-i-reduce-the-memory Minimum Path Sum â€”â€”â€”How can I reduce the memory. Here is the idea: f[m][n] is a matrix store the min value of every location we canget. f[0][0] =grid[0][0], f[i][0]=f[i-1][0]+grid[i][0], f[0][j]=f[0][j-1]+grid[0][j] f[i][j]=min(f[i-1][j],f[i][j-1])+grid[i][j]. at last return the f[m-1][n-1] 1234567891011121314151617181920212223242526272829303132class Solution &#123; public: int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) &#123; // IMPORTANT: Please reset any member data you declared, as // the same Solution instance will be reused for each test case. int m=grid.size(); int n=grid[0].size(); int** f; f=new int*[m]; for(int i=0;i&lt;m;i)&#123; f[i]=new int[n]; &#125; f[0][0]=grid[0][0]; for(int i=1;i&lt;m;i++)&#123; f[i][0]=f[i-1][0]+grid[i][0]; &#125; for(int i=1;i&lt;n;i++)&#123; f[0][i]=f[0][i-1]+grid[0][i]; &#125; for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++) f[i][j]=min(f[i-1][j],f[i][j-1])+grid[i][j]; &#125; return f[m-1][n-1]; &#125; int min(int a,int b)&#123; if(a&gt;b) return b; else return a; &#125; &#125;; https://discuss.leetcode.com/topic/16654/c-easy-solution-using-dp-space-compexity-o-1 C++ easy solution using dp. space compexity : O(1) 123456789101112131415161718class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; a) &#123; int m=a.size(); if(m==0) return 0; int n= a[0].size(); for(int i = 0 ; i&lt;m; i++ )&#123; for(int j=0; j&lt;n ; j++)&#123; int left= (j==0) ? INT_MAX : a[i][j-1]; int up = (i==0) ? INT_MAX : a[i-1][j]; if(i==0 &amp;&amp; j==0) continue; a[i][j] += min(left, up ); &#125; &#125; return a[m-1][n-1]; &#125;&#125;; python https://leetcode.com/discuss/34905/simple-python-dp-70ms 76ms, 49.83%, June.20th, 2016 12345678910111213141516class Solution(object): def minPathSum(self, grid): &quot;&quot;&quot; :type grid: List[List[int]] :rtype: int &quot;&quot;&quot; m = len(grid) n = len(grid[0]) for i in xrange(1, n): grid[0][i] += grid[0][i-1] for i in xrange(1, m): grid[i][0] += grid[i-1][0] for i in xrange(1,m): for j in xrange(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[-1][-1] java https://discuss.leetcode.com/topic/5459/my-java-solution-using-dp-and-no-extra-space My java solution using DP and no extra space 1234567891011121314151617181920public int minPathSum(int[][] grid) &#123; int m = grid.length;// row int n = grid[0].length; // column for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == 0 &amp;&amp; j != 0) &#123; grid[i][j] = grid[i][j] + grid[i][j - 1]; &#125; else if (i != 0 &amp;&amp; j == 0) &#123; grid[i][j] = grid[i][j] + grid[i - 1][j]; &#125; else if (i == 0 &amp;&amp; j == 0) &#123; grid[i][j] = grid[i][j]; &#125; else &#123; grid[i][j] = Math.min(grid[i][j - 1], grid[i - 1][j]) + grid[i][j]; &#125; &#125; &#125; return grid[m - 1][n - 1];&#125; https://discuss.leetcode.com/topic/30575/my-8-lines-simple-solution My 8 lines simple solution 123456789int m = grid.length, n = grid[0].length;for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == 0 &amp;&amp; j != 0) grid[i][j] += grid[i][j-1]; if(i != 0 &amp;&amp; j == 0) grid[i][j] += grid[i-1][j]; if (i != 0 &amp;&amp; j != 0) grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]); &#125;&#125;return grid[m-1][n-1]; https://discuss.leetcode.com/topic/3184/ac-java-dp-solution-v-s-tle-dijstra-solution AC Java DP solution v.s. TLE Dijstra solution When I looked at this question, the first thought was the Dijkstra solution, which is a very fast algorithm to calculate the shortest path. But this solution got TLE in this question, while DP solution worked fine. I will talk about the Dijkstra solution first, as itâ€™s the first though came into my mind, and there is already discussions on the DP solution. If you are not interested in the Dijkstra solution, you can jump to the latter part of this post, which is about the DP solution, which is accepted. DijkstraThe idea of Dijkstra algorithm is to divide the graph into 2 parts, visited and unvisited.For every node in the visited part has a dist value. Then we need to exam every edges across the visited part and the unvisited parts, which are edges that its start node is in the visited part, while its end node is in the unvisited part. What we are looking for is one edge, which has the minimum value of (dist(start node) + the edgeâ€™s value). Then we put this node into the visited part and exam the edges again. Following is the code. It uses a Java Heap, PriorityQueue to keep track of the minimum (dist(start node) + the edgeâ€™s value), but in this question, the edge value is in the node itself, which is the same for every edges ending to it, so actually the heap just keeps track of the mimimum dist(start node) of every unvisited nodes around the boarder between visited and unvisited. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Solution_dijkstra &#123;class PointComparator implements Comparator&lt;int[]&gt;&#123; int[][] dist; public PointComparator(int[][] dist)&#123; this.dist = dist; &#125; @Override public int compare(int[] o1, int[] o2) &#123; int[] point1 = (int[])o1; int[] point2 = (int[])o2; return Integer.valueOf(dist[point1[0]][point1[1]]) .compareTo(Integer.valueOf(dist[point2[0]][point2[1]])); &#125;&#125; public int minPathSum(int[][] grid) &#123; if(grid == null || grid.length == 0) return 0; int m = grid.length; int n = grid[0].length; boolean[][] visited = new boolean[m][n]; int[][] dist = new int[m][n]; for(int x = 0; x &lt; m; x++)&#123; for(int y = 0; y &lt; n; y++)&#123; dist[x][y] = Integer.MAX_VALUE; &#125; &#125; dist[0][0] = grid[0][0]; PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;( m*n, new PointComparator(dist)); pq.add(new int[]&#123;0, 0&#125;); while(!pq.isEmpty())&#123; int[] point = pq.poll(); int x = point[0]; int y = point[1]; int d = dist[x][y]; if(x == n-1 &amp;&amp; y == m-1)&#123; return d; &#125; visited[x][y] = true; if((y+1 &lt; n) &amp;&amp; !visited[x][y+1])&#123; dist[x][y+1] = min( dist[x][y+1], d + grid[x][y+1]); pq.add(new int[]&#123;x, y+1&#125;); &#125; if((x+1 &lt; m ) &amp;&amp; !visited[x+1][y])&#123; dist[x+1][y] = min( dist[x+1][y], d + grid[x+1][y]); pq.add(new int[]&#123;x+1, y&#125;); &#125; &#125; return 0; &#125;private int min(int i1, int i2)&#123; return i1 &lt; i2 ? i1 : i2;&#125;&#125; This solution got LTE error, mostly because of the priority queue and doesnâ€™t consider the special condition here that itâ€™s a grid and directed, which means a node can only be accessed from itâ€™s left and upper nodes. Put all these into consideration, we have the DP solution. Itâ€™s essentially formula is dist(node) = min( dist(upper node), dist(left node)) + nodeâ€™s value DPhere is the code: 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution_dp &#123;private int getDist(int[][] dist, int x, int y)&#123; if(x &lt; 0 || y &lt; 0)&#123; return Integer.MAX_VALUE; &#125; return dist[x][y]; &#125;private int min(int i1, int i2)&#123; return i1 &lt; i2 ? i1 : i2;&#125;public int minPathSum(int[][] grid) &#123; if(grid == null || grid.length == 0) return 0; int m = grid.length; int n = grid[0].length; int[][] dist = new int[m][n]; for(int x = 0; x &lt; m; x++)&#123; for(int y = 0; y &lt; n; y++)&#123; if(x == 0 &amp;&amp; y == 0)&#123; dist[0][0] = grid[0][0]; &#125;else&#123; dist[x][y] = min(getDist(dist, x-1, y), getDist(dist, x, y-1)) + grid[x][y]; &#125; &#125; &#125; return dist[m-1][n-1]; &#125;&#125; my code 1234567891011121314public class Solution &#123; public int minPathSum(int[][] grid) &#123; int m=grid.length; int n=grid[0].length; for(int i=0; i&lt;m; i++) for(int j=0; j&lt;n; j++)&#123; if(i==0 &amp;&amp; j==0) continue; if(i&gt;0 &amp;&amp; j==0) grid[i][j] += grid[i-1][j]; if(i==0 &amp;&amp; j&gt;0) grid[i][j] += grid[i][j-1]; if(i&gt;0 &amp;&amp; j&gt;0) grid[i][j] += Math.min(grid[i][j-1], grid[i-1][j]); &#125; return grid[m-1][n-1]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[063. Unique Paths II]]></title>
    <url>%2Fp%2F64df03c8%2F</url>
    <content type="text"><![CDATA[31.1% https://leetcode.com/problems/unique-paths-ii/ Follow up for â€œUnique Pathsâ€: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. 12345678910For example,There is one obstacle in the middle of a 3x3 grid as illustrated below.[ [0,0,0], [0,1,0], [0,0,0]]The total number of unique paths is 2. Note: m and n will be at most 100. æ–¹æ³•ä¸€ï¼š m*nï¼Œå˜ä¸º(m+1) * (n+1) ï¼Œç„¶åŽï¼ˆ0,1ï¼‰è®¾ä¸º1ï¼Œä¾æ¬¡éåŽ†å°±å¥½äº†ã€‚ 12345678910111213class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i = 1; i &lt;= m; ++i) for(int j = 1; j &lt;= n; ++j) if(!obstacleGrid[i-1][j-1]) dp[i][j] = dp[i-1][j] + dp[i][j-1]; return dp[m][n]; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i=1; i&lt;=m; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; if(obstacleGrid[i-1][j-1]) dp[i][j] = 0; else dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; æ–¹æ³•äºŒï¼š ä¸Šé¢çš„ç©ºé—´æ˜¯Oï¼ˆmnï¼‰ï¼Œæƒ³æ³•ç©ºé—´å˜ä¸ºOï¼ˆnï¼‰æˆ–è€…Oï¼ˆmï¼‰ã€‚ æˆ‘çš„ä»£ç å®žçŽ°ï¼š Dec 7th, 2017 è¯¥æ–¹æ³•ä¸»è¦æ˜¯é™ä½Žäº†ç©ºé—´å¤æ‚åº¦ï¼Œç›¸å¯¹äºŽä¸‹é¢çš„ä»£ç ï¼Œè¿™ä¸ªå€Ÿé‰´äº†ä¸Šé¢çš„æ€æƒ³ï¼Œä¸æ˜¯è®¾ç½®mä¸ªï¼Œè€Œæ˜¯m+1ä¸ªã€‚è¿™æ ·å­å°±ä»£ç ç®€æ´å’Œæ€è·¯æ¸…æ™°å¤šäº†ã€‚ æ³¨æ„ä»£ç ä¸­æ³¨é‡Šå¯èƒ½ä¼šçŠ¯çš„é”™ã€‚ 1234567891011121314151617class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; if(obstacleGrid.empty() || obstacleGrid[0].empty()) return 0; int m = obstacleGrid[0].size(); vector&lt;int&gt; res(m+1, 0); res[1] = 1; // ä¸è¦å¿˜äº†åˆå§‹åŒ– for(int i=0; i&lt;obstacleGrid.size(); i++) for(int j=0; j&lt;obstacleGrid[0].size(); j++) if(obstacleGrid[i][j]==0) //åˆ†æ¸…æ¥š0è¿˜æ˜¯1ï¼Œæ¡ä»¶ res[j+1] += res[j]; else res[j+1] = 0; return res[m];// m+1ä¸ªæœ€åŽä¸€ä½æ˜¯res[m],ä¸æ˜¯res[m+1] &#125;&#125;; 123456789101112131415161718192021222324252627class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); if(m==0 || n==0) return 0; vector&lt;int&gt; res(n, 0); if(obstacleGrid[0][0]==1) return 0; res[0] = 1; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(i==0 &amp;&amp; j==0) continue; if(i&gt;0 &amp;&amp; j==0)&#123; if(obstacleGrid[i][j]) res[j] = 0; &#125; if(j&gt;0)&#123; if(obstacleGrid[i][j]) res[j] = 0; else res[j] += res[j-1]; &#125; &#125; &#125; return res[n-1]; &#125;&#125;; cpp https://leetcode.com/discuss/13965/my-c-dp-solution-very-simple My C++ Dp solution , very simple! just use dp to find the answer , if there is a obstacle at (i,j), then dp[i][j] = 0. time is O(nm) , space is O(nm) . here is my code: 5ms, 8.13%, June.22th, 2016 12345678910111213class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i = 1; i &lt;= m; ++i) for(int j = 1; j &lt;= n; ++j) if(!obstacleGrid[i-1][j-1]) dp[i][j] = dp[i-1][j] + dp[i][j-1]; return dp[m][n]; &#125;&#125;; https://discuss.leetcode.com/topic/15267/4ms-o-n-dp-solution-in-c-with-explanations 4ms O(n) DP Solution in C++ with Explanations Well, this problem is similar to Unique Paths. The introduction of obstacles only changes the boundary conditions and make some points unreachable (simply set to 0). Denote the number of paths to arrive at point (i, j) to be P[i][j], the state equation is P[i][j] = P[i - 1][j] + P[i][j - 1] if obstacleGrid[i][j] != 1 and 0 otherwise. Now letâ€™s finish the boundary conditions. In the Unique Paths problem, we initialize P[0][j] = 1, P[i][0] = 1 for all valid i, j. Now, due to obstacles, some boundary points are no longer reachable and need to be initialized to 0. For example, if obstacleGrid is like [0, 0, 1, 0, 0], then the last three points are not reachable and need to be initialized to be 0. The result is [1, 1, 0, 0, 0]. Now we can write down the following (unoptimized) code. Note that we pad the obstacleGrid by 1 and initialize dp[0][1] = 1 to unify the boundary cases. 12345678910111213class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt; &gt; dp(m + 1, vector&lt;int&gt; (n + 1, 0)); dp[0][1] = 1; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (!obstacleGrid[i - 1][j - 1]) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; return dp[m][n]; &#125; &#125;; Well, the code is accepted but it has some obvious redundancy. There are two major concerns: Each time when we update path[i][j], we only need path[i - 1][j] (at the same column) and path[i][j - 1] (at the left column), so it is unnecessary to maintain the full m*n matrix. Maintaining two columns is enough.There are some cases that the loop can be terminated earlier. Suppose obstacleGrid = [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]], then we can see that it is impossible to reach the bottom-right corner after updating the second column since the number of paths to reach each element in the second column is 0.Taken these into considerations, we write down the following optimized code. 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;int&gt; pre(m, 0); vector&lt;int&gt; cur(m, 0); for (int i = 0; i &lt; m; i++) &#123; if (!obstacleGrid[i][0]) pre[i] = 1; else break; &#125; for (int j = 1; j &lt; n; j++) &#123; bool flag = false; if (!obstacleGrid[0][j]) &#123; cur[0] = pre[0]; if (cur[0]) flag = true; &#125; else cur[0] = 0; for (int i = 1; i &lt; m; i++) &#123; if (!obstacleGrid[i][j]) &#123; cur[i] = cur[i - 1] + pre[i]; if (cur[i]) flag = true; &#125; else cur[i] = 0; &#125; if (!flag) return 0; swap(pre, cur); &#125; return pre[m - 1]; &#125;&#125;; Further inspecting the above code, keeping two vectors only serve for the purpose of recovering pre[i], which is simply cur[i] before its update. So we can use only one vector and the space is further optimized. 12345678910111213141516171819202122232425262728class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;int&gt; cur(m, 0); for (int i = 0; i &lt; m; i++) &#123; if (!obstacleGrid[i][0]) cur[i] = 1; else break; &#125; for (int j = 1; j &lt; n; j++) &#123; bool flag = false; if (obstacleGrid[0][j]) cur[0] = 0; else flag = true; for (int i = 1; i &lt; m; i++) &#123; if (!obstacleGrid[i][j]) &#123; cur[i] += cur[i - 1]; if (cur[i]) flag = true; &#125; else cur[i] = 0; &#125; if (!flag) return 0; &#125; return cur[m - 1]; &#125;&#125;; python https://leetcode.com/discuss/19681/accepted-simple-python-in-place-solution Accepted simple Python in-place solution As below. Any comments on how to make it shorter? Thx! 68ms, 14.48%, June.22th, 20161234567891011121314151617class Solution(object): def uniquePathsWithObstacles(self, obstacleGrid): &quot;&quot;&quot; :type obstacleGrid: List[List[int]] :rtype: int &quot;&quot;&quot; m = len(obstacleGrid) n = len(obstacleGrid[0]) ResGrid = [[0 for x in range(n+1)] for x in range(m+1)] ResGrid[0][1] = 1 for i in range(1, m+1): for j in range(1, n+1): if not obstacleGrid[i-1][j-1]: ResGrid[i][j] = ResGrid[i][j-1] + ResGrid[i-1][j] return ResGrid[m][n] java https://leetcode.com/discuss/29816/short-java-solution Short JAVA solution 1ms, 22.20%, June.22th, 20161234567891011121314public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int width = obstacleGrid[0].length; int[] dp = new int[width]; dp[0] = 1; for(int[] row:obstacleGrid) for(int j=0; j&lt;width; j++) if(row[j] == 1) dp[j] = 0; else if(j&gt;0) dp[j] += dp[j-1]; return dp[width - 1]; &#125;&#125; https://discuss.leetcode.com/topic/4987/java-solution-using-dynamic-programming-o-1-space Java Solution using Dynamic Programming, O(1) space 12345678910111213141516171819202122232425262728public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; //Empty case if(obstacleGrid.length == 0) return 0; int rows = obstacleGrid.length; int cols = obstacleGrid[0].length; for(int i = 0; i &lt; rows; i++)&#123; for(int j = 0; j &lt; cols; j++)&#123; if(obstacleGrid[i][j] == 1) obstacleGrid[i][j] = 0; else if(i == 0 &amp;&amp; j == 0) obstacleGrid[i][j] = 1; else if(i == 0) obstacleGrid[i][j] = obstacleGrid[i][j - 1] * 1;// For row 0, if there are no paths to left cell, then its 0,else 1 else if(j == 0) obstacleGrid[i][j] = obstacleGrid[i - 1][j] * 1;// For col 0, if there are no paths to upper cell, then its 0,else 1 else obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]; &#125; &#125; return obstacleGrid[rows - 1][cols - 1]; &#125;&#125; https://discuss.leetcode.com/topic/9687/easy-java-solution-in-place-dp Easy Java solution, in-place, DP The idea is simple, set all obstacles to be 0 while doing the DP. No extra space is used. 123456789101112131415161718192021public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length; int n = obstacleGrid[0].length; obstacleGrid[0][0]^=1; for(int i = 1;i&lt;m;i++)&#123; obstacleGrid[i][0]=(obstacleGrid[i][0]==1)? 0:obstacleGrid[i-1][0]; &#125; for(int j = 1;j&lt;n;j++)&#123; obstacleGrid[0][j] =(obstacleGrid[0][j]==1)? 0: obstacleGrid[0][j-1]; &#125; for(int i = 1;i&lt;m;i++)&#123; for(int j =1;j&lt;n;j++)&#123; obstacleGrid[i][j] =(obstacleGrid[i][j]==1)? 0: obstacleGrid[i-1][j]+obstacleGrid[i][j-1]; &#125; &#125; return obstacleGrid[m-1][n-1]; &#125; &#125; my codeåŠ¨æ€è§„åˆ’ 12345678910111213141516171819202122232425public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; if(obstacleGrid.length == 0 || obstacleGrid[0].length == 0) return 0; int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[] ans = new int[n]; if(obstacleGrid[0][0]==1) return 0; ans[0] = 1; for(int i=0; i&lt;m; i++) for(int j=0; j&lt;n; j++)&#123; if(i==0 &amp;&amp; j==0) continue; if(i&gt;0 &amp;&amp; j==0)&#123; if(obstacleGrid[i][j]==1) ans[j] = 0; &#125; if(j&gt;0)&#123; if(obstacleGrid[i][j]==1) ans[j] = 0; else ans[j] += ans[j-1]; &#125; &#125; return ans[n-1]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[062. Unique Paths]]></title>
    <url>%2Fp%2F59afcf56%2F</url>
    <content type="text"><![CDATA[39.7% https://leetcode.com/problems/unique-paths/ A robot is located at the top-left corner of a m x n grid (marked â€˜Startâ€™ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked â€˜Finishâ€™ in the diagram below). How many possible unique paths are there? Above is a 3 x 7 grid. How many possible unique paths are there? è§£æž ç”¨dpç®—æ³•æˆ–è€…ä½¿ç”¨å…¬å¼ï¼Œå…±m+n-2æ­¥ï¼Œç„¶åŽä»Žä¸­é€‰å–m-1æ­¥ä½œä¸ºå‘å³ã€‚ æ–¹æ³•ä¸€ï¼š dpç®—æ³•è®°å½•æ¯ä¸€æ­¥æœ‰çš„æ–¹æ³•æ•°ï¼Œä»¥æ­¤ç±»æŽ¨ã€‚ 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; if(m==0 || n==0) return 0; vector&lt;int&gt; dp(n, 1); for(int i=1; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; dp[j] += dp[j-1]; &#125; &#125; return dp[n-1]; &#125;&#125;; ç±»ä¼¼çš„æ–¹æ³•ï¼Œ ä¸Šé¢çš„æ›´ç®€å•ã€‚ 1234567891011121314class Solution &#123;public: int uniquePaths(int m, int n) &#123; if(m==0 || n==0) return 0; vector&lt;int&gt; dp(n, 0); dp[0] = 1; for(int i=0; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; dp[j] += dp[j-1]; &#125; &#125; return dp[n-1]; &#125;&#125;; æ–¹æ³•äºŒï¼š ä½¿ç”¨å…¬å¼çš„è¯ï¼Œè®°å¾—å®šä¹‰å€¼çš„ç±»åž‹è¦ä¸ºdoubleï¼Œå¦åˆ™æ•°å€¼å°±ä¼šå‡ºé—®é¢˜ã€‚ 123456789101112131415class Solution &#123; public: int uniquePaths(int m, int n) &#123; int N = n + m - 2;// how much steps we need to do int k = m - 1; // number of steps that need to go down double res = 1; // here we calculate the total possible path number // Combination(N, k) = n! / (k!(n - k)!) // reduce the numerator and denominator and get // C = ( (n - k + 1) * (n - k + 2) * ... * n ) / k! for (int i = 1; i &lt;= k; i++) res = res * (N - k + i) / i; return (int)res; &#125; &#125;; my code: 1234567891011class Solution &#123;public: int uniquePaths(int m, int n) &#123; if(m==0 || n==0) return 0; double res = 1.0; for(int i=1; i&lt;=n-1; i++)&#123; res = res * (m-1+i) / i; &#125; return (int)res; &#125;&#125;; æ–¹æ³•ä¸‰ï¼š m+1 * n+1æ•°ç»„ 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i=1; i&lt;=m; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; cpp https://discuss.leetcode.com/topic/15265/0ms-5-lines-dp-solution-in-c-with-explanations 0ms, 5-lines DP Solution in C++ with Explanations This is a fundamental DP problem. First of all, letâ€™s make some observations. Since the robot can only move right and down, when it arrives at a point, there are only two possibilities: It arrives at that point from above (moving down to that point); It arrives at that point from left (moving right to that point).Thus, we have the following state equations: suppose the number of paths to arrive at a point (i, j) is denoted as P[i][j], it is easily concluded that P[i][j] = P[i - 1][j] + P[i][j - 1]. The boundary conditions of the above equation occur at the leftmost column (P[i][j - 1] does not exist) and the uppermost row (P[i - 1][j] does not exist). These conditions can be handled by initialization (pre-processing) â€” initialize P[0][j] = 1, P[i][0] = 1 for all valid i, j. Note the initial value is 1 instead of 0! Now we can write down the following (unoptimized) code. 123456789class Solution &#123; int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt; &gt; path(m, vector&lt;int&gt; (n, 1)); for (int i = 1; i &lt; m; i++) for (int j = 1; j &lt; n; j++) path[i][j] = path[i - 1][j] + path[i][j - 1]; return path[m - 1][n - 1]; &#125;&#125;; As can be seen, the above solution runs in O(n^2) time and costs O(m*n) space. However, you may have observed that each time when we update path[i][j], we only need path[i - 1][j] (at the same column) and path[i][j - 1] (at the left column). So it is enough to maintain two columns (the current column and the left column) instead of maintaining the full m*n matrix. Now the code can be optimized to have O(min(m, n)) space complexity. 12345678910111213class Solution &#123; int uniquePaths(int m, int n) &#123; if (m &gt; n) return uniquePaths(n, m); vector&lt;int&gt; pre(m, 1); vector&lt;int&gt; cur(m, 1); for (int j = 1; j &lt; n; j++) &#123; for (int i = 1; i &lt; m; i++) cur[i] = cur[i - 1] + pre[i]; swap(pre, cur); &#125; return pre[m - 1]; &#125;&#125;; Further inspecting the above code, we find that keeping two columns is used to recover pre[i], which is just cur[i] before its update. So there is even no need to use two vectors and one is just enough. Now the space is further saved and the code also gets much shorter. 12345678910class Solution &#123; int uniquePaths(int m, int n) &#123; if (m &gt; n) return uniquePaths(n, m); vector&lt;int&gt; cur(m, 1); for (int j = 1; j &lt; n; j++) for (int i = 1; i &lt; m; i++) cur[i] += cur[i - 1]; return cur[m - 1]; &#125;&#125;; Well, till now, I guess you may even want to optimize it to O(1) space complexity since the above code seems to rely on only cur[i] and cur[i - 1]. You may think that 2 variables is enough? Well, it is not. Since the whole cur needs to be updated for n - 1 times, it means that all of its values need to be saved for next update and so two variables is not enough. https://leetcode.com/discuss/9110/my-ac-solution-using-formula 0ms, 17.54%, June.19th, 2016 Binomial coefficient: 123456789101112131415class Solution &#123; public: int uniquePaths(int m, int n) &#123; int N = n + m - 2;// how much steps we need to do int k = m - 1; // number of steps that need to go down double res = 1; // here we calculate the total possible path number // Combination(N, k) = n! / (k!(n - k)!) // reduce the numerator and denominator and get // C = ( (n - k + 1) * (n - k + 2) * ... * n ) / k! for (int i = 1; i &lt;= k; i++) res = res * (N - k + i) / i; return (int)res; &#125; &#125;; First of all you should understand that we need to do n + m - 2 movements : m - 1 down, n - 1 right, because we start from cell (1, 1). Secondly, the path it is the sequence of movements( go down / go right), therefore we can say that two paths are different when there is i-th (1 .. m + n - 2) movement in path1 differ i-th movement in path2. So, how we can build paths. Letâ€™s choose (n - 1) movements(number of steps to the right) from (m + n - 2), and rest (m - 1) is (number of steps down). I think now it is obvious that count of different paths are all combinations (n - 1) movements from (m + n-2). python https://leetcode.com/discuss/63819/1-line-math-solution-python 1 Line Math Solution (Python) 48ms, 54.13%, June.19th, 201612345678class Solution(object): def uniquePaths(self, m, n): &quot;&quot;&quot; :type m: int :type n: int :rtype: int &quot;&quot;&quot; return math.factorial(m+n-2) / math.factorial(m-1) / math.factorial(n-1) https://discuss.leetcode.com/topic/6440/accpeted-simple-python-dp-solution Accpeted simple Python DP solution. 12345678class Solution: # @return an integer def uniquePaths(self, m, n): aux = [[1 for x in range(n)] for x in range(m)] for i in range(1, m): for j in range(1, n): aux[i][j] = aux[i][j-1]+aux[i-1][j] return aux[-1][-1] my code 1234567891011121314151617181920212248ms, 54.13%, June.19th, 2016class Solution(object): def uniquePaths(self, m, n): &quot;&quot;&quot; :type m: int :type n: int :rtype: int &quot;&quot;&quot; if m == 1 or n == 1: return 1 p1 = max(m-1, n-1) p2 = min(m-1, n-1) p3 = m + n - 2 res1 = 1 i = p3 while i &gt; p3 - p2: res1 *= i i -= 1 res2 = 1 while p2 &gt; 0: res2 *= p2 p2 -= 1 return res1 / res2 java https://discuss.leetcode.com/topic/5623/java-dp-solution-with-complexity-o-n-m Java DP solution with complexity O(n*m) 1234567891011121314151617public class Solution &#123; public int uniquePaths(int m, int n) &#123; Integer[][] map = new Integer[m][n]; for(int i = 0; i&lt;m;i++)&#123; map[i][0] = 1; &#125; for(int j= 0;j&lt;n;j++)&#123; map[0][j]=1; &#125; for(int i = 1;i&lt;m;i++)&#123; for(int j = 1;j&lt;n;j++)&#123; map[i][j] = map[i-1][j]+map[i][j-1]; &#125; &#125; return map[m-1][n-1]; &#125;&#125; The assumptions are When (n == 0||m == 0) the function always returns 1 since the robot canâ€™t go left or up. For all other cells. The result = uniquePaths(m-1,n)+uniquePaths(m,n-1) Therefore I populated the edges with 1 first and use DP to get the full 2-D array. Please give any suggestions on improving the code. my code 1234567891011121314public class Solution &#123; public int uniquePaths(int m, int n) &#123; if(m == 0 || n == 0) return 0; int[] ans = new int[n]; for(int i=0; i&lt;n; i++) ans[i] = 1; for(int i=1; i&lt;m; i++) for(int j=1; j&lt;n; j++) ans[j] += ans[j-1]; return ans[n-1]; &#125;&#125; 123456789100ms, 84.01%, June.19th, 2016https://leetcode.com/discuss/9110/my-ac-solution-using-formulapublic class Solution &#123; public int uniquePaths(int m, int n) &#123; double value = 1; for(int i = 1; i &lt;= n-1; i++) value *= ((double)(m+i-1)/(double)i); return (int)Math.round(value); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[061. Rotate List]]></title>
    <url>%2Fp%2F61df86e1%2F</url>
    <content type="text"><![CDATA[24.3% https://leetcode.com/problems/rotate-list/ Given a list, rotate the list to the right by k places, where k is non-negative. 123For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. æ–¹æ³•ä¸€ï¼š å…ˆéåŽ†ä¸€éï¼Œæ±‚å‡ºé•¿åº¦ é€šè¿‡å°†å°¾èŠ‚ç‚¹ä¸Žå¤´ç»“ç‚¹ç›¸é“¾æŽ¥ ç„¶åŽå‘å‰èµ° len - k%lenæ­¥ï¼Œå°±å¯ä»¥äº†ã€‚ æ ¸å¿ƒï¼šä¸€æ¬¡éåŽ†æ±‚é•¿åº¦ï¼Œç„¶åŽå°¾éƒ¨ç›¸è¿ž æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct, 11th, 2017 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; // æ˜¯æˆ–||çš„å…³ç³»ï¼Œä¸æ˜¯&amp;&amp; // k==0çš„æƒ…å†µè¦è€ƒè™‘åˆ° if(!head || !head-&gt;next || k==0) return head; ListNode* p1 = head; int cnt = 1; while(p1-&gt;next)&#123; cnt++; p1 = p1-&gt;next; &#125; // çŽ°é™¤ä»¥cnt // è¦ç§»åŠ¨çš„æ­¥æ•°ï¼Œéœ€è¦ç”¨cnt-k k %= cnt; k = cnt -k; p1-&gt;next = head; while(k!=0)&#123; p1 = p1-&gt;next; k--; &#125; ListNode* node = p1-&gt;next; p1-&gt;next = nullptr; return node; &#125;&#125;; C++ simple algorithm with explanation Enumerate through the list to find the last node, count the size along the way. Make a loop, by connection last to first Get modulo of |k/size| - avoiding extra rotation Enumerate again size-k nodes Break the loop and return new head code: 123456789101112131415161718192021222324252627282930ListNode *rotateRight(ListNode *head, int k) &#123; if(head == NULL || head-&gt;next == NULL||k==0) return head; ListNode* node = head; int size =1; while(node-&gt;next != NULL) &#123; size++; node = node-&gt;next; &#125; //loop the list node-&gt;next=head; //handle the case of k&gt;size k = k%size; //find the node to break the loop at while(--size &gt;= k) &#123; node=node-&gt;next; &#125; ListNode* first = node-&gt;next; node-&gt;next=NULL; return first; &#125; ä»£ç çš„å¦ä¸€ç§å®žçŽ° My clean C++ code, quite standard (find tail and reconnect the list) There is no trick for this problem. Some people used slow/fast pointers to find the tail node but I donâ€™t see the benefit (in the sense that it doesnâ€™t reduce the pointer move op) to do so. So I just used one loop to find the length first. 12ms, September 11, 2016 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(!head) return head; int len=1; // number of nodes ListNode *newH, *tail; newH=tail=head; while(tail-&gt;next) // get the number of nodes in the list &#123; tail = tail-&gt;next; len++; &#125; tail-&gt;next = head; // circle the link if(k %= len) &#123; for(auto i=0; i&lt;len-k; i++) tail = tail-&gt;next; // the tail node is the (len-k)-th node (1st node is head) &#125; newH = tail-&gt;next; tail-&gt;next = NULL; return newH; &#125;&#125;; https://discuss.leetcode.com/topic/815/what-to-do-when-k-is-greater-than-size-of-list What to do when k is greater than size of list ? i am not getting that what i should do when K is greater than size of the list. https://discuss.leetcode.com/topic/815/what-to-do-when-k-is-greater-than-size-of-list/2 Letâ€™s start with an example. Given [0,1,2], rotate 1 steps to the right -&gt; [2,0,1]. Given [0,1,2], rotate 2 steps to the right -&gt; [1,2,0]. Given [0,1,2], rotate 3 steps to the right -&gt; [0,1,2]. Given [0,1,2], rotate 4 steps to the right -&gt; [2,0,1]. So, no matter how big K, the number of steps is, the result is always the same as rotating K % n steps to the right. https://discuss.leetcode.com/topic/9161/i-think-the-description-of-this-problem-is-misleading I think the description of this problem is misleading. Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle. cpp https://discuss.leetcode.com/topic/14470/my-clean-c-code-quite-standard-find-tail-and-reconnect-the-list My clean C++ code, quite standard (find tail and reconnect the list) There is no trick for this problem. Some people used slow/fast pointers to find the tail node but I donâ€™t see the benefit (in the sense that it doesnâ€™t reduce the pointer move op) to do so. So I just used one loop to find the length first. 12ms, September 11, 2016 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(!head) return head; int len=1; // number of nodes ListNode *newH, *tail; newH=tail=head; while(tail-&gt;next) // get the number of nodes in the list &#123; tail = tail-&gt;next; len++; &#125; tail-&gt;next = head; // circle the link if(k %= len) &#123; for(auto i=0; i&lt;len-k; i++) tail = tail-&gt;next; // the tail node is the (len-k)-th node (1st node is head) &#125; newH = tail-&gt;next; tail-&gt;next = NULL; return newH; &#125;&#125;; https://discuss.leetcode.com/topic/7293/c-simple-algorithm-with-explanation C++ simple algorithm with explanation Enumerate through the list to find the last node, count the size along the way. Make a loop, by connection last to first Get modulo of |k/size| - avoiding extra rotation Enumerate again size-k nodes Break the loop and return new head code: 123456789101112131415161718192021222324252627282930ListNode *rotateRight(ListNode *head, int k) &#123; if(head == NULL || head-&gt;next == NULL||k==0) return head; ListNode* node = head; int size =1; while(node-&gt;next != NULL) &#123; size++; node = node-&gt;next; &#125; //loop the list node-&gt;next=head; //handle the case of k&gt;size k = k%size; //find the node to break the loop at while(--size &gt;= k) &#123; node=node-&gt;next; &#125; ListNode* first = node-&gt;next; node-&gt;next=NULL; return first; &#125; java 1ms, September 11, 2016 https://discuss.leetcode.com/topic/2861/share-my-java-solution-with-explanation Share my java solution with explanation Since n may be a large number compared to the length of list. So we need to know the length of linked list.After that, move the list after the (l-n%l )th node to the front to finish the rotation. Ex: {1,2,3} k=2 Move the list after the 1st node to the front Ex: {1,2,3} k=5, In this case Move the list after (3-5%3=1)st node to the front. So the code has three parts. Get the length Move to the (l-n%l)th node 3)Do the rotation 12345678910111213141516171819public ListNode rotateRight(ListNode head, int n) &#123; if (head==null||head.next==null) return head; ListNode dummy=new ListNode(0); dummy.next=head; ListNode fast=dummy,slow=dummy; int i; for (i=0;fast.next!=null;i++)//Get the total length fast=fast.next; for (int j=i-n%i;j&gt;0;j--) //Get the i-n%i th node slow=slow.next; fast.next=dummy.next; //Do the rotation dummy.next=slow.next; slow.next=null; return dummy.next;&#125; https://discuss.leetcode.com/topic/26364/clean-java-solution-with-brief-explanation Clean Java Solution with Brief Explanation The basic idea is to link the tail of the list with the head, make it a cycle. Then count to the rotate point and cut it. 123456789101112131415161718192021if (head == null) return head; ListNode copyHead = head; int len = 1; while (copyHead.next != null) &#123; copyHead = copyHead.next; len++; &#125; copyHead.next = head; for (int i = len - k % len; i &gt; 1; i--) head = head.next; copyHead = head.next; head.next = null; return copyHead;&#125; https://discuss.leetcode.com/topic/10991/my-short-java-solution-with-comments My short java solution with comments 1234567891011121314151617public ListNode rotateRight(ListNode head, int k) &#123; if(head==null||head.next==null||k==0) return head; //make it a cricle, break from k postion far from the head ListNode index=head; int len=1;// int len to record the length of list while(index.next!=null) &#123;index=index.next; len++;&#125; index.next=head; for(int i=0;i&lt;len-k%len;i++) &#123; index=index.next; &#125; ListNode result=index.next; index.next=null; return result;&#125; https://discuss.leetcode.com/topic/42445/java-clean-solution-only-one-pointer-used Java clean solution, only one pointer used I first used a ListNode p, and point it to the head, then move it to the end of the list, and at the same time get the length of the list. Then p.next = head; gives me a circle. At this time, by moving p for len-k times, it will be pointing to the node before the break point. Then all we need to do is record the next node as head, and break the circle with p.next = null. 12345678910111213141516171819public ListNode rotateRight(ListNode head, int k) &#123; if(head == null || k == 0) &#123; return head; &#125; ListNode p = head; int len = 1; while(p.next != null) &#123; p = p.next; len++; &#125; p.next = head; k %= len; for(int i = 0; i &lt; len - k; i++) &#123; p = p.next; &#125; head = p.next; p.next = null; return head;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[060. Permutation Sequence]]></title>
    <url>%2Fp%2F7d81a399%2F</url>
    <content type="text"><![CDATA[28.6% https://leetcode.com/problems/permutation-sequence/ The set [1,2,3,â€¦,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, 12345678We get the following sequence (ie, for n = 3):1. &quot;123&quot;2. &quot;132&quot;3. &quot;213&quot;4. &quot;231&quot;5. &quot;312&quot;6. &quot;321&quot; Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. éœ€è¦å†æ€è€ƒ cpp https://discuss.leetcode.com/topic/3313/most-concise-c-solution-minimal-memory-required Most concise C++ solution, minimal memory required 1234567891011121314151617181920string getPermutation(int n, int k) &#123; int i,j,f=1; // left part of s is partially formed permutation, right part is the leftover chars. string s(n,&apos;0&apos;); for(i=1;i&lt;=n;i++)&#123; f*=i; s[i-1]+=i; // make s become 1234...n &#125; for(i=0,k--;i&lt;n;i++)&#123; f/=n-i; j=i+k/f; // calculate index of char to put at s[i] char c=s[j]; // remove c by shifting to cover up (adjust the right part). for(;j&gt;i;j--) s[j]=s[j-1]; k%=f; s[i]=c; &#125; return s;&#125; https://discuss.leetcode.com/topic/7002/sharing-my-straightforward-c-solution-with-explanation Sharing my straightforward C++ solution with explanation 12345678910111213141516171819202122232425string getPermutation(int n, int k) &#123; int pTable[10] = &#123;1&#125;; for(int i = 1; i &lt;= 9; i++)&#123; pTable[i] = i * pTable[i - 1]; &#125; string result; vector&lt;char&gt; numSet; numSet.push_back(&apos;1&apos;); numSet.push_back(&apos;2&apos;); numSet.push_back(&apos;3&apos;); numSet.push_back(&apos;4&apos;); numSet.push_back(&apos;5&apos;); numSet.push_back(&apos;6&apos;); numSet.push_back(&apos;7&apos;); numSet.push_back(&apos;8&apos;); numSet.push_back(&apos;9&apos;); while(n &gt; 0)&#123; int temp = (k - 1) / pTable[n - 1]; result += numSet[temp]; numSet.erase(numSet.begin() + temp); k = k - temp * pTable[n - 1]; n--; &#125; return result;&#125; In this program, pTable refers to permutation table and numSet refers to a set of numbers from 1 to 9. Before while loop, we need to initialize pTable and numSet, which is trivial. In while loop, we do these following things. 1 calculate which number we will use. 2 remove that number from numSet. 3 recalculate k. 4 nâ€“. Finally, we return result. https://discuss.leetcode.com/topic/19181/0ms-c-12-line-concise-solution-no-recursion-no-helper-function 0ms C++ 12-line concise solution (no recursion, no helper function) Attached please find my solution. Idea: For an n-element permutation, there are (n-1)! permutations started with â€˜1â€™, (n-1)! permutations started with â€˜2â€™, and so forth. Therefore we can determine the value of the first element. After determining the first element, there are (n-1) candidates left. Then there are (n-2)! permutations started with the minimum element within the remaining set, and so forth. Complexities: Time complexity: O(n^2) Space complexity: O(n) 123456789101112131415161718192021222324252627class Solution &#123;public: string getPermutation(int n, int k) &#123; // initialize a dictionary that stores 1, 2, ..., n. This string will store the permutation. string dict(n, 0); iota(dict.begin(), dict.end(), &apos;1&apos;); // build up a look-up table, which stores (n-1)!, (n-2)!, ..., 1!, 0! vector&lt;int&gt; fract(n, 1); for (int idx = n - 3; idx &gt;= 0; --idx) &#123; fract[idx] = fract[idx + 1] * (n - 1 - idx); &#125; // let k be zero base --k; // the main part. string ret(n, 0); for (int idx = 0; idx &lt; n; ++idx) &#123; int select = k / fract[idx]; k %= fract[idx]; ret[idx] = dict[select]; dict.erase(next(dict.begin(), select)); // note that it is an O(n) operation &#125; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/37865/simple-0s-c-solution Simple 0s C++ solution since n will be between 1 and 9 inclusive. pre-calculate the factorials is faster. 12345678910111213141516class Solution &#123;public: string getPermutation(int n, int k) &#123; string res; string nums = &quot;123456789&quot;; int f[10] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;; --k; for (int i = n; i &gt;= 1; --i) &#123; int j = k / f[i - 1]; k %= f[i - 1]; res.push_back(nums[j]); nums.erase(nums.begin() + j); &#125; return res; &#125;&#125;; python 44ms, 90.94%, 17 July 2016 https://discuss.leetcode.com/topic/19269/share-my-python-solution-with-detailed-explanation Share my Python solution with detailed explanation The idea is as follow: For permutations of n, the first (n-1)! permutations start with 1, next (n-1)! ones start with 2, â€¦ and so on. And in each group of (n-1)! permutations, the first (n-2)! permutations start with the smallest remaining number, â€¦ take n = 3 as an example, the first 2 (that is, (3-1)! ) permutations start with 1, next 2 start with 2 and last 2 start with 3. For the first 2 permutations (123 and 132), the 1st one (1!) starts with 2, which is the smallest remaining number (2 and 3). So we can use a loop to check the region that the sequence number falls in and get the starting digit. Then we adjust the sequence number and continue. 123456789101112131415161718import mathclass Solution: # @param &#123;integer&#125; n # @param &#123;integer&#125; k # @return &#123;string&#125; def getPermutation(self, n, k): numbers = range(1, n+1) permutation = &apos;&apos; k -= 1 while n &gt; 0: n -= 1 # get the index of current digit index, k = divmod(k, math.factorial(n)) permutation += str(numbers[index]) # remove handled number numbers.remove(numbers[index]) return permutation https://discuss.leetcode.com/topic/1746/does-anyone-have-a-better-idea-share-my-accepted-python-code-here Does anyone have a better idea? Share my accepted python code here Itâ€™s obvious that if we try to come up with n! solutions one by one until it reach kth element - O(k), it will exceed the time limit. Therefore, I tried to implement a mathematical solution as follows: 1234567891011121314151617181920212223242526272829class Solution: # @return a string def getPermutation(self, n, k): ll = [str(i) for i in range(1,n+1)] # build a list of [&quot;1&quot;,&quot;2&quot;,...&quot;n&quot;] divisor = 1 for i in range(1,n): # calculate 1*2*3*...*(n-1) divisor *= i answer = &quot;&quot; while k&gt;0 and k&lt;=divisor*n: # there are only (divisor*n) solutions in total group_num = k/divisor k %= divisor if k&gt;0: # it&apos;s kth element of (group_num+1)th group choose = ll.pop(group_num) answer += choose else: # it&apos;s last element of (group_num)th group choose = ll.pop(group_num-1) answer += choose ll.reverse() # reverse the list to get DESC order for the last element to_add = &quot;&quot;.join(ll) answer += to_add break divisor/=len(ll) return answer Briefly take (n,k) = (4,21) for example, in the first iteration we divide the solution set into 4 groups: â€œ1xxxâ€, â€œ2xxxâ€, â€œ3xxxâ€, and â€œ4xxxâ€, while each group has 3! = 6 members. From 21/6 = 3â€¦3, we know that the 21th element is the 3rd element in the (3+1)th group. In this group, we can divide it into 3 sub-groups again: â€œ41xxâ€, â€œ42xxâ€ and â€œ43xxâ€, and each group has 2!=2 members. Then, we calculate 3/2 and get 1â€¦1, so itâ€™s the 1st element of (1+1)nd sub-group - â€œ421xâ€, and now it reach the base case with only one possibility - â€œ4213â€. Anyone pass the problem with different ideas? java https://discuss.leetcode.com/topic/17348/explain-like-i-m-five-java-solution-in-o-n â€œExplain-like-Iâ€™m-fiveâ€ Java Solution in O(n) Iâ€™m sure somewhere can be simplified so itâ€™d be nice if anyone can let me know. The pattern was that: say n = 4, you have {1, 2, 3, 4} If you were to list out all the permutations you have 1 + (permutations of 2, 3, 4) 2 + (permutations of 1, 3, 4) 3 + (permutations of 1, 2, 4) 4 + (permutations of 1, 2, 3) We know how to calculate the number of permutations of n numbersâ€¦ n! So each of those with permutations of 3 numbers means there are 6 possible permutations. Meaning there would be a total of 24 permutations in this particular one. So if you were to look for the (k = 14) 14th permutation, it would be in the 3 + (permutations of 1, 2, 4) subset. To programmatically get that, you take k = 13 (subtract 1 because of things always starting at 0) and divide that by the 6 we got from the factorial, which would give you the index of the number you want. In the array {1, 2, 3, 4}, k/(n-1)! = 13/(4-1)! = 13/3! = 13/6 = 2. The array {1, 2, 3, 4} has a value of 3 at index 2. So the first number is a 3. Then the problem repeats with less numbers. The permutations of {1, 2, 4} would be: 1 + (permutations of 2, 4) 2 + (permutations of 1, 4) 4 + (permutations of 1, 2) But our k is no longer the 14th, because in the previous step, weâ€™ve already eliminated the 12 4-number permutations starting with 1 and 2. So you subtract 12 from k.. which gives you 1. Programmatically that would beâ€¦ k = k - (index from previous) (n-1)! = k - 2(n-1)! = 13 - 2*(3)! = 1 In this second step, permutations of 2 numbers has only 2 possibilities, meaning each of the three permutations listed above a has two possibilities, giving a total of 6. Weâ€™re looking for the first one, so that would be in the 1 + (permutations of 2, 4) subset. Meaning: index to get number from is k / (n - 2)! = 1 / (4-2)! = 1 / 2! = 0.. from {1, 2, 4}, index 0 is 1 so the numbers we have so far is 3, 1â€¦ and then repeating without explanations. {2, 4} k = k - (index from pervious) (n-2)! = k - 0 (n - 2)! = 1 - 0 = 1; third numberâ€™s index = k / (n - 3)! = 1 / (4-3)! = 1/ 1! = 1â€¦ from {2, 4}, index 1 has 4 Third number is 4 {2} k = k - (index from pervious) (n - 3)! = k - 1 (4 - 3)! = 1 - 1 = 0; third numberâ€™s index = k / (n - 4)! = 0 / (4-4)! = 0/ 1 = 0â€¦ from {2}, index 0 has 2 Fourth number is 2 Giving us 3142. If you manually list out the permutations using DFS method, it would be 3142. Done! It really was all about pattern finding. 12345678910111213141516171819202122232425262728293031323334public class Solution &#123;public String getPermutation(int n, int k) &#123; int pos = 0; List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); int[] factorial = new int[n+1]; StringBuilder sb = new StringBuilder(); // create an array of factorial lookup int sum = 1; factorial[0] = 1; for(int i=1; i&lt;=n; i++)&#123; sum *= i; factorial[i] = sum; &#125; // factorial[] = &#123;1, 1, 2, 6, 24, ... n!&#125; // create a list of numbers to get indices for(int i=1; i&lt;=n; i++)&#123; numbers.add(i); &#125; // numbers = &#123;1, 2, 3, 4&#125; k--; for(int i = 1; i &lt;= n; i++)&#123; int index = k/factorial[n-i]; sb.append(String.valueOf(numbers.get(index))); numbers.remove(index); k-=index*factorial[n-i]; &#125; return String.valueOf(sb);&#125;&#125; 4ms, 3.65%, 17 July 2016 https://discuss.leetcode.com/topic/5081/an-iterative-solution-for-reference An iterative solution for reference Recursion will use more memory, while this problem can be solved by iteration. I solved this problem before, but I didnâ€™t realize that using k = k-1 would avoid dealing with case k%(n-1)!==0. Rewrote this code, should be pretty concise now. Only thing is that I have to use a list to store the remaining numbers, neither linkedlist nor arraylist are very efficient, anyone has a better idea? The logic is as follows: for n numbers the permutations can be divided to (n-1)! groups, for n-1 numbers can be divided to (n-2)! groups, and so on. Thus k/(n-1)! indicates the index of current number, and k%(n-1)! denotes remaining index for the remaining n-1 numbers.We keep doing this until n reaches 0, then we get n numbers permutations that is kth. 12345678910111213141516public String getPermutation(int n, int k) &#123; List&lt;Integer&gt; num = new LinkedList&lt;Integer&gt;(); for (int i = 1; i &lt;= n; i++) num.add(i); int[] fact = new int[n]; // factorial fact[0] = 1; for (int i = 1; i &lt; n; i++) fact[i] = i*fact[i-1]; k = k-1; StringBuilder sb = new StringBuilder(); for (int i = n; i &gt; 0; i--)&#123; int ind = k/fact[i-1]; k = k%fact[i-1]; sb.append(num.get(ind)); num.remove(ind); &#125; return sb.toString(); &#125; https://discuss.leetcode.com/topic/5081/an-iterative-solution-for-reference/2 Thanks for your post and explanation. I think linkedlist is as efficient as you can get in order to store the remaining numbers. Linkedlist may require counting index to get to the number, but it is more efficient than an array for removing elements. I havenâ€™t seen a better solution yet. We can reduce the memory usage for factorial a little by using just one integer, since we are going down in factorial anyway. I think you meant â€œpermutations can be divided into n groups with (n - 1)! elements in each groupâ€. Thus, k / (n - 1)! is the index among current n groups, and k % (n - 1)! is the index for next iteration. 123456789101112131415public String getPermutation(int n, int k) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int i = 1; i &lt;= n; i++) list.add(i); int fact = 1; for (int i = 2; i &lt;= n; i++) fact *= i; // factorial StringBuilder strBuilder = new StringBuilder(); for (k--; n &gt; 0; n--) &#123; fact /= n; strBuilder.append(list.remove(k / fact)); k %= fact; &#125; return strBuilder.toString();&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[059. Spiral Matrix II]]></title>
    <url>%2Fp%2F3551638a%2F</url>
    <content type="text"><![CDATA[38.4% https://leetcode.com/problems/spiral-matrix-ii/ Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. 123456789For example,Given n = 3,You should return the following matrix:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] æ–¹æ³•ä¸€: å€Ÿé‰´54é¢˜çš„æ€æƒ³ï¼Œç±»ä¼¼çš„ä»£ç  123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; if(n==0) return &#123;&#125;; if(n==1) return &#123;&#123;1&#125;&#125;; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n)); int i=1, up=0, down=n-1, left=0, right=n-1; while(true)&#123; for(int col=left; col&lt;=right; col++) res[up][col] = i++; if(++up&gt;down) break; for(int row=up; row&lt;=down; row++) res[row][right] = i++; if(--right&lt;left) break; for(int col=right; col&gt;=left; col--) res[down][col] = i++; if(--down&lt;up) break; for(int row=down; row&gt;=up; row--) res[row][left] = i++; if(++left&gt;right) break; &#125; return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; int cnt = 0; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); int left = 0, right = n-1, up = 0, down = n-1; while(true)&#123; for(int i=left; i&lt;=right; i++) res[up][i] = ++cnt; up++; if(up&gt;down) break; for(int j=up; j&lt;=down; j++) res[j][right] = ++cnt; right--; if(left&gt;right) break; for(int k=right; k&gt;=left; k--) res[down][k] = ++cnt; down--; if(up&gt;down) break; for(int l=down; l&gt;=up; l--) res[l][left] = ++cnt; left++; if(left&gt;right) break; &#125; return res; &#125;&#125;; cpp 4ms, 13.71%, June.19th, 2016 https://leetcode.com/discuss/21677/simple-c-solution-with-explaination 12345678910111213141516171819202122232425class Solution &#123; public: vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt; &gt; ret( n, vector&lt;int&gt;(n) ); int k = 1, i = 0; while( k &lt;= n * n ) &#123; int j = i; // four steps while( j &lt; n - i ) // 1. horizonal, left to right ret[i][j++] = k++; j = i + 1; while( j &lt; n - i ) // 2. vertical, top to bottom ret[j++][n-i-1] = k++; j = n - i - 2; while( j &gt; i ) // 3. horizonal, right to left ret[n-i-1][j--] = k++; j = n - i - 1; while( j &gt; i ) // 4. vertical, bottom to top ret[j--][i] = k++; i++; // next loop &#125; return ret; &#125; &#125;; æ–¹æ³•äºŒï¼š ä¿®æ”¹åˆ¤æ–­æ¡ä»¶åœ¨whileæ¡ä»¶é‡Œï¼Œä¸å¿…æ¯æ¬¡éƒ½åŽ»åˆ¤æ–­æ˜¯å¦è·³å‡ºå¾ªçŽ¯ 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; int cnt = 0; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); int left = 0, right = n-1, up = 0, down = n-1; while(up&lt;=down &amp;&amp; left&lt;=right)&#123; for(int i=left; i&lt;=right; i++) res[up][i] = ++cnt; up++; for(int j=up; j&lt;=down; j++) res[j][right] = ++cnt; right--; for(int k=right; k&gt;=left; k--) res[down][k] = ++cnt; down--; for(int l=down; l&gt;=up; l--) res[l][left] = ++cnt; left++; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/2736/my-ac-solution-with-using-direction-variable My AC solution with using direction variable 12345678910111213141516171819202122232425vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) &#123; int dir = 0; vector&lt; vector&lt;int&gt; &gt; matrix(n, vector&lt;int&gt; (n, 0)); int i = 0, j = 0, k = 1; while (k &lt;= n * n) &#123; matrix[i][j] = k++; if (dir == 0)&#123; j++; if (j == n || matrix[i][j] != 0) dir = 1, j--, i++; &#125; else if (dir == 1) &#123; i++; if (i == n || matrix[i][j] != 0) dir = 2, i--, j--; &#125; else if (dir == 2) &#123; j--; if (j &lt; 0 || matrix[i][j] != 0) dir = 3, j++, i--; &#125; else if (dir == 3) &#123; i--; if (i &lt; 0 || matrix[i][j] != 0) dir = 0, i++, j++; &#125; &#125; return matrix; &#125; https://discuss.leetcode.com/topic/11317/simple-c-solution Simple C++ solution 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt; &gt; vv(n, vector&lt;int&gt;(n)); int rowStart = 0, rowEnd = n - 1; int colStart = 0, colEnd = n - 1; int cnt = 1; while(rowStart &lt;= rowEnd &amp;&amp; colStart &lt;= colEnd) &#123; for(int i = colStart; i&lt;= colEnd; i++) vv[rowStart][i] = cnt++; rowStart++; for(int i = rowStart; i&lt;= rowEnd; i++) vv[i][colEnd] = cnt++; colEnd--; for(int i = colEnd; i&gt;= colStart; i--) vv[rowEnd][i] = cnt++; rowEnd--; for(int i = rowEnd; i&gt;= rowStart; i--) vv[i][colStart] = cnt++; colStart++; &#125; return vv; &#125;&#125;; https://discuss.leetcode.com/topic/30057/c-concise-solution C++ concise solution. 1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt; (n, 1)); int left, right, top, down, index; left = top = index = 0, right = down = n-1; while (left &lt;= right &amp;&amp; top &lt;= down) &#123; for (unsigned int j = left; j &lt;= right; j++) res[top][j] = ++index; top++; for (unsigned int i = top; i &lt;= down; i++) res[i][right] = ++index; right--; for (int j = right; j &gt;= left; j--) res[down][j] = ++index; down--; for (int i = down; i &gt;= top; i--) res[i][left] = ++index; left++; &#125; return res;&#125; python 56ms, 49.97%, June.19th, 2016 https://leetcode.com/discuss/46720/4-9-lines-python-solutions 4-9 lines Python solutions Solution 1: Build it inside-out - 44 ms, 5 lines Start with the empty matrix, add the numbers in reverse order until we added the number 1. Always rotate the matrix clockwise and add a top row: 123|| =&gt; |9| =&gt; |8| |6 7| |4 5| |1 2 3| |9| =&gt; |9 8| =&gt; |9 6| =&gt; |8 9 4| |8 7| |7 6 5| The code: 123456def generateMatrix(self, n): A, lo = [], n*n+1 while lo &gt; 1: lo, hi = lo - len(A), lo A = [range(lo, hi)] + zip(*A[::-1]) return A While this isnâ€™t O(n^2), itâ€™s actually quite fast, presumably due to me not doing much in Python but relying on zip and range and + being fast. I got it accepted in 44 ms, matching the fastest time for recent Python submissions (according to the submission detail page). Solution 2: Ugly inside-out - 48 ms, 4 lines Same as solution 1, but without helper variables. Saves a line, but makes it ugly. Also, because I access A[0][0], I had to handle the n=0 case differently. 12345def generateMatrix(self, n): A = [[n*n]] while A[0][0] &gt; 1: A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1]) return A * (n&gt;0) Solution 3: Walk the spiral - 52 ms, 9 lines Initialize the matrix with zeros, then walk the spiral path and write the numbers 1 to n*n. Make a right turn when the cell ahead is already non-zero. 12345678910def generateMatrix(self, n): A = [[0] * n for _ in range(n)] i, j, di, dj = 0, 0, 0, 1 for k in xrange(n*n): A[i][j] = k + 1 if A[(i+di)%n][(j+dj)%n]: di, dj = dj, -di i += di j += dj return A https://discuss.leetcode.com/topic/7739/if-we-can-t-write-data-to-the-matrix-we-change-the-direction-a-simple-python-solution If we canâ€™t write data to the matrix, we change the direction,a simple python solution 1234567891011121314151617class Solution:# @return a list of lists of integerdef generateMatrix(self, n): matrix = [[0]*n for _ in range(n)] directions = ((0, 1), (1, 0), (0, -1), (-1, 0)) d = 0 y, x = 0, 0 for i in range(1, n*n+1): matrix[y][x] = i dy, dx = directions[d % 4] if -1 &lt; y+dy &lt; n and -1 &lt; x+dx &lt; n and matrix[y+dy][x+dx] == 0: y, x = y+dy, x+dx else: d += 1 dy, dx = directions[d % 4] y, x = y+dy, x+dx return matrix Change the direction If the we canâ€™t write to the matrix java https://discuss.leetcode.com/topic/4362/my-super-simple-solution-can-be-used-for-both-spiral-matrix-i-and-ii My Super Simple Solution. Can be used for both Spiral Matrix I and II This is my solution for Spiral Matrix I, https://oj.leetcode.com/discuss/12228/super-simple-and-easy-to-understand-solution. If you can understand that, this one is a no brainer :) Guess what? I just made several lines of change (with comment â€œ//changeâ€) from that and I have the following AC code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public int[][] generateMatrix(int n) &#123; // Declaration int[][] matrix = new int[n][n]; // Edge Case if (n == 0) &#123; return matrix; &#125; // Normal Case int rowStart = 0; int rowEnd = n-1; int colStart = 0; int colEnd = n-1; int num = 1; //change while (rowStart &lt;= rowEnd &amp;&amp; colStart &lt;= colEnd) &#123; for (int i = colStart; i &lt;= colEnd; i ++) &#123; matrix[rowStart][i] = num ++; //change &#125; rowStart ++; for (int i = rowStart; i &lt;= rowEnd; i ++) &#123; matrix[i][colEnd] = num ++; //change &#125; colEnd --; for (int i = colEnd; i &gt;= colStart; i --) &#123; if (rowStart &lt;= rowEnd) matrix[rowEnd][i] = num ++; //change &#125; rowEnd --; for (int i = rowEnd; i &gt;= rowStart; i --) &#123; if (colStart &lt;= colEnd) matrix[i][colStart] = num ++; //change &#125; colStart ++; &#125; return matrix; &#125;&#125; Obviously, you could merge colStart and colEnd into rowStart and rowEnd because it is a square matrix. But this is easily extensible to matrices that are m*n. Hope this helps :) 0ms, 17.235, June.19th, 2016 https://leetcode.com/discuss/38659/share-my-java-solution Share my java solution 123456789101112131415161718192021222324252627public class Solution &#123; public static int[][] generateMatrix(int n) &#123; int[][] ret = new int[n][n]; int left = 0,top = 0; int right = n -1,down = n - 1; int count = 1; while (left &lt;= right) &#123; for (int j = left; j &lt;= right; j ++) &#123; ret[top][j] = count++; &#125; top ++; for (int i = top; i &lt;= down; i ++) &#123; ret[i][right] = count ++; &#125; right --; for (int j = right; j &gt;= left; j --) &#123; ret[down][j] = count ++; &#125; down --; for (int i = down; i &gt;= top; i --) &#123; ret[i][left] = count ++; &#125; left ++; &#125; return ret; &#125;&#125; https://discuss.leetcode.com/topic/9299/share-my-simple-solution-with-graphical-explanation-java Share my simple solution with graphical explanation - Java If n is odd, only the first direction will cover it (top left -&gt; right, shown as # in the graph), because the other three direction all start from the next position( +1 or -1). 1234567891011121314151617181920212223242526272829303132333435363738/** * -&gt; -&gt; -&gt; * ^ | * | | * &lt;- &lt;-- V * * # # # # * % $ * % $ * &amp; &amp; &amp; $ * */ public static int[][] generateMatrix(int n) &#123; int[][] res = new int[n][n]; int num = 1; int level = (int) Math.ceil(n / 2.); for(int i = 0; i &lt; level; i++) &#123; // top left -&gt; right, shown as # for(int j = i; j &lt; n - i; j++) res[i][j] = num++; // top right + 1 -&gt; bot, shown as $ for(int j = i + 1; j &lt; n - i; j++) res[j][n - i - 1] = num++; // bot right - 1 -&gt; left, shown as &amp; for(int j = n - i - 2; j &gt;= i; j--) res[n - i - 1][j] = num++; // bot left -1 -&gt; top + 1, shown as % for(int j = n - i - 2; j &gt; i; j--) res[j][i] = num++; &#125; return res; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[058. Length of Last Word]]></title>
    <url>%2Fp%2Fe32fb410%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/length-of-last-word/ Given a string s consists of upper/lower-case alphabets and empty space characters â€˜ â€˜, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. 123For example, Given s = &quot;Hello World&quot;,return 5. æ–¹æ³•ä¸€ï¼š code 1ï¼š æ ¸å¿ƒæ€æƒ³ï¼Œä»ŽåŽå‘å‰éåŽ†ï¼Œä»ŽåŽéåŽ†ï¼Œè¿™ä¸ªæƒ³æ³•å¾ˆå¥½ã€‚ å¾ˆå¤šæ—¶å€™ä»Žå‰å‘åŽå¯èƒ½æœ‰ä¸€å®šçš„éº»çƒ¦ï¼Œä½†æ˜¯ä»ŽåŽå‘å‰çš„éåŽ†ï¼Œ ä¼šæ”¶åˆ°å¾ˆå¥½çš„æ•ˆæžœã€‚ æˆ–è®¸è¿™å°±æ˜¯æ‰€è°“çš„é€†å‘æ€ç»´å§ã€‚ https://discuss.leetcode.com/topic/17312/7-lines-4ms-c-solution 7-lines 4ms C++ Solution Well, the basic idea is very simple. Start from the tail of s and move backwards to find the first non-space character. Then from this character, move backwards and count the number of non-space characters until we pass over the head of s or meet a space character. The count will then be the length of the last word. 123456789101112class Solution &#123;public: int lengthOfLastWord(string s) &#123; int len = 0, tail = s.length() - 1; while (tail &gt;= 0 &amp;&amp; s[tail] == &apos; &apos;) tail--; while (tail &gt;= 0 &amp;&amp; s[tail] != &apos; &apos;) &#123; len++; tail--; &#125; return len; &#125;&#125;; code 2: 12345678910111213141516class Solution &#123;public: int lengthOfLastWord(string s) &#123; if(s.empty()) return 0; int n = s.size(); int len = 0; int tail = n-1; while(tail&gt;=0 &amp;&amp; s[tail]==&apos; &apos;) tail--; while(tail&gt;=0 &amp;&amp; s[tail]!=&apos; &apos;)&#123; len++; tail--; &#125; return len; &#125;&#125;; python Solution mine: 40ms, 88.34%, June.23th, 2016 1234567class Solution(object): def lengthOfLastWord(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; return len(s.strip().split(&apos; &apos;)[-1]) https://discuss.leetcode.com/topic/7733/one-line-python-solution One line Python solution12def lengthOfLastWord(self, s): return len(s.rstrip(&apos; &apos;).split(&apos; &apos;)[-1]) java 1ms, 41.25%, June.23th, 2016 https://leetcode.com/discuss/18670/a-single-line-of-code-in-java A single line of Code in Java12345public class Solution &#123; public int lengthOfLastWord(String s) &#123; return s.trim().length()-s.trim().lastIndexOf(&quot; &quot;)-1; &#125;&#125; https://discuss.leetcode.com/topic/27201/my-3-line-0-ms-java-solution My 3 line 0 ms java solution12345public int lengthOfLastWord(String s) &#123; s = s.trim(); int lastIndex = s.lastIndexOf(&apos; &apos;) + 1; return s.length() - lastIndex; &#125; https://discuss.leetcode.com/topic/17762/228ms-java-solution 228ms Java Solution 1 - Use 2 loops. One to locate the last non-space character, one to count. 123456789101112131415161718public int lengthOfLastWord(String s) &#123; //228ms int lenIndex = s.length()-1; int len = 0; /*can also use while here, resulting in 264ms while (lenIndex&gt;=0 &amp;&amp; s.charAt(lenIndex)==&apos; &apos;) lenIndex--;*/ /*or use trim - 324ms s = s.trim();*/ for (int i=lenIndex; i&gt;=0 &amp;&amp; s.charAt(i)==&apos; &apos;; i--) lenIndex--; for (int i=lenIndex; i&gt;=0 &amp;&amp; s.charAt(i)!=&apos; &apos;; i--) len++; return len;&#125; 2 - Use split 1234//292ms String[] words = s.split(&quot; &quot;); if (words.length==0) return 0; else return words[words.length-1].length(); 3 - use lastIndexOf 12//308ms return s.trim().length() - s.trim().lastIndexOf(&quot; &quot;) - 1;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[057. Insert Interval]]></title>
    <url>%2Fp%2F65f5c34%2F</url>
    <content type="text"><![CDATA[26.7% https://leetcode.com/problems/insert-interval/ Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. 1234567Example 1:Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].Example 2:Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10]. æ–¹æ³•ä¸€ï¼š å¤´æ¡ä»£ç  Easy and clean O(n) C++ solution Very easy to understand code as follows. First, put all intervals that are to the left of the inserted interval. Second, merge all intervals that intersect with the inserted interval. Finally, put all intervals that are to the right of the inserted interval. Thatâ€™s it! You are done! é‡ç‚¹ç­”æ¡ˆï¼Œç®€å•ç›´ç™½é«˜æ•ˆ ä¸€ä¸ªå¯ç¤ºï¼Œæœªå¿…åªç”¨ä¸€ä¸ªwhile/forå¾ªçŽ¯ï¼Œå¯ä»¥å‰ä¸€æ®µä¸€ä¸ªwhileï¼Œä¸­é—´ä¸€ä¸ªwhileï¼ŒåŽé¢ä¸€ä¸ªwhileï¼Œè¿™æ ·åˆ†å¼€è®¨è®ºçš„æƒ…å†µï¼Œå¾ˆç®€æ´ï¼Œæ€è·¯ç•…é€šã€‚ é’ˆå¯¹ç›¸é‡çš„æƒ…å†µï¼Œæ›´æ”¹äº†newIntervalçš„å€¼ï¼Œå§‹ç»ˆä¿æŒstartæœ€å°ï¼Œendæœ€å¤§ï¼Œæœ€åŽåŠ å…¥åˆ°ç»“æžœä¸­ã€‚ 1234567891011121314151617181920class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int index = 0; while(index &lt; intervals.size() &amp;&amp; intervals[index].end &lt; newInterval.start)&#123; res.push_back(intervals[index++]); &#125; while(index &lt; intervals.size() &amp;&amp; intervals[index].start &lt;= newInterval.end)&#123; newInterval.start = min(newInterval.start, intervals[index].start); newInterval.end = max(newInterval.end, intervals[index].end); index++; &#125; res.push_back(newInterval); while(index &lt; intervals.size())&#123; res.push_back(intervals[index++]); &#125; return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122232425262728/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; int n = intervals.size(); vector&lt;Interval&gt; res; int i = 0; while(i&lt;n &amp;&amp; intervals[i].end&lt;newInterval.start) res.push_back(intervals[i++]); while(i&lt;n &amp;&amp; intervals[i].start&lt;=newInterval.end)&#123; newInterval.start = min(newInterval.start, intervals[i].start); newInterval.end = max(newInterval.end, intervals[i].end); i++; &#125; res.push_back(newInterval); while(i&lt;n) res.push_back(intervals[i++]); return res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/12899/very-short-and-easy-to-understand-c-solution Very short and easy to understand C++ solution 12345678910111213141516171819vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; ret; auto it = intervals.begin(); for(; it!=intervals.end(); ++it)&#123; if(newInterval.end &lt; (*it).start) //all intervals after will not overlap with the newInterval break; else if(newInterval.start &gt; (*it).end) //*it will not overlap with the newInterval ret.push_back(*it); else&#123; //update newInterval bacause *it overlap with the newInterval newInterval.start = min(newInterval.start, (*it).start); newInterval.end = max(newInterval.end, (*it).end); &#125; &#125; // don&apos;t forget the rest of the intervals and the newInterval ret.push_back(newInterval); for(; it!=intervals.end(); ++it) ret.push_back(*it); return ret;&#125; My question is why this code need 500ms !? https://discuss.leetcode.com/topic/28015/elegant-c-stl-solution-using-equal_range-to-find-overlapped-intervals Elegant C++ STL solution, using â€œequal_rangeâ€ to find overlapped intervals. 123456789101112131415161718class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; auto compare = [] (const Interval &amp;intv1, const Interval &amp;intv2) &#123; return intv1.end &lt; intv2.start; &#125;; auto range = equal_range(intervals.begin(), intervals.end(), newInterval, compare); auto itr1 = range.first, itr2 = range.second; if (itr1 == itr2) &#123; intervals.insert(itr1, newInterval); &#125; else &#123; itr2--; itr2-&gt;start = min(newInterval.start, itr1-&gt;start); itr2-&gt;end = max(newInterval.end, itr2-&gt;end); intervals.erase(itr1, itr2); &#125; return intervals; &#125;&#125;; https://discuss.leetcode.com/topic/24439/easy-and-clean-o-n-c-solution Easy and clean O(n) C++ solution Very easy to understand code as follows. First, put all intervals that are to the left of the inserted interval. Second, merge all intervals that intersect with the inserted interval. Finally, put all intervals that are to the right of the inserted interval. Thatâ€™s it! You are done! é‡ç‚¹ç­”æ¡ˆï¼Œç®€å•ç›´ç™½é«˜æ•ˆ ä¸€ä¸ªå¯ç¤ºï¼Œæœªå¿…åªç”¨ä¸€ä¸ªwhile/forå¾ªçŽ¯ï¼Œå¯ä»¥å‰ä¸€æ®µä¸€ä¸ªwhileï¼Œä¸­é—´ä¸€ä¸ªwhileï¼ŒåŽé¢ä¸€ä¸ªwhileï¼Œè¿™æ ·åˆ†å¼€è®¨è®ºçš„æƒ…å†µï¼Œå¾ˆç®€æ´ï¼Œæ€è·¯ç•…é€šã€‚ é’ˆå¯¹ç›¸é‡çš„æƒ…å†µï¼Œæ›´æ”¹äº†newIntervalçš„å€¼ï¼Œå§‹ç»ˆä¿æŒstartæœ€å°ï¼Œendæœ€å¤§ï¼Œæœ€åŽåŠ å…¥åˆ°ç»“æžœä¸­ã€‚ 1234567891011121314151617181920class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int index = 0; while(index &lt; intervals.size() &amp;&amp; intervals[index].end &lt; newInterval.start)&#123; res.push_back(intervals[index++]); &#125; while(index &lt; intervals.size() &amp;&amp; intervals[index].start &lt;= newInterval.end)&#123; newInterval.start = min(newInterval.start, intervals[index].start); newInterval.end = max(newInterval.end, intervals[index].end); index++; &#125; res.push_back(newInterval); while(index &lt; intervals.size())&#123; res.push_back(intervals[index++]); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/17937/two-easy-o-n-c-solutions-with-explanations Two Easy O(n) C++ Solutions with Explanations By far the best solution I have seen is of O(n) time (some solutions claim to be of O(logn) turns out to be O(n)). One of the simplest ideas is to compare each interval in intervals (intervals[i]) with newInterval and then perform respective operations according to their relationships. If they overlap, merge them to newInterval; If intervals[i] is to the left of newInterval, push intervals[i] to the result vector; If newInterval is to the left of intervals[i], push newInterval and all the remaining intervals (intervals[i], â€¦, intervals[n - 1]) to the result vector. The code is as follows. 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int n = intervals.size(); for (int i = 0; i &lt; n; i++) &#123; if (intervals[i].end &lt; newInterval.start) res.push_back(intervals[i]); else if (newInterval.end &lt; intervals[i].start) &#123; res.push_back(newInterval); for (int j = i; j &lt; n; j++) res.push_back(intervals[j]); return res; &#125; else newInterval = merge(intervals[i], newInterval); &#125; res.push_back(newInterval); return res; &#125;private: Interval merge(Interval&amp; interval1, Interval&amp; interval2) &#123; int start = min(interval1.start, interval2.start); int end = max(interval1.end, interval2.end); return Interval(start, end); &#125;&#125;; Another idea is to search for the two ends of the overlapping intervals using binary search. Then we only need to merge newInterval with the intervals at the two ends if they overlap. All the intervals within the two ends will be contained innewInterval. Letâ€™s do the example in the problem statement: intervals = [1, 2], [3, 5], [6, 7], [8, 10], [12, 16] and newInterval = [4, 9]. We first find the rightmost interval with start smaller than that of newInterval, which is [3, 5]. Then we find the leftmost interval with end larger than that of newInterval, which is [8, 10]. Then all the intervals between them will be contained within newInterval (you may check this to convince yourself) and so can be safely ignored. We only need to check whether newInterval overlaps with the two intervals on the two ends and merge them if necessary. The complete code is as follows. 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; int n = intervals.size(), leftEnd, rightEnd, l, r; vector&lt;Interval&gt; res; // Find the rightmost interval with start smaller than that of newInterval for (l = 0, r = n - 1; l &lt;= r; ) &#123; int mid = l + ((r - l) &gt;&gt; 1); if (intervals[mid].start &gt; newInterval.start) r = mid - 1; else l = mid + 1; &#125; leftEnd = r; // Find the leftmost interval with end larger than that of newInterval for (l = 0, r = n - 1; l &lt;= r; ) &#123; int mid = l + ((r - l) &gt;&gt; 1); if (intervals[mid].end &lt; newInterval.end) l = mid + 1; else r = mid - 1; &#125; rightEnd = l; // Merge newInterval with intervals[leftEnd] and intervals[rightEnd] if necessary if (leftEnd &gt;= 0 &amp;&amp; intervals[leftEnd].end &gt;= newInterval.start) newInterval.start = intervals[leftEnd--].start; if (rightEnd &lt; n &amp;&amp; intervals[rightEnd].start &lt;= newInterval.end) newInterval.end = intervals[rightEnd++].end; // Save the intervals sequentially for (int i = 0; i &lt;= leftEnd; i++) res.push_back(intervals[i]); res.push_back(newInterval); for (int i = rightEnd; i &lt; n; i++) res.push_back(intervals[i]); return res; &#125;&#125;; python https://discuss.leetcode.com/topic/16988/7-lines-3-easy-solutions 7+ lines, 3 easy solutions Solution 1: (7 lines, 88 ms) Collect the intervals strictly left or right of the new interval, then merge the new one with the middle ones (if any) before inserting it between left and right ones. 12345678def insert(self, intervals, newInterval): s, e = newInterval.start, newInterval.end left = [i for i in intervals if i.end &lt; s] right = [i for i in intervals if i.start &gt; e] if left + right != intervals: s = min(s, intervals[len(left)].start) e = max(e, intervals[~len(right)].end) return left + [Interval(s, e)] + right Solution 2: (8 lines, 84 ms) Same algorithm as solution 1, but different implementation with only one pass and explicitly collecting the to-be-merged intervals. 123456789def insert(self, intervals, newInterval): s, e = newInterval.start, newInterval.end parts = merge, left, right = [], [], [] for i in intervals: parts[(i.end &lt; s) - (i.start &gt; e)].append(i) if merge: s = min(s, merge[0].start) e = max(e, merge[-1].end) return left + [Interval(s, e)] + right Solution 3: (11 lines, 80 ms) Same again, but collect and merge while going over the intervals once. 123456789101112def insert(self, intervals, newInterval): s, e = newInterval.start, newInterval.end left, right = [], [] for i in intervals: if i.end &lt; s: left += i, elif i.start &gt; e: right += i, else: s = min(s, i.start) e = max(e, i.end) return left + [Interval(s, e)] + right https://discuss.leetcode.com/topic/6976/o-n-python-solution O(n) Python solution 123456789101112131415161718192021class Solution: # @param intervals, a list of Intervals # @param newInterval, a Interval # @return a list of Interval def insert(self, intervals, newInterval): start = newInterval.start end = newInterval.end result = [] i = 0 while i &lt; len(intervals): if start &lt;= intervals[i].end: if end &lt; intervals[i].start: break start = min(start, intervals[i].start) end = max(end, intervals[i].end) else: result.append(intervals[i]) i += 1 result.append(Interval(start, end)) result += intervals[i:] return result 112ms, 19.91%, June.23th, 2016 123456789101112131415161718192021# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def insert(self, intervals, newInterval): &quot;&quot;&quot; :type intervals: List[Interval] :type newInterval: Interval :rtype: List[Interval] &quot;&quot;&quot; intervals.append(newInterval) rtype = [] for i in sorted(intervals, key = lambda x:x.start): if rtype and i.start &lt;= rtype[-1].end: rtype[-1].end = max(rtype[-1].end, i.end) else: rtype += i, return rtype java https://discuss.leetcode.com/topic/7808/short-and-straight-forward-java-solution Short and straight-forward Java solution Hi guys! Hereâ€™s a pretty straight-forward and concise solution below. è¿™ä¸ªç›´ç™½çš„è§£æ³•ï¼Œå¾ˆå–œæ¬¢ï¼Œå…ˆé’ˆå¯¹intervalsæ¯”è¾ƒå°çš„ï¼ŒæœªæŽ¥è§¦å¤„ç†ï¼Œç„¶åŽè¿›è¡Œä¸­é—´ç›¸é‡çš„å¤„ç†ï¼Œç„¶åŽå¤„ç†ç›¸é‡åŽçš„ã€‚å¾ˆç›´ç™½ï¼Œå¾ˆç®€å•ã€‚ 123456789101112131415161718public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new LinkedList&lt;&gt;(); int i = 0; // add all the intervals ending before newInterval starts while (i &lt; intervals.size() &amp;&amp; intervals.get(i).end &lt; newInterval.start) result.add(intervals.get(i++)); // merge all overlapping intervals to one considering newInterval while (i &lt; intervals.size() &amp;&amp; intervals.get(i).start &lt;= newInterval.end) &#123; newInterval = new Interval( // we could mutate newInterval here also Math.min(newInterval.start, intervals.get(i).start), Math.max(newInterval.end, intervals.get(i).end)); i++; &#125; result.add(newInterval); // add the union of intervals we got // add all the rest while (i &lt; intervals.size()) result.add(intervals.get(i++)); return result;&#125; Hope it helps. https://discuss.leetcode.com/topic/12691/short-java-code Short java code 123456789101112131415161718public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new ArrayList&lt;Interval&gt;(); for (Interval i : intervals) &#123; if (newInterval == null || i.end &lt; newInterval.start) result.add(i); else if (i.start &gt; newInterval.end) &#123; result.add(newInterval); result.add(i); newInterval = null; &#125; else &#123; newInterval.start = Math.min(newInterval.start, i.start); newInterval.end = Math.max(newInterval.end, i.end); &#125; &#125; if (newInterval != null) result.add(newInterval); return result;&#125; https://discuss.leetcode.com/topic/41004/my-binary-search-approach-implementation-2ms My Binary Search Approach Implementation, 2ms I know this is a little messy. For clean and simple code, please use the O(n) approach. We have great answer here with just 3 while loops. The BS approach utilizes the ordered characteristic of the input. For me, I want to get the position of the interval that is the first to have start equal to or larger than the inserted intervalâ€™s start. Similarly, I get the position of the interval that is the first to have end equal to or larger than the new intervalâ€™s end. Then I can get the range of intervals that the new interval connects. There are some corner cases that need to be considered, i.e. when the new interval has no overlap with any of the existing intervals (smaller, larger, or the original list is empty). In these corner cases, we just donâ€™t need to update the new interval. The code could possibly be cleaner and simpler without sacrificing the speed, or even with less time and space. Please let me know if you have any suggestions. Thank you! 123456789101112131415161718192021222324252627282930313233343536373839404142public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); if (intervals == null || newInterval == null) return result; int iStart = findStartPos(intervals, newInterval.start); int iEnd = findEndPos(intervals, newInterval.end); if (iStart &gt; 0 &amp;&amp; intervals.get(iStart - 1).end &gt;= newInterval.start) iStart--; if (iEnd == intervals.size() || intervals.get(iEnd).start &gt; newInterval.end) iEnd--; //If not in the corner cases, this condition should apply. if (iStart &lt;= iEnd) &#123; newInterval = new Interval(Math.min(newInterval.start, intervals.get(iStart).start),Math.max(newInterval.end, intervals.get(iEnd).end)); &#125; int i = 0; while (i &lt; iStart) result.add(intervals.get(i++)); result.add(newInterval); i = iEnd + 1; while (i &lt; intervals.size()) result.add(intervals.get(i++)); return result;&#125;private int findStartPos(List&lt;Interval&gt; intervals, int value) &#123; int l = 0, r = intervals.size() - 1; while (l &lt;= r) &#123; int m = (l + r) &gt;&gt; 1; if (intervals.get(m).start == value) return m; else if (intervals.get(m).start &lt; value) l = m + 1; else r = m - 1; &#125; return l;&#125;private int findEndPos(List&lt;Interval&gt; intervals, int value) &#123; int l = 0, r = intervals.size() - 1; while (l &lt;= r) &#123; int m = (l + r) &gt;&gt; 1; if (intervals.get(m).end == value) return m; else if (intervals.get(m).end &lt; value) l = m + 1; else r = m - 1; &#125; return l;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hard</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[056. Merge Intervals]]></title>
    <url>%2Fp%2F5eec50bd%2F</url>
    <content type="text"><![CDATA[28.9% https://leetcode.com/problems/merge-intervals/ Given a collection of intervals, merge all overlapping intervals. 123For example,Given [1,3],[2,6],[8,10],[15,18],return [1,6],[8,10],[15,18]. æ–¹æ³•ä¸€ï¼š å…ˆæŽ’åºï¼Œå†ä¸€ä¸ªä¸ªçš„å¤„ç†ã€‚ é‡ç‚¹å­¦ä¹ ï¼š sortå‡½æ•°çš„ç”¨æ³• vectorçš„backå‡½æ•° maxå‡½æ•°çš„ç”¨æ³• 123456789101112131415class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; ins) &#123; if (ins.empty()) return vector&lt;Interval&gt;&#123;&#125;; vector&lt;Interval&gt; res; sort(ins.begin(), ins.end(), [](Interval a, Interval b)&#123;return a.start &lt; b.start;&#125;); res.push_back(ins[0]); for (int i = 1; i &lt; ins.size(); i++) &#123; if (res.back().end &lt; ins[i].start) res.push_back(ins[i]); else res.back().end = max(res.back().end, ins[i].end); &#125; return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; int n = intervals.size(); if(n&lt;=1) return intervals; vector&lt;Interval&gt; res; sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;return a.start&lt;b.start;&#125;); res.push_back(intervals[0]); for(int i=1; i&lt;n; i++)&#123; if(intervals[i].start &gt; res.back().end)&#123; res.push_back(intervals[i]); &#125;else&#123; res.back().end = max(res.back().end, intervals[i].end); &#125; &#125; return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°: Dec 10th, 2017 1234567891011121314151617181920class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; vector&lt;Interval&gt; res; if(intervals.size()&lt;=1) return intervals; sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;if(a.start&lt;b.start || (a.start==b.start) &amp;&amp; a.end&lt;b.end) return true; return false;&#125;); int s=intervals[0].start, e = intervals[0].end; for(int i=1; i&lt;intervals.size(); i++)&#123; if(e&lt;intervals[i].start)&#123; res.push_back(Interval(s, e)); s = intervals[i].start; e = intervals[i].end; &#125;else&#123; e = max(e, intervals[i].end); &#125; &#125; res.push_back(Interval(s, e)); return res; &#125;&#125;; cpp 20ms, 28.53%, June.22th, 2016 https://leetcode.com/discuss/49276/c-10-line-solution-easing-understanding C++ 10 line solution. easing understanding å…ˆæŽ’åºï¼Œç„¶åŽå¼€å§‹å¼€å§‹éåŽ†ã€‚ é‡ç‚¹åœ¨äºŽæŽ’åºæ€Žä¹ˆå†™ã€‚ å…³äºŽsortå‡½æ•°çš„ç”¨æ³•ï¼Œå¯ä»¥å‚è€ƒä»¥ä¸‹é“¾æŽ¥ http://www.cplusplus.com/reference/algorithm/sort/ http://www.cplusplus.com/articles/NhA0RXSz/ 123456789101112131415161718192021222324/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; ins) &#123; if (ins.empty()) return vector&lt;Interval&gt;&#123;&#125;; vector&lt;Interval&gt; res; sort(ins.begin(), ins.end(), [](Interval a, Interval b)&#123;return a.start &lt; b.start;&#125;); res.push_back(ins[0]); for (int i = 1; i &lt; ins.size(); i++) &#123; if (res.back().end &lt; ins[i].start) res.push_back(ins[i]); else res.back().end = max(res.back().end, ins[i].end); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/5765/my-easy-c-solution My easy C++ solution 12345678910111213141516171819202122static bool comp(const Interval&amp; a, const Interval&amp; b)&#123; return a.start &lt; b.start;&#125;vector&lt;Interval&gt; merge(vector&lt;Interval&gt; &amp;intervals) &#123; vector&lt;Interval&gt; result; if(intervals.empty())&#123; return result; &#125; sort(intervals.begin(), intervals.end(), comp); result.push_back(intervals[0]); for(int i = 1; i &lt; intervals.size(); i++)&#123; if(intervals[i].start &lt;= result.back().end)&#123; Interval temp(result.back().start, max(result.back().end, intervals[i].end)); result.pop_back(); result.push_back(temp); &#125; else&#123; result.push_back(intervals[i]); &#125; &#125; return result;&#125; https://discuss.leetcode.com/topic/20628/my-c-o-nlogn-solution-580ms My C++ O(NlogN) solution 580ms Just copy the input to res and do sorting (in ascending order of start). Then try to merge the sorted interval: cur is the last processed interval and i is the current to-be-processed interval. if cur is ahead of i and no overlapping, just copy i to cur+1, and update cur to cur+1, otherwise, merge interval cur and i and move to i+1. At last, we need to resize res to remove the redundent intervals. 12345678910111213141516class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; int len = intervals.size(),i,cur; vector&lt;Interval&gt; res(intervals); if(len&gt;1) &#123; std::sort(res.begin(), res.end(), [](Interval i, Interval j)&#123;return i.start&lt;j.start;&#125;); for(cur=0, i=1;i&lt;len; ++i) if(res[cur].end&lt;res[i].start) res[++cur] = res[i]; // no overlapping, copy to cur+1, else res[cur].end = max(res[cur].end, res[i].end); // cur and i overlap with each other, merge res.resize(cur+1); // resize to remove redundant intervals &#125; return res; &#125;&#125;; python 88ms, 81.79%, June.22th, 2016 https://leetcode.com/discuss/42344/7-lines-easy-python 7 lines, easy, Python Just go through the intervals sorted by start coordinate and either combine the current interval with the previous one if they overlap, or add it to the output by itself if they donâ€™t. 12345678910111213141516171819# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def merge(self, intervals): &quot;&quot;&quot; :type intervals: List[Interval] :rtype: List[Interval] &quot;&quot;&quot; out = [] for i in sorted(intervals, key = lambda i: i.start): if out and i.start &lt;= out[-1].end: out[-1].end = max(out[-1].end, i.end) else: out += i, return out https://discuss.leetcode.com/topic/27383/short-python-solution Short python solution Sort the list first. Check if the new interval overlaps with the previous one in the output list. If yes, update it. Otherwise, append the new one. 12345678910111213class Solution(object): def merge(self, intervals): &quot;&quot;&quot; :type intervals: List[Interval] :rtype: List[Interval] &quot;&quot;&quot; if len(intervals) == 0: return [] intervals = sorted(intervals, key = lambda x: x.start) res = [intervals[0]] for n in intervals[1:]: if n.start &lt;= res[-1].end: res[-1].end = max(n.end, res[-1].end) else: res.append(n) return res java https://discuss.leetcode.com/topic/4319/a-simple-java-solution A simple Java solution The idea is to sort the intervals by their starting points. Then, we take the first interval and compare its end with the next intervals starts. As long as they overlap, we update the end to be the max end of the overlapping intervals. Once we find a non overlapping interval, we can add the previous â€œextendedâ€ interval and start over. Sorting takes O(n log(n)) and merging the intervals takes O(n). So, the resulting algorithm takes O(n log(n)). I used an anonymous comparator and a for-each loop to try to keep the code clean and simple. 123456789101112131415161718192021222324252627282930public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; if (intervals.size() &lt;= 1) return intervals; // Sort by ascending starting point using an anonymous Comparator Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval i1, Interval i2) &#123; return Integer.compare(i1.start, i2.start); &#125; &#125;); List&lt;Interval&gt; result = new LinkedList&lt;Interval&gt;(); int start = intervals.get(0).start; int end = intervals.get(0).end; for (Interval interval : intervals) &#123; if (interval.start &lt;= end) // Overlapping intervals, move the end if needed end = Math.max(end, interval.end); else &#123; // Disjoint intervals, add the previous one and reset bounds result.add(new Interval(start, end)); start = interval.start; end = interval.end; &#125; &#125; // Add the last interval result.add(new Interval(start, end)); return result;&#125; https://discuss.leetcode.com/topic/12788/a-clean-java-solution A clean java solution 1234567891011121314151617181920212223public class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; Collections.sort(intervals, new Comparator&lt;Interval&gt;()&#123; @Override public int compare(Interval obj0, Interval obj1) &#123; return obj0.start - obj1.start; &#125; &#125;); List&lt;Interval&gt; ret = new ArrayList&lt;&gt;(); Interval prev = null; for (Interval inter : intervals) &#123; if ( prev==null || inter.start&gt;prev.end ) &#123; ret.add(inter); prev = inter; &#125; else if (inter.end&gt;prev.end) &#123; // Modify the element already in list prev.end = inter.end; &#125; &#125; return ret; &#125;&#125; https://discuss.leetcode.com/topic/38628/beat-98-java-sort-start-end-respectively Beat 98% Java. Sort start &amp; end respectively. The idea is that for the result distinct Interval, the latter oneâ€™s start must &gt; previous oneâ€™s end. 123456789101112131415161718192021public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; // sort start&amp;end int n = intervals.size(); int[] starts = new int[n]; int[] ends = new int[n]; for (int i = 0; i &lt; n; i++) &#123; starts[i] = intervals.get(i).start; ends[i] = intervals.get(i).end; &#125; Arrays.sort(starts); Arrays.sort(ends); // loop through List&lt;Interval&gt; res = new ArrayList&lt;Interval&gt;(); for (int i = 0, j = 0; i &lt; n; i++) &#123; // j is start of interval. if (i == n - 1 || starts[i + 1] &gt; ends[i]) &#123; res.add(new Interval(starts[j], ends[i])); j = i + 1; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/8571/fast-ana-simple-java-code Fast ana simple java code The idea is to sort intervals based on start and iterate all itervals to merge them if: 1curr.end &gt;= iter.start The time complexity is : sort nO(logn)+ merge: O(n) = nO(logn) No Extra space except necessary result : ) 1234567891011121314151617181920212223public class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; res = new LinkedList&lt;Interval&gt;(); if(intervals.size()&lt;2) return intervals; Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval o1, Interval o2) &#123; return o1.start-o2.start; &#125; &#125;); Interval curr = intervals.get(0); for(Interval iter: intervals) &#123; if(curr.end &gt;= iter.start) &#123; curr.end = Math.max(curr.end,iter.end); &#125;else &#123; res.add(curr); curr = iter; &#125; &#125; res.add(curr); return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[055. Jump Game]]></title>
    <url>%2Fp%2F5ad5dd79%2F</url>
    <content type="text"><![CDATA[29.5% https://leetcode.com/problems/jump-game/ Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. 1234For example:A = [2,3,1,1,4], return true.A = [3,2,1,0,4], return false. æ–¹æ³•ä¸€ï¼š code 1ï¼š 12345678910class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int i = 0; for(int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + nums[i], reach); return i == n; &#125;&#125;; code 2ï¼š æˆ‘çš„å®žçŽ° 12345678910class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int i = 0; for(int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + nums[i], reach); return i == n; &#125;&#125;; cpp https://leetcode.com/discuss/15567/linear-and-simple-solution-in-c 12ms, 98.85%, June.22th, 2016 12345678910class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int i = 0; for(int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + nums[i], reach); return i == n; &#125;&#125;; https://discuss.leetcode.com/topic/4911/linear-and-simple-solution-in-c Linear and simple solution in C++ I just iterate and update the maximal index that I can reach 123456bool canJump(int A[], int n) &#123; int i = 0; for (int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + A[i], reach); return i == n;&#125; https://discuss.leetcode.com/topic/3443/simplest-o-n-solution-with-constant-space Simplest O(N) solution with constant space Idea is to work backwards from the last index. Keep track of the smallest index that can â€œjumpâ€ to the last index. Check whether the current index can jump to this smallest index. 1234567bool canJump(int A[], int n) &#123; int last=n-1,i,j; for(i=n-2;i&gt;=0;i--)&#123; if(i+A[i]&gt;=last)last=i; &#125; return last&lt;=0;&#125; https://discuss.leetcode.com/topic/21062/c-elegant-solution-o-n-time C++, elegant solution, O(n) time. 123456789101112bool canJump(vector&lt;int&gt;&amp; nums) &#123; int size=nums.size(); int step=nums[0]; for(int i=1;i&lt;size;++i)&#123; step--; if(step&lt;0) return false; if(nums[i]&gt;step) step=nums[i]; &#125; return true;&#125; my code 12345678910111213class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int m = 0; int cur_max = 1; while(m &lt; cur_max &amp;&amp; cur_max &lt; n)&#123; cur_max = max(nums[m]+m+1, cur_max); m += 1; &#125; return cur_max &gt; n-1; &#125;&#125;; my code 123456789101112131415class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return true; int loc = 0; for(int i=0; i&lt;n-1; i++)&#123; if(i&lt;=loc) loc = max(i+nums[i], loc); if(i&gt;loc) return false; &#125; return loc &gt;= n-1; &#125;&#125;; python https://leetcode.com/discuss/41420/1-6-lines-o-n-time-o-1-space 68ms, 46.69%, June.22th, 2016123456789101112class Solution(object): def canJump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; m = 0 for i, n in enumerate(nums): if i &gt; m: return False m = max(m, i+n) return True https://discuss.leetcode.com/topic/16704/1-6-lines-o-n-time-o-1-space 1-6 lines, O(n) time, O(1) space Solution 1 Going forwards. m tells the maximum index we can reach so far. 1234567def canJump(self, nums): m = 0 for i, n in enumerate(nums): if i &gt; m: return False m = max(m, i+n) return True Solution 2 One-liner version: 12def canJump(self, nums): return reduce(lambda m, (i, n): max(m, i+n) * (i &lt;= m), enumerate(nums, 1), 1) &gt; 0 Solution 3 Going backwards, most people seem to do that, hereâ€™s my version. 123456def canJump(self, nums): goal = len(nums) - 1 for i in range(len(nums))[::-1]: if i + nums[i] &gt;= goal: goal = i return not goal Solution 4 C version. 1234567bool canJump(int* nums, int n) &#123; int goal=n-1, i; for (i=n; i--;) if (i+nums[i] &gt;= goal) goal=i; return !goal;&#125; Solution mine: 96ms, 10.22%, June.22th, 2016 1234567891011121314class Solution(object): def canJump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; i = 0 max = 0 while i &lt; len(nums) and i &lt;= max: tmp = i + nums[i] if tmp &gt; max: max = tmp i += 1 return max &gt;= len(nums) - 1 Solution mine: 60ms, 79.56%, June.22th, 2016 12345678910111213class Solution(object): def canJump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; i = 0 m = 0 n = len(nums) while i &lt; n and i &lt;= m: m = max(i+nums[i], m) i += 1 return m &gt;= len(nums) -1 java https://leetcode.com/discuss/22560/java-solution-easy-to-understand 3ms, 26.71%, June.22th, 2016 Java Solution easy to understand 12345678910public class Solution &#123; public boolean canJump(int[] nums) &#123; int max = 0; for(int i = 0; i&lt; nums.length; i++)&#123; if(i &gt; max) return false; max = Math.max(nums[i] + i, max); &#125; return true; &#125;&#125; https://discuss.leetcode.com/topic/19931/6-line-java-solution-in-o-n 6 line java solution in O(n) The basic idea is this: at each step, we keep track of the furthest reachable index. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable. Hence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable. 12345678public boolean canJump(int[] nums) &#123; int reachable = 0; for (int i=0; i&lt;nums.length; ++i) &#123; if (i &gt; reachable) return false; reachable = Math.max(reachable, i + nums[i]); &#125; return true;&#125; https://discuss.leetcode.com/topic/36578/java-98-percentile-solution Java 98% Percentile Solution The easiest way to think about this problem is to ask are the elements with a 0 value avoidable? this is the algorithm that I constructed to answer this question.Starting from the second to last element in the array we continue to decrement towards the start of the array. Only stopping if we hit an element with a value of 0; in this case we evaluate if there exist an element somewhere at the start of the array which has a jump value large enough to jump over this 0 value element. 1234567891011121314151617public class Solution &#123; public boolean canJump(int[] nums) &#123; if(nums.length &lt; 2) return true; for(int curr = nums.length-2; curr&gt;=0;curr--)&#123; if(nums[curr] == 0)&#123; int neededJumps = 1; while(neededJumps &gt; nums[curr])&#123; neededJumps++; curr--; if(curr &lt; 0) return false; &#125; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[054. Spiral Matrix]]></title>
    <url>%2Fp%2F50cae0bf%2F</url>
    <content type="text"><![CDATA[25.1% https://leetcode.com/problems/spiral-matrix/ Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. 123456789For example,Given the following matrix:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]You should return [1,2,3,6,9,8,7,4,5]. æ–¹æ³•ä¸€ï¼š è®¾ç½®å››ä¸ªå˜é‡ï¼Œupï¼Œdownï¼Œ leftï¼Œ rightï¼ŒæŽ§åˆ¶è¾¹ç•Œï¼Œç›´åˆ°è¦è·³å‡ºå¾ªçŽ¯ã€‚ å‰‘æŒ‡offerï¼Œ20é¢˜ã€‚ 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return &#123;&#125;; int m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; spiral(m * n); int u = 0, d = m - 1, l = 0, r = n - 1, k = 0; while (true) &#123; // up for (int col = l; col &lt;= r; col++) spiral[k++] = matrix[u][col]; if (++u &gt; d) break; // right for (int row = u; row &lt;= d; row++) spiral[k++] = matrix[row][r]; if (--r &lt; l) break; // down for (int col = r; col &gt;= l; col--) spiral[k++] = matrix[d][col]; if (--d &lt; u) break; // left for (int row = d; row &gt;= u; row--) spiral[k++] = matrix[row][l]; if (++l &gt; r) break; &#125; return spiral; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼› 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; if(matrix.empty() || matrix[0].empty()) return res; // right = matrix[0].size()-1 è€Œä¸æ˜¯matrix[0]-1 æˆ‘ä»¬è¦çš„æ˜¯index int left = 0, right = matrix[0].size()-1, up = 0, down = matrix.size()-1; // è¿™é‡Œè®¾ç½®ä¸ºæ°¸è¿œä¸ºtrue while(true)&#123; for(int i=left; i&lt;=right; i++) res.push_back(matrix[up][i]); up++; // éœ€è¦åœ¨è¿™é‡Œåˆ¤æ–­ä¸€ä¸‹æ˜¯å¦è·³å‡ºå¾ªçŽ¯ if(up&gt;down) break; for(int j=up; j&lt;=down; j++) res.push_back(matrix[j][right]); right--; if(left&gt;right) break; for(int k=right; k&gt;=left; k--) res.push_back(matrix[down][k]); down--; if(up&gt;down) break; for(int l=down; l&gt;=up; l--) res.push_back(matrix[l][left]); left++; if(left&gt;right) break; &#125; return res; &#125;&#125;; 0ms, 15.19%, June.25th, 2016 https://leetcode.com/discuss/38974/a-concise-c-implementation-based-on-directions A concise C++ implementation based on Directions When traversing the matrix in the spiral order, at any time we follow one out of the following four directions: RIGHT DOWN LEFT UP. Suppose we are working on a 5 x 3 matrix as such: 0 1 2 3 4 56 7 8 9 1011 12 13 14 15 Imagine a cursor starts off at (0, -1), i.e. the position at â€˜0â€™, then we can achieve the spiral order by doing the following: Go right 5 times Go down 2 times Go left 4 times Go up 1 times. Go right 3 times Go down 0 times -&gt; quit Notice that the directions we choose always follow the order â€˜right-&gt;down-&gt;left-&gt;upâ€™, and for horizontal movements, the number of shifts follows:{5, 4, 3}, and vertical movements follows {2, 1, 0}. Thus, we can make use of a direction matrix that records the offset for all directions, then an array of two elements that stores the number of shifts for horizontal and vertical movements, respectively. This way, we really just need one for loop instead of four. Another good thing about this implementation is that: If later we decided to do spiral traversal on a different direction (e.g. Counterclockwise), then we only need to change the Direction matrix; the main loop does not need to be touched. 1234567891011121314151617181920vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;vector&lt;int&gt; &gt; dirs&#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; vector&lt;int&gt; res; int nr = matrix.size(); if (nr == 0) return res; int nc = matrix[0].size(); if (nc == 0) return res; vector&lt;int&gt; nSteps&#123;nc, nr-1&#125;; int iDir = 0; // index of direction. int ir = 0, ic = -1; // initial position while (nSteps[iDir%2]) &#123; for (int i = 0; i &lt; nSteps[iDir%2]; ++i) &#123; ir += dirs[iDir][0]; ic += dirs[iDir][1]; res.push_back(matrix[ir][ic]); &#125; nSteps[iDir%2]--; iDir = (iDir + 1) % 4; &#125; return res;&#125; https://discuss.leetcode.com/topic/21090/0ms-clear-c-solution 0ms Clear C++ Solution The idea is just to add the elements in the spiral order. First the up-most row (u), then the right-most column (r), then the down-most row (d), and finally the left-most column (l). After finishing a row or a column, update the corresponding variable to continue the process. The code is as follows. ç®€å•ç›´æŽ¥ 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return &#123;&#125;; int m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; spiral(m * n); int u = 0, d = m - 1, l = 0, r = n - 1, k = 0; while (true) &#123; // up for (int col = l; col &lt;= r; col++) spiral[k++] = matrix[u][col]; if (++u &gt; d) break; // right for (int row = u; row &lt;= d; row++) spiral[k++] = matrix[row][r]; if (--r &lt; l) break; // down for (int col = r; col &gt;= l; col--) spiral[k++] = matrix[d][col]; if (--d &lt; u) break; // left for (int row = d; row &gt;= u; row--) spiral[k++] = matrix[row][l]; if (++l &gt; r) break; &#125; return spiral; &#125;&#125;; my code: 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.size()==0 || matrix[0].size()==0) return &#123;&#125;; int m = matrix.size(); int n = matrix[0].size(); vector&lt;int&gt; spiral(m*n, 0); int up=0, down=m-1, left=0, right=n-1, i=0; while(true)&#123; for(int col=left; col&lt;=right; col++) spiral[i++] = matrix[up][col]; if(++up&gt;down) break; for(int row=up; row&lt;=down; row++) spiral[i++] = matrix[row][right]; if(--right&lt;left) break; for(int col=right; col&gt;=left; col--) spiral[i++] = matrix[down][col]; if(--down&lt;up) break; for(int row=down; row&gt;=up; row--) spiral[i++] = matrix[row][left]; if(++left&gt;right) break; &#125; return spiral; &#125;&#125;; https://discuss.leetcode.com/topic/19034/1-liner-in-python 1-liner in Python Take the first row plus the spiral order of the rotated remaining matrix. Inefficient for large matrices, but here I got it accepted in 40 ms, one of the fastest Python submissions. 12def spiralOrder(self, matrix): return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1]) 52ms, 35.84%, June.25th, 2016 https://leetcode.com/discuss/17818/simple-python-solution-by-mutating-the-matrix Simple Python solution by mutating the matrix The con is mutating the matrix, if this is not allowed, we can make a deep copy of the matrix first. And of course it comes with the additional memory usage. 123456789101112131415161718class Solution(object): def spiralOrder(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: List[int] &quot;&quot;&quot; ret = [] while matrix: ret += matrix.pop(0) if matrix and matrix[0]: for row in matrix: ret.append(row.pop()) if matrix: ret += matrix.pop()[::-1] if matrix and matrix[0]: for row in matrix[::-1]: ret.append(row.pop(0)) return ret https://discuss.leetcode.com/topic/26242/ac-python-32ms-solution AC Python 32ms solution 1234567891011121314151617181920212223def spiralOrder(self, matrix): if not matrix or not matrix[0]: return [] ans = [] m, n = len(matrix), len(matrix[0]) u, d, l, r = 0, m - 1, 0, n - 1 while l &lt; r and u &lt; d: ans.extend([matrix[u][j] for j in xrange(l, r)]) ans.extend([matrix[i][r] for i in xrange(u, d)]) ans.extend([matrix[d][j] for j in xrange(r, l, -1)]) ans.extend([matrix[i][l] for i in xrange(d, u, -1)]) u, d, l, r = u + 1, d - 1, l + 1, r - 1 if l == r: ans.extend([matrix[i][r] for i in xrange(u, d + 1)]) elif u == d: ans.extend([matrix[u][j] for j in xrange(l, r + 1)]) return ans# 22 / 22 test cases passed.# Status: Accepted# Runtime: 32 ms# 100% https://discuss.leetcode.com/topic/3713/super-simple-and-easy-to-understand-solution Super Simple and Easy to Understand Solution This is a very simple and easy to understand solution. I traverse right and increment rowBegin, then traverse down and decrement colEnd, then I traverse left and decrement rowEnd, and finally I traverse up and increment colBegin. The only tricky part is that when I traverse left or up I have to check whether the row or col still exists to prevent duplicates. If anyone can do the same thing without that check, please let me know! Any comments greatly appreciated. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (matrix.length == 0) &#123; return res; &#125; int rowBegin = 0; int rowEnd = matrix.length-1; int colBegin = 0; int colEnd = matrix[0].length - 1; while (rowBegin &lt;= rowEnd &amp;&amp; colBegin &lt;= colEnd) &#123; // Traverse Right for (int j = colBegin; j &lt;= colEnd; j ++) &#123; res.add(matrix[rowBegin][j]); &#125; rowBegin++; // Traverse Down for (int j = rowBegin; j &lt;= rowEnd; j ++) &#123; res.add(matrix[j][colEnd]); &#125; colEnd--; if (rowBegin &lt;= rowEnd) &#123; // Traverse Left for (int j = colEnd; j &gt;= colBegin; j --) &#123; res.add(matrix[rowEnd][j]); &#125; &#125; rowEnd--; if (colBegin &lt;= colEnd) &#123; // Traver Up for (int j = rowEnd; j &gt;= rowBegin; j --) &#123; res.add(matrix[j][colBegin]); &#125; &#125; colBegin ++; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/22270/elegant-and-fast-java-solution-240ms Elegant and fast Java solution (240ms) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;List&lt;Integer&gt; spiralList = new ArrayList&lt;&gt;();if(matrix == null || matrix.length == 0) return spiralList;// declare indicesint top = 0;int bottom = matrix.length - 1;int left = 0;int right = matrix[0].length - 1;while(true)&#123; // 1. print top row for(int j=left; j &lt;=right;j++)&#123; spiralList.add(matrix[top][j]); &#125; top++; if(boundriesCrossed(left,right,bottom,top)) break; // 2. print rightmost column for(int i=top; i &lt;= bottom; i++)&#123; spiralList.add(matrix[i][right]); &#125; right--; if(boundriesCrossed(left,right,bottom,top)) break; // 3. print bottom row for(int j=right; j &gt;=left; j--)&#123; spiralList.add(matrix[bottom][j]); &#125; bottom--; if(boundriesCrossed(left,right,bottom,top)) break; // 4. print leftmost column for(int i=bottom; i &gt;= top; i--)&#123; spiralList.add(matrix[i][left]); &#125; left++; if(boundriesCrossed(left,right,bottom,top)) break; &#125;// end while truereturn spiralList;&#125;private boolean boundriesCrossed(int left,int right,int bottom,int top)&#123;if(left&gt;right || bottom&lt;top) return true;else return false;&#125; https://discuss.leetcode.com/topic/44784/clean-java-readable-human-friendly-code Clean Java, readable, human friendly code 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(matrix.length == 0 || matrix[0].length == 0) return res; int top = 0; int bottom = matrix.length-1; int left = 0; int right = matrix[0].length-1; while(true)&#123; for(int i = left; i &lt;= right; i++) res.add(matrix[top][i]); top++; if(left &gt; right || top &gt; bottom) break; for(int i = top; i &lt;= bottom; i++) res.add(matrix[i][right]); right--; if(left &gt; right || top &gt; bottom) break; for(int i = right; i &gt;= left; i--) res.add(matrix[bottom][i]); bottom--; if(left &gt; right || top &gt; bottom) break; for(int i = bottom; i &gt;= top; i--) res.add(matrix[i][left]); left++; if(left &gt; right || top &gt; bottom) break; &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[053. Maximum Subarray]]></title>
    <url>%2Fp%2Fe4eaff71%2F</url>
    <content type="text"><![CDATA[39.0% https://leetcode.com/problems/maximum-subarray/ Find the contiguous subarray within an array (containing at least one number) which has the largest sum. 12For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. click to show more practice. More practice: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. æ–¹æ³•ä¸€ï¼š åŠ¨æ€è§„åˆ’ dp[n] ä¿å­˜ä»¥nums[n]ç»“å°¾çš„æœ€å¤§å€¼ï¼Œansä¿å­˜å½“å‰åˆ°næ‰€æœ‰è¡¨ä¸­çš„æœ€å¤§å€¼ã€‚ 1234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; vector&lt;int&gt; dp(nums.size(), 0); dp[0] = nums[0]; int ans = nums[0]; for(int i=1; i&lt;nums.size(); i++)&#123; dp[i] = nums[i] + (dp[i-1]&gt;0?dp[i-1]:0); ans = max(ans, dp[i]); &#125; return ans; &#125;&#125;; æ–¹æ³•äºŒï¼š ä¸Žä¸Šé¢é€»è¾‘å…¶å®žæ˜¯ç±»ä¼¼çš„ï¼Œä¿å­˜ä¸€ä¸ªå½“å‰æœ€å¤§å€¼cur_sumï¼Œè¡¨ç¤ºç¬¬iä¸ªä½ç½®ä¹‹å‰ï¼Œä»Ži-1å‘å‰æ‰€èƒ½å–å¾—çš„æœ€å¤§å€¼ï¼Œå¹¶ä¸”ä»¥i-1ç»“å°¾çš„ï¼Œ å…¨å±€æœ€å¤§å€¼ max_sumè¡¨ç¤º0è‡³i-1ä¹‹å‰çš„æœ€å¤§å€¼ã€‚åˆ°è¾¾ç¬¬iä½æ—¶ï¼Œå…ˆæ›´æ–°å½“å‰æœ€å¤§å€¼ï¼Œå†æ›´æ–°å…¨å±€çš„ã€‚ 1234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;0) return 0; int cur_sum = 0; int max_sum = INT_MIN; for(auto num:nums)&#123; cur_sum = max(cur_sum, 0) + num; max_sum = max(cur_sum, max_sum); &#125; return max_sum; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š é€šè¿‡åˆå§‹åŒ–ä¸ºç¬¬0ä½ï¼Œé¿å…äº†ä½¿ç”¨INT_MINã€‚ 12345678910111213class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;1) return n; int cur_max = nums[0], all_max = nums[0]; for(int i=1; i&lt;n; i++)&#123; cur_max = max(cur_max+nums[i], nums[i]); all_max = max(all_max, cur_max); &#125; return all_max; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°: 123456789101112131415161718class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;1) return 0; if(n==1) return nums[0]; int cur_max = nums[0], res = nums[0]; int i=1; while(i&lt;n)&#123; // ä»”ç»†æ€è€ƒï¼Œè¿™é‡Œæ˜¯ max(nums[i], cur_max+nums[i]) // è€Œä¸æ˜¯max(cur_max, cur_max+nums[i]); cur_max = max(nums[i], cur_max+nums[i]); res = max(res, cur_max); i++; &#125; return res; &#125;&#125;; cpp https://leetcode.com/discuss/11288/simplest-and-fastest-o-n-c-solution 8ms, 72.20%, June.18th, 2016 Simplest and fastest O(n) C++ solution Idea is very simple. Basically, keep adding each integer to the sequence until the sum drops below 0. If sum is negative, then should reset the sequence. 123456789101112class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int ans = nums[0], sum = 0; for(int i=0; i &lt; nums.size();i++)&#123; sum += nums[i]; ans = max(ans, sum); sum = max(sum, 0); &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/4175/share-my-solutions-both-greedy-and-divide-and-conquer Share my solutions - both greedy and divide and conquer greedy: 123456789101112class Solution &#123;public: int maxSubArray(int A[], int n) &#123; int sum = 0, min = 0, res = A[0]; for(int i = 0; i &lt; n; i++) &#123; sum += A[i]; if(sum - min &gt; res) res = sum - min; if(sum &lt; min) min = sum; &#125; return res; &#125;&#125;; The idea is to find the largest difference between the sums when you summing up the array from left to right. The largest difference corresponds to the sub-array with largest sum. I worked it out independently although It is very close to lucastanâ€™s solution https://oj.leetcode.com/discuss/11288/simple-o-n-c-solution-no-dp-no-divide-and-conquer divide and conquer: 12345678910111213141516171819202122struct val &#123; int l, m, r, s; val(int l, int m, int r, int s):l(l), m(m), r(r), s(s)&#123;&#125;&#125;;class Solution &#123;public: val dac(int A[], int n) &#123; if(n == 1) return val(A[0], A[0], A[0], A[0]); val v1 = dac(A, n / 2), v2 = dac(A + n / 2, n - n / 2); int l, m, r, s; l = max(v1.l, v1.s + v2.l); m = max(v1.r + v2.l, max(v1.m, v2.m)); r = max(v2.r, v1.r + v2.s); s = v1.s + v2.s; return val(l, m, r, s); &#125; int maxSubArray(int A[], int n) &#123; val v = dac(A, n); return v.m; &#125;&#125;; the idea is: for each sub array we calculate 4 values in O(1) time based on the return values of its two halves. The meaning of the values: l: the sum of the sub array with largest sum starting from the first element m: the sum of the sub array with largest sum r: the sum of the sub array with largest sum ending at the last element s: the sum of the whole array the recursive relation is clear in the code. https://discuss.leetcode.com/topic/25396/c-an-clear-o-n-divide-and-conquer-solution-with-comments [C++] An clear O(n) divide and conquer solution with comments For each subarray, calculate four attributes: 1234mx (largest sum of this subarray), lmx(largest sum starting from the left most element), rmx(largest sum ending with the right most element), sum(the sum of the total subarray). The recurrence is: T(n) = 2T(n / 2) + O(1). So the running time of this algorithm is O(n). 123456789101112131415161718192021222324252627class Solution &#123;public: void maxSubArray(vector&lt;int&gt;&amp; nums, int l, int r, int&amp; mx, int&amp; lmx, int&amp; rmx, int&amp; sum) &#123; if (l == r) &#123; mx = lmx = rmx = sum = nums[l]; &#125; else &#123; int m = (l + r) / 2; int mx1, lmx1, rmx1, sum1; int mx2, lmx2, rmx2, sum2; maxSubArray(nums, l, m, mx1, lmx1, rmx1, sum1); maxSubArray(nums, m + 1, r, mx2, lmx2, rmx2, sum2); mx = max(max(mx1, mx2), rmx1 + lmx2); lmx = max(lmx1, sum1 + lmx2); rmx = max(rmx2, sum2 + rmx1); sum = sum1 + sum2; &#125; &#125; int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) &#123; return 0; &#125; int mx, lmx, rmx, sum; maxSubArray(nums, 0, nums.size() - 1, mx, lmx, rmx, sum); return mx; &#125;&#125;; https://discuss.leetcode.com/topic/426/how-to-solve-maximum-subarray-by-using-the-divide-and-conquer-approach How to solve â€œMaximum Subarrayâ€ by using the divide and conquer approach ? I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach. I cannot figure out how to do it with divide and conquer. You guys have ideas? https://discuss.leetcode.com/topic/426/how-to-solve-maximum-subarray-by-using-the-divide-and-conquer-approach/2 Step1. Select the middle element of the array. So the maximum subarray may contain that middle element or not. Step 2.1 If the maximum subarray does not contain the middle element, then we can apply the same algorithm to the the subarray to the left of the middle element and the subarray to the right of the middle element. Step 2.2 If the maximum subarray does contain the middle element, then the result will be simply the maximum suffix subarray of the left subarray plus the maximum prefix subarray of the right subarray Step 3 return the maximum of those three answer. Here is a sample code for divide and conquer solution. Please try to understand the algorithm before look at the code 1234567891011121314151617181920212223242526272829class Solution &#123;public: int maxSubArray(int A[], int n) &#123; // IMPORTANT: Please reset any member data you declared, as // the same Solution instance will be reused for each test case. if(n==0) return 0; return maxSubArrayHelperFunction(A,0,n-1); &#125; int maxSubArrayHelperFunction(int A[], int left, int right) &#123; if(right == left) return A[left]; int middle = (left+right)/2; int leftans = maxSubArrayHelperFunction(A, left, middle); int rightans = maxSubArrayHelperFunction(A, middle+1, right); int leftmax = A[middle]; int rightmax = A[middle+1]; int temp = 0; for(int i=middle;i&gt;=left;i--) &#123; temp += A[i]; if(temp &gt; leftmax) leftmax = temp; &#125; temp = 0; for(int i=middle+1;i&lt;=right;i++) &#123; temp += A[i]; if(temp &gt; rightmax) rightmax = temp; &#125; return max(max(leftans, rightans),leftmax+rightmax); &#125;&#125;; python https://leetcode.com/discuss/29296/a-python-solution 64ms, 49.06%, June.18th, 201612345678910111213class Solution(object): def maxSubArray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if not nums: return 0 cursum = maxsum = nums[0] for num in nums[1:]: cursum = max(num, num+cursum) maxsum = max(cursum, maxsum) return maxsum java https://discuss.leetcode.com/topic/6413/dp-solution-some-thoughts Analysis of this problem: Apparently, this is a optimization problem, which can be usually solved by DP. So when it comes to DP, the first thing for us to figure out is the format of the sub problem(or the state of each sub problem). The format of the sub problem can be helpful when we are trying to come up with the recursive relation. At first, I think the sub problem should look like: maxSubArray(int A[], int i, int j), which means the maxSubArray for A[i: j]. In this way, our goal is to figure out what maxSubArray(A, 0, A.length - 1) is. However, if we define the format of the sub problem in this way, itâ€™s hard to find the connection from the sub problem to the original problem(at least for me). In other words, I canâ€™t find a way to divided the original problem into the sub problems and use the solutions of the sub problems to somehow create the solution of the original one. So I change the format of the sub problem into something like: maxSubArray(int A[], int i), which means the maxSubArray for A[0:i ] which must has A[i] as the end element. Note that now the sub problemâ€™s format is less flexible and less powerful than the previous one because thereâ€™s a limitation that A[i] should be contained in that sequence and we have to keep track of each solution of the sub problem to update the global optimal value. However, now the connect between the sub problem &amp; the original one becomes clearer: 1maxSubArray(A, i) = maxSubArray(A, i - 1) &gt; 0 ? maxSubArray(A, i - 1) : 0 + A[i]; And hereâ€™s the code 123456789101112131415public class Solution &#123; public int maxSubArray(int[] nums) &#123; int n = nums.length; int[] dp = new int[n]; dp[0] = nums[0]; int max = dp[0]; for(int i=1; i&lt;n; i++)&#123; dp[i] = nums[i] + (dp[i-1]&gt;0?dp[i-1]:0); max = Math.max(max, dp[i]); &#125; return max; &#125;&#125; https://leetcode.com/discuss/15805/accepted-o-n-solution-in-java 1ms, 69.50%, June.18th, 2016 Accepted O(n) solution in java this problem was discussed by Jon Bentley (Sep. 1984 Vol. 27 No. 9 Communications of the ACM P885) the paragraph below was copied from his paper (with a little modifications) algorithm that operates on arrays: it starts at the left end (element A[1]) and scans through to the right end (element A[n]), keeping track of the maximum sum subvector seen so far. The maximum is initially A[0]. Suppose weâ€™ve solved the problem for A[1 .. i - 1]; how can we extend that to A[1 .. i]? The maximumsum in the first I elements is either the maximum sum in the first i - 1 elements (which weâ€™ll call MaxSoFar), or it is that of a subvector that ends in position i (which weâ€™ll call MaxEndingHere). MaxEndingHere is either A[i] plus the previous MaxEndingHere, or just A[i], whichever is larger. 12345678public static int maxSubArray(int[] A) &#123; int maxSoFar=A[0], maxEndingHere=A[0]; for (int i=1;i&lt;A.length;++i)&#123; maxEndingHere= Math.max(maxEndingHere+A[i],A[i]); maxSoFar=Math.max(maxSoFar, maxEndingHere); &#125; return maxSoFar;&#125; https://discuss.leetcode.com/topic/7447/o-n-java-solution O(n) Java solution The catch here is that we have to take care of negative value. The solution does 1 iteration with constant space and no DP. 1234567891011121314public class Solution &#123;public int maxSubArray(int[] A) &#123; int max = Integer.MIN_VALUE, sum = 0; for (int i = 0; i &lt; A.length; i++) &#123; if (sum &lt; 0) sum = A[i]; else sum += A[i]; if (sum &gt; max) max = sum; &#125; return max;&#125;&#125; https://discuss.leetcode.com/topic/27151/my-concise-o-n-dp-java-solution My concise O(n) DP JAVA Solution Explanation Although thereâ€™re some other simplified solutions, but DP solution can make the original thought for this problem clearer. In this solution, dp[i] means the largest sum among the subarrays whose last element is A[i]. Solution1. DP Solution - O(n) time, O(n) space 12345678public int maxSubArray(int[] A) &#123; int dp[] = new int[A.length]; int max = A[0]; dp[0] = A[0]; for (int i = 1; i &lt; A.length; i++) &#123; dp[i] = Math.max(dp[i-1] + A[i] ,A[i]); max = Math.max(max, dp[i]); &#125; return max;&#125; Solution2. Simplified DP Solution - O(n) time, O(1) space - Special thanks for TWiStErRobâ€™s smart comment The basic idea is to check previous sum, reset it to 0 if itâ€™s less than 0. 12345678public int maxSubArray(int[] A) &#123; int res = Integer.MIN_VALUE, sum = 0; for (int i = 0; i &lt; A.length; i++) &#123; sum = Math.max(sum, 0) + A[i]; res = Math.max(res, sum); &#125; return res;&#125; Solution3. Pre-Sum Array Solution - O(n) time, O(n) space The basic idea is to use pre-sum array, max = Math.max(max, sum[i] - minSum). (minSum is the minimum sum before A[i]) 123456789101112public int maxSubArray(int[] A) &#123; if (A == null || A.length == 0) return 0; int max = A[0], minSum = Integer.MAX_VALUE; int sum[] = new int[A.length]; sum[0] = A[0]; for (int i = 1; i &lt; A.length; i++) &#123; sum[i] = sum[i-1] + A[i]; minSum = Math.min(0, Math.min(minSum, sum[i-1])); max = Math.max(max, sum[i] - minSum); &#125; return max;&#125; https://discuss.leetcode.com/topic/42213/my-divide-and-conquer-solution-in-java-under-instruction-of-clrs-o-nlogn My Divide and Conquer Solution in Java under instruction of CLRS(O(nlogn)) 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123;//divdie and conquer public int maxSubArray(int[] nums) &#123; return Subarray(nums, 0 ,nums.length -1 ); &#125; public int Subarray(int[] A,int left, int right)&#123; if(left == right)&#123;return A[left];&#125; int mid = left + (right - left) / 2; int leftSum = Subarray(A,left,mid);// left part int rightSum = Subarray(A,mid+1,right);//right part int crossSum = crossSubarray(A,left,right);// cross part if(leftSum &gt;= rightSum &amp;&amp; leftSum &gt;= crossSum)&#123;// left part is max return leftSum; &#125; if(rightSum &gt;= leftSum &amp;&amp; rightSum &gt;= crossSum)&#123;// right part is max return rightSum; &#125; return crossSum; // cross part is max &#125; public int crossSubarray(int[] A,int left,int right)&#123; int leftSum = Integer.MIN_VALUE; int rightSum = Integer.MIN_VALUE; int sum = 0; int mid = left + (right - left) / 2; for(int i = mid; i &gt;= left ; i--)&#123; sum = sum + A[i]; if(leftSum &lt; sum)&#123; leftSum = sum; &#125; &#125; sum = 0; for(int j = mid + 1; j &lt;= right; j++)&#123; sum = sum + A[j]; if(rightSum &lt; sum)&#123; rightSum = sum; &#125; &#125; return leftSum + rightSum; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>divide and conquer</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[052. N-Queens II]]></title>
    <url>%2Fp%2F8e5f0d6d%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/n-queens-ii/ Follow up for N-Queens problem. Now, instead outputting board configurations, return the total number of distinct solutions. cpp https://discuss.leetcode.com/topic/19741/c-solution-dfs-easy-understanding C++ solution - DFS - easy understanding 1234567891011121314151617181920212223int totalNQueens(int n) &#123; vector&lt;bool&gt; col(n, true); vector&lt;bool&gt; anti(2*n-1, true); vector&lt;bool&gt; main(2*n-1, true); vector&lt;int&gt; row(n, 0); int count = 0; dfs(0, row, col, main, anti, count); return count;&#125;void dfs(int i, vector&lt;int&gt; &amp;row, vector&lt;bool&gt; &amp;col, vector&lt;bool&gt;&amp; main, vector&lt;bool&gt; &amp;anti, int &amp;count) &#123; if (i == row.size()) &#123; count++; return; &#125; for (int j = 0; j &lt; col.size(); j++) &#123; if (col[j] &amp;&amp; main[i+j] &amp;&amp; anti[i+col.size()-1-j]) &#123; row[i] = j; col[j] = main[i+j] = anti[i+col.size()-1-j] = false; dfs(i+1, row, col, main, anti, count); col[j] = main[i+j] = anti[i+col.size()-1-j] = true; &#125; &#125;&#125; https://discuss.leetcode.com/topic/19741/c-solution-dfs-easy-understanding/2 Nice job!I think row is useless, delete it is ok. 123456789101112131415161718192021222324252627282930class Solution &#123;public:int totalNQueens(int n) &#123; int count = 0; vector&lt;bool&gt; cols(n, true); vector&lt;bool&gt; main(2 * n - 1, true); vector&lt;bool&gt; anti(2 * n - 1, true); helper(0, count, cols, main, anti); return count;&#125;private:void helper(int s, int&amp; count, vector&lt;bool&gt;&amp; cols, vector&lt;bool&gt;&amp; main, vector&lt;bool&gt;&amp; anti)&#123; if (s == cols.size()) &#123; count++; return; &#125; for (int i = 0; i &lt; cols.size(); i++) &#123; if (cols[i] &amp;&amp; main[s + i] &amp;&amp; anti[s + cols.size() - 1 - i]) &#123; cols[i] = main[s + i] = anti[s + cols.size() - 1 - i] = false; helper(s + 1, count, cols, main, anti); cols[i] = main[s + i] = anti[s + cols.size() - 1 - i] = true; &#125; &#125;&#125;&#125;; And I want to share my 4ms Solution. The ideas are same but the diagonal conflict checking method diffes. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public:int totalNQueens(int n) &#123; int count = 0; vector&lt;bool&gt; mark(n); vector&lt;int&gt; cols(n, -1); for (int i = 0; i &lt; n; i++) &#123; cols[0] = i; mark[i] = true; helper(1, n, count, mark, cols); cols[0] = -1; mark[i] = false; &#125; return count;&#125;private:void helper(int s, int n, int&amp; count, vector&lt;bool&gt;&amp; mark, vector&lt;int&gt;&amp; cols)&#123; if (s == n) &#123; count++; return; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!mark[i]) &#123; bool mark2 = true; for (int k = 0; k &lt; s; k++) &#123; if (abs(s - k) == abs(i - cols[k])) &#123; mark2 = false; break; &#125; &#125; if (mark2) &#123; cols[s] = i; mark[i] = true; helper(s + 1, n, count, mark, cols); cols[s] = -1; mark[i] = false; &#125; &#125; &#125;&#125;&#125;; https://discuss.leetcode.com/topic/38923/share-my-java-code-beats-97-83-run-times Share my Java code (beats 97.83% run times) 1234567891011121314151617181920212223242526272829/* å¸¸è§„n-queensè§£æ³•, æ•°ç­”æ¡ˆä¸ªæ•°. ç”¨columnæ ‡è®°æ­¤è¡Œä¹‹å‰çš„å“ªäº›columnå·²ç»æ”¾ç½®äº†queen. æ£‹ç›˜åæ ‡(row, col)å¯¹åº”columnçš„ç¬¬colä½(LSB --&gt; MSB, ä¸‹åŒ). ç”¨diagæ ‡è®°æ­¤ä½ç½®ä¹‹å‰çš„å“ªäº›ä¸»å¯¹è§’çº¿å·²ç»æ”¾ç½®äº†queen. æ£‹ç›˜åæ ‡(row, col)å¯¹åº”diagçš„ç¬¬(n - 1 + row - col)ä½. ç”¨antiDiagæ ‡è®°æ­¤ä½ç½®ä¹‹å‰çš„å“ªäº›å‰¯å¯¹è§’çº¿å·²ç»æ”¾ç½®äº†queen. æ£‹ç›˜åæ ‡(row, col)å¯¹åº”antiDiagçš„ç¬¬(row + col)ä½.*/public class Solution &#123; int count = 0; public int totalNQueens(int n) &#123; dfs(0, n, 0, 0, 0); return count; &#125; private void dfs(int row, int n, int column, int diag, int antiDiag) &#123; if (row == n) &#123; ++count; return; &#125; for (int i = 0; i &lt; n; ++i) &#123; boolean isColSafe = ((1 &lt;&lt; i) &amp; column) == 0; boolean isDiagSafe = ((1 &lt;&lt; (n - 1 + row - i)) &amp; diag) == 0; boolean isAntiDiagSafe = ((1 &lt;&lt; (row + i)) &amp; antiDiag) == 0; if (isColSafe &amp;&amp; isDiagSafe &amp;&amp; isAntiDiagSafe) &#123; dfs(row + 1, n, (1 &lt;&lt; i) | column, (1 &lt;&lt; (n - 1 + row - i)) | diag, (1 &lt;&lt; (row + i)) | antiDiag); &#125; &#125; &#125;&#125; cpp https://discuss.leetcode.com/topic/15329/shortest-c-solution-in-0ms Shortest C++ solution in 0ms Idea is to use vectors to keep track of invalid positions , so validity can be checked in O(1) and put a queen in each column 12345678910111213141516171819202122#include&lt;vector&gt;using namespace std;class Solution &#123;public: int find(int n, int left, int i, int r, vector&lt;int&gt;&amp;rows,vector&lt;int&gt;&amp;d1,vector&lt;int&gt;&amp;d2)&#123; if (left == 0) return 1; int j,sum=0; for (j=r; j&lt;n; j++)&#123; if (rows[j] || d1[i+j] || d2[n-1+i-j]) continue; rows[j]=d1[i+j]=d2[n-1+i-j]=1; sum += find(n, left-1, i+1, 0,rows,d1,d2 ); rows[j]=d1[i+j]=d2[n-1+i-j]=0; &#125; return sum; &#125; int totalNQueens(int n) &#123; vector&lt;int&gt; rows(n),d1(2*n-1),d2(2*n-1); return find(n,n,0,0,rows,d1,d2); &#125;&#125;; https://discuss.leetcode.com/topic/11348/my-concise-dfs-c-solution-using-three-unordered_map-int-bool My concise DFS C++ solution using three unordered_map&lt;int, bool&gt;. 1234567891011121314151617181920212223242526class Solution &#123;public: unordered_map&lt;int, bool&gt; column, obliqueLeft, obliqueRight; int total; void NQueensHelper(int row, int n) &#123; if (row == n+1) &#123; total++; return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!column[i] &amp;&amp; !obliqueLeft[i + row] &amp;&amp; !obliqueRight[i - row]) &#123; column[i] = obliqueLeft[i + row] = obliqueRight[i - row] = true; NQueensHelper(row+1, n); column[i] = obliqueLeft[i + row] = obliqueRight[i - row] = false; &#125; &#125; &#125; int totalNQueens(int n) &#123; column.clear(); obliqueLeft.clear(); obliqueRight.clear(); total = 0; NQueensHelper(1, n); return total; &#125;&#125;; Each unordered_map represents whether column/left oblique line/right oblique line is occupied before. python https://discuss.leetcode.com/topic/22294/python-recursive-dfs-solution Python recursive dfs solution. The idea here is quite similar to N-Queens while we donâ€™t need to record the path, and as the return value is a number not a list, itâ€™s better to use a global variable to record the result. 12345678910111213141516171819def totalNQueens(self, n): self.res = 0 self.dfs([-1]*n, 0) return self.res def dfs(self, nums, index): if index == len(nums): self.res += 1 return for i in xrange(len(nums)): nums[index] = i if self.valid(nums, index): self.dfs(nums, index+1) def valid(self, nums, n): for i in xrange(n): if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i: return False return True 72ms, 85.33%, June.17th, 2016 1234567891011121314151617class Solution(object): def totalNQueens(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; def DFS(queens, xy_dif, xy_sum): p = len(queens) if p==n: result.append(queens) return None for q in range(n): if q not in queens and p-q not in xy_dif and p+q not in xy_sum: DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q]) result = [] DFS([],[],[]) return len(result) java https://discuss.leetcode.com/topic/5962/accepted-java-solution Accepted Java Solution 123456789101112131415161718192021222324252627282930313233343536373839404142/** * don&apos;t need to actually place the queen, * instead, for each row, try to place without violation on * col/ diagonal1/ diagnol2. * trick: to detect whether 2 positions sit on the same diagnol: * if delta(col, row) equals, same diagnol1; * if sum(col, row) equals, same diagnal2. */private final Set&lt;Integer&gt; occupiedCols = new HashSet&lt;Integer&gt;();private final Set&lt;Integer&gt; occupiedDiag1s = new HashSet&lt;Integer&gt;();private final Set&lt;Integer&gt; occupiedDiag2s = new HashSet&lt;Integer&gt;();public int totalNQueens(int n) &#123; return totalNQueensHelper(0, 0, n);&#125;private int totalNQueensHelper(int row, int count, int n) &#123; for (int col = 0; col &lt; n; col++) &#123; if (occupiedCols.contains(col)) continue; int diag1 = row - col; if (occupiedDiag1s.contains(diag1)) continue; int diag2 = row + col; if (occupiedDiag2s.contains(diag2)) continue; // we can now place a queen here if (row == n-1) count++; else &#123; occupiedCols.add(col); occupiedDiag1s.add(diag1); occupiedDiag2s.add(diag2); count = totalNQueensHelper(row+1, count, n); // recover occupiedCols.remove(col); occupiedDiag1s.remove(diag1); occupiedDiag2s.remove(diag2); &#125; &#125; return count;&#125; https://discuss.leetcode.com/topic/29626/easiest-java-solution-1ms-98-22 Easiest Java Solution (1ms, 98.22%) This is a classic backtracking problem. Start row by row, and loop through columns. At each decision point, skip unsafe positions by using three boolean arrays. Start going back when we reach row n. Just FYI, if using HashSet, running time will be at least 3 times slower! 123456789101112131415161718192021222324public class Solution &#123; int count = 0; public int totalNQueens(int n) &#123; boolean[] cols = new boolean[n]; // columns | boolean[] d1 = new boolean[2 * n]; // diagonals \ boolean[] d2 = new boolean[2 * n]; // diagonals / backtracking(0, cols, d1, d2, n); return count; &#125; public void backtracking(int row, boolean[] cols, boolean[] d1, boolean []d2, int n) &#123; if(row == n) count++; for(int col = 0; col &lt; n; col++) &#123; int id1 = col - row + n; int id2 = col + row; if(cols[col] || d1[id1] || d2[id2]) continue; cols[col] = true; d1[id1] = true; d2[id2] = true; backtracking(row + 1, cols, d1, d2, n); cols[col] = false; d1[id1] = false; d2[id2] = false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[051. N-Queens]]></title>
    <url>%2Fp%2Faa0d9b9e%2F</url>
    <content type="text"><![CDATA[31.1% https://leetcode.com/problems/n-queens/ The n-queens puzzle is the problem of placing n queens on an nÃ—n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queensâ€™ placement, where â€˜Qâ€™ and â€˜.â€™ both indicate a queen and an empty space respectively. 1234567891011121314For example,There exist two distinct solutions to the 4-queens puzzle:[ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] https://discuss.leetcode.com/topic/1154/the-description-should-give-a-clear-explanation-of-the-problem-of-n-queens The description should give a clear explanation of the problem of â€œn-queensâ€ queens can attack other queen in the same row, same column, but i forget the diagonal.. = ã€‚= æ–¹æ³•ä¸€ï¼š https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand Accepted 4ms c++ solution use backtracking and bitmask, easy understand. In this problem, we can go row by row, and in each position, we need to check if the column, the 45Â° diagonal and the 135Â° diagonal had a queen before. Solution A: Directly check the validity of each position, 12ms: 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: std::vector&lt;std::vector&lt;std::string&gt; &gt; solveNQueens(int n) &#123; std::vector&lt;std::vector&lt;std::string&gt; &gt; res; std::vector&lt;std::string&gt; nQueens(n, std::string(n, &apos;.&apos;)); solveNQueens(res, nQueens, 0, n); return res; &#125;private: void solveNQueens(std::vector&lt;std::vector&lt;std::string&gt; &gt; &amp;res, std::vector&lt;std::string&gt; &amp;nQueens, int row, int &amp;n) &#123; if (row == n) &#123; res.push_back(nQueens); return; &#125; for (int col = 0; col != n; ++col) if (isValid(nQueens, row, col, n)) &#123; nQueens[row][col] = &apos;Q&apos;; solveNQueens(res, nQueens, row + 1, n); nQueens[row][col] = &apos;.&apos;; &#125; &#125; bool isValid(std::vector&lt;std::string&gt; &amp;nQueens, int row, int col, int &amp;n) &#123; //check if the column had a queen before. for (int i = 0; i != row; ++i) if (nQueens[i][col] == &apos;Q&apos;) return false; //check if the 45Â° diagonal had a queen before. for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) if (nQueens[i][j] == &apos;Q&apos;) return false; //check if the 135Â° diagonal had a queen before. for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j) if (nQueens[i][j] == &apos;Q&apos;) return false; return true; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; queens(n, string(n, '.')); helper(res, queens, 0, n); return res; &#125; void helper(vector&lt;vector&lt;string&gt;&gt;&amp; res, vector&lt;string&gt;&amp; queens, int row, int n)&#123; if(row==n)&#123; res.push_back(queens); return; &#125; for(int col=0; col&lt;n; col++)&#123; if(isvalid(queens, row, col, n))&#123; queens[row][col] = 'Q'; helper(res, queens, row+1, n); queens[row][col] = '.'; &#125; &#125; &#125; bool isvalid(vector&lt;string&gt;&amp; queens, int row, int col, int n)&#123; for(int i=0; i&lt;row; i++) if(queens[i][col]=='Q') return false; for(int i=row-1, j=col-1; i&gt;=0 &amp;&amp; j&gt;=0; i--, j--) if(queens[i][j]=='Q') return false; for(int i=row-1, j=col+1; i&gt;=0 &amp;&amp; j&lt;n; i--, j++) if(queens[i][j]=='Q') return false; return true; &#125;&#125;; Solution B: Use flag vectors as bitmask, 4ms: The number of columns is n, the number of 45Â° diagonals is 2 n - 1, the number of 135Â° diagonals is also 2 n - 1. When reach [row, col], the column No. is col, the 45Â° diagonal No. is row + col and the 135Â° diagonal No. is n - 1 + col - row. We can use three arrays to indicate if the column or the diagonal had a queen before, if not, we can put a queen in this position and continue. 12345678910111213141516171819202122232425262728293031323334/** | | | / / / \ \ \ * O O O O O O O O O * | | | / / / / \ \ \ \ * O O O O O O O O O * | | | / / / / \ \ \ \ * O O O O O O O O O * | | | / / / \ \ \ * 3 columns 5 45Â° diagonals 5 135Â° diagonals (when n is 3) */class Solution &#123;public: std::vector&lt;std::vector&lt;std::string&gt; &gt; solveNQueens(int n) &#123; std::vector&lt;std::vector&lt;std::string&gt; &gt; res; std::vector&lt;std::string&gt; nQueens(n, std::string(n, &apos;.&apos;)); std::vector&lt;int&gt; flag_col(n, 1), flag_45(2 * n - 1, 1), flag_135(2 * n - 1, 1); solveNQueens(res, nQueens, flag_col, flag_45, flag_135, 0, n); return res; &#125;private: void solveNQueens(std::vector&lt;std::vector&lt;std::string&gt; &gt; &amp;res, std::vector&lt;std::string&gt; &amp;nQueens, std::vector&lt;int&gt; &amp;flag_col, std::vector&lt;int&gt; &amp;flag_45, std::vector&lt;int&gt; &amp;flag_135, int row, int &amp;n) &#123; if (row == n) &#123; res.push_back(nQueens); return; &#125; for (int col = 0; col != n; ++col) if (flag_col[col] &amp;&amp; flag_45[row + col] &amp;&amp; flag_135[n - 1 + col - row]) &#123; flag_col[col] = flag_45[row + col] = flag_135[n - 1 + col - row] = 0; nQueens[row][col] = &apos;Q&apos;; solveNQueens(res, nQueens, flag_col, flag_45, flag_135, row + 1, n); nQueens[row][col] = &apos;.&apos;; flag_col[col] = flag_45[row + col] = flag_135[n - 1 + col - row] = 1; &#125; &#125;&#125;; But we actually do not need to use three arrays, we just need one. Now, when reach [row, col], the subscript of column is col, the subscript of 45Â° diagonal is n + row + col and the subscript of 135Â° diagonal is n + 2 * n - 1 + n - 1 + col - row. 123456789101112131415161718192021222324252627282930class Solution &#123;public: std::vector&lt;std::vector&lt;std::string&gt; &gt; solveNQueens(int n) &#123; std::vector&lt;std::vector&lt;std::string&gt; &gt; res; std::vector&lt;std::string&gt; nQueens(n, std::string(n, &apos;.&apos;)); /* flag[0] to flag[n - 1] to indicate if the column had a queen before. flag[n] to flag[3 * n - 2] to indicate if the 45Â° diagonal had a queen before. flag[3 * n - 1] to flag[5 * n - 3] to indicate if the 135Â° diagonal had a queen before. */ std::vector&lt;int&gt; flag(5 * n - 2, 1); solveNQueens(res, nQueens, flag, 0, n); return res; &#125;private: void solveNQueens(std::vector&lt;std::vector&lt;std::string&gt; &gt; &amp;res, std::vector&lt;std::string&gt; &amp;nQueens, std::vector&lt;int&gt; &amp;flag, int row, int &amp;n) &#123; if (row == n) &#123; res.push_back(nQueens); return; &#125; for (int col = 0; col != n; ++col) if (flag[col] &amp;&amp; flag[n + row + col] &amp;&amp; flag[4 * n - 2 + col - row]) &#123; flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 0; nQueens[row][col] = &apos;Q&apos;; solveNQueens(res, nQueens, flag, row + 1, n); nQueens[row][col] = &apos;.&apos;; flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 1; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/4007/accepted-auxillary-space-o-n-using-dfs-cpp Accepted : auxillary space O(n) , using dfs , cpp Space complexity : Instead of using a 2D array to represent the chess board, i am using a 1D array , the index of which would represent the row number and the value of arr at row index will be the column number for the correct position of the queen. i.e 12Instead of doing arr[row][col]=1i am using arr[row]=col ; where queen is positioned at (row,col); Logic : DFS for every column number ,ranging from 0 to n-1, for all the rows from 0 to n-1 and check the validity of queen position for every row,col combination(using isSafe function) isSafe function : It checks whether the queen in current position(r,c) is being attacked by any of the r-1 queens positioned in row numbers 0 through r-1. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; public: vector &lt; vector &lt;string&gt; &gt; sol; int limit; vector&lt;string&gt; toChessString(vector&lt;int&gt; arr) &#123; string s(arr.size(),&apos;.&apos;); vector&lt;string&gt; ans(arr.size(),s); for(int i=0 ; i&lt;arr.size() ; i++) ans[i][arr[i]]=&apos;Q&apos;; return ans; &#125; bool isSafe(vector&lt;int&gt; arr, int r , int c ) &#123; int check; for(int row=r-1,ldia=c-1,rdia=c+1 ; row&gt;=0 ; row--,ldia--,rdia++) &#123; check=arr[row]; if(check==c || check==ldia || check==rdia) return false; &#125; return true; &#125; void solveNqueen(vector&lt;int&gt; arr , int r , int c) &#123; if(r==limit) sol.push_back(toChessString(arr)); else &#123; for(int col=c ; col&lt;limit ; col++) &#123; arr[r]=col; if(isSafe(arr,r,col)) solveNqueen(arr,r+1,0); &#125; &#125; &#125; vector&lt;vector&lt;string&gt; &gt; solveNQueens(int n) &#123; vector&lt;int&gt; arr(n,0); limit=n; solveNqueen(arr,0,0); return sol; &#125; &#125;; https://discuss.leetcode.com/topic/7644/c-6ms-solution-use-bitmask C++ 6ms solution use bitmask 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; int n; string getNq(int p) &#123; string s(n, &apos;.&apos;); s[p] = &apos;Q&apos;; return s; &#125; void nQueens(int p, int l, int m, int r, vector&lt;vector&lt;string&gt;&gt; &amp;res) &#123; static vector&lt;string&gt; ans; if (p &gt;= n) &#123; res.push_back(ans); return ; &#125; int mask = l | m | r; for (int i = 0, b = 1; i &lt; n; ++ i, b &lt;&lt;= 1) if (!(mask &amp; b)) &#123; ans.push_back(getNq(i)); nQueens(p + 1, (l | b) &gt;&gt; 1, m | b, (r | b) &lt;&lt; 1, res); ans.pop_back(); &#125; &#125;public: vector&lt;vector&lt;string&gt; &gt; solveNQueens(int n) &#123; this-&gt;n = n; vector&lt;vector&lt;string&gt;&gt; res; nQueens(0, 0, 0, 0, res); return res; &#125;&#125;; python 108ms, 77.32%, June.16th, 2016 https://leetcode.com/discuss/49179/fast-short-and-easy-understand-python-solution-11-lines-76ms Fast, short, and easy-to-understand python solution, 11 lines, 76ms ideas: Use the DFS helper function to find solutions recursively. A solution will be found when the length of queens is equal to n ( queens is a list of the indices of the queens). In this problem, whenever a location (x, y) is occupied, any other locations (p, q ) where p + q == x + y or p - q == x - y would be invalid. We can use this information to keep track of the indicators (xy_dif and xy_sum ) of the invalid positions and then call DFS recursively with valid positions only. At the end, we convert the result (a list of lists; each sublist is the indices of the queens) into the desire format. 123456789101112def solveNQueens(self, n): def DFS(queens, xy_dif, xy_sum): p = len(queens) if p==n: result.append(queens) return None for q in range(n): if q not in queens and p-q not in xy_dif and p+q not in xy_sum: DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q]) result = [] DFS([],[],[]) return [ [&quot;.&quot;*i + &quot;Q&quot; + &quot;.&quot;*(n-i-1) for i in sol] for sol in result] https://discuss.leetcode.com/topic/9445/14-lines-python-code-dfs-solution 14 lines python code, DFS solution 1234567891011121314class Solution:# @return a list of lists of stringdef solveNQueens(self, n): stack, res = [[(0, i)] for i in range(n)], [] while stack: board = stack.pop() row = len(board) if row == n: res.append([&apos;&apos;.join(&apos;Q&apos; if i == c else &apos;.&apos; for i in range(n)) for r, c in board]) for col in range(n): if all(col != c and abs(row-r) != abs(col-c)for r, c in board): stack.append(board+[(row, col)]) return res https://discuss.leetcode.com/topic/22293/python-recursive-dfs-solution-with-comments Python recursive dfs solution with comments 123456789101112131415161718192021222324def solveNQueens(self, n): res = [] self.dfs([-1]*n, 0, [], res) return res # nums is a one-dimension array, like [1, 3, 0, 2] means# first queen is placed in column 1, second queen is placed# in column 3, etc.def dfs(self, nums, index, path, res): if index == len(nums): res.append(path) return # backtracking for i in xrange(len(nums)): nums[index] = i if self.valid(nums, index): # pruning tmp = &quot;.&quot;*len(nums) self.dfs(nums, index+1, path+[tmp[:i]+&quot;Q&quot;+tmp[i+1:]], res)# check whether nth queen can be placed in that columndef valid(self, nums, n): for i in xrange(n): if abs(nums[i]-nums[n]) == n -i or nums[i] == nums[n]: return False return True java https://discuss.leetcode.com/topic/8592/comparably-concise-java-code Comparably concise Java code Hi guys! I didnâ€™t invent a wheel here. We just remember the busy columns and diagonals and recursively try to put the queen into the next row. But I think the code below is short enough to be reproduced in the interview. Hope it helps! 123456789101112131415161718192021222324252627public class Solution &#123; private void helper(int r, boolean[] cols, boolean[] d1, boolean[] d2, String[] board, List&lt;String[]&gt; res) &#123; if (r == board.length) res.add(board.clone()); else &#123; for (int c = 0; c &lt; board.length; c++) &#123; int id1 = r - c + board.length, id2 = 2*board.length - r - c - 1; if (!cols[c] &amp;&amp; !d1[id1] &amp;&amp; !d2[id2]) &#123; char[] row = new char[board.length]; Arrays.fill(row, &apos;.&apos;); row[c] = &apos;Q&apos;; board[r] = new String(row); cols[c] = true; d1[id1] = true; d2[id2] = true; helper(r+1, cols, d1, d2, board, res); cols[c] = false; d1[id1] = false; d2[id2] = false; &#125; &#125; &#125; &#125; public List&lt;String[]&gt; solveNQueens(int n) &#123; List&lt;String[]&gt; res = new ArrayList&lt;&gt;(); helper(0, new boolean[n], new boolean[2*n], new boolean[2*n], new String[n], res); return res; &#125;&#125; https://discuss.leetcode.com/topic/19470/my-easy-understanding-java-solution My easy understanding Java Solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; char[][] board = new char[n][n]; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) board[i][j] = &apos;.&apos;; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); dfs(board, 0, res); return res; &#125; private void dfs(char[][] board, int colIndex, List&lt;List&lt;String&gt;&gt; res) &#123; if(colIndex == board.length) &#123; res.add(construct(board)); return; &#125; for(int i = 0; i &lt; board.length; i++) &#123; if(validate(board, i, colIndex)) &#123; board[i][colIndex] = &apos;Q&apos;; dfs(board, colIndex + 1, res); board[i][colIndex] = &apos;.&apos;; &#125; &#125; &#125; private boolean validate(char[][] board, int x, int y) &#123; for(int i = 0; i &lt; board.length; i++) &#123; for(int j = 0; j &lt; y; j++) &#123; if(board[i][j] == &apos;Q&apos; &amp;&amp; (x + j == y + i || x + y == i + j || x == i)) return false; &#125; &#125; return true; &#125; private List&lt;String&gt; construct(char[][] board) &#123; List&lt;String&gt; res = new LinkedList&lt;String&gt;(); for(int i = 0; i &lt; board.length; i++) &#123; String s = new String(board[i]); res.add(s); &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/24329/share-my-java-dfs-solution-very-easy-to-understand Share my JAVA DFS solution very easy to understand 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; private Set&lt;Integer&gt; col = new HashSet&lt;Integer&gt;(); private Set&lt;Integer&gt; diag1 = new HashSet&lt;Integer&gt;(); private Set&lt;Integer&gt; diag2 = new HashSet&lt;Integer&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); dfs(res,new ArrayList&lt;String&gt;(), 0, n); return res; &#125; private void dfs(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; list, int row, int n)&#123; if (row == n)&#123; res.add(new ArrayList&lt;String&gt;(list)); return; &#125; for (int i = 0; i &lt; n; i++)&#123; if (col.contains(i) || diag1.contains(row + i) || diag2.contains(row - i)) continue; char[] charArray = new char[n]; Arrays.fill(charArray, &apos;.&apos;); charArray[i] = &apos;Q&apos;; String rowString = new String(charArray); list.add(rowString); col.add(i); diag1.add(row + i); diag2.add(row - i); dfs(res, list, row + 1, n); list.remove(list.size() - 1); col.remove(i); diag1.remove(row + i); diag2.remove(row - i); &#125; &#125;&#125; https://discuss.leetcode.com/topic/40881/93-concise-fast-and-clear-java-solution 93% concise, fast, and clear java solution The code has comment. 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; boolean[] //ocp0 = new boolean[n], //whether there&apos;s a queen ocupying nth row, I don&apos;t need it ocp90 = new boolean[n], //whether there&apos;s a queen ocupying nth column ocp45 = new boolean[2 * n - 1], // mark 45 degree occupation ocp135 = new boolean[2 * n - 1]; // mark 135 degree occupation List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;List&lt;String&gt;&gt;(); char[][] map = new char[n][n]; for (char[] tmp : map) Arrays.fill(tmp, &apos;.&apos;); //init solve(0, n, map, ans, ocp45, ocp90, ocp135); return ans; &#125; private void solve(int depth, int n, char[][] map, List&lt;List&lt;String&gt;&gt; ans, boolean[] ocp45, boolean[] ocp90, boolean[] ocp135) &#123; if (depth == n) &#123; addSolution(ans, map); return; &#125; for (int j = 0; j &lt; n; j++) if (!ocp90[j] &amp;&amp; !ocp45[depth + j] &amp;&amp; !ocp135[j - depth + n - 1]) &#123; ocp90[j] = true; ocp45[depth + j] = true; ocp135[j - depth + n - 1] = true; map[depth][j] = &apos;Q&apos;; solve(depth + 1, n, map, ans, ocp45, ocp90, ocp135); ocp90[j] = false; ocp45[depth + j] = false; ocp135[j - depth + n - 1] = false; map[depth][j] = &apos;.&apos;; &#125; &#125; private void addSolution(List&lt;List&lt;String&gt;&gt; ans, char[][] map) &#123; List&lt;String&gt; cur = new ArrayList&lt;String&gt;(); for (char[] i : map) cur.add(String.valueOf(i)); ans.add(cur); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[050. Pow(x, n)]]></title>
    <url>%2Fp%2Ff4cb4bf8%2F</url>
    <content type="text"><![CDATA[26.3% https://leetcode.com/problems/powx-n/ Implement pow(x, n). è§£æ³•å¦‚ä¸‹ï¼š https://discuss.leetcode.com/topic/21837/5-different-choices-when-talk-with-interviewers After reading some good sharing solutions, Iâ€™d like to show them together. You can see different ideas in the code. nest myPow 1234567double myPow(double x, int n) &#123; if(n&lt;0) return 1/x * myPow(1/x, -(n+1)); if(n==0) return 1; if(n==2) return x*x; if(n%2==0) return myPow( myPow(x, n/2), 2); else return x*myPow( myPow(x, n/2), 2);&#125; double myPow 123456double myPow(double x, int n) &#123; if(n==0) return 1; double t = myPow(x,n/2); if(n%2) return n&lt;0 ? 1/x*t*t : x*t*t; else return t*t;&#125; double x 12345678double myPow(double x, int n) &#123; if(n==0) return 1; if(n&lt;0)&#123; n = -n; x = 1/x; &#125; return n%2==0 ? myPow(x*x, n/2) : x*myPow(x*x, n/2);&#125; iterative one 1234567891011121314double myPow(double x, int n) &#123; if(n==0) return 1; if(n&lt;0) &#123; n = -n; x = 1/x; &#125; double ans = 1; while(n&gt;0)&#123; if(n&amp;1) ans *= x; x *= x; n &gt;&gt;= 1; &#125; return ans;&#125; bit operation https://discuss.leetcode.com/topic/3636/my-answer-using-bit-operation-c-implementation In bit format and for a unsigned number, the number is represented as k02^0 + k12^1 + â€¦ +k31 2 ^31. Therefore, once we know the pow(x,2^0), pow(x,2^1), â€¦, pow(x,2^31), we can get pow(x,n). And pow(x,2 ^ m) can be constructed easily as pow(x,2^m) = pow(x,2^(m-1)) pow(x,2^(m-1)). 123456789101112131415161718192021class Solution &#123;public: double pow(double x, int n) &#123; if(n&lt;0)&#123; x = 1.0/x; n = -n; &#125; int unsigned m = n; double tbl[32] = &#123;0&#125;; double result = 1; tbl[0] = x; for(int i=1;i&lt;32;i++)&#123; tbl[i] = tbl[i-1]*tbl[i-1]; &#125; for(int i=0;i&lt;32;i++)&#123; if( m &amp; (0x1&lt;&lt;i) ) result *= tbl[i]; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/17832/non-recursive-c-log-n-solution 1234567891011121314151617181920class Solution &#123;public: double myPow(double x, int n) &#123; double ans = 1; unsigned long long p; if (n &lt; 0) &#123; p = -n; x = 1 / x; &#125; else &#123; p = n; &#125; while (p) &#123; if (p &amp; 1) ans *= x; x *= x; p &gt;&gt;= 1; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/10572/8-lines-of-c-7-ms 123456789double pow(double x, int n) &#123; if (n==0) return 1; double t = pow(x,n/2); if (n%2) &#123; return n&lt;0 ? 1/x*t*t : x*t*t; &#125; else &#123; return t*t; &#125;&#125; python https://discuss.leetcode.com/topic/15630/shortest-python-guaranteed Surprisingly, I can just use Pythonâ€™s existing pow like this: 12class Solution: myPow = pow Thatâ€™s even shorter than the other more obvious â€œcheatâ€: 123class Solution: def myPow(self, x, n): return x ** n And to calm down the haters, hereâ€™s me â€œdoing it myselfâ€: Recursive: 123456789class Solution: def myPow(self, x, n): if not n: return 1 if n &lt; 0: return 1 / self.myPow(x, -n) if n % 2: return x * self.myPow(x, n-1) return self.myPow(x*x, n/2) Iterative: 123456789101112class Solution: def myPow(self, x, n): if n &lt; 0: x = 1 / x n = -n pow = 1 while n: if n &amp; 1: pow *= x x *= x n &gt;&gt;= 1 return pow java https://discuss.leetcode.com/topic/5425/short-and-easy-to-understand-solution 1234567891011public class Solution &#123; public double pow(double x, int n) &#123; if(n == 0) return 1; if(n&lt;0)&#123; n = -n; x = 1/x; &#125; return (n%2 == 0) ? pow(x*x, n/2) : x*pow(x*x, n/2); &#125;&#125; https://discuss.leetcode.com/topic/2836/o-logn-solution-in-java /* This is a simple solution based on divide and conquer */ 1234567891011121314151617public class Solution &#123; public double pow(double x, int m) &#123; double temp=x; if(m==0) return 1; temp=pow(x,m/2); if(m%2==0) return temp*temp; else &#123; if(m &gt; 0) return x*temp*temp; else return (temp*temp)/x; &#125; &#125; https://discuss.leetcode.com/topic/40546/iterative-log-n-solution-with-clear-explanation I couldnâ€™t find a clear explanation for an interative Log(n) solution so hereâ€™s mine. The basic idea is to decompose the exponent into powers of 2, so that you can keep dividing the problem in half. For example, lets say N = 9 = 2^3 + 2^0 = 1001 in binary. Then: x^9 = x ^ (2 ^ 3) * x ^ (2 ^ 0) We can see that every time we encounter a 1 in the binary representation of N, we need to multiply the answer with x^(2^i) where i is the ith bit of the exponent. Thus, we can keep a running total of repeatedly squaring x - (x, x^2, x^4, x^8, etc) and multiply it by the answer when we see a 1. To handle the case where N=INTEGER_MIN we use a long (64-bit) variable. Below is solution: 123456789101112public class Solution &#123; public double MyPow(double x, int n) &#123; double ans = 1; long absN = Math.Abs((long)n); while(absN &gt; 0) &#123; if((absN&amp;1)==1) ans *= x; absN &gt;&gt;= 1; x *= x; &#125; return n &lt; 0 ? 1/ans : ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[049. Group Anagrams]]></title>
    <url>%2Fp%2F6810cb45%2F</url>
    <content type="text"><![CDATA[35.2% https://leetcode.com/problems/group-anagrams/description/ Given an array of strings, group anagrams together. 12345678For example, given: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;], Return:[ [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lower-case. æ–¹æ³•ä¸€ï¼š æŽ’åºå·çš„strä½œä¸ºkeyï¼Œç›¸åº”çš„é˜Ÿä¼ä½œä¸ºvalueçš„vectorï¼Œç„¶åŽmapè¿­ä»£å™¨æŠŠè¿™äº›éƒ½åˆå¹¶å°±å¯ä»¥äº†ã€‚ æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; vector&lt;vector&lt;string&gt;&gt; res; // ç”¨vector&lt;string&gt; è€Œä¸æ˜¯vector&lt;string&gt;() // ä½¿ç”¨æŽ’åºå¥½stringä½œä¸ºkey unordered_map&lt;string, vector&lt;string&gt;&gt; map; for(auto str: strs)&#123; string key = helper(str); // ä¸ç®¡æœ‰æ²¡æœ‰keyï¼Œéƒ½push_back map[key].push_back(str); &#125; // å­¦ä¹ mapçš„è¿­ä»£å™¨çš„ä½¿ç”¨ for(auto it=map.begin(); it!=map.end(); it++)&#123; res.push_back(it-&gt;second); &#125; return res; &#125; string helper(string s)&#123; if(s.empty()) return s; int n = s.size(); vector&lt;int&gt; cnt(26, 0); for(int i=0; i&lt;n; i++) cnt[s[i]-'a']++; string t(n, 'a'); int p = 0; for(int i=0; i&lt;26; i++)&#123; for(int j=0; j&lt;cnt[i]; j++)&#123; t[p++] += i; &#125; &#125; return t; &#125;&#125;; https://discuss.leetcode.com/topic/307/what-does-it-mean-return-all-groups-but-the-return-result-is-vector-string-how-can-we-return-all-groups What does it mean â€œreturn all groupsâ€? But the return result is vector? How can we return all groups? What does it mean â€œreturn all groupsâ€? But the return result is vector? How can we return all groups? I mean, for example, we have such vector [â€œdogâ€,â€catâ€,â€godâ€,â€tacâ€]. What should I return? https://discuss.leetcode.com/topic/307/what-does-it-mean-return-all-groups-but-the-return-result-is-vector-string-how-can-we-return-all-groups/2 1337c0d3rReputation: 1,607UPDATE: The return type had been changed to a list of list to avoid confusion. An example would be [â€œeatâ€, â€œteaâ€, â€œtanâ€, â€œateâ€, â€œnatâ€, â€œbatâ€], return: 12345[ [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note that even a single word is included as a group containing a single element. And here is the original old post: It means return all group of anagrams being flatten into one single list. For the input [â€œdogâ€,â€catâ€,â€godâ€,â€tacâ€], it should return: [â€œdogâ€,â€catâ€,â€godâ€,â€tacâ€], as dog and god are one group of anagrams, and cat and tac are another group of anagrams. I will probably change the return format to a more intuitive manner sometime in the future, such as: 1234[ [&quot;dog&quot;, &quot;god&quot;], [&quot;cat&quot;, &quot;tac&quot;]] Until this change happens, you will have to deal with the slightly confusing way of returning a flatten list, which should not affect the algorithm itself. https://discuss.leetcode.com/topic/8269/why-not-list-of-list-of-strings-as-output Why not list of list of strings as output? Why the output is list and not a list of list. What If there are multiple groups of anagrams? cpp 68ms, 79.37%, September 21, 2016 https://discuss.leetcode.com/topic/21038/10-lines-76ms-easy-c-solution-updated-function-signature 10-lines 76ms Easy C++ Solution (Updated Function Signature) The function signature has been updated to return a more intuitive vector&lt;vector&gt; which treats a single string as a group of anagrams consisting of only itself. The idea is to use an unordered_map to store those strings that are anagrams. We use the sorted string as the key and the string itself as the value. The strings are stored in a multiset since there may be duplicates. Moreover, multiset will sort them by default as we desire. The code is as follows. 1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, multiset&lt;string&gt;&gt; mp; for (string s : strs) &#123; string t = s; sort(t.begin(), t.end()); mp[t].insert(s); &#125; vector&lt;vector&lt;string&gt;&gt; anagrams; for (auto m : mp) &#123; vector&lt;string&gt; anagram(m.second.begin(), m.second.end()); anagrams.push_back(anagram); &#125; return anagrams; &#125;&#125;; Update: as suggested by yswu1234 in the answer, general sort takes O(nlogn) time. In this problem, since the string only contains lower-case alphabets, we can write a sorting function using counting sort (O(n) time) to speed up the sorting process. I write a string sorting function strSort below and using it to sort the string achieves the overall running time 72ms for this problem. 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, multiset&lt;string&gt;&gt; mp; for (string s : strs) &#123; string t = strSort(s); mp[t].insert(s); &#125; vector&lt;vector&lt;string&gt;&gt; anagrams; for (auto m : mp) &#123; vector&lt;string&gt; anagram(m.second.begin(), m.second.end()); anagrams.push_back(anagram); &#125; return anagrams; &#125;private: string strSort(string&amp; s) &#123; int count[26] = &#123;0&#125;, n = s.length(); for (int i = 0; i &lt; n; i++) count[s[i] - &apos;a&apos;]++; int p = 0; string t(n, &apos;a&apos;); for (int j = 0; j &lt; 26; j++) for (int i = 0; i &lt; count[j]; i++) t[p++] += j; return t; &#125; &#125;; https://discuss.leetcode.com/topic/6053/sharing-my-very-concise-solution-with-explanation Sharing my very concise solution with explanation 1234567891011121314151617vector&lt;string&gt; anagrams(vector&lt;string&gt; &amp;strs) &#123; vector&lt;string&gt; result; vector&lt;string&gt; sortedStrs = strs; unordered_map&lt;string, vector&lt;int&gt;&gt; map; for(int i = 0; i &lt; strs.size(); i++)&#123; sort(sortedStrs[i].begin(), sortedStrs[i].end()); map[sortedStrs[i]].push_back(i); &#125; for(auto it = map.begin(); it != map.end(); it++)&#123; if(it-&gt;second.size() &gt; 1)&#123; for(int i = 0; i &lt; it-&gt;second.size(); i++)&#123; result.push_back(strs[it-&gt;second[i]]); &#125; &#125; &#125; return result;&#125; Here is basic idea for this problem. First, get a copy of â€œstrsâ€. Letâ€™s name this copy â€œsortedStrsâ€. Second, sort all strings in â€œsortedStrsâ€. And we have a hash map unordered_map&lt;string, vector&gt; map. Every string in â€œsortedStrsâ€ will be recorded in this hash map with its position. In the second loop, we traverse this hash map. And find each value of which size is larger than 1. Then find the original string in â€œstrsâ€. Done. https://discuss.leetcode.com/topic/26074/a-clean-c-solution-with-unordered_map A clean c++ solution with unordered_map vector&lt;vector&gt; groupAnagrams(vector&amp; strs) { 1234567891011121314unordered_map&lt;string, vector&lt;string&gt;&gt; count; int i = 0; for (auto s : strs) &#123; sort(s.begin(), s.end()); count[s].push_back(strs[i++]); &#125; vector&lt;vector&lt;string&gt;&gt; res; for (auto n : count)&#123; sort(n.second.begin(), n.second.end()); res.push_back(n.second); &#125; return res;&#125; python https://discuss.leetcode.com/topic/3297/2-line-python-solution-ac-with-350ms-some-useful-python-tricks 2-line Python solution, AC with 350ms (some useful Python tricks) 123def anagrams(self, strs): count = collections.Counter([tuple(sorted(s)) for s in strs]) return filter(lambda x: count[tuple(sorted(x))]&gt;1, strs) collections.Counter creates a counter object. A counter object is like a specific kind of dictionary where it is build for counting (objects that hashes to same value) tuple(sorted(s)) is used here so that anagrams will be hashed to the same value. tuple is used because sorted returns a list which cannot be hashed but tuples can be hashed filter: selects some elements of the list based on given function (first argument - a lambda function is given here) lambda function defined here returns True if number of anagrams of that elements is greater than 1 https://discuss.leetcode.com/topic/3297/2-line-python-solution-ac-with-350ms-some-useful-python-tricks/2 Here is another python solution which is 4-line but a little more concise and faster (~ 20ms faster) 12345def anagrams(self, strs): d = collections.defaultdict(list) for s in strs: d[tuple(sorted(s))].append(s) return [a for agram_group in d.values() if len(agram_group)&gt;1 for a in agram_group] collection.defaultdict is used instead of Counter. It is almost same as dict but you can set default value (the value when item is not found in the dictionary) list comprehension is used in the return statement in order to select anagrams which have more than 1 word and also to flatten the d.values() which is list of lists https://discuss.leetcode.com/topic/21052/1-line-ruby-python-for-updated-problem 1 line Ruby/Python for Updated Problem The problem just got updated, now asking for different results. Here are some solutions for the new version. All of them use the sorted string as the group identifier, so for example the words â€œleetcoderâ€ and â€œelectrodeâ€ both have the group identifier â€œcdeeelortâ€ (or rather an array version of it), which is how I know that theyâ€™re anagrams of each other. Python solution 1 Sort and group by group identifier, then sort each group normally. 12def groupAnagrams(self, strs): return [sorted(g) for _, g in itertools.groupby(sorted(strs, key=sorted), sorted)] Or â€œbreaking it downâ€ to maybe make it more readable for beginners and because I just noticed that in Firefox it violates my self-imposed â€œno scrollbarsâ€ rule (I usually use Chrome and didnâ€™t think it differed): 123def groupAnagrams(self, strs): groups = itertools.groupby(sorted(strs, key=sorted), sorted) return [sorted(members) for _, members in groups] Python solution 2 Using defaultdict to collect the groups. 12345def groupAnagrams(self, strs): groups = collections.defaultdict(list) for s in strs: groups[tuple(sorted(s))].append(s) return map(sorted, groups.values()) java 46ms, 4.52%, September 21, 2016 https://discuss.leetcode.com/topic/24494/share-my-short-java-solution Share my short JAVA solution 123456789101112131415public class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; if(strs == null || strs.length == 0) return new ArrayList&lt;List&lt;String&gt;&gt;(); Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); Arrays.sort(strs); for(String s: strs)&#123; char[] ca = s.toCharArray(); Arrays.sort(ca); String keyStr = String.valueOf(ca); if(!map.containsKey(keyStr)) map.put(keyStr, new ArrayList&lt;String&gt;()); map.get(keyStr).add(s); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125; https://discuss.leetcode.com/topic/45639/java-beat-100-use-prime-number Java beat 100%!!! use prime number 12345678910111213141516171819202122public static List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; int[] prime = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103&#125;;//æœ€å¤š10609ä¸ªz List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (String s : strs) &#123; int key = 1; for (char c : s.toCharArray()) &#123; key *= prime[c - &apos;a&apos;]; &#125; List&lt;String&gt; t; if (map.containsKey(key)) &#123; t = res.get(map.get(key)); &#125; else &#123; t = new ArrayList&lt;&gt;(); res.add(t); map.put(key, res.size() - 1); &#125; t.add(s); &#125; return res; &#125; https://discuss.leetcode.com/topic/12509/o-m-n-algorithm-using-hash-without-sort O(M * N) algorithm using hash, without sort() Assign a prime number for a to z, and then multiply all prime numbers together to form a hash value. 123456789101112131415161718192021222324private static final int[] PRIMES = new int[]&#123;2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107&#125;;public List&lt;String&gt; anagrams(String[] strs) &#123; List&lt;String&gt; list = new LinkedList&lt;&gt;(); Map&lt;Integer, List&lt;String&gt;&gt; mapString = new HashMap&lt;&gt;(); int result = -1; for (int i = 0; i &lt; strs.length; i++)&#123; int mapping = 1; for (int j = 0, max = strs[i].length(); j &lt; max; j++) &#123; mapping *= PRIMES[strs[i].charAt(j) - &apos;a&apos;]; &#125; List&lt;String&gt; strings = mapString.get(mapping); if (strings == null) &#123; strings = new LinkedList&lt;&gt;(); mapString.put(mapping, strings); &#125; strings.add(strs[i]); &#125; for (List&lt;String&gt; mapList : mapString.values())&#123; if (mapList.size() &gt; 1) list.addAll(mapList); &#125; return list;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[048. Rotate Image]]></title>
    <url>%2Fp%2Ff0ab6b95%2F</url>
    <content type="text"><![CDATA[38.5% https://leetcode.com/problems/rotate-image/ You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up: Could you do this in-place? æ–¹æ³•ä¸€ï¼š https://leetcode.com/discuss/20589/a-common-method-to-rotate-the-image ä¸¤æ¬¡åè½¬ï¼Œä¸€æ¬¡ä¸Šä¸‹åè½¬ï¼Œä¸€æ¬¡ä¾§ç€åè½¬ å­¦ä¹ reverså‡½æ•° reverse(matrix.begin(), matrix.end()); A common method to rotate the image here give a common method to solve the image rotation problems. 12345678910111213141516171819202122/* * clockwise rotate * first reverse up to down, then swap the symmetry * 1 2 3 7 8 9 7 4 1 * 4 5 6 =&gt; 4 5 6 =&gt; 8 5 2 * 7 8 9 1 2 3 9 6 3*/void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; reverse(matrix.begin(), matrix.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125;/* * anticlockwise rotate * first reverse left to right, then swap the symmetry * 1 2 3 3 2 1 3 6 9 * 4 5 6 =&gt; 6 5 4 =&gt; 2 5 8 * 7 8 9 9 8 7 1 4 7*/ 1234567void anti_rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; for (auto vi : matrix) reverse(vi.begin(), vi.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix.size()==0 || matrix[0].size()==0) return; int n = matrix.size(); if(n==1) return; for(int i=0; i&lt;(n+1)/2; i++)&#123; for(int j=0; j&lt;n; j++)&#123; swap(matrix[i][j], matrix[n-1-i][j]); &#125; &#125; for(int i=0; i&lt;n; i++)&#123; for(int j=i+1; j&lt;n; j++) swap(matrix[i][j], matrix[j][i]); &#125; return; &#125;&#125;; cpp 6ms, 7.71%, June.17th, 2016 https://leetcode.com/discuss/20589/a-common-method-to-rotate-the-image A common method to rotate the image here give a common method to solve the image rotation problems. 12345678910111213141516171819202122/* * clockwise rotate * first reverse up to down, then swap the symmetry * 1 2 3 7 8 9 7 4 1 * 4 5 6 =&gt; 4 5 6 =&gt; 8 5 2 * 7 8 9 1 2 3 9 6 3*/void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; reverse(matrix.begin(), matrix.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125;/* * anticlockwise rotate * first reverse left to right, then swap the symmetry * 1 2 3 3 2 1 3 6 9 * 4 5 6 =&gt; 6 5 4 =&gt; 2 5 8 * 7 8 9 9 8 7 1 4 7*/ 1234567void anti_rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; for (auto vi : matrix) reverse(vi.begin(), vi.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125; https://discuss.leetcode.com/topic/20921/4ms-few-lines-c-code-rotate-image-90-degree-for-o-1-space 4ms few lines C++ code Rotate Image 90 degree for O(1) space 1234567891011121314void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); int a = 0; int b = n-1; while(a&lt;b)&#123; for(int i=0;i&lt;(b-a);++i)&#123; swap(matrix[a][a+i], matrix[a+i][b]); swap(matrix[a][a+i], matrix[b][b-i]); swap(matrix[a][a+i], matrix[b-i][a]); &#125; ++a; --b; &#125; &#125; https://discuss.leetcode.com/topic/17645/6-lines-of-code-and-with-o-1-space-in-c 6 lines of code and with O(1) space in c++ First we transpose the matrix and then reverse every row: 12345678910void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; m) &#123; int n = m.size(); for(int i=0; i&lt;n; i++) for(int j=0; j&lt;i; j++) swap(m[i][j], m[j][i]); for(int i=0; i&lt;n; i++) reverse(m[i].begin(), m[i].end()); &#125; https://discuss.leetcode.com/topic/5564/share-my-inplace-solution Share my inplace solution 123456789101112131415161718192021class Solution &#123;public: //fold for the middle, fold for the diagnal void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; //find middle int mid = matrix.size()/2; int n = matrix.size(); //swap, i swap with matrix.size()-1-i for(int i = 0; i &lt; mid; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; swap(matrix[i][j], matrix[n-1-i][j]); &#125; &#125; //swap, i,j swap with j,i for(int i = 0; i &lt; n; i++)&#123; for(int j = i; j &lt; n; j++)&#123; swap(matrix[i][j], matrix[j][i]); &#125; &#125; &#125;&#125;; Fold matrix once to the middle line. Fold matrix one more time along the diagonal line. python https://discuss.leetcode.com/topic/15295/seven-short-solutions-1-to-7-lines Seven Short Solutions (1 to 7 lines) While these solutions are Python, I think theyâ€™re understandable/interesting for non-Python coders as well. But before I begin: No mathematician would call a matrix matrix, so Iâ€™ll use the usual A. Also, btw, the 40 ms reached by two of the solutions is I think the fastest achieved by Python solutions so far. Most Pythonic - [::-1] and zip - 44 ms The most pythonic solution is a simple one-liner using [::-1] to flip the matrix upside down and then zip to transpose it. It assigns the result back into A, so itâ€™s â€œin-placeâ€ in a sense and the OJ accepts it as such, though some people might not. 123class Solution: def rotate(self, A): A[:] = zip(*A[::-1]) Most Direct - 52 ms A 100% in-place solution. It even reads and writes each matrix element only once and doesnâ€™t even use an extra temporary variable to hold them. It walks over the â€œtop-left quadrantâ€ of the matrix and directly rotates each element with the three corresponding elements in the other three quadrants. Note that Iâ€™m moving the four elements in parallel and that [~ i] is way nicer than [n-1-i]. 1234567class Solution: def rotate(self, A): n = len(A) for i in range(n/2): for j in range(n-n/2): A[i][j], A[~j][i], A[~i][~j], A[j][~i] = \ A[~j][i], A[~i][~j], A[j][~i], A[i][j] Clean Most Pythonic - 56 ms While the OJ accepts the above solution, the the result rows are actually tuples, not lists, so itâ€™s a bit dirty. To fix this, we can just apply list to every row: 123class Solution: def rotate(self, A): A[:] = map(list, zip(*A[::-1])) List Comprehension - 60 ms If you donâ€™t like zip, you can use a nested list comprehension instead: 123class Solution: def rotate(self, A): A[:] = [[row[i] for row in A[::-1]] for i in range(len(A))] Almost as Direct - 40 ms If you donâ€™t like the little repetitive code of the above â€œMost Directâ€ solution, we can instead do each four-cycle of elements by using three swaps of just two elements. 12345678class Solution: def rotate(self, A): n = len(A) for i in range(n/2): for j in range(n-n/2): for _ in &apos;123&apos;: A[i][j], A[~j][i], i, j = A[~j][i], A[i][j], ~j, ~i i = ~j Flip Flip - 40 ms Basically the same as the first solution, but using reverse instead of [::-1] and transposing the matrix with loops instead of zip. Itâ€™s 100% in-place, just instead of only moving elements around, it also moves the rows around. 123456class Solution: def rotate(self, A): A.reverse() for i in range(len(A)): for j in range(i): A[i][j], A[j][i] = A[j][i], A[i][j] Flip Flip, all by myself - 48 ms Similar again, but I first transpose and then flip left-right instead of upside-down, and do it all by myself in loops. This one is 100% in-place again in the sense of just moving the elements. 123456789class Solution: def rotate(self, A): n = len(A) for i in range(n): for j in range(i): A[i][j], A[j][i] = A[j][i], A[i][j] for row in A: for j in range(n/2): row[j], row[~j] = row[~j], row[j] java 0ms, 26.51%, June.17th, 2016 https://leetcode.com/discuss/27262/java-in-place-solution-with-explanation-easy-to-understand AC Java in place solution with explanation Easy to understand. The idea was firstly transpose the matrix and then flip it symmetrically. For instance, 1231 2 3 4 5 67 8 9 after transpose, it will be swap(matrix[i][j], matrix[j][i]) 1231 4 72 5 83 6 9 Then flip the matrix horizontally. (swap(matrix[i][j], matrix[i][matrix.length-1-j]) 1237 4 18 5 29 6 3 Hope this helps. 1234567891011121314151617181920public class Solution &#123; public void rotate(int[][] matrix) &#123; for(int i = 0; i&lt;matrix.length; i++)&#123; for(int j = i; j&lt;matrix[0].length; j++)&#123; int temp = 0; temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125; for(int i =0 ; i&lt;matrix.length; i++)&#123; for(int j = 0; j&lt;matrix.length/2; j++)&#123; int temp = 0; temp = matrix[i][j]; matrix[i][j] = matrix[i][matrix.length-1-j]; matrix[i][matrix.length-1-j] = temp; &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/20212/clear-java-solution Clear Java solution 12345678910111213public class Solution &#123;public void rotate(int[][] matrix) &#123; int n=matrix.length; for (int i=0; i&lt;n/2; i++) for (int j=i; j&lt;n-i-1; j++) &#123; int tmp=matrix[i][j]; matrix[i][j]=matrix[n-j-1][i]; matrix[n-j-1][i]=matrix[n-i-1][n-j-1]; matrix[n-i-1][n-j-1]=matrix[j][n-i-1]; matrix[j][n-i-1]=tmp; &#125; &#125;&#125; https://discuss.leetcode.com/topic/25989/a-simple-and-in-place-solution-in-java A Simple and In-Place Solution in Java 123456789101112131415161718192021222324public void rotate(int[][] matrix) &#123; if (matrix == null || matrix.length &lt;= 1) &#123; return; &#125; int n = matrix.length; for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &lt; n; j++) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; int head = 0; int tail = n - 1; while (head &lt; tail) &#123; int temp = matrix[i][head]; matrix[i][head] = matrix[i][tail]; matrix[i][tail] = temp; head++; tail--; &#125; &#125;&#125; For example, if the matrix is: 1 2 3 4 5 6 7 8 9 then after the first for loop, it becomes: 1 4 7 2 5 8 3 6 9 then after the second for loop, it becomes: 7 4 1 8 5 2 9 6 3]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[047. Permutations II]]></title>
    <url>%2Fp%2F94a736fc%2F</url>
    <content type="text"><![CDATA[32.8% https://leetcode.com/problems/permutations-ii/ Given a collection of numbers that might contain duplicates, return all possible unique permutations. 1234567891011For example,[1,1,2] have the following unique permutations:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] æ–¹æ³•ä¸€ï¼š 123456789101112131415161718192021class Solution &#123;public: void recursion(vector&lt;int&gt; nums, int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp; res)&#123; if(i==j-1)&#123; res.push_back(nums); return; &#125; for(int k=i; k&lt;j; k++)&#123; if(i!=k &amp;&amp; nums[i] == nums[k]) continue; swap(nums[i], nums[k]); recursion(nums, i+1, j, res); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; recursion(nums, 0, nums.size(), res); return res; &#125;&#125;; æ–¹æ³•äºŒï¼š æ­¤æ–¹æ³•é€šä¸è¿‡ï¼Œæœ‰ç–‘é—® é”™è¯¯æ ·ä¾‹ Input: [2,2,1,1] Output: [[1,1,2,2],[1,2,1,2],[1,2,2,1],[1,2,2,1],[1,2,1,2],[2,1,1,2],[2,1,2,1],[2,2,1,1],[2,1,2,1],[2,1,1,2],[2,2,1,1]] Expected: [[1,1,2,2],[1,2,1,2],[1,2,2,1],[2,1,1,2],[2,1,2,1],[2,2,1,1]] 12345678910111213141516171819202122class Solution &#123;public: void recursion(vector&lt;int&gt;&amp; nums, int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp; res)&#123; if(i==j-1)&#123; res.push_back(nums); return; &#125; for(int k=i; k&lt;j; k++)&#123; if(i!=k &amp;&amp; nums[i] == nums[k]) continue; swap(nums[i], nums[k]); recursion(nums, i+1, j, res); swap(nums[i], nums[k]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; recursion(nums, 0, nums.size(), res); return res; &#125;&#125;; cpp 23ms, 98.52%, September 21, 2016 https://discuss.leetcode.com/topic/8831/a-simple-c-solution-in-only-20-lines A simple C++ solution in only 20 lines 123456789101112131415161718192021class Solution &#123;public: void recursion(vector&lt;int&gt; nums, int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp; res)&#123; if(i==j-1)&#123; res.push_back(nums); return; &#125; for(int k=i; k&lt;j; k++)&#123; if(i!=k &amp;&amp; nums[i] == nums[k]) continue; swap(nums[i], nums[k]); recursion(nums, i+1, j, res); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; recursion(nums, 0, nums.size(), res); return res; &#125;&#125;; https://discuss.leetcode.com/topic/3194/a-non-recursive-c-implementation-with-o-1-space-cost A non-recursive C++ implementation with O(1) space cost 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permuteUnique(vector&lt;int&gt; &amp;S) &#123; // res.clear(); sort(S.begin(), S.end()); res.push_back(S); int j; int i = S.size()-1; while (1)&#123; for (i=S.size()-1; i&gt;0; i--)&#123; if (S[i-1]&lt; S[i])&#123; break; &#125; &#125; if(i == 0)&#123; break; &#125; for (j=S.size()-1; j&gt;i-1; j--)&#123; if (S[j]&gt;S[i-1])&#123; break; &#125; &#125; swap(S[i-1], S[j]); reverse(S, i, S.size()-1); res.push_back(S); &#125; return res; &#125; void reverse(vector&lt;int&gt; &amp;S, int s, int e)&#123; while (s&lt;e)&#123; swap(S[s++], S[e--]); &#125; &#125; vector&lt;vector&lt;int&gt; &gt; res;&#125;; Basically, assume we have â€œ1234â€, the idea is to increase the number in ascending order, so next is â€œ1243â€, next is â€œ1324â€, and so on. python https://discuss.leetcode.com/topic/32976/9-line-python-solution-with-1-line-to-handle-duplication-beat-99-of-others 9-line python solution with 1 line to handle duplication, beat 99% of others :-) Very similar to Permutation I, see explanations in https://leetcode.com/discuss/19510/my-ac-simple-iterative-java-python-solution. To handle duplication, just avoid inserting a number before any of its duplicates. 12345678910def permuteUnique(self, nums): ans = [[]] for n in nums: new_ans = [] for l in ans: for i in xrange(len(l)+1): new_ans.append(l[:i]+[n]+l[i:]) if i&lt;len(l) and l[i]==n: break #handles duplication ans = new_ans return ans https://discuss.leetcode.com/topic/32976/9-line-python-solution-with-1-line-to-handle-duplication-beat-99-of-others/2 Nice one! Hereâ€™s an even shorter and I think faster implementation, though. Got it accepted in 100 ms, achieving the coveted â€œYour runtime beats 100.00% of python submissions.â€ (Well, I tried five times, they were 112, 104, 100, 104 and 116 ms). 1234567def permuteUnique(self, nums): ans = [[]] for n in nums: ans = [l[:i]+[n]+l[i:] for l in ans for i in xrange((l+[n]).index(n)+1)] return ans And for fun, a one-liner version: 12def permuteUnique(self, nums): return reduce(lambda a,n:[l[:i]+[n]+l[i:]for l in a for i in xrange((l+[n]).index(n)+1)],nums,[[]]) https://discuss.leetcode.com/topic/7667/iterative-python-solution-without-using-set-111ms Iterative Python solution without using set, 111ms Duplication happens when we insert the duplicated element before and after the same element, to eliminate duplicates, just insert only after the same element. 123456789101112131415def permuteUnique(self, num): if not num: return [] num.sort() ret = [[]] for n in num: new_ret = [] l = len(ret[-1]) for seq in ret: for i in range(l, -1, -1): if i &lt; l and seq[i] == n: break new_ret.append(seq[:i] + [n] + seq[i:]) ret = new_ret return ret java https://discuss.leetcode.com/topic/31445/really-easy-java-solution-much-easier-than-the-solutions-with-very-high-vote Really easy Java solution, much easier than the solutions with very high vote Use an extra boolean array â€œ boolean[] usedâ€ to indicate whether the value is added to list. Sort the array â€œint[] numsâ€ to make sure we can skip the same value. when a number has the same value with its previous, we can use this number only if his previous is used 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(nums==null || nums.length==0) return res; boolean[] used = new boolean[nums.length]; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Arrays.sort(nums); dfs(nums, used, list, res); return res; &#125; public void dfs(int[] nums, boolean[] used, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res)&#123; if(list.size()==nums.length)&#123; res.add(new ArrayList&lt;Integer&gt;(list)); return; &#125; for(int i=0;i&lt;nums.length;i++)&#123; if(used[i]) continue; if(i&gt;0 &amp;&amp;nums[i-1]==nums[i] &amp;&amp; !used[i-1]) continue; used[i]=true; list.add(nums[i]); dfs(nums,used,list,res); used[i]=false; list.remove(list.size()-1); &#125; &#125;&#125; https://discuss.leetcode.com/topic/5993/share-my-recursive-solution Share my recursive solution 1234567891011121314151617181920212223242526272829public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] num) &#123; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; current = new ArrayList&lt;Integer&gt;(); boolean[] visited = new boolean[num.length]; permute(result, current, num, visited); return result; &#125; private void permute(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; current, int[] num, boolean[] visited) &#123; if (current.size() == num.length) &#123; result.add(new ArrayList&lt;Integer&gt;(current)); return; &#125; for (int i=0; i&lt;visited.length; i++) &#123; if (!visited[i]) &#123; if (i &gt; 0 &amp;&amp; num[i] == num[i-1] &amp;&amp; visited[i-1]) &#123; return; &#125; visited[i] = true; current.add(num[i]); permute(result, current, num, visited); current.remove(current.size()-1); visited[i] = false; &#125; &#125; &#125;&#125; The idea to resolve duplicate is to ensure that for elements with the same value, we make sure that they are picked up in the ascending order of index. To implement this, every time we try to pick up some value, we just check if the previous element has the same value and is visited or not. If so, we just return! https://discuss.leetcode.com/topic/36221/share-my-java-code-with-detailed-explanantion Share my Java code with detailed explanantion 12345678910111213141516171819202122232425262728293031public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (nums==null || nums.length==0) &#123; return ans; &#125; permute(ans, nums, 0); return ans; &#125; private void permute(List&lt;List&lt;Integer&gt;&gt; ans, int[] nums, int index) &#123; if (index == nums.length) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for (int num: nums) &#123; temp.add(num); &#125; ans.add(temp); return; &#125; Set&lt;Integer&gt; appeared = new HashSet&lt;&gt;(); for (int i=index; i&lt;nums.length; ++i) &#123; if (appeared.add(nums[i])) &#123; swap(nums, index, i); permute(ans, nums, index+1); swap(nums, index, i); &#125; &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int save = nums[i]; nums[i] = nums[j]; nums[j] = save; &#125;&#125; https://discuss.leetcode.com/topic/12923/short-iterative-java-solution Short iterative Java solution Hi guys! Hereâ€™s an iterative solution which doesnâ€™t use nextPermutation helper. It builds the permutations for i-1 first elements of an input array and tries to insert the ith element into all positions of each prebuilt i-1 permutation. I couldnâ€™t come up with more effective controling of uniqueness than just using a Set. See the code below! 12345678910111213141516171819public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] num) &#123; LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); res.add(new ArrayList&lt;&gt;()); for (int i = 0; i &lt; num.length; i++) &#123; Set&lt;String&gt; cache = new HashSet&lt;&gt;(); while (res.peekFirst().size() == i) &#123; List&lt;Integer&gt; l = res.removeFirst(); for (int j = 0; j &lt;= l.size(); j++) &#123; List&lt;Integer&gt; newL = new ArrayList&lt;&gt;(l.subList(0,j)); newL.add(num[i]); newL.addAll(l.subList(j,l.size())); if (cache.add(newL.toString())) res.add(newL); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[046. Permutations]]></title>
    <url>%2Fp%2Fc83ab0f7%2F</url>
    <content type="text"><![CDATA[42.0% https://leetcode.com/problems/permutations/ Given a collection of distinct numbers, return all possible permutations. 12345678910For example,[1,2,3] have the following permutations:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] æ–¹æ³•ä¸€ï¼šæ ‡å‡†çš„å›žæº¯æ³• å‰‘æŒ‡offer 28 æˆ‘çš„ä»£ç å®žçŽ°: 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; dfs(nums, res, 0); return res; &#125; void dfs(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; res, int k)&#123; if(k==nums.size()-1)&#123; res.push_back(nums); return; &#125; for(int i=k; i&lt;nums.size(); i++)&#123; swap(nums[k], nums[i]); dfs(nums, res, k+1); swap(nums[k], nums[i]); &#125; &#125;&#125;; æ³¨æ„ï¼Œå€’æ•°ç¬¬ä¸‰è¡Œï¼Œå‚æ•°æ˜¯begin+1, ä¸æ˜¯i+1. permuteRecursive(nums, begin, result); ä»£è¡¨numsä¸­0è‡³begin-1å·²ç»æŽ’å¥½åºäº†ï¼Œå‰©ä¸‹çš„æ˜¯beginè‡³n-1 n = nums.size()-1 æ‰€ä»¥å½“begin = næ—¶ï¼Œåˆ™pushè¿›åŽ»ã€‚ ç„¶åŽï¼ŒbeginæœªæŽ’å¥½ï¼Œä»Žbeginå¼€å§‹ï¼Œbeginä¸ŽåŽé¢çš„éƒ½äº¤æ¢ä¸€é æ¯æ¬¡äº¤æ¢åŽï¼Œè°ƒç”¨permuteRecurive(nums, begin+1, res); æ‰€ä»¥é€»è¾‘æ˜¯å¾ˆæ¸…æ™°çš„äº†ã€‚ My elegant recursive C++ solution with inline explanation This recursive solution is the my first response for this problem. I was surprised when I found no similar solution posted here. It is much easier to understand than DFS-based ones, at least in my opinion. Please find more explanations here. All comments are welcome. 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; result; permuteRecursive(num, 0, result); return result; &#125; // permute num[begin..end] // invariant: num[0..begin-1] have been fixed/permuted void permuteRecursive(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;result) &#123; if (begin &gt;= num.size()) &#123; // one permutation instance result.push_back(num); return; &#125; for (int i = begin; i &lt; num.size(); i++) &#123; swap(num[begin], num[i]); permuteRecursive(num, begin + 1, result); // reset swap(num[begin], num[i]); &#125; &#125;&#125;; æˆ‘çš„å®žçŽ° ç»å…¸å›žæº¯æ³• æ€è€ƒæ¸…æ¥šè¿‡ç¨‹ 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; res; helper(nums, 0, n, res); return res; &#125; void helper(vector&lt;int&gt;&amp; nums, int k, int n, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(k==n)&#123; res.push_back(nums); return; &#125; for(int i=k; i&lt;n; i++)&#123; swap(nums[k], nums[i]); helper(nums, k+1, n, res); // æ­¤å¤„å˜ä¸ºk+1ï¼Œä¸æ˜¯i+1 swap(nums[k], nums[i]); &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/5881/my-elegant-recursive-c-solution-with-inline-explanation My elegant recursive C++ solution with inline explanation This recursive solution is the my first response for this problem. I was surprised when I found no similar solution posted here. It is much easier to understand than DFS-based ones, at least in my opinion. Please find more explanations here. All comments are welcome. 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; result; permuteRecursive(num, 0, result); return result; &#125; // permute num[begin..end] // invariant: num[0..begin-1] have been fixed/permuted void permuteRecursive(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;result) &#123; if (begin &gt;= num.size()) &#123; // one permutation instance result.push_back(num); return; &#125; for (int i = begin; i &lt; num.size(); i++) &#123; swap(num[begin], num[i]); permuteRecursive(num, begin + 1, result); // reset swap(num[begin], num[i]); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/6740/share-my-three-different-solutions Share my three different solutions 1234567891011121314151617181920// method 1: standard backtracing solutionvector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; ans; permutation(num, 0, ans); return ans;&#125;void permutation(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;ans) &#123; if (begin &gt;= num.size()) &#123; ans.push_back(num); return; &#125; // every number chosen to be the begin once for (int i = begin; i &lt; num.size(); ++i) &#123; swap(num[begin], num[i]); permutation(num, begin+1, ans); swap(num[begin], num[i]); &#125;&#125; 12345678910// method 2: using next_permutation to iterate all the permutaionsvector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; ans; sort(num.begin(), num.end()); ans.push_back(num); while(next_permutation(num.begin(), num.end())) ans.push_back(num); return ans;&#125; 12345678910111213141516171819202122232425262728// method 3: recursive dfsvector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; ans; dfs(num, ans); return ans;&#125;void dfs(vector&lt;int&gt; &amp;num, vector&lt;vector&lt;int&gt;&gt; &amp;ans) &#123; if (num.size() == 1) &#123; vector&lt;int&gt; tmp(num.begin(), num.end()); ans.push_back(tmp); return; &#125; vector&lt;vector&lt;int&gt; &gt; ans1; vector&lt;int&gt; num1(num.begin()+1, num.end()); dfs(num1, ans); for(int i = 0; i &lt; ans.size(); ++i) &#123; for(int j = 0; j &lt;= ans[i].size(); ++j) &#123; vector&lt;int&gt; tmp = ans[i]; tmp.insert(tmp.begin()+j, num[0]); ans1.push_back(tmp); &#125; &#125; ans = ans1;&#125; 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; result; permuteRecursive(num, 0, result); return result; &#125; // permute num[begin..end] // invariant: num[0..begin-1] have been fixed/permuted void permuteRecursive(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;result) &#123; if (begin &gt;= num.size()) &#123; // one permutation instance result.push_back(num); return; &#125; for (int i = begin; i &lt; num.size(); i++) &#123; swap(num[begin], num[i]); permuteRecursive(num, begin + 1, result); // reset swap(num[begin], num[i]); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/17277/one-liners-in-python One-Liners in Python Solution 1: Recursive, take any number as first Take any number as the first number and append any permutation of the other numbers. 1234def permute(self, nums): return [[n] + p for i, n in enumerate(nums) for p in self.permute(nums[:i] + nums[i+1:])] or [[]] Solution 2: Recursive, insert first number anywhere Insert the first number anywhere in any permutation of the remaining numbers. 1234def permute(self, nums): return nums and [p[:i] + [nums[0]] + p[i:] for p in self.permute(nums[1:]) for i in range(len(nums))] or [[]] Solution 3: Reduce, insert next number anywhere Use reduce to insert the next number anywhere in the already built permutations. 1234def permute(self, nums): return reduce(lambda P, n: [p[:i] + [n] + p[i:] for p in P for i in range(len(p)+1)], nums, [[]]) Solution 4: Using the library 12def permute(self, nums): return list(itertools.permutations(nums)) That returns a list of tuples, but the OJ accepts it anyway. If needed, I could easily turn it into a list of lists: 12def permute(self, nums): return map(list, itertools.permutations(nums)) 76ms, 93.03%, June.17th, 2016 https://leetcode.com/discuss/51398/simple-python-solution-dfs 12345678910111213141516class Solution(object): def permute(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; res = [] self.dfs(nums, [], res) return res def dfs(self, nums, path, res): if not nums: res.append(path) else: for i in xrange(len(nums)): self.dfs(nums[:i] + nums[i+1:], path+[nums[i]], res) java https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partioning) This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. Subsets : https://leetcode.com/problems/subsets/ 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Subsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Permutations : https://leetcode.com/problems/permutations/ 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/ 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum : https://leetcode.com/problems/combination-sum/ 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum II (canâ€™t reuse same element) : https://leetcode.com/problems/combination-sum-ii/ 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Palindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/ 12345678910111213141516171819202122232425public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list;&#125;public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125;&#125;public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true;&#125; https://discuss.leetcode.com/topic/6377/my-ac-simple-iterative-java-python-solution 123456789My AC simple iterative java/python solutionthe basic idea is, to permute n numbers, we can add the nth number into the resulting List&lt;List&lt;Integer&gt;&gt; from the n-1 numbers, in every possible position.For example, if the input num[] is &#123;1,2,3&#125;: First, add 1 into the initial List&lt;List&lt;Integer&gt;&gt; (let&apos;s call it &quot;answer&quot;).Then, 2 can be added in front or after 1. So we have to copy the List&lt;Integer&gt; in answer (it&apos;s just &#123;1&#125;), add 2 in position 0 of &#123;1&#125;, then copy the original &#123;1&#125; again, and add 2 in position 1. Now we have an answer of &#123;&#123;2,1&#125;,&#123;1,2&#125;&#125;. There are 2 lists in the current answer.Then we have to add 3. first copy &#123;2,1&#125; and &#123;1,2&#125;, add 3 in position 0; then copy &#123;2,1&#125; and &#123;1,2&#125;, and add 3 into position 1, then do the same thing for position 3. Finally we have 2\*3=6 lists in answer, which is what we want. 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (num.length ==0) return ans; List&lt;Integer&gt; l0 = new ArrayList&lt;Integer&gt;(); l0.add(num[0]); ans.add(l0); for (int i = 1; i&lt; num.length; ++i)&#123; List&lt;List&lt;Integer&gt;&gt; new_ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for (int j = 0; j&lt;=i; ++j)&#123; for (List&lt;Integer&gt; l : ans)&#123; List&lt;Integer&gt; new_l = new ArrayList&lt;Integer&gt;(l); new_l.add(j,num[i]); new_ans.add(new_l); &#125; &#125; ans = new_ans; &#125; return ans;&#125; python version is more concise: 123456789def permute(self, nums): perms = [[]] for n in nums: new_perms = [] for perm in perms: for i in xrange(len(perm)+1): new_perms.append(perm[:i] + [n] + perm[i:]) ###insert n perms = new_perms return perms https://discuss.leetcode.com/topic/10812/share-my-short-iterative-java-solution Share my short iterative JAVA solution 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) &#123; LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;List&lt;Integer&gt;&gt;(); res.add(new ArrayList&lt;Integer&gt;()); for (int n : num) &#123; int size = res.size(); for (; size &gt; 0; size--) &#123; List&lt;Integer&gt; r = res.pollFirst(); for (int i = 0; i &lt;= r.size(); i++) &#123; List&lt;Integer&gt; t = new ArrayList&lt;Integer&gt;(r); t.add(i, n); res.add(t); &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/23036/java-clean-code-two-recursive-solutions Java Clean Code - Two recursive solutions Bottom up? approach - 280ms 1234567891011121314151617181920212223242526public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; permutations = new ArrayList&lt;&gt;(); if (nums.length == 0) &#123; return permutations; &#125; collectPermutations(nums, 0, new ArrayList&lt;&gt;(), permutations); return permutations; &#125; private void collectPermutations(int[] nums, int start, List&lt;Integer&gt; permutation, List&lt;List&lt;Integer&gt;&gt; permutations) &#123; if (permutation.size() == nums.length) &#123; permutations.add(permutation); return; &#125; for (int i = 0; i &lt;= permutation.size(); i++) &#123; List&lt;Integer&gt; newPermutation = new ArrayList&lt;&gt;(permutation); newPermutation.add(i, nums[start]); collectPermutations(nums, start + 1, newPermutation, permutations); &#125; &#125;&#125; Code flow 123456789101112131415nums = 1,2,3start = 0, permutation = []i = 0, newPermutation = [1] start = 1, permutation = [1] i = 0, newPermutation = [2, 1] start = 2, permutation = [2, 1] i = 0, newPermutation = [3, 2, 1] i = 1, newPermutation = [2, 3, 1] i = 2, newPermutation = [2, 1, 3] i = 1, newPermutation = [1, 2] start = 2, permutation = [1, 2] i = 0, newPermutation = [3, 1, 2] i = 1, newPermutation = [1, 3, 2] i = 2, newPermutation = [1, 2, 3] Base case and build approach - 524ms 1234567891011121314151617181920212223242526272829public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; return permute(Arrays.stream(nums).boxed().collect(Collectors.toList())); &#125; private List&lt;List&lt;Integer&gt;&gt; permute(List&lt;Integer&gt; nums) &#123; List&lt;List&lt;Integer&gt;&gt; permutations = new ArrayList&lt;&gt;(); if (nums.size() == 0) &#123; return permutations; &#125; if (nums.size() == 1) &#123; List&lt;Integer&gt; permutation = new ArrayList&lt;&gt;(); permutation.add(nums.get(0)); permutations.add(permutation); return permutations; &#125; List&lt;List&lt;Integer&gt;&gt; smallPermutations = permute(nums.subList(1, nums.size())); int first = nums.get(0); for(List&lt;Integer&gt; permutation : smallPermutations) &#123; for (int i = 0; i &lt;= permutation.size(); i++) &#123; List&lt;Integer&gt; newPermutation = new ArrayList&lt;&gt;(permutation); newPermutation.add(i, first); permutations.add(newPermutation); &#125; &#125; return permutations; &#125;&#125; Code flow 12345678910111213141516171819nums = 1,2,3smallPermutations(2, 3) smallPermutations(3) return [[3]] first = 2 permutation = [3] i = 0, newPermutation = [2, 3] i = 1, newPermutation = [3, 2] return [[2, 3], [3, 2]]first = 1 permutation = [2, 3] i = 0, newPermutation = [1, 2, 3] i = 1, newPermutation = [2, 1, 3] i = 2, newPermutation = [2, 3, 1] permutation = [3, 2] i = 0, newPermutation = [1, 3, 2] i = 1, newPermutation = [3, 1, 2] i = 2, newPermutation = [3, 2, 1] å›žæº¯æ³• https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning1234567891011121314151617181920public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), nums); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums)&#123; if(tempList.size() == nums.length) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i=0; i&lt;nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size()-1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[045. Jump Game II]]></title>
    <url>%2Fp%2Fded0cd97%2F</url>
    <content type="text"><![CDATA[26.2% https://leetcode.com/problems/jump-game-ii/ Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. 123456For example:Given array A = [2,3,1,1,4]The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.) Note: You can assume that you can always reach the last index. æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç ï¼š lastJumpï¼Œè¡¨ç¤ºç»è¿‡ä¸Šä¸€æ­¥ä¹‹åŽï¼Œæ‰€èƒ½åˆ°è¾¾æœ€è¿œçš„ç‚¹ã€‚ nextJumpæ˜¯step++ä¹‹åŽï¼Œæ–°çš„ä¸€æ®µï¼Œèƒ½èµ°çš„æœ€è¿œçš„ç‚¹ã€‚ 1234567891011121314151617class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==1) return 0; int lastJump = 0; int nextJump = 0; int step = 0; for(int i=0; i&lt;nums.size()-1; i++)&#123; nextJump = max(nextJump, i+nums[i]); if(lastJump == i)&#123; step++; lastJump = nextJump; &#125; &#125; return step; &#125;&#125;; my code 12345678910111213141516class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int step = 0; int e = 0; int ma = 0; for(int i=0; i&lt;nums.size()-1; i++)&#123; ma = max(i+nums[i], ma); if(i==e)&#123; step++; e = ma; &#125; &#125; return step; &#125;&#125;; cpp https://discuss.leetcode.com/topic/3191/o-n-bfs-solution O(n), BFS solution I try to change this problem to a BFS problem, where nodes in level i are all the nodes that can be reached in i-1th jump. for example. 2 3 1 1 4 , is 2|| 3 1|| 1 4 || clearly, the minimum jump of 4 is 2 since 4 is in level 3. my ac code. 1234567891011121314int jump(int A[], int n) &#123; if(n&lt;2)return 0; int level=0,currentMax=0,i=0,nextMax=0; while(currentMax-i+1&gt;0)&#123; //nodes count of current level&gt;0 level++; for(;i&lt;=currentMax;i++)&#123; //traverse current level , and update the max reach of next level nextMax=max(nextMax,A[i]+i); if(nextMax&gt;=n-1)return level; // if last element is in level+1, then the min jump=level &#125; currentMax=nextMax; &#125; return 0; &#125; https://leetcode.com/discuss/45992/10-lines-c-16ms-python-bfs-solutions-with-explanations 16ms, 22.73%, June.22th, 2016 10-lines C++ (16ms) / Python BFS Solutions with Explanations This problem has a nice BFS structure. Letâ€™s illustrate it using the example nums = [2, 3, 1, 1, 4] in the problem statement. We are initially at position 0. Then we can move at most nums[0] steps from it. So, after one move, we may reach nums[1] = 3 or nums[2] = 1. So these nodes are reachable in 1 move. From these nodes, we can further move to nums[3] = 1 and nums[4] = 4. Now you can see that the target nums[4] = 4 is reachable in 2 moves. Putting these into codes, we keep two pointers start and end that record the current range of the starting nodes. Each time after we make a move, update start to be end + 1 and end to be the farthest index that can be reached in 1 move from the current [start, end]. To get an accepted solution, it is important to handle all the edge cases. And the following codes handle all of them in a unified way without using the unclean if statements :-) 1234567891011121314151617class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), start = 0, end = 0, step=0; while(end &lt; n - 1)&#123; step++; int maxend = end + 1; for(int i = start; i &lt; end + 1; i++)&#123; if(nums[i] + i &gt;= n - 1) return step; maxend = max(maxend, nums[i] + i); &#125; start = end + 1; end = maxend; &#125; return step; &#125;&#125;; https://discuss.leetcode.com/topic/5810/sharing-my-straightforward-c-solution Sharing my straightforward C++ solution 12345678910111213141516171819int jump(int A[], int n) &#123; if(n == 0)&#123; return 0; &#125; int maxReachPos = A[0]; int curMaxReachPos = A[0]; int curStep = 1; for(int i = 1; i &lt;= min(n, maxReachPos); i++)&#123; curMaxReachPos = max(curMaxReachPos, i + A[i]); if(i == n - 1)&#123; return curStep; &#125; if(i == maxReachPos)&#123; maxReachPos = curMaxReachPos; curStep++; &#125; &#125; return 0;&#125; The variable maxReachPos indicates the farthest reachable position and the variable curMaxReachPos indicates the current farthest reachable position. At the very beginning, both maxReachPos and curMaxReachPos are equal to A[0]. In the For loop, we keep updating curMaxReachPos while i &lt;= maxReachPos. However, if( i == n - 1), we return curStep, which is the minimum step. If i reaches the maxReachPos, we update maxReachPos with curMaxReachPos and increment curStep by one. Finally, if we canâ€™t reach the end point, just return 0. python https://discuss.leetcode.com/topic/11761/easy-python-greedy-solution-with-explanation Easy Python Greedy solution with explanation 123456789101112131415class Solution:# @param A, a list of integers# @return an integerdef jump(self, A): last_max_reach, current_max_reach = 0 , 0 njump , i = 0 , 0 while current_max_reach &lt; len(A)-1: while i &lt;= last_max_reach: current_max_reach = max(i+A[i],current_max_reach) i+=1 if last_max_reach == current_max_reach: return -1 last_max_reach = current_max_reach njump+=1 return njump The basic thoughts underline is a greedy style. Every one more jump, you want to jump as far as possible.In Jump Game I, when you at position i, you care about what is the furthest position could be reached from i th position. but here in Jump Game II, instead you care about what would be the next furthest jump could be made when you could reach as far as ith position from last jump. So you iterate all positions could be reached from last jump till i th position to find it out. https://leetcode.com/discuss/45992/10-lines-c-16ms-python-bfs-solutions-with-explanations 86ms, 29.68%, June.22th, 201612345678910111213141516class Solution(object): def jump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n, start, end, step = len(nums), 0, 0, 0 while end &lt; n - 1: step += 1 maxend = end + 1 for i in range(start, end + 1): if i + nums[i] &gt;= n - 1: return step maxend = max(maxend, i + nums[i]) start, end = end + 1, maxend return step https://leetcode.com/discuss/45992/10-lines-c-16ms-python-bfs-solutions-with-explanations 84ms, 29.68%, June.22th, 2016 12345678910111213141516class Solution(object): def jump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n, start, end, step = len(nums), 0, 0, 0 while end &lt; n - 1: step += 1 maxend = end + 1 for i in range(start, end + 1): maxend = max(maxend, i + nums[i]) if maxend &gt;= n - 1: return step start, end = end + 1, maxend return step java https://discuss.leetcode.com/topic/11408/single-loop-simple-java-solution Single loop simple java solution 12345678910111213public int jump(int[] A) &#123; int step = 0; int e = 0; int max = 0; for(int i=0; i&lt;A.length-1; i++) &#123; max = Math.max(max, i+A[i]); if( i == e ) &#123; step++; e = max; &#125; &#125; return step;&#125; https://discuss.leetcode.com/topic/11408/single-loop-simple-java-solution/2 Very elegant method, but it took me a long time to understand. Some comment for the above: e: longest distance in current minimum step step: minimum steps for reaching e From i to e, even max is changed in a loop, it is reachable in one step. Help it will help : ) https://discuss.leetcode.com/topic/11408/single-loop-simple-java-solution/4 12345678910111213public int jump(int[] A) &#123; int step_count = 0; int last_jump_max = 0; int current_jump_max = 0; for(int i=0; i&lt;A.length-1; i++) &#123; current_jump_max = Math.max(current_jump_max, i+A[i]); if( i == last_jump_max ) &#123; step_count++; last_jump_max = current_jump_max; &#125; &#125; return step_count;&#125; https://discuss.leetcode.com/topic/4069/sharing-my-ac-java-solution Sharing My AC Java Solution Hi All, below is my AC solution: 12345678910111213141516171819public int jump(int[] A) &#123; int maxReach = A[0]; int edge = 0; int minstep = 0; for(int i = 1; i &lt; A.length; i++) &#123; if (i &gt; edge) &#123; minstep += 1; edge = maxReach; if(edge &gt; A.length - 1) return minstep; &#125; maxReach = Math.max(maxReach, A[i] + i); if (maxReach == i): return -1; &#125; return minstep;&#125; When iterate the array, I set an edge for the Search phase, which means that if I exceeds the edge, the minstep must add one and the maxReach will be update. And when the last index is within the range of the edge, output the minstep. [2, 3, 1, 1, 4] First, the edge is 0; Second, after start iterate the array, it exceeds the edge 0 when reaching the A[0] and update the edge to 2; Third, after it reach the A[2], it exceeds the edge 2 and update the new edge to the maxReach 4. Finally, end of the array is inside the edge, output the minstep. https://discuss.leetcode.com/topic/28470/concise-o-n-one-loop-java-solution-based-on-greedy Concise O(n) one loop JAVA solution based on Greedy Explanation The main idea is based on greedy. Letâ€™s say the range of the current jump is [curBegin, curEnd], curFarthest is the farthest point that all points in [curBegin, curEnd] can reach. Once the current point reaches curEnd, then trigger another jump, and set the new curEnd with curFarthest, then keep the above steps, as the following: 1234567891011public int jump(int[] A) &#123; int jumps = 0, curEnd = 0, curFarthest = 0; for (int i = 0; i &lt; A.length - 1; i++) &#123; curFarthest = Math.max(curFarthest, i + A[i]); if (i == curEnd) &#123; jumps++; curEnd = curFarthest; &#125; &#125; return jumps;&#125; https://leetcode.com/discuss/30647/single-loop-simple-java-solution 3ms, 55.57%, June.22th, 2016123456789101112131415public class Solution &#123; public int jump(int[] nums) &#123; int sc = 0; int e = 0; int max = 0; for(int i=0; i&lt;nums.length-1; i++) &#123; max = Math.max(max, i+nums[i]); if( i == e ) &#123; sc++; e = max; &#125; &#125; return sc; &#125; &#125; my code 12345678910111213public class Solution &#123; public int jump(int[] nums) &#123; int step=0, cur=0, max=0; for(int i=0; i&lt;nums.length-1; i++)&#123; max = Math.max(max, i+nums[i]); if(i==cur)&#123; step += 1; cur = max; &#125; &#125; return step; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hard</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[044. Wildcard Matching]]></title>
    <url>%2Fp%2Fbcc0695c%2F</url>
    <content type="text"><![CDATA[20.4% https://leetcode.com/problems/wildcard-matching/ Implement wildcard pattern matching with support for â€˜?â€™ and â€˜*â€˜. 12345678910111213141516&apos;?&apos; Matches any single character.&apos;*&apos; Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) â†’ falseisMatch(&quot;aa&quot;,&quot;aa&quot;) â†’ trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) â†’ falseisMatch(&quot;aa&quot;, &quot;*&quot;) â†’ trueisMatch(&quot;aa&quot;, &quot;a*&quot;) â†’ trueisMatch(&quot;ab&quot;, &quot;?*&quot;) â†’ trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) â†’ false æ–¹æ³•ä¸€: æˆ‘çš„ä»£ç å®žçŽ°: 1234567891011121314151617181920212223class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.size(), n = p.size(); if(n==0) return m==0; vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=1; i&lt;=n; i++) dp[0][i] = dp[0][i-1] &amp;&amp; (p[i-1]=='*'); for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) if(p[j-1]!='*') dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]=='?'); else&#123; for(int k=i; k&gt;=0; k--)&#123; dp[i][j] = dp[i][j] || dp[k][j-1]; if(dp[i][j]==true) break; &#125; &#125; return dp[m][n]; &#125;&#125;; æ–¹æ³•äºŒ: æˆ‘çš„ä»£ç å®žçŽ°: 123456789101112131415161718class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.size(), n = p.size(); if(n==0) return m==0; vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=1; i&lt;=n; i++) dp[0][i] = dp[0][i-1] &amp;&amp; (p[i-1]=='*'); for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) if(p[j-1]!='*') dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]=='?'); else dp[i][j] = dp[i-1][j] || dp[i][j-1]; return dp[m][n]; &#125;&#125;; æ›´æ–°è¿­ä»£å…¬å¼è§£é‡Šï¼š https://discuss.leetcode.com/topic/7266/c-dp-solution/2 Equation 1). means that if p[j-1] is not *, f(i,j) is determined by if s[0:i-2] matches p[0:j-2] and if (s[i-1]==p[j-1] or p[j-1]==â€™?â€™). Equation 2). means that if p[j-1] is , f(i,j) is true if either f(i,j-1) is true: s[0:i-1] matches p[0:j-2] and is not used here; or f(i-1,j) is true: s[0:i-2] matches p[0:j-1] and * is used to match s[i-1]. https://discuss.leetcode.com/topic/17901/accepted-c-dp-solution-with-a-trick Accepted C++ DP Solution with a Trick 1312ms, 28.41%, September 22, 2016 Updated: Since the OJ has relaxed the time constraint, the following DP solution is now accepted without the trick :-) Well, so many people has tried to solve this problem using DP. And almost all of them get TLE (if you see a C++ DP solution that gets accepted, please let me know ^_^). Well, this post aims at providing an accpted DP solution which uses a trick to get around the largest test case, insteaed of a solution that is fully correct. So please do not give me down votes for that :-) Letâ€™s briefly summarize the idea of DP. We define the state P[i][j] to be whether s[0..i) matches p[0..j). The state equations are as follows: 121. P[i][j] = P[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;?&apos;), if p[j - 1] != &apos;*&apos;;2. P[i][j] = P[i][j - 1] || P[i - 1][j], if p[j - 1] == &apos;*&apos;. If you feel confused with the second equation, you may refer to this link. There is an explanation in the comments. We optimize the DP code to O(m) space by recording P[i - 1][j - 1] using a single variable pre. The trick to avoid TLE is to hard-code the result for the largest test case by 1if (n &gt; 30000) return false; The complete code is as follows. 123456789101112131415161718192021class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(), n = p.length(); if (n &gt; 30000) return false; // the trick vector&lt;bool&gt; cur(m + 1, false); cur[0] = true; for (int j = 1; j &lt;= n; j++) &#123; bool pre = cur[0]; // use the value before update cur[0] = cur[0] &amp;&amp; p[j - 1] == &apos;*&apos;; for (int i = 1; i &lt;= m; i++) &#123; bool temp = cur[i]; // record the value before update if (p[j - 1] != &apos;*&apos;) cur[i] = pre &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;?&apos;); else cur[i] = cur[i - 1] || cur[i]; pre = temp; &#125; &#125; return cur[m]; &#125;&#125;; æ–¹æ³•ä¸‰: For those interested in a fully correct solution, this link has a nice Greedy solution. And I have rewritten the code below to fit the new C++ interface (changed from char* to string). 123456789101112131415161718192021222324class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(), n = p.length(); int i = 0, j = 0, asterisk = -1, match; while (i &lt; m) &#123; if (j &lt; n &amp;&amp; p[j] == &apos;*&apos;) &#123; match = i; asterisk = j++; &#125; else if (j &lt; n &amp;&amp; (s[i] == p[j] || p[j] == &apos;?&apos;)) &#123; i++; j++; &#125; else if (asterisk &gt;= 0) &#123; i = ++match; j = asterisk + 1; &#125; else return false; &#125; while (j &lt; n &amp;&amp; p[j] == &apos;*&apos;) j++; return j == n; &#125;&#125;; https://discuss.leetcode.com/topic/21577/my-three-c-solutions-iterative-16ms-dp-180ms-modified-recursion-88ms My three C++ solutions (iterative (16ms) &amp; DP (180ms) &amp; modified recursion (88ms)) The reason that the iterative solution is much faster for this case is we only need to save (and deal with) the positions (iStar for s, jStar for p) of the last â€œâ€ we met. We only need to do traceback using iStar and jStar and all the previous â€œâ€ can be ignored since the last â€œâ€ will cover all the traceback cases for the previous â€œâ€.What we need to do are if the current p character is â€˜â€™ (i.e. p[j]==â€™â€™), then we update iStar and jStar with the cureent i and j values. iStar/jStar will be used for traceback. Also we do â€“i to start the depth first search with the case that â€˜*â€™ represents a null string. if p[j]!=â€™â€™, then we check if mismatch occurs (i.e. p[j]!=s[i] and p[j]!=â€™?â€™), if so we check if we met a â€˜â€™ before (iStar&gt;=0), if not, then we return false since no match can achieve. Otherwise, we traceback to the positions at which the last â€˜*â€™ happens and do the next possible dfs search (i.e. i = iStar++; j = jStar; remember to update iStar too to save the i position to try in the next traceback). The loop will quit when we reach the end of s. At last, we need to skip all the â€˜*â€™ in p to see if we can reach the end of p. if so, match, otherwise mismatch 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool isMatch(string s, string p) &#123; int slen = s.size(), plen = p.size(), i, j, iStar=-1, jStar=-1; for(i=0,j=0 ; i&lt;slen; ++i, ++j) &#123; if(p[j]==&apos;*&apos;) &#123; //meet a new &apos;*&apos;, update traceback i/j info iStar = i; jStar = j; --i; &#125; else &#123; if(p[j]!=s[i] &amp;&amp; p[j]!=&apos;?&apos;) &#123; // mismatch happens if(iStar &gt;=0) &#123; // met a &apos;*&apos; before, then do traceback i = iStar++; j = jStar; &#125; else return false; // otherwise fail &#125; &#125; &#125; while(p[j]==&apos;*&apos;) ++j; return j==plen; &#125;&#125;; A DP solution is also given here. It has O(N^2) time complexity and O(N) space 12345678910111213141516171819class Solution &#123;public: bool isMatch(string s, string p) &#123; int pLen = p.size(), sLen = s.size(), i, j, k, cur, prev; if(!pLen) return sLen == 0; bool matched[2][sLen+1]; fill_n(&amp;matched[0][0], 2*(sLen+1), false); matched[0][0] = true; for(i=1; i&lt;=pLen; ++i) &#123; cur = i%2, prev= 1-cur; matched[cur][0]= matched[prev][0] &amp;&amp; p[i-1]==&apos;*&apos;; if(p[i-1]==&apos;*&apos;) for(j=1; j&lt;=sLen; ++j) matched[cur][j] = matched[cur][j-1] || matched[prev][j]; else for(j=1; j&lt;=sLen; ++j) matched[cur][j] = matched[prev][j-1] &amp;&amp; (p[i-1]==&apos;?&apos; || p[i-1]==s[j-1]) ; &#125; return matched[cur][sLen]; &#125;&#125;; A recursion version. A typical recursion version will give us TLE due to too many unnecessary recursive calls. As we explained, all the traceback recursive calls at the â€˜â€™ we met (except the last â€˜â€™) are unneccessary and should be avoided. In the below version, we use recLevel to track the recursion level (i.e the total â€˜â€™ we met) and we also use curLevel to save the order of â€˜â€™ we currently process. If it is not the last â€˜â€™ we met (i.e if(recLevel&gt;curLevel+1) ), then we will return false directly ( if(recLevel&gt;curLevel+1) return false;) to skip all unneccessary recursion call at the â€˜â€™ before the last â€˜*â€™. 12345678910111213141516171819202122232425262728class Solution &#123;private: bool helper(const string &amp;s, const string &amp;p, int si, int pi, int &amp;recLevel) &#123; int sSize = s.size(), pSize = p.size(), i, curLevel = recLevel; bool first=true; while(si&lt;sSize &amp;&amp; (p[pi]==s[si] || p[pi]==&apos;?&apos;)) &#123;++pi; ++si;&#125; //match as many as possible if(pi == pSize) return si == sSize; // if p reaches the end, return if(p[pi]==&apos;*&apos;) &#123; // if a star is met while(p[++pi]==&apos;*&apos;); //skip all the following stars if(pi&gt;=pSize) return true; // if the rest of p are all star, return true for(i=si; i&lt;sSize; ++i) &#123; // then do recursion if(p[pi]!= &apos;?&apos; &amp;&amp; p[pi]!=s[i]) continue; if(first) &#123;++recLevel; first = false;&#125; if(helper(s, p, i, pi, recLevel)) return true; if(recLevel&gt;curLevel+1) return false; // if the currently processed star is not the last one, return &#125; &#125; return false; &#125;public: bool isMatch(string s, string p) &#123; int recLevel = 0; return helper(s, p, 0, 0, recLevel); &#125;&#125;; https://discuss.leetcode.com/topic/7266/c-dp-solution C++ DP solution It seems that only Greedy solution can pass all test cases (sorry if I omit any DP solution that passes all test cases). My DP solution also fails to pass the s=aaaaaaaaaaaaaaâ€¦â€¦â€¦â€¦.. (lots of aâ€™sâ€¦). However, despite this very large case my DP solution passes all other cases. The idea is: f(i,j) == whether the first i chars of s match the first j chars of p. The transition equation is: 1231). if(p[j-1]!=&apos;*&apos;) f(i, j) = f(i-1, j-1) &amp;&amp; (s[i-1]==p[j-1] || p[j-1]==&apos;?&apos;)2). if(p[j-1]==&apos;*&apos;) f(i, j) = f(i, j-1) || f(i-1, j) 12345678910111213141516171819202122bool isMatch(const char *s, const char *p) &#123; const int m = strlen(s); const int n = strlen(p); if(m&gt;30000) return false; // to skip the large test case vector&lt;bool&gt; prev(n+1,false); // to save space, just O(n) space is used prev[0]=true; for(int j=1; j&lt;=n; j++) prev[j] = prev[j-1] &amp;&amp; p[j-1]==&apos;*&apos;; for(int i=1; i&lt;=m; i++) &#123; vector&lt;bool&gt; cur(n+1,false); for(int j=1; j&lt;=n; j++) &#123; if(p[j-1]==&apos;*&apos;) &#123; cur[j] = cur[j-1] || prev[j]; &#125; else &#123; cur[j] = prev[j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]==&apos;?&apos;); &#125; &#125; prev = cur; &#125; return prev[n];&#125; 12345678Equation 1). means that if p[j-1] is not *, f(i,j) is determinedby if s[0:i-2] matches p[0:j-2] and if (s[i-1]==p[j-1] orp[j-1]==&apos;?&apos;).Equation 2). means that if p[j-1] is *, f(i,j) is true if eitherf(i,j-1) is true: s[0:i-1] matches p[0:j-2] and * is not usedhere; or f(i-1,j) is true: s[0:i-2] matches p[0:j-1] and * isused to match s[i-1]. my code: 1234567891011121314class Solution &#123;public: bool isMatch(string s, string p) &#123; int m=0, n=0, match=0, startIdx=-1; while(m&lt;s.size())&#123; if(n&lt;p.size() &amp;&amp; (p[n]==&apos;?&apos; || p[n]==s[m]))&#123;m++; n++;&#125; else if(n&lt;p.size() &amp;&amp; p[n]==&apos;*&apos;)&#123;startIdx=n; match=m; n++;&#125; else if(startIdx!=-1)&#123;n=startIdx+1; match++; m=match;&#125; else return false; &#125; while(n&lt;p.size() &amp;&amp; p[n]==&apos;*&apos;) n++; return n==p.size(); &#125;&#125;; python https://discuss.leetcode.com/topic/9350/python-dp-solution Python DP solution 12345678910111213141516class Solution:# @return a booleandef isMatch(self, s, p): length = len(s) if len(p) - p.count(&apos;*&apos;) &gt; length: return False dp = [True] + [False]*length for i in p: if i != &apos;*&apos;: for n in reversed(range(length)): dp[n+1] = dp[n] and (i == s[n] or i == &apos;?&apos;) else: for n in range(1, length+1): dp[n] = dp[n-1] or dp[n] dp[0] = dp[0] and i == &apos;*&apos; return dp[-1] dp[n] means the substring s[:n] if match the pattern i dp[0] means the empty string â€˜â€™ or s[:0] which only match the pattern â€˜*â€™ use the reversed builtin because for every dp[n+1] we use the previous â€˜dpâ€™ add Java O(m*n) version code 1234567891011121314151617181920212223public boolean isMatch(String s, String p) &#123; int count = 0; for (char c : p.toCharArray()) &#123; if (c == &apos;*&apos;) count++; &#125; if (p.length() - count &gt; s.length()) return false; boolean[][] dp = new boolean[p.length() + 1][s.length() + 1]; dp[0][0] = true; for (int j = 1; j &lt;= p.length(); j++) &#123; char pattern = p.charAt(j - 1); dp[j][0] = dp[j - 1][0] &amp;&amp; pattern == &apos;*&apos;; for (int i = 1; i &lt;= s.length(); i++) &#123; char letter = s.charAt(i - 1); if (pattern != &apos;*&apos;) &#123; dp[j][i] = dp[j - 1][i - 1] &amp;&amp; (pattern == &apos;?&apos; || pattern == letter); &#125; else dp[j][i] = dp[j][i - 1] || dp[j - 1][i]; &#125; &#125; return dp[p.length()][s.length()];&#125; java http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html 123456789101112131415161718192021Analysis:For each element in sIf *s==*p or *p == ? which means this is a match, then goes to next element s++ p++.If p=='*', this is also a match, but one or many chars may be available, so let us save this *'s position and the matched s position.If not match, then we check if there is a * previously showed up, if there is no *, return false; if there is an *, we set current p to the next element of *, and set current s to the next saved s position.e.g.abed?b*d**a=?, go on, b=b, go on,e=*, save * position star=3, save s position ss = 3, p++e!=d, check if there was a *, yes, ss++, s=ss; p=star+1d=d, go on, meet the end.check the rest element in p, if all are *, true, else false;Note that in char array, the last is NOT NULL, to check the end, use "*p" or "*p=='\0'". https://discuss.leetcode.com/topic/3040/linear-runtime-and-constant-space-solution 60ms, 60.11%, September 22, 2016 1234567891011121314151617181920212223242526public class Solution &#123; public boolean isMatch(String str, String pattern) &#123; int s=0, p=0, match=0, starIdx=-1; while(s&lt;str.length())&#123; if(p&lt;pattern.length() &amp;&amp; (pattern.charAt(p)==&apos;?&apos; || str.charAt(s)==pattern.charAt(p)))&#123; s++; p++; &#125; else if(p&lt;pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;)&#123; starIdx = p; match = s; p++; &#125; else if(starIdx!=-1)&#123; p = starIdx + 1; match++; s = match; &#125; else return false; &#125; while(p&lt;pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;) p++; return p == pattern.length(); &#125;&#125; https://discuss.leetcode.com/topic/3040/linear-runtime-and-constant-space-solution Linear runtime and constant space solution I found this solution from http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html The basic idea is to have one pointer for the string and one pointer for the pattern. This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step. Here is Yuâ€™s elegant solution in C++ 12345678910111213141516171819202122232425bool isMatch(const char *s, const char *p) &#123; const char* star=NULL; const char* ss=s; while (*s)&#123; //advancing both pointers when (both characters match) or (&apos;?&apos; found in pattern) //note that *p will not advance beyond its length if ((*p==&apos;?&apos;)||(*p==*s))&#123;s++;p++;continue;&#125; // * found in pattern, track index of *, only advancing pattern pointer if (*p==&apos;*&apos;)&#123;star=p++; ss=s;continue;&#125; //current characters didn&apos;t match, last pattern pointer was *, current pattern pointer is not * //only advancing pattern pointer if (star)&#123; p = star+1; s=++ss;continue;&#125; //current pattern pointer is not star, last patter pointer was not * //characters do not match return false; &#125; //check for remaining characters in pattern while (*p==&apos;*&apos;)&#123;p++;&#125; return !*p; &#125; Here is my re-write in Java 12345678910111213141516171819202122232425262728293031boolean comparison(String str, String pattern) &#123; int s = 0, p = 0, match = 0, starIdx = -1; while (s &lt; str.length())&#123; // advancing both pointers if (p &lt; pattern.length() &amp;&amp; (pattern.charAt(p) == &apos;?&apos; || str.charAt(s) == pattern.charAt(p)))&#123; s++; p++; &#125; // * found, only advancing pattern pointer else if (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;)&#123; starIdx = p; match = s; p++; &#125; // last pattern pointer was *, advancing string pointer else if (starIdx != -1)&#123; p = starIdx + 1; match++; s = match; &#125; //current pattern pointer is not star, last patter pointer was not * //characters do not match else return false; &#125; //check for remaining characters in pattern while (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;) p++; return p == pattern.length();&#125; my codeï¼š 12345678910111213public class Solution &#123; public boolean isMatch(String s, String p) &#123; int m=0, n=0, match=0, startIdx=-1; while(m&lt;s.length())&#123; if(n&lt;p.length() &amp;&amp; (s.charAt(m)==p.charAt(n) || p.charAt(n)==&apos;?&apos;))&#123;m++; n++;&#125; else if(n&lt;p.length() &amp;&amp; p.charAt(n)==&apos;*&apos;)&#123;startIdx=n; match=m; n++;&#125; else if(startIdx!=-1)&#123;match++; m=match; n=startIdx+1;&#125; else return false; &#125; while(n&lt;p.length() &amp;&amp; p.charAt(n)==&apos;*&apos;)&#123;n++;&#125; return n==p.length(); &#125;&#125; https://discuss.leetcode.com/topic/22516/my-java-dp-solution-using-2d-table My java DP solution using 2D table 1234567891011121314151617181920212223public class Solution &#123; public boolean isMatch(String s, String p) &#123; boolean[][] match=new boolean[s.length()+1][p.length()+1]; match[s.length()][p.length()]=true; for(int i=p.length()-1;i&gt;=0;i--)&#123; if(p.charAt(i)!=&apos;*&apos;) break; else match[s.length()][i]=true; &#125; for(int i=s.length()-1;i&gt;=0;i--)&#123; for(int j=p.length()-1;j&gt;=0;j--)&#123; if(s.charAt(i)==p.charAt(j)||p.charAt(j)==&apos;?&apos;) match[i][j]=match[i+1][j+1]; else if(p.charAt(j)==&apos;*&apos;) match[i][j]=match[i+1][j]||match[i][j+1]; else match[i][j]=false; &#125; &#125; return match[0][0]; &#125;&#125; https://discuss.leetcode.com/topic/10794/my-java-dp-solution My Java DP Solution At first I cannot pass the the long â€˜aaaâ€¦â€™ test case. Then I add more check and pass it. 123456789101112131415161718192021222324252627282930public class Solution &#123; public boolean isMatch(String s, String p) &#123; int m = s.length(), n = p.length(); int count = 0; for (int i = 0; i &lt; n; i++) &#123; if (p.charAt(i) == &apos;*&apos;) count++; &#125; if (count==0 &amp;&amp; m != n) return false; else if (n - count &gt; m) return false; boolean[] match = new boolean[m+1]; match[0] = true; for (int i = 0; i &lt; m; i++) &#123; match[i+1] = false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (p.charAt(i) == &apos;*&apos;) &#123; for (int j = 0; j &lt; m; j++) &#123; match[j+1] = match[j] || match[j+1]; &#125; &#125; else &#123; for (int j = m-1; j &gt;= 0; j--) &#123; match[j+1] = (p.charAt(i) == &apos;?&apos; || p.charAt(i) == s.charAt(j)) &amp;&amp; match[j]; &#125; match[0] = false; &#125; &#125; return match[m]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[043. Multiply Strings]]></title>
    <url>%2Fp%2Fd81212f5%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/multiply-strings/ Given two numbers represented as strings, return multiplication of the numbers as a string. Note: The numbers can be arbitrarily large and are non-negative. Converting the input string to integer is NOT allowed. You should NOT use internal library such as BigInteger. cpp 6ms, September 19, 2016 https://discuss.leetcode.com/topic/9449/brief-c-solution-using-only-strings-and-without-reversal Brief C++ solution using only strings and without reversal This is the standard manual multiplication algorithm. We use two nested for loops, working backward from the end of each input number. We pre-allocate our result and accumulate our partial result in there. One special case to note is when our carry requires us to write to our sum string outside of our for loop. At the end, we trim any leading zeros, or return 0 if we computed nothing but zeros. 123456789101112131415161718192021class Solution &#123;public: string multiply(string num1, string num2) &#123; string sum(num1.size() + num2.size(), &apos;0&apos;); for(int i = num1.size()-1; i &gt;= 0; --i)&#123; int carry = 0; for(int j = num2.size() - 1; j&gt;=0; --j)&#123; int tmp = (sum[i+j+1] -&apos;0&apos;) + (num1[i] - &apos;0&apos;)*(num2[j] - &apos;0&apos;) + carry; sum[i+j+1] = tmp%10 + &apos;0&apos;; carry = tmp/10; &#125; sum[i] += carry; &#125; size_t startpos = sum.find_first_not_of(&quot;0&quot;); if(string::npos!=startpos) return sum.substr(startpos); return &quot;0&quot;; &#125;&#125;; https://discuss.leetcode.com/topic/3456/one-easy-solution-with-c One Easy solution with C++ The key part is to use a vector to store all digits REVERSELY. after the calculation, find the rightmost NON-Zero digits and convert it to a string. 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: string multiply(string num1, string num2) &#123; unsigned int l1=num1.size(),l2=num2.size(); if (l1==0||l2==0) return &quot;0&quot;; vector&lt;int&gt; v(l1+l2,0); for (unsigned int i=0;i&lt;l1;i++)&#123; int carry=0; int n1=(int)(num1[l1-i-1]-&apos;0&apos;);//Calculate from rightmost to left for (unsigned int j=0;j&lt;l2;j++)&#123; int n2=(num2[l2-j-1]-&apos;0&apos;);//Calculate from rightmost to left int sum=n1*n2+v[i+j]+carry; carry=sum/10; v[i+j]=sum%10; &#125; if (carry&gt;0) v[i+l2]+=carry; &#125; int start=l1+l2-1; while(v[start]==0) start--; if (start==-1) return &quot;0&quot;; string s=&quot;&quot;; for (int i=start;i&gt;=0;i--) s+=(char)(v[i]+&apos;0&apos;); return s; &#125;&#125;; https://discuss.leetcode.com/topic/8500/very-concise-16-ms-c-solution Very concise 16 ms c++ solution See comments inline for explanation. 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string multiply(string num1, string num2) &#123; int i, j; int m = num1.size(), n = num2.size(); // max (m + n) digits vector&lt;int&gt; product(m + n, 0); string result; // reverse for ease of calc reverse(num1.begin(), num1.end()); reverse(num2.begin(), num2.end()); // digit i * digit j contributes to digit i + j for (i = 0; i &lt; m; i++) &#123; for (j = 0; j &lt; n; j++) &#123; product[i + j] += (num1[i] - &apos;0&apos;) * (num2[j] - &apos;0&apos;); product[i + j + 1] += product[i + j] / 10; product[i + j] %= 10; &#125; &#125; // remove leading 0; keep last 0 if all 0 for (i = m + n - 1; i &gt; 0 &amp;&amp; 0 == product[i]; i--) ; for (; i &gt;= 0; i--) result += to_string(product[i]); return result; &#125;&#125;; python 59ms, September 19, 2016 My solution 12345678class Solution(object): def multiply(self, num1, num2): &quot;&quot;&quot; :type num1: str :type num2: str :rtype: str &quot;&quot;&quot; return str(int(num1)*int(num2)) https://discuss.leetcode.com/topic/20883/simple-python-solution-18-lines Simple Python solution, 18 lines123456789101112131415161718def multiply(num1, num2): product = [0] * (len(num1) + len(num2)) pos = len(product)-1 for n1 in reversed(num1): tempPos = pos for n2 in reversed(num2): product[tempPos] += int(n1) * int(n2) product[tempPos-1] += product[tempPos]/10 product[tempPos] %= 10 tempPos -= 1 pos -= 1 pt = 0 while pt &lt; len(product)-1 and product[pt] == 0: pt += 1 return &apos;&apos;.join(map(str, product[pt:])) java 31ms, September 19, 2016 https://discuss.leetcode.com/topic/30508/easiest-java-solution-with-graph-explanation Easiest JAVA Solution with Graph Explanation Remember how we do multiplication? Start from right to left, perform multiplication on every pair of digits, and add them together. Letâ€™s draw the process! From the following draft, we can immediately conclude: 1`num1[i] * num2[j]` will be placed at indices `[i + j`, `i + j + 1]` Here is my solution. Hope it helps! 123456789101112131415161718192021public class Solution &#123; public String multiply(String num1, String num2) &#123; int m = num1.length(), n = num2.length(); int[] pos = new int[m+n]; for(int i = m-1; i &gt;= 0; i--)&#123; for(int j = n-1; j&gt;=0; j--)&#123; int mul = (num1.charAt(i)-&apos;0&apos;) * (num2.charAt(j) -&apos;0&apos;); int p1 = i+j, p2 = i+j+1; int sum = mul + pos[p2]; pos[p1] += sum/10; pos[p2] = sum % 10; &#125; &#125; StringBuilder sb = new StringBuilder(); for(int p:pos) if(!(sb.length()==0 &amp;&amp; p==0)) sb.append(p); return sb.length() == 0?&quot;0&quot;:sb.toString(); &#125;&#125; https://discuss.leetcode.com/topic/13026/ac-solution-in-java-with-explanation AC solution in Java with explanation 1234567891011121314151617181920212223public class Solution &#123; public String multiply(String num1, String num2) &#123; int n1 = num1.length(), n2 = num2.length(); int[] products = new int[n1 + n2]; for (int i = n1 - 1; i &gt;= 0; i--) &#123; for (int j = n2 - 1; j &gt;= 0; j--) &#123; int d1 = num1.charAt(i) - &apos;0&apos;; int d2 = num2.charAt(j) - &apos;0&apos;; products[i + j + 1] += d1 * d2; &#125; &#125; int carry = 0; for (int i = products.length - 1; i &gt;= 0; i--) &#123; int tmp = (products[i] + carry) % 10; carry = (products[i] + carry) / 10; products[i] = tmp; &#125; StringBuilder sb = new StringBuilder(); for (int num : products) sb.append(num); while (sb.length() != 0 &amp;&amp; sb.charAt(0) == &apos;0&apos;) sb.deleteCharAt(0); return sb.length() == 0 ? &quot;0&quot; : sb.toString(); &#125;&#125; If we break it into steps, it will have the following steps. 1. compute products from each pair of digits from num1 and num2. 2. carry each element over. 3. output the solution. Things to note: The product of two numbers cannot exceed the sum of the two lengths. (e.g. 99 * 99 cannot be five digit) 123int d1 = num1.charAt(i) - &apos;0&apos;;int d2 = num2.charAt(j) - &apos;0&apos;;products[i + j + 1] += d1 * d2; https://discuss.leetcode.com/topic/10757/clear-java-solution-without-reversal Clear JAVA solution without reversal 123456789101112131415161718192021public String multiply(String num1, String num2) &#123; int len1 = num1.length(); int len2 = num2.length(); int[] product = new int[len1 + len2]; for (int i = len1 - 1; i &gt;= 0; i--) &#123; for (int j = len2 - 1; j &gt;= 0; j--) &#123; int index = len1 + len2 - i - j - 2; product[index] += (num1.charAt(i) - &apos;0&apos;) * (num2.charAt(j) - &apos;0&apos;); product[index + 1] += product[index] / 10; product[index] %= 10; &#125; &#125; StringBuilder stringBuilder = new StringBuilder(); for (int i = product.length - 1; i &gt; 0; i--) &#123; if (stringBuilder.length() == 0 &amp;&amp; product[i] == 0) continue; stringBuilder.append(product[i]); &#125; stringBuilder.append(product[0]); return stringBuilder.toString();&#125; https://discuss.leetcode.com/topic/21008/simple-clear-java-solution Simple &amp;&amp; clear java solution 12345678910111213141516171819202122232425public class Solution &#123; public String multiply(String num1, String num2) &#123; int len1 = num1.length(); int len2 = num2.length(); int len = len1 + len2; int[] mul = new int[len]; for (int i = len1 - 1; i &gt;= 0; i--) &#123; int a = num1.charAt(i) - &apos;0&apos;; int k = len2 + i; for (int j = len2 - 1; j &gt;= 0; j--) &#123; int b = num2.charAt(j) - &apos;0&apos;; int c = mul[k] + a * b; mul[k] = c % 10; mul[k - 1] = mul[k - 1] + c /10; k--; &#125; &#125; int i = 0; while(mul[i] == 0 &amp;&amp; i &lt; len - 1) i++; StringBuilder sb = new StringBuilder(); for (; i &lt; len; i++) sb.append(mul[i]); return sb.length() == 0 ? &quot;0&quot; : sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[042. Trapping Rain Water]]></title>
    <url>%2Fp%2F33f3f22a%2F</url>
    <content type="text"><![CDATA[36.7% https://leetcode.com/problems/trapping-rain-water/ Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. 12For example, Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! æ–¹æ³•ä¸€ï¼š https://discuss.leetcode.com/topic/5125/sharing-my-simple-c-code-o-n-time-o-1-space Sharing my simple c++ code: O(n) time, O(1) space Here is my idea: instead of calculating area by height*width, we can think it in a cumulative way. In other words, sum water amount of each bin(width=1). Search from left to right and maintain a max height of left and right separately, which is like a one-side wall of partial container. Fix the higher one and flow water from the lower part. For example, if current height of left is lower, we fill water in the left bin. Until left meets right, we filled the whole container. 123456789101112131415161718192021class Solution &#123;public: int trap(int A[], int n) &#123; int left=0; int right=n-1; int res=0; int maxleft=0, maxright=0; while(left&lt;=right)&#123; if(A[left]&lt;=A[right])&#123; if(A[left]&gt;=maxleft) maxleft=A[left]; else res+=maxleft-A[left]; left++; &#125; else&#123; if(A[right]&gt;=maxright) maxright= A[right]; else res+=maxright-A[right]; right--; &#125; &#125; return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if(n&lt;=1) return 0; int left=0, right=n-1; int maxleft = 0, maxright=0; int res = 0; while(left&lt;right)&#123; if(height[left]&lt;=height[right])&#123; if(height[left]&gt;maxleft) maxleft = height[left]; else res += maxleft - height[left]; left++; &#125;else&#123; if(height[right] &gt; maxright) maxright = height[right]; else res += maxright - height[right]; right--; &#125; &#125; return res; &#125;&#125;; æ–¹æ³•äºŒï¼š ä¸‰æ¬¡éåŽ†ã€‚ ç¬¬ä¸€æ¬¡éåŽ†ï¼ŒæŸ¥çœ‹å½“å‰ä½ç½®içš„ä»Žå·¦ä¾§çœ‹ï¼Œå·¦ä¾§çš„æŒ¡æ¿çš„æœ€å¤§å€¼ã€‚ç¬¬äºŒæ¬¡ä»Žå³è¾¹å‘å·¦éåŽ†ã€‚ ç¬¬ä¸‰å¤©éåŽ†ï¼Œè®¡ç®—å½“å‰ä½ç½®æœ‰çš„æ°´ã€‚ https://discuss.leetcode.com/topic/4136/a-different-o-n-approach-easy-to-understand-and-simple-code A different O(n) approach - easy to understand and simple code 123456789101112131415class Solution &#123;public: int trap(int a[], int n) &#123; int i, res = 0; if(!n) return res; vector&lt;int&gt; ltr(n, 0), rtl(n, 0); for(i = 1, ltr[0] = a[0]; i &lt; n; i++) ltr[i] = max(ltr[i-1], a[i]); for(i = n - 2, rtl[n-1] = a[n-1]; i &gt;= 0; i--) rtl[i] = max(rtl[i+1], a[i]); for(i = 0; i &lt; n; i++) res += min(ltr[i], rtl[i]) - a[i]; return res; &#125;&#125;; observation: scan A both from left to right and right to left, record the largest seen during the scan; then for each position the water level should be the min of the 2 large value. æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if(n&lt;=1) return 0; vector&lt;int&gt; ltr(n, 0); vector&lt;int&gt; rtr(n, 0); int res = 0; ltr[0] = height[0]; for(int i=1; i&lt;n; i++) ltr[i] = max(ltr[i-1], height[i]); rtr[n-1] = height[n-1]; for(int j=n-2; j&gt;=0; j--) rtr[j] = max(rtr[j+1], height[j]); for(int k=0; k&lt;n; k++) res += min(ltr[k], rtr[k]) - height[k]; return res; &#125;&#125;; å®˜æ–¹è§£ç­” https://leetcode.com/articles/trapping-rain-water/#approach-3-using-stacks-accepted https://discuss.leetcode.com/topic/18731/7-lines-c-c 7 lines C / C++ Keep track of the already safe level and the total water so far. In each step, process and discard the lower one of the leftmost or rightmost elevation. C Changing the given parameters to discard the lower border. Iâ€™m quite fond of this one. 123456789int trap(int* height, int n) &#123; int level = 0, water = 0; while (n--) &#123; int lower = *height &lt; height[n] ? *height++ : height[n]; if (lower &gt; level) level = lower; water += level - lower; &#125; return water;&#125; Slight variation with two pointers (left and right). 123456789int trap(int* height, int n) &#123; int *L = height, *R = L+n-1, level = 0, water = 0; while (L &lt; R) &#123; int lower = *L &lt; *R ? *L++ : *R--; if (lower &gt; level) level = lower; water += level - lower; &#125; return water;&#125; C++ With left and right index. 123456789int trap(vector&lt;int&gt;&amp; height) &#123; int l = 0, r = height.size()-1, level = 0, water = 0; while (l &lt; r) &#123; int lower = height[height[l] &lt; height[r] ? l++ : r--]; level = max(level, lower); water += level - lower; &#125; return water;&#125; With left and right iterator. 12345678910int trap(vector&lt;int&gt;&amp; height) &#123; auto l = height.begin(), r = height.end() - 1; int level = 0, water = 0; while (l != r + 1) &#123; int lower = *l &lt; *r ? *l++ : *r--; level = max(level, lower); water += level - lower; &#125; return water;&#125; python https://discuss.leetcode.com/topic/18720/8-lines-c-c-java-python-solution 8-lines C/C++/Java/Python Solution Note: The following idea is in fact from the last answer in this link, which leads to a clean code. I just reorganize it and add some explanations. I hope it is Ok. The following are four solutions in C/C++/Java/Python respectively. The basic idea is that we set two pointers l and r to the left and right end of height. Then we get the minimum height (minHeight) of these pointers (similar to Container with Most Water due to the Leaking Bucket Effect) since the level of the water cannot be higher than it. Then we move the two pointers towards the center. If the coming level is less than minHeight, then it will hold some water. Fill the water until we meet some â€œbarrierâ€ (with height larger than minHeight) and update l and r to repeat this process in a new interval. C 1234567891011int trap(int* height, int heightSize) &#123; int l = 0, r = heightSize - 1, water = 0, minHeight = 0; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; height[l] &lt;= minHeight) water += minHeight - height[l++]; while (r &gt; l &amp;&amp; height[r] &lt;= minHeight) water += minHeight - height[r--]; minHeight = height[l] &lt;= height[r] ? height[l] : height[r]; &#125; return water;&#125; C++ 1234567891011121314class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(), l = 0, r = n - 1, water = 0, minHeight = 0; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; height[l] &lt;= minHeight) water += minHeight - height[l++]; while (r &gt; l &amp;&amp; height[r] &lt;= minHeight) water += minHeight - height[r--]; minHeight = min(height[l], height[r]); &#125; return water; &#125;&#125;; Java 12345678910111213public class Solution &#123; public int trap(int[] height) &#123; int n = height.length, l = 0, r = n - 1, water = 0, minHeight = 0; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; height[l] &lt;= minHeight) water += minHeight - height[l++]; while (r &gt; l &amp;&amp; height[r] &lt;= minHeight) water += minHeight - height[r--]; minHeight = Math.min(height[l], height[r]); &#125; return water; &#125;&#125; Python 123456789101112131415class Solution: # @param &#123;integer[]&#125; height # @return &#123;integer&#125; def trap(self, height): n = len(height) l, r, water, minHeight = 0, n - 1, 0, 0 while l &lt; r: while l &lt; r and height[l] &lt;= minHeight: water += minHeight - height[l] l += 1 while r &gt; l and height[r] &lt;= minHeight: water += minHeight - height[r] r -= 1 minHeight = min(height[l], height[r]) return water java https://discuss.leetcode.com/topic/3016/share-my-short-solution Share my short solution. Keep track of the maximum height from both forward directions backward directions, call them leftmax and rightmax. 1234567891011121314151617181920public int trap(int[] A)&#123; int a=0; int b=A.length-1; int max=0; int leftmax=0; int rightmax=0; while(a&lt;=b)&#123; leftmax=Math.max(leftmax,A[a]); rightmax=Math.max(rightmax,A[b]); if(leftmax&lt;rightmax)&#123; max+=(leftmax-A[a]); // leftmax is smaller than rightmax, so the (leftmax-A[a]) water can be stored a++; &#125; else&#123; max+=(rightmax-A[b]); b--; &#125; &#125; return max;&#125; 2ms, 20.31%, June.18th, 2016 https://leetcode.com/discuss/18022/sharing-my-java-code-o-n-time-o-1-space 12345678910111213141516171819202122public class Solution &#123; public int trap(int[] height) &#123; if(height.length &lt; 3) return 0; int ans = 0; int l = 0, r = height.length - 1; while(l &lt; r &amp;&amp; height[l] &lt; height[l+1]) l++; while(l &lt; r &amp;&amp; height[r] &lt; height[r-1]) r--; while(l &lt; r)&#123; int left = height[l]; int right = height[r]; if(left &lt;= right)&#123; while(l &lt; r &amp;&amp; left &gt; height[++l]) ans += left - height[l]; &#125;else&#123; while(l &lt; r &amp;&amp; right &gt; height[--r]) ans += right - height[r]; &#125; &#125; return ans; &#125;&#125; https://discuss.leetcode.com/topic/4939/a-stack-based-solution-for-reference-inspired-by-histogram A stack based solution for reference, inspired by Histogram Indeed this question can be solved in one pass and O(1) space, but itâ€™s probably hard to come up with in a short interview. If you have read the stack O(n) solution for Largest Rectangle in Histogram, you will find this solution is very very similar. The main idea is : if we want to find out how much water on a bar(bot), we need to find out the left larger barâ€™s index (il), and right larger barâ€™s index(ir), so that the water is (min(A[il],A[ir])-A[bot])*(ir-il-1), use min since only the lower boundary can hold water, and we also need to handle the edge case that there is no il. To implement this we use a stack that store the indices with decreasing bar height, once we find a bar whoâ€™s height is larger, then let the top of the stack be bot, the cur bar is ir, and the previous bar is il. 1234567891011121314151617public int trap(int[] A) &#123; if (A==null) return 0; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int i = 0, maxWater = 0, maxBotWater = 0; while (i &lt; A.length)&#123; if (s.isEmpty() || A[i]&lt;=A[s.peek()])&#123; s.push(i++); &#125; else &#123; int bot = s.pop(); maxBotWater = s.isEmpty()? // empty means no il 0:(Math.min(A[s.peek()],A[i])-A[bot])*(i-s.peek()-1); maxWater += maxBotWater; &#125; &#125; return maxWater; &#125; https://discuss.leetcode.com/topic/5819/sharing-my-java-code-o-n-time-o-1-space Sharing my Java code: O(n) time, O(1) space 123456789101112131415161718192021222324252627public int trap(int[] A) &#123; if (A.length &lt; 3) return 0; int ans = 0; int l = 0, r = A.length - 1; // find the left and right edge which can hold water while (l &lt; r &amp;&amp; A[l] &lt;= A[l + 1]) l++; while (l &lt; r &amp;&amp; A[r] &lt;= A[r - 1]) r--; while (l &lt; r) &#123; int left = A[l]; int right = A[r]; if (left &lt;= right) &#123; // add volum until an edge larger than the left edge while (l &lt; r &amp;&amp; left &gt;= A[++l]) &#123; ans += left - A[l]; &#125; &#125; else &#123; // add volum until an edge larger than the right volum while (l &lt; r &amp;&amp; A[--r] &lt;= right) &#123; ans += right - A[r]; &#125; &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/7612/java-10-lines-accepted-code-o-n-time-o-1-space-is-there-a-better-solution JAVA 10 lines accepted code, O(n) time, O(1) space. Is there a better solution? Basically this solution runs two pointers from two sides to the middle, and the plank is used to record the height of the elevation within a certain range, plank height can only increase (or remain the same) from two sides to the middle. If the current pointer is pointing at a number that is less than the current plank height, the difference between plank height and the number would be the amount of water trapped. Otherwise, A[i] == plank, no water is trapped. 12345678910public class Solution &#123; public int trap(int[] A) &#123; int i = 0, j = A.length - 1, result = 0, plank = 0; while(i &lt;= j)&#123; plank = plank &lt; Math.min(A[i], A[j]) ? Math.min(A[i], A[j]) : plank; result = A[i] &gt;= A[j] ? result + (plank - A[j--]) : result + (plank - A[i++]); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
        <tag>hard</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[041. First Missing Positive]]></title>
    <url>%2Fp%2F257d685e%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/first-missing-positive/ Given an unsorted integer array, find the first missing positive integer. 123For example,Given [1,2,0] return 3,and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. é¢˜æ„éœ€è¦ç†è§£ ç­”æ¡ˆéœ€è¦æ€è€ƒ cpp https://discuss.leetcode.com/topic/8293/my-short-c-solution-o-1-space-and-o-n-time My short c++ solution, O(1) space, and O(n) time Put each number in its right place. For example: When we find 5, then swap it with A[4]. At last, the first place where its number is not right, return the place + 1. 12345678910111213141516class Solution&#123;public: int firstMissingPositive(int A[], int n) &#123; for(int i = 0; i &lt; n; ++ i) while(A[i] &gt; 0 &amp;&amp; A[i] &lt;= n &amp;&amp; A[A[i] - 1] != A[i]) swap(A[i], A[A[i] - 1]); for(int i = 0; i &lt; n; ++ i) if(A[i] != i + 1) return i + 1; return n + 1; &#125;&#125;; https://discuss.leetcode.com/topic/17035/my-c-solution-4-ms My c++ solution (4 ms) 12345678910111213141516class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; for(int i=0; i&lt;nums.size(); i++)&#123; if(i+1==nums[i]) continue; int x = nums[i]; while(x&gt;=1 &amp;&amp; x&lt;=nums.size() &amp;&amp; x!=nums[x-1])&#123; swap(x, nums[x-1]); &#125; &#125; for(int i=0; i&lt;nums.size(); i++)&#123; if(i+1!=nums[i]) return i+1; &#125; return nums.size()+1; &#125;&#125;; Since we can not use extra space, so thinking about using the nums vector itself to record a positive number occurred. https://discuss.leetcode.com/topic/3384/o-n-time-o-1-space-c O(n) time, O(1) space C++ Idea is to swap each positive integer you encounter to its â€œrightfulâ€ place at index (x-1) where x is the integer. Itâ€™s O(n) because you visit each integer in at most 2 unique loop iterations. 1234567891011121314151617181920class Solution &#123;public: int firstMissingPositive(int A[], int n) &#123; int i,j; for(i=0;i&lt;n;i++)&#123; int cur=A[i]; // if in place or non-pos or out of bounds, skip. if(cur==i+1||cur&lt;=0||cur&gt;n)continue; swap(A[i],A[cur-1]); // if not the same, then reprocess it. if(A[i]!=A[cur-1]) i--; &#125; for(i=0;i&lt;n;i++) if(A[i]!=i+1) return i+1; return n+1; &#125;&#125;; python https://discuss.leetcode.com/topic/1361/a-very-nice-solution-from-ants-aasma-stackoverflow A very nice solution (from Ants Aasma @stackoverflow) time complexity is O(N) and space complexity is O(1). Link: http://stackoverflow.com/questions/1586858/find-the-smallest-integer-not-in-a-list Posted by Ants Aasma on Oct 20 â€˜09. The code is pasted here: 12345678910111213#Pass 1, move every value to the position of its valuefor cursor in range(N): target = array[cursor] while target &lt; N and target != array[target]: new_target = array[target] array[target] = target target = new_target#Pass 2, find first location where the index doesn&apos;t match the valuefor cursor in range(N): if array[cursor] != cursor: return cursorreturn N java https://discuss.leetcode.com/topic/2633/share-my-o-n-time-o-1-space-solution Share my O(n) time, O(1) space solution Share my O(n)/O(1) solution The basic idea is for any k positive numbers (duplicates allowed), the first missing positive number must be within [1,k+1]. The reason is like you put k balls into k+1 bins, there must be a bin empty, the empty bin can be viewed as the missing number. Unfortunately, there are 0 and negative numbers in the array, so firstly I think of using partition technique (used in quick sort) to put all positive numbers together in one side. This can be finished in O(n) time, O(1) space. After partition step, you get all the positive numbers lying within A[0,k-1]. Now, According to the basic idea, I infer the first missing number must be within [1,k+1]. I decide to use A[i] (0&lt;=i&lt;=k-1) to indicate whether the number (i+1) exists. But here I still have to main the original information A[i] holds. Fortunately, A[i] are all positive numbers, so I can set them to negative to indicate the existence of (i+1) and I can still use abs(A[i]) to get the original information A[i] holds. After step 2, I can again scan all elements between A[0,k-1] to find the first positive element A[i], that means (i+1) doesnâ€™t exist, which is what I want. 12345678910111213141516171819202122232425262728293031323334353637383940public int firstMissingPositive(int[] A) &#123; int n=A.length; if(n==0) return 1; int k=partition(A)+1; int temp=0; int first_missing_Index=k; for(int i=0;i&lt;k;i++)&#123; temp=Math.abs(A[i]); if(temp&lt;=k) A[temp-1]=(A[temp-1]&lt;0)?A[temp-1]:-A[temp-1]; &#125; for(int i=0;i&lt;k;i++)&#123; if(A[i]&gt;0)&#123; first_missing_Index=i; break; &#125; &#125; return first_missing_Index+1;&#125;public int partition(int[] A)&#123; int n=A.length; int q=-1; for(int i=0;i&lt;n;i++)&#123; if(A[i]&gt;0)&#123; q++; swap(A,q,i); &#125; &#125; return q;&#125;public void swap(int[] A, int i, int j)&#123; if(i!=j)&#123; A[i]^=A[j]; A[j]^=A[i]; A[i]^=A[j]; &#125;&#125; https://discuss.leetcode.com/topic/10351/o-1-space-java-solution O(1) space Java Solution The key here is to use swapping to keep constant space and also make use of the length of the array, which means there can be at most n positive integers. So each time we encounter an valid integer, find its correct position and swap. Otherwise we continue. 12345678910111213141516171819public class Solution &#123; public int firstMissingPositive(int[] A) &#123; int i = 0; while(i &lt; A.length)&#123; if(A[i] == i+1 || A[i] &lt;= 0 || A[i] &gt; A.length) i++; else if(A[A[i]-1] != A[i]) swap(A, i, A[i]-1); else i++; &#125; i = 0; while(i &lt; A.length &amp;&amp; A[i] == i+1) i++; return i+1; &#125; private void swap(int[] A, int i, int j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125;&#125; https://discuss.leetcode.com/topic/25441/beat-100-fast-elegant-java-index-based-solution-with-explanation Beat 100% Fast Elegant Java Index-Based Solution with Explanation The basic idea is to traversal and try to move the current value to position whose index is exactly the value (swap them). Then travelsal again to find the first unusal value, which can not be corresponding to its index. 12345678910111213141516171819202122232425262728293031public int firstMissingPositive(int[] nums) &#123; int i = 0, n = nums.length; while (i &lt; n) &#123; // If the current value is in the range of (0,length) and it&apos;s not at its correct position, // swap it to its correct position. // Else just continue; if (nums[i] &gt;= 0 &amp;&amp; nums[i] &lt; n &amp;&amp; nums[nums[i]] != nums[i]) swap(nums, i, nums[i]); else i++; &#125; int k = 1; // Check from k=1 to see whether each index and value can be corresponding. while (k &lt; n &amp;&amp; nums[k] == k) k++; // If it breaks because of empty array or reaching the end. K must be the first missing number. if (n == 0 || k &lt; n) return k; else // If k is hiding at position 0, K+1 is the number. return nums[0] == k ? k + 1 : k;&#125;private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[040. Combination Sum II]]></title>
    <url>%2Fp%2F217971c0%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/combination-sum-ii/ Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. 123456789For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] æ–¹æ³•ä¸€ï¼š å›žæº¯æ³•ï¼Œæˆ‘çš„ä»£ç å®žçŽ° 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end()); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; combination; helper(candidates, target, 0, combination, res); return res; &#125; void helper(vector&lt;int&gt;&amp; candidates, int target, int start, vector&lt;int&gt;&amp; combination, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(target==0)&#123; res.push_back(combination); return; &#125; if(target&lt;0 || start&gt;=candidates.size()) return; for(int i=start; i&lt;candidates.size(); i++)&#123; if(i!=start &amp;&amp; candidates[i]==candidates[i-1]) continue; combination.push_back(candidates[i]); helper(candidates, target-candidates[i], i+1, combination, res); // start+1 ä¸Ž i+1 çš„åŒºåˆ« combination.pop_back(); &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/8916/c-backtracking-solution-with-detailed-explanation C++ backtracking solution with detailed explanation At the beginning, I stuck on this problem. After careful thought, I think this kind of backtracking contains a iterative component and a resursive component so Iâ€™d like to give more details to help beginners save time. The revursive component tries the elements after the current one and also tries duplicate elements. So we can get correct answer for cases like [1 1] 2. The iterative component checks duplicate combinations and skip it if it is. So we can get correct answer for cases like [1 1 1] 2. 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combinationSum2(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(num.begin(),num.end()); vector&lt;int&gt; local; findCombination(res, 0, target, local, num); return res; &#125; void findCombination(vector&lt;vector&lt;int&gt;&gt;&amp; res, const int order, const int target, vector&lt;int&gt;&amp; local, const vector&lt;int&gt;&amp; num) &#123; if(target==0) &#123; res.push_back(local); return; &#125; else &#123; for(int i = order;i&lt;num.size();i++) // iterative component &#123; if(num[i]&gt;target) return; if(i&amp;&amp;num[i]==num[i-1]&amp;&amp;i&gt;order) continue; // check duplicate combination local.push_back(num[i]), findCombination(res,i+1,target-num[i],local,num); // recursive componenet local.pop_back(); &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/17682/8ms-c-backtracking-easy-to-understand 8ms C++ backtracking easy to understand 12345678910111213141516171819vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; current; sort(candidates.begin(),candidates.end()); backTracking(candidates.begin(),current,res,candidates,target); return res;&#125;void backTracking(vector&lt;int&gt;::iterator n, vector&lt;int&gt;&amp; current,vector&lt;vector&lt;int&gt;&gt;&amp; res, const vector&lt;int&gt;&amp; candidates, int target)&#123; if(!target) res.push_back(current); else if(target&gt;0)&#123; for(;n!=candidates.end()&amp;&amp;*n&lt;=target;++n)&#123; current.push_back(*n); backTracking(n+1,current,res,candidates,target-*n); current.pop_back(); while(n+1!=candidates.end()&amp;&amp;*(n+1)==*n) ++n; &#125; &#125;&#125; https://discuss.leetcode.com/topic/3399/my-solution-without-using-set My solution without using set My idea is skip same number during recursion. Like Permutations II. Firstly sort num, then search from back for numbers sum to target. 1234567891011121314151617181920212223242526272829vector&lt;vector&lt;int&gt; &gt; combinationSum2(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(num.begin(), num.end()); vector&lt;int&gt; cur; find(num, target, num.size() - 1, res, cur); return res;&#125;void find(vector&lt;int&gt; &amp;num, int target, int end, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; cur)&#123; if (target == 0) &#123; res.push_back(cur); return; &#125; if (end &lt; 0 || num[end] * (end + 1) &lt; target) return; if (num[end] &lt;= target) &#123; cur.insert(cur.begin(), num[end]); find(num, target - num[end], end - 1, res, cur); cur.erase(cur.begin()); &#125; //find combinations ends at the first number different from num[end] int temp = num[end]; while (end &gt;= 0 &amp;&amp; num[end] == temp) end--; find(num, target, end, res, cur);&#125; 12ms, 57.77%, June.21th, 2016 https://leetcode.com/discuss/37071/accepted-16ms-c-solution-use-backtracking-easy-understand 1234567891011121314151617181920212223class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target) &#123; std::sort(candidates.begin(), candidates.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum2(candidates, target, res, combination, 0); return res; &#125;private: void combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin) &#123; if (!target) &#123; res.push_back(combination); return; &#125; for (int i = begin; i != candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) if (i == begin || candidates[i] != candidates[i - 1]) &#123; combination.push_back(candidates[i]); combinationSum2(candidates, target - candidates[i], res, combination, i + 1); combination.pop_back(); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/5777/dp-solution-in-python DP solution in Python I also did it with recursion, turns out the DP solution is 3~4 times faster. 12345678910def combinationSum2(self, candidates, target): candidates.sort() table = [None] + [set() for i in range(target)] for i in candidates: if i &gt; target: break for j in range(target - i, 0, -1): table[i + j] |= &#123;elt + (i,) for elt in table[j]&#125; table[i].add((i,)) return map(list, table[target]) https://discuss.leetcode.com/topic/11852/my-84ms-python-recursive-solution My 84ms python recursive solution. 1234567891011121314151617class Solution: def combinationSum2(self, candidates, target): candidates.sort() return self.search(candidates, 0 ,target) def search(self, candidates, start, target): if target==0: return [[]] res=[] for i in xrange(start,len(candidates)): if i!=start and candidates[i]==candidates[i-1]: continue if candidates[i]&gt;target: break for r in self.search(candidates, i+1, target-candidates[i]): res.append([candidates[i]]+r) return res https://discuss.leetcode.com/topic/47845/beating-98-python-solution-using-recursion-with-comments Beating 98% Python solution using recursion with comments 12345678910111213141516171819202122232425262728293031def combinationSum2(self, candidates, target): # Sorting is really helpful, se we can avoid over counting easily candidates.sort() result = [] self.combine_sum_2(candidates, 0, [], result, target) return result def combine_sum_2(self, nums, start, path, result, target): # Base case: if the sum of the path satisfies the target, we will consider # it as a solution, and stop there if not target: result.append(path) return for i in xrange(start, len(nums)): # Very important here! We don&apos;t use `i &gt; 0` because we always want # to count the first element in this recursive step even if it is the same # as one before. To avoid overcounting, we just ignore the duplicates # after the first element. if i &gt; start and nums[i] == nums[i - 1]: continue # If the current element is bigger than the assigned target, there is # no need to keep searching, since all the numbers are positive if nums[i] &gt; target: break # We change the start to `i + 1` because one element only could # be used once self.combine_sum_2(nums, i + 1, path + [nums[i]], result, target - nums[i]) java https://discuss.leetcode.com/topic/19845/java-solution-using-dfs-easy-understand Java solution using dfs, easy understand 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] cand, int target) &#123; Arrays.sort(cand); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;Integer&gt;(); dfs_com(cand, 0, target, path, res); return res;&#125;void dfs_com(int[] cand, int cur, int target, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (target == 0) &#123; res.add(new ArrayList(path)); return ; &#125; if (target &lt; 0) return; for (int i = cur; i &lt; cand.length; i++)&#123; if (i &gt; cur &amp;&amp; cand[i] == cand[i-1]) continue; path.add(path.size(), cand[i]); dfs_com(cand, i+1, target - cand[i], path, res); path.remove(path.size()-1); &#125;&#125; https://discuss.leetcode.com/topic/44037/combination-sum-i-ii-and-iii-java-solution-see-the-similarities-yourself Combination Sum I, II and III Java solution (see the similarities yourself) Combination Sum I 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(candidates); backtrack(list, new ArrayList&lt;Integer&gt;(), candidates, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] cand, int remain, int start) &#123; if (remain &lt; 0) return; /** no solution */ else if (remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for (int i = start; i &lt; cand.length; i++) &#123; tempList.add(cand[i]); backtrack(list, tempList, cand, remain-cand[i], i); tempList.remove(tempList.size()-1); &#125; &#125;&#125; Combination Sum II 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(candidates); backtrack(list, new ArrayList&lt;Integer&gt;(), candidates, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] cand, int remain, int start) &#123; if(remain &lt; 0) return; /** no solution */ else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for (int i = start; i &lt; cand.length; i++) &#123; if(i &gt; start &amp;&amp; cand[i] == cand[i-1]) continue; /** skip duplicates */ tempList.add(cand[i]); backtrack(list, tempList, cand, remain - cand[i], i+1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum III 1234567891011121314151617public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;Integer&gt;(), k, n, 1); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int k, int remain, int start) &#123; if(tempList.size() &gt; k) return; /** no solution */ else if(tempList.size() == k &amp;&amp; remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for (int i = start; i &lt;= 9; i++) &#123; tempList.add(i); backtrack(list, tempList, k, remain-i, i+1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; https://discuss.leetcode.com/topic/24059/java-short-and-recursive-clean-code Java - short and recursive, clean code. 123456789101112131415161718192021222324252627public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); List&lt;Integer&gt; comb = new ArrayList&lt;&gt;(); Arrays.sort(candidates); // need sort to make this work. combination(candidates, target, 0, comb, ans); return ans;&#125;private void combination(int[] candi, int target, int start, List&lt;Integer&gt; comb, List&lt;List&lt;Integer&gt;&gt; ans) &#123; for (int i = start; i &lt; candi.length; i++) &#123; if (i &gt; start &amp;&amp; candi[i] == candi[i - 1]) //remove duplicates. continue; if (candi[i] == target) &#123; //recursion exit. List&lt;Integer&gt; newComb = new ArrayList&lt;&gt;(comb); newComb.add(candi[i]); ans.add(newComb); &#125; else if (candi[i] &lt; target) &#123; //continue to look for the rest. List&lt;Integer&gt; newComb = new ArrayList&lt;&gt;(comb); newComb.add(candi[i]); combination(candi, target - candi[i], i + 1, newComb, ans); &#125; else break; //invalid path, return nothing. &#125;&#125; https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning 12345678910111213141516171819202122public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125; &#125; https://discuss.leetcode.com/topic/34364/java-solutions-beats-99-87 Java solutions beats 99,87% 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); calcCombinationSum2(candidates, 0, new int[candidates.length], 0, target, results); return results; &#125; private void calcCombinationSum2(int[] candidates, int cindex, int[] list, int lindex, int target, List&lt;List&lt;Integer&gt;&gt; results) &#123; if (target == 0) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; lindex; i++) &#123; result.add(list[i]); &#125; results.add(result); return; &#125; int prev = 0; for (int i = cindex; i &lt; candidates.length; i++) &#123; if (candidates[i] != prev) &#123; if (target - candidates[i] &lt; 0) &#123; break; &#125; list[lindex] = candidates[i]; calcCombinationSum2(candidates, i + 1, list, lindex + 1, target - candidates[i], results); prev = candidates[i]; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[039. Combination Sum]]></title>
    <url>%2Fp%2Ff5e0c04b%2F</url>
    <content type="text"><![CDATA[38.6% https://leetcode.com/problems/combination-sum/ Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. 1234567For example, given candidate set [2, 3, 6, 7] and target 7, A solution set is: [ [7], [2, 2, 3]] æ–¹æ³•ä¸€ï¼š å›žæº¯æ³•, æˆ‘çš„ä»£ç å®žçŽ° 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; sort(candidates.begin(), candidates.end()); helper(candidates, 0, target, tmp, res); return res; &#125; // 0è‡³start-1ä¹‹é—´çš„candidateså·²ç»ç”¨è¿‡äº†ï¼Œåªèƒ½ä»Žstartå¼€å§‹ç”¨äº† void helper(vector&lt;int&gt;&amp; candidates, int start, int target, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(target==0)&#123; res.push_back(tmp); return; &#125;else if(target&lt;0 || start&gt;=candidates.size())&#123; return; &#125; for(int i=start; i&lt;candidates.size(); i++)&#123; tmp.push_back(candidates[i]); helper(candidates, i, target-candidates[i], tmp, res); tmp.pop_back(); &#125; &#125;&#125;; cpp 16ms, 71.93%, June.21th, 2016 https://leetcode.com/discuss/37071/accepted-16ms-c-solution-use-backtracking-easy-understand Accepted 16ms c++ solution use backtracking, easy understand. Accepted 16ms c++ solution use backtracking for Combination Sum: 12345678910111213141516171819202122class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum(std::vector&lt;int&gt; &amp;candidates, int target) &#123; std::sort(candidates.begin(), candidates.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum(candidates, target, res, combination, 0); return res; &#125;private: void combinationSum(std::vector&lt;int&gt; &amp;candidates, int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin) &#123; if (!target) &#123; res.push_back(combination); return; &#125; for (int i = begin; i != candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) &#123; combination.push_back(candidates[i]); combinationSum(candidates, target - candidates[i], res, combination, i); combination.pop_back(); &#125; &#125;&#125;; Accepted 12ms c++ solution use backtracking for Combination Sum II: 1234567891011121314151617181920212223class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target) &#123; std::sort(candidates.begin(), candidates.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum2(candidates, target, res, combination, 0); return res; &#125;private: void combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin) &#123; if (!target) &#123; res.push_back(combination); return; &#125; for (int i = begin; i != candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) if (i == begin || candidates[i] != candidates[i - 1]) &#123; combination.push_back(candidates[i]); combinationSum2(candidates, target - candidates[i], res, combination, i + 1); combination.pop_back(); &#125; &#125;&#125;; Accepted 0ms c++ solution use backtracking for Combination Sum III: 1234567891011121314151617181920212223class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum3(int k, int n) &#123; std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum3(n, res, combination, 1, k); return res; &#125;private: void combinationSum3(int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin, int need) &#123; if (!target) &#123; res.push_back(combination); return; &#125; else if (!need) return; for (int i = begin; i != 10 &amp;&amp; target &gt;= i * need + need * (need - 1) / 2; ++i) &#123; combination.push_back(i); combinationSum3(target - i, res, combination, i + 1, need - 1); combination.pop_back(); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/6431/concise-backtracking-solution Concise Backtracking Solution We backtrack from successful searches as well because they are saved at the leafs of recursion tree 12345678910111213141516171819202122232425262728293031class Solution &#123;public: void search(vector&lt;int&gt;&amp; num, int next, vector&lt;int&gt;&amp; pSol, int target, vector&lt;vector&lt;int&gt; &gt;&amp; result) &#123; if(target == 0) &#123; result.push_back(pSol); return; &#125; if(next == num.size() || target - num[next] &lt; 0) return; pSol.push_back(num[next]); search(num, next, pSol, target - num[next], result); pSol.pop_back(); search(num, next + 1, pSol, target, result); &#125; vector&lt;vector&lt;int&gt; &gt; combinationSum(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt; &gt; result; sort(num.begin(), num.end()); vector&lt;int&gt; pSol; search(num, 0, pSol, target, result); return result; &#125;&#125;; https://discuss.leetcode.com/topic/4454/dynamic-programming-solution Dynamic Programming Solution It adapts the DP solution of coin change problem 12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combinationSum(vector&lt;int&gt; &amp;candidates, int target) &#123; vector&lt; vector&lt; vector&lt;int&gt; &gt; &gt; combinations(target + 1, vector&lt;vector&lt;int&gt;&gt;()); combinations[0].push_back(vector&lt;int&gt;()); for (auto&amp; score : candidates) for (int j = score; j &lt;= target; j++) if (combinations[j - score].size() &gt; 0) &#123; auto tmp = combinations[j - score]; for (auto&amp; s : tmp) s.push_back(score); combinations[j].insert(combinations[j].end(), tmp.begin(), tmp.end()); &#125; auto ret = combinations[target]; for (int i = 0; i &lt; ret.size(); i++) sort(ret[i].begin(), ret[i].end()); return ret; &#125;&#125;; python 188ms, 27.12%, June.21th, 2016 https://leetcode.com/discuss/55666/python-dfs-solution Python dfs solution. 1234567891011121314151617181920class Solution(object): def combinationSum(self, candidates, target): &quot;&quot;&quot; :type candidates: List[int] :type target: int :rtype: List[List[int]] &quot;&quot;&quot; res = [] candidates.sort() self.dfs(candidates, target, [], res, 0) return res def dfs(self, nums, target, path, res, index): if target &lt; 0: return if target == 0: res.append(path) return for i in xrange(index, len(nums)): self.dfs(nums, target - nums[i], path + [nums[i]], res, i) 100ms, 88.35%, June.21th, 2016 https://leetcode.com/discuss/55666/python-dfs-solution 1234567891011121314151617181920class Solution(object): def combinationSum(self, candidates, target): &quot;&quot;&quot; :type candidates: List[int] :type target: int :rtype: List[List[int]] &quot;&quot;&quot; res = [] candidates.sort() self.dfs(candidates, target, [], res, 0) return res def dfs(self, nums, target, path, res, index): if target == 0: res.append(path) return for i in xrange(index, len(nums)): if nums[i] &gt; target: break self.dfs(nums, target - nums[i], path + [nums[i]], res, i) java https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning) This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. Subsets : https://leetcode.com/problems/subsets/ 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Subsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Permutations : https://leetcode.com/problems/permutations/ 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/ 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum : https://leetcode.com/problems/combination-sum/ 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum II (canâ€™t reuse same element) : https://leetcode.com/problems/combination-sum-ii/ 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Palindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/ 12345678910111213141516171819202122232425public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list;&#125;public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125;&#125;public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true;&#125; 6ms, 66.615, June.21th, 2016 https://leetcode.com/discuss/22651/java-solution-using-recursive Java solution using recursive 12345678910111213141516171819202122public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); getResult(result, new ArrayList&lt;Integer&gt;(), candidates, target, 0); return result; &#125; private void getResult(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; cur, int candidates[], int target, int start)&#123; if(target &gt; 0)&#123; for(int i = start; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++)&#123; cur.add(candidates[i]); getResult(result, cur, candidates, target - candidates[i], i); cur.remove(cur.size() - 1); &#125;//for &#125;//if else if(target == 0 )&#123; result.add(new ArrayList&lt;Integer&gt;(cur)); &#125;//else if &#125;&#125; https://discuss.leetcode.com/topic/8200/iterative-java-dp-solution Iterative Java DP solution Hi guys! The main idea reminds an approach for solving coins/knapsack problem - to store the result for all i &lt; target and create the solution from them. For that for each t from 1 to our target we try every candidate which is less or equal to t in ascending order. For each candidate â€œcâ€ we run through all combinations for target t-c starting with the value greater or equal than c to avoid duplicates and store only ordered combinations. 123456789101112131415161718192021222324public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] cands, int t) &#123; Arrays.sort(cands); // sort candidates to try them in asc order List&lt;List&lt;List&lt;Integer&gt;&gt;&gt; dp = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= t; i++) &#123; // run through all targets from 1 to t List&lt;List&lt;Integer&gt;&gt; newList = new ArrayList(); // combs for curr i // run through all candidates &lt;= i for (int j = 0; j &lt; cands.length &amp;&amp; cands[j] &lt;= i; j++) &#123; // special case when curr target is equal to curr candidate if (i == cands[j]) newList.add(Arrays.asList(cands[j])); // if current candidate is less than the target use prev results else for (List&lt;Integer&gt; l : dp.get(i-cands[j]-1)) &#123; if (cands[j] &lt;= l.get(0)) &#123; List cl = new ArrayList&lt;&gt;(); cl.add(cands[j]); cl.addAll(l); newList.add(cl); &#125; &#125; &#125; dp.add(newList); &#125; return dp.get(t-1); &#125;&#125; Hope it helps! https://discuss.leetcode.com/topic/3043/a-solution-avoid-using-set A solution avoid using set Sort the candidates and we choose from small to large recursively, every time we add a candidate to our possible sub result, we subtract the target to a new smaller one. 12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(candidates); // sort the candidates // collect possible candidates from small to large to eliminate duplicates, recurse(new ArrayList&lt;Integer&gt;(), target, candidates, 0, ret); return ret;&#125;// the index here means we are allowed to choose candidates from that indexprivate void recurse(List&lt;Integer&gt; list, int target, int[] candidates, int index, List&lt;List&lt;Integer&gt;&gt; ret) &#123; if (target == 0) &#123; ret.add(list); return; &#125; for (int i = index; i &lt; candidates.length; i++) &#123; int newTarget = target - candidates[i]; if (newTarget &gt;= 0) &#123; List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(list); copy.add(candidates[i]); recurse(copy, newTarget, candidates, i, ret); &#125; else &#123; break; &#125; &#125;&#125; https://discuss.leetcode.com/topic/3043/a-solution-avoid-using-set/2 Slightly modified your solution, this will make the method run a little faster. 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(candidates); // sort the candidates // collect possible candidates from small to large to eliminate duplicates, recurse(new ArrayList&lt;Integer&gt;(), target, candidates, 0, ret); return ret;&#125;// the index here means we are allowed to choose candidates from that indexprivate void recurse(List&lt;Integer&gt; list, int target, int[] candidates, int index, List&lt;List&lt;Integer&gt;&gt; ret) &#123; if (target == 0) &#123; ret.add(list); return; &#125; for (int i = index; i &lt; candidates.length; i++) &#123; int newTarget = target - candidates[i]; if (newTarget &gt;= 0) &#123; List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(list); copy.add(candidates[i]); recurse(copy, newTarget, candidates, i, ret); &#125;else&#123;break;&#125; &#125; https://discuss.leetcode.com/topic/8364/java-solution-backtracking Java solution (backtracking) 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; solution; private List&lt;Integer&gt; curSolution; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; solution = new ArrayList&lt;List&lt;Integer&gt;&gt;(); curSolution = new ArrayList&lt;Integer&gt;(); Arrays.sort(candidates); backTrack(candidates, target, 0); return solution; &#125; private void backTrack(int[] candidates, int target, int lastIdx) &#123; if (target == 0) &#123; solution.add(new ArrayList&lt;&gt;(curSolution)); &#125; else if (target &lt; 0) &#123; return; &#125; else &#123; int i = lastIdx; while (i &lt; candidates.length) &#123; int candidate = candidates[i]; curSolution.add(candidate); backTrack(candidates, target - candidate, i); curSolution.remove(curSolution.size() - 1); while (i &lt; candidates.length &amp;&amp; candidates[i] == candidate) &#123; i++; &#125; &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/4997/non-recursive-java-solution Non-Recursive JAVA solution 12345678910111213141516171819202122232425262728293031public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); int i=0, size = candidates.length, sum=0; Stack&lt;Integer&gt; combi = new Stack&lt;&gt;(), indices = new Stack&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); while (i &lt; size) &#123; if (sum + candidates[i]&gt;= target) &#123; if (sum + candidates[i] == target) &#123; combi.push(candidates[i]); result.add(new ArrayList&lt;&gt;(combi)); combi.pop(); &#125; // indices stack and combination stack should have the same size all the time if (!indices.empty())&#123; sum -= combi.pop(); i = indices.pop(); while (i == size-1 &amp;&amp; !indices.empty()) &#123; i = indices.pop(); sum -= combi.pop(); &#125; &#125; i++; &#125; else &#123; combi.push(candidates[i]); sum +=candidates[i]; indices.push(i); &#125; &#125; return result;&#125; https://discuss.leetcode.com/topic/6994/recursive-java-solution Recursive java solution 12345678910111213141516171819202122232425262728293031323334public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); // sort the array, so the result could be increasing order List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i = 0; i &lt; candidates.length; i++)&#123; // target smaller than current number, jump the current and rest of numbers if(target &lt; candidates[i]) continue; // if target is equal to the current number,add it to a new list and add that list to result else if(target == candidates[i])&#123; List&lt;Integer&gt; set = new ArrayList&lt;Integer&gt;(); set.add(candidates[i]); result.add(set); &#125; // if the target is smaller the current number,call this function again else&#123; // use modified array which not includes those numbers that before i to eliminate the duplicates int[] array = Arrays.copyOfRange(candidates,i,candidates.length); // call this function. pass the new target and modified array. List&lt;List&lt;Integer&gt;&gt; temp = combinationSum(array, target - candidates[i]); // for each list in the return list, add current number in the front of list, then add it to result // attention that if return list is null, this enhanced for loop will not perform. for(List&lt;Integer&gt; list:temp)&#123; list.add(0,candidates[i]); result.add(list); &#125; &#125; &#125; return result;&#125; They key point is passing new target and modified array. Pass the modified array to make sure no duplicates set. If the new target could not find a match number, the return list will be null, thus this null list will not be added to the result list.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[038. Count and Say]]></title>
    <url>%2Fp%2Ff2d63f47%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/count-and-say/ 1234567The count-and-say sequence is the sequence of integers beginning as follows:1, 11, 21, 1211, 111221, ...1 is read off as &quot;one 1&quot; or 11.11 is read off as &quot;two 1s&quot; or 21.21 is read off as &quot;one 2, then one 1&quot; or 1211.Given an integer n, generate the nth sequence. Note: The sequence of integers will be represented as a string. https://discuss.leetcode.com/topic/1296/please-change-the-misleading-description Please change the misleading description It seems not only me misunderstood the question. Please modify the description, since itâ€™s frustrating if you are solving a â€œdifferentâ€ question. Thanks. https://discuss.leetcode.com/topic/2264/examples-of-nth-sequence Examples of nth sequence At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so Iâ€™m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10: 1234567891011test 1. 1 2. 11 3. 21 4. 1211 5. 111221 6. 312211 7. 13112221 8. 1113213211 9. 31131211131221 10. 13211311123113112211 From the examples you can see, the (i+1)th sequence is the â€œcount and sayâ€ of the ith sequence! Hope this helps! https://discuss.leetcode.com/topic/2526/i-suggest-we-should-add-the-description-the-1-is-the-1st-string-and-calculate-the-n-th-string I suggest we should add the description: The â€œ1â€ is the 1st string, and calculate the n th string. Because usually we start from the 0 th item, so add this description to avoid misunderstanding. java 6ms, September 19, 2016 https://discuss.leetcode.com/topic/2309/show-an-answer-in-java Show an Answer in Java I found nobody answered this question in Java. Actually I got some trouble even this question is not so hard. Maybe many other people had some trouble too. So I put my answer here. @code StringBuilder.append() is the default way to append one string to another. While I have tried String.cancate(),which is not working properly. Any comment is welcomed. 12345678910111213141516171819202122232425public class Solution &#123; public String countAndSay(int n) &#123; StringBuilder curr = new StringBuilder(&quot;1&quot;); StringBuilder prev; int count; char say; for(int i=1; i&lt;n; i++)&#123; prev = curr; curr = new StringBuilder(); count = 1; say = prev.charAt(0); for(int j=1, len=prev.length(); j&lt;len; j++)&#123; if(prev.charAt(j)!=say)&#123; curr.append(count).append(say); count = 1; say = prev.charAt(j); &#125; else count++; &#125; curr.append(count).append(say); &#125; return curr.toString(); &#125;&#125; https://discuss.leetcode.com/topic/14543/straightforward-java-solution Straightforward Java Solution 123456789101112131415161718192021222324252627282930public class Solution &#123; public String countAndSay(int n) &#123; String s = &quot;1&quot;; for(int i = 1; i &lt; n; i++)&#123; s = countIdx(s); &#125; return s; &#125; public String countIdx(String s)&#123; StringBuilder sb = new StringBuilder(); char c = s.charAt(0); int count = 1; for(int i = 1; i &lt; s.length(); i++)&#123; if(s.charAt(i) == c)&#123; count++; &#125; else &#123; sb.append(count); sb.append(c); c = s.charAt(i); count = 1; &#125; &#125; sb.append(count); sb.append(c); return sb.toString(); &#125;&#125; cpp 3ms, September 19, 2016 https://discuss.leetcode.com/topic/20195/c-solution-easy-understand C++ solution easy-understand 1234567891011121314151617181920class Solution &#123;public: string countAndSay(int n) &#123; if(n==0) return &quot;&quot;; string res = &quot;1&quot;; while(--n)&#123; string cur = &quot;&quot;; for(int i=0; i&lt;res.size(); i++)&#123; int count = 1; while((i+1&lt;res.size())&amp;&amp;(res[i] == res[i+1]))&#123; count++; i++; &#125; cur += to_string(count) + res[i]; &#125; res = cur; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/2068/how-to-proof-the-count-is-always-less-than-10 How to proof the COUNT is always less than 10? At first, I solved this problem with the considering of the cases when COUNT is greater than 9, which can not be handled using:curString +=count+â€™0â€™;, since it is more than one digit. And I solved it using itoa. But when I thinked about the problem, it seems that the COUNT is always less than 10, even 4. Then I re-writed the solution and also accepted by OJ. Can you guys help me proof it?My code: 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string countAndSay(int n) &#123; string prevString; string curString = &quot;1&quot;; for (int i = 1; i&lt;n; ++i)&#123; prevString = curString; curString = &quot;&quot;; int count = 1; char digit = prevString[0]; for (int j = 1; j&lt;prevString.length(); ++j)&#123; if (prevString[j] == digit)&#123; ++count; &#125; else&#123; curString +=count+&apos;0&apos;; //myItoa(count); curString += digit; digit = prevString[j]; count = 1; &#125; &#125; curString += count+&apos;0&apos;;//myItoa(count); curString += digit; &#125; return curString; &#125;/*private: string myItoa(int i)&#123; string str; while (i)&#123; str += i%10+&apos;0&apos;; i /=10; &#125; reverse(str.begin(), str.end()); return str; &#125;*/&#125;; https://discuss.leetcode.com/topic/2068/how-to-proof-the-count-is-always-less-than-10/2 Proof by exhaustion and contrapositive: In order for a number greater than 4 to be created, there must be a series of numbers n&gt;4 in length all the same digit. Therefore, there is a subset of that series where the count would only reach 4. Because of this, any proof for the existence of a chain resulting in a number greater than 4 is also a proof for the existence of a 4-chain. Using the proof by contrapositive, this means that if 4-chains are proved to be impossible, then any n-chain with n&gt;4 is also impossible. In order to start with a chain with numbers greater than 4, you must assume that a 4-chain is possible in the first place, which is circular reasoning, and so cannot be used as an initial point. It is further impossible to have a negative value, since the counting numbers do not include them. Therefore, the only chains able to create a 4 (at least the first one) are 0000, 1111, 2222, or 3333. 10 0 0 0 -&gt; 40 The 0000 is read zero 0, zero 0, which must come from . Since there is nothing present, it could in theory occur anywhere in the string. However, since they would be next to each other, if the 0 is repeated as would be neccessary, the zeros would add together, resulting in just zero 0, leaving only 20, not 40. 11 1 1 1 -&gt; 41 The 1111 is read one 1, one 1 (or 11), which translates to 21, not 1111. This contradicts the assumption that there is a way to get 1111, and so prevents 4 or greater from appearing. Therefore, 1s cannot reach 4. 12 2 2 2 -&gt; 42 The 2222 is read two 2, two 2 (or 22 22), which is identical to the output. Since the input maps to itself, there is no way to leave that cycle, or it already would have. If 2222 exists in the input, then 2222 must have mapped to it. It cannot reach 42. Therefore, 2s cannot reach 4. 13 3 3 3 -&gt; 43 The 3333 is read three 3, three 3 (or 333 333). This in turn would require 333 333 333. This fails in two respects. First, that the previous inputs would not merge to 63 or 93. The second, that the sequence eventually traces back to the origin, 1. Since it keeps increasing in length as the number of rounds since the start decreases, it cannot have started at 1. Therefore, 3s cannot reach 4. As every possible case has been examined, and none can reach a 4 while starting at the given beginning (1), it is not possible for a 4-chain to occur, meaning a 4 cannot appear in any valid string for this problem. Further, as stated above, since a 4-chain is impossible, so too are all n-chains with n&gt;4, so no number greater than 4 can appear either. https://discuss.leetcode.com/topic/5377/c-solution-runtime-o-n-space-o-n C++ solution, runtime O(n), space O(n) Please see the comments in the code.The solution is quite straight-forward. We generate k-th string, and from k-th string we generate k+1-th string, until we generate n-th string.We use string-helper to save temporary result,Iâ€™m sure there is a way for in-place solution also. 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: std::string countAndSay(int n) &#123; if (0 == n) return &quot;&quot;; if (1 == n) return &quot;1&quot;; std::string res=&quot;1&quot;; std::string s; for (int i = 1; i &lt; n; i++)&#123; // run from starting to generate second string int len = res.size(); //cheack all digits in the string for (int j = 0; j &lt; len; j++)&#123; int count=1; // we have at least 1 occourence of each digit // get the number of times same digit occurred (be carefull with the end of the string) while ((j + 1 &lt; len) &amp;&amp; (res[j] == res[j + 1]))&#123; count++; j++; // we need to keep increasing the index inside of the string &#125; // add to new string &quot;count&quot;+&quot;digit itself&quot; s += std::to_string(count) + res[j]; &#125; // save temporary result res = s; // clean our string-helper s.clear(); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/7800/c-iterative-solution-with-explanation-easy-to-understand C++ iterative solution with explanation, easy to understand. Renewed Solution The key point here is to find the maximum consecutive identical numbers, which means, for example: Say there is a array like this [1, 1, 2, 3, 4, 4, 5, 5, 5], we will need to divide the array into different segments like this, [1, 1], [2], [3], [4, 4], [5, 5, 5]. Only in this way, can we count the occurrence of each consecutive segments and convert them into â€œ21 12 13 24 35â€. The description of the problem is misleading and I struggled for a while, after some searching I found the right explanation. The number n has nothing to do with the algorithm directly, but but only control the number of iteration. The problem can be solved by using iterative algorithm. Code 1234567891011121314151617181920212223242526272829303132333435string countAndSay(int n)&#123; string curr_str; // The initial case, when n = 1 curr_str += &apos;1&apos;; // The iterative case, when n &gt; 1 for (int i = 0; i &lt; n - 1; i++) &#123; string buffer; // Handle the current string int index = 0; for (int index = 0; index &lt; curr_str.size(); ++index) &#123; // Count the occurance of each digit int cnt = 1; // At least one occurance while (index + 1 &lt; curr_str.size() and curr_str[index + 1] == curr_str[index]) &#123; index++; cnt++; &#125; buffer.push_back(cnt + &apos;0&apos;); buffer.push_back(curr_str[index]); &#125; // Update the current string curr_str = buffer; &#125; return curr_str;&#125; python 52ms, September 19, 2016 https://discuss.leetcode.com/topic/28084/simple-python-solution Idea here is keep track of the first letter in the sequence and count consecutive occurances. Once you encounter a new letter you add the previous count and letter to the chain. Repeat n-1 times (since we seeded the initial â€˜1â€™ case). We always update temp after the inner loop since we will never have already added the last sequence. 12345678910111213141516171819class Solution(object): def countAndSay(self, n): &quot;&quot;&quot; :type n: int :rtype: str &quot;&quot;&quot; s = &apos;1&apos; for _ in range(n-1): let, temp, count = s[0], &apos;&apos;, 0 for l in s: if let == l: count += 1 else: temp += str(count) + let let = l count = 1 temp += str(count) + let s = temp return s https://discuss.leetcode.com/topic/28084/simple-python-solution Simple Python Solution Idea here is keep track of the first letter in the sequence and count consecutive occurances. Once you encounter a new letter you add the previous count and letter to the chain. Repeat n-1 times (since we seeded the initial â€˜1â€™ case). We always update temp after the inner loop since we will never have already added the last sequence. 1234567891011121314def countAndSay(self, n): s = &apos;1&apos; for _ in range(n-1): let, temp, count = s[0], &apos;&apos;, 0 for l in s: if let == l: count += 1 else: temp += str(count)+let let = l count = 1 temp += str(count)+let s = temp return s https://discuss.leetcode.com/topic/32023/4-5-lines-python-solutions 4-5 lines Python solutions Solution 1 â€¦ using a regular expression 12345def countAndSay(self, n): s = &apos;1&apos; for _ in range(n - 1): s = re.sub(r&apos;(.)\1*&apos;, lambda m: str(len(m.group(0))) + m.group(1), s) return s Solution 2 â€¦ using a regular expression 123456def countAndSay(self, n): s = &apos;1&apos; for _ in range(n - 1): s = &apos;&apos;.join(str(len(group)) + digit for group, digit in re.findall(r&apos;((.)\2*)&apos;, s)) return s Solution 3 â€¦ using groupby 123456def countAndSay(self, n): s = &apos;1&apos; for _ in range(n - 1): s = &apos;&apos;.join(str(len(list(group))) + digit for digit, group in itertools.groupby(s)) return s]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[037. Sudoku Solver]]></title>
    <url>%2Fp%2Ff1a3dfa0%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/sudoku-solver/ Write a program to solve a Sudoku puzzle by filling the empty cells. Empty cells are indicated by the character â€˜.â€™. You may assume that there will be only one unique solution. A sudoku puzzleâ€¦ â€¦and its solution numbers marked in red. https://discuss.leetcode.com/topic/2145/there-is-a-dancing-links-x-algorithm There is a Dancing Links X Algorithm Dr. Donald Knuthâ€™s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem. NOTE:This is a very complicate solution. A Sudoku Solver in Java implementing Knuthâ€™s Dancing Links Algorithm java 25ms, 54.00%, September 21, 2016 https://discuss.leetcode.com/topic/11327/straight-forward-java-solution-using-backtracking Straight Forward Java Solution Using Backtracking Try 1 through 9 for each cell. The time complexity should be 9 ^ m (m represents the number of blanks to be filled in), since each blank can have 9 choices. Details see comments inside code. Let me know your suggestions. Sorry for being late to answer the time complexity question 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public void solveSudoku(char[][] board) &#123; if(board == null || board.length == 0) return; solve(board); &#125; public boolean solve(char[][] board)&#123; for(int i=0; i&lt;board.length; i++)&#123; for(int j=0; j&lt;board[0].length; j++)&#123; if(board[i][j]==&apos;.&apos;)&#123; for(char c=&apos;1&apos;; c&lt;=&apos;9&apos;; c++)&#123; if(isValid(board, i, j, c))&#123; board[i][j] = c; if(solve(board)) return true; else board[i][j]=&apos;.&apos;; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; public boolean isValid(char[][] board, int i, int j, char c)&#123; for(int row = 0; row&lt;9; row++) if(board[row][j] == c) return false; for(int col = 0; col&lt;9; col++) if(board[i][col] == c) return false; for(int row = (i/3)*3; row &lt; (i/3)*3 + 3; row++) for(int col = (j/3)*3; col &lt; (j/3)*3+3; col++) if(board[row][col] == c) return false; return true; &#125;&#125; cpp https://discuss.leetcode.com/topic/7195/sharing-my-2ms-c-solution-with-comments-and-explanations Sharing my 2ms C++ solution with comments and explanations. Update: thereâ€™s a follow-up 0ms solution which is even more optimized This is one of the fastest Sudoku solvers Iâ€™ve ever written. It is compact enough - just 150 lines of C++ code with comments. I thought itâ€™d be interesting to share it, since it combines several techniques like reactive network update propagation and backtracking with very aggressive pruning. The algorithm is online - it starts with an empty board and as you add numbers to it, it starts solving the Sudoku. Unlike in other solutions where you have bitmasks of allowed/disallowed values per row/column/square, this solution track bitmask for every(!) cell, forming a set of constraints for the allowed values for each particular cell. Once a value is written into a cell, new constraints are immediately propagated to row, column and 3x3 square of the cell. If during this process a value of other cell can be unambiguously deduced - then the value is set, new constraints are propagated, so onâ€¦. You can think about this as an implicit reactive network of cells. If weâ€™re lucky (and weâ€™ll be lucky for 19 of 20 of Sudokus published in magazines) then Sudoku is solved at the end (or even before!) processing of the input. Otherwise, there will be empty cells which have to be resolved. Algorithm uses backtracking for this purpose. To optimize it, algorithm starts with the cell with the smallest ambiguity. This could be improved even further by using priority queue (but itâ€™s not implemented here). Backtracking is more or less standard, however, at each step we guess the number, the reactive update propagation comes back into play and it either quickly proves that the guess is unfeasible or significantly prunes the remaining search space. Itâ€™s interesting to note, that in this case taking and restoring snapshots of the compact representation of the state is faster than doing backtracking rollback by â€œundoing the movesâ€. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141class Solution &#123; struct cell // encapsulates a single cell on a Sudoku board &#123; uint8_t value; // cell value 1..9 or 0 if unset // number of possible (unconstrained) values for the cell uint8_t numPossibilities; // if bitset[v] is 1 then value can&apos;t be v bitset&lt;10&gt; constraints; cell() : value(0), numPossibilities(9),constraints() &#123;&#125;; &#125;; array&lt;array&lt;cell,9&gt;,9&gt; cells; // sets the value of the cell to [v] // the function also propagates constraints to other cells and deduce new values where possible bool set(int i, int j, int v) &#123; // updating state of the cell cell&amp; c = cells[i][j]; if (c.value == v) return true; if (c.constraints[v]) return false; c.constraints = bitset&lt;10&gt;(0x3FE); // all 1s c.constraints.reset(v); c.numPossibilities = 1; c.value = v; // propagating constraints for (int k = 0; k&lt;9; k++) &#123; // to the row: if (i != k &amp;&amp; !updateConstraints(k, j, v)) return false; // to the column: if (j != k &amp;&amp; !updateConstraints(i, k, v)) return false; // to the 3x3 square: int ix = (i / 3) * 3 + k / 3; int jx = (j / 3) * 3 + k % 3; if (ix != i &amp;&amp; jx != j &amp;&amp; !updateConstraints(ix, jx, v)) return false; &#125; return true; &#125; // update constraints of the cell i,j by excluding possibility of &apos;excludedValue&apos; // once there&apos;s one possibility left the function recurses back into set() bool updateConstraints(int i, int j, int excludedValue) &#123; cell&amp; c = cells[i][j]; if (c.constraints[excludedValue]) &#123; return true; &#125; if (c.value == excludedValue) &#123; return false; &#125; c.constraints.set(excludedValue); if (--c.numPossibilities &gt; 1) return true; for (int v = 1; v &lt;= 9; v++) &#123; if (!c.constraints[v]) &#123; return set(i, j, v); &#125; &#125; assert(false); &#125; // backtracking state - list of empty cells vector&lt;pair&lt;int, int&gt;&gt; bt; // find values for empty cells bool findValuesForEmptyCells() &#123; // collecting all empty cells bt.clear(); for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (!cells[i][j].value) bt.push_back(make_pair(i, j)); &#125; &#125; // making backtracking efficient by pre-sorting empty cells by numPossibilities sort(bt.begin(), bt.end(), [this](const pair&lt;int, int&gt;&amp;a, const pair&lt;int, int&gt;&amp;b) &#123; return cells[a.first][a.second].numPossibilities &lt; cells[b.first][b.second].numPossibilities; &#125;); return backtrack(0); &#125; // Finds value for all empty cells with index &gt;=k bool backtrack(int k) &#123; if (k &gt;= bt.size()) return true; int i = bt[k].first; int j = bt[k].second; // fast path - only 1 possibility if (cells[i][j].value) return backtrack(k + 1); auto constraints = cells[i][j].constraints; // slow path &gt;1 possibility. // making snapshot of the state array&lt;array&lt;cell,9&gt;,9&gt; snapshot(cells); for (int v = 1; v &lt;= 9; v++) &#123; if (!constraints[v]) &#123; if (set(i, j, v)) &#123; if (backtrack(k + 1)) return true; &#125; // restoring from snapshot, // note: computationally this is cheaper // than alternative implementation with undoing the changes cells = snapshot; &#125; &#125; return false; &#125;public: void solveSudoku(vector&lt;vector&lt;char&gt;&gt; &amp;board) &#123; cells = array&lt;array&lt;cell,9&gt;,9&gt;(); // clear array // Decoding input board into the internal cell matrix. // As we do it - constraints are propagated and even additional values are set as we go // (in the case if it is possible to unambiguously deduce them). for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != &apos;.&apos; &amp;&amp; !set(i, j, board[i][j] - &apos;0&apos;)) return; // sudoku is either incorrect or unsolvable &#125; &#125; // if we&apos;re lucky we&apos;ve already got a solution, // however, if we have empty cells we need to use backtracking to fill them if (!findValuesForEmptyCells()) return; // sudoku is unsolvable // copying the solution back to the board for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (cells[i][j].value) board[i][j] = cells[i][j].value + &apos;0&apos;; &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/13314/singapore-prime-minister-lee-hsien-loong-s-sudoku-solver-code-runs-in-1ms Singapore prime minister Lee Hsien Loongâ€™s Sudoku Solver code runs in 1ms Singaporeâ€™s prime minister Lee Hsien Loong showcased his Sudoku Solver C code. You can read his original Facebook post here and another news reporting it here. I have made some slight modification to adapt it so it can be tested on LeetCode OJ. It passed all 6/6 test cases with a runtime of 1 ms. Pretty impressive for a prime minister, huh? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// Original author: Hsien Loong Lee (http://bit.ly/1zfIGMc)// Slight modification by @1337c0d3r to adapt to run on LeetCode OJ.// https://leetcode.com/problems/sudoku-solver/int InBlock[81], InRow[81], InCol[81];const int BLANK = 0;const int ONES = 0x3fe; // Binary 1111111110int Entry[81]; // Records entries 1-9 in the grid, as the corresponding bit set to 1int Block[9], Row[9], Col[9]; // Each int is a 9-bit arrayint SeqPtr = 0;int Sequence[81];void SwapSeqEntries(int S1, int S2)&#123; int temp = Sequence[S2]; Sequence[S2] = Sequence[S1]; Sequence[S1] = temp;&#125;void InitEntry(int i, int j, int val)&#123; int Square = 9 * i + j; int valbit = 1 &lt;&lt; val; int SeqPtr2; // add suitable checks for data consistency Entry[Square] = valbit; Block[InBlock[Square]] &amp;= ~valbit; Col[InCol[Square]] &amp;= ~valbit; // Simpler Col[j] &amp;= ~valbit; Row[InRow[Square]] &amp;= ~valbit; // Simpler Row[i] &amp;= ~valbit; SeqPtr2 = SeqPtr; while (SeqPtr2 &lt; 81 &amp;&amp; Sequence[SeqPtr2] != Square) SeqPtr2++ ; SwapSeqEntries(SeqPtr, SeqPtr2); SeqPtr++;&#125;void PrintArray(char **board)&#123; int i, j, valbit, val, Square; char ch; Square = 0; for (i = 0; i &lt; 9; i++) &#123; for (j = 0; j &lt; 9; j++) &#123; valbit = Entry[Square++]; if (valbit == 0) ch = &apos;-&apos;; else &#123; for (val = 1; val &lt;= 9; val++) if (valbit == (1 &lt;&lt; val)) &#123; ch = &apos;0&apos; + val; break; &#125; &#125; board[i][j] = ch; &#125; &#125;&#125;int NextSeq(int S)&#123; int S2, Square, Possibles, BitCount; int T, MinBitCount = 100; for (T = S; T &lt; 81; T++) &#123; Square = Sequence[T]; Possibles = Block[InBlock[Square]] &amp; Row[InRow[Square]] &amp; Col[InCol[Square]]; BitCount = 0; while (Possibles) &#123; Possibles &amp;= ~(Possibles &amp; -Possibles); BitCount++; &#125; if (BitCount &lt; MinBitCount) &#123; MinBitCount = BitCount; S2 = T; &#125; &#125; return S2;&#125;void Place(int S, char** board)&#123; if (S &gt;= 81) &#123; PrintArray(board); return; &#125; int S2 = NextSeq(S); SwapSeqEntries(S, S2); int Square = Sequence[S]; int BlockIndex = InBlock[Square], RowIndex = InRow[Square], ColIndex = InCol[Square]; int Possibles = Block[BlockIndex] &amp; Row[RowIndex] &amp; Col[ColIndex]; while (Possibles) &#123; int valbit = Possibles &amp; (-Possibles); // Lowest 1 bit in Possibles Possibles &amp;= ~valbit; Entry[Square] = valbit; Block[BlockIndex] &amp;= ~valbit; Row[RowIndex] &amp;= ~valbit; Col[ColIndex] &amp;= ~valbit; Place(S + 1, board); Entry[Square] = BLANK; // Could be moved out of the loop Block[BlockIndex] |= valbit; Row[RowIndex] |= valbit; Col[ColIndex] |= valbit; &#125; SwapSeqEntries(S, S2);&#125;void solveSudoku(char **board, int m, int n) &#123; SeqPtr = 0; int i, j, Square; for (i = 0; i &lt; 9; i++) for (j = 0; j &lt; 9; j++) &#123; Square = 9 * i + j; InRow[Square] = i; InCol[Square] = j; InBlock[Square] = (i / 3) * 3 + ( j / 3); &#125; for (Square = 0; Square &lt; 81; Square++) &#123; Sequence[Square] = Square; Entry[Square] = BLANK; &#125; for (i = 0; i &lt; 9; i++) Block[i] = Row[i] = Col[i] = ONES; for (int i = 0; i &lt; 9; ++i) for (int j = 0; j &lt; 9; ++j) &#123; if (&apos;.&apos; != board[i][j]) InitEntry(i, j, board[i][j] - &apos;0&apos;); &#125; Place(SeqPtr, board);&#125; https://discuss.leetcode.com/topic/5002/a-simple-dfs-solution A simple DFS solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) &#123; return true; &#125; void solveSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) &#123; util(board, 0); &#125; bool util(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) &#123; if (pos &gt;= 81) return true; int i = pos / 9; int j = pos % 9; if (board[i][j] != &apos;.&apos;) return util(board, pos + 1); else &#123; for (char c = &apos;1&apos;; c &lt;= &apos;9&apos;; c++) &#123; if (!isInRow(board, i,c) &amp;&amp; !isInCol(board, j, c) &amp;&amp; !isInRec(board, i, j, c)) &#123; board[i][j] = c; if (util(board, pos + 1)) return true; else board[i][j] = &apos;.&apos;; &#125; &#125; return false; &#125; &#125; bool isInRow(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, char c) &#123; vector&lt;char&gt;&amp; row = board[i]; for (int k = 0; k &lt; 9; k++) &#123; if (row[k] == c) return true; &#125; return false; &#125; bool isInCol(vector&lt;vector&lt;char&gt;&gt;&amp; board,int j, char c) &#123; for (int k = 0; k &lt; 9; k++) &#123; if (board[k][j] == c) return true; &#125; return false; &#125; bool isInRec(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, char c) &#123; int bigrow = i / 3, bigcol = j / 3; for (int m = 3 * bigrow; m &lt; 3 * (bigrow + 1); m++) &#123; for (int n = 3 * bigcol; n &lt; 3 * (bigcol + 1); n++) if (board[m][n] == c) return true; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/21103/simple-and-clean-solution-c Simple and Clean Solution / C++ 1234567891011121314151617181920212223242526272829303132bool check(vector&lt;vector&lt;char&gt;&gt; &amp;board, int i, int j, char val)&#123; int row = i - i%3, column = j - j%3; for(int x=0; x&lt;9; x++) if(board[x][j] == val) return false; for(int y=0; y&lt;9; y++) if(board[i][y] == val) return false; for(int x=0; x&lt;3; x++) for(int y=0; y&lt;3; y++) if(board[row+x][column+y] == val) return false; return true;&#125;bool solveSudoku(vector&lt;vector&lt;char&gt;&gt; &amp;board, int i, int j)&#123; if(i==9) return true; if(j==9) return solveSudoku(board, i+1, 0); if(board[i][j] != &apos;.&apos;) return solveSudoku(board, i, j+1); for(char c=&apos;1&apos;; c&lt;=&apos;9&apos;; c++) &#123; if(check(board, i, j, c)) &#123; board[i][j] = c; if(solveSudoku(board, i, j+1)) return true; board[i][j] = &apos;.&apos;; &#125; &#125; return false;&#125;public:void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;solveSudoku(board, 0, 0);&#125; https://discuss.leetcode.com/topic/27787/c-clear-solution-using-dfs-beating-90-c-coder C++ clear solution using dfs, beating 90% c++ coder. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: bool col[10][10],row[10][10],f[10][10]; bool flag = false; void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; memset(col,false,sizeof(col)); memset(row,false,sizeof(row)); memset(f,false,sizeof(f)); for(int i = 0; i &lt; 9;i++)&#123; for(int j = 0; j &lt; 9;j++)&#123; if(board[i][j] == &apos;.&apos;) continue; int temp = 3*(i/3)+j/3; int num = board[i][j]-&apos;0&apos;; col[j][num] = row[i][num] = f[temp][num] = true; &#125; &#125; dfs(board,0,0); &#125; void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,int i,int j)&#123; if(flag == true) return ; if(i &gt;= 9)&#123; flag = true; return ; &#125; if(board[i][j] != &apos;.&apos;)&#123; if(j &lt; 8) dfs(board,i,j+1); else dfs(board,i+1,0); if(flag) return; &#125; else&#123; int temp = 3*(i/3)+j/3; for(int n = 1; n &lt;= 9; n++)&#123; if(!col[j][n] &amp;&amp; !row[i][n] &amp;&amp; !f[temp][n])&#123; board[i][j] = n + &apos;0&apos;; col[j][n] = row[i][n] = f[temp][n] = true; if(j &lt; 8) dfs(board,i,j+1); else dfs(board,i+1,0); col[j][n] = row[i][n] = f[temp][n] = false; if(flag) return; &#125; &#125; board[i][j] = &apos;.&apos;; &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/18316/48ms-straitforward-python-dfs-solution-with-explanations 48ms straitforward python DFS solution with explanations Itâ€™s similar to how human solve Sudoku. create a hash table (dictionary) val to store possible values in every location. Each time, start from the location with fewest possible values, choose one value from it and then update the board and possible values at other locations. If this update is valid, keep solving (DFS). If this update is invalid (leaving zero possible values at some locations) or this value doesnâ€™t lead to the solution, undo the updates and then choose the next value. Since we calculated val at the beginning and start filling the board from the location with fewest possible values, the amount of calculation and thus the runtime can be significantly reduced: The run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest python solutions here. The PossibleVals function may be further simplified/optimized, but it works just fine for now. (it would look less lengthy if we are allowed to use numpy array for the board lol). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556def solveSudoku(self, board): self.board = board self.val = self.PossibleVals() self.Solver()def PossibleVals(self): a = &quot;123456789&quot; d, val = &#123;&#125;, &#123;&#125; for i in xrange(9): for j in xrange(9): ele = self.board[i][j] if ele != &quot;.&quot;: d[(&quot;r&quot;, i)] = d.get((&quot;r&quot;, i), []) + [ele] d[(&quot;c&quot;, j)] = d.get((&quot;c&quot;, j), []) + [ele] d[(i//3, j//3)] = d.get((i//3, j//3), []) + [ele] else: val[(i,j)] = [] for (i,j) in val.keys(): inval = d.get((&quot;r&quot;,i),[])+d.get((&quot;c&quot;,j),[])+d.get((i/3,j/3),[]) val[(i,j)] = [n for n in a if n not in inval ] return valdef Solver(self): if len(self.val)==0: return True kee = min(self.val.keys(), key=lambda x: len(self.val[x])) nums = self.val[kee] for n in nums: update = &#123;kee:self.val[kee]&#125; if self.ValidOne(n, kee, update): # valid choice if self.Solver(): # keep solving return True self.undo(kee, update) # invalid choice or didn&apos;t solve it =&gt; undo return False def ValidOne(self, n, kee, update): self.board[kee[0]][kee[1]] = n del self.val[kee] i, j = kee for ind in self.val.keys(): if n in self.val[ind]: if ind[0]==i or ind[1]==j or (ind[0]/3,ind[1]/3)==(i/3,j/3): update[ind] = n self.val[ind].remove(n) if len(self.val[ind])==0: return False return Truedef undo(self, kee, update): self.board[kee[0]][kee[1]]=&quot;.&quot; for k in update: if k not in self.val: self.val[k]= update[k] else: self.val[k].append(update[k]) return None https://discuss.leetcode.com/topic/7475/accepted-python-solution Accepted Python solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution: # @param board, a 9x9 2D array # Solve the Sudoku by modifying the input board in-place. # Do not return any value. def solveSudoku(self, board): self.board = board self.solve() def findUnassigned(self): for row in range(9): for col in range(9): if self.board[row][col] == &quot;.&quot;: return row, col return -1, -1 def solve(self): row, col = self.findUnassigned() #no unassigned position is found, puzzle solved if row == -1 and col == -1: return True for num in [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;]: if self.isSafe(row, col, num): self.board[row][col] = num if self.solve(): return True self.board[row][col] = &quot;.&quot; return False def isSafe(self, row, col, ch): boxrow = row - row%3 boxcol = col - col%3 if self.checkrow(row,ch) and self.checkcol(col,ch) and self.checksquare(boxrow, boxcol, ch): return True return False def checkrow(self, row, ch): for col in range(9): if self.board[row][col] == ch: return False return True def checkcol(self, col, ch): for row in range(9): if self.board[row][col] == ch: return False return True def checksquare(self, row, col, ch): for r in range(row, row+3): for c in range(col, col+3): if self.board[r][c] == ch: return False return True Itâ€™s a simple backtracking solution.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[036. Valid Sudoku]]></title>
    <url>%2Fp%2F7b8b841d%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/valid-sudoku/ Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character â€˜.â€™. A partially filled sudoku which is valid. Note: A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. java 38ms, 6.81%, September 20, 2016 https://discuss.leetcode.com/topic/9748/shared-my-concise-java-code Shared my concise Java code 123456789101112131415161718public class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; for(int i=0; i&lt;9; i++)&#123; HashSet&lt;Character&gt; rows = new HashSet&lt;Character&gt;(); HashSet&lt;Character&gt; columns = new HashSet&lt;Character&gt;(); HashSet&lt;Character&gt; cube = new HashSet&lt;Character&gt;(); for(int j=0; j &lt; 9; j++)&#123; if(board[i][j] != &apos;.&apos; &amp;&amp; !rows.add(board[i][j])) return false; if(board[j][i] != &apos;.&apos; &amp;&amp; !columns.add(board[j][i])) return false; int RowIndex = 3*(i/3); int ColIndex = 3*(i%3); if(board[RowIndex+j/3][ColIndex+j%3]!=&apos;.&apos; &amp;&amp; !cube.add(board[RowIndex+j/3][ColIndex+j%3])) return false; &#125; &#125; return true; &#125;&#125; https://discuss.leetcode.com/topic/5803/sharing-my-easy-understand-java-solution-using-set Sharing my easy-understand java solution using set 1234567891011121314151617181920212223public class Solution &#123;public boolean isValidSudoku(char[][] board) &#123; for (int i=0; i&lt;9; i++) &#123; if (!isParticallyValid(board,i,0,i,8)) return false; if (!isParticallyValid(board,0,i,8,i)) return false; &#125; for (int i=0;i&lt;3;i++)&#123; for(int j=0;j&lt;3;j++)&#123; if (!isParticallyValid(board,i*3,j*3,i*3+2,j*3+2)) return false; &#125; &#125; return true;&#125;private boolean isParticallyValid(char[][] board, int x1, int y1,int x2,int y2)&#123; Set singleSet = new HashSet(); for (int i= x1; i&lt;=x2; i++)&#123; for (int j=y1;j&lt;=y2; j++)&#123; if (board[i][j]!=&apos;.&apos;) if(!singleSet.add(board[i][j])) return false; &#125; &#125; return true;&#125;&#125; Each time send the coordinates to check if the board is partially valid. https://discuss.leetcode.com/topic/27436/short-simple-java-using-strings Short+Simple Java using Strings Collect the set of things we see, encoded as strings. For example: â€˜4â€™ in row 7 is encoded as â€œ(4)7â€.â€˜4â€™ in column 7 is encoded as â€œ7(4)â€.â€˜4â€™ in the top-right block is encoded as â€œ0(4)2â€.Scream false if we ever fail to add something because it was already added (i.e., seen before). 12345678910111213public boolean isValidSudoku(char[][] board) &#123; Set seen = new HashSet(); for (int i=0; i&lt;9; ++i) &#123; for (int j=0; j&lt;9; ++j) &#123; if (board[i][j] != &apos;.&apos;) &#123; String b = &quot;(&quot; + board[i][j] + &quot;)&quot;; if (!seen.add(b + i) || !seen.add(j + b) || !seen.add(i/3 + b + j/3)) return false; &#125; &#125; &#125; return true;&#125; Edit: Just occurred to me that we can also make it really clear and self-explaining. Iâ€™m loving it. 1234567891011121314public boolean isValidSudoku(char[][] board) &#123; Set seen = new HashSet(); for (int i=0; i&lt;9; ++i) &#123; for (int j=0; j&lt;9; ++j) &#123; char number = board[i][j]; if (number != &apos;.&apos;) if (!seen.add(number + &quot; in row &quot; + i) || !seen.add(number + &quot; in column &quot; + j) || !seen.add(number + &quot; in block &quot; + i/3 + &quot;-&quot; + j/3)) return false; &#125; &#125; return true;&#125; https://discuss.leetcode.com/topic/40078/yet-another-java-2ms-solution Yet another java 2ms solution 1234567891011121314151617181920public boolean isValidSudoku(char[][] board) &#123; int [] vset = new int [9]; int [] hset = new int [9]; int [] bckt = new int [9]; int idx = 0; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != &apos;.&apos;) &#123; idx = 1 &lt;&lt; (board[i][j] - &apos;0&apos;) ; if ((hset[i] &amp; idx) &gt; 0 || (vset[j] &amp; idx) &gt; 0 || (bckt[(i / 3) * 3 + j / 3] &amp; idx) &gt; 0) return false; hset[i] |= idx; vset[j] |= idx; bckt[(i / 3) * 3 + j / 3] |= idx; &#125; &#125; &#125; return true;&#125; cpp 16ms, 34.54%, September 20, 2016 https://discuss.leetcode.com/topic/8241/my-short-solution-by-c-o-n2 My short solution by C++. O(n2) Three flags are used to check whether a number appear. used1: check each row used2: check each column used3: check each sub-boxes 1234567891011121314class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int used1[9][9] = &#123;0&#125;, used2[9][9] = &#123;0&#125;, used3[9][9] = &#123;0&#125;; for(int i = 0; i&lt;board.size(); ++i) for(int j = 0; j &lt; board[i].size(); ++j) if(board[i][j] != &apos;.&apos;)&#123; int num = board[i][j] - &apos;0&apos; - 1, k = i/3*3 + j/3; if(used1[i][num] || used2[j][num] || used3[k][num]) return false; used1[i][num] = used2[j][num] = used3[k][num] = 1; &#125; return true; &#125;&#125;; https://discuss.leetcode.com/topic/20201/c-very-simple-and-easy-understand-using-bit-operation C++ very simple and easy understand. using bit operation 1234567891011121314151617bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; vector&lt;short&gt; col(9, 0); vector&lt;short&gt; block(9, 0); vector&lt;short&gt; row(9, 0); for (int i = 0; i &lt; 9; i++) for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != &apos;.&apos;) &#123; int idx = 1 &lt;&lt; (board[i][j] - &apos;0&apos;); if (row[i] &amp; idx || col[j] &amp; idx || block[i/3 * 3 + j / 3] &amp; idx) return false; row[i] |= idx; col[j] |= idx; block[i/3 * 3 + j/3] |= idx; &#125; &#125; return true; &#125; https://discuss.leetcode.com/topic/15917/my-12-lines-c-c-solution-with-1-time-traversal-and-9x9x3-memory My 12 lines C/C++ solution with 1 time traversal and 9x9x3 memory 1234567891011121314int isValidSudoku(char** board, int boardRowSize, int boardColSize) &#123; int rows[9][9]=&#123;0&#125;; //rows[5][0] means whether number 1(&apos;0&apos;+1) in row 5 has appeared. int cols[9][9]=&#123;0&#125;; //cols[3][8] means whether number 9(&apos;8&apos;+1) in col 3 has appeared. int blocks[3][3][9]=&#123;0&#125;;//blocks[0][2][5] means whether number &apos;6&apos; in block 0,2 (row 0~2,col 6~8) has appeared. for(int r=0;r&lt;9;r++) //traverse board r,c for(int c=0;c&lt;9;c++) if(board[r][c]!=&apos;.&apos;)&#123; //skip all number &apos;.&apos; int number=board[r][c]-&apos;1&apos;; //calculate the number&apos;s index(board&apos;s number minus 1) if(rows[r][number]++) return 0; //if the number has already appeared once, return false. if(cols[c][number]++) return 0; if(blocks[r/3][c/3][number]++) return 0; &#125; return 1;&#125; python https://discuss.leetcode.com/topic/20016/1-7-lines-python-4-solutions 1-7 lines Python, 4 solutions Idea Just go through all you see (like â€œ7 in row 3â€) and check for duplicates. Solution 1 Using Counter. One logical line, seven physical lines. 12345678def isValidSudoku(self, board): return 1 == max(collections.Counter( x for i, row in enumerate(board) for j, c in enumerate(row) if c != &apos;.&apos; for x in ((c, i), (j, c), (i/3, j/3, c)) ).values() + [1]) The + [1] is only for the empty board, where max would get an empty list and complain. Itâ€™s not necessary to get it accepted here, as the empty board isnâ€™t among the test cases, but itâ€™s good to have. Solution 2 Using len(set). 123456def isValidSudoku(self, board): seen = sum(([(c, i), (j, c), (i/3, j/3, c)] for i, row in enumerate(board) for j, c in enumerate(row) if c != &apos;.&apos;), []) return len(seen) == len(set(seen)) Solution 3 Using any. 1234567def isValidSudoku(self, board): seen = set() return not any(x in seen or seen.add(x) for i, row in enumerate(board) for j, c in enumerate(row) if c != &apos;.&apos; for x in ((c, i), (j, c), (i/3, j/3, c))) Solution 4 Iterating a different way. 12345def isValidSudoku(self, board): seen = sum(([(c, i), (j, c), (i/3, j/3, c)] for i in range(9) for j in range(9) for c in [board[i][j]] if c != &apos;.&apos;), []) return len(seen) == len(set(seen)) https://discuss.leetcode.com/topic/20016/1-7-lines-python-4-solutions/2 Your solutions are briliant! Just another way to write Solution2: 1234567def isValidSudoku(self, board): seen = [] for i, row in enumerate(board): for j, c in enumerate(row): if c != &apos;.&apos;: seen += [(c,j),(i,c),(i/3,j/3,c)] return len(seen) == len(set(seen))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[035. Search Insert Position]]></title>
    <url>%2Fp%2F370b1fef%2F</url>
    <content type="text"><![CDATA[37.9% https://leetcode.com/problems/search-insert-position/ Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. 12345Here are few examples.[1,3,5,6], 5 â†’ 2[1,3,5,6], 2 â†’ 1[1,3,5,6], 7 â†’ 4[1,3,5,6], 0 â†’ 0 æ–¹æ³•ä¸€ï¼š è¯„ä»·ï¼šItâ€™s just lower bound binary search. https://leetcode.com/discuss/39829/c-o-logn-binary-search-that-handles-duplicate C++ O(logn) Binary Search that handles duplicate If there are duplicate elements equal to target, my code will always return the one with smallest index. 1234567891011121314151617181920212223242526class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int low = 0, high = nums.size()-1; // Invariant: the desired index is between [low, high+1] while (low &lt;= high) &#123; int mid = low + (high-low)/2; if (nums[mid] &lt; target) low = mid+1; else high = mid-1; &#125; // (1) At this point, low &gt; high. That is, low &gt;= high+1 // (2) From the invariant, we know that the index is between [low, high+1], // so low &lt;= high+1. Follwing from (1), now we know low == high+1. // (3) Following from (2), the index is between [low, high+1] = [low, low], //which means that low is the desired index // Therefore, we return low as the answer. //You can also return high+1 as the result, //since low == high+1 return low; &#125;&#125;; æ–¹æ³•äºŒï¼š A simple CPP solution with lower_bound Actually, what we need here is std::lower_bound in C++ STL, which returns an iterator pointing to the first element that does not less than target. And then, things are quite simple: 123456class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; return lower_bound(nums.begin(), nums.end(), target) - nums.begin(); &#125;&#125;; Or we can implement an inline lower_bound: 123456789101112131415class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; auto first = nums.begin(), last = nums.end(); while (first &lt; last) &#123; auto mid = first + ((last - first) &gt;&gt; 1); if (*mid &lt; target) &#123; first = mid + 1; &#125; else &#123; last = mid; &#125; &#125; return first - nums.begin(); &#125;&#125;; cpp 8ms, 15.81%, June.18th, 2016 https://leetcode.com/discuss/39829/c-o-logn-binary-search-that-handles-duplicate C++ O(logn) Binary Search that handles duplicate If there are duplicate elements equal to target, my code will always return the one with smallest index. 12345678910111213141516171819202122class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int low = 0, high = nums.size()-1; // Invariant: the desired index is between [low, high+1] while (low &lt;= high) &#123; int mid = low + (high-low)/2; if (nums[mid] &lt; target) low = mid+1; else high = mid-1; &#125; // (1) At this point, low &gt; high. That is, low &gt;= high+1 // (2) From the invariant, we know that the index is between [low, high+1], so low &lt;= high+1. Follwing from (1), now we know low == high+1. // (3) Following from (2), the index is between [low, high+1] = [low, low], which means that low is the desired index // Therefore, we return low as the answer. You can also return high+1 as the result, since low == high+1 return low; &#125;&#125;; https://discuss.leetcode.com/topic/7648/my-8ms-accepted-code My 8ms accepted code. 1234567891011121314151617class Solution &#123;public: int searchInsert(int A[], int n, int target) &#123; int low = 0,high = n - 1; while (low &lt;= high)&#123; int mid = (low + high) / 2; if(A[mid]==target) return mid; else if (A[mid] &gt;target)&#123; high = mid - 1; &#125; else&#123; low = mid + 1; &#125; &#125; return low; &#125;&#125;; https://discuss.leetcode.com/topic/16628/a-simple-cpp-solution-with-lower_bound A simple CPP solution with lower_bound Actually, what we need here is std::lower_bound in C++ STL, which returns an iterator pointing to the first element that does not less than target. And then, things are quite simple: 123456class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; return lower_bound(nums.begin(), nums.end(), target) - nums.begin(); &#125;&#125;; Or we can implement an inline lower_bound: 123456789101112131415class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; auto first = nums.begin(), last = nums.end(); while (first &lt; last) &#123; auto mid = first + ((last - first) &gt;&gt; 1); if (*mid &lt; target) &#123; first = mid + 1; &#125; else &#123; last = mid; &#125; &#125; return first - nums.begin(); &#125;&#125;; https://discuss.leetcode.com/topic/20299/my-understanding-of-lower-bound-upper-bound-binary-search-in-c-thanks-to-two-post My understanding of (lower bound,upper bound) binary search, in C++, thanks to two post thanks to A simple CPP solution with lower_boundand C++ O(logn) Binary Search that handles duplicate, thanks to phu1ku â€˜s answer on the second post. links for std::lower_bound and std::upper_bound 12345678910111213141516171819class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; /// return index of first one that comp(item,target)==true, or nums.size() if not found /// comp is greater or equal to for lower_bound /// comp is greater for upper_bound int first=0, last=nums.size(), mid; while (first&lt;last) &#123; mid=first+((last-first)&gt;&gt;1); // first&lt;=mid, mid&lt;last /// if comp(item,target)==false, advance first // if(nums[mid]&lt;=target) // for upper_bound if (nums[mid]&lt;target) // for lower_bound first=mid+1; // first always increases else /// else recede last last=mid; // last always decreases (even last-first==1) &#125; return first; &#125;&#125;; python https://discuss.leetcode.com/topic/25828/python-beats-98 Python beats 98% Once the left border is larger than key, than return index. Once the right border is less than key, then return index. 12345678910111213141516171819202122232425262728class Solution(object):def searchInsert(self, nums, key): if key &gt; nums[len(nums) - 1]: return len(nums) if key &lt; nums[0]: return 0 l, r = 0, len(nums) - 1 while l &lt;= r: m = (l + r)/2 if nums[m] &gt; key: r = m - 1 if r &gt;= 0: if nums[r] &lt; key: return r + 1 else: return 0 elif nums[m] &lt; key: l = m + 1 if l &lt; len(nums): if nums[l] &gt; key: return l else: return len(nums) else: return m https://discuss.leetcode.com/topic/30370/python-one-liner-48ms Python one liner 48ms 12345678class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; return len([x for x in nums if x&lt;target]) Solution Mine: 64ms, 5.76%, June.18th, 2016 123456789101112131415class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if target &lt;= nums[0]: return 0 if target &gt; nums[-1]: return len(nums) rtype = 0 while target &gt; nums[rtype]: rtype += 1 return rtype 48ms, 60.93%, June.18th, 2016 https://leetcode.com/discuss/61347/python-beats-98%25 123456789101112131415161718192021222324252627282930313233class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if target &gt; nums[len(nums) - 1]: return len(nums) if target &lt; nums[0]: return 0 l, r = 0, len(nums) - 1 while l &lt;= r: m = (l + r)/2 if nums[m] &gt; target: r = m - 1 if r &gt;= 0: if nums[r] &lt; target: return r + 1 else: return 0 elif nums[m] &lt; target: l = m + 1 if l &lt; len(nums): if nums[l] &gt; target: return l else: return len(nums) else: return m java 0ms, 17.55%, June.18h, 2016 https://leetcode.com/discuss/23076/my-8-line-java-solution My 8 line Java solution 1234567891011public class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int low = 0, high = nums.length; while(low &lt; high)&#123; int mid = low + (high-low) / 2; if(nums[mid] &gt;= target) high = mid; else low = mid + 1; &#125; return low; &#125;&#125; https://discuss.leetcode.com/topic/31499/very-concise-and-efficient-solution-in-java Very concise and efficient solution in Java I have several solutions to this problem; this is the most concise and efficient one I have. 12345678910111213public class Solution &#123;public int searchInsert(int[] nums, int target) &#123; int low = 0, high = nums.length; while(low &lt; high) &#123; int mid = low + (high - low) / 2; if(nums[mid] &lt; target) low = mid + 1; else high = mid; &#125; return low;&#125;&#125; https://discuss.leetcode.com/topic/2661/simple-binary-search-solution Simple Binary Search Solution I think the solution does not need a lot of if statement. Only two cases: if found, just return current index if not found, return next index where the search end 12345678910int search(int A[], int start, int end, int target) &#123; if (start &gt; end) return start; int mid = (start + end) / 2; if (A[mid] == target) return mid; else if (A[mid] &gt; target) return search(A, start, mid - 1, target); else return search(A, mid + 1, end, target);&#125;int searchInsert(int A[], int n, int target) &#123; return search(A, 0, n - 1, target);&#125; https://discuss.leetcode.com/topic/4764/accepted-o-logn-java-solution-binary-search Accepted O(logN) Java solution, binary search 12345678910111213141516171819202122232425262728public class Solution &#123; public int searchInsert(int[] A, int target) &#123; if(A.length == 0)return 0; int left = 0, right = A.length - 1; int mid = 0; while(left &lt;= right)&#123; if(target&lt;A[left])return left; if(target&gt;A[right])return right+1; mid = (left+right)/2; if(A[mid]==target)return mid; else if(target &lt; A[mid])&#123; right = mid-1; &#125;else&#123; left = mid +1; &#125; &#125; return -1; &#125;&#125; https://discuss.leetcode.com/topic/20133/simple-java-solution Simple Java solution 1234567public int searchInsert(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt;= target) return i; &#125; return nums.length;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[034. Search for a Range]]></title>
    <url>%2Fp%2Fffb88a9b%2F</url>
    <content type="text"><![CDATA[34.1% https://leetcode.com/problems/search-for-a-range/ Given a sorted array of integers, find the starting and ending position of a given target value. Your algorithmâ€™s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. 123For example,Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. å‰‘æŒ‡offer 38 æ–¹æ³•ä¸€ï¼š å…ˆæ‰¾æœ€å·¦ä¾§è¾¹ç•Œï¼Œç„¶åŽå³ä¾§è¾¹ç•Œ æˆ‘çš„ä»£ç å®žçŽ°: 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int left, right; // è¿™é‡Œæ˜¯nums.size() ä¸æ˜¯nums.size()-1 int l = 0, r = nums.size(); while(l&lt;r)&#123; int mid = l+(r-l)/2; if(nums[mid]&gt;=target) r = mid; else l = mid+1; &#125; left = l; l = 0, r = nums.size(); while(l&lt;r)&#123; int mid = l+(r-l)/2; if(nums[mid]&lt;=target) l = mid+1; else r = mid; &#125; right = l; // lower_boundå’Œupper_boundç›¸ç­‰æ—¶ï¼Œä¸€å®šæ˜¯ä¸ç­‰äºŽé¢ &gt;= &gt;ç›¸ç­‰ ä¸€å®šæ˜¯å¤§äºŽ return left==right?vector&lt;int&gt;&#123;-1, -1&#125; : vector&lt;int&gt;&#123;left, right-1&#125;; &#125;&#125;; è¿˜æœ‰å°±æ˜¯å­¦ä¸€ä¸‹è¿™ç§å†™æ³•ï¼švector {-1,-1} The standard and clean c++ binary search implementation. Yeah, binary search is quite simple, but many people write complex and error-prone code. 123456789101112131415161718192021vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int start = 0, end = nums.size(), mid, left, right; while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt;= target) end = mid; else start = mid + 1; &#125; left = start; start = 0, end = nums.size(); while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt; target) end = mid; else start = mid + 1; &#125; right = start; return left == right ? vector&lt;int&gt; &#123;-1,-1&#125; : vector&lt;int&gt; &#123;left,right-1&#125;;&#125; æ–¹æ³•äºŒ: å°±æ˜¯lower_bound upper_boundä¸¤ä¸ªå‡½æ•°ï¼Œä½†æ˜¯è¦è®°å¾—ä»–ä»¬çš„è¾¹ç•Œï¼Œä»¥åŠç›¸åº”å‡½æ•°ä½¿ç”¨æ–¹æ³• è¿˜æœ‰ä½¿ç”¨è¿­ä»£å™¨æ±‚å…ƒç´ çš„ä½ç½®ç´¢å¼•çš„æ–¹æ³•ï¼Œä»¥åŠè¿”å›žvectoræ€Žä¹ˆåŽ»åˆå§‹åŒ–è¿”å›ž 1234567891011class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; auto itlow = lower_bound(nums.begin(), nums.end(), target); auto itup = upper_bound(nums.begin(), nums.end(), target); if(itlow==nums.end() || (*itlow)!=target) return &#123;-1, -1&#125;; else return &#123;itlow-nums.begin(), itup-nums.begin()-1&#125;; &#125;&#125;; cpp 12ms, 19.84%, June.22th, 2016 https://leetcode.com/discuss/18242/clean-iterative-solution-binary-searches-with-explanation Clean iterative solution with two binary searches (with explanation) The problem can be simply broken down as two binary searches for the begining and end of the range, respectively: First letâ€™s find the left boundary of the range. We initialize the range to [i=0, j=n-1]. In each step, calculate the middle element [mid = (i+j)/2]. Now according to the relative value of A[mid] to target, there are three possibilities: If A[mid] &lt; target, then the range must begins on the right of mid (hence i = mid+1 for the next iteration) If A[mid] &gt; target, it means the range must begins on the left of mid (j = mid-1) If A[mid] = target, then the range must begins on the left of or at mid (j= mid) Since we would move the search range to the same side for case 2 and 3, we might as well merge them as one single case so that less code is needed: 12*. If A[mid] &gt;= target, j = mid; Surprisingly, 1 and 2* are the only logic you need to put in loop while (i &lt; j). When the while loop terminates, the value of i/j is where the start of the range is. Why? No matter what the sequence originally is, as we narrow down the search range, eventually we will be at a situation where there are only two elements in the search range. Suppose our target is 5, then we have only 7 possible cases: 1234567case 1: [5 7] (A[i] = target &lt; A[j])case 2: [5 3] (A[i] = target &gt; A[j])case 3: [5 5] (A[i] = target = A[j])case 4: [3 5] (A[j] = target &gt; A[i])case 5: [3 7] (A[i] &lt; target &lt; A[j])case 6: [3 4] (A[i] &lt; A[j] &lt; target)case 7: [6 7] (target &lt; A[i] &lt; A[j]) For case 1, 2 and 3, if we follow the above rule, since mid = i =&gt; A[mid] = target in these cases, then we would set j = mid. Now the loop terminates and i and j both point to the first 5. For case 4, since A[mid] &lt; target, then set i = mid+1. The loop terminates and both i and j point to 5. For all other cases, by the time the loop terminates, A[i] is not equal to 5. So we can easily know 5 is not in the sequence if the comparison fails. In conclusion, when the loop terminates, if A[i]==target, then i is the left boundary of the range; otherwise, just return -1; For the right of the range, we can use a similar idea. Again we can come up with several rules: If A[mid] &gt; target, then the range must begins on the left of mid (j = mid-1) If A[mid] &lt; target, then the range must begins on the right of mid (hence i = mid+1 for the next iteration) If A[mid] = target, then the range must begins on the right of or at mid (i= mid) Again, we can merge condition 2 and 3 into: 12* If A[mid] &lt;= target, then i = mid; However, the terminate condition on longer works this time. Consider the following case: 1[5 7], target = 5 Now A[mid] = 5, then according to rule 2, we set i = mid. This practically does nothing because i is already equal to mid. As a result, the search range is not moved at all! The solution is by using a small trick: instead of calculating mid as mid = (i+j)/2, we now do: 1mid = (i+j)/2+1 Why does this trick work? When we use mid = (i+j)/2, the mid is rounded to the lowest integer. In other words, mid is always biased towards the left. This means we could have i == mid when j - i == mid, but we NEVER have j == mid. So in order to keep the search range moving, you must make sure the new i is set to something different than mid, otherwise we are at the risk that i gets stuck. But for the new j, it is okay if we set it to mid, since it was not equal to mid anyways. Our two rules in search of the left boundary happen to satisfy these requirements, so it works perfectly in that situation. Similarly, when we search for the right boundary, we must make sure i wonâ€™t get stuck when we set the new i to i = mid. The easiest way to achieve this is by making mid biased to the right, i.e. mid = (i+j)/2+1. All this reasoning boils down to the following simple code: 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int i = 0, j = nums.size() - 1; vector&lt;int&gt; ret(2, -1); while(i &lt; j)&#123; int mid = (i + j) / 2; if(nums[mid] &lt; target) i = mid + 1; else j = mid; &#125; if(nums[i] != target) return ret; else ret[0] = i; j = nums.size() - 1; while(i &lt; j)&#123; int mid = (i + j) / 2 + 1; if(nums[mid] &gt; target) j = mid - 1; else i = mid; &#125; ret[1] = j; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/19437/the-standard-and-clean-c-binary-search-implementation The standard and clean c++ binary search implementation. Yeah, binary search is quite simple, but many people write complex and error-prone code. 123456789101112131415161718192021vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int start = 0, end = nums.size(), mid, left, right; while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt;= target) end = mid; else start = mid + 1; &#125; left = start; start = 0, end = nums.size(); while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt; target) end = mid; else start = mid + 1; &#125; right = start; return left == right ? vector&lt;int&gt; &#123;-1,-1&#125; : vector&lt;int&gt; &#123;left,right-1&#125;;&#125; python 56ms, 46.67%, June.22th, 2016 https://leetcode.com/discuss/18242/clean-iterative-solution-binary-searches-with-explanation 123456789101112131415161718192021222324252627282930class Solution(object): def searchRange(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; l, r = 0, len(nums) - 1 res = [-1, -1] while(l &lt; r): mid = (l + r) / 2 if nums[mid] &lt; target: l = mid + 1 else: r = mid if nums[l] != target: return res else: res[0] = l r = len(nums) - 1 while(l &lt; r): mid = (l + r) / 2 + 1 if nums[mid] &gt; target: r = mid - 1 else: l = mid res[1] = r return res 52ms, 65.78%, June.22th, 2016 https://leetcode.com/discuss/18242/clean-iterative-solution-binary-searches-with-explanation 123456789101112131415161718192021222324252627282930313233class Solution(object): def searchRange(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; if not nums: return [-1, -1] l, r = 0, len(nums) - 1 res = [-1, -1] while(l &lt; r): mid = (l + r) / 2 if nums[mid] &lt; target: l = mid + 1 else: r = mid if nums[l] != target: return res else: res[0] = l r = len(nums) - 1 while(l &lt; r): mid = (l + r) / 2 + 1 if nums[mid] &gt; target: r = mid - 1 else: l = mid res[1] = r return res https://discuss.leetcode.com/topic/16486/9-11-lines-o-log-n 9-11 lines O(log n) Solution 1 : Divide and Conquer with early breaks : 56 ms The O(log n) time isnâ€™t quite obvious, so Iâ€™ll explain it below. Or you can take the challenge and prove it yourself :-) 12345678910def searchRange(self, nums, target): def search(lo, hi): if nums[lo] == target == nums[hi]: return [lo, hi] if nums[lo] &lt;= target &lt;= nums[hi]: mid = (lo + hi) / 2 l, r = search(lo, mid), search(mid+1, hi) return max(l, r) if -1 in l+r else [l[0], r[1]] return [-1, -1] return search(0, len(nums)-1) The search helper function returns an index range just like the requested searchRange function, but only searches in nums[lo..hi]. It first compares the end points and immediately returns [lo, hi] if that whole part of nums is full of target, and immediately returns [-1, -1] if target is outside the range. The interesting case is when target can be in the range but doesnâ€™t fill it completely. In that case, we split the range in left and right half, solve them recursively, and combine their results appropriately. Why doesnâ€™t this explode exponentially? Well, letâ€™s call the numbers in the left half A, â€¦, B and the numbers in the right half C, â€¦, D. Now if one of them immediately return their [lo, hi] or [-1, -1], then this doesnâ€™t explode. And if neither immediately returns, that means we have A &lt;= target &lt;= B and C &lt;= target &lt;= D. And since nums is sorted, we actually have target &lt;= B &lt;= C &lt;= target, so B = C = target. The left half thus ends with target and the right half starts with it. I highlight that because itâ€™s important. Now consider what happens further. The left half gets halved again. Call the middle elements a and b, so the left half is A, â€¦, a, b, â€¦, B. Then a &lt;= target and: If a &lt; target, then the call analyzing A, â€¦, a immediately returns [-1, -1] and we only look further into b, â€¦, B which is again a part that ends with target. If a == target, then a = b = â€¦ = B = target and thus the call analyzing b, â€¦, B immediately returns its [lo, hi] and we only look further into A, â€¦, a which is again a part that ends with target.Same for the right half C, â€¦, D. So in the beginning of the search, as long as target is only in at most one of the two halves (so the other immediately stops), we have a single path. And if we ever come across the case where target is in both halves, then we split into two paths, but then each of those remains a single path. And both paths are only O(log n) long, so we have overall runtime O(log n). This is btw based on us917â€™s solution. 1234567891011121314Solution 2 : Two binary searches : 56 msdef searchRange(self, nums, target): def search(n): lo, hi = 0, len(nums) while lo &lt; hi: mid = (lo + hi) / 2 if nums[mid] &gt;= n: hi = mid else: lo = mid + 1 return lo lo = search(target) return [lo, search(target+1)-1] if target in nums[lo:lo+1] else [-1, -1] Here, my helper function is a simple binary search, telling me the first index where I could insert a number n into nums to keep it sorted. Thus, if nums contains target, I can find the first occurrence with search(target). I do that, and if target isnâ€™t actually there, then I return [-1, -1]. Otherwise, I ask search(target+1), which tells me the first index where I could insert target+1, which of course is one index behind the last index containing target, so all I have left to do is subtract 1. Solution 3 : Two binary searches, using the library Binary search is so good and common that many languages have it in their standard library and you just need to figure out how to apply it to the problem at hand. Python: 123def searchRange(self, nums, target): lo = bisect.bisect_left(nums, target) return [lo, bisect.bisect(nums, target)-1] if target in nums[lo:lo+1] else [-1, -1] C++: 123456vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; auto bounds = equal_range(nums.begin(), nums.end(), target); return *bounds.first != target ? vector&lt;int&gt; &#123;-1, -1&#125; : vector&lt;int&gt; &#123;bounds.first - nums.begin(), bounds.second - nums.begin() - 1&#125;;&#125; Or: 1234567vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = lower_bound(nums.begin(), nums.end(), target) - nums.begin(); if (nums[lo] != target) return vector&lt;int&gt; &#123;-1, -1&#125;; int hi = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1; return vector&lt;int&gt; &#123;lo, hi&#125;;&#125; Java: Well, Java decided to be annoying and offer Arrays.binSearch but with â€œIf the array contains multiple elements with the specified value, there is no guarantee which one will be foundâ€. So itâ€™s useless for us. Iâ€™m not good at Java, though, so maybe Iâ€™m overlooking a way to still make it work. If you manage to do so, please let me know. java https://discuss.leetcode.com/topic/6327/a-very-simple-java-solution-with-only-one-binary-search-algorithm/2 A very simple Java solution, with only one binary search algorithm 12345678910111213141516171819202122232425262728public class Solution &#123; public int[] searchRange(int[] A, int target) &#123; int start = Solution.firstGreaterEqual(A, target); if (start == A.length || A[start] != target) &#123; return new int[]&#123;-1, -1&#125;; &#125; return new int[]&#123;start, Solution.firstGreaterEqual(A, target + 1) - 1&#125;; &#125; //find the first number that is greater than or equal to target. //could return A.length if target is greater than A[A.length-1]. //actually this is the same as lower_bound in C++ STL. private static int firstGreaterEqual(int[] A, int target) &#123; int low = 0, high = A.length; while (low &lt; high) &#123; int mid = low + ((high - low) &gt;&gt; 1); //low &lt;= mid &lt; high if (A[mid] &lt; target) &#123; low = mid + 1; &#125; else &#123; //should not be mid-1 when A[mid]==target. //could be mid even if A[mid]&gt;target because mid&lt;high. high = mid; &#125; &#125; return low; &#125;&#125; https://discuss.leetcode.com/topic/10692/simple-and-strict-o-logn-solution-in-java-using-recursion Simple and strict O(logn) solution in Java using recursion 123456789101112131415161718192021222324252627public class Solution &#123; public int[] searchRange(int[] A, int target) &#123; int[] range = &#123;A.length, -1&#125;; searchRange(A, target, 0, A.length - 1, range); if (range[0] &gt; range[1]) range[0] = -1; return range; &#125; public void searchRange(int[] A, int target, int left, int right, int[] range) &#123; if (left &gt; right) return; int mid = left + (right - left) / 2; if (A[mid] == target) &#123; if (mid &lt; range[0]) &#123; range[0] = mid; searchRange(A, target, left, mid - 1, range); &#125; if (mid &gt; range[1]) &#123; range[1] = mid; searchRange(A, target, mid + 1, right, range); &#125; &#125; else if (A[mid] &lt; target) &#123; searchRange(A, target, mid + 1, right, range); &#125; else &#123; searchRange(A, target, left, mid - 1, range); &#125; &#125;&#125; https://discuss.leetcode.com/topic/21783/easy-java-o-logn-solution Easy java O(logn) solution There must be two indices in the array. Which means, we can just simply apply to binary search twice to find each index of the target element. 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123;public int[] searchRange(int[] nums, int target) &#123; int[] result = new int[2]; result[0] = findFirst(nums, target); result[1] = findLast(nums, target); return result;&#125;private int findFirst(int[] nums, int target)&#123; int idx = -1; int start = 0; int end = nums.length - 1; while(start &lt;= end)&#123; int mid = (start + end) / 2; if(nums[mid] &gt;= target)&#123; end = mid - 1; &#125;else&#123; start = mid + 1; &#125; if(nums[mid] == target) idx = mid; &#125; return idx;&#125;private int findLast(int[] nums, int target)&#123; int idx = -1; int start = 0; int end = nums.length - 1; while(start &lt;= end)&#123; int mid = (start + end) / 2; if(nums[mid] &lt;= target)&#123; start = mid + 1; &#125;else&#123; end = mid - 1; &#125; if(nums[mid] == target) idx = mid; &#125; return idx;&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[033. Search in Rotated Sorted Array]]></title>
    <url>%2Fp%2Ff6d1f394%2F</url>
    <content type="text"><![CDATA[32.1% https://leetcode.com/problems/search-in-rotated-sorted-array/ Suppose a sorted array is rotated at some pivot unknown to you beforehand. 1(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. æ–¹æ³•ä¸€ï¼š äºŒåˆ†æŸ¥æ‰¾ é¢è¯•å¥‡è™Ž360æ›¾é‡åˆ°è¿‡ æˆ‘çš„ä»£ç å®žçŽ°ï¼Œæœ€æ¸…æ™°æœ€æ˜Žäº†ã€‚ ç®€å•æ˜“æ‡‚ã€‚å°±æŒ‰è¿™ä¸ªæ¥äº†ã€‚ è®¾å®šä¸€ä¸ªå·¦indexï¼Œä¸€ä¸ªå³indexã€‚è‚¯å®šè¦ç”¨åˆ°ä¸­é—´çš„indexï¼Œå³midã€‚ åœ¨å¾ªçŽ¯é‡Œé¢ï¼Œé¦–å…ˆç®—å‡ºmidçš„å€¼ï¼Œç„¶åŽå¦‚æžœä¸­é—´å€¼ç­‰äºŽtargetï¼Œè¿”å›žç»“æžœã€‚å¦åˆ™å°±è¦æœç´¢äº†ã€‚ æ€Žä¹ˆæœç´¢å‘¢ï¼Œè¦åˆ†æƒ…å†µè®¨è®ºï¼ŒçŽ°åœ¨æœ‰çš„å€¼æ˜¯leftï¼Œrightï¼Œmid å’Œtargetï¼Œç”¨ä»€ä¹ˆåˆ†å¥½å‘¢ï¼Ÿ ç”¨ä¸ç”¨targetï¼Ÿç­”æ¡ˆæ˜¯ä¸ç”¨ã€‚è¦ç”¨leftå’Œmidè¿™æ ·çš„å€¼æ¥æ¯”è¾ƒï¼Œåˆ¤æ–­å½“å‰æ‰€å¤„çš„çŽ¯å¢ƒï¼Œ å³å·¦åŠéƒ¨åˆ†çš„æƒ…å†µï¼Œçœ‹å·¦è¾¹æ˜¯ä¸Šå‡ï¼Œè¿˜æ˜¯å…ˆä¸Šå‡åŽä»Žæœ€å°å€¼ä¸Šå‡ã€‚ å³è¾¹æ˜¯ä¸Šå‡è¿˜æ˜¯ä»Žæœ€å°å€¼ä¸Šå‡ã€‚ 1234567891011121314151617181920212223242526class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if(n==0) return -1; int left=0, right = n-1; while(left&lt;=right)&#123; int mid = left+(right-left)/2; if(nums[mid]==target) return mid; if(nums[left]&lt;=nums[mid])&#123; // è¿™é‡Œæ˜¯&lt;= è€Œä¸æ˜¯&lt;ï¼Œå› ä¸ºleftå¯èƒ½=midçš„æƒ…å†µï¼Œå¦åˆ™ä¸èƒ½é€šè¿‡ã€‚ if(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid])&#123; right = mid-1; &#125;else&#123; left = mid+1; &#125; &#125;else&#123; if(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right]) left = mid+1; else right = mid-1; &#125; &#125; return -1; &#125;&#125;; æ–¹æ³•äºŒï¼š Revised Binary Search è¿™ç§æ–¹æ³•è¾ƒå¥½ï¼Œæœ€åŽreturnéœ€è¦åˆ¤æ–­ä¸Žtargetçš„å…³ç³» 1234567891011121314151617181920212223public int search(int[] A, int target) &#123; int lo = 0; int hi = A.length - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if (A[mid] == target) return mid; if (A[lo] &lt;= A[mid]) &#123; if (target &gt;= A[lo] &amp;&amp; target &lt; A[mid]) &#123; hi = mid - 1; &#125; else &#123; lo = mid + 1; &#125; &#125; else &#123; if (target &gt; A[mid] &amp;&amp; target &lt;= A[hi]) &#123; lo = mid + 1; &#125; else &#123; hi = mid - 1; &#125; &#125; &#125; return A[lo] == target ? lo : -1;&#125; cpp https://discuss.leetcode.com/topic/7711/revised-binary-search Revised Binary Search 1234567891011121314151617181920212223public int search(int[] A, int target) &#123; int lo = 0; int hi = A.length - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if (A[mid] == target) return mid; if (A[lo] &lt;= A[mid]) &#123; if (target &gt;= A[lo] &amp;&amp; target &lt; A[mid]) &#123; hi = mid - 1; &#125; else &#123; lo = mid + 1; &#125; &#125; else &#123; if (target &gt; A[mid] &amp;&amp; target &lt;= A[hi]) &#123; lo = mid + 1; &#125; else &#123; hi = mid - 1; &#125; &#125; &#125; return A[lo] == target ? lo : -1;&#125; https://discuss.leetcode.com/topic/34491/clever-idea-making-it-simple Clever idea making it simple This very nice idea is from rantos22â€™s solution who sadly only commented â€œYou are not expected to understand that :)â€, which I guess is the reason itâ€™s now itâ€™s hidden among the most downvoted solutions. I present an explanation and a more usual implementation. Explanation Letâ€™s say nums looks like this: [12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] Because itâ€™s not fully sorted, we canâ€™t do normal binary search. But here comes the trick: If target is letâ€™s say 14, then we adjust nums to this, where â€œinfâ€ means infinity:[12, 13, 14, 15, 16, 17, 18, 19, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf] If target is letâ€™s say 7, then we adjust nums to this:[-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] And then we can simply do ordinary binary search. Of course we donâ€™t actually adjust the whole array but instead adjust only on the fly only the elements we look at. And the adjustment is done by comparing both the target and the actual element against nums[0]. Code If nums[mid] and target are â€œon the same sideâ€ of nums[0], we just take nums[mid]. Otherwise we use -infinity or +infinity as needed. 123456789101112131415161718int search(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, hi = nums.size(); while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; double num = (nums[mid] &lt; nums[0]) == (target &lt; nums[0]) ? nums[mid] : target &lt; nums[0] ? -INFINITY : INFINITY; if (num &lt; target) lo = mid + 1; else if (num &gt; target) hi = mid; else return mid; &#125; return -1;&#125; python https://discuss.leetcode.com/topic/13096/python-binary-search-solution-o-logn-48ms Python binary search solution - O(logn) - 48ms 123456789101112131415161718192021222324252627class Solution: # @param &#123;integer[]&#125; numss # @param &#123;integer&#125; target # @return &#123;integer&#125; def search(self, nums, target): if not nums: return -1 low, high = 0, len(nums) - 1 while low &lt;= high: mid = (low + high) / 2 if target == nums[mid]: return mid if nums[low] &lt;= nums[mid]: if nums[low] &lt;= target &lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &lt;= target &lt;= nums[high]: low = mid + 1 else: high = mid - 1 return -1 https://discuss.leetcode.com/topic/34467/pretty-short-c-java-ruby-python Pretty short C++/Java/Ruby/Python Explanation below the codes. Python: 123456789def search(self, nums, target): lo, hi = 0, len(nums) - 1 while lo &lt; hi: mid = (lo + hi) / 2 if (nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid]): lo = mid + 1 else: hi = mid return lo if target in nums[lo:lo+1] else -1 Python using bisect: 123456class Solution: def search(self, nums, target): self.__getitem__ = lambda i: \ (nums[0] &lt;= target) ^ (nums[0] &gt; nums[i]) ^ (target &gt; nums[i]) i = bisect.bisect_left(self, True, 0, len(nums)) return i if target in nums[i:i+1] else -1 C++: 1234567891011int search(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, hi = int(nums.size()) - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid])) lo = mid + 1; else hi = mid; &#125; return lo == hi &amp;&amp; nums[lo] == target ? lo : -1;&#125; Java: 1234567891011public int search(int[] nums, int target) &#123; int lo = 0, hi = nums.length - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid])) lo = mid + 1; else hi = mid; &#125; return lo == hi &amp;&amp; nums[lo] == target ? lo : -1;&#125; Explanation My solutions use binary search guided by the following thoughts: Remember the array is sorted, except it might drop at one point. 12345678If nums[0] &lt;= nums[i], then nums[0..i] is sorted (in case of &quot;==&quot; it&apos;s just one element, and in case of &quot;&lt;&quot; there must be a drop elsewhere). So we should keep searching in nums[0..i] if the target lies in this sorted range, i.e., if nums[0] &lt;= target &lt;= nums[i].If nums[i] &lt; nums[0], then nums[0..i] contains a drop, and thus nums[i+1..end] is sorted and lies strictly between nums[i] and nums[0]. So we should keep searching in nums[0..i] if the target doesn&apos;t lie strictly between them, i.e., if target &lt;= nums[i] &lt; nums[0] or nums[i] &lt; nums[0] &lt;= target Those three cases look cyclic: 123nums[0] &lt;= target &lt;= nums[i] target &lt;= nums[i] &lt; nums[0] nums[i] &lt; nums[0] &lt;= target So I have the three checks (nums[0] &lt;= target), (target &lt;= nums[i]) and (nums[i] &lt; nums[0]), and I want to know whether exactly two of them are true. They canâ€™t all be true or all be false (check it), so I just need to distinguish between â€œtwo trueâ€ and â€œone trueâ€. Parity is enough for that, so instead of adding them I xor them, which is a bit shorter and particularly helpful in Java and Ruby, because those donâ€™t let me add booleans but do let me xor them. (Actually while developing this I thought of permutations of nums[0], target and nums[i] and the permutation parity and saw those three checks as representing inversions, but I had trouble putting that into words and now find the above explanation much better. But it helped me get there, so I wanted to mention it here.) java https://discuss.leetcode.com/topic/3538/concise-o-log-n-binary-search-solution Concise O(log N) Binary search solution 1234567891011121314151617181920212223242526class Solution &#123;public: int search(int A[], int n, int target) &#123; int lo=0,hi=n-1; // find the index of the smallest value using binary search. // Loop will terminate since mid &lt; hi, and lo or hi will shrink by at least 1. // Proof by contradiction that mid &lt; hi: if mid==hi, then lo==hi and loop would have been terminated. while(lo&lt;hi)&#123; int mid=(lo+hi)/2; if(A[mid]&gt;A[hi]) lo=mid+1; else hi=mid; &#125; // lo==hi is the index of the smallest value and also the number of places rotated. int rot=lo; lo=0;hi=n-1; // The usual binary search and accounting for rotation. while(lo&lt;=hi)&#123; int mid=(lo+hi)/2; int realmid=(mid+rot)%n; if(A[realmid]==target)return realmid; if(A[realmid]&lt;target)lo=mid+1; else hi=mid-1; &#125; return -1; &#125;&#125;; https://discuss.leetcode.com/topic/16580/java-ac-solution-using-once-binary-search Java AC Solution using once binary search The idea is that when rotating the array, there must be one half of the array that is still in sorted order.For example, 6 7 1 2 3 4 5, the order is disrupted from the point between 7 and 1. So when doing binary search, we can make a judgement that which part is ordered and whether the target is in that range, if yes, continue the search in that half, if not continue in the other half. 1234567891011121314151617181920212223242526public class Solution &#123; public int search(int[] nums, int target) &#123; int start = 0; int end = nums.length - 1; while (start &lt;= end)&#123; int mid = (start + end) / 2; if (nums[mid] == target) return mid; if (nums[start] &lt;= nums[mid])&#123; if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) end = mid - 1; else start = mid + 1; &#125; if (nums[mid] &lt;= nums[end])&#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) start = mid + 1; else end = mid - 1; &#125; &#125; return -1; &#125;&#125; https://discuss.leetcode.com/topic/8889/binary-search-java-solusion-o-log-n Binary Search, Java Solusion. O(log(n)) 1234567891011121314151617181920212223242526public int search(int[] A, int target) &#123; if (A.length == 0) return -1; int L = 0, R = A.length-1; // if (target &lt; A[L] &amp;&amp; target &gt; A[R]) return -1; while (L &lt; R) &#123; int M = (L + R)/2; if (A[M] &lt;= A[R]) &#123; if (target &gt; A[M] &amp;&amp; target &lt;= A[R]) &#123; L = M+1; &#125; else &#123; R = M; &#125; &#125; else &#123; if (target &lt;= A[M] &amp;&amp; target &gt;= A[L]) &#123; R = M; &#125; else &#123; L = M+1; &#125; &#125; &#125; if (A[L] == target) return L; else return -1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[032. Longest Valid Parentheses]]></title>
    <url>%2Fp%2F3f681304%2F</url>
    <content type="text"><![CDATA[23.1% https://leetcode.com/problems/longest-valid-parentheses/ Given a string containing just the characters â€˜(â€˜ and â€˜)â€™, find the length of the longest valid (well-formed) parentheses substring. 12345For &quot;(()&quot;, the longest valid parentheses substring is &quot;()&quot;, which has length = 2.Another example is &quot;)()())&quot;, where the longest valid parentheses substring is &quot;()()&quot;, which has length = 4. æ–¹æ³•ä¸€ï¼š è¿™ç§æ–¹æ³•å¾ˆå·§å¦™ï¼Œç”¨äº†æ ˆï¼Œå¹¶ä¸”æ ˆé‡Œå­˜å‚¨ç´¢å¼•ä½ç½® My O(n) solution using a stack The workflow of the solution is as below. Scan the string from beginning to end. If current character is â€˜(â€˜, push its index to the stack. If current character is â€˜)â€™ and the character at the index of the top of stack is â€˜(â€˜, we just find a matching pair so pop from the stack. Otherwise, we push the index of â€˜)â€™ to the stack. After the scan is done, the stack will only contain the indices of characters which cannot be matched. Then letâ€™s use the opposite side - substring between adjacent indices should be valid parentheses. If the stack is empty, the whole input string is valid. Otherwise, we can scan the stack to get longest valid substring as described in step 3. 123456789101112131415161718192021222324252627282930class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.length(), longest = 0; stack&lt;int&gt; st; for(int i=0; i&lt;n; i++)&#123; if(s[i]==&apos;(&apos;) st.push(i); else&#123; if(!st.empty())&#123; if(s[st.top()]==&apos;(&apos;) st.pop(); else st.push(i); &#125; else st.push(i); &#125; &#125; if(st.empty()) longest = n; else&#123; int a=n, b=0; while(!st.empty())&#123; b = st.top(); st.pop(); longest = max(longest, a-b-1); a = b; &#125; longest = max(longest, a); &#125; return longest; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°: 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.size(); if(n==0) return 0; // å¯¹äºŽå­—ç¬¦ä¸²ï¼Œstackå¯ä»¥ä¿å­˜å…·ä½“çš„å­—ç¬¦ï¼Œä¹Ÿå¯ä»¥ä¿å­˜index // ä¿å­˜indexå°±æ˜¯ä¸€ç§å¸¸è§çš„æ“ä½œï¼Œæœ¬å¤„å°±æ˜¯ä¿å­˜çš„index stack&lt;int&gt; stack; for(int i=0; i&lt;n; i++)&#123; if(s[i]=='(') stack.push(i); else&#123; if(!stack.empty() &amp;&amp; s[stack.top()]=='(') stack.pop(); else stack.push(i); &#125; &#125; if(stack.empty()) return n; int start = 0, end = n, res = 0; while(!stack.empty())&#123; start = stack.top(); // åˆ«å¿˜äº†å°†stackçš„å€¼ç»™popå‡ºåŽ» stack.pop(); res = max(res, end-start-1); end = start; &#125; // ä¸é‡ä¸æ¼ï¼Œ è¿™ä¸€æ­¥è¦è€ƒè™‘å‘¨å…¨ res = max(res, start); return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°äºŒ: å¯¹ä¸Šé¢çš„ä»£ç ä¼˜åŒ–äº†ä¸€ä¸‹ 12345678910111213141516171819202122232425262728class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.size(); if(n==0) return 0; // å¯¹äºŽå­—ç¬¦ä¸²ï¼Œstackå¯ä»¥ä¿å­˜å…·ä½“çš„å­—ç¬¦ï¼Œä¹Ÿå¯ä»¥ä¿å­˜index // ä¿å­˜indexå°±æ˜¯ä¸€ç§å¸¸è§çš„æ“ä½œï¼Œæœ¬å¤„å°±æ˜¯ä¿å­˜çš„index stack&lt;int&gt; stack; for(int i=0; i&lt;n; i++)&#123; if(s[i]==')' &amp;&amp; !stack.empty() &amp;&amp; s[stack.top()]=='(') stack.pop(); else stack.push(i); &#125; if(stack.empty()) return n; int start = 0, end = n, res = 0; while(!stack.empty())&#123; start = stack.top(); // åˆ«å¿˜äº†å°†stackçš„å€¼ç»™popå‡ºåŽ» stack.pop(); res = max(res, end-start-1); end = start; &#125; // ä¸é‡ä¸æ¼ï¼Œ è¿™ä¸€æ­¥è¦è€ƒè™‘å‘¨å…¨ res = max(res, start); return res; &#125;&#125;; cpp September 22, 2016 https://discuss.leetcode.com/topic/2289/my-o-n-solution-using-a-stack My O(n) solution using a stack The workflow of the solution is as below. Scan the string from beginning to end. If current character is â€˜(â€˜, push its index to the stack. If current character is â€˜)â€™ and the character at the index of the top of stack is â€˜(â€˜, we just find a matching pair so pop from the stack. Otherwise, we push the index of â€˜)â€™ to the stack. After the scan is done, the stack will only contain the indices of characters which cannot be matched. Then letâ€™s use the opposite side - substring between adjacent indices should be valid parentheses. If the stack is empty, the whole input string is valid. Otherwise, we can scan the stack to get longest valid substring as described in step 3.123456789101112131415161718192021222324252627282930class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.length(), longest = 0; stack&lt;int&gt; st; for(int i=0; i&lt;n; i++)&#123; if(s[i]==&apos;(&apos;) st.push(i); else&#123; if(!st.empty())&#123; if(s[st.top()]==&apos;(&apos;) st.pop(); else st.push(i); &#125; else st.push(i); &#125; &#125; if(st.empty()) longest = n; else&#123; int a=n, b=0; while(!st.empty())&#123; b = st.top(); st.pop(); longest = max(longest, a-b-1); a = b; &#125; longest = max(longest, a); &#125; return longest; &#125;&#125;; https://discuss.leetcode.com/topic/2426/my-dp-o-n-solution-without-using-stack My DP, O(n) solution without using stack My solution uses DP. The main idea is as follows: I construct a array longest[], for any longest[i], it stores the longest length of valid parentheses which is end at i. And the DP idea is : If s[i] is â€˜(â€˜, set longest[i] to 0,because any string end with â€˜(â€˜ cannot be a valid one. Else if s[i] is â€˜)â€™ If s[i-1] is &apos;(&apos;, longest[i] = longest[i-2] + 2 Else if s[i-1] is &apos;)&apos; and s[i-longest[i-1]-1] == &apos;(&apos;, longest[i] = longest[i-1] + 2 + longest[i-longest[i-1]-2] For example, input â€œ()(())â€, at i = 5, longest array is [0,2,0,0,2,0], longest[5] = longest[4] + 2 + longest[1] = 6. 123456789101112131415161718192021int longestValidParentheses(string s) &#123; if(s.length() &lt;= 1) return 0; int curMax = 0; vector&lt;int&gt; longest(s.size(),0); for(int i=1; i &lt; s.length(); i++)&#123; if(s[i] == &apos;)&apos;)&#123; if(s[i-1] == &apos;(&apos;)&#123; longest[i] = (i-2) &gt;= 0 ? (longest[i-2] + 2) : 2; curMax = max(longest[i],curMax); &#125; else&#123; // if s[i-1] == &apos;)&apos;, combine the previous length. if(i-longest[i-1]-1 &gt;= 0 &amp;&amp; s[i-longest[i-1]-1] == &apos;(&apos;)&#123; longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 &gt;= 0)?longest[i-longest[i-1]-2]:0); curMax = max(longest[i],curMax); &#125; &#125; &#125; //else if s[i] == &apos;(&apos;, skip it, because longest[i] must be 0 &#125; return curMax; &#125; Updated: thanks to Philip0116, I have a more concise solution(though this is not as readable as the above one, but concise): 123456789101112int longestValidParentheses(string s) &#123; if(s.length() &lt;= 1) return 0; int curMax = 0; vector&lt;int&gt; longest(s.size(),0); for(int i=1; i &lt; s.length(); i++)&#123; if(s[i] == &apos;)&apos; &amp;&amp; i-longest[i-1]-1 &gt;= 0 &amp;&amp; s[i-longest[i-1]-1] == &apos;(&apos;)&#123; longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 &gt;= 0)?longest[i-longest[i-1]-2]:0); curMax = max(longest[i],curMax); &#125; &#125; return curMax; &#125; https://discuss.leetcode.com/topic/14690/my-simple-8ms-c-code My simple 8ms C++ code 1234567891011121314151617181920class Solution &#123;public: int longestValidParentheses(string s) &#123; stack&lt;int&gt; stk; stk.push(-1); int maxL=0; for(int i=0;i&lt;s.size();i++) &#123; int t=stk.top(); if(t!=-1&amp;&amp;s[i]==&apos;)&apos;&amp;&amp;s[t]==&apos;(&apos;) &#123; stk.pop(); maxL=max(maxL,i-stk.top()); &#125; else stk.push(i); &#125; return maxL; &#125;&#125;; https://discuss.leetcode.com/topic/2745/my-solution-using-one-stack-in-one-pass My solution using one stack in one pass Since any valid parentheses sequence starts from a â€˜(â€˜ and ends at â€˜)â€™, we can calculate new length when we meet a â€˜)â€™. The key is to use a stack to store all the indices and the start position is always the one on top of the stack. See the code below for details. 12345678910111213141516171819202122// Using a stack. One passint longestValidParentheses(string s) &#123; vector&lt;int&gt; stack; int maxLen = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] == &apos;(&apos;) stack.push_back(i); else &#123; if (!stack.empty() &amp;&amp; s[stack.back()] == &apos;(&apos;) &#123; stack.pop_back(); int lastPos = -1; if (!stack.empty()) lastPos = stack.back(); int curLen = i - lastPos; maxLen = (maxLen &lt; curLen) ? curLen : maxLen; &#125; else stack.push_back(i); &#125; &#125; return maxLen;&#125; https://discuss.leetcode.com/topic/22287/constant-space-o-n-time-with-forward-and-backward-pass Constant space, O(n) time with forward and backward pass When right parentheses are more than left parentheses in the forward pass, we can discard previous parentheses. In the backward pass, when left parentheses are more than right parentheses, we can discard previous parentheses. 123456789101112131415161718192021222324252627282930313233343536373839404142434445int longestValidParentheses(string s) &#123; int longest = 0; int extra=0; int length=0; for(int i=0; i&lt;s.size(); i++) &#123; if(s[i] == &apos;(&apos;) &#123; extra++; length++; &#125; else &#123; if(extra&gt;0) &#123; extra--; length++; if(extra == 0) longest = max(longest, length); &#125; else &#123; extra = 0; length=0; &#125; &#125; &#125; length = 0; extra=0; for(int i=s.size()-1; i&gt;=0; i--) &#123; if(s[i] == &apos;)&apos;) &#123; extra++; length++; &#125; else &#123; if(extra&gt;0)&#123; extra--; length++; if(extra == 0) longest = max(longest, length); &#125; else &#123; extra = 0; length=0; &#125; &#125; &#125; return longest;&#125; python https://discuss.leetcode.com/topic/23559/pure-1d-dp-without-using-stack-python-with-detailed-explanation Pure 1D-DP without using stack (python) with detailed explanation 123456789101112131415161718192021222324252627class Solution(object): def longestValidParentheses(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; # use 1D DP # dp[i] records the longestValidParenthese EXACTLY ENDING at s[i] dp = [0 for x in xrange(len(s))] max_to_now = 0 for i in xrange(1,len(s)): if s[i] == &apos;)&apos;: # case 1: ()() if s[i-1] == &apos;(&apos;: # add nearest parentheses pairs + 2 dp[i] = dp[i-2] + 2 # case 2: (()) # i-dp[i-1]-1 is the index of last &quot;(&quot; not paired until this &quot;)&quot; elif i-dp[i-1]-1 &gt;= 0 and s[i-dp[i-1]-1] == &apos;(&apos;: if dp[i-1] &gt; 0: # content within current matching pair is valid # add nearest parentheses pairs + 2 + parentheses before last &quot;(&quot; dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2] else: # otherwise is 0 dp[i] = 0 max_to_now = max(max_to_now, dp[i]) return max_to_now java https://discuss.leetcode.com/topic/7234/simple-java-solution-o-n-time-one-stack Simple JAVA solution, O(n) time, one stack 12345678910111213141516171819public class Solution &#123; public int longestValidParentheses(String s) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int max=0; int left = -1; for(int j=0;j&lt;s.length();j++)&#123; if(s.charAt(j)==&apos;(&apos;) stack.push(j); else &#123; if (stack.isEmpty()) left=j; else&#123; stack.pop(); if(stack.isEmpty()) max=Math.max(max,j-left); else max=Math.max(max,j-stack.peek()); &#125; &#125; &#125; return max; &#125;&#125; https://discuss.leetcode.com/topic/7234/simple-java-solution-o-n-time-one-stack/3 Nice solution! Inspired by your solution. I changed a little to make it shorter and easier. 12345678910111213141516public class Solution &#123; public int longestValidParentheses(String s) &#123; LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); int result = 0; stack.push(-1); for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == &apos;)&apos; &amp;&amp; stack.size() &gt; 1 &amp;&amp; s.charAt(stack.peek()) == &apos;(&apos;) &#123; stack.pop(); result = Math.max(result, i - stack.peek()); &#125; else &#123; stack.push(i); &#125; &#125; return result; &#125;&#125; The idea is simple, we only update the result (max) when we find a â€œpairâ€. If we find a pair. We throw this pair away and see how big the gap is between current and previous invalid. EX: â€œ( )( )â€ stack: -1, 0, when we get to index 1 â€œ)â€, the peek is â€œ(â€œ so we pop it out and see whatâ€™s before â€œ(â€œ. In this example itâ€™s -1. So the gap is â€œcurrent_indexâ€ - (-1) = 2. The idea only update the result (max) when we find a â€œpairâ€ and push -1 to stack first covered all edge cases. https://discuss.leetcode.com/topic/37982/my-easy-o-n-java-solution-with-explanation My easy O(n) java solution with explanation 1234567891011121314151617181920212223public class Solution &#123; public int longestValidParentheses(String s) &#123; int res=0; int tep=0; Stack&lt;Integer&gt; s1=new Stack&lt;&gt;(); int data[]=new int[s.length()]; for(int i=0;i&lt;s.length();i++)&#123; char c=s.charAt(i); if(c==&apos;(&apos;) s1.push(i); else&#123; if(!s1.empty())&#123; data[i]=1; data[s1.pop()]=1; &#125; &#125; &#125; for(int i:data)&#123; if(i==1) tep++; else &#123;res=Math.max(tep,res);tep=0;&#125; &#125; return Math.max(tep,res); &#125;&#125; Imaging we are coloring the original string, each substring that has valid parentheses is colored with â€˜1â€™ and other characters are colored by â€˜0â€™. For example â€œ( ) ( ( ) â€œwould become â€œ11011â€. Thus, the problem has converted to finding the longest subsequence that all elements are â€˜1â€™, which could be easily solved. https://discuss.leetcode.com/topic/8305/simple-java-solution Simple Java solution. 123456789101112131415public int longestValidParentheses(String s) &#123; char[] S = s.toCharArray(); int[] V = new int[S.length]; int open = 0; int max = 0; for (int i=0; i&lt;S.length; i++) &#123; if (S[i] == &apos;(&apos;) open++; if (S[i] == &apos;)&apos; &amp;&amp; open &gt; 0) &#123; V[i] = 2 + V[i-1] + (i-2-V[i-1] &gt; 0 ? V[i-2-V[i-1]] : 0); open--; &#125; if (V[i] &gt; max) max = V[i]; &#125; return max;&#125; https://discuss.leetcode.com/topic/12200/explaining-solution-using-stack Explaining solution using Stack I have seen a lot of good answers but it is not immediately clear how they are achieving the result. I am going to make an attempt to explain my solution using a stack. Every time we encounter â€˜(â€˜ we push the index onto the stack and when we encounter â€˜)â€™ we pop the stack and use the current index minus the index at the top of the stack to be the current_length. we check against the max found so far and update if needed. Here is the code 1234567891011121314151617181920212223242526272829303132333435public static int longestValidParentheses(String s) &#123; Stack&lt;Integer&gt; bracketStack = new Stack&lt;Integer&gt;(); int max_len=0; int current_len=0; int last = -1; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == &apos;(&apos;) &#123; bracketStack.push(i); &#125; else&#123; if(!bracketStack.isEmpty()) &#123; bracketStack.pop(); if(!bracketStack.isEmpty()) current_len = i-bracketStack.peek(); else current_len=i-last; max_len = Math.max(max_len,current_len); &#125; else&#123; last = i; &#125; &#125; &#125; return max_len; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[031. Next Permutation]]></title>
    <url>%2Fp%2F3f16d422%2F</url>
    <content type="text"><![CDATA[28.8% https://leetcode.com/problems/next-permutation/ Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. 12345Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.1,2,3 â†’ 1,3,23,2,1 â†’ 1,2,31,1,5 â†’ 1,5,1 æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°: 123456789101112131415161718192021222324252627class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return; int left = n-2; while(left&gt;=0)&#123; if(nums[left]&lt;nums[left+1]) break; left--; &#125; if(left&lt;0)&#123; reverse(nums.begin(), nums.end()); return; &#125; int right = n - 1; while(right&gt;=0)&#123; if(nums[right]&gt;nums[left]) break; right--; &#125; swap(nums[left], nums[right]); reverse(nums.begin()+left+1, nums.end()); return; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°: 1234567891011121314151617181920212223242526class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==1) return; int i = n-2; while(i&gt;=0)&#123; if(nums[i+1]&gt;nums[i]) break; i--; &#125; if(i&lt;0)&#123; reverse(nums.begin(), nums.end()); return; &#125; int j = n-1; while(j&gt;0)&#123; if(nums[j]&gt;nums[i]) break; j--; &#125; swap(nums[i], nums[j]); reverse(nums.begin()+i+1, nums.end()); return; &#125;&#125;; æˆç†Ÿçš„è§£æ³• ç¬¬ä¸€æ­¥ï¼Œä»ŽåŽå‘å‰ï¼Œæ‰¾åˆ°ä¸€ä¸ªindex kï¼Œkæ˜¯ç¬¬ä¸€ä¸ªæ»¡è¶³å½“å‰èŠ‚ç‚¹å€¼å¤§äºŽä¸‹ä¸€ä¸ªç‚¹çš„å€¼ã€‚ å°±æ˜¯è¯´åŽé¢çš„éƒ½æ˜¯é€’å‡çš„ã€‚ (å¦‚æžœæ‰¾ä¸åˆ°ï¼Œè¯´æ˜Žå·²ç»æ˜¯æœ€å¤§çš„æ•°ç»„äº†ï¼Œè€Œä¸”éƒ½æ˜¯é€†åºï¼Œåè½¬è¿”å›žå³å¯) ç¬¬äºŒæ­¥ï¼Œä»ŽåŽå‘å‰æ‰¾ï¼Œæ‰¾åˆ°ä¸€ä¸ªindex lï¼Œlæ˜¯nums[l] &gt; nums[k]ï¼Œä¹Ÿå°±æ˜¯læ˜¯å¤§äºŽnums[k]çš„æœ€å¤§ç´¢å¼•ã€‚ ç¬¬ä¸‰æ­¥ï¼Œäº¤æ¢lå’Œkå¯¹åº”çš„å€¼ ç¬¬å››æ­¥ï¼ŒæŠŠä»Žk+1å¼€å§‹åˆ°numsæœ«å°¾çš„æ•°ç»„ï¼Œè¿›è¡Œåè½¬reverseã€‚ A simple algorithm from Wikipedia with C++ implementation (can be used in Permutations and Permutations II) Well, in fact the problem of next permutation has been studied long ago. From the Wikipedia page, in the 14th century, a man named Narayana Pandita gives the following classic and yet quite simple algorithm (with minor modifications in notations to fit the problem statement): Find the largest index k such that nums[k] &lt; nums[k + 1]. If no such index exists, the permutation is sorted in descending order, just reverse it to ascending order and we are done. For example, the next permutation of [3, 2, 1] is [1, 2, 3]. Find the largest index l greater than k such that nums[k] &lt; nums[l]. Swap the value of nums[k] with that of nums[l]. Reverse the sequence from nums[k + 1] up to and including the final element nums[nums.size() - 1]. Quite simple, yeah? Now comes the following code, which is barely a translation. Well, a final note here, the above algorithm is indeed powerful â€” it can handle the cases of duplicates! If you have tried the problems Permutations and Permutations II, then the following function is also useful. Both of Permutations and Permutations II can be solved easily using this function. Hints: sort nums in ascending order, add it to the result of all permutations and then repeatedly generate the next permutation and add it â€¦ until we get back to the original sorted condition. If you want to learn more, please visit this solution and that solution. 123456789101112131415161718192021222324class Solution &#123; void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int k = -1; for (int i = nums.size() - 2; i &gt;= 0; i--) &#123; if (nums[i] &lt; nums[i + 1]) &#123; k = i; break; &#125; &#125; if (k == -1) &#123; reverse(nums.begin(), nums.end()); return; &#125; int l = -1; for (int i = nums.size() - 1; i &gt; k; i--) &#123; if (nums[i] &gt; nums[k]) &#123; l = i; break; &#125; &#125; swap(nums[k], nums[l]); reverse(nums.begin() + k + 1, nums.end()); &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return; int left = -1; for(int i=n-2; i&gt;=0; i--) if(nums[i]&lt;nums[i+1])&#123; left = i; break; // breakä¸èƒ½å¿˜ &#125; if(left == -1)&#123; reverse(nums.begin(), nums.end()); return; &#125; int right; for(int j=n-1; j&gt;left; j--) if(nums[j]&gt;nums[left])&#123; right = j; break; // breakä¸èƒ½å¿˜ &#125; swap(nums[left], nums[right]); reverse(nums.begin()+left+1, nums.end()); return; &#125;&#125;; cpp https://discuss.leetcode.com/topic/15216/a-simple-algorithm-from-wikipedia-with-c-implementation-can-be-used-in-permutations-and-permutations-ii A simple algorithm from Wikipedia with C++ implementation (can be used in Permutations and Permutations II) Well, in fact the problem of next permutation has been studied long ago. From the Wikipedia page, in the 14th century, a man named Narayana Pandita gives the following classic and yet quite simple algorithm (with minor modifications in notations to fit the problem statement): Find the largest index k such that nums[k] &lt; nums[k + 1]. If no such index exists, the permutation is sorted in descending order, just reverse it to ascending order and we are done. For example, the next permutation of [3, 2, 1] is [1, 2, 3]. Find the largest index l greater than k such that nums[k] &lt; nums[l]. Swap the value of nums[k] with that of nums[l]. Reverse the sequence from nums[k + 1] up to and including the final element nums[nums.size() - 1]. Quite simple, yeah? Now comes the following code, which is barely a translation. Well, a final note here, the above algorithm is indeed powerful â€” it can handle the cases of duplicates! If you have tried the problems Permutations and Permutations II, then the following function is also useful. Both of Permutations and Permutations II can be solved easily using this function. Hints: sort nums in ascending order, add it to the result of all permutations and then repeatedly generate the next permutation and add it â€¦ until we get back to the original sorted condition. If you want to learn more, please visit this solution and that solution. 123456789101112131415161718192021222324class Solution &#123; void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int k = -1; for (int i = nums.size() - 2; i &gt;= 0; i--) &#123; if (nums[i] &lt; nums[i + 1]) &#123; k = i; break; &#125; &#125; if (k == -1) &#123; reverse(nums.begin(), nums.end()); return; &#125; int l = -1; for (int i = nums.size() - 1; i &gt; k; i--) &#123; if (nums[i] &gt; nums[k]) &#123; l = i; break; &#125; &#125; swap(nums[k], nums[l]); reverse(nums.begin() + k + 1, nums.end()); &#125;&#125;; https://discuss.leetcode.com/topic/8508/9-lines-of-c-code-with-comments 9 Lines of C++ code with Comments 1234567891011121314151617181920212223class Solution &#123;public: void nextPermutation(vector&lt;int&gt; &amp;num) &#123; if (num.empty()) return; // in reverse order, find the first number which is in increasing trend (we call it violated number here) int i; for (i = num.size()-2; i &gt;= 0; --i) &#123; if (num[i] &lt; num[i+1]) break; &#125; // reverse all the numbers after violated number reverse(begin(num)+i+1, end(num)); // if violated number not found, because we have reversed the whole array, then we are done! if (i == -1) return; // else binary search find the first number larger than the violated number auto itr = upper_bound(begin(num)+i+1, end(num), num[i]); // swap them, done! swap(num[i], *itr); &#125;&#125;; You might need to think for a while why this would work. https://discuss.leetcode.com/topic/19264/1-4-11-lines-c 1, 4, 11 lines C++ Solution 1 Just for info: Thereâ€™s a library function that does the job, even going from totally reverse sorted to sorted: 123void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; next_permutation(begin(nums), end(nums));&#125; Solution 2 Using library functions for all building blocks of the algorithm. Very nice how they all play together, notice the total lack of +1/-1, it all fits exactly. 123456void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; auto i = is_sorted_until(nums.rbegin(), nums.rend()); if (i != nums.rend()) swap(*i, *upper_bound(nums.rbegin(), i, *i)); reverse(nums.rbegin(), i);&#125; Solution 3 Doing it all on my own (except swap, letâ€™s not be silly): 12345678910111213void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int i = nums.size() - 1, k = i; while (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i]) i--; for (int j=i; j&lt;k; j++, k--) swap(nums[j], nums[k]); if (i &gt; 0) &#123; k = i--; while (nums[k] &lt;= nums[i]) k++; swap(nums[i], nums[k]); &#125;&#125; Solution 4 Ok, letâ€™s be silly after all and not even use swap :-) 12345678910111213void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int i = nums.size() - 1, k = i, tmp; while (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i]) i--; for (int j=i; j&lt;k; j++, k--) tmp = nums[j], nums[j] = nums[k], nums[k] = tmp; if (i &gt; 0) &#123; k = i--; while (nums[k] &lt;= nums[i]) k++; tmp = nums[i], nums[i] = nums[k], nums[k] = tmp; &#125;&#125; https://discuss.leetcode.com/topic/7138/sharing-my-really-simple-solution-with-explanation Sharing my really simple solution with explanation 123456789101112131415161718void nextPermutation(vector&lt;int&gt; &amp;num) &#123; for(int i = num.size() - 2; i &gt;= 0; i--)&#123; if(num[i] &lt; num[i + 1])&#123; int pos; int diff = INT_MAX; for(int j = i + 1; j &lt; num.size(); j++)&#123; if(num[j] &gt; num[i] &amp;&amp; abs(num[i] - num[j]) &lt; diff)&#123; diff = abs(num[i] - num[j]); pos = j; &#125; &#125; swap(num[i], num[pos]); sort(num.begin() + i + 1, num.end()); return; &#125; &#125; sort(num.begin(), num.end());&#125; For this problem, coding is not a big deal. Algorithm is! Now letâ€™s pick a number, for example, 24387651. what is the next permutation? 24513678. How can I get the answer? First step: find the first ascending digit from the back of the number. 3 &lt; 8 &gt; 7 &gt; 6 &gt; 5 &gt; 1. Then 3 is the digit. Second step: swap that digit with the next big digit in following digits. Which one is the next big digit in 87651? 5! So swap them. Now the number becomes 24587631. Third step: sort 87631 into 13678. The final answer is 24513678. 12ms, 10.84%, April.23rd, 2016 https://github.com/haoel/leetcode/blob/master/algorithms/cpp/nextPermutation/nextPermutation.cpp 123456789101112131415161718192021222324252627282930313233343536373839/* * Take a look the following continuous permutation, can you find the patern? * * 1 2 3 4 * 1 2 4 3 * 1 3 2 4 * 1 3 4 2 * 1 4 2 3 * 1 4 3 2 * 2 1 3 4 * ... * * The pattern can be descripted as below: * * 1) from n-1 to 0, find the first place [i-1] which num[i-1] &lt; num[i] * 2) from n-1 to i, find the first number from n-1 to i which &gt;= num[i-1] * 3) swap the 2) num with the num[i-1] * 4) sort the sub-array [i, n) //actuall sort is fine as well * * For example: * * 1 4 3 2 &lt;-- 1) find the first place which num[i-1] &lt; num[i] * ^ * * 1 4 3 2 &lt;-- 2) find the first number from n-1 to i which &gt;= num[i-1] * ^ ^ * * 2 4 3 1 &lt;-- 3) swap them * ^ ^ * * 2 4 3 1 &lt;-- 4) sort * ^ ^ * * 2 1 3 4 * * Edge Case: * * 4 3 2 1, the next permutation is 1 2 3 4 */ 12345678910111213141516171819202122class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt;= 1) return; for(int i = nums.size() - 1; i &gt; 0; i--)&#123; if(nums[i-1] &lt; nums[i])&#123; int j = nums.size() - 1; while(nums[i-1] &gt;= nums[j]) j--; int tmp = nums[j]; nums[j] = nums[i-1]; nums[i-1] = tmp; reverse(nums.begin()+i, nums.end()); return; &#125; if(i == 1)&#123; reverse(nums.begin(), nums.end()); return; &#125; &#125; &#125;&#125;; 12ms, 10.84%, April.23rd, 2016 http://blog.csdn.net/m6830098/article/details/17291259 123456class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; next_permutation(nums.begin(), nums.end()); &#125;&#125;; python https://discuss.leetcode.com/topic/52275/easy-python-solution-based-on-lexicographical-permutation-algorithm Easy python solution based on lexicographical permutation algorithm For the detailed algorithm and demonstration, please go to https://www.nayuki.io/page/next-lexicographical-permutation-algorithm The steps are shown in the picture below. 123456789101112131415161718192021222324252627282930class Solution(object): def nextPermutation(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; # find longest non-increasing suffix right = len(nums)-1 while nums[right] &lt;= nums[right-1] and right-1 &gt;=0: right -= 1 if right == 0: return self.reverse(nums,0,len(nums)-1) # find pivot pivot = right-1 successor = 0 # find rightmost succesor for i in range(len(nums)-1,pivot,-1): if nums[i] &gt; nums[pivot]: successor = i break # swap pivot and successor nums[pivot],nums[successor] = nums[successor],nums[pivot] # reverse suffix self.reverse(nums,pivot+1,len(nums)-1) def reverse(self,nums,l,r): while l &lt; r: nums[l],nums[r] = nums[r],nums[l] l += 1 r -= 1 60ms, 77.71%, April.23rd, 2016 https://leetcode.com/discuss/59874/two-pointer-solution-in-python-with-detail-expalanation Two-pointer solution in python with detail expalanation Credit goes to http://blog.csdn.net/m6830098/article/details/17291259 1234567891011121314151617181920212223class Solution(object): def nextPermutation(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; # Use two-pointers: two pointers start from back # first pointer j stop at descending point # second pointer i stop at value &gt; nums[j] # swap and sort rest if not nums: return None i = len(nums)-1 j = -1 # j is set to -1 for case `4321`, so need to reverse all in following step while i &gt; 0: if nums[i-1] &lt; nums[i]: # first one violates the trend j = i-1 break i-=1 for i in xrange(len(nums)-1, -1, -1): if nums[i] &gt; nums[j]: # nums[i], nums[j] = nums[j], nums[i] # swap position nums[j+1:] = sorted(nums[j+1:]) # sort rest return java https://discuss.leetcode.com/topic/2542/share-my-o-n-time-solution Share my O(n) time solution My idea is for an array: Start from its last element, traverse backward to find the first one with index i that satisfy num[i-1] &lt; num[i]. So, elements from num[i] to num[n-1] is reversely sorted. To find the next permutation, we have to swap some numbers at different positions, to minimize the increased amount, we have to make the highest changed position as high as possible. Notice that index larger than or equal to i is not possible as num[i,n-1] is reversely sorted. So, we want to increase the number at index i-1, clearly, swap it with the smallest number between num[i,n-1] that is larger than num[i-1]. For example, original number is 121543321, we want to swap the â€˜1â€™ at position 2 with â€˜2â€™ at position 7. The last step is to make the remaining higher position part as small as possible, we just have to reversely sort the num[i,n-1] The following is my code: 1234567891011121314151617181920212223242526272829303132333435363738394041public void nextPermutation(int[] num) &#123; int n=num.length; if(n&lt;2) return; int index=n-1; while(index&gt;0)&#123; if(num[index-1]&lt;num[index]) break; index--; &#125; if(index==0)&#123; reverseSort(num,0,n-1); return; &#125; else&#123; int val=num[index-1]; int j=n-1; while(j&gt;=index)&#123; if(num[j]&gt;val) break; j--; &#125; swap(num,j,index-1); reverseSort(num,index,n-1); return; &#125;&#125;public void swap(int[] num, int i, int j)&#123; int temp=0; temp=num[i]; num[i]=num[j]; num[j]=temp;&#125;public void reverseSort(int[] num, int start, int end)&#123; if(start&gt;end) return; for(int i=start;i&lt;=(end+start)/2;i++) swap(num,i,start+end-i);&#125; https://discuss.leetcode.com/topic/14124/sharing-my-clean-and-easy-understand-java-code-with-explanation Sharing my clean and easy-understand java code with explanation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public void nextPermutation(int[] nums) &#123; if(nums.length&lt;=1)&#123; return; &#125; int i= nums.length-1; for(;i&gt;=1;i--)&#123; if(nums[i]&gt;nums[i-1])&#123; //find first number which is smaller than it&apos;s after number break; &#125; &#125; if(i!=0)&#123; swap(nums,i-1); //if the number exist,which means that the nums not like&#123;5,4,3,2,1&#125; &#125; reverse(nums,i); &#125; private void swap(int[] a,int i)&#123; for(int j = a.length-1;j&gt;i;j--)&#123; if(a[j]&gt;a[i])&#123; int t = a[j]; a[j] = a[i]; a[i] = t; break; &#125; &#125; &#125; private void reverse(int[] a,int i)&#123;//reverse the number after the number we have found int first = i; int last = a.length-1; while(first&lt;last)&#123; int t = a[first]; a[first] = a[last]; a[last] = t; first ++; last --; &#125; &#125; &#125; åœ¨å½“å‰åºåˆ—ä¸­ï¼Œä»Žå°¾ç«¯å¾€å‰å¯»æ‰¾ä¸¤ä¸ªç›¸é‚»å…ƒç´ ï¼Œå‰ä¸€ä¸ªè®°ä¸ºfirstï¼ŒåŽä¸€ä¸ªè®°ä¸ºsecondï¼Œå¹¶ä¸”æ»¡è¶³first å°äºŽ secondã€‚ç„¶åŽå†ä»Žå°¾ç«¯å¯»æ‰¾å¦ä¸€ä¸ªå…ƒç´ numberï¼Œå¦‚æžœæ»¡è¶³first å°äºŽnumberï¼Œå³å°†ç¬¬firstä¸ªå…ƒç´ ä¸Žnumberå…ƒç´ å¯¹è°ƒï¼Œå¹¶å°†secondå…ƒç´ ä¹‹åŽï¼ˆåŒ…æ‹¬secondï¼‰çš„æ‰€æœ‰å…ƒç´ é¢ å€’æŽ’åºï¼Œå³æ±‚å‡ºä¸‹ä¸€ä¸ªåºåˆ— example: 6ï¼Œ3ï¼Œ4ï¼Œ9ï¼Œ8ï¼Œ7ï¼Œ1 æ­¤æ—¶ first ï¼ 4ï¼Œsecond = 9 ä»Žå°¾å·´åˆ°å‰æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºŽfirstçš„æ•°å­—ï¼Œå°±æ˜¯7 äº¤æ¢4å’Œ7ï¼Œå³ä¸Šé¢çš„swapå‡½æ•°ï¼Œæ­¤æ—¶åºåˆ—å˜æˆ6ï¼Œ3ï¼Œ7ï¼Œ9ï¼Œ8ï¼Œ4ï¼Œ1 å†å°†secondï¼9ä»¥åŠä»¥åŽçš„åºåˆ—é‡æ–°æŽ’åºï¼Œè®©å…¶ä»Žå°åˆ°å¤§æŽ’åºï¼Œä½¿å¾—æ•´ä½“æœ€å°ï¼Œå³reverseä¸€ä¸‹ï¼ˆå› ä¸ºæ­¤æ—¶è‚¯å®šæ˜¯é€’å‡åºåˆ—ï¼‰ å¾—åˆ°æœ€ç»ˆçš„ç»“æžœï¼š6ï¼Œ3ï¼Œ7ï¼Œ1ï¼Œ4ï¼Œ8ï¼Œ9 https://discuss.leetcode.com/topic/30212/easiest-java-solution Easiest JAVA Solution Using a simple example, we can derive the following steps: 123456789101112131415161718192021public void nextPermutation(int[] A) &#123; if(A == null || A.length &lt;= 1) return; int i = A.length - 2; while(i &gt;= 0 &amp;&amp; A[i] &gt;= A[i + 1]) i--; // Find 1st id i that breaks descending order if(i &gt;= 0) &#123; // If not entirely descending int j = A.length - 1; // Start from the end while(A[j] &lt;= A[i]) j--; // Find rightmost first larger id j swap(A, i, j); // Switch i and j &#125; reverse(A, i + 1, A.length - 1); // Reverse the descending sequence&#125;public void swap(int[] A, int i, int j) &#123; int tmp = A[i]; A[i] = A[j]; A[j] = tmp;&#125;public void reverse(int[] A, int i, int j) &#123; while(i &lt; j) swap(A, i++, j--);&#125; https://discuss.leetcode.com/topic/30688/readable-code-without-confusing-i-j-and-with-explanation Readable code without confusing i/j, and with explanation Implementation based on description from Project Nayuki. I cannot describe it better than them: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123;/*0*/ public void nextPermutation(int[] nums) &#123; // pivot is the element just before the non-increasing (weakly decreasing) suffix/*2*/ int pivot = indexOfLastPeak(nums) - 1; // paritions nums into [prefix pivot suffix] if (pivot != -1) &#123; int nextPrefix = lastIndexOfGreater(nums, nums[pivot]); // in the worst case it&apos;s suffix[0] // next prefix must exist because pivot &lt; suffix[0], otherwise pivot would be part of suffix/*4*/ swap(nums, pivot, nextPrefix); // this minimizes the change in prefix &#125;/*5*/ reverseSuffix(nums, pivot + 1); // reverses the whole list if there was no pivot/*6*/ &#125; /** * Find the last element which is a peak. * In case there are multiple equal peaks, return the first of those. * @return first index of last peak *//*1*/ int indexOfLastPeak(int[] nums) &#123; for (int i = nums.length - 1; 0 &lt; i; --i) &#123; if (nums[i - 1] &lt; nums[i]) return i; &#125; return 0; &#125; /** @return last index where the &#123;@code num &gt; threshold&#125; or -1 if not found *//*3*/ int lastIndexOfGreater(int[] nums, int threshold) &#123; for (int i = nums.length - 1; 0 &lt;= i; --i) &#123; if (threshold &lt; nums[i]) return i; &#125; return -1; &#125; /** Reverse numbers starting from an index till the end. */ void reverseSuffix(int[] nums, int start) &#123; int end = nums.length - 1; while (start &lt; end) &#123; swap(nums, start++, end--); &#125; &#125; void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[030. Substring with Concatenation of All Words]]></title>
    <url>%2Fp%2Ff97ee9f9%2F</url>
    <content type="text"><![CDATA[22.0% https://leetcode.com/problems/substring-with-concatenation-of-all-words/ You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. 123456For example, given:s: &quot;barfoothefoobarman&quot;words: [&quot;foo&quot;, &quot;bar&quot;]You should return the indices: [0,9].(order does not matter). ä¸Žé¢˜ç›® 76 ç±»ä¼¼ï¼Œ Minimum Window Substring cpp https://discuss.leetcode.com/topic/6617/an-o-n-solution-with-detailed-explanation An O(N) solution with detailed explanation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// travel all the words combinations to maintain a window// there are wl(word len) times travel// each time, n/wl words, mostly 2 times travel for each word// one left side of the window, the other right side of the window// so, time complexity O(wl * 2 * N/wl) = O(2N)vector&lt;int&gt; findSubstring(string S, vector&lt;string&gt; &amp;L) &#123; vector&lt;int&gt; ans; int n = S.size(), cnt = L.size(); if (n &lt;= 0 || cnt &lt;= 0) return ans; // init word occurence unordered_map&lt;string, int&gt; dict; for (int i = 0; i &lt; cnt; ++i) dict[L[i]]++; // travel all sub string combinations int wl = L[0].size(); for (int i = 0; i &lt; wl; ++i) &#123; int left = i, count = 0; unordered_map&lt;string, int&gt; tdict; for (int j = i; j &lt;= n - wl; j += wl) &#123; string str = S.substr(j, wl); // a valid word, accumulate results if (dict.count(str)) &#123; tdict[str]++; if (tdict[str] &lt;= dict[str]) count++; else &#123; // a more word, advance the window left side possiablly while (tdict[str] &gt; dict[str]) &#123; string str1 = S.substr(left, wl); tdict[str1]--; if (tdict[str1] &lt; dict[str1]) count--; left += wl; &#125; &#125; // come to a result if (count == cnt) &#123; ans.push_back(left); // advance one word tdict[S.substr(left, wl)]--; count--; left += wl; &#125; &#125; // not a valid word, reset all vars else &#123; tdict.clear(); count = 0; left = j + wl; &#125; &#125; &#125; return ans;&#125; 698ms, 47.43%, September 22, 2016 https://discuss.leetcode.com/topic/17943/naive-c-solution-using-two-unordered_map-about-20-lines Naive C++ Solution using two unordered_map (about 20 lines) I think the following code is self-explanatory enough. We use an unordered_map&lt;string, int&gt; counts to record the expected times of each word and another unordered_map&lt;string, int&gt; seen to record the times we have seen. Then we check for every possible position of i. Once we meet an unexpected word or the times of some word is larger than its expected times, we stop the check. If we finish the check successfully, push i to the result indexes. 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; unordered_map&lt;string, int&gt; counts; for(string word:words) counts[word]++; int n = s.length(), num = words.size(), len = words[0].length(); vector&lt;int&gt; indexes; for(int i=0; i&lt;n-num*len+1; i++)&#123; unordered_map&lt;string, int&gt; seen; int j = 0; for(;j&lt;num; j++)&#123; string word = s.substr(i+j*len, len); if(counts.find(word)!=counts.end())&#123; seen[word]++; if(seen[word]&gt;counts[word]) break; &#125; else break; &#125; if(j==num) indexes.push_back(i); &#125; return indexes; &#125;&#125;; https://discuss.leetcode.com/topic/7552/my-ac-c-code-o-n-complexity-26ms My AC c++ code, O(n) complexity, 26ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution &#123;// The general idea:// Construct a hash function f for L, f: vector&lt;string&gt; -&gt; int, // Then use the return value of f to check whether a substring is a concatenation // of all words in L.// f has two levels, the first level is a hash function f1 for every single word in L.// f1 : string -&gt; double// So with f1, L is converted into a vector of float numbers// Then another hash function f2 is defined to convert a vector of doubles into a single int.// Finally f(L) := f2(f1(L))// To obtain lower complexity, we require f1 and f2 can be computed through moving window.// The following corner case also needs to be considered:// f2(f1([&quot;ab&quot;, &quot;cd&quot;])) != f2(f1([&quot;ac&quot;, &quot;bd&quot;]))// There are many possible options for f2 and f1. // The following code only shows one possibility (probably not the best), // f2 is the function &quot;hash&quot; in the class,// f1([a1, a2, ... , an]) := int( decimal_part(log(a1) + log(a2) + ... + log(an)) * 1000000000 )public: // The complexity of this function is O(nW). double hash(double f, double code[], string &amp;word) &#123; double result = 0.; for (auto &amp;c : word) result = result * f + code[c]; return result; &#125; vector&lt;int&gt; findSubstring(string S, vector&lt;string&gt; &amp;L) &#123; uniform_real_distribution&lt;double&gt; unif(0., 1.); default_random_engine seed; double code[128]; for (auto &amp;d : code) d = unif(seed); double f = unif(seed) / 5. + 0.8; double value = 0; // The complexity of the following for loop is O(L.size( ) * nW). for (auto &amp;str : L) value += log(hash(f, code, str)); int unit = 1e9; int key = (value-floor(value))*unit; int nS = S.size(), nL = L.size(), nW = L[0].size(); double fn = pow(f, nW-1.); vector&lt;int&gt; result; if (nS &lt; nW) return result; vector&lt;double&gt; values(nS-nW+1); string word(S.begin(), S.begin()+nW); values[0] = hash(f, code, word); // Use a moving window to hash every word with length nW in S to a float number, // which is stored in vector values[] // The complexity of this step is O(nS). for (int i=1; i&lt;=nS-nW; ++i) values[i] = (values[i-1] - code[S[i-1]]*fn)*f + code[S[i+nW-1]]; // This for loop will run nW times, each iteration has a complexity O(nS/nW) // So the overall complexity is O(nW * (nS / nW)) = O(nS) for (int i=0; i&lt;nW; ++i) &#123; int j0=i, j1=i, k=0; double sum = 0.; // Use a moving window to hash every L.size() continuous words with length nW in S. // This while loop will terminate within nS/nW iterations since the increasement of j1 is nW, // So the complexity of this while loop is O(nS / nW). while(j1&lt;=nS-nW) &#123; sum += log(values[j1]); ++k; j1 += nW; if (k==nL) &#123; int key1 = (sum-floor(sum)) * unit; if (key1==key) result.push_back(j0); sum -= log(values[j0]); --k; j0 += nW; &#125; &#125; &#125; return result; &#125;&#125;; Though theoretically it has a very small chance to fail. python https://discuss.leetcode.com/topic/3018/hash-idea-and-exception-case Hash Idea and exception case The following python code is accepted by OJ. It is based on the following idea (assumption) We know that two multisets consist of same elements and size of the multisets are equal. if sum of hashes of all elements are the same for these multisets -&gt; those multisets are identical This is not true for same very very rare cases. Please describe such a case. 12345678def findSubstring(self, S, L): n = len(L) #num words w = len(L[0]) #length of each word t = n*w # total length hashsum = sum([hash(x) for x in L]) h = [hash(S[i:i+w])*(S[i:i+w] in L) for i in xrange(len(S)-w+1)] return [i for i in xrange(len(S)-t+1) if sum(h[i:i+t:w])==hashsum] https://discuss.leetcode.com/topic/26043/ac-python-80ms-solution-dictionary-and-two-pointers AC Python 80ms solution, dictionary and two pointers 1234567891011121314151617181920212223242526272829303132333435def _findSubstring(self, l, r, n, k, t, s, req, ans): curr = &#123;&#125; while r + k &lt;= n: w = s[r:r + k] r += k if w not in req: l = r curr.clear() else: curr[w] = curr[w] + 1 if w in curr else 1 while curr[w] &gt; req[w]: curr[s[l:l + k]] -= 1 l += k if r - l == t: ans.append(l)def findSubstring(self, s, words): if not s or not words or not words[0]: return [] n = len(s) k = len(words[0]) t = len(words) * k req = &#123;&#125; for w in words: req[w] = req[w] + 1 if w in req else 1 ans = [] for i in xrange(min(k, n - t + 1)): self._findSubstring(i, i, n, k, t, s, req, ans) return ans# 169 / 169 test cases passed.# Status: Accepted# Runtime: 80 ms# 98.60% First of all consider s as several series of words with length k starting at [0, k-1]. For example â€œbarfootheâ€ with k = 3, can be view as [â€œbarâ€, â€œfooâ€, â€œtheâ€] for i=0 and [â€œarfâ€, â€œootâ€] for i = 1 and [â€œrfoâ€, â€œothâ€] for i = 2.Thus we need to check each of these series and find out the valid index by definition. For each series, we just need to check if there exist a range [l, r) where the occurrence or â€œspectrumâ€ of the words in the range is the same as our given word listâ€™s â€œspectrumâ€. We use dictionary to store the spectrum and maintain it as we loop through s. collections.Counter class may save a bit of code on updating the counts of the dictionary. However plain dict wins on the speed. https://discuss.leetcode.com/topic/13630/99ms-python-o-kmn-solution 99ms Python O(kmn) Solution The idea comes from [https://leetcode.com/discuss/20151/an-o-n-solution-with-detailed-explanation] Using a counter and a sliding window, we push the window from left to right, counting the number of valid words in the window. When the number of a word in the window is more than the times it appears in words or we meet a invalid word, push the window. 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution:# @param &#123;string&#125; s# @param &#123;string[]&#125; words# @return &#123;integer[]&#125;def findSubstring(self, s, words): if len(words) == 0: return [] # initialize d, l, ans l = len(words[0]) d = &#123;&#125; for w in words: if w in d: d[w] += 1 else: d[w] = 1 i = 0 ans = [] # sliding window(s) for k in range(l): left = k subd = &#123;&#125; count = 0 for j in xrange(k, len(s)-l+1, l): tword = s[j:j+l] # valid word if tword in d: if tword in subd: subd[tword] += 1 else: subd[tword] = 1 count += 1 while subd[tword] &gt; d[tword]: subd[s[left:left+l]] -= 1 left += l count -= 1 if count == len(words): ans.append(left) # not valid else: left = j + l subd = &#123;&#125; count = 0 return ans Assuming we have k words in words, and there are m substrings in the string, the complexity is O(kmn) because we need to adjust the window when more valid words are found. This solution runs 99ms on OJ. java 180ms, September 22, 2016 https://discuss.leetcode.com/topic/6432/simple-java-solution-with-two-pointers-and-map Simple Java Solution with Two Pointers and Map My idea is pretty simple. Just build a map for the words and their relative count in L. Then we traverse through S to check whether there is a match. 12345678910111213141516171819202122232425262728public class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(s == null || words == null || words.length == 0) return res; int len = words[0].length(); Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); for(String word:words) map.put(word, map.containsKey(word)?map.get(word)+1:1); for(int i=0; i&lt;=s.length()-len*words.length; i++)&#123; Map&lt;String, Integer&gt; copy = new HashMap&lt;String, Integer&gt;(map); for(int j = 0; j&lt;words.length; j++)&#123; String str = s.substring(i+j*len, i+j*len+len); if(copy.containsKey(str))&#123; int count = copy.get(str); if(count == 1) copy.remove(str); else copy.put(str, count-1); if(copy.isEmpty())&#123; res.add(i); break; &#125; &#125; else break; &#125; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/35676/accepted-java-solution-12ms-with-explanation Accepted Java solution 12ms with explanation Itâ€™s not too hard to find some resemblance between this problem and minimum-window-substring. Actually the main difference is the fact that we are interested at some interval length: we want intervals with fixed length K * M, where K is the number of strings in the â€œwordsâ€ array and M the length of each target string. In order to apply the same idea we used for that problem, all we need to do is to map each string from the â€œwordsâ€ array to something we are able to index (I prefer to use hashing for this). Also, in order to speed up the algorithm, we can find all occurrences of those strings in S (which is equivalent to do it on demand, but we will potentially do the same matching twice). Notice that, we can simply apply these occurrences as they appear because we are assured that no word is contained by some other. Finally, we use all this information to process each possibility. Notice here that, the fact that all strings has the same length, implies that we have just M (being M the length of each target string) possible starting points, hence we end up performing M linear scans over array with length O(N/M) (being N the length of S) and that makes the scanning stage of the algorithm to be linear on the length of S. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; int N = s.length(); List&lt;Integer&gt; indexes = new ArrayList&lt;Integer&gt;(s.length()); if (words.length == 0) &#123; return indexes; &#125; int M = words[0].length(); if (N &lt; M * words.length) &#123; return indexes; &#125; int last = N - M + 1; //map each string in words array to some index and compute target counters Map&lt;String, Integer&gt; mapping = new HashMap&lt;String, Integer&gt;(words.length); int [][] table = new int[2][words.length]; int failures = 0, index = 0; for (int i = 0; i &lt; words.length; ++i) &#123; Integer mapped = mapping.get(words[i]); if (mapped == null) &#123; ++failures; mapping.put(words[i], index); mapped = index++; &#125; ++table[0][mapped]; &#125; //find all occurrences at string S and map them to their current integer, -1 means no such string is in words array int [] smapping = new int[last]; for (int i = 0; i &lt; last; ++i) &#123; String section = s.substring(i, i + M); Integer mapped = mapping.get(section); if (mapped == null) &#123; smapping[i] = -1; &#125; else &#123; smapping[i] = mapped; &#125; &#125; //fix the number of linear scans for (int i = 0; i &lt; M; ++i) &#123; //reset scan variables int currentFailures = failures; //number of current mismatches int left = i, right = i; Arrays.fill(table[1], 0); //here, simple solve the minimum-window-substring problem while (right &lt; last) &#123; while (currentFailures &gt; 0 &amp;&amp; right &lt; last) &#123; int target = smapping[right]; if (target != -1 &amp;&amp; ++table[1][target] == table[0][target]) &#123; --currentFailures; &#125; right += M; &#125; while (currentFailures == 0 &amp;&amp; left &lt; right) &#123; int target = smapping[left]; if (target != -1 &amp;&amp; --table[1][target] == table[0][target] - 1) &#123; int length = right - left; //instead of checking every window, we know exactly the length we want if ((length / M) == words.length) &#123; indexes.add(left); &#125; ++currentFailures; &#125; left += M; &#125; &#125; &#125; return indexes;&#125; https://discuss.leetcode.com/topic/32038/java-12ms-beats-100 Java 12ms beats 100% The two pointers method with hashmap is known by many other solutions. The idea is to slide the scan window as far as possible, and keep throwing the impossible cases based on the length test. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; /** * Let n=s.length, k=words[0].length traverse s with indices i, i+k, * i+2k, ... for 0&lt;=i&lt;k, so that the time complexity is O(n). */ List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int n = s.length(), m = words.length, k; if (n == 0 || m == 0 || (k = words[0].length()) == 0) return res; HashMap&lt;String, Integer&gt; wDict = new HashMap&lt;String, Integer&gt;(); for (String word : words) &#123; if (wDict.containsKey(word)) wDict.put(word, wDict.get(word) + 1); else wDict.put(word, 1); &#125; int i, j, start, x, wordsLen = m * k; HashMap&lt;String, Integer&gt; curDict = new HashMap&lt;String, Integer&gt;(); String test, temp; for (i = 0; i &lt; k; i++) &#123; curDict.clear(); start = i; if (start + wordsLen &gt; n) return res; for (j = i; j + k &lt;= n; j += k) &#123; test = s.substring(j, j + k); if (wDict.containsKey(test)) &#123; if (!curDict.containsKey(test)) &#123; curDict.put(test, 1); start = checkFound(res, start, wordsLen, j, k, curDict, s); continue; &#125; // curDict.containsKey(test) x = curDict.get(test); if (x &lt; wDict.get(test)) &#123; curDict.put(test, x + 1); start = checkFound(res, start, wordsLen, j, k, curDict, s); continue; &#125; // curDict.get(test)==wDict.get(test), slide start to // the next word of the first same word as test while (!(temp = s.substring(start, start + k)).equals(test)) &#123; decreaseCount(curDict, temp); start += k; &#125; start += k; if (start + wordsLen &gt; n) break; continue; &#125; // totally failed up to index j+k, slide start and reset all start = j + k; if (start + wordsLen &gt; n) break; curDict.clear(); &#125; &#125; return res; &#125; public int checkFound(List&lt;Integer&gt; res, int start, int wordsLen, int j, int k, HashMap&lt;String, Integer&gt; curDict, String s) &#123; if (start + wordsLen == j + k) &#123; res.add(start); // slide start to the next word decreaseCount(curDict, s.substring(start, start + k)); return start + k; &#125; return start; &#125; public void decreaseCount(HashMap&lt;String, Integer&gt; curDict, String key) &#123; // remove key if curDict.get(key)==1, otherwise decrease it by 1 int x = curDict.get(key); if (x == 1) curDict.remove(key); else curDict.put(key, x - 1); &#125; https://discuss.leetcode.com/topic/6593/accepted-recursive-solution-using-trie-tree Accepted recursive solution using Trie Tree The idea is quite simple. Just use a trie tree to accelerate testing whether a substring is valid. The value of each TrieNode is used to deal with duplication and to mark whether the word is used before. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static class TrieNode &#123; int value = 0; Map&lt;Character, TrieNode&gt; children = new HashMap&lt;Character, TrieNode&gt;(); &#125; TrieNode trie;// build a trie treepublic List&lt;Integer&gt; findSubstring(String S, String[] L) &#123; trie = buildTrie(L); int length = getTotalLength(L); List&lt;Integer&gt; result = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; S.length() - length + 1; i++) &#123; if (isSubString(S, i, i + length)) result.add(i); &#125; return result;&#125;private int getTotalLength(String[] L) &#123; int sum = 0; for (String l : L) sum += l.length(); return sum;&#125;private TrieNode buildTrie(String[] L) &#123; TrieNode root = new TrieNode(); for (String l : L) addWord(root, l); return root;&#125;private void addWord(TrieNode root, String s) &#123; TrieNode node = root; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); TrieNode next = node.children.get(c); if (next == null) &#123; next = new TrieNode(); node.children.put(c, next); &#125; node = next; &#125; node.value++;&#125;private boolean isSubString(String S, int start, int end) &#123; if (start == end) return true; // search in the trie tree TrieNode node = trie; for (int i = start; i &lt; end; i++) &#123; char c = S.charAt(i); if (node.children.get(c) == null) return false; node = node.children.get(c); if (node.value &gt; 0) &#123; // leaf &amp; can be used node.value--; // mark as used if (isSubString(S, i + 1, end)) &#123; node.value++; // mark as unused return true; &#125; node.value++; // mark as unused &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[029. Divide Two Integers]]></title>
    <url>%2Fp%2Fa87eef55%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/divide-two-integers/ Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT. cpp https://discuss.leetcode.com/topic/15568/detailed-explained-8ms-c-solution Detailed Explained 8ms C++ solution In this problem, we are asked to divide two integers. However, we are not allowed to use division, multiplication and mod operations. So, what else can we use? Yeah, bit manipulations. Letâ€™s do an example and see how bit manipulations work. Suppose we want to divide 15 by 3, so 15 is dividend and 3 is divisor. Well, division simply requires us to find how many times we can subtract the divisor from the the dividend without making the dividend negative. Letâ€™s get started. We subtract 3 from 15 and we get 12, which is positive. Letâ€™s try to subtract more. Well, we shift 3 to the left by 1 bit and we get 6. Subtracting 6 from 15 still gives a positive result. Well, we shift again and get 12. We subtract 12 from 15 and it is still positive. We shift again, obtaining 24 and we know we can at most subtract 12. Well, since 12 is obtained by shifting 3 to left twice, we know it is 4 times of 3. How do we obtain this 4? Well, we start from 1 and shift it to left twice at the same time. We add 4 to an answer (initialized to be 0). In fact, the above process is like 15 = 3 * 4 + 3. We now get part of the quotient (4), with a remainder 3. Then we repeat the above process again. We subtract divisor = 3 from the remaining dividend = 3 and obtain 0. We know we are done. No shift happens, so we simply add 1 &lt;&lt; 0 to the answer. Now we have the full algorithm to perform division. According to the problem statement, we need to handle some exceptions, such as overflow. Well, two cases may cause overflow: divisor = 0; dividend = INT_MIN and divisor = -1 (because abs(INT_MIN) = INT_MAX + 1). Of course, we also need to take the sign into considerations, which is relatively easy. Putting all these together, we have the following code. 123456789101112131415161718192021class Solution &#123;public: int divide(int dividend, int divisor) &#123; if (!divisor || (dividend == INT_MIN &amp;&amp; divisor == -1)) return INT_MAX; int sign = ((dividend &lt; 0) ^ (divisor &lt; 0)) ? -1 : 1; long long dvd = labs(dividend); long long dvs = labs(divisor); int res = 0; while (dvd &gt;= dvs) &#123; long long temp = dvs, multiple = 1; while (dvd &gt;= (temp &lt;&lt; 1)) &#123; temp &lt;&lt;= 1; multiple &lt;&lt;= 1; &#125; dvd -= temp; res += multiple; &#125; return sign == 1 ? res : -res; &#125;&#125;; https://discuss.leetcode.com/topic/3421/simple-o-log-n-2-c-solution Simple O((log N) ^ 2) C++ solution Long division in binary: The outer loop reduces n by at least half each iteration. So It has O(log N) iterations. The inner loop has at most log N iterations. So the overall complexity is O(( log N)^2) typedef long long ll; 123456789101112131415int divide(int n_, int d_) &#123; ll ans=0; ll n=abs((ll)n_); ll d=abs((ll)d_); while(n&gt;=d)&#123; ll a=d; ll m=1; while((a&lt;&lt;1) &lt; n)&#123;a&lt;&lt;=1;m&lt;&lt;=1;&#125; ans+=m; n-=a; &#125; if((n_&lt;0&amp;&amp;d_&gt;=0)||(n_&gt;=0&amp;&amp;d_&lt;0)) return -ans; return ans;&#125; https://discuss.leetcode.com/topic/38191/summary-of-3-c-solutions Summary of 3 C++ solutions-1- log-based solution 123456789101112131415class Solution &#123;public: int divide(int dividend, int divisor) &#123; /** a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b)) **/ if(dividend==0) return 0; if(divisor==0) return INT_MAX; double t1=log(fabs(dividend)); double t2=log(fabs(divisor)); long long result=double(exp(t1-t2)); if((dividend&lt;0) ^ (divisor&lt;0)) result=-result; if(result&gt;INT_MAX) result=INT_MAX; return result; &#125;&#125;; -2- Binary Index tree idea inspired solution, as we can decompose any result number to sum of the power of 2. Here is the C++ implementation. 123456789101112131415161718192021222324class Solution &#123;public: int divide(int dividend, int divisor) &#123; if(!divisor || (dividend==INT_MIN &amp;&amp; divisor==-1)) return INT_MAX; int sign=((dividend&lt;0)^(divisor&lt;0)) ? -1:1; long long m=labs(dividend); long long n=labs(divisor); int result=0; /** dvd &gt;= 2^k1*dvs + 2^k2*dvs ... **/ while(m&gt;=n)&#123; long long temp=n, count=1; while(m &gt;= (temp&lt;&lt;1))&#123; temp&lt;&lt;=1; count&lt;&lt;=1; &#125; m-=temp; result+=count; &#125; return sign==1?result:-result; &#125;&#125;; -3- concise version of the solution 2 1234567891011121314151617class Solution &#123;public: int divide(int dividend, int divisor) &#123; long long result=0; long long m=abs((long long)dividend); long long n=abs((long long)divisor); while(m&gt;=n)&#123; long long s=n, power=1; while((s&lt;&lt;1) &lt;= m) &#123; s&lt;&lt;=1; power&lt;&lt;=1; &#125; result+=power; m-=s; &#125; if( (dividend&gt;0) ^ (divisor&gt;0)) result = -result; return result&gt;INT_MAX ? INT_MAX:result; &#125;&#125;; python https://discuss.leetcode.com/topic/8714/clear-python-code Clear python code 12345678910111213141516class Solution:# @return an integerdef divide(self, dividend, divisor): positive = (dividend &lt; 0) is (divisor &lt; 0) dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend &gt;= divisor: temp, i = divisor, 1 while dividend &gt;= temp: dividend -= temp res += i i &lt;&lt;= 1 temp &lt;&lt;= 1 if not positive: res = -res return min(max(-2147483648, res), 2147483647) https://discuss.leetcode.com/topic/6966/15-line-easy-understand-solution-129ms 15 line easy understand solution. 129ms for example, if we want to calc (17/2) ret = 0; 17-2 ,ret+=1; left=15 15-4 ,ret+=2; left=11 11-8 ,ret+=4; left=3 3-2 ,ret+=1; left=1 ret=8; 123456789101112131415161718192021class Solution:# @return an integerdef divide(self, dividend, divisor): isMinus= ((dividend&lt;0 and divisor &gt;0) or (dividend&gt;0 and divisor &lt;0)); ret=0; dividend,divisor=abs(dividend),abs(divisor); c,sub=1,divisor; while(dividend &gt;= divisor): if(dividend&gt;=sub): dividend-=sub; ret+=c; sub=(sub&lt;&lt;1); c=(c&lt;&lt;1); else: sub=(sub&gt;&gt;1); c=(c&gt;&gt;1); if(isMinus): ret=-ret; return min(max(-2147483648,ret),2147483647); java https://discuss.leetcode.com/topic/23968/clean-java-solution-with-some-comment Clean Java solution with some comment. 12345678910111213141516171819202122232425262728293031323334353637383940public int divide(int dividend, int divisor) &#123; //Reduce the problem to positive long integer to make it easier. //Use long to avoid integer overflow cases. int sign = 1; if ((dividend &gt; 0 &amp;&amp; divisor &lt; 0) || (dividend &lt; 0 &amp;&amp; divisor &gt; 0)) sign = -1; long ldividend = Math.abs((long) dividend); long ldivisor = Math.abs((long) divisor); //Take care the edge cases. if (ldivisor == 0) return Integer.MAX_VALUE; if ((ldividend == 0) || (ldividend &lt; ldivisor)) return 0; long lans = ldivide(ldividend, ldivisor); int ans; if (lans &gt; Integer.MAX_VALUE)&#123; //Handle overflow. ans = (sign == 1)? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; else &#123; ans = (int) (sign * lans); &#125; return ans;&#125;private long ldivide(long ldividend, long ldivisor) &#123; // Recursion exit condition if (ldividend &lt; ldivisor) return 0; // Find the largest multiple so that (divisor * multiple &lt;= dividend), // whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason. // Think this as a binary search. long sum = ldivisor; long multiple = 1; while ((sum+sum) &lt;= ldividend) &#123; sum += sum; multiple += multiple; &#125; //Look for additional value for the multiple from the reminder (dividend - sum) recursively. return multiple + ldivide(ldividend - sum, ldivisor);&#125; https://discuss.leetcode.com/topic/8271/accepted-java-solution-with-comments Accepted Java solution with comments. 12345678910111213141516171819202122232425262728293031public int divide(int dividend, int divisor) &#123; long result = divideLong(dividend, divisor); return result &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)result;&#125;// It&apos;s easy to handle edge cases when// operate with long numbers rather than intpublic long divideLong(long dividend, long divisor) &#123; // Remember the sign boolean negative = dividend &lt; 0 != divisor &lt; 0; // Make dividend and divisor unsign if (dividend &lt; 0) dividend = -dividend; if (divisor &lt; 0) divisor = -divisor; // Return if nothing to divide if (dividend &lt; divisor) return 0; // Sum divisor 2, 4, 8, 16, 32 .... times long sum = divisor; long divide = 1; while ((sum+sum) &lt;= dividend) &#123; sum += sum; divide += divide; &#125; // Make a recursive call for (devided-sum) and add it to the result return negative ? -(divide + divideLong((dividend-sum), divisor)) : (divide + divideLong((dividend-sum), divisor));&#125; https://discuss.leetcode.com/topic/3631/a-readable-java-implementation A readable Java implementation At first, I used dividend / divisor, just to check. But that was cheating. Then, I implemented a solution which failed the corner cases. I solved it by using long instead of int. But I felt that was also cheating. At last, I came up with this solution. It handles all the corner cases. Running time analysis after the code. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123; public int divide(int dividend, int divisor) &#123; if (divisor == 1) // Trival case 1 return dividend; // Use negative integers to avoid integer overflow if (dividend &gt; 0) return -divide(-dividend, divisor); if (divisor &gt; 0) return -divide(dividend, -divisor); if (dividend &gt; divisor) // Trivial case 2 return 0; if ((dividend == Integer.MIN_VALUE) &amp;&amp; (divisor == -1)) // Overflow case return Integer.MAX_VALUE; // Find the highest mult = (divisor * 2^shifts) which is &lt;= dividend // by shifting mult to the left without causing an overflow. // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations. int min_divisor = Integer.MIN_VALUE &gt;&gt; 1; int mult = divisor; // = divisor * 2^shifts int shifts = 0; while ((mult &gt;= min_divisor) &amp;&amp; (mult &gt; dividend)) &#123; mult &lt;&lt;= 1; ++shifts; &#125; // Compute the result by shifting mult to the right. // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations for the outer loop. // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations for the inner loop // (in total, not per outer iteration). int result = 0; int power = 1 &lt;&lt; shifts; // = 2^shifts while (dividend &lt;= divisor) &#123; shifts = 0; while (mult &lt; dividend) &#123; mult &gt;&gt;= 1; ++shifts; &#125; dividend -= mult; power &gt;&gt;= shifts; result |= power; // Adds power to result &#125; return result; &#125;&#125; I see lots of people talking about O(log(n)) solutions. Since n is bounded by -2^31 and 2^31-1, Iâ€™m not sure the Big-Oh notation is appropriate here. Anyway, hereâ€™s a rough worst-case analysis of this code. The first loop runs (log2(|dividend|) - log2(|divisor|) + 1) times. There are 2 comparisons 1 bit shift 1 increment The second loop runs between 1 time and (log2(|dividend|) - log2(|divisor|) + 1) times. For worst-case, we take the latter. There are 1 comparison 1 assignment 1 substraction 1 bit shift 1 bitwise or The inner while loop runs (log2(|dividend|) - log2(|divisor|) + 1) times also (in total, not per outer loop iteration). There are 1 comparison 1 bit shift 1 increment So, roughly, the overall worst-case running time is 12(log2(dividend) - log2(divisor) + 1) operations. You can notice that (log2(|dividend|) - log2(|divisor|)) = log2(|result|). Thus, the running time is (worst-case) 12(log2(|result|) + 1) operations.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[028. Implement strStr()]]></title>
    <url>%2Fp%2F78eeb38d%2F</url>
    <content type="text"><![CDATA[27.5% https://leetcode.com/problems/implement-strstr/ Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. æ–¹æ³•ä¸€ï¼šæš´åŠ›æ³• 1234567891011121314class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.size(), n = needle.size(); if(!haystack || !needle || m&lt;n) return -1; for(int i=0; ;i++)&#123; for(int j=0; ;j++)&#123; if(j==n-1) return i; if(i+j==m-1) return -1; if(haystack[i+j]!=needle[j]) break; &#125; &#125; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.size(), n = needle.size(); if(n==0) return 0; if(m==0 || m&lt;n) return -1; for(int i=0; ;i++)&#123; for(int j=0; ;j++)&#123; if(j==n) return i; if(i+j==m) return -1; if(haystack[i+j]!=needle[j]) break; &#125; &#125; &#125;&#125;; æ–¹æ³•äºŒï¼šKMPç®—æ³• å…ˆå»ºç«‹lpsï¼Œç„¶åŽä½¿ç”¨kmpç®—æ³• 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.length(), n = needle.length(); if (!n) return 0; vector&lt;int&gt; lps = kmpProcess(needle); for (int i = 0, j = 0; i &lt; m; ) &#123; if (haystack[i] == needle[j]) &#123; i++; j++; &#125; if (j == n) return i - j; if (i &lt; m &amp;&amp; haystack[i] != needle[j]) &#123; if (j) j = lps[j - 1]; else i++; &#125; &#125; return -1; &#125;private: vector&lt;int&gt; kmpProcess(string&amp; needle) &#123; int n = needle.length(); vector&lt;int&gt; lps(n, 0); for (int i = 1, len = 0; i &lt; n; ) &#123; if (needle[i] == needle[len]) lps[i++] = ++len; else if (len) len = lps[len - 1]; else lps[i++] = 0; &#125; return lps; &#125;&#125;; å®Œæ•´å®žçŽ°ä»£ç : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// C++ program for implementation of KMP pattern searching// algorithm#include&lt;bits/stdc++.h&gt; void computeLPSArray(char *pat, int M, int *lps); // Prints occurrences of txt[] in pat[]void KMPSearch(char *pat, char *txt)&#123; int M = strlen(pat); int N = strlen(txt); // create lps[] that will hold the longest prefix suffix // values for pattern int lps[M]; // Preprocess the pattern (calculate lps[] array) computeLPSArray(pat, M, lps); int i = 0; // index for txt[] int j = 0; // index for pat[] while (i &lt; N) &#123; if (pat[j] == txt[i]) &#123; j++; i++; &#125; if (j == M) &#123; printf("Found pattern at index %d n", i-j); j = lps[j-1]; &#125; // mismatch after j matches else if (i &lt; N &amp;&amp; pat[j] != txt[i]) &#123; // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) j = lps[j-1]; else i = i+1; &#125; &#125;&#125; // Fills lps[] for given patttern pat[0..M-1]void computeLPSArray(char *pat, int M, int *lps)&#123; // length of the previous longest prefix suffix int len = 0; lps[0] = 0; // lps[0] is always 0 // the loop calculates lps[i] for i = 1 to M-1 int i = 1; while (i &lt; M) &#123; if (pat[i] == pat[len]) &#123; len++; lps[i] = len; i++; &#125; else // (pat[i] != pat[len]) &#123; // This is tricky. Consider the example. // AAACAAAA and i = 7. The idea is similar // to search step. if (len != 0) &#123; len = lps[len-1]; // Also, note that we do not increment // i here &#125; else // if (len == 0) &#123; lps[i] = 0; i++; &#125; &#125; &#125;&#125; // Driver program to test above functionint main()&#123; char *txt = "ABABDABACDABABCABAB"; char *pat = "ABABCABAB"; KMPSearch(pat, txt); return 0;&#125; è¯´æ˜Žï¼š http://www.cplusplus.com/reference/cstring/strstr/ 123strstrconst char * strstr ( const char * str1, const char * str2 ); char * strstr ( char * str1, const char * str2 ); Locate substring Returns a pointer to the first occurrence of str2 in str1, or a null pointer if str2 is not part of str1. The matching process does not include the terminating null-characters, but it stops there. KMPç®—æ³•é˜…è¯»èµ„æ–™ KMP on jBoxerâ€™s blog; http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/ KMP on geeksforgeeks, with a well-commented C code. http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/ é˜®ä¸€å³°çš„åšå®¢ http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html https://discuss.leetcode.com/topic/6888/this-test-case-doesn-t-make-sense This test case doesnâ€™t make sense. Input: â€œâ€, â€œâ€Output: -1Expected: 0 Basically there is nothing in the string, how do you get the index. If this test case is valid, then needle =â€â€, haystack=â€anythingâ€ could return any value. since empty is everywhere. cpp https://discuss.leetcode.com/topic/15569/explained-4ms-easy-c-solution Explained 4ms Easy C++ solution Well, the problem does not aim for an advanced algorithm like KMP but only a clean brute-force algorithm. So we can traverse all the possible starting points of haystack (from 0 to haystack.length() - needle.length()) and see if the following characters in haystack match those of needle. The code is as follows. 123456789101112131415class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.length(), n = needle.length(); if (!n) return 0; for (int i = 0; i &lt; m - n + 1; i++) &#123; int j = 0; for (; j &lt; n; j++) if (haystack[i + j] != needle[j]) break; if (j == n) return i; &#125; return -1; &#125;&#125;; Of course, you may challenge yourself implementing the KMP algorithm for this problem. KMP is a classic and yet notoriously hard-to-understand algorithm. However, I think the following two links give nice explanations. You may refer to them. KMP on jBoxerâ€™s blog; http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/ KMP on geeksforgeeks, with a well-commented C code. http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/ I am sorry that I am still unable to give a personal explanation of the algorithm. I only read it from the two links above and mimic the code in the second link. My accepted C++ code using KMP is as follows. Well, it also takes 4ms -_- 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.length(), n = needle.length(); if (!n) return 0; vector&lt;int&gt; lps = kmpProcess(needle); for (int i = 0, j = 0; i &lt; m; ) &#123; if (haystack[i] == needle[j]) &#123; i++; j++; &#125; if (j == n) return i - j; if (i &lt; m &amp;&amp; haystack[i] != needle[j]) &#123; if (j) j = lps[j - 1]; else i++; &#125; &#125; return -1; &#125;private: vector&lt;int&gt; kmpProcess(string&amp; needle) &#123; int n = needle.length(); vector&lt;int&gt; lps(n, 0); for (int i = 1, len = 0; i &lt; n; ) &#123; if (needle[i] == needle[len]) lps[i++] = ++len; else if (len) len = lps[len - 1]; else lps[i++] = 0; &#125; return lps; &#125;&#125;; https://discuss.leetcode.com/topic/4340/my-c-code-that-implements-boyer-moore-string-search-got-accepted-in-12ms My c++ code that implements Boyer-Moore string search got accepted in 12ms. I implements Boyer-Moore string search algorithm and it turns out to be very efficient (accepted in 12ms). Boyer-Moore uses information gained by preprocessing the pattern string to skip as many alignments as possible. A shift is calculated by applying both rules: the bad character rule and the good suffix rule. The actual shifting offset is the maximum of the shifts calculated by these rules. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657char *strStr(char *haystack, char *needle) &#123; if(NULL==haystack||NULL==needle) return NULL; int plen = strlen(needle); int slen = strlen(haystack); if(0==plen) return haystack; else if(plen&gt;slen) return NULL; int badChar[256]; int np = 0; int i,j,k; for(i=0;i&lt;256;i++) badChar[i] = plen; while(np&lt;plen) &#123; badChar[*(needle+np)] = plen-np-1; np++; &#125; int* goodSuffix = new int[plen]; int prefix_index = plen; for(i=plen-1;i&gt;=0;i--) &#123; goodSuffix[i] = prefix_index; if(*(needle+i)==*(needle+plen-1-i)&amp;&amp;prefix_index==i+1) prefix_index = i; &#125; for(i=0;i&lt;plen-1;i++) &#123; j = plen-1, k = 0; while(k&lt;i&amp;&amp;*(needle+j)==*(needle+i-k)) &#123;j--;k++;&#125; if(*(needle+plen-1)==*(needle+i)) goodSuffix[j] = plen-1-i; &#125; goodSuffix[plen-1] = 0; int sp = 0; while(sp&lt;slen) &#123; i = plen-1; while(i&gt;=0&amp;&amp;*(haystack+sp+i)==*(needle+i)) i--; if(i&lt;0) return haystack+sp; int bj = badChar[*(haystack+sp+i)] - plen + i + 1; sp += (bj&gt;goodSuffix[i]?bj:goodSuffix[i]); &#125; delete goodSuffix; return NULL;&#125; https://discuss.leetcode.com/topic/31171/kmp-in-c-explanation-included KMP in C++, explanation included 123456789101112131415161718192021222324252627282930313233343536373839404142434445int strStr(string haystack, string needle) &#123; int nsize = needle.size(); int hsize = haystack.size(); if (nsize == 0) return 0; int *table = new int[nsize]; memset(table, 0, sizeof(int)*nsize); //building match table for (int i = 1, j = 0; i &lt; nsize - 1;)&#123; if (needle[i] != needle[j])&#123; if (j&gt;0)&#123; j = table[j - 1]; &#125; else&#123; i++; &#125; &#125; else&#123; table[i] = j + 1; i++; j++; &#125; &#125; //matching for (int i = 0, match_pos = 0; i &lt; hsize;)&#123; if (haystack[i] == needle[match_pos])&#123; if (match_pos == nsize - 1)&#123; return i - (nsize - 1); &#125; else&#123; i++; match_pos++; &#125; &#125; else&#123; if (match_pos == 0)&#123; i++; &#125; else&#123; match_pos = table[match_pos - 1]; &#125; &#125; &#125; delete[]table; return -1; &#125; Iâ€™ll talk about the basic idea behind KMP algorithm. First, some notations: Denote the pattern string as ps and the match table as table, ps and table use 0 based index. Denote substring of ps from index i to index j (i and j included) as substr(ps,i,j). Denote string1 is the same as string2 as string1==string2 The definition of my match table: table[i] when i&gt;0 means the max length of prefix of ps(0,i) which is the same as the suffix of ps(0,i). Or1table[i]=max&#123;k| substr(substr(ps,0,i),0,k-1) == substr(substr(ps,0,i),i-k+1,i), k&lt;=i&#125;. Also, we define table[i]=0. So, for string â€œabaâ€, table={0,0,1}. table[1]=0 is because no prefix equals suffix of â€œabâ€. table[2]=1 is because prefix â€œaâ€ equals suffix â€œaâ€ of â€œabaâ€. for string â€œabcabceâ€, table={0,0,0,1,2,3,0}. table[4]=2 is because prefix â€œabâ€ equals suffix â€œabâ€ of â€œabcabâ€ table[5]=3 is because prefix â€œabcâ€ equals suffix â€œabcâ€ of â€œabcabcâ€ for string â€œaabaabaaaâ€, table={0,1,0,1,2,3,4,5,2}. How would this match table be helpful to string matching? Suppose we have a target string â€œabcabcdxxxxxâ€ and a pattern â€œabcabceâ€.In the first round of matching, we start at first character and have 12abcabcdxxxxxabcabce We discover that â€˜dâ€™ and â€˜eâ€™ are different and string before that is the same, which is â€œabcabcâ€.if we move â€œabcabceâ€ forward one character, we would be comparing 12abcabcdxxxxx abcabce letâ€™s focus on the parts which are same in the previous round: 12abcabc abcabc we are actually comparing the suffix of length 5 of â€œabcabcâ€, which is â€œbcabcâ€ and the prefix of length 5 of â€œabcabcâ€, which is â€œabcabâ€. However, table[5]==3 tells us the max length of suffix and prefix of â€œabcabcâ€ which are same is 3, so suffix and prefixof length 5 canâ€™t be the same. Thus, we can skip this round of comparing.Next, we move â€œabcabceâ€ forward by another one character, we would be comparing 12abcabc abcabc Now, we are comparing suffix and prefix of length 4, since table[5]==3, we can skip this round.Next, we move â€œabcabceâ€ forward by another one character, we would be comparing 12abcabc abcabc Now, we are comparing suffix and prefix of length 3, since table[5]==3, this is valid.Another property we can use to simply the matching process is that we already know the prefix and suffix of length 3 are the same, so we can start by comparing from the 4th charater in pattern, which is â€˜aâ€™, with the target string. To sum up, when the ps(pattern string) at index i(i&gt;0) failed to match ts(target string) at index j, which means substr(ps,0,i-1) matches, we start by comparing ps[table[i-1]] with ts[j]. python 35ms, 100.00%, September 6, 2016 https://discuss.leetcode.com/topic/29848/my-answer-by-python My answer by Python 1234567891011class Solution(object): def strStr(self, haystack, needle): &quot;&quot;&quot; :type haystack: str :type needle: str :rtype: int &quot;&quot;&quot; for i in range(len(haystack)-len(needle)+1): if haystack[i:i+len(needle)] == needle: return i return -1 c 0ms, 28.37%, September 6, 2016 https://discuss.leetcode.com/topic/6557/a-very-clean-solution-brute-force A very clean solution, brute-force 12345678910int strStr(char *haystack, char *needle) &#123; if (!haystack || !needle) return -1; for (int i = 0; ; ++i) &#123; for (int j = 0; ; ++j) &#123; if (needle[j] == 0) return i; if (haystack[i + j] == 0) return -1; if (haystack[i + j] != needle[j]) break; &#125; &#125; &#125; java 8ms, 28.67%, September 9, 2016 https://discuss.leetcode.com/topic/18839/elegant-java-solution Elegant Java solution 12345678910public class Solution &#123; public int strStr(String haystack, String needle) &#123; for(int i=0; ; i++) for(int j=0; ; j++)&#123; if(j == needle.length()) return i; if(i+j == haystack.length()) return -1; if(needle.charAt(j) != haystack.charAt(i+j)) break; &#125; &#125;&#125; https://discuss.leetcode.com/topic/9872/share-my-accepted-java-solution Share my accepted java solution 1234567891011121314151617public class Solution &#123; public int strStr(String haystack, String needle) &#123; int l1 = haystack.length(), l2 = needle.length(); if (l1 &lt; l2) &#123; return -1; &#125; else if (l2 == 0) &#123; return 0; &#125; int threshold = l1 - l2; for (int i = 0; i &lt;= threshold; ++i) &#123; if (haystack.substring(i,i+l2).equals(needle)) &#123; return i; &#125; &#125; return -1; &#125;&#125; https://discuss.leetcode.com/topic/3576/accepted-kmp-solution-in-java-for-reference Accepted KMP solution in java for reference 1234567891011121314151617181920212223242526272829303132333435public String strStr(String haystack, String needle) &#123; //KMP algorithms if(needle.equals(&quot;&quot;)) return haystack; if(haystack.equals(&quot;&quot;)) return null; char[] arr = needle.toCharArray(); int[] next = makeNext(arr); for(int i = 0, j = 0, end = haystack.length(); i &lt; end;)&#123; if(j == -1 || haystack.charAt(i) == arr[j])&#123; j++; i++; if(j == arr.length) return haystack.substring(i - arr.length); &#125; if(i &lt; end &amp;&amp; haystack.charAt(i) != arr[j]) j = next[j]; &#125; return null;&#125;private int[] makeNext(char[] arr)&#123; int len = arr.length; int[] next = new int[len]; next[0] = -1; for(int i = 0, j = -1; i + 1 &lt; len;)&#123; if(j == -1 || arr[i] == arr[j])&#123; next[i+1] = j+1; if(arr[i+1] == arr[j+1]) next[i+1] = next[j+1]; i++; j++; &#125; if(arr[i] != arr[j]) j = next[j]; &#125; return next;&#125; https://discuss.leetcode.com/topic/41463/java-easy-to-understand-solutions Java easy to understand solutions. 123456789101112131415161718public int strStr1(String haystack, String needle) &#123; return haystack.indexOf(needle);&#125;public int strStr(String haystack, String needle) &#123; if (haystack == null || needle == null) return -1; int l1 = haystack.length(); int l2 = needle.length(); for (int i = 0; i &lt; l1-l2+1; i++) &#123; int count = 0; while (count &lt; l2 &amp;&amp; haystack.charAt(i+count) == needle.charAt(count)) count++; if (count == l2) return i; &#125; return -1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[027. Remove Element]]></title>
    <url>%2Fp%2F98cbed82%2F</url>
    <content type="text"><![CDATA[39.1% https://leetcode.com/problems/remove-element/ Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesnâ€™t matter what you leave beyond the new length. 1234Example:Given input array nums = [3,2,2,3], val = 3Your function should return length = 2, with the first two elements of nums being 2. Hint: Try two pointers. Did you use the property of â€œthe order of elements can be changedâ€? What happens when the elements to remove are rare? æ–¹æ³•ä¸€ï¼š https://discuss.leetcode.com/topic/17282/very-simple-and-optimal-c-solution Very simple and optimal c++ solution. 12345678910int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int cnt = 0; for(int i = 0 ; i &lt; nums.size() ; ++i) &#123; if(nums[i] == val) cnt++; else nums[i-cnt] = nums[i]; &#125; return nums.size()-cnt;&#125; æ–¹æ³•äºŒï¼š beats 4.4%,but the other 95.6% are same to you ~ including me 4ms, 4.44%, April.23rd, 2016 123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int index = 0; for(int i = 0; i &lt; nums.size(); ++i)&#123; if(nums[i] != val)&#123; nums[index++] = nums[i]; &#125; &#125; return index; &#125;&#125;; 4ms, 4.44%, April.23rd, 2016 123456class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; return distance(nums.begin(), remove(nums.begin(), nums.end(), val)); &#125;&#125;; 4ms, 4.44%, April.23rd, 2016 123456789101112131415class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int tail = nums.size() -1; int i = 0; while(i &lt;= tail)&#123; if(nums[i] == val)&#123; nums[i] = nums[tail--]; continue; &#125; i++; &#125; return tail+1; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int n = nums.size(); if(n==0) return 0; int index = -1; for(int i=0; i&lt;n; i++) if(nums[i]!=val) nums[++index] = nums[i]; return index+1; &#125;&#125;; python https://discuss.leetcode.com/topic/27777/simple-python-o-n-two-pointer-in-place-solution Simple Python O(n) two pointer in place solution Starting from the left every time we find a value that is the target value we swap it out with an item starting from the right. We decrement end each time as we know that the final item is the target value and only increment start once we know the value is ok. Once start reaches end we know all items after that point are the target value so we can stop there. 12345678def removeElement(self, nums, val): start, end = 0, len(nums) - 1 while start &lt;= end: if nums[start] == val: nums[start], nums[end], end = nums[end], nums[start], end - 1 else: start +=1 return start 48ms, 45.02%, April.23rd, 2016 12345678910class Solution(object): def removeElement(self, nums, val): &quot;&quot;&quot; :type nums: List[int] :type val: int :rtype: int &quot;&quot;&quot; while(val in nums): nums.remove(val) return len(nums) 44ms, 71.09%, April.23rd, 2016 123456789101112class Solution(object): def removeElement(self, nums, val): &quot;&quot;&quot; :type nums: List[int] :type val: int :rtype: int &quot;&quot;&quot; try: while True: nums.remove(val) except: return len(nums) java https://discuss.leetcode.com/topic/1228/my-solution-for-your-reference My solution for your reference. 12345int removeElement(int A[], int n, int elem) &#123; int begin=0; for(int i=0;i&lt;n;i++) if(A[i]!=elem) A[begin++]=A[i]; return begin;&#125; https://discuss.leetcode.com/topic/10753/accepted-java-solution Accepted java solution 123456789101112public int removeElement(int[] A, int elem) &#123; int m = 0; for(int i = 0; i &lt; A.length; i++)&#123; if(A[i] != elem)&#123; A[m] = A[i]; m++; &#125; &#125; return m;&#125; https://discuss.leetcode.com/topic/5205/9-line-java-solution 9-line java solution The basic idea is when elem is found at index i, let A[i] = the last element in the modifying array, then repeat searching until elem is not found. 123456789public int removeElement(int[] A, int elem) &#123; int len = A.length; for (int i = 0 ; i&lt; len; ++i)&#123; while (A[i]==elem &amp;&amp; i&lt; len) &#123; A[i]=A[--len]; &#125; &#125; return len;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[026. Remove Duplicates from Sorted Array]]></title>
    <url>%2Fp%2Fca4383ce%2F</url>
    <content type="text"><![CDATA[35.5% https://leetcode.com/problems/remove-duplicates-from-sorted-array/ Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. 123456For example,Given input array nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn&apos;t matter what you leave beyond the new length. æ–¹æ³•ä¸€ï¼š beats 35.10% of cppsubmissions 1234567891011class Solution &#123; public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n &lt; 2) return n; int id = 1; for(int i = 1; i &lt; n; ++i) if(nums[i] != nums[i-1]) nums[id++] = nums[i]; return id; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return n; int index = 0; for(int i=1; i&lt;n; i++) if(nums[i]!=nums[index]) nums[++index] = nums[i]; return index+1; &#125;&#125;; https://discuss.leetcode.com/topic/17252/5-lines-c-java-nicer-loops 5 lines C++/Java, nicer loops I donâ€™t like old-style indexed looping. I much prefer the â€œenhancedâ€ (Java) / â€œrange-basedâ€ (C++) loops, they make things much cleaner. C++ 1234567int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int i = 0; for (int n : nums) if (!i || n &gt; nums[i-1]) nums[i++] = n; return i;&#125; And to not need the !i check in the loop: 1234567int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int i = !nums.empty(); for (int n : nums) if (n &gt; nums[i-1]) nums[i++] = n; return i;&#125; https://discuss.leetcode.com/topic/8907/share-my-clean-c-code Share my clean C++ code 123456int count = 0;for(int i = 1; i &lt; n; i++)&#123; if(A[i] == A[i-1]) count++; else A[i-count] = A[i];&#125;return n-count; https://discuss.leetcode.com/topic/25354/simple-c-o-n-solution Simple C++ O(n) solution 12345678910int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int pos = 0; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (i == 0 || nums[i] != nums[pos - 1]) nums[pos++] = nums[i]; &#125; return pos;&#125; python https://discuss.leetcode.com/topic/12672/simple-python-solution-o-n Simple Python solution - O(n) 123456789101112131415class Solution: # @param a list of integers # @return an integer def removeDuplicates(self, A): if not A: return 0 newTail = 0 for i in range(1, len(A)): if A[i] != A[newTail]: newTail += 1 A[newTail] = A[i] return newTail + 1 java https://discuss.leetcode.com/topic/3102/my-solution-time-o-n-space-o-1 My Solution : Time O(n), Space O(1) 12345678910class Solution &#123; public: int removeDuplicates(int A[], int n) &#123; if(n &lt; 2) return n; int id = 1; for(int i = 1; i &lt; n; ++i) if(A[i] != A[i-1]) A[id++] = A[i]; return id; &#125;&#125;; https://discuss.leetcode.com/topic/17252/5-lines-c-java-nicer-loops Java 1234567public int removeDuplicates(int[] nums) &#123; int i = 0; for (int n : nums) if (i == 0 || n &gt; nums[i-1]) nums[i++] = n; return i;&#125; And to not need the i == 0 check in the loop: 1234567public int removeDuplicates(int[] nums) &#123; int i = nums.length &gt; 0 ? 1 : 0; for (int n : nums) if (n &gt; nums[i-1]) nums[i++] = n; return i;&#125; https://discuss.leetcode.com/topic/10262/5-lines-java-solution 5 lines Java solution 1234567public int removeDuplicates(int[] A) &#123; if (A.length==0) return 0; int j=0; for (int i=0; i&lt;A.length; i++) if (A[i]!=A[j]) A[++j]=A[i]; return ++j;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[025. Reverse Nodes in k-Group]]></title>
    <url>%2Fp%2F6d6210c%2F</url>
    <content type="text"><![CDATA[30.0% https://leetcode.com/problems/reverse-nodes-in-k-group/ Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed. 1234567For example,Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 æ–¹æ³•ä¸€ï¼š æ­¤é¢˜ç›®æ˜¯25é¢˜çš„åŠ å¼ºç‰ˆ è¿­ä»£ï¼Œå‚è€ƒåè½¬é“¾è¡¨çš„æ–¹æ³• å…¶å®žä¸Ž206é¢˜ï¼Œåè½¬é“¾è¡¨ç±»ä¼¼ï¼Œä½†æ˜¯å¤šäº†å‡ æ­¥ã€‚å…ˆéåŽ†ä¸€éï¼ŒèŽ·å¾—æ•°ç›® https://discuss.leetcode.com/topic/9839/20-line-iterative-c-solution 20-line iterative C++ solution 1234567891011-1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 | | |pre cur nex -1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; 5 | | | pre cur nex -1 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5 | | | pre cur nex Above is how it works inside one group iteration(for example, k=3) ä¼˜åŒ–åŽçš„ä»£ç ï¼š Thanks to ciaoliang1992, the tmp pointer is no necessary, so the more concise solution is 12345678910111213141516171819202122232425class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;++i) &#123; cur-&gt;next=nex-&gt;next; nex-&gt;next=pre-&gt;next; pre-&gt;next=nex; nex=cur-&gt;next; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°: 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if(!head || !head-&gt;next || k&lt;=1) return head; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* cur = dummy; int cnt = 0; // æœ‰å¿…è¦çš„æ—¶å€™å¯ä»¥éåŽ†ä¸€éé“¾è¡¨ï¼Œæ±‚å‡ºé“¾è¡¨çš„é•¿åº¦ while(cur-&gt;next)&#123; cnt++; cur = cur-&gt;next; &#125; ListNode* pre = dummy, *nex; while(cnt/k)&#123; cur = pre-&gt;next; nex = cur-&gt;next; // å¯¹äºŽåè½¬kä¸ªï¼Œéœ€è¦çš„æ˜¯k-1ä¸ªåŽé¢çš„è½¬åˆ°å‰é¢ï¼Œè€Œä¸æ˜¯kä¸ª for(int i=0; i&lt;k-1; i++)&#123; cur-&gt;next = nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; nex = cur-&gt;next; &#125; pre = cur; cnt -= k; &#125; return dummy-&gt;next; &#125;&#125;; åŽŸå§‹ä»£ç ï¼š 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *tmp, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;i++) &#123; tmp= nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; cur-&gt;next = tmp; nex = tmp; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if(!head || !head-&gt;next || k&lt;=1) return head; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* cur = dummy; int cnt = 0; // æœ‰å¿…è¦çš„æ—¶å€™å¯ä»¥éåŽ†ä¸€éé“¾è¡¨ï¼Œæ±‚å‡ºé“¾è¡¨çš„é•¿åº¦ while(cur-&gt;next)&#123; cnt++; cur = cur-&gt;next; &#125; ListNode* pre = dummy, *nex, *tmp; while(cnt/k)&#123; cur = pre-&gt;next; nex = cur-&gt;next; // å¯¹äºŽåè½¬kä¸ªï¼Œéœ€è¦çš„æ˜¯k-1ä¸ªåŽé¢çš„è½¬åˆ°å‰é¢ï¼Œè€Œä¸æ˜¯kä¸ª for(int i=0; i&lt;k-1; i++)&#123; tmp = nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; cur-&gt;next = tmp; nex = cur-&gt;next; &#125; pre = cur; cnt -= k; &#125; return dummy-&gt;next; &#125;&#125;; æ–¹æ³•äºŒï¼š é€’å½’ C++ Elegant and Small 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: ListNode* reverse(ListNode* first, ListNode* last) &#123; ListNode* prev = last; while ( first != last ) &#123; auto tmp = first-&gt;next; first-&gt;next = prev; prev = first; first = tmp; &#125; return prev; &#125; ListNode* reverseKGroup(ListNode* head, int k) &#123; auto node=head; for (int i=0; i &lt; k; ++i) &#123; if ( ! node ) return head; // nothing to do list too sort node = node-&gt;next; &#125; auto new_head = reverse( head, node); head-&gt;next = reverseKGroup( node, k); return new_head; &#125;&#125;; æˆ‘çš„å®žçŽ°ï¼š 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; int cnt = 0; auto node = head; while(cnt&lt;k)&#123; if(node==NULL) return head; cnt++; node = node-&gt;next; &#125; auto new_head = reverse(head, k); head-&gt;next = reverseKGroup(node, k); return new_head; &#125; ListNode* reverse(ListNode* head, int k)&#123; ListNode* pre = NULL; int cnt = 0; while(cnt&lt;k)&#123; ListNode* nex = head-&gt;next; head-&gt;next = pre; pre = head; head = nex; cnt++; &#125; return pre; &#125;&#125;; cpp å…¶å®žä¸Ž206é¢˜ï¼Œåè½¬é“¾è¡¨ç±»ä¼¼ï¼Œä½†æ˜¯å¤šäº†å‡ æ­¥ã€‚å…ˆéåŽ†ä¸€éï¼ŒèŽ·å¾—æ•°ç›® https://discuss.leetcode.com/topic/9839/20-line-iterative-c-solution 20-line iterative C++ solution 1234567891011-1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 | | | | pre cur nex tmp-1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; 5 | | | | pre cur nex tmp-1 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5 | | | | pre cur nex tmp Above is how it works inside one group iteration(for example, k=3) 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *tmp, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;i++) &#123; tmp= nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; cur-&gt;next = tmp; nex = tmp; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; Thanks to ciaoliang1992, the tmp pointer is no necessary, so the more concise solution is 12345678910111213141516171819202122232425class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;++i) &#123; cur-&gt;next=nex-&gt;next; nex-&gt;next=pre-&gt;next; pre-&gt;next=nex; nex=cur-&gt;next; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/25867/c-elegant-and-small C++ Elegant and Small 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: ListNode* reverse(ListNode* first, ListNode* last) &#123; ListNode* prev = last; while ( first != last ) &#123; auto tmp = first-&gt;next; first-&gt;next = prev; prev = first; first = tmp; &#125; return prev; &#125; ListNode* reverseKGroup(ListNode* head, int k) &#123; auto node=head; for (int i=0; i &lt; k; ++i) &#123; if ( ! node ) return head; // nothing to do list too sort node = node-&gt;next; &#125; auto new_head = reverse( head, node); head-&gt;next = reverseKGroup( node, k); return new_head; &#125;&#125;; https://discuss.leetcode.com/topic/17914/24ms-easy-c-iterative-solution-with-explanations 24ms Easy C++ Iterative Solution with Explanations Well, since the head pointer may also be modified, we create a new_head that points to it to facilitate the reverse process. For the example list 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 in the problem statement, it will become 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 (we init new_head -&gt; val to be 0). Then we set a pointer pre to new_head and another cur to head. Then we insert cur -&gt; next after pre for k - 1 times if the current node cur has at least k nodes after it (including itself). After reversing one k-group, we update pre to be cur and cur to be pre -&gt; next to reverse the next k-group. The code is as follows. 12345678910111213141516171819202122232425262728293031class Solution &#123; public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if (!hasKNodes(head, k)) return head; ListNode* new_head = new ListNode(0); new_head -&gt; next = head; ListNode* pre = new_head; ListNode* cur = head; while (hasKNodes(cur, k)) &#123; for (int i = 0; i &lt; k - 1; i++) &#123; ListNode* temp = pre -&gt; next; pre -&gt; next = cur -&gt; next; cur -&gt; next = cur -&gt; next -&gt; next; pre -&gt; next -&gt; next = temp; &#125; pre = cur; cur = pre -&gt; next; &#125; return new_head -&gt; next; &#125;private: bool hasKNodes(ListNode* node, int k) &#123; int cnt = 0; while (node) &#123; cnt++; if (cnt &gt;= k) return true; node = node -&gt; next; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/31618/succinct-iterative-python-o-n-time-o-1-space Succinct iterative Python, O(n) time O(1) space Use a dummy head, and l, r : define reversing range pre, cur : used in reversing, standard reverse linked linked list method jump : used to connect last node in previous k-group to first node in following k-group 12345678910111213141516def reverseKGroup(self, head, k): dummy = jump = ListNode(0) dummy.next = l = r = head while True: count = 0 while r and count &lt; k: # use r to locate the range r = r.next count += 1 if count == k: # if size k satisfied, reverse the inner linked list pre, cur = r, l for _ in range(k): cur.next, cur, pre = pre, cur.next, cur # standard reversing jump.next, jump, l = pre, l, r # connect two k-groups else: return dummy.next https://discuss.leetcode.com/topic/6956/simple-python-solution-one-pass-no-additional-space-109ms Simple Python solution, one pass, no additional space, 109ms The key idea is to keep track of the next_head while reversing the group, tail of the current group is always the start node of the group, once the group reversing is done, next_head is available, simply connect it to tail. 12345678910111213141516171819202122232425def reverseKGroup(self, head, k): if head is None or k &lt; 2: return head next_head = head for i in range(k - 1): next_head = next_head.next if next_head is None: return head ret = next_head current = head while next_head: tail = current prev = None for i in range(k): if next_head: next_head = next_head.next _next = current.next current.next = prev prev = current current = _next tail.next = next_head or current return ret java https://discuss.leetcode.com/topic/7126/short-but-recursive-java-code-with-comments Short but recursive Java code with comments Hi, guys! Despite the fact that the approach is recursive, the code is less than 20 lines. :) 123456789101112131415161718192021public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode curr = head; int count = 0; while (curr != null &amp;&amp; count != k) &#123; // find the k+1 node curr = curr.next; count++; &#125; if (count == k) &#123; // if k+1 node is found curr = reverseKGroup(curr, k); // reverse list with k+1 node as head // head - head-pointer to direct part, // curr - head-pointer to reversed part; while (count-- &gt; 0) &#123; // reverse current k-group: ListNode tmp = head.next; // tmp - next head in direct part head.next = curr; // preappending &quot;direct&quot; head to the reversed list curr = head; // move head of reversed part to a new node head = tmp; // move &quot;direct&quot; head to the next node in direct part &#125; head = curr; &#125; return head;&#125; Hope it helps! https://discuss.leetcode.com/topic/5604/share-my-java-solution-with-comments-in-line Share my Java Solution with comments in line 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if (head==null||head.next==null||k&lt;2) return head; ListNode dummy = new ListNode(0); dummy.next = head; ListNode tail = dummy, prev = dummy,temp; int count; while(true)&#123; count =k; while(count&gt;0&amp;&amp;tail!=null)&#123; count--; tail=tail.next; &#125; if (tail==null) break;//Has reached the end head=prev.next;//for next cycle // prev--&gt;temp--&gt;...---&gt;....---&gt;tail--&gt;.... // Delete @temp and insert to the next position of @tail // prev--&gt;...--&gt;...--&gt;tail--&gt;head--&gt;... // Assign @temp to the next node of @prev // prev--&gt;temp--&gt;...--&gt;tail--&gt;...--&gt;... // Keep doing until @tail is the next node of @prev while(prev.next!=tail)&#123; temp=prev.next;//Assign prev.next=temp.next;//Delete temp.next=tail.next; tail.next=temp;//Insert &#125; tail=head; prev=head; &#125; return dummy.next; &#125;&#125; https://discuss.leetcode.com/topic/12364/non-recursive-java-solution-and-idea Non-recursive Java solution and idea Reference: http://www.cnblogs.com/lichen782/p/leetcode_Reverse_Nodes_in_kGroup.html First, build a function reverse() to reverse the ListNode between begin and end. See the explanation below: 123456789101112131415test /** * Reverse a link list between begin and end exclusively * an example: * a linked list: * 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 * | | * begin end * after call begin = reverse(begin, end) * * 0-&gt;3-&gt;2-&gt;1-&gt;4-&gt;5-&gt;6 * | | * begin end * @return the reversed list&apos;s &apos;begin&apos; node, which is the precedence of node end */ Then walk thru the linked list and apply reverse() iteratively. See the code below. 123456789101112131415161718192021222324252627282930313233343536public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode begin; if (head==null || head.next ==null || k==1) return head; ListNode dummyhead = new ListNode(-1); dummyhead.next = head; begin = dummyhead; int i=0; while (head != null)&#123; i++; if (i%k == 0)&#123; begin = reverse(begin, head.next); head = begin.next; &#125; else &#123; head = head.next; &#125; &#125; return dummyhead.next; &#125;public ListNode reverse(ListNode begin, ListNode end)&#123; ListNode curr = begin.next; ListNode next, first; ListNode prev = begin; first = curr; while (curr!=end)&#123; next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; begin.next = prev; first.next = curr; return first;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[024. Swap Nodes in Pairs]]></title>
    <url>%2Fp%2F94079f17%2F</url>
    <content type="text"><![CDATA[38.3% https://leetcode.com/problems/swap-nodes-in-pairs/ Given a linked list, swap every two adjacent nodes and return its head. 12For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. æ–¹æ³•ä¸€ï¼š é€’å½’è°ƒç”¨ Simple implementation with C++ 123456789101112131415class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(head == NULL) return NULL; if(head-&gt;next == NULL) return head; ListNode* next = head-&gt;next; head-&gt;next = swapPairs(next-&gt;next); next-&gt;next = head; return next; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š é€’å½’æ–¹æ³•ï¼Œå®žçŽ°èµ·æ¥æœ€ç®€å• 123456789101112131415161718/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* nex = head-&gt;next; head-&gt;next = swapPairs(nex-&gt;next); nex-&gt;next = head; return nex; &#125;&#125;; å¦ä¸€ç§å®žçŽ° Very easy solution 123456789101112class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode *l=head; if(head&amp;&amp;head-&gt;next)&#123; l=head-&gt;next; head-&gt;next=swapPairs(l-&gt;next); l-&gt;next=head; &#125; return l; &#125;&#125;; æ–¹æ³•äºŒï¼š æˆ‘è‡ªå·±çš„æ–¹æ³•ï¼Œå¤šå®šä¹‰å‡ ä¸ªå˜é‡ï¼Œä¾æ¬¡è¿­ä»£ã€‚ 12345678910111213141516class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* cur = dummy; while(cur-&gt;next!=NULL &amp;&amp; cur-&gt;next-&gt;next!=NULL)&#123; ListNode* n1=cur-&gt;next, *n2 = cur-&gt;next-&gt;next, *n3=cur-&gt;next-&gt;next-&gt;next; cur-&gt;next = n2; n2-&gt;next = n1; n1-&gt;next = n3; cur = n1; &#125; return dummy-&gt;next; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* cur = dummy, *first, *second; while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123; first = cur-&gt;next; second = cur-&gt;next-&gt;next; first-&gt;next = second-&gt;next; second-&gt;next = first; cur-&gt;next = second; cur = first; &#125; return dummy-&gt;next; &#125;&#125;; cpp 4ms, 3.56%, July 14th, 2016 https://discuss.leetcode.com/topic/18860/7-8-lines-c-python-ruby 7-8 lines C++ / Python / Ruby Three different implementations of the same algorithm, taking advantage of different strengths of the three languages. I suggest reading all three, even if you donâ€™t know all three languages. All three of course work swap the current node with the next node by rearranging pointers, then move on to the next pair, and repeat until the end of the list. C++ Pointer-pointer pp points to the pointer to the current node. So at first, pp points to head, and later it points to the next field of ListNodes. Additionally, for convenience and clarity, pointers a and b point to the current node and the next node. We need to go from pp == a -&gt; b -&gt; (b-&gt;next) to pp == b -&gt; a -&gt; (b-&gt;next). The first three lines inside the loop do that, setting those three pointers (from right to left). The fourth line moves pp to the next pair. 12345678910ListNode* swapPairs(ListNode* head) &#123; ListNode **pp = &amp;head, *a, *b; while ((a = *pp) &amp;&amp; (b = a-&gt;next)) &#123; a-&gt;next = b-&gt;next; b-&gt;next = a; *pp = b; pp = &amp;(a-&gt;next); &#125; return head;&#125; Python Here, pre is the previous node. Since the head doesnâ€™t have a previous node, I just use self instead. Again, a is the current node and b is the next node. To go from pre -&gt; a -&gt; b -&gt; b.next to pre -&gt; b -&gt; a -&gt; b.next, we need to change those three references. Instead of thinking about in what order I change them, I just change all three at once. 12345678def swapPairs(self, head): pre, pre.next = self, head while pre.next and pre.next.next: a = pre.next b = a.next pre.next, b.next, a.next = b, a, b.next pre = a return self.next https://discuss.leetcode.com/topic/29060/simple-implementation-with-c Simple implementation with C++ 123456789101112131415class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(head == NULL) return NULL; if(head-&gt;next == NULL) return head; ListNode* next = head-&gt;next; head-&gt;next = swapPairs(next-&gt;next); next-&gt;next = head; return next; &#125;&#125;; https://discuss.leetcode.com/topic/31626/very-easy-solution Very easy solution 123456789101112class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode *l=head; if(head&amp;&amp;head-&gt;next)&#123; l=head-&gt;next; head-&gt;next=swapPairs(l-&gt;next); l-&gt;next=head; &#125; return l; &#125;&#125;; python 4ms, 3.56%, July 14th, 2016 https://discuss.leetcode.com/topic/18860/7-8-lines-c-python-ruby 12345678910111213141516171819# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def swapPairs(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; pre, pre.next = self, head while pre.next and pre.next.next: a = pre.next b = a.next pre.next, b.next, a.next = b, a, b.next pre = a return self.next java 0ms, 6.43%, July 14th, 2016 https://discuss.leetcode.com/topic/4351/my-accepted-java-code-used-recursion My accepted java code. used recursion. 123456789101112131415161718/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if((head == null) || (head.next == null)) return head; ListNode n = head.next; head.next = swapPairs(head.next.next); n.next = head; return n; &#125;&#125; 0ms, 6.43%, July 14th, 2016 https://discuss.leetcode.com/topic/10649/my-simple-java-solution-for-share My accepted java code. used recursion. 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode current = dummy; while(current.next != null &amp;&amp; current.next.next != null)&#123; ListNode first = current.next; ListNode second = current.next.next; first.next = second.next; current.next = second; current.next.next = first; current = current.next.next; &#125; return dummy.next; &#125;&#125; https://discuss.leetcode.com/topic/41459/java-simple-recursive-solution Java simple recursive solution Starting to see that recursion is the perfect tool for (many) linked list problems (this one + merging list problem). 1234567891011121314151617181920/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode second = head.next; ListNode third = second.next; second.next = head; head.next = swapPairs(third); return second; &#125;&#125; https://discuss.leetcode.com/topic/5163/my-simple-recursive-solution My simple recursive solution My solution is quite simple. Just find the reverse job is the same for every 2 nodes. 12345678910public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode newhd = head.next; head.next = swapPairs(newhd.next); newhd.next = head; return newhd;&#125; https://discuss.leetcode.com/topic/39095/my-straight-forward-java-solution-without-recursion-or-dummy-nodes-0ms My straight-forward Java solution without recursion or dummy nodes (0ms) The idea is straightforward: use two pointers and swap a.next = b.next, b.next = a. Then continue the next pair, b = a.next.next, a=a.next Remember to check null Remember to track new head Remember to link the new pair after the prior nodes.Attached is the accepted code. 12345678910111213141516public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head==null || head.next==null) return head; ListNode newHead = head.next, a=head,b=a.next,pre = null; while(a!=null &amp;&amp; b!=null)&#123; a.next = b.next; b.next = a; if(pre!=null) pre.next = b; if(a.next==null) break; b = a.next.next; pre = a; a = a.next; &#125; return newHead; &#125;&#125; AC, 0ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[023. Merge k Sorted Lists]]></title>
    <url>%2Fp%2F32640f57%2F</url>
    <content type="text"><![CDATA[26.4% https://leetcode.com/problems/merge-k-sorted-lists/ Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. æ–¹æ³•ä¸€ï¼š å¯¹è¿™ä¸ªvector&lt;ListNode*&gt; çš„å‰ä¸¤ä¸ªï¼Œè¿›è¡Œåˆå¹¶ï¼Œç„¶åŽåˆå¹¶ç»“æžœï¼Œ æ”¾å…¥vectorä¸­ï¼Œå†æŠŠvectorçš„å‰ä¸¤ä¸ªåˆ é™¤ã€‚åªè¦vectorçš„sizeä¸ä¸º1ï¼Œ ä¸€ç›´å¾ªçŽ¯ã€‚ æ³¨æ„ï¼Œvectoræœ‰eraseçš„å‡½æ•°ï¼Œç¤ºä¾‹å¦‚ä¸‹ï¼šlists.erase(lists.begin()); 123456789101112131415161718192021222324252627ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; if(lists.empty())&#123; return nullptr; &#125; while(lists.size() &gt; 1)&#123; lists.push_back(mergeTwoLists(lists[0], lists[1])); lists.erase(lists.begin()); lists.erase(lists.begin()); &#125; return lists.front();&#125;ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(l1 == nullptr)&#123; return l2; &#125; if(l2 == nullptr)&#123; return l1; &#125; if(l1-&gt;val &lt;= l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125;&#125; æˆ‘çš„ä»£ç å®žçŽ°: 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; // è€ƒè™‘å¼‚å¸¸ï¼Œä¸ºç©ºæ—¶ if(lists.empty()) return NULL; while(lists.size()&gt;1)&#123; ListNode* node = helper(lists[0], lists[1]); // å­¦ä¹ eraseçš„ç”¨æ³•ï¼Œé‡Œé¢ä½¿ç”¨çš„æ˜¯è¿­ä»£å™¨ lists.erase(lists.begin()); lists.erase(lists.begin()); lists.push_back(node); &#125; return lists[0]; &#125; ListNode* helper(ListNode* l1, ListNode* l2)&#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = helper(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = helper(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; æ–¹æ³•äºŒ: vector eraseæ•ˆçŽ‡å ªå¿§ï¼Œä½¿ç”¨dequeæ¥è§£å†³ 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; int n = lists.size(); if(n==0) return NULL; if(n==1) return lists[0]; deque&lt;ListNode*&gt; dq; for(auto node:lists) dq.push_back(node); while(dq.size()&gt;1)&#123; ListNode* l1 = dq.front(); dq.pop_front(); ListNode* l2 = dq.front(); dq.pop_front(); ListNode* l3 = merge(l1, l2); dq.push_back(l3); &#125; return dq.front(); &#125; ListNode* merge(ListNode* l1, ListNode* l2)&#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = merge(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = merge(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/6882/sharing-my-straightforward-c-solution-without-data-structure-other-than-vector Sharing my straightforward C++ solution without data structure other than vector 123456789101112131415161718192021222324252627ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; if(lists.empty())&#123; return nullptr; &#125; while(lists.size() &gt; 1)&#123; lists.push_back(mergeTwoLists(lists[0], lists[1])); lists.erase(lists.begin()); lists.erase(lists.begin()); &#125; return lists.front();&#125;ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(l1 == nullptr)&#123; return l2; &#125; if(l2 == nullptr)&#123; return l1; &#125; if(l1-&gt;val &lt;= l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125;&#125; The second function is from Merge Two Sorted Lists. The basic idea is really simple. We can merge first two lists and then push it back. Keep doing this until there is only one list left in vector. Actually, we can regard this as an iterative divide-and-conquer solution. https://discuss.leetcode.com/topic/7160/brief-c-solution-with-priority_queue Brief C++ solution with priority_queue We just need to define a comparison struct for ListNodes, then managing the priority_queue is quite straightforward. After filling the priority_queue, if it is non-empty, we set the head and tail. Then we repeatedly pop the top off the queue and append that to the tail. If the next node is not null, we push it onto the queue. 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; struct compare &#123; bool operator()(const ListNode* l, const ListNode* r) &#123; return l-&gt;val &gt; r-&gt;val; &#125; &#125;; public: ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, compare&gt; q; for (auto l : lists) &#123; if (l) &#123; q.push(l); &#125; &#125; if (q.empty()) &#123; return NULL; &#125; ListNode* result = q.top(); q.pop(); if (result-&gt;next) &#123; q.push(result-&gt;next); &#125; ListNode* tail = result; while (!q.empty()) &#123; tail-&gt;next = q.top(); q.pop(); tail = tail-&gt;next; if (tail-&gt;next) &#123; q.push(tail-&gt;next); &#125; &#125; return result; &#125;&#125;; python 128ms, 79.54%, September 4, 2016 https://discuss.leetcode.com/topic/23140/108ms-python-solution-with-heapq-and-avoid-changing-heap-size 108ms python solution with heapq and avoid changing heap size 123456789101112131415def mergeKLists(self, lists): from heapq import heappush, heappop, heapreplace, heapify dummy = node = ListNode(0) h = [(n.val, n) for n in lists if n] heapify(h) while h: v, n = h[0] if n.next is None: heappop(h) #only change heap size when necessary else: heapreplace(h, (n.next.val, n.next)) node.next = n node = node.next return dummy.next https://discuss.leetcode.com/topic/33609/10-line-python-solution-with-priority-queue 10-line python solution with priority queue 12345678910111213from Queue import PriorityQueueclass Solution(object): def mergeKLists(self, lists): dummy = ListNode(None) curr = dummy q = PriorityQueue() for node in lists: if node: q.put((node.val,node)) while q.qsize()&gt;0: curr.next = q.get()[1] curr=curr.next if curr.next: q.put((curr.next.val, curr.next)) return dummy.next java https://discuss.leetcode.com/topic/2780/a-java-solution-based-on-priority-queue A java solution based on Priority Queue If someone understand how priority queue works, then it would be trivial to walk through the codes. My question: is that possible to solve this question under the same time complexity without implementing the priority queue? 123456789101112131415161718192021222324252627282930313233public class Solution &#123; public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; if (lists==null||lists.size()==0) return null; PriorityQueue&lt;ListNode&gt; queue= new PriorityQueue&lt;ListNode&gt;(lists.size(),new Comparator&lt;ListNode&gt;()&#123; @Override public int compare(ListNode o1,ListNode o2)&#123; if (o1.val&lt;o2.val) return -1; else if (o1.val==o2.val) return 0; else return 1; &#125; &#125;); ListNode dummy = new ListNode(0); ListNode tail=dummy; for (ListNode node:lists) if (node!=null) queue.add(node); while (!queue.isEmpty())&#123; tail.next=queue.poll(); tail=tail.next; if (tail.next!=null) queue.add(tail.next); &#125; return dummy.next; &#125;&#125; https://discuss.leetcode.com/topic/2780/a-java-solution-based-on-priority-queue/4 I think my codeâ€™s complexity is also O(nlogk) and not using heap or priority queue, n means the total elements and k means the size of list. The mergeTwoLists functiony in my code comes from the problem Merge Two Sorted Lists whose complexity obviously is O(n), n is the sum of length of l1 and l2. To put it simpler, assume the k is 2^x, So the progress of combination is like a full binary tree, from bottom to top. So on every level of tree, the combination complexity is n, beacause every level have all n numbers without repetition. The level of tree is x, ie logk. So the complexity is O(nlogk). 12345678910for example, 8 ListNode, and the length of every ListNode is x1, x2,x3, x4, x5, x6, x7, x8, total is n.on level 3: x1+x2, x3+x4, x5+x6, x7+x8 sum: non level 2: x1+x2+x3+x4, x5+x6+x7+x8 sum: non level 1: x1+x2+x3+x4+x5+x6+x7+x8 sum: ntotal 3n, nlog8 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; ListNode head=null; ListNode former=null; while (l1!=null&amp;&amp;l2!=null) &#123; if (l1.val&gt;l2.val) &#123; if (former==null) former=l2; else former.next=l2; if (head==null) head=former; else former=former.next; l2=l2.next; &#125; else &#123; if (former==null) former=l1; else former.next=l1; if (head==null) head=former; else former=former.next; l1=l1.next; &#125; &#125; if (l2!=null) l1=l2; former.next=l1; return head; &#125; public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; if (lists.size()==0) return null; if (lists.size()==1) return lists.get(0); if (lists.size()==2) return mergeTwoLists(lists.get(0), lists.get(1)); return mergeTwoLists(mergeKLists(lists.subList(0, lists.size()/2)), mergeKLists(lists.subList(lists.size()/2, lists.size()))); &#125;&#125; 3ms, 91.70%, September 5, 2016 https://discuss.leetcode.com/topic/26095/my-simple-java-solution-use-recursion My simple java Solution use recursion 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; return partion(lists, 0, lists.length-1); &#125; public static ListNode partion(ListNode[] lists, int s, int e)&#123; if(s==e) return lists[s]; if(s&lt;e)&#123; int q = (s+e) / 2; ListNode l1 = partion(lists, s, q); ListNode l2 = partion(lists, q+1, e); return merge(l1, l2); &#125;else return null; &#125; public static ListNode merge(ListNode l1, ListNode l2)&#123; if(l1==null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val)&#123; l1.next = merge(l1.next, l2); return l1; &#125;else&#123; l2.next = merge(l1, l2.next); return l2; &#125; &#125;&#125; https://discuss.leetcode.com/topic/31276/simple-java-merge-sort Simple Java Merge Sort For this problem, use merge sort is simple and fast, I wonder why some guys solve it use PriorityQueue. I think the complexity is k n logk. Because the recursion depth is logK, and in each level, every element will be compared. 1234567891011121314151617public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) return null; return mergeKLists(lists, 0, lists.length - 1);&#125;private ListNode mergeKLists(ListNode[] lists, int start, int end) &#123; if (start == end) &#123; return lists[start]; &#125; else if (start &lt; end)&#123; int mid = (end - start) / 2 + start; ListNode left = mergeKLists(lists, start, mid); ListNode right = mergeKLists(lists, mid + 1, end); return mergeTwoLists(left, right); &#125; else &#123; return null; &#125;&#125; mergeTwoLists is base on the Merge Two Sorted Lists problem. https://discuss.leetcode.com/topic/8949/13-lines-in-java 13-lines in Java Hi guys! The approach is standard - PriorityQueue, but I noticed that solutions presented before are kind of a bit long. So thatâ€™s the concise version. :) Hope it helps! 1234567891011121314151617public class Solution &#123; public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; Queue&lt;ListNode&gt; heap = new PriorityQueue(new Comparator&lt;ListNode&gt;()&#123; @Override public int compare(ListNode l1, ListNode l2) &#123; return l1.val - l2.val; &#125; &#125;); ListNode head = new ListNode(0), tail = head; for (ListNode node : lists) if (node != null) heap.offer(node); while (!heap.isEmpty()) &#123; tail.next = heap.poll(); tail = tail.next; if (tail.next != null) heap.offer(tail.next); &#125; return head.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>divide and conquer</tag>
        <tag>hard</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[022. Generate Parentheses]]></title>
    <url>%2Fp%2Fa9da9348%2F</url>
    <content type="text"><![CDATA[33.4% https://leetcode.com/problems/generate-parentheses/ Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] æ–¹æ³•ä¸€ï¼š The idea is intuitive. Use two integers to count the remaining left parenthesis (n) and the right parenthesis (m) to be added. At each function call add a left parenthesis if n &gt;0 and add a right parenthesis if m&gt;0. Append the result and terminate recursive calls when both m and n are zero. https://leetcode.com/discuss/14436/concise-recursive-c-solution 123456789101112131415161718class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; addingpar(res, &quot;&quot;, n, 0); return res; &#125; void addingpar(vector&lt;string&gt; &amp;v,string str, int n, int m)&#123; if(m==0 &amp;&amp; n==0)&#123; v.push_back(str); return; &#125; if(m&gt;0) addingpar(v, str+&quot;)&quot;, n, m-1); if(n&gt;0) addingpar(v, str+&quot;(&quot;, n-1, m+1); &#125;&#125;; æ–¹æ³•äºŒï¼š https://discuss.leetcode.com/topic/15294/6-lines-c-3-4-ms-super-easy-to-understand 6 lines c++ 3~4 ms, super easy to understand 123456789101112vector&lt;string&gt; result;void helper(string str, int left, int right)&#123; if(left == 0 &amp;&amp; right == 0) result.push_back(str); if(left!=0) helper(str+&apos;(&apos;, left-1, right); if(right!=0 &amp;&amp; right &gt; left) helper(str+&apos;)&apos;, left, right-1);&#125; vector&lt;string&gt; generateParenthesis(int n) &#123; helper(&quot;&quot;,n,n); return result;&#125; æˆ‘çš„ä»£ç å®žçŽ°ï¼š é€’å½’ï¼Œ å¾ªçŽ¯è°ƒç”¨æ ˆ,æ¶ˆè€—å†…å­˜ 1234567891011121314151617class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; helper(res, n, n, ""); return res; &#125; void helper(vector&lt;string&gt;&amp; res, int left, int right, string s)&#123; if(left==0 &amp;&amp; right==0) res.push_back(s); if(left!=0) helper(res, left-1, right, s+'('); if(right!=0 &amp;&amp; right&gt;left) helper(res, left, right-1, s+')'); &#125;&#125;; æ–¹æ³•ä¸‰ï¼› dpè§£æ³• https://discuss.leetcode.com/topic/3474/an-iterative-method My method is DP. First consider how to get the result f(n) from previous result f(0)â€¦f(n-1).Actually, the result f(n) will be put an extra () pair to f(n-1). Let the â€œ(â€œ always at the first position, to produce a valid result, we can only put â€œ)â€ in a way that there will be i pairs () inside the extra () and n - 1 - i pairs () outside the extra pair. Let us consider an example to get clear view: f(0): â€œâ€ f(1): â€œ(â€œf(0)â€)â€ f(2): â€œ(â€œf(0)â€)â€f(1), â€œ(â€œf(1)â€)â€ f(3): â€œ(â€œf(0)â€)â€f(2), â€œ(â€œf(1)â€)â€f(1), â€œ(â€œf(2)â€)â€ So f(n) = â€œ(â€œf(0)â€)â€f(n-1) , â€œ(â€œf(1)â€)â€f(n-2) â€œ(â€œf(2)â€)â€f(n-3) â€¦ â€œ(â€œf(i)â€)â€f(n-1-i) â€¦ â€œ(f(n-1)â€)â€ Below is my code: æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; // æ³¨æ„å®šä¹‰åŠåˆå§‹åŒ–çš„é—®é¢˜ï¼Œvector&lt;string&gt;()ï¼Œè€Œä¸æ˜¯vector&lt;string&gt; vector&lt;vector&lt;string&gt;&gt; dp(n+1, vector&lt;string&gt;()); // å­¦ä¹ æ­¤å¤„çš„åˆå§‹åŒ– dp[0] = vector&lt;string&gt;&#123;""&#125;; for(int i=1; i&lt;=n; i++)&#123; for(int j=0; j&lt;i; j++) for(string first:dp[j]) for(string second:dp[i-j-1])&#123; string t = '(' + first + ')' + second; dp[i].push_back(t); &#125; &#125; return dp[n]; &#125;&#125;; cpp The idea is intuitive. Use two integers to count the remaining left parenthesis (n) and the right parenthesis (m) to be added. At each function call add a left parenthesis if n &gt;0 and add a right parenthesis if m&gt;0. Append the result and terminate recursive calls when both m and n are zero. https://leetcode.com/discuss/14436/concise-recursive-c-solution123456789101112131415161718class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; addingpar(res, &quot;&quot;, n, 0); return res; &#125; void addingpar(vector&lt;string&gt; &amp;v,string str, int n, int m)&#123; if(m==0 &amp;&amp; n==0)&#123; v.push_back(str); return; &#125; if(m&gt;0) addingpar(v, str+&quot;)&quot;, n, m-1); if(n&gt;0) addingpar(v, str+&quot;(&quot;, n-1, m+1); &#125;&#125;; python https://leetcode.com/discuss/43122/4-7-lines-python 4-7 lines Python p is the parenthesis-string built so far, left and right tell the number of left and right parentheses still to add, and parens collects the parentheses. Solution 1 I used a few â€œtricksâ€â€¦ how many can you find? :-) 1234567def generateParenthesis(self, n): def generate(p, left, right, parens=[]): if left: generate(p + &apos;(&apos;, left-1, right) if right &gt; left: generate(p + &apos;)&apos;, left, right-1) if not right: parens += p, return parens return generate(&apos;&apos;, n, n) Solution 2 Here I wrote an actual Python generator. I allow myself to put the yield q at the end of the line because itâ€™s not that bad and because in â€œreal lifeâ€ I use Python 3 where I just say yield from generate(â€¦). 12345678def generateParenthesis(self, n): def generate(p, left, right): if right &gt;= left &gt;= 0: if not right: yield p for q in generate(p + &apos;(&apos;, left-1, right): yield q for q in generate(p + &apos;)&apos;, left, right-1): yield q return list(generate(&apos;&apos;, n, n)) Solution 3 Improved version of this. Parameter open tells the number of â€œalready openedâ€ parentheses, and I continue the recursion as long as I still have to open parentheses (n &gt; 0) and I havenâ€™t made a mistake yet (open &gt;= 0). 12345def generateParenthesis(self, n, open=0): if n &gt; 0 &lt;= open: return [&apos;(&apos; + p for p in self.generateParenthesis(n-1, open+1)] + \ [&apos;)&apos; + p for p in self.generateParenthesis(n, open-1)] return [&apos;)&apos; * open] * (not n) java The idea here is to only add â€˜(â€˜ and â€˜)â€™ that we know will guarantee us a solution (instead of adding 1 too many close). Once we add a â€˜(â€˜ we will then discard it and try a â€˜)â€™ which can only close a valid â€˜(â€˜. Each of these steps are recursively called. https://leetcode.com/discuss/25063/easy-to-understand-java-backtracking-solution 1234567891011121314151617181920public class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); backtrack(list, &quot;&quot;, 0, 0, n); return list; &#125; public void backtrack(List&lt;String&gt; list, String str, int open, int close, int max)&#123; if(str.length() == max*2)&#123; list.add(str); return; &#125; if(open&lt;max) backtrack(list, str+&quot;(&quot;, open+1, close, max); if(close&lt;open) backtrack(list, str+&quot;)&quot;, open, close+1, max); &#125; &#125; https://discuss.leetcode.com/topic/3474/an-iterative-method An iterative method. My method is DP. First consider how to get the result f(n) from previous result f(0)â€¦f(n-1).Actually, the result f(n) will be put an extra () pair to f(n-1). Let the â€œ(â€œ always at the first position, to produce a valid result, we can only put â€œ)â€ in a way that there will be i pairs () inside the extra () and n - 1 - i pairs () outside the extra pair. 1234567891011Let us consider an example to get clear view:f(0): &quot;&quot;f(1): &quot;(&quot;f(0)&quot;)&quot;f(2): &quot;(&quot;f(0)&quot;)&quot;f(1), &quot;(&quot;f(1)&quot;)&quot;f(3): &quot;(&quot;f(0)&quot;)&quot;f(2), &quot;(&quot;f(1)&quot;)&quot;f(1), &quot;(&quot;f(2)&quot;)&quot;So f(n) = &quot;(&quot;f(0)&quot;)&quot;f(n-1) , &quot;(&quot;f(1)&quot;)&quot;f(n-2) &quot;(&quot;f(2)&quot;)&quot;f(n-3) ... &quot;(&quot;f(i)&quot;)&quot;f(n-1-i) ... &quot;(f(n-1)&quot;)&quot; Below is my code: 12345678910111213141516171819202122232425262728public class Solution&#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;&gt;(); lists.add(Collections.singletonList(&quot;&quot;)); for (int i = 1; i &lt;= n; ++i) &#123; final List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; i; ++j) &#123; for (final String first : lists.get(j)) &#123; for (final String second : lists.get(i - 1 - j)) &#123; list.add(&quot;(&quot; + first + &quot;)&quot; + second); &#125; &#125; &#125; lists.add(list); &#125; return lists.get(lists.size() - 1); &#125;&#125; https://discuss.leetcode.com/topic/23229/java-dfs-way-solution Java DFS way solution 1234567891011121314151617181920public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); generateOneByOne(&quot;&quot;, list, n, n); return list;&#125;public void generateOneByOne(String sublist, List&lt;String&gt; list, int left, int right)&#123; if(left &gt; right)&#123; return; &#125; if(left &gt; 0)&#123; generateOneByOne( sublist + &quot;(&quot; , list, left-1, right); &#125; if(right &gt; 0)&#123; generateOneByOne( sublist + &quot;)&quot; , list, left, right-1); &#125; if(left == 0 &amp;&amp; right == 0)&#123; list.add(sublist); return; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[021. Merge Two Sorted Lists]]></title>
    <url>%2Fp%2F149a587d%2F</url>
    <content type="text"><![CDATA[39.2% https://leetcode.com/problems/merge-two-sorted-lists/ Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. å‰‘æŒ‡offer 17é¢˜ æ–¹æ³•ä¸€ï¼š ç®€å•çš„é€’å½’å°±è¡Œäº† æˆ‘çš„ä»£ç å®žçŽ°ï¼š Oct 11ï¼Œ 2017 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 1234567891011121314class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(l1==NULL) return l2; if(l2==NULL) return l1; if(l1-&gt;val &lt;= l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; æ–¹æ³•äºŒï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125; cur = cur-&gt;next; &#125; if(l1) cur-&gt;next = l1; if(l2) cur-&gt;next = l2; return dummy-&gt;next; &#125;&#125;; è¿­ä»£å½¢å¼çš„å†™æ³• 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; ListNode dummy(INT_MIN); ListNode *tail = &amp;dummy; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; tail-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; tail-&gt;next = l2; l2 = l2-&gt;next; &#125; tail = tail-&gt;next; &#125; tail-&gt;next = l1 ? l1 : l2; return dummy.next; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125; // curä¸è¦å¿˜è®°å‰å‘èµ° cur = cur-&gt;next; &#125; // å¯¹äºŽé“¾è¡¨ï¼Œå‰©ä¸‹çš„ä¸€éƒ¨åˆ†ç‰¹åˆ«å¥½å¤„ç† cur-&gt;next = l1 ? l1 : l2; return dummy-&gt;next; &#125;&#125;; cpp https://discuss.leetcode.com/topic/2513/a-recursive-solution A recursive solution 123456789101112131415class Solution &#123;public: ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(l1 == NULL) return l2; if(l2 == NULL) return l1; if(l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l2-&gt;next, l1); return l2; &#125; &#125;&#125;; This solution is not a tail-recursive, the stack will overflow while the list is too long :) http://en.wikipedia.org/wiki/Tail_call 12ms, 7.11%, June.18th, 2016 https://leetcode.com/discuss/18986/14-line-clean-c-solution 14 line clean C++ Solution 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; ListNode dummy(INT_MIN); ListNode *tail = &amp;dummy; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; tail-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; tail-&gt;next = l2; l2 = l2-&gt;next; &#125; tail = tail-&gt;next; &#125; tail-&gt;next = l1 ? l1 : l2; return dummy.next; &#125;&#125;; https://discuss.leetcode.com/topic/4480/clean-simple-o-n-m-c-solution-without-dummy-head-and-recurtion Clean, simple O(n+m) C++ Solution, without dummy head and recurtion Please refer to the comments inline. 1234567891011121314151617181920212223242526ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(NULL == l1) return l2; if(NULL == l2) return l1; ListNode* head=NULL; // head of the list to return // find first element (can use dummy node to put this part inside of the loop) if(l1-&gt;val &lt; l2-&gt;val) &#123; head = l1; l1 = l1-&gt;next; &#125; else &#123; head = l2; l2 = l2-&gt;next; &#125; ListNode* p = head; // pointer to form new list // I use &amp;&amp; to remove extra IF from the loop while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val) &#123; p-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; p-&gt;next = l2; l2 = l2-&gt;next; &#125; p=p-&gt;next; &#125; // add the rest of the tail, done! if(l1) p-&gt;next=l1; else p-&gt;next=l2; return head;&#125; python https://leetcode.com/discuss/51679/python-solutions-iteratively-recursively-iteratively-place Python solutions (iteratively, recursively, iteratively in-place). 12345678910111213# iterativelydef mergeTwoLists1(self, l1, l2): dummy = cur = ListNode(0) while l1 and l2: if l1.val &lt; l2.val: cur.next = l1 l1 = l1.next else: cur.next = l2 l2 = l2.next cur = cur.next cur.next = l1 or l2 return dummy.next 12345678910# recursively def mergeTwoLists2(self, l1, l2): if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2 123456789101112131415161718# in-place, iteratively def mergeTwoLists(self, l1, l2): if None in (l1, l2): return l1 or l2 dummy = cur = ListNode(0) dummy.next = l1 while l1 and l2: if l1.val &lt; l2.val: l1 = l1.next else: nxt = cur.next cur.next = l2 tmp = l2.next l2.next = nxt l2 = tmp cur = cur.next cur.next = l1 or l2 return dummy.next java https://discuss.leetcode.com/topic/5513/my-recursive-way-to-solve-this-problem-java-easy-understanding My recursive way to solve this problem(JAVA, easy understanding) Hello every one, here is my code, simple but works well: 123456789101112131415161718192021public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null)&#123; return l2; &#125; if(l2 == null)&#123; return l1; &#125; ListNode mergeHead; if(l1.val &lt; l2.val)&#123; mergeHead = l1; mergeHead.next = mergeTwoLists(l1.next, l2); &#125; else&#123; mergeHead = l2; mergeHead.next = mergeTwoLists(l1, l2.next); &#125; return mergeHead; &#125;&#125; https://discuss.leetcode.com/topic/45002/java-1-ms-4-lines-codes-using-recursion Java, 1 ms, 4 lines codes, using recursion 1234567891011public ListNode mergeTwoLists(ListNode l1, ListNode l2)&#123; if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val)&#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else&#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; https://discuss.leetcode.com/topic/5199/java-solution-for-reference Java solution for reference Similar to array, the difference is if any of two listnode is not null after first loop, we only need to add it as previous nodeâ€™s next and no need to add them one by one. 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null &amp;&amp; l2 == null) &#123; return null; &#125; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; ListNode result = new ListNode(0); ListNode prev = result; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; prev.next = l1; l1 = l1.next; &#125; else &#123; prev.next = l2; l2 = l2.next; &#125; prev = prev.next; &#125; if (l1 != null) &#123; prev.next = l1; &#125; if (l2 != null) &#123; prev.next = l2; &#125; return result.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[020. Valid Parentheses]]></title>
    <url>%2Fp%2F44690127%2F</url>
    <content type="text"><![CDATA[32.5% https://leetcode.com/problems/valid-parentheses/ Given a string containing just the characters â€˜(â€˜, â€˜)â€™, â€˜{â€˜, â€˜}â€™, â€˜[â€˜ and â€˜]â€™, determine if the input string is valid. The brackets must close in the correct order, â€œ()â€ and â€œ()[]{}â€ are all valid but â€œ(]â€ and â€œ([)]â€ are not. æ–¹æ³•ä¸€ï¼š ä½¿ç”¨æ ˆï¼Œä¾æ¬¡è¿›è¡Œè€ƒè™‘ã€‚ My 0ms c++ solution using stack code 1ï¼š 1234567891011121314bool isValid(string s) &#123; stack&lt;char&gt; st; for(char c : s)&#123; if(c == &apos;(&apos;|| c == &apos;&#123;&apos; || c == &apos;[&apos;)&#123; st.push(c); &#125;else&#123; if(st.empty()) return false; if(c == &apos;)&apos; &amp;&amp; st.top() != &apos;(&apos;) return false; if(c == &apos;&#125;&apos; &amp;&amp; st.top() != &apos;&#123;&apos;) return false; if(c == &apos;]&apos; &amp;&amp; st.top() != &apos;[&apos;) return false; st.pop(); &#125; &#125; return st.empty(); æ–¹æ³•äºŒ: æˆ‘çš„ä»£ç å®žçŽ°: 12345678910111213141516171819class Solution &#123;public: bool isValid(string s) &#123; if(s.empty()) return true; stack&lt;char&gt; stack; unordered_map&lt;char, char&gt; map = &#123;&#123;'(', ')'&#125;, &#123;'[', ']'&#125;, &#123;'&#123;', '&#125;'&#125;&#125;; for(auto c:s)&#123; if(map.find(c)!=map.end()) stack.push(map[c]); else&#123; if(!stack.empty() &amp;&amp; stack.top()==c) stack.pop(); else return false; &#125; &#125; return stack.empty(); &#125;&#125;; é‡ç‚¹å­¦ä¸€ä¸‹ï¼Œè¿›ä¸€ä¸ªmapï¼ŒåŠmapçš„èµ‹å€¼æ“ä½œã€‚ 1234567891011121314151617181920212223class Solution &#123; public: bool isValid(string s) &#123; map&lt;char, char&gt; parenth_dict; parenth_dict[&apos;(&apos;] = &apos;)&apos;; parenth_dict[&apos;&#123;&apos;] = &apos;&#125;&apos;; parenth_dict[&apos;[&apos;] = &apos;]&apos;; stack&lt;char&gt; aux; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos;(&apos; || s[i] == &apos;&#123;&apos; || s[i] == &apos;[&apos;) aux.push(s[i]); else if (aux.empty() || parenth_dict[aux.top()] != s[i]) return false; else aux.pop(); &#125; return aux.empty(); &#125;&#125;; java https://discuss.leetcode.com/topic/7813/my-easy-to-understand-java-solution-with-one-stack My easy to understand Java Solution with one stack 12345678910111213141516171819202122public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); // Iterate through string until empty for(int i = 0; i&lt;s.length(); i++) &#123; // Push any open parentheses onto stack if(s.charAt(i) == &apos;(&apos; || s.charAt(i) == &apos;[&apos; || s.charAt(i) == &apos;&#123;&apos;) stack.push(s.charAt(i)); // Check stack for corresponding closing parentheses, false if not valid else if(s.charAt(i) == &apos;)&apos; &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == &apos;(&apos;) stack.pop(); else if(s.charAt(i) == &apos;]&apos; &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == &apos;[&apos;) stack.pop(); else if(s.charAt(i) == &apos;&#125;&apos; &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == &apos;&#123;&apos;) stack.pop(); else return false; &#125; // return true if no open parentheses left in stack return stack.empty(); &#125;&#125; https://discuss.leetcode.com/topic/27572/short-java-solution Short java solution1234567891011121314public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c : s.toCharArray()) &#123; if (c == &apos;(&apos;) stack.push(&apos;)&apos;); else if (c == &apos;&#123;&apos;) stack.push(&apos;&#125;&apos;); else if (c == &apos;[&apos;) stack.push(&apos;]&apos;); else if (stack.isEmpty() || stack.pop() != c) return false; &#125; return stack.isEmpty();&#125; https://discuss.leetcode.com/topic/9372/12-lines-of-java 12 lines of Java 123456789101112public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Integer&gt; p = new Stack&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++) &#123; int q = &quot;()&#123;&#125;[]&quot;.indexOf(s.substring(i, i + 1)); if(q % 2 == 1) &#123; if(p.isEmpty() || p.pop() != q - 1) return false; &#125; else p.push(q); &#125; return p.isEmpty(); &#125;&#125; https://discuss.leetcode.com/topic/27768/short-easy-to-follow-8ms-java-solution Short, Easy to Follow 8ms Java Solution 123456789101112public class Solution &#123; public boolean isValid(String s) &#123; int length; do &#123; length = s.length(); s = s.replace(&quot;()&quot;, &quot;&quot;).replace(&quot;&#123;&#125;&quot;, &quot;&quot;).replace(&quot;[]&quot;, &quot;&quot;); &#125; while(length != s.length()); return s.length() == 0; &#125;&#125; In this solution you essentially can remove parentheses that you know are valid until the string is empty. If the string is not empty, that means that the parentheses were malformed. https://discuss.leetcode.com/topic/47067/java-iterative-solution-beating-97 Java iterative solution beating 97% Just implement a simple stack using a char array and check that, for each closing bracket, there is its counterpart in the top of the stack. 1234567891011121314151617181920212223242526public class Solution &#123; public boolean isValid(String s) &#123; char[] stack = new char[s.length()]; int head = 0; for(char c : s.toCharArray()) &#123; switch(c) &#123; case &apos;&#123;&apos;: case &apos;[&apos;: case &apos;(&apos;: stack[head++] = c; break; case &apos;&#125;&apos;: if(head == 0 || stack[--head] != &apos;&#123;&apos;) return false; break; case &apos;)&apos;: if(head == 0 || stack[--head] != &apos;(&apos;) return false; break; case &apos;]&apos;: if(head == 0 || stack[--head] != &apos;[&apos;) return false; break; &#125; &#125; return head == 0; &#125;&#125; my code: 1234567891011121314151617181920212223public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); if(s==null || s.length()==0) return true; for(int i=0; i&lt;s.length(); i++)&#123; char tmp = s.charAt(i); if(!stack.empty() &amp;&amp; tmp==&apos;)&apos; &amp;&amp; stack.peek()==&apos;(&apos;) stack.pop(); else if(!stack.empty() &amp;&amp; tmp==&apos;]&apos; &amp;&amp; stack.peek()==&apos;[&apos;) stack.pop(); else if(!stack.empty() &amp;&amp; tmp==&apos;&#125;&apos; &amp;&amp; stack.peek()==&apos;&#123;&apos;) stack.pop(); else if(tmp==&apos;(&apos; || tmp==&apos;[&apos; || tmp==&apos;&#123;&apos;) stack.push(tmp); else return false; &#125; if(stack.empty()) return true; else return false; &#125;&#125; cpp https://discuss.leetcode.com/topic/13231/2ms-c-sloution 2ms C++ sloution Repetitive code but I guess this is clean, and easy to understand. This solution also accepts (and ignores) any characters other than parenthesis in the string. Hence, it can be used to check if the parenthesis matches in an equation for example. 1234567891011121314151617181920#include &lt;stack&gt;class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; paren; for (char&amp; c : s) &#123; switch (c) &#123; case &apos;(&apos;: case &apos;&#123;&apos;: case &apos;[&apos;: paren.push(c); break; case &apos;)&apos;: if (paren.empty() || paren.top()!=&apos;(&apos;) return false; else paren.pop(); break; case &apos;&#125;&apos;: if (paren.empty() || paren.top()!=&apos;&#123;&apos;) return false; else paren.pop(); break; case &apos;]&apos;: if (paren.empty() || paren.top()!=&apos;[&apos;) return false; else paren.pop(); break; default: ; // pass &#125; &#125; return paren.empty() ; &#125;&#125;; https://discuss.leetcode.com/topic/32413/my-0ms-c-solution-using-stack My 0ms c++ solution using stack 1234567891011121314bool isValid(string s) &#123; stack&lt;char&gt; st; for(char c : s)&#123; if(c == &apos;(&apos;|| c == &apos;&#123;&apos; || c == &apos;[&apos;)&#123; st.push(c); &#125;else&#123; if(st.empty()) return false; if(c == &apos;)&apos; &amp;&amp; st.top() != &apos;(&apos;) return false; if(c == &apos;&#125;&apos; &amp;&amp; st.top() != &apos;&#123;&apos;) return false; if(c == &apos;]&apos; &amp;&amp; st.top() != &apos;[&apos;) return false; st.pop(); &#125; &#125; return st.empty(); https://discuss.leetcode.com/topic/7188/sharing-my-simple-cpp-code-with-2ms Sharing my simple cpp code with 2ms 1234567891011121314151617181920212223class Solution &#123; public: bool isValid(string s) &#123; map&lt;char, char&gt; parenth_dict; parenth_dict[&apos;(&apos;] = &apos;)&apos;; parenth_dict[&apos;&#123;&apos;] = &apos;&#125;&apos;; parenth_dict[&apos;[&apos;] = &apos;]&apos;; stack&lt;char&gt; aux; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos;(&apos; || s[i] == &apos;&#123;&apos; || s[i] == &apos;[&apos;) aux.push(s[i]); else if (aux.empty() || parenth_dict[aux.top()] != s[i]) return false; else aux.pop(); &#125; return aux.empty(); &#125;&#125;; python https://discuss.leetcode.com/topic/6534/simple-python-solution-with-stack Simple Python solution with stack 1234567891011121314class Solution: # @return a boolean def isValid(self, s): stack = [] dict = &#123;&quot;]&quot;:&quot;[&quot;, &quot;&#125;&quot;:&quot;&#123;&quot;, &quot;)&quot;:&quot;(&quot;&#125; for char in s: if char in dict.values(): stack.append(char) elif char in dict.keys(): if stack == [] or dict[char] != stack.pop(): return False else: return False return stack == [] https://discuss.leetcode.com/topic/40897/python-is-this-a-cheating-method-accepted-with-40ms-easy-to-understand-but [Python] is this a cheating method? accepted with 40ms, easy to understand, but 1234567891011121314151617181920class Solution(object): def isValid(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; n = len(s) if n == 0: return True if n % 2 != 0: return False while &apos;()&apos; in s or &apos;&#123;&#125;&apos; in s or &apos;[]&apos; in s: s = s.replace(&apos;&#123;&#125;&apos;,&apos;&apos;).replace(&apos;()&apos;,&apos;&apos;).replace(&apos;[]&apos;,&apos;&apos;) if s == &apos;&apos;: return True else: return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[019. Remove Nth Node From End of List]]></title>
    <url>%2Fp%2F72420d7f%2F</url>
    <content type="text"><![CDATA[33.6% https://leetcode.com/problems/remove-nth-node-from-end-of-list/ Given a linked list, remove the nth node from the end of list and return its head. 12345For example,Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Try to do this in one pass. ç±»ä¼¼äºŽå‰‘æŒ‡offer 15 æ–¹æ³•ä¸€ï¼š 4ms, 37.53%, September 3, 2016 https://discuss.leetcode.com/topic/5397/my-short-c-solution My short C++ solution 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode** t1 = &amp;head, *t2 = head; for(int i=1; i&lt;n; ++i) t2 = t2-&gt;next; while(t2-&gt;next != NULL)&#123; t1 = &amp;((*t1)-&gt;next); t2 = t2 -&gt; next; &#125; *t1 = (*t1)-&gt;next; return head; &#125;&#125;; æ–¹æ³•äºŒï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; // é“¾è¡¨ç»å¸¸åœ¨å¤´éƒ¨è®¾ç½®ä¸€ä¸ªå“‘å˜é‡ï¼Œ é’ˆå¯¹ä¸€äº›ç‰¹æ®Šæƒ…å†µï¼Œéžå¸¸æœ‰æ•ˆ ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* fast = dummy, *slow = dummy; while(n&gt;0)&#123; fast = fast-&gt;next; n--; &#125; while(fast-&gt;next)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return dummy-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/7753/c-solution-easy-to-understand-with-explanations C++ solution, easy to understand with explanations. Renewed SolutionThe difference between the final node and the to_be_delete node is N. And here the assumption is that n is always valid. fast pointer points to the node which is N step away from the to_be_delete node. slow pointer points to the to_be_delete node. The algorithms is described as below: Firstly, move fast pointer N step forward. Secondly,move fast and slow pointers simultaneously one step a time forward till the fast pointer reach the end, which will cause the slow pointer points to the previous node of the to_be_delete node. Finally, slow-&gt;next = slow-&gt;next-&gt;next. 1234567891011121314151617181920212223242526ListNode *removeNthFromEnd(ListNode *head, int n) &#123; if (!head) return nullptr; ListNode new_head(-1); new_head.next = head; ListNode *slow = &amp;new_head, *fast = &amp;new_head; for (int i = 0; i &lt; n; i++) fast = fast-&gt;next; while (fast-&gt;next) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; ListNode *to_de_deleted = slow-&gt;next; slow-&gt;next = slow-&gt;next-&gt;next; delete to_be_deleted; return new_head.next;&#125; Fixed : Added code for deleting the N-th node. java 1ms, 5.49%, September 3, 2016 https://discuss.leetcode.com/topic/7031/simple-java-solution-in-one-pass Simple Java solution in one pass A one pass solution can be done using pointers. Move one pointer fast â€“&gt; n+1 places forward, to maintain a gap of n between the two pointers and then move both at the same speed. Finally, when the fast pointer reaches the end, the slow pointer will be n+1 places behind - just the right spot for it to be able to skip the next node. Since the question gives that n is valid, not too many checks have to be put in place. Otherwise, this would be necessary. 12345678910111213141516171819public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode start = new ListNode(0); ListNode slow = start, fast = start; slow.next = head; //Move fast in front so that the gap between slow and fast becomes n for(int i=1; i&lt;=n+1; i++) &#123; fast = fast.next; &#125; //Move fast to the end, maintaining the gap while(fast != null) &#123; slow = slow.next; fast = fast.next; &#125; //Skip the desired node slow.next = slow.next.next; return start.next;&#125; 1ms, 5.49%, September 3, 2016 https://discuss.leetcode.com/topic/20745/my-one-pass-solution My one pass solution 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode h1 = head, h2=head; while(n--&gt;0) h2 = h2.next; if(h2==null) return head.next; h2=h2.next; while(h2!=null)&#123; h1 = h1.next; h2 = h2.next; &#125; h1.next = h1.next.next; return head; &#125;&#125; https://discuss.leetcode.com/topic/42339/java-solution-1ms-%E5%AE%B9%E6%98%93%E7%90%86%E8%A7%A3 Java solution 1ms å®¹æ˜“ç†è§£ 12345678910111213141516//è¿˜æ˜¯èµ°çš„å¿«çš„ç‚¹(fastNode)ä¸Žèµ°å¾—æ…¢çš„ç‚¹(slowNode)è·¯ç¨‹å·®çš„é—®é¢˜ public static ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode headNode = new ListNode(9527); headNode.next = head; ListNode fastNode = headNode; ListNode slowNode = headNode; while(fastNode.next != null)&#123; if(n &lt;= 0) slowNode = slowNode.next; fastNode = fastNode.next; n--; &#125; if(slowNode.next != null) slowNode.next = slowNode.next.next; return headNode.next; &#125; https://discuss.leetcode.com/topic/12125/my-simple-java-solution-in-one-pass My simple Java solution in one pass 123456789101112131415public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy=new ListNode(0); dummy.next=head; ListNode fast=dummy; ListNode slow=dummy; int temp=n; for(;fast.next!=null;temp--)&#123; if(temp&lt;=0)&#123; //control slow=slow.next; &#125; fast=fast.next; &#125; slow.next=slow.next.next;//delete Nth return dummy.next;&#125; python 39ms, 100.00%, September 3, 2016 https://discuss.leetcode.com/topic/14692/3-short-python-solutions Value-Shifting - AC in 64 ms My first solution is â€œcheatingâ€ a little. Instead of really removing the nth node, I remove the nth value. I recursively determine the indexes (counting from back), then shift the values for all indexes larger than n, and then always drop the head. 1234567891011class Solution: def removeNthFromEnd(self, head, n): def index(node): if not node: return 0 i = index(node.next) + 1 if i &gt; n: node.next.val = node.val return i index(head) return head.next Index and Remove - AC in 56 ms In this solution I recursively determine the indexes again, but this time my helper function removes the nth node. It returns two values. The index, as in my first solution, and the possibly changed head of the remaining list. 12345678class Solution: def removeNthFromEnd(self, head, n): def remove(head): if not head: return 0, head i, head.next = remove(head.next) return i+1, (head, head.next)[i+1 == n] return remove(head)[1] n ahead - AC in 48 ms The standard solution, but without a dummy extra node. Instead, I simply handle the special case of removing the head right after the fast cursor got its head start. 123456789101112class Solution: def removeNthFromEnd(self, head, n): fast = slow = head for _ in range(n): fast = fast.next if not fast: return head.next while fast.next: fast = fast.next slow = slow.next slow.next = slow.next.next return head]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[018. 4Sum]]></title>
    <url>%2Fp%2F964c48a1%2F</url>
    <content type="text"><![CDATA[25.9% https://leetcode.com/problems/4sum/ Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 12345678For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] æ–¹æ³•ä¸€ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); if(n&lt;4) return res; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-3; i++)&#123; if(i!=0 &amp;&amp; nums[i]==nums[i-1]) continue; if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target) break; // æ­¤å¤„ä¸ºbreakï¼› if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]&lt;target) continue; // æ­¤å¤„ä¸ºcontinue; æ³¨æ„åŒºåˆ† for(int j=i+1; j&lt;n-2; j++)&#123; if(j!=i+1 &amp;&amp; nums[j]==nums[j-1]) continue; if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; int k=j+1, l=n-1; while(k&lt;l)&#123; int sum = nums[i]+nums[j]+nums[k]+nums[l]; if(sum==target)&#123; res.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[k], nums[l]&#125;); while(k&lt;l &amp;&amp; nums[k+1]==nums[k]) k++; while(k&lt;l &amp;&amp; nums[l-1]==nums[l]) l--; k++; l--; &#125;else if(sum&gt;target) l--; else k++; &#125; &#125; &#125; return res; &#125;&#125;; 16ms, 91.80%, April.23rd, 2016 https://leetcode.com/discuss/87769/implementation-carefully-pruning-accelerates-from-100ms First thanks to the post from @cx1992 I will just say that with out the 2 using of the 123if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; The runing time without these two lines cost 100ms. But with these lines, cost 16ms ! Here is the final implementation 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; result; int n=nums.size(); if(n&lt;4) return result; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-3; i++)&#123; if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) continue; /** cut edge to accelerate the speed **/ if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target) break; // æ­¤å¤„åŠ break if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]&lt;target) continue; for(int j=i+1; j&lt;n-2; j++)&#123; if(j&gt;i+1 &amp;&amp; nums[j]==nums[j-1]) continue; /** cut edge to accelerate the speed **/ if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; /** jia bi process **/ int start=j+1, end=n-1; while(start &lt; end)&#123; int sum=nums[start]+nums[end]+nums[i]+nums[j]; if(sum&lt;target) start++; else if(sum&gt;target) end--; else&#123; result.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[start], nums[end]&#125;); start++; end--; while(nums[start-1]==nums[start] &amp;&amp; start&lt;end) start++; while(nums[end+1]==nums[end] &amp;&amp; start&lt;end) end--; &#125; &#125; &#125; &#125; return result; &#125;&#125;; å¦ä¸€ç§ä»£ç å®žçŽ°ï¼š https://discuss.leetcode.com/topic/28641/my-16ms-c-code My 16ms c++ code 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; total; int n = nums.size(); if(n&lt;4) return total; sort(nums.begin(),nums.end()); for(int i=0;i&lt;n-3;i++) &#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue; if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target) break; if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]&lt;target) continue; for(int j=i+1;j&lt;n-2;j++) &#123; if(j&gt;i+1&amp;&amp;nums[j]==nums[j-1]) continue; if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; int left=j+1,right=n-1; while(left&lt;right)&#123; int sum=nums[left]+nums[right]+nums[i]+nums[j]; if(sum&lt;target) left++; else if(sum&gt;target) right--; else&#123; total.push_back(vector&lt;int&gt;&#123;nums[i],nums[j],nums[left],nums[right]&#125;); do&#123;left++;&#125;while(nums[left]==nums[left-1]&amp;&amp;left&lt;right); do&#123;right--;&#125;while(nums[right]==nums[right+1]&amp;&amp;left&lt;right); &#125; &#125; &#125; &#125; return total; &#125;&#125;; æ–¹æ³•äºŒï¼š 100ms, 45.73%, Apr.23rd, 2016 http://c4fun.cn/blog/2014/03/20/leetcode-solution-02/ 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt; &gt; ans; sort(num.begin(), num.end()); for (int i = 0; i &lt; num.size(); i++) &#123; if (i &gt; 0 &amp;&amp; num[i] == num[i-1]) continue; for (int j = i + 1; j &lt; num.size(); j++) &#123; if (j &gt; i + 1 &amp;&amp; num[j] == num[j - 1]) continue; int l = j + 1, r = num.size() - 1; while (l &lt; r) &#123; int sum = num[i] + num[j] + num[l] + num[r]; if (sum == target) &#123; ans.push_back(&#123;num[i], num[j], num[l], num[r]&#125;); while (l &lt; r &amp;&amp; num[l] == num[l + 1]) l++; l++; while (l &lt; r &amp;&amp; num[r] == num[r - 1]) r--; r--; &#125; else if (sum &lt; target) &#123; l++; &#125; else &#123; r--; &#125; &#125; &#125; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/27445/lower-bound-n-3 Lower bound n^3 Some people say their solutions are O(n2 log n) or even O(n2), butâ€¦ Consider cases where nums is the n numbers from 1 to n. =&gt; There are Î˜(n4) different quadruplets (nC4, to be exact, so about n4 / 24). =&gt; There are Î˜(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums). =&gt; At least one sum must have Î©(n3) different quadruplets. =&gt; For that sum, we must generate those Î©(n3) quadruplets. =&gt; For these cases we have to do Î©(n3) work. =&gt; O(n2 log n) or even O(n2) are impossible. (I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.) cpp https://discuss.leetcode.com/topic/3752/my-c-solution-using-hashtable My C++ solution using hashtable My idea is to sort num first, then build a hashtable with the key as the sum of the pair and the value as a vector storing all pairs of index of num that having the same sum. In this way, all elements stored in hashtable has a order that duplicate pairs are neighbors. Therefore scanning the vector in the hashtable we only put non duplicate elements into the final answer vvi. Is this method O(n^2) ? or Does anyone can improve it to O(n^2); 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution&#123; //using hashtable, avg O(n^2)public: vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target)&#123; vector&lt;vector&lt;int&gt; &gt; vvi; int n = num.size(); if(n &lt; 4) return vvi; sort(num.begin(), num.end()); unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt; &gt; mp; for(int i = 0; i &lt; n; i++)&#123; for(int j = i + 1; j &lt; n; j++)&#123; mp[num[i]+num[j]].push_back(make_pair(i,j)); &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; if(i&gt;0 &amp;&amp; num[i] == num[i-1]) continue; for(int j = i + 1; j &lt; n; j++)&#123; if(j &gt; i + 1 &amp;&amp; num[j] == num[j-1]) continue; int res = target - num[i] - num[j]; if(mp.count(res))&#123; for(auto it = mp[res].begin(); it != mp[res].end(); it++)&#123; int k = (*it).first, l = (*it).second; if(k &gt; j)&#123; // k&gt;j make sure that the second pair has bigger values than the first pair. if(!vvi.empty() &amp;&amp; num[i]==vvi.back()[0] &amp;&amp; num[j]==vvi.back()[1] &amp;&amp; num[k]==vvi.back()[2] &amp;&amp; num[l] == vvi.back()[3])&#123; continue; //if the obtained 4 elements are the same as previous one continue to next &#125; vector&lt;int&gt; vi=&#123;num[i], num[j], num[k], num[l]&#125;; vvi.push_back(vi); &#125; // if k&gt;j &#125;//for it &#125;//if &#125;// forj &#125;//for i return vvi; &#125; &#125;; python https://discuss.leetcode.com/topic/10995/share-my-python-code-run-time-200-20ms Share my python code, run time 200+- 20ms 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution: # @return a list of lists of length 4, [[val1,val2,val3,val4]] def fourSum(self, num, target): num.sort() result = [] for i in xrange(len(num)-3): if num[i] &gt; target/4.0: break if i &gt; 0 and num[i] == num[i-1]: continue target2 = target - num[i] for j in xrange(i+1, len(num)-2): if num[j] &gt; target2/3.0: break if j &gt; i+1 and num[j] == num[j-1]: continue k = j + 1 l = len(num) - 1 target3 = target2 - num[j] # we should use continue not break # because target3 changes as j changes if num[k] &gt; target3/2.0: continue if num[l] &lt; target3/2.0: continue while k &lt; l: sum_value = num[k] + num[l] if sum_value == target3: result.append([num[i], num[j], num[k], num[l]]) kk = num[k] k += 1 while k&lt;l and num[k] == kk: k += 1 ll = num[l] l -= 1 while k&lt;l and num[l] == ll: l -= 1 elif sum_value &lt; target3: k += 1 else: l -= 1 return result We can reduce run time by adding some restrictions. https://discuss.leetcode.com/topic/9078/twosum-twosum-foursum-a-simple-python-solution TwoSum+twoSum == fourSum, a simple python solution 12345678910111213141516class Solution:# @return a list of lists of length 4, [[val1,val2,val3,val4]]def fourSum(self, num, target): two_sum = collections.defaultdict(list) res = set() for (n1, i1), (n2, i2) in itertools.combinations(enumerate(num), 2): two_sum[i1+i2].append(&#123;n1, n2&#125;) for t in list(two_sum.keys()): if not two_sum[target-t]: continue for pair1 in two_sum[t]: for pair2 in two_sum[target-t]: if pair1.isdisjoint(pair2): res.add(tuple(sorted(num[i] for i in pair1 | pair2))) del two_sum[t] return [list(r) for r in res] https://discuss.leetcode.com/topic/10556/a-conise-python-solution-based-on-ksum A conise python solution based on ksum 12345678910111213141516171819202122232425262728class Solution: # @return a list of lists of length 4, [[val1,val2,val3,val4]] def fourSum(self, num, target): num.sort() def ksum(num, k, target): i = 0 result = set() if k == 2: j = len(num) - 1 while i &lt; j: if num[i] + num[j] == target: result.add((num[i], num[j])) i += 1 elif num[i] + num[j] &gt; target: j -= 1 else: i += 1 else: while i &lt; len(num) - k + 1: newtarget = target - num[i] subresult = ksum(num[i+1:], k - 1, newtarget) if subresult: result = result | set( (num[i],) + nr for nr in subresult) i += 1 return result return [list(t) for t in ksum(num, 4, target)] 148ms, 86.46%, April.23rd, 2016 https://leetcode.com/discuss/83152/python-beats-86-07%25-may-be-better python beats 86.07% may be better make sure nums[i]!=nums[i+1] to avoid duplication and unnecessary computations and whennums[i]*4 &gt; target,Itâ€™ll be impossible to get another answer. and when nums[j]*4 &lt; target,It should turn to next loop maybe in some situations:usenums[i]+nums[i+1]+nums[i+2]+nums[i+3]wil be better.I am just for convenience.. 1234567891011121314151617181920212223242526class Solution(object): def fourSum(self, nums, target): res, n, nums, limit = [], len(nums), sorted(nums), target &gt;&gt; 2 for i in xrange(n-3): if nums[i] &gt; limit: #limit 1 break if i != 0 and nums[i] == nums[i-1]: #remove duplicate continue for j in xrange(n-1,i+2,-1): #Reverse traversal if nums[j] &lt; limit: #limit 2 break if j != n -1 and nums[j] == nums[j+1]: #remove duplicate continue lo, hi, sum2 = i + 1, j - 1, nums[i] + nums[j] limit2 = (target - sum2) &gt;&gt; 1 while lo &lt; hi and nums[lo] &lt;= limit2 and nums[hi] &gt;= limit2: #limit 3 sum = sum2 + nums[lo] + nums[hi] if sum == target: res += (nums[i], nums[lo], nums[hi], nums[j]), while lo &lt; hi and nums[hi] == nums[hi-1]: #remove duplicate hi -= 1 while lo &lt; hi and nums[lo] == nums[lo+1]: #remove duplicate lo += 1 lo += sum &lt;= target hi -= sum &gt;= target return res https://discuss.leetcode.com/topic/22705/python-140ms-beats-100-and-works-for-n-sum-n-2 Python 140ms beats 100%, and works for N-sum (N&gt;=2) The core is to implement a fast 2-pointer to solve 2-sum, and recursion to reduce the N-sum to 2-sum. Some optimization was be made knowing the list is sorted. 1234567891011121314151617181920212223242526272829303132def fourSum(self, nums, target): nums.sort() results = [] self.findNsum(nums, target, 4, [], results) return resultsdef findNsum(self, nums, target, N, result, results): if len(nums) &lt; N or N &lt; 2: return # solve 2-sum if N == 2: l,r = 0,len(nums)-1 while l &lt; r: if nums[l] + nums[r] == target: results.append(result + [nums[l], nums[r]]) l += 1 r -= 1 while l &lt; r and nums[l] == nums[l - 1]: l += 1 while r &gt; l and nums[r] == nums[r + 1]: r -= 1 elif nums[l] + nums[r] &lt; target: l += 1 else: r -= 1 else: for i in range(0, len(nums)-N+1): # careful about range if target &lt; nums[i]*N or target &gt; nums[-1]*N: # take advantages of sorted list break if i == 0 or i &gt; 0 and nums[i-1] != nums[i]: # recursively reduce N self.findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results) return Just revisited and clean the code 12345678910111213141516171819202122232425def fourSum(self, nums, target): def findNsum(nums, target, N, result, results): if len(nums) &lt; N or N &lt; 2 or target &lt; nums[0]*N or target &gt; nums[-1]*N: # early termination return if N == 2: # two pointers solve sorted 2-sum problem l,r = 0,len(nums)-1 while l &lt; r: s = nums[l] + nums[r] if s == target: results.append(result + [nums[l], nums[r]]) l += 1 while l &lt; r and nums[l] == nums[l-1]: l += 1 elif s &lt; target: l += 1 else: r -= 1 else: # recursively reduce N for i in range(len(nums)-N+1): if i == 0 or (i &gt; 0 and nums[i-1] != nums[i]): findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results) results = [] findNsum(sorted(nums), target, 4, [], results) return results java https://discuss.leetcode.com/topic/29585/7ms-java-code-win-over-100 26ms, 97.32% 7ms java code win over 100% The first time win over 100%. Basic idea is using subfunctions for 3sum and 2sum, and keeping throwing all impossible cases. O(n^3) time complexity, O(1) extra space complexity.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); int len = nums.length; if (nums == null || len &lt; 4) return res; Arrays.sort(nums); int max = nums[len - 1]; if (4 * nums[0] &gt; target || 4 * max &lt; target) return res; int i, z; for (i = 0; i &lt; len; i++) &#123; z = nums[i]; if (i &gt; 0 &amp;&amp; z == nums[i - 1])// avoid duplicate continue; if (z + 3 * max &lt; target) // z is too small continue; if (4 * z &gt; target) // z is too large break; if (4 * z == target) &#123; // z is the boundary if (i + 3 &lt; len &amp;&amp; nums[i + 3] == z) res.add(Arrays.asList(z, z, z, z)); break; &#125; threeSumForFourSum(nums, target - z, i + 1, len - 1, res, z); &#125; return res; &#125; /* * Find all possible distinguished three numbers adding up to the target * in sorted array nums[] between indices low and high. If there are, * add all of them into the ArrayList fourSumList, using * fourSumList.add(Arrays.asList(z1, the three numbers)) */ public void threeSumForFourSum(int[] nums, int target, int low, int high, ArrayList&lt;List&lt;Integer&gt;&gt; fourSumList, int z1) &#123; if (low + 1 &gt;= high) return; int max = nums[high]; if (3 * nums[low] &gt; target || 3 * max &lt; target) return; int i, z; for (i = low; i &lt; high - 1; i++) &#123; z = nums[i]; if (i &gt; low &amp;&amp; z == nums[i - 1]) // avoid duplicate continue; if (z + 2 * max &lt; target) // z is too small continue; if (3 * z &gt; target) // z is too large break; if (3 * z == target) &#123; // z is the boundary if (i + 1 &lt; high &amp;&amp; nums[i + 2] == z) fourSumList.add(Arrays.asList(z1, z, z, z)); break; &#125; twoSumForFourSum(nums, target - z, i + 1, high, fourSumList, z1, z); &#125; &#125; /* * Find all possible distinguished two numbers adding up to the target * in sorted array nums[] between indices low and high. If there are, * add all of them into the ArrayList fourSumList, using * fourSumList.add(Arrays.asList(z1, z2, the two numbers)) */ public void twoSumForFourSum(int[] nums, int target, int low, int high, ArrayList&lt;List&lt;Integer&gt;&gt; fourSumList, int z1, int z2) &#123; if (low &gt;= high) return; if (2 * nums[low] &gt; target || 2 * nums[high] &lt; target) return; int i = low, j = high, sum, x; while (i &lt; j) &#123; sum = nums[i] + nums[j]; if (sum == target) &#123; fourSumList.add(Arrays.asList(z1, z2, nums[i], nums[j])); x = nums[i]; while (++i &lt; j &amp;&amp; x == nums[i]) // avoid duplicate ; x = nums[j]; while (i &lt; --j &amp;&amp; x == nums[j]) // avoid duplicate ; &#125; if (sum &lt; target) i++; if (sum &gt; target) j--; &#125; return; &#125;&#125; https://discuss.leetcode.com/topic/12368/clean-accepted-java-o-n-3-solution-based-on-3sum Clean accepted java O(n^3) solution based on 3sum 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] num, int target) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if(num.length&lt;4)return ans; Arrays.sort(num); for(int i=0; i&lt;num.length-3; i++)&#123; if(i&gt;0&amp;&amp;num[i]==num[i-1])continue; for(int j=i+1; j&lt;num.length-2; j++)&#123; if(j&gt;i+1&amp;&amp;num[j]==num[j-1])continue; int low=j+1, high=num.length-1; while(low&lt;high)&#123; int sum=num[i]+num[j]+num[low]+num[high]; if(sum==target)&#123; ans.add(Arrays.asList(num[i], num[j], num[low], num[high])); while(low&lt;high&amp;&amp;num[low]==num[low+1])low++; while(low&lt;high&amp;&amp;num[high]==num[high-1])high--; low++; high--; &#125; else if(sum&lt;target)low++; else high--; &#125; &#125; &#125; return ans; &#125;&#125; https://discuss.leetcode.com/topic/12893/on-average-o-n-2-and-worst-case-o-n-3-java-solution-by-reducing-4sum-to-2sum On average O(n^2) and worst case O(n^3) java solution by reducing 4Sum to 2Sum Basic idea is to reduce the 4Sum problem to 2Sum one. In order to achieve that, we can use an array (size of n^2) to store the pair sums and this array will act as the array in 2Sum case (Here n is the size of the original 1D array and it turned out that we do not even need to explicitly use the n^2 sized array ). We also use a hashmap to mark if a pair sum has been visited or not (the same as in the 2Sum case). The tricky part here is that we may have multiple pairs that result in the same pair sum. So we will use a list to group these pairs together. For every pair with a particular sum, check if the pair sum that is needed to get the target has been visited. If so, further check if there is overlapping between these two pairs. If not, record the result. Time complexity to get all the pairs is O(n^2). For each pair, if the pair sum needed to get the target has been visited, the time complexity will be O(k), where k is the maximum size of the lists holding pairs with visited pair sum. Therefore the total time complexity will be O(k*n^2). Now we need to determine the range of k. Basically the more distinct pair sums we get, the smaller k will be. If all the pair sums are different from each other, k will just be 1. However, if we have many repeated elements in the original 1D array, or in some extreme cases such as the elements form an arithmetic progression, k can be of the order of n (strictly speaking, for the repeated elements case, k can go as high as n^2, but we can get rid of many of them). On average k will be some constant between 1 and n for normal elements distribution in the original 1D array. So on average our algorithm will go in O(n^2) but with worst case of O(n^3). Here is the complete code in java: 1234567891011121314151617181920212223242526272829303132333435363738394041public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] num, int target) &#123; Arrays.sort(num); Map&lt;Integer, List&lt;int[]&gt;&gt; twoSumMap = new HashMap&lt;&gt;(); // for holding visited pair sums. All pairs with the same pair sum are grouped together Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;(); // for holding the results for (int i = 0; i &lt; num.length; i++) &#123; // get rid of repeated pair sums if (i &gt; 1 &amp;&amp; num[i] == num[i - 2]) continue; for (int j = i + 1; j &lt; num.length; j++) &#123; // get rid of repeated pair sums if (j &gt; i + 2 &amp;&amp; num[j] == num[j - 2]) continue; // for each pair sum, check if the pair sum that is needed to get the target has been visited. if (twoSumMap.containsKey(target - (num[i] + num[j]))) &#123; // if so, get all the pairs that contribute to this visited pair sum. List&lt;int[]&gt; ls = twoSumMap.get(target - (num[i] + num[j])); for (int[] pair : ls) &#123; // we have two pairs: one is indicated as (pair[0], pair[1]), the other is (i, j). // we first need to check if they are overlapping with each other. int m1 = Math.min(pair[0], i); // m1 will always be the smallest index int m2 = Math.min(pair[1], j); // m2 will be one of the middle two indices int m3 = Math.max(pair[0], i); // m3 will be one of the middle two indices int m4 = Math.max(pair[1], j); // m4 will always be the largest index if (m1 == m3 || m1 == m4 || m2 == m3 || m2 == m4) continue; // two pairs are overlapping, so just ignore this case res.add(Arrays.asList(num[m1], num[Math.min(m2, m3)], num[Math.max(m2, m3)], num[m4])); // else record the result &#125; &#125; // mark that we have visited current pair and add it to the corrsponding pair sum group. // here we&apos;ve encoded the pair indices i and j into an integer array of length 2. twoSumMap.computeIfAbsent(num[i] + num[j], key -&gt; new ArrayList&lt;&gt;()).add(new int[] &#123;i, j&#125;); &#125; &#125; return new ArrayList&lt;List&lt;Integer&gt;&gt;(res);&#125; https://discuss.leetcode.com/topic/46339/my-solution-generalized-for-ksums-in-java My solution generalized for kSums in JAVA General Idea If you have already read and implement the 3sum and 4sum by using the sorting approach: reduce them into 2sum at the end, you might already got the feeling that, all ksum problem can be divided into two problems: 2sum Problem Reduce K sum problem to K â€“ 1 sum Problem Therefore, the ideas is simple and straightforward. We could use recursive to solve this problem. Time complexity is O(N^(K-1)). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; int len = 0; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; len = nums.length; Arrays.sort(nums); return kSum(nums, target, 4, 0); &#125; private ArrayList&lt;List&lt;Integer&gt;&gt; kSum(int[] nums, int target, int k, int index) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(index &gt;= len) &#123; return res; &#125; if(k == 2) &#123; int i = index, j = len - 1; while(i &lt; j) &#123; //find a pair if(target - nums[i] == nums[j]) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); temp.add(nums[i]); temp.add(target-nums[i]); res.add(temp); //skip duplication while(i&lt;j &amp;&amp; nums[i]==nums[i+1]) i++; while(i&lt;j &amp;&amp; nums[j-1]==nums[j]) j--; i++; j--; //move left bound &#125; else if (target - nums[i] &gt; nums[j]) &#123; i++; //move right bound &#125; else &#123; j--; &#125; &#125; &#125; else&#123; for (int i = index; i &lt; len - k + 1; i++) &#123; //use current number to reduce ksum into k-1sum ArrayList&lt;List&lt;Integer&gt;&gt; temp = kSum(nums, target - nums[i], k-1, i+1); if(temp != null)&#123; //add previous results for (List&lt;Integer&gt; t : temp) &#123; t.add(0, nums[i]); &#125; res.addAll(temp); &#125; while (i &lt; len-1 &amp;&amp; nums[i] == nums[i+1]) &#123; //skip duplicated numbers i++; &#125; &#125; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/33433/java-a-little-bit-faster-than-other-common-methods-9ms-beats-95 Java a little bit faster than other common methods (9ms, beats 95%) To avoid duplicate list items, I skip unnecessary indices at two locations: one at the end of the outer loop (i-loop) the other at the end of the inner loop (j-loop). To avoid useless computations, the following is kind of critical: the function return immediately when nums[i]*4 &gt; target the inner loop break immediately when nums[j]*4 &lt; target. These two lines save quite some time due to the set up of the test cases in OJ. 12345678910111213141516171819202122232425262728public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(nums); int second = 0, third = 0, nexti = 0, nextj = 0; for(int i=0, L=nums.length; i&lt;L-3; i++) &#123; if(nums[i]&lt;&lt;2 &gt; target) return list; // return immediately for(int j=L-1; j&gt;i+2; j--) &#123; if(nums[j]&lt;&lt;2 &lt; target) break; // break immediately int rem = target-nums[i]-nums[j]; int lo = i+1, hi=j-1; while(lo&lt;hi) &#123; int sum = nums[lo] + nums[hi]; if(sum&gt;rem) --hi; else if(sum&lt;rem) ++lo; else &#123; list.add(Arrays.asList(nums[i],nums[lo],nums[hi],nums[j])); while(++lo&lt;=hi &amp;&amp; nums[lo-1]==nums[lo]) continue; // avoid duplicate results while(--hi&gt;=lo &amp;&amp; nums[hi]==nums[hi+1]) continue; // avoid duplicate results &#125; &#125; while(j&gt;=1 &amp;&amp; nums[j]==nums[j-1]) --j; // skip inner loop &#125; while(i&lt;L-1 &amp;&amp; nums[i]==nums[i+1]) ++i; // skip outer loop &#125; return list; &#125;&#125; https://discuss.leetcode.com/topic/9712/4sum-c-solution-with-explanation-and-comparison-with-3sum-problem-easy-to-understand For the reference, please have a look at my explanation of 3Sum problem because the algorithm are exactly the same. The link is as blow. My 3Sum problem answer The key idea is to downgrade the problem to a 2Sum problem eventually. And the same algorithm can be expand to NSum problem. After you had a look at my explanation of 3Sum, the code below will be extremely easy to understand. 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] num, int target) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if(num.length&lt;4)return ans; Arrays.sort(num); for(int i=0; i&lt;num.length-3; i++)&#123; if(i&gt;0&amp;&amp;num[i]==num[i-1])continue; for(int j=i+1; j&lt;num.length-2; j++)&#123; if(j&gt;i+1&amp;&amp;num[j]==num[j-1])continue; int low=j+1, high=num.length-1; while(low&lt;high)&#123; int sum=num[i]+num[j]+num[low]+num[high]; if(sum==target)&#123; ans.add(Arrays.asList(num[i], num[j], num[low], num[high])); while(low&lt;high&amp;&amp;num[low]==num[low+1])low++; while(low&lt;high&amp;&amp;num[high]==num[high-1])high--; low++; high--; &#125; else if(sum&lt;target)low++; else high--; &#125; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[017. Letter Combinations of a Phone Number]]></title>
    <url>%2Fp%2F9a201804%2F</url>
    <content type="text"><![CDATA[34.7% https://leetcode.com/problems/letter-combinations-of-a-phone-number/ Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. 12Input:Digit string &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. æ–¹æ³•ä¸€ï¼š è¿­ä»£çš„æ–¹æ³• My iterative sollution, very simple under 15 lines This is my solution, FYI é’ˆå¯¹æ–°æ¥çš„ä¸€ä¸ªæ•°å­—ï¼Œæ¯”å¦‚2=â€œabcâ€ï¼Œä»ŽåŽŸæœ‰çš„resä¸­çš„æ‰€æœ‰stringéƒ½å–å‡ºæ¥ï¼Œé’ˆå¯¹æ¯ä¸€ä¸ªéƒ½åŠ ä¸€ä¸ªaæˆ–bæˆ–cï¼Œå†æ”¾å…¥æ–°çš„vectorä¸­ï¼Œå†æŠŠæ–°çš„èµ‹å€¼ç»™resã€‚ 12345678910111213141516171819class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.size()==0) return res; string charmap[10] = &#123;&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; res.push_back(&quot;&quot;); for (int i = 0; i &lt; digits.size(); i++) &#123; vector&lt;string&gt; tempres; string chars = charmap[digits[i] - &apos;0&apos;]; for (int c = 0; c &lt; chars.size();c++) for (int j = 0; j &lt; res.size();j++) tempres.push_back(res[j]+chars[c]); res = tempres; &#125; return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°: 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.empty()) return res; // stringç”¨åŒå¼•å· å•åŒå¼•å·è¦ä»”ç»†è€ƒè™‘ unordered_map&lt;char, string&gt;map = &#123;&#123;'1', ""&#125;, &#123;'2', "abc"&#125;, &#123;'3', "def"&#125;, &#123;'4', "ghi"&#125;, &#123;'5', "jkl"&#125;, &#123;'6', "mno"&#125;, &#123;'7', "pqrs"&#125;, &#123;'8', "tuv"&#125;, &#123;'9', "wxyz"&#125;&#125;; string s = ""; dfs(digits, 0, s, res, map); return res; &#125; void dfs(string&amp; digits, int k, string&amp; s, vector&lt;string&gt;&amp; res, unordered_map&lt;char, string&gt;&amp; map)&#123; if(k==digits.size())&#123; res.push_back(s); return; &#125; for(auto c:map[digits[k]])&#123; // string çš„push_backï¼Œpop_backæ–¹æ³• s.push_back(c); dfs(digits, k+1, s, res, map); s.pop_back(); &#125; &#125;&#125;; java https://discuss.leetcode.com/topic/8125/concise-o-n-2-java-solution Concise O(N^2) Java solution Hi guys! The idea is to sort an input array and then run through all indices of a possible first element of a triplet. For each possible first element we make a standard bi-directional 2Sum sweep of the remaining part of the array. Also we want to skip equal elements to avoid duplicates in the answer without making a set or smth like that. 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) &#123; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; num.length-2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; num[i] != num[i-1])) &#123; int lo = i+1, hi = num.length-1, sum = 0 - num[i]; while (lo &lt; hi) &#123; if (num[lo] + num[hi] == sum) &#123; res.add(Arrays.asList(num[i], num[lo], num[hi])); while (lo &lt; hi &amp;&amp; num[lo] == num[lo+1]) lo++; while (lo &lt; hi &amp;&amp; num[hi] == num[hi-1]) hi--; lo++; hi--; &#125; else if (num[lo] + num[hi] &lt; sum) lo++; else hi--; &#125; &#125; &#125; return res;&#125; Have a nice coding! https://discuss.leetcode.com/topic/28857/easiest-java-solution Easiest Java Solution Sort the array, iterate through the list, and use another two pointers to approach the target. 12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i + 2 &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; // skip same result continue; &#125; int j = i + 1, k = nums.length - 1; int target = -nums[i]; while (j &lt; k) &#123; if (nums[j] + nums[k] == target) &#123; res.add(Arrays.asList(nums[i], nums[j], nums[k])); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++; // skip same result while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--; // skip same result &#125; else if (nums[j] + nums[k] &gt; target) &#123; k--; &#125; else &#123; j++; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/45491/share-my-simple-java-solution Share my simple java solution 123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(nums.length &lt; 3) return result; Arrays.sort(nums); int i = 0; while(i &lt; nums.length - 2) &#123; if(nums[i] &gt; 0) break; int j = i + 1; int k = nums.length - 1; while(j &lt; k) &#123; int sum = nums[i] + nums[j] + nums[k]; if(sum == 0) result.add(Arrays.asList(nums[i], nums[j], nums[k])); if(sum &lt;= 0) while(nums[j] == nums[++j] &amp;&amp; j &lt; k); if(sum &gt;= 0) while(nums[k--] == nums[k] &amp;&amp; j &lt; k); &#125; while(nums[i] == nums[++i] &amp;&amp; i &lt; nums.length - 2); &#125; return result; &#125;&#125; https://discuss.leetcode.com/topic/26050/simple-o-n-2-two-pointers-java-solution Simple O(n^2) two pointers Java solution Runtime = O(n^2); Space = O(1) 12345678910111213141516171819202122232425262728public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] A) &#123; List&lt;List&lt;Integer&gt;&gt;res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (A == null || A.length == 0) return res; Arrays.sort(A); for (int i = 0; i &lt; A.length; i++) &#123; if (i - 1 &gt;= 0 &amp;&amp; A[i] == A[i - 1]) continue;// Skip equal elements to avoid duplicates int left = i + 1, right = A.length - 1; while (left &lt; right) &#123;// Two Pointers int sum = A[i] + A[left] + A[right]; if (sum == 0) &#123; res.add(Arrays.asList(A[i], A[left], A[right])); while (left + 1 &lt; right &amp;&amp; A[left] == A[left+1])// Skip equal elements to avoid duplicates left++; while (right -1 &gt; left &amp;&amp; A[right] == A[right-1])// Skip equal elements to avoid duplicates right--; left++; right--; &#125; else if (sum &lt; 0) &#123; left++; &#125; else &#123; right--; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/8465/my-java-solution-with-fifo-queue My java solution with FIFO queue1234567891011121314public List&lt;String&gt; letterCombinations(String digits) &#123; LinkedList&lt;String&gt; ans = new LinkedList&lt;String&gt;(); String[] mapping = new String[] &#123;&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; ans.add(&quot;&quot;); for(int i =0; i&lt;digits.length();i++)&#123; int x = Character.getNumericValue(digits.charAt(i)); while(ans.peek().length()==i)&#123; String t = ans.remove(); for(char s : mapping[x].toCharArray()) ans.add(t+s); &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/6380/my-recursive-solution-using-java My recursive solution using Java1234567891011121314151617181920public class Solution &#123; private static final String[] KEYS = &#123; &quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot; &#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; ret = new LinkedList&lt;String&gt;(); combination(&quot;&quot;, digits, 0, ret); return ret; &#125; private void combination(String prefix, String digits, int offset, List&lt;String&gt; ret) &#123; if (offset &gt;= digits.length()) &#123; ret.add(prefix); return; &#125; String letters = KEYS[(digits.charAt(offset) - &apos;0&apos;)]; for (int i = 0; i &lt; letters.length(); i++) &#123; combination(prefix + letters.charAt(i), digits, offset + 1, ret); &#125; &#125; &#125; cpp https://discuss.leetcode.com/topic/8107/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments Share my AC C++ solution, around 50ms, O(N*N), with explanation and comments the key idea is the same as the TwoSum problem. When we fix the 1st number, the 2nd and 3rd number can be found following the same reasoning as TwoSum. The only difference is that, the TwoSum problem of LEETCODE has a unique solution. However, in ThreeSum, we have multiple duplicate solutions that can be found. Most of the OLE errors happened here because you couldâ€™ve ended up with a solution with so many duplicates. The naive solution for the duplicates will be using the STL methods like below : 12std::sort(res.begin(), res.end());res.erase(unique(res.begin(), res.end()), res.end()); But according to my submissions, this way will cause you double your time consuming almostly. A better approach is that, to jump over the number which has been scanned, no matter it is part of some solution or not. If the three numbers formed a solution, we can safely ignore all the duplicates of them. We can do this to all the three numbers such that we can remove the duplicates. Hereâ€™s my AC C++ Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; res; std::sort(num.begin(), num.end()); for (int i = 0; i &lt; num.size(); i++) &#123; int target = -num[i]; int front = i + 1; int back = num.size() - 1; while (front &lt; back) &#123; int sum = num[front] + num[back]; // Finding answer which start from number num[i] if (sum &lt; target) front++; else if (sum &gt; target) back--; else &#123; vector&lt;int&gt; triplet(3, 0); triplet[0] = num[i]; triplet[1] = num[front]; triplet[2] = num[back]; res.push_back(triplet); // Processing duplicates of Number 2 // Rolling the front pointer to the next different number forwards while (front &lt; back &amp;&amp; num[front] == triplet[1]) front++; // Processing duplicates of Number 3 // Rolling the back pointer to the next different number backwards while (front &lt; back &amp;&amp; num[back] == triplet[2]) rear--; &#125; &#125; // Processing duplicates of Number 1 while (i + 1 &lt; num.size() &amp;&amp; num[i + 1] == num[i]) i++; &#125; return res; &#125; https://discuss.leetcode.com/topic/15291/20-lines-68ms-c-solution-used-two-pointers-similar-to-2sum ~20 lines. 68ms. c++ solution. Used two pointers similar to 2sum 1234567891011121314151617181920212223242526272829303132vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt;=2) return &#123;&#125;; vector&lt;vector&lt;int&gt; &gt; rtn; sort(nums.begin(), nums.end()); for(int i =0; i &lt; nums.size();)&#123; int start = i+1, end = nums.size()-1; while(start &lt; end)&#123; if(nums[i]+nums[start]+nums[end] == 0)&#123; rtn.push_back(&#123;nums[i],nums[start],nums[end]&#125;); start++; end--; while((start &lt; end) &amp;&amp; nums[start] == nums[start-1]) start++; while((start &lt; end) &amp;&amp; nums[end] == nums[end+1]) end--; &#125;else if(nums[i]+nums[start]+nums[end]&lt;0)&#123; start++; while((start &lt; end) &amp;&amp; nums[start] == nums[start-1]) start++; &#125;else&#123; end--; while((start &lt; end) &amp;&amp; nums[end] == nums[end+1]) end--; &#125; &#125; i++; while((i &lt; nums.size()) &amp;&amp; nums[i] == nums[i-1]) i++; &#125; return rtn;&#125; Thanks to my friend Yang Li inspired me of using two pointers https://discuss.leetcode.com/topic/15291/20-lines-68ms-c-solution-used-two-pointers-similar-to-2sum/2 Excellent way to avoid duplicate triples! (I had previously collected them in a set and moved them to a vector in the end). Hereâ€™s my take on it (got it to run in 52 ms): 12345678910111213141516vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; triples; sort(nums.begin(), nums.end()); int i = 0, last = nums.size() - 1; while (i &lt; last) &#123; int a = nums[i], j = i+1, k = last; while (j &lt; k) &#123; int b = nums[j], c = nums[k], sum = a+b+c; if (sum == 0) triples.push_back(&#123;a, b, c&#125;); if (sum &lt;= 0) while (nums[j] == b &amp;&amp; j &lt; k) j++; if (sum &gt;= 0) while (nums[k] == c &amp;&amp; j &lt; k) k--; &#125; while (nums[i] == a &amp;&amp; i &lt; last) i++; &#125; return triples;&#125; https://discuss.leetcode.com/topic/3396/my-iterative-sollution-very-simple-under-15-lines My iterative sollution, very simple under 15 lines This is my solution, FYI é’ˆå¯¹æ–°æ¥çš„ä¸€ä¸ªæ•°å­—ï¼Œæ¯”å¦‚2=â€œabcâ€ï¼Œä»ŽåŽŸæœ‰çš„resä¸­çš„æ‰€æœ‰stringéƒ½å–å‡ºæ¥ï¼Œé’ˆå¯¹æ¯ä¸€ä¸ªéƒ½åŠ ä¸€ä¸ªaæˆ–bæˆ–cï¼Œå†æ”¾å…¥resã€‚ 12345678910111213141516171819class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.size()==0) return res; string charmap[10] = &#123;&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; res.push_back(&quot;&quot;); for (int i = 0; i &lt; digits.size(); i++) &#123; vector&lt;string&gt; tempres; string chars = charmap[digits[i] - &apos;0&apos;]; for (int c = 0; c &lt; chars.size();c++) for (int j = 0; j &lt; res.size();j++) tempres.push_back(res[j]+chars[c]); res = tempres; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/13160/8-line-backtracking-function-c-solution 8-line Backtracking-Function C++ Solution Most concise backtracking function, no? 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.size()==0) return res; string local; vector&lt;vector&lt;char&gt;&gt; table(2,vector&lt;char&gt;()); table.push_back(vector&lt;char&gt;&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;); // index 2 table.push_back(vector&lt;char&gt;&#123;&apos;d&apos;,&apos;e&apos;,&apos;f&apos;&#125;); // 3 table.push_back(vector&lt;char&gt;&#123;&apos;g&apos;,&apos;h&apos;,&apos;i&apos;&#125;); table.push_back(vector&lt;char&gt;&#123;&apos;j&apos;,&apos;k&apos;,&apos;l&apos;&#125;); // 5 table.push_back(vector&lt;char&gt;&#123;&apos;m&apos;,&apos;n&apos;,&apos;o&apos;&#125;); table.push_back(vector&lt;char&gt;&#123;&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;&#125;); // 7 table.push_back(vector&lt;char&gt;&#123;&apos;t&apos;,&apos;u&apos;,&apos;v&apos;&#125;); table.push_back(vector&lt;char&gt;&#123;&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;&#125;); // 9 backtracking(table,res,local,0,digits); return res; &#125; void backtracking(const vector&lt;vector&lt;char&gt;&gt;&amp; table, vector&lt;string&gt;&amp; res, string&amp; local, int index, const string&amp; digits) &#123; if(index==digits.size()) res.push_back(local); else for(int i=0;i&lt;table[digits[index]-&apos;0&apos;].size();i++) &#123; local.push_back(table[digits[index]-&apos;0&apos;][i]); backtracking(table, res, local, index+1, digits); local.pop_back(); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/22619/python-easy-to-understand-solution-o-n-n-time Python easy to understand solution (O(n*n) time). 123456789101112131415161718192021def threeSum(self, nums): res = [] nums.sort() for i in xrange(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue l, r = i+1, len(nums)-1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s &lt; 0: l +=1 elif s &gt; 0: r -= 1 else: res.append((nums[i], nums[l], nums[r])) while l &lt; r and nums[l] == nums[l+1]: l += 1 while l &lt; r and nums[r] == nums[r-1]: r -= 1 l += 1; r -= 1 return res https://discuss.leetcode.com/topic/13703/straight-forward-python-ac-o-n-2-solution-with-decent-explanation Straight forward Python AC O(n^2) solution with decent explanation 1234567891011121314151617181920212223242526272829class Solution: # @param &#123;integer[]&#125; nums # @return &#123;integer[][]&#125; def threeSum(self, nums): if len(nums) &lt;3: # deal with special input return [] elif len(nums) == 3: if sum(nums) == 0: return [sorted(nums)] nums = sorted(nums) # sorted, O(nlgn) ans = [] for i in range(len(nums) -2): j = i+1 k = len(nums) -1 # hence i &lt; j &lt; k while j&lt;k: # if not cross line temp_sum = nums[i] + nums[j] + nums[k] if temp_sum == 0: ans.append((nums[i], nums[j], nums[k])) if temp_sum &gt; 0: # which means we need smaller sum, move k backward, remember we sort the array k -= 1 else: j += 1 return list(set(tuple(ans))) # I bet this is not the best way to eliminate duplicate solutions https://discuss.leetcode.com/topic/11783/one-line-python-solution 48ms, 58.58%, September 1, 2016 123456789101112131415161718class Solution(object): def letterCombinations(self, digits): &quot;&quot;&quot; :type digits: str :rtype: List[str] &quot;&quot;&quot; if digits == &apos;&apos;: return [] kvmaps = &#123; &apos;2&apos;:&apos;abc&apos;, &apos;3&apos;:&apos;def&apos;, &apos;4&apos;:&apos;ghi&apos;, &apos;5&apos;:&apos;jkl&apos;, &apos;6&apos;:&apos;mno&apos;, &apos;7&apos;:&apos;pqrs&apos;, &apos;8&apos;:&apos;tuv&apos;, &apos;9&apos;:&apos;wxyz&apos; &#125; return reduce(lambda acc, digit:[x+y for x in acc for y in kvmaps[digit]], digits, [&apos;&apos;])]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[016. 3Sum Closest]]></title>
    <url>%2Fp%2F473b519e%2F</url>
    <content type="text"><![CDATA[30.7% https://leetcode.com/problems/3sum-closest/ Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. 123For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). æ–¹æ³•ä¸€ï¼š å…ˆsortï¼Œç„¶åŽä¸€ä¸ªæŒ‡é’ˆï¼Œä»Žå¤´éåŽ†ï¼Œå¦å¤–ä¸¤ä¸ªæŒ‡é’ˆã€‚ https://discuss.leetcode.com/topic/17215/c-solution-o-n-2-using-sort C++ solution O(n^2) using sort Sort the vector and then no need to run O(N^3) algorithm as each index has a direction to move. 1234567The code starts from this formation.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678if nums[first] + nums[second] + nums[third] is smaller than the target, we know we have to increase the sum. so only choice is moving the second index forward.----------------------------------------------------^ ^ ^| | || +- second third+-first 123456789if the sum is bigger than the target, we know that we need to reduce the sum. so only choice is moving &apos;third&apos; to backward. of course if the sum equals to target, we can immediately return the sum.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678when second and third cross, the round is done so start next round by moving &apos;first&apos; and resetting second and third.---------------------------------------------------- ^ ^ ^ | | | | +- second third +-first 123456789while doing this, collect the closest sum of each stage by calculating and comparing delta. Compare abs(target-newSum) and abs(target-closest). At the end of the process the three indexes will eventually be gathered at the end of the array.---------------------------------------------------- ^ ^ ^ | | `- third | +- second +-first if no exactly matching sum has been found so far, the value in closest will be the answer. 1234567891011121314151617181920212223int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size() &lt; 3) return 0; int closest = nums[0]+nums[1]+nums[2]; sort(nums.begin(), nums.end()); for(int first = 0 ; first &lt; nums.size()-2 ; ++first) &#123; if(first &gt; 0 &amp;&amp; nums[first] == nums[first-1]) continue; int second = first+1; int third = nums.size()-1; while(second &lt; third) &#123; int curSum = nums[first]+nums[second]+nums[third]; if(curSum == target) return curSum; if(abs(target-curSum)&lt;abs(target-closest)) &#123; closest = curSum; &#125; if(curSum &gt; target) &#123; --third; &#125; else &#123; ++second; &#125; &#125; &#125; return closest;&#125; https://discuss.leetcode.com/topic/36978/12-lines-concise-and-easy-understand-c-solultion 12 lines concise and easy understand c++ solultion 1234567891011121314151617class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; nums.size() - 2; i++)&#123; int j = i + 1, k = nums.size() - 1; while(j &lt; k)&#123; int num = nums[i] + nums[j] + nums[k]; if(abs(num - target) &lt; abs(res - target)) res = num; if(num &lt; target) j++; else k--; &#125; &#125; return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°: 123456789101112131415161718192021222324class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; // res åˆå§‹åŒ–ä¸ºINT_MAXå¯èƒ½ä¼šå¯¼è‡´å„ç§æ„å¤–ï¼Œå› ä¸ºresè¦è¿›è¡ŒåŠ å‡ // å®¹æ˜“è¶…èŒƒå›´ï¼Œæœ€å¥½çš„åŠžæ³•æ˜¯ä»»æ„åˆå§‹åŒ– int res = nums[0]+nums[1]+nums[2]; int n = nums.size(); sort(nums.begin(), nums.end()); for(int first=0; first&lt;n-2; first++)&#123; int second = first+1, third = n-1; while(second&lt;third)&#123; int cur = nums[first]+nums[second]+nums[third]; // å­¦ä¹ ä½¿ç”¨abså‡½æ•°ï¼Œç”¨äºŽæ±‚ç»å¯¹å€¼ if(abs(cur-target)&lt;abs(res-target)) res = cur; if(cur&lt;target) second++; else third--; &#125; &#125; return res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/1978/a-n-2-solution-can-we-do-better Here is a solution in Order(N^2). I got help from this post onstackoverflow Can we improve this time complexity ? Edit:Thanks @thr for pointing out that. I have corrected it and also renamed â€˜mxâ€™ by â€˜ansâ€™. 12345678910111213141516171819202122232425262728293031323334353637383940int threeSumClosest(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;int&gt; v(num.begin(), num.end()); // I didn&apos;t wanted to disturb original array. int n = 0; int ans = 0; int sum; sort(v.begin(), v.end()); // If less then 3 elements then return their sum while (v.size() &lt;= 3) &#123; return accumulate(v.begin(), v.end(), 0); &#125; n = v.size(); /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1] * v[i] &lt;= v[j] &lt;= v[k] always, because we sorted our array. * Now, for each number, v[i] : we look for pairs v[j] &amp; v[k] such that * absolute value of (target - (v[i] + v[j] + v[k]) is minimised. * if the sum of the triplet is greater then the target it implies * we need to reduce our sum, so we do K = K - 1, that is we reduce * our sum by taking a smaller number. * Simillarly if sum of the triplet is less then the target then we * increase out sum by taking a larger number, i.e. J = J + 1. */ ans = v[0] + v[1] + v[2]; for (int i = 0; i &lt; n-2; i++) &#123; int j = i + 1; int k = n - 1; while (j &lt; k) &#123; sum = v[i] + v[j] + v[k]; if (abs(target - ans) &gt; abs(target - sum)) &#123; ans = sum; if (ans == target) return ans; &#125; (sum &gt; target) ? k-- : j++; &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/17215/c-solution-o-n-2-using-sort C++ solution O(n^2) using sort Sort the vector and then no need to run O(N^3) algorithm as each index has a direction to move. 1234567The code starts from this formation.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678if nums[first] + nums[second] + nums[third] is smaller than the target, we know we have to increase the sum. so only choice is moving the second index forward.----------------------------------------------------^ ^ ^| | || +- second third+-first 123456789if the sum is bigger than the target, we know that we need to reduce the sum. so only choice is moving &apos;third&apos; to backward. of course if the sum equals to target, we can immediately return the sum.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678when second and third cross, the round is done so start next round by moving &apos;first&apos; and resetting second and third.---------------------------------------------------- ^ ^ ^ | | | | +- second third +-first 123456789while doing this, collect the closest sum of each stage by calculating and comparing delta. Compare abs(target-newSum) and abs(target-closest). At the end of the process the three indexes will eventually be gathered at the end of the array.---------------------------------------------------- ^ ^ ^ | | `- third | +- second +-first if no exactly matching sum has been found so far, the value in closest will be the answer. 1234567891011121314151617181920212223int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size() &lt; 3) return 0; int closest = nums[0]+nums[1]+nums[2]; sort(nums.begin(), nums.end()); for(int first = 0 ; first &lt; nums.size()-2 ; ++first) &#123; if(first &gt; 0 &amp;&amp; nums[first] == nums[first-1]) continue; int second = first+1; int third = nums.size()-1; while(second &lt; third) &#123; int curSum = nums[first]+nums[second]+nums[third]; if(curSum == target) return curSum; if(abs(target-curSum)&lt;abs(target-closest)) &#123; closest = curSum; &#125; if(curSum &gt; target) &#123; --third; &#125; else &#123; ++second; &#125; &#125; &#125; return closest;&#125; https://discuss.leetcode.com/topic/36978/12-lines-concise-and-easy-understand-c-solultion 12 lines concise and easy understand c++ solultion 1234567891011121314151617class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; nums.size() - 2; i++)&#123; int j = i + 1, k = nums.size() - 1; while(j &lt; k)&#123; int num = nums[i] + nums[j] + nums[k]; if(abs(num - target) &lt; abs(res - target)) res = num; if(num &lt; target) j++; else k--; &#125; &#125; return res; &#125;&#125;; 12ms, 51.55%, Apr.23rd, 2016 https://github.com/haoel/leetcode/blob/master/algorithms/cpp/3SumClosest/3SumClosest.cpp 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int n = nums.size(); int distance = 2147483647; int result; for(int i=0; i&lt;n-2; i++)&#123; if(i&gt;0 &amp;&amp; nums[i-1]==nums[i]) continue; int a = nums[i]; int low = i+1; int high = n-1; while(low &lt; high)&#123; int b = nums[low]; int c = nums[high]; int sum = a + b + c; if(sum - target == 0) return target; else&#123; if(abs(sum - target) &lt; distance)&#123; distance = abs(sum - target); result = sum; &#125; if (sum - target &gt; 0)&#123; while(high &gt; 0 &amp;&amp; nums[high] == nums[high-1]) high--; high--; &#125;else&#123; while(low &lt; n-1 &amp;&amp; nums[low] == nums[low+1]) low++; low++; &#125; &#125; &#125; &#125; return result; &#125;&#125;; 28ms, 16.01%, Apr.23rd, 2016 https://leetcode.com/discuss/85999/12-lines-concise-and-easy-understand-c-solultion 1234567891011121314151617class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; nums.size(); i++)&#123; int j = i + 1, k = nums.size() - 1; while(j &lt; k)&#123; int num = nums[i] + nums[j] + nums[k]; if(abs(num - target) &lt; abs(res - target)) res = num; if(num &lt; target) j++; else k--; &#125; &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/9815/python-o-n-2-solution Python O(N^2) solution 123456789101112131415161718192021class Solution: # @return an integer def threeSumClosest(self, num, target): num.sort() result = num[0] + num[1] + num[2] for i in range(len(num) - 2): j, k = i+1, len(num) - 1 while j &lt; k: sum = num[i] + num[j] + num[k] if sum == target: return sum if abs(sum - target) &lt; abs(result - target): result = sum if sum &lt; target: j += 1 elif sum &gt; target: k -= 1 return result https://discuss.leetcode.com/topic/20359/python-solution-two-pointer Python solution (two-pointer). 12345678910111213141516def threeSumClosest(self, nums, target): nums.sort() res = sum(nums[:3]) for i in xrange(len(nums)): l, r = i+1, len(nums)-1 while l &lt; r: s = sum((nums[i], nums[l], nums[r])) if abs(s-target) &lt; abs(res-target): res = s if s &lt; target: l += 1 elif s &gt; target: r -= 1 else: # break early return res return res 508ms, 2.61%, Apr.23rd, 2016 http://c4fun.cn/blog/2014/03/20/leetcode-solution-02/ æ±‚é›†åˆä¸­3ä¸ªæ•°èƒ½å¤Ÿå¾—åˆ°çš„è·ç¦»targetæœ€è¿‘çš„å’Œ å’Œ3Sumä¸€æ ·ï¼Œè€Œä¸”ä¸ç”¨å¤„ç†é‡å¤è§£é—®é¢˜äº†ã€‚ 1234567891011121314151617181920class Solution(object): def threeSumClosest(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; nums.sort() ans = None for i in range(len(nums)): l, r = i + 1, len(nums) - 1 while l &lt; r: sum = nums[l] + nums[r] + nums[i] if ans is None or abs(sum - target) &lt; abs(ans - target): ans = sum if sum &lt;= target: l = l + 1 else: r = r - 1 return ans java https://discuss.leetcode.com/topic/5192/java-solution-with-o-n2-for-reference Java solution with O(n2) for reference Similar to 3 Sum problem, use 3 pointers to point current element, next element and the last element. If the sum is less than target, it means we have to add a larger element so next element move to the next. If the sum is greater, it means we have to add a smaller element so last element move to the second last element. Keep doing this until the end. Each time compare the difference between sum and target, if it is less than minimum difference so far, then replace result with it, otherwise keep iterating. 123456789101112131415161718192021public class Solution &#123; public int threeSumClosest(int[] num, int target) &#123; int result = num[0] + num[1] + num[num.length - 1]; Arrays.sort(num); for (int i = 0; i &lt; num.length - 2; i++) &#123; int start = i + 1, end = num.length - 1; while (start &lt; end) &#123; int sum = num[i] + num[start] + num[end]; if (sum &gt; target) &#123; end--; &#125; else &#123; start++; &#125; if (Math.abs(sum - target) &lt; Math.abs(result - target)) &#123; result = sum; &#125; &#125; &#125; return result; &#125;&#125; https://discuss.leetcode.com/topic/31117/7ms-and-o-n-2-java-solution 7ms and o(n^2) java solution My solution does not need compare each sum ,just need to compare possible sum ,so can save time. 123456789101112131415161718192021222324public class Solution &#123;public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int closest=nums[0]+nums[1]+nums[2]; int low,high; for(int i=0;i&lt;nums.length-1;i++)&#123; low=i+1; high=nums.length-1; while(low&lt;high)&#123; if(nums[low]+nums[high]==target-nums[i]) return target; else if(nums[low]+nums[high]&gt;target-nums[i])&#123; while(low&lt;high&amp;&amp;nums[low]+nums[high]&gt;target-nums[i]) high--; if(Math.abs(nums[i]+nums[low]+nums[high+1]-target)&lt;Math.abs(closest-target)) closest=nums[i]+nums[low]+nums[high+1]; &#125; else&#123; while(low&lt;high&amp;&amp;nums[low]+nums[high]&lt;target-nums[i]) low++; if(Math.abs(nums[i]+nums[low-1]+nums[high]-target)&lt;Math.abs(closest-target)) closest=nums[i]+nums[low-1]+nums[high]; &#125; &#125; &#125; return closest;&#125; https://discuss.leetcode.com/topic/35892/share-my-24-line-java-code-beats-94-57-run-times Share my 24-line Java code (beats 94.57% run times) 1234567891011121314151617181920212223242526public class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int diff = Integer.MAX_VALUE, closest = 0; for (int k=0; k&lt;nums.length-2; ++k) &#123; for (int i=k+1, j=nums.length-1; i&lt;j; ) &#123; int sum = nums[k] + nums[i] + nums[j]; if (sum == target) &#123; return target; &#125; else if (sum &gt; target) &#123; if (sum-target &lt; diff) &#123; diff = sum-target; closest = sum; &#125; --j; &#125; else &#123; if (target-sum &lt; diff) &#123; diff = target-sum; closest = sum; &#125; ++i; &#125; &#125; &#125; return closest; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[015. 3Sum]]></title>
    <url>%2Fp%2F6a4c11d8%2F</url>
    <content type="text"><![CDATA[21.2% https://leetcode.com/problems/3sum/ Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 1234567For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [[-1, 0, 1],[-1, -1, 2] ] æ–¹æ³•ä¸€ï¼š å…ˆæŽ’åºï¼Œç„¶åŽä»¥iè¿›è¡ŒéåŽ†ï¼Œç„¶åŽæ”¾jå’Œkä¸¤ä¸ªæŒ‡é’ˆéåŽ†ã€‚ é‡ç‚¹æ˜¯è€ƒè™‘é‡å¤çš„æƒ…å†µï¼Œæ‰€ä»¥æœ‰ä¸¤å¤„è€ƒè™‘äº†é‡å¤çš„é—®é¢˜ã€‚ 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); int n = nums.size(); for(int i=0; i&lt;n-2; i++)&#123; if(i!=0 &amp;&amp; nums[i]==nums[i-1]) continue; int target = 0 - nums[i]; int j=i+1, k=n-1; while(j&lt;k)&#123; if(nums[j]+nums[k]==target)&#123; vector&lt;int&gt; tmp&#123;nums[i], nums[j], nums[k]&#125;; res.push_back(tmp); while(j&lt;k &amp;&amp; nums[j]==tmp[1]) j++; while(j&lt;k &amp;&amp; nums[k]==tmp[2]) k--; &#125;else if(nums[j]+nums[k]&gt;target)&#123; k--; &#125;else j++; &#125; &#125; return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ä¸€ï¼š æ³¨æ„å…¶ä¸­çš„é‡ç‚¹ï¼Œä¸€ä¸ªæ˜¯è¦è€ƒè™‘é‡å¤ï¼Œä¸€ä¸ªæ˜¯è¦è€ƒè™‘è·³å‡ºå¾ªçŽ¯ 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); if(n&lt;3) return res; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-2; i++)&#123; if(i!=0 &amp;&amp; nums[i]==nums[i-1]) // è€ƒè™‘é‡å¤æƒ…å†µ continue; int left = i+1, right = n-1; while(left&lt;right)&#123; int sum = nums[i]+nums[left]+nums[right]; if(sum==0)&#123; vector&lt;int&gt; tmp = &#123;nums[i], nums[left], nums[right]&#125;; res.push_back(tmp); while(left+1&lt;right &amp;&amp; nums[left+1]==nums[left]) left++; // æ­¤å¤„è¦è·³å‡ºå¾ªçŽ¯ï¼Œç»§ç»­å¯»æ‰¾ while(left&lt;right-1 &amp;&amp; nums[right-1]==nums[right]) right--; left++, right--; &#125;else if(sum&lt;0) left++; else right--; &#125; &#125; return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°äºŒ: 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); if(n&lt;3) return res; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-2; i++)&#123; // è€ƒè™‘é‡å¤çš„æƒ…å†µ if(i!=0 &amp;&amp; nums[i]==nums[i-1]) continue; int target = - nums[i]; int left = i+1, right = n-1; while(left&lt;right)&#123; int sum = nums[left] + nums[right]; if(sum==target)&#123; res.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;); while(left&lt;right &amp;&amp; nums[left+1]==nums[left]) left++; while(left&lt;right &amp;&amp; nums[right-1]==nums[right]) right--; left++; right--; &#125; else if(sum&lt;target) left++; else right--; &#125; &#125; return res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/8107/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments the key idea is the same as the TwoSum problem. When we fix the 1st number, the 2nd and 3rd number can be found following the same reasoning as TwoSum. The only difference is that, the TwoSum problem of LEETCODE has a unique solution. However, in ThreeSum, we have multiple duplicate solutions that can be found. Most of the OLE errors happened here because you couldâ€™ve ended up with a solution with so many duplicates. The naive solution for the duplicates will be using the STL methods like below : 12std::sort(res.begin(), res.end());res.erase(unique(res.begin(), res.end()), res.end()); But according to my submissions, this way will cause you double your time consuming almostly. A better approach is that, to jump over the number which has been scanned, no matter it is part of some solution or not. If the three numbers formed a solution, we can safely ignore all the duplicates of them. We can do this to all the three numbers such that we can remove the duplicates. Hereâ€™s my AC C++ Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; res; std::sort(num.begin(), num.end()); for (int i = 0; i &lt; num.size(); i++) &#123; int target = -num[i]; int front = i + 1; int back = num.size() - 1; while (front &lt; back) &#123; int sum = num[front] + num[back]; // Finding answer which start from number num[i] if (sum &lt; target) front++; else if (sum &gt; target) back--; else &#123; vector&lt;int&gt; triplet(3, 0); triplet[0] = num[i]; triplet[1] = num[front]; triplet[2] = num[back]; res.push_back(triplet); // Processing duplicates of Number 2 // Rolling the front pointer to the next different number forwards while (front &lt; back &amp;&amp; num[front] == triplet[1]) front++; // Processing duplicates of Number 3 // Rolling the back pointer to the next different number backwards while (front &lt; back &amp;&amp; num[back] == triplet[2]) rear--; &#125; &#125; // Processing duplicates of Number 1 while (i + 1 &lt; num.size() &amp;&amp; num[i + 1] == num[i]) i++; &#125; return res; &#125; 64ms, 23.81%, Apr.23rd, 2016 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt; vector&lt;int&gt; &gt; result; // å…ˆæŽ’åº sort(nums.begin(), nums.end()); int n = nums.size(); for(int i=0; i&lt;n-2; i++)&#123; // è·³è¿‡é‡å¤é¡¹ if(i&gt;0 &amp;&amp; nums[i-1]==nums[i]) continue; int a = nums[i]; int low = i + 1; int high = n - 1; while(low &lt; high)&#123; int b = nums[low]; int c = nums[high]; if(a + b + c == 0)&#123; vector&lt;int&gt; v; v.push_back(a); v.push_back(b); v.push_back(c); result.push_back(v); // ç»§ç»­å¯»æ‰¾ç­”æ¡ˆ,å¿½ç•¥é‡å¤é¡¹ï¼Œhighï¼Œlowå„åŠ 1 while(low &lt; n-1 &amp;&amp; nums[low] == nums[low+1]) low++; while(high &gt; 0 &amp;&amp; nums[high] == nums[high-1]) high--; low++; high--; &#125;else if(a+b+c &gt; 0)&#123; while(high &gt; 0 &amp;&amp; nums[high] == nums[high-1]) high--; high--; &#125;else&#123; while(low &gt; 0 &amp;&amp; nums[low] == nums[low+1]) low++; low++; &#125; &#125; &#125; return result; &#125;&#125;; python 224ms, 44.36%, Apr.23rd, 2016 æ±‚3ä¸ªæ•°çš„å’Œä¸ºtargetçš„æ‰€æœ‰è§£ã€‚ æžšä¸¾ç¬¬ä¸€ä¸ªæ•°ï¼Œç„¶åŽç¬¬äºŒä¸ªæ•°ä¸ºè¿™ä¸ªæ•°çš„åŽä¸€ä¸ªæ•°ï¼Œç¬¬ä¸‰ä¸ªæ•°ä¸ºæœ€åŽä¸€ä¸ªæ•°ï¼Œå¦‚æžœå’Œå°äºŽ0ï¼Œç¬¬äºŒä¸ªæ•°åŽç§»ï¼Œ å¦‚å¤§äºŽ0ç¬¬ä¸‰ä¸ªæ•°å‰ç§»ï¼Œç­‰äºŽ0çš„è¯è®°å½•ç»“æžœå¹¶ä¸”éƒ½å‘ä¸­é—´ç§»ã€‚æ³¨æ„å¤„ç†é‡å¤è§£ã€‚ 123456789101112131415161718192021class Solution: # @return a list of lists of length 3, [[val1,val2,val3]] def threeSum(self, num): num.sort() ans = [] for i in range(len(num)): if (i &gt; 0 and num[i] == num[i-1]): continue l, r = i + 1, len(num) - 1 while l &lt; r: sum = num[l] + num[r] + num[i] if sum == 0: ans.append([num[i], num[l], num[r]]) while l &lt; r and num[l] == num[l + 1]: l = l + 1 while l &lt; r and num[r] == num[r - 1]: r = r - 1 l, r = l + 1, r - 1 elif sum &lt; 0: l = l + 1 else: r = r - 1 return ans java https://discuss.leetcode.com/topic/8125/concise-o-n-2-java-solution Concise O(N^2) Java solution Hi guys! The idea is to sort an input array and then run through all indices of a possible first element of a triplet. For each possible first element we make a standard bi-directional 2Sum sweep of the remaining part of the array. Also we want to skip equal elements to avoid duplicates in the answer without making a set or smth like that. Have a nice coding! 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) &#123; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; num.length-2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; num[i] != num[i-1])) &#123; int lo = i+1, hi = num.length-1, sum = 0 - num[i]; while (lo &lt; hi) &#123; if (num[lo] + num[hi] == sum) &#123; res.add(Arrays.asList(num[i], num[lo], num[hi])); while (lo &lt; hi &amp;&amp; num[lo] == num[lo+1]) lo++; while (lo &lt; hi &amp;&amp; num[hi] == num[hi-1]) hi--; lo++; hi--; &#125; else if (num[lo] + num[hi] &lt; sum) lo++; else hi--; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/28857/easiest-java-solution Easiest Java Solution Sort the array, iterate through the list, and use another two pointers to approach the target. 12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i + 2 &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; // skip same result continue; &#125; int j = i + 1, k = nums.length - 1; int target = -nums[i]; while (j &lt; k) &#123; if (nums[j] + nums[k] == target) &#123; res.add(Arrays.asList(nums[i], nums[j], nums[k])); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++; // skip same result while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--; // skip same result &#125; else if (nums[j] + nums[k] &gt; target) &#123; k--; &#125; else &#123; j++; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/45491/share-my-simple-java-solution Share my simple java solution 123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(nums.length &lt; 3) return result; Arrays.sort(nums); int i = 0; while(i &lt; nums.length - 2) &#123; if(nums[i] &gt; 0) break; int j = i + 1; int k = nums.length - 1; while(j &lt; k) &#123; int sum = nums[i] + nums[j] + nums[k]; if(sum == 0) result.add(Arrays.asList(nums[i], nums[j], nums[k])); if(sum &lt;= 0) while(nums[j] == nums[++j] &amp;&amp; j &lt; k); if(sum &gt;= 0) while(nums[k--] == nums[k] &amp;&amp; j &lt; k); &#125; while(nums[i] == nums[++i] &amp;&amp; i &lt; nums.length - 2); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[014. Longest Common Prefix]]></title>
    <url>%2Fp%2F58ae5420%2F</url>
    <content type="text"><![CDATA[31.5% https://leetcode.com/problems/longest-common-prefix/ Write a function to find the longest common prefix string amongst an array of strings. æ–¹æ³•ä¸€ï¼š First one: check from strs[0][0] to strs[i][0]. If matches, check strs[0][1] to strs[i][1]. Code: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=&quot;&quot;; int max=INT_MAX; for(auto&amp; s:strs) &#123; max=(max&gt;s.length())?s.length():max; &#125; for(int i=0;i&lt;max;i++) &#123; bool flag=true; char x=strs[0][i]; for(auto&amp; s:strs) &#123; if(s[i]!=x) &#123; flag=false; break; &#125; &#125; if(flag==false) return ans; ans+=x; &#125; return ans; &#125;&#125;; ä»£ç çš„å¦ä¸€ç§å†™æ³•ï¼š 12345678910111213class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string prefix = &quot;&quot;; for(int idx=0; strs.size()&gt;0;idx++)&#123; for(int i=0; i&lt;strs.size(); i++) if(idx&gt;=strs[i].size() || (i&gt;0&amp;&amp;strs[i][idx] != strs[i-1][idx])) return prefix; prefix+=strs[0][idx]; &#125; return prefix; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string res = ""; int n = strs.size(); // ä¸€å®šè€ƒè™‘æ˜¯å¦æœ‰å¼‚å¸¸æƒ…å†µçš„å¯èƒ½æ€§ if(n==0) return res; int i = 0; while(true)&#123; for(int j=0; j&lt;n; j++)&#123; if(i&gt;=strs[j].size() || j&gt;0 &amp;&amp; strs[j][i]!=strs[j-1][i])&#123; return res; &#125; &#125; res += strs[0][i]; i++; &#125; &#125;&#125;; æ–¹æ³•äºŒï¼š Second one: assume the prefix is strs[0]. Compair with strs[i], and cut the letters which donâ€™t match. Code: 1234567891011121314151617181920212223class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=strs[0]; int max=INT_MAX; for(auto&amp; s:strs) &#123; if(s.length()==0) return &quot;&quot;; int i=0; for(i=0;i&lt;ans.length()&amp;&amp;i&lt;s.length();i++) &#123; if(s[i]!=ans[i]) break; &#125; ans=ans.substr(0,i); &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/13121/what-does-longest-common-prefix-mean What does Longest Common Prefix mean ? The problem statement is confusing and unclear. Can someone throw light on this ? Is it to find prefix between each pair of strings and return the one which is longest. Or all the strings has to have a common prefix? https://discuss.leetcode.com/topic/13121/what-does-longest-common-prefix-mean/2 It seems that it is not to check between pair of strings but on all the strings in the array. For example: {â€œaâ€,â€aâ€,â€bâ€} should give â€œâ€ as there is nothing common in all the 3 strings. {â€œaâ€, â€œaâ€} should give â€œaâ€ as a is longest common prefix in all the strings. {â€œabcaâ€, â€œabcâ€} as abc {â€œacâ€, â€œacâ€, â€œaâ€, â€œaâ€} as a. Logic goes something like this: Pick a character at i=0th location and compare it with the character at that location in every string. If anyone doesnâ€™t have that just return â€œâ€ Else append that character in to the result. Increment i and do steps 1-3 till the length of that string. return result. Make sure proper checks are maintained to avoid index out of bounds error. cpp https://discuss.leetcode.com/topic/20991/accepted-c-6-lines-4ms Accepted c++ 6 lines 4ms 6ms, September 19, 2016 1234567891011class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string prefix = &quot;&quot;; for(int idx=0; strs.size()&gt;0;prefix+=strs[0][idx], idx++) for(int i=0; i&lt;strs.size(); i++) if(idx&gt;=strs[i].size() || (i&gt;0&amp;&amp;strs[i][idx] != strs[i-1][idx])) return prefix; return prefix; &#125;&#125;; https://discuss.leetcode.com/topic/16623/3-diffrent-c-solutions-each-one-costs-8ms 3 diffrent C++ solutions, each one costs 8ms. First one: check from strs[0][0] to strs[i][0]. If matches, check strs[0][1] to strs[i][1]. Code: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=&quot;&quot;; int max=INT_MAX; for(auto&amp; s:strs) &#123; max=(max&gt;s.length())?s.length():max; &#125; for(int i=0;i&lt;max;i++) &#123; bool flag=true; char x=strs[0][i]; for(auto&amp; s:strs) &#123; if(s[i]!=x) &#123; flag=false; break; &#125; &#125; if(flag==false) return ans; ans+=x; &#125; return ans; &#125;&#125;; Second one: assume the prefix is strs[0]. Compair with strs[i], and cut the letters which donâ€™t match. Code: 1234567891011121314151617181920212223class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=strs[0]; int max=INT_MAX; for(auto&amp; s:strs) &#123; if(s.length()==0) return &quot;&quot;; int i=0; for(i=0;i&lt;ans.length()&amp;&amp;i&lt;s.length();i++) &#123; if(s[i]!=ans[i]) break; &#125; ans=ans.substr(0,i); &#125; return ans; &#125;&#125;; Third one: use a Trie data structure to save the strs. Search the trie, and stops when a TrieNode has more than one son. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879Code:class TrieNode&#123;public: bool val; TrieNode* next[52]; int sons; TrieNode() :val(false), sons(0) &#123; for (int i = 0; i &lt; 52; i++) next[i] = nullptr; &#125;&#125;;class Trie&#123;private: TrieNode* putst(string&amp; s, TrieNode * node, int loc, TrieNode *father) &#123; if (s.length() == 0) &#123; node-&gt;val = true; node-&gt;sons++; return node; &#125; if (node == nullptr) &#123; node = new TrieNode(); if (father != nullptr) father-&gt;sons++; &#125; if (loc == s.length()) &#123; node-&gt;val = true; return node; &#125; if (s[loc] &gt;= &apos;a&apos;) node-&gt;next[s[loc] - &apos;a&apos;] = putst(s, node-&gt;next[s[loc] - &apos;a&apos;], loc + 1, node); else node-&gt;next[s[loc] - &apos;A&apos; + 26] = putst(s, node-&gt;next[s[loc] - &apos;A&apos; + 26], loc + 1, node); return node; &#125;public: TrieNode *root; void insert(string &amp; str)&#123; putst(str, root, 0, nullptr); &#125; Trie()&#123; root = new TrieNode(); &#125;&#125;;class Solution &#123;private: string findPre(TrieNode * node) &#123; if (node == nullptr || (node != nullptr&amp;&amp;node-&gt;sons &gt; 1)) return string(&quot;&quot;); int i = 0; for (i = 0; i &lt; 52; i++) &#123; if (node-&gt;next[i] != nullptr) break; &#125; if (i == 52) return string(&quot;&quot;); char temp1 = ((i&gt;25) ? (&apos;A&apos; + i) : (&apos;a&apos; + i)); string temp; temp.insert(temp.begin(), temp1); if (node-&gt;val) &#123; return string(&quot;&quot;); &#125; else &#123; return temp + findPre(node-&gt;next[i]); &#125; &#125;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; Trie a; for (auto&amp; str : strs) a.insert(str); return findPre(a.root); &#125;&#125;; python https://discuss.leetcode.com/topic/6308/simple-python-solution Simple Python solution 62ms, September 19, 2016 Might be a bit slow, but hereâ€™s my relatively elegant Python solution: 1234567891011121314class Solution(object): def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str] :rtype: str &quot;&quot;&quot; if not strs: return &apos;&apos; for i, letter_group in enumerate(zip(*strs)): if len(set(letter_group)) &gt; 1: return strs[0][:i] return min(strs) https://discuss.leetcode.com/topic/6308/simple-python-solution/2 Nice use of zip. Hereâ€™s my version, it ran in 58 ms. I was proud of myself for using reduce() appropriately: 123456789101112131415161718class Solution: def lcp(self, str1, str2): i = 0 while (i &lt; len(str1) and i &lt; len(str2)): if str1[i] == str2[i]: i = i+1 else: break return str1[:i] # @return a string def longestCommonPrefix(self, strs): if not strs: return &apos;&apos; else: return reduce(self.lcp,strs) https://discuss.leetcode.com/topic/27094/5-line-python-with-zip-and-len-set 5 line python with zip() and len(set()) Just for fun :) 1234567891011class Solution(object): def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str]; rtype: str &quot;&quot;&quot; sz, ret = zip(*strs), &quot;&quot; # looping corrected based on @StefanPochmann&apos;s comment below for c in sz: if len(set(c)) &gt; 1: break ret += c[0] return ret https://discuss.leetcode.com/topic/21222/already-implemented-in-python Already implemented in Python 1234567import osclass Solution: # @param &#123;string[]&#125; strs # @return &#123;string&#125; def longestCommonPrefix(self, strs): return os.path.commonprefix(strs) java https://discuss.leetcode.com/topic/6987/java-code-with-13-lines Java code with 13 lines 1234567891011public String longestCommonPrefix(String[] strs) &#123; if(strs == null || strs.length == 0) return &quot;&quot;; String pre = strs[0]; int i = 1; while(i &lt; strs.length)&#123; while(strs[i].indexOf(pre) != 0) pre = pre.substring(0,pre.length()-1); i++; &#125; return pre;&#125; https://discuss.leetcode.com/topic/6987/java-code-with-13-lines/6 Since you seem to value the number of lines, why didnâ€™t you use a for-loop? It saves three lines. 12345678public String longestCommonPrefix(String[] strs) &#123; if (strs.length == 0) return &quot;&quot;; String pre = strs[0]; for (int i = 1; i &lt; strs.length; i++) while(strs[i].indexOf(pre) != 0) pre = pre.substring(0,pre.length()-1); return pre;&#125; https://discuss.leetcode.com/topic/27913/sorted-the-array-java-solution-2-ms Sorted the array, Java solution, 2 ms Sort the array first, and then you can simply compare the first and last elements in the sorted array. 1234567891011121314151617181920public String longestCommonPrefix(String[] strs) &#123; StringBuilder result = new StringBuilder(); if (strs!= null &amp;&amp; strs.length &gt; 0)&#123; Arrays.sort(strs); char [] a = strs[0].toCharArray(); char [] b = strs[strs.length-1].toCharArray(); for (int i = 0; i &lt; a.length; i ++)&#123; if (b.length &gt; i &amp;&amp; b[i] == a[i])&#123; result.append(b[i]); &#125; else &#123; return result.toString(); &#125; &#125; return result.toString();&#125; https://discuss.leetcode.com/topic/12173/fast-and-simple-java-code-231ms Fast and simple Java code 231ms 1234567891011121314public class Solution &#123; public String longestCommonPrefix(List&lt;String&gt; strs) &#123; if(strs.size()==0) return &quot;&quot;; StringBuilder lcp=new StringBuilder(); for(int i=0;i&lt;strs.get(0).length();i++)&#123; char c=strs.get(0).charAt(i); for(String s:strs)&#123; if(s.length()&lt;i+1||c!=s.charAt(i)) return lcp.toString(); &#125; lcp.append(c); &#125; return lcp.toString(); &#125;&#125; https://discuss.leetcode.com/topic/40472/java-we-love-clear-code Java â€”â€” We Love Clear Code! 123456789101112public String longestCommonPrefix(String[] strs) &#123; if (strs == null) return null; if (strs.length == 0) return &quot;&quot;; Arrays.sort(strs); char[] first = strs[0].toCharArray(); char[] last = strs[strs.length - 1].toCharArray(); int i = 0, len = Math.min(first.length, last.length); while (i &lt; len &amp;&amp; first[i] == last[i]) i++; return strs[0].substring(0, i);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[013. Roman to Integer]]></title>
    <url>%2Fp%2F850f821a%2F</url>
    <content type="text"><![CDATA[46.0% https://leetcode.com/problems/roman-to-integer/ Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. æ–¹æ³•ä¸€: ä»ŽåŽå‘å‰éåŽ†ï¼Œå¦‚æžœå½“å‰å€¼å¤§äºŽå³è¾¹ï¼ŒåŠ ä¸Šå½“å‰å€¼ï¼Œå¦‚æžœå½“å‰å€¼å°äºŽå³è¾¹ï¼Œå‡åŽ»å½“å‰å€¼ã€‚ https://leetcode.com/discuss/22867/clean-o-n-c-solution Clean O(n) c++ solution 80ms, 7.24%, May.4th, 2016 Problem is simpler to solve by working the string from back to front and using a map. Runtime speed is 88 ms. 12345678910111213141516class Solution &#123;public: int romanToInt(string s) &#123; unordered_map&lt;char, int&gt; T = &#123;&#123; &apos;I&apos;, 1&#125;, &#123;&apos;V&apos;, 5&#125;, &#123;&apos;X&apos;, 10&#125;, &#123;&apos;L&apos;, 50&#125;, &#123;&apos;C&apos;, 100&#125;, &#123;&apos;D&apos;, 500&#125;, &#123;&apos;M&apos;, 1000&#125;&#125;; int sum = T[s.back()]; for(int i = s.length() - 2; i &gt;= 0; --i)&#123; if(T[s[i]] &lt; T[s[i + 1]]) sum -= T[s[i]]; else sum += T[s[i]]; &#125; return sum; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718class Solution &#123;public: int romanToInt(string s) &#123; int n = s.size(); if(n==0) return 0; // å­¦ä¹ mapçš„åˆå§‹åŒ– map&lt;char, int&gt; map = &#123;&#123;'I',1&#125;, &#123;'V', 5&#125;, &#123;'X', 10&#125;, &#123;'L', 50&#125;, &#123;'C', 100&#125;, &#123;'D', 500&#125;, &#123;'M', 1000&#125;&#125;; int res = map[s[n-1]]; // é€†å‘æ€è€ƒé—®é¢˜ï¼Œæœ‰æ—¶æ›´å®¹æ˜“è§£å†³ for(int i=n-2; i&gt;=0; i--) if(map[s[i]] &gt;= map[s[i+1]]) res += map[s[i]]; else res -= map[s[i]]; return res; &#125;&#125;; https://discuss.leetcode.com/topic/6127/my-easy-to-understand-c-solutions My easy-to-understand C++ solutions 1234567891011121314151617181920212223242526272829class Solution &#123;public: int romanToInt(string s) &#123; int num = 0; int size = s.size(); for (int i = 0; i &lt; size; i++) &#123; if (i &lt; (size - 1) &amp;&amp; romanCharToInt(s[i]) &lt; romanCharToInt(s[i + 1])) &#123; num -= romanCharToInt(s[i]); &#125; else &#123; num += romanCharToInt(s[i]); &#125; &#125; return num; &#125; int romanCharToInt(char c) &#123; switch (c) &#123; case &apos;I&apos;: return 1; case &apos;V&apos;: return 5; case &apos;X&apos;: return 10; case &apos;L&apos;: return 50; case &apos;C&apos;: return 100; case &apos;D&apos;: return 500; case &apos;M&apos;: return 1000; default: return 0; &#125; &#125;&#125;; The code is faster if the body of the for loop is replaced with: 12345678if (i &lt; (size - 1) &amp;&amp; ( &apos;I&apos; == s[i] &amp;&amp; (&apos;V&apos; == s[i + 1] || &apos;X&apos; == s[i + 1]) || &apos;X&apos; == s[i] &amp;&amp; (&apos;L&apos; == s[i + 1] || &apos;C&apos; == s[i + 1]) || &apos;C&apos; == s[i] &amp;&amp; (&apos;D&apos; == s[i + 1] || &apos;M&apos; == s[i + 1]) )) &#123; num -= romanCharToInt(s[i]);&#125; else &#123; num += romanCharToInt(s[i]);&#125; https://discuss.leetcode.com/topic/15224/simple-56ms-c-solution Simple 56ms C++ solution Processing the roman number from right to left turns out to be a bit easier since we can easily tell when to add or subtract: 123456789101112class Solution &#123;public: int romanToInt(string s) &#123; if (s.empty()) &#123; return 0; &#125; unordered_map&lt;char, int&gt; mp &#123; &#123;&apos;I&apos;, 1&#125;, &#123;&apos;V&apos;, 5&#125;, &#123;&apos;X&apos;, 10&#125;, &#123;&apos;L&apos;, 50&#125;, &#123;&apos;C&apos;, 100&#125;, &#123;&apos;D&apos;, 500&#125;, &#123;&apos;M&apos;, 1000&#125; &#125;; int sum = mp[s.back()]; for (int i = s.size() - 2; i &gt;= 0; --i) &#123; sum += mp[s[i]] &gt;= mp[s[i + 1]] ? mp[s[i]] : -mp[s[i]]; &#125; return sum; &#125;&#125;; https://discuss.leetcode.com/topic/30205/i-strongly-suggest-leetcode-explains-the-conversion-rule-clearer I strongly suggest leetcode explains the conversion rule clearer. It would help a lot for those who are not familiar with Roman numerals if the conversion rule is provided, or a conversion table similar to Roman Numerals Chart is given. python https://discuss.leetcode.com/topic/17110/my-straightforward-python-solution My Straightforward Python Solution 123456789101112class Solution:# @param &#123;string&#125; s# @return &#123;integer&#125;def romanToInt(self, s): roman = &#123;&apos;M&apos;: 1000,&apos;D&apos;: 500 ,&apos;C&apos;: 100,&apos;L&apos;: 50,&apos;X&apos;: 10,&apos;V&apos;: 5,&apos;I&apos;: 1&#125; z = 0 for i in range(0, len(s) - 1): if roman[s[i]] &lt; roman[s[i+1]]: z -= roman[s[i]] else: z += roman[s[i]] return z + roman[s[-1]] *Note: The trick is that the last letter is always added. Except the last one, if one letter is less than its latter one, this letter is subtracted. https://discuss.leetcode.com/topic/47179/4-lines-in-python 4 lines in Python d = {â€˜Mâ€™:1000, â€˜Dâ€™:500, â€˜Câ€™:100, â€˜Lâ€™:50, â€˜Xâ€™:10, â€˜Vâ€™:5, â€˜Iâ€™:1} 12345def romanToInt(self, s): res, p = 0, &apos;I&apos; for c in s[::-1]: res, p = res - d[c] if d[c] &lt; d[p] else res + d[c], c return res https://leetcode.com/discuss/21888/python-solution Python solution 160ms, 85.18%, May.4th, 2016 12345678910111213141516171819class Solution(object): def romanToInt(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; romans = &#123;&apos;M&apos;:1000, &apos;D&apos;:500, &apos;C&apos;:100, &apos;L&apos;:50, &apos;X&apos;:10, &apos;V&apos;:5, &apos;I&apos;:1&#125; prev_value = running_total = 0 for i in xrange(len(s)-1, -1, -1): int_val = romans[s[i]] if int_val &lt; prev_value: running_total -= int_val else: running_total += int_val prev_value = int_val return running_total java https://discuss.leetcode.com/topic/821/my-solution-for-this-question-but-i-don-t-know-is-there-any-easier-way My solution for this question but I donâ€™t know is there any easier way? count every Symbol and add its value to the sum, and minus the extra part of special cases. 1234567891011121314151617181920212223242526public int romanToInt(String s) &#123; int sum=0; if(s.indexOf(&quot;IV&quot;)!=-1)&#123;sum-=2;&#125; if(s.indexOf(&quot;IX&quot;)!=-1)&#123;sum-=2;&#125; if(s.indexOf(&quot;XL&quot;)!=-1)&#123;sum-=20;&#125; if(s.indexOf(&quot;XC&quot;)!=-1)&#123;sum-=20;&#125; if(s.indexOf(&quot;CD&quot;)!=-1)&#123;sum-=200;&#125; if(s.indexOf(&quot;CM&quot;)!=-1)&#123;sum-=200;&#125; char c[]=s.toCharArray(); int count=0; for(;count&lt;=s.length()-1;count++)&#123; if(c[count]==&apos;M&apos;) sum+=1000; if(c[count]==&apos;D&apos;) sum+=500; if(c[count]==&apos;C&apos;) sum+=100; if(c[count]==&apos;L&apos;) sum+=50; if(c[count]==&apos;X&apos;) sum+=10; if(c[count]==&apos;V&apos;) sum+=5; if(c[count]==&apos;I&apos;) sum+=1; &#125; return sum; &#125; https://leetcode.com/discuss/2369/solution-for-this-question-but-dont-know-there-any-easier-way/2 6ms, 97.91%, May.4th, 2016 My solution, only scan string once 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public int romanToInt(String s) &#123; int res = 0; for(int i = s.length() - 1; i &gt;= 0; i--)&#123; char c = s.charAt(i); switch(c)&#123; case &apos;I&apos;: res += (res &gt;= 5 ? -1 : 1); break; case &apos;V&apos;: res += 5; break; case &apos;X&apos;: res += 10 * (res &gt;= 50 ? -1 : 1); break; case &apos;L&apos;: res += 50; break; case &apos;C&apos;: res += 100 * (res &gt;= 500 ? -1 : 1); break; case &apos;D&apos;: res += 500; break; case &apos;M&apos;: res += 1000; break; &#125; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/821/my-solution-for-this-question-but-i-don-t-know-is-there-any-easier-way/3 My solution, scan string once from tail to head. If s[i]â€™s corresponding integer is no less than the previous one, add it to the result; otherwise, subtract it from the result. 1234567891011121314151617181920int romanToInt(string s) &#123; unordered_map&lt;char, int&gt; charToInt = &#123; &#123; &apos;I&apos;, 1 &#125;, &#123; &apos;V&apos;, 5 &#125;, &#123; &apos;X&apos;, 10 &#125;, &#123; &apos;L&apos;, 50 &#125;, &#123; &apos;C&apos;, 100 &#125;, &#123; &apos;D&apos;, 500 &#125;, &#123; &apos;M&apos;, 1000 &#125; &#125;; int result = 0; int index = s.length() - 1; int preInt = 0; while (index &gt;= 0) &#123; char ch = s[index]; int curInt = charToInt[ch]; if (curInt &gt;= preInt) result += curInt; else result -= curInt; preInt = curInt; index--; &#125; return result;&#125; https://discuss.leetcode.com/topic/28471/7ms-solution-in-java-easy-to-understand 7ms solution in Java. easy to understand 123456789101112131415161718192021222324252627282930313233343536public int romanToInt(String s) &#123; int nums[]=new int[s.length()]; for(int i=0;i&lt;s.length();i++)&#123; switch (s.charAt(i))&#123; case &apos;M&apos;: nums[i]=1000; break; case &apos;D&apos;: nums[i]=500; break; case &apos;C&apos;: nums[i]=100; break; case &apos;L&apos;: nums[i]=50; break; case &apos;X&apos; : nums[i]=10; break; case &apos;V&apos;: nums[i]=5; break; case &apos;I&apos;: nums[i]=1; break; &#125; &#125; int sum=0; for(int i=0;i&lt;nums.length-1;i++)&#123; if(nums[i]&lt;nums[i+1]) sum-=nums[i]; else sum+=nums[i]; &#125; return sum+nums[nums.length-1];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>math</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[012. Integer to Roman]]></title>
    <url>%2Fp%2F7da1ea45%2F</url>
    <content type="text"><![CDATA[45.0% https://leetcode.com/problems/integer-to-roman/ Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. æ–¹æ³•ä¸€ï¼š 48ms, 15.75%, May.4th, 2016 12345678910class Solution &#123;public: string intToRoman(int num) &#123; vector&lt;string&gt;M&#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125;; vector&lt;string&gt;C&#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;; vector&lt;string&gt;X&#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;; vector&lt;string&gt;I&#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;; return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10]; &#125;&#125;; https://discuss.leetcode.com/topic/7061/sharing-my-really-simple-solution-with-explanation Sharing my really simple solution with explanation 12345678910111213141516string intToRoman(int num) &#123; string table[4][10] = &#123;&#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;, &#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;, &#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;, &#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125; &#125;; string result; int count = 0; while(num &gt; 0)&#123; int temp = num % 10; result = table[count][temp] + result; num /= 10; count++; &#125; return result;&#125; The basic idea is really simple: replace every digit in num by roman numerals. For example, we have a num: 2438. 2 â€“&gt; â€œMMâ€ 4 â€“&gt; â€œCDâ€ 3 â€“&gt; â€œXXXâ€ 8 â€“&gt; â€œVIIIâ€ Then the result is â€œMMCDXXXVIIIâ€. python https://discuss.leetcode.com/topic/32333/share-my-python-solution-96ms Share My Python Solution 96ms 124ms, 69.84%, May.4th, 2016 1234567891011class Solution(object): def intToRoman(self, num): &quot;&quot;&quot; :type num: int :rtype: str &quot;&quot;&quot; M = [&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;] C = [&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;] X = [&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;] I = [&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;] return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10] java https://leetcode.com/discuss/32626/simple-solution Simple Solution 10ms, 34.15%, 3999 / 3999, May.4th, 2016 123456789public class Solution &#123; public String intToRoman(int num) &#123; String M[] = &#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125;; String C[] = &#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;; String X[] = &#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;; String I[] = &#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;; return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10]; &#125;&#125; https://discuss.leetcode.com/topic/20510/my-java-solution-easy-to-understand My java solution easy to understand Reference: http://blog.csdn.net/beiyeqingteng/article/details/8547565 1234567891011121314151617public class Solution &#123;public String intToRoman(int num) &#123; int[] values = &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; String[] strs = &#123;&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;&#125;; StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;values.length;i++) &#123; while(num &gt;= values[i]) &#123; num -= values[i]; sb.append(strs[i]); &#125; &#125; return sb.toString();&#125;&#125; https://discuss.leetcode.com/topic/20510/my-java-solution-easy-to-understand/3 Your function is not really optimal because you will ALWAYS iterate until the end of your values array even if your number becomes zero! Which is not optimal at all. In addition to that you didnâ€™t even check if the input number has a valid roman representation. You had to check that (even if the exercice assumes that the number has it already), you can do that easily with one line. Here is an improvement of your function : 12345678910111213141516171819public static String intToRoman(int num)&#123; if (num &lt; 1 || num &gt; 3999) return &quot;&quot;; StringBuilder result = new StringBuilder(); String[] roman = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;; int[] values = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;; int i = 0; //iterate until the number becomes zero, NO NEED to go until the last element in roman array while (num &gt;0) &#123; while ( num &gt;= values[i]) &#123; num -= values[i]; result.append(roman[i]); &#125; i++; &#125; return result.toString();&#125; As you see, you add just a simple line and you win an optimisation since the code will stop if the current number becomes zero (instead of doing additionnal iterations in the roman array). https://discuss.leetcode.com/topic/26543/easy-to-understand-java-solution Easy to understand Java solution 1234567891011121314151617public enum Type&#123; M(1000),CM(900),D(500),CD(400),C(100),XC(90),L(50),XL(40),X(10),IX(9),V(5),IV(4),I(1); private final int value; Type(int value) &#123; this.value = value; &#125;&#125;;public String intToRoman(int num) &#123; StringBuilder output = new StringBuilder(); for (Type t:Type.values()) &#123; while (num&gt;=t.value) &#123; output.append(t); num -= t.value; &#125; &#125; return output.toString();&#125; https://discuss.leetcode.com/topic/2858/share-my-iterative-solution Share my iterative Solution 1234567891011121314151617public String intToRoman(int num) &#123; int[] weights=&#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; String[] tokens=&#123;&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;&#125;; StringBuilder rs=new StringBuilder(&quot;&quot;); int start=0; while(num&gt;0)&#123; for(int i=start;i&lt;13;i++)&#123; if(num&gt;=weights[i])&#123; num-=weights[i]; rs.append(tokens[i]); break; &#125; start=i+1; // skip those impossible check, make it faster &#125; &#125; return rs.toString();&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[011. Container With Most Water]]></title>
    <url>%2Fp%2F971339dc%2F</url>
    <content type="text"><![CDATA[36.2% https://leetcode.com/problems/container-with-most-water/ Given n non-negative integers a1, a2, â€¦, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container. https://discuss.leetcode.com/topic/29962/for-someone-who-is-not-so-clear-on-this-question For someone who is not so clear on this question 12345678910test y ^ | | a2 | | a3 an | a1 | | a5 | | | | | a4 | | | | | | | | .. | ---------------------------&gt; 0 1 2 3 4 5 .. n x For someone who is not clear on this question. Itâ€™s not like â€œhttps://leetcode.com/problems/trapping-rain-water/ â€œ Which is to get the total water for all the bars problem, It actually is to find the any 2 bars ai, aj, which hold most water together with x-axis. This post give a very good detail explanation as well. https://leetcode.com/discuss/37631/simple-and-clear-proof-explanation æ–¹æ³•ä¸€ï¼š åŒæŒ‡é’ˆ https://leetcode.com/discuss/41527/simple-and-fast-c-c-with-explanation 24ms, 61.49%, June.20th, 2016 Start by evaluating the widest container, using the first and the last line. All other possible containers are less wide, so to hold more water, they need to be higher. Thus, after evaluating that widest container, skip lines at both ends that donâ€™t support a higher height. Then evaluate that new container we arrived at. Repeat until there are no more possible containers left. C++ 1234567891011int maxArea(vector&lt;int&gt;&amp; height) &#123; int water = 0; int i = 0, j = height.size() - 1; while (i &lt; j) &#123; int h = min(height[i], height[j]); water = max(water, (j - i) * h); while (height[i] &lt;= h &amp;&amp; i &lt; j) i++; while (height[j] &lt;= h &amp;&amp; i &lt; j) j--; &#125; return water;&#125; æˆ‘çš„ä»£ç å®žçŽ°ä¸€ï¼š 12345678910111213141516class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int left = 0, right = height.size()-1; int maxArea=0, minHeight=0; // è¦è®¾ç½®åˆå§‹å€¼ï¼ŒåŽç»­æœ‰max while(left&lt;right)&#123; minHeight = min(height[right], height[left]); // ä½¿ç”¨maxï¼Œ è€Œä¸æ˜¯ç›´æŽ¥ç­‰äºŽ(right-left)*minHeight,å› ä¸ºå˜åŒ–ä¹‹åŽå¯èƒ½å˜å° // å› ä¸ºä¸æ»¡è¶³left&lt;rightçš„æƒ…å†µ maxArea = max(maxArea, (right-left)*minHeight); while(left&lt;right &amp;&amp; height[left]&lt;=minHeight) left++; while(left&lt;right &amp;&amp; height[right]&lt;=minHeight) right--; &#125; return maxArea; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°äºŒï¼š 12345678910111213141516class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if(n&lt;2) return 0; int left = 0, right = n-1; int res = 0, h = 0; while(left&lt;right)&#123; h = min(height[left], height[right]); res = max(res, h*(right-left)); while(left&lt;right &amp;&amp; height[left]&lt;=h) left++; while(left&lt;right &amp;&amp; height[right]&lt;=h) right--; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/3462/yet-another-way-to-see-what-happens-in-the-o-n-algorithm Yet another way to see what happens in the O(n) algorithm The O(n) solution with proof by contradiction doesnâ€™t look intuitive enough to me. Before moving on, read the algorithm first if you donâ€™t know it yet. Hereâ€™s another way to see what happens in a matrix representation: Draw a matrix where the row is the first line, and the column is the second line. For example, say n=6. In the figures below, x means we donâ€™t need to compute the volume for that case: (1) On the diagonal, the two lines are overlapped; (2) The lower left triangle area of the matrix is symmetric to the upper right area. 123456789101112We start by computing the volume at (1,6), denoted by o. Now if the left line is shorter than the right line, then all the elements left to (1,6) on the first row have smaller volume, so we don&apos;t need to compute those cases (crossed by ---). 1 2 3 4 5 61 x ------- o2 x x3 x x x 4 x x x x5 x x x x x6 x x x x x x 1234567891011Next we move the left line and compute (2,6). Now if the right line is shorter, all cases below (2,6) are eliminated. 1 2 3 4 5 61 x ------- o2 x x o3 x x x |4 x x x x |5 x x x x x |6 x x x x x x 1234567891011And no matter how this o path goes, we end up only need to find the max value on this path, which contains n-1 cases. 1 2 3 4 5 61 x ------- o2 x x - o o o3 x x x o | |4 x x x x | |5 x x x x x |6 x x x x x x Hope this helps. I feel more comfortable seeing things this way. https://discuss.leetcode.com/topic/4552/very-simple-o-n-solution Very simple O(n) solution The idea is : to compute area, we need to take min(height[i],height[j]) as our height. Thus if height[i]&lt;height[j], then the expression min(height[i],height[j]) will always lead to at maximum height[i] for all other j(i being fixed), hence no point checking them. Similarly when height[i]&gt;height[j] then all the other iâ€™s can be ignored for that particular j. 123456789101112131415161718class Solution &#123;public: int maxArea(vector&lt;int&gt; &amp;height) &#123; int j=height.size()-1,i=0,mx=0; while(i&lt;j) &#123; mx=max(mx,((j-i)*(min(height[i],height[j])))); if(height[i]&lt;height[j]) i++; else if(height[i]&gt;=height[j]) j--; &#125; return mx; &#125;&#125;; https://discuss.leetcode.com/topic/42122/c-o-n-solution-with-thought-process-applying-simple-bucket-theory C++ O(n) solution with thought process applying simple bucket theory The brute force solution can definitely lead us to the right answer just by doing too many redundant comparisons. When two pointer approach comes to mind, it is intuitive to set both pointers i, j at each end of this array, and move them strategically to the middle of array, update the answer during this process return the answer when we reach the end of array. Suppose now we have the scenarios below: 1237, 5, 6, 9i j When i = 1, j = 4, 1ans = min(7, 9) * (4 - 1) = 21 Whatâ€™s next? Should we move i or j? We notice that to calculate the area, the height is really identified by the smaller number / shorter end between the two ends, since itâ€™s required that you may not slant the water, so it sounds like Bucket theory: how much water a bucket can contain depends on the shortest plank. So, as to find the next potential maximum area, we disregard the shorter end by moving it to the next position. So in the above case, the next status is to move i to the left, 1237, 5, 6, 9 i j update: 12area (i, j) = area(2, 4) = min(5, 9) * (4 - 2) = 10ans = max(21, 10) = 21 You may notice that, if we move j instead, you actually get a larger area for length of 2: 1area (i, j) = area(1, 3) = min(7, 6) * (3 - 1) = 18 Does that mean this approach will not work? If you look at this way, we move pointer as to get the next potential max, so it doesnâ€™t need to be the maximum for all combinations with length l. Even though 18 is greater than 10, itâ€™s smaller than 21 right? So donâ€™t worry, we can move on to find the next potential maximum result. Now we need to prove, why disregard the shorter end can safely lead us to the right answer by doing a little maths. 12Given an array: a1, a2, a3, a4, ai, ......, aj, ......, an i j Assume the maximum area so far is ans, we prove that 12&quot;By moving shorter end pointer further doesn&apos;t eliminate the final answer (with two ends at maxi, maxj respectively) in our process&quot; Suppose we have two ends at (i, j) respectively at this moment: (i) If the final answer equals what we have already achieved, itâ€™s done! In this scenario, we must have 1maxi &lt;= i, maxj &gt;= j (ii) Otherwise, we know as we move any pointer further, the length of the next rectangle decreases, so the height needs to increase as to result in a larger area. So we have 1min(height[maxi], height[maxj]) &gt; min(height[i], height[j]) So the smaller one in height[i], height[j] wonâ€™t become any end in the maximum rectangle, so itâ€™s safe to move forward without it. Till now, it has been proved that this approach can work in O(n) time since we advance one end towards the middle in each iteration, and update ans takes constant time in each iteration. 12345678910111213class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int ans = 0; int i = 0, j = height.size() - 1; while(i &lt; j)&#123; ans = max(ans, (j - i) * min(height[i], height[j])); height[i] &gt; height[j] ? j-- : i++; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/12843/my-short-and-easy-c-code-in-o-n My short and easy c++ code in O(n) 12345678910111213class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int i=0,j=height.size()-1,ans = 0; while(j&gt;i) &#123; ans = max(min(height[i],height[j])*(j-i),ans); if(height[i]&gt;height[j]) j--; else i++; &#125; return ans; &#125;&#125;; python https://discuss.leetcode.com/topic/14940/simple-and-clear-proof-explanation Simple and clear proof/explanation Iâ€™ve seen some â€œproofsâ€ for the common O(n) solution, but I found them very confusing and lacking. Some even didnâ€™t explain anything but just used lots of variables and equations and were like â€œTada! See?â€. I think mine makes more sense: Idea / Proof: The widest container (using first and last line) is a good candidate, because of its width. Its water level is the height of the smaller one of first and last line.All other containers are less wide and thus would need a higher water level in order to hold more water.The smaller one of first and last line doesnâ€™t support a higher water level and can thus be safely removed from further consideration. Further explanation: Variables i and j define the container under consideration. We initialize them to first and last line, meaning the widest container. Variable water will keep track of the highest amount of water we managed so far. We compute j - i, the width of the current container, and min(height[i], height[j]), the water level that this container can support. Multiply them to get how much water this container can hold, and update water accordingly. Next remove the smaller one of the two lines from consideration, as justified above in â€œIdea / Proofâ€. Continue until there is nothing left to consider, then return the result. Implementation: (Python) 1234567891011class Solution: def maxArea(self, height): i, j = 0, len(height) - 1 water = 0 while i &lt; j: water = max(water, (j - i) * min(height[i], height[j])) if height[i] &lt; height[j]: i += 1 else: j -= 1 return water java https://discuss.leetcode.com/topic/25004/easy-concise-java-o-n-solution-with-proof-and-explanation Easy Concise Java O(N) Solution with Proof and Explanation AKA, the general idea to find some max is to go through all cases where max value can possibly occur and keep updating the max value. The efficiency of the scan depends on the size of cases you plan to scan.To increase efficiency, all we need to do is to find a smart way of scan to cut off the useless cases and meanwhile 100% guarantee the max value can be reached through the rest of cases. In this problem, the smart scan way is to set two pointers initialized at both ends of the array. Every time move the smaller value pointer to inner array. Then after the two pointers meet, all possible max cases have been scanned and the max situation is 100% reached somewhere in the scan. Following is a brief prove of this. Given a1,a2,a3â€¦..an as input array. Lets assume a10 and a20 are the max area situation. We need to prove that a10 can be reached by left pointer and during the time left pointer stays at a10, a20 can be reached by right pointer. That is to say, the core problem is to prove: when left pointer is at a10 and right pointer is at a21, the next move must be right pointer to a20. Since we are always moving the pointer with the smaller value, i.e. if a10 &gt; a21, we should move pointer at a21 to a20, as we hope. Why a10 &gt;a21? Because if a21&gt;a10, then area of a10 and a20 must be less than area of a10 and a21. Because the area of a10 and a21 is at least height[a10] (21-10) while the area of a10 and a20 is at most height[a10] (20-10). So there is a contradiction of assumption a10 and a20 has the max area. So, a10 must be greater than a21, then next move a21 has to be move to a20. The max cases must be reached. 123456789101112131415public int maxArea(int[] height) &#123; int left = 0, right = height.length - 1; int maxArea = 0; while (left &lt; right) &#123; maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left)); if (height[left] &lt; height[right]) left++; else right--; &#125; return maxArea;&#125; https://discuss.leetcode.com/topic/33498/java-3ms-solution-with-step-by-step-explanations-beats-85 Java 3ms solution with step-by-step explanations (beats 85%) It took me quite some time to finally optimize my solution from 21ms to 3ms :( If you have difficulty understanding the following code, check this link for a detailed explanation. 12345678910111213141516public int maxArea(int[] height) &#123; int L = height.length, lo = 0, hi = L-1; int max = 0; while(lo&lt;hi) &#123; int loMax = height[lo], hiMax = height[hi]; int candidate = (hi-lo) * (loMax&lt;hiMax ? loMax : hiMax); max = candidate &gt; max ? candidate : max; if(height[lo]&lt;=height[hi]) while(lo&lt;hi &amp;&amp; height[lo]&lt;=loMax) ++lo; else while(hi&gt;lo &amp;&amp; height[hi]&lt;=hiMax) --hi; &#125; return max;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[010. Regular Expression Matching]]></title>
    <url>%2Fp%2F34b0b346%2F</url>
    <content type="text"><![CDATA[23.9% https://leetcode.com/problems/regular-expression-matching/ 123456789101112131415161718Implement regular expression matching with support for &apos;.&apos; and &apos;*&apos;.&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) â†’ falseisMatch(&quot;aa&quot;,&quot;aa&quot;) â†’ trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) â†’ falseisMatch(&quot;aa&quot;, &quot;a*&quot;) â†’ trueisMatch(&quot;aa&quot;, &quot;.*&quot;) â†’ trueisMatch(&quot;ab&quot;, &quot;.*&quot;) â†’ trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) â†’ true æ–¹æ³•ä¸€ï¼š ä¼˜å…ˆè€ƒè™‘é€’å½’ é€’å½’æ–¹æ³• å­¦ä¹ stringçš„substrçš„ç”¨æ³• My concise recursive and DP solutions with full explanation in C++ Please refer to my blog post if you have any comment. Wildcard matching problem can be solved similarly. 12345678910111213class Solution &#123;public: bool isMatch(string s, string p) &#123; if (p.empty()) return s.empty(); if (&apos;*&apos; == p[1]) // x* matches empty string or at least one character: x* -&gt; xx* // *s is to ensure s is non-empty return (isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p)); else return !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; my code: 12345678910class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.empty()) return s.empty(); if(p.size()&gt;1 &amp;&amp; p[1]==&apos;*&apos;)&#123; return isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0]==p[0] || p[0]==&apos;.&apos;) &amp;&amp; isMatch(s.substr(1), p); &#125;else return !s.empty() &amp;&amp; (s[0]==p[0] || p[0]==&apos;.&apos;) &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°äºŒ: 12345678910class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.empty()) return s.empty(); if(p.size()&gt;1 &amp;&amp; p[1]=='*') return isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0]==p[0] || p[0]=='.') &amp;&amp; isMatch(s.substr(1), p); // è¦æ£€æŸ¥sæ˜¯å¦ä¸ºç©ºï¼Œä¸èƒ½å¿˜è®° return !s.empty() &amp;&amp; (s[0]==p[0] || p[0]=='.') &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; æ–¹æ³•äºŒï¼š dp mn è®¾ç½®(m+1) (n+1)çš„é•¿åº¦ï¼Œå¤šçš„ä¸€è¡Œè¡¨ç¤ºç©ºçš„æ—¶å€™çš„ç»“æžœã€‚ ç»å¸¸æœ‰ä¸Šè¿°åšæ³•ã€‚ 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: bool isMatch(string s, string p) &#123; /** * f[i][j]: if s[0..i-1] matches p[0..j-1] * if p[j - 1] != &apos;*&apos; * f[i][j] = f[i - 1][j - 1] &amp;&amp; s[i - 1] == p[j - 1] * if p[j - 1] == &apos;*&apos;, denote p[j - 2] with x * f[i][j] is true iff any of the following is true * 1) &quot;x*&quot; repeats 0 time and matches empty: f[i][j - 2] * 2) &quot;x*&quot; repeats &gt;= 1 times and matches &quot;x*x&quot;: s[i - 1] == x &amp;&amp; f[i - 1][j] * &apos;.&apos; matches any single character */ int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; f(m + 1, vector&lt;bool&gt;(n + 1, false)); f[0][0] = true; for (int i = 1; i &lt;= m; i++) f[i][0] = false; // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is &apos;*&apos; and p[0..j - 3] matches empty for (int j = 1; j &lt;= n; j++) f[0][j] = j &gt; 1 &amp;&amp; &apos;*&apos; == p[j - 1] &amp;&amp; f[0][j - 2]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (p[j - 1] != &apos;*&apos;) f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || &apos;.&apos; == p[j - 1]); else // p[0] cannot be &apos;*&apos; so no need to check &quot;j &gt; 1&quot; here f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || &apos;.&apos; == p[j - 2]) &amp;&amp; f[i - 1][j]; return f[m][n]; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ° : ä¸Žæ–¹æ³•ä¸€ç±»ä¼¼ éƒ½æ˜¯æ¯æ¬¡è¦ä¹ˆå¢žé•¿sï¼Œè¦ä¹ˆå¢žé•¿p ä»¥å½“å‰ä½ç½®æ˜¯å¦ä¸º*ä½œä¸ºåˆ¤æ–­æ¡ä»¶ 1234567891011121314151617181920class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.empty()) return s.empty(); int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=2; i&lt;=n; i++) dp[0][i] = p[i-1]=='*' &amp;&amp; dp[0][i-2]; for(int i=1; i&lt;=m; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; if(p[j-1]=='*') dp[i][j] = dp[i][j-2] || dp[i-1][j] &amp;&amp; (s[i-1]==p[j-2] || p[j-2]=='.'); else dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]=='.'); &#125; &#125; return dp[m][n]; &#125;&#125;; ç›¸ä¼¼é¢˜ç›®ï¼šæ­£åˆ™è¡¨è¾¾å¼åŒ¹é…è¯·å®žçŽ°ä¸€ä¸ªå‡½æ•°ç”¨æ¥åŒ¹é…åŒ…æ‹¬â€™.â€™å’Œâ€™â€˜çš„æ­£åˆ™è¡¨è¾¾å¼ã€‚æ¨¡å¼ä¸­çš„å­—ç¬¦â€™.â€™è¡¨ç¤ºä»»æ„ä¸€ä¸ªå­—ç¬¦ï¼Œè€Œâ€™â€˜è¡¨ç¤ºå®ƒå‰é¢çš„å­—ç¬¦å¯ä»¥å‡ºçŽ°ä»»æ„æ¬¡ï¼ˆåŒ…å«0æ¬¡ï¼‰ã€‚ åœ¨æœ¬é¢˜ä¸­ï¼ŒåŒ¹é…æ˜¯æŒ‡å­—ç¬¦ä¸²çš„æ‰€æœ‰å­—ç¬¦åŒ¹é…æ•´ä¸ªæ¨¡å¼ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸²â€aaaâ€ä¸Žæ¨¡å¼â€a.aâ€å’Œâ€abacaâ€åŒ¹é…ï¼Œä½†æ˜¯ä¸Žâ€aa.aâ€å’Œâ€ab*aâ€å‡ä¸åŒ¹é… æ–¹æ³•ä¸€ï¼š ä½¿ç”¨é€’å½’ 123456789101112131415161718192021222324class Solution &#123;public: bool match(char* str, char* pattern) &#123; if(str==NULL || pattern==NULL) return false; return helper(str, pattern); &#125; bool helper(char* str, char* pattern)&#123; if(*str==&apos;\0&apos; &amp;&amp; *pattern==&apos;\0&apos;) return true; if(*str!=&apos;\0&apos; &amp;&amp; *pattern==&apos;\0&apos;) return false; if(*(pattern+1)==&apos;*&apos;)&#123; if(*pattern==*str || (*pattern==&apos;.&apos; &amp;&amp; *str!=&apos;\0&apos;))&#123; return helper(str+1, pattern+2) || helper(str+1, pattern) || helper(str, pattern+2); &#125;else&#123; return helper(str, pattern+2); &#125; &#125; if(*str==*pattern || (*pattern==&apos;.&apos; &amp;&amp; *str!=&apos;\0&apos;)) return helper(str+1, pattern+1); return false; &#125;&#125;; https://discuss.leetcode.com/topic/6183/my-concise-recursive-and-dp-solutions-with-full-explanation-in-c My concise recursive and DP solutions with full explanation in C++ Please refer to my blog post if you have any comment. Wildcard matching problem can be solved similarly. é€’å½’æ–¹æ³• 12345678910111213class Solution &#123;public: bool isMatch(string s, string p) &#123; if (p.empty()) return s.empty(); if (&apos;*&apos; == p[1]) // x* matches empty string or at least one character: x* -&gt; xx* // *s is to ensure s is non-empty return (isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p)); else return !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; dpï¼š 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: bool isMatch(string s, string p) &#123; /** * f[i][j]: if s[0..i-1] matches p[0..j-1] * if p[j - 1] != &apos;*&apos; * f[i][j] = f[i - 1][j - 1] &amp;&amp; s[i - 1] == p[j - 1] * if p[j - 1] == &apos;*&apos;, denote p[j - 2] with x * f[i][j] is true iff any of the following is true * 1) &quot;x*&quot; repeats 0 time and matches empty: f[i][j - 2] * 2) &quot;x*&quot; repeats &gt;= 1 times and matches &quot;x*x&quot;: s[i - 1] == x &amp;&amp; f[i - 1][j] * &apos;.&apos; matches any single character */ int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; f(m + 1, vector&lt;bool&gt;(n + 1, false)); f[0][0] = true; for (int i = 1; i &lt;= m; i++) f[i][0] = false; // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is &apos;*&apos; and p[0..j - 3] matches empty for (int j = 1; j &lt;= n; j++) f[0][j] = j &gt; 1 &amp;&amp; &apos;*&apos; == p[j - 1] &amp;&amp; f[0][j - 2]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (p[j - 1] != &apos;*&apos;) f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || &apos;.&apos; == p[j - 1]); else // p[0] cannot be &apos;*&apos; so no need to check &quot;j &gt; 1&quot; here f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || &apos;.&apos; == p[j - 2]) &amp;&amp; f[i - 1][j]; return f[m][n]; &#125;&#125;; 16ms, 60.02%, September 21, 2016 https://discuss.leetcode.com/topic/17852/9-lines-16ms-c-dp-solutions-with-explanations 9-lines 16ms C++ DP Solutions with Explanations This problem has a typical solution using Dynamic Programming. We define the state P[i][j] to be true if s[0..i) matches p[0..j) and false otherwise. Then the state equations are: P[i][j] = P[i - 1][j - 1], if p[j - 1] != â€˜*â€™ &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == â€˜.â€™); P[i][j] = P[i][j - 2], if p[j - 1] == â€˜*â€™ and the pattern repeats for 0 times; P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == â€˜.â€™), if p[j - 1] == â€˜*â€™ and the pattern repeats for at least 1 times. Putting these together, we will have the following code. 1234567891011121314class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(), n = p.length(); vector&lt;vector&lt;bool&gt; &gt; dp(m + 1, vector&lt;bool&gt; (n + 1, false)); dp[0][0] = true; for (int i = 0; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (p[j - 1] == &apos;*&apos;) dp[i][j] = dp[i][j - 2] || (i &gt; 0 &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == &apos;.&apos;) &amp;&amp; dp[i - 1][j]); else dp[i][j] = i &gt; 0 &amp;&amp; dp[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;.&apos;); return dp[m][n]; &#125;&#125;; https://discuss.leetcode.com/topic/2818/the-shortest-ac-code The shortest AC code. 1.â€™.â€™ is easy to handle. if p has a â€˜.â€™, it can pass any single character in s except â€˜\0â€™. 2.â€™â€™ is a totally different problem. if p has a â€˜â€™ character, it can pass any length of first-match characters in s including â€˜\0â€™. 12345678910111213141516171819class Solution &#123; public: bool matchFirst(const char *s, const char *p)&#123; return (*p == *s || (*p == &apos;.&apos; &amp;&amp; *s != &apos;\0&apos;)); &#125;bool isMatch(const char *s, const char *p) &#123; if (*p == &apos;\0&apos;) return *s == &apos;\0&apos;; //empty if (*(p + 1) != &apos;*&apos;) &#123;//without * if(!matchFirst(s,p)) return false; return isMatch(s + 1, p + 1); &#125; else &#123; //next: with a * if(isMatch(s, p + 2)) return true; //try the length of 0 while ( matchFirst(s,p) ) //try all possible lengths if (isMatch(++s, p + 2))return true; &#125;&#125;&#125;; https://discuss.leetcode.com/topic/21370/my-4ms-c-dp-solution-another-recursive-version-also-given-72ms My 4ms C++ DP solution (another recursive version also given 72ms) Just to build a DP table checked, where checked[i][j] indicates whether s[0..i-1] matches with p[0..j-1]. The recursive relationship is as below: To match with the empty string s[0..0] (i.e. to make checked[0][j]), P[0..j-1] has to meet: p[j-1]==â€™*â€™ (to cancel p[j-2]) and checked[0][j-2] == true; To match with the string s[0..i-1] (i.e. to make checked[i][j]), P[0..j-1] has to meet: if p[j-1] ==â€™*â€™, then j must be larger than 1 (j&gt;1) and checked[i][j-2] (i.e. p[j-2] cancelled by â€˜*â€™) checked[i-1][j] &amp;&amp; (s[i-1] ==p[j-2] || p[j-2] ==â€™.â€™) (s[i-1] matches with p[j-2] or â€˜.â€™, ) if p[j-1] !=â€™*â€™, checked[i-1][j-1] &amp;&amp; (s[i-1] ==p[j-1] || p[j-1] ==â€™.â€™)(i.e. s[i-1] matches with p[j-1] or â€˜.â€™) 123456789101112131415161718192021class Solution &#123; public: bool isMatch(string s, string p) &#123; int sSize = s.size(), pSize = p.size(), i, j; bool checked[sSize+1][pSize+1]; // fill_n(&amp;matched[0][0], (sSize+1)*(pSize+1), false); for(j=2, checked[0][0]=true, checked[0][1]= false; j&lt;=pSize; ++j) // match s[0..0] checked[0][j] = p[j-1] == &apos;*&apos;? checked[0][j-2] : false; for(i=1; i&lt;=sSize; ++i) for(j=1, checked[i][0]=false; j&lt;=pSize; ++j) &#123; if(p[j-1]==&apos;*&apos;) // case (1) checked[i][j] = (j&gt;1) &amp;&amp; ( checked[i][j-2] || ( ( checked[i-1][j]) &amp;&amp; (s[i-1]== p[j-2] || p[j-2] == &apos;.&apos;)) ); else // case (2) checked[i][j] = checked[i-1][j-1] &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == &apos;.&apos;); &#125; return checked[sSize][pSize]; &#125; &#125;; A recursive version, divide cases into two groups (if the next p char is â€˜*â€™ or not) 123456789101112131415161718192021222324class Solution &#123;private: bool helper(const string &amp;s, const string &amp;p, int sS, int pS) &#123; int sSize = s.size(), pSize = p.size(), i, j; if(pS==pSize) return sS ==sSize; // if p goes to its end, then only if s also goes to its end to return true; if(p[pS+1]!=&apos;*&apos;) &#123; if( sS&lt;sSize &amp;&amp; (p[pS]==s[sS] || p[pS] == &apos;.&apos;)) return helper(s, p, sS+1, pS+1); &#125; else &#123; if(helper(s, p, sS,pS+2)) return true; while(sS&lt;sSize &amp;&amp; (p[pS]==s[sS] || p[pS] == &apos;.&apos;)) if(helper(s,p, ++sS, pS+2)) return true; &#125; return false; &#125;public: bool isMatch(string s, string p) &#123; helper(s, p, 0, 0); &#125;&#125;; python https://discuss.leetcode.com/topic/22948/my-dp-approach-in-python-with-comments-and-unittest My DP approach in Python with comments and unittest I shared my DP approach with comments and provided some unit tests for it. Some statements in the approach directly affect some corner cases, for example, comment out line 22-23, then the unittest test_symbol_0 will fail. Hope this script helps us better understand the problem. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import unittestclass Solution(object): def isMatch(self, s, p): # The DP table and the string s and p use the same indexes i and j, but # table[i][j] means the match status between p[:i] and s[:j], i.e. # table[0][0] means the match status of two empty strings, and # table[1][1] means the match status of p[0] and s[0]. Therefore, when # refering to the i-th and the j-th characters of p and s for updating # table[i][j], we use p[i - 1] and s[j - 1]. # Initialize the table with False. The first row is satisfied. table = [[False] * (len(s) + 1) for _ in range(len(p) + 1)] # Update the corner case of matching two empty strings. table[0][0] = True # Update the corner case of when s is an empty string but p is not. # Since each &apos;*&apos; can eliminate the charter before it, the table is # vertically updated by the one before previous. [test_symbol_0] for i in range(2, len(p) + 1): table[i][0] = table[i - 2][0] and p[i - 1] == &apos;*&apos; for i in range(1, len(p) + 1): for j in range(1, len(s) + 1): if p[i - 1] != &quot;*&quot;: # Update the table by referring the diagonal element. table[i][j] = table[i - 1][j - 1] and \ (p[i - 1] == s[j - 1] or p[i - 1] == &apos;.&apos;) else: # Eliminations (referring to the vertical element) # Either refer to the one before previous or the previous. # I.e. * eliminate the previous or count the previous. # [test_symbol_1] table[i][j] = table[i - 2][j] or table[i - 1][j] # Propagations (referring to the horizontal element) # If p&apos;s previous one is equal to the current s, with # helps of *, the status can be propagated from the left. # [test_symbol_2] if p[i - 2] == s[j - 1] or p[i - 2] == &apos;.&apos;: table[i][j] |= table[i][j - 1] return table[-1][-1]class TestSolution(unittest.TestCase): def test_none_0(self): s = &quot;&quot; p = &quot;&quot; self.assertTrue(Solution().isMatch(s, p)) def test_none_1(self): s = &quot;&quot; p = &quot;a&quot; self.assertFalse(Solution().isMatch(s, p)) def test_no_symbol_equal(self): s = &quot;abcd&quot; p = &quot;abcd&quot; self.assertTrue(Solution().isMatch(s, p)) def test_no_symbol_not_equal_0(self): s = &quot;abcd&quot; p = &quot;efgh&quot; self.assertFalse(Solution().isMatch(s, p)) def test_no_symbol_not_equal_1(self): s = &quot;ab&quot; p = &quot;abb&quot; self.assertFalse(Solution().isMatch(s, p)) def test_symbol_0(self): s = &quot;&quot; p = &quot;a*&quot; self.assertTrue(Solution().isMatch(s, p)) def test_symbol_1(self): s = &quot;a&quot; p = &quot;ab*&quot; self.assertTrue(Solution().isMatch(s, p)) def test_symbol_2(self): # E.g. # s a b b # p 1 0 0 0 # a 0 1 0 0 # b 0 0 1 0 # * 0 1 1 1 s = &quot;abb&quot; p = &quot;ab*&quot; self.assertTrue(Solution().isMatch(s, p))if __name__ == &quot;__main__&quot;: unittest.main() https://discuss.leetcode.com/topic/6739/fast-python-solution-with-backtracking-and-caching-dp-solution Fast Python solution with backtracking and caching + DP solution Takes about 174ms: 123456789101112131415161718cache = &#123;&#125;def isMatch(self, s, p): if (s, p) in self.cache: return self.cache[(s, p)] if not p: return not s if p[-1] == &apos;*&apos;: if self.isMatch(s, p[:-2]): self.cache[(s, p)] = True return True if s and (s[-1] == p[-2] or p[-2] == &apos;.&apos;) and self.isMatch(s[:-1], p): self.cache[(s, p)] = True return True if s and (p[-1] == s[-1] or p[-1] == &apos;.&apos;) and self.isMatch(s[:-1], p[:-1]): self.cache[(s, p)] = True return True self.cache[(s, p)] = False return False DP version: 1234567891011121314def isMatch(self, s, p): dp = [[False] * (len(s) + 1) for _ in range(len(p) + 1)] dp[0][0] = True for i in range(1, len(p)): dp[i + 1][0] = dp[i - 1][0] and p[i] == &apos;*&apos; for i in range(len(p)): for j in range(len(s)): if p[i] == &apos;*&apos;: dp[i + 1][j + 1] = dp[i - 1][j + 1] or dp[i][j + 1] if p[i - 1] == s[j] or p[i - 1] == &apos;.&apos;: dp[i + 1][j + 1] |= dp[i + 1][j] else: dp[i + 1][j + 1] = dp[i][j] and (p[i] == s[j] or p[i] == &apos;.&apos;) return dp[-1][-1] https://discuss.leetcode.com/topic/40371/easy-dp-java-solution-with-detailed-explanation Easy DP Java Solution with detailed Explanation This Solution use 2D DP. beat 90% solutions, very simple. Here are some conditions to figure out, then the logic can be very straightforward. 1234567891, If p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1];2, If p.charAt(j) == &apos;.&apos; : dp[i][j] = dp[i-1][j-1];3, If p.charAt(j) == &apos;*&apos;: here are two sub conditions: 1 if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty 2 if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == &apos;.&apos;: dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a or dp[i][j] = dp[i][j-1] // in this case, a* counts as single a or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty Here is the solution 12345678910111213141516171819202122232425262728293031public boolean isMatch(String s, String p) &#123; if (s == null || p == null) &#123; return false; &#125; boolean[][] dp = new boolean[s.length()+1][p.length()+1]; dp[0][0] = true; for (int i = 0; i &lt; p.length(); i++) &#123; if (p.charAt(i) == &apos;*&apos; &amp;&amp; dp[0][i-1]) &#123; dp[0][i+1] = true; &#125; &#125; for (int i = 0 ; i &lt; s.length(); i++) &#123; for (int j = 0; j &lt; p.length(); j++) &#123; if (p.charAt(j) == &apos;.&apos;) &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == s.charAt(i)) &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == &apos;*&apos;) &#123; if (p.charAt(j-1) != s.charAt(i) &amp;&amp; p.charAt(j-1) != &apos;.&apos;) &#123; dp[i+1][j+1] = dp[i+1][j-1]; &#125; else &#123; dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]); &#125; &#125; &#125; &#125; return dp[s.length()][p.length()];&#125; https://discuss.leetcode.com/topic/12289/clean-java-solution Clean Java Solution 1234567891011121314151617181920212223public boolean isMatch(String s, String p) &#123; if (p.isEmpty()) &#123; return s.isEmpty(); &#125; if (p.length() == 1 || p.charAt(1) != &apos;*&apos;) &#123; if (s.isEmpty() || (p.charAt(0) != &apos;.&apos; &amp;&amp; p.charAt(0) != s.charAt(0))) &#123; return false; &#125; else &#123; return isMatch(s.substring(1), p.substring(1)); &#125; &#125; //P.length() &gt;=2 while (!s.isEmpty() &amp;&amp; (s.charAt(0) == p.charAt(0) || p.charAt(0) == &apos;.&apos;)) &#123; if (isMatch(s, p.substring(2))) &#123; return true; &#125; s = s.substring(1); &#125; return isMatch(s, p.substring(2));&#125; https://discuss.leetcode.com/topic/2601/my-ac-dp-solution-for-this-problem-asking-for-improvements My AC DP solution for this problem, asking for improvements. 123456789101112131415161718192021222324252627282930public boolean isMatch(String s, String p) &#123; int m = s.length(); int n = p.length(); if (s == null || p == null) &#123; return false; &#125; boolean[][] OPT = new boolean[m+1][n+1]; OPT[0][0] = true; for (int i = 1; i &lt;= m; i++) &#123; OPT[i][0] = false; &#125; for (int j = 1; j &lt;= n; j++) &#123; OPT[0][j] = (p.charAt(j-1) == &apos;*&apos;) &amp;&amp; (j-2 &gt;= 0) &amp;&amp; OPT[0][j-2]; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; OPT[i][j] = ((OPT[i-1][j-1]) &amp;&amp; equals(s, p, i-1, j-1)) || ((OPT[i-1][j] || OPT[i][j-1]) &amp;&amp; (p.charAt(j-1) == &apos;*&apos;) &amp;&amp; equals(s, p, i-1, j-2)) || ((p.charAt(j-1) == &apos;*&apos;) &amp;&amp; (j-2 &gt;= 0) &amp;&amp; OPT[i][j-2]); &#125; &#125; return OPT[m][n];&#125; private boolean equals(String s, String p, int si, int pi) { return (s.charAt(si) == p.charAt(pi) || p.charAt(pi) == â€˜.â€™);}Basically, the OPT[i][j] means preceding substring of length i of s and length j of p. For any two substrings, the value of OPT[i][j] can be from one of following four cases: case 1: OPT[i-1][j-1] is true, and ith character of s is equal to j th character of p. Or j th character of p is â€˜.â€™ case 2: OPT[i-1][j] is true, then my pattern now is â€˜*â€™ and preceding character is equal to incoming character of s case 3: OPT[i][j-1] is true, then my pattern now is â€˜*â€™ which can match an empty string case 4: OPT[i][j-2] is true, and the pattern like (a*) matches an empty stringbase case is the OPT[0][0], OPT[i][0], OPT[0][j]. https://discuss.leetcode.com/topic/2601/my-ac-dp-solution-for-this-problem-asking-for-improvements/2 I found I was using the exact algorithm as you did. So I post one for your references.It has no additional brace. It is very difficult to write a pretty code in string operations by Java due to .charAt(). By the way Your value assignment in the nested loop is indeed a pain to read(At least for me ). I do suggest you to give more lines on that part. 1234567891011121314151617181920212223242526272829303132333435363738public class RegularExpressionMatching &#123; public boolean isMatch(String s, String p) &#123; if (s==null&amp;&amp;p==null) return true; if (s.length()==0&amp;&amp;p.length()==0) return true; boolean[][] matrix = new boolean[s.length()+1][p.length()+1]; matrix[0][0]=true; for (int i=1;i&lt;=s.length();i++) matrix[i][0]=false; for (int j=1;j&lt;=p.length();j++) if (p.charAt(j-1)==&apos;*&apos;&amp;&amp;j&gt;1) matrix[0][j]=matrix[0][j-2]; else matrix[0][j]=false; for (int i=1;i&lt;=s.length();i++) for (int j=1;j&lt;=p.length();j++) if (p.charAt(j-1)==s.charAt(i-1)||p.charAt(j-1)==&apos;.&apos;) matrix[i][j]=matrix[i-1][j-1]; else if (p.charAt(j-1)==&apos;*&apos;&amp;&amp;j&gt;1) if (p.charAt(j-2)==s.charAt(i-1)||p.charAt(j-2)==&apos;.&apos;) matrix[i][j]=matrix[i-1][j]||matrix[i][j-2]||matrix[i][j-1]; //matrix[i-1][j]:abb vs ab*: depends on ab vs ab* //matrix[i][j-2] a vs ab* depends on a vs a //matrix[i][j-1] ab vs ab*: depends on ab vs ab else matrix[i][j]=matrix[i][j-2]; else matrix[i][j]=false; return matrix[s.length()][p.length()]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[009. Palindrome Number]]></title>
    <url>%2Fp%2Fc3ad93e8%2F</url>
    <content type="text"><![CDATA[35.4% https://leetcode.com/problems/palindrome-number/ Determine whether an integer is a palindrome. Do this without extra space. click to show spoilers. Some hints:Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem â€œReverse Integerâ€, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. æ–¹æ³•ä¸€ï¼š å…ˆç‰¹æ®Šæƒ…å†µï¼Œè´Ÿæ•°ï¼Œæœ€åŽä¸€ä½ä¸º0ä¸”æ•°å€¼ä¸ç­‰äºŽ0ï¼ŒæŽ’é™¤ã€‚ ç„¶åŽç¿»è½¬å¾—åˆ°å€¼ åˆ¤æ–­æƒ…å†µï¼Œç›¸ç­‰ï¼Œæˆ–è€…ç­‰äºŽrev/10ï¼Œè¿™æ˜¯å› ä¸ºåªèµ°äº†ä¸€åŠ 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0 || x != 0 &amp;&amp; x%10 == 0) return false; int rev = 0; while(x &gt; rev)&#123; rev = rev * 10 + x % 10; x = x / 10; &#125; return (x == rev || x == rev / 10); &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ä¸€ï¼š 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0 || x&gt;0 &amp;&amp; x%10==0) return false; // æŽ’é™¤10ï¼Œ 100ï¼Œ1000è¿™ç§æƒ…å†µ int rev = 0; while(rev&lt;x)&#123; rev = rev*10 + x%10; x /= 10; &#125; return rev == x || rev/10 == x; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°äºŒï¼š 1234567891011121314class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0 || x!=0 &amp;&amp; x%10 == 0) return false; int y = 0; while(y&lt;x)&#123; y = y*10 + x%10; x /= 10; &#125; // æ³¨æ„æ­¤å¤„è¯¥/è¿˜æ˜¯% return x==y || x==y/10; &#125;&#125;; https://discuss.leetcode.com/topic/31602/this-problem-is-meanless This problem is meanless Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack. If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space. https://discuss.leetcode.com/topic/3151/2147447412-is-not-a-palindromic-number -2147447412 is not a palindromic number I am wondering how the other people got their code ACed, the testing result of â€œ-2147447412â€ seems a little odd to me. Should it be a palindromic number or not? Note: I believe the range of int is [-2147483648, 2147483647] and â€œ-2147447412â€ is not overflowed, plus I handled the overflow cases already (test case â€œ-2147483648â€ in particular). 11499 / 11502 test cases passed. Status: Wrong Answer Input: -2147447412 Output: true Expected: false Hereâ€™s my second question: Why does the function take â€œintâ€ as input instead of â€œunsigned intâ€, when we assume all negative numbers are NOT palindromic. java https://leetcode.com/discuss/23563/line-accepted-java-code-without-the-need-handling-overflow 9-line accepted Java code, without the need of handling overflow 12ms, 46.14%, May.4th, 2016 compare half of the digits in x, so donâ€™t need to deal with overflow. 123456789public boolean isPalindrome(int x) &#123; if (x&lt;0 || (x!=0 &amp;&amp; x%10==0)) return false; int rev = 0; while (x&gt;rev)&#123; rev = rev*10 + x%10; x = x/10; &#125; return (x==rev || x==rev/10);&#125; https://discuss.leetcode.com/topic/9477/o-1-space-o-lgn-time-java-solution-no-overflow-risk O(1) space, O(lgn) time java solution, no overflow risk 123456789101112131415public boolean isPalindrome(int x) &#123; if (x &lt; 0) return false; int p = x; int q = 0; while (p &gt;= 10)&#123; q *=10; q += p%10; p /=10; &#125; return q == x / 10 &amp;&amp; p == x % 10;&#125; so the reversed version of int is always 1 time short in the factor of 10s . in case of Int16, check 63556 will finally check if (6553 == 6355 &amp;&amp; 6 == 63556%10) so there will have no concerns about the overflow. https://discuss.leetcode.com/topic/3879/neat-ac-java-code-o-n-time-complexity Neat AC java code. O(n) time complexity. 123456789public boolean isPalindrome(int x) &#123; int palindromeX = 0; int inputX = x; while(x&gt;0)&#123; palindromeX = palindromeX*10 + (x % 10); x = x/10; &#125; return palindromeX==inputX; &#125; https://discuss.leetcode.com/topic/39795/simple-java-o-1-space-solution Simple JAVA O(1) space solution 12345678910public boolean isPalindrome(int x) &#123; if(x&lt;0 || (x!=0 &amp;&amp; x%10==0)) return false; int res = 0; while(x&gt;res)&#123; res = res*10 + x%10; x = x/10; &#125; return (x==res || x==res/10);&#125; cpp https://leetcode.com/discuss/33500/an-easy-lines-code-only-reversing-till-half-and-then-compare An easy c++ 8 lines code (only reversing till half and then compare) 76ms, 65.37%, May.4th, 2016 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0 || x != 0 &amp;&amp; x%10 == 0) return false; int rev = 0; while(x &gt; rev)&#123; rev = rev * 10 + x % 10; x = x / 10; &#125; return (x == rev || x == rev / 10); &#125;&#125;; https://discuss.leetcode.com/topic/39259/7-line-simple-c-solution-beats-90-submissions-in-o-1-space-two-pointers 7 line simple C++ solution beats 90% submissions in O(1) space, two pointers Use two pointers concept, find the half point, and compare first half and 2nd half. Variable revhalf is the reversed 2nd half(x has even number of digits), or 2nd half with the middle digit(if x has odd number of digits) 12345678910111213class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0) return false; int revhalf = 0, slow = x, fast = x; while(fast)&#123; revhalf = revhalf * 10 + slow % 10; slow /= 10; fast /= 100; &#125; return slow == revhalf || slow == revhalf / 10; &#125;&#125;; https://discuss.leetcode.com/topic/18921/my-c-solution My C++ solution.. 1234567891011121314151617bool isPalindrome(int x) &#123; if(x&lt;0) return false; int num=x; int a=0; while(x) &#123; a=a*10 + x%10; x=x/10; &#125; if(a==num) return true; else return false; &#125; python 272ms, 66.06%, May.4th, 2016 https://leetcode.com/discuss/82355/5-line-python-solution-248ms 1234567891011class Solution(object): def isPalindrome(self, x): &quot;&quot;&quot; :type x: int :rtype: bool &quot;&quot;&quot; if x &lt; 0 or (x &gt; 0 and x % 10 == 0): return False half = 0 while x &gt; half: half, x = half * 10 + x % 10, x / 10 return x in (half, half / 10)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[008. String to Integer (atoi)]]></title>
    <url>%2Fp%2F7d4ee2b3%2F</url>
    <content type="text"><![CDATA[14.0% https://leetcode.com/problems/string-to-integer-atoi/ Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. spoilers alertâ€¦ click to show requirements for atoi. Requirements for atoi: The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. https://discuss.leetcode.com/topic/35270/such-a-shitty-problem Such a shitty problem The description is not clear not all unless you click on the hint. Whatâ€™s the point of testing all the â€œ+-1â€ or â€œ-+1â€ without any input spec nor any situation where input is obtained. æ–¹æ³•ä¸€ï¼š å¦‚ä¸‹ä»£ç ï¼Œä»Žç¬¬ä¸€ä¸ªéž â€˜ â€˜å¼€å§‹ï¼Œç„¶åŽæ­£è´Ÿå·ï¼Œç„¶åŽæ¯ä¸ªè¿›è¡Œåˆ¤åˆ«ï¼Œè€ƒè™‘ä¸Žæœ€å¤§æœ€å°å€¼çš„å·®å¼‚ã€‚ stringçš„å‡½æ•°æ–¹æ³•find_first_not_of(â€˜ â€˜) 1234567891011121314151617int myAtoi(string str) &#123; long result = 0; int indicator = 1; for(int i = 0; i&lt;str.size();) &#123; i = str.find_first_not_of(&apos; &apos;); if(str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) indicator = (str[i++] == &apos;-&apos;)? -1 : 1; while(&apos;0&apos;&lt;= str[i] &amp;&amp; str[i] &lt;= &apos;9&apos;) &#123; result = result*10 + (str[i++]-&apos;0&apos;); if(result*indicator &gt;= INT_MAX) return INT_MAX; if(result*indicator &lt;= INT_MIN) return INT_MIN; &#125; return result*indicator; &#125;&#125; æˆ‘ä¼˜åŒ–åŽçš„ä»£ç å®žçŽ°ï¼š 123456789101112131415161718class Solution &#123;public: int myAtoi(string str) &#123; long result = 0; int indicator = 1; int i = 0; i = str.find_first_not_of(' '); if(str[i] == '-' || str[i] == '+') indicator = (str[i++] == '-')? -1 : 1; while('0'&lt;= str[i] &amp;&amp; str[i] &lt;= '9') &#123; result = result*10 + (str[i++]-'0'); if(result*indicator &gt;= INT_MAX) return INT_MAX; if(result*indicator &lt;= INT_MIN) return INT_MIN; &#125; return result*indicator; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š æ³¨æ„é‡Œé¢çš„å‘ï¼Œå¤„ç†æ•´æ•°intæ•°å­—ï¼Œä¸€å®šè¦æ³¨æ„æº¢å‡ºé—®é¢˜ï¼Œæ‰€ä»¥è¿™æ ·çš„ï¼Œåè½¬çš„ç­‰ç­‰ï¼Œä¸€å®šè¦ç”¨long ä¸ç”¨intï¼Œè€Œæ˜¯ç”¨longï¼Œå¤„ç†æº¢å‡ºé—®é¢˜ï¼Œæ­¤å¤„è¦ç‰¹åˆ«æ³¨æ„ã€‚ 123456789101112131415161718class Solution &#123;public: int myAtoi(string str) &#123; if(str.empty()) return 0; int flag = 1; int i = 0; i = str.find_first_not_of(' '); if(str[i]=='+' || str[i]=='-') flag = (str[i++]=='-') ? -1 : 1; long base = 0; // æ­¤å¤„ä¸€å®šè¦ç”¨long while(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9')&#123; base = base*10 + (str[i++]-'0'); if(base*flag &gt;= INT_MAX) return INT_MAX; if(base*flag &lt;= INT_MIN) return INT_MIN; &#125; return flag*base; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š å¯¹äºŽintå¯èƒ½æº¢å‡ºçš„é¢˜ç›®ï¼Œå°±ç”¨long long 123456789101112131415161718192021class Solution &#123;public: int myAtoi(string str) &#123; long long res = 0; int i = str.find_first_not_of(' '); int flag = 1; if(str[i] == '+')&#123; flag = 1; i++; &#125;else if(str[i]=='-')&#123; flag = -1; i++; &#125; while(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9')&#123; res = res*10 + str[i++] - '0'; if(flag*res &gt; INT_MAX) return INT_MAX; if(flag*res &lt; INT_MIN) return INT_MIN; &#125; return flag*res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/15891/8ms-c-solution-easy-to-understand 8ms C++ solution, easy to understand 12ms, 15.61%, August 31, 2016 1234567891011121314151617int myAtoi(string str) &#123; long result = 0; int indicator = 1; for(int i = 0; i&lt;str.size();) &#123; i = str.find_first_not_of(&apos; &apos;); if(str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) indicator = (str[i++] == &apos;-&apos;)? -1 : 1; while(&apos;0&apos;&lt;= str[i] &amp;&amp; str[i] &lt;= &apos;9&apos;) &#123; result = result*10 + (str[i++]-&apos;0&apos;); if(result*indicator &gt;= INT_MAX) return INT_MAX; if(result*indicator &lt;= INT_MIN) return INT_MIN; &#125; return result*indicator; &#125;&#125; https://discuss.leetcode.com/topic/29207/8-line-c-concise-solution 8 line C++ concise solution 12345678910int myAtoi(string str) &#123; int ret = 0, sign = 1, i = str.find_first_not_of(&apos; &apos;), base = INT_MAX / 10; if (str[i] == &apos;+&apos; || str[i] == &apos;-&apos;) sign = str[i++] == &apos;+&apos; ?: -1; while (isdigit(str[i])) &#123; if (ret &gt; base || (ret == base &amp;&amp; str[i] - &apos;0&apos; &gt; 7)) return sign &gt; 0 ? INT_MAX : INT_MIN; ret = 10 * ret + (str[i++] - &apos;0&apos;); &#125; return sign * ret;&#125; https://discuss.leetcode.com/topic/32966/c-10-lines-solution-easy-understanding-clean-code C++ 10 lines solution, easy understanding, clean code 12345678910111213int myAtoi(string str) &#123; if (str.empty()) return 0; int i = 0, sign = 1; while (i + 1 &lt; str.size() &amp;&amp; isspace(str[i])) ++i; long res = 0; if (str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) sign = 44 - str[i++]; while (i &lt; str.size()) &#123; if (isdigit(str[i])) res = 10 * res + str[i++] - &apos;0&apos;; else return res * sign; if (res &gt; INT_MAX) return sign == -1 ? INT_MIN : INT_MAX; &#125; return res * sign;&#125; python https://discuss.leetcode.com/topic/10740/python-solution-based-on-regex Python solution based on RegEx 123456789101112131415161718class Solution: # @return an integer def atoi(self, str): str = str.strip() str = re.findall(&apos;(^[\+\-0]*\d+)\D*&apos;, str) try: result = int(&apos;&apos;.join(str)) MAX_INT = 2147483647 MIN_INT = -2147483648 if result &gt; MAX_INT &gt; 0: return MAX_INT elif result &lt; MIN_INT &lt; 0: return MIN_INT else: return result except: return 0 https://discuss.leetcode.com/topic/26920/60ms-python-solution-oj-says-this-beats-100-python-submissions 60ms python solution; OJ says this beats 100% python submissions 12345678910111213141516171819class Solution(object): def myAtoi(self, s): &quot;&quot;&quot; :type str: str :rtype: int &quot;&quot;&quot; ###better to do strip before sanity check (although 8ms slower): #ls = list(s.strip()) #if len(ls) == 0 : return 0 if len(s) == 0 : return 0 ls = list(s.strip()) sign = -1 if ls[0] == &apos;-&apos; else 1 if ls[0] in [&apos;-&apos;,&apos;+&apos;] : del ls[0] ret, i = 0, 0 while i &lt; len(ls) and ls[i].isdigit() : ret = ret*10 + ord(ls[i]) - ord(&apos;0&apos;) i += 1 return max(-2**31, min(sign * ret,2**31-1)) java https://discuss.leetcode.com/topic/2666/my-simple-solution My simple solution I think we only need to handle four cases: discards all leading whitespaces sign of the number overflow invalid input Is there any better solution? Thanks for pointing out! 123456789101112131415int atoi(const char *str) &#123; int sign = 1, base = 0, i = 0; while (str[i] == &apos; &apos;) &#123; i++; &#125; if (str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) &#123; sign = 1 - 2 * (str[i++] == &apos;-&apos;); &#125; while (str[i] &gt;= &apos;0&apos; &amp;&amp; str[i] &lt;= &apos;9&apos;) &#123; if (base &gt; INT_MAX / 10 || (base == INT_MAX / 10 &amp;&amp; str[i] - &apos;0&apos; &gt; 7)) &#123; if (sign == 1) return INT_MAX; else return INT_MIN; &#125; base = 10 * base + (str[i++] - &apos;0&apos;); &#125; return base * sign;&#125; https://discuss.leetcode.com/topic/12473/java-solution-with-4-steps-explanations 3ms, August 31, 2016 Java Solution with 4 steps explanations 1234567891011121314151617181920212223242526272829public int myAtoi(String str) &#123; int index = 0, sign = 1, total = 0; //1. Empty string if(str.length() == 0) return 0; //2. Remove Spaces while(str.charAt(index) == &apos; &apos; &amp;&amp; index &lt; str.length()) index ++; //3. Handle signs if(str.charAt(index) == &apos;+&apos; || str.charAt(index) == &apos;-&apos;)&#123; sign = str.charAt(index) == &apos;+&apos; ? 1 : -1; index ++; &#125; //4. Convert number and avoid overflow while(index &lt; str.length())&#123; int digit = str.charAt(index) - &apos;0&apos;; if(digit &lt; 0 || digit &gt; 9) break; //check if total will be overflow after 10 times and add digit if(Integer.MAX_VALUE/10 &lt; total || Integer.MAX_VALUE/10 == total &amp;&amp; Integer.MAX_VALUE %10 &lt; digit) return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; total = 10 * total + digit; index ++; &#125; return total * sign;&#125; https://discuss.leetcode.com/topic/33142/java-easy-version-to-understand JAVAâ€”â€”-Easy Version To Understand!!!!!!!!!! 1234567891011121314151617181920212223242526public static int myAtoi(String str) &#123; if (str == null || str.length() == 0) return 0;// str = str.trim(); char firstChar = str.charAt(0); int sign = 1, start = 0, len = str.length(); long sum = 0; if (firstChar == &apos;+&apos;) &#123; sign = 1; start++; &#125; else if (firstChar == &apos;-&apos;) &#123; sign = -1; start++; &#125; for (int i = start; i &lt; len; i++) &#123; if (!Character.isDigit(str.charAt(i))) return (int) sum * sign; sum = sum * 10 + str.charAt(i) - &apos;0&apos;; if (sign == 1 &amp;&amp; sum &gt; Integer.MAX_VALUE) return Integer.MAX_VALUE; if (sign == -1 &amp;&amp; (-1) * sum &lt; Integer.MIN_VALUE) return Integer.MIN_VALUE; &#125; return (int) sum * sign;&#125; https://discuss.leetcode.com/topic/37311/my-nice-java-code-3ms My Nice Java Code 3ms 123456789101112131415161718192021public class Solution &#123; public int myAtoi(String str) &#123; if (str.isEmpty()) return 0; str = str.trim(); int i = 0, ans = 0, sign = 1, len = str.length(); if (str.charAt(i) == &apos;-&apos; || str.charAt(i) == &apos;+&apos;) sign = str.charAt(i++) == &apos;+&apos; ? 1 : -1; for (; i &lt; len; ++i) &#123; int tmp = str.charAt(i) - &apos;0&apos;; if (tmp &lt; 0 || tmp &gt; 9) break; if (ans &gt; Integer.MAX_VALUE / 10 || (ans == Integer.MAX_VALUE / 10 &amp;&amp; Integer.MAX_VALUE % 10 &lt; tmp)) return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; else ans = ans * 10 + tmp; &#125; return sign * ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[007. Reverse Integer]]></title>
    <url>%2Fp%2Ff2b740bb%2F</url>
    <content type="text"><![CDATA[23.8% https://leetcode.com/problems/reverse-integer/ Reverse digits of an integer. 12Example1: x = 123, return 321Example2: x = -123, return -321 click to show spoilers. Have you thought about this? Here are some good questions to ask before coding. Bonus points for you if you have already thought through this! If the integerâ€™s last digit is 0, what should the output be? ie, cases such as 10, 100. Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases? For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Update (2014-11-10): Test cases had been added to test the overflow behavior. å¦‚æžœä¸ºè´Ÿæ•°ï¼Œæ˜¯æ€Žä¹ˆæ ·çš„æƒ…å½¢å‘¢ï¼Ÿ 1234567-78 / 10 = -7 -78 % 10 = -8-78 / 100 = 0-78 % 100 = 78-9 / 10 = 0-9 % 10 = -9 æ–¹æ³•ä¸€ï¼š è€ƒè™‘è´Ÿæ•°å’Œ0çš„æƒ…å†µ Shortest code possible in c++ long long make res a 64 bit number, the overflow is checked. 1234567891011class Solution &#123;public: int reverse(int x) &#123; long long res = 0; while(x) &#123; res = res*10 + x%10; x /= 10; &#125; return (res&lt;INT_MIN || res&gt;INT_MAX) ? 0 : res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°åŠæ³¨æ„äº‹é¡¹ 1234567891011class Solution &#123;public: int reverse(int x) &#123; long long res = 0; // æ­¤å¤„è¦ç”¨long longï¼Œå› ä¸ºintä¼šæº¢å‡º while(x)&#123; res = res*10 + x%10; x /= 10; &#125; return (res&lt;INT_MIN || res&gt;INT_MAX)?0:res; // æ‹¬å·æœ€å¥½ä¸è¦çœç•¥ï¼Œä¸ç„¶å¯èƒ½ä¼šå‡ºé—®é¢˜ &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°äºŒ: 1234567891011121314class Solution &#123;public: int reverse(int x) &#123; // ç”¨åˆ°å¤§æ•°çš„æ—¶å€™ä¸€å®šè¦è®°å¾—ç”¨long long // è™½ç„¶ç»™çš„æ˜¯intï¼Œä½†æ˜¯æˆ‘ä»¬ä¾ç„¶è¦ç”¨long long long long res = 0; while(x!=0)&#123; res = res*10 + x%10; x /= 10; &#125; // ä¸‹é¢æœ€å¥½åŠ æ‹¬å·ï¼Œä»¥ç¤ºåŒºåˆ†ï¼Œè™½ç„¶ä¸è¦æ‹¬å·ä¹Ÿèƒ½æ­£ç¡®è¿è¡Œ return (res&lt;INT_MIN || res&gt;INT_MAX) ? 0 : res; &#125;&#125;; æ–¹æ³•äºŒï¼š è¾¹èµ°è¾¹æ£€æŸ¥è¾¹ç•Œ 8 ms simple C++ solution which checks overflow 8ms, 49.31%, 17 July 2016 123456789101112131415class Solution &#123;public: int reverse(int x) &#123; int ans = 0; while(x)&#123; int temp = ans * 10 + x % 10; if(temp / 10 != ans) return 0; ans = temp; x /= 10; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/6005/shortest-code-possible-in-c Shortest code possible in c++ long long make res a 64 bit number, the overflow is checked. 1234567891011class Solution &#123;public: int reverse(int x) &#123; long long res = 0; while(x) &#123; res = res*10 + x%10; x /= 10; &#125; return (res&lt;INT_MIN || res&gt;INT_MAX) ? 0 : res; &#125;&#125;; https://discuss.leetcode.com/topic/34506/8-ms-simple-c-solution-which-checks-overflow 8 ms simple C++ solution which checks overflow 8ms, 49.31%, 17 July 2016 123456789101112131415class Solution &#123;public: int reverse(int x) &#123; int ans = 0; while(x)&#123; int temp = ans * 10 + x % 10; if(temp / 10 != ans) return 0; ans = temp; x /= 10; &#125; return ans; &#125;&#125;; python https://discuss.leetcode.com/topic/15832/golfing-in-python Golfing in Python Get the sign, get the reversed absolute integer, and return their product if r didnâ€™t â€œoverflowâ€. 1234def reverse(self, x): s = cmp(x, 0) r = int(`s*x`[::-1]) return s*r * (r &lt; 2**31) As compressed one-liner, for potential comparison: 12def reverse(self, x): s=cmp(x,0);r=int(`s*x`[::-1]);return(r&lt;2**31)*s*r Anybody got something shorter? 12345678910111268ms, 50.07%, 17 July 2016class Solution(object): def reverse(self, x): &quot;&quot;&quot; :type x: int :rtype: int &quot;&quot;&quot; x = (-1 if x &lt; 0 else 1) * int(str(abs(x))[::-1]) if (x &lt; 2**31 - 1) and (x &gt; -2**31 + 1): return x else: return 0 c https://discuss.leetcode.com/topic/12975/a-simple-c-solution-with-5ms A simple C solution with 5ms 12345678910int reverse(int x) &#123; long long val = 0; do &#123; val = val * 10 + x % 10; x /= 10; &#125; while (x); return (val &gt; INT_MAX || val &lt; INT_MIN) ? 0 : val;&#125; java https://discuss.leetcode.com/topic/6104/my-accepted-15-lines-of-code-for-java My accepted 15 lines of code for Java Only 15 lines. If overflow exists, the new result will not equal previous one. No flags needed. No hard code like 0xf7777777 needed. Sorry for my bad english. 12345678910111213141516public int reverse(int x)&#123; int result = 0; while (x != 0) &#123; int tail = x % 10; int newResult = result * 10 + tail; if ((newResult - tail) / 10 != result) &#123; return 0; &#125; result = newResult; x = x / 10; &#125; return result;&#125; https://discuss.leetcode.com/topic/15134/very-short-7-lines-and-elegant-solution Very Short (7 lines) and Elegant Solution 2ms, 48.43%, 17 July 2016 123456789101112public class Solution &#123; public int reverse(int x) &#123; long rev= 0; while( x != 0)&#123; rev= rev*10 + x % 10; x= x/10; if( rev &gt; Integer.MAX_VALUE || rev &lt; Integer.MIN_VALUE) return 0; &#125; return (int) rev; &#125;&#125; https://discuss.leetcode.com/topic/8941/simple-java-solution-o-n-time-and-o-1-space Simple Java Solution O(N) time and O(1) space. Simply just modulo the input by 10, add it to a long-integer variable as the result. Repeat. When the result is &gt; max integer or &lt; min integer, return 0. Hence, return the result as an integer 123456789101112131415public class Solution &#123; public int reverse(int x) &#123; long result =0; while(x != 0) &#123; result = (result*10) + (x%10); if(result &gt; Integer.MAX_VALUE) return 0; if(result &lt; Integer.MIN_VALUE) return 0; x = x/10; &#125; return (int)result; &#125;&#125; https://discuss.leetcode.com/topic/41683/might-be-helpful-to-you-my-2ms-11-lines-java-solution Might be helpful to you: my 2ms 11 lines Java solution 1234567891011public int reverse(int x) &#123; long result = 0; while (x != 0) &#123; result = result * 10 + x%10; if (result &gt; Integer.MAX_VALUE || result &lt; Integer.MIN_VALUE) &#123; return 0; &#125; x = x / 10; &#125; return (int)result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[006. ZigZag Conversion]]></title>
    <url>%2Fp%2F6cbc5e00%2F</url>
    <content type="text"><![CDATA[26.3% https://leetcode.com/problems/zigzag-conversion/ 123456789101112The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P A H NA P L S I I GY I RAnd then read line by line: &quot;PAHNAPLSIIGYIR&quot;Write the code that will take a string and make this conversion given a number of rows:string convert(string text, int nRows);convert(&quot;PAYPALISHIRING&quot;, 3) should return &quot;PAHNAPLSIIGYIR&quot;. æ–¹æ³•ä¸€ï¼š æœ€å¥½çš„ä¸€ç‚¹æ˜¯ä½¿ç”¨äº†ç©ºé—´ï¼Œåˆ†æˆäº†nä¸ªç»„ï¼Œæ¯ä¸ªç»„éƒ½æ˜¯stringï¼Œæœ€åŽåˆå¹¶ã€‚ https://discuss.leetcode.com/topic/4502/share-simple-c-solution 28ms, 23.79%, August 31, 2016 The problem statement itself is unclear for many. Especially for 2-row case. â€œABCDâ€, 2 â€“&gt; â€œACBDâ€. The confusion most likely is from the character placement. I would like to extend it a little bit to make ZigZag easy understood. è®¾äº†ä¸€ä¸ªæ•°ç»„ï¼Œæ¯ä¸€ç»„ä»£è¡¨ä¸€è¡Œçš„å€¼ï¼Œç„¶åŽå°†ä»–ä»¬ä¸²è”åˆ°ä¸€èµ· The example can be written as follow: Pâ€¦â€¦.Aâ€¦â€¦..Hâ€¦â€¦.N ..A..Pâ€¦.L..Sâ€¦.Iâ€¦Iâ€¦.G â€¦.Yâ€¦â€¦â€¦Iâ€¦â€¦..R Therefore, &lt;ABCD, 2&gt; can be arranged as: Aâ€¦.C â€¦Bâ€¦.D My simple accepted code: 12345678910111213141516171819202122232425262728class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows &lt;= 1) return s; const int len = (int)s.length(); string *str = new string[numRows]; int row = 0, step=1; for(int i = 0; i &lt; len; ++i)&#123; str[row].push_back(s[i]); if(row==0) step = 1; else if(row == numRows - 1) step = -1; row += step; &#125; s.clear(); for(int j= 0; j &lt; numRows; ++j) s.append(str[j]); delete[] str; return s; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š å¯ä»¥å­¦ä¹ ä¸Šä¸€æ®µä»£ç ä¸­çš„clearï¼Œappendï¼Œdeleteå‡½æ•° 123456789101112131415161718192021class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows&lt;=1) return s; // æ­¤å¤„è¦åˆå§‹åŒ–ä¸ºv(numRows) vector&lt;string&gt; v(numRows); int pos = 0, flag = 1; for(int i=0; i&lt;s.size(); i++)&#123; v[pos] += s[i]; if(pos==0) flag = 1; else if(pos==numRows-1) flag = -1; pos += flag; &#125; string t = ""; for(int i=0; i&lt;numRows; i++) t.append(v[i]); return t; &#125;&#125;; https://discuss.leetcode.com/topic/22925/if-you-are-confused-with-zigzag-pattern-come-and-see If you are confused with zigzag pattern,come and see! 123456789/*n=numRowsÎ”=2n-2 1 2n-1 4n-3Î”= 2 2n-2 2n 4n-4 4n-2Î”= 3 2n-3 2n+1 4n-5 .Î”= . . . . .Î”= . n+2 . 3n .Î”= n-1 n+1 3n-3 3n-1 5n-5Î”=2n-2 n 3n-2 5n-4*/ thatâ€™s the zigzag pattern the question asked!Be careful with nR=1 &amp;&amp; nR=2 my 16ms code in c++: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string convert(string s, int numRows) &#123; string result=""; if(numRows==1) return s; int step1,step2; int len=s.size(); for(int i=0;i&lt;numRows;++i)&#123; step1=(numRows-i-1)*2; step2=(i)*2; int pos=i; if(pos&lt;len) result+=s.at(pos); while(1)&#123; pos+=step1; if(pos&gt;=len) break; if(step1) result+=s.at(pos); pos+=step2; if(pos&gt;=len) break; if(step2) result+=s.at(pos); &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/22925/if-you-are-confused-with-zigzag-pattern-come-and-see1234567891011/*n=numRowsÎ”=2n-2 1 2n-1 4n-3Î”= 2 2n-2 2n 4n-4 4n-2Î”= 3 2n-3 2n+1 4n-5 .Î”= . . . . .Î”= . n+2 . 3n .Î”= n-1 n+1 3n-3 3n-1 5n-5Î”=2n-2 n 3n-2 5n-4*/that&apos;s the zigzag pattern the question asked!Be careful with nR=1 &amp;&amp; nR=2 my 16ms code in c++: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string convert(string s, int numRows) &#123; string result=&quot;&quot;; if(numRows==1) return s; int step1,step2; int len=s.size(); for(int i=0;i&lt;numRows;++i)&#123; step1=(numRows-i-1)*2; step2=(i)*2; int pos=i; if(pos&lt;len) result+=s.at(pos); while(1)&#123; pos+=step1; if(pos&gt;=len) break; if(step1) result+=s.at(pos); pos+=step2; if(pos&gt;=len) break; if(step2) result+=s.at(pos); &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/21196/a-10-lines-one-pass-o-n-time-o-1-space-accepted-solution-with-detailed-explantation A 10-lines one-pass o(n)-time o(1)-space accepted solution with detailed explantation The distribution of the elements is period. 123P A H NA P L S I I GY I R For example, the following has 4 periods(cycles): 123P | A | H | NA P | L S | I I | GY | I | R | The size of every period is defined as â€œcycleâ€ 1cycle = (2*nRows - 2), except nRows == 1. In this example, (2*nRows - 2) = 4. In every period, every row has 2 elements, except the first row and the last row. Suppose the current row is i, the index of the first element is j: 1j = i + cycle*k, k = 0, 1, 2, ... The index of the second element is secondJ: 1secondJ = (j - i) + cycle - i (j-i) is the start of current period, (j-i) + cycle is the start of next period. 12345678910111213141516string convert(string s, int nRows) &#123; if(nRows &lt;= 1) return s; string result = &quot;&quot;; //the size of a cycle(period) int cycle = 2 * nRows - 2; for(int i = 0; i &lt; nRows; ++i) &#123; for(int j = i; j &lt; s.length(); j = j + cycle)&#123; result = result + s[j]; int secondJ = (j - i) + cycle - i; if(i != 0 &amp;&amp; i != nRows-1 &amp;&amp; secondJ &lt; s.length()) result = result + s[secondJ]; &#125; &#125; return result; &#125; python https://discuss.leetcode.com/topic/34573/python-o-n-solution-in-96ms-99-43 Python O(n) Solution in 96ms (99.43%) 12345678910111213141516171819202122class Solution(object): def convert(self, s, numRows): &quot;&quot;&quot; :type s: str :type numRows: int :rtype: str &quot;&quot;&quot; if numRows == 1 or numRows &gt;= len(s): return s L = [&apos;&apos;] * numRows index, step = 0, 1 for x in s: L[index] += x if index == 0: step = 1 elif index == numRows -1: step = -1 index += step return &apos;&apos;.join(L) https://discuss.leetcode.com/topic/10330/a-simple-python-solution-97ms-8-lines A simple python solution, 97ms, 8 lines 12345678910111213141516def convert(self, s, nRows): if nRows==1: return s period= 2*(nRows -1) lines=[&quot;&quot; for i in range(nRows)] d=&#123;&#125; # dict remainder:line for i in xrange(period): if i&lt;nRows: d[i]=i else: d[i]=period-i for i in xrange(len(s)): lines[ d[i%period] ] +=s[i] return &quot;&quot;.join(lines) The idea is to use the remainder (index%period) to determine which line the character at the given index will be. The period is calculated first based on nRows. A dictionary with remainder:line as key:value is then created (this can also be done with a list or a tuple). Once these are done, we simply go through s, assign each character to its new line, and then combine these lines to get the converted string. The code can be further shortened to 8 lines by using dict comprehension: 1d=&#123;i:i if i&lt;nRows else (period-i) for i in xrange(period)&#125; 1234567891011def convert(self, s, nRows): if nRows==1: return s period= 2*(nRows -1) lines=[&quot;&quot; for i in range(nRows)] d=&#123;i:i if i&lt;nRows else (period-i) for i in xrange(period)&#125; for i in xrange(len(s)): lines[ d[i%period] ] +=s[i] return &quot;&quot;.join(lines) java https://discuss.leetcode.com/topic/3162/easy-to-understand-java-solution Easy to understand Java solution Create nRows StringBuffers, and keep collecting characters from original string to corresponding StringBuffer. Just take care of your index to keep them in bound. 1234567891011121314151617public String convert(String s, int nRows) &#123; char[] c = s.toCharArray(); int len = c.length; StringBuffer[] sb = new StringBuffer[nRows]; for (int i = 0; i &lt; sb.length; i++) sb[i] = new StringBuffer(); int i = 0; while (i &lt; len) &#123; for (int idx = 0; idx &lt; nRows &amp;&amp; i &lt; len; idx++) // vertically down sb[idx].append(c[i++]); for (int idx = nRows-2; idx &gt;= 1 &amp;&amp; i &lt; len; idx--) // obliquely up sb[idx].append(c[i++]); &#125; for (int idx = 1; idx &lt; sb.length; idx++) sb[0].append(sb[idx]); return sb[0].toString();&#125; https://discuss.leetcode.com/topic/41037/java-solution-easy-and-clear-interesting-approach JAVA solutionâ€“easy and clear ( interesting approach ) 12345678910111213141516171819202122public class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows&lt;=1)return s; StringBuilder[] sb=new StringBuilder[numRows]; for(int i=0;i&lt;sb.length;i++)&#123; sb[i]=new StringBuilder(&quot;&quot;); //init every sb element **important step!!!! &#125; int incre=1; int index=0; for(int i=0;i&lt;s.length();i++)&#123; sb[index].append(s.charAt(i)); if(index==0)&#123;incre=1;&#125; if(index==numRows-1)&#123;incre=-1;&#125; index+=incre; &#125; String re=&quot;&quot;; for(int i=0;i&lt;sb.length;i++)&#123; re+=sb[i]; &#125; return re.toString(); &#125;&#125; https://discuss.leetcode.com/topic/3305/two-ways-of-o-n-solutions-one-follows-the-order-of-input-string-and-other-follows-the-order-of-output-string Two ways of O(n) solutions one follows the order of input string and other follows the order of output string Both the algorithms are of O(n) time complexity as every character in the input string is traversed only once.In the first version of algorithm, the output stringâ€™s string buffer get populated based on the output string order i.e, string builder gets populated incrementally from 0 to size-1. 12345670 6 12 181 5 7 11 13 17 192 4 8 10 14 16 203 9 15 21 In the above sample case the number of rows is 4, when the first iteration is completed the locations 0,1,2,3 of the string builder gets filled with the locations 0,6,12,18 of the input string it goes on further for other three rows. 123456789101112131415161718192021222324252627282930public class Solution &#123; public String convert(String s, int nRows) &#123; if (nRows == 1) return s; StringBuilder strBuilder = new StringBuilder(); int borderRowStep = 2 * nRows - 2; for (int i = 0; i &lt; nRows; i++) &#123; if (i == 0 || i == nRows - 1) &#123; for (int j = i; j &lt; s.length(); j = j + borderRowStep) &#123; strBuilder.append(s.charAt(j)); &#125; &#125; else &#123; int j = i; boolean flag = true; int insideRowLargeStep = 2 * (nRows - 1 - i); int insideRowSmallStep = borderRowStep - insideRowLargeStep; while (j &lt; s.length()) &#123; strBuilder.append(s.charAt(j)); if (flag) j = j + insideRowLargeStep; else j = j + insideRowSmallStep; flag = !flag; &#125; &#125; &#125; return strBuilder.toString(); &#125;&#125; In the second version of algorithm string buffer is filled in the order of input string i.e, the string buffer gets filled in the zig zag order, when the first iteration of the outer while loop completes the locations 0,5,11,17 in string builder gets filled with the locations 0,1,2,3, from the input string 123456789101112131415161718class Solution&#123;public String convert(String s, int nRows) &#123; char[] c = s.toCharArray(); int len = c.length; StringBuffer[] sb = new StringBuffer[nRows]; for (int z=0; z &lt; sb.length; z++) sb[z] = new StringBuffer(); int k=0; while (k &lt; len) &#123; for (int zigZagIndex = 0; zigZagIndex &lt; nRows &amp;&amp; k &lt; len; zigZagIndex++) // vertically down sb[zigZagIndex].append(c[k++]); for (int zigZagIndex = nRows-2; zigZagIndex &gt;= 1 &amp;&amp; k &lt; len; zigZagIndex--) // obliquely up sb[zigZagIndex].append(c[k++]); &#125; for (int index = 1; index &lt; sb.length; index++) sb[0].append(sb[index]); return sb[0].toString();&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[005. Longest Palindromic Substring]]></title>
    <url>%2Fp%2Fa8573ae4%2F</url>
    <content type="text"><![CDATA[25.0% https://leetcode.com/problems/longest-palindromic-substring/ Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. 1234567Example:Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. 12345Example:Input: &quot;cbbd&quot;Output: &quot;bb&quot; æ–¹æ³•ä¸€ï¼š ä¾æ¬¡éåŽ†ï¼ŒéåŽ†è‡³iæ—¶ï¼Œä»Žiå¼€å§‹å‘å·¦å‘å³ç§»åŠ¨ï¼Œæ‰¾åˆ°æœ€å¤§é•¿åº¦ã€‚ 12345678910111213141516171819202122232425class Solution &#123; int start, longest;public: string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; for(int i=0; i&lt;n-1; i++)&#123; helper(s, i, i); helper(s, i, i+1); &#125; return s.substr(start, longest); &#125; void helper(string&amp; s, int i, int j)&#123; while(i&gt;=0 &amp;&amp; j&lt;s.size() &amp;&amp; s[i]==s[j])&#123; i--; j++; &#125; if(longest&lt;j-i-1)&#123; start = i+1; longest = j-i-1; &#125; return; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ä¸€ï¼š 1234567891011121314151617181920212223242526class Solution &#123;public: int head = 0; int l = 0; string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; for(int i=0; i&lt;n-1; i++)&#123; helper(i, i, s); helper(i, i+1, s); &#125; return s.substr(head, l); &#125; void helper(int left, int right, string &amp; s)&#123; int n = s.size(); while(left&gt;=0 &amp;&amp; right&lt;n &amp;&amp; s[left]==s[right])&#123; left--; right++; &#125; if(right-left-1&gt;l)&#123; head = left+1; l = right-left-1; &#125; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°äºŒï¼š 12345678910111213141516171819202122232425class Solution &#123;public: string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; int head = 0, d = 0; for(int i=0; i&lt;n-1; i++)&#123; helper(s, i, i, head, d); helper(s, i, i+1, head, d); &#125; return s.substr(head, d); &#125; void helper(string s, int left, int right, int&amp; head, int&amp; d)&#123; while(left&gt;=0 &amp;&amp; right&lt;s.size() &amp;&amp; s[left]==s[right])&#123; left--; right++; &#125; if(right-left-1&gt;d)&#123; head = left+1; d = right-left-1; &#125; return; &#125;&#125;; æ–¹æ³•äºŒï¼š https://discuss.leetcode.com/topic/16317/accepted-4ms-c-solution Accepted 4ms c++ solution. æ ¸å¿ƒé€»è¾‘ç‚¹ï¼š 1 5 5 5 5 6 7 8 éåŽ†åˆ°æŸä¸€ä¸ªæ ¸å¿ƒå¦‚ 5 5æ—¶ï¼Œä¸€å®šè¦æŠŠ5å…¨éƒ¨æ”¾ä¸­é—´æ‰æ˜¯æœ€é•¿çš„ï¼Œä¸ç„¶è‚¯å®šé‡è§ä¸€ä¸ªä¸å¯¹ç§°çš„5 ç„¶åŽä¸‹ä¸€ä¸ªæ ¸å¿ƒæ˜¯6ï¼ŒåŒæ—¶å½“å‰ä½ç½®è·ç¦»æœ«å°¾å°äºŽæœ€é•¿é•¿åº¦æ—¶è¦åœæ­¢ï¼Œè¿›ä¸€æ­¥ä¼˜åŒ–äº†ç®—æ³• 1234567891011121314151617181920212223class Solution &#123;public: std::string longestPalindrome(std::string s) &#123; if (s.size() &lt; 2) return s; int len = s.size(), max_left = 0, max_len = 1, left, right; for (int start = 0; start &lt; len &amp;&amp; len - start &gt; max_len / 2;) &#123; left = right = start; while (right &lt; len - 1 &amp;&amp; s[right + 1] == s[right]) ++right; start = right + 1; while (right &lt; len - 1 &amp;&amp; left &gt; 0 &amp;&amp; s[right + 1] == s[left - 1]) &#123; ++right; --left; &#125; if (max_len &lt; right - left + 1) &#123; max_left = left; max_len = right - left + 1; &#125; &#125; return s.substr(max_left, max_len); &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š ä¸¤ç‚¹ä¼˜åŒ– 3msï¼Œ94.75% 123456789101112131415161718192021222324class Solution &#123;public: string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; int head = 0, d = 0; int left = 0, right = 0; for(int i=0; i&lt;n-d/2; )&#123; left = right = i; while(right+1&lt;n &amp;&amp; s[right+1]==s[right]) right++; i = right+1; while(left-1&gt;=0 &amp;&amp; right+1&lt;n &amp;&amp; s[left-1]==s[right+1])&#123; left--; right++; &#125; if(right-left+1&gt;d)&#123; head = left; d = right-left+1; &#125; &#125; return s.substr(head, d); &#125;&#125;; https://discuss.leetcode.com/topic/12187/simple-c-solution-8ms-13-lines Simple C++ solution (8ms, 13 lines) 123456789101112131415string longestPalindrome(string s) &#123; if (s.empty()) return &quot;&quot;; if (s.size() == 1) return s; int min_start = 0, max_len = 1; for (int i = 0; i &lt; s.size();) &#123; if (s.size() - i &lt;= max_len / 2) break; int j = i, k = i; while (k &lt; s.size()-1 &amp;&amp; s[k+1] == s[k]) ++k; // Skip duplicate characters. i = k+1; while (k &lt; s.size()-1 &amp;&amp; j &gt; 0 &amp;&amp; s[k + 1] == s[j - 1]) &#123; ++k; --j; &#125; // Expand. int new_len = k - j + 1; if (new_len &gt; max_len) &#123; min_start = j; max_len = new_len; &#125; &#125; return s.substr(min_start, max_len);&#125; python https://discuss.leetcode.com/topic/7144/python-o-n-2-method-with-some-optimization-88ms 14ms, 79.15%, 23 July 2016 maxLenæ˜¯é•¿åº¦ï¼Œiä¸ºå½“å‰ä½ç½®ï¼Œåˆ¤æ–­ï¼Œi-maxLenè‡³iä¹‹é—´æ˜¯å¦å¯¹ç§° Basic thought is simple. when you increase s by 1 character, you could only increase maxPalindromeLen by 1 or 2, and that new maxPalindrome includes this new character. Proof: if on adding 1 character, maxPalindromeLen increased by 3 or more, say the new maxPalindromeLen is Q, and the old maxPalindromeLen is P, and Q&gt;=P+3. Then it would mean, even without this new character, there would be a palindromic substring ending in the last character, whose length is at least Q-2. Since Q-2 would be &gt;P, this contradicts the condition that P is the maxPalindromeLen without the additional character. So, it becomes simple, you only need to scan from beginning to the end, adding one character at a time, keeping track of maxPalindromeLen, and for each added character, you check if the substrings ending with this new character, with length P+1 or P+2, are palindromes, and update accordingly. Now, this is O(n^2) as taking substrings and checking palindromicity seem O(n) time. We can speed up it by realizing that strings are immutable, and there are memory slicing tricks will help to speed these operations up. comparing string equality with â€œ==â€ is O(1), and using slicing to substring and reverse is Ì¶aÌ¶lÌ¶sÌ¶oÌ¶ Ì¶OÌ¶(Ì¶1Ì¶)Ì¶ Ì¶(Ì¶nÌ¶oÌ¶tÌ¶ Ì¶tÌ¶oÌ¶tÌ¶aÌ¶lÌ¶lÌ¶yÌ¶ Ì¶sÌ¶uÌ¶rÌ¶eÌ¶ Ì¶aÌ¶bÌ¶oÌ¶uÌ¶tÌ¶ Ì¶tÌ¶hÌ¶eÌ¶ Ì¶sÌ¶lÌ¶iÌ¶cÌ¶iÌ¶nÌ¶gÌ¶ Ì¶tÌ¶hÌ¶oÌ¶uÌ¶gÌ¶hÌ¶.Ì¶ Ì¶ Ì¶IÌ¶ Ì¶tÌ¶hÌ¶iÌ¶nÌ¶kÌ¶ Ì¶iÌ¶tÌ¶ Ì¶iÌ¶sÌ¶ Ì¶OÌ¶(Ì¶1Ì¶)Ì¶,Ì¶ Ì¶bÌ¶uÌ¶tÌ¶ Ì¶cÌ¶oÌ¶uÌ¶lÌ¶dÌ¶ Ì¶nÌ¶oÌ¶tÌ¶ Ì¶fÌ¶iÌ¶nÌ¶dÌ¶ Ì¶aÌ¶nÌ¶yÌ¶ Ì¶sÌ¶oÌ¶lÌ¶iÌ¶dÌ¶ Ì¶lÌ¶iÌ¶tÌ¶eÌ¶rÌ¶aÌ¶tÌ¶uÌ¶rÌ¶eÌ¶ Ì¶aÌ¶bÌ¶oÌ¶uÌ¶tÌ¶ Ì¶iÌ¶tÌ¶.Ì¶ O(n) (thanks to ChuntaoLu). But as slicing is optimized by the interpreterâ€™s C code, it should run pretty fast. Iâ€™m pretty new to Python. Would appreciate you would give more insights or further optimization. Thus, here is the O(n) method: 123456789101112131415161718class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; if len(s) == 0: return 0 maxLen = 1 start = 0 for i in xrange(len(s)): if i - maxLen &gt;= 1 and s[i-maxLen - 1: i+1] == s[i - maxLen-1:i+1][::-1]: start = i-maxLen -1 maxLen+= 2 continue if i - maxLen &gt;= 0 and s[i-maxLen:i+1] == s[i-maxLen:i+1][::-1]: start = i - maxLen maxLen += 1 return s[start:start+maxLen] https://discuss.leetcode.com/topic/20844/python-easy-to-understand-solution-with-comments-from-middle-to-two-ends Python easy to understand solution with comments (from middle to two ends). 12345678910111213141516171819def longestPalindrome(self, s): res = &quot;&quot; for i in xrange(len(s)): # odd case, like &quot;aba&quot; tmp = self.helper(s, i, i) if len(tmp) &gt; len(res): res = tmp # even case, like &quot;abba&quot; tmp = self.helper(s, i, i+1) if len(tmp) &gt; len(res): res = tmp return res # get the longest palindrome, l, r are the middle indexes # from inner to outerdef helper(self, s, l, r): while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]: l -= 1; r += 1 return s[l+1:r] java https://discuss.leetcode.com/topic/23498/very-simple-clean-java-solution The performance is pretty good, surprisingly. 12345678910111213141516171819202122232425public class Solution &#123;private int lo, maxLen;public String longestPalindrome(String s) &#123; int len = s.length(); if (len &lt; 2) return s; for (int i = 0; i &lt; len-1; i++) &#123; extendPalindrome(s, i, i); //assume odd length, try to extend Palindrome as possible extendPalindrome(s, i, i+1); //assume even length. &#125; return s.substring(lo, lo + maxLen);&#125;private void extendPalindrome(String s, int j, int k) &#123; while (j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k)) &#123; j--; k++; &#125; if (maxLen &lt; k - j - 1) &#123; lo = j + 1; maxLen = k - j - 1; &#125;&#125;&#125; https://discuss.leetcode.com/topic/21848/ac-relatively-short-and-very-clear-java-solution (AC) relatively short and very clear Java solution Key idea, every time we move to right, we only need to consider whether using this new character as tail could produce new palindrome string of length (current length +1) or (current length +2) 12345678910111213141516171819202122232425public class Solution &#123; public String longestPalindrome(String s) &#123; String res = &quot;&quot;; int currLength = 0; for(int i=0;i&lt;s.length();i++)&#123; if(isPalindrome(s,i-currLength-1,i))&#123; res = s.substring(i-currLength-1,i+1); currLength = currLength+2; &#125; else if(isPalindrome(s,i-currLength,i))&#123; res = s.substring(i-currLength,i+1); currLength = currLength+1; &#125; &#125; return res; &#125; public boolean isPalindrome(String s, int begin, int end)&#123; if(begin&lt;0) return false; while(begin&lt;end)&#123; if(s.charAt(begin++)!=s.charAt(end--)) return false; &#125; return true; &#125;&#125; For friends who are confused about the key idea to check only new palindrome with length = current length +2 or +1, I add some more explanation here. 12345678910Example: &quot;xxxbcbxxxxxa&quot;, (x is random character, not all x are equal) now we are dealing with the last character &apos;a&apos;. The current longest palindrome is &quot;bcb&quot; with length 3.1. check &quot;xxxxa&quot; so if it is palindrome we could get a new palindrome of length 5.2. check &quot;xxxa&quot; so if it is palindrome we could get a new palindrome of length 4.3. do NOT check &quot;xxa&quot; or any shorter string since the length of the new string is no bigger than current longest length.4. do NOT check &quot;xxxxxa&quot; or any longer string because if &quot;xxxxxa&quot; is palindrome then &quot;xxxx&quot; got from cutting off the head and tail is also palindrom. It has length &gt; 3 which is impossible.&apos; https://discuss.leetcode.com/topic/25500/share-my-java-solution-using-dynamic-programming Share my Java solution using dynamic programming dp(i, j) represents whether s(i â€¦ j) can form a palindromic substring, dp(i, j) is true when s(i) equals to s(j) and s(i+1 â€¦ j-1) is a palindromic substring. When we found a palindrome, check if itâ€™s the longest one. Time complexity O(n^2). 123456789101112131415161718public String longestPalindrome(String s) &#123; int n = s.length(); String res = null; boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i; j &lt; n; j++) &#123; dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; 3 || dp[i + 1][j - 1]); if (dp[i][j] &amp;&amp; (res == null || j - i + 1 &gt; res.length())) &#123; res = s.substring(i, j + 1); &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/23498/very-simple-clean-java-solution 14ms, 79.15%, 23 July 2016 ç¬¬ä¸€éå¾ªçŽ¯ï¼Œé’ˆå¯¹æ¯ä¸ªç´¢å¼•ï¼Œå¼€å§‹å‘ä¸¤éæ‰©å±•ï¼Œç›´åˆ°ä¸èƒ½æ‰©å±•ä¸ºæ­¢ã€‚ 123456789101112131415161718192021222324252627public class Solution &#123; private int lo, maxLen; public String longestPalindrome(String s) &#123; int len = s.length(); if(len &lt; 2) return s; for(int i=0; i&lt;len-1;i++)&#123; // assume odd length, try to extend Palindrome as possible extenPalindrome(s, i, i); //assume even length. extenPalindrome(s, i, i+1); &#125; return s.substring(lo, lo + maxLen); &#125; private void extenPalindrome(String s, int j, int k)&#123; while(j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k))&#123; j--; k++; &#125; if(maxLen &lt; k - j - 1)&#123; lo = j + 1; maxLen = k - j - 1; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[004. Median of Two Sorted Arrays]]></title>
    <url>%2Fp%2F82de9929%2F</url>
    <content type="text"><![CDATA[21.0% https://leetcode.com/problems/median-of-two-sorted-arrays/ There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 12345Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0 12345Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 cpp https://discuss.leetcode.com/topic/16797/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation Very concise O(log(min(M,N))) iterative solution with detailed explanation This problem is notoriously hard to implement due to all the corner cases. Most implementations consider odd-lengthed and even-lengthed arrays as two different cases and treat them separately. As a matter of fact, with a little mind twist. These two cases can be combined as one, leading to a very simple solution where (almost) no special treatment is needed. First, letâ€™s see the concept of â€˜MEDIANâ€™ in a slightly unconventional way. That is: 123&quot;if we cut the sorted array to two halves of EQUAL LENGTHS, thenmedian is the AVERAGE OF Max(lower_half) and Min(upper_half), i.e. thetwo numbers immediately next to the cut&quot;. For example, for [2 3 5 7], we make the cut between 3 and 5: 1[2 3 / 5 7] then the median = (3+5)/2. Note that Iâ€™ll use â€˜/â€˜ to represent a cut, and (number / number) to represent a cut made through a number in this article. for [2 3 4 5 6], we make the cut right through 4 like this: [2 3 (4/4) 5 7] Since we split 4 into two halves, we say now both the lower and upper subarray contain 4. This notion also leads to the correct answer: (4 + 4) / 2 = 4; For convenience, letâ€™s use L to represent the number immediately left to the cut, and R the right counterpart. In [2 3 5 7], for instance, we have L = 3 and R = 5, respectively. We observe the index of L and R have the following relationship with the length of the array N: 123456789N Index of L / R1 0 / 02 0 / 13 1 / 1 4 1 / 2 5 2 / 26 2 / 37 3 / 38 3 / 4 It is not hard to conclude that index of L = (N-1)/2, and R is at N/2. Thus, the median can be represented as 1(L + R)/2 = (A[(N-1)/2] + A[N/2])/2 To get ready for the two array situation, letâ€™s add a few imaginary â€˜positionsâ€™ (represented as #â€™s) in between numbers, and treat numbers as â€˜positionsâ€™ as well. 12345[6 9 13 18] -&gt; [# 6 # 9 # 13 # 18 #] (N = 4)position index 0 1 2 3 4 5 6 7 8 (N_Position = 9) [6 9 11 13 18]-&gt; [# 6 # 9 # 11 # 13 # 18 #] (N = 5)position index 0 1 2 3 4 5 6 7 8 9 10 (N_Position = 11) As you can see, there are always exactly 2*N+1 â€˜positionsâ€™ regardless of length N. Therefore, the middle cut should always be made on the Nth position (0-based). Since index(L) = (N-1)/2 and index(R) = N/2 in this situation, we can infer that index(L) = (CutPosition-1)/2, index(R) = (CutPosition)/2. Now for the two-array case: 123A1: [# 1 # 2 # 3 # 4 # 5 #] (N1 = 5, N1_positions = 11)A2: [# 1 # 1 # 1 # 1 #] (N2 = 4, N2_positions = 9) Similar to the one-array problem, we need to find a cut that divides the two arrays each into two halves such that 12&quot;any number in the two left halves&quot; &lt;= &quot;any number in the two righthalves&quot;. We can also make the following observationsï¼š There are 2N1 + 2N2 + 2 position altogether. Therefore, there must be exactly N1 + N2 positions on each side of the cut, and 2 positions directly on the cut. Therefore, when we cut at position C2 = K in A2, then the cut position in A1 must be C1 = N1 + N2 - k. For instance, if C2 = 2, then we must have C1 = 4 + 5 - C2 = 7. 123[# 1 # 2 # 3 # (4/4) # 5 #] [# 1 / 1 # 1 # 1 #] When the cuts are made, weâ€™d have two Lâ€™s and two Râ€™s. They are L1 = A1[(C1-1)/2]; R1 = A1[C1/2];L2 = A2[(C2-1)/2]; R2 = A2[C2/2];In the above example, 12L1 = A1[(7-1)/2] = A1[3] = 4; R1 = A1[7/2] = A1[3] = 4;L2 = A2[(2-1)/2] = A2[0] = 1; R2 = A1[2/2] = A1[1] = 1; Now how do we decide if this cut is the cut we want? Because L1, L2 are the greatest numbers on the left halves and R1, R2 are the smallest numbers on the right, we only need 1L1 &lt;= R1 &amp;&amp; L1 &lt;= R2 &amp;&amp; L2 &lt;= R1 &amp;&amp; L2 &lt;= R2 to make sure that any number in lower halves &lt;= any number in upper halves. As a matter of fact, sinceL1 &lt;= R1 and L2 &lt;= R2 are naturally guaranteed because A1 and A2 are sorted, we only need to make sure: L1 &lt;= R2 and L2 &lt;= R1. Now we can use simple binary search to find out the result. 12345678If we have L1 &gt; R1, it means there are too many large numbers on the left half of A1, then we must move C1 to the left (i.e. move C2 to the right); If L2 &gt; R1, then there are too many large numbers on the left half of A2, and we must move C2 to the left.Otherwise, this cut is the right one. After we find the cut, the medium can be computed as (max(L1, L2) + min(R1, R2)) / 2; Two side notes: A. since C1 and C2 can be mutually determined from each other, we might as well select the shorter array (say A2) and only move C2 around, and calculate C1 accordingly. That way we can achieve a run-time complexity of O(log(min(N1, N2))) B. The only edge case is when a cut falls on the 0th(first) or the 2Nth(last) position. For instance, if C2 = 2N2, then R2 = A2[2*N2/2] = A2[N2], which exceeds the boundary of the array. To solve this problem, we can imagine that both A1 and A2 actually have two extra elements, INT_MAX at A[-1] and INT_MAX at A[N]. These additions donâ€™t change the result, but make the implementation easier: If any L falls out of the left boundary of the array, then L = INT_MIN, and if any R falls out of the right boundary, then R = INT_MAX. I know that was not very easy to understand, but all the above reasoning eventually boils down to the following concise code: 1234567891011121314151617181920212223double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int N1 = nums1.size(); int N2 = nums2.size(); if (N1 &lt; N2) return findMedianSortedArrays(nums2, nums1); // Make sure A2 is the shorter one. if (N2 == 0) return ((double)nums1[(N1-1)/2] + (double)nums1[N1/2])/2; // If A2 is empty int lo = 0, hi = N2 * 2; while (lo &lt;= hi) &#123; int mid2 = (lo + hi) / 2; // Try Cut 2 int mid1 = N1 + N2 - mid2; // Calculate Cut 1 accordingly double L1 = (mid1 == 0) ? INT_MIN : nums1[(mid1-1)/2]; // Get L1, R1, L2, R2 respectively double L2 = (mid2 == 0) ? INT_MIN : nums2[(mid2-1)/2]; double R1 = (mid1 == N1 * 2) ? INT_MAX : nums1[(mid1)/2]; double R2 = (mid2 == N2 * 2) ? INT_MAX : nums2[(mid2)/2]; if (L1 &gt; R2) lo = mid2 + 1; // A1&apos;s lower half is too big; need to move C1 left (C2 right) else if (L2 &gt; R1) hi = mid2 - 1; // A2&apos;s lower half too big; need to move C2 left. else return (max(L1,L2) + min(R1, R2)) / 2; // Otherwise, that&apos;s the right cut. &#125; return -1;&#125; If you have any suggestions to make the logic and implementation even more cleaner. Please do let me know! https://discuss.leetcode.com/topic/2778/share-my-simple-o-log-m-n-solution-for-your-reference Share my simple O(log(m+n)) solution for your reference Binary search. Call 2 times getkth and k is about half of (m + n). Every time call getkth can reduce the scale k to its half. So the time complexity is log(m + n). 12345678910111213141516171819202122232425class Solution &#123;public: int getkth(int s[], int m, int l[], int n, int k)&#123; // let m &lt;= n if (m &gt; n) return getkth(l, n, s, m, k); if (m == 0) return l[k - 1]; if (k == 1) return min(s[0], l[0]); int i = min(m, k / 2), j = min(n, k / 2); if (s[i - 1] &gt; l[j - 1]) return getkth(s, m, l + j, n - j, k - j); else return getkth(s + i, m - i, l, n, k - i); return 0; &#125; double findMedianSortedArrays(int A[], int m, int B[], int n) &#123; int l = (m + n + 1) &gt;&gt; 1; int r = (m + n + 2) &gt;&gt; 1; return (getkth(A, m ,B, n, l) + getkth(A, m, B, n, r)) / 2.0; &#125;&#125;; https://discuss.leetcode.com/topic/5728/share-one-divide-and-conquer-o-log-m-n-method-with-clear-description Share one divide and conquer O(log(m+n)) method with clear description // using divide and conquer idea, each time find the mid of both arrays 12345678910111213141516171819202122232425262728293031323334353637383940414243double findMedianSortedArrays(int A[], int m, int B[], int n) &#123; /* A[0, 1, 2, ..., n-1, n] */ /* A[0, 1, 2, ..., m-1, m] */ int k = (m + n + 1) / 2; double v = (double)FindKth(A, 0, m - 1, B, 0, n - 1, k); if ((m+n) % 2 == 0) &#123; int k2 = k+1; double v2 = (double)FindKth(A, 0, m - 1, B, 0, n - 1, k2); v = (v + v2) / 2; &#125; return v; &#125; // find the kth element int the two sorted arrays // let us say: A[aMid] &lt;= B[bMid], x: mid len of a, y: mid len of b, then wen can know // // (1) there will be at least (x + 1 + y) elements before bMid // (2) there will be at least (m - x - 1 + n - y) = m + n - (x + y +1) elements after aMid // therefore // if k &lt;= x + y + 1, find the kth element in a and b, but unconsidering bMid and its suffix // if k &gt; x + y + 1, find the k - (x + 1) th element in a and b, but unconsidering aMid and its prefix int FindKth(int A[], int aL, int aR, int B[], int bL, int bR, int k) &#123; if (aL &gt; aR) return B[bL + k - 1]; if (bL &gt; bR) return A[aL + k - 1]; int aMid = (aL + aR) / 2; int bMid = (bL + bR) / 2; if (A[aMid] &lt;= B[bMid]) &#123; if (k &lt;= (aMid - aL) + (bMid - bL) + 1) return FindKth(A, aL, aR, B, bL, bMid - 1, k); else return FindKth(A, aMid + 1, aR, B, bL, bR, k - (aMid - aL) - 1); &#125; else &#123; // A[aMid] &gt; B[bMid] if (k &lt;= (aMid - aL) + (bMid - bL) + 1) return FindKth(A, aL, aMid - 1, B, bL, bR, k); else return FindKth(A, aL, aR, B, bMid + 1, bR, k - (bMid - bL) - 1); &#125; &#125; https://discuss.leetcode.com/topic/11478/o-lg-m-n-c-solution-using-kth-smallest-number O(lg(m+n)) c++ solution using kth smallest number 1234567891011121314151617181920212223class Solution &#123;public: int kth(int a[], int m, int b[], int n, int k) &#123; if (m &lt; n) return kth(b,n,a,m,k); if (n==0) return a[k-1]; if (k==1) return min(a[0],b[0]); int j = min(n,k/2); int i = k-j; if (a[i-1] &gt; b[j-1]) return kth(a,i,b+j,n-j,k-j); return kth(a+i,m-i,b,j,k-i); &#125; double findMedianSortedArrays(int a[], int m, int b[], int n) &#123; int k = (m+n)/2; int m1 = kth(a,m,b,n,k+1); if ((m+n)%2==0) &#123; int m2 = kth(a,m,b,n,k); return ((double)m1+m2)/2.0; &#125; return m1; &#125;&#125;; https://discuss.leetcode.com/topic/26926/another-simple-and-neat-solution-binary-search-non-recursion-3-rows-of-core-code-o-log-min-m-n Another simple and neat solution, binary search, non-recursion, 3 rows of core code, O(log(min(m, n))) If you solve the k-th minmum value of two sorted arrays, you solve this problem.This is a classical problem of â€œDivide and conquerâ€. Here is another more simple and more neat solution. Cosider chosing first x numbers from A and k - x numbers from B.if these k numbers are the k minmum numbers of A and B, x must satisfies that A[x + 1] &gt;= B[k - x] and B[k - x + 1] &gt;= A[x] (for better explanation index is base-1). So this x is what we want. Obviously, if A[x + 1] &lt; B[k - x + 1] then x must be smaller, else if B[k - x] &lt; A[x] then x must be greater. A nice two-value definition for binary search :) To simplify edge cases, we cosider each array indefinite, with value of INTMIN when index &lt; 1 and INTMAX when index &gt; n. Here is the solution of c++ version: 12345678910111213141516171819202122232425typedef vector&lt;int&gt; vi;const int inf = 0x7fffffff, ninf = 0x80000000;class Solution &#123; int kth_min(vi&amp; a, vi&amp; b, int k, int n, int m)&#123; #define A(i) (i &lt; 1 ? ninf : (i &gt; n ? inf : a[i - 1])) #define B(i) (i &lt; 1 ? ninf : (i &gt; m ? inf : b[i - 1])) int l = 0, r = n + 1, x; while(l &lt;= r)&#123; x = (l + r) &gt;&gt; 1; if(A(x) &gt; B(k - x + 1)) r = x - 1; else if(B(k - x) &gt; A(x + 1)) l = x + 1; else return max(A(x), B(k - x)); &#125; return 0; //never execute , just to hide the warning :) #undef A #undef B &#125;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123; int n = a.size(), m = b.size(); if(n &gt; m) return findMedianSortedArrays(b, a); //make sure that a.size() &lt;= b.size() if((m + n) &amp; 1) return kth_min(a, b, (m + n + 1) &gt;&gt; 1, n, m); return (0.0 + kth_min(a, b, (m + n + 1) &gt;&gt; 1, n, m) + kth_min(a, b, ((m + n) &gt;&gt; 1) + 1, n, m)) * 0.5; &#125;&#125;; python https://discuss.leetcode.com/topic/4996/share-my-o-log-min-m-n-solution-with-explanation To solve this problem, we need to understand â€œWhat is the use of medianâ€. In statistics, the median is used for dividing a set into two equal length subsets, that one subset is always greater than the other. If we understand the use of median for dividing, we are very close to the answer.1234First let&apos;s cut A into two parts at a random position i: left_A | right_AA[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] Since A has m elements, so there are m+1 kinds of cutting( i = 0 ~ m ). And we know: len(left_A) = i, len(right_A) = m - i . Note: when i = 0 , left_A is empty, and when i = m , right_A is empty.1234With the same way, cut B into two parts at a random position j: left_B | right_BB[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] Put left_A and left_B into one set, and put right_A and right_B into another set.1234Let&apos;s name them left_part and right_part : left_part | right_partA[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1]B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] If we can ensure:121) len(left_part) == len(right_part)2) max(left_part) &lt;= min(right_part) then we divide all elements in {A, B} into two parts with equal length, and one part is always greater than the other. Then median = (max(left_part) + min(right_part))/2. To ensure these two conditions, we just need to ensure:123(1) i + j == m - i + n - j (or: m - i + n - j + 1) if n &gt;= m, we just need to set: i = 0 ~ m, j = (m + n + 1)/2 - i(2) B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j] (For simplicity, I presume A[i-1],B[j-1],A[i],B[j] are always valid even if i=0/i=m/j=0/j=n . I will talk about how to deal with these edge values at last.) So, all we need to do is:12Searching i in [0, m], to find an object `i` that: B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j], ( where j = (m + n + 1)/2 - i ) And we can do a binary search following steps described below:123456789101112131415161718192021222324&lt;1&gt; Set imin = 0, imax = m, then start searching in [imin, imax]&lt;2&gt; Set i = (imin + imax)/2, j = (m + n + 1)/2 - i&lt;3&gt; Now we have len(left_part)==len(right_part). And there are only 3 situations that we may encounter: &lt;a&gt; B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j] Means we have found the object `i`, so stop searching. &lt;b&gt; B[j-1] &gt; A[i] Means A[i] is too small. We must `ajust` i to get `B[j-1] &lt;= A[i]`. Can we `increase` i? Yes. Because when i is increased, j will be decreased. So B[j-1] is decreased and A[i] is increased, and `B[j-1] &lt;= A[i]` may be satisfied. Can we `decrease` i? `No!` Because when i is decreased, j will be increased. So B[j-1] is increased and A[i] is decreased, and B[j-1] &lt;= A[i] will be never satisfied. So we must `increase` i. That is, we must ajust the searching range to [i+1, imax]. So, set imin = i+1, and goto &lt;2&gt;. &lt;c&gt; A[i-1] &gt; B[j] Means A[i-1] is too big. And we must `decrease` i to get `A[i-1]&lt;=B[j]`. That is, we must ajust the searching range to [imin, i-1]. So, set imax = i-1, and goto &lt;2&gt;. When the object i is found, the median is:12max(A[i-1], B[j-1]) (when m + n is odd) æ³¨é‡Š odd å¥‡æ•°or (max(A[i-1], B[j-1]) + min(A[i], B[j]))/2 (when m + n is even) Now letâ€™s consider the edges values i=0,i=m,j=0,j=n where A[i-1],B[j-1],A[i],B[j] may not exist. Actually this situation is easier than you think. What we need to do is ensuring that max(left_part) &lt;= min(right_part). So, if i and j are not edges values(means A[i-1],B[j-1],A[i],B[j] all exist), then we must check both B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]. But if some of A[i-1],B[j-1],A[i],B[j] donâ€™t exist, then we donâ€™t need to check one(or both) of these two conditions. For example, if i=0, then A[i-1] doesnâ€™t exist, then we donâ€™t need to check A[i-1] &lt;= B[j]. So, what we need to do is:123456789101112131415Searching i in [0, m], to find an object `i` that: (j == 0 or i == m or B[j-1] &lt;= A[i]) and (i == 0 or j == n or A[i-1] &lt;= B[j]) where j = (m + n + 1)/2 - iAnd in a searching loop, we will encounter only three situations:&lt;a&gt; (j == 0 or i == m or B[j-1] &lt;= A[i]) and (i == 0 or j = n or A[i-1] &lt;= B[j]) Means i is perfect, we can stop searching.&lt;b&gt; j &gt; 0 and i &lt; m and B[j - 1] &gt; A[i] Means i is too small, we must increase it.&lt;c&gt; i &gt; 0 and j &lt; n and A[i - 1] &gt; B[j] Means i is too big, we must decrease it. Thank @Quentin.chen , him pointed out that: i &lt; m ==&gt; j &gt; 0 and i &gt; 0 ==&gt; j &lt; n . Because:12m &lt;= n, i &lt; m ==&gt; j = (m+n+1)/2 - i &gt; (m+n+1)/2 - m &gt;= (2*m+1)/2 - m &gt;= 0 m &lt;= n, i &gt; 0 ==&gt; j = (m+n+1)/2 - i &lt; (m+n+1)/2 &lt;= (2*n+1)/2 &lt;= n So in situation and , we donâ€™t need to check whether j &gt; 0 and whether j &lt; n. Below is the accepted code:1234567891011121314151617181920212223242526272829303132def median(A, B): m, n = len(A), len(B) if m &gt; n: A, B, m, n = B, A, n, m if n == 0: raise ValueError imin, imax, half_len = 0, m, (m + n + 1) / 2 while imin &lt;= imax: i = (imin + imax) / 2 j = half_len - i if i &lt; m and B[j-1] &gt; A[i]: # i is too small, must increase it imin = i + 1 elif i &gt; 0 and A[i-1] &gt; B[j]: # i is too big, must decrease it imax = i - 1 else: # i is perfect if i == 0: max_of_left = B[j-1] elif j == 0: max_of_left = A[i-1] else: max_of_left = max(A[i-1], B[j-1]) if (m + n) % 2 == 1: return max_of_left if i == m: min_of_right = B[j] elif j == n: min_of_right = A[i] else: min_of_right = min(A[i], B[j]) return (max_of_left + min_of_right) / 2.0 https://leetcode.com/discuss/15790/share-my-o-log-min-m-n-solution-with-explanation 120ms, 86.12%, June.25th, 2016 12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def findMedianSortedArrays(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: float &quot;&quot;&quot; m, n = len(nums1), len(nums2) if m &gt; n: nums1, nums2, m, n = nums2, nums1, n, m if n == 0: raise ValueError imin, imax, half_len = 0, m, (m + n + 1) / 2 while imin &lt;= imax: i = (imin + imax) / 2 j = half_len - i if j &gt; 0 and i &lt; m and nums2[j-1] &gt; nums1[i]: # i is too small, must increase it imin = i + 1 elif i &gt; 0 and j &lt; n and nums1[i-1] &gt; nums2[j]: # i is too big, must decrease it imax = i - 1 else: # i is perfect if i == 0: max_of_left = nums2[j-1] elif j == 0: max_of_left = nums1[i-1] else: max_of_left = max(nums1[i-1], nums2[j-1]) if (m + n) % 2 == 1: return max_of_left if i == m: min_of_right = nums2[j] elif j == n: min_of_right = nums1[i] else: min_of_right = min(nums1[i], nums2[j]) return (max_of_left + min_of_right) / 2.0 https://leetcode.com/discuss/20897/intuitive-python-solution-smallest-two-sorted-arrays-252ms Intuitive Python O(log (m+n)) solution, by kth smallest in the two sorted arrays, 252ms 144ms, 30.79%, June.25th, 2016 The idea is in the comment: 12345678910111213141516171819202122232425262728293031class Solution(object): def findMedianSortedArrays(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: float &quot;&quot;&quot; l = len(nums1) + len(nums2) if l % 2 == 1: return self.kth(nums1, nums2, l // 2) else: return (self.kth(nums1, nums2, l // 2) + self.kth(nums1, nums2, l // 2 - 1)) / 2. def kth(self, a, b, k): if not a: return b[k] if not b: return a[k] ia, ib = len(a) // 2, len(b) // 2 ma, mb = a[ia], b[ib] if ia + ib &lt; k: if ma &gt; mb: return self.kth(a, b[ib + 1:], k - ib - 1) else: return self.kth(a[ia + 1:], b, k -ia - 1) else: if ma &gt; mb: return self.kth(a[:ia], b, k) else: return self.kth(a, b[:ib], k) https://discuss.leetcode.com/topic/22406/python-o-log-min-m-n-solution Python O(log(min(m,n)) solution Itâ€™s guaranteed to be O(log(min(m,n)) because every time the findKth function cuts the shorter array by half of its size. 123456789101112131415161718192021class Solution: # @return a float def findMedianSortedArrays(self, A, B): l=len(A)+len(B) return self.findKth(A,B,l//2) if l%2==1 else (self.findKth(A,B,l//2-1)+self.findKth(A,B,l//2))/2.0 def findKth(self,A,B,k): if len(A)&gt;len(B): A,B=B,A if not A: return B[k] if k==len(A)+len(B)-1: return max(A[-1],B[-1]) i=len(A)//2 j=k-i if A[i]&gt;B[j]: #Here I assume it is O(1) to get A[:i] and B[j:]. In python, it&apos;s not but in cpp it is. return self.findKth(A[:i],B[j:],i) else: return self.findKth(A[i:],B[:j],j) java https://discuss.leetcode.com/topic/3367/share-my-iterative-solution-with-o-log-min-n-m Share my iterative solution with O(log(min(n, m))) This is my iterative solution using binary search. The main idea is to find the approximate location of the median and compare the elements around it to get the final result. do binary search. suppose the shorter list is A with length n. the runtime is O(log(n)) which means no matter how large B array is, it only depends on the size of A. It makes sense because if A has only one element while B has 100 elements, the median must be one of A[0], B[49], and B[50] without check everything else. If A[0] &lt;= B[49], B[49] is the answer; if B[49] &lt; A[0] &lt;= B[50], A[0] is the answer; else, B[50] is the answer. After binary search, we get the approximate location of median. Now we just need to compare at most 4 elements to find the answer. This step is O(1). the same solution can be applied to find kth element of 2 sorted arrays. Here is the code: 123456789101112131415161718192021222324252627282930313233343536public double findMedianSortedArrays(int A[], int B[]) &#123;int n = A.length;int m = B.length;// the following call is to make sure len(A) &lt;= len(B).// yes, it calls itself, but at most once, shouldn&apos;t be// consider a recursive solutionif (n &gt; m) return findMedianSortedArrays(B, A);// now, do binary searchint k = (n + m - 1) / 2;int l = 0, r = Math.min(k, n); // r is n, NOT n-1, this is important!!while (l &lt; r) &#123; int midA = (l + r) / 2; int midB = k - midA; if (A[midA] &lt; B[midB]) l = midA + 1; else r = midA;&#125;// after binary search, we almost get the median because it must be between// these 4 numbers: A[l-1], A[l], B[k-l], and B[k-l+1] // if (n+m) is odd, the median is the larger one between A[l-1] and B[k-l].// and there are some corner cases we need to take care of.int a = Math.max(l &gt; 0 ? A[l - 1] : Integer.MIN_VALUE, k - l &gt;= 0 ? B[k - l] : Integer.MIN_VALUE);if (((n + m) &amp; 1) == 1) return (double) a;// if (n+m) is even, the median can be calculated by // median = (max(A[l-1], B[k-l]) + min(A[l], B[k-l+1]) / 2.0// also, there are some corner cases to take care of.int b = Math.min(l &lt; n ? A[l] : Integer.MAX_VALUE, k - l + 1 &lt; m ? B[k - l + 1] : Integer.MAX_VALUE);return (a + b) / 2.0;&#125; Iâ€™m lazy to type. But I found a very good pdf to explain my algorithm: http://ocw.alfaisal.edu/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/30C68118-E436-4FE3-8C79-6BAFBB07D935/0/ps9sol.pdf BTW: Thanks to xdxiaoxin. Iâ€™ve removed the check â€œmidB &gt; kâ€. https://discuss.leetcode.com/topic/28602/concise-java-solution-based-on-binary-search Concise JAVA solution based on Binary Search Explanation The key point of this problem is to ignore half part of A and B each step recursively by comparing the median of remaining A and B: 123if (aMid &lt; bMid) Keep [aRight + bLeft]else Keep [bRight + aLeft] As the following: time=O(log(m + n)) 123456789101112131415161718192021public double findMedianSortedArrays(int[] A, int[] B) &#123; int m = A.length, n = B.length; int l = (m + n + 1) / 2; int r = (m + n + 2) / 2; return (getkth(A, 0, B, 0, l) + getkth(A, 0, B, 0, r)) / 2.0; &#125;public double getkth(int[] A, int aStart, int[] B, int bStart, int k) &#123; if (aStart &gt; A.length - 1) return B[bStart + k - 1]; if (bStart &gt; B.length - 1) return A[aStart + k - 1]; if (k == 1) return Math.min(A[aStart], B[bStart]); int aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE; if (aStart + k/2 - 1 &lt; A.length) aMid = A[aStart + k/2 - 1]; if (bStart + k/2 - 1 &lt; B.length) bMid = B[bStart + k/2 - 1]; if (aMid &lt; bMid) return getkth(A, aStart + k/2, B, bStart, k - k/2);// Check: aRight + bLeft else return getkth(A, aStart, B, bStart + k/2, k - k/2);// Check: bRight + aLeft&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>medium</tag>
        <tag>divide and conquer</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[003. Longest Substring Without Repeating Characters]]></title>
    <url>%2Fp%2Ff34c3115%2F</url>
    <content type="text"><![CDATA[23.9% https://leetcode.com/problems/longest-substring-without-repeating-characters/ Given a string, find the length of the longest substring without repeating characters. Examples: Given â€œabcabcbbâ€, the answer is â€œabcâ€, which the length is 3. Given â€œbbbbbâ€, the answer is â€œbâ€, with the length of 1. Given â€œpwwkewâ€, the answer is â€œwkeâ€, with the length of 3. Note that the answer must be a substring, â€œpwkeâ€ is a subsequence and not a substring. leetcode 3 leetcode 76 leetcode 159 ç›¸ä¼¼ï¼Œæ¨¡æ¿ç›¸ä¼¼ï¼Œå­¦ä¹ ä¸€ä¸‹ æ–¹æ³•ä¸€ï¼š ä½¿ç”¨å“ˆå¸Œè¡¨ç»´æŠ¤å€¼å’Œå€¼çš„index æ–¹æ³•äºŒï¼š æ—¢ç„¶æ˜¯å¯¹æ•°å­—çš„å“ˆå¸Œï¼Œä¸å¦‚ä½¿ç”¨æ•°ç»„æ¥çš„æ–¹ä¾¿ã€‚ æˆ‘çš„ä»£ç å®žçŽ°ä¸€ï¼š å®žçŽ°æ•ˆæžœæœ€å¥½ã€‚ æœ€å¼€å§‹indexéƒ½æŒ‡å‘-1ï¼ŒæŒ‡å‘å¼€å§‹ç´¢å¼•çš„å‰ä¸€ä¸ªä½ç½®ï¼Œå°±æ˜¯-1ã€‚ ç„¶åŽstartå°±æ˜¯æŒ‡å‘ç´¢å¼•çš„å‰ä¸€ä¸ªä½ç½®ã€‚ ä¸€ä¸ªendä»Ž0å¼€å§‹éåŽ†è‡³æœ€åŽï¼ŒstartæŒ‡å‘å‰ä¸€ä¸ªä½ç½®ã€‚ æ›´æ–°æ—¶ï¼Œå…ˆæ›´æ–°startï¼Œç„¶åŽæ˜¯lengthï¼Œæœ€åŽæ›´æ–°ç´¢å¼•ï¼Œend++ã€‚ 1234567891011121314151617class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.size(); if(n&lt;=1) return n; vector&lt;int&gt; indexs(256, -1); int start = -1, end = 0, length=0; while(end &lt; n)&#123; start = max(start, indexs[s[end]]); length = max(length, end-start); indexs[s[end]] = end; end++; &#125; return length; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°äºŒï¼š å®žçŽ°é€»è¾‘æ¸…æ™°ï¼Œä½†æ˜¯ä¸å¦‚ä¸Šé¢ä»£ç ã€‚ å­—ç¬¦è¦ç”¨256ä½ï¼Œä¸è¦ç”¨26ä½ã€‚ 12345678910111213141516171819class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int res = 0; int start = 0; vector&lt;int&gt; v(256, -1); for(int i=0; i&lt;s.size(); i++)&#123; if(v[s[i]]!=-1)&#123; start = max(start, v[s[i]]+1); res = max(res, i-start+1); v[s[i]] = i; &#125;else&#123; res = max(res, i-start+1); v[s[i]] = i; &#125; &#125; return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°: 123456789101112131415class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; indexs(256, -1); int length = 0, start = -1, end = 0; int n = s.size(); while(end&lt;n)&#123; start = max(start, indexs[s[end]]); length = max(length, end-start); indexs[s[end]] = end; end++; &#125; return length; &#125;&#125;; code 1ï¼š https://discuss.leetcode.com/topic/4083/shortest-o-n-dp-solution-with-explanations Shortest O(n) DP solution with explanations 12345678910111213141516171819202122232425262728293031323334/** * Solution (DP, O(n)): * * Assume L[i] = s[m...i], denotes the longest substring without repeating * characters that ends up at s[i], and we keep a hashmap for every * characters between m ... i, while storing &lt;character, index&gt; in the * hashmap. * We know that each character will appear only once. * Then to find s[i+1]: * 1) if s[i+1] does not appear in hashmap * we can just add s[i+1] to hash map. and L[i+1] = s[m...i+1] * 2) if s[i+1] exists in hashmap, and the hashmap value (the index) is k * let m = max(m, k), then L[i+1] = s[m...i+1], we also need to update * entry in hashmap to mark the latest occurency of s[i+1]. * * Since we scan the string for only once, and the &apos;m&apos; will also move from * beginning to end for at most once. Overall complexity is O(n). * * If characters are all in ASCII, we could use array to mimic hashmap. */int lengthOfLongestSubstring(string s) &#123; // for ASCII char sequence, use this as a hashmap vector&lt;int&gt; charIndex(256, -1); int longest = 0, m = 0; for (int i = 0; i &lt; s.length(); i++) &#123; m = max(charIndex[s[i]] + 1, m); // automatically takes care of -1 case charIndex[s[i]] = i; longest = max(longest, i - m + 1); &#125; return longest;&#125; code 2ï¼š start è¡¨ç¤ºæœ€é•¿å­—ç¬¦ä¸²èµ·å§‹çš„ä½ç½®ã€‚ iè¡¨ç¤ºç»ˆæ­¢çš„ä½ç½®ï¼Œæˆ–è€…è¯´å½“å‰åˆ°è¾¾çš„ä½ç½®ã€‚ 1234567891011121314class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; dict(256, -1); int maxLen = 0, start = -1; for (int i = 0; i != s.length(); i++) &#123; if (dict[s[i]] &gt; start) start = dict[s[i]]; dict[s[i]] = i; maxLen = max(maxLen, i - start); &#125; return maxLen; &#125;&#125;; æ–¹æ³•ä¸‰ï¼š æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516171819202122class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int start = 0, length = 0, end = 0, cnt = 0; vector&lt;int&gt; v(256, 0); int n = s.size(); while(end&lt;n)&#123; if(v[s[end]]==1) cnt++; v[s[end]]++; end++; while(cnt&gt;0)&#123; if(v[s[start]]==2) cnt--; v[s[start]]--; start++; &#125; length = max(length, end-start); &#125; return length; &#125;&#125;; æœ‰æ¨¡æ¿çš„ï¼Œä¸‹é¢æ˜¯è¯¦æƒ… 12345678910int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; map(128,0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++&gt;0) counter++; while(counter&gt;0) if(map[s[begin++]]--&gt;1) counter--; d=max(d, end-begin); //while valid, update d &#125; return d; &#125; æˆ‘çš„ä»£ç å®žçŽ°ä¸€ï¼š 1234567891011121314151617181920212223class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.size(); if(n&lt;=1) return n; vector&lt;int&gt; indexs(256, 0); int left = 0, right = 0, counter = 0, length = 0; while(right&lt;n)&#123; if(indexs[s[right]]&gt;0) counter++; indexs[s[right]]++; right++; while(counter&gt;0)&#123; if(indexs[s[left]]&gt;1) counter--; indexs[s[left]]--; left++; &#125; length = max(length, right-left); &#125; return length; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°äºŒï¼š 1234567891011121314151617181920212223class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; if(s.empty()) return 0; int head = 0, end = 0, d = 0, cnt = 0; vector&lt;int&gt; v(256, 0); while(end &lt; s.size())&#123; if(v[s[end]]!=0) cnt++; v[s[end]]++; end++; while(cnt&gt;0)&#123; if(v[s[head]]&gt;1) cnt--; v[s[head]]--; head++; &#125; d = max(d, end - head); &#125; return d; &#125;&#125;; å­¦ä¹ åŒºï¼š https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems I will first give the solution then show you the magic template. The code of solving this problem is below. It might be the shortest among all solutions provided in Discuss. Minimum Window Substring 12345678910111213string minWindow(string s, string t) &#123; vector&lt;int&gt; map(128,0); for(auto c: t) map[c]++; int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0; while(end&lt;s.size())&#123; if(map[s[end++]]--&gt;0) counter--; //in t while(counter==0)&#123; //valid if(end-begin&lt;d) d=end-(head=begin); if(map[s[begin++]]++==0) counter++; //make it invalid &#125; &#125; return d==INT_MAX? &quot;&quot;:s.substr(head, d); &#125; Here comes the template. For most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers. The template is given below. 12345678910111213141516171819202122232425int findSubstring(string s)&#123; vector&lt;int&gt; map(128,0); int counter; // check whether the substring is valid int begin=0, end=0; //two pointers, one point to tail and one head int d; //the length of substring for() &#123; /* initialize the hash map here */ &#125; while(end&lt;s.size())&#123; if(map[s[end++]]-- ?)&#123; /* modify counter here */ &#125; while(/* counter condition */)&#123; /* update d here if finding minimum*/ //increase begin to make it invalid/valid again if(map[s[begin++]]++ ?)&#123; /*modify counter here*/ &#125; &#125; /* update d here if finding maximum*/ &#125; return d; &#125; One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop. The code of solving Longest Substring with At Most Two Distinct Characters is below: 12345678910int lengthOfLongestSubstringTwoDistinct(string s) &#123; vector&lt;int&gt; map(128, 0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++==0) counter++; while(counter&gt;2) if(map[s[begin++]]--==1) counter--; d=max(d, end-begin); &#125; return d; &#125; The code of solving Longest Substring Without Repeating Characters is below: Update 01.04.2016, thanks @weiyi3 for advise. 12345678910int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; map(128,0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++&gt;0) counter++; while(counter&gt;0) if(map[s[begin++]]--&gt;1) counter--; d=max(d, end-begin); //while valid, update d &#125; return d; &#125; I think this post deserves some upvotes! : ) https://discuss.leetcode.com/topic/24739/c-code-in-9-lines 16ms, 62.39%, 23 July 2016 1234567891011121314class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; dict(256, -1); int maxLen = 0, start = -1; for (int i = 0; i != s.length(); i++) &#123; if (dict[s[i]] &gt; start) start = dict[s[i]]; dict[s[i]] = i; maxLen = max(maxLen, i - start); &#125; return maxLen; &#125;&#125;; https://discuss.leetcode.com/topic/1914/my-o-n-solution My O(n) Solution if only use DP, itâ€™s an O(n*n) solution, adding a map to get O(n). 1234567891011121314151617181920class Solution &#123; public: int lengthOfLongestSubstring(string s) &#123; if(s.size()&lt;2) return s.size(); int d=1, maxLen=1; unordered_map&lt;char,int&gt; map; map[s[0]]=0; for(int i=1;i&lt;s.size();i++) &#123; if(map.count(s[i])==0 || map[s[i]]&lt;i-d) d++; else d= i- map[s[i]]; map[s[i]]=i; if(d&gt;maxLen) maxLen = d; &#125; return maxLen; &#125; &#125;; python https://discuss.leetcode.com/topic/11632/a-python-solution-85ms-o-n 104ms, 84.17%, 23 July 2016 1234567891011121314151617class Solution(object): def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; start = maxLength = 0 usedChar = &#123;&#125; for i in range(len(s)): if s[i] in usedChar and start &lt;= usedChar[s[i]]: start = usedChar[s[i]] + 1 else: maxLength = max(maxLength, i - start + 1) usedChar[s[i]] = i return maxLength java https://discuss.leetcode.com/topic/8232/11-line-simple-java-solution-o-n-with-explanation 11-line simple Java solution, O(n) with explanation the basic idea is, keep a hashmap which stores the characters in string as keys and their positions as values, and keep two pointers which define the max substring. move the right pointer to scan through the string , and meanwhile update the hashmap. If the character is already in the hashmap, then move the left pointer to the right of the same character last found. Note that the two pointers can only move forward. 12345678910111213public int lengthOfLongestSubstring(String s) &#123; if (s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max=0; for (int i=0, j=0; i&lt;s.length(); ++i)&#123; if (map.containsKey(s.charAt(i)))&#123; j = Math.max(j,map.get(s.charAt(i))+1); &#125; map.put(s.charAt(i),i); max = Math.max(max,i-j+1); &#125; return max;&#125; https://discuss.leetcode.com/topic/25499/share-my-java-solution-using-hashset Share my Java solution using HashSet The idea is use a hash set to track the longest substring without repeating characters so far, use a fast pointer j to see if character j is in the hash set or not, if not, great, add it to the hash set, move j forward and update the max length, otherwise, delete from the head by using a slow pointer i until we can put character j to the hash set. 123456789101112131415public int lengthOfLongestSubstring(String s) &#123; int i = 0, j = 0, max = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); while (j &lt; s.length()) &#123; if (!set.contains(s.charAt(j))) &#123; set.add(s.charAt(j++)); max = Math.max(max, set.size()); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return max;&#125; https://leetcode.com/articles/longest-substring-without-repeating-characters/ æ€è·¯ï¼šåŒæŒ‡é’ˆï¼Œjåœ¨å‰ï¼Œiåœ¨åŽï¼Œå¦‚æžœs[j]ä¸åŒ…å«ï¼Œåˆ™æ·»åŠ è¿›å“ˆå¸Œè¡¨ï¼Œå¦‚æžœåŒ…å«ï¼Œåˆ™åŽ»æŽ‰iï¼Œiå‘åŽèµ°ã€‚123456789101112131415161718public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int ans = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) &#123; // try to extend the range [i, j] if (!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans, j - i); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return ans; &#125;&#125; æ€è·¯ï¼šå»ºç«‹mapï¼Œä¸ä»…å­˜å­—ç¬¦è¿˜å­˜å­—ç¬¦çš„ä½ç½® 123456789101112131415public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) &#123; if (map.containsKey(s.charAt(j))) &#123; i = Math.max(map.get(s.charAt(j)), i); &#125; ans = Math.max(ans, j - i + 1); map.put(s.charAt(j), j + 1); &#125; return ans; &#125;&#125; ä¸Žä¸Šä¸€æ®µä»£ç æ€è·¯ç›¸åŒ ä¸€ä¸ªæ˜¯lengthä¸º0ï¼Œreturn 0ï¼Œæ£€æŸ¥ç‰¹æ®Šæƒ…å†µã€‚ ä¸€ä¸ªæ˜¯åšä¸€ä¸ªhashmapï¼Œå­˜å…¥èŽ·å–çš„æ“ä½œè¦å¥½å¥½çœ‹çœ‹ã€‚ 22ms, 31.97%, 23 July 2016 https://discuss.leetcode.com/topic/8232/11-line-simple-java-solution-o-n-with-explanation/11234567891011121314public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max = 0; for(int i=0, j=0; i &lt; s.length(); ++i)&#123; if(map.containsKey(s.charAt(i))) j = Math.max(j, map.get(s.charAt(i))+1); map.put(s.charAt(i), i); max = Math.max(max, i-j+1); &#125; return max; &#125;&#125; The previous implements all have no assumption on the charset of the string s. If we know that the charset is rather small, we can replace the Map with an integer array as direct access table. Commonly used tables are: 123int[26] for Letters &apos;a&apos; - &apos;z&apos; or &apos;A&apos; - &apos;Z&apos;int[128] for ASCIIint[256] for Extended ASCII 12345678910111213public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; int[] index = new int[128]; // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) &#123; i = Math.max(index[s.charAt(j)], i); ans = Math.max(ans, j - i + 1); index[s.charAt(j)] = j + 1; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[002. Add Two Numbers]]></title>
    <url>%2Fp%2F7dbbe8ef%2F</url>
    <content type="text"><![CDATA[26.7% https://leetcode.com/problems/add-two-numbers/ You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. 12Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 æ–¹æ³•ä¸€ï¼š 12345678910111213141516class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while(l1 || l2 || extra)&#123; int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + extra; extra = sum / 10; p-&gt;next = new ListNode(sum % 10); p = p-&gt;next; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; &#125; return preHead.next; &#125;&#125;; How about this? 123456789101112ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while (l1 || l2 || extra) &#123; if (l1) extra += l1-&gt;val, l1 = l1-&gt;next; if (l2) extra += l2-&gt;val, l2 = l2-&gt;next; p-&gt;next = new ListNode(extra % 10); extra /= 10; p = p-&gt;next; &#125; return preHead.next;&#125; æˆ‘çš„ä»£ç å®žçŽ°ä¸€ï¼š 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; if(!l1) return l2; else if(!l2) return l1; int carry = 0; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 || l2 || carry)&#123; carry += l1 ? l1-&gt;val : 0; carry += l2 ? l2-&gt;val : 0; cur-&gt;next = new ListNode(carry%10); cur = cur-&gt;next; carry /= 10; l1 = l1 ? l1-&gt;next : 0; l2 = l2 ? l2-&gt;next : 0; &#125; return dummy-&gt;next; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°äºŒï¼š 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); int carry = 0; ListNode* cur = dummy; while(l1 || l2 || carry)&#123; carry += l1 ? l1-&gt;val : 0; carry += l2 ? l2-&gt;val : 0; cur-&gt;next = new ListNode(carry%10); carry /= 10; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; cur = cur-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/5905/c-sharing-my-11-line-c-solution-can-someone-make-it-even-more-concise 40ms, 24.98%, 17 July 2016 12345678910111213141516class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while(l1 || l2 || extra)&#123; int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + extra; extra = sum / 10; p-&gt;next = new ListNode(sum % 10); p = p-&gt;next; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; &#125; return preHead.next; &#125;&#125;; https://discuss.leetcode.com/topic/5905/c-sharing-my-11-line-c-solution-can-someone-make-it-even-more-concise/4 How about this? 123456789101112ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while (l1 || l2 || extra) &#123; if (l1) extra += l1-&gt;val, l1 = l1-&gt;next; if (l2) extra += l2-&gt;val, l2 = l2-&gt;next; p-&gt;next = new ListNode(extra % 10); extra /= 10; p = p-&gt;next; &#125; return preHead.next;&#125; python https://discuss.leetcode.com/topic/21192/python-concise-solution 188ms, 7.15%, 17 July 2016 Python concise solution. 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; dummy = cur = ListNode(0) carry = 0 while l1 or l2 or carry: if l1: carry += l1.val l1 = l1.next if l2: carry += l2.val l2 = l2.next cur.next = ListNode(carry%10) cur = cur.next carry //= 10 return dummy.next https://discuss.leetcode.com/topic/8909/clear-python-code-straight-forward 172ms, 15.49%, 17 July 2016 Clear python code, straight forward 123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; carry = 0 root = n = ListNode(0) while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry, 10) n.next = ListNode(val) n = n.next return root.next https://discuss.leetcode.com/topic/8909/clear-python-code-straight-forward 1234567891011121314151617class Solution:# @return a ListNodedef addTwoNumbers(self, l1, l2): carry = 0 root = n = ListNode(0) while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry, 10) n.next = ListNode(val) n = n.next return root.next https://discuss.leetcode.com/topic/14575/python-for-the-win Python for the win Python supports arbitrarily large integers, so I can safely turn the two lists into ints, add them, and turn the sum into a list. 12345678910class Solution: def addTwoNumbers(self, l1, l2): def toint(node): return node.val + 10 * toint(node.next) if node else 0 def tolist(n): node = ListNode(n % 10) if n &gt; 9: node.next = tolist(n / 10) return node return tolist(toint(l1) + toint(l2)) Iterative tolist instead of recursive: 12345678910class Solution: def addTwoNumbers(self, l1, l2): def toint(node): return node.val + 10 * toint(node.next) if node else 0 n = toint(l1) + toint(l2) first = last = ListNode(n % 10) while n &gt; 9: n /= 10 last.next = last = ListNode(n % 10) return first And a very different solution that could sum arbitrarily many addends, not just two: 1234567891011class Solution: def addTwoNumbers(self, l1, l2): addends = l1, l2 dummy = end = ListNode(0) carry = 0 while addends or carry: carry += sum(a.val for a in addends) addends = [a.next for a in addends if a.next] end.next = end = ListNode(carry % 10) carry /= 10 return dummy.next java https://leetcode.com/articles/add-two-numbers/ Time complexity : O(\max(m, n))O(max(m,n)). Assume that mm and nn represents the length of l1l1 and l2l2 respectively, the algorithm above iterates at most \max(m, n)max(m,n) times. Space complexity : O(\max(m, n))O(max(m,n)). The length of the new list is at most \max(m,n) + 1max(m,n)+1. 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next; &#125;&#125; 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode c1 = l1; ListNode c2 = l2; ListNode sentinel = new ListNode(0); ListNode d = sentinel; int sum = 0; while (c1 != null || c2 != null) &#123; sum /= 10; if (c1 != null) &#123; sum += c1.val; c1 = c1.next; &#125; if (c2 != null) &#123; sum += c2.val; c2 = c2.next; &#125; d.next = new ListNode(sum % 10); d = d.next; &#125; if (sum / 10 == 1) d.next = new ListNode(1); return sentinel.next; &#125;&#125; https://discuss.leetcode.com/topic/799/is-this-algorithm-optimal-or-what Is this Algorithm optimal or what? 12345678910111213141516171819202122232425public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode c1 = l1; ListNode c2 = l2; ListNode sentinel = new ListNode(0); ListNode d = sentinel; int sum = 0; while (c1 != null || c2 != null) &#123; sum /= 10; if (c1 != null) &#123; sum += c1.val; c1 = c1.next; &#125; if (c2 != null) &#123; sum += c2.val; c2 = c2.next; &#125; d.next = new ListNode(sum % 10); d = d.next; &#125; if (sum / 10 == 1) d.next = new ListNode(1); return sentinel.next; &#125;&#125; https://discuss.leetcode.com/topic/6220/my-accepted-java-solution My accepted Java solution Two things to make the code simple: Whenever one of the two ListNode is null, replace it with 0. Keep the while loop going when at least one of the three conditions is met. Let me know if there is something wrong. Thanks. 12345678910111213141516171819public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode prev = new ListNode(0); ListNode head = prev; int carry = 0; while (l1 != null || l2 != null || carry != 0) &#123; ListNode cur = new ListNode(0); int sum = ((l2 == null) ? 0 : l2.val) + ((l1 == null) ? 0 : l1.val) + carry; cur.val = sum % 10; carry = sum / 10; prev.next = cur; prev = cur; l1 = (l1 == null) ? l1 : l1.next; l2 = (l2 == null) ? l2 : l2.next; &#125; return head.next; &#125;&#125; https://discuss.leetcode.com/topic/39130/4ms-11lines-java-solution 4ms 11lines java solution 1234567891011121314151617public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode ln1 = l1, ln2 = l2, head = null, node = null; int carry = 0, remainder = 0, sum = 0; head = node = new ListNode(0); while(ln1 != null || ln2 != null || carry != 0) &#123; sum = (ln1 != null ? ln1.val : 0) + (ln2 != null ? ln2.val : 0) + carry; carry = sum / 10; remainder = sum % 10; node = node.next = new ListNode(remainder); ln1 = (ln1 != null ? ln1.next : null); ln2 = (ln2 != null ? ln2.next : null); &#125; return head.next; &#125;&#125; https://discuss.leetcode.com/topic/44133/java-concise-solution Java concise solution. 12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int carry = 0; ListNode p, dummy = new ListNode(0); p = dummy; while (l1 != null || l2 != null || carry != 0) &#123; if (l1 != null) &#123; carry += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; carry += l2.val; l2 = l2.next; &#125; p.next = new ListNode(carry%10); carry /= 10; p = p.next; &#125; return dummy.next;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[001. Two Sum]]></title>
    <url>%2Fp%2F6bed6d6%2F</url>
    <content type="text"><![CDATA[31.0% https://leetcode.com/problems/two-sum/ Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. 12345Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. UPDATE (2016/2/13): The return format had been changed to zero-based indices. Please read the above updated description carefully. æ€è·¯ æ–¹æ³•ä¸€ï¼š dic, å…¨éƒ¨éƒ½æ”¾å…¥dic, ä¾æ¬¡éåŽ†ï¼ŒæŸ¥æ‰¾å½“å‰å€¼targetç¼ºçš„é‚£éƒ¨åˆ†ï¼Œè¦ç¼ºçš„indexå¤§äºŽå½“å‰çš„indexã€‚ 1234567891011121314151617181920// é¢è¯•å¥‡è™Ž360æ—¶æ›¾é‡åˆ°è¿‡ // beats 45.40% of cppsubmissions.class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; mapping; vector&lt;int&gt; result; for(int i = 0; i &lt; nums.size(); i++)&#123; mapping[nums[i]] = i; &#125; for(int i = 0; i &lt; nums.size(); i++)&#123; const int gap = target - nums[i]; if(mapping.find(gap) != mapping.end() &amp;&amp; mapping[gap] &gt; i)&#123; result.push_back(i); result.push_back(mapping[gap]); &#125; &#125; return result; &#125;&#125;; æ–¹æ³•äºŒï¼š ä¸€ééåŽ†ï¼Œä¸€è¾¹æ”¾å…¥dic my code: 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res; unordered_map&lt;int, int&gt; map; for(int i=0; i&lt;nums.size(); i++)&#123; int nex = target - nums[i]; if(map.find(nex)!=map.end())&#123; res.push_back(i); res.push_back(map[nex]); break; &#125;else&#123; map[nums[i]] = i; &#125; &#125; return res; &#125;&#125;; æˆ‘çš„ä»£ç å®žçŽ°ï¼š 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2, -1); unordered_map&lt;int, int&gt; map; for(int i=0; i&lt;nums.size(); i++)&#123; int gap = target - nums[i]; if(map.count(gap))&#123; res[0] = map[gap]; res[1] = i; return res; &#125;else map[nums[i]] = i; &#125; &#125;&#125;; 48ms, 59.36%, Apr.23rd, 2016 æ‰¾å‡ºæ•°ç»„ä¸­çš„ä¸¤ä¸ªæ•°ï¼Œè¿™ä¸¤ä¸ªæ•°å’Œä¸ºtarget æ‰«åˆ°xæ—¶çœ‹å‰é¢Hashçš„æ•°é‡Œæœ‰æ²¡æœ‰target-xï¼Œç„¶åŽå°†xä¹Ÿæ”¾è¿›Hashè¡¨ã€‚ 12345678910111213class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; dict = &#123;&#125; for i in range(len(nums)): if dict.get(target - nums[i], None) == None: dict[nums[i]] = i else: return (dict[target - nums[i]], i) my code 123456789101112class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; maps = &#123;&#125; for i, num in enumerate(nums): if target-num in maps: return [i, maps[target-num]] maps[num] = i ä¸‹é¢è¿™ä¸ªæ–¹æ³•é€Ÿåº¦ç‰¹æ…¢ï¼ŒåŽŸå› :å¯¹æ¯ä¸ªå…ƒç´ éƒ½è¿›è¡Œäº†å“ˆå¸Œï¼Œæ€»ä¹‹ï¼Œæ— è®ºå»ºç«‹è¿˜æ˜¯æŸ¥æ‰¾éƒ½è´¹äº†æ—¶é—´ã€‚ ä¸Šé¢ä¸€ç§æ–¹æ³•ï¼Œæ³¨æ„ï¼Œpythonå­—å…¸æœ‰getæ–¹æ³• 1234567891011class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; dict = &#123;n: i for i, n in enumerate(nums)&#125; for i, n in enumerate(nums): if target-n in dict.keys() and dict[target-n] != i: return [i, dict[target-n]] java https://leetcode.com/articles/two-sum/ Approach #2 (Two-pass Hash Table) [Accepted] To improve our run time complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to look up its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table. We reduce the look up time from O(n)O(n) to O(1)O(1) by trading space for speed. A hash table is built exactly for this purpose, it supports fast look up in near constant time. I say â€œnearâ€ because if a collision occurred, a look up could degenerate to O(n)O(n) time. But look up in hash table should be amortized O(1)O(1) time as long as the hash function was chosen carefully. A simple implementation uses two iterations. In the first iteration, we add each elementâ€™s value and its index to the table. Then, in the second iteration we check if each elementâ€™s complement (target - nums[i]targetâˆ’nums[i]) exists in the table. Beware that the complement must not be nums[i]nums[i] itself!12345678910111213public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;);&#125; Complexity Analysis: Time complexity : O(n)O(n). We traverse the list containing nn elements exactly twice. Since the hash table reduces the look up time to O(1)O(1), the time complexity is O(n)O(n). Space complexity : O(n)O(n). The extra space required depends on the number of items stored in the hash table, which stores exactly nn elements. Approach #3 (One-pass Hash Table) [Accepted] It turns out we can do it in one-pass. While we iterate and inserting elements into the table, we also look back to check if current elementâ€™s complement already exists in the table. If it exists, we have found a solution and return immediately.1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;);&#125; Complexity Analysis: Time complexity : O(n)O(n). We traverse the list containing nn elements only once. Each look up in the table costs only O(1)O(1) time. Space complexity : O(n)O(n). The extra space required depends on the number of items stored in the hash table, which stores at most nn elements.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€ŠMulti-objective Learning and Mask-based Post-processing for Deep Neural Network based Speech Enhancementã€‹é˜…è¯»ç¬”è®°]]></title>
    <url>%2Fp%2F719f3cc0%2F</url>
    <content type="text"><![CDATA[è¿™æ˜¯2017å¹´Xu Yongå…³äºŽä½¿ç”¨å¤šä»»åŠ¡å­¦ä¹ å’Œä½¿ç”¨maskåšåŽå¤„ç†åšè¯­éŸ³å¢žå¼ºçš„ä¸€ç¯‡è®ºæ–‡[1]ã€‚ åŒæ ·æœ‰githubæºç [2]åŠå±•ç¤ºdemo[3,4]ã€‚ è®ºæ–‡åŽŸæ–‡ï¼šMulti-objective Learning and Mask-based Post-processing for Deep Neural Network based Speech Enhancement 1. Abstractè®ºæ–‡ä¸»è¦çš„å­¦ä¹ ç›®æ ‡æ˜¯clean log-power spectra (LPS) featuresï¼Œå› ä¸ºLPSå¯ä»¥ç›´æŽ¥ç”¨äºŽæž„é€ å¢žå¼ºåŽçš„ä¿¡å·ã€‚ä½œä¸ºå¤šä»»åŠ¡å­¦ä¹ ï¼Œä½¿ç”¨äº†é™„åŠ çš„æž¶æž„ï¼ŒåŽ»å­¦ä¹ æ¯”å¦‚MFCCç‰¹å¾ï¼ŒåŒæ—¶åŽ»å­¦ä¹ ç±»åˆ«ä¿¡æ¯ï¼Œæ¯”å¦‚ideal binary mask (IBM)ã€‚è¿™äº›ç‰¹å¾å…¶å®žä¹Ÿæ˜¯å¯¹DNNçš„ä¸€ç§é™åˆ¶ï¼Œæ½œåœ¨çš„èƒ½æé«˜LPSè¿™ä¸ªé¦–è¦ç›®æ ‡çš„æ•ˆæžœã€‚ 2. Introduction3. Multi-objective Learning for DNN-based Speech Enhancementå¤šä»»åŠ¡å­¦ä¹ æ¡†æž¶å¦‚ä¸‹å›¾å›¾1æ‰€ç¤ºï¼š è¾“å…¥æ˜¯å¸¦å™ªè¯­éŸ³ä¿¡å·ï¼Œè¾“å‡ºæ˜¯å¹²å‡€éŸ³é¢‘ä¿¡å·ã€‚åªæ˜¯è¾“å…¥è¾“å‡ºæœ‰æ—¶æœ‰å¸¦å™ªçš„ç‰¹å¾ï¼Œè¾“å‡ºæ˜¯å¹²å‡€çš„ç‰¹å¾ã€‚è¾“å‡ºæœ‰æ—¶æœ‰ç±»åˆ«ä¿¡æ¯ã€‚ å…¬å¼2æ˜¯å•ç‹¬çš„dnn+LPSè®­ç»ƒçš„è¯¯å·®å‡½æ•°ï¼Œå…¬å¼3æ˜¯å¤šè¾“å‡ºçš„ã€‚ 3.1 Joint Prediction of LPS with MFCCè¿™ä¸ªå°±æ˜¯LPSå’ŒMFCCä¸¤ä¸ªçš„å¤šè¾“å‡ºäº†ã€‚ 3.2 Joint Prediction of LPS with IBMåŒä¸Šï¼ŒLPS+IBM 3.3 IBM-based Post-processingIBMç”¨äºŽLPSçš„åŽå¤„ç†ã€‚å¦‚å…¬å¼3ï¼Œå¦‚æžœIBMå¤§äºŽä¸€å®šé˜ˆå€¼ï¼Œè¯´æ˜ŽSNRå¾ˆé«˜ï¼Œå°±ä¸å¿…åšè¯­éŸ³å¢žå¼ºäº†ï¼Œæ‰€ä»¥ç›´æŽ¥ç”¨åŽŸå§‹çš„è¯­éŸ³ä¿¡æ¯ã€‚å¦‚æžœä¸­é—´å°±æ˜¯åŽŸå§‹ä¿¡æ¯å’Œå¢žå¼ºåŽçš„ä¿¡æ¯çš„å‡å€¼ã€‚å¦‚æžœä½ŽäºŽä¸€å®šé˜ˆå€¼ï¼Œå°±æ˜¯ä½¿ç”¨å¤„ç†åŽçš„ä¿¡æ¯ã€‚ 4. Experimental Results and Analysis 5. Conclusionæœ¬æ–‡æå‡ºäº†å¤šç›®æ ‡å­¦ä¹ ä»¥æ”¹å–„è¯­éŸ³å¢žå¼ºçš„DNNè®­ç»ƒã€‚ æ˜¾ç¤ºç›®æ ‡å‡½æ•°ä¸­æ·»åŠ æ¥è‡ªMFCCæˆ–IBMç­‰åŠŸèƒ½çš„çº¦æŸå¯èŽ·å¾—æ›´å‡†ç¡®çš„å¹²å‡€çš„LPSä¼°è®¡ã€‚ MFCCå¯ä»¥ä½¿å¯¹æ•°é¢‘è°±å¤±çœŸåœ¨ä½Žé¢‘ä¸‹æ›´åŠ ä¸€è‡´; IBMå¯ä»¥æ˜Žç¡®è¡¨ç¤ºT-Få•å…ƒçš„è¯­éŸ³å‘ˆçŽ°ä¿¡æ¯ï¼Œå› æ­¤å¯ä»¥æä¾›æ›´é«˜çš„SSNRã€‚ æ­¤å¤–ï¼Œå¯ä»¥é‡‡ç”¨ä¼°è®¡çš„IBMæ¥è¿›è¡ŒåŽæœŸå¤„ç†ï¼Œä»¥å‡è½»åŸºäºŽå›žå½’çš„DNNä¸­çš„é«˜ä¼°æˆ–ä½Žä¼°é—®é¢˜ã€‚ åŸºäºŽIBMçš„åŽå¤„ç†å¯¹äºŽå‡å°‘è¯­éŸ³å¤±çœŸè‡³å…³é‡è¦ï¼Œç‰¹åˆ«æ˜¯åœ¨é«˜ä¿¡å™ªæ¯”T-Få•å…ƒã€‚ å‚è€ƒèµ„æ–™ï¼š https://arxiv.org/abs/1703.07172 https://github.com/yongxuUSTC/sednn http://staff.ustc.edu.cn/~jundu/The%20team/yongxu/demo/SE_DNN_taslp.html http://staff.ustc.edu.cn/~jundu/The%20team/yongxu/demo/IS15.html http://yucc.me/p/719f3cc0/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AIä¸€ä¸ä¸€æ¯«</tag>
        <tag>speech enhancement</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€ŠSEGAN: Speech Enhancement Generative Adversarial Networkã€‹é˜…è¯»ç¬”è®°]]></title>
    <url>%2Fp%2Fbea139a%2F</url>
    <content type="text"><![CDATA[æœ¬è®ºæ–‡æ˜¯2017å¹´çš„ä¸€ç¯‡ä½¿ç”¨GANç½‘ç»œåšå•å£°é“è¯­éŸ³å¢žå¼ºçš„è®ºæ–‡[1]ï¼Œåœ¨githubä¸Šæœ‰ä½œè€…çš„å¼€æºä»£ç [2]ï¼Œè¯­éŸ³å¢žå¼ºçš„æ•ˆæžœæœ‰å®˜æ–¹ç¤ºä¾‹[3]ã€‚ è®ºæ–‡åŽŸæ–‡ï¼šSEGAN: Speech Enhancement Generative Adversarial Network 1. Introductionç»å…¸çš„è¯­éŸ³å¢žå¼ºï¼ˆspeech enhancementï¼‰æ–¹æ³•æœ‰è°±å‡æ³•ï¼ˆspectral subtractionï¼‰ã€ç»´çº³æ»¤æ³¢ï¼ˆWiener filteringï¼‰ã€ç»Ÿè®¡æ¨¡åž‹ï¼ˆstatistical model-based methodsï¼‰å’Œå­ç©ºé—´ç®—æ³•ï¼ˆsubspace algorithmsï¼‰ã€‚ å…¶ä¸­ç»Ÿè®¡æ¨¡åž‹æœ‰æœ€å¤§ä¼¼ç„¶ã€è´å¶æ–¯ã€MMSEåŠLog-MMSEã€‚ è®ºæ–‡ç»™äºˆGANç½‘ç»œï¼ˆGenerative Adversarial Networksï¼‰æå‡ºäº†seganï¼ˆspeech enhancementGANï¼‰ï¼Œseganä¸»è¦ä¼˜åŠ¿æœ‰ä¸‰ç‚¹ï¼š å®ƒæä¾›äº†ä¸€ä¸ªå¿«é€Ÿè¯­éŸ³å¢žå¼ºè¿‡ç¨‹ã€‚ æ²¡æœ‰å› æžœå…³ç³»æ˜¯å¿…éœ€çš„ï¼Œå› æ­¤æ²¡æœ‰åƒRNNé‚£æ ·çš„é€’å½’æ“ä½œã€‚ å®ƒåŸºäºŽåŽŸå§‹éŸ³é¢‘åšå¤„ç†ã€‚ å› æ­¤ï¼Œæ²¡æœ‰æå–æ‰‹å·¥ç‰¹å¾ï¼Œå› æ­¤æ²¡æœ‰å¯¹åŽŸå§‹æ•°æ®åšå‡ºæ˜Žç¡®çš„å‡è®¾ã€‚ ä»Žä¸åŒçš„è¯´è¯äººå’Œå™ªå£°ç±»åž‹ä¸­å­¦ä¹ ï¼Œå¹¶å°†å®ƒä»¬åˆå¹¶åˆ°ç›¸åŒçš„å…±äº«å‚æ•°ä¸­ã€‚è¿™ä½¿å¾—ç³»ç»Ÿåœ¨è¿™äº›ç»´åº¦ä¸Šå˜å¾—ç®€å•å’Œä¸€èˆ¬åŒ–ã€‚ 2. Generative Adversarial Networksè¿™èŠ‚æ˜¯GANç½‘ç»œçš„ä»‹ç»ã€‚å¦‚æžœæœ‰GANç½‘ç»œåŸºç¡€ï¼Œå¯ä»¥è·³è¿‡æ­¤èŠ‚ã€‚ GANç½‘ç»œèƒ½æ˜¯ä¸€ç§å¯¹æŠ—æ€§æ¨¡åž‹ï¼Œå¯ä»¥å°†æ ·æœ¬æœä»ŽZåˆ†å¸ƒçš„æ ·æœ¬zæ˜ å°„åˆ°æœä»ŽXåˆ†å¸ƒçš„xã€‚ æ¥ç†è§£è¿™å¥è¯ã€‚åœ¨æˆ‘ä»¬è¿™é‡Œï¼Œå¯ä»¥ç†è§£ä¸ºZä¸ºå«å™ªå£°çš„è¯­éŸ³çš„åˆ†å¸ƒï¼Œzä¸ºå…¶ä¸­çš„ä¸€ä¸ªæ ·æœ¬ã€‚Xä¸ºçº¯å‡€è¯­éŸ³çš„åˆ†å¸ƒï¼Œxä¸ºå…¶ä¸­çš„ä¸€ä¸ªæ ·æœ¬ã€‚ GANä¸­ï¼Œæœ‰ä¸¤ä¸ªå•å…ƒï¼Œä¸€ä¸ªè´Ÿè´£æ˜ å°„ï¼Œå«åšç”Ÿæˆå™¨Gï¼Œå¦ä¸€ä¸ªè´Ÿè´£åˆ¤åˆ«ï¼Œå«åšåˆ¤åˆ«å™¨Dã€‚Gè´Ÿè´£æ˜ å°„ï¼ŒGçš„æ˜ å°„è´Ÿè´£ä»ŽZåˆ†å¸ƒæ˜ å°„åˆ°Xåˆ†å¸ƒï¼Œä¸åŒäºŽä¼ ç»Ÿçš„è¾“å…¥è¾“å‡ºæ˜ å°„ã€‚åˆ¤åˆ«å™¨Dæ˜¯ä¸€ä¸ªäºŒåˆ†ç±»å™¨ï¼Œè¾“å‡ºå€¼æ˜¯0-1ä¹‹é—´çš„æ•°å­—ã€‚ Gå°†æ ·æœ¬zæ˜ å°„ä¸º$\hat{x}$ï¼Œè€ŒçœŸå®žæ ·æœ¬ä¸º$x$ï¼ŒGçš„ç›®çš„æ˜¯å°½å¯èƒ½çš„ä½¿$\hat{x}$ä¸Ž$x$ç›¸ä¼¼ï¼Œä»¥è¿·æƒ‘åˆ¤åˆ«å™¨Dã€‚è€ŒDçš„åŠŸèƒ½æ˜¯åŒºåˆ†çœŸå®žæ ·æœ¬$x$å’ŒGç”Ÿæˆçš„æ ·æœ¬$\hat{x}$ï¼ŒçœŸå®žæ ·æœ¬å°½å¯èƒ½çš„åˆ¤ä¸º1ï¼ŒGç”Ÿæˆçš„å°½å¯èƒ½çš„åˆ¤ä¸º0ã€‚æ‰€ä»¥Gçš„ç›®çš„åœ¨äºŽè¿·æƒ‘Dï¼Œè€ŒDçš„ç›®çš„æ˜¯ä¸è¢«Gè¿·æƒ‘ã€‚æ‰€ä»¥å«ç”Ÿæˆå¯¹æŠ—ç½‘ç»œã€‚ äºŽæ˜¯å°±æœ‰äº†å¯¹æŠ—ç½‘ç»œçš„åŸºæœ¬å…¬å¼ï¼š å…¶ä¸­pdata(x)è¡¨ç¤ºçœŸå®žæ ·æœ¬ï¼Œpz(z)è¡¨ç¤ºç»è¿‡Gä¹‹å‰çš„æ ·æœ¬ã€‚ æ„ä¹‰å°±å¾ˆæ˜Žæ˜¾äº†ï¼Œå¯¹äºŽDä¼˜åŒ–çš„ç›®æ ‡å°±æ˜¯å¸Œæœ›çœŸå®žæ ·æœ¬è¾“å‡ºè¶Šå¤§ï¼Œç”Ÿæˆçš„æ ·æœ¬å°½å¯èƒ½è¾“å‡ºå°ï¼Œä½¿å¾—ç»“æžœæœ€å¤§ã€‚å¯¹äºŽGï¼Œå¸Œæœ›ç”Ÿæˆçš„æ—¶å€™ï¼Œå°½å¯èƒ½çš„éª—è¿‡Dï¼Œä½¿å¾—ç›®æ ‡å‡½æ•°æœ€å°ã€‚ ä¸‹é¢çš„å…¬å¼2æ˜¯å¸¦é¢å¤–ä¿¡æ¯çš„GANã€‚ ä¸€äº›è®ºæ–‡è‡´åŠ›äºŽæå‡GANç½‘ç»œç”Ÿæˆçš„è´¨é‡ã€‚æ¯”å¦‚ï¼Œåœ¨åŽŸå§‹çš„è®­ç»ƒä¸­ï¼Œç”±äºŽä½¿ç”¨sigmoidäº¤å‰ç†µæŸå¤±ï¼Œä¼šå‡ºçŽ°æ¢¯åº¦æ¶ˆå¤±çš„é—®é¢˜ã€‚è¿™æ—¶ï¼Œå¯ä»¥å°†æŸå¤±æ›¿æ¢ä¸ºæœ€å°å¹³æ–¹ï¼ˆleast squareï¼‰çš„Least Square GANï¼ˆLSGANï¼‰æ–¹æ³•ã€‚ç»“æžœå¦‚ä¸‹ï¼š å…³äºŽgançš„æ›´å¤šè§£é‡Šï¼š æœ‰äººè¯´GANå¼ºå¤§ä¹‹å¤„åœ¨äºŽå¯ä»¥è‡ªåŠ¨çš„å­¦ä¹ åŽŸå§‹çœŸå®žæ ·æœ¬é›†çš„æ•°æ®åˆ†å¸ƒï¼Œä¸ç®¡è¿™ä¸ªåˆ†å¸ƒå¤šä¹ˆçš„å¤æ‚ï¼Œåªè¦è®­ç»ƒçš„è¶³å¤Ÿå¥½å°±å¯ä»¥å­¦å‡ºæ¥ã€‚é’ˆå¯¹è¿™ä¸€ç‚¹ï¼Œæ„Ÿè§‰æœ‰å¿…è¦å¥½å¥½ç†è§£ä¸€ä¸‹ä¸ºä»€ä¹ˆåˆ«äººä¼šè¿™ä¹ˆè¯´ã€‚ æˆ‘ä»¬çŸ¥é“ï¼Œä¼ ç»Ÿçš„æœºå™¨å­¦ä¹ æ–¹æ³•ï¼Œæˆ‘ä»¬ä¸€èˆ¬éƒ½ä¼šå®šä¹‰ä¸€ä¸ªä»€ä¹ˆæ¨¡åž‹è®©æ•°æ®åŽ»å­¦ä¹ ã€‚æ¯”å¦‚è¯´å‡è®¾æˆ‘ä»¬çŸ¥é“åŽŸå§‹æ•°æ®å±žäºŽé«˜æ–¯åˆ†å¸ƒå‘€ï¼Œåªæ˜¯ä¸çŸ¥é“é«˜æ–¯åˆ†å¸ƒçš„å‚æ•°ï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬å®šä¹‰é«˜æ–¯åˆ†å¸ƒï¼Œç„¶åŽåˆ©ç”¨æ•°æ®åŽ»å­¦ä¹ é«˜æ–¯åˆ†å¸ƒçš„å‚æ•°å¾—åˆ°æˆ‘ä»¬æœ€ç»ˆçš„æ¨¡åž‹ã€‚å†æ¯”å¦‚è¯´æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªåˆ†ç±»å™¨ï¼Œæ¯”å¦‚SVMï¼Œç„¶åŽå¼ºè¡Œè®©æ•°æ®è¿›è¡Œä¸œå˜è¥¿å˜ï¼Œè¿›è¡Œå„ç§é«˜ç»´æ˜ å°„ï¼Œæœ€åŽå¯ä»¥å˜æˆä¸€ä¸ªç®€å•çš„åˆ†å¸ƒï¼ŒSVMå¯ä»¥å¾ˆè½»æ˜“çš„è¿›è¡ŒäºŒåˆ†ç±»åˆ†å¼€ï¼Œå…¶å®žSVMå·²ç»æ”¾æ¾äº†è¿™ç§æ˜ å°„å…³ç³»äº†ï¼Œä½†æ˜¯ä¹Ÿæ˜¯ç»™äº†ä¸€ä¸ªæ¨¡åž‹ï¼Œè¿™ä¸ªæ¨¡åž‹å°±æ˜¯æ ¸æ˜ å°„ï¼ˆä»€ä¹ˆå¾„å‘åŸºå‡½æ•°ç­‰ç­‰ï¼‰ï¼Œè¯´ç™½äº†å…¶å®žä¹Ÿå¥½åƒæ˜¯ä½ äº‹å…ˆçŸ¥é“è®©æ•°æ®è¯¥æ€Žä¹ˆæ˜ å°„ä¸€æ ·ï¼Œåªæ˜¯æ ¸æ˜ å°„çš„å‚æ•°å¯ä»¥å­¦ä¹ ç½¢äº†ã€‚ æ‰€æœ‰çš„è¿™äº›æ–¹æ³•éƒ½åœ¨ç›´æŽ¥æˆ–è€…é—´æŽ¥çš„å‘Šè¯‰æ•°æ®ä½ è¯¥æ€Žä¹ˆæ˜ å°„ä¸€æ ·ï¼Œåªæ˜¯ä¸åŒçš„æ˜ å°„æ–¹æ³•èƒ½åŠ›ä¸ä¸€æ ·ã€‚é‚£ä¹ˆæˆ‘ä»¬å†æ¥çœ‹çœ‹GANï¼Œç”Ÿæˆæ¨¡åž‹æœ€åŽå¯ä»¥é€šè¿‡å™ªå£°ç”Ÿæˆä¸€ä¸ªå®Œæ•´çš„çœŸå®žæ•°æ®ï¼ˆæ¯”å¦‚äººè„¸ï¼‰ï¼Œè¯´æ˜Žç”Ÿæˆæ¨¡åž‹å·²ç»æŽŒæ¡äº†ä»Žéšæœºå™ªå£°åˆ°äººè„¸æ•°æ®çš„åˆ†å¸ƒè§„å¾‹äº†ï¼Œæœ‰äº†è¿™ä¸ªè§„å¾‹ï¼Œæƒ³ç”Ÿæˆäººè„¸è¿˜ä¸å®¹æ˜“ã€‚ç„¶è€Œè¿™ä¸ªè§„å¾‹æˆ‘ä»¬å¼€å§‹çŸ¥é“å—ï¼Ÿæ˜¾ç„¶ä¸çŸ¥é“ï¼Œå¦‚æžœè®©ä½ è¯´ä»Žéšæœºå™ªå£°åˆ°äººè„¸åº”è¯¥æœä»Žä»€ä¹ˆåˆ†å¸ƒï¼Œä½ ä¸å¯èƒ½çŸ¥é“ã€‚è¿™æ˜¯ä¸€å±‚å±‚æ˜ å°„ä¹‹åŽç»„åˆèµ·æ¥çš„éžå¸¸å¤æ‚çš„åˆ†å¸ƒæ˜ å°„è§„å¾‹ã€‚ç„¶è€ŒGANçš„æœºåˆ¶å¯ä»¥å­¦ä¹ åˆ°ï¼Œä¹Ÿå°±æ˜¯è¯´GANå­¦ä¹ åˆ°äº†çœŸå®žæ ·æœ¬é›†çš„æ•°æ®åˆ†å¸ƒã€‚ å†æ‹¿åŽŸè®ºæ–‡ä¸­çš„ä¸€å¼ å›¾æ¥è§£é‡Šï¼š è¿™å¼ å›¾è¡¨æ˜Žçš„æ˜¯GANçš„ç”Ÿæˆç½‘ç»œå¦‚ä½•ä¸€æ­¥æ­¥ä»Žå‡åŒ€åˆ†å¸ƒå­¦ä¹ åˆ°æ­£å¤ªåˆ†å¸ƒçš„ã€‚åŽŸå§‹æ•°æ®xæœä»Žæ­£å¤ªåˆ†å¸ƒï¼Œè¿™ä¸ªè¿‡ç¨‹ä½ ä¹Ÿæ²¡å‘Šè¯‰ç”Ÿæˆç½‘ç»œè¯´ä½ å¾—ç”¨æ­£å¤ªåˆ†å¸ƒæ¥å­¦ä¹ ï¼Œä½†æ˜¯ç”Ÿæˆç½‘ç»œå­¦ä¹ åˆ°äº†ã€‚å‡è®¾ä½ æ”¹ä¸€ä¸‹xçš„åˆ†å¸ƒï¼Œä¸ç®¡ä»€ä¹ˆåˆ†å¸ƒï¼Œç”Ÿæˆç½‘ç»œå¯èƒ½ä¹Ÿèƒ½å­¦åˆ°ã€‚è¿™å°±æ˜¯GANå¯ä»¥è‡ªåŠ¨å­¦ä¹ çœŸå®žæ•°æ®çš„åˆ†å¸ƒçš„å¼ºå¤§ä¹‹å¤„ã€‚ è¿˜æœ‰äººè¯´GANå¼ºå¤§ä¹‹å¤„åœ¨äºŽå¯ä»¥è‡ªåŠ¨çš„å®šä¹‰æ½œåœ¨æŸå¤±å‡½æ•°ã€‚ ä»€ä¹ˆæ„æ€å‘¢ï¼Œè¿™åº”è¯¥è¯´çš„æ˜¯åˆ¤åˆ«ç½‘ç»œå¯ä»¥è‡ªåŠ¨å­¦ä¹ åˆ°ä¸€ä¸ªå¥½çš„åˆ¤åˆ«æ–¹æ³•ï¼Œå…¶å®žå°±æ˜¯ç­‰æ•ˆçš„ç†è§£ä¸ºå¯ä»¥å­¦ä¹ åˆ°å¥½çš„æŸå¤±å‡½æ•°ï¼Œæ¥æ¯”è¾ƒå¥½æˆ–è€…ä¸å¥½çš„åˆ¤åˆ«å‡ºæ¥ç»“æžœã€‚è™½ç„¶å¤§çš„losså‡½æ•°è¿˜æ˜¯æˆ‘ä»¬äººä¸ºå®šä¹‰çš„ï¼ŒåŸºæœ¬ä¸Šå¯¹äºŽå¤šæ•°GANä¹Ÿéƒ½è¿™ä¹ˆå®šä¹‰å°±å¯ä»¥äº†ï¼Œä½†æ˜¯åˆ¤åˆ«ç½‘ç»œæ½œåœ¨å­¦ä¹ åˆ°çš„æŸå¤±å‡½æ•°éšè—åœ¨ç½‘ç»œä¹‹ä¸­ï¼Œä¸åŒçš„é—®é¢˜è¿™ä¸ªå‡½æ•°å°±ä¸ä¸€æ ·ï¼Œæ‰€ä»¥è¯´å¯ä»¥è‡ªåŠ¨å­¦ä¹ è¿™ä¸ªæ½œåœ¨çš„æŸå¤±å‡½æ•°ã€‚ 3. Speech Enhancement GAN &amp;&amp; Experimental Setupè¿™éƒ¨åˆ†æ˜¯æœ¬æ–‡çš„è€Œæ ¸å¿ƒSEGANã€‚ æ•´ä¸ªç½‘ç»œå…¨éƒ¨æ˜¯ç”±CNNç»„æˆã€‚ ä¸‹å›¾æ˜¯ç”Ÿæˆå™¨Gï¼Œå®ƒæ˜¯ä¸€ä¸ªencoder-decoderã€‚Dçš„ç»“æž„æ˜¯encoderï¼Œä¸Šé¢æŽ¥äº†ä¸€ä¸ªé™ç»´å±‚ã€‚å°†8* 1024ä¸ªå‚æ•°é™ä¸º8ä¸ªã€‚ encoderç”±æ­¥é•¿ä¸º2çš„1ç»´å·ç§¯å±‚æž„æˆã€‚16384Ã—1, 8192Ã—16, 4096Ã—32, 2048Ã—32, 1024Ã—64, 512Ã—64, 256Ã—128, 128Ã—128, 64Ã—256,32Ã—256, 16Ã—512, and 8Ã—1024ã€‚ è‡³äºŽSEGANçš„è®­ç»ƒï¼Œå…¶å®žè·Ÿæ™®é€šçš„GANå¾ˆç±»ä¼¼ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œå…ˆè®­ç»ƒä¸€ä¸ªåˆ¤åˆ«å™¨Dã€‚Dçš„è¾“å…¥ä¸ºçº¯å‡€ä¿¡å·å’Œç»è¿‡ç”Ÿæˆå™¨å¢žå¼ºåŽçš„ä¿¡å·ã€‚ç„¶åŽå†å›ºå®šåˆ¤åˆ«å™¨Dï¼Œæ”¹å˜ç”Ÿæˆå™¨Gçš„å‚æ•°ã€‚ å…¶ä¸­ï¼Œæœ‰ä¸€ç‚¹ï¼Œåœ¨åˆæ­¥å®žéªŒä¸­ï¼Œæˆ‘ä»¬å‘çŽ°åœ¨Gçš„æŸå¤±ä¸­å¢žåŠ ä¸€ä¸ªæ¬¡è¦æˆåˆ†æ˜¯å¾ˆæ–¹ä¾¿çš„ï¼Œä»¥ä¾¿å°†å®ƒçš„ä¸–ä»£ä¸Žå¹²å‡€çš„ä¾‹å­ä¹‹é—´çš„è·ç¦»å‡è‡³æœ€å°ã€‚ ä¸ºäº†æµ‹é‡è¿™ç§è·ç¦»ï¼Œæˆ‘ä»¬é€‰æ‹©äº†L1èŒƒæ•°ï¼Œå› ä¸ºå®ƒå·²è¢«è¯æ˜Žåœ¨å›¾åƒå¤„ç†é¢†åŸŸæœ‰æ•ˆã€‚ æ‰€ä»¥æœ€ç»ˆGçš„æŸå¤±å‡½æ•°å¦‚å…¬å¼6ï¼š 4. Resultsåˆ†ä¸ºå®¢è§‚å’Œä¸»è§‚è¯„ä»·ä¸¤éƒ¨åˆ†ã€‚ 4.1 Objective Evaluationå®¢è§‚è¯„ä»·ï¼Œæœ‰ä»¥ä¸‹å‡ ä¸ªæŒ‡æ ‡ï¼Œéƒ½æ˜¯è¶Šå¤§è¶Šå¥½ï¼š PESQ: Perceptual evaluation of speech quality, using the wide-band version recommended in ITU-T P.862.2 (from â€“0.5 to 4.5).ä¸»è§‚è¯­éŸ³è´¨é‡è¯„ä¼°ï¼Œè™½ç„¶å«ä¸»è§‚ï¼Œå®žé™…è¿˜æ˜¯ä¸ªå®¢è§‚çš„å€¼ã€‚ CSIG: Mean opinion score (MOS) prediction of the signal distortion attending only to the speech signal(from 1to 5). CBAK: MOS prediction of the intrusiveness of background noise (from 1 to 5). COVL: MOS prediction of the overall effect(from 1 to 5). SSNR: Segmental SNR (from 0 to âˆž). ç»“æžœå¦‚ä¸‹å›¾ï¼š å¯ä»¥çœ‹åˆ°ï¼Œseganåœ¨PESQæŒ‡æ ‡ä¸Šè¡¨çŽ°ç¨å¾®å·®ä¸€ç‚¹ã€‚åœ¨æ‰€æœ‰å…¶ä»–æŒ‡æ ‡ä¸Šï¼Œè¿™äº›æŒ‡æ ‡æ›´ä¸Žè¯­éŸ³å¤±çœŸæœ‰å…³ç³»ï¼Œseganéƒ½æ¯”wieneræ›´å¥½ã€‚seganäº§ç”Ÿæ›´å°‘çš„è¯­éŸ³å¤±çœŸï¼ˆCSIGï¼‰å’Œç§»é™¤å™ªå£°æ›´æœ‰æ•ˆï¼ˆCBAKå’ŒSSNRï¼‰ã€‚æ‰€ä»¥ï¼Œseganèƒ½åœ¨äºŒè€…ä¹‹é—´å–å¾—æ›´å¥½çš„æƒè¡¡ã€‚ 4.2 Subjective Evaluationä¸»è§‚æè¿°ï¼Œå°±æ˜¯ä¸€æ®µéŸ³é¢‘ï¼Œç»™å‡ºå®ƒåŽŸå§‹éŸ³é¢‘ã€wienerå¤„ç†çš„éŸ³é¢‘ã€seganå¤„ç†åŽçš„éŸ³é¢‘ï¼Œä¸æ˜¾ç¤ºå…·ä½“å“ªä¸ªå¯¹åº”å“ªä¸ªï¼Œè®©è¢«æµ‹è¯•è€…æ‰“åˆ†ï¼Œ1-5ä¹‹é—´ï¼Œåˆ†æ•°è¶Šé«˜ä»£è¡¨è¶Šå¥½ã€‚ 16ä¸ªæµ‹è¯•è€…ï¼Œ20ä¸ªå¥å­ã€‚æ•ˆæžœå¦‚ä¸‹å›¾ã€‚ 5. Conclusionsåœ¨è¿™é¡¹å·¥ä½œä¸­ï¼Œç«¯å¯¹ç«¯è¯­éŸ³å¢žå¼ºæ–¹æ³•å·²ç»åœ¨ç”Ÿæˆå¯¹æŠ—æ¡†æž¶å†…å®žæ–½ã€‚è¯¥æ¨¡åž‹ä½¿ç”¨ç¼–ç å™¨-è§£ç å™¨å®Œå…¨å·ç§¯ç»“æž„ï¼Œä½¿å¾—å®ƒèƒ½å¤Ÿå¿«é€Ÿæ“ä½œæ¥å¯¹æ³¢å½¢å—è¿›è¡ŒåŽ»å™ªã€‚ ç»“æžœè¡¨æ˜Žï¼Œä¸ä»…è¯¥æ–¹æ³•æ˜¯å¯è¡Œçš„ï¼Œè€Œä¸”å®ƒä¹Ÿå¯ä»¥ä½œå½“å‰æ–¹æ³•çš„æœ‰æ•ˆæ›¿ä»£ã€‚ ç–‘æƒ‘ï¼š å¯¹ç§°çš„è§£å·ç§¯æ˜¯å¦‚ä½•åšçš„ï¼Ÿ å‚è€ƒèµ„æ–™ï¼š https://arxiv.org/abs/1703.09452 https://github.com/santi-pdp/segan http://veu.talp.cat/segan/ https://mp.weixin.qq.com/s?__biz=MjM5ODU3OTIyOA==&amp;mid=2650668193&amp;idx=3&amp;sn=19157c2124a9731094e23e67fd846abd&amp;scene=19#wechat_redirect https://v.qq.com/x/page/m05070a168l.html https://mp.weixin.qq.com/s?__biz=MzAwNDI4ODcxNA==&amp;mid=2652247409&amp;idx=2&amp;sn=0373c6984e722dd6542e2bc8fd983936&amp;chksm=80cc8cd4b7bb05c22cb61616307525fbb7ce5846707c5289999359704ec219aff2a9968b12d6&amp;scene=0#rd http://yucc.me/p/bea139a/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AIä¸€ä¸ä¸€æ¯«</tag>
        <tag>speech enhancement</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä½¿ç”¨vultræ­å»ºvpnï¼ˆshadowsocksï¼‰ç¿»å¢™å¹¶æ”¯æŒåŒ—é‚®äººbtï¼ˆipv6ï¼‰ä¸‹è½½æ•™ç¨‹]]></title>
    <url>%2Fp%2Fb4d20b2d%2F</url>
    <content type="text"><![CDATA[å­¦ä¹ æœ¬æ•™ç¨‹ï¼Œä¸»è¦æ”¶èŽ·ä¼šæœ‰ä¸¤ä¸ªã€‚ä¸€ä¸ªæ˜¯ç§‘å­¦ä¸Šç½‘ï¼Œä¸€ä¸ªèƒ½å¤ŸåŽ»åŒ—é‚®äººbtä¸Šä¼ ä¸‹è½½èµ„æºã€‚è¯¦ç»†çš„å†…å®¹è§ä¸‹è¡¨ï¼Œå¦‚æžœåªä¸ºäº†ç§‘å­¦ä¸Šç½‘ï¼Œå­¦ä¹ 1-3å³å¯ã€‚éœ€è¦æ”¯æŒåŒ—é‚®äººbtçœ‹1-4ï¼ŒæœåŠ¡å™¨ç®¡ç†ç›¸å…³çš„å†…å®¹æ”¾åœ¨äº†5ï¼Œç« èŠ‚6ä¸»è¦æ˜¯ä¸€äº›é—®é¢˜çš„è§£å†³åŠžæ³•ã€‚å†…å®¹ä¸»è¦æ˜¯ä»¥winä¸ºä¾‹å†™çš„ï¼Œmacã€androidçš„ç§‘å­¦ä¸Šç½‘ä¹Ÿå¯ä»¥è·Ÿç€æœ¬æ•™ç¨‹æ¥ã€‚å†…å®¹æ¦‚è¦ï¼š vultrè´­ä¹°VPSæœåŠ¡å™¨ åœ¨æœåŠ¡å™¨ä¸Šæ­å»ºshadowsocks åœ¨win10é…ç½®shadowsocks é…ç½®utorrentï¼Œæ”¯æŒåŒ—é‚®äººbt æœåŠ¡å™¨ç®¡ç†è¯´æ˜Ž Q &amp; A 1. vulträ¸Šè´­ä¹°VPSæœåŠ¡å™¨è¦ç§‘å­¦ä¸Šç½‘ï¼Œéœ€è¦ä½¿ç”¨åˆ°VPSæœåŠ¡å™¨ï¼Œæœ¬æ•™ç¨‹ä½¿ç”¨çš„æ˜¯vultrï¼Œè´¹ç”¨æ˜¯2.5ç¾Žå…ƒ/æœˆï¼Œè´¹ç”¨æ˜¯vultræ”¶å–çš„ï¼Œè·Ÿæœ¬æ•™ç¨‹æ— å…³ã€‚é™¤äº†vulträ¹Ÿå¯ä»¥ä½¿ç”¨å…¶ä»–çš„VPSï¼Œæ•ˆæžœç±»ä¼¼ã€‚ ä¸€äº›åŒå­¦ç”¨çš„æ¬ç“¦å·¥ï¼Œè·Ÿæˆ‘çš„å¯èƒ½ä¼šæœ‰äº›ä¸åŒã€‚æˆ‘å°±é‡åˆ°æœ‰åŒå­¦çš„æ¬ç“¦å·¥vpsæœ¬èº«ä¸æ”¯æŒipv6ï¼Œå¯¹äºŽä¸ŠåŒ—é‚®äººbtå°±å¾ˆéº»çƒ¦ï¼Œè¿™æ˜¯æœ¬æ•™ç¨‹åŠ›æ‰€ä¸èƒ½åŠçš„ã€‚æœ¬æ•™ç¨‹å»ºè®®ä½¿ç”¨vultrï¼Œæ‰€æœ‰ä½¿ç”¨éžvultrçš„vpsï¼Œä¸€å®šè¦ç¡®ä¿æ”¯æŒå¹¶å¯ä»¥å¼€å¯ipv6ã€‚ä¸æ”¯æŒipv6çš„ç»“æžœå°±æ˜¯å¯¹ä¸ŠåŒ—é‚®äººbtç­‰ipv6ç«™ç‚¹æœ‰å½±å“ï¼Œä¸å½±å“ç§‘å­¦ä¸Šç½‘ã€‚ 1.1 æ³¨å†ŒåŠäº¤è´¹è¿™ä¸€æ­¥å°±éžå¸¸ç®€å•äº†ï¼Œç”¨ä¸‹é¢çš„é“¾æŽ¥æ³¨å†Œï¼š https://www.vultr.com/?ref=7402906 1.2 è´­ä¹°æœåŠ¡å™¨æ³¨å†Œå®Œè´¦æˆ·ï¼Œå¹¶å……å€¼åŽã€‚è¿›å…¥ä»¥ä¸‹ç½‘å€è´­ä¹°æœåŠ¡å™¨ã€‚ https://my.vultr.com/deploy/ Server Locationè‡ªå·±éšæ„é€‰ï¼Œä½†æ˜¯éƒ¨åˆ†çš„ç¡®æ²¡æœ‰2.5ç¾Žå…ƒ/æœˆçš„æœåŠ¡å™¨ã€‚åœ°åŒºå¯ä»¥å…¨éƒ½è¯•è¯•ï¼Œç›®å‰è¿˜æ˜¯èƒ½æ‰¾åˆ°2.5ç¾Žå…ƒ/æœˆçš„æœåŠ¡å™¨çš„ã€‚Server Typeè‡ªå·±éšæ„ï¼Œå»ºè®®ç”¨centosã€‚Server Sizeéšæ„ï¼Œå¦‚æžœåªæ˜¯åšvpnçš„è¯ï¼Œä¹°2.5ç¾Žå…ƒ/æœˆçš„é‚£ä¸ªå°±è¡Œã€‚Additional Featuresä¸­ï¼Œå¦‚æžœæƒ³æ”¯æŒipv6ï¼Œ è®¿é—®åŒ—é‚®äººbtï¼Œé‚£ä¹ˆEnable IPv6å¿…é€‰ã€‚ ç„¶åŽç‚¹å‡»Deploy Nowã€‚ ç„¶åŽè·³è½¬æˆ–è®¿é—®ä»¥ä¸‹ç½‘å€ï¼š https://my.vultr.com/ å°±èƒ½çœ‹åˆ°è‡ªå·±çš„ipåœ°å€ï¼ˆIP addressï¼‰ã€ç”¨æˆ·åï¼ˆUsernameï¼Œé€šå¸¸æ˜¯rootï¼‰å’Œå¯†ç ï¼ˆpasswordï¼‰äº†ã€‚ 1.3 æ£€æŸ¥ipåœ°å€æ˜¯å¦è¢«å¢™ï¼ˆå¯è·³è¿‡ï¼‰è¿™ä¸€æ­¥ï¼Œwinç³»ç»Ÿçš„åŒå­¦éœ€è¦æ‰“å¼€cmdè¾“å…¥ ping ipå¹¶æŒ‰å›žè½¦ï¼Œæ£€æŸ¥æ˜¯å¦è¢«å¢™ã€‚å…¶ä¸­ipéœ€è¦æ›¿æ¢ä¸ºä½ ä¸Šä¸€æ­¥çœ‹åˆ°çš„ipåœ°å€ã€‚ å¦‚æžœæ²¡æœ‰å‡ºçŽ°time outã€‚æ­å–œè¿™ä¸ªæ²¡é—®é¢˜ã€‚å¦‚æžœä½ ä¸çŸ¥é“å¦‚ä½•æ‰“å¼€cmdï¼Œå¯ä»¥è‡ªè¡Œç™¾åº¦æˆ–googleï¼Œæˆ–è·³è¿‡æ­¤æ­¥éª¤ã€‚ å¦‚æžœæ˜¯macï¼Œcmdæ›¿æ¢ä¸ºâ€œç»ˆç«¯â€ã€‚ 2. åœ¨æœåŠ¡å™¨ä¸Šæ­å»ºshadowsocks2.1 ç™»å½•æœåŠ¡å™¨winä¸‹ï¼Œå¯ä»¥ä½¿ç”¨xshellæ¥ç™»å½•ã€‚ å¯ä»¥ä¸‹è½½å¥½xshellã€‚ macçŽ¯å¢ƒï¼Œä½¿ç”¨â€œç»ˆç«¯â€æˆ–â€œiterm2â€ï¼Œä¸€æ ·çš„æ•ˆæžœã€‚ åœ¨é»‘çª—å£é‡Œè¾“å…¥ä¸€ä¸‹ä»£ç ï¼š 1ssh root@ip å…¶ä¸­ipæ›¿æ¢ä¸ºä½ è‡ªå·±çš„ipåœ°å€ã€‚ ç„¶åŽä¼šå¼¹å‡ºå¼¹å‡ºä¸€ä¸ªæ¡†ï¼Œè¾“å…¥ä½ å‰å‡ æ­¥æåˆ°çš„å¯†ç ï¼Œå¹¶å›žè½¦ï¼ˆenteré”®ï¼‰ã€‚ è‡³æ­¤ï¼Œä½ å·²ç»ç™»é™†äº†ã€‚ 2.2 æœåŠ¡å™¨ä¸Šéƒ¨ç½²shadowsocksåœ¨åˆšæ‰ç™»å½•çš„xshellæœåŠ¡å™¨ä¸Šï¼Œè¾“å…¥ä»¥ä¸‹ä»£ç ã€‚ 123wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log å®‰è£…å®ŒæˆåŽæ˜¾ç¤ºæ•ˆæžœå¦‚ä¸‹ï¼Œå¯ä»¥æˆªå›¾ä¿å­˜è¿™äº›ä¿¡æ¯ä¸‹é¢é…ç½®ä¼šç”¨çš„åˆ°ï¼š 12345678910Congratulations, Shadowsocks-python server install completed!Your Server IP : your ipYour Server Port : your portYour Password : your passwordYour Encryption Method: aes-256-gcm Welcome to visit:https://teddysun.com/342.htmlEnjoy it![root@vultr ~]# è‡³æ­¤ï¼ŒæœåŠ¡å™¨ç«¯çš„é…ç½®å·²ç»å®Œæˆã€‚ 3. åœ¨windowsç³»ç»Ÿé…ç½®shadowsocks3.1 ä¸‹è½½shadowsockså®¢æˆ·ç«¯Windowsï¼šhttps://github.com/shadowsocks/shadowsocks-windows/releases Androidï¼šhttps://github.com/shadowsocks/shadowsocks-android/releases macï¼šhttps://github.com/shadowsocks/ShadowsocksX-NG/releases ubuntuçš„é…ç½®è¾ƒä¸ºå¤æ‚ï¼Œå¯ä»¥å‚è€ƒ[4]ã€‚ 3.2 é…ç½®shadowsockså®¢æˆ·ç«¯ä»¥winä¸ºä¾‹ï¼Œä¸‹è½½ï¼Œå¹¶è§£åŽ‹ç¼©åŽï¼Œè¿è¡Œã€‚ è¾“å…¥ipï¼Œportï¼Œpasswordï¼ŒåŠencryptionç‚¹å‡»okå°±å¯ä»¥äº†ã€‚ å¦‚æžœæ˜¯macï¼Œè§£åŽ‹ç¼©åŽè¿è¡Œï¼Œåœ¨ä¸Šé¢ç‚¹å‡»é‚£ä¸ªå°é£žæœºï¼Œå‡ºçŽ°ä¸‹æ‹‰æ â€œæœåŠ¡å™¨-æ–°æœåŠ¡å™¨â€-â€œæœåŠ¡å™¨è®¾ç½®â€ã€‚åŒæ ·æ˜¯è¾“å…¥åœ°å€ã€ç«¯å£ã€åŠ å¯†æ–¹æ³•ã€å¯†ç ï¼Œå¹¶ç¡®å®šå°±å¯ä»¥äº†ã€‚ å¦‚æžœæ˜¯Androidï¼Œæ“ä½œç±»ä¼¼ï¼Œè¯·å¤§å®¶è‡ªè¡ŒæŽ¢ç´¢ã€‚ æœ‰å¯èƒ½éœ€è¦å…³é—­å¹¶é‡æ–°æ‰“å¼€shadowsocksçš„æ“ä½œï¼Œæœ‰å¯èƒ½ä¸éœ€è¦ã€‚ æ‰“å¼€ä½ çš„æµè§ˆå™¨ï¼Œè¾“å…¥ https://www.google.com/ ï¼Œé‚£ä¹ˆè§è¯å¥‡è¿¹çš„æ—¶åˆ»åˆ°äº†ã€‚ å¦‚æžœæ˜¯Androidï¼Œåˆ™ç‚¹å‡»å³ä¸Šè§’çš„è¾ƒå¥½ï¼Œè¿›åŽ»é…ç½®æœåŠ¡å™¨ã€è¿œç¨‹ç«¯å£ã€å¯†ç ã€åŠ å¯†æ–¹å¼ã€è·¯ç”±ï¼Œç„¶åŽç‚¹å‡»å³ä¸Šè§’çš„å¯¹å·è¿›è¡Œä¿å­˜ã€‚ ç„¶åŽï¼Œé€‰ä¸­åˆšæ‰é…ç½®çš„vpnï¼Œç„¶åŽç‚¹å‡»å³ä¸‹è§’æœ‰ä¸ªé£žæœºçš„é‚£ä¸ªåœ†åœˆï¼Œå°±å¯ä»¥äº†ã€‚å¿«æ¥æµ‹è¯•ä¸‹å§ï¼ è‡³æ­¤ï¼Œç”µè„‘åŠæ‰‹æœºçš„ç§‘å­¦ä¸Šç½‘å·²ç»é…ç½®å®Œæˆã€‚ 4. é…ç½®utorrentï¼Œæ”¯æŒåŒ—é‚®äººbtä¸¤æ­¥ï¼Œç¬¬ä¸€æ­¥å°†åŒ—é‚®äººbtçš„ç½‘å€åŠ å…¥æ”¯æŒç¿»å¢™çš„åˆ—è¡¨ï¼Œç¬¬äºŒæ­¥é…ç½®utorrentã€‚éƒ½å¾ˆç®€å•ã€‚ 4.1 é…ç½®shadowsocksé¦–å…ˆé€šè¿‡ å³é”®Shadowsocksæ‰˜ç›˜å›¾æ ‡ &gt;-&gt; PAC &gt;-&gt; ç¼–è¾‘ GFWList çš„ç”¨æˆ·è§„åˆ™ï¼ˆæˆ– Edit User rule for GFWListï¼‰ æ¥æ‰“å¼€user-rule.txtã€‚ï¼ˆmacç”¨æˆ·ï¼Œç‚¹å‡»å°é£žæœºï¼Œâ€œç¼–è¾‘PACç”¨æˆ·è‡ªå®šè§„åˆ™â€ï¼‰ æ·»åŠ å¦‚ä¸‹è§„åˆ™å¹¶ä¿å­˜ï¼š 1||bt.byr.cn^ æ•ˆæžœå¦‚ä¸‹å›¾ï¼š æ­¤æ—¶å…³é—­shadowsocksï¼Œå¹¶é‡æ–°æ‰“å¼€ã€‚åœ¨åœ°å€æ é‡Œè¾“å…¥åŒ—é‚®äººbtçš„ç½‘å€: https://bt.byr.cn/ ã€‚å°±å¯ä»¥æ­£å¸¸è®¿é—®äº†ã€‚ 4.2 é…ç½®utorrentä¸‹è½½å¹¶æ‰“å¼€utorrentã€‚è¿™ä¸€æ­¥å°±ä¸è¯´äº†ã€‚ windowsç”¨æˆ·é…ç½®æ–¹æ³•ï¼šæŒ‰å¿«æ·é”®ï¼šâ€œctrl+Pâ€ï¼Œæ‰“å¼€utorrentçš„è®¾ç½®ã€‚è®¾ç½®å·¦ä¾§æ‰¾åˆ°Connectionï¼ˆä¸­æ–‡åº”è¯¥æ˜¯è¿žæŽ¥ï¼‰ï¼Œé…ç½®å¦‚ä¸‹å›¾çº¢åœˆé‡Œæ‰€ç¤ºï¼š macç”¨æˆ·é…ç½®æ–¹æ³•ï¼šæŒ‰å¿«æ·é”®ï¼šâ€œcommand+,â€ï¼Œæ‰“å¼€utorrentçš„è®¾ç½®ã€‚åœ¨è®¾ç½®ä¸Šä¾§æ‰¾åˆ°Networkï¼ˆä¸­æ–‡åº”è¯¥æ˜¯ç½‘ç»œï¼‰ï¼Œé…ç½®æ–¹æ³•è·Ÿä¸Šå›¾ç±»ä¼¼ã€‚å°±æ˜¯é…ç½®proxy serverï¼Œaddressï¼Œportï¼Œé…ç½®çš„å†…å®¹è·Ÿä¸Šå›¾å¯¹åº”çš„ä¸€æ ·ã€‚åŒæ—¶é€‰ä¸­ä¸‹é¢çš„use proxy for hostname lookupsåŠuse proxy for peer-to-peer connectionsã€‚ è‡³æ­¤å°±èƒ½æ„‰å¿«çš„ä¸‹è½½äº†ã€‚ æœ¬ç« å†…å®¹é™¤äº†å¯ä»¥ç”¨äºŽåŒ—é‚®äººbtï¼Œä¹Ÿå¯ä»¥ç”¨äºŽåŒ—äº¤å¤§çš„æ™¨å…‰ptï¼Œåªè¦æŠŠæ™¨å…‰ptçš„ç½‘å€æŒ‰ç±»ä¼¼æ–¹æ³•åŠ è¿›åŽ»å°±å¯ä»¥äº†ã€‚ è¯•è¯•æ•ˆæžœï¼Ÿæœ‰é—®é¢˜æ¬¢è¿Žç•™è¨€ã€‚ä¸‹é¢çš„5æ˜¯å¯¹äºŽæœåŠ¡å™¨ç®¡ç†ç”¨çš„ï¼Œä¸€èˆ¬ç”¨ä¸åˆ°ï¼Œå¯ä»¥ä¸çœ‹ï¼Œè‡³æ­¤å®Œæˆäº†ç§‘å­¦ä¸Šç½‘+æ”¯æŒåŒ—é‚®äººbtã€‚ 5. æœåŠ¡å™¨ç®¡ç†è¯´æ˜Žæ­¤å†…å®¹æ˜¯ç”¨äºŽå¯¹æœåŠ¡å™¨çš„vpnè¿›è¡Œç®¡ç†ä½¿ç”¨çš„ï¼Œæ­£å¸¸æƒ…å†µä¸‹æ˜¯ä¸éœ€è¦çœ‹è¿™ä¸ªçš„ã€‚ 5.1 å¸è½½æ–¹æ³•è¯´æ˜Žï¼šä½¿ç”¨rootç”¨æˆ·ç™»å½•ï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š 1./shadowsocks.sh uninstall 5.2 é…ç½®è¯´æ˜Žï¼šå•ç”¨æˆ·é…ç½®æ–‡ä»¶ç¤ºä¾‹ï¼š é…ç½®æ–‡ä»¶è·¯å¾„ï¼š/etc/shadowsocks.json12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:your_server_port, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;your_password&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; å¤šç”¨æˆ·å¤šç«¯å£é…ç½®æ–‡ä»¶ç¤ºä¾‹ï¼š é…ç½®æ–‡ä»¶è·¯å¾„ï¼š/etc/shadowsocks.json 123456789101112131415&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123; &quot;8989&quot;:&quot;password0&quot;, &quot;9001&quot;:&quot;password1&quot;, &quot;9002&quot;:&quot;password2&quot;, &quot;9003&quot;:&quot;password3&quot;, &quot;9004&quot;:&quot;password4&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 5.3 ä½¿ç”¨å‘½ä»¤ï¼šå¯åŠ¨ï¼š/etc/init.d/shadowsocks start åœæ­¢ï¼š/etc/init.d/shadowsocks stop é‡å¯ï¼š/etc/init.d/shadowsocks restart çŠ¶æ€ï¼š/etc/init.d/shadowsocks status 6. Q &amp; Aæœ¬å°ç»“æ˜¯å¯¹é…ç½®æœ‰é—®é¢˜çš„ä¸€äº›é—®é¢˜çš„å›žç­”ã€‚ googleä¸Šä¸åŽ»ã€‚ è¿™æ˜¯shadowsockséƒ½æ²¡é…ç½®å¥½ã€‚å‡ºé—®é¢˜çš„åœ°æ–¹å¯èƒ½æœ‰ ä¸€ã€ä½ çš„æœåŠ¡å™¨ipè¢«å¢™äº†ã€‚å¯ä»¥å°è¯•åœ¨cmdä¸­æ•²ping ipï¼Œçœ‹çœ‹æ˜¯å¦æœ‰time outã€‚æœ‰time outè¯´æ˜Žä½ è¿žä¸ä¸ŠæœåŠ¡å™¨çš„ï¼Œæˆ‘åœ¨å®¶å°±ç»å¸¸è¿žä¸ä¸Šï¼Œåœ¨å…¬å¸å°±æ²¡é—®é¢˜ã€‚ä¸€ä¸ªåŠžæ³•å°±æ˜¯é”€æ¯æœåŠ¡å™¨ï¼Œé‡æ–°ç”³è¯·å°æœåŠ¡å™¨çš„ipã€‚æˆ‘æ¢äº†å¥½å‡ ä¸ªipéƒ½æ²¡ç”¨ï¼Œæˆ‘æ„Ÿè§‰æˆ‘æ˜¯å®¶é‡Œçš„ç½‘å¯èƒ½æœ‰é—®é¢˜ã€‚ äºŒã€å¯¹äºŽå¾ˆå¤šé—®é¢˜ï¼Œå¯ä»¥å°è¯•æ¢ä¸ªæµè§ˆå™¨ã€é‡å¯shadowsocksä¹‹ç±»çš„çœ‹çœ‹èƒ½ä¸èƒ½ç™»å½•ã€‚ ä¸‰ã€çœ‹æŠ¥ä»€ä¹ˆé”™ã€‚å¦‚æžœæ˜¯500 Internal Privoxy Errorã€‚å¯ä»¥ä¿®æ”¹ç«¯å£å·ã€åŠ å¯†æ–¹å¼ã€‚ä¸€äº›ç«¯å£å·å¯èƒ½è¢«é‡ç‚¹å…³ç…§äº†ï¼Œå»ºè®®ä¿®æ”¹ä¸ºè¾ƒå°çš„ç«¯å£å·ï¼Œ æ¯”å¦‚ä¸€åƒä»¥å†…çš„ã€‚æ¥¼ä¸‹ä¹Ÿæœ‰ä¿®æ”¹åŠ å¯†æ–¹å¼è§£å†³é—®é¢˜çš„ã€‚å››ã€è‡ªè¡Œæ ¹æ®errorä¸Šç½‘æœç›¸å…³èµ„æ–™ã€‚ googleèƒ½ä¸Šï¼Œbtä¸Šä¸åŽ»é—®é¢˜ã€‚ googleèƒ½ä¸Šï¼Œè¯´æ˜Žshadowsocksé…ç½®æ²¡é—®é¢˜ã€‚btç›¸å¯¹äºŽæ™®é€šçš„ç§‘å­¦ä¸Šç½‘ï¼Œå¤šçš„æ­¥éª¤å°±ä¸‰ä¸ªï¼Œä¸€ã€vpsæ”¯æŒipv6ï¼ŒäºŒã€åŒ—é‚®äººbtçš„ç½‘å€åŠ å…¥åˆ°èµ°å¤–ç½‘åå•ï¼Œä¸‰ã€utorrentçš„é…ç½®ã€‚ ä¸»è¦æ£€æŸ¥ä¸€å’ŒäºŒã€‚ btå¯ä»¥ä¸Šç½‘ï¼Œutorrenté…ç½®æ‰¾ä¸åˆ°æˆ–ä¸‹è½½æ²¡é€Ÿåº¦ã€‚ é‚£å°±æ˜¯utorrenté…ç½®çš„é—®é¢˜äº†ï¼Œæœ‰çš„åŒå­¦çš„utorrenté…ç½®å’Œæˆ‘ç»™çš„æœ‰äº›å‡ºå…¥ï¼Œå»ºè®®æ›´æ–°utorrentåˆ°æœ€æ–°ç‰ˆï¼Œæˆ–è®¸å°±æ‰¾åˆ°å¯¹åº”çš„é…ç½®åœ°æ–¹äº†ã€‚ 500 Internal Privoxy Error é¦–å…ˆçœ‹æ˜¯å¦èƒ½ä¸Šgoogleï¼Œå¦‚æžœä¸èƒ½ï¼Œå°è¯•ä¿®æ”¹ç«¯å£å·ã€åŠ å¯†æ–¹å¼ã€‚ å¦‚æžœèƒ½ä¸Šèƒ½ä¸Šgoogleï¼Œä¸èƒ½btï¼Œå°±æ˜¯é—®é¢˜2ã€‚ å‚è€ƒèµ„æ–™ï¼š https://teddysun.com/342.html https://doub.io/ss-jc43/ https://www.cnblogs.com/edward2013/p/5560836.html https://blog.csdn.net/TotoroCyx/article/details/80032556 http://yucc.me/p/b4d20b2d/]]></content>
      <categories>
        <category>experience of life</category>
      </categories>
      <tags>
        <tag>ç¿»å¢™</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åˆ†ç±»ä»»åŠ¡ä¸­çš„æ¨¡åž‹æ€§èƒ½è¯„ä¼°æŒ‡æ ‡è¯¦è§£]]></title>
    <url>%2Fp%2F82f51d0e%2F</url>
    <content type="text"><![CDATA[æœ¬æ–‡ä¸»è¦å†…å®¹æœ‰ï¼š é”™è¯¯çŽ‡ï¼ˆError Rateï¼‰ä¸Žå‡†ç¡®çŽ‡ï¼ˆAccuracyã€ACCï¼‰ æ··æ·†çŸ©é˜µï¼ˆConfusion matrixï¼‰ ç²¾ç¡®çŽ‡ï¼ˆPrecisionï¼‰ã€å¬å›žçŽ‡ï¼ˆRecallï¼‰ã€F1å€¼ï¼ˆF1-scoreï¼‰ å®ç²¾ç¡®çŽ‡ï¼ˆmacro-Pï¼‰ã€å®å¬å›žçŽ‡ï¼ˆmarco-Rï¼‰ã€å®F1å€¼ï¼ˆmacro-F1ï¼‰ã€å¾®ç²¾ç¡®çŽ‡ï¼ˆmicro-Pï¼‰ã€å¾®å¬å›žçŽ‡ï¼ˆmicro-Rï¼‰ã€å¾®F1å€¼ï¼ˆmicro-F1ï¼‰ ROCä¸ŽAUC Mean Average Precision @ K å›žå½’ä»»åŠ¡çš„è¯„ä¼°æŒ‡æ ‡ å¯¹äºŽåˆ†ç±»æ¨¡åž‹å¸¸ç”¨çš„åˆ†ç±»æŒ‡æ ‡æœ‰1-6ã€‚è¿™äº›è¯„ä¼°æŒ‡æ ‡ï¼Œå·¥ç¨‹å’Œç ”ç©¶ä¸­éƒ½ä¼šç»å¸¸é‡åˆ°ï¼Œéœ€è¦å¯¹å…¶æœ‰é€å½»çš„ç†è§£å’Œå¯¹å…¶ä¸­çš„å·®åˆ«æ¸…æ¥šçŸ¥æ™“ã€‚æœ¬æ–‡å¯¹è¿™äº›æŒ‡æ ‡è¿›è¡Œä¸€äº›æ€»ç»“å’Œå½’çº³ã€‚ 1. é”™è¯¯çŽ‡ï¼ˆError Rateï¼‰ä¸Žå‡†ç¡®çŽ‡ï¼ˆAccuracyã€ACCï¼‰å‡†ç¡®çŽ‡äº¦ç§°ç²¾åº¦ã€‚é”™è¯¯çŽ‡ä¸Žå‡†ç¡®çŽ‡æ˜¯åˆ†ç±»ä»»åŠ¡ä¸­å¸¸è§çš„æ€§èƒ½åº¦é‡ï¼ŒåŒæ—¶é€‚ç”¨äºŽäºŒåˆ†ç±»åŠå¤šåˆ†ç±»ä»»åŠ¡ã€‚é”™è¯¯çŽ‡æ˜¯åˆ†ç±»é”™è¯¯çš„æ ·æœ¬æ•°å æ ·æœ¬æ€»æ•°çš„æ¯”ä¾‹ï¼Œå‡†ç¡®çŽ‡æ˜¯åˆ†ç±»æ­£ç¡®çš„æ ·æœ¬æ•°å æ ·æœ¬æ€»æ•°çš„æ¯”ä¾‹ã€‚æ˜¾ç„¶ï¼ŒäºŒè€…çš„å’Œä¸º1ã€‚ å¯¹äºŽæ ·ä¾‹é›†$D$ï¼Œåˆ†ç±»çš„é”™è¯¯çŽ‡å¯ä»¥å®šä¹‰ä¸ºï¼š $$\begin{equation}E(f; D) = \frac{1}{m} \sum_{i=1}^m {I(f(x_i) \ne y_i)}\end{equation} \tag{1}$$ å…¶ä¸­mè¡¨ç¤ºmä¸ªç±»åˆ«ï¼Œ$y_i$è¡¨ç¤º$x_i$å¯¹åº”çš„çœŸå®žæ ‡ç­¾ã€‚ å‡†ç¡®çŽ‡åˆ™å®šä¹‰ä¸ºï¼š $$\begin{equation}\begin{split}ACC(f; D) &amp; = \frac{1}{m} \sum_{i=1}^m {I(f(x_i) = y_i)} \\&amp; = 1 - E(f; D)\end{split}\end{equation} \tag{2}$$ å¯¹äºŽæ›´ä¸€èˆ¬çš„æƒ…å†µï¼Œæ•°æ®åˆ†å¸ƒä¸ºDï¼Œæ¦‚çŽ‡åˆ†å¸ƒä¸ºp(Â·)ï¼Œé”™è¯¯çŽ‡å’Œå‡†ç¡®çŽ‡å¯ä»¥æè¿°ä¸ºï¼š $$\begin{equation}E(f; D) = \int_{x \sim D} I(f(x) \ne y)p(x) {\rm d}x\end{equation} \tag{3}$$ $$\begin{equation}\begin{split}ACC(f; D) &amp; = \int_{x \sim D} I(f(x) = y)p(x) {\rm d}x \\&amp; = 1 - E(f; D)\end{split}\end{equation} \tag{4}$$ 2. æ··æ·†çŸ©é˜µï¼ˆConfusion matrixï¼‰æ··æ·†çŸ©é˜µæ˜¯ç›‘ç£å­¦ä¹ ä¸­çš„ä¸€ç§å¯è§†åŒ–å·¥å…·ï¼Œä¸»è¦ç”¨äºŽæ¯”è¾ƒåˆ†ç±»ç»“æžœå’Œå®žä¾‹çš„çœŸå®žä¿¡æ¯ã€‚çŸ©é˜µä¸­çš„æ¯ä¸€è¡Œä»£è¡¨å®žä¾‹çš„é¢„æµ‹ç±»åˆ«ï¼Œæ¯ä¸€åˆ—ä»£è¡¨å®žä¾‹çš„çœŸå®žç±»åˆ«ã€‚ä¸‹è¡¨æ˜¯ä¸€ä¸ªäºŒåˆ†ç±»ä»»åŠ¡çš„åˆ†ç±»ç»“æžœçš„æ··æ·†çŸ©é˜µã€‚ - çœŸå®žå€¼ä¸ºæ­£æ ·æœ¬P çœŸå®žå€¼ä¸ºè´Ÿæ ·æœ¬N é¢„æµ‹å€¼ä¸ºP True Postive(TP) False Postive(FP) é¢„æµ‹å€¼ä¸ºN False Negative(FN) True Negative(TN) åœ¨æ··æ·†çŸ©é˜µä¸­ï¼Œæ¯ä¸€ä¸ªå®žä¾‹å¯ä»¥åˆ’åˆ†ä¸ºä»¥ä¸‹å››ç§ç±»åž‹ä¹‹ä¸€ï¼š çœŸæ­£(True Positive , TP)ï¼šè¢«æ¨¡åž‹é¢„æµ‹ä¸ºæ­£çš„æ­£æ ·æœ¬ å‡æ­£(False Positive , FP)ï¼šè¢«æ¨¡åž‹é¢„æµ‹ä¸ºæ­£çš„è´Ÿæ ·æœ¬ å‡è´Ÿ(False Negative , FN)ï¼šè¢«æ¨¡åž‹é¢„æµ‹ä¸ºè´Ÿçš„æ­£æ ·æœ¬ çœŸè´Ÿ(True Negative , TN)ï¼šè¢«æ¨¡åž‹é¢„æµ‹ä¸ºè´Ÿçš„è´Ÿæ ·æœ¬ 3. çœŸæ­£çŽ‡ã€å‡è´ŸçŽ‡ã€å‡æ­£çŽ‡åŠçœŸè´ŸçŽ‡å®šä¹‰ä»¥ä¸‹å‡ ä¸ªæŒ‡æ ‡ çœŸæ­£çŽ‡(True Positive Rate, TP Rate, TPR)ï¼ˆçµæ•åº¦sensitivityï¼Œ ä¹Ÿæ˜¯å¬å›žçŽ‡ï¼‰å®šä¹‰ä¸º$\frac{è¢«é¢„æµ‹ä¸ºæ­£çš„æ­£æ ·æœ¬ç»“æžœæ•°}{æ­£æ ·æœ¬å®žé™…æ•°}$ï¼Œå³ï¼š $$\begin{equation}TPR = \frac{TP}{TP + FN}\end{equation} \tag{5}$$ å‡è´ŸçŽ‡(False Negative Rate, FN Rate, FNR)å®šä¹‰ä¸º$\frac{è¢«é¢„æµ‹ä¸ºè´Ÿçš„æ­£æ ·æœ¬ç»“æžœæ•°}{æ­£æ ·æœ¬å®žé™…æ•°}$ï¼Œå³ï¼š $$\begin{equation}FNR = \frac{FN}{TP + FN}\end{equation} \tag{6}$$ å‡æ­£çŽ‡(False Positive Rate, FP Rate, FPR) å®šä¹‰ä¸º$\frac{è¢«é¢„æµ‹ä¸ºæ­£çš„è´Ÿæ ·æœ¬ç»“æžœæ•°}{è´Ÿæ ·æœ¬å®žé™…æ•°}$ï¼Œå³ï¼š $$\begin{equation}FPR = \frac{FP}{FP + TN}\end{equation} \tag{7}$$ çœŸè´ŸçŽ‡(True Negative Rate, TN Rate, TNR)ï¼ˆç‰¹æŒ‡åº¦specificityï¼‰å®šä¹‰ä¸º$\frac{è¢«é¢„æµ‹ä¸ºè´Ÿçš„è´Ÿæ ·æœ¬ç»“æžœæ•°}{è´Ÿæ ·æœ¬å®žé™…æ•°}$ï¼Œå³ï¼š $$\begin{equation}TNR = \frac{TN}{TN + FP}\end{equation} \tag{8}$$ å¯ä»¥çœ‹å‡ºï¼ŒçœŸæ­£ï¼ˆTPï¼‰å’Œå‡è´Ÿï¼ˆFNï¼‰éƒ½æ˜¯å®žé™…ç±»åˆ«æ˜¯æ­£æ ·æœ¬ï¼Œåˆ†åˆ«è¢«åˆ¤ä¸ºæ­£åŠè´Ÿï¼ŒçœŸæ­£çŽ‡ï¼ˆTPRï¼‰åŠå‡è´ŸçŽ‡ï¼ˆFNRï¼‰éƒ½æ˜¯é™¤ä»¥æ­£æ ·æœ¬çš„æ€»ä¸ªæ•°ï¼ˆTP+FNï¼‰ã€‚æ‰€ä»¥TPR+FNR=1ã€‚ç±»ä¼¼çš„ï¼Œå‡æ­£ï¼ˆFPï¼‰å’ŒçœŸè´Ÿï¼ˆTNï¼‰éƒ½æ˜¯å®žé™…æ ·æœ¬ç±»åˆ«æ˜¯è´Ÿæ ·æœ¬ï¼Œåˆ†åˆ«è¢«åˆ¤ä¸ºæ­£åŠè´Ÿï¼Œå‡æ­£çŽ‡ï¼ˆFPRï¼‰åŠçœŸè´ŸçŽ‡ï¼ˆTNRï¼‰éƒ½æ˜¯é™¤ä»¥è´Ÿæ ·æœ¬çš„æ€»æ•°ï¼ˆFP+TNï¼‰ã€‚æ‰€ä»¥FPR+TNR=1ã€‚ å¯ä»¥çœ‹å‡ºï¼Œä»¥ä¸Šå››ä¸ªçŽ‡ï¼ˆRateï¼‰éƒ½æ˜¯é™¤ä»¥ä»–ä»¬çš„çœŸå®žæ ‡ç­¾å¯¹åº”çš„æ‰€æœ‰ä¸Žå®ƒä»¬çœŸå®žæ ‡ç­¾ç›¸åŒçš„æ ·æœ¬çš„ä¸ªæ•°ã€‚TPRã€FNRäºŒè€…çŸ¥å…¶ä¸€ï¼Œä¾¿çŸ¥å¦å¤–ä¸€ä¸ªã€‚FPRã€TNRä¹Ÿåªéœ€è¦çŸ¥é“ä¸€ä¸ªä¾¿çŸ¥å¦å¤–ä¸€ä¸ªã€‚ ä¸€ä¸ªå…·ä½“çš„ä¾‹å­ï¼Œå°±æ˜¯[5]ã€‚å‡è®¾ä½ æ­£åœ¨æž„å»ºä¸€ä¸ªä½¿ç”¨éº¦å…‹é£Žæ¥ç›‘å¬ç”¨æˆ·è¯´å‡ºç‰¹å®šâ€œå”¤é†’è¯â€ï¼Œæ£€æµ‹åˆ°â€œå”¤é†’è¯å°±å”¤é†’ç³»ç»Ÿçš„ç¡¬ä»¶è®¾å¤‡ã€‚ä¾‹å¦‚äºšé©¬é€Šçš„Echoå€¾å¬â€œAlexaâ€ï¼Œè‹¹æžœsiriçš„â€œHey Siriâ€ï¼Œå®‰å“çš„â€œOkay Googleâ€åŠç™¾åº¦åº”ç”¨çš„â€œä½ å¥½ï¼Œç™¾åº¦â€ã€‚ä½ å…³å¿ƒçš„æ˜¯å‡æ­£çŽ‡ï¼ˆå‡é˜³æ€§çŽ‡ï¼‰åŠå‡è´ŸçŽ‡ï¼ˆå‡é˜´æ€§çŽ‡ï¼‰ã€‚å‡æ­£çŽ‡ï¼ˆå‡é˜³æ€§çŽ‡ï¼‰æŒ‡æ²¡æœ‰äººè¯´å”¤é†’è¯ç³»ç»Ÿé†’æ¥çš„é¢‘çŽ‡ï¼Œå‡è´ŸçŽ‡ï¼ˆå‡é˜´æ€§çŽ‡ï¼‰æ˜¯å½“æœ‰äººè¯´å”¤é†’è¯ç³»ç»Ÿæ²¡æœ‰é†’æ¥çš„é¢‘çŽ‡ã€‚ä¸€ä¸ªåˆç†çš„ç›®æ ‡æ˜¯åœ¨æ»¡è¶³æ¯è¿è¡Œ24å°æ—¶ä¸ä¼šæœ‰ä¸€ä¸ªå‡é˜³æ€§ï¼ˆæ»¡è¶³æŒ‡æ ‡ï¼‰çš„æƒ…å†µä¸‹ï¼Œæœ€å¤§é™åº¦çš„å‡å°‘å‡é˜´æ€§çŽ‡ï¼ˆä¼˜åŒ–æŒ‡æ ‡ï¼‰ã€‚ åœ¨wekaé‡Œï¼Œä¼šæ˜¾ç¤ºTPRå’ŒFPRä¸¤ä¸ªå‚æ•°ã€‚ 3. ç²¾ç¡®çŽ‡ï¼ˆPrecisionï¼‰ã€å¬å›žçŽ‡ï¼ˆRecallï¼‰ã€F1å€¼ï¼ˆF1-scoreï¼‰äºŒåˆ†ç±»é—®é¢˜å¸¸ç”¨çš„è¯„ä»·æŒ‡æ ‡æœ‰ç²¾ç¡®çŽ‡ï¼ˆPrecisionï¼‰ã€å¬å›žçŽ‡ï¼ˆRecallï¼‰å’ŒF1å€¼ã€‚ç²¾ç¡®çŽ‡äº¦ç§°ä¸ºâ€œæŸ¥å‡†çŽ‡â€ï¼Œå¬å›žçŽ‡äº¦ç§°â€œæŸ¥å…¨çŽ‡â€ã€‚ ç²¾ç¡®çŽ‡å®šä¹‰ä¸ºï¼š $$\begin{equation}P = \frac{TP}{TP+FP}\end{equation} \tag{9}$$ å¬å›žçŽ‡å®šä¹‰ä¸ºï¼š $$\begin{equation}R = \frac{TP}{TP+FN}\end{equation} \tag{10}$$ F1ä¹‹å®šä¹‰ä¸ºç²¾ç¡®çŽ‡å’Œå¬å›žçŽ‡çš„è°ƒå’Œå¹³å‡æ•°ï¼Œå³ï¼š $$\begin{equation}\frac{2}{F1} = \frac{1}{P} + \frac{1}{R}\end{equation} \tag{11}$$ å³ $$\begin{equation}\begin{split}F1 &amp; = \frac{2PR}{P+R} \\&amp; = \frac{2}{\frac{TP+FP}{TP}+\frac{TP+FN}{TP}} \\&amp; = \frac{2TP}{2TP+FP+FN}\end{split}\end{equation} \tag{12}$$ å¯¹äºŽä¸€äº›åº”ç”¨ï¼Œç²¾ç¡®çŽ‡å’Œå¬å›žçŽ‡é‡è§†ç¨‹åº¦ä¸åŒï¼Œæ¯”å¦‚åœ¨å•†å“æŽ¨èä¸­ï¼Œä¸ºäº†å‡å°‘å¯¹ç”¨æˆ·çš„æ‰“æ‰°ï¼Œæ›´å¸Œæœ›æŽ¨èç”¨æˆ·æ„Ÿå…´è¶£çš„ï¼Œæ­¤æ—¶ç²¾ç¡®çŽ‡æ›´é‡è¦ã€‚æŸ¥æ‰¾é€ƒçŠ¯æ—¶ï¼Œå¸Œæœ›å°½å¯èƒ½çš„å‡å°‘é€ƒçŠ¯é—æ¼ï¼Œåˆ™å¬å›žçŽ‡æ›´é‡è¦ã€‚äºŽæ˜¯æœ‰äº†F1å€¼æ›´ä¸€èˆ¬çš„å½¢åŠ¿$F_\beta$ï¼Œå®šä¹‰ä¸ºç²¾ç¡®çŽ‡å’Œå¬å›žçŽ‡çš„åŠ æƒå¹³å‡æ•°ï¼š $$\begin{equation}\frac{1+\beta^2}{F_\beta} = \frac{1}{P} + \frac{\beta^2}{R}\end{equation} \tag{13}$$ å³ï¼š $$\begin{equation}F_\beta = \frac{(1+\beta^2)PR}{\beta^2P + R}\end{equation} \tag{14}$$ å…¶ä¸­ï¼Œ$\beta &gt; 0$ï¼Œ$\beta$åº¦é‡äº†ç²¾ç¡®çŽ‡å’Œå¬å›žçŽ‡ä¹‹é—´çš„é‡è¦æ€§ï¼Œå½“$\beta=1$æ—¶,å°±æ˜¯F1ï¼›å½“$\beta&lt;1$æ—¶ï¼Œç²¾ç¡®çŽ‡æ›´é‡è¦ï¼›å½“$\beta&gt;1$æ—¶ï¼Œå¬å›žçŽ‡æ›´é‡è¦ã€‚è¿™äº›ç»“è®ºå¯ä»¥é€šè¿‡è§‚å¯Ÿå…¬å¼ï¼ˆ13ï¼‰å¾—å‡ºã€‚ 4. å®ç²¾ç¡®çŽ‡ï¼ˆmacro-Pï¼‰ã€å®å¬å›žçŽ‡ï¼ˆmarco-Rï¼‰ã€å®F1å€¼ï¼ˆmacro-F1ï¼‰ã€å¾®ç²¾ç¡®çŽ‡ï¼ˆmicro-Pï¼‰ã€å¾®å¬å›žçŽ‡ï¼ˆmicro-Rï¼‰ã€å¾®F1å€¼ï¼ˆmicro-F1ï¼‰å¾ˆå¤šæ—¶å€™æˆ‘ä»¬æœ‰å¤šä¸ªäºŒåˆ†ç±»æ··æ·†çŸ©é˜µï¼Œä¾‹å¦‚è¿›è¡Œå¤šæ¬¡è®­ç»ƒ/æµ‹è¯•ï¼Œæ¯æ¬¡å¾—åˆ°ä¸€ä¸ªæ··æ·†çŸ©é˜µ;æˆ–æ˜¯åœ¨å¤šä¸ªæ•°æ®é›†ä¸Šè¿›è¡Œè®­ç»ƒ/æµ‹è¯•ï¼Œå¸Œæœ›ä¼°è®¡ç®—æ³•çš„â€å…¨å±€â€æ€§èƒ½;ç”šæˆ–æ˜¯æ‰§è¡Œå¤šåˆ†ç±»ä»»åŠ¡ï¼Œæ¯ä¸¤ä¸¤ç±»åˆ«çš„ç»„åˆéƒ½å¯¹åº”ä¸€ä¸ªæ··æ·†çŸ©é˜µï¼Œæ€»ä¹‹ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨ä¸ªäºŒåˆ†ç±»æ··æ·†çŸ©é˜µä¸Šç»¼åˆè€ƒå¯Ÿç²¾ç¡®çŽ‡å’Œå¬å›žçŽ‡ã€‚ ä¸€ç§ç›´æŽ¥çš„åšæ³•æ˜¯çŽ°åœ¨å„ä¸ªæ··æ·†çŸ©é˜µä¸Šåˆ†åˆ«è®¡ç®—å‡ºç²¾ç¡®çŽ‡å’Œå¬å›žçŽ‡ï¼Œè®°ä¸º$(P_1, R_1),(P_2,R_2),â€¦,(P_n, R_n)$ï¼Œå†è®¡ç®—å¹³å‡å€¼ï¼Œè¿™æ ·å°±å¾—åˆ°å®ç²¾ç¡®çŽ‡ï¼ˆmacro-Pï¼‰ã€å®å¬å›žçŽ‡ï¼ˆmarco-Rï¼‰ã€å®F1å€¼ï¼ˆmacro-F1ï¼‰ï¼Œåˆ†åˆ«å®šä¹‰å¦‚ä¸‹ï¼š $$\begin{equation}marco-P = \frac{1}{n} \sum_{i=1}^n P_i\end{equation} \tag{15}$$ $$\begin{equation}marco-R = \frac{1}{n} \sum_{i=1}^n R_i\end{equation} \tag{16}$$ $$\begin{equation}marco-F1 = \frac{2 \times marco-P \times macro-R}{macro-P + macro-R}\end{equation} \tag{17}$$ é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜å¯ä»¥å°†å„ä¸ªæ··æ·†çŸ©é˜µçš„å¯¹åº”å…ƒç´ è¿›è¡Œå¹³å‡ï¼Œå¾—åˆ°TPã€FPã€TNã€FNçš„å¹³å‡å€¼ï¼Œåˆ†åˆ«è®°ä¸º$\overline{TP}ã€ \overline{FP}ã€ \overline{TN}ã€ \overline{FN}$ï¼Œç„¶åŽå†åŸºäºŽè¿™äº›æŒ‡æ ‡ï¼Œè®¡ç®—å‡ºå¾®ç²¾ç¡®çŽ‡ï¼ˆmicro-Pï¼‰ã€å¾®å¬å›žçŽ‡ï¼ˆmicro-Rï¼‰ã€å¾®F1å€¼ï¼ˆmicro-F1ï¼‰ï¼Œåˆ†åˆ«å®šä¹‰å¦‚ä¸‹ï¼š $$\begin{equation}mirco-P = \frac{\overline{TP}}{\overline{TP}+\overline{FP}}\end{equation} \tag{18}$$ $$\begin{equation}mirco-R = \frac{\overline{TP}}{\overline{TP}+\overline{FN}}\end{equation} \tag{19}$$ $$\begin{equation}mirco-F1 = \frac{2 \times mirco-P \times micro-R}{micro-P + micro-R}\end{equation} \tag{20}$$ 5. ROCä¸ŽAUCROCå…¨ç§°æ˜¯å—è¯•è€…å·¥ä½œç‰¹å¾ï¼ˆReceiver Operating Characteristicï¼‰ã€‚ROCæ›²çº¿çš„çºµè½´æ˜¯ä¸Šæ–‡æåˆ°çš„çœŸæ­£çŽ‡ï¼ˆTPRï¼‰ï¼Œæ¨ªè½´æ˜¯å‡æ­£çŽ‡ï¼ˆFPRï¼‰ï¼Œåˆ†åˆ«å¯¹åº”äºŽå…¬å¼ï¼ˆ5ï¼‰å’Œå…¬å¼ï¼ˆ7ï¼‰ã€‚æ­¤å¤„å†æ¬¡æ¬è¿è¿‡æ¥ã€‚ $$\begin{equation}TPR = \frac{TP}{TP + FN}\end{equation} \tag{21}$$ $$\begin{equation}FPR = \frac{FP}{FP + TN}\end{equation} \tag{22}$$ æ­£å¦‚å‰æ–‡åˆ†æžçš„é‚£æ ·ï¼ŒTPRçš„åˆ†å­ä¸ºåˆ†ç±»ç»“æžœä¸­ä¸ºæ­£æ ·æœ¬ä¸”çœŸå®žæ ‡ç­¾ä¹Ÿä¸ºæ­£æ ·æœ¬çš„ä¸ªæ•°ï¼Œåˆ†æ¯æ˜¯æ‰€æœ‰æ ·æœ¬ä¸­æ­£æ ·æœ¬çš„ä¸ªæ•°ã€‚FPRçš„åˆ†å­ä¸ºåˆ†ç±»ç»“æžœä¸ºæ­£æ ·æœ¬ä¸”çœŸå®žæ ·æœ¬ä¸ºè´Ÿæ ·æœ¬çš„ä¸ªæ•°ï¼Œåˆ†æ¯æ˜¯æ‰€æœ‰æ ·æœ¬ä¸­è´Ÿæ ·æœ¬çš„ä¸ªæ•°ã€‚æ‰€ä»¥å¯¹äºŽä¸€ä¸ªå›ºå®šçš„æµ‹è¯•é›†æ¥è¯´ï¼ŒTPRã€FPRçš„åˆ†æ¯éƒ½æ˜¯å›ºå®šå€¼ã€‚ä¸€ä¸ªROCæ›²çº¿å›¾å¦‚ä¸‹æ‰€ç¤ºï¼š å¯¹ä¸Šå›¾çš„å››ä¸ªå…³é”®ç‚¹è¿›è¡Œåˆ†æžï¼š (0,0)ï¼šTP=0ï¼ŒFP=0ï¼Œå¯ä»¥å‘çŽ°è¯¥åˆ†ç±»å™¨é¢„æµ‹æ‰€æœ‰çš„æ ·æœ¬éƒ½ä¸ºè´Ÿæ ·æœ¬(Negative) (1,1)ï¼šTN=0ï¼ŒFN=0ï¼Œå¯ä»¥å‘çŽ°è¯¥åˆ†ç±»å™¨é¢„æµ‹æ‰€æœ‰çš„æ ·æœ¬éƒ½ä¸ºæ­£æ ·æœ¬(Positive) (0,1)ï¼šFP=0ï¼ŒFN=0ï¼Œå®ƒå°†æ‰€æœ‰çš„æ ·æœ¬éƒ½æ­£ç¡®åˆ†ç±» (1,0)ï¼šTP=0ï¼ŒTN=0ï¼Œå®ƒå°†æ‰€æœ‰çš„æ ·æœ¬éƒ½é”™è¯¯åˆ†ç±» ä»Žä¸Šé¢çš„åˆ†æžæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æžœROCæ›²çº¿è¶Šé è¿‘å·¦ä¸Šæ–¹ï¼Œé‚£ä¹ˆåˆ†ç±»å™¨çš„æ•ˆæžœè¶Šå¥½ã€‚è¿›è¡Œå­¦ä¹ å™¨çš„æ¯”è¾ƒæ—¶ï¼Œè‹¥ä¸€ä¸ªåˆ†ç±»å™¨çš„ROCæ›²çº¿å®Œå…¨åŒ…ä½å¦ä¸€ä¸ªåˆ†ç±»å™¨ï¼Œé‚£ä¹ˆå¯ä»¥åˆ¤æ–­å‰è€…çš„æ€§èƒ½æ›´å¥½ã€‚ ROCçš„ç»˜å›¾è¿‡ç¨‹æ˜¯ï¼šç»™å®š$m^+$ä¸ªæ­£æ ·æœ¬å’Œ$m^-$ä¸ªè´Ÿæ ·æœ¬ã€‚æ ¹æ®å­¦ä¹ æœŸé¢„æµ‹ç»“æžœå¯¹æ ·ä¾‹è¿›è¡ŒæŽ’åºï¼Œç„¶åŽæŠŠåˆ†ç±»é˜ˆå€¼è®¾ä¸ºæœ€å¤§ï¼Œåˆ™æŠŠæ‰€æœ‰ç»“æžœé¢„æµ‹ä¸ºè´Ÿæ ·æœ¬ï¼Œæ­¤æ—¶çœŸæ­£çŽ‡å’Œå‡æ­£çŽ‡å‡ä¸º0ï¼Œåœ¨åæ ‡ï¼ˆ0,0ï¼‰å¤„æ ‡è®°ä¸€ä¸ªç‚¹ã€‚ç„¶åŽï¼Œå°†åˆ†ç±»é˜ˆå€¼ä¸€æ¬¡è®¾ä¸ºæ¯ä¸ªæ ·æœ¬çš„é¢„æµ‹å€¼ï¼Œå³ä¾æ¬¡å°†æ¯ä¸ªæ ·ä¾‹åˆ’åˆ†ä¸ºæ­£æ ·æœ¬ã€‚è®¾ç­¾ä¸€ä¸ªæ ‡è®°ç‚¹åæ ‡ä¸ºï¼ˆxï¼Œyï¼‰ï¼Œå½“å‰è‹¥ä¸ºæ­£æ ·æœ¬ï¼Œåˆ™å¯¹åº”æ ‡è®°ç‚¹çš„åæ ‡ä¸º$(x,y+\frac{1}{m^+})$ï¼›å½“å‰è‹¥å½“è´Ÿæ ·æœ¬ï¼Œåˆ™å¯¹åº”æ ‡è®°ç‚¹çš„åæ ‡ä¸º$(x+\frac{1}{m^-}, y)$ï¼Œç„¶åŽç”¨çº¿æ®µè¿žæŽ¥ç›¸é‚»ç‚¹å³å¯ã€‚ åœ¨è¿›è¡Œå­¦ä¹ æœŸæ¯”è¾ƒæ—¶ï¼Œå¦‚æžœä¸€ä¸ªå­¦ä¹ æœŸçš„ROCæ›²çº¿è¢«å¦ä¸€ä¸ªå­¦ä¹ æœŸçš„æ›²çº¿å®Œå…¨â€œåŒ…ä½â€ï¼Œåˆ™å¯ä»¥æ–­è¨€åŽè€…ä¼˜äºŽå‰è€…ã€‚ä½†æ˜¯å¦‚æžœæœ‰äº¤å‰ï¼Œåˆ™ä¸€èˆ¬éš¾ä»¥æ–­è¨€å“ªä¸ªæ›´å¥½ã€‚æ­¤æ—¶å¦‚æžœä¸€å®šè¦æ¯”è¾ƒï¼Œåˆ™è¾ƒä¸ºåˆç†çš„åˆ¤æ–­æ˜¯æ¯”è¾ƒROCæ›²çº¿ä¸‹çš„é¢ç§¯ï¼Œå³AUCï¼ˆArea Under ROC Curveï¼‰ã€‚ ä»Žä»¥ä¸Šå®šä¹‰å¯çŸ¥ï¼ŒAUCå¯ä»¥é€šè¿‡å¯¹ROCæ›²çº¿ä¸‹ä¸ªé¢ç§¯æ±‚å’Œå¾—åˆ°ã€‚å‡è®¾ROCæ›²çº¿çš„åæ ‡ä¸º${(x_1, y_1),(x_2, y_2),â€¦(x_m, y_m)}çš„ç‚¹æŒ‰åºè¿žæŽ¥è€Œæˆ$(x_1 = 0, x_m = 1)$ï¼Œåˆ™AUCå¯ä»¥ä¼°ç®—ä¸ºï¼š $$\begin{equation}AUC = \frac{1}{2} \sum_{i=1}^{m-1} (x_{i+1} - x_i)(y_i + y_{i+1})\end{equation} \tag{23}$$ 6. Mean Average Precision @ Kåœ¨kaggleçš„Freesound General-Purpose Audio Tagging Challenge[7]ä½¿ç”¨çš„è¯„ä¼°æ–¹æ³•æ˜¯Mean Average Precision @ 3 (MAP@3)ï¼Œè¯¥é—®é¢˜æ˜¯æ¯ä¸ªéŸ³é¢‘æ–‡ä»¶è¿›è¡Œè‡ªåŠ¨æ ‡æ³¨ï¼Œæ¯ä¸ªéŸ³é¢‘å®žé™…ä¸Šåªå¯¹åº”ä¸€ä¸ªæ ‡ç­¾ï¼Œä½†æ˜¯å¯ä»¥åšå‡ºæœ€å¤šä¸‰ä¸ªé¢„æµ‹æ ‡ç­¾å€¼ï¼Œå¯¹åº”çš„å…¬å¼æ˜¯ï¼š $$\begin{equation}MAP@3 = \frac{1}{U} \sum_{u=1}^U {\sum_{k=1}^{min(n,3)} P(k)}\end{equation} \tag{24}$$ Uæ˜¯æ ·æœ¬çš„æ€»ä¸ªæ•°ï¼Œæœ€åŽæ˜¯å¯¹æ¯ä¸ªæ ·æœ¬çš„è¯„ä»·æ±‚å¹³å‡ï¼Œæ‰€ä»¥å…³é”®è¿˜æ˜¯è¦Average Precision @ 3 (AP@3ï¼‰ï¼Œæ‰€ä»¥å¯¹åº”çš„å…¬å¼æ˜¯ï¼š $$\begin{equation}AP@3 = \sum_{k=1}^{min(n,3)} P(k)\end{equation} \tag{25}$$ næ˜¯é¢„æµ‹ç»“æžœçš„æ€»ä¸ªæ•°ï¼Œä¹Ÿå°±æ˜¯é™åˆ¶ä¸º3ã€‚æ¯”å¦‚ä¸€ä¸ªçœŸå®žæ ‡ç­¾ä¸ºé¸Ÿå«å£°çš„éŸ³é¢‘ï¼Œå¯ä»¥é¢„æµ‹ä¸ºï¼šé¸Ÿå«å£°ï¼Œé—¨å£°ï¼ŒçŽ»ç’ƒç ´ç¢Žå£°ã€‚åˆ™å¯¹åº”çš„ç»“æžœä¸ºAP@3 = 1 * 1 + 0 * 1/2 + 0 * 1/3 = 1ã€‚ä¹Ÿå°±æ˜¯æ¯ä¸€ä½æ˜¯æœ‰æƒé‡çš„ï¼Œè¶Šé å‰æƒé‡è¶Šé«˜ï¼Œç¬¬ä¸€ä½æƒé‡ä¸º1ï¼Œç¬¬äºŒä½1/2ï¼Œç¬¬ä¸‰ä½ä¸º1/3ã€‚å¦‚æžœé¢„æµ‹ä¸ºé—¨å£°ï¼ŒçŽ»ç’ƒç ´ç¢Žå£°ï¼Œé¸Ÿå«å£°ï¼Œåˆ™AP@3 = 0 * 1 + 0 * 1/2 + 0 * 1/3 = 1/3 ã€‚ 7. å›žå½’ä»»åŠ¡çš„è¯„ä¼°æŒ‡æ ‡å›žå½’ä»»åŠ¡ä¸­æœ€å¸¸ç”¨çš„æ€§èƒ½åº¦é‡æ˜¯å‡æ–¹è¯¯å·®ï¼ˆmean squared error)ï¼š $$\begin{equation}E(f; D) = \frac{1}{m} \sum_{i=1}^m (f(x_i)-y_i)^2\end{equation} \tag{26}$$ æ›´ä¸€èˆ¬çš„ï¼Œå¯¹äºŽæ•°æ®åˆ†å¸ƒDå’Œæ¦‚çŽ‡å¯†åº¦å‡½æ•°p(Â·)ï¼Œå‡æ–¹è¯¯å·®å¯ä»¥å¦‚ä¸‹å®šä¹‰ï¼š $$\begin{equation}E(f; D) = \int_{x \sim D} (f(x) - y)^2p(x) {\rm d}x\end{equation} \tag{27}$$ 8. åŽç»­å·¥ä½œä¸Žå…¶ä»–å†…å®¹ä¸€æ ·ï¼Œæœ‰å†…å®¹ä¼šæŒç»­æ›´æ–°ã€‚ PRC Areaä¸ŽMCCè¿˜éœ€è¦åœ¨æ›´æ–°ã€‚ å‚è€ƒèµ„æ–™ï¼š http://blog.sina.com.cn/s/blog_629e606f0102v7a0.html https://en.wikipedia.org/wiki/Evaluation_of_binary_classifiers å‘¨å¿—åŽã€Šæœºå™¨å­¦ä¹ ã€‹ æŽèˆªã€Šç»Ÿè®¡å­¦ä¹ æ–¹æ³•ã€‹ https://yuchenchen.gitbook.io/machine-learning-yearning/9.-you-hua-he-man-zu-zhi-biao https://zhuanlan.zhihu.com/p/25528580 https://www.kaggle.com/c/freesound-audio-tagging#evaluation http://yucc.me/p/82f51d0e/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AIä¸€ä¸ä¸€æ¯«</tag>
        <tag>to do</tag>
        <tag>machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è¯¯å·®åå‘ä¼ æ’­ï¼ˆerror backpropagationï¼‰æŽ¨å¯¼è¿‡ç¨‹ã€å¾…å®Œæˆã€‘]]></title>
    <url>%2Fp%2F55aa0f10%2F</url>
    <content type="text"><![CDATA[è¯¯å·®åå‘ä¼ æ’­ç®—æ³•ï¼ˆerror backpropagationï¼‰æŽ¨å¯¼è¿‡ç¨‹æ˜¯æ¯ä¸ªåšæ·±åº¦å­¦ä¹ ï¼ˆdeep learningï¼‰çš„äººå‘˜å¿…ä¼šçš„åŸºæœ¬åŠŸã€‚è¿™é‡Œæ˜¯é’ˆå¯¹å‰é¦ˆç¥žç»ç½‘ç»œï¼ˆFeed Forward Neural Networkï¼‰æˆ–è€…å«å¤šå±‚æ„ŸçŸ¥æœºï¼ˆMulti Layer Perceptronï¼‰æˆ–è€…å«æ·±åº¦ç¥žç»ç½‘ç»œï¼ˆDeep Neural Networkï¼‰çš„åšä¸€ä¸ªæŽ¨å¯¼ã€‚æ­¤å¤„ç”¨åˆ°çš„è¯¯å·®å‡½æ•°æ˜¯å‡æ–¹è¯¯å·®ï¼ˆMean Squared Errorï¼‰ã€‚ 1. å‰é¦ˆç¥žç»ç½‘ç»œç®€ä»‹åŸºæœ¬ç½‘ç»œå¦‚å›¾1æ‰€ç¤ºï¼Œè¿™æ˜¯ä¸€ä¸ªåŸºæœ¬çš„ç¥žç»ç½‘ç»œï¼Œä¸‹é¢æ¥è§£æžè¿™ä¸ªç½‘ç»œç»“æž„ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬æž„é€ è¾“å…¥å˜é‡$x_1,â€¦,x_D$çš„çº¿æ€§ç»„åˆï¼Œå½¢å¼ä¸ºï¼š $$\begin{equation}{a_j} = \sum_{i=1}^D {w_{ji}}^{(1)} \cdot x_i + {w_{j0}}^{(1)}\end{equation} \tag{1}$$ å…¶ä¸­$j=1,â€¦,M$ï¼ŒMæ˜¯è¾“å‡ºçš„æ€»é‡ï¼Œä¸”ä¸Šæ ‡(1)è¡¨ç¤ºå¯¹åº”çš„å‚æ•°æ˜¯ç¥žç»ç½‘ç»œçš„ç¬¬ä¸€å±‚ã€‚${w_{ji}}^{(1)}$å«åšæƒé‡ï¼ˆweightï¼‰ï¼Œå‚æ•°$w_{j0}$å«åšåç½®ï¼ˆbiasï¼‰,$a_j$å«åšæ¿€æ´»(activation)ã€‚æ¯ä¸ªæ¿€æ´»éƒ½ä½¿ç”¨ä¸€ä¸ªéžçº¿æ€§æ¿€æ´»å‡½æ•°(activation function) $h(Â·)$è¿›è¡Œå˜æ¢ï¼Œå¾—ï¼š $$\begin{equation}z_j = h(a_j)\end{equation} \tag{2}$$ éžçº¿æ€§å‡½æ•°$h(a_j)$é€šå¸¸é€‰ç”¨sigmoidï¼Œtanhï¼Œreluç­‰ã€‚$z_j$ä¸ºç»è¿‡æ¿€æ´»å‡½æ•°çš„å€¼ã€‚è¿™äº›å€¼ä¼šå†æ¬¡çº¿æ€§ç»„åˆï¼Œå¾—åˆ°è¾“å‡ºå•å…ƒæ¿€æ´»ï¼ˆoutput unit activationï¼‰ï¼š $$\begin{equation}{a_k} = \sum_{i=1}^K {w_{kj}}^{(2)} \cdot z_j + {w_{k0}}^{(2)}\end{equation} \tag{3}$$ è¿™ä¸ªå˜æ¢å¯¹åº”äºŽç¥žç»ç½‘ç»œç¬¬äºŒå±‚ï¼Œç±»ä¼¼äºŽä¹‹å‰ã€‚æœ€åŽä½¿ç”¨ä¸€ä¸ªæ°å½“çš„æ¿€æ´»å‡½æ•°è¿›è¡Œå˜æ¢ï¼Œå¾—åˆ°ç¥žç»ç½‘ç»œçš„ä¸€ç»„è¾“å‡º$y_k$ã€‚å¯¹äºŽæ ‡å‡†å›žå½’é—®é¢˜ï¼Œæ¿€æ´»å‡½æ•°æ˜¯æ’ç­‰å‡½æ•°ï¼Œä»Žè€Œ$y_k = a_k$ã€‚å¯¹äºŽä¸€ä¸ªäºŒå…ƒåˆ†ç±»é—®é¢˜ï¼Œæ¯ä¸ªè¾“å‡ºå•å…ƒæ¿€æ´»å¯ä»¥ä½¿ç”¨logistic sigmoidè¿›è¡Œå˜æ¢ï¼Œå³: $$\begin{equation}y_k = \sigma(a_k)\end{equation} \tag{4}$$ $\sigma(Â·)$å‡½æ•°å½¢å¼è¿™é‡Œä¸å†ç»™å‡ºï¼Œå¯ä»¥è‡ªå·±æŸ¥çœ‹ã€‚å¯¹äºŽå¤šåˆ†ç±»é—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨softmaxæ¿€æ´»å‡½æ•°ã€‚ æœ€åŽç»¼åˆä»¥ä¸Šçš„è§‚ç‚¹ï¼Œæˆ‘ä»¬å®¹æ˜“å¾—åˆ°ä¸€ä¸ªç½‘ç»œæ•´ä½“ï¼Œå¦‚ä¸‹: $$\begin{equation}y_k = \sigma(\sum_{i=1}^K {w_{kj}}^{(2)} \cdot h(\sum_{i=1}^D {w_{ji}}^{(1)} \cdot x_i + {w_{j0}}^{(1)}) + {w_{k0}}^{(2)})\end{equation} \tag{5}$$ å…¶ä¸­æ‰€æœ‰æƒé‡å‚æ•°å’Œåç½®è¢«èšé›†åœ¨ä¸€èµ·ï¼Œè®°åš$\vec{w}$ã€‚å› æ­¤ï¼Œç¥žç»ç½‘ç»œå¯ä»¥ç®€å•åœ°è®¤ä¸ºæ˜¯ä»Žè¾“å…¥å˜é‡$\vec{x}$åˆ°è¾“å‡ºå˜é‡$\vec{y}$çš„éžçº¿æ€§å‡½æ•°ï¼Œæ˜ å°„ç”±è°ƒèŠ‚å‚æ•°$\vec{w}$æ¥æŽ§åˆ¶ã€‚ å…·ä½“ç½‘ç»œç»“æž„æ­£å¦‚å›¾1æ‰€ç¤ºã€‚è®¡ç®—å…¬å¼ï¼ˆ5ï¼‰çš„è¿‡ç¨‹å¯ä»¥è®¤ä¸ºæ˜¯ä¿¡æ¯é€šè¿‡ç½‘ç»œçš„å‰å‘ä¼ æ’­ï¼ˆforward propagationï¼‰ã€‚ é€šè¿‡å®šä¹‰é¢å¤–çš„è¾“å…¥å˜é‡$x_0$è®²å…¬å¼(1)ä¸­çš„åç½®å‚æ•°æ•´åˆè¿›æƒé‡å‚æ•°é›†åˆä¸­ï¼Œå¹¶ä¸”$x_0$è¢«é™å®šä¸º1ï¼Œå› æ­¤å…¬å¼ï¼ˆ1ï¼‰å¯ä»¥æ”¹å†™ä¸ºï¼š $$\begin{equation}{a_j} = \sum_{i=0}^D {w_{ji}}^{(1)} \cdot x_i\end{equation} \tag{6}$$ ç¬¬äºŒå±‚çš„åç½®ä¹Ÿåšç±»ä¼¼å¤„ç†ï¼Œæœ€ç»ˆæ•´ä½“ç½‘ç»œå‡½æ•°å¯ä»¥ä»Žå…¬å¼ï¼ˆ5ï¼‰å˜ä¸ºï¼š $$\begin{equation}y_k = \sigma(\sum_{i=0}^K {w_{kj}}^{(2)} \cdot h(\sum_{i=0}^D {w_{ji}}^{(1)} \cdot x_i))\end{equation} \tag{7}$$ è‡³æ­¤ï¼Œä¸€ä¸ªç®€å•çš„å‰é¦ˆç¥žç»ç½‘ç»œå·²ç»å®Œæˆäº†ã€‚ 2. è¯¯å·®åå‘ä¼ æ’­ç®—æ³•ç®€ä»‹æˆ‘ä»¬çš„ç›®æ ‡æ˜¯å¯»æ‰¾ä¸€ç§è®¡ç®—å‰é¦ˆç¥žç»ç½‘ç»œçš„è¯¯å·®å‡½æ•°$E(w)$çš„æ¢¯åº¦é«˜æ•ˆçš„æ–¹æ³•ã€‚æˆ‘ä»¬å°†ä¼šçœ‹åˆ°ï¼Œå¯ä»¥ä½¿ç”¨å±€éƒ¨ä¿¡æ¯ä¼ é€’çš„æ€æƒ³æ¥å®Œæˆè¿™ä¸€ç‚¹ã€‚åœ¨å±€éƒ¨ä¿¡æ¯ä¼ é€’çš„æ€æƒ³ä¸­ï¼Œä¿¡æ¯åœ¨ç¥žç»ç½‘ç»œä¸­äº¤æ›¿çš„å‘å‰ã€å‘åŽä¼ æ’­ã€‚è¿™ç§æ–¹æ³•è¢«ç§°ä¸ºè¯¯å·®åå‘ä¼ æ’­ï¼ˆerror propagationï¼‰ï¼Œæœ‰æ—¶è¢«ç§°ä¸ºbackpropï¼Œé€šå¸¸ç®€ç§°bpç®—æ³•ã€‚ å…³äºŽè®­ç»ƒè¿‡ç¨‹çš„æœ¬è´¨ã€‚å¤§éƒ¨åˆ†è®­ç»ƒç®—æ³•æ¶‰åŠåˆ°ä¸€ä¸ªè¿­ä»£çš„æ­¥éª¤ç”¨äºŽè¯¯å·®å‡½æ•°çš„æœ€å°åŒ–ï¼Œä»¥åŠé€šè¿‡ä¸€ç³»åˆ—çš„æ­¥éª¤è¿›è¡Œæƒé‡è°ƒèŠ‚ã€‚åœ¨æ¯ä¸€ä¸ªè¿™æ ·è¿­ä»£è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åŒºåˆ†è¿™ä¸¤ä¸ªä¸åŒçš„é˜¶æ®µã€‚åœ¨ç¬¬ä¸€ä¸ªé˜¶æ®µï¼Œè¯¯å·®å‡½æ•°å…³äºŽæƒé‡çš„å¯¼æ•°å¿…é¡»è¢«è®¡ç®—å‡ºæ¥ã€‚æ­£å¦‚æˆ‘ä»¬ç¨åŽçœ‹åˆ°çš„é‚£æ ·ï¼Œåå‘ä¼ æ’­ç®—æ³•çš„ä¸€ä¸ªé‡è¦è´¡çŒ®æ˜¯æä¾›äº†è®¡ç®—è¿™äº›å¯¼æ•°çš„ä¸€ä¸ªé«˜æ•ˆçš„æ–¹æ³•ã€‚ç”±äºŽæ­£æ˜¯è¿™ä¸ªé˜¶æ®µï¼Œè¯¯å·®é€šè¿‡ç½‘ç»œè¿›è¡Œä¼ æ’­ï¼Œå› æ­¤æˆ‘ä»¬å°†ä¸“é—¨ä½¿ç”¨åå‘ä¼ æ’­è¿™ä¸ªå±žäºŽæ¥æè¿°è®¡ç®—å¯¼æ•°çš„è¿‡ç¨‹ã€‚åœ¨ç¬¬äºŒä¸ªé˜¶æ®µï¼Œå¯¼æ•°ç”¨äºŽè®¡ç®—æƒé‡çš„è°ƒæ•´é‡ã€‚æœ€ç®€å•çš„æ–¹æ³•ï¼Œä¹Ÿæ˜¯æœ€å¼€å§‹ç”±Rumelhart et al.ï¼ˆ1986ï¼‰è€ƒè™‘çš„æ–¹æ³•ï¼Œæ¶‰åŠåˆ°æ¢¯åº¦ä¸‹é™ã€‚è®¤è¯†åˆ°è¿™ä¸¤ä¸ªé˜¶æ®µå±žäºŽä¸åŒçš„é˜¶æ®µæ˜¯å¾ˆé‡è¦çš„ã€‚å› æ­¤ï¼Œç¬¬ä¸€é˜¶æ®µï¼Œå³ä¸ºäº†è®¡ç®—å¯¼æ•°è€Œè¿›è¡Œçš„è¯¯å·®åœ¨ç½‘ç»œä¸­çš„åå‘ä¼ æ’­é˜¶æ®µï¼Œå¯ä»¥åº”ç”¨äºŽè®¸å¤šä¸åŒç§ç±»çš„ç½‘ç»œï¼Œè€Œä¸ä»…ä»…æ˜¯å¤šå±‚æ„ŸçŸ¥å™¨ã€‚å®ƒä¹Ÿå¯ä»¥ åº”ç”¨äºŽå…¶ä»–çš„è¯¯å·®å‡½æ•°ï¼Œè€Œä¸ä»…ä»…æ˜¯ç®€å•çš„å¹³æ–¹å’Œè¯¯å·®å‡½æ•°ã€‚å®ƒä¹Ÿå¯ä»¥ç”¨äºŽè®¡ç®—å…¶ä»–ç±»åž‹çš„å¯¼æ•°ã€‚ç¬¬äºŒé˜¶æ®µï¼Œå³ä½¿ç”¨è®¡ç®—è¿‡çš„å¯¼æ•°è°ƒæ•´æƒé‡çš„é˜¶æ®µï¼Œå¯ä»¥ä½¿ç”¨è®¸å¤šæœ€ä¼˜åŒ–æ–¹æ³•å¤„ç†ï¼Œè®¸å¤šæœ€ä¼˜åŒ–æ–¹æ³•æœ¬è´¨ä¸Šè¦æ¯”ç®€å•çš„æ¢¯åº¦ä¸‹é™æ›´å¼ºå¤§ã€‚ 3. ç®€å•çº¿æ€§æ¨¡åž‹è¯¯å·®å¯¼æ•°çš„è®¡ç®—è®¸å¤šå®žé™…åº”ç”¨ä¸­ä½¿ç”¨çš„è¯¯å·®å‡½æ•°ï¼Œä¾‹å¦‚é’ˆå¯¹ä¸€ç»„ç‹¬ç«‹åŒåˆ†å¸ƒçš„æ•°æ®çš„æœ€å¤§ä¼¼ç„¶æ–¹æ³•å®šä¹‰çš„è¯¯å·®å‡½æ•°ï¼Œç”±è‹¥å¹²é¡¹çš„æ±‚å’Œå…¬å¼ç»„æˆã€‚æ¯ä¸€é¡¹å¯¹åº”äºŽè®­ç»ƒé›†ä¸­çš„ä¸€ä¸ªæ•°æ®ç‚¹ï¼Œå³ï¼š $$\begin{equation}E(w) = \sum_{n=1}^N {w}\end{equation} \tag{8}$$ è¿™é‡Œï¼Œæˆ‘ä»¬è¦è€ƒè™‘è®¡ç®—$\nabla E_n(w)$çš„é—®é¢˜ã€‚è¿™å¯ä»¥ç›´æŽ¥ä½¿ç”¨é¡ºåºä¼˜åŒ–çš„æ–¹æ³•è®¡ç®—ï¼Œæˆ–è€…ä½¿ç”¨æ‰¹å¤„ç†æ–¹æ³•åœ¨è®­ç»ƒé›†ä¸Šè¿›è¡Œç´¯åŠ ã€‚ å¯¹äºŽä¸€ä¸ªç‰¹å®šçš„è¾“å…¥æ¨¡å¼nï¼ˆç­‰ä»·äºŽå¯¹äºŽä¸€ä¸ªç‰¹å®šçš„æ ·æœ¬$\vec{x}$ï¼‰ï¼Œè¯¯å·®å‡½æ•°å½¢å¼ä¸ºï¼š $$\begin{equation}E_n = \frac{1}{2} \cdot \sum_{k} {(y_{nk}-t_{nk})}^2\end{equation} \tag{9}$$ å…¶ä¸­$y_{nk} = y_k(\vec{x_n}, \vec{w})$ï¼Œ$y_{nk}$è¡¨ç¤ºå¯¹äºŽç‰¹å®šè¾“å…¥æ¨¡å¼çš„è¾“å‡ºï¼Œ$t_{nk}$è¡¨ç¤ºå¯¹åº”çš„å®žé™…æ ‡ç­¾ï¼ˆæˆ–é¢„æµ‹å€¼ï¼‰ã€‚è¿™ä¸ªè¯¯å·®å‡½æ•°å…³äºŽæƒé‡$w_{ji}$çš„æ¢¯åº¦ä¸ºï¼š $$\begin{equation}\frac{E_n}{w_{ji}} = (y_{nj} - t_{nj})x_{ni}\end{equation} \tag{10}$$ å®ƒå¯ä»¥è¡¨ç¤ºä¸ºä¸Žé“¾æŽ¥$w_{ji}$çš„è¾“å‡ºç«¯å…³è”çš„â€œè¯¯å·®ä¿¡å·â€$y_{nj}-t_{nj}$å’Œä¸Žé“¾æŽ¥çš„è¾“å…¥ç«¯ç›¸å…³è¿žçš„å˜é‡$x_{ni}$çš„ä¹˜ç§¯ã€‚æˆ‘ä»¬çŽ°åœ¨ä¼šçœ‹åˆ°è¿™ä¸ªç®€å•çš„ç»“æžœå¦‚ä½•æ‰©å±•åˆ°æ›´å¤æ‚çš„å¤šå±‚å‰é¦ˆç¥žç»ç½‘ç»œä¸­ã€‚ 4. é€šç”¨å‰é¦ˆç¥žç»ç½‘ç»œbpç®—æ³•æŽ¨å¯¼ 5. ä¸€ä¸ªç®€å•çš„ä¾‹å­å‚è€ƒèµ„æ–™ï¼š BISHOP, C, M. Pattern recognition and machine learning[M]. New York:Springer, 2006. 225-244 http://yucc.me/p/55aa0f10/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AIä¸€ä¸ä¸€æ¯«</tag>
        <tag>to do</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 3 è¯»å–ä¸­æ–‡æ–‡ä»¶]]></title>
    <url>%2Fp%2F6821aaf2%2F</url>
    <content type="text"><![CDATA[åœ¨windowsçŽ¯å¢ƒä¸‹ï¼Œpython3 è¯»å–ä¸­æ–‡æ–‡ä»¶æ–¹æ³•ï¼ŒæŠ˜è…¾äº†å¾ˆä¹…ï¼Œæ€»ç»“äº†ä¸‹ã€‚ å…ˆæ‰¾åˆ°æ–‡ä»¶ç¼–ç æ ¼å¼ã€‚ å› ä¸ºè¯»æ–‡ä»¶çš„æ—¶å€™ï¼Œéœ€è¦çŸ¥é“æ–‡ä»¶çš„ç¼–ç æ ¼å¼ï¼Œç¼–ç æ ¼å¼æ€Žä¹ˆçœ‹å‘¢ï¼Ÿ æˆ‘çš„æ–¹æ³•æ˜¯ï¼Œä½¿ç”¨windowsè‡ªå¸¦çš„è®°äº‹æœ¬æ‰“å¼€æ–‡ä»¶ï¼Œç„¶åŽctrl+shift+sï¼Œæˆ–æ–‡ä»¶-å¦å­˜ä¸ºï¼Œå¯ä»¥çœ‹åˆ°æ–‡ä»¶çš„ç¼–ç æ ¼å¼ã€‚ å¸¸è§çš„ç¼–ç æ ¼å¼æœ‰utf-8ï¼Œgbkï¼Œgb2312ã€‚æˆ‘ä»Šå¤©æŠŠè¿™äº›ç¼–ç æ ¼å¼éƒ½è¯•äº†å‘çŽ°éƒ½ä¸èƒ½è§£ç ï¼Œæœ€åŽå‘çŽ°æ–‡ä»¶ç¼–ç æ ¼å¼æ˜¯Unicode big endianï¼Œç„¶åŽçœ‹åˆ°Stack Overflowä¸Šè¯´ï¼Œç¼–ç å°±æ˜¯UTF-16[1]ï¼Œæœ€ç»ˆè§£å†³é—®é¢˜ã€‚ ç¼–å†™ç›¸åº”ä»£ç ã€‚ ä¸¤ç§æ–¹æ³•ï¼Œæ–¹æ³•ä¸€ï¼Œä½¿ç”¨codecsæ¨¡å—ï¼š 123import codecswith codecs.open(file, 'r', encoding='utf-16') as f: text = f.read() æˆ– 12with open(file, 'rb') as f: text = f.read().decode('utf-16') æ–¹æ³•äºŒï¼š 12with open(file, 'r', encoding='UTF-16') as f: text = f.read() è‡ªå·±å†™çš„æ—¶å€™è®°å¾—ä¿®æ”¹encodingä¸ºè‡ªå·±æ–‡ä»¶çš„ç›¸åº”æ ¼å¼ï¼ŒåŒæ—¶æ ¹æ®è‡ªå·±éœ€è¦ä¿®æ”¹è¯»å†™ã€‚ å‚è€ƒèµ„æ–™ï¼š https://stackoverflow.com/questions/8827419/converting-utf-16-utf-8-and-remove-bom http://yucc.me/p/6821aaf2/]]></content>
      <categories>
        <category>experience of code</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>ç¼–ç </tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€ŠA consolidated perspective on multi-microphone speech enhancement and source separationã€‹ é˜…è¯»ç¬”è®°ã€å¾…å®Œæˆã€‘]]></title>
    <url>%2Fp%2F9c92dc77%2F</url>
    <content type="text"><![CDATA[è®ºæ–‡A consolidated perspective on multi-microphone speech enhancement and source separationé˜…è¯»åˆ†äº« å‚è€ƒèµ„æ–™ http://yucc.me/p/9c92dc77/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AIä¸€ä¸ä¸€æ¯«</tag>
        <tag>speech enhancement</tag>
        <tag>paper</tag>
        <tag>to do</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç»æµŽå­¦äººï¼ˆThe Economistï¼‰EPUBï¼ŒMOBI,ï¼ŒPDFåŠMP3åˆ†äº«ä¸‹è½½]]></title>
    <url>%2Fp%2F1c573a7b%2F</url>
    <content type="text"><![CDATA[ç®€ä»‹ã€Šç»æµŽå­¦äººã€‹æ˜¯ä¸€ä»½ç”±ä¼¦æ•¦ç»æµŽå­¦äººæŠ¥çº¸æœ‰é™å…¬å¸å‡ºç‰ˆçš„æ‚å¿—ï¼Œåˆ›åŠžäºŽ1843å¹´9æœˆï¼Œåˆ›åŠžäººè©¹å§†å£«Â·å¨å°”é€Šã€‚æ‚å¿—çš„å¤§å¤šæ•°æ–‡ç« å†™å¾—æœºæ™ºï¼Œå¹½é»˜ï¼Œæœ‰åŠ›åº¦ï¼Œä¸¥è‚ƒåˆä¸å¤±è¯™è°ï¼Œå¹¶ä¸”æ³¨é‡äºŽå¦‚ä½•åœ¨æœ€å°çš„ç¯‡å¹…å†…å‘Šè¯‰è¯»è€…æœ€å¤šçš„ä¿¡æ¯ã€‚è¯¥æ‚å¿—åˆä»¥å‘æ˜Žå·¨æ— éœ¸æŒ‡æ•°é—»åï¼Œæ˜¯ç¤¾ä¼šç²¾è‹±å¿…ä¸å¯å°‘çš„è¯»ç‰©ã€‚è¯¥æ‚å¿—è‹±æ–‡ç”µå­ç‰ˆå¯é€šè¿‡ç§»åŠ¨Appã€ç½‘ç«™æˆ–è€…æœ‰å£°ç‰ˆé˜…è¯»æ¯å‘¨å®Œæ•´å†…å®¹ã€‚ æ‚å¿—ä¸»è¦å…³æ³¨æ”¿æ²»å’Œå•†ä¸šæ–¹é¢çš„æ–°é—»ï¼Œä½†æ˜¯æ¯æœŸä¹Ÿæœ‰ä¸€ä¸¤ç¯‡é’ˆå¯¹ç§‘æŠ€å’Œè‰ºæœ¯çš„æŠ¥å¯¼ï¼Œä»¥åŠä¸€äº›ä¹¦è¯„ã€‚æ‚å¿—ä¸­æ‰€æœ‰æ–‡ç« éƒ½ä¸ç½²åï¼Œè€Œä¸”å¾€å¾€å¸¦æœ‰é²œæ˜Žçš„ç«‹åœºï¼Œä½†åˆå¤„å¤„ç”¨äº‹å®žè¯´è¯ã€‚ä¸»ç¼–ä»¬è®¤ä¸ºï¼šå†™å‡ºäº†ä»€ä¹ˆä¸œè¥¿ï¼Œæ¯”å‡ºè‡ªè°çš„æ‰‹ç¬”æ›´é‡è¦ã€‚ä»Ž2012å¹´1æœˆ28æ—¥çš„é‚£ä¸€æœŸæ‚å¿—å¼€å§‹ã€Šç»æµŽå­¦äººã€‹æ‚å¿—å¼€è¾Ÿäº†ä¸­å›½ä¸“æ ï¼Œä¸ºæœ‰å…³ä¸­å›½çš„æ–‡ç« æä¾›æ›´å¤šçš„ç‰ˆé¢ã€‚ è¿‘æœŸä¸‹è½½é“¾æŽ¥åŠè¯´æ˜Žå†…å®¹æ ¼å¼å«EPUBï¼ŒMOBI,ï¼ŒPDFåŠMP3ã€‚ç‚¹è¿›æ—¥æœŸè¿›åŽ»å°±åˆ°äº†ç™¾åº¦ç½‘ç›˜é“¾æŽ¥ï¼Œè¾“å…¥åŽé¢çš„å¯†ç å°±å¯ä»¥äº†ã€‚æœ¬å†…å®¹ä¼šæŒç»­æ›´æ–°ã€‚ä»…ä¾›å­¦ä¹ äº¤æµä½¿ç”¨ï¼Œè¯·å‹¿ç”¨ä½œå•†ä¸šç”¨é€”ã€‚ 20180519 å¯†ç : yd8dã€‚ 20180512 å¯†ç : 7gkaã€‚ 20180505 å¯†ç : ygdxã€‚ 20180428 å¯†ç ï¼š8v3dã€‚ 20180421 å¯†ç ï¼škdpnã€‚ 20180414 å¯†ç : u2xaã€‚ 20180407 å¯†ç : z44rã€‚ 2018å¹´1æœˆ-4æœˆã€2017å¹´å…¨å¹´ã€2016å¹´å…¨å¹´ä¸‹è½½é“¾æŽ¥2018å¹´å…¨å¹´ç»æµŽå­¦äººä¸‹è½½ï¼ˆå«EPUBã€MOBIã€PDFã€MP3ï¼‰ å¯†ç : ihqwã€‚ 2017å¹´å…¨å¹´ç»æµŽå­¦äººä¸‹è½½ï¼ˆå«EPUBã€MOBIã€PDFã€MP3ï¼‰ å¯†ç : 57z5ã€‚ 2016å¹´å…¨å¹´ç»æµŽå­¦äººä¸‹è½½ï¼ˆå«EPUBã€MOBIã€PDFã€MP3ï¼‰ å¯†ç : v2bdã€‚ å‚è€ƒèµ„æ–™ http://yucc.me/p/1c573a7b/]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>ç»æµŽå­¦äºº</tag>
        <tag>The Economist</tag>
        <tag>ä¸‹è½½</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[machine-learning-yearning(by Andrew Ng) 1-22ç« ç¿»è¯‘æœ€æ–°ç‰ˆ]]></title>
    <url>%2Fp%2Fb706c49c%2F</url>
    <content type="text"><![CDATA[machine-learning-yearningæœ¬å†…å®¹æ˜¯Andrew NGçš„My Machine Learning Yearning 1-22ç« å†…å®¹çš„ç¿»è¯‘åŠå…¶åŽŸç¨¿ï¼Œä¼šæŒç»­æ›´æ–°ã€‚ Andrewè¡¨ç¤ºæœ€è¿‘æ¯å‘¨ä¼šæŒç»­æ›´æ–°æœ¬ä¹¦ç±ï¼Œæˆ‘å†³å®šæŠŠå®ƒç¿»è¯‘å‡ºæ¥ï¼ŒåŠ æ·±è‡ªå·±çš„å°è±¡ï¼ŒåŒæ—¶å¸Œæœ›èƒ½å¯¹å¤§å®¶æœ‰ç‚¹å¸®åŠ©ï¼ŒåŽç»­ä¼šæŒç»­æ›´æ–°ã€‚ æœ¬ä¹¦å®˜ç½‘ï¼šhttp://www.mlyearning.org/ Andrew Ngå…³äºŽæœ¬ä¹¦ä»‹ç»äº²çˆ±çš„æœ‹å‹ï¼Œä½ æ˜¯å¦‚ä½•ç»„ç»‡ä¸€ä¸ªäººå·¥æ™ºèƒ½ï¼ˆAIï¼‰é¡¹ç›®çš„å‘¢ï¼Ÿ äººå·¥æ™ºèƒ½ï¼ˆAIï¼‰ï¼Œæœºå™¨å­¦ä¹ ï¼ˆMachine Leaningï¼‰å’Œæ·±åº¦å­¦ä¹ ï¼ˆDeep learningï¼‰æ­£åœ¨æ”¹å˜ä¼—å¤šè¡Œä¸šã€‚æˆ‘ä¸€ç›´åœ¨å†™æ­¤ä¹¦â€”â€”Machine Learning Yearningï¼Œæ¥æ•™ä½ å¦‚ä½•æž„å»ºæœºå™¨å­¦ä¹ é¡¹ç›®ã€‚ æœ¬ä¹¦çš„é‡ç‚¹ä¸åœ¨äºŽæ•™æŽˆæœºå™¨å­¦ä¹ ç®—æ³•ï¼Œè€Œåœ¨äºŽä½¿æœºå™¨å­¦ä¹ ç®—æ³•å‘æŒ¥ä½œç”¨ã€‚ä¸€äº›äººå·¥æ™ºèƒ½æŠ€æœ¯ä¼šç»™ä½ ä¸€ä¸ªé”¤å­ï¼Œè€Œæœ¬ä¹¦æ•™ä½ å¦‚ä½•ä½¿ç”¨é”¤å­ã€‚å¦‚æžœä½ æ¸´æœ›æˆä¸ºäººå·¥æ™ºèƒ½æŠ€æœ¯çš„é¢†å¯¼è€…å¹¶æƒ³å­¦ä¹ å¦‚ä½•ä¸ºä½ çš„å›¢é˜Ÿè®¾å®šæ–¹å‘ï¼Œè¿™æœ¬ä¹¦å°†ä¼šæœ‰æ‰€å¸®åŠ©ã€‚ é˜…è¯»å®ŒMachine Learning Yearningä¹‹åŽï¼Œä½ å°†èƒ½å¤Ÿï¼š ä¸ºäººå·¥æ™ºèƒ½é¡¹ç›®æœ€æœ‰å‰é€”çš„æ–¹å‘è®¾ç«‹ä¼˜å…ˆçº§ è¯Šæ–­æœºå™¨å­¦ä¹ ç³»ç»Ÿä¸­çš„é”™è¯¯ åœ¨å¤æ‚è®¾ç½®ä¸­æž„å»ºæœºå™¨å­¦ä¹ ï¼Œä¾‹å¦‚ä¸åŒ¹é…çš„è®­ç»ƒé›†/æµ‹è¯•é›† å»ºç«‹ä¸€ä¸ªå¯ä»¥äººç±»æ¯”è¾ƒæˆ–è¶…è¶Šäººç±»è¡¨çŽ°çš„æœºå™¨å­¦ä¹ é¡¹ç›® äº†è§£ä½•æ—¶ä»¥åŠå¦‚ä½•åº”ç”¨ç«¯åˆ°ç«¯å­¦ä¹ ï¼ˆend-to-end learningï¼‰ï¼Œè¿ç§»å­¦ä¹ ï¼ˆtransfer learningï¼‰å’Œå¤šä»»åŠ¡å­¦ä¹ ï¼ˆmulti-task learningï¼‰ ä»ŽåŽ†å²ä¸Šçœ‹ï¼Œå­¦ä¹ å¦‚ä½•åˆ¶å®šè¿™äº›â€œç­–ç•¥â€å†³ç­–çš„å”¯ä¸€æ–¹æ³•æ˜¯åœ¨ç ”ç©¶ç”Ÿè¯¾ç¨‹æˆ–å…¬å¸ä¸­åšå¤šå¹´çš„å­¦å¾’ã€‚æˆ‘æ­£åœ¨å†™çš„Machine Learning Yearningå¯ä»¥å¸®ä½ å¿«é€Ÿçš„èŽ·å¾—è¿™é¡¹æŠ€èƒ½ï¼Œä»¥ä¾¿ä½ å¯ä»¥æ›´å¥½åœ°æž„å»ºäººå·¥æ™ºèƒ½ç³»ç»Ÿã€‚ æœ¬ä¹¦å¤§çº¦100é¡µï¼ŒåŒ…å«å¾ˆå¤šæ˜“äºŽé˜…è¯»çš„1-2é¡µçš„ç« èŠ‚ã€‚å¦‚æžœä½ å¸Œæœ›æ”¶åˆ°æ¯ç« å®ŒæˆåŽçš„è‰ç¨¿ï¼Œè¯·æ³¨å†Œé‚®ä»¶åˆ—è¡¨ã€‚ â€”â€” å´æ©è¾¾ï¼ˆAndrew Ngï¼‰ ç¿»è¯‘ç‰ˆgitbooké˜…è¯»åœ°å€ï¼šgitbooké˜…è¯»ä½“éªŒæ›´å¥½ï¼Œæ¬¢è¿Žæ¥ç‚¹å‡»ä¸‹é¢é“¾æŽ¥é˜…è¯»ç¿»è¯‘ç‰ˆï¼š https://yuchenchen.gitbook.io/machine-learning-yearning/ ç¿»è¯‘ç‰ˆgithubåœ°å€ï¼šhttps://github.com/yucc2018/machine-learning-yearning è‹±æ–‡åŽŸç‰ˆpdfä¸‹è½½ï¼šåŽŸæ–‡åŽŸç‰ˆæ‰‹ç¨¿å·²ç»æ›´æ–°åˆ°19ç« ï¼Œä¸‹è½½é“¾æŽ¥åˆ†åˆ«å¦‚ä¸‹: 1-14ç« pdfä¸‹è½½ï¼ˆ2018.04.18ç‰ˆï¼‰ 15-19ç« pdfä¸‹è½½ï¼ˆ2018.04.25ç‰ˆï¼‰ 20-22ç« pdfä¸‹è½½ï¼ˆ2018.05.02ç‰ˆï¼‰ æˆ‘è‡ªå·±æ‰‹åŠ¨å°†ä¸Šé¢ä¸¤éƒ¨åˆ†åˆå¹¶ï¼Œæˆä¸º1-19ç« çš„åˆé›†ã€‚æƒ³ä¸‹è½½ä¸€ä¸ªçš„ç›´æŽ¥ç‚¹ä¸‹é¢è¿™ä¸ªé“¾æŽ¥ã€‚ 1-22ç« åˆå¹¶ç‰ˆpdfä¸‹è½½ï¼ˆ2018.05.02æ›´æ–°ï¼‰ ç¿»è¯‘ç« èŠ‚ï¼š1. ä¸ºä»€ä¹ˆæ˜¯æœºå™¨å­¦ä¹ ç­–ç•¥ï¼Ÿ 2. å¦‚ä½•ä½¿ç”¨æœ¬ä¹¦æ¥å¸®åŠ©ä½ çš„å›¢é˜Ÿ 3. é¢„å¤‡çŸ¥è¯†å’Œè¡¨ç¤ºç¬¦å· 4. è§„æ¨¡æŽ¨åŠ¨æœºå™¨å­¦ä¹ è¿›åº¦ ä¸‹ä¸€éƒ¨åˆ†ï¼šè®¾ç½®å¼€å‘å’Œæµ‹è¯•é›† 5. ä½ çš„å¼€å‘é›†å’Œæµ‹è¯•é›† 6. ä½ çš„å¼€å‘é›†å’Œæµ‹è¯•é›†åº”å½“æ¥è‡ªç›¸åŒçš„åˆ†å¸ƒ 7. å¼€å‘é›†å’Œæµ‹è¯•é›†éœ€è¦å¤šå¤§ï¼Ÿ 8. ä¸ºä½ çš„å›¢é˜Ÿè¿›è¡Œç®—æ³•ä¼˜åŒ–å»ºç«‹ä¸€ä¸ªå•æ•°å­—ä¼°æŒ‡æ ‡ 9. ä¼˜åŒ–å’Œæ»¡è¶³æŒ‡æ ‡ 10. ä½¿ç”¨å¼€å‘é›†å’Œè¯„ä¼°æŒ‡æ ‡æ¥åŠ é€Ÿè¿­ä»£ 11. ä½•æ—¶æ›´æ”¹å¼€å‘é›†/æµ‹è¯•é›†å’Œè¯„ä¼°æŒ‡æ ‡ 12. å°ç»“ï¼šè®¾ç½®å¼€å‘é›†å’Œæµ‹è¯•é›† ä¸‹ä¸€éƒ¨åˆ†ï¼šåŸºæœ¬é”™è¯¯åˆ†æž 13. å¿«é€Ÿæž„å»ºä½ çš„ç¬¬ä¸€ä¸ªç³»ç»Ÿï¼Œç„¶åŽè¿­ä»£ 14. é”™è¯¯åˆ†æžï¼šæŸ¥çœ‹å¼€å‘é›†çš„ä¾‹å­æ¥è¯„ä¼°æƒ³æ³• 15. åœ¨é”™è¯¯åˆ†æžä¸­å¹¶è¡Œè¯„ä¼°å¤šä¸ªæƒ³æ³• 16. æ¸…ç†é”™è¯¯æ ‡è®°çš„å¼€å‘é›†å’Œæµ‹è¯•é›†æ ·ä¾‹ 17. å¦‚æžœä½ æœ‰ä¸€ä¸ªå¾ˆå¤§çš„å¼€å‘é›†ï¼Œå°†å®ƒåˆ†æˆä¸¤ä¸ªï¼Œè€Œä¸”ä½ åªçœ‹ä¸€ä¸ª 18. çœ¼çƒå¼€å‘é›†å’Œé»‘ç›’å¼€å‘é›†åº”è¯¥å¤šå¤§ï¼Ÿ 19. åŸºæœ¬é”™è¯¯åˆ†æž ä¸‹ä¸€éƒ¨åˆ†ï¼šåå·®ï¼ˆBiasï¼‰å’Œæ–¹å·®ï¼ˆVarianceï¼‰ 20. åå·®ï¼ˆBiasï¼‰å’Œæ–¹å·®ï¼ˆVarianceï¼‰ï¼šé”™è¯¯çš„ä¸¤å¤§æ¥æº 21. åå·®ï¼ˆBiasï¼‰å’Œæ–¹å·®ï¼ˆvarianceï¼‰çš„ä¾‹å­ 22. å¯¹æ¯”æœ€ä¼˜é”™è¯¯çŽ‡ å¾…Andrewæ›´æ–°åŽç¿»è¯‘ç« èŠ‚ï¼š Addressing Bias and Variance Bias vs. Variance tradeoff Techniques for reducing avoidable bias Techniques for reducing Variance Error analysis on the training set Diagnosing bias and variance: Learning curves Plotting training error Interpreting learning curves: High bias Interpreting learning curves: Other cases Plotting learning curves Why we compare to human-level performance How to define human-level performance Surpassing human-level performance Why train and test on different distributions Whether to use all your data Whether to include inconsistent data Weighting data Generalizing from the training set to the dev set Addressing Bias, and Variance, and Data Mismatch Addressing data mismatch Artificial data synthesis The Optimization Verification test General form of Optimization Verification test Reinforcement learning example The rise of end-to-end learning More end-to-end learning examples Pros and cons of end-to-end learning Learned sub-components Directly learning rich outputs Error Analysis by Parts Beyond supervised learning: Whatâ€™s next? Building a superhero team - Get your teammates to read this Big picture Credits è”ç³»æ–¹å¼ï¼š6506666@gmail.com å‚è€ƒèµ„æ–™ï¼š http://yucc.me/p/b706c49c/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AIä¸€ä¸ä¸€æ¯«</tag>
        <tag>to do</tag>
        <tag>machine learning</tag>
        <tag>machine learning yearning</tag>
        <tag>Andrew Ng</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017å¹´ç®—æ³•å·¥ç¨‹å¸ˆï¼ˆæœºå™¨å­¦ä¹ æ–¹å‘ï¼‰æ‰¾å®žä¹ æ‰¾æ ¡æ‹›ç»éªŒæ€»ç»“]]></title>
    <url>%2Fp%2F102faecd%2F</url>
    <content type="text"><![CDATA[å†™åœ¨å‰é¢ï¼Œè¿™æ˜¯æˆ‘åŽ»å¹´å¹´åº•ï¼ˆ2017.12ï¼‰ä¾æ®è‡ªå·±æ‰¾å®žä¹ æ‰¾å·¥ä½œç»åŽ†æ’°å†™ï¼Œåˆ†äº«åœ¨åŒ—é‚®äººbbsä¸Šçš„æ–‡ç« ï¼Œè§‰å¾—è¿˜æ˜¯æœ‰ä»·å€¼çš„ï¼Œé‡æ–°å‘è¡¨åœ¨è¿™é‡Œã€‚ 2017å¹´å³å°†è¿‡åŽ»ï¼Œä»Šå¹´æ˜¯å¿™ç¢Œçš„ä¸€å¹´ï¼Œä»Ž2æœˆ17è¿˜æ²¡å¼€å­¦å°±æ¥å­¦æ ¡ï¼Œåˆ°çŽ°åœ¨12æœˆåˆï¼Œå·¥ä½œçš„äº‹æƒ…ç»ˆäºŽå°˜åŸƒè½å®šï¼ŒçŽ°å°†è¿™ä¸€æ®µç»åŽ†å†™ä¸‹æ¥ï¼Œå¸Œæœ›èƒ½å¸®åŠ©æ¥å¹´æ‰¾å·¥ä½œçš„å­¦å¼Ÿå­¦å¦¹ï¼ŒåŒæ—¶ï¼Œå¯¹è‡ªå·±æ¥è¯´ï¼Œä¹Ÿæ˜¯ä¸€å¹´çš„å·¥ä½œæ€»ç»“ï¼Œæ€»ç»“ç»éªŒæ•™è®­ï¼Œå¯¹è‡ªå·±ä¸€ä¸ªæå‡ã€‚ ç®€å•ä»‹ç»ä¸€ä¸‹ï¼ŒåŒ—é‚®æœ¬ç¡•ï¼Œè¦æ‰¾çš„å²—ä½ä¸»è¦æ˜¯ç®—æ³•å·¥ç¨‹å¸ˆï¼ˆæœºå™¨å­¦ä¹ æ–¹å‘ï¼‰ã€‚ç®—æ³•å·¥ç¨‹å¸ˆæ‰¾å®žä¹ çš„æ—¶å€™ï¼Œæœ€ç»ˆçš„ç»“æžœæ˜¯æ‰¾åˆ°äº†å››å®¶ï¼šäºšé©¬é€Šã€äº¬ä¸œã€æ»´æ»´ã€è…¾è®¯åœ°å›¾ã€‚æ‰¾å·¥ä½œçš„æ—¶å€™ï¼Œä¸»è¦æœ‰ç™¾åº¦spã€æ»´æ»´spã€ç¾Žå›¢spã€æ–°æµªspã€æœç‹—spã€å°ç±³ï¼ˆæ²¡è°ˆè–ªèµ„ç›´æŽ¥æ‹’äº†ï¼‰ç­‰ã€‚æ€»ä½“è€Œè¨€ï¼Œä»Šå¹´æ‰¾å·¥ä½œç›¸å¯¹ä»¥å¾€è¿˜æ˜¯å¾ˆé¡ºåˆ©çš„ï¼Œå„å¤§å…¬å¸éƒ½å¾ˆç¼ºäººï¼Œå„å®¶å¼€å‡ºçš„å·¥èµ„ç›¸å¯¹äºŽåŽ»å¹´éƒ½éžå¸¸è¯±äººï¼Œæ‰¾å·¥ä½œçš„æƒ…å†µä¹Ÿå‡ºä¹Žäº†æˆ‘ä»¬å¾ˆå¤šäººçš„æ„æ–™ã€‚ å¹´åˆçš„æ—¶å€™ï¼Œå¤§æ¦‚2æœˆ28å·¦å³å¼€å­¦å§ï¼Œæˆ‘2æœˆ16å°±æ¥äº†ï¼Œå¼€å§‹å‡†å¤‡æ‰¾å®žä¹ ã€‚ç®€å•çš„è¯´ä¸€ä¸‹é¢è¯•çš„æƒ…å†µï¼Œæœ‰äº›å¯èƒ½å·²ç»å¿˜è®°ï¼ŒçŽ°åœ¨è¯´ä¸ªå¤§æ¦‚æƒ…å†µã€‚ å„å®¶é¢è¯•æƒ…å†µ æ»´æ»´ï¼Œå®žä¹ çš„æ˜¯åœ¨è®ºå›æ‹›äººå†…æŽ¨çš„ï¼Œä¸¤é¢ï¼Œç¬¬ä¸€é¢æ˜¯ä¸»è¦é—®äº†svm lrç­‰åŽŸç†ï¼Œç®€åŽ†ä¸Šçš„é¡¹ç›®ï¼Œsvmæ€Žä¹ˆç”¨äºŽå¤šåˆ†ç±»ã€‚ç¬¬äºŒé¢å†™äº†ä¸€é“ç®—æ³•é¢˜ï¼Œleetcode 63. Unique Paths IIã€‚é—®æˆ‘æ˜¯å¦ä¼šç”¨sparkï¼Œæˆ‘è¯´ä¸ä¼šã€‚ç„¶åŽå°±ç»™æˆ‘ä»‹ç»äº†ä»–ä»¬æ‰€åšçš„é¡¹ç›®ã€‚åŽæ¥å›žæ¥çš„è·¯ä¸Šæˆ‘æƒ³äº†æƒ³ï¼Œå½“æ—¶é—®æˆ‘æ˜¯å¦ä¼šä¸ä¼šsparkï¼Œæˆ‘åº”è¯¥è¯´æˆ‘è™½ç„¶ä¸ä¼šï¼Œä½†æ˜¯å¯ä»¥å­¦çš„ï¼Œç•™ä¸ªå¥½å°è±¡ã€‚æ²¡è¿‡å¤šä¹…ï¼Œå°±å‘äº†å®žä¹ offerã€‚åŽæ¥åŽ»äº†æ»´æ»´å®žä¹ ã€‚å®žä¹ è½¬æ­£ä¸‰é¢ï¼Œæ¯é¢åŠå°æ—¶ï¼Œæ‰€ä»¥è¿˜æ˜¯ç›¸å¯¹å®¹æ˜“äº†å¾ˆå¤šã€‚è½¬æ­£ä¸€é¢ï¼Œä¸»è¦é—®äº†åœ¨æ»´æ»´çš„å®žä¹ ï¼Œç»™æˆ‘çš„æŸ‘æ©˜æ˜¯æ›´åé‡ä¸šåŠ¡ï¼Œå¯¹æŠ€æœ¯å¹¶ä¸æ˜¯å¤ªçƒ­è¡·ï¼Œåšçš„é¡¹ç›®çš„ä¸šåŠ¡çš„ä¸»è¦åº”ç”¨æ˜¯ä»€ä¹ˆï¼Œå°†æ¥æ€Žä¹ˆè¯„ä»·ä¹‹ç±»çš„ã€‚ä¸€é“ç®—æ³•é¢˜ï¼Œleetcodeä¸Šçš„ï¼Œæ—‹è½¬æ•°ç»„ï¼Œleetcode 59. Spiral Matrix IIã€‚è½¬æ­£äºŒé¢ï¼Œä¹Ÿæ˜¯é—®äº†é—®æ»´æ»´çš„å®žä¹ ï¼Œé—®äº†ä¸‹gbdtçš„åŽŸç†ï¼Œxgboostä¸Žgbdtçš„åŒºåˆ«ï¼Œgbdtç”¨äºŽåˆ†ç±»æ—¶ï¼Œåˆ†ç±»æ¦‚çŽ‡çš„æ¢¯åº¦ä½“çŽ°åœ¨å“ªé‡Œã€‚ä¸€é“ç¼–ç¨‹é¢˜ï¼ŒçŸ©é˜µAä¸ŽçŸ©é˜µBç›¸ä¹˜å¾—åˆ°çŸ©é˜µCï¼Œç»™å®šAå’ŒBï¼Œæ±‚Cçš„ç§©ã€‚è½¬æ­£ä¸‰é¢ï¼Œä¸‰é¢é¢è¯•å®˜æ˜¯ä¸€ä¸ªç ”ç©¶å‘˜ï¼Œå¯¹æ•°å­¦æŽ¨å¯¼æœ‰ç‹¬ç‰¹çš„å…´è¶£ã€‚é—®äº†svmçš„æŽ¨å¯¼ï¼Œä»€ä¹ˆæ˜¯å‡¸å‡½æ•°ï¼Œä¸ºä»€ä¹ˆæ‹‰æ ¼æœ—æ—¥å¯¹å¶æ–¹ç¨‹æˆç«‹ã€‚æ»´æ»´çš„offerå¤§çº¦10æœˆåˆå‘ã€‚ ç¾Žå›¢ã€‚å®žä¹ çš„æ—¶å€™è²Œä¼¼æ²¡å†…æŽ¨ï¼Œèµ°çš„æ ¡æ‹›ã€‚ä¸€é¢ï¼Œä¸Šæ¥è®©å†™äº†å‡ ä¸ªç®—æ³•ï¼Œä¸€ä¸ªæ˜¯æ•°ç»„å…¨æŽ’åˆ—ï¼Œä¸€ä¸ªæ˜¯äºŒå‰æ ‘çš„éžé€’å½’å…ˆåºéåŽ†ï¼Œä¸€ä¸ªæ˜¯åè½¬é“¾è¡¨ã€‚ç„¶åŽé—®äº†è¿‡æ‹Ÿåˆé—®é¢˜ï¼Œl1 l2æ­£åˆ™åŒºåˆ«ä¹‹ç±»çš„ã€‚ç„¶åŽè¿›å…¥äºŒé¢ï¼ŒäºŒé¢çš„æ—¶å€™é¢è¯•å®˜å…ˆé—®äº†ä¸€ä¸ªäºŒå‰æ ‘çš„åž‚ç›´éåŽ†ï¼ŒLeetCode 314. Binary Tree Vertical Order Traversalï¼ˆè¿™ä¸ªé¢˜æ˜¯leetcodeä»˜è´¹çš„é¢˜ï¼‰ã€‚æ²¡ç­”ä¸Šæ¥ï¼Œå°±æŒ‚äº†ã€‚æ ¡æ‹›æ—¶æ˜¯æ‰¾æ–œå¯¹é—¨çš„ç¾Žå›¢å®žä¹ çš„å¤§ä½¬å†…æŽ¨çš„ã€‚å…±ä¸‰é¢ï¼Œä¸€é¢é¢å®Œå‘ŠçŸ¥é€šè¿‡æŽ¥ç€äºŒé¢ï¼ŒäºŒé¢é¢å®Œå‘ŠçŸ¥é€šè¿‡è®©å›žåŽ»ç­‰ä¸‰é¢ï¼Œä¸‰é¢æ˜¯ç”µè¯é¢ï¼Œæ™šä¸Š7ç‚¹ä¸‰é¢çš„ï¼Œæ™šä¸Š12ç‚¹å°±æ”¶åˆ°å½•å–æ„å‘ä¹¦ã€‚åšå®Œç¬”è¯•ï¼Œè¿‡äº†å‡ å¤©ï¼Œæ™šä¸Š9ç‚¹å¤šç¾Žå›¢æ‰“ç”µè¯è¿‡æ¥ï¼Œè¯´æ˜Žå¤©æ—©ä¸Š10ç‚¹æ¥æŸæŸé…’åº—é¢è¯•ã€‚ç¬¬äºŒå¤©ä¸€é¢é—®äº†ç®€åŽ†ä¸Šçš„é¡¹ç›®ï¼Œç¼–ç¨‹é¢˜é—®äº†1åˆ°nçš„ä¸€ä¸ªæŽ’å¥½åºçš„æ•°ç»„ï¼Œå°‘äº†ä¸€ä¸ªå…ƒç´ ï¼Œæ€Žä¹ˆæ‰¾å‡ºæ¥ã€‚æˆ‘è¯´äºŒåˆ†æŸ¥æ‰¾ï¼Œæ—¶é—´æ•ˆçŽ‡lognï¼ˆä¹Ÿå¯ä»¥ç”¨ä½è¿ç®—ï¼Œæ—¶é—´æ•ˆçŽ‡nï¼‰ã€‚äºŒé¢é—®äº†é¡¹ç›®ï¼Œæˆ‘ç®€åŽ†ä¸Šæœ‰k-meansï¼Œå°±é—®äº†å…¶ä»–èšç±»çš„æ–¹æ³•ï¼Œè·ç¦»æœ‰å¤šå°‘ç§ï¼Œå½±å“èšç±»çš„å› ç´ ã€‚é—®äº†ç¼–ç¨‹é¢˜leetcode 198 House Robberï¼ˆåŠ¨æ€è§„åˆ’ï¼‰ã€‚ä¸‰é¢ç”µè¯é¢ï¼Œé—®äº†é¡¹ç›®ï¼Œé—®äº†è¿‡æ‹Ÿåˆçš„é—®é¢˜äº§ç”Ÿã€è§£å†³åŠžæ³•ï¼Œé—®äº†ä¸¤ä¸ªç¼–ç¨‹é¢˜ï¼Œleetcode 69 Sqrt(x)ï¼Œä¸¤ç§æ–¹æ³•è§£å†³ï¼Œä¸€ç§æ˜¯äºŒåˆ†æŸ¥æ‰¾ï¼Œä¸€ç§æ˜¯ç‰›é¡¿æ³•ã€‚å¦ä¸€ä¸ªç¼–ç¨‹é¢˜ç»™å¿˜äº†ï¼Œæƒ³èµ·å†è¡¥å……ã€‚ ç™¾åº¦ã€‚å†…æŽ¨å®žä¹ çš„æ—¶å€™ï¼ŒåŽ»å¹´æ¯•ä¸šçš„å¸ˆå…„åŽ»äº†ç™¾åº¦ç»„ï¼Œæˆ‘ä»¬å°±æ‰¾ä»–å†…æŽ¨çš„ã€‚è¯´å®žè¯ï¼ŒæŒºåŽæ‚”çš„ï¼Œæˆ‘å¹¶ä¸å–œæ¬¢ä»–è¿™ä¸ªæ–¹å‘ï¼Œä¸€æ–¹é¢æˆ‘ä¸æ“…é•¿ï¼Œå¦ä¸€æ–¹é¢è¿‡äº†æˆ‘ä¹Ÿä¸ä¼šåŽ»ã€‚ä¸è¯¥å›¾çœäº‹æ‰¾ä»–æŽ¨çš„ã€‚å†…æŽ¨å®žä¹ æ—¶ï¼Œå…±äºŒé¢ï¼ŒæŒ‚äº†ã€‚é¢è¯•ä¸»è¦é—®çš„æ˜¯æ–¹é¢çš„ï¼Œä¹Ÿæ²¡ä»€ä¹ˆæ„æ€ï¼Œç­”çš„ä¹Ÿä¸å¥½ã€‚é—®äº†leetcode 206 Reverse Linked Listï¼Œè®©è‡ªå·±å®šä¹‰é“¾è¡¨ï¼Œé—®æŒ‡é’ˆï¼Œå¯¹è±¡ï¼ŒæŒ‡é’ˆæ˜¯å¯¹è±¡å—ï¼Œå¯¹C++çš„è€ƒå¯Ÿå¾ˆå¤šã€‚åˆ°æ ¡æ‹›å®žä¹ æ—¶ï¼Œæ²¡æŠ•ç®€åŽ†ã€‚åˆ°æ ¡æ‹›å¼€å§‹æ—¶ï¼Œæˆ‘æŠ•çš„æ¯”è¾ƒæ™šï¼Œæ‰€ä»¥é”™è¿‡äº†å†…æŽ¨æœºä¼šï¼Œç„¶åŽåˆ°äº†æ ¡æ‹›ã€‚æ ¡æ‹›å…±ä¸‰é¢ï¼Œéƒ½æ˜¯æŠ€æœ¯é¢ï¼Œå½“å¤©çŠ¶æ€ä¸å¤ªå¥½ï¼Œæ„Ÿå†’äº†ã€‚ä¸»è¦é—®äº†äºŒåˆ†ç±»çš„æ ‡å‡†æœ‰å¤šå°‘ç§ï¼Œæ¯ç§éƒ½æ˜¯ä»€ä¹ˆã€‚structä¸Žclassçš„åŒºåˆ«ã€‚çº¿ç¨‹ä¸Žè¿›ç¨‹çš„åŒºåˆ«ï¼Œioå¯†é›†ï¼Œè®¡ç®—å¯†é›†ä½¿ç”¨å¤šçº¿ç¨‹è¿˜æ˜¯å¤šè¿›ç¨‹ã€‚ä¸€ä¸ªå‘ç”Ÿå™¨ï¼Œäº§ç”Ÿ0çš„æ¦‚çŽ‡æ˜¯pï¼Œäº§ç”Ÿ1çš„æ¦‚çŽ‡æ˜¯1-pï¼Œpï¼=0.5ï¼Œæ€Žä¹ˆä½¿ç”¨è¿™ä¸ªäº§ç”Ÿ0å’Œ1ç­‰æ¦‚çŽ‡çš„å‘ç”Ÿå™¨ï¼ˆå¯ä»¥æ¯æ¬¡äº§ç”Ÿä¸¤ä¸ªæ•°å­—ï¼Œ0 1åˆ¤ä¸º0ï¼Œ1 0åˆ¤ä¸º1ï¼Œå…¶ä»–çš„èˆå¼ƒé‡æ¥ï¼‰ã€‚k-meansèšç±»ç›¸å…³é—®é¢˜ï¼Œsvmä¸Žlrçš„å¯¹æ¯”ä¸ŽåŒºåˆ«ã€‚ç¼–ç¨‹é¢˜é—®äº†å¤šé“ï¼Œæœ€å°æ ˆleetcode 155. Min Stackï¼Œè¿˜æœ‰å‡ é“å…¶ä»–é¢˜ç›®ï¼Œå¿˜äº†å·²ç»ã€‚ è…¾è®¯ã€‚å®žä¹ æŠ•çš„åŒ—äº¬å¾®ä¿¡ï¼Œæ ¡æ‹›æŠ•çš„å¹¿å·žå¾®ä¿¡ï¼Œç„¶è€Œéƒ½æ²¡æ‰¾æˆ‘é¢è¯•ã€‚æ‰¾å®žä¹ æ—¶ï¼Œqqç©ºé—´æŠŠæˆ‘æžäº†èµ·æ¥é‚€è¯·æˆ‘é¢è¯•ï¼Œæˆ‘æ‹’ç»äº†ï¼ŒåŽæ¥è…¾è®¯åœ°å›¾é‚€è¯·æˆ‘åŽ»é¢è¯•ï¼Œå°±åŽ»äº†ã€‚é¢è¯•ä¸€ä¸‹åˆï¼Œä»Ž1ï¼š40åˆ°5ï¼š20ï¼Œå…±å››é¢ï¼Œå‰ä¸‰ä¸ªä¸ºæŠ€æœ¯é¢ï¼Œç¬¬å››ä¸ªä¸ºleaderé¢ï¼Œleaderä¹Ÿé—®äº†ä¸€äº›æŠ€æœ¯ï¼Œæœªæ¥çš„è§„åˆ’ï¼Œæ¥è¿™é‡Œä¹‹åŽä¼šå¹²ä»€ä¹ˆï¼Œåæ­£å°±æ˜¯æ³›æ³›çš„èŠï¼Œè¿˜æœ‰å°±æ˜¯ä½ å°è±¡æœ€æ·±åˆ»çš„ä¸€ä»¶äº‹ï¼Œæœ€æ„ŸåŠ¨çš„ï¼Œæœ€éš¾å¿˜çš„ä¸€ä»¶äº‹ï¼Œå“Žï¼Œè¿™äº›é—®é¢˜ã€‚å…ˆæ˜¯40åˆ†é’Ÿä¸€å¥—å·å­ï¼Œè®©åšé¢˜ï¼Œ5é“ç¼–ç¨‹é¢˜ï¼Œ3é“é—®ç­”é¢˜å¯ä»¥é€‰æ‹©åšã€‚æˆ‘å½“æ—¶40åˆ†é’ŸæŠŠ5é“ç¼–ç¨‹å†™å®Œå°±æ²¡æ—¶é—´äº†ã€‚æœ‰ä¸€é“æ˜¯leetcode 300 Longest Increasing Subsequenceï¼Œå…¶ä»–å¿˜äº†ï¼Œä¸è¿‡ä¹Ÿä¸éš¾ã€‚é¢è¯•èŠäº†é¡¹ç›®ï¼ŒèŠ±äº†ä¸å°‘æ—¶é—´ï¼Œä¹Ÿçœ‹äº†é‚£5é“ç¼–ç¨‹é¢˜ï¼Œæ€Žä¹ˆå¤„ç†POIä¸­çš„åç§°é—®é¢˜ï¼Œå°±æ˜¯è¯´ä¸€ä¸ªåœ°ç‚¹å¯èƒ½æœ‰å¾ˆå¤šå¤‡é€‰çš„åå­—ï¼Œæ€Žä¹ˆç¡®å®šå“ªä¸ªæ›´åˆé€‚ã€‚çˆ¬è™«ç›¸å…³æŠ€æœ¯ã€‚è¿˜èŠäº†èŠæ‰‹å¤´çš„offeræƒ…å†µç­‰ã€‚åˆ°åŽé¢æ ¡æ‹›å†…æŽ¨æ—¶ï¼ŒæŠ•çš„å¹¿å·žå¾®ä¿¡ï¼Œä½†æ˜¯å¹¿å·žå¾®ä¿¡å¹¶ä¸æ€Žä¹ˆç¼ºäººï¼ŒæŠ•çš„äººåˆå¤šï¼Œæ‰€ä»¥å°±æ²¡ç»™é¢è¯•æœºä¼šã€‚qqéŸ³ä¹æŠŠæˆ‘æžäº†èµ·æ¥ï¼Œä½†æˆ‘å¹¶ä¸æƒ³åŽ»æ·±åœ³ï¼Œå°±æ‹’ç»äº†ã€‚å†åŽæ¥æ ¡æ‹›çš„æ—¶å€™ï¼Œä¸çŸ¥é“è…¾è®¯å“ªä¸ªéƒ¨é—¨é‚€è¯·æˆ‘åŽ»é¢è¯•å¼€å‘å²—ã€‚æˆ‘æƒ³äº†æƒ³ï¼Œæˆ‘å¹¶ä¸æƒ³åšå¼€å‘ï¼Œå°±æ‹’ç»äº†ã€‚çŽ°åœ¨çœ‹èµ·æ¥ï¼Œè…¾è®¯æˆ‘è¿˜æ˜¯æœ‰å¾ˆå¤šæœºä¼šçš„ï¼Œç„¶è€Œæˆ‘éƒ½æ‹’ç»äº†ã€‚å“Žï¼ŒçŽ°åœ¨ä»”ç»†æƒ³ä¸€æƒ³ï¼Œè™½ç„¶æˆ¿ä»·é«˜ï¼Œä½†æ˜¯æ·±åœ³å…¶ä»–æ–¹é¢éƒ½æŒºå¥½çš„ï¼Œç©ºæ°”è´¨é‡å¥½ï¼Œå„ç§ç”Ÿæ´»è¿˜æ˜¯å¾ˆä¸é”™çš„ï¼Œå››ä¸ªé¢è¯•æœºä¼šï¼Œåªé¢äº†ä¸€ä¸ªï¼Œå…¶ä»–çš„éƒ½è‡ªå·±æ‹’ç»çš„ï¼Œæ„Ÿè§‰è¿˜æ˜¯éžå¸¸å¯æƒœçš„ã€‚ æ–°æµªã€‚å®žä¹ æ²¡æœ‰æŠ•ï¼Œæ ¡æ‹›æŠ•çš„å†…æŽ¨ï¼Œé¢äº†å››é¢ï¼Œä¸¤é¢æŠ€æœ¯é¢ï¼Œä¸‰é¢æ€»ç›‘é¢ï¼Œå››é¢hré¢ã€‚ä¸»è¦é—®äº†é¡¹ç›®ã€gbdtä¸Žxgboostçš„åŒºåˆ«ã€è´å¶æ–¯å­¦æ´¾å’Œç»Ÿè®¡å­¦æ´¾çš„åˆ†æ­§ï¼Œç¼–ç¨‹é¢˜é—®äº†åè½¬é“¾è¡¨leetcode206ï¼Œtop kå¤§çš„æ•°ï¼ˆå‰‘æŒ‡offeré¢˜ç›®ï¼Œç¬¬ä¸€ç‰ˆ30é¢˜ï¼‰ã€‚ æœç‹—ã€‚å®žä¹ æ²¡æœ‰æŠ•ï¼Œæ ¡æ‹›å†…æŽ¨é¢äº†ä¸¤é¢æŒ‚äº†ï¼Œæ ¡æ‹›é¢äº†ä¸¤é¢ï¼Œå‘äº†offerã€‚æ ¡æ‹›å†…æŽ¨æ—¶ï¼Œä¹Ÿæ˜¯ä¸ºäº†çœäº‹ï¼Œæ‰¾çš„æœç‹—æŸç»„çš„å¤§å¤§å¤§å¸ˆå…„æŽ¨çš„ï¼Œè·Ÿç™¾åº¦é‚£ä¸ªç±»ä¼¼ï¼Œæˆ‘ä¹Ÿä¸æ„Ÿå…´è¶£ã€‚é¢è¯•é—®äº†é¡¹ç›®ï¼Œç¼–ç¨‹é—®äº†æœ€å°ç¼–è¾‘è·ç¦»leetcode 72 Edit Distanceï¼Œå‰‘æŒ‡offer 31è¿žç»­å­æ•°ç»„çš„æœ€å¤§å’Œï¼ˆæ‰¾åˆ°èµ·å§‹ä½ç½®å’Œæœ€å¤§å’Œï¼‰ã€‚æ ¡æ‹›ä¸¤é¢ã€‚ä¸»è¦æ˜¯é¡¹ç›®ï¼ŒäºŒåˆ†ç±»çš„è¯„ä»·æ ‡å‡†æœ‰å“ªäº›ã€åˆ†åˆ«æ˜¯ä»€ä¹ˆã€‚ç¼–ç¨‹æœ‰äºŒå‰æ ‘çš„å…ˆåºä¸­åºåŽç»­éžé€’å½’éåŽ†ã€‚äºŒé¢é¢å®Œè¯´åŽ»çœ‹çœ‹é¢†å¯¼åœ¨ä¸åœ¨ï¼Œå›žæ¥è¯´é¢†å¯¼ä¸åœ¨ï¼Œå°±è®©å›žæ¥äº†ï¼Œè¯´åŽé¢å¯èƒ½æœ‰hré¢ã€‚æˆ‘å¿ƒæƒ³ï¼Œè¿™æ˜¯å§”å©‰æ‹’ç»çš„å¥—è·¯å§ï¼Œè¿‡äº†å‡ å¤©hrè®©æˆ‘åŽ»å…¬å¸é¢ï¼Œé—®äº†ä¸‹å­¦åŽ†ï¼Œé—®è€ƒç ”è¿˜æ˜¯ä¿ç ”ï¼Œæœ‰å“ªäº›offerï¼Œç„¶åŽå‘äº†offerã€‚ å°ç±³ã€‚ä¸‰é¢æŠ€æœ¯é¢ã€‚é¢è¯•ä¹‹åŽï¼Œå‘äº†æ„å‘ä¹¦ï¼Œç›´åˆ°å‰äº›æ—¥å­æ‰è”ç³»æˆ‘ã€‚æˆ‘è¯´æˆ‘å·²ç»äº¤å…¶ä»–å…¬å¸ä¸‰æ–¹ï¼Œæ ¡æ‹›ç»“æŸäº†ã€‚ç¼–ç¨‹é¢˜é—®äº†leetcode 228. Summary Rangesï¼Œ ç»™ä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾åˆ°æœ€æ·±çš„ä¸€ä¸ªèŠ‚ç‚¹åˆ°æœ€æµ…çš„ä¸€ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„æœ€å°å…¬å…±çˆ¶èŠ‚ç‚¹ï¼Œæˆ‘çš„æ–¹æ³•æ˜¯å±‚æ¬¡éåŽ†ï¼Œæ‰¾åˆ°æœ€æµ…çš„èŠ‚ç‚¹åŠæœ€æ·±çš„èŠ‚ç‚¹ï¼Œç„¶åŽä½¿ç”¨ leetcode 236 Lowest Common Ancestor of a Binary Treeä¸­çš„æ–¹æ³•åŽ»è§£å†³é—®é¢˜ï¼Œæ—¶é—´æ•ˆçŽ‡ä¸ºoï¼ˆnï¼‰ï¼Œç©ºé—´æ•ˆçŽ‡ä¸ºoï¼ˆnï¼‰ï¼Œé¢è¯•å®˜ç»™çš„æ–¹æ³•æ˜¯ä¿å­˜æ‰€æœ‰è·¯å¾„ï¼Œç„¶åŽåŽ»æŸ¥æ‰¾ã€‚é—®äº†é¡¹ç›®ï¼Œä¸¤ä¸ªé¡¹ç›®é—®çš„éžå¸¸ç»†ï¼Œä½¿ç”¨random forestè®¡ç®—ç‰¹å¾é‡è¦æ€§ï¼Œå¯¹è¯¥ç»´ç‰¹å¾ä¸è¿›è¡Œpermutationï¼Œåˆ é™¤å¯ä»¥ä¸å¯ä»¥ã€‚å³°åº¦ã€ååº¦çš„æ•°å­¦å…¬å¼åŠæ„ä¹‰ã€‚äºŒåˆ†ç±»ä¸­AUCçš„å…·ä½“å®šä¹‰ï¼Œå„ä¸ªåˆ†ç±»è¯„ä»·æ–¹æ³•ã€‚æœ€åŽä¸‰é¢leaderé¢çš„æ—¶å€™è¿˜é—®äº†ä¸¤ä¸ªæ€è€ƒé—®é¢˜ï¼Œé‡‘èžè¿çº¦çŽ‡ï¼Œå¯èƒ½è¦æˆ¿è´·å¾ˆé•¿æ—¶é—´æ‰èƒ½çŸ¥é“æ˜¯å¦è¿çº¦ï¼Œæ•°æ®å°‘ï¼Œå®žéªŒæ ·æœ¬å›žæ”¶æ—¶é—´é•¿æ‰€ä»¥å¯¹äºŽè¿™ä¸ªé—®é¢˜æ€Žä¹ˆå¤„ç†ã€‚è¿˜æœ‰å°±æ˜¯ä¸ºä½•åˆ©ç”¨è®­ç»ƒé›†è®­ç»ƒï¼Œç”¨æ¥é¢„æµ‹æµ‹è¯•é›†å¯ä»¥ç”¨æ¥é¢„æµ‹ã€‚æˆ‘è¯´çš„æ˜¯è¿™æ˜¯åŸºäºŽä¸€ä¸ªå¤§çš„å‡è®¾ï¼Œè®­ç»ƒæ ·æœ¬å’Œæµ‹è¯•æ ·æœ¬æ˜¯åŸºäºŽç‹¬ç«‹åŒåˆ†å¸ƒçš„ï¼ŒåŽæ¥æˆ‘æƒ³äº†æƒ³æˆ‘è§‰å¾—ä¹Ÿå¯ä»¥ä»Žç†µ ä¿¡æ¯å¢žç›Šçš„è§’åº¦æ€è€ƒã€‚ äº¬ä¸œã€‚ äº¬ä¸œæ˜¯å®žä¹ è¿‡äº†ï¼Œæ ¡æ‹›æ²¡é‚€è¯·æˆ‘é¢è¯•ã€‚ æ ¡æ‹›çš„æ—¶å€™ï¼Œæˆ‘æ‰¾çš„äº¬ä¸œçš„å¸ˆå…„å†…æŽ¨çš„ï¼ŒåŽæ¥ä¹Ÿå‚åŠ äº†æ ¡æ‹›ï¼Œç¬”è¯•çš„æŒºå¥½çš„ï¼Œå°±æ˜¯æ²¡é‚€è¯·é¢è¯•ï¼Œä¹Ÿæœ‰ä¸€äº›åŒå­¦è·Ÿæˆ‘ä¸€æ ·çš„æƒ…å†µï¼Œå¯èƒ½ç®€åŽ†æŒ‚äº†å§ã€‚äº¬ä¸œå®žä¹ é¢è¯•æ˜¯ä¸‰é¢ï¼Œä¸¤é¢æŠ€æœ¯é¢ï¼Œä¸€é¢hré¢ã€‚æ„Ÿè§‰æ¯”è¾ƒå‘çš„æ˜¯äº¬ä¸œçš„ä¸‰é¢åˆ†åˆ«å®‰æŽ’åœ¨äº†ä¸‰å¤©ï¼Œä¸ºæ­¤æˆ‘ç»™æˆ‘ä»¬è€å¸ˆè¯·äº†ä¸‰å¤©å‡ã€‚äº¬ä¸œç”¨çš„è¾ƒå¤šçš„æ˜¯Javaï¼Œæˆ‘è‡ªå·±æ˜¯cpp Pythonè¾ƒå¤šã€‚é¢è¯•ç›¸å¯¹ç®€å•ï¼Œé—®äº†svmåŽŸç†æŽ¨å¯¼ï¼Œä¸¤ä¸ªæŽ’å¥½åºçš„æ•°ç»„æ€Žä¹ˆåˆå¹¶æˆä¸€ä¸ªæŽ’å¥½åºçš„æ•°ç»„ï¼ŒåŒæŒ‡é’ˆå•Šã€‚é—®äº†ä¸€ä¸ªä¸šåŠ¡é¢˜åœºæ™¯é¢˜ï¼Œç»™ä½ ä¸€äº›æ¶æ•°æ®ï¼Œè®©ä½ å¯¹é¡¾å®¢å¯¹ä¸€ä¸ªæ–°å•†å“çš„é€€å•çŽ‡é¢„æµ‹ï¼Œå¦‚æžœèƒ½é¢„æµ‹å‡ºé€€å•çŽ‡ï¼Œåˆ™å¯ä»¥å»¶è¿Ÿæˆ–è€…ä¸å‘è´§ï¼ŒèŠ‚çº¦ç‰©æµæˆæœ¬ã€‚hré¢çš„æ—¶å€™é—®äº†å‡ ä¸ªé—®é¢˜ï¼ŒçŽ°åœ¨åŽ‰å®³çš„å¾ˆå¤šéƒ½æ˜¯åšå£«ï¼Œä½ æ€Žä¹ˆçœ‹ï¼Œæœ‰æ— è¯»åšçš„æ‰“ç®—ï¼Ÿä»‹ç»ä¸€ä¸ªä½ çš„é¡¹ç›®ã€‚ äºšé©¬é€Šã€‚ äºšé©¬é€Šä¹Ÿæ˜¯å®žä¹ è¿‡äº†ï¼Œæ ¡æ‹›æ²¡é‚€è¯·æˆ‘ã€‚äºšé©¬é€Šå®žä¹ æŠ•çš„æ—©ï¼ŒåŽæ¥é‚€è¯·åŽ»é¢è¯•ï¼Œå…±ä¸¤é¢æŠ€æœ¯é¢ã€‚ç¬¬ä¸€é¢æ˜¯ä¸€ä¸ªç¾Žä¸½çš„åŒ—é‚®å­¦å§ï¼ˆæˆ‘ä¸è®¤è¯†ï¼‰ï¼Œä¸»è¦é—®äº†ç®€åŽ†çš„é¡¹ç›®ï¼Œlstmçš„åŽŸç†ï¼Œlstmä¸ºä½•èƒ½é•¿æ—¶è®°å¿†ã€‚äºŒé¢æœ‰ä¸¤ä½é¢è¯•å®˜åŒæ—¶é¢ï¼Œä¸»è¦æ˜¯ç¼–ç¨‹é¢˜ï¼Œä¹Ÿé—®äº†é¡¹ç›®ã€‚ç¼–ç¨‹é¢˜ç›¸å¯¹éƒ½æ˜¯æ¯”è¾ƒå®¹æ˜“çš„ï¼Œä¸»è¦æ˜¯leetcode 1 Two Sum ï¼Œleetcode 15 3Sumï¼Œleetcode 16 3Sum Closest ï¼Œleetcode 18 4Sumã€‚è¿˜é—®äº†ä¸€ä¸ªä¸šåŠ¡åœºæ™¯é¢„æµ‹é¢˜ï¼Œäºšé©¬é€Šè¦é”€å”®å¾ˆå¤šå•†å“ï¼Œä½ å¦‚ä½•åŽ»é¢„æµ‹å•†å“éœ€è¦ç”¨åˆ°çš„è´§ä»“çš„ä½“ç§¯ã€‚å¦‚æžœèƒ½é¢„æµ‹å‡ºè´§ä»“ä½“ç§¯ï¼Œè¿™æ ·å­å°±å¾ˆå®¹æ˜“åŽ»ç§Ÿèµä»“åº“äº†ã€‚åŽé¢çš„å…¬å¸éƒ½æ˜¯å®žä¹ å’Œæ ¡æ‹›éƒ½æ²¡è¿‡çš„ã€‚æœ‰çš„æ˜¯é¢è¯•æœªé€šè¿‡ï¼Œæœ‰çš„æ˜¯æ²¡æœ‰é¢è¯•ï¼Œä¹Ÿä¸€å¹¶å†™ä¸‹æ¥ã€‚ 360ã€‚å®žä¹ ä¸‰é¢æŒ‚ï¼Œæ ¡æ‹›å†…æŽ¨ä¸€é¢æŒ‚ã€‚å®žä¹ é¢è¯•ï¼Œæ˜¯æˆ‘ç¬¬ä¸€æ¬¡åŽ»é¢è¯•ï¼Œé¢çš„å®žä¹ ï¼Œè·¯ä¸Šè¿˜æƒ³ï¼Œå¦‚æžœ360è¿‡äº†ï¼Œå®žä¹ å°±ç»“æŸäº†ï¼Œå¯æƒœæƒ³æ³•æ˜¯ç¾Žå¥½çš„ï¼ŒçŽ°å®žæ˜¯æ®‹é…·ã€‚å®žä¹ æ˜¯ä¸‰é¢ï¼Œä¸¤é¢æŠ€æœ¯ï¼Œä¸€é¢hrã€‚ä¸Šåˆ10ç‚¹é¢ï¼Œ40åˆ†é’Ÿä¸€åœºï¼Œç­‰é¢å®ŒäºŒé¢ç­‰ä¸‹åˆ1ç‚¹åŠè¿˜æ˜¯2ç‚¹å¼€å§‹hré¢ã€‚ä¸¤é¢æŠ€æœ¯é¢çš„çš„ç¡®æŒºä¸å¥½çš„ï¼Œé‚£æ˜¯ç¬¬ä¸€æ¬¡åŽ»é¢è¯•ï¼Œä¹Ÿæ²¡çœ‹ç½‘ä¸Šçš„é¢ç»ï¼Œè‡ªå·±çš„æŠ€æœ¯ä¹Ÿå¹¶ä¸å¤ªå¥½ã€‚æŠ€æœ¯ä¸»è¦é—®äº†ï¼Œsvmçš„åŽŸç†ï¼Œsmoç®—æ³•ï¼Œlstmæœ‰ä»€ä¹ˆå¥½å¤„ï¼Œä¸ºä½•é˜²æ­¢æ¢¯åº¦çˆ†ç‚¸å’Œæ¢¯åº¦æ¶ˆå¤±ï¼ŒbpæŽ¨å¯¼ï¼Œç¼–ç¨‹é¢˜é—®äº†æ ‘çš„æ·±åº¦ï¼Œè¿™ä¸ªç®€å•ï¼Œä½†æ˜¯ä»£ç ä¸­ç«Ÿç„¶æŠŠ==é”™å†™æˆäº†=ï¼ŒèŒƒäº†è¿™æ ·çš„é”™è¯¯ã€‚è¿˜æœ‰é—®äº†æ‰¾å‡ºäºŒå‰æ ‘ä¸­å’Œæœ€å¤§çš„ä¸€æ¡è·¯å¾„ï¼Œä¸å¿…ç»è¿‡æ ¹èŠ‚ç‚¹leetcode 124. Binary Tree Maximum Path Sumã€‚ hré¢çš„æ—¶å€™é—®äº†ä»¥å‰çš„å®žä¹ ç»åŽ†ï¼Œè€ƒç ”è¿˜ä¿ç ”ï¼Œæˆ‘è¯´è€ƒç ”ï¼Œé—®è€ƒäº†å¤šå°‘åˆ†ï¼Œæœ‰æ— å¯¹è±¡ï¼Œå°†æ¥æ˜¯æ‰“ç®—åœ¨å“ªé‡Œå‘å±•ã€‚æ ¡æ‹›çš„æ—¶å€™ï¼Œå†…æŽ¨åŽ»é¢ï¼Œä¸€æŒ‚é¢ã€‚é—®äº†ç®€åŽ†é¡¹ç›®ï¼Œé—®äº†èšç±»ç®—æ³•éƒ½æœ‰é‚£äº›ï¼Œç®—æ³•çš„æ¯”è¾ƒï¼Œcnnçš„åŽŸç†å„ä¸ªå±‚çš„ä½œç”¨ï¼Œç¼–ç¨‹é¢˜é—®äº†äºŒåˆ†æœç´¢ã€‚æ„Ÿè§‰é¢çš„æŒºå¥½çš„ï¼Œç„¶è€Œè¿˜æ˜¯æŒ‚äº†ã€‚å¾ˆå¤šåŒå­¦éƒ½è¯´360åŸºæœ¬ä¸ç¼ºäººã€‚çš„ç¡®å®žä¹ è¿˜æ˜¯æ ¡æ‹›ï¼Œå‘¨å›´è¿‡360çš„å¾ˆå°‘ï¼ŒåŒ…æ‹¬å¾ˆå¤šå¤§ç‰›ã€‚ é˜¿é‡Œã€‚ å®žä¹ å†…æŽ¨ä¸€é¢è§†é¢‘é¢ï¼ŒåŽæ¥çš„å®žä¹ æ ¡æ‹›ä¹Ÿæ˜¯ä¸€é¢æŒ‚ï¼Œæ ¡æ‹›ä¹Ÿæ˜¯è§†é¢‘ä¸€é¢æŒ‚ã€‚å®žä¹ é¢çš„æ—¶å€™ï¼Œä¸»è¦é—®äº†ç®€åŽ†é¡¹ç›®ï¼Œé—®äº†svmçš„åŽŸç†ï¼Œsvmçš„æ ¸å‡½æ•°çš„ä½œç”¨ï¼Œlrèƒ½ä¸èƒ½ç”¨æ ¸å‡½æ•°ï¼Œä¸ºä»€ä¹ˆã€‚æ ¡æ‹›çš„æ—¶å€™ï¼Œé—®äº†å¤šå…ƒé«˜æ–¯å‡½æ•°çš„æœŸæœ›æ˜¯ä»€ä¹ˆï¼Œæ€Žä¹ˆæŽ¨å¯¼ï¼Ÿç†µçš„å®šä¹‰æ˜¯ä»€ä¹ˆï¼Ÿæ€Žä¹ˆç†è§£ï¼Ÿç¼–ç¨‹é¢˜æ˜¯å‰‘æŒ‡offer 30é¢˜ï¼Œæœ€å°çš„kä¸ªæ•°ï¼Œä¹Ÿæ˜¯leetcode 215 Kth Largest Element in an Arrayï¼Œå†™ä»£ç å¹¶åˆ†æžæ—¶é—´å¤æ‚åº¦ã€‚é˜¿é‡Œå®žä¹ æŠ•çš„æ˜¯é˜¿é‡Œå¦ˆå¦ˆï¼Œæ ¡æ‹›æŠ•çš„æ˜¯èš‚èšé‡‘æœã€‚é™¤äº†æŠ€æœ¯éœ€è¦åŠ å¼ºä¹‹å¤–ï¼Œè§†é¢‘é¢è¯•ä¹Ÿè¡¨çŽ°å‡ºäº†ä¸¤ä¸ªç¼ºç‚¹ï¼Œä¸€ä¸ªæ˜¯è¡¨è¾¾æ²Ÿé€šéœ€è¦å¤§å¤§çš„åŠ å¼ºï¼Œä¸€ä¸ªæ˜¯è¦è‡ªä¿¡ï¼ŒåŒå­¦åœ¨æ—è¾¹è¡¨ç¤ºæˆ‘çš„è¡¨è¾¾å¤ªå¿«ï¼Œå¤ªç´§å¼ äº†ã€‚è¿˜æœ‰ä¸€ä¸ªéžå¸¸é‡è¦çš„ä¸€ç‚¹ï¼Œæˆ‘æ ¡æ‹›å†…æŽ¨æŠ•çš„å¤ªæ™šäº†ï¼ˆ8.8æŠ•çš„ï¼‰ä»¥è‡³äºŽé”™è¿‡äº†æ ¡æ‹›å†…æŽ¨çš„æ—¶é—´ç‚¹ï¼Œæ²¡äººæ‰¾æˆ‘é¢è¯•ï¼Œç›´æŽ¥åˆ°äº†æ ¡æ‹›äº†ã€‚æˆ‘ä¸ºä»€ä¹ˆæŠ•è¿™ä¹ˆæ™šå‘¢ï¼Ÿå¯ä»¥è®°ä½ä¸€ä¸ªæ—¶é—´ç‚¹ï¼Œå¤§æ¦‚6æœˆåº•ï¼Œ7æœˆåˆå°±å¼€å§‹äº’è”ç½‘çš„å†…æŽ¨äº†ã€‚æˆ‘ä»¬æ˜¯7æœˆå¼€å§‹æ”¾å®žä¹ ï¼Œ7.4æ‰å¼€å§‹åŽ»å®žä¹ å…¬å¸æŠ¥åˆ°ï¼Œé‚£ä¸ªæ—¶å€™æƒ³ç€ï¼Œç®€åŽ†ä¸Šæ²¡æœ‰ä¸ªåƒæ ·çš„å®žä¹ ï¼ŒåˆšåŽ»å®žä¹ çš„å…¬å¸ï¼Œä»€ä¹ˆä¹Ÿä¸ä¼šå‘¢ï¼Œç®€åŽ†ä¹Ÿä¸å¥½å†™ã€‚æ‰€ä»¥æƒ³ç¨å¾®ç­‰ä¸€ç­‰ï¼Œç»“æžœ8.8å†æŠ•çš„æ—¶å€™ï¼Œå·®ä¸å¤šå¿«ç»“æŸäº†ï¼Œæˆ‘è®°å¾—æ ¡æ‹›çš„å†…æŽ¨æ˜¯8.18å·¦å³ã€‚æ‰€ä»¥æ—¶é—´èŠ‚ç‚¹ä¸€å®šè¦æŠŠæ¡å¥½ï¼Œåƒä¸‡ä¸è¦æ‹–ã€‚ ç½‘æ˜“ã€‚å®žä¹ çš„æ—¶å€™æ˜¯ç¬”è¯•æŒ‚äº†ï¼Œæ ¡æ‹›å†…æŽ¨ä¹Ÿæ˜¯ç¬”è¯•æŒ‚äº†ï¼Œæ ¡æ‹›çš„æ—¶å€™ç”³çš„æ·±åº¦å­¦ä¹ å·¥ç¨‹å¸ˆï¼Œæ ¡æ‹›æ—¶äºŒé¢æŒ‚ã€‚ç¬¬ä¸€é¢æ˜¯ä¸€ä¸ªç¾Žå¥³å§å§ï¼Œç¬¬äºŒé¢è¯•æ˜¯ä¸¤ä½é¢è¯•å®˜ä¸€èµ·é¢ã€‚ä¸»è¦é—®äº†é¡¹ç›®ï¼Œè‡ªå·±æ­å»ºç½‘ç»œçš„ç»“æž„ï¼ŒCNNç½‘ç»œçš„ç»“æž„ï¼Œç›¸å…³çŸ¥åçš„cnnç½‘ç»œç»“æž„ï¼Œç¼–ç¨‹å°±é—®äº†ä¸€é“ï¼Œä¸€äº›åæ ‡ç‚¹éƒ½æ˜¯ï¼ˆxï¼Œyï¼‰å½¢å¼çš„è®©ä»¥xçš„å¤§å°æŽ’åºï¼Œxä¸€æ ·çš„æŒ‰yæŽ’åºï¼Œæˆ‘è¯´å¾ˆç®€å•å•Šï¼Œä½¿ç”¨sortå‡½æ•°å†™ä¸ªcompareå‡½æ•°å°±å¯ä»¥äº†ï¼Œä¸çŸ¥é“æ˜¯è¦è€ƒå¯Ÿä»€ä¹ˆï¼Œè¦è€ƒå¯ŸçŽ°åœºå†™æŽ’åºç®—æ³•å—ï¼Ÿæˆ‘å½“æ—¶åº”è¯¥é—®é—®çš„ã€‚å…¶å®žæˆ‘å¯¹æ·±åº¦å­¦ä¹ çš„äº†è§£è¿˜æ˜¯å¤ªå°‘ï¼Œéœ€è¦æ›´å¤šçš„å­¦ä¹ ï¼Œç›®å‰æ›´å¤šçš„æ˜¯å·¥ç¨‹ä½¿ç”¨ä¸Šçš„ä¸œè¥¿ï¼Œæˆ‘å½“æ—¶åº”è¯¥ç”³æœºå™¨å­¦ä¹ å·¥ç¨‹å¸ˆçš„ï¼Œæˆ–è®¸é¢è¯•å°±é€šè¿‡äº†ã€‚ ç½‘æ˜“æ¸¸æˆã€‚ å®žä¹ çš„æ—¶å€™ç®€åŽ†æŒ‚äº†ï¼Œæ ¡æ‹›çš„æ—¶å€™æœ¬æ¥ç”³çš„äººå·¥æ™ºèƒ½å·¥ç¨‹å¸ˆï¼Œç»“æžœç»™æˆ‘è½¬æˆäº†æ¸¸æˆç ”å‘å·¥ç¨‹å¸ˆï¼Œè¿˜ä¸èƒ½æ›´æ”¹ï¼Œæˆ‘åŽ»é¢äº†ï¼Œä¸€é¢æŒ‚ã€‚é¦–å…ˆå¯ä»¥è¯´æ˜Žä¸€ç‚¹ï¼Œç½‘æ˜“å’Œç½‘æ˜“æ¸¸æˆæ˜¯åˆ†å¼€æ‹›è˜çš„ï¼Œä¸¤å®¶å¯ä»¥åˆ†åˆ«æŠ•ã€‚å†æœ‰å°±æ˜¯ç½‘æ˜“æ¸¸æˆæœ‰ä¸¤å—ï¼Œä¸€å—æ˜¯é›·ç«ç›˜å¤ï¼Œä¸€å—æ˜¯äº’å¨±ã€‚æˆ‘å®žä¹ æŠ•çš„æ˜¯é›·ç«ï¼Œæ‰¾äº†äº’å¨±çš„åŒå­¦å†…æŽ¨äº†ä¸€ä¸‹ï¼Œæœ€å¼€å§‹ä¸çŸ¥é“ä»–ä»¬å†…éƒ¨äº’ä¸æ‰¿è®¤ï¼Œç»“æžœç›¸å½“äºŽæ²¡æœ‰å†…æŽ¨ï¼Œç®€åŽ†å°±ç»™æˆ‘æŒ‚äº†ã€‚æ‰€ä»¥æŠ•é›·ç«ä¸€å®šè¦æ‰¾é›·ç«çš„äººæŽ¨ï¼ŒæŠ•äº’å¨±ä¸€å®šè¦æ‰¾äº’å¨±çš„äººæŽ¨ï¼Œä¸ç„¶ç­‰äºŽæ²¡æœ‰æŽ¨ã€‚è¿˜æœ‰å°±æ˜¯ç½‘æ˜“æ¸¸æˆå®žä¹ å¼€å§‹çš„ç‰¹åˆ«æ—©ï¼ŒåŽ»å¹´11æœˆè¿˜æ˜¯12æœˆï¼Œå°±å¼€å§‹å†…æŽ¨äº†ï¼ŒçŽ°åœ¨ä¹Ÿæ˜¯12æœˆå¤§å®¶å¯ä»¥å…³æ³¨ä¸‹æ¶ˆæ¯ã€‚ä»Šå¹´2æœˆä»½æˆ‘åˆšè¿‡å®Œå¹´æ¥å­¦æ ¡ï¼Œæˆ‘åŒå­¦è·Ÿæˆ‘è¯´ä»–ç½‘æ˜“æ¸¸æˆå·²ç»ç¬”è¯•è¿‡ä¸¤æ‰¹äº†ï¼Œæˆ‘é¡¿æ—¶è§‰å¾—è‡ªå·±è½åŽäº†å¾ˆå¤šï¼Œæœ‰ç§åˆ«äººæ ¡æ‹›éƒ½ç»“æŸäº†ï¼Œä½ æ‰åˆšæ¥å­¦æ ¡çš„feelï¼Œä½•å†µæˆ‘æ¯”å­¦æ ¡è§„å®šçš„å¼€å­¦æ—¶å€™æ—©æ¥äº†åå¤šå¤©ï¼Œå½“æ—¶ä¸€é¡¿æ…Œå¼ ï¼Œèµ¶ç´§é—®é—®å¸ˆå…„å¸ˆå§åˆ°åº•ä»€ä¹ˆæƒ…å†µã€‚å†æœ‰å°±æ˜¯æ ¡æ‹›é¢è¯•ï¼Œå…ˆæ˜¯40åˆ†é’Ÿè®©å†™é“ç¼–ç¨‹é¢˜ï¼Œç„¶åŽå†åŽ»è§é¢è¯•å®˜ã€‚å› ä¸ºä»–ä»¬ç»™æˆ‘è°ƒæˆäº†å¼€å‘ï¼Œæˆ‘è‡ªå·±ä¹Ÿç¡®å®žæ²¡ä»€ä¹ˆç»éªŒï¼Œé—®çš„å…¨æ˜¯è¯­è¨€ç»†èŠ‚çš„ï¼Œç®—æ³•å·¥ç¨‹å¸ˆä»Žæ¥ä¸æ€Žä¹ˆé—®çš„ï¼Œç»“æžœå¯æƒ³è€ŒçŸ¥ï¼Œå°±æŒ‚äº†ã€‚ ä»Šæ—¥å¤´æ¡ã€‚å®žä¹ çš„æ—¶å€™ä¸€é¢æŒ‚ï¼Œæ ¡æ‹›çš„æ—¶å€™ä¹Ÿæ˜¯ä¸€é¢æŒ‚ã€‚å®žä¹ çš„æ—¶å€™é—®äº†ç®€åŽ†ï¼Œå½“æ—¶ç¬¬ä¸€å®¶é¢çš„360ï¼ŒæŒ‚äº†ã€‚è²Œä¼¼ç¬¬äºŒå®¶é¢çš„å¤´æ¡ï¼Œä¹ŸæŒ‚äº†ï¼ŒæŒ‚äº†å¾ˆå¤šå®¶ï¼Œå¿ƒæƒ…è¿˜æ˜¯æŒºéƒé—·çš„å½“æ—¶ã€‚å¤´æ¡å®žä¹ ä¸€é¢çš„æ—¶å€™å…ˆè®©å†™ç¼–ç¨‹é¢˜ï¼Œç±»ä¼¼äºŽå‰‘æŒ‡offerç¬¬ä¸€ç‰ˆçš„ç¬¬7ç« çš„7.2é‡Œçš„é¢˜ç›®ï¼Œå«åšå¤šå‰æ ‘ï¼ˆæ²¡æœ‰æŒ‡å‘çˆ¶èŠ‚ç‚¹æŒ‡é’ˆï¼‰ä¸­ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€ä½Žå…¬å…±ç¥–å…ˆã€‚ç„¶åŽé—®äº†é¡¹ç›®ï¼Œé—®äº†svmçš„æŽ¨å¯¼ï¼Œé—®çš„éžå¸¸ç»†ï¼Œé—®è·ç¦»åˆ°åº•å¦‚ä½•å®šä¹‰çš„ï¼Œä¸å¯åˆ†çš„svmä¸­æ¾å¼›å˜é‡æ€Žä¹ˆç†è§£ï¼Œå¦‚æžœæœ‰ä¸ªç‚¹ç‰¹åˆ«å¼‚å¸¸ï¼Œæ˜¯å¦è¿˜èƒ½æ‰¾åˆ°åˆ†å‰²é¢ï¼Œæˆ‘è‡ªå·±å½“æ—¶æ°´å¹³ä¹Ÿæ¯”è¾ƒèœï¼Œä»–é—®ä¸€ä¸ªæˆ‘å›žç­”ä¸€ä¸ªï¼Œæˆ‘å›žç­”ä¸€ä¸ªï¼Œä»–è¯´ä¸€å¥é ï¼ˆkao å››å£°ï¼‰ï¼Œæˆ‘å¿ƒé‡Œä¸€é˜µæ…Œå¼ ã€‚é—®äº†lrçš„å…¬å¼æŽ¨å¯¼ã€‚çš„ç¡®é¢çš„ä¸å¥½ã€‚æ ¡æ‹›çš„æ—¶å€™ï¼Œæ‰¾çš„å†…æŽ¨ï¼Œå½“æ—¶å†…æŽ¨è¦å†…æŽ¨ç ï¼Œä½†æ˜¯å†…æŽ¨æœ‰å†…æŽ¨ç ä¹Ÿè¦ç¬”è¯•ï¼Œä½†æ˜¯å†…æŽ¨ç æœ‰ä¸€ç§æ˜¯å†…æŽ¨ç™½é‡‘ç ï¼Œåªæœ‰å¤´æ¡æŠ€æœ¯å‘˜å·¥æœ‰ï¼Œä¸”æ¯äººåªæœ‰ä¸€ä¸ªï¼Œæœ‰äº†å†…æŽ¨ç™½é‡‘ç ï¼Œå¯ä»¥ç›´æŽ¥é¢è¯•ï¼Œå…ç¬”è¯•ï¼Œæ—©é¢è¯•ã€‚æˆ‘å°±æ‰¾äººè¦äº†ä¸€ä¸ªå†…æŽ¨ç™½é‡‘ç ï¼Œæ˜¯å¤´æ¡çš„ç¬¬ä¸€æ‰¹é¢è¯•ï¼ŒæŒ‚äº†ã€‚æ ¡æ‹›å†…æŽ¨æŒ‚äº†ï¼Œä¸èƒ½å‚åŠ åŽç»­çš„æ ¡æ‹›ï¼Œè·Ÿ360ä¸€æ ·çš„ã€‚æ ¡æ‹›ä¸€é¢ï¼Œä¸»è¦é—®äº†ç®€åŽ†ï¼Œé—®äº†é¡¹ç›®ï¼Œé—®äº†ä¸€äº›å€’æŽ’ç´¢å¼•ï¼Œè¯å‘é‡åŠå¤æ‚åº¦ç›¸å…³é—®é¢˜ã€‚ç¼–ç¨‹æ˜¯leetcode 57 Insert Intervalï¼Œè¿™æ˜¯leetcodeçš„hardé¢˜ç›®ï¼Œæ ¹æ®å¤§å®¶çš„ååº”ï¼Œå¤´æ¡ç¼–ç¨‹é¢˜é—®çš„æ™®éç›¸å¯¹éš¾ä¸€äº›ã€‚ç¼–ç¨‹é¢˜æˆ‘æ²¡ç­”ä¸Šæ¥ï¼ŒæŒ‚äº†ä¹Ÿæ˜¯å¾ˆæ­£å¸¸çš„äº‹æƒ…ã€‚ æµ·åº·å¨è§†ã€‚å®žä¹ æ²¡æŠ•ï¼Œæ ¡æ‹›æŠ•äº†ã€‚å…±ä¸‰é¢ã€‚å…ˆæ˜¯ç”µè¯ä¸€é¢ï¼ŒåŽæ˜¯åŽ»å…¬å¸é¢è¯•äºŒé¢å’Œä¸‰é¢ï¼Œè€Œé¢è¯•æŠ€æœ¯é¢2v1ï¼Œä¸‰é¢æ˜¯hré¢ã€‚ä¸€é¢å°±æ˜¯ç®€å•çš„èŠäº†èŠï¼Œé—®äº†é—®ã€‚äºŒé¢æ˜¯èŠèŠå¹³æ—¶ç”¨ä»€ä¹ˆæŠ€æœ¯ï¼Œç”¨ä»€ä¹ˆç½‘ç»œï¼Œä¸šå†…ï¼ˆæˆ‘çš„ç ”ç©¶æ–¹å‘ï¼‰ä¸»è¦ç”¨ä»€ä¹ˆæ–¹æ³•ï¼Œä¸šå†…ï¼ˆæˆ‘çš„ç ”ç©¶æ–¹å‘ï¼‰éƒ½åœ¨åšä»€ä¹ˆï¼Œå¯¹äº†è§£å¤šå°‘ï¼Œæœ‰æ— è½¬æ–¹å‘çš„æ„æ„¿ã€‚ä¹Ÿæ²¡å¤ªå¤šçš„é—®é¢˜ï¼Œæ›´å¤šçš„æ˜¯å‘æ•£æ€§çš„é—®é¢˜ã€‚hré¢çš„æ—¶å€™ï¼Œé—®äº†æœ‰å¤šå°‘offeräº†ï¼Œå› ä¸ºå·²ç»å¾ˆæ™šäº†ï¼Œæˆ‘å°±è¯´æˆ‘çŽ°åœ¨æœ‰7å®¶å…¬å¸å‘äº†sp offerã€‚åŽæ¥æ²¡ç»™æˆ‘å‘offerï¼Œæˆ‘è§‰å¾—å¯èƒ½ä¸»è¦åœ¨äºŽæˆ‘å¯¹æ–¹å‘äº†è§£ç”šå°‘ï¼Œæˆ‘æœ¬æ¥ä¹Ÿä¸æ˜¯ç ”ç©¶é‚£ä¸ªæ–¹å‘ï¼Œä½†æ˜¯å¹³æ—¶è¿˜æ˜¯æœ‰å¾ˆå¤šä¸Žæ–¹å‘å­¦ä¹ çš„æœºä¼šï¼Œæˆ‘éƒ½ä¸æƒ³åŽ»å­¦ã€‚è¿™ç»™æˆ‘ä¸€ä¸ªæç¤ºï¼Œé™¤äº†æŠ€æœ¯çš„æ·±åº¦ï¼Œä¸€å®šè¦æé«˜çš„è‡ªå·±æ¶‰çŒŽçš„å¹¿åº¦ã€‚ å¾®ç­–ç•¥ã€‚ å…ˆæ˜¯çº¿ä¸‹ç¬”è¯•ï¼Œç„¶åŽä¸‰é¢æŠ€æœ¯é¢ã€‚å¾®ç­–ç•¥æ˜¯å…ˆåŽ»å¬å®£è®²ä¼šï¼Œç„¶åŽå†çº¿ä¸Šé¢è¯•ã€‚ç¬”è¯•é¢è¯•éƒ½æ˜¯å…¨è‹±çš„ã€‚ç¬”è¯•ä¸€å°æ—¶ï¼Œé¢˜ç›®è¿˜æ˜¯ä¸å¤ªéš¾çš„ã€‚é¢è¯•ä¸€é¢ï¼Œ13*16 = 244ï¼Œé—®è¿™äº‹å‡ è¿›åˆ¶ï¼Œç­”ï¼šï¼ˆ1x+3)(x+6) = 2x^2 + 4x + 4 =&gt; x=7ã€‚è¯æ˜Žï¼šn(n^2-1) å¯¹äºŽä»»ä½•n&gt;=3çš„å¥‡æ•°éƒ½å¯ä»¥æ•´é™¤ã€‚ç­”ï¼šå¯ä»¥æ•°å­¦å½’çº³æ³•ï¼Œå‡å®šn=2k+1æ»¡è¶³æ¡ä»¶ï¼Œè¯æ˜Žï¼ˆ2k+3)ä¹Ÿæ»¡è¶³ï¼Œæœ€åŽå¾—åˆ°[(2k+1)^3-(2k+1)] + 24k^2 + 48k + 24æ˜¾ç„¶æˆç«‹ã€‚é—®ä¸€ä¸ªå­—ç¬¦ä¸²çš„å…¨æŽ’åˆ—ï¼Œæˆ‘ä»¥ä¸ºæ˜¯leetcode 46. Permutationsï¼Œå®žé™…ä¸Šæ˜¯leetcode 47. Permutations IIã€‚æˆ‘æŒ‰ç…§46çš„æ€è·¯å†™çš„ä»£ç ï¼Œä¸»è¦å·®åˆ«æ˜¯47æ˜¯æœ‰é‡å¤çš„ã€‚åŽæ¥ä»–æç¤ºæ˜¯å¦æœ‰bugï¼Œæˆ‘æƒ³åˆ°äº†47ï¼Œç„¶åŽæ”¹äº†é‡å¤çš„éƒ¨åˆ†ï¼Œä½†æ˜¯ç«Ÿç„¶åˆå¿˜äº†å…ˆsortä¸‹ã€‚æ‰€ä»¥è¿™é“é¢˜ç­”çš„ä¸å¥½ã€‚è¿™é“é¢˜ç­”çš„ä¸å¥½ï¼Œæˆ‘ä¹Ÿåæ€è¿‡ï¼Œè‡ªå·±ä¸å¤Ÿçµæ´»ï¼Œæ²¡è€ƒè™‘é‚£ä¹ˆå¤šï¼Œç›´æŽ¥å¯¹ä¸Šé¢˜å·äº†ï¼Œæ€æƒ³åƒµï¼ˆjiangï¼‰åŒ–äº†ï¼Œä¸€å®šè¦ä¸Žè‡ªå·±åšè¿‡çš„é¢˜ç›®å¯¹ä¸€èµ·åšå¯¹æ¯”ï¼Œæ³¨æ„å·®åˆ«ã€‚äºŒé¢ã€‚ç»™ä¸€æ®µä»£ç ï¼Œè®©æ‰¾å‡ºbugï¼Œé‡Œé¢æ¶‰åŠäº†æŒ‡é’ˆå’Œmallocå’Œstrcpyè¿™äº›ï¼Œæˆ‘æ²¡æ‰¾å‡ºbugã€‚ç¼–ç¨‹é¢˜1ï¼Œä¸€æ®µé“¾è¡¨ï¼Œåè½¬å‰nä¸ªèŠ‚ç‚¹ã€‚ç±»ä¼¼äºŽleetcode 92. Reverse Linked List IIã€‚ç¼–ç¨‹é¢˜2ï¼Œleetcode 25. Reverse Nodes in k-Groupã€‚ ç¼–ç¨‹é¢˜3ï¼Œsingle numberé—®é¢˜leetcode 136. Single Numberï¼Œç¼–ç¨‹é¢˜4ï¼Œleetcode 137. Single Number IIã€‚ä¸‰é¢ã€‚ç¼–ç¨‹é¢˜1ï¼Œ 121. Best Time to Buy and Sell Stockï¼Œç¼–ç¨‹é¢˜2ï¼Œ leetcode 123. Best Time to Buy and Sell Stock IIIï¼Œç¼–ç¨‹é¢˜3ï¼Œleetcode 122. Best Time to Buy and Sell Stock IIï¼Œç¼–ç¨‹é¢˜4ï¼Œ397 Integer Replacement ã€‚ç¼–ç¨‹é¢˜ 2å†™äº†ä¸¤ç§æ–¹æ³•ï¼Œæ€è€ƒèŠ±äº†äº›æ—¶é—´ã€‚ç¼–ç¨‹é¢˜4ç»™äº†å‡ ç§è§£æ³•ï¼Œä½†é—æ†¾çš„æ˜¯æ²¡æœ‰ç»™å‡ºæœ€ä¼˜è§£ã€‚ å•†æ±¤ã€‚å®žä¹ çš„æ—¶å€™ç¬”è¯•è¿‡äº†ï¼Œé‚€è¯·é¢è¯•ï¼Œæˆ‘å½“æ—¶æœ‰ä¸‰å››å®¶éƒ½è¦é¢è¯•ï¼Œè¿˜è¦äº¤pptï¼Œå¬è¯´æ¯”è¾ƒéš¾ï¼Œå°±æ²¡åŽ»é¢ã€‚æ ¡æ‹›çš„æ—¶å€™ç¬”è¯•æŒ‚äº†ã€‚ face++ï¼Œå®žä¹ æ²¡æŠ•ï¼Œæ ¡æ‹›ç¬”è¯•æŒ‚ã€‚ å¾®è½¯ã€‚å®žä¹ å’Œæ ¡æ‹›éƒ½æ˜¯ç¬”è¯•æŒ‚äº†ã€‚ è˜‘è‡è¡—&amp;ç¾Žä¸½è¯´ã€‚ å®žä¹ æŠ•äº†æ²¡ç†æˆ‘ã€‚æ ¡æ‹›å†…æŽ¨æŠŠæˆ‘ç®€åŽ†æŒ‚äº†ï¼Œæ ¡æ‹›åˆæŠ•äº†ä¸€æ¬¡ï¼ŒåˆæŒ‚äº†ä¸€æ¬¡ç®€åŽ†ã€‚ freewheelï¼Œç¬¬å››èŒƒå¼ï¼Œhuluï¼Œå¿«æ‰‹ç­‰æŠ•äº†æ ¡æ‹›ï¼Œæ²¡æ¶ˆæ¯ï¼Œåº”è¯¥æ˜¯ç®€åŽ†æŒ‚äº†ã€‚çœ‹å‘¨å›´äººéƒ½æŠ•äº†é“¾å®¶ç½‘çš„å†…æŽ¨ï¼Œæˆ‘å°±æŠ•äº†é“¾å®¶ç½‘ï¼Œç»“æžœé“¾å®¶çš„æ ¡æ‹›æ˜¯çº¿ä¸‹ç¬”è¯•ï¼Œæˆ‘ä¸çŸ¥é“ï¼Œå°±é”™è¿‡äº†ã€‚ é¢è¯•å¿ƒå¾—ä»¥ä¸Šå°±æ˜¯è¯¦ç»†çš„é¢è¯•éƒ¨åˆ†ï¼Œä¸‹é¢æ˜¯ä¸€äº›è‡ªå·±å‚è€ƒåˆ«äººçš„ç»éªŒåŠè‡ªèº«çš„ç»åŽ†ï¼Œæ€»ç»“çš„ä¸€äº›ç»éªŒæ•™è®­å§ï¼Œå¸Œæœ›å¯¹è‡ªå·±æ˜¯ä¸€ä¸ªæ€»ç»“ï¼Œå¯¹å­¦å¼Ÿå­¦å¦¹ä»¬ä¹Ÿå¸Œæœ›èƒ½æœ‰æ‰€å¸®åŠ©å§ã€‚ æŠŠæ¡å¥½æ—¶é—´å®žä¹ ã€æ ¡æ‹›çš„æ—¶é—´è¡¨ã€‚å®žä¹ åˆ†ä¸ºå†…æŽ¨é˜¶æ®µå’Œæ ¡æ‹›é˜¶æ®µã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œäº’è”ç½‘æ‰¾å·¥ä½œçš„æ—¶é—´è¶Šæ¥è¶Šæ—©ã€‚2017å¹´ä»Šå¹´çš„æƒ…å†µæ˜¯å¤§éƒ¨åˆ†å…¬å¸åœ¨2-5æœˆï¼ˆå®žä¹ åŒ…å«å†…æŽ¨å’Œæ ¡æ‹›ä¸¤é˜¶æ®µï¼‰ã€‚å…ˆæ˜¯å†…æŽ¨ï¼ŒåŽé¢å°±æ˜¯æ ¡æ‹›ã€‚ä¹Ÿæœ‰ç‰¹åˆ«æ—©çš„ï¼Œæ¯”å¦‚ç½‘æ˜“æ¸¸æˆï¼ŒåŽ»å¹´12æœˆå·¦å³å°±å¼€å§‹å†…æŽ¨äº†ã€‚å†…æŽ¨é˜¶æ®µåˆšèµ°å®Œæˆ–è€…æ²¡æœ‰èµ°å®Œå°±å¼€å§‹åˆ°äº†å®žä¹ çš„æ ¡æ‹›é˜¶æ®µäº†ã€‚æ ¡æ‹›ä¹Ÿåˆ†ä¸¤ä¸ªé˜¶æ®µï¼Œå†…æŽ¨é˜¶æ®µå’Œï¼ˆæ­£å¼ï¼‰æ ¡æ‹›é˜¶æ®µã€‚æ—¶é—´åœ¨6æœˆåº•å·¦å³-11æœˆã€‚å¾ˆå¤šå…¬å¸åœ¨6æœˆåº•7æœˆåˆå°±å¼€å§‹äº†ï¼Œæ¯”å¦‚äº¬ä¸œã€é˜¿é‡Œã€è…¾è®¯ç­‰ã€‚äº¬ä¸œä»¥å¾€è²Œä¼¼éƒ½æ˜¯æ¯”è¾ƒæ—©çš„ï¼Œä»Šå¹´ä¹Ÿæ˜¯æ—©æ—©çš„é¢è¯•ï¼Œæ—©æ—©åœ°å‘äº†offerã€‚é™¤äº†å†…æŽ¨å’Œæ ¡æ‹›é˜¶æ®µï¼Œæœ‰çš„å…¬å¸è²Œä¼¼è¿˜æœ‰æå‰æ‰¹ï¼ˆäº¬ä¸œè²Œä¼¼æœ‰ï¼‰ã€‚æˆ‘è‡ªå·±çš„æ•™è®­å°±æ˜¯ï¼Œæ ¡æ‹›æŠ•çš„å¤ªæ™šï¼Œä»¥è‡³äºŽé”™è¿‡äº†å¾ˆå¤šé¢è¯•æœºä¼šã€‚æˆ‘ä¸ºä»€ä¹ˆæŠ•è¿™ä¹ˆæ™šå‘¢ï¼Ÿä¸Šé¢ä¹Ÿåˆ†æžè¿‡ï¼Œæœ‰å¸Œæœ›èƒ½æŠŠå®žä¹ ç»åŽ†å†™ä¸ŠåŽ»ï¼Œä¹Ÿæœ‰è‡ªå·±æƒ³å¥½å¥½å¤ä¹ å¥½å¥½å‡†å¤‡çš„å› ç´ ã€‚å®žä¹ çš„æ—¶å€™æˆ‘æŠ•çš„å°±éžå¸¸æ—©ï¼Œç»“æžœå‡†å¤‡çš„ä¸å……åˆ†ï¼Œé‡åˆ°äº†å¾ˆå¤šè¢«æ‹’ï¼Œä¹Ÿç®—æ˜¯æ‰¾å®žä¹ é‡åˆ°çš„å°åŽé—ç—‡å§ã€‚æŠ•çš„å¤ªæ™šé”™è¿‡äº†è…¾è®¯ã€é˜¿é‡Œçš„æ ¡æ‹›å†…æŽ¨é˜¶æ®µï¼Œæ˜¯éžå¸¸å¯æƒœçš„ã€‚é˜¿é‡Œçš„æ ¡æ‹›å†…æŽ¨éœ€è¦é‡æ–°å†…æŽ¨ï¼Œè…¾è®¯çš„å®žä¹ çš„ç®€åŽ†ä¼šç›´æŽ¥è½¬æˆæ ¡æ‹›å†…æŽ¨çš„ï¼Œä¸ç”¨å†æŽ¨ï¼Œå¯ä»¥æ›´æ–°ä¸‹è‡ªå·±æŠ•çš„éƒ¨é—¨ä¿¡æ¯å°±è¡Œäº†ã€‚æˆ‘è‡ªå·±ä¹Ÿæ²¡åŽ»æ›´æ–°ç®€åŽ†ã€‚æ€»ä¹‹å§ï¼Œè‡ªå·±çš„ç®€åŽ†ä¸å¤Ÿå¥½çœ‹ï¼Œå¸Œæœ›èƒ½åˆ·æ–°ä¸‹ç®€åŽ†å†æŠ•ï¼Œä»¥è‡³äºŽé”™è¿‡äº†æ—¶é—´ã€‚è¿˜æœ‰äºšé©¬é€Šï¼Œäºšé©¬é€Šå†™çš„æ ¡æ‹›å¼€å§‹æ—¶9.10ï¼Œç»“æžœæˆ‘æŠ•çš„æ™šï¼Œäººå®¶9.5å°±å¼€å§‹ç¬¬2è½®è¿˜æ˜¯ç¬¬3è½®ç¬”è¯•äº†ã€‚æŒºå¯æƒœçš„é”™è¿‡äº†ã€‚ æŠŠæ¡å¥½å†…æŽ¨å’Œå®žä¹ è½¬æ­£æœºä¼šã€‚çŽ°åœ¨å¤§å®¶éƒ½æ‹›å†…æŽ¨äº†ï¼Œç„¶åŽå†…æŽ¨è·Ÿæ­£å¼çš„ä¹Ÿå·®ä¸å¤šäº†ã€‚æ— è®ºä»Žå®žä¹ è¿˜æ˜¯æ ¡æ‹›çš„ç»“æžœæ¥çœ‹ï¼Œå†…æŽ¨ä¼šå¸æ”¶å¾ˆå¤§ä¸€æ‰¹äººï¼Œæ‰€ä»¥ç•™ç»™æ ¡æ‹›çš„åé¢å¹¶ä¸å¤šï¼Œå¹¶ä¸”æ‰€æœ‰äººéƒ½å‚åŠ æ ¡æ‹›ï¼Œæ‰€ä»¥ç«žäº‰æ˜¯éžå¸¸æ¿€çƒˆçš„ã€‚æ‰€ä»¥å¤§å®¶ä¸€å®šè¦æŠŠæ¡å¥½å†…æŽ¨çš„æœºä¼šã€‚å°¤å…¶æ ¡æ‹›çš„æ—¶å€™ï¼Œå¾ˆå¤šå…¬å¸çš„å®žä¹ ç”Ÿéƒ½è½¬æ­£äº†ï¼Œå ç”¨äº†å¾ˆå¤šåé¢ï¼Œæ‰€ä»¥æ ¡æ‹›çš„å†…æŽ¨å’Œæ ¡æ‹›é˜¶æ®µç«žäº‰è¿˜æ˜¯éžå¸¸æ¿€çƒˆçš„ï¼Œå­¦å¼Ÿå­¦å¦¹ä»¬è¿˜æ˜¯è¦åŠ æ²¹ã€‚è¯´æ˜¯å®žä¹ è½¬æ­£ï¼Œå¤§å®¶è¦åƒä¸‡æŠŠæ¡å¥½æœºä¼šã€‚å¦‚æžœæƒ³åœ¨æŸä¸ªå…¬å¸ç•™ä¸‹ï¼Œæˆ‘ä¸ªäººå»ºè®®ï¼Œä¼˜å…ˆåŽ»è¯¥å…¬å¸å®žä¹ ã€‚å®žä¹ è½¬æ­£ï¼Œå°¤å…¶æ˜¯å®žä¹ çš„æœ¬éƒ¨é—¨è½¬æ­£æ˜¯æœ€å®¹æ˜“çš„ã€‚æƒ³åœ¨å“ªä¸ªéƒ¨é—¨å·¥ä½œï¼Œå®žä¹ æ˜¯ä¸€ä¸ªéžå¸¸ç®€å•åˆçœäº‹çš„é€”å¾„ã€‚å†…æŽ¨çš„æ—¶å€™æœ€å¥½è¦æ‰¾ç†Ÿäººå†…æŽ¨ã€‚å¯ä»¥å¸®å¿™æŸ¥çœ‹ç®€åŽ†è¿›åº¦ã€‚è…¾è®¯çš„å†…éƒ¨å¯ä»¥çœ‹åˆ°ç®€åŽ†è¯„ä»·Sçº§ã€A+ã€Aã€Bã€Cç­‰ã€‚ä¹Ÿå¯ä»¥çœ‹åˆ°é¢è¯•å®˜çš„åç§°ç­‰ä¿¡æ¯ã€‚é˜¿é‡Œçš„ä¹Ÿå¯ä»¥çœ‹åˆ°é¢è¯•å®˜çš„åç§°ä¿¡æ¯ï¼Œå¹¶ä¾æ­¤åˆ¤æ–­æŸäº›ä¿¡æ¯ã€‚æ‰¾ç†ŸäººæŽ¨ï¼Œæ–¹ä¾¿åŽç»­çš„è”ç³»ã€‚è¿˜æœ‰æœ€å¥½ç›´æŽ¥æŽ¨åˆ°è‡ªå·±æƒ³åŽ»çš„éƒ¨é—¨ã€‚å¦‚æžœè‡ªå·±æœ‰æ˜Žç¡®çš„éƒ¨é—¨ï¼Œå¯ä»¥ç›´æŽ¥æŽ¨åˆ°ç›¸å…³éƒ¨é—¨ï¼Œå¦‚æžœä¸å†™éƒ¨é—¨ï¼Œå¾ˆå¤šéƒ½æ˜¯ç›´æŽ¥è¿›å…¬å¸ç®€åŽ†æ± ã€‚å¦‚æžœå†™äº†ï¼Œç›¸å½“äºŽå…ˆåœ¨éƒ¨é—¨ç®€åŽ†æ± ï¼Œç„¶åŽè¿›å…¬å¸ç®€åŽ†æ± ï¼Œç›¸å¯¹è€Œè¨€ï¼Œç›¸å½“äºŽå¤šäº†ä¸€æ¬¡æœºä¼šã€‚æ‰¾ç†Ÿäººå†…æŽ¨çš„å¦ä¸€ä¸ªå¥½å¤„æ˜¯ï¼Œå¦‚æžœæ˜¯æŠ•çš„ä»–çš„éƒ¨é—¨ï¼Œä»–å¯ä»¥ç›´æŽ¥æŠŠç®€åŽ†æ‰”ç»™ä»–è€å¤§ï¼Œé‚€è¯·ä½ åŽ»é¢è¯•ã€‚ å†™å¥½ç®€åŽ†ï¼Œè®²å¥½é¡¹ç›®ã€‚ç®€åŽ†è‚¯å®šæ˜¯ç‰¹åˆ«é‡è¦çš„ï¼Œç®€åŽ†æ˜¯é¢è¯•å®˜å¯¹ä½ çš„ç¬¬ä¸€å°è±¡ï¼Œä¸€å®šè¦å¥½å¥½å†™ï¼Œå¦‚å®žç¨å¾®ä¿®é¥°çš„å†™ã€‚è‡ªå·±çš„ä¼šçš„èƒ½è®²æ¸…æ¥šæ˜Žç™½çš„éƒ½å†™ä¸ŠåŽ»ï¼Œè‡ªå·±å«ç³Šå…¶è¾žçš„æžä¸å¤ªæ¸…æ¥šå®¹æ˜“è¢«é—®æ‡µçš„å°±ä¸è¦å†™äº†ã€‚ç»å¸¸æ›´æ–°è‡ªå·±çš„ç®€åŽ†ã€‚æˆ‘è‡ªå·±çš„ç®€åŽ†é¢è¯•å®Œå°±ä¼šæ”¹ä¸€æ”¹ï¼Œä¿®ä¸€ä¿®ï¼Œæ¯æ¬¡éƒ½æ€»ç»“ä¸€ä¸‹é¢è¯•ï¼Œä¿®ç¼®ä¸€ä¸‹ç®€åŽ†ã€‚ç®€åŽ†ä¸Šçš„é¡¹ç›®çš„ç»†èŠ‚ä¹‹ç±»çš„è‡ªå·±éƒ½è¦æ¸…æ¥šåœ°æ˜Žç™½ï¼Œä¸€å®šä¸èƒ½ç»™é¢è¯•å®˜é—®çš„ç­”ä¸å‡ºæ¥ï¼Œé‚£é¢è¯•å®˜å°±å¾ˆæ€€ç–‘ä½ çš„æ°´å¹³å’Œé¡¹ç›®æ˜¯å¦ä½ åšçš„äº†ã€‚ æé«˜è‡ªå·±çš„ç¼–ç¨‹æ°´å¹³ã€‚å¾ˆå¤šäººéƒ½æŽ¨èå‰‘æŒ‡offerã€leetcodeã€‚çš„ç¡®å¾ˆä¸é”™çš„ï¼Œæˆ‘çœ‹çŽ°åœ¨å‰‘æŒ‡offeréƒ½æ›´æ–°åˆ°ç¬¬äºŒç‰ˆäº†ã€‚è‡³äºŽç¼–ç¨‹æé«˜åˆ°ä»€ä¹ˆæ°´å¹³ï¼Œå‰‘æŒ‡offerå¯ä»¥éƒ½çœ‹äº†ï¼Œéƒ½æžæ˜Žç™½äº†ã€‚æˆ‘è‡ªå·±æ˜¯åˆ·äº†300é“leetcodeï¼Œåˆ·äº†ä¸¤éå·¦å³çš„ã€‚æˆ‘çœ‹å‘¨å›´çš„åŒå­¦å¤§éƒ½åœ¨100-200å·¦å³çš„æ ·å­ï¼Œä¹Ÿéƒ½æ‰¾åˆ°çš„éžå¸¸ä¸é”™çš„å·¥ä½œã€‚æˆ‘è¿™é‡Œçš„ç»éªŒæ˜¯ç®—æ³•å·¥ç¨‹å¸ˆçš„ï¼Œå¾ˆå¤šå…¬å¸çš„ï¼ˆæ¯”å¦‚æ»´æ»´ã€ç¾Žå›¢ã€ç™¾åº¦ã€é˜¿é‡Œç­‰ï¼‰ç®—æ³•å·¥ç¨‹å²—ä½çš„é¢è¯•ï¼Œä¸€åœºé¢è¯•éƒ½æ˜¯åˆ†ä¸‰å—ï¼Œé¡¹ç›®ä»‹ç»ã€æœºå™¨å­¦ä¹ ç›¸å…³çŸ¥è¯†ã€ç¼–ç¨‹é¢˜ã€‚ä¸€åœºé¢è¯•ä¸€èˆ¬å°±ä¸€é“ç¼–ç¨‹é¢˜ã€‚ç¼–ç¨‹å†™ä¸å‡ºæ¥å°±åŸºæœ¬æŒ‚äº†ã€‚å½“ç„¶é¢è¯•ä¹Ÿæ²¡æœ‰éžè¦æŒ‰ä¸€å®šå¥—è·¯çš„ï¼Œè¦çœ‹é¢è¯•å®˜çš„ï¼Œé¢è¯•å®˜å–œæ¬¢é—®ä»€ä¹ˆï¼Œæˆ‘ä»¬å°±ç­”ä»€ä¹ˆã€‚æœ‰çš„å…¬å¸éžå¸¸æ³¨é‡ç¼–ç¨‹ï¼Œæ¯”å¦‚å¾®è½¯ï¼Œé¢è¯•å‡ ä¹Žå…¨æ˜¯ç¼–ç¨‹é¢˜ï¼Œè€Œä¸”ç¼–ç¨‹çš„è¦æ±‚æ¯”è¾ƒé«˜ã€‚å¤´æ¡çš„ç¼–ç¨‹é¢˜é—®çš„ä¹Ÿå¾ˆä¸å®¹æ˜“ã€‚è¦æ˜¯æƒ³æ‰¾ä¸€èˆ¬çš„äº’è”ç½‘å…¬å¸ï¼Œæ„Ÿè§‰çœ‹å®Œå‰‘æŒ‡offerã€åˆ·leetcode 100-200é“å°±å·®ä¸å¤šäº†ã€‚å½“ç„¶è¿™æ˜¯æˆ‘è‡ªå·±çš„åˆ¤æ–­ï¼Œä»…ä¾›å‚è€ƒï¼Œå¯¹æ­¤ä¸è´Ÿè´£ä»»ã€‚è¿˜æœ‰å»ºè®®æ˜¯åˆ·é¢˜çš„æ—¶å€™ï¼Œè¦åšä¸€ä¸‹ç¬”è®°ï¼Œç»å¸¸å›žå¤´çœ‹ä¸€çœ‹ï¼Œæˆ‘åˆ·é¢˜çš„æ—¶å€™ï¼Œä½¿ç”¨æŸç¬”è®°ï¼ˆç”µå­ç¬”è®°ç±»äº§å“ï¼Œé¿å…å¹¿å‘Šå«Œç–‘ï¼‰è®°å½•ä¸€ä¸‹é¢˜ç›®ï¼Œæ ‡ç­¾ï¼Œè§£å†³æ€è·¯ä¸Žæ–¹æ³•ç­‰ã€‚ä»¥åŽæ–¹ä¾¿å›žé¡¾ã€‚æˆ‘è‡ªå·±å°±æ˜¯ç»å¸¸çœ‹ä¸€çœ‹è‡ªå·±åšçš„ç¬”è®°ï¼Œæ¯”æ¯æ¬¡éƒ½é‡å¤´åˆ·ï¼Œæ€è·¯æ¸…æ™°å¤šäº†ã€‚å»ºè®®å°è¯•ä¸€ä¸‹ã€‚ æé«˜æœºå™¨å­¦ä¹ ç›¸å…³çš„æŠ€æœ¯æ°´å¹³ã€‚ç®—æ³•å·¥ç¨‹å¸ˆä¸€å®šä¼šé—®æœºå™¨å­¦ä¹ ç›¸å…³çš„çŸ¥è¯†ï¼Œè¿™ä¸€å—ä¸€å®šè¦å¥½å¥½çš„æžæ¸…æ¥šæ˜Žç™½äº†ã€‚æˆ‘è‡ªå·±æ˜¯çœ‹äº†æŽèˆªè€å¸ˆçš„ç»Ÿè®¡å­¦ä¹ æ–¹æ³•+éƒ¨åˆ†prml+ä¸€äº›å…¶ä»–çš„å­¦ä¹ ã€‚å¯¹è¿™ä¸€å—å†…å®¹çš„ç†è§£åº”è¯¥æ˜¯å†³å®šæ˜¯å¦å‘å¤§offerçš„å…³é”®ã€‚ä¸€èˆ¬ç¼–ç¨‹é¢˜éƒ½èƒ½å†™å‡ºæ¥ï¼Œå†™ä¸å‡ºæ¥å°±æŒ‚äº†ã€‚ä½ å¯¹æœºå™¨å­¦ä¹ ç›¸å…³çš„ç†è§£æ·±å…¥ç¨‹åº¦ã€å¥½çš„å®žä¹ ç»åŽ†ã€å¥½çš„è®ºæ–‡ã€å¥½çš„ç«žèµ›éƒ½æ˜¯é¢è¯•ä¸­çš„äº®ç‚¹ã€‚å¦‚æžœä½ å…¶ä»–æ–¹é¢éƒ½ä¸èƒ½é—ªå…‰çš„è¯ï¼Œå°±æŠŠå¯¹æŠ€æœ¯çš„ç†è§£æ·±å…¥ä½œä¸ºåˆ‡å…¥ç‚¹ï¼Œå¥½å¥½çš„ä¸“ç ”ä¸‹åŽ»å§ã€‚ æœ¬è´´çš„ç›®çš„åœ¨äºŽå¯¹è‡ªå·±ä¸€å¹´å·¥ä½œçš„æ€»ç»“ä¸Žæ€è€ƒï¼ŒåŒæ—¶å¸Œæœ›èƒ½å¯¹å­¦å¼Ÿå­¦å¦¹ä»¬æœ‰æ‰€å¸®åŠ©æ¬¢è¿Žè®¨è®ºï¼Œå¦‚æœ‰ä¸å½“ï¼Œæœ›æŒ‡å‡ºã€‚æœ€åŽç¥å­¦å¼Ÿå­¦å¦¹ä»¬éƒ½èƒ½æœ‰å¥½çš„å®žä¹ ï¼Œæ”¶å‰²å¤§é‡çš„offerï¼å¦‚éœ€è½¬è½½ï¼Œæ³¨æ˜Žå‡ºå¤„ã€‚ ç›¸å…³é—®é¢˜åŠæˆ‘çš„æƒ³æ³•ï¼š1.å¯ä»¥ç®€å•ä»‹ç»ä¸€ä¸‹ä½ ç®€åŽ†ä¸Šæœ‰å‡ ä¸ªé¡¹ç›®(æˆ‘çœ‹æ–‡ç« é‡Œè¯´æ˜¯2ä¸ª)ï¼Œä»¥åŠé¡¹ç›®çš„å¤§è‡´å·¥ä½œå—ï¼Ÿæˆ‘è‡ªå·±å†™ç®€åŽ†çš„æ—¶å€™ä¹Ÿæ˜¯è›®å°´å°¬çš„ï¼Œé¡¹ç›®çš„ç¡®éžå¸¸å°‘ã€‚æˆ‘è‡ªå·±åªæœ‰ä¸€æ®µå°å…¬å¸çš„å®žä¹ ç»åŽ†ï¼Œè€Œä¸”è·Ÿç®—æ³•å…³ç³»ä¸å¤§ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œå› ä¸ºå¯¼å¸ˆä¸¥æ ¼ä¸è®©å®žä¹ ï¼Œå°±æ²¡æœ‰å®žä¹ ç»åŽ†äº†ã€‚ç›¸å¯¹æ¯”è¾ƒå¥½çš„æ˜¯ï¼Œæˆ‘ä»¬å®žéªŒå®¤éƒ½æ˜¯åšç®—æ³•ç›¸å…³çš„ï¼Œæ‰€ä»¥æˆ‘æŠŠæœ¬ç§‘æ¯•è®¾å†™äº†è¿›åŽ»ã€‚ç ”ç©¶ç”ŸæœŸé—´å¯¼å¸ˆä¹Ÿæ²¡æœ‰é¡¹ç›®ï¼Œæ‰€ä»¥æˆ‘æŠŠæˆ‘çš„ç ”ç©¶æ–¹å‘ï¼ˆå°±æ˜¯æˆ‘è‡ªå·±ç ”ç©¶æ–¹å‘åšçš„å®žéªŒï¼Œä¹Ÿæ˜¯ç ”ç©¶ç”Ÿæ¯•è®¾ï¼‰å†™äº†è¿›åŽ»ã€‚ä¹‹å‰è¿˜æœ‰å‚åŠ äº†ä¸€ä¸ªå°åž‹çš„ç«žèµ›ï¼Œæ‰€ä»¥è¿™æ ·å­å°±å‡‘å¤Ÿäº†å››ä¸ªé¡¹ç›®ã€‚ä¸€èˆ¬ç®€åŽ†ä¸Šå¤§å®¶å†™3-4ä¸ªå°±å¤Ÿäº†ï¼Œå†™å¤ªå¤šä¹Ÿæ²¡å¤ªå¤šæ„ä¹‰ã€‚å…¶ä¸­æˆ‘çš„é‚£ä¸ªå°å…¬å¸å®žä¹ é¢è¯•çš„æ—¶å€™å‡ ä¹Žæ²¡äººé—®ï¼Œæ‰€ä»¥åœ¨é¢å®žä¹ çš„æ—¶å€™ä¸»è¦æ˜¯é—®ç ”ç©¶ç”Ÿç›¸å…³çš„é‚£ä¸ªé¡¹ç›®ï¼Œé‚£ä¸ªå°ç«žèµ›ï¼Œè¿˜æœ‰æœ¬ç§‘æ¯•è®¾ã€‚åŽæ¥æ ¡æ‹›çš„æ—¶å€™å°±æŠŠé‚£ä¸ªå°å…¬å¸å®žä¹ ç»™æ¢æˆäº†æ»´æ»´çš„å®žä¹ ï¼ŒæŠŠå°å…¬å¸å®žä¹ ç»™åˆ äº†ã€‚æ‰¾å·¥ä½œçš„æ—¶å€™å¤§å®¶éƒ½ä¼šé—®ä½ çš„å®žä¹ ç»åŽ†ã€‚å½“æ—¶çš„æœ¬ç§‘æ¯•è®¾åšçš„çš„ç¡®æ¯”è¾ƒæ°´ï¼ŒåˆåŠ ä¸Šæœ¬ç§‘æ—¶æ°´å¹³èœï¼Œåšçš„çš„ç¡®å°±é‚£æ ·ã€‚ç ”ç©¶ç”Ÿçš„æ¯•è®¾åšçš„è¿˜æ˜¯æŒºè®¤çœŸçš„ï¼Œè¿˜æ˜¯æœ‰è¿›æ­¥çš„ç©ºé—´ã€‚å¦‚æžœé‡æ–°èµ°çš„è¯ï¼Œæˆ‘è¿™äº›éƒ½ä¼šæ›´è®¤çœŸçš„åšï¼Œæ‰¾å®žä¹ æ‰¾å·¥ä½œè¿˜æ˜¯éžå¸¸æœ‰æœ‰ç”¨çš„ã€‚ç ”ä¸€æš‘å‡æ˜¯åŽ»å®žä¹ çš„å¥½æœºä¼šï¼Œé‚£æ—¶æˆ‘ä»¬æ˜¯æŒ‰æ ¡åŽ†æ”¾å‡çš„ï¼Œåˆæœ‰æ—¶é—´ï¼Œæˆ‘æ²¡æœ‰æŠ“ä½ã€‚ 2.é¡¹ç›®åœ¨é¢è¯•è¿‡ç¨‹ä¸­çš„é‡è¦æ€§æ˜¯1/3å·¦å³å—ï¼Ÿå¦‚æžœç»™é¡¹ç›®ã€æœºå™¨å­¦ä¹ çŸ¥è¯†ä»¥åŠç¼–ç¨‹æŽ’åºï¼Œåº”è¯¥æ˜¯æ€Žä¹ˆæ ·çš„ï¼Ÿæœ‰æ²¡æœ‰é¡¹ç›®ç»åŽ†ä¸è¶³ï¼Œä½†ç”¨åŸºç¡€çŸ¥è¯†åŽ»å¹³è¡¡çš„æƒ…å†µï¼Ÿå¾ˆå¤šåŒå­¦éƒ½ä¼šé—®é¡¹ç›®ç›¸å…³é—®é¢˜ã€‚é¢è¯•ä¸­çš„ç¡®ä¼šé—®é¡¹ç›®ï¼Œä¸€èˆ¬ä¸€ä¸ªå°æ—¶ä¸€åœºé¢è¯•ï¼Œå¸¸è§„çš„æ˜¯20åˆ†é’ŸèŠé¡¹ç›®ï¼Œ20åˆ†é’ŸèŠæœºå™¨å­¦ä¹ ç›¸å…³çŸ¥è¯†ï¼Œæœ€åŽ20åˆ†é’Ÿç¼–ç¨‹å¹¶ç™½çº¸ç®—æ³•ã€‚æ—¶é—´20åˆ†é’Ÿåªæ˜¯ä¼°è®¡ï¼Œåªèƒ½è¯´æ˜¯å¤§æ¦‚ã€‚ä¸€èˆ¬ä¸€é¢éƒ½æ˜¯æŠ€æœ¯ï¼ŒäºŒé¢å¯èƒ½æŠ€æœ¯ä¹Ÿå¯èƒ½ä¼šéšä¾¿èŠã€‚å¦‚ä¸Šæ–‡æ‰€è¿°ï¼Œæˆ‘ä¹Ÿæ²¡æœ‰ç‰¹åˆ«å¥½çœ‹çš„é¡¹ç›®ã€‚éƒ½æ˜¯æœ¬ç§‘æ¯•è®¾ï¼Œç ”ç©¶ç”Ÿæ¯•è®¾ï¼Œå°ç«žèµ›è¿™æ ·å­çš„ã€‚å¤§å®¶ä¹Ÿå¯ä»¥å‘æŒ¥èªæ˜Žçš„è„‘å­æƒ³æƒ³æ€Žä¹ˆå†™ç®€åŽ†ã€‚è‡³äºŽé‡è¦æ€§ï¼Œéƒ½æ˜¯éžå¸¸é‡è¦çš„ã€‚æœ‰çš„é¢è¯•å®˜å–œæ¬¢å…¨ç¨‹èŠé¡¹ç›®ï¼ŒèŠç€é¡¹ç›®ç©¿æ’ç€æœºå™¨å­¦ä¹ ç›¸å…³çŸ¥è¯†çš„æé—®ã€‚ä¹‹å‰æ‰¾å®žä¹ çš„æ—¶å€™ï¼Œå¾ˆå¤šäººé˜¿é‡Œçš„ä¸€é¢å°±æ˜¯æ‹¿ç€ç®€åŽ†èŠé¡¹ç›®åŠç›¸å…³çŸ¥è¯†ã€‚è¿™ä¹Ÿæ¶‰åŠä¸€ä¸ªå¾ˆå¤§çš„é—®é¢˜ï¼Œå°±æ˜¯é¢è¯•åˆ°åº•è¦é¢ä»€ä¹ˆï¼Ÿåˆ†è§£èµ·æ¥å°±æ˜¯è¦é¢ä»€ä¹ˆå†…å®¹ï¼Œæƒ³è€ƒå¯Ÿä»€ä¹ˆèƒ½åŠ›å‘¢ï¼Ÿæˆ–è€…è¯´ä¸€ä¸ªç®—æ³•å·¥ç¨‹å¸ˆå¯¹è¿™äº›çš„è¦æ±‚æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿå¾ˆç›´ç™½çš„ï¼Œå¾ˆåŸºæœ¬çš„å°±æ˜¯ç¼–ç¨‹ï¼Œç®—æ³•çš„ç†è§£ï¼Œå·¥ç¨‹å®žè·µèƒ½åŠ›ï¼Œè¿˜ä¼šè€ƒå¯Ÿæ•°å­¦çŸ¥è¯†ï¼Œè„‘ç­‹æ€¥è½¬å¼¯ç­‰ï¼Œç”šè‡³æ›´åŠ æ·±å…¥çš„ä¼šè€ƒå¯Ÿä½ çš„çŸ¥è¯†çš„å¹¿åº¦ï¼Œæ·±åº¦ï¼Œè¿˜æœ‰éšæœºåº”å˜çš„èƒ½åŠ›ã€‚å¯¹äºŽç¼–ç¨‹ï¼Œæˆ‘è®¤ä¸ºæœ€ä½Žè¦æ±‚æ˜¯åˆ«è®©ç¼–ç¨‹æ‹–ä½ çš„åŽè…¿ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œæ¯åœºé¢è¯•éƒ½ä¼šæœ‰ä¸€ä¸ªç¼–ç¨‹é¢˜ï¼Œä¸€èˆ¬å¥—è·¯æ˜¯å…ˆè®²æ€è·¯ï¼Œå†å†™ä»£ç ã€‚ä»£ç æœ€å¥½bug-freeã€‚å³ä½¿æ²¡æœ‰bug-freeï¼Œç»è¿‡æé†’æƒ³æ˜Žç™½ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚å¤§éƒ¨åˆ†éƒ½ä¼šè®©åˆ†æžä¸‹ä½ çš„ç®—æ³•æ—¶é—´å¤æ‚åº¦ï¼Œç©ºé—´å¤æ‚åº¦ï¼Œå¹¶èƒ½è¯´æ˜Žä¸ºä»€ä¹ˆæ˜¯è¿™ä¸ªæ—¶é—´å¤æ‚åº¦ã€‚å¾ˆå¤šéƒ½ä¼šè¿½æ±‚æœ€ä¼˜è§£ï¼Œæ‰€ä»¥è¿™ä¹Ÿç»™åˆ·é¢˜ä¸€ä¸ªæç¤ºï¼Œåˆ·é¢˜ä¸æ˜¯acå°±å¯ä»¥äº†ï¼Œè€Œæ˜¯è¦è¿½æ±‚æœ€ä¼˜è§£ã€‚ç¼–ç¨‹è¿™å—å¯ä»¥è‡ªå·±æŠŠæ¡ï¼Œåƒä¸‡ä¸è¦åªè¿½æ±‚ç¼–ç¨‹ï¼Œä¸ç®¡å…¶ä»–çš„ã€‚è¿™å¤šä¸ªæ–¹é¢è¦å¹³è¡¡ä¸‹æ—¶é—´å’Œç²¾åŠ›ã€‚æˆ‘ä¹‹å‰æœ‰ä¸€æ®µæ—¶é—´æ•´å¤©åˆ·é¢˜ï¼Œæœ‰æ®µæ—¶é—´æ•´å¤©çœ‹ç®—æ³•ï¼Œæ„Ÿè§‰éƒ½ä¸æ˜¯å¾ˆå¥½ã€‚æœ€å¥½èƒ½å¹³è¡¡ä¸‹æ¥ï¼Œä¸è®©ä»»ä½•ä¸€æ–¹é¢åŽ»æ‹‰åŽè…¿ã€‚å¾ˆå¤šå…¬å¸æ¥è¯´ï¼Œç¼–ç¨‹ä¼šè€ƒå¯Ÿï¼Œä½†æ˜¯é€šè¿‡çš„å¤§å®¶éƒ½ç»™å‡ºæœ€ä¼˜è§£ï¼Œå·®åˆ«ä¹Ÿæ²¡é‚£ä¹ˆå¤§ï¼Œæ‰€ä»¥å¤šå¤šæŽŒæ¡æœºå™¨å­¦ä¹ ç›¸å…³çš„ç®—æ³•å§ï¼Œç›®å‰æˆ‘æ˜¯è¿™ä¹ˆçœ‹çš„ã€‚å…³äºŽå·¥ç¨‹å®žè·µï¼Œä¹Ÿå°±é¡¹ç›®ã€‚åšçš„é¡¹ç›®ï¼Œéƒ½æ˜¯å·¥ç¨‹å®žçŽ°çš„ä¸€éƒ¨åˆ†ï¼Œå¦‚æžœä»€ä¹ˆé¡¹ç›®éƒ½æ²¡åšè¿‡ï¼Œæˆ‘ä»¬æ˜¯é¢è¯•å®˜ï¼Œæˆ‘ä»¬ä¹Ÿä¼šå¯¹è¿™æ ·çš„é¢è¯•è€…ä¸æ”¾å¿ƒçš„ã€‚åƒå¾ˆå¥½çš„å®žä¹ ç»åŽ†ï¼Œå¾ˆå¤šå®žéªŒå®¤æˆ–å¯¼å¸ˆä¸æ”¾å®žä¹ çš„æƒ…å†µä¸‹ï¼Œå®žä¹ ç»åŽ†å¾ˆå¤šåŒå­¦éƒ½æ²¡æœ‰ã€‚å¦‚æžœæœ‰å®žä¹ æœºä¼šï¼Œä¸€å®šè¦æŠŠæ¡ä½ã€‚æ¯”å¦‚ç ”ä¸€ä¸‹çš„æš‘å‡ï¼Œé‚£ä¸ªå‡æœŸå¦‚æžœæ”¾å‡æ—¶é—´æ¯”è¾ƒé•¿çš„è¯ï¼Œå¯ä»¥æ‰¾ä¸ªçŸ­æœŸçš„å®žä¹ ï¼Œä½“éªŒä¸€ä¸‹ã€‚æœ‰äº›å¦‚ACMå¤§ç¥žï¼Œå¯èƒ½å¾ˆå¤šäººæ˜¯åˆ°ä¸äº†è¿™ä¸ªå±‚æ¬¡çš„ã€‚å¯¹äºŽå¤šæ•°åŒå­¦æ¥è¯´ï¼Œçš„ç¡®æ²¡æœ‰å¤ªå¥½çš„å®žä¹ ç»åŽ†ã€‚è§£å†³åŠžæ³•æ˜¯å¦‚æžœæ¡ä»¶å…è®¸ï¼Œå°±åŽ»æ‰¾ä¸€æ®µå®žä¹ ã€‚å¦‚æžœæ¡ä»¶ä¸å…è®¸ï¼Œå¯ä»¥åœ¨å­¦æ ¡å¥½å¥½çš„å­¦å¥½ç›¸å…³çš„æœºå™¨å­¦ä¹ ç†è®ºï¼Œåšå¥½è‡ªå·±çš„è¯¾é¢˜ã€‚æœ‰äº›åŒå­¦å‚åŠ ä¸€äº›ç«žèµ›ï¼Œä¹Ÿæ˜¯å¯ä»¥çš„ã€‚è‡³äºŽæŽ’åï¼Œè‚¯å®šæ˜¯è¶Šé å‰è¶Šå¥½ã€‚æˆ‘è‡ªå·±åšçš„é‚£ä¸ªå°ç«žèµ›ä¹Ÿæ²¡æ‹¿åˆ°å¤ªå¥½çš„åæ¬¡ã€‚æ ¹æ®æˆ‘çš„é¢è¯•æ¥çœ‹ï¼Œé¢è¯•å®˜æˆ–è€…hrå¯èƒ½ä¼šé—®é¢è¯•æŽ’åï¼Œä¹Ÿå¯èƒ½ä¸é—®ã€‚ä½†æ˜¯æŽ’åå¹¶ä¸æ˜¯é‡ç‚¹ï¼Œé‡ç‚¹æ˜¯ä½ èƒ½è®²æ¸…æ¥šä½ çš„é¡¹ç›®ä¸­ï¼Œä½ åšäº†ä»€ä¹ˆå·¥ä½œï¼Œæ€è€ƒå‡ºäº†å“ªäº›æ€è·¯ï¼Œéƒ½ç”¨äº†å“ªäº›æ–¹æ³•ï¼Œå…·ä½“çš„å·¥ä½œåŠæ”¶èŽ·æ˜¯ä»€ä¹ˆã€‚ä»–ä»¬çœ‹åˆ°ä½ çš„é¡¹ç›®ï¼Œé‡ç‚¹è¿˜æ˜¯æƒ³é€šè¿‡ä½ çš„é¡¹ç›®ï¼Œçœ‹æ¸…æ¥šä½ çš„èƒ½åŠ›å’Œå®žåŠ›ã€‚è‡³äºŽè¿™äº›ç«žèµ›èƒ½ä¸èƒ½å†™åˆ°ç®€åŽ†ä¸Šï¼Œå½“ç„¶å®Œå…¨æ˜¯å¯ä»¥çš„ã€‚æœºå™¨å­¦ä¹ ç®—æ³•ç›¸å…³çš„ç†è§£ã€‚å¾ˆå¤šäººè¯´ï¼Œç®—æ³•å·¥ç¨‹å¸ˆæ—¥å¸¸å·¥ä½œæ˜¯è°ƒå‚ï¼Œè°ƒæ¨¡åž‹ã€‚è°ƒå‚å’Œè°ƒç”¨æ¨¡åž‹è¿˜æ˜¯è¦ç†è§£å…¶ä¸­çš„åŽŸç†ï¼Œæ‰èƒ½å‘æ­£ç¡®çš„æ–¹å‘èµ°ã€‚å¯¹ç®—æ³•çš„è€ƒå¯Ÿï¼Œé‡ç‚¹ä¼šè€ƒå¯Ÿä½ åŸºæœ¬åŠŸçš„ç†è§£ï¼Œæ¯”å¦‚svm lrçš„åŸºæœ¬åŽŸç†ï¼Œå„ç§åˆ†ç±»çš„è¯„ä»·å‡†åˆ™ï¼Œl1 l2çš„åŒºåˆ«ç­‰ã€‚å†æ‹“å±•çš„å°±æ˜¯å¯¹ç®—æ³•å¹¿åº¦çš„ç†è§£ï¼Œæœ€åŸºæœ¬çš„å°±æ˜¯å¯¹å¸¸ç”¨çš„ä¸€äº›ç®—æ³•æœ‰æ·±å…¥çš„ç†è§£å°±å¤Ÿäº†ã€‚å…¶ä»–ç›¸å…³çš„ï¼Œç®—æ³•å·¥ç¨‹å¸ˆè¦æŽŒæ¡çš„å¾ˆå¤šï¼Œæ•°å­¦ç›¸å…³çš„çŸ¥è¯†ç”¨åˆ°çš„å¾ˆå¤šï¼Œæ¯”å¦‚çŸ©é˜µï¼Œæ¦‚çŽ‡è®ºç›¸å…³çš„ã€‚æ¯”å¦‚æ»´æ»´ä¹‹å‰é—®çš„æ±‚Aå’ŒBçš„ä¹˜å¾—åˆ°çš„çŸ©é˜µCçš„ç§©ï¼Œé¢è¯•å®˜èŠå®Œå‘Šè¯‰æˆ‘ï¼Œè¿™é“é¢˜çš„é‡ç‚¹å°±æ˜¯è€ƒå¯Ÿä¸€ä¸‹æ•°å­¦ç›¸å…³çš„çŸ¥è¯†ï¼Œå› ä¸ºç®—æ³•å·¥ç¨‹å¸ˆæ—¥å¸¸ä¼šç”¨åˆ°å¾ˆå¤šæ•°å­¦çŸ¥è¯†ã€‚å†æ¯”å¦‚ï¼Œç¾Žå›¢å†…æŽ¨é¢è¯•ä¸€é¢çš„æ—¶å€™ï¼Œè¿˜é—®äº†ä¸€ä¸ªæ¦‚çŽ‡é¢˜ï¼Œæˆ‘å¿˜äº†å†™äº†ï¼Œæ˜¯è¿™æ ·çš„ã€‚ä¸€ä¸ªæ‘å­ç‰¹åˆ«çƒ­çˆ±ç”·å­©ï¼Œæœ€åˆæ‘å­é‡Œç”·å¥³å¹³è¡¡ï¼Œä½†æ˜¯å¤«å¦»ç”Ÿå­©å­æ—¶ï¼Œå¦‚æžœç”Ÿåˆ°å¥³å„¿å°±ä¼šä¸€ç›´ç”Ÿï¼Œç›´åˆ°ç”Ÿåˆ°ç”·å­©ä¸ºæ­¢ï¼Œé—®ï¼Œå¤šå¹´åŽï¼Œç”·å¥³æ¯”ä¾‹æ˜¯å¤šå°‘?è¿˜é—®äº†ä¸¤ä¸ªäººè½®æµæŠ•ç¡¬å¸ï¼Œç›´åˆ°æœ‰äººæŠ•åˆ°æ­£é¢ä¸ºèµ¢ã€‚é—®å…ˆæ‰‹å’ŒåŽæ‰‹èµ¢çš„æ¦‚çŽ‡å¤šå°‘ã€‚ä¸¤ä¸ªé¢˜å¾ˆç±»ä¼¼ã€‚åˆ°æœ€åŽï¼Œæ— è®ºæ˜¯èŠé¡¹ç›®ï¼Œè¿˜æ˜¯æœºå™¨å­¦ä¹ ç›¸å…³ç®—æ³•ï¼Œéƒ½æ˜¯è¦è€ƒå¯Ÿä½ çš„æ•´ä¸ªçš„æ€ç»´èƒ½åŠ›ï¼ŒåŸºæœ¬åŠŸçš„èƒ½åŠ›ã€‚å¦‚æžœæ²¡æœ‰å¾ˆå¥½çš„é¡¹ç›®ï¼Œå°±ä»Žå®žä¹ ã€ç«žèµ›ã€è‡ªå·±çš„å®žéªŒå®¤é¡¹ç›®ã€è‡ªå·±çš„ç ”ç©¶è¯¾é¢˜ç­‰æ–¹é¢æ‰¾æ‰¾çµæ„Ÿã€‚é‡ç‚¹è¿˜æ˜¯è‡ªå·±å¯¹è¿™äº›çŸ¥è¯†çš„æŽŒæ¡ç¨‹åº¦è¿˜æœ‰ç¼–ç¨‹çš„èƒ½åŠ›ã€‚ 3.å¦‚æžœæ²¡æœ‰å¥½çœ‹çš„é¡¹ç›®ï¼Œç®€åŽ†ä¸Šå¦‚ä½•å½¢æˆé¡¹ç›®å‘¢ï¼Ÿæˆ–è€…æ˜¯åœ¨ç›®å‰è¿™ä¸ªç´§æ€¥çš„é˜¶æ®µï¼Œå¯ä»¥ä¸´æ—¶åšä¸€äº›ä»€ä¹ˆäº‹æƒ…è¡¥æ•‘ï¼Ÿç±»ä¼¼é—®é¢˜ï¼šä½ åšçš„é¡¹ç›®æ˜¯å®žéªŒå®¤çš„é¡¹ç›®å—ï¼Ÿå®žéªŒå®¤æœ¬èº«ä¸æ˜¯ç ”ç©¶æœºå™¨å­¦ä¹ æ–¹å‘çš„ï¼Œæ²¡æœ‰é¡¹ç›®æ€Žä¹ˆåŠžå‘¢ï¼Ÿè¿™ä¸ªé—®é¢˜ï¼Œè·Ÿå‰é¢çš„æœ‰äº›ç±»ä¼¼ã€‚å°±ä»Žå®žä¹ ã€ç«žèµ›ã€è‡ªå·±çš„å®žéªŒå®¤é¡¹ç›®ã€ç ”ç©¶è¯¾é¢˜ç­‰æ–¹é¢æ‰¾çµæ„Ÿã€‚æˆ‘ä¸€åŒå­¦ï¼Œä»–ä¹Ÿæ˜¯é€šä¿¡ç›¸å…³æ–¹å‘ï¼Œè½¬nlpã€‚å°±å…ˆæ‰¾äº†ä¸€ä¸ªå°ä¸€ç‚¹çš„å…¬å¸å®žä¹ ï¼Œç„¶åŽæ ¡æ‹›åŽ»äº†tmdä¸­çš„ä¸€å®¶ã€‚é¡¹ç›®ä¸æ˜¯è¶Šå¤šè¶Šå¥½ï¼Œæˆ‘ä¹‹å‰è§æœ‰äººç®€åŽ†ä¸Šå†™äº†7ä¸ªé¡¹ç›®ï¼Œå†™æ»¡äº†ã€‚ç„¶è€Œè¿™ä¹Ÿæ²¡å¤ªå¤šæ„ä¹‰ã€‚ç®€åŽ†ä¸Šé™¤äº†é¡¹ç›®ï¼Œå¯ä»¥å†™ä¸€ä¸‹ä¸ªäººæŠ€èƒ½ä¹‹ç±»çš„ï¼Œçªå‡ºä¸‹è‡ªå·±çš„ä¼˜ç‚¹ã€‚æˆ‘è‡ªå·±ä¹Ÿæ˜¯é¡¹ç›®ä¸å¤Ÿå¤šï¼Œå‡‘çš„ã€‚æˆ–è®¸å…¶ä»–å­¦é•¿å­¦å§æœ‰ç‹¬ç‰¹çš„é¡¹ç›®æŠ€å·§ï¼Œæˆ‘ä¸å¤ªçŸ¥é“ã€‚ 4.æˆ‘æœ€è¿‘å‚åŠ äº†ä¸€ä¸ªXXçš„æ¯”èµ›ï¼Œä½†æœ€åŽçš„åæ¬¡å¯èƒ½ä¸å¤ªå¥½ï¼ˆçŒœæµ‹å‰10%å§ï¼Œæ¯”èµ›æ²¡ç»“æŸï¼Œæœ€è¿‘ç–¯ç‹‚è¢«è¶…ï¼Œä½†æ„Ÿè§‰è‡ªå·±å·²ç»æ²¡æœ‰æ€è·¯äº†ï¼‰ï¼Œè¿™ç§ç»åŽ†å¯ä»¥å¾€ç®€åŽ†ä¸Šå†™å—ï¼Ÿå½“ç„¶å¯ä»¥äº†ã€‚å¦‚å‰æ–‡æ‰€è¿°ï¼Œé¡¹ç›®ç«žèµ›ä¹‹ç±»çš„å†™ä¸Šç®€åŽ†ï¼Œå¦‚æžœæœ‰å¥½çœ‹çš„åæ¬¡ï¼Œè‚¯å®šæ˜¯å¥½çš„ï¼Œæ²¡æœ‰ä¹Ÿæ²¡å…³ç³»ã€‚å‰10%å·²ç»å¾ˆä¸é”™äº†ã€‚æˆ‘ä»¥ä¸ºï¼Œé¢è¯•å®˜æ›´çœ‹é‡çš„è¿˜æ˜¯é€šè¿‡è¿™ä¸ªç«žèµ›ï¼Œä½“çŽ°äº†ä½ å¯¹å“ªäº›çŸ¥è¯†çš„è¿ç”¨ï¼Œè‡ªå·±æä¾›è¿™ä¸ªç«žèµ›çš„è§£å†³æ–¹æ¡ˆå’Œæ€è·¯æ˜¯ä»€ä¹ˆã€‚é‡ç‚¹è¿˜æ˜¯è€ƒå¯Ÿä½ çš„èƒ½åŠ›å’Œæ°´å‡†åœ¨å“ªé‡Œã€‚å¦‚æžœä¸€ä¸ªç«žèµ›ï¼Œä½ æ‹¿åˆ°äº†ç‰¹åˆ«é å‰çš„åæ¬¡ï¼Œä½†é¢è¯•çš„æ—¶å€™ï¼Œä»€ä¹ˆä¹Ÿè®²ä¸å‡ºæ¥ï¼Œéƒ½æ˜¯é éšä¾¿è°ƒå‚å¾—æ¥çš„ï¼Œæ²¡æœ‰ä¸œè¥¿å¯ä»¥è®²ï¼Œè¿˜æ˜¯éžå¸¸å°´å°¬çš„ã€‚ åˆ·é¢˜ä¸Šï¼Œç¬”è®°ä¹Ÿåšäº†åˆ†æžä¹Ÿåšäº†ï¼Œä½†æ²¡å‡ å¤©å‰é¢çš„å°±æ„Ÿè§‰ä¸€ç‚¹å„¿ä¹Ÿæƒ³ä¸èµ·æ¥äº†ç±»ä¼¼ï¼šå¾ˆæ‹…å¿ƒç¼–ç¨‹é¢˜å•Šã€‚è™½ç„¶åœ¨åˆ·é¢˜ï¼Œä½†æ˜¯æ„Ÿè§‰çŽ°åœºè¿˜æ˜¯ä¸ä¸€å®šèƒ½bug-freeå•Šï¼Œåˆ·é¢˜å¥½éš¾å•Šç¼–ç¨‹å¾ˆå¤šè€ƒå¯Ÿçš„è¿˜åœ¨easyï¼Œåmediumçš„æ°´å‡†ã€‚å½“ç„¶ä¹Ÿçœ‹å…¬å¸çœ‹éƒ¨é—¨ï¼Œæœ‰äº›å…¬å¸å°±æ˜¯çœ‹ä¸­ç¼–ç¨‹ï¼Œæ¯”å¦‚å¾®è½¯ï¼Œé‚£ä½ æƒ³åŽ»å°±å¥½å¥½æžå¥½ç¼–ç¨‹å°±å¥½äº†ã€‚å¯¹äºŽå¾ˆå¤šå…¬å¸æ¥è¯´ï¼Œç¼–ç¨‹çŸ¥è¯†è€ƒå¯Ÿçš„ä¸€éƒ¨åˆ†ï¼Œä¸€èˆ¬éƒ½æ˜¯mediumæ°´å‡†ã€‚ä¹Ÿæœ‰éƒ¨åˆ†å…¬å¸æˆ–éƒ¨é—¨è€ƒå¯Ÿhardçš„ã€‚åˆ·é¢˜çš„æ—¶å€™ï¼Œå¤šåšç¬”è®°ï¼Œç»å¸¸å›žé¡¾ï¼Œå¤šæ‰¾åŒå­¦è®¨è®ºã€‚ä¸€é“é¢˜ï¼Œå¤šå¤šçš„æ€è€ƒï¼Œå¤šå¤šçš„åŽ»è®¨è®ºã€‚æ€è·¯è¿™ä¸ªä¸œè¥¿ï¼Œæœ‰æ—¶å€™åŒå­¦çš„ç†è§£å’Œè§è¯†èƒ½å¾ˆå¤§çš„å¸®åŠ©ä½ çš„æˆé•¿ã€‚çš„ç¡®ä¼šå¿˜è®°ï¼Œä½†æ˜¯ä½ å¯ä»¥æŠŠä¸€ç±»é¢˜ç›®æ€»ç»“ä¸‹æ–¹æ³•ï¼Œæˆ–è€…çœ‹åˆ«äººæ€»ç»“çš„æ–¹æ³•ã€‚è¿™ä¸ªè¦å¤šç»ƒä¹ ï¼Œå¤šæ€»ç»“ï¼Œå¤šäº¤æµã€‚æˆ‘ä¹Ÿç¡®å®žæ²¡ç‰¹åˆ«å¥½çš„æ–¹æ³•ã€‚ä½†æ˜¯æˆ‘è§‰å¾—ç»å¸¸å›žé¡¾ä¸Žæ€è€ƒï¼Œç»å¸¸ç»ƒä¹ ï¼Œè‚¯å®šä¼šå¯¹ç¼–ç¨‹æœ‰æ‰€æå‡çš„ã€‚æˆ‘è‡ªå·±çœ‹äº†cpp primerçš„ä¸€åŠå’Œç®—æ³•å¯¼è®ºçš„ä¸€åŠå·¦å³ï¼ŒåŸºæœ¬éƒ½çœ‹äº†ç®—æ˜¯ä¸¤è¾¹å¤šä¸€ç‚¹å§ã€‚å‰‘æŒ‡offerå€’æ˜¯çœ‹äº†å››äº”éã€‚leetcodeæˆ‘åšçš„é¢˜ä¹ŸåŸºæœ¬åœ¨ä¸¤éä»¥ä¸Šå§ã€‚é¢è¯•çš„æ—¶å€™ï¼Œé™¤äº†ç¼–ç¨‹ï¼Œæœ‰æ—¶å€™ä¹Ÿä¼šè€ƒå¯Ÿcppçš„åŸºæœ¬çŸ¥è¯†ï¼ˆå¦‚æžœä½ ç”¨cppçš„è¯ï¼‰ï¼Œæ¯”å¦‚è™šå‡½æ•°çš„æ¦‚å¿µï¼Œstructä¸Žclassçš„åŒºåˆ«ï¼ŒæŒ‡é’ˆï¼Œstaticç­‰ã€‚ ä»Žä½ çš„ç»åŽ†æ¥çœ‹ï¼Œæ— è®ºæ˜¯åŸºç¡€çš„æœºå™¨å­¦ä¹ çŸ¥è¯†è¿˜æ˜¯ç¼–ç¨‹é¢˜ï¼ˆä»Žæˆ‘åˆ·leetcodeå’Œå‰‘æŒ‡offeræ¥çœ‹ï¼Œæ„Ÿè§‰éƒ½æ˜¯mediumå’Œhardçš„é¢˜ç›®ï¼‰çš„æŽŒæ¡æ¥çœ‹ï¼Œæ„Ÿè§‰å¸ˆå…„å¾ˆåŽ†å®³ï¼Œä¹Ÿæ‹¿åˆ°äº†å¾ˆå¤šspçš„offerã€‚ä½†æ˜¯åœ¨é˜¿é‡Œçš„é¢è¯•ä»…ä»…æ˜¯å› ä¸ºæŠ•çš„è¾ƒæ™šçš„åŽŸå› å¯¼è‡´çš„å—ï¼Ÿæ˜¯å¦è¿˜æœ‰å…¶ä»–çš„å› ç´ å’Œæ³¨æ„çš„ç‚¹ã€‚å› ä¸ºæƒ³åŽ»æ­å·žï¼Œæ‰€ä»¥å¯¹é˜¿é‡Œæ ¼å¤–çš„å…³æ³¨ã€‚ä¸ä»…ä»…æ˜¯å› ä¸ºæŠ•çš„æ™šã€‚æˆ‘æƒ³è¯´çš„æ˜¯æŠ•çš„æ™šæ˜¯éžå¸¸é‡è¦çš„ä¸€ä¸ªå½±å“å› ç´ ã€‚æˆ‘æŠ•çš„æ—¶å€™ï¼Œæˆ‘å‘¨å›´çš„åŒå­¦éƒ½å·²ç»é¢è¿‡äºŒé¢æˆ–è€…ä¸‰é¢äº†ï¼Œä¹Ÿå°±æ˜¯è¯´åŸºæœ¬éƒ½å·²ç»ç»“æŸäº†ã€‚æ‰€ä»¥é”™è¿‡å†…æŽ¨é˜¶æ®µï¼ŒåŠ ä¸Šå†…æŽ¨æ¶ˆè€—å¾ˆå¤šåé¢ï¼Œè½¬æ­£ä¹Ÿæ¶ˆè€—äº†å¾ˆå¤šåé¢ï¼Œæœ€åŽç•™ç»™æ¿€çƒˆçš„æ ¡æ‹›çš„åé¢ä¸å¤šã€‚æœ€æ ¹æœ¬çš„è¿˜æ˜¯è‡ªå·±çš„ç®€åŽ†å’Œè‡ªå·±çš„èƒ½åŠ›ä¸å¤Ÿä¼˜ç§€æˆ–è€…è¯´ä¸è¶³ã€‚å¦‚æžœèƒ½åŠ›éžå¸¸å¼ºï¼Œä»€ä¹ˆæ—¶å€™éƒ½æœ‰æœºä¼šå˜›ã€‚ä½†æ˜¯å¯¹äºŽå¾ˆå¤šäººï¼ŒåŒ…æ‹¬æˆ‘è®¤è¯†ä¸€äº›éžå¸¸ç‰›çš„çš„å¤§ç¥žæ¥è¯´ï¼Œè¿˜æ˜¯è¦æŠŠæ¡å¥½æœºä¼šï¼Œèƒ½äº‹åŠåŠŸå€ã€‚æˆ‘è¿™é‡Œçš„å»ºè®®æ˜¯æŠŠæ¡æ—¶é—´å’Œæœºä¼šï¼Œæå‰å¥½å¥½å‡†å¤‡ï¼Œä¸è¦çŠ¹è±«ã€‚æˆ‘æ ¡æ‹›æŠ•çš„èš‚èšé‡‘æœï¼Œèš‚èšé‡‘æœç›¸å¯¹é˜¿é‡Œå…¶ä»–éƒ¨é—¨æ¥è¯´æ˜¯éžå¸¸éš¾è¿›çš„éƒ¨é—¨ï¼Œä»Šå¹´èš‚èšé‡‘æœçš„å®žä¹ è²Œä¼¼å®¹æ˜“ä¸€äº›ï¼Œæˆ‘æ²¡æŠ•èš‚èšå®žä¹ ï¼Œæ ¡æ‹›ä¹Ÿä¸å®¹æ˜“å§ã€‚æƒ³åŽ»æ­å·žçš„è¯ï¼Œå°†æ¥å®žä¹ å¯ä»¥ç›´æŽ¥ç”³è¯·é˜¿é‡Œæ­å·žçš„å®žä¹ ï¼Œè½¬æ­£ç›´æŽ¥è½¬æœ¬éƒ¨é—¨å°±å¥½äº†ã€‚è¿™æ ·çš„ä¸€ä¸ªåå¤„å°±æ˜¯å°†æ¥æ ¡æ‹›çš„æ—¶å€™ï¼Œä½ å¯èƒ½åœ¨æ­å·žå®žä¹ ï¼Œå¦‚æžœæ¥åŒ—äº¬é¢è¯•å…¶ä»–å…¬å¸ï¼Œå¯èƒ½ä¼šä¸ä¼šå¤ªæ–¹ä¾¿ã€‚ä½†æ˜¯ä½ æœ‰äº†é‚£è¾¹çš„offerï¼Œéº»çƒ¦ç‚¹ä¹Ÿå°±é‚£ä¹ˆå›žäº‹ã€‚è™½ç„¶æœ‰çš„å…¬å¸å†…éƒ¨ä¹Ÿå¯ä»¥è½¬åˆ°æ­å·žï¼Œæˆ‘è§‰å¾—è¿˜æ˜¯ç›´æŽ¥è½¬ä¼šå¥½ä¸€ç‚¹ã€‚é˜¿é‡Œçš„é¢è¯•ï¼Œæ ¹æ®å…¶ä»–åŒå­¦çš„åé¦ˆï¼Œé™¤äº†ç®€åŽ†ã€é¡¹ç›®ã€ç¼–ç¨‹å¤–ï¼Œä¹Ÿä¼šé—®ä¸€äº›æ•°å­¦æˆ–è„‘ç­‹æ€¥è½¬å¼¯çš„é—®é¢˜ã€‚å…³äºŽæ•°å­¦æ¦‚çŽ‡è®ºçš„ç®€å•çš„ä¸€é“é¢˜ï¼Œä¸¤ä¸ªéšæœºå˜é‡X Yéƒ½ç¬¦åˆå‡åŒ€åˆ†å¸ƒï¼Œé‚£X+Yç¬¦åˆä»€ä¹ˆåˆ†å¸ƒå‘¢ï¼Ÿçœ‹ä½ æƒ³åŽ»å“ªä¸ªéƒ¨é—¨ï¼Œå¤šè·Ÿé‚£é‡Œçš„å­¦é•¿å­¦å§äº¤æµï¼Œå¯ä»¥é’ˆå¯¹æ€§çš„å‡†å¤‡ä¸‹ã€‚ å…³äºŽé¡¹ç›®çš„é—®é¢˜ã€‚ä»Žä½ åˆ†äº«çš„å†…å®¹æ¥çœ‹ï¼Œæ„Ÿè§‰é¡¹ç›®å çš„ä¸æ˜¯å¾ˆå¤šï¼Œè¿™ä¸€å—æ˜¯å¦å çš„æ¯”ä¾‹æ¯”è¾ƒå°ã€‚å› ä¸ºæˆ‘åœ¨å®žéªŒå®¤æ²¡åšä»€ä¹ˆé¡¹ç›®ï¼Œåªæ˜¯å­¦äº†ä¸€äº›ç›¸å…³çš„å¤§æ•°æ®å¤„ç†å·¥å…·ï¼Œæ‰€ä»¥é¡¹ç›®è¿™ä¸€å—å¾ˆç¼ºï¼Œæœ€è¿‘æ‰“äº†ä¸€äº›æ¯”èµ›ï¼Œè¿™ä¸ªç”¨æ¥å……å®žé¡¹ç›®æ˜¯å¦å¤Ÿã€‚å…³äºŽé¡¹ç›®ï¼ŒåŸºæœ¬æ¯åœºé¢è¯•éƒ½ä¼šé—®å§ã€‚æœ‰çš„æˆ‘å¯èƒ½æ²¡å†™è¦é—®é¡¹ç›®ã€‚70%çš„é¢è¯•éƒ½ä¼šå…ˆé—®é—®é¡¹ç›®ï¼Œå¾ˆå¤šéƒ½ä¼šä¸€ä¸ªæˆ–è€…ä¸¤ä¸ªã€‚ä¹Ÿæœ‰çš„ä¼šç®€å•çš„é—®ï¼Œæœ‰çš„æ·±å…¥çš„é—®ã€‚çœ‹é¢è¯•å®˜çš„é£Žæ ¼ã€‚ç«žèµ›å¯ä»¥å……å®žé¡¹ç›®ã€‚åªè¦ä½ çš„ç«žèµ›è·Ÿä½ è¦æ‰¾çš„å²—ä½åŒ¹é…çš„ä¸Šã€‚ ä½ è§‰å¾—å…¬å¸å¯¹ æ•°æ®æŒ–æŽ˜æ¯”èµ› çœ‹é‡çš„ç¨‹åº¦æ€Žæ ·ï¼Ÿé™¤éžå¾ˆå¥½å¾ˆçŸ¥åçš„æ¯”èµ›ä½ æ‹¿åˆ°ç‰¹åˆ«å¥½çš„åè¯ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œæ›´æ³¨é‡è¦è€ƒå¯Ÿçš„æ˜¯ä½ çš„çŸ¥è¯†çš„ç†è§£ï¼Œå…¨å±€æŠŠæŽ§ï¼Œæå‡ºçš„è§£å†³æ–¹æ¡ˆç­‰ç›¸å…³çš„èƒ½åŠ›ã€‚å› ä¸ºæˆ‘è‡ªå·±çš„ç«žèµ›æ¯”è¾ƒå°ï¼Œæ‰€ä»¥éƒ½æ˜¯è°ˆè®ºæŠ€æœ¯ç›¸å…³çš„ã€‚å…¶ä»–å¤§ç¥žçš„nbç«žèµ›æˆ‘ä¹Ÿä¸çŸ¥é“æ€Žä¹ˆæ ·çš„ã€‚ è¡¥å……å°ç±³è¿˜é—®äº†å¯¹äºŽç±»åˆ«ä¸å¹³è¡¡çš„æ ·æœ¬æ€Žä¹ˆå¤„ç†ã€‚æœç‹—ï¼Œå¯¹äºŽåˆ†ç±»ä½¿ç”¨auc få€¼ç­‰ï¼Œå¯¹äºŽé¢„æµ‹é—®é¢˜çš„æ ‡å‡†æ€Žä¹ˆè¯„åˆ¤ï¼Ÿæ–°æµªï¼Œé—®äº†bias-varianceåˆ†è§£é—®é¢˜ã€‚ç¾Žå›¢ï¼Œæœç‹—ï¼Œxgboostè°ƒå“ªäº›å‚æ•°ï¼Œå“ªäº›å‚æ•°æœ‰æ•ˆæžœï¼Œè®­ç»ƒæ—¶é—´ï¼Œæ˜¯æƒ³é—®ä¸‹å…·ä½“è¿‡ç¨‹ã€‚ç™¾åº¦ï¼Œsvm lræŸå¤±å‡½æ•°å¯¹æ¯”ï¼Œå¯¹å™ªå£°æ•æ„Ÿæ€§ã€‚è¿˜æœ‰é—®ä¸ºä½•random forestèƒ½å¤Ÿé™ä½Žè¯¯å·®çš„ã€‚æ–°æµªè¿˜é—®äº†ï¼Œå…ˆéªŒç›¸å…³çš„ï¼Œå“ªç§å…ˆéªŒåˆ†åˆ«å¯¹åº”l1 l2ï¼Œè¿˜æœ‰é«˜æ–¯çš„å…ˆéªŒæ˜¯ä»€ä¹ˆã€‚é˜¿é‡Œï¼Œç†µæ˜¯ä»€ä¹ˆã€‚ å‚è€ƒèµ„æ–™ http://yucc.me/p/102faecd/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AIä¸€ä¸ä¸€æ¯«</tag>
        <tag>å®žä¹ </tag>
        <tag>æ ¡æ‹›</tag>
        <tag>é¢è¯•ç»éªŒ</tag>
        <tag>é¢ç»</tag>
      </tags>
  </entry>
</search>
