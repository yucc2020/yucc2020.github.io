<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[VGGNet]]></title>
    <url>%2Fp%2Fb2e32499%2F</url>
    <content type="text"><![CDATA[VGGNet[1]是University of Oxford（牛津大学）的Visual Geometry GroupKaren小组的 Simonyan和Andrew Zisserman提出的一种经典网络结构，以机构Visual Geometry GroupKaren的缩写VGG命名。VGGNet赢得了ILSVRC 2014中localisation（定位）的第一名和classification（分类）的第二名(分类第一名是GoogLeNet）。该网络结构的主要工作时证明了增加网络结构深度能够在一定程度上影响网络的最终性能。VGG有两种网络结构，分别是VGG16和VGG19。两者没有本质区别，只是网络深度不一样。 1. 卷积网络配置1.1 架构/结构卷积网络的输入是 $224\times 224$RGB图像。 仅有的预处理是减去训练集的RGB均值。 全部使用3*3的卷积核，该卷积核恰好能看到上下左右及中心。使用了1*1的卷积滤波器，可以认为是输入通道的线性转换，后面紧跟着一个分线性转换。3*3的padding是1像素，这样能保证图像大小不变。使用max-pooling，窗口为2*2，步长为2。 三个全连接层4096,4096,1000。后面是softmax层。 所有隐层使用relu非线性激活。 1.2 配置卷积网络的配置如图2。图3中标识了不同配置的参数多少。尽管非常深，我们的权重个数并没有比浅的网络参数多多少（比如Sermanet 2014的144M个权重）。 1.3 讨论AlexNet第一层使用的11*11的卷积核，ZFNet使用的是7*7。我们全部使用3*3的卷积核，步长为1。很容易看到两个3*3的卷积核堆叠（他们之间不使用pooling）的感受野（receptive field）等价于5*5的。三层堆叠可以有7*7的感受野。所以，当我们使用堆叠的3*3的卷积核，而不是7*7的卷积核，我们获得了什么收益呢？ 首先，决策函数更有分辨性。其次，我们减少了参数的个数。假设输入和输出的3*3卷积堆有C个channel，则该堆具有的参数的个数是$3(3^2 C^2)=27C^2$，而相对应的7*7的参数个数为$7^7C^2=49C^2$。比前面的多了81%还多。可以看做是对7*7的滤波器上做了一个强制的正则化，让他们强制分解为3*3的滤波器，并且中间插入了非线性。 VGG C在最后的三个阶段都用到了1x1卷积核，选用1x1卷积核的最直接原因是在维度上继承全连接，然而作者首先认为1x1卷积可以增加决策函数（decision function，这里的决策函数我认为就是softmax）的非线性能力，非线性是由激活函数ReLU决定的，本身1x1卷积则是线性映射，即将输入的feature map映射到同样维度的feature map。作者还提到“Network in Network” architecture of Lin et al. (2014).这篇文章就大量使用了1x1卷积核。 此外，查了知乎简单总结下1x1卷积的特点（就不说加入非线性这个conv自带的特点了）： 专注于跨通道的特征组合：conv1x1根本不考虑单通道上像素的局部信息（不考虑局部信息），专注于那一个卷积核内部通道的信息整合。conv3x3既考虑跨通道，也考虑局部信息整合； 对feature map的channel级别降维或升维：例如224x224x100的图像（或feature map）经过20个conv1x1的卷积核，得到224x224x20的feature map。尤其当卷积核（即filter）数量达到上百个时，3x3或5x5卷积的计算会非常耗时，所以1x1卷积在3x3或5x5卷积计算前先降低feature map的维度。 1.4 内存与参数个数计算下图5中，可以看出。像其他卷积神经网络一样，内存（memory）同样也是计算时间（compute time）在早期的卷积网络中，而多数的参数则在全连接层（FC）。在VGGNet中，第一层FC（全连接）中有100M个参数，而总参数是140M个。 2. 分类框架2.1 训练训练的详细参数可以参考论文。 Training image size。训练图片大小。是这样，类似于AlexNet，先把图片缩放到一定大小，比如最小边长为S。S是大于224的。然后再从这个图片中裁剪一些224*224的图片作为输入。 这里使用了两种方法设置S。一种是S=256，也是AlexNet使用的。及使用S=384。 另一种是S从Smin和Smax中每次随机挑选。这里Smin=256,Smax=512。 2.2 测试 &amp;&amp; 实施细节这里是细节。参考论文就好。 3. 分类实验数据集是ILSVRC 2012，其中training 1.3m，validation 50k，testing 100k。 3.1 单尺度评估（Single Scale Evaluation）如图6，结果如下。证明了。 local response normalization（LRN）无效，开从A-LRN可以看出。所以B-E不再使用。 1*1的卷积是有效果的，可以从C比B好看出。 D比C好，说明通过卷积获取空间内容还是有效的。 深度越深越好。 3.2 多尺度评估（Multi-Scale Evaluation）对比图7与图6，说明多尺度评估明显有效果。 3.3 多裁剪评估多种裁剪方法进行评估，然后评估预测结果。这里只使用了D和E两个网络。结果如图8。 3.4 卷积网络混淆至此，我们尝试用了多种单一网络的模型。在这部分，我们尝试将多种模型的结果进行平均。AlexNet，ZFNet都证明了多种模型的预测是有效的，能够获得很好的结果。 结果如图9所示。 By the time of ILSVRC submission we had only trained the single-scale networks, as well as a multi-scale model D (by fine-tuning only the fully-connected layers rather than all layers). The resulting ensemble of 7 networks has 7.3% ILSVRC test error. After the submission, we considered an ensemble of only two best-performing multi-scale models (configurations D and E), which reduced the test error to 7.0% using dense evaluation and 6.8% using combined dense and multi-crop evaluation. For reference, our best-performing single model achieves 7.1% error. 3.5 与最先进的网络进行对比对比结果如图10所示。 3.6 VGGNet的泛化能力VGGNet对于其他数据集一样有非常好的泛化能力。多尺度卷积特征和线性SVM的组合或许优于更复杂的的识别管道加不太深的特征组合。我们对PASCAL VOC和Caltech图像分类的基准如下： 4. 结论这篇工作中，使用了深达19层的卷积神经网络进行大量图片分类。证明了网络的深度对于分类的准确率是有提升的。 参考资料 Simonyan K, Zisserman A. Very deep convolutional networks for large-scale image recognition[J]. arXiv preprint arXiv:1409.1556, 2014. https://mp.weixin.qq.com/s?__biz=MzUxNjcxMjQxNg==&amp;mid=2247485161&amp;idx=1&amp;sn=0d836d81ba051e37675bbf6f25504e9d&amp;chksm=f9a27466ced5fd701d93c4fd5ac9f286deab61bc0bc0448acc2876d7d251becf2eceb306fba5&amp;scene=0#rd https://blog.heuritech.com/2016/02/29/a-brief-report-of-the-heuritech-deep-learning-meetup-5/ https://blog.csdn.net/qq_40027052/article/details/79015827 http://www.robots.ox.ac.uk/~vgg/research/very_deep/ http://cs231n.github.io/convolutional-networks/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>cnn</tag>
        <tag>convolutional neural network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZFNet]]></title>
    <url>%2Fp%2F3f18ad9b%2F</url>
    <content type="text"><![CDATA[Matthew Zeiler和Rob Fergus发明的ZFNet[1]赢得了ILSVRC 2013的冠军，top-5错误率是11.2%。ZFNet是Zeiler和Fergus的缩写。 ZFNet可以认为是AlexNet进行了微调。 使用relu激活函数，交叉熵作为代价函数。 使用了较小的filter以保留更多原始像素信息。 整体架构如图1所示，结构如公式1所示。 $$\begin{equation}ZFNet = (conv + relu + maxpooling)\times 2 + （conv + relu)\times 3 + fc \times 2 + softmax\end{equation} \tag{1}$$ ZFNet的具体参数下图图2所示。 参考资料 Zeiler M D, Fergus R. Visualizing and understanding convolutional networks[C]//European conference on computer vision. Springer, Cham, 2014: 818-833. https://ziyubiti.github.io/2016/11/27/cnnnet/ https://blog.csdn.net/JNingWei/article/details/79100267 http://cs231n.github.io/convolutional-networks/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>cnn</tag>
        <tag>convolutional neural network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AlexNet]]></title>
    <url>%2Fp%2Fca9994d1%2F</url>
    <content type="text"><![CDATA[AlexNet[1]是经典CNN网络之一，由Alex Krizhevsky, Ilya Sutskever and Geoff Hinton三位开发，以一作Alex的名字命名。该网络结构赢得了2012年的ImageNet ILSVRC-2012竞赛的冠军，且大幅度的领先第二名。top-5的错误率为15.3%大幅度领先第二名的26.2%。 AlexNet的出现，证明了虽然计算昂贵，但是模型的深度是获得好的效果和性能的必要保证。同时，也让深度学习真正开始流行了起来。拐点之所以出现在2012年，在于一方面数据可用量大大增加，机器的计算能力伴随着gpu也大幅度提高。当然，AlexNet本身也很优秀，我们这里对该网络进行一些解读。 1. 网络结构1.1 使用了ReLU单元 论文使用了ReLU单元替代了传统的tanh，和sigmoid，|tanh|等激活函数。相对而言，ReLU更容易求导和运算。能加快迭代的进程。如图2所示，对于CIFAR-10，同样到达25%的训练误差，ReLU可以比tanh激活单元速度快6倍。 1.2 在多个gpu上训练 使用了两块GTX 580 gpu，3GB内存。 1.3 Local Response Normalization 这种方法据说没什么用，就不讲了。 1.4 Overlapping Pooling 此前的CNN普遍使用平均池化，AlexNet全部使用最大池化，避免了平均池化的模糊化效果，并且AlexNet提出步长比池化层的尺寸小，池化层的输出之间就会有重叠和覆盖，提升了特征的丰富性。 2. 减少过拟合整个网络结构有60m个参数（可以对比LeNet-5有大约60k个参数）。论文中使用了两种方式进行防止过拟合。 2.1 数据增强（Data Augmentation） 增强方法一。论文中，首先将所有图像缩放到最短的一边为256，然后截取长的一边也为256。于是得到256*256*3的图像，3代表RGB颜色。做数据增强的时候，从这个256*256的图像上随机抽取一些224*224的部分图片及其水平翻转。截取的时候，截取四个角落的片段和一个中心的片段，然后加上水平的翻转，正好10个patches。 关于水平反转的数据增强方法，可以参考我的另一篇博客[5]。同时，这里说的224*224因该是有误的，正确的是应该是227*227，最早由Andrei Karpathy在他的CS231n课程上提出[2]。这种增强方法还是很常用的，目前。 增强方法二。是在RGB颜色上增强，先做了PCA降维，然后进行做均值为0，方差为0.1的高斯扰动。 2.2 Dropout 目前的网络里，dropout非常常用，也是受本篇论文的影响。 3. 整体网络结构解析 整体的网络结构如图1所示。刚开始看的时候，我也没看太明白，后来看了其他博客才看懂。看的时候是这么看的。首先要明白，这是一个8层网络，5个卷积层，3个全连接层。然后从左向右看，Max Pooling这里，前面的那些虚线都表示的是一个卷积层，然后max pooling呢，表示卷积得到的图像，要经过max pooling层，这里只是写上了文字pooling，并没有画出来。然后经过max pooling之后的图像再经过卷积层，到达下一层。所以整体的网络结构可以参考下图图3。 下面的图4展示了各个层、参数个数、计算单元等详细情况。 4. 论文亮点4.1 使用了Relu替代tanh，增加非线性，在相同准确率情况下加速了6倍。4.2 使用dropout防止过拟合。4.3 使用了带重叠的池化层（pooling)层。它使得top1和top5的错误率分别减少了0.4%和0.3%。 AlexNet的出现，让人们认识到deep learning巨大的威力，也证明了要想获得更好的效果，增加网络的深度是必要的。 参考资料 Krizhevsky A, Sutskever I, Hinton G E. Imagenet classification with deep convolutional neural networks[C]//Advances in neural information processing systems. 2012: 1097-1105. https://medium.com/@smallfishbigsea/a-walk-through-of-alexnet-6cbd137a5637 https://blog.csdn.net/zyqdragon/article/details/72353420 https://blog.csdn.net/marsjhao/article/details/72953256 http://yucc.me/p/4a960c05/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>cnn</tag>
        <tag>convolutional neural network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典CNN模型LeNet]]></title>
    <url>%2Fp%2F623fcf69%2F</url>
    <content type="text"><![CDATA[CNN经典网络LeNet-5，我们通常说的LeNet就是指LeNet-5。网络结构如下图，由LeCun在1998年的大作[2]中提出，本文尝试对此网络进行分析。 上述是LeNet-5的网络结构，整体上是input layer-&gt;convulational layer-&gt;pooling layer-&gt;activation function-&gt;convulational layer-&gt;pooling layer-&gt;activation function-&gt;convulational layer-&gt;fully connect layer-&gt;fully connect layer-&gt;output layer. 1. input层输入为 32*32 pixel的图像。 2. C1层2.1 C1层为卷积层，kernel size = 5 * 5，步长为1，无填充，生成6个feature map，换做现在的话来讲，叫做depth为6。2.2 无填充，所以生成的feature map的长和宽都减去4（5-1得到），最终得到的feature map为28*28。2.3 参数个数为（5*5+1)*6 = 156。其中5*5对应kernel size，1对应为bias，6是feature map的个数。2.4 连接数 156*28*28 = 122304。156位参数个数，其中feature map上每个像素点对应5*5+1=26个连接，但是如果将深度为6的6个像素点作为一个的话，这一个对应的连接数为(5*5+1)*6 = 156个。 3. S2层3.1 S2层为降采样层，kernel size为2*2，长和宽的步长都为2,无填充。3.2 S2层其实相当于降采样层+激活层。先是降采样，然后激活函数sigmoid非线性输出。3.3 新生成的feature map大小为(28/2)*(28/2) = 14*14。3.4 LeNet-5中，先对2*2的视野进行平均，然后进入激活函数。就是sigmoid(a*sigmoid(x)+b)，的方法。所以参数的个数为 6*(1+1) = 12。3.5 连接个数为12*14*14=5880。同2.4的算法，每个像素点（此处使用6个feature map的对应的6个像素点作为一个像素点）对应12个连接，所以feature map的连接数那么算了。当然，也可以使用6*14*14*(2*2+1) = 5880，可能更容易理解一些。 4. C3层4.1 C3层为卷积层，kernel size为5*5，步长为1，生成16个feature map。C3的feature map并不是由全部S1的feature map生成的，对应的关系如下图图2。4.2 并没有全部连接的原因：a. 控制参数个数 b.打破对称性，期望学到互补的特征。4.3 同前方的计算方法，新得到的feature map大小为14-(5-1) = 10，即10*10。4.4 参数个数 (5*5*3+1)*6+(5*5*4+1)*9+(5*5*6+1)=1516个。括号内部为kernel_size * kernel_size * feature_map_num + bias_num，表示从feature_map_size卷积得到的feature map所需要的参数个数；括号外为相应得到feature map的数目。4.5 连接的个数是1516*10*10=151,600。10*10为新feature map的大小，feature map上的每个点（此处的点对应的16个像素点）都对应着1516个连接。 5. S4层5.1 S4层为降采样层，此层配置如同S2层。kernel size为2*2,长和宽的步长均为2，无填充（本网络一直都是无填充）。5.2 新生成的feature map为5*5，depth为16。5.3 参数个数为16*2 = 32。5.4 连接个数为5*5*16*(2*2+1) = 2000。其中，2*2为feature map的数目，1位bias。 6. C5层6.1 C5为卷积层，kernel size为5*5，步长为1，无填充。全连接生成120个feature map。6.2 C5层可以理解为两层，第一层是卷积层，经过5*5的卷积，从depth16,5*5的feature map变为depth为16，大小为1*1的feature map，其实就是16个点。第二层就是全连接层，16个点与120个点全连接。6.3 参数个数 120*(5*5+1)=48120。惯例，1位偏置bias。6.4 连接个数等于48120*1 = 48120。 7. F6层7.1 F6层为全连接层，就很简单了，具体的内容如果不懂可以学习多层感知机（MLP）7.2 参数个数=连接个数=(120+1)*84 = 10164。 8. output层8.1 从F6层到output层，使用的公式(1)。8.2 连接数84*10 = 840。8.3 目前主流的都会使用softmax了，不使用这种方式了。 $$\begin{equation}{y_j} = \sum_{j} {x_j - w_{ij}}\end{equation} \tag{1}$$ 9. 实现效果最终网络的实现效果展示如下： 10. 简单评价10.1 跟当前常用的cnn结构已经基本一致了。目前的cnn一般是[CONV - RELU - POOL]，这里的[CONV - POOL - RELU]，不过基本没什么影响。文章的激活函数是sigmoid，目前图像一般用tanh，relu，leakly relu较多，实践证明，一般比sigmoid好。后面一般接全连接层FC，这里也是一致的。10.2 目前，多分类最后一层一般用softmax，文中的与此不太相同。 参考资料 http://yann.lecun.com/exdb/lenet/ LeCun Y, Bottou L, Bengio Y, et al. Gradient-based learning applied to document recognition[J]. Proceedings of the IEEE, 1998, 86(11): 2278-2324. LeCun Y, Boser B, Denker J S, et al. Backpropagation applied to handwritten zip code recognition[J]. Neural computation, 1989, 1(4): 541-551. https://blog.csdn.net/silent56_th/article/details/53456522]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>cnn</tag>
        <tag>convolutional neural network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音频(audio)信号中做数据增强(Data Augmentation)及部分代码实现]]></title>
    <url>%2Fp%2Fa6e89bc4%2F</url>
    <content type="text"><![CDATA[音频信号处理中，常用到数据增强的方法。一般而言，音频中的数据增强也是对音频的时频谱（spectrogram）进行增强的，时频谱本身也是一种图像，这使得音频中的数据增强与图像的数据增强有诸多相似之处。这里对一些资源进行了简单的总结。 1. 一些数据增强的代码这里主要参考[1]。 1.1 相同类别增强（Same Class Augmentation）相同类别的增强是简单将两个音频片段s1和s2，按照一定比例相加： 1s_aug = alpha * s1 + (1-alpha) * s2 其中alph可以从平均分布[0, 1)中随机抽取。 python代码实现： 12345678910def same_class_augmentation(wave, class_dir): """ Perform same class augmentation of the wave by loading a random segment from the class_dir and additively combine the wave with that segment. """ sig_paths = glob.glob(os.path.join(class_dir, "*.wav")) aug_sig_path = np.random.choice(sig_paths, 1, replace=False)[0] (fs, aug_sig) = utils.read_wave_file(aug_sig_path) alpha = np.random.rand() wave = (1.0-alpha)*wave + alpha*aug_sig return wave 1.2 噪声增强（Noise Augmentation）噪声增强只是在增强信号之上增加一个随机噪声段，阻尼系数为0.4。 1s_aug += (noise_seg * 0.4) for noise_seg in noise_segs 其中noise_segs是来自噪声段目录的三个随机选择的噪声段。 python代码实现： 123456789101112def noise_augmentation(wave, noise_dir): """ Perform noise augmentation of the wave by loading three noise segments from the noise_dir and add these on top of the wave with a dampening factor of 0.4 """ noise_paths = glob.glob(os.path.join(noise_dir, "*.wav")) aug_noise_paths = np.random.choice(noise_paths, 3, replace=False) dampening_factor = 0.4 for aug_noise_path in aug_noise_paths: (fs, aug_noise) = utils.read_wave_file(aug_noise_path) wave = wave + aug_noise*dampening_factor return wave 1.3 时移增强（Time Shift Augmentation）时移增强是通过沿时间轴滚动信号来随机移位信号。包裹着移动。 1234567def time_shift_spectrogram(spectrogram): """ Shift a spectrogram along the time axis in the spectral-domain at random """ nb_cols = spectrogram.shape[1] nb_shifts = np.random.randint(0, nb_cols) return np.roll(spectrogram, nb_shifts, axis=1) 1.4 音高变换增强（Pitch Shift Augmentation）音高变化增量是围绕频率轴的±5％范围内的随机滚动。环绕式转换以保留所有信息。 123456789def pitch_shift_spectrogram(spectrogram): """ Shift a spectrogram along the frequency axis in the spectral-domain at random """ nb_cols = spectrogram.shape[0] max_shifts = nb_cols//20 # around 5% shift nb_shifts = np.random.randint(-max_shifts, max_shifts) return np.roll(spectrogram, nb_shifts, axis=0) 2. 一些数据增强的其他资料Andrew Ng关于image中的data augmentation的讲解。Ng讲到主要是两方面。一个是图像的形状的变形，比如翻转、旋转、缩放等。另一个是RGB颜色的变化，比如加入一定的R或减少一定的G[2]。 现在一些开源框里也可以做数据增强了。这里分别是tensorflow[3]、keras[4]的实践。这里代码信实现非常简单，因为只用了他们的接口，传入参数，不需要自己写。其中[4]调用的接口是keras的[5]。而且这里的数据增强是针对图像的，只要是图像都可以使用。 前面的这些适用于图像，当然也是用音频的声谱图。这里有两个专门做音频数据增强的实践，一个是做了时移变换（Time shifting）、速度调整（Speed tuning）、混合背景音（Mix background noise）和音量调节（volume tuning）[6]。另一个也是做了增加白噪声（adding white noise）、移动音频（shifting the sound）、拉伸音频信号（stretching the sound）[7]。这两个有说明，有代码实践，而且都是专门针对音频处理的，值得一看。 有一个专门做音频数据增强的开源库，叫做muda[8]，全称为A library for Musical Data Augmentation。做到音频增强，可以尝试使用此库。Salamon 2016年的一篇关于音频事件分类的论文中使用的数据增强就是使用此库做的[9]。 参考资料 https://github.com/johnmartinsson/bird-species-classification/wiki/Data-Augmentation https://www.coursera.org/lecture/convolutional-neural-networks/data-augmentation-AYzbX?authMode=signup https://www.kaggle.com/dansbecker/data-augmentation https://absentm.github.io/2016/06/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84Data-Augmentation%E6%96%B9%E6%B3%95%E5%92%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/ https://keras.io/preprocessing/image/ https://www.kaggle.com/haqishen/augmentation-methods-for-audio https://www.kaggle.com/CVxTz/audio-data-augmentation https://github.com/bmcfee/muda https://arxiv.org/abs/1608.04363]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>data augmentation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据增强(Data Augmentation)]]></title>
    <url>%2Fp%2F4a960c05%2F</url>
    <content type="text"><![CDATA[我们常常会遇到数据不足的情况。比如，你遇到的一个任务，目前只有小几百的数据，然而，你知道目前现在流行的最先进的神经网络都是成千上万的图片数据。你知道有人提及大的数据集是效果好的保证。对自己数据集小感到失望，你怀疑在我的小数据集上能使我的“最先进的”神经网络能表现好吗？ 答案是：是！在我们开始是这件事发生之前，我们需要先反思几个问题。 1. 为什么需要大量的数据？ 当你训练一个机器学习mode时候，你真正做的就是调参以便它能将输入（比如图片）映射到输出（比如标签）。我们优化目标是追求我们模型损失较低的最佳点，当参数以正确的方式调整时就会发生这种情况。 最领先的神经网络有着数百万的参数！ 显然，如果你有很多参数，你需要给你的模型足够比例的样本。同样，你需要的参数的个数与你任务的复杂度成比例。 2. 如果没有很多数据，我怎么去获得更多数据？你不必寻找新奇的图片增加到你的数据集中。为什么？因为，神经网络在开始的时候并不是那么聪明。比如，一个欠训练的神经网络会认为这三个如下的网球是不同、独特的图片。 所以，为了获得更多的数据，我们只要对现有的数据集进行微小的改变。比如旋转（flips）、移位（translations）、旋转（rotations）等微小的改变。我们的网络会认为这是不同的图片。 一个卷积神经网络，如果能够对物体即使它放在不同的地方也能稳健的分类，就被称为具有不变性的属性。更具体的，CNN可以对移位（translation）、视角（viewpoint）、大小（size）、照明（illumination）（或者以上的组合）具有不变性。 这本质上是数据增强的前提。在现实场景中，我们可能会有一批在有限场景中拍摄的数据集。但是我们的目标应用可能存在于不同的条件，比如在不同的方向、位置、缩放比例、亮度等。我们通过额外合成的数据来训练神经网络来解释这些情况。 如果我有很多的数据，数据增强会有用吗？ 是的。它能增加你数据集中相关数据的数据量。这与神经网络的学习方式有关。让我们用一个例子来阐述它。 假设我们有一个数据集，含两种品牌的车，如上所示。我们假设A品牌的车都如上面左侧一样对其（所有的车头朝向左侧）。同样B如右侧（所有的都朝向右侧）。现在，你将你的数据集送入“最先进的”神经网络，你希望等训练结束后获得令人印象深刻的结果。 当训练结束后，你送入上面的品牌A车的图片。 但是你的神经网络却认为它是一辆B品牌的车！你很困惑。难道不是刚刚通过这个“最先进的”神经网络获得了95%的准确率吗？我不是夸张，这个事情以往发生过[2]。 为什么发生了这件事？ 它的发生正是很多机器学习算法工作的院里。它会去寻找最能区分两个类别的、最明显的特征。这里，A品牌与B品牌最明显的区别是A都是朝向左侧，B是朝向右侧。 你的神经网络会与你喂给它的数据质量一样好或坏。 我们如何去阻止这件事发生呢？ 我们不得不减少数据集中不相关的特征。对于上面的轿车模型分类器，一个简单的方案是增加分别朝向原始方向反向的两种车的图片。更好的方法是，你可以从沿着水平方向翻转图片以便它们都朝着反方向！现在，在新数据集上训练神经网络，你将会获得你想要获得的性能。 通过执行数据增强，你可以阻止神经网络学习不相关的特征，从根本上提升整体性能。 3. 入门在我们开始各种增强技术之前，有一问题我们必须考虑清楚 在我们的机器学习管道（pipeline）的何处进行增强数据呢？ 答案似乎很显然，在我们喂入模型之前，进行数据增强，对吧？是的，但是你有两个选项。一种是事先执行所有转换，实质上会增强你的数据集的大小。另一种选项是在送入机器学习之前，在小批量（mini-batch）上执行这些转换。 第一个选项叫做线下增强（offline augmentation）。这种方法适用于较小的数据集（smaller dataset）。你最终会增加一定的倍数的数据集，这个倍数等于你转换的个数。比如我要翻转我的所有图片，我的数据集相当于乘以2。 第二种方法叫做线上增强（online augmentation）或在飞行中增强（augmentation on the fly）。这种方法更适用于较大的数据集（larger datasets），因为你无法承受爆炸性增加的规模。另外，你会在喂入模型之前进行小批量的转换。一些机器学习框架支持在线增强，可以再gpu上加速。 4. 流行的数据增强技术在本章节中，我们会展示一些基本的但是很强大的、流行的增强技术。在我们探索这些技术之前，简便起见，我们做一个假设，假设我们不需要考虑图片边界之外的东西。我们会使用以下技术，使我们的假设有效。 如果我们使用一种技术迫使我们猜出图像边界之外的东西，会发生什么？在这种情况下，我们需要插入一些信息。在我们介绍了增强类型之后，我们将详细讨论这个问题。 对于这些技术中的每一种，我们还指定了数据集大小增加的因子，也称为数据增强因子（Data Augmentation Factor）。 4.1 翻转（Flip）可以对图片进行水平和垂直翻转。一些框架不提供垂直翻转功能。但是，一个垂直反转的图片等同于图片的180度旋转，然后再执行水平翻转。下面是我们的图片翻转的例子。 你可以使用你喜欢的工具包进行下面的任意命令进行翻转，数据增强因子=2或4 123456789# NumPy.'img' = A single image.flip_1 = np.fliplr(img)# TensorFlow. 'x' = A placeholder for an image.shape = [height, width, channels]x = tf.placeholder(dtype = tf.float32, shape = shape)flip_2 = tf.image.flip_up_down(x)flip_3 = tf.image.flip_left_right(x)flip_4 = tf.image.random_flip_up_down(x)flip_5 = tf.image.random_flip_left_right(x) 4.2 旋转（Rotation）一个关键性的问题是当旋转之后图像的维数可能并不能保持跟原来一样。如果你的图片是正方形的，那么以直角旋转将会保持图像大小。如果它是长方形，那么180度的旋转将会保持原来的大小。以更精细的角度旋转图像也会改变最终的图像尺寸。我们将在下一节中看到我们如何处理这个问题。以下是以直角旋转的方形图像的示例。 你可以使用你喜欢的工具包执行以下的旋转命令。数据增强因子= 2或4。 12345678910111213# Placeholders: 'x' = A single image, 'y' = A batch of images# 'k' denotes the number of 90 degree anticlockwise rotationsshape = [height, width, channels]x = tf.placeholder(dtype = tf.float32, shape = shape)rot_90 = tf.image.rot90(img, k=1)rot_180 = tf.image.rot90(img, k=2)# To rotate in any angle. In the example below, 'angles' is in radiansshape = [batch, height, width, 3]y = tf.placeholder(dtype = tf.float32, shape = shape)rot_tf_180 = tf.contrib.image.rotate(y, angles=3.1415)# Scikit-Image. 'angle' = Degrees. 'img' = Input Image# For details about 'mode', checkout the interpolation section below.rot = skimage.transform.rotate(img, angle=45, mode='reflect') 4.3 缩放比例（Scale）图像可以向外或向内缩放。向外缩放时，最终图像尺寸将大于原始图像尺寸。大多数图像框架从新图像中剪切出一个部分，其大小等于原始图像。我们将在下一节中处理向内缩放，因为它会缩小图像大小，迫使我们对超出边界的内容做出假设。以下是缩放的示例或图像。 您可以使用scikit-image使用以下命令执行缩放。数据增强因子=任意。 123456# Scikit Image. 'img' = Input Image, 'scale' = Scale factor# For details about 'mode', checkout the interpolation section below.scale_out = skimage.transform.rescale(img, scale=2.0, mode='constant')scale_in = skimage.transform.rescale(img, scale=0.5, mode='constant')# Don't forget to crop the images back to the original size (for # scale_out) 4.4 裁剪（Crop）与缩放不同，我们只是从原始图像中随机抽样一个部分。然后，我们将此部分的大小调整为原始图像大小。这种方法通常称为随机裁剪。以下是随机裁剪的示例。仔细观察，你会发现此方法与缩放之间的区别。 你可以使用以下任何TensorFlow命令执行随机裁剪。数据增强因子=任意。 12345678# TensorFlow. 'x' = A placeholder for an image.original_size = [height, width, channels]x = tf.placeholder(dtype = tf.float32, shape = original_size)# Use the following commands to perform random cropscrop_size = [new_height, new_width, channels]seed = np.random.randint(1234)x = tf.random_crop(x, size = crop_size, seed = seed)output = tf.images.resize_images(x, size = original_size) 4.5 移位（Translation）移位只涉及沿X或Y方向（或两者）移动图像。在下面的示例中，我们假设图像在其边界之外具有黑色背景，并且被适当地移位。这种增强方法非常有用，因为大多数对象几乎可以位于图像的任何位置。这迫使你的卷积神经网络看到所有角落。 你可以使用以下命令在TensorFlow中执行转换。数据增强因子=任意。 1234567# pad_left, pad_right, pad_top, pad_bottom denote the pixel # displacement. Set one of them to the desired value and rest to 0shape = [batch, height, width, channels]x = tf.placeholder(dtype = tf.float32, shape = shape)# We use two functions to get our desired augmentationx = tf.image.pad_to_bounding_box(x, pad_top, pad_left, height + pad_bottom + pad_top, width + pad_right + pad_left)output = tf.image.crop_to_bounding_box(x, pad_bottom, pad_right, height, width) 4.6 高斯噪声（Gaussian Noise）当您的神经网络试图学习可能无用的高频特征（大量出现的模式）时，通常会发生过度拟合。具有零均值的高斯噪声基本上在所有频率中具有数据点，从而有效地扭曲高频特征。这也意味着较低频率的组件（通常是您的预期数据）也会失真，但你的神经网络可以学会超越它。添加适量的噪音可以增强学习能力。 一个色调较低的版本是盐和胡椒噪音，它表现为随机的黑白像素在图像中传播。这类似于通过向图像添加高斯噪声而产生的效果，但可能具有较低的信息失真水平。 您可以在TensorFlow上使用以下命令为图像添加高斯噪声。数据增强因子= 2。 1234567#TensorFlow. 'x' = A placeholder for an image.shape = [height, width, channels]x = tf.placeholder(dtype = tf.float32, shape = shape)# Adding Gaussian noisenoise = tf.random_normal(shape=tf.shape(x), mean=0.0, stddev=1.0,dtype=tf.float32)output = tf.add(x, noise) 5. 高级增强技术现实世界中，自然数据仍然可以存在于上述简单方法无法解释的各种条件下。例如，让我们承担识别照片中景观的任务。景观可以是任何东西：冻结苔原，草原，森林等。听起来像一个非常直接的分类任务吧？除了一件事，你是对的。我们忽略了影响照片表现中的一个重要特征 - 拍摄照片的季节。 如果我们的神经网络不了解某些景观可以在各种条件下（雪，潮湿，明亮等）存在的事实，它可能会将冰冻的湖岸虚假地标记为冰川或湿地作为沼泽。 缓解这种情况的一种方法是添加更多图片，以便我们考虑所有季节性变化。但这是一项艰巨的任务。扩展我们的数据增强概念，想象一下人工生成不同季节的效果有多酷？ 条件对抗神经网络（Conditional GANs）来救援！ 在没有进入血腥细节的情况下，条件GAN可以将图像从一个域转换为图像到另一个域。如果你认为这听起来太模糊，那就不是;这就是这个神经网络的强大功能[3]！以下是用于将夏季风景照片转换为冬季风景的条件GAN的示例。 上述方法是稳健的，但计算密集。更便宜的替代品将被称为神经风格转移（neural style transfer）。它抓取一个图像（又称“风格”）的纹理、氛围、外观，并将其与另一个图像的内容混合。使用这种强大的技术，我们产生类似于条件GAN的效果（事实上，这种方法是在cGAN发明之前引入的！）。 这种方法的唯一缺点是，输出看起来更具艺术性而非现实性。但是，有一些进步，如下面显示的深度照片风格转移（Deep Photo Style Transfer），有令人印象深刻的结果。 我们没有深入探索这些技术，因为我们并不关心它们的内在工作。我们可以使用现有的训练模型，以及转移学习的魔力，将其用于增强。 6. 关于插值（interpolation）的简要说明如果您想要翻译不具有黑色背景的图像，该怎么办？如果你想向内扩展怎么办？或者以更精细的角度旋转？在我们执行这些转换后，我们需要保留原始图像大小。由于我们的图像没有关于其边界之外的任何信息，我们需要做出一些假设。通常，假设图像边界之外的空间在每个点都是常数0。因此，当您进行这些转换时，会得到一个未定义图像的黑色区域。 但是这是个正确的假设吗？在现实世界的情况下，它主要是否定的。图像处理和ML框架有一些标准方法，您可以使用它们来决定如何填充未知空间。它们的定义如下。 6.1 常数（Constant）最简单的插值方法是用一些常数值填充未知区域。这可能不适用于自然图像，但可以用于在单色背景下拍摄的图像。 6.2 边界（Edge）在边界之后扩展图像的边缘值。此方法适用于温和移位。 6.3 反射（Reflect）图像像素值沿图像边界反射。此方法适用于包含树木，山脉等的连续或自然背景。 6.4 对称（Symmetric）该方法类似于反射，除了在反射边界处制作边缘像素的副本的事实。通常，反射和对称可以互换使用，但在处理非常小的图像或图案时会出现差异。 6.5 包裹（Wrap）图像只是重复超出其边界，就好像它正在平铺一样。这种方法并不像其他方法那样普遍使用，因为它对很多场景都没有意义。 除此之外，你可以设计自己的方法来处理未定义的空间，但通常这些方法对大多数分类问题都可以。 7. 所以，如果我使用上述技术，我的机器学习算法会很健壮（robust），对吗？如果你以正确的方式使用它，那么是的！你问的正确方法是什么？好吧，有时并非所有的增强技术都对数据集有意义。再考虑我们的汽车示例。以下是一些修改图像的方法。 当然，它们是同一辆车的照片，但你的目标应用可能永远不会看到以这些方向呈现的汽车。 例如，如果你只是想在路上对随机汽车进行分类，那么只有第二张图像才能在数据集上进行分类。但是，如果你拥有一家处理车祸的保险公司，并且你想要确定倒车，破车的车型，那么第三张图片就有意义了。对于上述两种情况，最后一张图像可能没有意义。 关键是，在使用增强技术时，我们必须确保不增加不相关的数据。 8. 真的值得努力吗？你可能期待一些结果来激励你走得更远。很公平;我也有这个问题。让我用小的示例证明增强确实有效。您可以复制此实验以进行验证。 让我们创建两个神经网络，将数据分类为四类中的一类：猫，狮子，老虎或豹子。问题是，一个不会使用数据增加，而另一个则不会。您可以从此处下载数据集链接[4]。 如果你已经检查了数据集，你会发现每个类只有50个图像用于训练和测试显然，我们不能对其中一个分类器使用扩充。为了使机会更公平，我们使用迁移学习（Transfer Learning)[5]为模型提供了更少的数据量。 对于没有增强的那个，让我们使用VGG19网络。我在这里写了一个TensorFlow实现[6]，它基于这个实现[7]。一旦你克隆了我的仓库[6]，你可以从这里获得数据[4],并且vgg19.npy（用于迁移学习）在这里[8]。你现在可以建模验证表现了。 我同意，编写额外的数据扩充代码确实是需要功夫。所以，为了建立我们的第二个模型，我转向Nanonets[9]。他们在内部使用迁移学习和数据扩充，以使用最少的数据提供最佳结果。你需要做的就是在他们的网站[10]上传数据，并等待它们在他们的服务器上训练（通常大约30分钟）。你知道什么，它对我们的比较实验来说是完美的。 如果已完成培训，您可以请求调用其API来计算测试准确性。查看我的仓库以获取示例代码段（不要忘记在代码段中插入您的模型ID）。 123ResultsVGG19 (No Augmentation)- 76% Test Accuracy (Highest)Nanonets (With Augmentation) - 94.5% Test Accuracy 令人印象深刻，不是吗？事实上，大多数模型在更多数据的情况下表现良好。所以为了提供一个具体的证明，我已经提到了下表。它显示了Cifar 10（C10）和Cifar 100（C100）数据集上流行神经网络的错误率。 C10 +和C100 +列是数据增强的错误率。 感谢您阅读本文！如果你这样击中那个拍手按钮！希望它能够为数据扩充提供一些启示。如果您有任何疑问，可以在社交媒体[11]上给我打电话或给我发电子邮件（bharathrajn98@gmail.com）。 更多了解请参考[1]。 参考资料 https://medium.com/nanonets/how-to-use-deep-learning-when-you-have-limited-data-part-2-data-augmentation-c26971dc8ced https://www.theverge.com/2018/1/12/16882408/google-racist-gorillas-photo-recognition-algorithm-ai https://junyanz.github.io/CycleGAN/ https://drive.google.com/drive/folders/1GpIpbqBQ_ak1Z_4yAj7t6YRqDDyyBbAq?usp=sharing https://medium.com/nanonets/nanonets-how-to-use-deep-learning-when-you-have-limited-data-f68c0b512cab https://github.com/thatbrguy/VGG19-Transfer-Learn https://github.com/machrisaa/tensorflow-vgg https://mega.nz/#!xZ8glS6J!MAnE91ND_WyfZ_8mvkuSa2YcA7q-1ehfSm-Q1fxOvvs https://nanonets.com/?utm_source=Medium&amp;utm_campaign=data%20augmentation/ https://nanonets.com/#demo https://thatbrguy.github.io/ https://arxiv.org/abs/1703.07511]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>data augmentation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[农民群体，被有意无意忽略的大多数——《中国农民调查》读后感]]></title>
    <url>%2Fp%2F9cd63d93%2F</url>
    <content type="text"><![CDATA[秉持着读完一定要尽快写，拖延着就没了的精神。在这几天读完此书后，赶快下笔写了下来。 父辈及以上都是农民，生活的前十八年都是农村及我们的小县城度过的，可以说，生活的见闻是我对此书中的例子有切实的体会的。记得小的时候，我会坐着爸爸的奔马车去乡里交公粮。小时候的我，大多数时间都是在村里，只有交公粮才算是出去一次，记得那时第一次见中间有人指挥的十字路口。再后来，国家不收公粮了，我查了下，大概2006年开始的。我奶奶时常说起胡主席的好，胡主席免了大家的公粮。我们家在河南农村，农民的苦和心酸，在我这里基本可以说很麻木了。以我们家自己最近一季种的大蒜为例，大蒜现在价格是0.35元/斤，一亩地约3k斤大蒜。前几天我们家卖了一亩蒜，1100元。这1100是收入，但是如果扣除种子费、农药费、浇水用电费等必不可少的开支成本，我们这亩蒜是赔钱的。也就是说，家里这一季度又白忙活了。有人或许会问，那为什么不承包出去呢？现在承包一亩地的价格是400元/年，即使价格如此低我们家也很乐意去承包出去，但是仍然没人愿意承包。这就是农村的现状，这就是2018年的河南农村现状。 引言提到，“我们常常骄傲地宣称：我们是以世界百分之七的耕地，养活了世界上百分之二十一的人口。我们的农民为十三亿人口提供了足够的粮食，这不能不是一个世界性的伟大贡献，可是，我们却往往很少想到，我们是在以占世界上百分之四十的农民才养活了这百分之二十一的人口的。这只能说明，我们的农业目前还相当落后，绝大多数的农民生活水平还很低。“从7%土地养活21%的人口而言，的确伟大。但是我们是靠着40%的农民养活21%的人口，这种现实却常常被忽略。一定程度上，这种事实被一些人有意的掩盖着，自己等大多数人们也被欺骗着。 书依然可以分为两块，殉道者、恶人治村、漫漫上访路等章节以典型事件来凸显农村现状为第一部分，而税改等对农村出路的探讨为第二部分。注意此书的成书时间是2003年，主要写的还是90年代左右（~1986-~2002）的事情，整体事件大体都发生在25年前左右。看到“恶人治村“这一块，很自然的想到我们村，我不是说我们的村干部们是书中的恶人，但是村里跟所谓的法治社会关系也不大，且这不是我们一个村的问题。以某年村干部选举为例，选举前，某人相当村干部，拉全村人吃个一星期，每人天天发包烟。这也没什么，就是贿赂选民。选举中，乡里派过来的选举监督代表，某些人就可以喊，谁跟我抢××位置我就弄死谁。然后靠兄弟多人多直接把乡里的监督代表轰走了。你想想，这问题。顺便吐槽，跟zf打交道也是一样的麻烦，我们那边官本位意识一点不差，从来没有为人民服务的想法。之前去乡里办身份证，跑了很多趟，跑了两个月才拍照。为什么呢？记得有次说，照相机坏了，有次说人放假了（工作日去的），有次说出去玩了，有次说今天不办理身份证，有次说负责照相的人不在，有次说打印机坏了等。后来，我妈就同我讲，“身份证一定要放好，办的时候难死”。的确，在农村，办事难死。回头想一想，不就一个身份证吗？照个相，交个钱就行了，有什么难的呢？而现实中，我依然跑了两个月才给照相办理。在农村，各种办事都要靠有人有权。像我们家这种没人（没有人当村干部及乡干部）的大多数家庭而言，这么多年怎么过来的，其中的艰难你们应该很难想象。虽然21世纪了，村里依然是兄弟多的人横着走，没有儿子的依然被人瞧不起，这种文化或风气带来的结果就是，在农村儿子还是非生不可的。这也解释了，为何农村剩男多。 从书中，我们也看到农村经历过这么多苦难。乱收费、乱摊派、乱集资的“三乱”。书中的后半部分是讲农村体制改革，改为收公粮的一次性交清的方法。这种方法的好处的确很多，提高了农民的积极性。这种改革，是一种非常大的进步。但是这种改革其实并没有触及根本，因为国家要发展，就需要钱，需要钱就要从人民或农民身上出。出的钱最终不会少太多。这种改革，从大约90年开始，走了十多年的路，这种改革过程中，遇到的各种阻碍，阻力还是非常大的。最终还是有一个相对非常好的结果，还是不错的。 正如书中所言，户口的城市与农村，使得农民先天成为二等人民。农民们为国家的城市化进程提供了所有能提供的支撑，却被排除在了城市化之外。我爸妈外出务工十多年了，成为了常年在外的农民工。一如书中所言，所谓的社保局永远是为城里人开的社保局，公积金也一样。我爸妈他们没有任何的医疗、工伤、养老等保险。像爸妈一样的务工人员，他们为城市化进程出力，却一直不被城市接纳。这种问题也是新的或一直以来的问题。同样，务工人员的子女教育问题，留守儿童问题都十分的突出和严峻。农村要增加收入，靠土地早已经不行了。比如我们种的小麦，亩产基本稳定是800-1000斤，小麦是国家定价8毛一斤，出去化肥、农药、交水等一亩也就两三百元的净收入，这就是辛苦半年的收入。外出务工可能是对多数农民的出路了。外出务工带动了运输、消费，提供了生产力。可是社会从来没有为他们的社保及子女付出过什么。难道不该做点什么吗？从来都讲，中华民族是勤劳、智慧、善良的，我们的农民是最朴实、善良的，也是说我们的农民是世界上最能承受压迫的，只要能活着，基本都不会有什么事情，任何官员，含村长，村电工，村水管工都可以欺负我们或他们，可是我们的农民活的真的很苦、很累、很委屈。书中的描述的确很煽情，有一些适当的过分，但是现实里也差不多。书中也点出了一些问题，中央的出发点是好的，但是具体行动起来难。如果都按照文件来，真的实现不了，这也是矛盾的地方，所以政策实施也未必全怪地方官员。在生活里，很多村里乡里的干部故意刁难的现象很常见，我们的农民依然是任人宰割的羔羊，很多新的矛盾和问题也在不断地凸显，比如像我们的地承包不出去，种了等于没种的现象。这些问题，依然有待解决。]]></content>
      <categories>
        <category>看风起听雨落</category>
      </categories>
      <tags>
        <tag>公众号文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim, tab设置为4个空格，4个空格设置为tab]]></title>
    <url>%2Fp%2F3f4679d1%2F</url>
    <content type="text"><![CDATA[vim中tab与空格互换。 在.vimrc中添加以下代码后，重启vim即可实现按TAB产生4个空格： 12set ts=4 (注：ts是tabstop的缩写，设TAB宽4个空格)set expandtab 对于已保存的文件，可以使用下面的方法进行空格和TAB的替换： TAB替换为空格： 123:set ts=4:set expandtab:%retab! 空格替换为TAB：123:set ts=4:set noexpandtab:%retab! 加!是用于处理非空白字符之后的TAB，即所有的TAB，若不加!，则只处理行首的TAB。 参考资料： https://blog.csdn.net/jiang1013nan/article/details/6298727]]></content>
      <categories>
        <category>experience of code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常用排序算法总结（冒泡、插入、选择、希尔、归并、快排、堆排序、基数排序）]]></title>
    <url>%2Fp%2F176ecc84%2F</url>
    <content type="text"><![CDATA[针对常用的排序算法（冒泡排序、插入排序、选择排序、希尔排序、归并排序、快速排序、堆排序、基数排序）的原理、稳定性、算法复杂度分别作了分析，并使用c++做了实现。 所有排序实现默认从小到大。 1. 冒泡排序 (Bubble Sort)稳定排序 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。 冒泡排序是最简单粗暴的排序方法之一。它的原理很简单，每次从左到右两两比较，把大的交换到后面，每次可以确保将前M个元素的最大值移动到最右边。 最好O(N)，最坏O(N ^ 2)，平均O(N ^ 2) 步骤 从左开始比较相邻的两个元素x和y，如果 x &gt; y 就交换两者 执行比较和交换，直到到达数组的最后一个元素 重复执行1和2，直到执行n次，也就是n个最大元素都排到了最后 注意： i从后向前走，注意i–，j从0至i之间的sort 1234567891011void bubble_sort(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); if(n&lt;=1) return; for(int i = n-1; i&gt;=0; i--)&#123; for(int j=0; j&lt;i; j++)&#123; if(nums[j]&gt;nums[j+1]) swap(nums[j], nums[j+1]); &#125; &#125; return;&#125; 其中swap代码可以换成下面两种： 123int temp = nums[j];nums[j] = nums[j + 1];nums[j + 1] = temp; 或者不借助tmp 123nums[j] += nums[j + 1];nums[j + 1] = num[j] - nums[j + 1];nums[j] -= num[j + 1]; 复杂度分析 由于我们要重复执行n次冒泡，每次冒泡要执行n次比较（实际是1到n的等差数列，也就是(a1 + an) * n / 2），也就是 O(n^2)。 空间复杂度是O(n)。 2. 插入排序（Insertion Sort）稳定排序 插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。 插入排序的原理是从左到右，把选出的一个数和前面的数进行比较，找到最适合它的位置放入，使前面部分有序。 最好O(N)，最坏O(N^2)，平均O(N ^ 2) 步骤 从左开始，选出当前位置的数x，和它之前的数y比较，如果x &lt; y则交换两者，否则跳出此次循环 对x之前的数都执行1步骤，直到前面的数字都有序 选择有序部分后一个数字，插入到前面有序部分，直到没有数字可选择 12345678910void InsertSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt;= 1) return; for (int i = 1; i &lt; n; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; nums[j] &lt; nums[j - 1]; j--) &#123; swap(nums[j], nums[j - 1]); &#125; &#125; return;&#125; 复杂度分析 因为要选择n次，而且插入时最坏要比较n次，所以时间复杂度同样是O(n^2)。空间复杂度是O(n)。 3. 选择排序（Selection Sort）不稳定排序 选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。 最好，最差，平均都是O(N^2) 选择排序的原理是，每次都从乱序数组中找到最大（最小）值，放到当前乱序数组头部，最终使数组有序。 步骤 从左开始，选择后面元素中最小值，和最左元素交换 从当前已交换位置往后执行，直到最后一个元素 1234567891011121314void SelectionSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt;= 1) return; for (int i = 0; i &lt; n; i++) &#123; int min = i; for (int j = i + 1; j &lt; n; j++) &#123; if (nums[j] &lt; nums[i]) &#123; min = j; &#125; &#125; swap(nums[min], nums[i]); &#125; return;&#125; 复杂度分析 每次要找一遍最小值，最坏情况下找n次，这样的过程要执行n次，所以时间复杂度还是O(n^2)。空间复杂度是O(n)。 4. 希尔排序（Shell Sort）不稳定排序 希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。 最好O(n logn logn)，最坏 O(n ^ 2)，平均O(n ^ 1 ~ 2) 希尔排序从名字上看不出来特点，因为它是以发明者命名的。它的另一个名字是“递减增量排序算法“。这个算法可以看作是插入排序的优化版，因为插入排序需要一位一位比较，然后放置到正确位置。为了提升比较的跨度，希尔排序将数组按照一定步长分成几个子数组进行排序，通过逐渐减短步长来完成最终排序。 例子 例如 [10, 80, 70, 100, 90, 30, 20] 如果我们按照一次减一半的步长来算， 这个数组第一次排序时以3为步长，子数组是： 10 80 70 90 30 20 100 这里其实按照列划分的4个子数组，排序后结果为 10 30 20 90 80 70 100 也就是 [10, 30 20 90 80 70 100] 然后再以1为步长生成子数组 10 30 20 .. 这个时候就是一纵列了，也就是说最后一定是以一个数组来排序的。 步骤 计算当前步长，按步长划分子数组 子数组内插入排序 步长除以2后继续12两步，直到步长最后变成1 123456789101112void ShellSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt;= 1) return; for (int gap = nums.size() &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1) &#123; for (int i = gap; i &lt; nums.size(); i++) &#123; for (int j = i; j &gt;= gap &amp;&amp; nums[j - gap] &gt; nums[j]; j--) &#123; swap(nums[j - gap], nums[j]); &#125; &#125; &#125; return;&#125; 复杂度分析 希尔排序的时间复杂度受步长的影响，具体分析在维基百科。 5. 归并排序（Merge Sort）稳定性排序 归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定性是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。 最差最好平均都是O(nlogn) 归并排序是采用分治法（Divide and Conquer）的一个典型例子。这个排序的特点是把一个数组打散成小数组，然后再把小数组拼凑再排序，直到最终数组有序。 步骤 把当前数组分化成n个单位为1的子数组，然后两两比较合并成单位为2的n/2个子数组 继续进行这个过程，按照2的倍数进行子数组的比较合并，直到最终数组有序 123456789101112131415161718192021222324252627282930313233void Merge(vector&lt;int&gt;&amp; nums, int start, int mid, int end) &#123; vector&lt;int&gt; left(nums.begin() + start, nums.begin() + mid + 1); vector&lt;int&gt; right(nums.begin() + mid + 1, nums.begin() + end + 1); int i = 0, j = 0, k = start; while (i&lt;left.size() &amp;&amp; j&lt;right.size()) &#123; if (left[i] &lt;= right[j]) &#123; nums[k++] = left[i++]; &#125; else &#123; nums[k++] = right[j++]; &#125; &#125; while (i &lt; left.size()) &#123; nums[k++] = left[i++]; &#125; while (j &lt; right.size()) &#123; nums[k++] = right[j++]; &#125; return;&#125;void MergeSort(vector&lt;int&gt;&amp; nums, int start, int end) &#123; if (start &lt; end) &#123; int mid = start + (end - start) / 2; MergeSort(nums, start, mid); MergeSort(nums, mid + 1, end); Merge(nums, start, mid, end); &#125; return;&#125; 这个实现中加了一个temp，是和原数组一样大的一个空间，用来临时存放排序后的子数组的。 复杂度分析 在merge_array过程中，实际的操作是当前两个子数组的长度，即2m。又因为打散数组是二分的，最终循环执行数是logn。所以这个算法最终时间复杂度是O(nlogn)，空间复杂度是O(n)。 6. 快速排序（Quick Sort）不稳定排序 快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11，现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j]交换的时刻。 快速排序也是利用分治法实现的一个排序算法。快速排序和归并排序不同，它不是一半一半的分子数组，而是选择一个基准数，把比这个数小的挪到左边，把比这个数大的移到右边。然后不断对左右两部分也执行相同步骤，直到整个数组有序。 最好O(nlogn)，平均O(nlogn)，最差O(n ^ 2) 步骤 用一个基准数将数组分成两个子数组 将大于基准数的移到右边，小于的移到左边 递归的对子数组重复执行1，2，直到整个数组有序 1234567891011121314151617181920212223// start开始位置，end最后一位int Patition(vector&lt;int&gt;&amp; nums, int start, int end) &#123; int x = nums[end]; int i = start - 1; for (int j = start; j &lt; end; j++) &#123; if (nums[j] &lt;= x) &#123; i++; swap(nums[i], nums[j]); &#125; &#125; swap(nums[++i], nums[end]); return i;&#125;void QuickSort(vector&lt;int&gt;&amp; nums, int start, int end) &#123; if (start &lt; end) &#123; int pos = Patition(nums, start, end); QuickSort(nums, start, pos - 1); QuickSort(nums, pos + 1, end); &#125; return;&#125; 示例代码二： 1234567891011121314151617181920212223242526272829303132int partition(vector&lt;int&gt;&amp; nums, int i, int j)&#123; if(i&gt;=j) return i; int k=i+1; for(; k&lt;j; k++)&#123; if(nums[k]&gt;nums[j])&#123; swap(nums[k], nums[j]); k--; j--; &#125; &#125; if(nums[k]&lt;nums[i]) swap(nums[i], nums[k]); return k;&#125;void quick_sort(vector&lt;int&gt;&amp; nums, int i, int j)&#123; if(i&gt;=j) return; int mid = partition(nums, i,j); quick_sort(nums, i, mid-1); quick_sort(nums, mid+1, j); return;&#125;int main()&#123; vector&lt;int&gt; nums = &#123;4, 10, 4, 3, 8, 9&#125;; quick_sort(nums, 0, 5); for(auto num:nums) cout&lt;&lt;num&lt;&lt;endl;&#125; 复杂度分析 快速排序也是一个不稳定排序，时间复杂度看维基百科。空间复杂度是O(n)。 7. 堆排序（Heap Sort）堆排序经常用于求一个数组中最大k个元素时。因为堆实际上是一个完全二叉树，所以用它可以用一维数组来表示。因为最大堆的第一位总为当前堆中最大值，所以每次将最大值移除后，调整堆即可获得下一个最大值，通过一遍一遍执行这个过程就可以得到前k大元素，或者使堆有序。 时间复杂度，平均/最好/最坏均为O(nlogn) 在了解算法之前，首先了解在一维数组中节点的下标： i节点的父节点 parent(i) = floor((i-1)/2) i节点的左子节点 left(i) = 2i + 1 i节点的右子节点 right(i) = 2i + 2 步骤 构造最大堆（Build Max Heap）：首先将当前元素放入最大堆下一个位置，然后将此元素依次和它的父节点比较，如果大于父节点就和父节点交换，直到比较到根节点。重复执行到最后一个元素。 最大堆调整（Max Heapify）：调整最大堆即将根节点移除后重新整理堆。整理方法为将根节点和最后一个节点交换，然后把堆看做n-1长度，将当前根节点逐步移动到其应该在的位置。 堆排序（HeapSort）：重复执行2，直到所有根节点都已移除。 1234567891011121314151617181920212223242526272829303132333435void MaxHeapify(vector&lt;int&gt;&amp; nums, int begin, int end) &#123; int cur = begin; int child = cur * 2 + 1; while (child &lt;= end) &#123; if (child + 1 &lt; end &amp;&amp; nums[child] &lt; nums[child + 1]) &#123; child++; &#125; if (nums[cur] &lt; nums[child]) &#123; swap(nums[cur], nums[child]); cur = child; child = 2 * child + 1; &#125; else &#123; break; &#125; &#125; return;&#125;void HeapSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt;= 1) return; for (int i = （n-2)/2; i &gt;= 0; i--) &#123; //最后节点n-1，然后((n-1)-1)/2; MaxHeapify(nums, i, n - 1); &#125; for (int i = n - 1; i &gt; 0; i--) &#123; swap(nums[0], nums[i]); MaxHeapify(nums, 0, i-1); &#125; return;&#125; 复杂度分析 堆执行一次调整需要O(logn)的时间，在排序过程中需要遍历所有元素执行堆调整，所以最终时间复杂度是O(nlogn)。空间复杂度是O(n)。 8. 基数排序稳定排序 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。 堆排序、快排、归并代码实践 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;bitset&gt;using namespace std;void merge(vector&lt;int&gt;&amp;nums, int left, int mid, int right)&#123; vector&lt;int&gt;l(nums.begin()+left, nums.begin()+mid+1); vector&lt;int&gt;r(nums.begin()+mid+1, nums.begin()+right+1); int i=0, j=0, k=left; while(i&lt;l.size()&amp;&amp;j&lt;r.size())&#123; if(l[i]&lt;=r[j])&#123; nums[k++] = l[i++]; &#125;else&#123; nums[k++] = r[j++]; &#125; &#125; while(i&lt;l.size())&#123; nums[k++] = l[i++]; &#125; while(j&lt;r.size())&#123; nums[k++] = r[j++]; &#125; &#125;int partition(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if(right==left) return left; int i = left-1; int flag = nums[right]; int j=left; for(;j&lt;right; j++)&#123; if(nums[j]&lt;=flag)&#123; swap(nums[++i], nums[j]); &#125; &#125; swap(nums[++i], nums[right]); return i;&#125;void quick_sort(vector&lt;int&gt;&amp; nums, int start, int end)&#123; if(start&lt;end)&#123; int q = partition(nums, start, end); quick_sort(nums, start, q-1); quick_sort(nums, q+1, end); &#125;&#125;void merge_sort(vector&lt;int&gt;&amp; nums, int i, int j)&#123; if(j&gt;i)&#123; int mid = i+(j-i)/2; merge_sort(nums, i, mid); merge_sort(nums, mid+1, j); merge(nums, i, mid, j); &#125; return;&#125;void max_heapify(vector&lt;int&gt;&amp; nums, int l, int r)&#123; if(l==r) return; int parent = l; int child = 2*l+1; while(child&lt;=r)&#123; if(child+1&lt;=r &amp;&amp; nums[child+1]&gt;nums[child]) child+=1; if(nums[child]&gt;nums[parent])&#123; swap(nums[child], nums[parent]); parent = child; child = parent*2+1; &#125;else&#123; break; &#125; &#125; return;&#125;void heap_sort(vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); if(n&lt;=1) return; for(int i=(n-1)/2; i&gt;=0; i--)&#123; max_heapify(nums, i, n-1); &#125; for(int i=n-1; i&gt;0; i--)&#123; swap(nums[0], nums[i]); max_heapify(nums, 0, i-1); &#125;&#125;int main()&#123; vector&lt;int&gt; nums = &#123;4, 10, 4, 3, 8, 9, 11, 1, 5, 21, 23, 2&#125;;// quick_sort(nums, 0, nums.size()-1);// merge_sort(nums, 0, nums.size()-1); heap_sort(nums); for(auto num:nums) cout&lt;&lt;num&lt;&lt;endl;&#125; 参考资料： http://yansu.org/2015/09/07/sort-algorithms.html 《算法导论》 http://yucc.me/p/176ecc84/]]></content>
      <categories>
        <category>experience of code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo自定义首页/主页教程]]></title>
    <url>%2Fp%2F14eafa62%2F</url>
    <content type="text"><![CDATA[hexo+github.io搭建博客后，有一个问题是，我的域名yucc.me直接指向我的博客首页，但是问题是我想用我的顶级域名yucc.me自定义页面用于个人信息及成果展示，同时又不想失去这个原有博客首页。本教程就是解决这个问题。 经过本教程，大家可以看到顶级域名yucc.me 已经可以自定义了，而博客首页对应的域名变为yucc.me/blog了，除了这些，其他的所有链接地址（包含导航链接、文章内容链接等）都没有改变。 在google也搜了很多，都没找到合适的答案，有的是通过将博客作为子域名来展示，顶级域名再单独搭建一个库，我觉得太麻烦，而且我的很多网页域名都改了，肯定不行。有的建议不生成首页，去除生成首页的插件，这也不行，原有的博客首页，还是很有必要的，我还是想保留。发现网上没有我想要的答案。 其实，仔细思考这个问题，最主要的问题是生成的博客首页的地址是根目录/顶级域名,所以占用了这个yucc.me的域名。所以最好的办法是让生成的博客首页地址改了就可以了，所以有了下面的教程。该教程只会让生成的博客首页至博客索引的第n页更改，对原有的博客内容页面毫无影响。 1. 更改首页的地址去hexo的配置文件_config.yml中，找到index_genernator，更改path，默认的是’’，更改为’/blog/‘。 以我的为例，更改前，博客的首页地址yucc.me/，更改后，yucc.me/blog/ 。这个更改非常好，更改后，只有博客首页地址变了，其他的所有内容，比如关于，归档，标签等的地址全部不变，博客文章的地址等全部不变。 1234index_generator: path: &apos;/blog/&apos; per_page: 10 order_by: -date 此时，可以去你的主题（我的主题是next）下面的_config.yml中的menu目录下的home对应的地址，从 / 改为 /blog/ 。 12menu: home: /blog/ || home 2. 设置你的顶级域名首页可以在source目录下面，新建一个文件叫做 index.md,写下如下内容： 1234567layout: false---hello, I am Chenchen Yu. This page is in building to show my work.You can visit my blog: [yucc.me/blog/](./blog/) . layout: false表示，该页不会使用hexo或主题的模板渲染。 名字叫index表示，这个就是对应着顶级域名的页面，对于我而言，就是yucc.me。所以想展示的就可以在这里面写了。 除了在source下面新建index.md的方法，也可以使用在source直接放一个index.html，这样顶级域名对应的就是index.html展示的内容了。 至此，教程结束。 可以看到顶级域名yucc.me 已经可以自定义了，而博客首页对应的域名变为yucc.me/blog了，除了这些，其他的都没有改变，我想这就是大家想要的答案了,欢迎点击上面的链接验证我的网站。 参考资料 http://yucc.me/p/14eafa62/]]></content>
      <categories>
        <category>experience of code</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter notebook在服务器上配置，本地进行开发教程]]></title>
    <url>%2Fp%2Fe2b147ab%2F</url>
    <content type="text"><![CDATA[适用于在linux环境的服务器且已经安装了jupyter，希望能在服务器上配置好的jupyter，在本地进行连接jupyter用于开发的情况。也适合本地配置。 1. 生成配置文件1jupyter notebook --generate-config 如下图，生成配置文件，同时下面也显示了配置文件所在的位置。 2. 生成密码1jupyter notebook password 我是输入命令后，直接按两次enter，也就是没有密码。 3. 配置jupyter配置文件使用vim打开配置文件，配置文件的地址可以从图1对应的位置找到。下面是我的位置，你需要换成自己的位置。 1vim /root/.jupyter/jupyter_notebook_config.py 配置如下，其中port对应的是端口号，notebook_dir对应的是jupyter的默认路径，可以根据自己需要更改就行了。 1234c.NotebookApp.port = 8082c.NotebookApp.ip = &apos;*&apos;c.NotebookApp.open_browser = Falsec.NotebookApp.notebook_dir = &apos;/dfsdata/yucc1_data/jupyters&apos; 4. 运行jupyter命令为： 1jupyter notebook 然后在本地浏览器里打开 ip:port，就可以了，比如我的http://10.100.208.201:8082 。在浏览器里打开，首先需要输入密码，根据步骤2，我的密码为空，我直接enter键就可以了。 参考资料 http://jupyter-notebook.readthedocs.io/en/stable/notebook.html#installing-kernels http://yucc.me/p/e2b147ab/]]></content>
      <categories>
        <category>experience of code</category>
      </categories>
      <tags>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[明媚阳光下，被忽略的阴暗角落——《我不是药神》观后感]]></title>
    <url>%2Fp%2Fe8d0c662%2F</url>
    <content type="text"><![CDATA[《我不是药神》好评如潮，今天下午跟风去影院围观了下。溢美之词无需多言，值得安利。该部电影讲述的是以徐峥饰演的程勇这个印度神油小商贩为生计所迫转行为印度神药代理商，由最初的赚钱转为救赎的故事。影片中，程勇与张长林达成交易并金盆洗手为前半部分，这部分的内容是黑色幽默，刻画的是荒诞的事实，接近4w一瓶的所谓正版药，而批发价500元的印度仿制药，就因为不某些规定而列为假药进行严厉打击。后半部分为救赎部分，目睹因自己洗手而导致自己曾经战友吕受益死亡的场景，程勇决定救赎自己凭借自己的努力去挽救更多的生命。 男主程勇，第一次出现的时候，是一个衰败失落的中年男子形象。老婆带着孩子去满足日益增长的美好生活需要，毅然决然的放弃这位不充分不平衡发展的程勇男士，此为婚姻感情的落魄。租着门面房，卖着印度神油，无奈大家喜欢的是伟哥，神油已经不流行了，生活窘迫，以至于后面连门面房的租金已经交不起了，此为事业的不幸。自己的老爹，本来就年纪大了，躺在床上需要人喂饭才能吃下去，屋漏偏逢连夜雨，老爹做手术需要8w元。可是自己连房租都交不起，何况8w呢？这也是压死骆驼的最后一个重担。 一个偶然的机会，知道去印度代购神油的时候可以代购仿制药，可以赚保理。本来是坚定拒绝的他（遵纪守法的好公民，嗯）面对自己的父亲的手术，他妥协了。正所谓，当所有的合法合规的办法无法支撑你走下去的时候，多看看刑法，快速赚钱的方法都在上面。为了家人，他决然的走向了转行之路——代购印度神油转行印度神药独家代理。神药在中国市场大，于是开始了自己的创业之路，组建了自己的靠谱团队，从拉白血病人吕受益下水，到吕受益拉群知名群主刘思慧，群主刘姐拉来自己的靠谱营销受众病人群友。一阵乱斗，有了自己的得力干将黄毛，为了对外沟通，又拉来了病人牧师。至此，团队组建完毕，营销受众组建完毕。一次靠谱的生意至此算是开始了。 好景不长，大约半年后，张长林的出现让他开始意识到，自己不能这么干下去了。理由很简单，这是违法的事情，抓进去就是进去了。自己之所以这么卖命，不过是为了摆脱贫困，奔向小康，现在小康生活也有了，生活的基本矛盾已经变了，自己开始对美好生活向往了。根据剧情设定，他这半年收入大约是50w人民币。再加上张长林承诺买断路径给的200w，这次基本上算是250w，根据时间设定，那时是2002-2003年。这笔钱可以生活的特别舒适，可以考虑买套房子，再投资其他的。可以说，这次转型是非常成功的。这点令人非常服气，说不干就不干了，说洗手就洗手了。对于一个这么赚快钱的方法，这么舍得，必然不是一般人。在最后的晚餐上，各个人的反应是耐人寻味的，也鲜明的体现了各个人的性格。黄毛首先大杯敬酒，摔破水杯，破门而出。刘姐坚定决绝，牧师一如既往的god bless you，吕受益还在希望最后的妥协。这些人物形象鲜明，可以说，主创们花费了一番心思。世界上，从来只有好聚，哪有什么好散呢？从来都是这样。为什么分道扬镳，程勇不过是为了生存，生存解决了，当然就退出了，而其他几位都是为了活命，他们不能停，停了就是死亡。至此，第一段算是告一段落。 拿了这250w的money后，考虑到2003年非典时期的上海，当时的房价也不那么高，买个几套房还是不成问题的，可惜我想错了，故事也不是这么发展，毕竟大家都买房了，还演什么电影。这位程勇男士就开始了自己牛哄哄的经历了。看电影的时候，一直觉得到这里为止，我们的男主的能力和思想觉悟都是有突变增强的。为什么这么说呢？最开始的时候，神油卖不出去，房租交不起，日子维艰。经过一番折腾，又坚定的金盆洗手，这个举动给人表明他是明大局，敢决断的人。再加上办企业后，买设备，灵活的与领导沟通技巧，这种人到哪里都不会混的太差的。而且创业不是花点钱就能成的，不出意外，这应该是他第一次创立这么大的企业，但一年内就成了这么大的企业。从后面的设定看，说是一个月几十万的收入（利润）。故事中，应该是制造企业，这种劳动密集型企业，能榨取的就是工人的剩余价值，一个月榨取几十万的剩余价值？一个百万级别的企业年收入比企业规模还大？那这企业赶上春风了。如果真有这么大的能耐，当初卖神油没落怎么没有改行买伟哥的觉悟呢？当时在电影院，对此点保持怀疑态度。而且后面因为印度出了问题，到手价格由500涨到2000，一个月几十万的利润也不够填坑。所以，就男主的能力而言，的确有太大的突变，毕竟是电影，不能要求那么高。后面看了故事原型人物——陆勇，他是本来家里就开厂，所以在现实中这才是合理的。 故事的后半部分是泪点所在，电影院的我多次落泪。故事的转折在程勇金盆洗手一年后，吕受益的去世给他带来了不可磨灭的印象，他开始思考，为了什么？开始忏悔，开始懊悔为了自己的一己之私而抛下这些病友而不顾，开始自我救赎。不得不说，江湖骗子张长林心真黑，500进口的药，他能买1w，再提价到2w，被人给告发了，也是理所当然。吕受益的死亡给程勇带来了强烈的冲击和思考，这群可怜的白血病友。人跟人的差别就在这个时刻体现了，我前文提到程勇先生的能力和思想觉悟都是明显突变增强的。前文分析了能力，这边便是说觉悟。为何这么说呢？最开始经手神药，不过是为了赚钱，life is money。这里开始变为大无畏活雷锋了。人能变吗？能。这么变可以吗？可以。为什么说突然增强了呢？程勇这位人物的设定，他是一个落魄的人，落魄到人至中年一无所有，而且是一个打老婆的惯犯，打老婆的估计都没什么文化吧。从一个落魄的神油小商贩，到一个救苦救难的活雷锋成功企业家。这其中的转变，对于他来说，唯一的办法是多读书，多思考，而他显然没有多读书的觉悟。你说人生的阅历，这种曾经战友的死亡带来的思考不行吗？不行，没有思维，没有思考的模式，再多的磨难也不过是打击。他的确该有惭愧和忏悔之心，但是有了这颗心就去救赎世界上所有的白血病友，就显得稍微不那么合理。至于审判时刻的，程勇再次进化升级，点出前途是光明的，道路是曲折的，不过是为了过审，没什么好讲。 “我不想死，我想活着”，当一群白血病友因药物被抓到警局后，老奶奶对着警局的“领导”说，她把上海的房子都吃没的时候，她不想死，想活着的时候，是不是假药自己心里有数，抓了程勇们就是断了她们的命的时候，我默默的留下了眼泪。看病难看病贵，摊上大病一夜返贫。谁不想好好地活着？到底哪里出了问题，现在的医药那么贵。回来的路上，我还在想，问题的几个关键。药价太贵，这个问题的解决就要靠两种办法，一个是商务部的反垄断调查，控制药价，一个是通过医保进行谈判，大幅度降低药价。这些工作，需要中央听见民众的声音，对于这些普通的民众，上达天听，还是太难。可以依靠的更靠谱的还是程勇的个人英雄角色。从政治上讲，民众的声音也需要被听到，民众的诉求也需要被满足，尤其是生存以下的民众的诉求。作为一个普通群众，面对社会主义的阳光尚未照耀之前的日子，该如何度过呢？剧中有句话说，“世界上，只有一种病是治不好的，那就是穷病。”，就像网上为何那么多地域黑，总喜欢黑东北及河南呢？道理很简单，穷是原罪。可是，事实上，吃空一套上海房子的老奶奶，真是穷人吗？我不认为她之前是穷人，可是她依然负担不起这么昂贵的药物。他们有什么错？不过是想活命罢了。作为一个13亿的超级大国，政府能顾不全所有民众也是理所当然的，没人有这么大的能力。那么，作为一个普通的民众，还是好好的活着，好好珍惜显得日子，也要为将来多准备下，努力提高自己家的水准，不要给党和政府添麻烦。 从作品的创作而言，人物形象鲜明，每个人都有自己独特的点，人物形象的塑造可以说是非常成功的。尤其是恭喜王传君，通过这部作品，必定撕掉了之前的关谷神奇的固有形象。该部作品把一些“不可说”的药物问题放在台面上说，不但说了，而且公开的放映了。有同学说，看的时候都怀疑是怎么过审的。可以说，这部批判现实主义的作品能够过审，的确是审查制度的一个非常大的进步。这么些年，国产电影良莠不齐，以莠居多。这部电影的出现，可以说是一次非常高水准的创造，值得表扬和鼓励。该部影视涉及和民众最深切利益相关的药物问题，反映现实又能带来一些思考的空间，值得推荐每个人去看一下。 参考资料： https://mp.weixin.qq.com/s?__biz=MzIxNTIxNjYyNg==&amp;mid=2651121658&amp;idx=1&amp;sn=9cd9bd85647f917f127709f6adf7657f&amp;chksm=8c6bff67bb1c7671eb0315fb3709af594ec918a1222c5dc593ce205f2fa44f0ea9a49fa2bbef#rd http://yucc.me/p/e8d0c662/]]></content>
      <categories>
        <category>看风起听雨落</category>
      </categories>
      <tags>
        <tag>公众号文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Two Convolutional Neural Networks for Bird Detection in Audio Signals》阅读笔记]]></title>
    <url>%2Fp%2Fd61fa53b%2F</url>
    <content type="text"><![CDATA[本文作者Thomas Grill和Jan Schlüter参加了Bird Aduio Detection 2017（以下简称BAD）[3]，获得了第一名，并将代码开源[4]并写出了本篇论文[1]。本文是针对次论文的阅读笔记。 1. 介绍参与了BAD 2017竞赛，并提交了两个系统bulbul和sparrow，两个系统都是使用的是声谱图（spectrogram）加CNN的方法。其中bulbul获得了第一名。 2. 数据2.1 数据资源 freefield1010，是freesound上面得到的，从不同的环境和设备录制。 Warblr，从一个鸟密集的地区录制的，地点是英国，有不同的背景音，比如人声、环境交通噪声等。 Chernobyl，是一个鸟远程监控项目得到的数据集。 2.2 数据结构 开发集是freefield1010（7690个样本，25%鸟叫）和Warblr（8000个样本，76%是鸟叫）。 评估集主要是Chernobyl和一小部分Warblr，共8620个样本。 3. 方法共采用了两种方法，均使用了feed-forward CNN 与 Mel-scaled log-maganitude spectrograms。 使用了两种方法，一种叫做bulbul，一种是sparrow。 3.1 输入特征音频采样率22.05khz，帧长1024，帧移315，使用1024的stft。bulbul使用的频段是50Hz-11kHz，sparrow使用50Hz-10kHz（留着做pitch-shifting）。 3.2 bulbul输入是1000帧（14s），网络结果如图 3.3 sparrow 3.4 训练batch size， bulbul为64，sparrow为32。学习率0.001。 update大约都在8w次，这里有疑惑的，如果理解为一个batch为一个update，那么转换过来也就320个epcoh。如果理解为8w个epoch，这也太多了。 dropout在全连接层都加了，三个，都为0.5。 3.5 预测使用的五折交叉验证。 4. 结果分别结果如下图 5. 结论使用bulbul得到了88.7%的auc，其他网络也近似如此，除非网络结构有大的变化，否则不会有太多提升空间了。 参考资料 https://ieeexplore.ieee.org/document/8081512/ http://yucc.me/p/d61fa53b/ http://machine-listening.eecs.qmul.ac.uk/bird-audio-detection-challenge/ https://jobim.ofai.at/gitlab/gr/bird_audio_detection_challenge_2017/tree/master]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DCASE 2018 task3 Bird Audio Detection介绍]]></title>
    <url>%2Fp%2F62100baa%2F</url>
    <content type="text"><![CDATA[DCASE是Detection and Classification of Acoustic Scenes and Events的缩写，翻译过来就是声学场景与事件的检测与分类[1]。DCASE含有竞赛（challenge）和研讨会（workshop）两部分。该竞赛的目的在于提供声学场景和事件的公开数据集，鼓励大家使用和比较不同的方法的优缺点，促进声学场景和事件领域的向前发展。分别在2013、2016、2017年举办过DCASE Challenge比赛，今年是DCASE Challenge 2018，包含五个任务，本文主要讲解的是任务3（task3），该任务是Bird Aduio Detection（鸟叫声检测，以下简称BAD）[2]。 1. 描述给定三个开发集，三个评估集。三个开发集的音频都有标签注明0或1,0表示没有鸟叫，1表示有鸟叫。需要根据开发集去预测评估集的标签，鼓励预测0至1之间的概率值，该课题的评估方法使用的是AUC。 这几个数据集之间使用的录音设备、环境状况、样本个数、正负样本比例等都不同，本赛题更想要的是泛化性能。 2. 音频数据给定的三个开发集和三个评估集，每个数据集分别属于同一个音频检测项目。每个数据集中的每个音频长度都是10s，采样率都是44.1k，单声道，并分别标注为0或1，表明无鸟叫或有鸟叫。 值得注意，人工标注的可能会有一定的错误，一般可以认为96.7%是没问题的，对于BirdVox数据集可以认为99.5%或更好。 3. 开发集3.1 Field recordings, worldwide (“freefield1010”) - a collection of 7,690 excerpts from field recordings around the world, gathered by the FreeSound project, and then standardised for research. This collection is very diverse in location and environment, and for the BAD Challenge we have annotated it for the presence/absence of birds. Download: [data labels] • [audio files (5.8 Gb zip)] (or [via bittorrent]) 3.2 Crowdsourced dataset, UK (“warblrb10k”) - 8,000 smartphone audio recordings from around the UK, crowdsourced by users of Warblr the bird recognition app. The audio covers a wide distribution of UK locations and environments, and includes weather noise, traffic noise, human speech and even human bird imitations. Download: [data labels] • [audio files (4.3 Gb zip)] (or [via bittorrent]) 3.3 Remote monitoring flight calls, USA (“BirdVox-DCASE-20k”) - 20,000 audio clips collected from remote monitoring units placed near Ithaca, NY, USA during the autumn of 2015, by the BirdVox project. More info about BirdVox-DCASE-20k Download: [data labels] • [audio files (15.4 Gb zip)] 4. 评估集4.1 Crowdsourced dataset, UK (“warblrb10k”) - a held-out set of 2,000 recordings from the same conditions as the Warblr development dataset. Download: audio files (1.3 GB zip) 4.2 Remote monitoring dataset, Chernobyl (“Chernobyl”) - 6,620 audio clips collected from unattended remote monitoring equipment in the Chernobyl Exclusion Zone (CEZ). This data was collected as part of the TREE (Transfer-Exposure-Effects) research project into the long-term effects of the Chernobyl accident on local ecology. The audio covers a range of birds and includes weather, large mammal and insect noise sampled across various CEZ environments, including abandoned village, grassland and forest areas. Download: audio files (5.3 GB zip) 4.3 Remote monitoring night-flight calls, Poland (“PolandNFC”) - 4,000 recordings from Hanna Pamuɫa’s PhD project of monitoring autumn nocturnal bird migration. The recordings were collected every night, from September to November 2016 on the Baltic Sea coast, Poland, using Song Meter SM2 units with microphones mounted on 3–5 m poles. For this challenge, we use a subset derived from 15 nights with different weather conditions and background noise including wind, rain, sea noise, insect calls, human voice and deer calls. Download: audio files (2.3 Gb zip) 5. baseline本次官方提供的Baselline是基于去年的比赛Bird Aduio Detection 2017[6]的第一名的代码，BAD 2018 baseline代码的地址是[4] 6. 提交本次提交预测结果的地址是[5]。评估集大约1.2w个样本，结果预览只展示1000个样本的结果。 参考资料 http://dcase.community http://dcase.community/challenge2018/task-bird-audio-detection https://groups.google.com/forum/#!forum/dcase-discussions https://github.com/DCASE-REPO/bulbul_bird_detection_dcase2018 http://lsis-argo.lsis.org:8005 http://machine-listening.eecs.qmul.ac.uk/bird-audio-detection-challenge/ http://machine-listening.eecs.qmul.ac.uk/bird-audio-detection-challenge-results/ http://c4dm.eecs.qmul.ac.uk/events/badchallenge_results/ https://jobim.ofai.at/gitlab/gr/bird_audio_detection_challenge_2017/tree/master http://yucc.me/p/62100baa/ http://yucc.me/p/d61fa53b/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>dcase</tag>
        <tag>bird audio detection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda配置jupyter同时支持python2和python3]]></title>
    <url>%2Fp%2Ffb786859%2F</url>
    <content type="text"><![CDATA[在anaconda环境下，配置jupyter notebook，使其同时适用于python2和python3。本方法适用于windows、mac、ubuntu环境。 1. 配置方法假设你在使用anaconda配置的python3及jupyter环境，想同时支持python2的jupyter。只需要在相应的地方运行以下代码即可： 123conda create -n ipykernel_py2 python=2 ipykernelsource activate ipykernel_py2 # Windows环境中的话, 需要去掉&apos;source&apos;这个词python -m ipykernel install --user 如果目前是使用anaconda配置的python2及jupyter环境，则只需要将上面代码中的2改为3即可。 一个小启发就是，多使用google及英文搜索，这样容易找到官方的答案。中文的很多文章都很不靠谱，又浪费时间。 参考资料： https://ipython.readthedocs.io/en/stable/install/kernel_install.html http://yucc.me/p/fb786859/]]></content>
      <categories>
        <category>experience of code</category>
      </categories>
      <tags>
        <tag>anaconda</tag>
        <tag>jupyter</tag>
        <tag>python2</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网判题系统的输入输出]]></title>
    <url>%2Fp%2F82598037%2F</url>
    <content type="text"><![CDATA[牛客网判题系统的输入输出 对于传统ACM的OJ模式题目，你的程序需要stdin（标准输入）读取输入，然后stdout（标准输出）来打印结果，举个例子，你可以使用c语言的scanf或者c++的cin来读取输入，然后使用c语言的printf或者c++的cout来输出结果。代码禁止读取和写入任何文件，否则判题系统将会返回运行错误。OJ一次处理多个case，所以代码需要循环处理，一般通过while循环来出来多个case。以下是A+B题目的样例代码，http://www.nowcoder.com/questionTerminal/dae9959d6df7466d9a1f6d70d6a11417 C++ 64位输出请用printf(“%lld”) 1234567#include &lt;iostream&gt;using namespace std;int main() &#123; int a,b; while(cin &gt;&gt; a &gt;&gt; b)//注意while处理多个case cout &lt;&lt; a+b &lt;&lt; endl;&#125; Python 12345678910import systry: while True: line = sys.stdin.readline().strip() if line == &apos;&apos;: break lines = line.split() print int(lines[0]) + int(lines[1])except: pass Python3 1234import sys for line in sys.stdin: a = line.split() print(int(a[0]) + int(a[1])) JAVA，注意类名必须为Main, 不要有任何package xxx信息注意hasNext和hasNextLine的区别，详细见&lt;java的oj输入注意点&gt; 12345678910import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (in.hasNextInt()) &#123;//注意while处理多个case int a = in.nextInt(); int b = in.nextInt(); System.out.println(a + b); &#125; &#125;&#125; 参考资料： https://www.nowcoder.com/discuss/276 http://yucc.me/p/82598037/]]></content>
      <categories>
        <category>experience of code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Xshell在按delete,backspace键产生乱码的解决方法]]></title>
    <url>%2Fp%2Fca737a5f%2F</url>
    <content type="text"><![CDATA[当我们用Xshell登录进入linux后,按delete,backspace键时会产生^H等乱码问题. 解决方法: 选择File =&gt; Propertise =&gt; Terminal =&gt; Keyboard 如下设置: 参考资料： http://www.cnblogs.com/hnrainll/archive/2011/05/06/2038455.html http://yucc.me/p/ca737a5f/]]></content>
      <categories>
        <category>experience of code</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[本地环境配置git及github]]></title>
    <url>%2Fp%2Fb95cc0b9%2F</url>
    <content type="text"><![CDATA[本地环境配置github，经常用，所以总结了下。 1. 本地环境配置git及github首先，下载安装git。我这里的git是安装好的，在服务器上。 其次，在命令行或黑框里输入以下命令，主意更改名字邮箱。 12git config --global user.name yuccgit config --global user.email 6506666@gmail.com 再次， 创建本地ssh，输入以下命令，注意更改为自己的邮箱。 1ssh-keygen -t rsa -C 6506666@gmail.com 都按enter键就可以了。 最后，打开默认路径“ .ssh\id_rsa.pub”的内容。登陆github网站，点击Settings——SSH keys——点击右侧的Add SSH key。把id_rsa.pub的内容粘贴到对应里面就可以了。 参考资料： https://segmentfault.com/a/1190000002533334 http://yucc.me/p/b95cc0b9/]]></content>
      <categories>
        <category>experience of code</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[690. Employee Importance]]></title>
    <url>%2Fp%2F79ca8c23%2F</url>
    <content type="text"><![CDATA[58.7% https://leetcode.com/problems/employee-importance/description/ You are given a data structure of employee information, which includes the employee’s unique id, his importance value and his direct subordinates’ id. For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct. Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates. 123456Example 1:Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1Output: 11Explanation:Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11. Note: One employee has at most one direct leader and may have several subordinates. The maximum number of employees won’t exceed 2000. 方法一： 12345678910111213141516171819202122232425262728293031/*// Employee infoclass Employee &#123;public: // It's the unique ID of each node. // unique id of this employee int id; // the importance value of this employee int importance; // the id of direct subordinates vector&lt;int&gt; subordinates;&#125;;*/class Solution &#123;public: int getImportance(vector&lt;Employee*&gt; employees, int id) &#123; unordered_map&lt;int, Employee*&gt; map; for(auto it:employees) map[it-&gt;id] = it; int res = 0; helper(id, res, map); return res; &#125; void helper(int id, int&amp; res, unordered_map&lt;int, Employee*&gt;&amp; map)&#123; res += map[id]-&gt;importance; for(auto i:map[id]-&gt;subordinates) helper(i, res, map); return; &#125;&#125;; https://discuss.leetcode.com/topic/105382/c-dfs-using-stl C++ DFS using STL without STL 1234567891011121314151617181920212223242526class Solution &#123;public: int getImportance(vector&lt;Employee*&gt; employees, int id) &#123; unordered_map&lt;int, Employee*&gt; map; for(const auto element : employees)&#123; map[element-&gt;id] = element; &#125; return help(map, id); &#125; int help(unordered_map&lt;int, Employee*&gt;&amp; map, const int id)&#123; auto sum = map[id]-&gt;importance; for(const auto element : map[id]-&gt;subordinates)&#123; sum += help(map, element); &#125; return sum; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>hash table</tag>
        <tag>easy</tag>
        <tag>depth first search</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[653. Two Sum IV - Input is a BST]]></title>
    <url>%2Fp%2Ff2d9b1ab%2F</url>
    <content type="text"><![CDATA[50.8% https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/ Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. 123456789Example 1:Input: 5 / \ 3 6 / \ \2 4 7Target = 9 123456789101112Output: TrueExample 2:Input: 5 / \ 3 6 / \ \2 4 7Target = 28Output: False Three simple methods - choose one you like 方法一： 随便一种遍历，然后边边遍历，边放入set，边检查是否能返回。 Method 1. This method also works for those who are not BSTs. The idea is to use a hashtable to save the values of the nodes in the BST. Each time when we insert the value of a new node into the hashtable, we check if the hashtable contains k - node.val. Time Complexity: O(n), Space Complexity: O(n). C++ version: 1234567891011bool findTarget(TreeNode* root, int k) &#123; unordered_set&lt;int&gt; set; return dfs(root, set, k);&#125;bool dfs(TreeNode* root, unordered_set&lt;int&gt;&amp; set, int k)&#123; if(root == NULL)return false; if(set.count(k - root-&gt;val))return true; set.insert(root-&gt;val); return dfs(root-&gt;left, set, k) || dfs(root-&gt;right, set, k);&#125; 方法二： 二叉搜索树，中序遍历应该最好想到 中序遍历后是有序的。 Method 2. The idea is to use a sorted array to save the values of the nodes in the BST by using an inorder traversal. Then, we use two pointers which begins from the start and end of the array to find if there is a sum k. Time Complexity: O(n), Space Complexity: O(n). C++ version: 12345678910111213141516bool findTarget(TreeNode* root, int k) &#123; vector&lt;int&gt; nums; inorder(root, nums); for(int i = 0, j = nums.size()-1; i&lt;j;)&#123; if(nums[i] + nums[j] == k)return true; (nums[i] + nums[j] &lt; k)? i++ : j--; &#125; return false;&#125;void inorder(TreeNode* root, vector&lt;int&gt;&amp; nums)&#123; if(root == NULL)return; inorder(root-&gt;left, nums); nums.push_back(root-&gt;val); inorder(root-&gt;right, nums);&#125; 我的代码实现： 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool findTarget(TreeNode* root, int k) &#123; vector&lt;int&gt; nums; inorder(root, nums); int left = 0, right = nums.size()-1; while(left&lt;right)&#123; int sum = nums[left] + nums[right]; if(sum==k) return true; else if(sum&gt;k) right--; else left++; &#125; return false; &#125; void inorder(TreeNode* root, vector&lt;int&gt;&amp; nums)&#123; if(!root) return; inorder(root-&gt;left, nums); nums.push_back(root-&gt;val); inorder(root-&gt;right, nums); return; &#125;&#125;; 方法三： 针对每一个点，查找k-node.val是否在BST中 Method 3. The idea is to use binary search method. For each node, we check if k - node.val exists in this BST. Time Complexity: O(nlogn), Space Complexity: O(h). h is the height of the tree, which is logn at best case, and n at worst case. C++ version: 123456789101112131415bool findTarget(TreeNode* root, int k) &#123; return dfs(root, root, k);&#125;bool dfs(TreeNode* root, TreeNode* cur, int k)&#123; if(cur == NULL)return false; return search(root, cur, k - cur-&gt;val) || dfs(root, cur-&gt;left, k) || dfs(root, cur-&gt;right, k);&#125;bool search(TreeNode* root, TreeNode *cur, int value)&#123; if(root == NULL)return false; return (root-&gt;val == value) &amp;&amp; (root != cur) || (root-&gt;val &lt; value) &amp;&amp; search(root-&gt;right, cur, value) || (root-&gt;val &gt; value) &amp;&amp; search(root-&gt;left, cur, value);&#125; https://discuss.leetcode.com/topic/98440/java-c-three-simple-methods-choose-one-you-like]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[541. Reverse String II]]></title>
    <url>%2Fp%2Fcb7af514%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/contest/leetcode-weekly-contest-23/problems/reverse-string-ii/ Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original. 123Example:Input: s = &quot;abcdefg&quot;, k = 2Output: &quot;bacdfeg&quot; Restrictions: The string consists of lower English letters only. Length of the given string and k will in the range [1, 10000] my code： 1234567891011121314151617181920212223class Solution(object): def reverseStr(self, s, k): &quot;&quot;&quot; :type s: str :type k: int :rtype: str &quot;&quot;&quot; n = len(s) cur = 0 res = &apos;&apos; while cur&lt;n: if cur+2*k&lt;=n: res+=s[cur:cur+k][::-1] res+=s[cur+k:cur+2*k] cur += 2*k elif cur+k&gt; n: res+=s[cur:][::-1] return res else: res+=s[cur:cur+k][::-1] res+=s[cur+k:] return res return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[539. Minimum Time Difference]]></title>
    <url>%2Fp%2F51b4e64e%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/contest/leetcode-weekly-contest-23/problems/minimum-time-difference/ Given a list of 24-hour clock time points in “Hour:Minutes” format, find the minimum minutes difference between any two time points in the list. 123Example 1:Input: [&quot;23:59&quot;,&quot;00:00&quot;]Output: 1 Note: The number of time points in the given list is at least 2 and won’t exceed 20000. The input time is legal and ranges from 00:00 to 23:59. my code： 正常思路，就可以解决问题，问题在于要思考到第一个和最后一个的距离，这个不可以忽略。 123456789101112131415161718class Solution(object): def findMinDifference(self, timePoints): &quot;&quot;&quot; :type timePoints: List[str] :rtype: int &quot;&quot;&quot; if len(timePoints)==0 or len(timePoints)==1: return 0 tmp = [] for t in timePoints: tt = t.split(&apos;:&apos;) tt = int(tt[0])*60+int(tt[1]) tmp.append(tt) tmp.sort() res = min(abs(tmp[0]-tmp[-1]), 1440-abs(tmp[0]-tmp[-1])) for i in range(1, len(tmp)): cur = min(abs(tmp[i]-tmp[i-1]), 1440-abs(tmp[i]-tmp[i-1])) res = min(cur, res) return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[533. Lonely Pixel II]]></title>
    <url>%2Fp%2Ff04371ac%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/contest/leetcode-weekly-contest-22/problems/lonely-pixel-ii/ Given a picture consisting of black and white pixels, and a positive integer N, find the number of black pixels located at some specific row R and column C that align with all the following rules: Row R and column C both contain exactly N black pixels. For all rows that have a black pixel at column C, they should be exactly the same as row R The picture is represented by a 2D char array consisting of ‘B’ and ‘W’, which means black and white pixels respectively. 1234567891011121314151617181920Example:Input: [[&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;], [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;], [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;], [&apos;W&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;]] N = 3Output: 6Explanation: All the bold &apos;B&apos; are the black pixels we need (all &apos;B&apos;s at column 1 and 3). 0 1 2 3 4 5 column index 0 [[&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;], 1 [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;], 2 [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;], 3 [&apos;W&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;]] row indexTake &apos;B&apos; at row R = 0 and column C = 1 as an example:Rule 1, row R = 0 and column C = 1 both have exactly N = 3 black pixels. Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2. They are exactly the same as row R = 0. Note: The range of width and height of the input 2D array is [1,200]. cpp my code: 审题很重要，第2个条件是完全相同，我最初理解为B的个数相同，所以出现错误。 for循环后的值为n，而不是n-1。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: int findBlackPixel(vector&lt;vector&lt;char&gt;&gt;&amp; picture, int N) &#123; if(picture.size()==0) return 0; if(picture[0].size()==0) return 0; int m = picture.size(); int n = picture[0].size(); vector&lt;int&gt; dp1(m, 0); vector&lt;int&gt; dp2(n, 0); for(int i=0; i&lt;m; i++)&#123; int tmp = 0; for(int j=0; j&lt;n; j++)&#123; if(picture[i][j]==&apos;B&apos;) tmp++; &#125; dp1[i] = tmp; &#125; for(int i=0; i&lt;n; i++)&#123; int tmp = 0; for(int j=0; j&lt;m; j++)&#123; if(picture[j][i]==&apos;B&apos;) tmp++; &#125; dp2[i] = tmp; &#125; int res = 0; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(dp1[i]==dp2[j] &amp;&amp; dp1[i]==N)&#123; int k; int flag = true; for(k=0; k&lt;m; k++)&#123; if(picture[k][j]==&apos;B&apos;) for(int l=0; l&lt;n; l++)&#123; if(picture[i][l]!=picture[k][l])&#123; flag = false; break; &#125; &#125; &#125; if(flag == true) res++; &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[532. K-diff Pairs in an Array]]></title>
    <url>%2Fp%2F25ef048e%2F</url>
    <content type="text"><![CDATA[21.8% https://leetcode.com/contest/leetcode-weekly-contest-22/problems/k-diff-pairs-in-an-array/ Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k. 12345Example 1:Input: [3, 1, 4, 1, 5], k = 2Output: 2Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs. 1234Example 2:Input:[1, 2, 3, 4, 5], k = 1Output: 4Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5). 1234Example 3:Input: [1, 3, 1, 5, 4], k = 0Output: 1Explanation: There is one 0-diff pair in the array, (1, 1). Note: The pairs (i, j) and (j, i) count as the same pair. The length of the array won’t exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7]. cpp my code: 先排序，然后依次查找，注意去重。 1234567891011121314151617181920class Solution &#123;public: int findPairs(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); if(n==0 || n==1) return 0; sort(nums.begin(), nums.end()); if(k&gt;nums[n-1]-nums[0]) return 0; int cnt = 0; for(int i=0; i&lt;n-1; i++)&#123; if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) continue; for(int j=i+1; j&lt;n; j++)&#123; if(j&gt;i+1 &amp;&amp; nums[j]==nums[j-1]) continue; int tmp = nums[j] - nums[i]; if(tmp==k) cnt++; else if(tmp&gt;k) break; &#125; &#125; return cnt; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[531. Lonely Pixel I]]></title>
    <url>%2Fp%2F97b40838%2F</url>
    <content type="text"><![CDATA[44.4% https://leetcode.com/contest/leetcode-weekly-contest-22/problems/lonely-pixel-i/ Given a picture consisting of black and white pixels, find the number of black lonely pixels. The picture is represented by a 2D char array consisting of ‘B’ and ‘W’, which means black and white pixels respectively. A black lonely pixel is character ‘B’ that located at a specific position where the same row and same column don’t have any other black pixels. 12345678Example:Input: [[&apos;W&apos;, &apos;W&apos;, &apos;B&apos;], [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;], [&apos;B&apos;, &apos;W&apos;, &apos;W&apos;]]Output: 3Explanation: All the three &apos;B&apos;s are black lonely pixels. Note: The range of width and height of the input 2D array is [1,500]. cpp my code: 与第200道，小岛的题目很类似，可以考虑参考。但是有不一样，这里建立两个数组，保证横纵坐标都是1，且此处为‘B’就是要找的点，计数。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int findLonelyPixel(vector&lt;vector&lt;char&gt;&gt;&amp; picture) &#123; // if(picture==NULL) return 0; if(picture.size()==0) return 0; if(picture[0].size()==0) return 0; int m = picture.size(); int n = picture[0].size(); vector&lt;int&gt; dp1(m, 0); vector&lt;int&gt; dp2(n, 0); for(int i=0; i&lt;m; i++)&#123; int tmp = 0; for(int j=0; j&lt;n; j++)&#123; if(picture[i][j]==&apos;B&apos;) tmp++; &#125; dp1[i] = tmp; &#125; for(int i=0; i&lt;n; i++)&#123; int tmp = 0; for(int j=0; j&lt;m; j++)&#123; if(picture[j][i]==&apos;B&apos;) tmp++; &#125; dp2[i] = tmp; &#125; int res = 0; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(dp1[i]==1 &amp;&amp; dp2[j]==1 &amp;&amp; picture[i][j]==&apos;B&apos;) res++; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[524. Longest Word in Dictionary through Deleting]]></title>
    <url>%2Fp%2Fe949f471%2F</url>
    <content type="text"><![CDATA[39.8% https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/?tab=Description Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string. 123456Example 1:Input:s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]Output: &quot;apple&quot; 123456Example 2:Input:s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]Output: &quot;a&quot; Note: All the strings in the input will only contain lower-case letters. The size of the dictionary won’t exceed 1,000. The length of all the strings in the input won’t exceed 1,000. https://discuss.leetcode.com/topic/80799/short-java-solutions-sorting-dictionary-and-without-sorting Short Java Solutions - Sorting Dictionary and Without Sorting We sort the input dictionary by longest length and lexicography. Then, we iterate through the dictionary exactly once. In the process, the first dictionary word in the sorted dictionary which appears as a subsequence in the input string s must be the desired solution. 12345678910public String findLongestWord(String s, List&lt;String&gt; d) &#123; Collections.sort(d, (a,b) -&gt; a.length() != b.length() ? -Integer.compare(a.length(), b.length()) : a.compareTo(b)); for (String dictWord : d) &#123; int i = 0; for (char c : s.toCharArray()) if (i &lt; dictWord.length() &amp;&amp; c == dictWord.charAt(i)) i++; if (i == dictWord.length()) return dictWord; &#125; return &quot;&quot;;&#125; An alternate, more efficient solution which avoids sorting the dictionary: 12345678910111213public String findLongestWord(String s, List&lt;String&gt; d) &#123; String longest = &quot;&quot;; for (String dictWord : d) &#123; int i = 0; for (char c : s.toCharArray()) if (i &lt; dictWord.length() &amp;&amp; c == dictWord.charAt(i)) i++; if (i == dictWord.length() &amp;&amp; dictWord.length() &gt;= longest.length()) if (dictWord.length() &gt; longest.length() || dictWord.compareTo(longest) &lt; 0) longest = dictWord; &#125; return longest;&#125; Time Complexity: O(nk), where n is the length of string s and k is the number of words in the dictionary. https://discuss.leetcode.com/topic/80887/short-python-solutions Short Python solutions 12345def findLongestWord(self, s, d): def isSubsequence(x): it = iter(s) return all(c in it for c in x) return max(sorted(filter(isSubsequence, d)) + [&apos;&apos;], key=len) More efficient version (no sorting): 12345def findLongestWord(self, s, d): def isSubsequence(x): it = iter(s) return all(c in it for c in x) return min(filter(isSubsequence, d) + [&apos;&apos;], key=lambda x: (-len(x), x)) Different style: 12345678def findLongestWord(self, s, d): best = &apos;&apos; for x in d: if (-len(x), x) &lt; (-len(best), best): it = iter(s) if all(c in it for c in x): best = x return best Optimized as suggested by @easton042, testing from longest to shortest and returning the first valid one without testing the rest: 123456def findLongestWord(self, s, d): def isSubsequence(x): it = iter(s) return all(c in it for c in x) d.sort(key=lambda x: (-len(x), x)) return next(itertools.ifilter(isSubsequence, d), &apos;&apos;) Or: 123456def findLongestWord(self, s, d): for x in sorted(d, key=lambda x: (-len(x), x)): it = iter(s) if all(c in it for c in x): return x return &apos;&apos; And taking that even further by not sorting unnecessarily much: 123456789def findLongestWord(self, s, d): heap = [(-len(word), word) for word in d] heapq.heapify(heap) while heap: word = heapq.heappop(heap)[1] it = iter(s) if all(c in it for c in word): return word return &apos;&apos; https://discuss.leetcode.com/topic/80876/10-lines-solutions-for-c 10 lines solutions for c++ I think there is no need to sort the dic, just iterate the dic and test whether the word is satisfied and whether we need update our answer. 123456789101112string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123; string ans; for (int i = 0; i &lt; d.size(); i++) &#123; int pi = 0, pj = 0; for (; pi &lt; s.size() &amp;&amp; pj &lt; d[i].size(); pi++) &#123; pj += s[pi] == d[i][pj]; &#125; if (pj == d[i].size() &amp;&amp; (ans.size() &lt; d[i].size() || (ans.size() == d[i].size() &amp;&amp; ans &gt; d[i]))) ans = d[i]; &#125; return ans;&#125; https://discuss.leetcode.com/topic/80816/python-simple-two-pointer Python Simple (Two pointer) Let’s check whether each word is a subsequence of S individually by “best” order (largest size, then lexicographically smallest.) Then if we find a match, we know the word being considered must be the best possible answer, since better answers were already considered beforehand. Let’s figure out how to check if a needle (word) is a subsequence of a haystack (S). This is a classic problem with the following solution: walk through S, keeping track of the position (i) of the needle that indicates that word[i:] still remains to be matched to S at this point in time. Whenever word[i] matches the current character in S, we only have to match word[i+1:], so we increment i. At the end of this process, i == len(word) if and only if we’ve matched every character in word to some character in S in order of our walk. 12345678910def findLongestWord(self, S, D): D.sort(key = lambda x: (-len(x), x)) for word in D: i = 0 for c in S: if i &lt; len(word) and word[i] == c: i += 1 if i == len(word): return word return &quot;&quot; my code: 关键点，两个string的对齐 同时要读清题意，两个字符串长度相等，按照字典顺序排列。 1234567891011121314151617181920class Solution &#123;public: string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123; string longest=&quot;&quot;; for(int i=0; i&lt;d.size(); i++)&#123; int j=0; if(d[i].size()&lt;longest.size()) continue; for(auto c:s)&#123; if(c==d[i][j]) j++; &#125; if(j==d[i].size() &amp;&amp; d[i].size()&gt;longest.size()) longest = d[i]; else if(j==d[i].size() &amp;&amp; d[i].size()==longest.size() &amp;&amp; d[i] &lt; longest) longest = d[i]; &#125; return longest; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[500. Keyboard Row]]></title>
    <url>%2Fp%2F796a54cb%2F</url>
    <content type="text"><![CDATA[Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below. 123Example 1:Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]Output: [&quot;Alaska&quot;, &quot;Dad&quot;] Note: You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet. 方法一： https://discuss.leetcode.com/topic/77761/c-solution C++ solution 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) &#123; unordered_set&lt;char&gt; row1 &#123;'q', 'w', 'e', 'r', 't', 'y','u', 'i', 'o', 'p'&#125;; unordered_set&lt;char&gt; row2 &#123;'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'&#125;; unordered_set&lt;char&gt; row3 &#123; 'z', 'x', 'c', 'v', 'b' ,'n', 'm'&#125;; vector&lt;unordered_set&lt;char&gt;&gt; rows &#123;row1, row2, row3&#125;; vector&lt;string&gt; validWords; for(int i=0; i&lt;words.size(); ++i)&#123; int row=0; for(int k=0; k&lt;3; ++k)&#123; if(rows[k].count((char)tolower(words[i][0])) &gt; 0) row = k; &#125; validWords.push_back(words[i]); for(int j=1; j&lt;words[i].size(); ++j)&#123; if(rows[row].count((char)tolower(words[i][j])) == 0)&#123; validWords.pop_back(); break; &#125; &#125; &#125; return validWords; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) &#123; vector&lt;string&gt; res; unordered_set&lt;char&gt; row1 = &#123;'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'&#125;; unordered_set&lt;char&gt; row2 = &#123;'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'&#125;; unordered_set&lt;char&gt; row3 = &#123;'z', 'x', 'c', 'v', 'b', 'n', 'm'&#125;; vector&lt;unordered_set&lt;char&gt;&gt; rows&#123;row1, row2, row3&#125;; for(int i=0; i&lt;words.size(); i++)&#123; int row; for(int j=0; j&lt;3; j++)&#123; if(rows[j].count(tolower(words[i][0]))&gt;0)&#123; row = j; break; &#125; &#125; res.push_back(words[i]); for(int k=0; k&lt;words[i].size(); k++)&#123; if(rows[row].count(tolower(words[i][k]))==0)&#123; res.pop_back(); break; &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[498. Diagonal Traverse]]></title>
    <url>%2Fp%2Fae6da68b%2F</url>
    <content type="text"><![CDATA[45.8% Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image. 12345678Example:Input:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]Output: [1,2,4,7,5,3,6,8,9] Explanation: Note: The total number of elements of the given matrix will not exceed 10,000. 方法一： https://discuss.leetcode.com/topic/77918/c-without-paying-too-much-attention-on-direction-switch Put all diagonal sequences from top-right to bottom-left to an array and then combine all sequence together by reversing odd sequences. 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(); if (m == 0) return vector&lt;int&gt;(); int n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; tmp (m+n-1); for (int i = 0; i &lt; m+n-1 ; i++) &#123; int row = max(0, i-n+1); int col = min(i, n-1); for (; col &gt;= 0 &amp;&amp; row &lt; m; row++, col--) &#123; tmp[i].push_back(matrix[row][col]); &#125; &#125; vector&lt;int&gt; res; for (int i = 0; i&lt; tmp.size(); i++) &#123; if (i % 2) res.insert(res.end(), tmp[i].begin(), tmp[i].end()); else res.insert(res.end(), tmp[i].rbegin(), tmp[i].rend()); &#125; return res; &#125;&#125;; Some simple modification eliminates the use of a temporary storage. 123456789101112131415vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.size() == 0 || matrix[0].size() == 0) return &#123;&#125;; int m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; res; for (int i = 0; i &lt; m+n-1; i++) &#123; int begin_pos = res.size(); for (int row = max(0, i-n+1), col = min(i, n-1); col &gt;= 0 &amp;&amp; row &lt; m; row++, col--) res.push_back(matrix[row][col]); if (i % 2 == 0) reverse(res.begin() + begin_pos, res.end()); &#125; return res;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[494. Target Sum]]></title>
    <url>%2Fp%2F84bf5c1d%2F</url>
    <content type="text"><![CDATA[44.2% https://leetcode.com/problems/target-sum/?tab=Description You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. 123456789101112Example 1:Input: nums is [1, 1, 1, 1, 1], S is 3. Output: 5Explanation: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3There are 5 ways to assign symbols to make the sum of nums be target 3. Note: The length of the given array is positive and will not exceed 20. The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer. 方法一: dfs 我的代码实现： 123456789101112131415161718class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int cnt = 0; dfs(nums, 0, nums.size(), 0, S, cnt); return cnt; &#125; void dfs(vector&lt;int&gt;&amp; nums, int k, int n, int target, int&amp; S, int&amp; cnt)&#123; if(k==n)&#123; if(target==S) cnt++; return; &#125; dfs(nums, k+1, n, target+nums[k], S, cnt); dfs(nums, k+1, n, target-nums[k], S, cnt); &#125;&#125;; 方法二: 最核心的是发现其中的规律，找到下面的规律，本题目就和题目416是一样的了。 我的代码实现： 12345678910111213141516171819class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); // sum &lt; S 这种情况要考虑到 return (sum+S)&amp;1 || sum &lt; S ? 0 : helper(nums, (sum+S)&gt;&gt;1); &#125; int helper(vector&lt;int&gt;&amp; nums, int target)&#123; vector&lt;int&gt; dp(target+1, 0); dp[0] = 1; // 之所以这样遍历，可以参考416位运算，就是移位相加 // 从后向前遍历保证了不会出错 for(auto num:nums) for(int i=target; i&gt;=num; i--) dp[i] += dp[i-num]; return dp[target]; &#125;&#125;; For example: Given nums = [1, 2, 3, 4, 5] and target = 3 then one possible solution is +1-2+3-4+5 = 3 Here positive subset is P = [1, 3, 5] and negative subset is N = [2, 4] Then let’s see how this can be converted to a subset sum problem: test sum(P) - sum(N) = targetsum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N) 2 * sum(P) = target + sum(nums)So the original problem has been converted to a subset sum problem as follows: Find a subset P of nums such that sum(P) = (target + sum(nums)) / 2 Note that the above formula has proved that target + sum(nums) must be even https://discuss.leetcode.com/topic/76243/java-15-ms-c-3-ms-o-ns-iterative-dp-solution-using-subset-sum-with-explanation Java (15 ms) C++ (3 ms) O(ns) iterative DP solution using subset sum with explanation The recursive solution is very slow, because its runtime is exponential The original problem statement is equivalent to: Find a subset of nums that need to be positive, and the rest of them negative, such that the sum is equal to target Let P be the positive subset and N be the negative subset For example: Given nums = [1, 2, 3, 4, 5] and target = 3 then one possible solution is +1-2+3-4+5 = 3 Here positive subset is P = [1, 3, 5] and negative subset is N = [2, 4] Then let’s see how this can be converted to a subset sum problem: 1234test sum(P) - sum(N) = targetsum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N) 2 * sum(P) = target + sum(nums) So the original problem has been converted to a subset sum problem as follows:Find a subset P of nums such that sum(P) = (target + sum(nums)) / 2 Note that the above formula has proved that target + sum(nums) must be even We can use that fact to quickly identify inputs that do not have a solution (Thanks to @BrunoDeNadaiSarnaglia for the suggestion) For detailed explanation on how to solve subset sum problem, you may refer to Partition Equal Subset Sum Here is Java solution (15 ms) 123456789101112131415public int findTargetSumWays(int[] nums, int s) &#123; int sum = 0; for (int n : nums) sum += n; return sum &lt; s || (s + sum) % 2 &gt; 0 ? 0 : subsetSum(nums, (s + sum) &gt;&gt;&gt; 1); &#125; public int subsetSum(int[] nums, int s) &#123; int[] dp = new int[s + 1]; dp[0] = 1; for (int n : nums) for (int i = s; i &gt;= n; i--) dp[i] += dp[i - n]; return dp[s];&#125; Here is C++ solution (3 ms) 12345678910111213141516class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int s) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); return sum &lt; s || (s + sum) &amp; 1 ? 0 : subsetSum(nums, (s + sum) &gt;&gt; 1); &#125; int subsetSum(vector&lt;int&gt;&amp; nums, int s) &#123; int dp[s + 1] = &#123; 0 &#125;; dp[0] = 1; for (int n : nums) for (int i = s; i &gt;= n; i--) dp[i] += dp[i - n]; return dp[s]; &#125;&#125;; int dp[s + 1] = { 0 }; 上式中=后面是初始化内容，不初始化可能出错。 https://discuss.leetcode.com/topic/76397/c-iterative-with-unordered_map C++ iterative with unordered_map 1234567891011121314151617class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; unordered_map&lt;int, int&gt; ans; ans[0] = 1; for (int n : nums) &#123; unordered_map&lt;int, int&gt; newAns; for (auto p : ans) &#123; int sum = p.first, cnt = p.second; newAns[sum + n] += cnt; newAns[sum - n] += cnt; &#125; ans = newAns; &#125; return ans[S]; &#125;&#125;; https://discuss.leetcode.com/topic/76373/evolve-from-brute-force-to-dp Evolve from brute force to dp This is similar to Partition Equal Subset Sum. O(2^n) brute force 1234567int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; return find(0,nums,S); &#125;int find(int p, vector&lt;int&gt;&amp; nums, int sum) &#123; if(p==nums.size()) return sum==0; return find(p+1,nums,sum+nums[p])+find(p+1,nums,sum-nums[p]);&#125; O(ns) Memoization. There is redundancy in brute force. A call to find with the same start index and target sum can be made multiple times. We can use a 2d table to cache the result to avoid duplicate calls with the same state. 12345678910int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; vector&lt;unordered_map&lt;int,int&gt;&gt; mem(nums.size()); return find(0,nums,S,mem); &#125;int find(int p, vector&lt;int&gt;&amp; nums, int sum, vector&lt;unordered_map&lt;int,int&gt;&gt;&amp; mem) &#123; if(p==nums.size()) return sum==0; auto it = mem[p].find(sum); if(it != mem[p].end()) return it-&gt;second; return mem[p][sum]=find(p+1,nums,sum+nums[p],mem)+find(p+1,nums,sum-nums[p],mem);&#125; O(ns) dp, most dp problems visits continuous states and this is a great example to use hashtable to visit valid states only. 1234567891011int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int n = nums.size(); vector&lt;unordered_map&lt;int,int&gt;&gt; dp(n+1); dp[0][0]=1; for(int i=0;i&lt;n;i++) for(auto &amp;p:dp[i]) &#123; dp[i+1][p.first+nums[i]] += p.second; dp[i+1][p.first-nums[i]] += p.second; &#125; return dp[n][S];&#125; O(ns) time, linear space dp. 123456789101112int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; unordered_map&lt;int,int&gt; cur(&#123;&#123;0,1&#125;&#125;), nxt, *p_cur=&amp;cur, *p_nxt=&amp;nxt; for(int i=0;i&lt;nums.size();i++) &#123; for(auto &amp;p:*p_cur) &#123; (*p_nxt)[p.first+nums[i]] += p.second; (*p_nxt)[p.first-nums[i]] += p.second; &#125; swap(p_cur,p_nxt); p_nxt-&gt;clear(); &#125; return (*p_cur)[S];&#125; O(ns) dp with continuous states. When hashtable is replaced by vector, test cases show significant runtime improvement. #4 is theoretically better because it does not visit invalid states. 12345678910111213141516int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) &#123; int sum = accumulate(nums.begin(),nums.end(),0); if(S&gt;sum || S&lt;-sum) return 0; vector&lt;int&gt; cur(2*sum+1), nxt(2*sum+1), *p_cur = &amp;cur, *p_nxt = &amp;nxt; cur[sum] = 1; for(int i=0;i&lt;nums.size();i++) &#123; for(int j=0;j&lt;=2*sum;j++) if(p_cur-&gt;at(j)) &#123; p_nxt-&gt;at(j+nums[i]) += p_cur-&gt;at(j); p_nxt-&gt;at(j-nums[i]) += p_cur-&gt;at(j); &#125; swap(p_cur,p_nxt); p_nxt-&gt;assign(2*sum+1,0); &#125; return p_cur-&gt;at(S+sum);&#125; python https://discuss.leetcode.com/topic/76205/python-dp Python DP 123456789101112class Solution(object): def findTargetSumWays(self, nums, S): if not nums: return 0 dic = &#123;nums[0]: 1, -nums[0]: 1&#125; if nums[0] != 0 else &#123;0: 2&#125; for i in range(1, len(nums)): tdic = &#123;&#125; for d in dic: tdic[d + nums[i]] = tdic.get(d + nums[i], 0) + dic.get(d, 0) tdic[d - nums[i]] = tdic.get(d - nums[i], 0) + dic.get(d, 0) dic = tdic return dic.get(S, 0) https://discuss.leetcode.com/topic/76650/python-intuitive-dfs-solution-with-memorization Python intuitive DFS solution with memorization At first I just remember the current index and current target, and for each index, either subtract the nums[i] from S or add it to S. But this got TLE, them I came up with this solution. Just store the intermediate result with (index, s) and this got accepted. 1234567891011121314151617181920class Solution(object): def findTargetSumWays(self, nums, S): &quot;&quot;&quot; :type nums: List[int] :type S: int :rtype: int &quot;&quot;&quot; def findTarget(i, s): if (i, s) not in cache: r = 0 if i == len(nums): if s == 0: r = 1 else: r = findTarget(i+1, s-nums[i]) + findTarget(i+1, s+nums[i]) cache[(i, s)] = r return cache[(i, s)] cache = &#123;&#125; return findTarget(0, S)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[493. Reverse Pairs]]></title>
    <url>%2Fp%2Fc54c3d19%2F</url>
    <content type="text"><![CDATA[17.7% Given an array nums, we call (i, j) an important reverse pair if i &lt; j and nums[i] &gt; 2* nums[j]. You need to return the number of important reverse pairs in the given array. 1234Example1:Input: [1,3,2,3,1]Output: 2 1234Example2:Input: [2,4,3,5,1]Output: 3 Note: The length of the given array will not exceed 50,000. All the numbers in the input array are in the range of 32-bit integer. cpp https://discuss.leetcode.com/topic/78993/c-with-iterators C++ with iterators Just a mergesort solution, but using iterators (instead of indexes) and inplace_merge. 1234567891011121314151617181920class Solution &#123;public: int sort_and_count(vector&lt;int&gt;::iterator begin, vector&lt;int&gt;::iterator end) &#123; if (end - begin &lt;= 1) return 0; auto mid = begin + (end - begin) / 2; int count = sort_and_count(begin, mid) + sort_and_count(mid, end); for (auto i = begin, j = mid; i != mid; ++i) &#123; while (j != end and *i &gt; 2L * *j) ++j; count += j - mid; &#125; inplace_merge(begin, mid, end); return count; &#125; int reversePairs(vector&lt;int&gt;&amp; nums) &#123; return sort_and_count(nums.begin(), nums.end()); &#125;&#125;; https://discuss.leetcode.com/topic/78953/c-solution-using-merge-sort C++ Solution using merge sort 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;private: int count; void checkCount(vector&lt;int&gt;&amp; nums, int start, int mid, int end)&#123; // two pointers; int l = start, r = mid + 1; while(l &lt;= mid &amp;&amp; r &lt;= end)&#123; if((long)nums[l] &gt; (long) 2 * nums[r])&#123; count += (mid - l + 1); r++; &#125;else&#123; l++; &#125; &#125; // worst case might be nlog(n) sort(nums.begin() + start, nums.begin() + end + 1); return; //every step sort &#125; void mergeSort(vector&lt;int&gt;&amp; nums, int start, int end)&#123; if(start == end) return; int mid = (start + end)/2; mergeSort(nums,start, mid); mergeSort(nums,mid+1,end); checkCount(nums,start,mid,end); return; &#125;public: int reversePairs(vector&lt;int&gt;&amp; nums) &#123; if(!nums.size())return 0; count = 0; mergeSort(nums,0,nums.size()-1); return count; &#125;&#125;; python https://discuss.leetcode.com/topic/78980/well-explained-o-nlogn-python-solution-based-on-mergesort Well explained O(nlogn) Python Solution based on mergesort Count “important reverse pairs” while doing mergesort: When we’re doing mergesort, original index of elements in left part (smaller side), i, must less than those in right part, j. Simply compare nums[i] and 2* nums[j] and sum them up. Note that those partial lists induced during mergesort here are generated by sorted(), instead of building it one by one. 123456789101112131415161718192021222324class Solution(object): def __init__(self): self.cnt = 0 def reversePairs(self, nums): def msort(lst): # merge sort body L = len(lst) if L &lt;= 1: # base case return lst else: # recursive case return merger(msort(lst[:int(L/2)]), msort(lst[int(L/2):])) def merger(left, right): # merger l, r = 0, 0 # increase l and r iteratively while l &lt; len(left) and r &lt; len(right): if left[l] &lt;= 2*right[r]: l += 1 else: self.cnt += len(left)-l # add here r += 1 return sorted(left+right) # I can&apos;t avoid TLE without timsort... msort(nums) return self.cnt java https://discuss.leetcode.com/topic/78933/very-short-and-clear-mergesort-bst-java-solutions Very Short and Clear MergeSort &amp; BST Java Solutions MergeSort Explanation: In each round, we divide our array into two parts and sort them. So after “int cnt = mergeSort(nums, s, mid) + mergeSort(nums, mid+1, e); “, the left part and the right part are sorted and now our only job is to count how many pairs of number (leftPart[i], rightPart[j]) satisfies leftPart[i] &lt;= 2* rightPart[j].For example,left: 4 6 8 right: 1 2 3so we use two pointers to travel left and right parts. For each leftPart[i], if j&lt;=e &amp;&amp; nums[i]/2.0 &gt; nums[j], we just continue to move j to the end, to increase rightPart[j], until it is valid. Like in our example, left’s 4 can match 1 and 2; left’s 6 can match 1, 2, 3, and left’s 8 can match 1, 2, 3. So in this particular round, there are 8 pairs found, so we increases our total by 8. 12345678910111213141516public class Solution &#123; public int reversePairs(int[] nums) &#123; return mergeSort(nums, 0, nums.length-1); &#125; private int mergeSort(int[] nums, int s, int e)&#123; if(s&gt;=e) return 0; int mid = s + (e-s)/2; int cnt = mergeSort(nums, s, mid) + mergeSort(nums, mid+1, e); for(int i = s, j = mid+1; i&lt;=mid; i++)&#123; while(j&lt;=e &amp;&amp; nums[i]/2.0 &gt; nums[j]) j++; cnt += j-(mid+1); &#125; Arrays.sort(nums, s, e+1); return cnt; &#125;&#125; Or:Because left part and right part are sorted, you can replace the Arrays.sort() part with a actual merge sort process. The previous version is easy to write, while this one is faster. 123456789101112131415161718192021222324252627282930313233public class Solution &#123; int[] helper; public int reversePairs(int[] nums) &#123; this.helper = new int[nums.length]; return mergeSort(nums, 0, nums.length-1); &#125; private int mergeSort(int[] nums, int s, int e)&#123; if(s&gt;=e) return 0; int mid = s + (e-s)/2; int cnt = mergeSort(nums, s, mid) + mergeSort(nums, mid+1, e); for(int i = s, j = mid+1; i&lt;=mid; i++)&#123; while(j&lt;=e &amp;&amp; nums[i]/2.0 &gt; nums[j]) j++; cnt += j-(mid+1); &#125; //Arrays.sort(nums, s, e+1); myMerge(nums, s, mid, e); return cnt; &#125; private void myMerge(int[] nums, int s, int mid, int e)&#123; for(int i = s; i&lt;=e; i++) helper[i] = nums[i]; int p1 = s;//pointer for left part int p2 = mid+1;//pointer for rigth part int i = s;//pointer for sorted array while(p1&lt;=mid || p2&lt;=e)&#123; if(p1&gt;mid || (p2&lt;=e &amp;&amp; helper[p1] &gt;= helper[p2]))&#123; nums[i++] = helper[p2++]; &#125;else&#123; nums[i++] = helper[p1++]; &#125; &#125; &#125;&#125; BSTBST solution is no longer acceptable, because it’s performance can be very bad, O(n^2) actually, for extreme cases like [1,2,3,4……49999], due to the its unbalance, but I am still providing it below just FYI.We build the Binary Search Tree from right to left, and at the same time, search the partially built tree with nums[i]/2.0. The code below should be clear enough. 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123; public int reversePairs(int[] nums) &#123; Node root = null; int[] cnt = new int[1]; for(int i = nums.length-1; i&gt;=0; i--)&#123; search(cnt, root, nums[i]/2.0);//search and count the partially built tree root = build(nums[i], root);//add nums[i] to BST &#125; return cnt[0]; &#125; private void search(int[] cnt, Node node, double target)&#123; if(node==null) return; else if(target == node.val) cnt[0] += node.less; else if(target &lt; node.val) search(cnt, node.left, target); else&#123; cnt[0]+=node.less + node.same; search(cnt, node.right, target); &#125; &#125; private Node build(int val, Node n)&#123; if(n==null) return new Node(val); else if(val == n.val) n.same+=1; else if(val &gt; n.val) n.right = build(val, n.right); else&#123; n.less += 1; n.left = build(val, n.left); &#125; return n; &#125; class Node&#123; int val, less = 0, same = 1;//less: number of nodes that less than this node.val Node left, right; public Node(int v)&#123; this.val = v; &#125; &#125;&#125; Similar to this https://leetcode.com/problems/count-of-smaller-numbers-after-self/. But the main difference is: here, the number to add and the number to search are different (add nums[i], but search nums[i]/2.0), so not a good idea to combine build and search together. https://discuss.leetcode.com/topic/79227/general-principles-behind-problems-similar-to-reverse-pairs General principles behind problems similar to “Reverse Pairs” It looks like a host of solutions are out there (BST-based, BIT-based, Merge-sort-based). Here I’d like to focus on the general principles behind these solutions and its possible application to a number of similar problems. The fundamental idea is very simple: break down the array and solve for the subproblems. A breakdown of an array naturally reminds us of subarrays. To smoothen our following discussion, let’s assume the input array is nums, with a total of n elements. Let nums[i, j] denote the subarray starting from index i to index j (both inclusive), T(i, j) as the same problem applied to this subarray (for example, for Reverse Pairs, T(i, j) will represent the total number of important reverse pairs for subarray nums[i, j]). With the definition above, it’s straightforward to identify our original problem as T(0, n - 1). Now the key point is how to construct solutions to the original problem from its subproblems. This is essentially equivalent to building recurrence relations for T(i, j). Since if we can find solutions to T(i, j) from its subproblems, we surely can build solutions to larger subarrays until eventually the whole array is spanned. While there may be many ways for establishing recurrence relations for T(i, j), here I will only introduce the following two common ones: T(i, j) = T(i, j - 1) + C, i.e., elements will be processed sequentially and C denotes the subproblem for processing the last element of subarray nums[i, j]. We will call this sequential recurrence relation. T(i, j) = T(i, m) + T(m + 1, j) + C where m = (i+j)/2, i.e., subarray nums[i, j] will be further partitioned into two parts and C denotes the subproblem for combining the two parts. We will call this partition recurrence relation. For either case, the nature of the subproblem C will depend on the problem under consideration, and it will determine the overall time complexity of the original problem. So usually it’s crucial to find efficient algorithm for solving this subproblem in order to have better time performance. Also pay attention to possibilities of overlapping subproblems, in which case a dynamic programming (DP) approach would be preferred. Next, I will apply these two recurrence relations to this problem “Reverse Pairs” and list some solutions for your reference. I – Sequential recurrence relation Again we assume the input array is nums with n elements and T(i, j) denotes the total number of important reverse pairs for subarray nums[i, j]. For sequential recurrence relation, we can set i = 0, i.e., the subarray always starts from the beginning. Therefore we end up with: T(0, j) = T(0, j - 1) + C where the subproblem C now becomes “find the number of important reverse pairs with the first element of the pair coming from subarray nums[i, j - 1] while the second element of the pair being nums[j]”. Note that for a pair (p, q) to be an important reverse pair, it has to satisfy the following two conditions: p &lt; q: the first element must come before the second element; nums[p] &gt; 2 * nums[q]: the first element has to be greater than twice of the second element. For subproblem C, the first condition is met automatically; so we only need to consider the second condition, which is equivalent to searching for all elements within subarray nums[i, j - 1] that are greater than twice of nums[j]. The straightforward way of searching would be a linear scan of the subarray, which runs at the order of O(j). From the sequential recurrence relation, this leads to the naive O(n^2) solution. To improve the searching efficiency, a key observation is that the order of elements in the subarray does not matter, since we are only interested in the total number of important reverse pairs. This suggests we may sort those elements and do a binary search instead of a plain linear scan. If the searching space (formed by elements over which the search will be done) is “static” (it does not vary from run to run), placing the elements into an array would be perfect for us to do the binary search. However, this is not the case here. After the j-th element is processed, we need to add it to the searching space so that it becomes searchable for later elements, which renders the searching space expanding as more and more elements are processed. Therefore we’d like to strike a balance between searching and insertion operations. This is where data structures like binary search tree (BST) or binary indexed tree (BIT) prevail, which offers relatively fast performance for both operations. 1. BST-based solution we will define the tree node as follows, where val is the node value and cnt is the total number of elements in the subtree rooted at current node that are greater than or equal to val: 123456789class Node &#123; int val, cnt; Node left, right; Node(int val) &#123; this.val = val; this.cnt = 1; &#125;&#125; The searching and insertion operations can be done as follows: 1234567891011121314151617181920212223242526private int search(Node root, long val) &#123; if (root == null) &#123; return 0; &#125; else if (val == root.val) &#123; return root.cnt; &#125; else if (val &lt; root.val) &#123; return root.cnt + search(root.left, val); &#125; else &#123; return search(root.right, val); &#125;&#125;private Node insert(Node root, int val) &#123; if (root == null) &#123; root = new Node(val); &#125; else if (val == root.val) &#123; root.cnt++; &#125; else if (val &lt; root.val) &#123; root.left = insert(root.left, val); &#125; else &#123; root.cnt++; root.right = insert(root.right, val); &#125; return root;&#125; And finally the main program, in which we will search for all elements no less than twice of current element plus 1 (converted to long type to avoid overflow) while insert the element itself into the BST. Note: this homemade BST is not self-balanced and the time complexity can go as bad as O(n^2) (in fact you will get TLE if you copy and paste the solution here). To guarantee O(nlogn) performance, use one of the self-balanced BST’s (e.g. Red-black tree, AVL tree, etc.). 1234567891011public int reversePairs(int[] nums) &#123; int res = 0; Node root = null; for (int ele : nums) &#123; res += search(root, 2L * ele + 1); root = insert(root, ele); &#125; return res;&#125; 2. BIT-based solution For BIT, the searching and insertion operations are: 1234567891011121314151617private int search(int[] bit, int i) &#123; int sum = 0; while (i &lt; bit.length) &#123; sum += bit[i]; i += i &amp; -i; &#125; return sum;&#125;private void insert(int[] bit, int i) &#123; while (i &gt; 0) &#123; bit[i] += 1; i -= i &amp; -i; &#125;&#125; And the main program, where again we will search for all elements greater than twice of current element while insert the element itself into the BIT. For each element, the “index” function will return its index in the BIT. Unlike the BST-based solution, this is guaranteed to run at O(nlogn). 123456789101112131415161718192021222324252627282930public int reversePairs(int[] nums) &#123; int res = 0; int[] copy = Arrays.copyOf(nums, nums.length); int[] bit = new int[copy.length + 1]; Arrays.sort(copy); for (int ele : nums) &#123; res += search(bit, index(copy, 2L * ele + 1)); insert(bit, index(copy, ele)); &#125; return res;&#125;private int index(int[] arr, long val) &#123; int l = 0, r = arr.length - 1, m = 0; while (l &lt;= r) &#123; m = l + ((r - l) &gt;&gt; 1); if (arr[m] &gt;= val) &#123; r = m - 1; &#125; else &#123; l = m + 1; &#125; &#125; return l + 1;&#125; More explanation for the BIT-based solution: We want the elements to be sorted so there is a sorted version of the input array which is copy. The bit is built upon this sorted array. Its length is one greater than that of the copy array to account for the root. Initially the bit is empty and we start doing a sequential scan of the input array. For each element being scanned, we first search the bit to find all elements greater than twice of it and add the result to res. We then insert the element itself into the bit for future search. Note that conventionally searching of the bit involves traversing towards the root from some index of the bit, which will yield a predefined running total of the copy array up to the corresponding index. For insertion, the traversing direction will be opposite and go from some index towards the end of the bit array. For each scanned element of the input array, its searching index will be given by the index of the first element in the copy array that is greater than twice of it (shifted up by 1 to account for the root), while its insertion index will be the index of the first element in the copy array that is no less than itself (again shifted up by 1). This is what the index function is for. For our case, the running total is simply the number of elements encountered during the traversal process. If we stick to the convention above, the running total will be the number of elements smaller than the one at the given index, since the copy array is sorted in ascending order. However, we’d actually like to find the number of elements greater than some value (i.e., twice of the element being scanned), therefore we need to flip the convention. This is what you see inside the search and insert functions: the former traversing towards the end of the bit while the latter towards the root. II – Partition recurrence relation For partition recurrence relation, setting i = 0, j = n - 1, m = (n-1)/2, we have: T(0, n - 1) = T(0, m) + T(m + 1, n - 1) + C where the subproblem C now reads “find the number of important reverse pairs with the first element of the pair coming from the left subarray nums[0, m] while the second element of the pair coming from the right subarray nums[m + 1, n - 1]”. Again for this subproblem, the first of the two aforementioned conditions is met automatically. As for the second condition, we have as usual this plain linear scan algorithm, applied for each element in the left (or right) subarray. This, to no surprise, leads to the O(n^2) naive solution. Fortunately the observation holds true here that the order of elements in the left or right subarray does not matter, which prompts sorting of elements in both subarrays. With both subarrays sorted, the number of important reverse pairs can be found in linear time by employing the so-called two-pointer technique: one pointing to elements in the left subarray while the other to those in the right subarray and both pointers will go only in one direction due to the ordering of the elements. The last question is which algorithm is best here to sort the subarrays. Since we need to partition the array into halves anyway, it is most natural to adapt it into a Merge-sort. Another point in favor of Merge-sort is that the searching process above can be embedded seamlessly into its merging stage. So here is the Merge-sort-based solution, where the function “reversePairsSub” will return the total number of important reverse pairs within subarray nums[l, r]. The two-pointer searching process is represented by the nested while loop involving variable p, while the rest is the standard merging algorithm. 123456789101112131415161718192021222324252627public int reversePairs(int[] nums) &#123; return reversePairsSub(nums, 0, nums.length - 1);&#125; private int reversePairsSub(int[] nums, int l, int r) &#123; if (l &gt;= r) return 0; int m = l + ((r - l) &gt;&gt; 1); int res = reversePairsSub(nums, l, m) + reversePairsSub(nums, m + 1, r); int i = l, j = m + 1, k = 0, p = m + 1; int[] merge = new int[r - l + 1]; while (i &lt;= m) &#123; while (p &lt;= r &amp;&amp; nums[i] &gt; 2L * nums[p]) p++; res += p - (m + 1); while (j &lt;= r &amp;&amp; nums[i] &gt;= nums[j]) merge[k++] = nums[j++]; merge[k++] = nums[i++]; &#125; while (j &lt;= r) merge[k++] = nums[j++]; System.arraycopy(merge, 0, nums, l, merge.length); return res;&#125; III – Summary Many problems involving arrays can be solved by breaking down the problem into subproblems applied on subarrays and then link the solution to the original problem with those of the subproblems, to which we have sequential recurrence relation and partition recurrence relation. For either case, it’s crucial to identify the subproblem C and find efficient algorithm for approaching it. If the subproblem C involves searching on “dynamic searching space”, try to consider data structures that support relatively fast operations on both searching and updating (such as self-balanced BST, BIT, Segment tree, …). If the subproblem C of partition recurrence relation involves sorting, Merge-sort would be a nice sorting algorithm to use. Also, the code could be made more elegant if the solution to the subproblem can be embedded into the merging process. If there are overlapping among the subproblems T(i, j), it’s preferable to save the intermediate results for future lookup. Last let me name a few leetcode problems that fall into the patterns described above and thus can be solved with similar ideas. 315. Count of Smaller Numbers After Self327. Count of Range Sum For leetcode 315, applying the sequential recurrence relation (with j fixed), the subproblem C reads: find the number of elements out of visited ones that are smaller than current element, which involves searching on “dynamic searching space”; applying the partition recurrence relation, we have a subproblem C: for each element in the left half, find the number of elements in the right half that are smaller than it, which can be embedded into the merging process by noting that these elements are exactly those swapped to its left during the merging process. For leetcode 327, applying the sequential recurrence relation (with j fixed) on the pre-sum array, the subproblem C reads: find the number of elements out of visited ones that are within the given range, which again involves searching on “dynamic searching space”; applying the partition recurrence relation, we have a subproblem C: for each element in the left half, find the number of elements in the right half that are within the given range, which can be embedded into the merging process using the two-pointer technique. Anyway, hope these ideas can sharpen your skills for solving array-related problems. https://discuss.leetcode.com/topic/78950/java-merge-sort-solution-o-nlog-n Java merge sort solution, O(nlog(n)) Similar with count smaller after self, just scan the array before merge 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Solution &#123; public int ret; public int reversePairs(int[] nums) &#123; ret = 0; mergeSort(nums, 0, nums.length-1); return ret; &#125; public void mergeSort(int[] nums, int left, int right) &#123; if (right &lt;= left) &#123; return; &#125; int middle = left + (right - left)/2; mergeSort(nums, left, middle); mergeSort(nums,middle+1, right); //count elements int count = 0; for (int l = left, r = middle+1; l &lt;= middle;) &#123; if (r &gt; right || (long)nums[l] &lt;= 2*(long)nums[r]) &#123; l++; ret += count; &#125; else &#123; r++; count++; &#125; &#125; //merge sort int[] temp = new int[right - left + 1]; for (int l = left, r = middle+1, k = 0; l &lt;= middle || r &lt;= right;) &#123; if (l &lt;= middle &amp;&amp; ((r &gt; right) || nums[l] &lt; nums[r])) &#123; temp[k++] = nums[l++]; &#125; else &#123; temp[k++] = nums[r++]; &#125; &#125; for (int i = 0; i &lt; temp.length; i++) &#123; nums[left + i] = temp[i]; &#125; &#125;&#125; Clearer and simpler version, but slower, got the idea by another solution 123456789101112131415161718192021222324252627282930313233public class Solution &#123; public int ret; public int reversePairs(int[] nums) &#123; ret = 0; mergeSort(nums, 0, nums.length-1); return ret; &#125; public void mergeSort(int[] nums, int left, int right) &#123; if (right &lt;= left) &#123; return; &#125; int middle = left + (right - left)/2; mergeSort(nums, left, middle); mergeSort(nums,middle+1, right); //count elements int count = 0; for (int l = left, r = middle+1; l &lt;= middle;) &#123; if (r &gt; right || (long)nums[l] &lt;= 2*(long)nums[r]) &#123; l++; ret += count; &#125; else &#123; r++; count++; &#125; &#125; //sort Arrays.sort(nums, left, right + 1); &#125;&#125; https://discuss.leetcode.com/topic/78943/clean-java-solution-using-enhanced-binary-search-tree Clean Java Solution using Enhanced Binary Search Tree This is literally the same problem with 315. Count of Smaller Numbers After Self.The only difference is to find count of numbers smaller than half of the current number after itself.To efficiently search for count of numbers smaller than a target, we can use a Binary Search Tree. There is a little change of the TreeNode to include count of numbers smaller or equal to it. This will make the query even faster because we don’t need to traverse all its left sub-tree to get the count. Overall Algorithm: Scan the numbers from right to left. First search the tree to get count of numbers smaller than nums[i] / 2.0, sum to the final result. Insert nums[i] to the tree. Insert logic: Recursively try to find a place to insert this number. When root is null, its time to create a new node. If meet the same number, just increase the count. When try to insert the number to left sub-tree, increase count of current node. Query logic: If target value is greater than the current value, meaning current node and all left sub-tree are smaller than target, return count (remember it stands for count of numbers smaller or equal to current number) of current node plus any possible smaller number than target in right sub-tree. Otherwise, only search left sub-tree. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Solution &#123; class Node &#123; int value, count; Node left, right; Node (int v) &#123; value = v; count = 1; &#125; &#125; public int reversePairs(int[] nums) &#123; int result = 0; if (nums == null || nums.length &lt;= 1) return result; int len = nums.length; Node root = new Node(nums[len - 1]); for(int i = len - 2; i &gt;= 0; i--) &#123; result += query(root, nums[i] / 2.0); insert(root, nums[i]); &#125; return result; &#125; private Node insert(Node root, int value) &#123; if (root == null) return new Node(value); if (root.value == value) &#123; root.count++; &#125; else if (root.value &gt; value) &#123; root.count++; root.left = insert(root.left, value); &#125; else &#123; root.right = insert(root.right, value); &#125; return root; &#125; private int query(Node root, double value) &#123; if (root == null) return 0; if (value &gt; root.value) &#123; return root.count + query(root.right, value); &#125; else &#123; return query(root.left, value); &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>divide and conquer</tag>
        <tag>hard</tag>
        <tag>binary search tree</tag>
        <tag>binary indexed tree</tag>
        <tag>segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[491. Increasing Subsequences]]></title>
    <url>%2Fp%2F1ffd3329%2F</url>
    <content type="text"><![CDATA[38.9% https://leetcode.com/problems/increasing-subsequences/description/ Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 . 123Example:Input: [4, 6, 7, 7]Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]] Note: The length of the given array will not exceed 15. The range of integer in the given array is [-100,100]. The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence. 方法一： 我的代码实现： 值得学习，使用了set 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; paths; vector&lt;int&gt; path; dfs(nums, path, paths, 0); return paths; &#125; void dfs(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; paths, int k)&#123; if(path.size()&gt;1) paths.push_back(path); unordered_set&lt;int&gt; set; for(int i=k; i&lt;nums.size(); i++)&#123; if((!path.size() || nums[i]&gt;=path.back()) &amp;&amp; set.find(nums[i])==set.end())&#123; path.push_back(nums[i]); dfs(nums, path, paths, i+1); path.pop_back(); set.insert(nums[i]); &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/76274/c-dfs-solution-using-unordered_set C++ dfs solution using unordered_set 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; seq; dfs(res, seq, nums, 0); return res; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; seq, vector&lt;int&gt;&amp; nums, int pos) &#123; if(seq.size() &gt; 1) res.push_back(seq); unordered_set&lt;int&gt; hash; for(int i = pos; i &lt; nums.size(); ++i) &#123; if((seq.empty() || nums[i] &gt;= seq.back()) &amp;&amp; hash.find(nums[i]) == hash.end()) &#123; seq.push_back(nums[i]); dfs(res, seq, nums, i + 1); seq.pop_back(); hash.insert(nums[i]); &#125; &#125; &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/76367/evolve-from-intuitive-solution-to-optimal Evolve from intuitive solution to optimal This is similar to Subsets II. O(n2^n) For each number, we can either take it or drop it. Duplicates are removed by set. 123456789101112131415161718vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123; set&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; one; find(0,nums, one, res); return vector&lt;vector&lt;int&gt;&gt;(res.begin(),res.end()); &#125; void find(int p, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; one, set&lt;vector&lt;int&gt;&gt;&amp; res) &#123; if(p==nums.size()) &#123; if(one.size()&gt;1) res.insert(one); return; &#125; if(one.empty()||nums[p]&gt;=one.back()) &#123; one.push_back(nums[p]); find(p+1,nums,one,res); one.pop_back(); &#125; find(p+1,nums,one,res); &#125; 方法三： We can also generate all increasing subsequences by adding each number to the current sequencies iteratively and use set to remove duplicates. 1234567891011121314vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; seq(1); set&lt;vector&lt;int&gt;&gt; bst; for(int i=0;i&lt;nums.size();i++) &#123; int n = seq.size(); for(int j=0;j&lt;n;j++) if(seq[j].empty() || seq[j].back()&lt;=nums[i]) &#123; seq.push_back(seq[j]); seq.back().push_back(nums[i]); if(seq.back().size()&gt;1) bst.insert(seq.back()); &#125; &#125; return vector&lt;vector&lt;int&gt;&gt;(bst.begin(),bst.end()); &#125; 方法四： We can do better by not generating duplicates. When adding a duplicate number to existing sequences, we don’t need to add to all sequences because that will create duplicate sequence. We only need to add to the sequences created since adding this number last time. 1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res(1); unordered_map&lt;int,int&gt; ht; for(int i=0;i&lt;nums.size();i++) &#123; int n = res.size(); int start = ht[nums[i]]; ht[nums[i]] = n; for(int j=start;j&lt;n;j++) if(res[j].empty() || res[j].back()&lt;=nums[i]) &#123; res.push_back(res[j]); res.back().push_back(nums[i]); &#125; &#125; for(int i=res.size()-1;i&gt;=0;i--) if(res[i].size()&lt;2) &#123; swap(res[i],res.back()); res.pop_back(); &#125; return res; &#125; 方法五： Duplicates can also be avoided in recursion. Starting from a given number, we pick the next number. We cache the numbers already tried to avoid duplicates. 123456789101112131415161718vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; one; find(0,nums,one,res); return res; &#125; void find(int p, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; one, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123; int n = nums.size(); if(one.size()&gt;1) res.push_back(one); unordered_set&lt;int&gt; ht; for(int i=p;i&lt;n;i++) &#123; if((!one.empty() &amp;&amp; nums[i] &lt; one.back()) || ht.count(nums[i])) continue; ht.insert(nums[i]); one.push_back(nums[i]); find(i+1,nums,one,res); one.pop_back(); &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[488. Zuma Game]]></title>
    <url>%2Fp%2Ffeb0a0bd%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/zuma-game/ Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand. Each time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed. Find the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1. 1234567891011121314151617Examples:Input: &quot;WRRBBW&quot;, &quot;RB&quot;Output: -1Explanation: WRRBBW -&gt; WRR[R]BBW -&gt; WBBW -&gt; WBB[B]W -&gt; WWInput: &quot;WWRRBBWW&quot;, &quot;WRBRW&quot;Output: 2Explanation: WWRRBBWW -&gt; WWRR[R]BBWW -&gt; WWBBWW -&gt; WWBB[B]WW -&gt; WWWW -&gt; emptyInput:&quot;G&quot;, &quot;GGGGG&quot;Output: 2Explanation: G -&gt; G[G] -&gt; GG[G] -&gt; empty Input: &quot;RBYYBBRRB&quot;, &quot;YRBGB&quot;Output: 3Explanation: RBYYBBRRB -&gt; RBYY[Y]BBRRB -&gt; RBBBRRB -&gt; RRRB -&gt; B -&gt; B[B] -&gt; BB[B] -&gt; empty Note: You may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color. The number of balls on the table won’t exceed 20, and the string represents these balls is called “board” in the input. The number of balls in your hand won’t exceed 5, and the string represents these balls is called “hand” in the input. Both input strings will be non-empty and only contain characters ‘R’,’Y’,’B’,’G’,’W’. java https://discuss.leetcode.com/topic/75434/recursive-java-solution Recursive java solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class Solution &#123; public int findMinStep(String board, String hand) &#123; List&lt;Character&gt; boardList = new ArrayList&lt;Character&gt;(); for (char c : board.toCharArray()) &#123; boardList.add(c); &#125; Map&lt;Character,Integer&gt; handMap = new HashMap&lt;&gt;(); handMap.put(&apos;R&apos;,0); handMap.put(&apos;Y&apos;,0); handMap.put(&apos;B&apos;,0); handMap.put(&apos;G&apos;,0); handMap.put(&apos;W&apos;,0); for (char h : hand.toCharArray()) &#123; handMap.put(h, handMap.get(h) + 1); &#125; return find(boardList, handMap); &#125; private int find(List&lt;Character&gt; board, Map&lt;Character, Integer&gt; hand) &#123; cleanupBoard(board); if (board.size() == 0) return 0; if (empty(hand)) return -1; int count = 0; int min = Integer.MAX_VALUE; for (int i = 0; i&lt;board.size(); i++) &#123; char c = board.get(i); count++; if (i == board.size() - 1 || board.get(i+1) != c) &#123; int missing = 3 - count; if (hand.get(c) &gt;= missing) &#123; hand.put(c, hand.get(c) - missing); List&lt;Character&gt; smallerBoard = new ArrayList&lt;&gt;(board); for (int j = 0; j&lt;count; j++) &#123; smallerBoard.remove(i-j); &#125; int smallerFind = find(smallerBoard, hand); if ( smallerFind != -1 ) &#123; min = Math.min(smallerFind + missing, min); &#125; hand.put(c, hand.get(c) + missing); &#125; count = 0; &#125; &#125; return (min == Integer.MAX_VALUE) ? -1 : min; &#125; private void cleanupBoard(List&lt;Character&gt; board) &#123; int count = 0; boolean cleaned = false; for (int i = 0; i&lt;board.size(); i++) &#123; char c = board.get(i); count++; if (i == board.size() - 1 || board.get(i+1) != c) &#123; if (count &gt;= 3) &#123; for (int j = 0; j&lt;count; j++) &#123; board.remove(i-j); &#125; cleaned = true; break; &#125; count = 0; &#125; &#125; if (cleaned) &#123; cleanupBoard(board); &#125; &#125; private boolean empty(Map&lt;Character,Integer&gt; hand) &#123; for (int val : hand.values()) &#123; if (val &gt; 0) return false; &#125; return true; &#125;&#125; https://discuss.leetcode.com/topic/75447/search-and-memorize-java-solution Search and memorize Java solution Just searching and memorizing… It is not a good interview question because many codes are not related to the algorithm. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class Solution &#123; public int findMinStep(String board, String hand) &#123; HashMap&lt;Character, int[]&gt; mhand = new HashMap&lt;Character, int[]&gt;(); mhand.put(&apos;R&apos;, new int[]&#123;0&#125;); mhand.put(&apos;Y&apos;, new int[]&#123;0&#125;); mhand.put(&apos;B&apos;, new int[]&#123;0&#125;); mhand.put(&apos;G&apos;, new int[]&#123;0&#125;); mhand.put(&apos;W&apos;, new int[]&#123;0&#125;); for(char c:hand.toCharArray())&#123; mhand.get(c)[0]++; &#125; HashMap&lt;String, Integer&gt; record = new HashMap&lt;String, Integer&gt;(); int min = helper(board, mhand, record); if(min&gt;=10000)&#123; return -1; &#125; else &#123; return min; &#125; &#125; int helper(String board, HashMap&lt;Character, int[]&gt; hand, HashMap&lt;String, Integer&gt; record)&#123; if(board.length()==0)&#123; return 0; &#125; else &#123; int min = 10000; for(int i=0;i&lt;board.length();i++)&#123; if(hand.get(board.charAt(i))[0]&gt;0)&#123; hand.get(board.charAt(i))[0]--; String newboard = board.substring(0,i)+board.charAt(i)+board.substring(i); newboard = further(newboard); String c = code(newboard, hand); if(record.containsKey(c))&#123; min = Math.min(min, 1+record.get(c)); &#125; else &#123; int s = helper(newboard, hand, record); min = Math.min(min, 1+s); record.put(c, s); &#125; hand.get(board.charAt(i))[0]++; &#125; &#125; return min; &#125; &#125; String further(String board)&#123; if(board.length()==0)&#123; return &quot;&quot;; &#125; int count=1; for(int i=1;i&lt;board.length();i++)&#123; if(board.charAt(i-1)==board.charAt(i))&#123; count++; &#125; else &#123; if(count&gt;=3)&#123; return further(board.substring(0, i-count)+board.substring(i)); &#125; else &#123; count=1; &#125; &#125; &#125; if(count&gt;=3)&#123; return board.substring(0, board.length()-count); &#125; return board; &#125; String code(String board, HashMap&lt;Character, int[]&gt; hand)&#123; StringBuilder sb = new StringBuilder(); sb.append(board); for(Map.Entry&lt;Character, int[]&gt; e: hand.entrySet())&#123; sb.append(e.getKey()); sb.append(e.getValue()[0]); &#125; return sb.toString(); &#125;&#125; https://discuss.leetcode.com/topic/75460/java-bfs-solution Java BFS solution For each iteration, we find all the possible ways to insert a ball according to the current state. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class Solution &#123; Map&lt;Character, Integer&gt; colorId = new HashMap&lt;&gt;(); public int findMinStep(String board, String hand) &#123; String color = &quot;RYWBG&quot;; List&lt;Integer&gt; handBall = new ArrayList&lt;&gt;(Arrays.asList(0,0,0,0,0)); int index = 0; for(char c : color.toCharArray())&#123; colorId.put(c, index ++); &#125; for(char ball : hand.toCharArray())&#123; handBall.set(colorId.get(ball), handBall.get(colorId.get(ball)) + 1); &#125; return BFS(new StringBuilder(board), handBall); &#125; public int BFS(StringBuilder board, List&lt;Integer&gt; handBall)&#123; Queue&lt;State&gt; queue = new LinkedList&lt;&gt;(); Set&lt;String&gt; nextBoardSet = new HashSet&lt;&gt;(); queue.offer(new State(board, handBall)); int ans = 0; while(!queue.isEmpty())&#123; int size = queue.size(); ans ++; while(size -- &gt; 0)&#123; State currentState = queue.poll(); StringBuilder currentBoard = currentState.board; List&lt;Integer&gt; currentHandBall = currentState.handBall; for(int start = 0, end = start + 1; start &lt; currentBoard.length(); start = end, end++)&#123; while(end &lt; currentBoard.length() &amp;&amp; currentBoard.charAt(end) == currentBoard.charAt(end - 1))&#123; end ++; &#125; int number = end - start; int colorIndex = colorId.get(currentBoard.charAt(start)); if(currentHandBall.get(colorIndex) &lt; 3 - number)&#123; continue; &#125; else&#123; StringBuilder nextBoard = new StringBuilder(currentBoard.toString()); if(number == 2)&#123; nextBoard.delete(start, end); nextBoard = reduce(nextBoard); if(nextBoard.length() == 0)&#123; return ans; &#125; &#125; else&#123; nextBoard.insert(end, currentBoard.charAt(start)); &#125; if(!nextBoardSet.add(nextBoard.toString()))&#123; continue; &#125; List&lt;Integer&gt; nextHandBall = new ArrayList&lt;&gt;(); nextHandBall.addAll(currentHandBall); nextHandBall.set(colorIndex, nextHandBall.get((colorIndex)) - 1); queue.offer(new State(nextBoard, nextHandBall)); &#125; &#125; &#125; &#125; return -1; &#125; public StringBuilder reduce(StringBuilder nextBoard)&#123; String board = nextBoard.toString(); String tmp = board.replaceAll(&quot;([RYBGW])\\1&#123;2,&#125;&quot;,&quot;&quot;); while (tmp.length() != board.length()) &#123; board = tmp; tmp = board.replaceAll(&quot;([RYBGW])\\1&#123;2,&#125;&quot;,&quot;&quot;); &#125; return new StringBuilder(tmp); &#125; &#125;class State &#123; StringBuilder board; List&lt;Integer&gt; handBall = new ArrayList&lt;&gt;(); public State(StringBuilder board, List&lt;Integer&gt; handBall)&#123; this.board = board; this.handBall = handBall; &#125;&#125; cpp https://discuss.leetcode.com/topic/75465/concise-3ms-c-solution Concise 3ms C++ Solution At the first look, it is similar to Can I Win. But not like that problem, the board state is not relevant to the state of hand and this problem requires the minimum value. So, it seems that memorization might not help much. So, I just do it brute-force and stop iff it is sure there no better results than current one. Sort hand string so that we easily know if there at least 2 balls with same color in hand to eliminate a single ball on board. Refer to inline comments for details. According to the description, the number of balls in hand won’t exceed 5, to make life easier, I just return a number equal or greater than 6 when there is no way to clear board. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#define MAX_STEP 6 class Solution &#123;public: int findMinStep(string board, string hand) &#123; sort(hand.begin(), hand.end()); int res = helper(board, hand); return res &gt; hand.size() ? -1 : res; &#125; int helper(string b, string h) &#123; if (b.empty()) return 0; if (h.empty()) return MAX_STEP; int res = MAX_STEP; for (int i = 0; i &lt; h.size(); i++) &#123; int j = 0; int n = b.size(); while (j &lt; n) &#123; int k = b.find(h[i], j); if (k == string::npos) break; if (k &lt; n-1 &amp;&amp; b[k] == b[k+1]) &#123; // 2 consecutive balls with same color on board string nextb = shrink(b.substr(0, k) + b.substr(k+2)); // shrink the string until no 3 or more consecutive balls in same color if (nextb.empty()) return 1; // this is the best result for current board, no need to continue string nexth = h; nexth.erase(i, 1); // remove the used ball from hand res = min(res, helper(nextb, nexth) + 1); k++; &#125; else if (i &gt; 0 &amp;&amp; h[i] == h[i-1]) &#123; // 2 balls with same color in hand string nextb = shrink(b.substr(0, k) + b.substr(k+1)); // shrink the string until no 3 or more consecutive balls in same color if (nextb.empty()) return 2; // this is the best result for current board, no need to continue string nexth = h; nexth.erase(i, 1); // remove the used balls from hand nexth.erase(i-1, 1); res = min(res, helper(nextb, nexth) + 2); &#125; j = k + 1; &#125; &#125; return res; &#125; string shrink(string s) &#123; while(s.size() &gt; 0) &#123; int start = 0; bool done = true; for (int i = 0; i &lt;= s.size(); i++) &#123; if (i == s.size() || s[i] != s[start]) &#123; if (i - start &gt;= 3) &#123; s = s.substr(0, start) + s.substr(i); done = false; break; &#125; start = i; &#125; &#125; if (done) break; &#125; return s; &#125;&#125;; https://discuss.leetcode.com/topic/75448/memoization-c-solution memoization c++ solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Solution &#123;public: bool removeCon(std::string&amp; str) &#123; int con = 1; for (size_t i = 1; i &lt; str.size(); i++) &#123; if (str[i] == str[i - 1]) &#123; con++; &#125; else &#123; if (con &gt;= 3) &#123; str.erase(i - con, con); return true; &#125; con = 1; &#125; &#125; if (con &gt;= 3) &#123; str.erase(str.size() - con, con); return true; &#125; return false; &#125; int solve(string board, string hand) &#123; while (removeCon(board)); if (board.empty()) &#123; return 0; &#125; if (hand.empty() || board.size() + hand.size() &lt; 3) &#123; return -1; &#125; auto it = f.find(std::make_pair(board, hand)); if (it != f.end()) &#123; return it-&gt;second; &#125; int best = -1; for (size_t i = 0; i &lt; hand.size(); i++) &#123; for (size_t j = 0; j &lt; board.size(); j++) &#123; if (board[j] == hand[i]) &#123; std::string new_board = board; std::string new_hand = hand; new_board.insert(new_board.begin() + j, hand[i]); new_hand.erase(i, 1); int ret = solve(new_board, new_hand); if (ret &gt; -1) &#123; if (best == -1) &#123; best = ret + 1; &#125; else &#123; best = std::min(best, ret + 1); &#125; &#125; &#125; &#125; &#125; f[std::make_pair(board, hand)] = best; return best; &#125; int findMinStep(string board, string hand) &#123; f.clear(); std::sort(hand.begin(), hand.end()); return solve(board, hand); &#125; std::map&lt;std::pair&lt;std::string, std::string&gt;, int&gt; f;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[485. Max Consecutive Ones]]></title>
    <url>%2Fp%2F3637e9ae%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/max-consecutive-ones/ Given a binary array, find the maximum number of consecutive 1s in this array. 12345Example 1:Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note: The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 java https://discuss.leetcode.com/topic/75437/java-4-lines-concise-solution-with-explanation Java 4 lines concise solution with explanation 123456public int findMaxConsecutiveOnes(int[] nums) &#123; int maxHere = 0, max = 0; for (int n : nums) max = Math.max(max, maxHere = n == 0 ? 0 : maxHere + 1); return max; &#125; The idea is to reset maxHere to 0 if we see 0, otherwise increase maxHere by 1The max of all maxHere is the solution 1234567891011121314151617110111^ maxHere = 1110111.^ maxHere = 2110111..^ maxHere = 0110111...^ maxHere = 1110111....^ maxHere = 2110111.....^ maxHere = 3 We can also solve this problem by setting k = 0 of Max Consecutive Ones II https://discuss.leetcode.com/topic/75430/easy-java-solution Easy Java Solution This is a really easy problem. No explanation :) 12345678910111213141516public class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; int result = 0; int count = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == 1) &#123; count++; result = Math.max(count, result); &#125; else count = 0; &#125; return result; &#125;&#125; https://discuss.leetcode.com/topic/75470/concise-java-solution-without-if Concise Java Solution without “if”. 1234567891011public class Solution &#123; public int findMaxConsecutiveOnes(int[] nums) &#123; int maxSum = 0, sum = 0; for (int n : nums) &#123; sum *= n; sum += n; maxSum = Math.max(maxSum, sum); &#125; return maxSum; &#125;&#125; python https://discuss.leetcode.com/topic/75425/simple-python Simple Python 1234567891011class Solution(object): def findMaxConsecutiveOnes(self, nums): cnt = 0 ans = 0 for num in nums: if num == 1: cnt += 1 ans = max(ans, cnt) else: cnt = 0 return ans]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[482. License Key Formatting]]></title>
    <url>%2Fp%2F5c06d216%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/license-key-formatting/ Now you are given a string S, which represents a software license key which we would like to format. The string S is composed of alphanumerical characters and dashes. The dashes split the alphanumerical characters within the string into groups. (i.e. if there are M dashes, the string is split into M+1 groups). The dashes in the given string are possibly misplaced. We want each group of characters to be of length K (except for possibly the first group, which could be shorter, but still must contain at least one character). To satisfy this requirement, we will reinsert dashes. Additionally, all the lower case letters in the string must be converted to upper case. So, you are given a non-empty string S, representing a license key to format, and an integer K. And you need to return the license key formatted according to the description above. 123456Example 1:Input: S = &quot;2-4A0r7-4k&quot;, K = 4Output: &quot;24A0-R74K&quot;Explanation: The string S has been split into two parts, each part has 4 characters. 1234567Example 2:Input: S = &quot;2-4A0r7-4k&quot;, K = 3Output: &quot;24-A0R-74K&quot;Explanation: The string S has been split into three parts, each part has 3 characters except the first part as it could be shorter as said above. Note: The length of string S will not exceed 12,000, and K is a positive integer. String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-). String S is non-empty. java https://discuss.leetcode.com/topic/74995/java-5-lines-clean-solution Java 5 lines clean solution 1234567public String licenseKeyFormatting(String s, int k) &#123; StringBuilder sb = new StringBuilder(); for (int i = s.length() - 1; i &gt;= 0; i--) if (s.charAt(i) != &apos;-&apos;) sb.append(sb.length() % (k + 1) == k ? &apos;-&apos; : &quot;&quot;).append(s.charAt(i)); return sb.reverse().toString().toUpperCase();&#125; https://discuss.leetcode.com/topic/75182/easy-understand-java-solution-using-stringbuilder Easy Understand Java solution using StringBuilder 12345678910111213141516171819202122232425public class Solution &#123; public String licenseKeyFormatting(String S, int K) &#123; String[] strs = S.split(&quot;-&quot;); StringBuilder rst = new StringBuilder(); int gap = &apos;A&apos; - &apos;a&apos;; for (String str : strs) &#123; rst.append(str); &#125; int len = rst.length(); for (int i = 0; i &lt; len; i++) &#123; char c = rst.charAt(i); if (c&gt;=&apos;a&apos; &amp;&amp; c&lt;=&apos;z&apos;) &#123; rst.setCharAt(i, (char)(c+gap)); &#125; &#125; for (int i = len-K; i &gt; 0; i -= K) &#123; rst.insert(i, &apos;-&apos;); &#125; return rst.toString(); &#125;&#125; cpp https://discuss.leetcode.com/topic/74993/4-line-c-concise-solution-to-scan-string-backward 4-line C++ concise solution to scan string backward Key observation: every (K+1)th character from tail in formatted string must be a ‘-‘. 123456string licenseKeyFormatting(string S, int K) &#123; string res; for (auto i = S.rbegin(); i &lt; S.rend(); i++) if (*i != &apos;-&apos;) (res.size()%(K+1)-K? res : res+=&apos;-&apos;) += toupper(*i); return reverse(res.begin(), res.end()), res;&#125; python https://discuss.leetcode.com/topic/74891/python-solution Python solution 123456789101112131415class Solution(object): def licenseKeyFormatting(self, S, K): &quot;&quot;&quot; :type S: str :type K: int :rtype: str &quot;&quot;&quot; S = S.upper().replace(&apos;-&apos;,&apos;&apos;) size = len(S) s1 = K if size%K==0 else size%K res = S[:s1] while s1&lt;size: res += &apos;-&apos;+S[s1:s1+K] s1 += K return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[481. Magical String]]></title>
    <url>%2Fp%2F20aa09b0%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/magical-string/ A magical string S consists of only ‘1’ and ‘2’ and obeys the following rules: The string S is magical because concatenating the number of contiguous occurrences of characters ‘1’ and ‘2’ generates the string S itself. The first few elements of string S is the following: S = “1221121221221121122……” If we group the consecutive ‘1’s and ‘2’s in S, it will be: 1 22 11 2 1 22 1 22 11 2 11 22 …… and the occurrences of ‘1’s or ‘2’s in each group are: 1 2 2 1 1 2 1 2 2 1 2 2 …… You can see that the occurrence sequence above is the S itself. Given an integer N as input, return the number of ‘1’s in the first N number in the magical string S. Note: N will not exceed 100,000. 1234Example 1:Input: 6Output: 3Explanation: The first 6 elements of magical string S is &quot;12211&quot; and it contains three 1&apos;s, so return 3. java https://discuss.leetcode.com/topic/74917/simple-java-solution-using-one-array-and-two-pointers Simple Java solution using one array and two pointers Algorithm: Create an int array a and initialize the first 3 elements with 1, 2, 2. Create two pointers head and tail. head points to the number which will be used to generate new numbers. tail points to the next empty position to put the new number. Then keep generating new numbers until tail &gt;= n. Need to create the array 1 element more than n to avoid overflow because the last round head might points to a number 2. A trick to flip number back and forth between 1 and 2: num = num ^ 3 12345678910111213141516171819202122public class Solution &#123; public int magicalString(int n) &#123; if (n &lt;= 0) return 0; if (n &lt;= 3) return 1; int[] a = new int[n + 1]; a[0] = 1; a[1] = 2; a[2] = 2; int head = 2, tail = 3, num = 1, result = 1; while (tail &lt; n) &#123; for (int i = 0; i &lt; a[head]; i++) &#123; a[tail] = num; if (num == 1 &amp;&amp; tail &lt; n) result++; tail++; &#125; num = num ^ 3; head++; &#125; return result; &#125;&#125; https://discuss.leetcode.com/topic/74896/very-straightforward-and-simple-java-solution-o-n Very Straightforward and simple Java solution O(n) 1234567891011121314151617181920public int magicalString(int n) &#123; StringBuilder magic = new StringBuilder(&quot;1221121221221121122&quot;); int pt1 = 12, pt2 = magic.length(), count = 0; //initiate pointers //generate sequence directly while(magic.length() &lt; n)&#123; if(magic.charAt(pt1) == &apos;1&apos;)&#123; if(magic.charAt(pt2-1) == &apos;1&apos;) magic.append(2); else magic.append(1); pt2++; &#125;else&#123; //==2 if(magic.charAt(pt2-1) == &apos;1&apos;) magic.append(22); else magic.append(11); pt2+=2; &#125; pt1++; &#125; for(int i=0;i&lt;n;i++) if(magic.charAt(i)==&apos;1&apos;) count++; return count; &#125; https://discuss.leetcode.com/topic/75273/o-log-n-space-java O(log n) space Java Based on my Python solution. Here I use a helper class giving me the Kolakoski sequence (that’s its name) one element at a time with its next method. It has the first three elements hard-coded, and after that, it uses another instance of the sequence to iterate further. That other instance does the same, so it might eventually use yet another instance. And so on, O(log n) nested Kolakoski objects iterating in parallel at different speeds as needed. Takes O(log n) space and O(n) time. 123456789101112131415161718192021222324252627282930public class Solution &#123; public int magicalString(int n) &#123; Kolakoski kolakoski = new Kolakoski(); int ones = 0; while (n-- &gt; 0) if (kolakoski.next() == 1) ones++; return ones; &#125; private class Kolakoski &#123; private int[] queue = &#123;1, 2, 2&#125;; private int first = 0, last = 2; private Kolakoski source; int next() &#123; if (first &gt; last) &#123; if (source == null) &#123; source = new Kolakoski(); source.next(); source.next(); &#125; int output = queue[last % 3] ^ 3; for (int k = source.next(); k &gt; 0; k--) queue[++last % 3] = output; &#125; return queue[first++ % 3]; &#125; &#125;&#125; https://discuss.leetcode.com/topic/75067/simple-java-solution Simple Java Solution 12345678910111213141516171819202122public int magicalString(int n) &#123; if(n==0)return 0; if(n==1)return 1; StringBuilder sb= new StringBuilder(n); sb.append(&quot;122&quot;); int count=1; int i=2; while (sb.length()&lt;n)&#123; if(sb.charAt(i)==&apos;1&apos;)&#123; boolean one=sb.charAt(sb.length()-1) ==&apos;1&apos;; count+=one ? 0: 1; sb.append(one ? 2 : 1); &#125;else&#123; boolean one=sb.charAt(sb.length()-1) ==&apos;1&apos;; count+=one ? 0: 2; sb.append(one ? 22 : 11); &#125; i++; &#125; if(sb.length()&gt;n &amp;&amp; sb.charAt(sb.length()-1)==&apos;1&apos;)count--; return count; &#125; cpp https://discuss.leetcode.com/topic/74637/short-c Short C++ Just build enough of the string and then count. 1234567int magicalString(int n) &#123; string S = &quot;122&quot;; int i = 2; while (S.size() &lt; n) S += string(S[i++] - &apos;0&apos;, S.back() ^ 3); return count(S.begin(), S.begin() + n, &apos;1&apos;);&#125; python https://discuss.leetcode.com/topic/74640/short-python-using-queue Short Python using queue Since how many current “1” or “2” depends on previous number in S, we can use a queue to get the corresponding information we need. Every time we update S, we update queue as well. Updated: based @StefanPochmann ‘s idea, we can only use an index to indict current number of value we need. 123456789101112class Solution(object): def magicalString(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; S = [1,2,2] idx = 2 while len(S) &lt; n: S += S[idx] * [(3 - S[-1])] idx += 1 return S[:n].count(1) Old version: 123456789101112131415class Solution(object): def magicalString(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; queue = collections.deque([2]) S = [1,2,2] while len(S) &lt; n: k = queue.popleft() tmp = 3 - S[-1] for i in range(k): S.append(tmp) queue.append(tmp) return S[:n].count(1) https://discuss.leetcode.com/topic/75242/o-log-n-space-using-recursive-generators O(log n) space using recursive generators There’s a paper called A Space-Efficient Algorithm for Calculating the Digit Distribution in the Kolakoski Sequence about an O(log n) space and O(n) time algorithm. I didn’t read the paper but wrote my code based on Figure 1 on page 3. I use one generator per level, and to get things going, I hardcode the first three digits caused by the first two digits of the level above (which I therefore ignore). 123456789def magicalString(self, n): def gen(): for x in 1, 2, 2: yield x for i, x in enumerate(gen()): if i &gt; 1: for _ in range(x): yield i % 2 + 1 return sum(x &amp; 1 for x in itertools.islice(gen(), n)) I think it’s O(log n) space and O(n) time. Here are test results for different n, counting the numbers of generators and yields to measure space and time: 123456789101112&apos;test&apos; n generators yields (=space) (=time) 1 1 1 10 4 25 100 10 295 1000 16 3001 10000 22 30028 100000 27 299935 1000000 33 2999958 10000000 39 29999888 100000000 44 300001534 The number of generators is very close to log1.5(n), which makes sense because apparently there are about equally many ones and twos in any prefix of the sequence, so on average one digit in a generator causes 1.5 digits in the generator using it. The number of yields is very close to 3n, which also makes sense. The outermost generator yields n times, the generator it uses yields about (2/3)n times, the next inner generator yields about (2/3)2n times, and so on. So the total number of yields is about:n ⋅ ∑i=0..∞ (2/3)i = n ⋅ 1/(1-2/3) = 3n Here’s the testing code: 123456789101112131415161718192021222324import itertoolsclass Solution(object): def magicalString(self, n): def gen(): global generators, yields generators += 1 for x in 1, 2, 2: yields += 1 yield x for i, x in enumerate(gen()): if i &gt; 1: for _ in range(x): yields += 1 yield i % 2 + 1 return sum(x &amp; 1 for x in itertools.islice(gen(), n))print &apos; n generators yields&apos;print &apos; (=space) (=time)&apos;for e in range(9): n = 10**e generators = yields = 0 Solution().magicalString(n) print &apos;%10d&apos; * 3 % (n, generators, yields)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[480. Sliding Window Median]]></title>
    <url>%2Fp%2Fcad37328%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/sliding-window-median/ Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. 1234Examples: [2,3,4] , the median is 3[2,3], the median is (2 + 3) / 2 = 2.5 Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array. 123456789101112For example,Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.Window position Median--------------- -----[1 3 -1] -3 5 3 6 7 1 1 [3 -1 -3] 5 3 6 7 -1 1 3 [-1 -3 5] 3 6 7 -1 1 3 -1 [-3 5 3] 6 7 3 1 3 -1 -3 [5 3 6] 7 5 1 3 -1 -3 5 [3 6 7] 6Therefore, return the median sliding window as [1,-1,-1,3,5,6]. Note: You may assume k is always valid, ie: 1 ≤ k ≤ input array’s size for non-empty array. java https://discuss.leetcode.com/topic/74724/java-solution-using-two-priorityqueues Java solution using two PriorityQueues Almost the same idea of Find Median from Data Stream https://leetcode.com/problems/find-median-from-data-stream/ Use two Heaps to store numbers. maxHeap for numbers smaller than current median, minHeap for numbers bigger than and equal to current median. A small trick I used is always make size of minHeap equal (when there are even numbers) or 1 element more (when there are odd numbers) than the size of maxHeap. Then it will become very easy to calculate current median. Keep adding number from the right side of the sliding window and remove number from left side of the sliding window. And keep adding current median to the result. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Solution &#123; PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;Integer&gt;(); PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;( new Comparator&lt;Integer&gt;() &#123; public int compare(Integer i1, Integer i2) &#123; return i2.compareTo(i1); &#125; &#125; ); public double[] medianSlidingWindow(int[] nums, int k) &#123; int n = nums.length - k + 1; if (n &lt;= 0) return new double[0]; double[] result = new double[n]; for (int i = 0; i &lt;= nums.length; i++) &#123; if (i &gt;= k) &#123; result[i - k] = getMedian(); remove(nums[i - k]); &#125; if (i &lt; nums.length) &#123; add(nums[i]); &#125; &#125; return result; &#125; private void add(int num) &#123; if (num &lt; getMedian()) &#123; maxHeap.add(num); &#125; else &#123; minHeap.add(num); &#125; if (maxHeap.size() &gt; minHeap.size()) &#123; minHeap.add(maxHeap.poll()); &#125; if (minHeap.size() - maxHeap.size() &gt; 1) &#123; maxHeap.add(minHeap.poll()); &#125; &#125; private void remove(int num) &#123; if (num &lt; getMedian()) &#123; maxHeap.remove(num); &#125; else &#123; minHeap.remove(num); &#125; if (maxHeap.size() &gt; minHeap.size()) &#123; minHeap.add(maxHeap.poll()); &#125; if (minHeap.size() - maxHeap.size() &gt; 1) &#123; maxHeap.add(minHeap.poll()); &#125; &#125; private double getMedian() &#123; if (maxHeap.isEmpty() &amp;&amp; minHeap.isEmpty()) return 0; if (maxHeap.size() == minHeap.size()) &#123; return ((double)maxHeap.peek() + (double)minHeap.peek()) / 2.0; &#125; else &#123; return (double)minHeap.peek(); &#125; &#125;&#125; cpp https://discuss.leetcode.com/topic/74963/o-n-log-k-c-using-multiset-and-updating-middle-iterator Keep the window elements in a multiset and keep an iterator pointing to the middle value (to “index” k/2, to be precise). Thanks to @votrubac’s solution and comments. 123456789101112131415161718192021222324vector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; multiset&lt;int&gt; window(nums.begin(), nums.begin() + k); auto mid = next(window.begin(), k / 2); vector&lt;double&gt; medians; for (int i=k; ; i++) &#123; // Push the current median. medians.push_back((double(*mid) + *next(mid, k%2 - 1)) / 2); // If all done, return. if (i == nums.size()) return medians; // Insert nums[i]. window.insert(nums[i]); if (nums[i] &lt; *mid) mid--; // Erase nums[i-k]. if (nums[i-k] &lt;= *mid) mid++; window.erase(window.lower_bound(nums[i-k])); &#125;&#125; https://discuss.leetcode.com/topic/74679/o-n-log-n-time-c-solution-using-two-heaps-and-a-hash-table O(n* log(n)) Time C++ Solution Using Two Heaps and a Hash Table There are a few solutions using BST with worst case time complexity O(n*k), but we know k can be become large. I wanted to come up with a solution that is guaranteed to run in O(n* log(n)) time. This is in my opinion the best solution so far. The idea is inspired by solutions to Find Median from Data Stream: use two heaps to store numbers in the sliding window. However there is the issue of numbers moving out of the window, and it turns out that a hash table that records these numbers will just work (and is surprisingly neat). The recorded numbers will only be deleted when they come to the top of the heaps. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;double&gt; medians; unordered_map&lt;int, int&gt; hash; // count numbers to be deleted priority_queue&lt;int, vector&lt;int&gt;&gt; bheap; // heap on the bottom priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; theap; // heap on the top int i = 0; // Initialize the heaps while (i &lt; k) &#123; bheap.push(nums[i++]); &#125; for (int count = k/2; count &gt; 0; --count) &#123; theap.push(bheap.top()); bheap.pop(); &#125; while (true) &#123; // Get median if (k % 2) medians.push_back(bheap.top()); else medians.push_back( ((double)bheap.top() + theap.top()) / 2 ); if (i == nums.size()) break; int m = nums[i-k], n = nums[i++], balance = 0; // What happens to the number m that is moving out of the window if (m &lt;= bheap.top()) &#123; --balance; if (m == bheap.top()) bheap.pop(); else ++hash[m]; &#125; else &#123; ++balance; if (m == theap.top()) theap.pop(); else ++hash[m]; &#125; // Insert the new number n that enters the window if (!bheap.empty() &amp;&amp; n &lt;= bheap.top()) &#123; ++balance; bheap.push(n); &#125; else &#123; --balance; theap.push(n); &#125; // Rebalance the bottom and top heaps if (balance &lt; 0) &#123; bheap.push(theap.top()); theap.pop(); &#125; else if (balance &gt; 0) &#123; theap.push(bheap.top()); bheap.pop(); &#125; // Remove numbers that should be discarded at the top of the two heaps while (!bheap.empty() &amp;&amp; hash[bheap.top()]) &#123; --hash[bheap.top()]; bheap.pop(); &#125; while (!theap.empty() &amp;&amp; hash[theap.top()]) &#123; --hash[theap.top()]; theap.pop(); &#125; &#125; return medians; &#125;&#125;; Since both heaps will never have a size greater than n, the time complexity is O(n* log(n)) in the worst case. https://discuss.leetcode.com/topic/74577/c-solution-o-n-k C++ Solution O(n* k) The idea is to maintain a BST of the window and just search for the k/2 largest element and k/2 smallest element then the average of these two is the median of the window. Now if the STL’s multiset BST maintained how many element were in each subtree finding each median would take O(log k) time but since it doesn’t it takes O(k) time to find each median. 12345678910111213141516171819202122public: vector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; multiset&lt;int&gt; mp; vector&lt;double&gt; med; for(int i=0; i&lt;k-1; ++i) mp.insert(nums[i]); for(int i=k-1; i&lt; nums.size(); ++i)&#123; mp.insert(nums[i]); // Add the next number auto itb = mp.begin(); advance(itb, (k-1)/2); //Find the lower median auto ite = mp.end(); advance(ite, -(k+1)/2); //Find the upper median double avg = ((long)(*itb) + (*ite)) / 2.0; med.push_back(avg); mp.erase(mp.find(nums[i-k+1])); //Remove the oldest element &#125; return med; &#125;&#125;; python https://discuss.leetcode.com/topic/74634/easy-python-o-nk Easy Python O(nk) Just keep the window as a sorted list. 12345678def medianSlidingWindow(self, nums, k): window = sorted(nums[:k]) medians = [] for a, b in zip(nums, nums[k:] + [0]): medians.append((window[k/2] + window[~(k/2)]) / 2.) window.remove(a) bisect.insort(window, b) return medians]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>find median from data stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[477. Total Hamming Distance]]></title>
    <url>%2Fp%2F76798a8b%2F</url>
    <content type="text"><![CDATA[45.9% https://leetcode.com/problems/total-hamming-distance/ The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Now your job is to find the total Hamming distance between all pairs of the given numbers. 12345678Example:Input: 4, 14, 2Output: 6Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (justshowing the four bits relevant in this case). So the answer will be:HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6. Note: Elements of the given array are in the range of 0 to 10^9 Length of the array will not exceed 10^4. 方法一: 每一位，只有一个是0，一个是1，才会有效果。 所以统计每一位中1个个数和0的个数 每一位个数的乘积和就是答案 优化，1的个数和0的个数相加等于固定长度，所以只要统计一个就可以了。 我的代码实现： 12345678910111213141516171819202122class Solution &#123;public: int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ones(32, 0); vector&lt;int&gt; zeros(32, 0); int flag = 1; for(int i=0; i&lt;32; i++)&#123; for(auto num:nums)&#123; if(num&amp;flag)&#123; ones[i]++; &#125;else&#123; zeros[i]++; &#125; &#125; flag &lt;&lt;= 1; &#125; int res = 0; for(int i=0; i&lt;32; i++) res += ones[i] * zeros[i]; return res; &#125;&#125;; https://discuss.leetcode.com/topic/72092/java-o-n-time-o-1-space Java O(n) time O(1) Space For each bit position 1-32 in a 32-bit integer, we count the number of integers in the array which have that bit set. Then, if there are n integers in the array and k of them have a particular bit set and (n-k) do not, then that bit contributes k* (n-k) hamming distance to the total. 12345678910public int totalHammingDistance(int[] nums) &#123; int total = 0, n = nums.length; for (int j=0;j&lt;32;j++) &#123; int bitCount = 0; for (int i=0;i&lt;n;i++) bitCount += (nums[i] &gt;&gt; j) &amp; 1; total += bitCount*(n - bitCount); &#125; return total;&#125; 方法二: https://discuss.leetcode.com/topic/72099/share-my-o-n-c-bitwise-solution-with-thinking-process-and-explanation Share my O(n) C++ bitwise solution with thinking process and explanation 1. Problem The problem is to find the total Hamming distance between all pairs of the given numbers. 2. Thinking process 2.1 For one pair When you calculate Hamming distance between x and y, you just calculate p = x ^ y;count the number of 1’s in pThe distance from x to y is as same as y to x. 2.2 Trival approach For a series of number: a1, a2, a3,…, an Use the approach in 2.1(suppose distance(x, y) is the Hamming distance between x and y): For a1, calculate S(1) = distance(a1, a2)+distance(a1, a3)+ … +distance(a1, an)For a2, calculate S(2) = distance(a2, a3)+distance(a2, a4)+ … +distance(a2, an)……For a(n - 1), calculate S(n - 1) = distance(a(n - 1), a(n)) Finally , S = S(1) + S(2) + … + S(n - 1). The function distance is called 1 + 2 + … + (n - 1) = n(n - 1)/2 times! That’s too much! 2.3 New idea The total Hamming distance is constructed bit by bit in this approach. Let’s take a series of number: a1, a2, a3,…, an Just think about all the Least Significant Bit (LSB) of a(k) (1 ≤ k ≤ n). How many Hamming distance will they bring to the total? If a pair of number has same LSB, the total distance will get 0. If a pair of number has different LSB, the total distance will get 1. For all number a1, a2, a3,…, a(n), if there are p numbers have 0 as LSB (put in set M), and q numbers have 1 for LSB (put in set N). There are 2 situations: Situation 1. If the 2 number in a pair both comes from M (or N), the total will get 0. Situation 2. If the 1 number in a pair comes from M, the other comes from N, the total will get 1. Since Situation 1 will add NOTHING to the total, we only need to think about Situation 2 How many pairs are there in Situation 2? We choose 1 number from M (p possibilities), and 1 number from N (q possibilities). The total possibilities is p × q = pq, which means The total Hamming distance will get pq from LSB. If we remove the LSB of all numbers (right logical shift), the same idea can be used again and again until all numbers becomes zero 2.4 Time Complexity In each loop, we need to visit all numbers in nums to calculate how many numbers has 0 (or 1) as LSB. If the biggest number in nums[] is K, the total number of loop is [logM] + 1. So, the total time complexity of this approach is O(n). 3. Code 1234567891011121314151617181920212223class Solution &#123;public: int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); if(size &lt; 2) return 0; int ans = 0; int *zeroOne = new int[2]; while(true) &#123; int zeroCount = 0; zeroOne[0] = 0; zeroOne[1] = 0; for(int i = 0; i &lt; nums.size(); i++) &#123; if(nums[i] == 0) zeroCount++; zeroOne[nums[i] % 2]++; nums[i] = nums[i] &gt;&gt; 1; &#125; ans += zeroOne[0] * zeroOne[1]; if(zeroCount == nums.size()) return ans; &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/72149/python-via-strings Python via Strings 12def totalHammingDistance(self, nums): return sum(b.count(&apos;0&apos;) * b.count(&apos;1&apos;) for b in zip(*map(&apos;&#123;:032b&#125;&apos;.format, nums))) https://discuss.leetcode.com/topic/72095/python-explanation Python Explanation Notice the total hamming distance is the sum of the total hamming distance for each of the i-th bits separately. So, let’s consider the i-th column, which consists of numbers chosen from {0, 1}. The total hamming distance would be the number of pairs of numbers that are different. That is, Total hamming distance for the i-th bit = (the number of zeros in the i-th position) * (the number of ones in the i-th position). We then add all of these together to get our answer. Code: 123456bits = [ [0,0] for _ in xrange(32) ]for x in A: for i in xrange(32): bits[i][x%2] += 1 x /= 2return sum( x*y for x,y in bits ) https://discuss.leetcode.com/topic/72190/python-o-nlogv-time Python O(nlogV) time Just calculate combinations vertically. 123456789101112131415161718class Solution(object): def totalHammingDistance(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; ans = 0 mask = 1 for j in range(0, 32): ones = zeros = 0 for num in nums: if num &amp; mask: ones += 1 else: zeros += 1 ans += ones * zeros mask = mask &lt;&lt; 1 return ans java https://discuss.leetcode.com/topic/72104/java-solution-with-explanation Java Solution with Explanation The first solution came to my mind is brute forcely iterate through each pair, then sum all Integer.bitCount(x ^ y) like what I mentioned here https://discuss.leetcode.com/topic/72093/java-1-line-solution-d But as you can imagine, it TLE… Let’s think about this problem another way. We can separate the calculation to do one bit at a time. For example, look at the rightmost bit of all the numbers in nums. Suppose that i numbers have a rightmost 0-bit, and j numbers have a 1-bit. Then out of the pairs, i j of them will have 1 in the rightmost bit of the XOR. This is because there are i j ways to choose one number that has a 0-bit and one that has a 1-bit. These bits will therefore contribute i * j towards the total of all the XORs. Apply above algorithm to each bit (31 bits in total as specified in the problem), sum them together then we get the answer. Reference: http://stackoverflow.com/questions/21388448/sum-of-xor-values-of-all-pairs 1234567891011121314151617public class Solution &#123; public int totalHammingDistance(int[] nums) &#123; int n = 31; int len = nums.length; int[] countOfOnes = new int[n]; for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; countOfOnes[j] += (nums[i] &gt;&gt; j) &amp; 1; &#125; &#125; int sum = 0; for (int count: countOfOnes) &#123; sum += count * (len - count); &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[476. Number Complement]]></title>
    <url>%2Fp%2F9211f622%2F</url>
    <content type="text"><![CDATA[61.1% https://leetcode.com/problems/number-complement/?tab=Description Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note: The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation. 12345Example 1:Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. 12345Example 2:Input: 1Output: 0Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. https://discuss.leetcode.com/topic/74627/3-line-c 3 line C++ 12345678class Solution &#123;public: int findComplement(int num) &#123; unsigned mask = ~0; while (num &amp; mask) mask &lt;&lt;= 1; return ~mask &amp; ~num; &#125;&#125;; 12345For example,num = 00000101mask = 11111000~mask &amp; ~num = 00000010 https://discuss.leetcode.com/topic/74642/java-1-line-bit-manipulation-solution Java 1 line bit manipulation solution I post solution first and then give out explanation. Please think why does it work before read my explanation. 12345public class Solution &#123; public int findComplement(int num) &#123; return ~num &amp; ((Integer.highestOneBit(num) &lt;&lt; 1) - 1); &#125;&#125; According to the problem, the result is The flipped version of the original input but Only flip N bits within the range from LEFTMOST bit of 1 to RIGHTMOST. For example input = 5 (the binary representation is 101), the LEFTMOST bit of 1 is the third one from RIGHTMOST (100, N = 3). Then we need to flip 3 bits from RIGHTMOST and the answer is 010 To achieve above algorithm, we need to do 3 steps: Create a bit mask which has N bits of 1 from RIGHTMOST. In above example, the mask is 111. And we can use the decent Java built-in function Integer.highestOneBit to get the LEFTMOST bit of 1, left shift one, and then minus one. Please remember this wonderful trick to create bit masks with N ones at RIGHTMOST, you will be able to use it later. Negate the whole input number. Bit AND numbers in step 1 and 2. Three line solution if you think one line solution is too confusing: 1234567public class Solution &#123; public int findComplement(int num) &#123; int mask = (Integer.highestOneBit(num) &lt;&lt; 1) - 1; num = ~num; return num &amp; mask; &#125;&#125; https://discuss.leetcode.com/topic/74611/simple-python Simple Python 使用cpp测试，会超时，可能是因为cpp整数32位，很容易超出范围。 123456class Solution(object): def findComplement(self, num): i = 1 while i &lt;= num: i = i &lt;&lt; 1 return (i - 1) ^ num https://discuss.leetcode.com/topic/74897/maybe-fewest-operations maybe fewest operations 123456789int findComplement(int num) &#123; int mask = num; mask |= mask &gt;&gt; 1; mask |= mask &gt;&gt; 2; mask |= mask &gt;&gt; 4; mask |= mask &gt;&gt; 8; mask |= mask &gt;&gt; 16; return num ^ mask;&#125; https://discuss.leetcode.com/topic/75605/java-very-simple-code-and-self-evident-explanation Java, very simple code and self-evident, explanation for example: 100110, its complement is 011001, the sum is 111111. So we only need get the min number large or equal to num, then do substraction 12345678910111213public int findComplement(int num) &#123; int i = 0; int j = 0; while (i &lt; num) &#123; i += Math.pow(2, j); j++; &#125; return i - num;&#125; https://discuss.leetcode.com/topic/74570/oneline-c-solution Oneline C++ Solution 12345public: int findComplement(int num) &#123; return ~num &amp; ((1 &lt;&lt;(int)log2(num))-1); &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[468. Validate IP Address]]></title>
    <url>%2Fp%2F899bfeda%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/validate-ip-address/ In this problem, your job to write a function to check whether a input string is a valid IPv4 address or IPv6 address or neither. IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (“.”), e.g.,172.16.254.1; Besides, you need to keep in mind that leading zeros in the IPv4 is illegal. For example, the address 172.16.254.01 is illegal. IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (“:”). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a legal one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases). However, we don’t replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address. Besides, you need to keep in mind that extra leading zeros in the IPv6 is also illegal. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is also illegal. Note: You could assume there is no extra space in the test cases and there may some special characters in the input string. 12345678910111213141516Example 1:Input: &quot;172.16.254.1&quot;Output: &quot;IPv4&quot;Explanation: This is a valid IPv4 address, return &quot;IPv4&quot;.Example 2:Input: &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;Output: &quot;IPv6&quot;Explanation: This is a valid IPv6 address, return &quot;IPv6&quot;.Example 3:Input: &quot;256.256.256.256&quot;Output: &quot;Neither&quot; Explanation: This is neither a IPv4 address nor a IPv6 address. pythonhttps://discuss.leetcode.com/topic/71414/python-solution 1234567891011121314151617181920212223242526class Solution(object): def validIPAddress(self, IP): &quot;&quot;&quot; :type IP: str :rtype: str &quot;&quot;&quot; def is_hex(s): hex_digits = set(&quot;0123456789abcdefABCDEF&quot;) for char in s: if not (char in hex_digits): return False return True ary = IP.split(&apos;.&apos;) if len(ary) == 4: for i in xrange(len(ary)): if not ary[i].isdigit() or not 0 &lt;= int(ary[i]) &lt; 256 or (ary[i][0] == &apos;0&apos; and len(ary[i]) &gt; 1): return &quot;Neither&quot; return &quot;IPv4&quot; ary = IP.split(&apos;:&apos;) if len(ary) == 8: for i in xrange(len(ary)): tmp = ary[i] if len(tmp) == 0 or not len(tmp) &lt;= 4 or not is_hex(tmp): return &quot;Neither&quot; return &quot;IPv6&quot; return &quot;Neither&quot;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[461. Hamming Distance]]></title>
    <url>%2Fp%2F2b2126a5%2F</url>
    <content type="text"><![CDATA[70.8% https://leetcode.com/problems/hamming-distance/?tab=Description The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note: 0 ≤ x, y &lt; 231. 12345678910Example:Input: x = 1, y = 4Output: 2Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different. 方法一： 我的代码实现： 123456789101112class Solution &#123;public: int hammingDistance(int x, int y) &#123; int res = 0; int z = x ^ y; while(z)&#123; res++; z = z &amp; (z-1); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/72236/my-c-solution-using-bit-manipulation My C++ solution using bit manipulation 1234567891011class Solution &#123;public: int hammingDistance(int x, int y) &#123; int dist = 0, n = x ^ y; while (n) &#123; ++dist; n &amp;= n - 1; &#125; return dist; &#125;&#125;; https://discuss.leetcode.com/topic/72288/python-1-line-49ms Python 1 line 49ms 12345678class Solution(object): def hammingDistance(self, x, y): &quot;&quot;&quot; :type x: int :type y: int :rtype: int &quot;&quot;&quot; return bin(x^y).count(&apos;1&apos;) my code: 123456789101112class Solution &#123;public: int hammingDistance(int x, int y) &#123; int z = x ^ y; int res = 0; while(z)&#123; if(z&amp;1) res++; z &gt;&gt;= 1; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/72093/java-1-line-solution-d Java 1 Line Solution :D What does come to your mind first when you see this sentence “corresponding bits are different”? Yes, XOR! Also, do not forget there is a decent function Java provided: Integer.bitCount() ~~~ 12345public class Solution &#123; public int hammingDistance(int x, int y) &#123; return Integer.bitCount(x ^ y); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[459. Repeated Substring Pattern]]></title>
    <url>%2Fp%2Fffe478de%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/repeated-substring-pattern/ Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000. 1234567891011121314Example 1:Input: &quot;abab&quot;Output: TrueExplanation: It&apos;s the substring &quot;ab&quot; twice.Example 2:Input: &quot;aba&quot;Output: FalseExample 3:Input: &quot;abcabcabcabc&quot;Output: True Explanation: It’s the substring “abc” four times. (And the substring “abcabc” twice.) javahttps://discuss.leetcode.com/topic/67992/java-simple-solution-with-explanation The length of the repeating substring must be a divisor of the length of the input string Search for all possible divisor of str.length, starting for length/2 If i is a divisor of length, repeat the substring from 0 to i the number of times i is contained in s.length If the repeated substring is equals to the input str return true12345678910111213141516public class Solution &#123; public boolean repeatedSubstringPattern(String str) &#123; int l = str.length(); for(int i=l/2; i&gt;0; i--)&#123; if(l%i == 0)&#123; int m = l/i; String subS = str.substring(0, i); StringBuilder sb = new StringBuilder(); for(int j=0; j&lt;m; j++) sb.append(subS); if(sb.toString().equals(str)) return true; &#125; &#125; return false; &#125;&#125; https://discuss.leetcode.com/topic/67992/java-simple-solution-with-explanation/2 Added a small check in your code and time reduced from 48 ms to 18 ms. Just return if any of the substring will not match. No need to create the whole string. 23ms, 76.61%, Dec 30th, 2016 123456789101112131415161718public class Solution &#123; public boolean repeatedSubstringPattern(String str) &#123; int l = str.length(); for(int i=l/2; i&gt;0; i--)&#123; if(l%i == 0)&#123; int m = l/i; String subS = str.substring(0, i); int j; for(j=1; j&lt;m; j++)&#123; if(!subS.equals(str.substring(j*i, i+j*i))) break; &#125; if(j==m) return true; &#125; &#125; return false; &#125;&#125; https://discuss.leetcode.com/topic/67611/share-my-simple-solution Try every possible substring, then check. 12345678910111213141516171819public class Solution &#123; public boolean repeatedSubstringPattern(String str) &#123; int len = str.length(); if(len&lt;2) return false; for(int i=2;i&lt;=len;i++)&#123; if(len%i!=0) continue; if(check(str, i)) return true; &#125; return false; &#125; public boolean check(String str, int repeat)&#123; int len = str.length(); String cand = str.substring(0, len/repeat); for(int i=0;i&lt;len;i++)&#123; if(str.charAt(i)!=cand.charAt(i%(len/repeat))) return false; &#125; return true; &#125;&#125; https://discuss.leetcode.com/topic/68210/from-intuitive-but-slow-to-really-fast-but-a-little-hard-to-comprehend Solution 1:Let us start with the very naive solution. It uses 188 ms to solve 100 test cases. The idea is that when we see a character in str that matches the very first character of str, we can start to hoping that str is a built by copies of the substring composed by all characters before the reappearance of the its first character. 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public boolean repeatedSubstringPattern(String str) &#123; int l = str.length(); if(l == 1) &#123; return false; &#125; StringBuilder sb = new StringBuilder(); char first = str.charAt(0); sb.append(first); int i = 1; while(i &lt;= l / 2) &#123; char c = str.charAt(i++); if(c == first &amp;&amp; isCopies(str, sb.toString())) &#123; return true; &#125;else &#123; sb.append(c); &#125; &#125; return false; &#125; private boolean isCopies(String str, String substr) &#123; if(str.length() % substr.length() != 0) &#123; return false; &#125; for(int i = substr.length(); i &lt; str.length(); i += substr.length())&#123; if(!str.substring(i).startsWith(substr))&#123; return false; &#125; &#125; return true; &#125;&#125; Solution 2:The problem of the first solution is that we do not use the knowledge of failed matching, and the Knuth-Morris-Pratt algorithm is a classic example of how knowledge of failed tries can be use to guide future search. In fact we only need to compute the pattern table (the lps array, see below) in the Knuth-Morris-Pratt algorithm. The entry lps[i] is the length of the longest proper prefix that is also a suffix of (s[0], …, s[i]), or equivalently, length of the longest prefix that is also a proper suffix of (s[0], …, s[i]). lps[0] is 0, since a single - character string has no proper prefix or proper suffix. Here is a very detailed explanation on the KMP algorithm and how lps is computed dynamically. After we get lps, we relate the property of the lps table to the property of a string being constructed by joining copies of its substring. One on hand, if str = (s[0], …, s[km - 1]) is constructed by joining m copies of its substring substr = (s[0], …, s[k-1]), and assuming that substr is the finest making blockstr can be boiled down to, meaning str is not constructed by joining copies of any proper substring of substr. Then we must have lps[km - 1] equals (m - 1)k. On the other hand, assuming that the longest proper prefix of string str that is also a suffix, and the remaining string remainderStr obtained by removing prefix from str satisfies the following 3 properties: remainderStr is a proper substring of str,|str| is divisiable by |remainderStr|,remainderStr is a prefix of prefixStr.We can show by induction that str is constructed by joining copies of remainderStr.Here is the code. It solve the 100 test cases in 29ms. A great improvement over the native approach! Remember the statement above, since we are going to use it again. 123456789101112131415161718192021222324public class Solution &#123; public boolean repeatedSubstringPattern(String str) &#123; int l = str.length(); int[] lps = new int[l]; int leading = 1; int chasing = 0; while(leading &lt; l) &#123; if(str.charAt(chasing) == str.charAt(leading)) &#123; chasing++; lps[leading] = chasing; leading++; &#125;else &#123; if(chasing &gt; 0) &#123; chasing = lps[chasing - 1]; &#125;else &#123; chasing = 0; leading++; &#125; &#125; &#125; int lp = lps[l - 1]; return (lp &gt; 0 &amp;&amp; l % (l - lp) == 0 &amp;&amp; str.startsWith(str.substring(lp))); &#125;&#125; Solution 3: Can the problem be solved efficiently without KMP? The following solution runs even faster (23ms on 100 test cases) 12345678910111213141516171819202122public class Solution &#123; public boolean repeatedSubstringPattern(String str) &#123; int l = str.length(); for(int i = l / 2; i &gt; 0; i--) &#123; if(l % i == 0) &#123; String substr = str.substring(0, i); int j = i; while(j &lt; l) &#123; if(!str.substring(j, j + i).equals(substr))&#123; break; &#125;else &#123; j += i; &#125; &#125; if(j == l) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125; Solution 4: Want clearer code that runs even faster ? Here is it. The idea is stated at the end of the explanation for solution 2. Without really find the longest proper prefix that is also a suffix as in solution 2 and see whether the three properties are matched, we just test each remainderStr, from the longest possible that satisfies condition 1 and 2, that whether the corresponding prefix and suffix match each other. It solve 100 test cases in 16ms. So maybe now, you really want to prove the statement since it lead to such a clean and fast solution? It is not hard to prove by induction. 1234567891011121314public class Solution &#123; public boolean repeatedSubstringPattern(String str) &#123; int l = str.length(); for(int i = (l + 1) / 2; i &lt; l; i++) &#123; if(l % (l - i) == 0) &#123; String prefix = str.substring(0, i); String remainder = str.substring(i); String suffix = str.substring(l - i); if(str.startsWith(remainder) &amp;&amp; suffix.equals(prefix))&#123; return true; &#125; &#125; &#125; return false; cpphttps://discuss.leetcode.com/topic/67652/c-o-n-using-kmp-32ms-8-lines-of-code-with-brief-explanation First, we build the KMP table. Roughly speaking, dp[i+1] stores the maximum number of characters that the string is repeating itself up to position i.Therefore, if a string repeats a length 5 substring 4 times, then the last entry would be of value 15.To check if the string is repeating itself, we just need the last entry to be non-zero and str.size() to divide (str.size()-last entry). 12345678910bool repeatedSubstringPattern(string str) &#123; int i = 1, j = 0, n = str.size(); vector&lt;int&gt; dp(n+1,0); while( i &lt; str.size() )&#123; if( str[i] == str[j] ) dp[++i]=++j; else if( j == 0 ) i++; else j = dp[j]; &#125; return dp[n]&amp;&amp;dp[n]%(n-dp[n])==0; &#125; https://discuss.leetcode.com/topic/67652/c-o-n-using-kmp-32ms-8-lines-of-code-with-brief-explanation/2 1234567891011121314151617181920212223242526Same implementation.My p[i] stands for longest common string length of prefix string and the string ended with position i.The important point is the last one: len % (len - p[len - 1]) == 0for a string like below, if p[len-1] = 15, len=20:#####~~~~~^^^^^$$$$$#####~~~~~^^^^^$$$$$by p[len-1] = 15, we know the strings colored red are the same.so you can infer that:##### == ~~~~~~~~~~ == ^^^^^^^^^^ == $$$$$The whole is repeating as #####the length of it is 5, which can be completely divided by len.That&apos;s how this final condition works. 1234567891011121314bool repeatedSubstringPattern(string str) &#123; int len = str.length(), i = 0, j = 1; int p[len]; while (j &lt; len) if (str[i] == str[j]) p[j++] = ++i; else &#123; if (!i) p[j++] = 0; else i = p[i - 1]; &#125; return p[len - 1] &amp;&amp; len % (len - p[len - 1]) == 0; &#125; pythonhttps://discuss.leetcode.com/topic/68206/easy-python-solution-with-explaination Basic idea: First char of input string is first char of repeated substring Last char of input string is last char of repeated substring Let S1 = S + S (where S in input string) Remove 1 and last char of S1. Let this be S2 If S exists in S2 then return true else false Let i be index in S2 where S starts then repeated substring length i + 1 and repeated substring S[0: i+1] 1234567891011class Solution(object): def repeatedSubstringPattern(self, str): &quot;&quot;&quot; :type str: str :rtype: bool &quot;&quot;&quot; if not str: return False ss = (str+str)[1:-1] return ss.find(str) != -1]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[455. Assign Cookies]]></title>
    <url>%2Fp%2Ff3302f3c%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/assign-cookies/ Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number. Note: You may assume the greed factor is always positive. You cannot assign more than one cookie to one child. 12345678Example 1:Input: [1,2,3], [1,1]Output: 1Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.You need to output 1. 12345678Example 2:Input: [1,2], [1,2,3]Output: 2Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. You have 3 cookies and their sizes are big enough to gratify all of the children, You need to output 2. java https://discuss.leetcode.com/topic/67676/simple-greedy-java-solution Simple Greedy Java Solution 1234567Arrays.sort(g);Arrays.sort(s);int i = 0;for(int j=0;i&lt;g.length &amp;&amp; j&lt;s.length;j++) &#123; if(g[i]&lt;=s[j]) i++;&#125;return i; Just assign the cookies starting from the child with less greediness to maximize the number of happy children . https://discuss.leetcode.com/topic/68455/array-sort-two-pointer-greedy-solution-o-nlogn Array sort + Two pointer greedy solution O(nlogn) Two assign cookies to children optimaly we should give for each child the closest higher cookie. By using this greedy approach overall sum of wasted cookies will be minimum amoung all. To use this greedy solution in effective way we can sort both arrays and use two pointers. We should move pointer of children only if there is enough cookies to make that child content. In each step we will try to make content child at position pointerG by searching the closes higher cookie value. 1234567891011121314151617181920public class Solution &#123; public int findContentChildren(int[] g, int[] s) &#123; Arrays.sort(g); Arrays.sort(s); int pointG = 0; int pointS = 0; while (pointG&lt;g.length &amp;&amp; pointS&lt;s.length) &#123; if (g[pointG]&lt;=s[pointS]) &#123; pointG++; pointS++; &#125; else &#123; pointS++; &#125; &#125; return pointG; &#125;&#125; https://discuss.leetcode.com/topic/68288/java-solution-with-binary-search-tree Java Solution with binary search tree 1234567891011121314151617181920212223242526public class AssignCookies &#123; public static int findContentChildren(int[] g, int[] s) &#123; int count = 0; TreeMap&lt;Integer,Integer&gt; tree = new TreeMap&lt;&gt;(); for(int temp : s)&#123; Integer num = tree.get(temp); num = num==null?0:num; tree.put(temp,num+1); &#125; for(int temp : g)&#123; Integer targ = tree.ceilingKey(temp); if(targ!=null)&#123; Integer num = tree.get(targ); if(num&gt;0)&#123; count++; if(num==1)&#123; tree.remove(targ); &#125;else&#123; tree.put(targ, num - 1); &#125; &#125; &#125; &#125; return count; &#125;&#125; cpp https://discuss.leetcode.com/topic/68858/c-short-solution C++ short solution 1234567891011int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; sort(g.begin(),g.end()); sort(s.begin(),s.end()); int i=g.size()-1, j=s.size()-1,count = 0; while(i&gt;=0 &amp;&amp; j&gt;=0) &#123; if(g[i]&gt;s[j]) i--; else if(g[i--]&lt;=s[j--]) count++; &#125; return count;&#125; python https://discuss.leetcode.com/topic/67591/python-concise-efficient-solution Python concise &amp; efficient solution My solution from the contest: 123456789101112def findContentChildren(self, g, s): g.sort() s.sort() res = 0 i = 0 for e in s: if i == len(g): break if e &gt;= g[i]: res += 1 i += 1 return res O(nlogn) time and O(1) space]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[454. 4Sum II]]></title>
    <url>%2Fp%2Fdf24c58e%2F</url>
    <content type="text"><![CDATA[46.7% https://leetcode.com/problems/4sum-ii/discuss/ Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1. 123456789101112131415Example:Input:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]Output:2Explanation:The two tuples are:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 方法一： https://discuss.leetcode.com/topic/78430/concise-c-11-code-beat-99-5 Concise C++ 11 code beat 99.5% 123456789101112131415161718int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123; unordered_map&lt;int, int&gt; abSum; for(auto a : A) &#123; for(auto b : B) &#123; ++abSum[a+b]; &#125; &#125; int count = 0; for(auto c : C) &#123; for(auto d : D) &#123; auto it = abSum.find(0 - c - d); if(it != abSum.end()) &#123; count += it-&gt;second; &#125; &#125; &#125; return count;&#125; 我的代码实现： 12345678910111213141516class Solution &#123;public: int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123; int n = A.size(); unordered_map&lt;int, int&gt; map; for(auto a:A) for(auto b:B) map[a+b]++; int cnt = 0; for(auto c:C) for(auto d:D) if(map.find(-c-d)!=map.end()) cnt += map[-c-d]; // 是+map的value，不是cnt++ return cnt; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[452. Minimum Number of Arrows to Burst Balloons]]></title>
    <url>%2Fp%2F5942bc06%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/ There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 10**4 balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons. 1234567891011Example:Input:[[10,16], [2,8], [1,6], [7,12]]Output:2Explanation:One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and[1,6]) and another arrow at x = 11 (bursting the other two balloons). java https://discuss.leetcode.com/topic/66579/java-greedy-soution Java Greedy Soution 12345678910111213141516171819202122public int findMinArrowShots(int[][] points) &#123; if(points==null || points.length==0 || points[0].length==0) return 0; Arrays.sort(points, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] a, int[] b) &#123; if(a[0]==b[0]) return a[1]-b[1]; else return a[0]-b[0]; &#125; &#125;); int minArrows = 1; int arrowLimit = points[0][1]; for(int i=1;i&lt;points.length;i++) &#123; int[] baloon = points[i]; if(baloon[0]&lt;=arrowLimit) &#123; arrowLimit=Math.min(arrowLimit, baloon[1]); &#125; else &#123; minArrows++; arrowLimit=baloon[1]; &#125; &#125; return minArrows;&#125; https://discuss.leetcode.com/topic/66548/concise-java-solution-tracking-the-end-of-overlapping-intervals Concise Java solution tracking the end of overlapping intervals 1234567891011121314151617public class Solution &#123; public int findMinArrowShots(int[][] points) &#123; if(points == null || points.length &lt; 1) return 0; Arrays.sort(points, (a, b)-&gt;(a[0]-b[0])); int result = 1; int end = points[0][1]; for(int i = 1; i &lt; points.length; i ++) &#123; if(points[i][0] &gt; end) &#123; result ++; end = points[i][1]; &#125; else &#123; end = Math.min(end, points[i][1]); &#125; &#125; return result; &#125;&#125; https://discuss.leetcode.com/topic/70330/java-easy-to-understand-solution Java easy to understand solution 123456789101112131415161718192021public class Solution &#123; public int findMinArrowShots(int[][] points) &#123; if (points == null || points.length == 0) return 0; Arrays.sort(points,(a, b) -&gt; a[0] - b[0]); //sort the balloons according to their start coordinate int minRight = Integer.MAX_VALUE, count = 0; //minRight record the leftmost end of previous balloons for (int i = 0; i &lt; points.length; ++i) &#123; //whenever current balloon&apos;s start is bigger than minRight //that means we need an arrow to clear all previous balloons if (points[i][0] &gt; minRight) &#123; count++; minRight = points[i][1]; &#125; else &#123; minRight = Math.min(minRight, points[i][1]); &#125; &#125; return count + 1; &#125;&#125; cpp https://discuss.leetcode.com/topic/66709/c-easy-understood-solution-sort C++ easy understood solution (sort) First, we sort balloons by increasing points.end (if ends are the same, then by increasing of points.start). Every time arrow shot points.end, say, points[i].second. If next balloon.start &lt;= points[i].second, it is also shot, thus we continue. 12345678910111213int findMinArrowShots(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123; int count = 0, arrow = INT_MIN; sort(points.begin(), points.end(), mysort); for(int i = 0; i&lt;points.size(); i++)&#123; if(arrow!=INT_MIN &amp;&amp; points[i].first&lt;=arrow)&#123;continue;&#125; //former arrow shot points[i] arrow = points[i].second; // new arrow shot the end of points[i] count++; &#125; return count;&#125;static bool mysort(pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b)&#123; return a.second==b.second?a.first&lt;b.first:a.second&lt;b.second;&#125; https://discuss.leetcode.com/topic/66539/c-o-nlogn-solution-with-detailed-explanation C++ O(nlogn) solution with detailed explanation The main idea here sort the array first, and then find overlapping sequence which should cover the min(points[i].second, …, points[k].second), the operation above is insure to pick the common region from points i to points k. Time complexity is O(nlogn) for sort, and space complexity is O(n). 123456789101112131415161718192021222324class Solution &#123;public: int findMinArrowShots(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123; if(points.empty()) return 0; int ans = 0; sort(points.begin(), points.end(), cmp); for(int i = 0; i &lt; points.size(); ++ i) &#123; int j = i + 1; while(j &lt; points.size() &amp;&amp; points[j].first &lt;= points[i].second) &#123; points[i].second = min(points[i].second, points[j].second); j ++; &#125; ans += 1; i = j - 1; &#125; return ans; &#125; static bool cmp(pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b) &#123; if(a.first == b.first) return a.second &lt; b.second; return a.first &lt; b.first; &#125;&#125;; python https://discuss.leetcode.com/topic/66772/greedy-python-132-ms Greedy, Python (132 ms) Sort intervals by ending value; Only count valid intervals we need, and skip overlapping intervals return the count 12345678910111213class Solution(object): def findMinArrowShots(self, points): &quot;&quot;&quot; :type points: List[List[int]] :rtype: int &quot;&quot;&quot; points = sorted(points, key = lambda x: x[1]) res, end = 0, -float(&apos;inf&apos;) for interval in points: if interval[0] &gt; end: res += 1 end = interval[1] return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[448. Find All Numbers Disappeared in an Array]]></title>
    <url>%2Fp%2F553a16dc%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/ Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. 1234567Example:Input:[4,3,2,7,8,2,3,1]Output:[5,6] javahttps://discuss.leetcode.com/topic/65738/java-accepted-simple-solution Java accepted simple solution The basic idea is that we iterate through the input array and mark elements as negative using nums[nums[i] -1] = -nums[nums[i]-1]. In this way all the numbers that we have seen will be marked as negative. In the second iteration, if a value is not marked as negative, it implies we have never seen that index before, so just add it to the return list. 1234567891011121314151617public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; nums.length; i++) &#123; int val = Math.abs(nums[i]) - 1; if(nums[val] &gt; 0) &#123; nums[val] = -nums[val]; &#125; &#125; for(int i = 0; i &lt; nums.length; i++) &#123; if(nums[i] &gt; 0) &#123; ret.add(i+1); &#125; &#125; return ret;&#125; https://discuss.leetcode.com/topic/66063/5-line-java-easy-understanding 5-line Java Easy-understanding 1234567public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); int n = nums.length; for (int i = 0; i &lt; nums.length; i ++) nums[(nums[i]-1) % n] += n; for (int i = 0; i &lt; nums.length; i ++) if (nums[i] &lt;= n) res.add(i+1); return res; &#125; https://discuss.leetcode.com/topic/66211/2ms-o-n-in-space-java 2ms O(n) In-Space Java Think we surely have to negate anytime we are given an array with values from 1 to the length of array. If anyone has a better idea, will be happy to hear. The steps followed in this is: Negate each number while traversing Run again and find the index that is not negated. 1234567891011121314List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();for( int i=0;i&lt; nums.length; i++)&#123; int index = nums[i]; if(nums[Math.abs(index)-1] &gt; 0)&#123; nums[Math.abs(index)-1]= -nums[Math.abs(index)-1]; &#125;&#125;for(int j =1 ;j &lt;= nums.length ; j++)&#123; if(nums[j-1] &gt; 0)&#123; result.add(j); &#125;&#125;return result; https://discuss.leetcode.com/topic/66581/simple-java-in-place-sort-solution Simple Java In-place sort solution The idea is simple, if nums[i] != i + 1 and nums[i] != nums[nums[i] - 1], then we swap nums[i] with nums[nums[i] - 1], for example, nums[0] = 4 and nums[3] = 7, then we swap nums[0] with nums[3]. So In the end the array will be sorted and if nums[i] != i + 1, then i + 1 is missing. 123456789The example run as follows[4,3,2,7,8,2,3,1][7,3,2,4,8,2,3,1][3,3,2,4,8,2,7,1][2,3,3,4,8,2,7,1][3,2,3,4,8,2,7,1][3,2,3,4,1,2,7,8][1,2,3,4,3,2,7,8] Since every swap we put at least one number to its correct position, the time is O(n) 123456789101112131415161718public class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; while (nums[i] != i + 1 &amp;&amp; nums[i] != nums[nums[i] - 1]) &#123; int tmp = nums[i]; nums[i] = nums[tmp - 1]; nums[tmp - 1] = tmp; &#125; &#125; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != i + 1) &#123; res.add(i + 1); &#125; &#125; return res; &#125;&#125; cpphttps://discuss.leetcode.com/topic/65944/c-solution-o-1-space c++ solution O(1) space The idea is very similar to problem 442. Find All Duplicates in an Array: https://leetcode.com/problems/find-all-duplicates-in-an-array/. First iteration to negate values at position whose equal to values appear in array. Second iteration to collect all position whose value is positive, which are the missing values. Complexity is O(n) Time and O(1) space. 123456789101112131415class Solution &#123;public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); for(int i=0; i&lt;len; i++) &#123; int m = abs(nums[i])-1; // index start from 0 nums[m] = nums[m]&gt;0 ? -nums[m] : nums[m]; &#125; vector&lt;int&gt; res; for(int i = 0; i&lt;len; i++) &#123; if(nums[i] &gt; 0) res.push_back(i+1); &#125; return res; &#125;&#125;; pythonhttps://discuss.leetcode.com/topic/68838/python-4-lines-with-short-explanation Python 4 lines with short explanation For each number i in nums, we mark the number that i points as negative. Then we filter the list, get all the indexes who points to a positive number. Since those indexes are not visited. 123456789101112131415class Solution(object): def findDisappearedNumbers(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; # For each number i in nums, # we mark the number that i points as negative. # Then we filter the list, get all the indexes # who points to a positive number for i in range(len(nums)): index = abs(nums[i]) - 1 nums[index] = - abs(nums[index]) return [i + 1 for i in range(len(nums)) if nums[i] &gt; 0] https://discuss.leetcode.com/topic/68430/python-one-liner Python One-liner 123456def findDisappearedNumbers(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; return list(set(range(1, len(nums)+1)) - set(nums))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[445. Add Two Numbers II]]></title>
    <url>%2Fp%2Fb407a241%2F</url>
    <content type="text"><![CDATA[46.0% https://leetcode.com/problems/add-two-numbers-ii/description/ You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed. 1234Example:Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 方法一： 类似于 2. Add Two Numbers 此题的区别在于要反转链表，然后相加，再反转回去。 我的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; if(!l1) return l2; else if(!l2) return l1; ListNode* p1 = reverseListNode(l1); ListNode* p2 = reverseListNode(l2); ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; int carry = 0; while(p1 || p2 || carry)&#123; carry += p1 ? p1-&gt;val : 0; carry += p2 ? p2-&gt;val : 0; cur-&gt;next = new ListNode(carry%10); carry /= 10; cur = cur-&gt;next; if(p1) p1 = p1-&gt;next; if(p2) p2 = p2-&gt;next; &#125; return reverseListNode(dummy-&gt;next); &#125; ListNode* reverseListNode(ListNode* head)&#123; // 返回的是ListNode* 不是ListNode if(!head) return NULL; ListNode* pre = NULL; while(head)&#123; ListNode* nex = head-&gt;next; head-&gt;next = pre; pre = head; head = nex; &#125; return pre; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[442. Find All Duplicates in an Array]]></title>
    <url>%2Fp%2F2dc63e03%2F</url>
    <content type="text"><![CDATA[55.9% https://leetcode.com/problems/find-all-duplicates-in-an-array/ Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime? 123456Example:Input:[4,3,2,7,8,2,3,1]Output:[2,3] 方法一： https://discuss.leetcode.com/topic/64759/very-simple-c-solution Very simple C++ solution Firstly, we put each element x in nums[x - 1]. Since x ranges from 1 to N, then x - 1 ranges from 0 to N - 1, it won’t exceed the bound of the array.Secondly, we check through the array. If a number x doesn’t present in nums[x - 1], then x is absent. 123456789101112131415class Solution &#123;public: vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; int i = 0; while (i &lt; nums.size()) &#123; if (nums[i] != nums[nums[i]-1]) swap(nums[i], nums[nums[i]-1]); else i++; &#125; for (i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] != i + 1) res.push_back(nums[i]); &#125; return res; &#125;&#125;; 我的代码实现： 第一遍，先交换，将不对应的全部交还。 第二遍，找出不对应的。 这个分为两步，然后处理。不放在同一个步骤，清晰明了，值得学习。 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; int n = nums.size(); int i=0; while(i&lt;n)&#123; if(nums[i]!=nums[nums[i]-1]) swap(nums[i], nums[nums[i]-1]); else i++; &#125; for(int i=0; i&lt;n; i++) if(nums[i]!=i+1) res.push_back(nums[i]); return res; &#125;&#125;; https://discuss.leetcode.com/topic/64835/c-easy-o-n-time-and-o-1-extra-space-solution-through-swapping C++ Easy O(n) time and O(1) extra space solution through swapping. Given that each element is between 1 and n. All the elements occur either once or twice. So, in first pass, we can swap all the elements to their respective positions. In second pass, all the one-time occuring elements are supposed to be at their positions. The elements that violate this conditions are the elements of our interest (because they are at some other positions, in addition of being at their respective index, where they are not supposed to be). 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return &#123;&#125;; vector&lt;int&gt; res; int n = nums.size(); for(int i = 0; i &lt; n; i++) nums[i]-=1; //for indexing flexibility int i = 0; while(i &lt; n) &#123; if(nums[i] != nums[nums[i]]) swap(nums[i], nums[nums[i]]); //swap elements to their respective indexes. else i++; &#125; for(int i = 0; i &lt; n; i++) &#123; if(nums[i] != i) res.push_back(nums[i]+1); //get the elements which are at some other indexes (as they are occuring twice) &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/64903/c-using-another-idea-instead-of-swapping C++ using another idea instead of swapping idea: take advantage of sign bit in integer 123456789101112131415class Solution &#123;public: vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ret; int mark = 0x80000000; int mask = 0x7fffffff; for (int i = 0; i &lt; nums.size(); ++i)&#123; int num = nums[i] &amp; mask; if (nums[num - 1] &amp; mark) ret.push_back(num); nums[num - 1] |= mark; &#125; return ret; &#125;&#125;; pythonhttps://discuss.leetcode.com/topic/64979/python-o-n-time-o-1-space Python O(n) time O(1) space O(1) space not including the input and output variables The idea is we do a linear pass using the input array itself as a hash to store which numbers have been seen before. We do this by making elements at certain indexes negative. See the full explanation here http://www.geeksforgeeks.org/find-duplicates-in-on-time-and-constant-extra-space/ 12345678910111213class Solution(object): def findDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; res = [] for x in nums: if nums[abs(x)-1] &lt; 0: res.append(abs(x)) else: nums[abs(x)-1] *= -1 return res javahttps://discuss.leetcode.com/topic/64735/java-simple-solution Java Simple Solution 123456789101112131415public class Solution &#123; // when find a number i, flip the number at position i-1 to negative. // if the number at position i-1 is already negative, i is the number that occurs twice. public List&lt;Integer&gt; findDuplicates(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; int index = Math.abs(nums[i])-1; if (nums[index] &lt; 0) res.add(Math.abs(index+1)); nums[index] = -nums[index]; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/64908/java-solution-without-destroying-the-input-array-o-n-time-o-1-space Java solution without destroying the input array. O(n) time. O(1) space. 1234567891011121314151617public List&lt;Integer&gt; findDuplicates(int[] nums) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if(nums == null) return result; for(int i=0; i&lt;nums.length; i++)&#123; int location = Math.abs(nums[i])-1; if(nums[location] &lt; 0)&#123; result.add(Math.abs(nums[i])); &#125;else&#123; nums[location] = -nums[location]; &#125; &#125; for(int i=0; i&lt;nums.length; i++) nums[i] = Math.abs(nums[i]); return result;&#125; https://discuss.leetcode.com/topic/64805/java-easy-to-understand-solution-without-extra-space-and-in-o-n-time Java Easy to understand solution without extra space and in O(n) time The concept here is to negate each number’s index as the input is 1 &lt;= a[i] &lt;= n (n = size of array). Once a value is negated, if it requires to be negated again then it is a duplicate. 12345678910111213public List&lt;Integer&gt; findDuplicates(int[] nums) &#123; List&lt;Integer&gt; newList = new ArrayList&lt;Integer&gt;(); // creating a new List for(int i=0;i&lt;nums.length;i++)&#123; int index =Math.abs(nums[i]); // Taking the absolute value to find index if(nums[index-1] &gt;0)&#123; nums[index-1] = - nums[index-1]; &#125;else&#123; // If it is not greater than 0 (i.e) negative then the number is a duplicate newList.add(Math.abs(nums[i])); &#125; &#125; return newList;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[439. Ternary Expression Parser]]></title>
    <url>%2Fp%2Fa39c4b05%2F</url>
    <content type="text"><![CDATA[49.9% Given a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits 0-9, ?, :, T and F (T and F represent True and False respectively). Note: The length of the given string is ≤ 10000.Each number will contain only one digit.The conditional expressions group right-to-left (as usual in most languages).The condition will always be either T or F. That is, the condition will never be a digit.The result of the expression will always evaluate to either a digit 0-9, T or F. 1234567891011121314151617181920212223242526272829Example 1:Input: &quot;T?2:3&quot;Output: &quot;2&quot;Explanation: If true, then result is 2; otherwise result is 3.Example 2:Input: &quot;F?1:T?4:5&quot;Output: &quot;4&quot;Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as: &quot;(F ? 1 : (T ? 4 : 5))&quot; &quot;(F ? 1 : (T ? 4 : 5))&quot; -&gt; &quot;(F ? 1 : 4)&quot; or -&gt; &quot;(T ? 4 : 5)&quot; -&gt; &quot;4&quot; -&gt; &quot;4&quot;Example 3:Input: &quot;T?T?F:5:3&quot;Output: &quot;F&quot;Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as: &quot;(T ? (T ? F : 5) : 3)&quot; &quot;(T ? (T ? F : 5) : 3)&quot; -&gt; &quot;(T ? F : 3)&quot; or -&gt; &quot;(T ? F : 5)&quot; -&gt; &quot;F&quot; -&gt; &quot;F&quot; 解题思路： 先对字符串反转，每次向后读取进栈，如果遇到问号，则根据问号后是T还是F来弹栈，如果是T，则将最后一位保留，倒数第二位：和第三位删除，否则删除倒数第一和第二位，其他的保留。 python1234567891011121314151617181920class Solution(object): def parseTernary(self, expression): """ :type expression: str :rtype: str """ expression = expression[::-1] res = [] i = 0 while i &lt; len(expression): if expression[i] != '?': res.append(expression[i]) else: i += 1 if expression[i] == 'F': res = res[:-3] + [res[-3]] elif expression[i] == 'T': res = res[:-3] + [res[-1]] i += 1 return res[-1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[438. Find All Anagrams in a String]]></title>
    <url>%2Fp%2F5b7aa67c%2F</url>
    <content type="text"><![CDATA[33.5% Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. 1234567891011Example 1:Input:s: &quot;cbaebabacd&quot; p: &quot;abc&quot;Output:[0, 6]Explanation:The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;. 123456789101112Example 2:Input:s: &quot;abab&quot; p: &quot;ab&quot;Output:[0, 1, 2]Explanation:The substring with start index = 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.The substring with start index = 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.The substring with start index = 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;. 解题思路 使用数组做一个简单哈希表，另外一个数组每次进行预算，向前移动一次，增加一个元素，减去最前面的元素，每次与标准哈希表比较，确定是否加进去。 cpp123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; int cs[26] = &#123;&#125;, cp[26] = &#123;&#125;; vector&lt;int&gt; res; for(int i=0; i&lt;(int)p.length(); i++)&#123; cp[p[i]-&apos;a&apos;]++; &#125; for(int i=0; i&lt;(int)s.length(); i++)&#123; cs[s[i]-&apos;a&apos;]++; if(i&gt;=p.length()) cs[s[i-p.length()]-&apos;a&apos;]--; bool flag = true; for(int j=0; j&lt;26; j++) flag &amp;= cs[j] == cp[j]; if(flag==true) res.push_back(i-p.length()+1); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[437. Path Sum III]]></title>
    <url>%2Fp%2F2c1efbd3%2F</url>
    <content type="text"><![CDATA[38.9% https://leetcode.com/problems/path-sum-iii/?tab=Description You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. 1234567891011121314151617Example:root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \ 5 -3 / \ \ 3 2 11 / \ \3 -2 1Return 3. The paths that sum to 8 are:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 方法一： 每一个根节点，一个方向是依照此根节点为一个节点，找到sum。另一个是不含此根节点，寻找下一个根节点为出发点的和。下一个类似于此根节点 1234567891011121314151617181920212223242526class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; int ans = 0; go(root, sum, ans); return ans; &#125; void go(TreeNode *root, int need, int &amp;res)&#123; if(!root) return; go2(root, need - root-&gt;val, res); go(root-&gt;left, need, res); go(root-&gt;right, need, res); &#125; void go2(TreeNode *root, int need, int &amp;res)&#123; if(!root) return; if(!need) res++; if(root-&gt;left) go2(root-&gt;left, need - root-&gt;left-&gt;val, res); if(root-&gt;right) go2(root-&gt;right, need - root-&gt;right-&gt;val, res); &#125; &#125;; 我的代码实现： 第一个函数visit，表示遍历，遍历到root的每个节点 每个节点都有一个从该节点为开始，至一定节点的路径要判断，所以用helper函数。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; int res = 0; visit(root, sum, res); return res; &#125; void visit(TreeNode* root, int need, int&amp; res)&#123; if(!root) return; helper(root, need, res); visit(root-&gt;left, need, res); visit(root-&gt;right, need, res); &#125; void helper(TreeNode* root, int need, int&amp; res)&#123; if(!root) return; if(need==root-&gt;val) res += 1; helper(root-&gt;left, need-root-&gt;val, res); helper(root-&gt;right, need-root-&gt;val, res); &#125;&#125;; https://discuss.leetcode.com/topic/64402/c-5-line-body-code-dfs-solution C++ 5 Line Body Code DFS Solution For tree structure problems. recursion is usually intuitive and easy to write. lol 12345678910111213class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; if(!root) return 0; return sumUp(root, 0, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum); &#125;private: int sumUp(TreeNode* root, int pre, int&amp; sum)&#123; if(!root) return 0; int current = pre + root-&gt;val; return (current == sum) + sumUp(root-&gt;left, current, sum) + sumUp(root-&gt;right, current, sum); &#125;&#125;; https://discuss.leetcode.com/topic/64414/18ms-fast-one-pass-c-solution 18ms Fast One Pass C++ Solution 1234567891011121314151617class Solution &#123;public: int help(TreeNode* root, int sum, unordered_map&lt;int, int&gt;&amp; store, int pre) &#123; if (!root) return 0; root-&gt;val += pre; int res = (root-&gt;val == sum) + (store.count(root-&gt;val - sum) ? store[root-&gt;val - sum] : 0); store[root-&gt;val]++; res += help(root-&gt;left, sum, store, root-&gt;val) + help(root-&gt;right, sum, store, root-&gt;val); store[root-&gt;val]--; return res; &#125; int pathSum(TreeNode* root, int sum) &#123; unordered_map&lt;int, int&gt; store; return help(root, sum, store, 0); &#125;&#125;; https://discuss.leetcode.com/topic/64438/c-straight-forward-solution C++ straight forward solution 1234567891011121314151617181920class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; int res = 0; pathSumHelper(root, sum, res, false); return res; &#125; void pathSumHelper(TreeNode* root, int sum, int &amp;res, bool parent_used) &#123; if (!root) return; if (sum - root-&gt;val == 0) res++; pathSumHelper(root-&gt;left, sum - root-&gt;val, res, true); pathSumHelper(root-&gt;right, sum - root-&gt;val, res, true); if (parent_used == false) &#123; //if parent is part of the sum, then we cannot start a new path which jump over this node pathSumHelper(root-&gt;left, sum, res, false); pathSumHelper(root-&gt;right, sum, res, false); &#125; &#125;&#125;; For tree structure problems. recursion is usually intuitive and easy to write. lol https://discuss.leetcode.com/topic/64402/c-5-line-body-code-dfs-solution 12345678910111213class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; if(!root) return 0; return sumUp(root, 0, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum); &#125;private: int sumUp(TreeNode *root, int pre, int&amp;sum)&#123; if(!root) return 0; int current = pre + root-&gt;val; return (current == sum) + sumUp(root-&gt;left, current, sum) + sumUp(root-&gt;right, current, sum); &#125;&#125;; https://discuss.leetcode.com/topic/65100/python-solution-with-detailed-explanation Python solution with detailed explanation Path Sum III https://leetcode.com/problems/path-sum-iii/ Brute Force Solution The simplest solution is to traverse each node (preorder traversal) and then find all paths which sum to the target using this node as root. The worst case complexity for this method is N^2. If we have a balanced tree, we have the recurrence: T(N) = N + 2T(N/2). This is the merge sort recurrence and suggests NlgN. 123456789101112131415class SolutionBruteForce(object): def find_paths(self, root, target): if root: return int(root.val == target) + self.find_paths(root.left, target-root.val) + self.find_paths(root.right, target-root.val) return 0 def pathSum(self, root, sum): &quot;&quot;&quot; :type root: TreeNode :type sum: int :rtype: int &quot;&quot;&quot; if root: return self.find_paths(root, sum) + self.pathSum(root.left, sum) + self.pathSum(root.right, sum) return 0 Two Sum Method: Optimized Solution A more efficient implementation uses the Two Sum idea. It uses a hash table (extra memory of order N). With more space, it gives us an O(N) complexity. As we traverse down the tree, at an arbitrary node N, we store the sum until this node N (sum_so_far (prefix) + N.val). in hash-table. Note this sum is the sum from root to N. Now at a grand-child of N, say G, we can compute the sum from the root until G since we have the prefix_sum until this grandchild available.We pass in our recursive routine. How do we know if we have a path of target sum which ends at this grand-child G? Say there are multiple such paths that end at G and say they start at A, B, C where A,B,C are predecessors of G. Then sum(root-&gt;G) - sum(root-&gt;A) = target. Similarly sum(root-&gt;G)-sum(root&gt;B) = target. Therefore we can compute the complement at G as sum_so_far+G.val-target and look up the hash-table for the number of paths which had this sum Now after we are done with a node and all its grandchildren, we remove it from the hash-table. This makes sure that the number of complement paths returned always correspond to paths that ended at a predecessor node. 12345678910111213141516171819202122class Solution(object): def helper(self, root, target, so_far, cache): if root: complement = so_far + root.val - target if complement in cache: self.result += cache[complement] cache.setdefault(so_far+root.val, 0) cache[so_far+root.val] += 1 self.helper(root.left, target, so_far+root.val, cache) self.helper(root.right, target, so_far+root.val, cache) cache[so_far+root.val] -= 1 return def pathSum(self, root, sum): &quot;&quot;&quot; :type root: TreeNode :type sum: int :rtype: int &quot;&quot;&quot; self.result = 0 self.helper(root, sum, 0, &#123;0:1&#125;) return self.result https://discuss.leetcode.com/topic/64396/easy-recursive-python-7-lines-solution Easy Recursive Python 7 lines Solution Similar to #112 and #113, check the whole tree. The only difference is: Any node can play as start or end in a valid path. After each visit, use current node as start, and update the “targets” list. Pass the updated targets and initial target through. Base case: node is None Recursive case: node fits in certain path sum. node doesn’t meet. 1234567891011class Solution(object): def pathSum(self, root, s): return self.helper(root, s, [s]) def helper(self, node, origin, targets): if not node: return 0 hit = 0 for t in targets: if not t-node.val: hit += 1 # count if sum == target targets = [t-node.val for t in targets]+[origin] # update the targets return hit+self.helper(node.left, origin, targets)+self.helper(node.right, origin, targets)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[435. Non-overlapping Intervals]]></title>
    <url>%2Fp%2Fc873fefa%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/non-overlapping-intervals/ Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Note: You may assume the interval’s end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders “touching” but they don’t overlap each other. 123456Example 1:Input: [ [1,2], [2,3], [3,4], [1,3] ]Output: 1Explanation: [1,3] can be removed and the rest of intervals are non-overlapping. 123456Example 2:Input: [ [1,2], [1,2], [1,2] ]Output: 2Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping. 123456Example 3:Input: [ [1,2], [2,3] ]Output: 0Explanation: You don&apos;t need to remove any of the intervals since they&apos;re already non-overlapping. java https://discuss.leetcode.com/topic/65594/java-least-is-most Java: Least is Most Actually, the problem is the same as “Given a collection of intervals, find the maximum number of intervals that are non-overlapping.” (the classic Greedy problem: Interval Scheduling). With the solution to that problem, guess how do we get the minimum number of intervals to remove? : ) Sorting Interval.end in ascending order is O(nlogn), then traverse intervals array to get the maximum number of non-overlapping intervals is O(n). Total is O(nlogn). 123456789101112131415161718192021public int eraseOverlapIntervals(Interval[] intervals) &#123; if (intervals.length == 0) return 0; Arrays.sort(intervals, new myComparator()); int end = intervals[0].end; int count = 1; for (int i = 1; i &lt; intervals.length; i++) &#123; if (intervals[i].start &gt;= end) &#123; end = intervals[i].end; count++; &#125; &#125; return intervals.length - count;&#125;class myComparator implements Comparator&lt;Interval&gt; &#123; public int compare(Interval a, Interval b) &#123; return a.end - b.end; &#125;&#125; https://discuss.leetcode.com/topic/65828/java-solution-with-clear-explain Java Solution with clear explain First we sort the array by below rules 121) sort by end, smaller end in front2) if end is same, sort by start, bigger start in front Then, visited array by end. If we visited next closest end interval, access the bigger start priority. 1234567891011121314151617181920212223242526/** * 16 / 16 test cases passed * Status: Accepted * Runtime: 9 - 10 ms * * @param intervals * @return */public int eraseOverlapIntervals(Interval[] intervals) &#123; Arrays.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval o1, Interval o2) &#123; if (o1.end != o2.end) return o1.end - o2.end; //first sort by end return o2.start - o1.start; //second sort by start &#125; &#125;); int end = Integer.MIN_VALUE; int count = 0; for (Interval interval : intervals) &#123; if (interval.start &gt;= end) end = interval.end; else count++; &#125; return count; &#125; https://discuss.leetcode.com/topic/65583/o-nlogn-java-solution O(nlogn) java solution, used similar logic to “Merge Inteval” problem in leetcode to solve this problem. https://discuss.leetcode.com/topic/4319/a-simple-java-solution/2 123456789101112131415161718192021222324public int eraseOverlapIntervals(Interval[] intervals) &#123; if (intervals == null || intervals.length &lt; 2)&#123; return 0; &#125; //sort based on start time of the interval Arrays.sort(intervals, new Comparator&lt;Interval&gt;()&#123; @Override public int compare(Interval e0, Interval e1)&#123; return Integer.compare(e0.start, e1.start); &#125; &#125;); int n = intervals.length; int endLast = intervals[0].end; int ret = 0; for (int i = 1; i &lt; n; i++)&#123; int incremental = endLast &gt; intervals[i].start? +1: 0; endLast = incremental == 1? Math.min(endLast, intervals[i].end): intervals[i].end; ret += incremental; &#125; return ret; &#125; cpp https://discuss.leetcode.com/topic/65629/concise-c-solution Concise C++ Solution 12345678910111213141516class Solution &#123;public: int eraseOverlapIntervals(vector&lt;Interval&gt;&amp; intervals) &#123; auto comp = [](const Interval&amp; i1, const Interval&amp; i2)&#123; return i1.start &lt; i2.start; &#125;; sort(intervals.begin(), intervals.end(), comp); int res = 0, pre = 0; for (int i = 1; i &lt; intervals.size(); i++) &#123; if (intervals[i].start &lt; intervals[pre].end) &#123; res++; if (intervals[i].end &lt; intervals[pre].end) pre = i; &#125; else pre = i; &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/65672/short-ruby-and-python Short Ruby and Python Which interval would be the best first (leftmost) interval to keep? One that ends first, as it leaves the most room for the rest. So take one with smallest end, remove all the bad ones overlapping it, and repeat (taking the one with smallest end of the remaining ones). For the overlap test, just keep track of the current end, initialized with negative infinity. Take out intervals as described above, so what’s left is the bad overlapping ones, so just return their number. Alternatively, i.start &gt;= end_ and end_ = i.end works, too. 123456789def eraseOverlapIntervals(self, intervals): end = float(&apos;-inf&apos;) erased = 0 for i in sorted(intervals, key=lambda i: i.end): if i.start &gt;= end: end = i.end else: erased += 1 return erased]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[434. Number of Segments in a String]]></title>
    <url>%2Fp%2F3ed00b13%2F</url>
    <content type="text"><![CDATA[37.1% https://leetcode.com/problems/number-of-segments-in-a-string/ Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters. Please note that the string does not contain any non-printable characters. 1234Example:Input: &quot;Hello, my name is John&quot;Output: 5 cpphttps://discuss.leetcode.com/topic/70736/one-liners 6ms, 0.00%, Dec.30, 2016 123456class Solution &#123;public: int countSegments(string s) &#123; return regex_replace(regex_replace(s, regex(&quot;\\S+&quot;), &quot;x&quot;), regex(&quot; &quot;), &quot;&quot;).size(); &#125;&#125;; https://discuss.leetcode.com/topic/70640/o-n-sentinel-value-concise-solution-c 1234567891011class Solution &#123;public: int countSegments(string s) &#123; int res = 0; s.push_back(&apos; &apos;); for(int i=1; i&lt;s.size(); ++i) if(s[i]==&apos; &apos; &amp;&amp; s[i-1]!=&apos; &apos;) ++res; return res; &#125;&#125;; https://discuss.leetcode.com/topic/70651/c-concise-three-line-solutions 123456789class Solution &#123;public: int countSegments(string s) &#123; int res = 0; for(int i=0; i&lt;s.size(); i++) res += s[i] != &apos; &apos; &amp;&amp; (i+1 == s.size() || s[i+1]==&apos; &apos;); return res; &#125;&#125;; pythonhttps://discuss.leetcode.com/topic/70736/one-liners 1234567class Solution(object): def countSegments(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; return len(s.split()) my code: 12345678910111213class Solution(object): def countSegments(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; # return len(s.split()) cnt = 0 for i, char in enumerate(s): if char != &apos; &apos; and (i==0 or s[i-1] == &apos; &apos;): cnt += 1 return cnt javahttps://discuss.leetcode.com/topic/70642/clean-java-solution-o-n Time complexity: O(n) Space complexity: O(1)123456789public class Solution &#123; public int countSegments(String s) &#123; int res = 0; for(int i=0; i&lt;s.length(); i++) if(s.charAt(i) != &apos; &apos; &amp;&amp; (i==0 || s.charAt(i-1)==&apos; &apos;)) res++; return res; &#125;&#125; https://discuss.leetcode.com/topic/70736/one-liners 12345public class Solution &#123; public int countSegments(String s) &#123; return (&quot;x &quot; + s).split(&quot; +&quot;).length - 1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[423. Reconstruct Original Digits from English]]></title>
    <url>%2Fp%2Fc1b7b788%2F</url>
    <content type="text"><![CDATA[43.1% https://leetcode.com/problems/reconstruct-original-digits-from-english/ Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order. Note: Input contains only lowercase English letters.Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as “abc” or “zerone” are not permitted.Input length is less than 50,000. 12345&gt; Example 1:&gt; Input: &quot;owoztneoer&quot;&gt; &gt; Output: &quot;012&quot;&gt; 12345&gt; Example 2:&gt; Input: &quot;fviefuro&quot;&gt; &gt; Output: &quot;45&quot;&gt; cppOctober 16, 2016 123456789101112131415161718192021222324252627class Solution &#123;public: string originalDigits(string s) &#123; string res = &quot;&quot;; vector&lt;int&gt; alpha(26, 0); for(int i=0; i&lt;s.length(); i++) alpha[s[i] - &apos;a&apos;]++; int count = 0; vector&lt;int&gt; num(10, 0); num[0] = alpha[&apos;z&apos;-&apos;a&apos;]; num[2] = alpha[&apos;w&apos;-&apos;a&apos;]; num[3] = alpha[&apos;h&apos;-&apos;a&apos;] - alpha[&apos;g&apos;-&apos;a&apos;]; num[4] = alpha[&apos;u&apos;-&apos;a&apos;]; num[5] = alpha[&apos;f&apos;-&apos;a&apos;] - alpha[&apos;u&apos;-&apos;a&apos;]; num[6] = alpha[&apos;x&apos;-&apos;a&apos;]; num[7] = alpha[&apos;s&apos;-&apos;a&apos;] - alpha[&apos;x&apos;-&apos;a&apos;]; num[8] = alpha[&apos;g&apos;-&apos;a&apos;]; num[9] = alpha[&apos;i&apos;-&apos;a&apos;] - num[5] - num[6] - num[8]; num[1] = alpha[&apos;n&apos;-&apos;a&apos;] - num[7] - 2*num[9]; for(int i=0; i&lt;=9; i++) for(int j=0; j&lt;num[i]; j++) res += to_string(i); return res; &#125;&#125;; pythonmy solution: 98ms, , October 16, 2016 https://discuss.leetcode.com/topic/63425/my-python-mathematic-solution-o-n-easy-to-understand 12345678910111213141516171819202122232425262728class Solution(object): def originalDigits(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; nums = [0]*26 for i in s: nums[ord(i)-97] += 1 temp = [0]*10 temp[0] = nums[25] temp[2] = nums[22] temp[4] = nums[20] temp[6] = nums[23] temp[8] = nums[6] temp[7] = nums[18] - temp[6] temp[5] = nums[21] - temp[7] temp[3] = nums[17] - temp[0] - temp[4] temp[9] = nums[8] - temp[5] - temp[6] - temp[8] temp[1] = nums[14] - temp[0] -temp[2] - temp[4] res = &apos;&apos; for i, n in enumerate(temp): if n &gt; 0: res += str(i) * n return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[422. Valid Word Square]]></title>
    <url>%2Fp%2Ff4df1e1a%2F</url>
    <content type="text"><![CDATA[36.1% Given a sequence of words, check whether it forms a valid word square. A sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k &lt; max(numRows, numColumns). Note: The number of words given is at least 1 and does not exceed 500. Word length will be at least 1 and does not exceed 500. Each word contains only lowercase English alphabet a-z. java34ms, , October 16, 2016 https://discuss.leetcode.com/topic/63387/java-ac-solution-easy-to-understand 123456789101112131415public class Solution &#123; public boolean validWordSquare(List&lt;String&gt; words) &#123; if(words == null || words.size() == 0)&#123; return true; &#125; int n = words.size(); for(int i=0; i&lt;n; i++) for(int j=0; j&lt;words.get(i).length(); j++) if(n &lt;= j || words.get(j).length()&lt;=i || words.get(j).charAt(i) != words.get(i).charAt(j)) return false; return true; &#125;&#125; cpp23ms, , October 16, 2016 question:https://leetcode.com/contest/9/problems/valid-word-square/ https://discuss.leetcode.com/topic/63377/accepted-concise-c-solution 12345678910class Solution &#123;public: bool validWordSquare(vector&lt;string&gt;&amp; words) &#123; for(int i=0; i&lt; words.size(); ++i) for(int j=0; j&lt;words[i].size(); ++j) if(words.size() &lt;= j || words[j].size() &lt;= i || words[j][i] != words[i][j]) return false; return true; &#125;&#125;; python129ms, , October 16, 2016 https://discuss.leetcode.com/topic/63377/accepted-concise-c-solution 1234567891011class Solution(object): def validWordSquare(self, words): &quot;&quot;&quot; :type words: List[str] :rtype: bool &quot;&quot;&quot; for i in range(len(words)): for j in range(len(words[i])): if len(words) &lt;= j or len(words[j]) &lt;= i or words[i][j] != words[j][i]: return False return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[421. Maximum XOR of Two Numbers in an Array]]></title>
    <url>%2Fp%2Feb5e02ea%2F</url>
    <content type="text"><![CDATA[44.0% https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/?tab=Description Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai &lt; 231. Find the maximum result of ai XOR aj, where 0 ≤ i, j &lt; n. Could you do this in O(n) runtime? 1234567Example:Input: [3, 10, 5, 25, 2, 8]Output: 28Explanation: The maximum result is 5 ^ 25 = 28.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>bit manipulation</tag>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[420. Strong Password Checker]]></title>
    <url>%2Fp%2F583035f%2F</url>
    <content type="text"><![CDATA[20.5% https://leetcode.com/problems/strong-password-checker/?tab=Description A password is considered strong if below conditions are all met: It has at least 6 characters and at most 20 characters. It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit. It must NOT contain three repeating characters in a row (“…aaa…” is weak, but “…aa…a…” is strong, assuming other conditions are met). Write a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0. Insertion, deletion or replace of any one character are all considered as one change. 对于三个条件，先理解。然后解决的时候采用分类讨论思想。分为&lt;6, &gt;=6 &amp;&amp; &lt;=20, &gt;20三种情况。 java https://discuss.leetcode.com/topic/63185/java-easy-solution-with-explanation JAVA Easy Solution with explanation There are 2 wrong test cases which I list at the beginning. The general idea is to record some states, and calculate the edit distance at the end. All detail are explained in the comments. 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; public int strongPasswordChecker(String s) &#123; if(s.length()&lt;2) return 6-s.length(); //Initialize the states, including current ending character(end), existence of lowercase letter(lower), uppercase letter(upper), digit(digit) and number of replicates for ending character(end_rep) char end = s.charAt(0); boolean upper = end&gt;=&apos;A&apos;&amp;&amp;end&lt;=&apos;Z&apos;, lower = end&gt;=&apos;a&apos;&amp;&amp;end&lt;=&apos;z&apos;, digit = end&gt;=&apos;0&apos;&amp;&amp;end&lt;=&apos;9&apos;; //Also initialize the number of modification for repeated characters, total number needed for eliminate all consequnce 3 same character by replacement(change), and potential maximun operation of deleting characters(delete). Note delete[0] means maximum number of reduce 1 replacement operation by 1 deletion operation, delete[1] means maximun number of reduce 1 replacement by 2 deletion operation, delete[2] is no use here. int end_rep = 1, change = 0; int[] delete = new int[3]; for(int i = 1;i&lt;s.length();++i)&#123; if(s.charAt(i)==end) ++end_rep; else&#123; change+=end_rep/3; if(end_rep/3&gt;0) ++delete[end_rep%3]; //updating the states end = s.charAt(i); upper = upper||end&gt;=&apos;A&apos;&amp;&amp;end&lt;=&apos;Z&apos;; lower = lower||end&gt;=&apos;a&apos;&amp;&amp;end&lt;=&apos;z&apos;; digit = digit||end&gt;=&apos;0&apos;&amp;&amp;end&lt;=&apos;9&apos;; end_rep = 1; &#125; &#125; change+=end_rep/3; if(end_rep/3&gt;0) ++delete[end_rep%3]; //The number of replcement needed for missing of specific character(lower/upper/digit) int check_req = (upper?0:1)+(lower?0:1)+(digit?0:1); if(s.length()&gt;20)&#123; int del = s.length()-20; //Reduce the number of replacement operation by deletion if(del&lt;=delete[0]) change-=del; else if(del-delete[0]&lt;=2*delete[1]) change-=delete[0]+(del-delete[0])/2; else change-=delete[0]+delete[1]+(del-delete[0]-2*delete[1])/3; return del+Math.max(check_req,change); &#125; else return Math.max(6-s.length(), Math.max(check_req, change)); &#125;&#125; The author is already fixed all the test cases. https://discuss.leetcode.com/topic/63854/o-n-java-solution-by-analyzing-changes-allowed-to-fix-each-problem O(n) java solution by analyzing changes allowed to fix each problem The basic principle is straightforward: if we want to make MINIMUM changes to turn s into a strong password, each change made should fix as many problems as possible. So to start, let’s first identify all the problems in the input string s and list what changes are suitable for righting each of them. To clarify, each change should be characterized by at least two parts: the type of operation it takes and the position in the string where the operation is applied (Note: Ideally we should also include the characters involved in the operation and the “power” of each operation for eliminating problems but they turn out to be partially relevant so I will mention them only when appropriate). Length problem: if the total length is less than 6, the change that should be made is (insert, any position), which reads as “the operation is insertion and it can be applied to anywhere in the string”. If the total length is greater than 20, then the change should be (delete, any position). Missing letter or digit: if any of the lowercase/uppercase letters or digits is missing, we can do either (insert, any position) or (replace, any position) to correct it. (Note here the characters for insertion or replacement can only be those missing.) Repeating characters: for repeating characters, all three operations are allowed but the positions where they can be applied are limited within the repeating characters. For example, to fix “aaaaa”, we can do one replacement (replace the middle ‘a’) or two insertions (one after the second ‘a’ and one after the fourth ‘a’) or three deletions (delete any of the three ‘a’s). So the possible changes are (replace, repeating characters), (insert, repeating characters), (delete, repeating characters). (Note however the “power” of each operation for fixing the problem are different – replacement is the strongest while deletion is the weakest.) All right, what’s next? If we want a change to eliminate as many problems as it can, it must be shared among the possible solutions to each problem it can fix. So our task is to find out possible overlapping among the changes for fixing each problem. Since there are most (three) changes allowed for the third problem, we may start from combinations first problem &amp; third problem and second problem &amp; third problem. It’s not too hard to conclude that any change that can fix the first or second problems is also able to fix the third one (since the type of operation here is irrelevant, we are free to choose the position of the operation to match those of the repeating characters). For combination first problem &amp; second problem, depending on the length of the string, there will be overlapping if length is less than 6 or no overlapping if length is greater than 20. From the analyses above, it seems worthwhile to distinguish between the two cases: when the input string is too short or too long. For the former case, it can be shown that the total changes needed to fix the first and second problems always outnumber those for the third one. Since whatever change used fixing the first two problems can also correct the third one, we may concern ourselves with only the first two. Also as there is overlapping between the changes for fixing the first two problems, we will prefer those overlapping ones, i.e. (insert, any position). Another point is that the characters involved in the operation matters now. To fix the first problem, only those missing characters can be inserted while for the second condition, it can be any character. Therefore correcting the first problem takes precedence over the second one. For the latter case, there is overlapping between the first &amp; third and second &amp; third problems, so those overlapping changes will be taken, i.e., first problem =&gt; (delete, any position), second problem =&gt; (replace, any position). The reason not to use (insert, any position) for the second problem is that it contradicts the changes made to the first problem (therefore has the tendency to cancel its effects). After fixing the first two problems, what operation(s) should we choose for the third one? Now the “power” of each operation for eliminating problems comes into play. For the third problem, the “power” of each operation will be measured by the maximum number of repeating characters it is able to get rid of. For example, one replacement can eliminate at most 5 repeating characters while insertion and deletion can do at most 4 and 3, respectively. In this case, we say replacement has more “power” than insertion or deletion. Intuitively the more “powerful” the operation is, the less number of changes is needed for correcting the problem. Therefore (replace, repeating characters) triumphs in terms of fixing the third problem. Furthermore, another very interesting point shows up when the “power” of operation is taken into consideration (And thank yicui for pointing it out). As I mentioned that there is overlapping between changes made for fixing the first two problems and for the third one, which means the operations chosen above for the first two problems will also be applied to the third one. For the second problem with change chosen as (replace, any position), we have no problem adapting it so that it coincides with the optimal change (replace, repeating characters) made for the third problem. However, there is no way to do the same for the first problem with change (delete, any position). We have a conflict now! How do we reconcile it? The trick is that for a sequence of repeating characters of length k (k &gt;= 3), instead of turning it all the way into a sequence of length 2 (so as to fix the repeating character problem) by the change (delete, any position), we will first reduce its length to (3m + 2), where (3m + 2) is the largest integer of the form yet no more than k. That is to say, if k is a multiple of 3, we apply once such change so its length will become (k - 1); else if k is a multiple of 3 plus 1, we apply twice such change to cut its length down to (k - 2), provided we have more such changes to spare (be careful here as we need at least two changes but the remaining available changes may be less than that, so we should stick to the smaller one: 2 or the remaining available changes). The reason is that the optimal change (replace, repeating characters) for the third problem will be most “powerful” when the total length of the repeating characters is of this form. Of course, if we still have more changes (delete, any position) to do after that, then we are free to turn the repeating sequence all the way into a sequence of length 2. Here is the java program based on the above analyses. Both time and space complexity is O(n). Not sure if we can reduce the space down to O(1) by computing the arr array on the fly. A quick explanation is given at the end. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public int strongPasswordChecker(String s) &#123; int res = 0, a = 1, A = 1, d = 1; char[] carr = s.toCharArray(); int[] arr = new int[carr.length]; for (int i = 0; i &lt; arr.length;) &#123; if (Character.isLowerCase(carr[i])) a = 0; if (Character.isUpperCase(carr[i])) A = 0; if (Character.isDigit(carr[i])) d = 0; int j = i; while (i &lt; carr.length &amp;&amp; carr[i] == carr[j]) i++; arr[j] = i - j; &#125; int total_missing = (a + A + d); if (arr.length &lt; 6) &#123; res += total_missing + Math.max(0, 6 - (arr.length + total_missing)); &#125; else &#123; int over_len = Math.max(arr.length - 20, 0), left_over = 0; res += over_len; for (int k = 1; k &lt; 3; k++) &#123; for (int i = 0; i &lt; arr.length &amp;&amp; over_len &gt; 0; i++) &#123; if (arr[i] &lt; 3 || arr[i] % 3 != (k - 1)) continue; arr[i] -= Math.min(over_len, k); over_len -= k; &#125; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt;= 3 &amp;&amp; over_len &gt; 0) &#123; int need = arr[i] - 2; arr[i] -= over_len; over_len -= need; &#125; if (arr[i] &gt;= 3) left_over += arr[i] / 3; &#125; res += Math.max(total_missing, left_over); &#125; return res;&#125; A quick explanation of the program: res denotes the minimum changes; a, A and d are the number of missing lowercase letters, uppercase letters and digits, respectively; arr is an integer array whose element will be the number of repeating characters starting at the corresponding position in the string. In the following loop we fill in the values for a, A, d and arr to identify the problems for each condition. The total number of missing characters total_missing will be the summation of a, A, d and fixing this problem takes at least total_missing changes. We then distinguish the two cases when the string is too short or too long. If it is too short, we pad its length to at least 6 (note in this case we’ve already inserted total_missing characters so the new length is the summation of the original length and total_missing). Otherwise, to fix the first condition, we need to delete over_len (number of surplus characters) characters. Since fixing the first problem also corrects the third one, we need to get rid of those parts from the arr array. And as I mentioned, we need to first turn all numbers in the arr array greater than 2 into the form of (3m + 2) and then reduce them all the way to 2 if over_len is still greater than 0. After that, we need to replace total_missing characters to fix the second problem, which also fixes part (or all) of the third problem. Therefore we only need to take the larger number of changes needed for fixing the second problem (which is total_missing) and for the third one (which is left_over, since it is the number of changes still needed after fixing the first problem). https://discuss.leetcode.com/topic/64511/java-with-detailed-explanation java with detailed explanation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class Solution &#123; public int strongPasswordChecker(String s) &#123; int minReplace = getMinReplace(s); if (s.length() &lt; 6)&#123; int insersion = 6 - s.length(); return Math.max(insersion, minReplace); &#125; else if (s.length() &lt;= 20)&#123; List&lt;Integer&gt; groups = generateGroups(s); int replace = 0; for (int group : groups)&#123; replace += group / 3; &#125; return Math.max(replace, minReplace); &#125; else &#123; List&lt;Integer&gt; groups = generateGroups(s); Collections.sort(groups); int charCount = 0; int n = 0; while (charCount &lt; 20 &amp;&amp; n &lt; groups.size()) &#123; charCount += groups.get(n); n++; &#125; while (groups.size() &gt; n) &#123; groups.remove(groups.size() - 1); &#125; charCount = 0; int badGroup = 0; for (int i = 0; i &lt; groups.size(); i++) &#123; if (groups.get(i) &gt; 20) &#123; groups.set(i, 20); &#125; charCount += groups.get(i); if (groups.get(i) &gt; 2)&#123; badGroup++; &#125; &#125; int deletion = s.length() - 20; int toDelete = charCount - 20; int remainder = 0; while (toDelete &gt; 0 &amp;&amp; badGroup &gt; 0) &#123; for (int i = 0; i &lt; n; i++) &#123; if (groups.get(i) &gt; 2 &amp;&amp; groups.get(i) % 3 == remainder) &#123; int del = Math.min(toDelete, remainder + 1); groups.set(i, groups.get(i) - del); toDelete -= del; if (groups.get(i) &lt;= 2)&#123; badGroup--; &#125; if (toDelete == 0 || badGroup == 0) &#123; break; &#125; &#125; &#125; remainder = (remainder + 1) % 3; &#125; int replace = 0; for (int i = 0; i &lt; groups.size(); i++) &#123; replace += groups.get(i) / 3; &#125; return deletion + Math.max(replace, minReplace); &#125; &#125; /** * generate sorted groups * groups: # of continuous characters in S */ private List&lt;Integer&gt; generateGroups(String s)&#123; List&lt;Integer&gt; groups = new ArrayList&lt;&gt;(); for (int i = 0 ; i &lt; s.length();)&#123; int j = i; while (j &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(i))&#123; j++; &#125; groups.add(j - i); i = j; &#125; return groups; &#125; /** * return # of replacements needed to satisfy 2 */ private int getMinReplace(String s)&#123; boolean[] dls = new boolean[3]; for(char c : s.toCharArray())&#123; dls[getClass(c)] = true; &#125; int replace = 0; for (int i = 0; i &lt; dls.length; i++)&#123; if (!dls[i]) replace++; &#125; return replace; &#125; private int getClass(char c)&#123; if (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;)&#123; return 0; &#125; else if (c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;z&apos;)&#123; return 1; &#125; else&#123; return 2; &#125; &#125;&#125; cpp https://discuss.leetcode.com/topic/65158/c-0ms-o-n-35-lines-solution-with-detailed-explanation C++ 0ms O(n) 35 lines solution with detailed explanation I’ve separated the problem into three cases: 123(1) s.length() &lt; 6(2) 6 &lt;= s.length() &lt;= 20(3) s.length() &gt; 20 Let’s look at case (1) first. If s.length() &lt; 6, we know we have room to insert some more letters into s. Question is how to use the insertions effectively to reduce the number of potential replacements. I’m using a greedy approach for this one: I’m inserting one char between the second and third chars whenever I see a repetition of 3 letters as substring. e.g. Say we have room to insert some chars in string and we see a substring of “aaaa”. I’ll insert a ‘B’ to make it “aaBaa” to break the 3-char repetition, thus reducing potential replacement by 1. And we’ll do this until we can’t insert any more chars into s. When we reach this point, we’ll start dealing with case (2) For case (2), I still follow a greedy approach. I’m simply searching for 3-char repetitions, and replacing one of the chars to break the repetition.e.g. If we see a substring of “aaaa”, we’ll make it “aaBa”. My code deals with (1) and (2) together as s.length() &lt;= 20. Case (3) is a little bit tricky because simple greedy doesn’t work any more.When s.length() &gt; 20, we want to delete some chars instead of inserting chars to reduce potential replacements. Question is the same: how to do it effectively? Let’s do some observations here: Say len is the length of each repetition.(a) len % 3 only has three possible values, namely 0, 1 and 2.(b) Minimum number of replacements needed to break each repetition is len / 3.(c) Based on (a) and (b), we know that deletion can reduce replacements only if the deletion can change the value of len / 3(d) Based on (c), we know if we want to reduce 1 replacement, we need 1 deletion for len % 3 == 0, and 2 deletions for len % 3 == 1, and 3 deletions for len % 3 == 2. Given above observations, I simply implemented the solution to do (d). Also note that missing of upper case char, lower case char, or digit can always be resolved by insertion or replacement. I’ve pasted two versions of the solutions below, with and without comments, for easier reference. Without comments: 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: int strongPasswordChecker(string s) &#123; int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length()); int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1; for (int l = 0, r = 0; r &lt; s.length(); r++) &#123; if (isupper(s[r])) &#123; needUpper = 0; &#125; if (islower(s[r])) &#123; needLower = 0; &#125; if (isdigit(s[r])) &#123; needDigit = 0; &#125; if (r - l == 2) &#123; if (s[l] == s[l + 1] &amp;&amp; s[l + 1] == s[r]) &#123; if (toAdd &lt; addTarget) &#123; toAdd++, l = r; &#125; else &#123; toReplace++, l = r + 1; &#125; &#125; else &#123; l++; &#125; &#125; &#125; if (s.length() &lt;= 20) &#123; return max(addTarget + toReplace, needUpper + needLower + needDigit); &#125; toReplace = 0; vector&lt;unordered_map&lt;int, int&gt;&gt; lenCnts(3); for (int l = 0, r = 0, len; r &lt;= s.length(); r++) &#123; if (r == s.length() || s[l] != s[r]) &#123; if ((len = r - l) &gt; 2) &#123; lenCnts[len % 3][len]++; &#125; l = r; &#125; &#125; for (int i = 0, numLetters, dec; i &lt; 3; i++) &#123; for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) &#123; if (i &lt; 2) &#123; numLetters = i + 1, dec = min(it-&gt;second, (deleteTarget - toDelete) / numLetters); toDelete += dec * numLetters, it-&gt;second -= dec; if (it-&gt;first - numLetters &gt; 2) &#123; lenCnts[2][it-&gt;first - numLetters] += dec; &#125; &#125; toReplace += (it-&gt;second) * ((it-&gt;first) / 3); &#125; &#125; int dec = (deleteTarget - toDelete) / 3; toReplace -= dec, toDelete -= dec * 3; return deleteTarget + max(toReplace, needUpper + needLower + needDigit); &#125;&#125;; With comments: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: int strongPasswordChecker(string s) &#123; int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length()); int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1; /////////////////////////////////// // For cases of s.length() &lt;= 20 // /////////////////////////////////// for (int l = 0, r = 0; r &lt; s.length(); r++) &#123; if (isupper(s[r])) &#123; needUpper = 0; &#125; if (islower(s[r])) &#123; needLower = 0; &#125; if (isdigit(s[r])) &#123; needDigit = 0; &#125; if (r - l == 2) &#123; // if it&apos;s a three-letter window if (s[l] == s[l + 1] &amp;&amp; s[l + 1] == s[r]) &#123; // found a three-repeating substr if (toAdd &lt; addTarget) &#123; toAdd++, l = r; &#125; // insert letter to break repetition if possible else &#123; toReplace++, l = r + 1; &#125; // replace current word to avoid three repeating chars &#125; else &#123; l++; &#125; // keep the window with no more than 3 letters &#125; &#125; if (s.length() &lt;= 20) &#123; return max(addTarget + toReplace, needUpper + needLower + needDigit); &#125; ////////////////////////////////// // For cases of s.length() &gt; 20 // ////////////////////////////////// toReplace = 0; // reset toReplace vector&lt;unordered_map&lt;int, int&gt;&gt; lenCnts(3); // to record repetitions with (length % 3) == 0, 1 or 2 for (int l = 0, r = 0, len; r &lt;= s.length(); r++) &#123; // record all repetion frequencies if (r == s.length() || s[l] != s[r]) &#123; if ((len = r - l) &gt; 2) &#123; lenCnts[len % 3][len]++; &#125; // we only care about repetions with length &gt;= 3 l = r; &#125; &#125; /* Use deletions to minimize replacements, following below orders: (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1 (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1 (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three letters) decreases repalcements by 1 */ for (int i = 0, numLetters, dec; i &lt; 3; i++) &#123; for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) &#123; if (i &lt; 2) &#123; numLetters = i + 1, dec = min(it-&gt;second, (deleteTarget - toDelete) / numLetters); toDelete += dec * numLetters; // dec is the number of repetitions we&apos;ll delete from it-&gt;second -= dec; // update number of repetitions left // after letters deleted, it fits in the group where (length % 3) == 2 if (it-&gt;first - numLetters &gt; 2) &#123; lenCnts[2][it-&gt;first - numLetters] += dec; &#125; &#125; // record number of replacements needed // note if len is the length of repetition, we need (len / 3) number of replacements toReplace += (it-&gt;second) * ((it-&gt;first) / 3); &#125; &#125; int dec = (deleteTarget - toDelete) / 3; // try to delete multiple of three letters as many as possible toReplace -= dec, toDelete -= dec * 3; return deleteTarget + max(toReplace, needUpper + needLower + needDigit); &#125;&#125;; python https://discuss.leetcode.com/topic/63341/simple-python-solution Simple Python solution The len &lt; 6 and 6 &lt;= len &lt;= 20 cases are easy. When len &gt; 20, we need to do len - 20 times deletion. Also we need to do a change for every three repeating characters. For any repeating sequences with len % 3 == 0, we can reduce one replacement by deleting one character. For any repeating sequences with len % 3 == 1, we can reduce one replacement by deleting two character. For the remaining sequences, we can reduce every replacement by deleting three character. 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def strongPasswordChecker(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; missing_type = 3 if any(&apos;a&apos; &lt;= c &lt;= &apos;z&apos; for c in s): missing_type -= 1 if any(&apos;A&apos; &lt;= c &lt;= &apos;Z&apos; for c in s): missing_type -= 1 if any(c.isdigit() for c in s): missing_type -= 1 change = 0 one = two = 0 p = 2 while p &lt; len(s): if s[p] == s[p-1] == s[p-2]: length = 2 while p &lt; len(s) and s[p] == s[p-1]: length += 1 p += 1 change += length / 3 if length % 3 == 0: one += 1 elif length % 3 == 1: two += 1 else: p += 1 if len(s) &lt; 6: return max(missing_type, 6 - len(s)) elif len(s) &lt;= 20: return max(missing_type, change) else: delete = len(s) - 20 change -= min(delete, one) change -= min(max(delete - one, 0), two * 2) / 2 change -= max(delete - one - 2 * two, 0) / 3 return delete + max(missing_type, change)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[419. Battleships in a Board]]></title>
    <url>%2Fp%2Fd348909f%2F</url>
    <content type="text"><![CDATA[60.6% https://leetcode.com/problems/battleships-in-a-board/ Given an 2D board, count how many different battleships are in it. The battleships are represented with ‘X’s, empty slots are represented with ‘.’s. You may assume the following rules: You receive a valid board, made of only battleships or empty slots. Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size. At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.Example: 1234&gt; X..X&gt; ...X&gt; ...X&gt; In the above board there are 2 battleships.Invalid Example: 1234&gt; ...X&gt; XXXX&gt; ...X&gt; This is an invalid board that you will not receive - as battleships will always have a cell separating between them.Follow up:Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board? java4ms, October 18, 2016 https://discuss.leetcode.com/topic/62970/simple-java-solution 12345678910111213141516171819public class Solution &#123; public int countBattleships(char[][] board) &#123; int m = board.length; if(m==0) return 0; int n = board[0].length; int count = 0; for(int i=0; i&lt;m; i++) for(int j=0; j&lt;n; j++)&#123; if(board[i][j] == &apos;.&apos;) continue; if(i&gt;0 &amp;&amp; board[i-1][j] == &apos;X&apos;) continue; if(j&gt;0 &amp;&amp; board[i][j-1] == &apos;X&apos;) continue; count++; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[416. Partition Equal Subset Sum]]></title>
    <url>%2Fp%2Fb55b184b%2F</url>
    <content type="text"><![CDATA[38.3% https://leetcode.com/problems/partition-equal-subset-sum/?tab=Description Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. 1234567Example 1:Input: [1, 5, 11, 5]Output: trueExplanation: The array can be partitioned as [1, 5, 5] and [11]. 1234567Example 2:Input: [1, 2, 3, 5]Output: falseExplanation: The array cannot be partitioned into equal sum subsets. 相似问题 494 方法一: 两类，A + B = sum， A - B = 0得知 A=B = sum/2，sum必须为偶数 建立一个大vector然后去遍历，遍历方法可以学习一下 我的代码实现： 其中值得学习的，一个是accumulate函数，一个是遍历的方法。 12345678910111213141516class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int s = accumulate(nums.begin(), nums.end(), 0); return s&amp;1 ? false : helper(s&gt;&gt;1, nums); &#125; bool helper(int s, vector&lt;int&gt;&amp; nums)&#123; vector&lt;bool&gt;dp(s+1, false); dp[0] = true; for(auto num:nums) for(int i=s; i&gt;=num; i--) dp[i] = dp[i] || dp[i-num]; return dp[s]; &#125;&#125;; 方法二: 值得学习的地方，一个是bitset库，一个是根据题目给定的最大值，设定最长的一个bitset，还有就是每次一个数字，我们都使用bitset&lt;&lt;n，这样的方法非常神奇。 我的代码实现： 12345678910111213class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int s = accumulate(nums.begin(), nums.end(), 0); if(s&amp;1) return false; bitset&lt;20001&gt; bits; bits[0] = 1; for(auto num:nums) bits |= bits&lt;&lt;num; return bits[s&gt;&gt;1]; &#125;&#125;; https://discuss.leetcode.com/topic/62334/simple-c-4-line-solution-using-a-bitset Simple C++ 4-line solution using a bitsetNote: as @zhoudayang2 pointed out, the question description has changed (max array size 100 ==&gt; 200). I have modified my code below according to the new description, and also made it a bit easier to understand. Time complexity O(n), size of the bitset is 1256 bytes 1234567891011121314class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; const int MAX_NUM = 100; const int MAX_ARRAY_SIZE = 200; bitset&lt;MAX_NUM * MAX_ARRAY_SIZE / 2 + 1&gt; bits(1); int sum = 0; for (auto n : nums) &#123; sum += n; bits |= bits &lt;&lt; n; &#125; return !(sum % 2) &amp;&amp; bits[sum / 2]; &#125;&#125;; It’s possible to shorten the solution to 4 lines, by using std::accumulate(), but that doesn’t really make you type less or make it run faster though… 123456789class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; bitset&lt;10001&gt; bits(1); int sum = accumulate(nums.begin(), nums.end(), 0); for (auto n : nums) bits |= bits &lt;&lt; n; return !(sum &amp; 1) &amp;&amp; bits[sum &gt;&gt; 1]; &#125;&#125;; https://discuss.leetcode.com/topic/62285/concise-c-solution-summary-with-dfs-dp-bit Concise C++ Solution summary with DFS, DP, BIT DFS solution: 1234567891011121314class Solution &#123;public: bool backtrack(vector&lt;int&gt;&amp; nums, int start, int target) &#123; if (target &lt;= 0) return target == 0; for (int i = start; i &lt; nums.size(); i++) if (backtrack(nums, i + 1, target - nums[i])) return true; return false; &#125; bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); return !(sum &amp; 1) &amp;&amp; backtrack(nums, 0, sum &gt;&gt; 1); &#125;&#125;; DFS can’t pass the OJ, as more test cases are added. So here comes a DP solution based on @Hermits solution 12345678910bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(), nums.end(), 0), target = sum &gt;&gt; 1; if (sum &amp; 1) return false; vector&lt;int&gt; dp(target + 1, 0); dp[0] = 1; for(auto num : nums) for(int i = target; i &gt;= num; i--) dp[i] = dp[i] || dp[i - num]; return dp[target];&#125; A very fast and cool Bit solution by @alvin-777 solution 123456bool canPartition(vector&lt;int&gt;&amp; nums) &#123; bitset&lt;5001&gt; bits(1); int sum = accumulate(nums.begin(), nums.end(), 0); for (auto n : nums) bits |= bits &lt;&lt; n; return !(sum &amp; 1) &amp;&amp; bits[sum &gt;&gt; 1];&#125; https://discuss.leetcode.com/topic/63049/my-simple-c-dp-code-with-comments My Simple C++ DP Code with Comments 12345678910111213141516171819202122class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = accumulate(nums.begin(), nums.end(), 0); if (sum &amp; 1) return false; int half = sum &gt;&gt; 1; vector&lt;bool&gt; accessibility(half + 1, false); accessibility[0] = true; // &apos;0&apos; is always reachable //For all num in nums, check the accessibility from half - num to 0. //If &apos;i&apos; is accessible by former numbers, then &apos;i + num&apos; is also accessible. (DP Algorithm) for(auto num : nums) //Below here we must start from &apos;half&apos; downto &apos;num&apos;, otherwise current &apos;num&apos; might be multiply used. //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer. for(int i = half; i &gt;= num; i--)&#123; if (accessibility[i - num] == true)&#123; accessibility[i] = true; &#125; &#125; return accessibility[half]; &#125;&#125;; python https://discuss.leetcode.com/topic/62308/7-lines-59ms-recursive-python-solution 7 Lines 59ms Recursive Python Solution Seek whether there’s a combination has the sum equal to half of total sum. Simply return False if sum of the list is not even. Target minus each element as Target for next recursion of the rest elements. Base case: Target &lt; 0 (ignore) Target == 0 (return True) Recursive case: Otherwise 1234567891011class Solution(object): def canPartition(self, nums): nums.sort(reverse=True) def helper(start, target): # Here path is not needed if target &lt; 0: return elif target == 0: return True for i in xrange(start, len(nums)): if helper(i+1, target-nums[i]): return True return False return False if sum(nums)%2 else helper(0, sum(nums)/2) https://discuss.leetcode.com/topic/64124/4-line-passed-python-solution 4 line passed python solution 12345678910class Solution(object): def canPartition(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; possible_sums = &#123;0&#125; for n in nums: possible_sums.update(&#123;(v + n) for v in possible_sums&#125;) return (sum(nums) / 2.) in possible_sums java 33ms, , October 18, 2016 https://discuss.leetcode.com/topic/62312/java-solution-similar-to-backpack-problem-easy-to-understand 1234567891011121314151617181920212223public class Solution &#123; public boolean canPartition(int[] nums) &#123; if(nums == null || nums.length == 0) return true; int volumn = 0; for(int num:nums) volumn += num; if(volumn % 2 != 0) return false; volumn /= 2; boolean[] dp = new boolean[volumn + 1]; dp[0] = true; for(int i=1; i&lt;=nums.length; i++) for(int j=volumn; j&gt;=nums[i-1]; j--) dp[j] = dp[j] || dp[j-nums[i-1]]; return dp[volumn]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[415. Add Strings]]></title>
    <url>%2Fp%2F136ad2a0%2F</url>
    <content type="text"><![CDATA[41.3% https://leetcode.com/problems/add-strings/ Given two non-negative numbers num1 and num2 represented as string, return the sum of num1 and num2. Note: The length of both num1 and num2 is &lt; 5100. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly. java25ms, October 17, 2016 https://discuss.leetcode.com/topic/62310/straight-forward-java-10-main-lines-25ms 12345678910111213141516public class Solution &#123; public String addStrings(String num1, String num2) &#123; StringBuilder sb = new StringBuilder(); int carry = 0; for(int i=num1.length()-1, j=num2.length()-1; i&gt;=0 || j&gt;=0; i--, j--)&#123; int x = i &lt; 0 ? 0 : num1.charAt(i) - &apos;0&apos;; int y = j &lt; 0 ? 0 : num2.charAt(j) - &apos;0&apos;; sb.append((x+y+carry)%10); carry = (x+y+carry) / 10; &#125; if(carry != 0) sb.append(carry); return sb.reverse().toString(); &#125;&#125; cpp16ms, October 17, 2016 https://discuss.leetcode.com/topic/62305/c-_accepted_13ms 12345678910111213141516171819202122232425class Solution &#123;public: string addStrings(string num1, string num2) &#123; int n1 = num1.size(), i = n1 - 1; int n2 = num2.size(), j = n2 - 1; int carry = 0; string res = &quot;&quot;; while(i&gt;=0 || j&gt;= 0 || carry)&#123; long sum = 0; if(i &gt;= 0)&#123; sum += (num1[i] - &apos;0&apos;); i--; &#125; if(j &gt;= 0)&#123; sum += (num2[j] - &apos;0&apos;); j--; &#125; sum += carry; carry = sum / 10; sum = sum % 10; res = to_string(sum) + res; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[414. Third Maximum Number]]></title>
    <url>%2Fp%2F88fda95%2F</url>
    <content type="text"><![CDATA[27.9% https://leetcode.com/problems/third-maximum-number/ Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). 123456Example 1:Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1. 1234567Example 2:Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead. 12345678Example 3:Input: [2, 2, 3, 1]Output: 1Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. https://discuss.leetcode.com/topic/63903/short-easy-c-using-set 方法一： Short easy C++ using set Track the largest three values in a set. 123456789int thirdMax(vector&lt;int&gt;&amp; nums) &#123; set&lt;int&gt; top3; for (int num : nums) &#123; top3.insert(num); if (top3.size() &gt; 3) top3.erase(top3.begin()); &#125; return top3.size() == 3 ? *top3.begin() : *top3.rbegin();&#125; 我的代码实现： 主要几点，set是有序的，set可以去重。erase函数用法，对于地址的解析。begin, rbegin函数。 123456789101112class Solution &#123;public: int thirdMax(vector&lt;int&gt;&amp; nums) &#123; set&lt;int&gt; set; for(auto num:nums)&#123; set.insert(num); if(set.size()&gt;3) set.erase(set.begin()); &#125; return set.size()==3?*set.begin() : *set.rbegin(); &#125;&#125;; Alternatively (not sure which one I like better): 1234567int thirdMax(vector&lt;int&gt;&amp; nums) &#123; set&lt;int&gt; top3; for (int num : nums) if (top3.insert(num).second &amp;&amp; top3.size() &gt; 3) top3.erase(top3.begin()); return top3.size() == 3 ? *top3.begin() : *top3.rbegin();&#125; pythonhttps://discuss.leetcode.com/topic/64696/a-python-amusing-solution-which-actually-beats-98 A python amusing solution, which actually beats 98%… 1234567def thirdMax(self, nums): nums = set(nums) if len(nums) &lt; 3: return max(nums) nums.remove(max(nums)) nums.remove(max(nums)) return max(nums) https://discuss.leetcode.com/topic/70613/intuitive-and-short-python-solution Intuitive and Short Python solution Time complexity is O(n), space complexity is O(1). 123456789class Solution(object): def thirdMax(self, nums): v = [float(&apos;-inf&apos;), float(&apos;-inf&apos;), float(&apos;-inf&apos;)] for num in nums: if num not in v: if num &gt; v[0]: v = [num, v[0], v[1]] elif num &gt; v[1]: v = [v[0], num, v[1]] elif num &gt; v[2]: v = [v[0], v[1], num] return max(nums) if float(&apos;-inf&apos;) in v else v[2] https://discuss.leetcode.com/topic/63962/python-2-5-lines-o-n-time-o-1-space Python: 2-5 lines, O(n) time, O(1) space 123456def thirdMax(self, nums): l = [float(&apos;-inf&apos;)] * 3 for n in nums: if n &gt; l[0] and n not in l: heapq.heappushpop(l, n) return l[0] if l[0] != float(&apos;-inf&apos;) else max(l) A slightly shorter but uglier version based on the same concept is: Although I’m not sure whether the second version is still O(1) space. Does anyone know whether the Python interpreter will create the whole list comprehension in memory even though it is not being assigned anywhere? Update: two line solution by @StefanPochmann below.1234def thirdMax(self, nums): l = [float(&apos;-inf&apos;)] * 3 [heapq.heappushpop(l, n) for n in nums if n &gt; l[0] and n not in l] return l[0] if l[0] != float(&apos;-inf&apos;) else max(l) javahttps://discuss.leetcode.com/topic/63086/java-priorityqueue-o-n-o-1 Java PriorityQueue O(n) + O(1) 123456789101112131415161718192021public class Solution &#123; public int thirdMax(int[] nums) &#123; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i : nums) &#123; if (!set.contains(i)) &#123; pq.offer(i); set.add(i); if (pq.size() &gt; 3) &#123; set.remove(pq.poll()); &#125; &#125; &#125; if (pq.size() &lt; 3) &#123; while (pq.size() &gt; 1) &#123; pq.poll(); &#125; &#125; return pq.peek(); &#125;&#125; Nice solution, and here is the concise version: 1234567891011121314public class Solution &#123; public int thirdMax(int[] nums) &#123; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int n : nums) &#123; if(set.add(n)) &#123; pq.offer(n); if(pq.size() &gt; 3 ) pq.poll(); &#125; &#125; if(pq.size() == 2) pq.poll(); return pq.peek(); &#125;&#125; https://discuss.leetcode.com/topic/62236/java-solution-in-0ms-run-time-o-n-and-space-o-1 Java solution in 0ms run time O(n) and space O(1). 12345678910111213141516171819202122232425262728293031323334353637public int thirdMax(int[] nums) &#123; int max, mid, small, count; max = mid = small = Integer.MIN_VALUE; count = 0; //Count how many top elements have been found. for( int x: nums) &#123; //Skip loop if max or mid elements are duplicate. The purpose is for avoiding right shift. if( x == max || x == mid ) &#123; continue; &#125; if (x &gt; max) &#123; //right shift small = mid; mid = max; max = x; count++; &#125; else if( x &gt; mid) &#123; //right shift small = mid; mid = x; count++; &#125; else if ( x &gt;= small) &#123; //if small duplicated, that&apos;s find, there&apos;s no shift and need to increase count. small = x; count++; &#125; &#125; //&quot;count&quot; is used for checking whether found top 3 maximum elements. if( count &gt;= 3) &#123; return small; &#125; else &#123; return max; &#125; &#125; https://discuss.leetcode.com/topic/63671/o-n-time-o-1-space-java-short-solution O(n) time O(1) space Java short solution 123456789101112131415161718192021222324public class Solution &#123; public int thirdMax(int[] nums) &#123; long first=Long.MIN_VALUE; long second=Long.MIN_VALUE; long third=Long.MIN_VALUE; for(int i:nums)&#123; if(i&gt;first)&#123; third=second; second=first; first=i; &#125;else if(i==first) continue; else if(i&gt;second)&#123; third=second; second=i; &#125;else if(i==second) continue; else if(i&gt;third)&#123; third=i; &#125; &#125; return third==Long.MIN_VALUE?(int)first:(int)third; &#125;&#125; https://discuss.leetcode.com/topic/65119/java-solution-using-treeset Java Solution Using TreeSet 12345678910111213141516public class Solution &#123; public final int N = 3; public int thirdMax(int[] nums) &#123; if (nums.length == 0) return 0; TreeSet&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (set.contains(nums[i])) continue; if (set.size() &lt; N || nums[i] &gt; set.first()) &#123; if (set.size() == N) set.remove(set.first()); set.add(nums[i]); &#125; &#125; return set.size() == N ? set.first() : set.last(); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[413. Arithmetic Slices]]></title>
    <url>%2Fp%2F3f473676%2F</url>
    <content type="text"><![CDATA[54.7% https://leetcode.com/problems/arithmetic-slices/?tab=Description A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. 12345678For example, these are arithmetic sequence:1, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9The following sequence is not arithmetic.1, 1, 2, 5, 7 A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N. A slice (P, Q) of array A is called arithmetic if the sequence: A[P], A[p + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q. The function should return the number of arithmetic slices in the array A. 12345Example:A = [1, 2, 3, 4]return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself. cpp https://discuss.leetcode.com/topic/62992/3ms-c-standard-dp-solution-with-very-detailed-explanation 3ms C++ Standard DP Solution with Very Detailed Explanation 12345678910111213141516171819202122class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123; int n = A.size(); if (n &lt; 3) return 0; vector&lt;int&gt; dp(n, 0); // dp[i] means the number of arithmetic slices ending with A[i] if (A[2]-A[1] == A[1]-A[0]) dp[2] = 1; // if the first three numbers are arithmetic or not int result = dp[2]; for (int i = 3; i &lt; n; ++i) &#123; // if A[i-2], A[i-1], A[i] are arithmetic, then the number of arithmetic slices ending with A[i] (dp[i]) // equals to: // the number of arithmetic slices ending with A[i-1] (dp[i-1], all these arithmetic slices appending A[i] are also arithmetic) // + // A[i-2], A[i-1], A[i] (a brand new arithmetic slice) // it is how dp[i] = dp[i-1] + 1 comes if (A[i]-A[i-1] == A[i-1]-A[i-2]) dp[i] = dp[i-1] + 1; result += dp[i]; // accumulate all valid slices &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/62162/3ms-question-maker-solution-in-cpp-o-n-time-and-in-space 3ms Question Maker Solution in CPP O(n) time and in space I met this question in friend’s friend’s OA (recursive friend) lol It could be solved in O(n) with small math trick~~ O(n) time and in space. Thanks @JianShi for this solution! 12345678910111213141516171819202122232425class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123; if (A.size() &lt; 3) return 0; int size = (int) A.size(); for (int i = 0; i &lt; size - 1; i++) &#123; A[i] = A[i + 1] - A[i]; &#125; A.resize(size - 1); size--; int res = 0; int len = 1; for (int i = 1; i &lt; size; i++) &#123; if (A[i] != A[i - 1]) &#123; res += len * (len - 1) / 2; len = 1; &#125; else &#123; len++; &#125; &#125; if (len &gt; 1) res += len * (len - 1) / 2; return res; &#125;&#125;; https://discuss.leetcode.com/topic/62162/3ms-question-maker-solution-in-cpp-o-n-time-and-in-space/3 @codeRiya Hi, thank you for your question! As I said, this solution uses a small math trick. At first, it change A to an array of difference of adjacent items in original A. For example, if A is [1,2,3,4], then A should be [1,1,1]. So for adjusted A, 2 or more continuous same values indicates there is an arithmetic slice in original A. If there is N continuous same values in adjusted A, there should be an arithmetic slice with length of N + 1. Now let me show you how many arithmetic slices in a N + 1 long arithmetic slice. 123456[1,2,3] -&gt; 1 arithmetic slice[1,2,3,4] -&gt; 3 arithmetic slices, 2 more than before[1,2,3,4,5] -&gt; 6 arithmetic slices, 3 more than before........Arithmetic slice with length N -&gt; 1 + 2 + 3 + .....+ (N - 2) = (1 + N - 2) * (N - 2) / 2 = (N - 1) * (N - 2) / 2 arithmetic slice(s)So, when length N + 1 -&gt; (N - 1) * N / 2 If you have more question, please let me know~ cheers! :P python https://discuss.leetcode.com/topic/63873/python-dp-solution Python DP solution 1234567891011121314def numberOfArithmeticSlices(self, A): &quot;&quot;&quot; :type A: List[int] :rtype: int &quot;&quot;&quot; opt, i = [0,0], 1 for j in xrange(2,len(A)): if A[j]-A[j-1] == A[j-1]-A[j-2]: opt.append(opt[j-1]+i) i += 1 else: opt.append(opt[j-1]) i = 1 return opt[-1] https://discuss.leetcode.com/topic/63873/python-dp-solution/2 @zhan430 Why not use a variable instead of an array? 12345678910class Solution(object): def numberOfArithmeticSlices(self, A): curr, sum = 0, 0 for i in range(2,len(A)): if A[i]-A[i-1] == A[i-1]-A[i-2]: curr += 1 sum += curr else: curr = 0 return sum java https://discuss.leetcode.com/topic/63302/simple-java-solution-9-lines-2ms Simple Java solution 9 lines, 2ms 1234567891011public int numberOfArithmeticSlices(int[] A) &#123; int curr = 0, sum = 0; for (int i=2; i&lt;A.length; i++) if (A[i]-A[i-1] == A[i-1]-A[i-2]) &#123; curr += 1; sum += curr; &#125; else &#123; curr = 0; &#125; return sum;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[412. Fizz Buzz]]></title>
    <url>%2Fp%2F9de0f5d0%2F</url>
    <content type="text"><![CDATA[58.% https://leetcode.com/problems/fizz-buzz/ Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. 12345678910111213141516171819202122Example:n = 15,Return:[ &quot;1&quot;, &quot;2&quot;, &quot;Fizz&quot;, &quot;4&quot;, &quot;Buzz&quot;, &quot;Fizz&quot;, &quot;7&quot;, &quot;8&quot;, &quot;Fizz&quot;, &quot;Buzz&quot;, &quot;11&quot;, &quot;Fizz&quot;, &quot;13&quot;, &quot;14&quot;, &quot;FizzBuzz&quot;] 方法一： 我的代码实现： Oct 16， 2017 1234567891011121314151617class Solution &#123;public: vector&lt;string&gt; fizzBuzz(int n) &#123; vector&lt;string&gt; res; for(int i=1; i&lt;=n; i++)&#123; if(i%3==0 &amp;&amp; i%5==0) res.push_back("FizzBuzz"); else if(i%3 == 0) res.push_back("Fizz"); else if(i%5 == 0) res.push_back("Buzz"); else res.push_back(to_string(i)); &#125; return res; &#125;&#125;; 6ms, October 17, 2016 https://discuss.leetcode.com/topic/62160/pretty-straightforward-cpp-solution 注意，使用to_string(i)来把int转化为string 此处用15表示同时被3和5整除的数字，不错的想法。 12345678910111213class Solution &#123;public: vector&lt;string&gt; fizzBuzz(int n) &#123; vector&lt;string&gt; res; for(int i=1; i&lt;=n; i++)&#123; if(i%15 == 0) res.push_back(&quot;FizzBuzz&quot;); else if(i%3 == 0) res.push_back(&quot;Fizz&quot;); else if(i%5 == 0) res.push_back(&quot;Buzz&quot;); else res.push_back(to_string(i)); &#125; return res; &#125;&#125;; python78ms, October 17, 2016 https://discuss.leetcode.com/topic/63360/python-1-line-solution 1234567class Solution(object): def fizzBuzz(self, n): &quot;&quot;&quot; :type n: int :rtype: List[str] &quot;&quot;&quot; return [str(i) if (i%3 != 0 and i%5 != 0) else ((&apos;Fizz&apos;*(i%3==0)) + (&apos;Buzz&apos;*(i%5==0))) for i in range(1, n+1)] java4ms, October 17, 2016 https://discuss.leetcode.com/topic/62081/java-easy-iterative-solution 12345678910111213141516public class Solution &#123; public List&lt;String&gt; fizzBuzz(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int i=1; i&lt;=n; i++)&#123; if(i%3==0 &amp;&amp; i%5==0) list.add(&quot;FizzBuzz&quot;); else if(i%3 ==0) list.add(&quot;Fizz&quot;); else if(i%5==0) list.add(&quot;Buzz&quot;); else list.add(String.valueOf(i)); &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[410. Split Array Largest Sum]]></title>
    <url>%2Fp%2Fd46341cf%2F</url>
    <content type="text"><![CDATA[34.2% https://leetcode.com/problems/split-array-largest-sum/?tab=Description Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays. Note: If n is the length of array, assume the following constraints are satisfied: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n) 12345678910111213Examples:Input:nums = [7,2,5,10,8]m = 2Output:18Explanation:There are four ways to split nums into two subarrays.The best way is to split it into [7,2,5] and [10,8],where the largest sum among the two subarrays is only 18. 方法一： https://discuss.leetcode.com/topic/61395/c-fast-very-clear-explanation-clean-code-solution-with-greedy-algorithm-and-binary-search [C++ / Fast / Very clear explanation / Clean Code] Solution with Greedy Algorithm and Binary Search First thing first, below is the code: 123456789101112131415161718192021222324252627282930313233class Solution &#123;private: bool doable (const vector&lt;int&gt;&amp; nums, int cuts, long long max) &#123; int acc = 0; for (num : nums) &#123; // This step is unnecessary for this problem. I didn&apos;t discard this line because I want doable function more generalized. if (num &gt; max) return false; else if (acc + num &lt;= max) acc += num; else &#123; --cuts; acc = num; if (cuts &lt; 0) return false; &#125; &#125; return true; &#125; public: int splitArray(vector&lt;int&gt;&amp; nums, int m) &#123; long long left = 0, right = 0; for (num : nums) &#123; left = max(left, (long long)num); right += num; &#125; while (left &lt; right) &#123; long long mid = left + (right - left) / 2; if (doable(nums, m - 1, mid)) right = mid; else left = mid + 1; &#125; return left; &#125;&#125;; Introduction to this problem: We can break this problem into two smaller problems: Given an array (A), number of cuts (CUTS), and the Largest sum of sub-arrays (MAX). Can you use at most CUTS cuts to segment array A into CUTS + 1 sub-arrays, such that the sum of each sub-array is smaller or equal to MAX? Given a lower bound (left), an upper bound (right), an unknown bool array (B), and an API uses i as input and tells you whether B[i] is true. If we know there exists an index k, that B[i] is false when i &lt; k, and B[i] is true when i &gt;= k. What is the fastest way to find this k (the lower bound)?Solution to the first sub-problem (Skip this part if you already knew how to solve 1st sub-problem): For the first question, we can follow these steps: For each element in the array, if its value is larger than MAX, we know it’s not possible to cut this array into groups that the sum of all groups are smaller than MAX. (Reason is straightforward, if A is [10, 2, 3, 5] and MAX is 6, even you have 3 cuts by which you can cut A as [[10], [2], [3], [5]], the group containing 10 will still be larger than 6). Use greedy algorithm to cut A. Use an accumulator ACC to store the sum of the currently processed group, and process elements in A one by one. For each element num, if we add num with ACC and the new sum is still no larger than MAX, we update ACC to ACC + num, which means we can merge num into the current group. If not, we must use a cut before num to segment this array, then num will be the first element in the new group. If we didn’t go through A but already used up all cuts, then it’s not possible only using CUTS cuts to segment this array into groups to make sure sum of each sub-array is smaller than MAX. Otherwise, if we can reach the end of A with cuts left (or use exactly CUTS cuts). It’s possible to do so.Then the first question is solved. Solution to the second sub-problem(Skip this part if you already knew how to solve 2nd sub-problem): The array B will be something like [false, false, …, false, true, true, …, true]. We want to find the index of the first true. Use binary search to find this k. Keep a value mid, mid = (left + right) / 2. If B[mid] = false, then move the search range to the upper half of the original search range, a.k.a left = mid + 1, otherwise move search range to the lower half, a.k.a right = mid.Why this algorithm is correct… No matter how we cut the array A, the Largest sum of sub-arrays will fall into a range [left, right]. Left is the value of the largest element in this array. right is the sum of this array. (e.g., Given array [1, 2, 3, 4, 5], if we have 4 cuts and cut it as [[1], [2], [3], [4], [5]], the Largest sum of sub-arrays is 5, it cannot be smaller. And if we have 0 cut, and the only sub-array is [[1, 2, 3, 4, 5]], the Largest sum of sub-arrays is 15, it cannot be larger). However, we cannot decide the number of cuts (CUTS), this is an given constraint. But we know there must be a magic number k, which is the smallest value of the Largest sum of sub-arrays when given CUTS cuts. When the Largest sum of sub-arrays is larger than k, we can always find a way to cut A within CUTS cuts. When the Largest sum of sub-arrays is smaller than k, there is no way to do this.Example For example, given array A [1, 2, 3, 4, 5]. We can use 2 cuts. o matter how many cuts are allowed, the range of the possible value of the Largest sum of sub-arrays is [5, 15]. When given 2 cuts, we can tell the magic number k here is 6, the result of segmentation is [[1, 2, 3], [4], [5]]. When Largest sum of sub-arrays is in range [6, 15], we can always find a way to cut this array within two cuts. You can have a try. However, when Largest sum of sub-arrays is in range [5, 5], there is no way to do this. This mapped this problem into the second sub-problem. Bool array B here is [5:false, 6:true, 7:true, 8:true, …, 15:true]. We want to find the index i of the first true in B, which is the answer of this entire question, and by solving the first sub-problem, we have an API that can tell us given an i (Largest sum of sub-arrays), whether B[i] is true (whether we can find a way to cut A to satisfy the constraint).Below is the code with comment, just in case you don’t have time to read the explanations above. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution &#123;private: /* Params: nums - The input array; cuts - How many cuts are available (cuts = #groups - 1); max - The maximum of the (sum of elements in one group); Rtn: Whether we can use at most &apos;cuts&apos; number of cuts to segment the entire array, such that the sum of each group will not exceed &apos;max&apos;. */ bool doable (const vector&lt;int&gt;&amp; nums, int cuts, long long max) &#123; // &apos;acc&apos; is the temporary accumulator for the currently processed group. int acc = 0; for (num : nums) &#123; // If the current processed element in this array is larger than &apos;max&apos;, we cannot segment the array. // (Reason is straightforward, if &apos;nums&apos; is [10, 2, 3, 5] and &apos;max&apos; is 6, even you can have 3 cuts // (by which you can cut array as [[10], [2], [3], [5]]), the group containing 10 will be larger than 6, // there is no way to do this). // Ps: This step is unnecessary in this solution. Because &apos;left&apos; in the splitArray() function can assure // &apos;max&apos; will be larger than every single element. I just want to write a generalized doable() function :) if (num &gt; max) return false; // If the (sum of the currently processed group) + (current element) is smaller than max, we can add current // element into this group. else if (acc + num &lt;= max) acc += num; // If not, we will make a cut before this element, and this element will be the first element in the new group. else &#123; --cuts; acc = num; // If we&apos;ve used up all cuts, this means this &apos;max&apos; is not doable. if (cuts &lt; 0) return false; &#125; &#125; // If we can reach here, this means we&apos;ve used at most &apos;cuts&apos; cut to segment the array, and the sum of each groups is // not larger than &apos;max&apos;. Yeah! return true; &#125; public: int splitArray(vector&lt;int&gt;&amp; nums, int m) &#123; // Use long long to avoid overflow. long long left = 0, right = 0; // The smallest possible value (&apos;left&apos;) is the the value of the largest element in this array. // The largest possible value (&apos;right&apos;) is the sum of all elements in this array. for (num : nums) &#123; left = max(left, (long long)num); right += num; &#125; // Use binary search, find the lower bound of the possible (minimum sum of groups within m - 1 cuts). while (left &lt; right) &#123; long long mid = left + (right - left) / 2; if (doable(nums, m - 1, mid)) right = mid; else left = mid + 1; &#125; return left; &#125;&#125;; https://discuss.leetcode.com/topic/61314/binary-search-c-solution Binary Search C++ Solution Obviously, the final result is in the interval [left, right] (where left is the maximal number in the array, right is sum of all numbers).So, what we need to do is to find out the first element in [left, right], which exactly we cannot split the array into m subarrays whose sum is no greater than that element. Then its previous one is the final result. The progress is much similar to lower_bound in C++. 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: using ll = long long; bool canSplit(vector&lt;int&gt;&amp; nums, int m, ll sum) &#123; int c = 1; ll s = 0; for (auto&amp; num : nums) &#123; s += num; if (s &gt; sum) &#123; s = num; ++c; &#125; &#125; return c &lt;= m; &#125; int splitArray(vector&lt;int&gt;&amp; nums, int m) &#123; ll left = 0, right = 0; for (auto&amp; num : nums) &#123; left = max(left, (ll)num); right += num; &#125; while (left &lt;= right) &#123; ll mid = left + (right-left)/2; if (canSplit(nums, m, mid)) right = mid-1; else left = mid+1; &#125; return left; &#125;&#125;; python https://discuss.leetcode.com/topic/62139/python-solution-dp-and-binary-search Python solution dp and binary search First i try dp, while got TLE:(while if using java to implement dp, u may get AC…) 123456789101112131415161718192021222324import sysclass Solution(object): def splitArray(self, nums, m): &quot;&quot;&quot; :type nums: List[int] :type m: int :rtype: int &quot;&quot;&quot; dp = [[sys.maxint]*(m) for _ in range(len(nums)+1)] acc = 0 dp[0][0] = 0 for i in range(1, len(nums)+1): acc += nums[i - 1] dp[i][0] = acc for j in range(m): dp[0][j] = 0 for i in range(1, len(nums)+1): for i_ in range(i): for j in range(1, m): dp[i][j] = min(dp[i][j], max(dp[i_][j-1], dp[i][0]-dp[i_][0])) #print dp return dp[len(nums)][m-1] Then by binary search, got AC: 1234567891011121314151617181920212223242526272829class Solution(object): def splitArray(self, nums, m): &quot;&quot;&quot; :type nums: List[int] :type m: int :rtype: int &quot;&quot;&quot; def valid(mid): cnt = 0 current = 0 for n in nums: current += n if current&gt;mid: cnt += 1 if cnt&gt;=m: return False current = n return True l = max(nums) h = sum(nums) while l&lt;h: mid = l+(h-l)/2 if valid(mid): h = mid else: l = mid+1 return l java https://discuss.leetcode.com/topic/61324/clear-explanation-8ms-binary-search-java Clear Explanation: 8ms Binary Search Java The answer is between maximum value of input array numbers and sum of those numbers. Use binary search to approach the correct answer. We have l = max number of array; r = sum of all numbers in the array;Every time we do mid = (l + r) / 2; Use greedy to narrow down left and right boundaries in binary search. 3.1 Cut the array from left. 3.2 Try our best to make sure that the sum of numbers between each two cuts (inclusive) is large enough but still less than mid. 3.3 We’ll end up with two results: either we can divide the array into more than m subarrays or we cannot. If we can, it means that the mid value we pick is too small because we’ve already tried our best to make sure each part holds as many non-negative numbers as we can but we still have numbers left. So, it is impossible to cut the array into m parts and make sure each parts is no larger than mid. We should increase m. This leads to l = mid + 1;If we can’t, it is either we successfully divide the array into m parts and the sum of each part is less than mid, or we used up all numbers before we reach m. Both of them mean that we should lower mid because we need to find the minimum one. This leads to r = mid - 1; 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int splitArray(int[] nums, int m) &#123; int max = 0; long sum = 0; for (int num : nums) &#123; max = Math.max(num, max); sum += num; &#125; if (m == 1) return (int)sum; //binary search long l = max; long r = sum; while (l &lt;= r) &#123; long mid = (l + r)/ 2; if (valid(mid, nums, m)) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return (int)l; &#125; public boolean valid(long target, int[] nums, int m) &#123; int count = 1; long total = 0; for(int num : nums) &#123; total += num; if (total &gt; target) &#123; total = num; count++; if (count &gt; m) &#123; return false; &#125; &#125; &#125; return true; &#125;&#125; list item https://discuss.leetcode.com/topic/61405/dp-java DP Java DP solution. This is obviously not as good as the binary search solutions; but it did pass OJ. dp[s,j] is the solution for splitting subarray n[j]…n[L-1] into s parts. dp[s+1,i] = min{ max(dp[s,j], n[i]+…+n[j-1]) }, i+1 &lt;= j &lt;= L-s This solution does not take advantage of the fact that the numbers are non-negative (except to break the inner loop early). That is a loss. (On the other hand, it can be used for the problem containing arbitrary numbers) 123456789101112131415161718192021222324252627282930public int splitArray(int[] nums, int m)&#123; int L = nums.length; int[] S = new int[L+1]; S[0]=0; for(int i=0; i&lt;L; i++) S[i+1] = S[i]+nums[i]; int[] dp = new int[L]; for(int i=0; i&lt;L; i++) dp[i] = S[L]-S[i]; for(int s=1; s&lt;m; s++) &#123; for(int i=0; i&lt;L-s; i++) &#123; dp[i]=Integer.MAX_VALUE; for(int j=i+1; j&lt;=L-s; j++) &#123; int t = Math.max(dp[j], S[j]-S[i]); if(t&lt;=dp[i]) dp[i]=t; else break; &#125; &#125; &#125; return dp[0];&#125; https://discuss.leetcode.com/topic/61315/java-easy-binary-search-solution-8ms Java easy binary search solution 8ms Given a result, it is easy to test whether it is valid or not. The max of the result is the sum of the input nums. The min of the result is the max num of the input nums. Given the 3 conditions above we can do a binary search. (need to deal with overflow) 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public int splitArray(int[] nums, int m) &#123; long sum = 0; int max = 0; for(int num: nums)&#123; max = Math.max(max, num); sum += num; &#125; return (int)binary(nums, m, sum, max); &#125; private long binary(int[] nums, int m, long high, long low)&#123; long mid = 0; while(low &lt; high)&#123; mid = (high + low)/2; if(valid(nums, m, mid))&#123; //System.out.println(mid); high = mid; &#125;else&#123; low = mid + 1; &#125; &#125; return high; &#125; private boolean valid(int[] nums, int m, long max)&#123; int cur = 0; int count = 1; for(int num: nums)&#123; cur += num; if(cur &gt; max)&#123; cur = num; count++; if(count &gt; m)&#123; return false; &#125; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>binary search</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[409. Longest Palindrome]]></title>
    <url>%2Fp%2F34e4ebee%2F</url>
    <content type="text"><![CDATA[44.9% https://leetcode.com/problems/longest-palindrome/ Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example “Aa” is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010. 1234567891011&gt; Example:&gt; &gt; Input:&gt; &quot;abccccdd&quot;&gt; &gt; Output:&gt; 7&gt; &gt; Explanation:&gt; One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.&gt; java23ms, October 18, 2016 https://discuss.leetcode.com/topic/61300/simple-hashset-solution-java 1234567891011121314151617public class Solution &#123; public int longestPalindrome(String s) &#123; if(s==null || s.length()==0) return 0; HashSet&lt;Character&gt; hs = new HashSet&lt;Character&gt;(); int count = 0; for(int i=0; i&lt;s.length(); i++)&#123; if(hs.contains(s.charAt(i)))&#123; hs.remove(s.charAt(i)); count++; &#125;else&#123; hs.add(s.charAt(i)); &#125; &#125; if(!hs.isEmpty()) return count*2 + 1; return count*2; &#125;&#125; cpp46ms, , October 18, 2016 https://discuss.leetcode.com/topic/61338/what-are-the-odds-python-c 123456789class Solution &#123;public: int longestPalindrome(string s) &#123; int odds = 0; for(char c=&apos;A&apos;; c&lt;=&apos;z&apos;; c++) odds += count(s.begin(), s.end(), c) &amp; 1; return s.size() - odds + (odds&gt;0); &#125;&#125;; python69ms, October 18, 2016 https://discuss.leetcode.com/topic/61338/what-are-the-odds-python-c 12345678class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; odds = sum(v&amp;1 for v in collections.Counter(s).values()) return len(s) - odds + bool(odds)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[406. Queue Reconstruction by Height]]></title>
    <url>%2Fp%2Fcd55e9c6%2F</url>
    <content type="text"><![CDATA[54.8% https://leetcode.com/problems/queue-reconstruction-by-height/description/ Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note: The number of people is less than 1,100. 1234567ExampleInput:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 方法一： python175ms, 55.94%, October 18, 2016 https://discuss.leetcode.com/topic/60394/easy-concept-with-python-c-java-solution 1234567891011121314151617181920212223class Solution(object): def reconstructQueue(self, people): &quot;&quot;&quot; :type people: List[List[int]] :rtype: List[List[int]] &quot;&quot;&quot; if not people: return [] peopledct, height, res = &#123;&#125;, [], [] for i in xrange(len(people)): p = people[i] if p[0] in peopledct: peopledct[p[0]] += (p[1], i), else: peopledct[p[0]] = [(p[1], i)] height += p[0], height.sort() for h in height[::-1]: peopledct[h].sort() for p in peopledct[h]: res.insert(p[0], people[p[1]]) return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[405. Convert a Number to Hexadecimal]]></title>
    <url>%2Fp%2F1c03d1e4%2F</url>
    <content type="text"><![CDATA[40.7% https://leetcode.com/problems/convert-a-number-to-hexadecimal/?tab=Description Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used. Note: All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character ‘0’; otherwise, the first character in the hexadecimal string will not be the zero character. The given number is guaranteed to fit within the range of a 32-bit signed integer. You must not use any method provided by the library which converts/formats the number to hex directly. 1234567Example 1:Input:26Output:&quot;1a&quot; 1234567Example 2:Input:-1Output:&quot;ffffffff&quot; 方法一： 本题中，使用位运算最方便，直接4位4位的前进。 不用纠结它的二位码到底如何，直接位运算，决定结果。 我的代码实现： 123456789101112131415161718class Solution &#123;public: string toHex(int num) &#123; if(num==0) return "0"; vector&lt;string&gt; v = &#123;"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"&#125;; string res; // 为了对负数有效，加了res.size()&lt;8这个条件 while(num!=0 &amp;&amp; res.size()&lt;8)&#123; res = v[num&amp;15] + res; num = num&gt;&gt;4; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/60365/simple-java-solution-with-comment Simple Java solution with comment 123456789101112131415161718192021222324/*Basic idea: each time we take a look at the last four digits of binary verion of the input, and maps that to a hex char shift the input to the right by 4 bits, do it again until input becomes 0.*/public class Solution &#123; char[] map = &#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;&#125;; public String toHex(int num) &#123; if(num == 0) return &quot;0&quot;; String result = &quot;&quot;; while(num != 0)&#123; result = map[(num &amp; 15)] + result; num = (num &gt;&gt;&gt; 4); &#125; return result; &#125; &#125; https://discuss.leetcode.com/topic/60365/simple-java-solution-with-comment/2 My corresponding C++ code. I must add result.size()&lt;8 in the while condition, or it will loop forever with a negative input. 12345678910111213class Solution &#123;public: string toHex(int num) &#123; if (num == 0) return &quot;0&quot;; vector&lt;char&gt; toHexChar = &#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;&#125;; string result; while (num != 0 &amp;&amp; result.size()&lt;8)&#123; result = toHexChar[num&amp;15] + result; num = num &gt;&gt; 4; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/60365/simple-java-solution-with-comment/3 StringBuilder may be used here. 123456789public String toHex(int num) &#123; StringBuilder sb = new StringBuilder(); do &#123; int n = num &amp; 0xf; n += n &lt; 0xa ? &apos;0&apos; : &apos;a&apos; - 10; sb.append((char)n); &#125; while ((num &gt;&gt;&gt;= 4) != 0); return sb.reverse().toString();&#125; https://discuss.leetcode.com/topic/60431/concise-c-solution Concise C++ Solution 注意cpp中 双引号和单引号的区别 1234567891011121314const string HEX = &quot;0123456789abcdef&quot;;class Solution &#123;public: string toHex(int num) &#123; if (num == 0) return &quot;0&quot;; string result; int count = 0; while (num &amp;&amp; count++ &lt; 8) &#123; result = HEX[(num &amp; 0xf)] + result; num &gt;&gt;= 4; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/60929/1-liner-in-python 1-liner in Python 123456class Solution(object): def toHex(self, num): return &apos;&apos;.join( &apos;0123456789abcdef&apos;[(num &gt;&gt; 4 * i) &amp; 15] for i in range(8) )[::-1].lstrip(&apos;0&apos;) or &apos;0&apos; https://discuss.leetcode.com/topic/61846/easy-10-line-python-solution-with-inline-explanation easy 10-line python solution with inline explanation 12345678910def toHex(self, num): if num==0: return &apos;0&apos; mp = &apos;0123456789abcdef&apos; # like a map ans = &apos;&apos; for i in range(8): n = num &amp; 15 # this means num &amp; 1111b c = mp[n] # get the hex char ans = c + ans num = num &gt;&gt; 4 return ans.lstrip(&apos;0&apos;) #strip leading zeroes]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[404. Sum of Left Leaves]]></title>
    <url>%2Fp%2F892e5d79%2F</url>
    <content type="text"><![CDATA[46.4% Find the sum of all left leaves in a given binary tree. 12345678910Example: 3 / \ 9 20 / \ 15 7There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. 方法一： 我的代码实现 深度优先遍历，类似于先序遍历，等价于先序遍历加一个判断。 12345678910111213141516class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; int res = 0; helper(root, res); return res; &#125; void helper(TreeNode* root, int&amp; res)&#123; if(!root) return; if(root-&gt;left!=NULL &amp;&amp; root-&gt;left-&gt;left==NULL &amp;&amp; root-&gt;left-&gt;right==NULL) res += root-&gt;left-&gt;val; helper(root-&gt;left, res); helper(root-&gt;right, res); &#125;&#125;; 方法二： 3-line c++ solution 递归，调用本身 12345678class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; if (!root) return 0; if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) return root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right); return sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right); &#125;&#125;; 我的代码实现： 123456789101112131415161718/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; if(!root) return 0; if(root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) return root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right); return sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right); &#125;&#125;; 方法三： 3 line recursive c++ solution, no need to explain 12345int sumOfLeftLeaves(TreeNode* root, bool isleft = false) &#123; if (!root) return 0; if (!root-&gt;left &amp;&amp; !root-&gt;right) return isleft ? root-&gt;val : 0; return sumOfLeftLeaves(root-&gt;left, true) + sumOfLeftLeaves(root-&gt;right, false);&#125; https://discuss.leetcode.com/topic/60467/3-line-c-solution 3-line c++ solution 12345678class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; if (!root) return 0; if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) return root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right); return sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right); &#125;&#125;; https://discuss.leetcode.com/topic/60409/3-line-recursive-c-solution-no-need-to-explain 3 line recursive c++ solution, no need to explain 12345int sumOfLeftLeaves(TreeNode* root, bool isleft = false) &#123; if (!root) return 0; if (!root-&gt;left &amp;&amp; !root-&gt;right) return isleft ? root-&gt;val : 0; return sumOfLeftLeaves(root-&gt;left, true) + sumOfLeftLeaves(root-&gt;right, false);&#125; https://discuss.leetcode.com/topic/60395/4-lines-python-recursive-ac-solution 4 Lines Python Recursive AC Solution base case =&gt; node is none recursive case =&gt; Left child is / isn’t Leave 123456class Solution(object): def sumOfLeftLeaves(self, root): if not root: return 0 if root.left and not root.left.left and not root.left.right: return root.left.val + self.sumOfLeftLeaves(root.right) return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) # isn&apos;t leave EDIT: Could be 3 Lines, but L2 would be too long.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[403. Frog Jump]]></title>
    <url>%2Fp%2F504eaa0c%2F</url>
    <content type="text"><![CDATA[31.0% https://leetcode.com/problems/frog-jump/ A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water. Given a list of stones’ positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit. If the frog’s last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction. Note: The number of stones is ≥ 2 and is &lt; 1,100. Each stone’s position will be a non-negative integer &lt; 231. The first stone’s position is always 0. 12345678910111213Example 1:[0,1,3,5,6,8,12,17]There are a total of 8 stones.The first stone at the 0th unit, second stone at the 1st unit,third stone at the 3rd unit, and so on...The last stone at the 17th unit.Return true. The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone. 123456Example 2:[0,1,2,3,4,8,9,11]Return false. There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large. 6ms, September 19, 2016 https://discuss.leetcode.com/topic/59439/straight-forward-9ms-7-line-c-solution-with-explanation 方法一： Straight-forward 9ms 7-line c++ solution with explanation Search for the last stone in a depth-first way, prune those exceeding the [k-1,k+1] range. Well, I think the code is simple enough and need no more explanation. 123456789bool canCross(vector&lt;int&gt;&amp; stones, int pos = 0, int k = 0) &#123; for (int i = pos + 1; i &lt; stones.size(); i++) &#123; int gap = stones[i] - stones[pos]; if (gap &lt; k - 1) continue; if (gap &gt; k + 1) return false; if (canCross(stones, i, gap)) return true; &#125; return pos == stones.size() - 1;&#125; 我的代码实现： 上面的代码及本代码都会出现超时错误 123456789101112131415161718class Solution &#123;public: bool canCross(vector&lt;int&gt;&amp; stones) &#123; return helper(stones, 0, 0); &#125; // pos当前位置的索引，step位于位置pos的步长，函数表示当前能到达pos， // 步长为step，返回是否能到达最后一个位置 bool helper(vector&lt;int&gt;&amp; stones, int pos, int step)&#123; for(int i=pos+1; i&lt;stones.size(); i++)&#123; int cur_step = stones[i] - stones[pos]; if(cur_step&lt;step-1) continue; if(cur_step&gt;step+1) return false; if(helper(stones, i, cur_step)) return true; &#125; return pos==stones.size()-1; &#125;&#125;; 方法二： 我的代码实现: 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool canCross(vector&lt;int&gt;&amp; stones) &#123; unordered_map&lt;int, bool&gt; map; return helper(stones, 0, 0, map); &#125; bool helper(vector&lt;int&gt;&amp; stones, int index, int step, unordered_map&lt;int, bool&gt;&amp; map)&#123; int key = step&lt;&lt;11 | index; // 一定要先有这句话，不然每次都要重新运行 if(map.count(key)&gt;0) return map[key]; for(int i=index+1; i&lt;stones.size(); i++)&#123; int gap = stones[i] - stones[index]; if(gap&lt;step-1) continue; if(gap&gt;step+1)&#123; map[key] = false; return map[key]; &#125; if(helper(stones, i, gap, map))&#123; map[key] = true; return map[key]; &#125; &#125; map[key] = (index==stones.size()-1); return map[key]; &#125;&#125;; This can pass OJ at 9ms but is inefficient for extreme cases. (update: new test cases are added and the solution above no longer passes OJ, please see the solution below which takes 62ms) We can memorize the returns with minimum effort: 1234567891011121314151617181920unordered_map&lt;int, bool&gt; dp;bool canCross(vector&lt;int&gt;&amp; stones, int pos = 0, int k = 0) &#123; int key = pos | k &lt;&lt; 11; if (dp.count(key) &gt; 0) return dp[key]; for (int i = pos + 1; i &lt; stones.size(); i++) &#123; int gap = stones[i] - stones[pos]; if (gap &lt; k - 1) continue; if (gap &gt; k + 1) return dp[key] = false; if (canCross(stones, i, gap)) return dp[key] = true; &#125; return dp[key] = (pos == stones.size() - 1);&#125; The number of stones is less than 1100 so pos will always be less than 2^11 (2048).Stone positions could be theoretically up to 2^31 but k is practically not possible to be that big for the parameter as the steps must start from 0 and 1 and at the 1100th step the greatest valid k would be 1100. So combining pos and k is safe here. 我的代码实现： 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool canCross(vector&lt;int&gt;&amp; stones) &#123; unordered_map&lt;int, bool&gt; map; return helper(stones, 0, 0, map); &#125; bool helper(vector&lt;int&gt;&amp; stones, int pos, int step, unordered_map&lt;int, bool&gt;&amp; map)&#123; // map有find也有count函数，count有结果返回1，否则0 // find有则返回一个迭代器，否则返回一个end的迭代器 // key要用自己设置，包含pos和step，只使用pos是不能返回正确结果的 // dp时，不要用pos做key，使用pos的组合做也是可以的。 int key = pos | step &lt;&lt; 11; if(map.count(key)&gt;0) return map[key]; for(int i=pos+1; i&lt;stones.size(); i++)&#123; int gap = stones[i] - stones[pos]; if(gap&lt;step-1) continue; if(gap&gt;step+1)&#123; map[key] = false; return map[key]; // 此处也不要忘了更新map &#125; if(helper(stones, i, gap, map))&#123; map[key] = true; // 注意更新map,注意更新的是pos，不是i return map[key]; &#125; &#125; // map保存当前位置pos能否到达最后位置 // 经过前面的循环后，保存是否能到达，不要忘记此处的更新 map[key] = (pos == stones.size()-1); return map[key]; &#125;&#125;; 方法三： 我的代码实现： 1234567891011121314class Solution &#123;public: bool canCross(vector&lt;int&gt;&amp; stones) &#123; unordered_map&lt;int, set&lt;int&gt;&gt; map = &#123;&#123;0, &#123;0&#125;&#125;&#125;; // 学习map初始化，及set初始化 for(auto pos:stones)&#123; for(auto step:map[pos])&#123; if(step-1&gt;0) map[pos+step-1].insert(step-1); // insert if(step&gt;0) map[pos+step].insert(step); map[pos+step+1].insert(step+1); &#125; &#125; return map[stones.back()].size(); &#125;&#125;; 使用一个map，记录每个位置为key，value为到达当前位置的所有步长的set集合。 平时不怎么用map再套set，这个方法很容易想到，也比较有用。 https://discuss.leetcode.com/topic/60194/c-9-lines-o-n-2-iterative-dp-solution C++ 9 lines O(n^2) iterative DP solution This solution is not as fast as some other O(n^2) DFS solutions possibly due to the OJ test cases. But it’s simple and clean.Special thanks @farahcs and @vesion for correcting the bug in previous code. 1234567891011121314bool canCross(vector&lt;int&gt;&amp; stones) &#123; // To record available last steps to reach current position. Position 0 need 0 step to be reached unordered_map&lt;int, unordered_set&lt;int&gt;&gt; steps = &#123;&#123;0, &#123;0&#125;&#125;&#125;; for (int pos : stones) &#123; for (auto it = steps[pos].begin(); it != steps[pos].end(); it++) &#123; // record all future reachable positions if (*it - 1) &#123; steps[pos + *it - 1].insert(*it - 1); &#125; steps[pos + *it].insert(*it); steps[pos + *it + 1].insert(*it + 1); &#125; &#125; return steps[stones.back()].size(); // check if the last position is reachable &#125; python https://discuss.leetcode.com/topic/60080/python-dfs-easy-understanding-using-memo Python DFS easy understanding using memo Following is my backtracking solution using dict for memorization. The memo dict is using for save those dead end. So when we get to the same stone with the same speed we don’t need to search further. 12345678910111213141516171819202122232425262728class Solution(object): def canCross(self, stones): self.memo = set() target = stones[-1] stones = set(stones) res = self.bt(stones, 1, 1, target) return res def bt(self, stones, cur, speed, target): # check memo if (cur, speed) in self.memo: return False if cur==target: return True if cur&gt;target or cur&lt;0 or speed&lt;=0 or cur not in stones: return False # dfs candidate = [speed-1, speed, speed+1] for c in candidate: if (cur + c) in stones: if self.bt(stones, cur+c, c, target): return True self.memo.add((cur,speed)) return False java 26ms, September 19, 2016 https://discuss.leetcode.com/topic/59337/easy-version-java 1234567891011121314151617public class Solution &#123; public boolean canCross(int[] stones) &#123; if(stones[1]&gt; 1) return false; if(stones.length == 2) return true; return helper(stones, 1, 1); &#125; private boolean helper(int[] arr, int i, int step)&#123; boolean pass = false; if(i == arr.length -1) return true; for(int j = i+1; j &lt; arr.length; j++)&#123; if(arr[j] &lt;= arr[i] + step+1 &amp;&amp; arr[j] &gt;= arr[i] + step-1) pass = pass || helper(arr, j, arr[j] - arr[i]); &#125; return pass; &#125;&#125; https://leetcode.com/articles/frog-jump/ Approach #3 Using Memorization [Accepted] Algorithm Another problem with above approaches is that we can make the same function calls coming through different paths e.g. For a given currentIndexcurrentIndex, we can call the recursive function canCrosscanCross with the jumpsizejumpsize, say nn. This nn could be resulting from previous jumpsizejumpsize being n-1n−1,nn or n+1n+1. Thus, many redundant function calls could be made prolonging the running time. This redundancy can be removed by making use of memorization. We make use of a 2-d memomemo array, initialized by -1−1s, to store the result returned from a function call for a particular currentIndexcurrentIndex and jumpsizejumpsize. If the same currentIndexcurrentIndex and jumpsizejumpsize happens is encountered again, we can return the result directly using the memomemo array. This helps to prune the search tree to a great extent. java 12345678910111213141516171819202122232425public class Solution &#123; public boolean canCross(int[] stones) &#123; int[][] memo = new int[stones.length][stones.length]; for (int[] row : memo) &#123; Arrays.fill(row, -1); &#125; return can_Cross(stones, 0, 0, memo) == 1; &#125; public int can_Cross(int[] stones, int ind, int jumpsize, int[][] memo) &#123; if (memo[ind][jumpsize] &gt;= 0) &#123; return memo[ind][jumpsize]; &#125; for (int i = ind + 1; i &lt; stones.length; i++) &#123; int gap = stones[i] - stones[ind]; if (gap &gt;= jumpsize - 1 &amp;&amp; gap &lt;= jumpsize + 1) &#123; if (can_Cross(stones, i, gap, memo) == 1) &#123; memo[ind][gap] = 1; return 1; &#125; &#125; &#125; memo[ind][jumpsize] = (ind == stones.length - 1) ? 1 : 0; return memo[ind][jumpsize]; &#125;&#125; Approach #4 Using Memorization with Binary Search [Accepted] Algorithm We can optimize the above memorization approach, if we make use of Binary Search to find if a stone exists at currentPostion + newjumpsizecurrentPostion+newjumpsize instead of searching linearly. java 12345678910111213141516171819202122232425262728293031public class Solution &#123; public boolean canCross(int[] stones) &#123; int[][] memo = new int[stones.length][stones.length]; for (int[] row : memo) &#123; Arrays.fill(row, -1); &#125; return can_Cross(stones, 0, 0, memo) == 1; &#125; public int can_Cross(int[] stones, int ind, int jumpsize, int[][] memo) &#123; if (memo[ind][jumpsize] &gt;= 0) &#123; return memo[ind][jumpsize]; &#125; int ind1 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize); if (ind1 &gt;= 0 &amp;&amp; can_Cross(stones, ind1, jumpsize, memo) == 1) &#123; memo[ind][jumpsize] = 1; return 1; &#125; int ind2 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize - 1); if (ind2 &gt;= 0 &amp;&amp; can_Cross(stones, ind2, jumpsize - 1, memo) == 1) &#123; memo[ind][jumpsize - 1] = 1; return 1; &#125; int ind3 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize + 1); if (ind3 &gt;= 0 &amp;&amp; can_Cross(stones, ind3, jumpsize + 1, memo) == 1) &#123; memo[ind][jumpsize + 1] = 1; return 1; &#125; memo[ind][jumpsize] = ((ind == stones.length - 1) ? 1 : 0); return memo[ind][jumpsize]; &#125;&#125; Approach #5 Using Dynamic Programming[Accepted] Algorithm In the DP Approach, we make use of a hashmap mapmap which contains key:valuekey:value pairs such that keykey refers to the position at which a stone is present and valuevalue is a set containing the jumpsizejumpsize which can lead to the current stone position. We start by making a hashmap whose keykeys are all the positions at which a stone is present and the valuevalues are all empty except position 0 whose value contains 0. Then, we start traversing the elements(positions) of the given stone array in sequential order. For the currentPositioncurrentPosition, for every possible jumpsizejumpsize in the valuevalue set, we check if currentPosition + newjumpsizecurrentPosition+newjumpsize exists in the mapmap, where newjumpsizenewjumpsize can be either jumpsize-1jumpsize−1, jumpsizejumpsize, jumpsize+1jumpsize+1. If so, we append the corresponding valuevalue set with newjumpsizenewjumpsize. We continue in the same manner. If at the end, the valuevalue set corresponding to the last position is non-empty, we conclude that reaching the end is possible, otherwise, it isn’t. For more understanding see this animation- java 12345678910111213141516171819public class Solution &#123; public boolean canCross(int[] stones) &#123; HashMap&lt;Integer, Set&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; stones.length; i++) &#123; map.put(stones[i], new HashSet&lt;Integer&gt;()); &#125; map.get(0).add(0); for (int i = 0; i &lt; stones.length; i++) &#123; for (int k : map.get(stones[i])) &#123; for (int step = k - 1; step &lt;= k + 1; step++) &#123; if (step &gt; 0 &amp;&amp; map.containsKey(stones[i] + step)) &#123; map.get(stones[i] + step).add(step); &#125; &#125; &#125; &#125; return map.get(stones[stones.length - 1]).size() &gt; 0; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[402. Remove K Digits]]></title>
    <url>%2Fp%2Fc694c9c7%2F</url>
    <content type="text"><![CDATA[26.1% https://leetcode.com/problems/remove-k-digits/description/ Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible. Note: The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero. 123456789101112131415Example 1:Input: num = &quot;1432219&quot;, k = 3Output: &quot;1219&quot;Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.Example 2:Input: num = &quot;10200&quot;, k = 1Output: &quot;200&quot;Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.Example 3:Input: num = &quot;10&quot;, k = 2Output: &quot;0&quot;Explanation: Remove all the digits from the number and it is left with nothing which is 0. 方法一： https://discuss.leetcode.com/topic/59871/two-algorithms-with-detailed-explaination Two algorithms with detailed explaination The first algorithm is straight-forward. Let’s think about the simplest case: how to remove 1 digit from the number so that the new number is the smallest possible？ Well, one can simply scan from left to right, and remove the first “peak” digit; the peak digit is larger than its right neighbor. One can repeat this procedure k times, and obtain the first algorithm: 123456789101112131415string removeKdigits(string num, int k) &#123; while (k &gt; 0) &#123; int n = num.size(); int i = 0; while (i+1&lt;n &amp;&amp; num[i]&lt;=num[i+1]) i++; num.erase(i, 1); k--; &#125; // trim leading zeros int s = 0; while (s&lt;(int)num.size()-1 &amp;&amp; num[s]=='0') s++; num.erase(0, s); return num=="" ? "0" : num; &#125; 方法二： 我的代码实现： 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string removeKdigits(string num, int k) &#123; if(k&gt;=num.size()) return "0"; if(k==0) return num; string res; // k在后面发生了改变 int keep = num.size() - k; for(auto c:num)&#123; while(!res.empty() &amp;&amp; res.back()&gt;c &amp;&amp; k&gt;0)&#123; res.pop_back(); k--; &#125; res.push_back(c); &#125; // 记得去掉后面长度过长的部分 if(res.size()&gt;keep) res.erase(keep); // 牢记学习erase的用法 // sequence (1) 消除pos开始，长度为npos的一段 // string&amp; erase (size_t pos = 0, size_t len = npos); // character (2) 只消除p指向的位置 // iterator erase (const_iterator p); // range (3) 消除first至last之间的一段 // iterator erase (const_iterator first, const_iterator last); while(res.size()&gt;1 &amp;&amp; res[0]=='0') res.erase(0, 1); return res; &#125;&#125;; The above algorithm is a bit inefficient because it frequently remove a particular element from a string and has complexity O(k* n). One can simulate the above procedure by using a stack, and obtain a O(n) algorithm. Note, when the result stack (i.e. res) pop a digit, it is equivalent as remove that “peak” digit. 123456789101112131415161718192021string removeKdigits(string num, int k) &#123; string res; int keep = num.size() - k; for (int i=0; i&lt;num.size(); i++) &#123; while (res.size()&gt;0 &amp;&amp; res.back()&gt;num[i] &amp;&amp; k&gt;0) &#123; res.pop_back(); k--; &#125; res.push_back(num[i]); &#125; // 此处要求keep必须&lt;= res.size() // 注意等于也可以 res.erase(keep, string::npos); // trim leading zeros int s = 0; while (s&lt;(int)res.size()-1 &amp;&amp; res[s]=='0') s++; res.erase(0, s); return res=="" ? "0" : res; &#125; https://discuss.leetcode.com/topic/59412/a-greedy-method-using-stack-o-n-time-and-o-n-space A greedy method using stack, O(n) time and O(n) space 1234567891011121314151617181920212223public class Solution &#123; public String removeKdigits(String num, int k) &#123; int digits = num.length() - k; char[] stk = new char[num.length()]; int top = 0; // k keeps track of how many characters we can remove // if the previous character in stk is larger than the current one // then removing it will get a smaller number // but we can only do so when k is larger than 0 for (int i = 0; i &lt; num.length(); ++i) &#123; char c = num.charAt(i); while (top &gt; 0 &amp;&amp; stk[top-1] &gt; c &amp;&amp; k &gt; 0) &#123; top -= 1; k -= 1; &#125; stk[top++] = c; &#125; // find the index of first non-zero digit int idx = 0; while (idx &lt; digits &amp;&amp; stk[idx] == '0') idx++; return idx == digits? "0": new String(stk, idx, digits - idx); &#125;&#125; python52ms, September 19, 2016 https://discuss.leetcode.com/topic/59380/short-python-one-o-n-and-one-regex 1234567891011121314class Solution(object): def removeKdigits(self, num, k): &quot;&quot;&quot; :type num: str :type k: int :rtype: str &quot;&quot;&quot; out = [] for d in num: while k and out and out[-1] &gt; d: out.pop() k -= 1 out.append(d) return &apos;&apos;.join(out[:-k or None]).lstrip(&apos;0&apos;) or &apos;0&apos; 272ms, September 19, 2016 https://discuss.leetcode.com/topic/59380/short-python-one-o-n-and-one-regex 1234567891011class Solution(object): def removeKdigits(self, num, k): &quot;&quot;&quot; :type num: str :type k: int :rtype: str &quot;&quot;&quot; sub = re.compile(&apos;1[0]|2[01]|3[0-2]|4[0-3]|5[0-4]|6[0-5]|7[0-6]|8[0-7]|9[0-8]|.$&apos;).sub for _ in range(k): num = sub(lambda m: m.group()[1:], num, 1) return num.lstrip(&apos;0&apos;) or &apos;0&apos;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>stack</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[401. Binary Watch]]></title>
    <url>%2Fp%2F6e69068%2F</url>
    <content type="text"><![CDATA[44.4% A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right. For example, the above binary watch reads “3:25”. Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent. 1234Example:Input: n = 1Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;] Note: The order of output does not matter. The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”. The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”. 方法一: 使用bitset 将4个时钟和6个分针合并一起 同时遍历了所有可能的时间，然后去判断几个1，使用bitset 这个想法非常不粗 我的代码实现： 1234567891011121314class Solution &#123;public: vector&lt;string&gt; readBinaryWatch(int num) &#123; vector&lt;string&gt; res; for(int h=0; h&lt;12; h++) for(int m=0; m&lt;60; m++) if(bitset&lt;10&gt;(h&lt;&lt;6 | m).count()==num)&#123; string t; t = to_string(h) + (m&lt;10 ? ":0" : ":" ) + to_string(m); res.push_back(t); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/59401/straight-forward-6-line-c-solution-no-need-to-explain Straight-forward 6-line c++ solution, no need to explain 12345678vector&lt;string&gt; readBinaryWatch(int num) &#123; vector&lt;string&gt; rs; for (int h = 0; h &lt; 12; h++) for (int m = 0; m &lt; 60; m++) if (bitset&lt;10&gt;(h &lt;&lt; 6 | m).count() == num) rs.emplace_back(to_string(h) + (m &lt; 10 ? &quot;:0&quot; : &quot;:&quot;) + to_string(m)); return rs;&#125; 方法二： python 75ms, September 19, 2016 https://discuss.leetcode.com/topic/59374/simple-python-java 123456789class Solution(object): def readBinaryWatch(self, num): &quot;&quot;&quot; :type num: int :rtype: List[str] &quot;&quot;&quot; return [&apos;%d:%02d&apos; % (h, m) for h in range(12) for m in range(60) if (bin(h) + bin(m)).count(&apos;1&apos;) == num] https://discuss.leetcode.com/topic/60319/python-dfs-and-complexity-analysis Python DFS, and complexity analysis Similar to other solutions out there. The code has O(1) time complexity, because all the possible watch combinations (valid or invalid) can’t be more that 12 * 59.Regarding space complexity, it’s also O(1) cause the DFS will have depth of maximum n, which can’t be more than 9 as per problem boundary. 123456789101112131415161718class Solution(object): def readBinaryWatch(self, n): def dfs(n, hours, mins, idx): if hours &gt;= 12 or mins &gt; 59: return if not n: res.append(str(hours) + &quot;:&quot; + &quot;0&quot; * (mins &lt; 10) + str(mins)) return for i in range(idx, 10): if i &lt; 4: dfs(n - 1, hours | (1 &lt;&lt; i), mins, i + 1) else: k = i - 4 dfs(n - 1, hours, mins | (1 &lt;&lt; k), i + 1) res = [] dfs(n, 0, 0, 0) return res 62ms, September 19, 2016 12345678class Solution(object): def readBinaryWatch(self, num): &quot;&quot;&quot; :type num: int :rtype: List[str] &quot;&quot;&quot; ans = [[&apos;0:00&apos;], [&apos;0:01&apos;, &apos;0:02&apos;, &apos;0:04&apos;, &apos;0:08&apos;, &apos;0:16&apos;, &apos;0:32&apos;, &apos;1:00&apos;, &apos;2:00&apos;, &apos;4:00&apos;, &apos;8:00&apos;], [&apos;0:03&apos;, &apos;0:05&apos;, &apos;0:06&apos;, &apos;0:09&apos;, &apos;0:10&apos;, &apos;0:12&apos;, &apos;0:17&apos;, &apos;0:18&apos;, &apos;0:20&apos;, &apos;0:24&apos;, &apos;0:33&apos;, &apos;0:34&apos;, &apos;0:36&apos;, &apos;0:40&apos;, &apos;0:48&apos;, &apos;1:01&apos;, &apos;1:02&apos;, &apos;1:04&apos;, &apos;1:08&apos;, &apos;1:16&apos;, &apos;1:32&apos;, &apos;2:01&apos;, &apos;2:02&apos;, &apos;2:04&apos;, &apos;2:08&apos;, &apos;2:16&apos;, &apos;2:32&apos;, &apos;3:00&apos;, &apos;4:01&apos;, &apos;4:02&apos;, &apos;4:04&apos;, &apos;4:08&apos;, &apos;4:16&apos;, &apos;4:32&apos;, &apos;5:00&apos;, &apos;6:00&apos;, &apos;8:01&apos;, &apos;8:02&apos;, &apos;8:04&apos;, &apos;8:08&apos;, &apos;8:16&apos;, &apos;8:32&apos;, &apos;9:00&apos;, &apos;10:00&apos;], [&apos;0:07&apos;, &apos;0:11&apos;, &apos;0:13&apos;, &apos;0:14&apos;, &apos;0:19&apos;, &apos;0:21&apos;, &apos;0:22&apos;, &apos;0:25&apos;, &apos;0:26&apos;, &apos;0:28&apos;, &apos;0:35&apos;, &apos;0:37&apos;, &apos;0:38&apos;, &apos;0:41&apos;, &apos;0:42&apos;, &apos;0:44&apos;, &apos;0:49&apos;, &apos;0:50&apos;, &apos;0:52&apos;, &apos;0:56&apos;, &apos;1:03&apos;, &apos;1:05&apos;, &apos;1:06&apos;, &apos;1:09&apos;, &apos;1:10&apos;, &apos;1:12&apos;, &apos;1:17&apos;, &apos;1:18&apos;, &apos;1:20&apos;, &apos;1:24&apos;, &apos;1:33&apos;, &apos;1:34&apos;, &apos;1:36&apos;, &apos;1:40&apos;, &apos;1:48&apos;, &apos;2:03&apos;, &apos;2:05&apos;, &apos;2:06&apos;, &apos;2:09&apos;, &apos;2:10&apos;, &apos;2:12&apos;, &apos;2:17&apos;, &apos;2:18&apos;, &apos;2:20&apos;, &apos;2:24&apos;, &apos;2:33&apos;, &apos;2:34&apos;, &apos;2:36&apos;, &apos;2:40&apos;, &apos;2:48&apos;, &apos;3:01&apos;, &apos;3:02&apos;, &apos;3:04&apos;, &apos;3:08&apos;, &apos;3:16&apos;, &apos;3:32&apos;, &apos;4:03&apos;, &apos;4:05&apos;, &apos;4:06&apos;, &apos;4:09&apos;, &apos;4:10&apos;, &apos;4:12&apos;, &apos;4:17&apos;, &apos;4:18&apos;, &apos;4:20&apos;, &apos;4:24&apos;, &apos;4:33&apos;, &apos;4:34&apos;, &apos;4:36&apos;, &apos;4:40&apos;, &apos;4:48&apos;, &apos;5:01&apos;, &apos;5:02&apos;, &apos;5:04&apos;, &apos;5:08&apos;, &apos;5:16&apos;, &apos;5:32&apos;, &apos;6:01&apos;, &apos;6:02&apos;, &apos;6:04&apos;, &apos;6:08&apos;, &apos;6:16&apos;, &apos;6:32&apos;, &apos;7:00&apos;, &apos;8:03&apos;, &apos;8:05&apos;, &apos;8:06&apos;, &apos;8:09&apos;, &apos;8:10&apos;, &apos;8:12&apos;, &apos;8:17&apos;, &apos;8:18&apos;, &apos;8:20&apos;, &apos;8:24&apos;, &apos;8:33&apos;, &apos;8:34&apos;, &apos;8:36&apos;, &apos;8:40&apos;, &apos;8:48&apos;, &apos;9:01&apos;, &apos;9:02&apos;, &apos;9:04&apos;, &apos;9:08&apos;, &apos;9:16&apos;, &apos;9:32&apos;, &apos;10:01&apos;, &apos;10:02&apos;, &apos;10:04&apos;, &apos;10:08&apos;, &apos;10:16&apos;, &apos;10:32&apos;, &apos;11:00&apos;], [&apos;0:15&apos;, &apos;0:23&apos;, &apos;0:27&apos;, &apos;0:29&apos;, &apos;0:30&apos;, &apos;0:39&apos;, &apos;0:43&apos;, &apos;0:45&apos;, &apos;0:46&apos;, &apos;0:51&apos;, &apos;0:53&apos;, &apos;0:54&apos;, &apos;0:57&apos;, &apos;0:58&apos;, &apos;1:07&apos;, &apos;1:11&apos;, &apos;1:13&apos;, &apos;1:14&apos;, &apos;1:19&apos;, &apos;1:21&apos;, &apos;1:22&apos;, &apos;1:25&apos;, &apos;1:26&apos;, &apos;1:28&apos;, &apos;1:35&apos;, &apos;1:37&apos;, &apos;1:38&apos;, &apos;1:41&apos;, &apos;1:42&apos;, &apos;1:44&apos;, &apos;1:49&apos;, &apos;1:50&apos;, &apos;1:52&apos;, &apos;1:56&apos;, &apos;2:07&apos;, &apos;2:11&apos;, &apos;2:13&apos;, &apos;2:14&apos;, &apos;2:19&apos;, &apos;2:21&apos;, &apos;2:22&apos;, &apos;2:25&apos;, &apos;2:26&apos;, &apos;2:28&apos;, &apos;2:35&apos;, &apos;2:37&apos;, &apos;2:38&apos;, &apos;2:41&apos;, &apos;2:42&apos;, &apos;2:44&apos;, &apos;2:49&apos;, &apos;2:50&apos;, &apos;2:52&apos;, &apos;2:56&apos;, &apos;3:03&apos;, &apos;3:05&apos;, &apos;3:06&apos;, &apos;3:09&apos;, &apos;3:10&apos;, &apos;3:12&apos;, &apos;3:17&apos;, &apos;3:18&apos;, &apos;3:20&apos;, &apos;3:24&apos;, &apos;3:33&apos;, &apos;3:34&apos;, &apos;3:36&apos;, &apos;3:40&apos;, &apos;3:48&apos;, &apos;4:07&apos;, &apos;4:11&apos;, &apos;4:13&apos;, &apos;4:14&apos;, &apos;4:19&apos;, &apos;4:21&apos;, &apos;4:22&apos;, &apos;4:25&apos;, &apos;4:26&apos;, &apos;4:28&apos;, &apos;4:35&apos;, &apos;4:37&apos;, &apos;4:38&apos;, &apos;4:41&apos;, &apos;4:42&apos;, &apos;4:44&apos;, &apos;4:49&apos;, &apos;4:50&apos;, &apos;4:52&apos;, &apos;4:56&apos;, &apos;5:03&apos;, &apos;5:05&apos;, &apos;5:06&apos;, &apos;5:09&apos;, &apos;5:10&apos;, &apos;5:12&apos;, &apos;5:17&apos;, &apos;5:18&apos;, &apos;5:20&apos;, &apos;5:24&apos;, &apos;5:33&apos;, &apos;5:34&apos;, &apos;5:36&apos;, &apos;5:40&apos;, &apos;5:48&apos;, &apos;6:03&apos;, &apos;6:05&apos;, &apos;6:06&apos;, &apos;6:09&apos;, &apos;6:10&apos;, &apos;6:12&apos;, &apos;6:17&apos;, &apos;6:18&apos;, &apos;6:20&apos;, &apos;6:24&apos;, &apos;6:33&apos;, &apos;6:34&apos;, &apos;6:36&apos;, &apos;6:40&apos;, &apos;6:48&apos;, &apos;7:01&apos;, &apos;7:02&apos;, &apos;7:04&apos;, &apos;7:08&apos;, &apos;7:16&apos;, &apos;7:32&apos;, &apos;8:07&apos;, &apos;8:11&apos;, &apos;8:13&apos;, &apos;8:14&apos;, &apos;8:19&apos;, &apos;8:21&apos;, &apos;8:22&apos;, &apos;8:25&apos;, &apos;8:26&apos;, &apos;8:28&apos;, &apos;8:35&apos;, &apos;8:37&apos;, &apos;8:38&apos;, &apos;8:41&apos;, &apos;8:42&apos;, &apos;8:44&apos;, &apos;8:49&apos;, &apos;8:50&apos;, &apos;8:52&apos;, &apos;8:56&apos;, &apos;9:03&apos;, &apos;9:05&apos;, &apos;9:06&apos;, &apos;9:09&apos;, &apos;9:10&apos;, &apos;9:12&apos;, &apos;9:17&apos;, &apos;9:18&apos;, &apos;9:20&apos;, &apos;9:24&apos;, &apos;9:33&apos;, &apos;9:34&apos;, &apos;9:36&apos;, &apos;9:40&apos;, &apos;9:48&apos;, &apos;10:03&apos;, &apos;10:05&apos;, &apos;10:06&apos;, &apos;10:09&apos;, &apos;10:10&apos;, &apos;10:12&apos;, &apos;10:17&apos;, &apos;10:18&apos;, &apos;10:20&apos;, &apos;10:24&apos;, &apos;10:33&apos;, &apos;10:34&apos;, &apos;10:36&apos;, &apos;10:40&apos;, &apos;10:48&apos;, &apos;11:01&apos;, &apos;11:02&apos;, &apos;11:04&apos;, &apos;11:08&apos;, &apos;11:16&apos;, &apos;11:32&apos;], [&apos;0:31&apos;, &apos;0:47&apos;, &apos;0:55&apos;, &apos;0:59&apos;, &apos;1:15&apos;, &apos;1:23&apos;, &apos;1:27&apos;, &apos;1:29&apos;, &apos;1:30&apos;, &apos;1:39&apos;, &apos;1:43&apos;, &apos;1:45&apos;, &apos;1:46&apos;, &apos;1:51&apos;, &apos;1:53&apos;, &apos;1:54&apos;, &apos;1:57&apos;, &apos;1:58&apos;, &apos;2:15&apos;, &apos;2:23&apos;, &apos;2:27&apos;, &apos;2:29&apos;, &apos;2:30&apos;, &apos;2:39&apos;, &apos;2:43&apos;, &apos;2:45&apos;, &apos;2:46&apos;, &apos;2:51&apos;, &apos;2:53&apos;, &apos;2:54&apos;, &apos;2:57&apos;, &apos;2:58&apos;, &apos;3:07&apos;, &apos;3:11&apos;, &apos;3:13&apos;, &apos;3:14&apos;, &apos;3:19&apos;, &apos;3:21&apos;, &apos;3:22&apos;, &apos;3:25&apos;, &apos;3:26&apos;, &apos;3:28&apos;, &apos;3:35&apos;, &apos;3:37&apos;, &apos;3:38&apos;, &apos;3:41&apos;, &apos;3:42&apos;, &apos;3:44&apos;, &apos;3:49&apos;, &apos;3:50&apos;, &apos;3:52&apos;, &apos;3:56&apos;, &apos;4:15&apos;, &apos;4:23&apos;, &apos;4:27&apos;, &apos;4:29&apos;, &apos;4:30&apos;, &apos;4:39&apos;, &apos;4:43&apos;, &apos;4:45&apos;, &apos;4:46&apos;, &apos;4:51&apos;, &apos;4:53&apos;, &apos;4:54&apos;, &apos;4:57&apos;, &apos;4:58&apos;, &apos;5:07&apos;, &apos;5:11&apos;, &apos;5:13&apos;, &apos;5:14&apos;, &apos;5:19&apos;, &apos;5:21&apos;, &apos;5:22&apos;, &apos;5:25&apos;, &apos;5:26&apos;, &apos;5:28&apos;, &apos;5:35&apos;, &apos;5:37&apos;, &apos;5:38&apos;, &apos;5:41&apos;, &apos;5:42&apos;, &apos;5:44&apos;, &apos;5:49&apos;, &apos;5:50&apos;, &apos;5:52&apos;, &apos;5:56&apos;, &apos;6:07&apos;, &apos;6:11&apos;, &apos;6:13&apos;, &apos;6:14&apos;, &apos;6:19&apos;, &apos;6:21&apos;, &apos;6:22&apos;, &apos;6:25&apos;, &apos;6:26&apos;, &apos;6:28&apos;, &apos;6:35&apos;, &apos;6:37&apos;, &apos;6:38&apos;, &apos;6:41&apos;, &apos;6:42&apos;, &apos;6:44&apos;, &apos;6:49&apos;, &apos;6:50&apos;, &apos;6:52&apos;, &apos;6:56&apos;, &apos;7:03&apos;, &apos;7:05&apos;, &apos;7:06&apos;, &apos;7:09&apos;, &apos;7:10&apos;, &apos;7:12&apos;, &apos;7:17&apos;, &apos;7:18&apos;, &apos;7:20&apos;, &apos;7:24&apos;, &apos;7:33&apos;, &apos;7:34&apos;, &apos;7:36&apos;, &apos;7:40&apos;, &apos;7:48&apos;, &apos;8:15&apos;, &apos;8:23&apos;, &apos;8:27&apos;, &apos;8:29&apos;, &apos;8:30&apos;, &apos;8:39&apos;, &apos;8:43&apos;, &apos;8:45&apos;, &apos;8:46&apos;, &apos;8:51&apos;, &apos;8:53&apos;, &apos;8:54&apos;, &apos;8:57&apos;, &apos;8:58&apos;, &apos;9:07&apos;, &apos;9:11&apos;, &apos;9:13&apos;, &apos;9:14&apos;, &apos;9:19&apos;, &apos;9:21&apos;, &apos;9:22&apos;, &apos;9:25&apos;, &apos;9:26&apos;, &apos;9:28&apos;, &apos;9:35&apos;, &apos;9:37&apos;, &apos;9:38&apos;, &apos;9:41&apos;, &apos;9:42&apos;, &apos;9:44&apos;, &apos;9:49&apos;, &apos;9:50&apos;, &apos;9:52&apos;, &apos;9:56&apos;, &apos;10:07&apos;, &apos;10:11&apos;, &apos;10:13&apos;, &apos;10:14&apos;, &apos;10:19&apos;, &apos;10:21&apos;, &apos;10:22&apos;, &apos;10:25&apos;, &apos;10:26&apos;, &apos;10:28&apos;, &apos;10:35&apos;, &apos;10:37&apos;, &apos;10:38&apos;, &apos;10:41&apos;, &apos;10:42&apos;, &apos;10:44&apos;, &apos;10:49&apos;, &apos;10:50&apos;, &apos;10:52&apos;, &apos;10:56&apos;, &apos;11:03&apos;, &apos;11:05&apos;, &apos;11:06&apos;, &apos;11:09&apos;, &apos;11:10&apos;, &apos;11:12&apos;, &apos;11:17&apos;, &apos;11:18&apos;, &apos;11:20&apos;, &apos;11:24&apos;, &apos;11:33&apos;, &apos;11:34&apos;, &apos;11:36&apos;, &apos;11:40&apos;, &apos;11:48&apos;], [&apos;1:31&apos;, &apos;1:47&apos;, &apos;1:55&apos;, &apos;1:59&apos;, &apos;2:31&apos;, &apos;2:47&apos;, &apos;2:55&apos;, &apos;2:59&apos;, &apos;3:15&apos;, &apos;3:23&apos;, &apos;3:27&apos;, &apos;3:29&apos;, &apos;3:30&apos;, &apos;3:39&apos;, &apos;3:43&apos;, &apos;3:45&apos;, &apos;3:46&apos;, &apos;3:51&apos;, &apos;3:53&apos;, &apos;3:54&apos;, &apos;3:57&apos;, &apos;3:58&apos;, &apos;4:31&apos;, &apos;4:47&apos;, &apos;4:55&apos;, &apos;4:59&apos;, &apos;5:15&apos;, &apos;5:23&apos;, &apos;5:27&apos;, &apos;5:29&apos;, &apos;5:30&apos;, &apos;5:39&apos;, &apos;5:43&apos;, &apos;5:45&apos;, &apos;5:46&apos;, &apos;5:51&apos;, &apos;5:53&apos;, &apos;5:54&apos;, &apos;5:57&apos;, &apos;5:58&apos;, &apos;6:15&apos;, &apos;6:23&apos;, &apos;6:27&apos;, &apos;6:29&apos;, &apos;6:30&apos;, &apos;6:39&apos;, &apos;6:43&apos;, &apos;6:45&apos;, &apos;6:46&apos;, &apos;6:51&apos;, &apos;6:53&apos;, &apos;6:54&apos;, &apos;6:57&apos;, &apos;6:58&apos;, &apos;7:07&apos;, &apos;7:11&apos;, &apos;7:13&apos;, &apos;7:14&apos;, &apos;7:19&apos;, &apos;7:21&apos;, &apos;7:22&apos;, &apos;7:25&apos;, &apos;7:26&apos;, &apos;7:28&apos;, &apos;7:35&apos;, &apos;7:37&apos;, &apos;7:38&apos;, &apos;7:41&apos;, &apos;7:42&apos;, &apos;7:44&apos;, &apos;7:49&apos;, &apos;7:50&apos;, &apos;7:52&apos;, &apos;7:56&apos;, &apos;8:31&apos;, &apos;8:47&apos;, &apos;8:55&apos;, &apos;8:59&apos;, &apos;9:15&apos;, &apos;9:23&apos;, &apos;9:27&apos;, &apos;9:29&apos;, &apos;9:30&apos;, &apos;9:39&apos;, &apos;9:43&apos;, &apos;9:45&apos;, &apos;9:46&apos;, &apos;9:51&apos;, &apos;9:53&apos;, &apos;9:54&apos;, &apos;9:57&apos;, &apos;9:58&apos;, &apos;10:15&apos;, &apos;10:23&apos;, &apos;10:27&apos;, &apos;10:29&apos;, &apos;10:30&apos;, &apos;10:39&apos;, &apos;10:43&apos;, &apos;10:45&apos;, &apos;10:46&apos;, &apos;10:51&apos;, &apos;10:53&apos;, &apos;10:54&apos;, &apos;10:57&apos;, &apos;10:58&apos;, &apos;11:07&apos;, &apos;11:11&apos;, &apos;11:13&apos;, &apos;11:14&apos;, &apos;11:19&apos;, &apos;11:21&apos;, &apos;11:22&apos;, &apos;11:25&apos;, &apos;11:26&apos;, &apos;11:28&apos;, &apos;11:35&apos;, &apos;11:37&apos;, &apos;11:38&apos;, &apos;11:41&apos;, &apos;11:42&apos;, &apos;11:44&apos;, &apos;11:49&apos;, &apos;11:50&apos;, &apos;11:52&apos;, &apos;11:56&apos;], [&apos;3:31&apos;, &apos;3:47&apos;, &apos;3:55&apos;, &apos;3:59&apos;, &apos;5:31&apos;, &apos;5:47&apos;, &apos;5:55&apos;, &apos;5:59&apos;, &apos;6:31&apos;, &apos;6:47&apos;, &apos;6:55&apos;, &apos;6:59&apos;, &apos;7:15&apos;, &apos;7:23&apos;, &apos;7:27&apos;, &apos;7:29&apos;, &apos;7:30&apos;, &apos;7:39&apos;, &apos;7:43&apos;, &apos;7:45&apos;, &apos;7:46&apos;, &apos;7:51&apos;, &apos;7:53&apos;, &apos;7:54&apos;, &apos;7:57&apos;, &apos;7:58&apos;, &apos;9:31&apos;, &apos;9:47&apos;, &apos;9:55&apos;, &apos;9:59&apos;, &apos;10:31&apos;, &apos;10:47&apos;, &apos;10:55&apos;, &apos;10:59&apos;, &apos;11:15&apos;, &apos;11:23&apos;, &apos;11:27&apos;, &apos;11:29&apos;, &apos;11:30&apos;, &apos;11:39&apos;, &apos;11:43&apos;, &apos;11:45&apos;, &apos;11:46&apos;, &apos;11:51&apos;, &apos;11:53&apos;, &apos;11:54&apos;, &apos;11:57&apos;, &apos;11:58&apos;], [&apos;7:31&apos;, &apos;7:47&apos;, &apos;7:55&apos;, &apos;7:59&apos;, &apos;11:31&apos;, &apos;11:47&apos;, &apos;11:55&apos;, &apos;11:59&apos;], [], []] return ans[num] java 36ms, September 19, 2016 https://discuss.leetcode.com/topic/59374/simple-python-java 12345678910public class Solution &#123; public List&lt;String&gt; readBinaryWatch(int num) &#123; List&lt;String&gt; times = new ArrayList&lt;&gt;(); for(int h=0; h&lt;12; h++) for(int m = 0; m&lt;60; m++) if(Integer.bitCount(h*64 +m)==num) times.add(String.format(&quot;%d:%02d&quot;, h, m)); return times; &#125;&#125; https://discuss.leetcode.com/topic/59494/3ms-java-solution-using-backtracking-and-idea-of-permutation-and-combination 3ms Java Solution Using Backtracking and Idea of “Permutation and Combination” 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public List&lt;String&gt; readBinaryWatch(int num) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); int[] nums1 = new int[]&#123;8, 4, 2, 1&#125;, nums2 = new int[]&#123;32, 16, 8, 4, 2, 1&#125;; for(int i = 0; i &lt;= num; i++) &#123; List&lt;Integer&gt; list1 = generateDigit(nums1, i); List&lt;Integer&gt; list2 = generateDigit(nums2, num - i); for(int num1: list1) &#123; if(num1 &gt;= 12) continue; for(int num2: list2) &#123; if(num2 &gt;= 60) continue; res.add(num1 + &quot;:&quot; + (num2 &lt; 10 ? &quot;0&quot; + num2 : num2)); &#125; &#125; &#125; return res; &#125; private List&lt;Integer&gt; generateDigit(int[] nums, int count) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); generateDigitHelper(nums, count, 0, 0, res); return res; &#125; private void generateDigitHelper(int[] nums, int count, int pos, int sum, List&lt;Integer&gt; res) &#123; if(count == 0) &#123; res.add(sum); return; &#125; for(int i = pos; i &lt; nums.length; i++) &#123; generateDigitHelper(nums, count - 1, i + 1, sum + nums[i], res); &#125; &#125;&#125; https://discuss.leetcode.com/topic/59611/straightforward-java-answer straightforward java answer 1234567891011public List&lt;String&gt; readBinaryWatch(int num) &#123; ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 12; i++) &#123; for (int j = 0; j &lt; 60; j++) &#123; if (Integer.bitCount(i) + Integer.bitCount(j) == num) &#123; result.add(String.format(&quot;%d:%02d&quot;, i, j)); &#125; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>backtracking</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[400. Nth Digit]]></title>
    <url>%2Fp%2F2f0b7067%2F</url>
    <content type="text"><![CDATA[30.1% https://leetcode.com/problems/nth-digit/description/ Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … Note: n is positive and will fit within the range of a 32-bit signed integer (n &lt; 231). 1234567891011121314151617Example 1:Input:3Output:3Example 2:Input:11Output:0Explanation:The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10. 方法一： 找出数字开始的那个数字，如1， 10 ， 100等 找到确切的数字 找到第n个数字，并返回 我的代码实现： 1234567891011121314151617181920class Solution &#123;public: int findNthDigit(int n) &#123; int len = 1; int start = 1; // 如果是int就会答案错误， // 所以涉及数字较大，一定要用long，long long long cnt = 9; while(n&gt;len*cnt)&#123; n -= len*cnt; len++; cnt *= 10; start *= 10; &#125; start += (n-1)/len; string num = to_string(start); return num[(n-1)%len] - '0'; &#125;&#125;; 5ms, September 19, 2016 https://discuss.leetcode.com/topic/59314/java-solution 123456789101112131415161718public class Solution &#123; public int findNthDigit(int n) &#123; int len = 1; long count = 9; int start = 1; while(n &gt; len*count)&#123; n -= len*count; len += 1; count *= 10; start *= 10; &#125; start += (n-1) / len; String s = Integer.toString(start); return Character.getNumericValue(s.charAt((n-1)%len)); &#125;&#125; 方法二： 简单直接的方法，但是超时 我的代码实现： 123456789101112class Solution &#123;public: int findNthDigit(int n) &#123; string s; int i = 1; while(n&gt;s.size())&#123; s.append(to_string(i)); ++i; &#125; return s[n-1]-'0'; &#125;&#125;; 学习区： https://discuss.leetcode.com/topic/59322/sharing-my-thinking-process Sharing my thinking process Idea: The first idea is: the result will only be within 0~ 9, can we find a cycle? For input 1 to 20, the result is: 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, 1, 5 No cycle found. While we can find that digits matter! The result sequence should be like: 1~ 9: 1 * 9=9 in total 10~ 99: 2 * 90=180 in total 100~ 999: 3* 900=2700 in total Then, 49000, 590000, k910^k For input 12345, we have 9+180+2700&lt;12345&lt;9+180+2700+36000, so the corresponding number is 1000+. 12345-9-180-2700=9456-1=9455 9455/4 = 2363+1000=3363, 9455%4=3, so the result should be 3. For 12346: 3, for 12347: 3, for 12348: 6, for 12349: 4 336(12345 start from the next 3)3 (12346)3(12347)3(12348)6(12349)4]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[399. Evaluate Division]]></title>
    <url>%2Fp%2F205d1d21%2F</url>
    <content type="text"><![CDATA[41.2% https://leetcode.com/problems/evaluate-division/description/ Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0. 1234567891011121314Example:Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . return [6.0, 0.5, -1.0, 1.0, -1.0 ].The input is: vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values,vector&lt;pair&lt;string, string&gt;&gt; queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector&lt;double&gt;.According to the example above:equations = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],values = [2.0, 3.0],queries = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ]. The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction. 方法一： https://discuss.leetcode.com/topic/58577/0ms-c-union-find-solution-easy-to-understand 0ms C++ Union-Find Solution [EASY to UNDERSTAND] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; // date: 2016-09-12 location: Santa Clara City Librarypublic: vector&lt;double&gt; calcEquation(vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries) &#123; unordered_map&lt;string, Node*&gt; map; vector&lt;double&gt; res; for (int i = 0; i &lt; equations.size(); i ++) &#123; string s1 = equations[i].first, s2 = equations[i].second; if (map.count(s1) == 0 &amp;&amp; map.count(s2) == 0) &#123; map[s1] = new Node(); map[s2] = new Node(); map[s1] -&gt; value = values[i]; map[s2] -&gt; value = 1; map[s1] -&gt; parent = map[s2]; &#125; else if (map.count(s1) == 0) &#123; map[s1] = new Node(); map[s1] -&gt; value = map[s2] -&gt; value * values[i]; map[s1] -&gt; parent = map[s2]; &#125; else if (map.count(s2) == 0) &#123; map[s2] = new Node(); map[s2] -&gt; value = map[s1] -&gt; value / values[i]; map[s2] -&gt; parent = map[s1]; &#125; else &#123; unionNodes(map[s1], map[s2], values[i], map); &#125; &#125; for (auto query : queries) &#123; if (map.count(query.first) == 0 || map.count(query.second) == 0 || findParent(map[query.first]) != findParent(map[query.second])) res.push_back(-1); else res.push_back(map[query.first] -&gt; value / map[query.second] -&gt; value); &#125; return res; &#125; private: struct Node &#123; Node* parent; double value = 0.0; Node() &#123;parent = this;&#125; &#125;; void unionNodes(Node* node1, Node* node2, double num, unordered_map&lt;string, Node*&gt;&amp; map) &#123; Node* parent1 = findParent(node1), *parent2 = findParent(node2); double ratio = node2 -&gt; value * num / node1 -&gt; value; for (auto it = map.begin(); it != map.end(); it ++) if (findParent(it -&gt; second) == parent1) it -&gt; second -&gt; value *= ratio; parent1 -&gt; parent = parent2; &#125; Node* findParent(Node* node) &#123; if (node -&gt; parent == node) return node; node -&gt; parent = findParent(node -&gt; parent); return node -&gt; parent; &#125;&#125;; Update: Please also check Java solutions below. Special thanks to @iambright and @Scarlett_comeup. 方法二： https://discuss.leetcode.com/topic/58312/c-0ms-hash-dfs-solution c++ 0ms Hash+DFS solution 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;double&gt; calcEquation(vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; query) &#123; unordered_map&lt;string,unordered_map&lt;string, double&gt;&gt; m; vector&lt;double&gt; res; for (int i = 0; i &lt; values.size(); ++i) &#123; m[equations[i].first].insert(make_pair(equations[i].second,values[i])); if(values[i]!=0) m[equations[i].second].insert(make_pair(equations[i].first,1/values[i])); &#125; for (auto i : query) &#123; unordered_set&lt;string&gt; s; double tmp = check(i.first,i.second,m,s); if(tmp) res.push_back(tmp); else res.push_back(-1); &#125; return res; &#125; double check(string up, string down, unordered_map&lt;string,unordered_map&lt;string, double&gt;&gt; &amp;m, unordered_set&lt;string&gt; &amp;s) &#123; if(m[up].find(down) != m[up].end()) return m[up][down]; for (auto i : m[up]) &#123; if(s.find(i.first) == s.end()) &#123; s.insert(i.first); double tmp = check(i.first,down,m,s); if(tmp) return i.second*tmp; &#125; &#125; return 0; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[398. Random Pick Index]]></title>
    <url>%2Fp%2F6a82f8a8%2F</url>
    <content type="text"><![CDATA[43.4% https://leetcode.com/problems/random-pick-index/description/ Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Note: The array size can be very large. Solution that uses too much extra space will not pass the judge. 12345678910Example:int[] nums = new int[] &#123;1,2,3,3,3&#125;;Solution solution = new Solution(nums);// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.solution.pick(3);// pick(1) should return 0. Since in the array only nums[0] is equal to 1.solution.pick(1); 方法一： rand函数的用法 如果等概率的去选择一个数字 我的代码实现： Oct 21， 2017 123456789101112131415161718192021222324252627282930class Solution &#123; vector&lt;int&gt; _nums;public: Solution(vector&lt;int&gt; nums) &#123; _nums = nums; &#125; int pick(int target) &#123; int index=0, n=0; for(int i=0; i&lt;_nums.size(); i++)&#123; if(_nums[i]==target)&#123; if(n==0)&#123; n = 1; index = i; &#125;else&#123; ++n; if(rand()%n==0) index = i; &#125; &#125; &#125; return index; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(nums); * int param_1 = obj.pick(target); */ 我的代码实现： 12345678910111213141516171819202122232425262728293031class Solution &#123; vector&lt;int&gt; _nums;public: Solution(vector&lt;int&gt; nums) &#123; _nums = nums; &#125; int pick(int target) &#123; int n = 0, ans = -1; for(int i=0; i&lt;_nums.size(); i++)&#123; if(_nums[i]!=target) continue; if(n==0)&#123; ans = i; ++n; &#125; else&#123; ++n; if(rand()%n==0) ans = i; &#125; &#125; return ans; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(nums); * int param_1 = obj.pick(target); */ C++_Time: O(n), Space: O(n)_116ms_96.41%_with clear explanation by probability Actually, we could first consider following question: You have a file consisting of characters. The characters in the file can be read sequentially, but the length of the file is unknown. How do you pick a character so that every character in the file has equal probability of being chosen? For this problem we can take algorithm like this: Draw the 1st char. If there is a second char, then we will hold 1st char by prob = 1/2, and replace the 1st char to 2nd char with prob = 1/2. After this step we suppose that the char is X now. After then, if there is 3rd char, then we will hold the X with prob = 2/3 and replace X to 3rd char with prob = 1/3. Why do they hold the same prob to be picked? Because: Obviously, Prob(the 3rd char is picked) = 1/3; Prob(the 2nd char is picked) = 1 1/2 2/3 = 1/3; Prob(the 1st char is picked) = 1 1/2 2/3 = 1/3; So we can say that when we now has n chars and there is still another char in the file, we can pick the other char with prob= 1/(n+1), also keep original char with prob = n/(n+1), then we can secure each char is picked with same prob = 1/(n+1), because prob = 1 1/2 2/3 ···· n/(n+1) = 1/(n+1). Now, go back to this problem. The thought is the same, when we meet some nums[i] == target, we can use above conclusion: we can pick the other char with prob= 1/(n+1), also keep original char with prob = n/(n+1), then we can secure each char is picked with same prob = 1/(n+1). Code: 1234567891011121314151617181920class Solution &#123;vector&lt;int&gt; _nums;public:Solution(vector&lt;int&gt; nums) &#123; _nums = nums;&#125;int pick(int target) &#123; int n = 0, ans = -1; for(int i = 0 ; i &lt; _nums.size(); i++)&#123; if(_nums[i] != target) continue; if(n == 0)&#123;ans = i; n++;&#125; else&#123; n++; if(rand() % n == 0)&#123;ans = i;&#125;// with prob 1/(n+1) to replace the previous index &#125; &#125; return ans;&#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>reservoir sampling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[397. Integer Replacement]]></title>
    <url>%2Fp%2F6b6a3f32%2F</url>
    <content type="text"><![CDATA[29.5% https://leetcode.com/problems/integer-replacement/?tab=Description Given a positive integer n and you can do operations as follow: If n is even, replace n with n/2. If n is odd, you can replace n with either n + 1 or n - 1.What is the minimum number of replacements needed for n to become 1? 12345678910Example 1:Input:8Output:3Explanation:8 -&gt; 4 -&gt; 2 -&gt; 1 123456789101112Example 2:Input:7Output:4Explanation:7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1or7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1 方法一: 我的代码实现： Oct 21， 2017 123456789101112131415161718192021class Solution &#123;public: int integerReplacement(int n) &#123; int res = 0; long long m = n; while(m!=1)&#123; if(m==3)&#123; res += 2; break; &#125; if((m&amp;1)==0) m &gt;&gt;= 1; else if((m%4)==1) m -= 1; else m += 1; res++; &#125; return res; &#125;&#125;; 当n%4 == 3时，n转化为n+1更快 n%4 == 1时，转化为n-1更快 n%4 == 2 或 0，n /= 2; 要考虑到n=3的特殊情况，n为最大int的情况，所以用long long 我的代码实现： 12345678910111213141516171819202122232425262728class Solution &#123;public: int integerReplacement(int n) &#123; // 一定用long long，否则遇见INT_MAX时，+1会出错 long long m = n; int cnt = 0; while(m!=1)&#123; // m==3是特殊情况，特殊考虑 if(m==3)&#123; cnt += 2; break; &#125; // 千万注意，位运算优先级低于关系运算符 // == = != &gt; &amp; &gt; ^ &gt; | if((m&amp;1)==0)&#123; m = m&gt;&gt;1; ++cnt; &#125;else&#123; if(m%4==3) m += 1; else m -= 1; ++cnt; &#125; &#125; return cnt; &#125;&#125;; 我的代码实现二： Oct 16, 2017 微策略面试题，可惜没能给出最优解。 其实逻辑很简单，本来是除以二 我们除以4，4种情况分别讨论，非常easy 123456789101112131415161718192021class Solution &#123;public: int integerReplacement(int n) &#123; long long m = n; int res = 0; while(m!=1)&#123; if(m==3)&#123; res += 2; break; &#125; if((m&amp;1)==0) m &gt;&gt;= 1; else if(m%4==1) m -= 1; else m += 1; res += 1; &#125; return res; &#125;&#125;; 0 ms C++ recursion solution with Explanation All you need is determine replace n with n + 1 or n - 1, when n is odd. since, if n is even, you get no choice, just replace it with n / 2. if n is odd, you can either add 1 or reduce 1. If n + 1 % 4 == 0, replace n with n + 1 will short the path. Otherwise, replace n with n - 1 is always the right direction. 12345678910111213Examle:Input:31- 1. Replace 31 with 32:31 -&gt; 32 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1- 2. Replace 31 with 30:31 -&gt; 30 -&gt; 15 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1Output:6 Code: 1234567891011121314151617181920212223242526272829303132class Solution &#123; // date: 2016-09-11 location: Vista Del Lago III Apartments int res = 0;public: int integerReplacement(int n) &#123; if (n == 1) return res; if (n == 3) &#123; res += 2; return res; &#125; if (n == INT_MAX) return 32; if (n &amp; 1) // odd &#123; res ++; if ((n + 1) % 4 == 0) integerReplacement(n + 1); else integerReplacement(n - 1); &#125; else // even &#123; res ++; integerReplacement(n / 2); &#125; return res; &#125;&#125;; make it shorter: 1234567891011121314151617181920212223242526272829class Solution &#123; // date: 2016-09-11 location: Vista Del Lago III Apartments int res = 0;public: int integerReplacement(int n) &#123; if (n == 1) return res; if (n == 3) &#123; res += 2; return res; &#125; if (n == INT_MAX) return 32; res ++; if (n &amp; 1) if ((n + 1) % 4 == 0) integerReplacement(n + 1); else integerReplacement(n - 1); else integerReplacement(n / 2); return res; &#125;&#125;; 方法二: https://discuss.leetcode.com/topic/59350/python-o-log-n-time-o-1-space-with-explanation-and-proof Python O(log n) time, O(1) space with explanation and proof Denote f(n) the minimum number of jumps from n to 1. By definition, we have the recurrence f(1) = 0, f(2n) = 1 + f(n), f(2n + 1) = min(f(2n) + 1, f(2n + 2) + 1). First notice that this sequence is well defined because f(2n + 2) = f(n + 1) + 1, so f(2n + 1) = min(f(2n) + 1, f(n + 1) + 2). Every element is defined by some element before it. We want to show (* ): If n % 4 = 3 and n != 3, then f(n) = f(n + 1) + 1. If n % 4 = 1 or n = 3, then f(n) = f(n - 1) + 1. This gives us an O(log n) time, O(1) space solution. 123456789101112class Solution(object): def integerReplacement(self, n): rtn = 0 while n &gt; 1: rtn += 1 if n % 2 == 0: n //= 2 elif n % 4 == 1 or n == 3: n -= 1 else: n += 1 return rtn In this code, n will drop to at most n / 2 in at most 2 iterations, so the number of iterations is at most 2 log(n). In each iteration, the time complexity is constant. So the overall time complexity is O(log n). The space complexity is obviously 1. Correctness is guaranteed by ( ). Lemma 1. f(k+1) &lt;= f(k) + 1 Prove by induction: f(2) = 1 &lt;= 0 + 1 = f(1) + 1 Assume this hold for any 1 &lt;= k’ &lt; k, If k is even, f(k + 1) = min(f(k) + 1, f(k + 2) + 1) &lt;= f(k) + 1; If k is odd, denote k = 2l + 1 (l &gt;= 1), then f(k + 1) = f(2l + 2) = 1 + f(l + 1) &lt;= 1 + 1 + f(l) = 1 + f(2l) = 1 + f(k - 1). Also, f(k + 1) = 1 + f(l + 1) = f(2l + 2) = f(k + 1) &lt;= f(k + 1) + 1. Hence, f(k + 1) &lt;= min(f(k - 1) + 1, f(k + 1) + 1) = f(k) &lt;= f(k) + 1. Lemma 2. f(k) &lt;= 1 + f(k + 1), k &gt;= 1 Prove by induction: f(1) = 0 &lt;= 1 + f(2) Assume this hold for any 1 &lt;= k’ &lt; k, If k is odd, f(k) = min(1 + f(k - 1), 1 + f(k + 1)) &lt;= 1 + f(k + 1) If k is even, denote k = 2l (l &gt;= 1), then f(k) = f(2l) = 1 + f(l) 1 + f(l) &lt;= 3 + f(l) = 2 + f(2l) = 1 + (1 + f(2l)) 1 + f(l) &lt;= 1 + 1 + f(l + 1) &lt;= 3 + f(l + 1) = 2 + f(2l + 2) = 1 + (1 + f(2l + 2)) =&gt; f(k) = 1 + f(l) &lt;= 1 + min(1 + f(2l), 1 + f(2l + 2)) = 1 + f(2l + 1) = 1 + f(k + 1). Proof of (* ): If n % 4 = 3 and n != 3, denote n = 4k + 3 where k &gt;= 1. f(n - 1) = f(4k + 2) = 1 + f(2k + 1) = 1 + min(f(2k) + 1, f(2k + 2) + 1) = min(f(2k) + 2, f(2k + 2) + 2) f(2k) + 2 = f(k) + 3 &gt;= f(k + 1) + 2 = 1 + f(2k + 2) and f(2k + 2) + 2 &gt; f(2k + 2) + 1, so f(n - 1) &gt;= 1 + f(2k + 2) = f(4k + 4) = f(n + 1) =&gt; f(n) = min(f(n - 1) + 1, f(n + 1) + 1) = f(n + 1) + 1. If n = 3, it’s obvious that f(3) = min(f(2) + 1, f(2) + 2) = f(2) + 1. If n % 4 = 1 and n &gt; 1, denote n = 4k + 1 where k &gt;= 1. f(n - 1) = f(4k) = 1 + f(2k) 1 + f(2k) &lt; 2 + f(2k) 1 + f(2k) = 2 + f(k) &lt;= 3 + f(k + 1) = 2 + f(2k + 2) =&gt; f(n - 1) = 1 + f(2k) &lt;= min(2 + f(2k), 2 + f(2k + 2)) = 1 + min(f(2k) + 1, f(2k + 2) + 1) = 1 + f(2k + 1) = f(4k + 2) = f(n + 1) =&gt; f(n) = min(f(n - 1) + 1, f(n + 1) + 1) = f(n - 1) + 1. https://discuss.leetcode.com/topic/58313/3-lines-python-recursive-ac-solution 3 Lines Python Recursive AC Solution 12345class Solution(object): def integerReplacement(self, n, counter=0): if n == 1: return counter if not n%2: return self.integerReplacement(n/2, counter+1) else: return min(self.integerReplacement(n+1, counter+1), self.integerReplacement(n-1, counter+1)) https://discuss.leetcode.com/topic/58313/3-lines-python-recursive-ac-solution/2 Concise code! One slight improvement – you actually do not need to add a variable counter. Moreover, memoization could save a lot of runtime: 300ms –&gt; 30ms. Please see here: https://discuss.leetcode.com/topic/58402/python-top-down-approach-memoization-saves-hundreds-of-ms-345ms-36ms 123456789101112class Solution(object): def integerReplacement(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n == 1: return 0 if n % 2: return 1 + min(self.integerReplacement(n+1), self.integerReplacement(n-1)) else: return 1 + self.integerReplacement(n/2) https://discuss.leetcode.com/topic/58334/a-couple-of-java-solutions-with-explanations A couple of Java solutions with explanations I really think it should be tagged medium because there are many subtleties and good understanding of binary arithmetic is required. The first step towards solution is to realize that you’re allowed to remove the LSB only if it’s zero. And to reach the target as fast as possible, removing digits is the best way to go. Hence, even numbers are better than odd. This is quite obvious. What is not so obvious is what to do with odd numbers. One may think that you just need to remove as many 1’s as possible to increase the evenness of the number. Wrong! Look at this example: 1111011 -&gt; 111010 -&gt; 11101 -&gt; 11100 -&gt; 1110 -&gt; 111 -&gt; 1000 -&gt; 100 -&gt; 10 -&gt; 1 And yet, this is not the best way because 1111011 -&gt; 111100 -&gt; 11110 -&gt; 1111 -&gt; 10000 -&gt; 1000 -&gt; 100 -&gt; 10 -&gt; 1 See? Both 111011 -&gt; 111010 and 111011 -&gt; 111100 remove the same number of 1’s, but the second way is better. So, we just need to remove as many 1’s as possible, doing +1 in case of a tie? Not quite. The infamous test with n=3 fails for that strategy because 11 -&gt; 10 -&gt; 1 is better than 11 -&gt; 100 -&gt; 10 -&gt; 1. Fortunately, that’s the only exception (or at least I can’t think of any other, and there are none in the tests). So the logic is: If n is even, halve it. If n=3 or n-1 has less 1’s than n+1, decrement n. Otherwise, increment n. Here is an example of such a solution in Java: 1234567891011121314public int integerReplacement(int n) &#123; int c = 0; while (n != 1) &#123; if ((n &amp; 1) == 0) &#123; n &gt;&gt;&gt;= 1; &#125; else if (n == 3 || Integer.bitCount(n + 1) &gt; Integer.bitCount(n - 1)) &#123; --n; &#125; else &#123; ++n; &#125; ++c; &#125; return c;&#125; Of course, doing bitCount on every iteration is not the best way. It is enough to examine the last two digits to figure out whether incrementing or decrementing will give more 1’s. Indeed, if a number ends with 01, then certainly decrementing is the way to go. Otherwise, if it ends with 11, then certainly incrementing is at least as good as decrementing ( 011 -&gt; 010 / * 100) or even better (if there are three or more 1’s). This leads to the following solution: 1234567891011121314public int integerReplacement(int n) &#123; int c = 0; while (n != 1) &#123; if ((n &amp; 1) == 0) &#123; n &gt;&gt;&gt;= 1; &#125; else if (n == 3 || ((n &gt;&gt;&gt; 1) &amp; 1) == 0) &#123; --n; &#125; else &#123; ++n; &#125; ++c; &#125; return c;&#125; An alternative approach to intuitive algorithm was very well put by @dettier in a discussion: you should create as many trailing zeroes as you can. This way you can avoid the tie-breaking trap (there can be no ties), but you’ll still have to handle the n=3 exception separately. https://discuss.leetcode.com/topic/58425/java-12-line-4-5-ms-iterative-solution-with-explanations-no-other-data-structures Java 12 line 4(5)ms iterative solution with explanations. No other data structures. When n is even, the operation is fixed. The procedure is unknown when it is odd. When n is odd it can be written into the form n = 2k+1 (k is a non-negative integer.). That is, n+1 = 2k+2 and n-1 = 2k. Then, (n+1)/2 = k+1 and (n-1)/2 = k. So one of (n+1)/2 and (n-1)/2 is even, the other is odd. And the “best” case of this problem is to divide as much as possible. Because of that, always pick n+1 or n-1 based on if it can be divided by 4. The only special case of that is when n=3 you would like to pick n-1 rather than n+1. 12345678910111213public int integerReplacement(int n) &#123; if(n==Integer.MAX_VALUE) return 32; //n = 2^31-1; int count = 0; while(n&gt;1)&#123; if(n%2==0) n/=2; else&#123; if((n+1)%4==0&amp;&amp;(n-1!=2)) n++; else n--; &#125; count++; &#125; return count;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[396. Rotate Function]]></title>
    <url>%2Fp%2F2c308bfb%2F</url>
    <content type="text"><![CDATA[31.2% https://leetcode.com/problems/rotate-function/description/ Given an array of integers A and let n to be its length. Assume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a “rotation function” F on A as follow: F(k) = 0 Bk[0] + 1 Bk[1] + … + (n-1) * Bk[n-1]. Calculate the maximum value of F(0), F(1), …, F(n-1). Note: n is guaranteed to be less than 105. 12345678910Example:A = [4, 3, 2, 6]F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26. 方法一： 我的代码实现： 12345678910111213141516class Solution &#123;public: int maxRotateFunction(vector&lt;int&gt;&amp; A) &#123; int sum = accumulate(A.begin(), A.end(), 0); int res, cur=0; int n = A.size(); for(int i=0; i&lt;n; i++) cur += i*A[i]; res = cur; for(int i=n-1; i&gt;0; i--)&#123; cur = cur+sum - n*A[i]; res = max(cur, res); &#125; return res; &#125;&#125;; 方法二: 使用long long 13ms, September 12, 2016 https://discuss.leetcode.com/topic/58293/c-solution 12345678910111213141516171819202122class Solution &#123;public: int maxRotateFunction(vector&lt;int&gt;&amp; A) &#123; if(A.size()==0) return 0; long long allsum = 0; long long sum2 = 0; for(int i = 0; i &lt; A.size(); i++)&#123; allsum += A[i] * i; sum2 += A[i]; &#125; long long result = allsum; for(int i=0; i&lt;A.size(); i++)&#123; allsum -= sum2; allsum += A[i]; allsum += A[i] * int(A.size() - 1); result = max(allsum, result); &#125; return result; &#125;&#125;; python52ms, September 12, 2016 https://discuss.leetcode.com/topic/58310/6-lines-python-53ms-solution-use-f-n-to-get-f-n-1 123456789101112class Solution(object): def maxRotateFunction(self, A): &quot;&quot;&quot; :type A: List[int] :rtype: int &quot;&quot;&quot; if not A : return 0 maxres = tmp = sum([i*A[i] for i in xrange(len(A))]) tot, index = sum(A), -1 for index in xrange(-1, -len(A)-1, -1): maxres, tmp = max(maxres, tmp), tmp+tot-(len(A)*A[index]) return maxres java4ms, September 12, 2016 https://discuss.leetcode.com/topic/58302/java-solution 12345678910111213141516171819public class Solution &#123; public int maxRotateFunction(int[] A) &#123; int n = A.length; int sum = 0; int candidate = 0; for(int i = 0; i &lt; n; i++)&#123; sum += A[i]; candidate += A[i] * i; &#125; int best = candidate; for(int i=n-1; i&gt;0; i--)&#123; candidate = candidate + sum - A[i] * n; best = Math.max(best, candidate); &#125; return best; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[395. Longest Substring with At Least K Repeating Characters]]></title>
    <url>%2Fp%2F25480874%2F</url>
    <content type="text"><![CDATA[35.5% https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/description/ Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times. 123456789101112131415161718Example 1:Input:s = &quot;aaabb&quot;, k = 3Output:3The longest substring is &quot;aaa&quot;, as &apos;a&apos; is repeated 3 times.Example 2:Input:s = &quot;ababbc&quot;, k = 2Output:5The longest substring is &quot;ababb&quot;, as &apos;a&apos; is repeated 2 times and &apos;b&apos; is repeated 3 times. 方法一： 我的代码实现： 12345678910111213141516171819202122class Solution &#123;public: int longestSubstring(string s, int k) &#123; if(s.empty() || k&gt;s.size()) return 0; if(k==0) return s.size(); vector&lt;int&gt; cnts(26, 0); for(auto c:s) cnts[c-'a']++; int idx = 0; // 主要是char时，-'a'才是index // cnts[s[idx]-'a']，而不是cnts[s[idx]] while(idx&lt;s.size() &amp;&amp; cnts[s[idx]-'a']&gt;=k) idx++; if(idx==s.size()) return s.size(); int left = longestSubstring(s.substr(0, idx), k); int right = longestSubstring(s.substr(idx+1), k); return max(left, right); &#125;&#125;; 16ms, 23.77%, October 17, 2016 https://discuss.leetcode.com/topic/57735/c-recursive-solution C++ recursive solution in the first pass I record counts of every character in a hashmap in the second pass I locate the first character that appear less than k times in the string. this character is definitely not included in the result, and that separates the string into two parts. keep doing this recursively and the maximum of the left/right part is the answer. 1234567891011121314151617181920class Solution &#123;public: int longestSubstring(string s, int k) &#123; if(s.size()==0 || s.size() &lt; k) return 0; if(k == 0) return s.size(); unordered_map&lt;char, int&gt; Map; for(int i=0; i&lt;s.size(); i++) Map[s[i]]++; int idx=0; while(idx&lt;s.size() &amp;&amp; Map[s[idx]] &gt;= k) idx++; if(idx==s.size()) return s.size(); int left = longestSubstring(s.substr(0, idx), k); int right = longestSubstring(s.substr(idx+1), k); return max(left, right); &#125;&#125;; https://discuss.leetcode.com/topic/57134/two-short-c-solutions-3ms-and-6ms Two short C++ solutions (3ms and 6ms) Sol1: a simple improvement on the naive quaratic solution. The idea is that if a locally longest substr is found, there’s no need to check substrs overlapping it.Sol1 can run O(n) times in some cases, but worst case is O(n2). Anyway the C++ run time is 3ms. 123456789101112131415161718192021int longestSubstring(string s, int k) &#123; int max_len = 0; for (int first = 0; first+k &lt;= s.size();) &#123; int count[26] = &#123;0&#125;; int mask = 0; int max_last = first; for (int last = first; last &lt; s.size(); ++last) &#123; int i = s[last] - 'a'; count[i]++; if (count[i]&lt;k) mask |= (1 &lt;&lt; i); else mask &amp;= (~(1 &lt;&lt; i)); if (mask == 0) &#123; max_len = max(max_len, last-first+1); max_last = last; &#125; &#125; first = max_last + 1; &#125; return max_len;&#125; Sol2: recursive: split the string into substrs by characters of occurrence less than k. Then recursively apply the problem to each substr.Worst case of Sol2 is O(n), because there are at most 26 levels of recursions. The C++ impl. runs 6ms. I suspect this is because the current test cases does not cover enough cases in favor of this solution in run time. 123456789101112131415161718192021int longestSubstring(string s, int k) &#123; return longestSubstring_recur(s, k, 0, s.size());&#125;int longestSubstring_recur(const string&amp; s, int k, int first, int last) &#123; int count[26] = &#123;0&#125;; for (int j = first; j &lt; last; ++j) ++count[s[j] - 'a']; int max_len = 0; for (int j = first; j &lt; last;) &#123; while (j &lt; last &amp;&amp; count[s[j]-'a']&lt;k) ++j; if (j == last) break; int l = j; while (l &lt; last &amp;&amp; count[s[l]-'a']&gt;=k) ++l; //all chars appear more than k times if (j == first &amp;&amp; l == last) return last-first; max_len = max(max_len, longestSubstring_recur(s, k, j, l)); j = l; &#125; return max_len;&#125; 方法二： 比较直接，但是超时 我的代码实现： 1234567891011121314151617181920212223242526272829class Solution &#123;public: int longestSubstring(string s, int k) &#123; if(s.empty() || k&gt;s.size()) return 0; if(k==0) return s.size(); int n = s.size(); vector&lt;vector&lt;int&gt;&gt;v(n+1, vector&lt;int&gt;(26, 0)); for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;26; j++) v[i+1][j] = v[i][j]; v[i+1][s[i]-'a'] = v[i][s[i]-'a']+1; &#125; for(int len=n; len&gt;0; len--)&#123; for(int i=0; i+len&lt;=n; i++)&#123; bool flag = true; for(int j=0; j&lt;26; j++) // 计算i+len-1行与第i行之间的差距， // 应该从i+len-1的统计量减去i-1行的，而不是i行的 if(v[i+len][j]-v[i][j]&gt;=1 &amp;&amp; v[i+len][j]-v[i][j]&lt;k)&#123; flag = false; break; &#125; if(flag) return len; &#125; &#125; return 0; &#125;&#125;; python55ms, 71.53%, October 17, 2016 https://discuss.leetcode.com/topic/57092/4-lines-python 1234567891011class Solution(object): def longestSubstring(self, s, k): &quot;&quot;&quot; :type s: str :type k: int :rtype: int &quot;&quot;&quot; for c in set(s): if s.count(c) &lt; k: return max(self.longestSubstring(t, k) for t in s.split(c)) return len(s) 49ms, 80.41%, October 17, 2016 https://discuss.leetcode.com/topic/57092/4-lines-python 12345678910111213class Solution(object): def longestSubstring(self, s, k): &quot;&quot;&quot; :type s: str :type k: int :rtype: int &quot;&quot;&quot; if len(s) &lt; k: return 0 c = min(set(s), key=s.count) if s.count(c) &gt;= k: return len(s) return max(self.longestSubstring(t, k) for t in s.split(c)) java4ms, 73.89%, October 17, 2016 https://discuss.leetcode.com/topic/57372/java-3ms-divide-and-conquer-recursion-solution 123456789101112131415161718192021222324252627282930public class Solution &#123; public int longestSubstring(String s, int k) &#123; char[] str = s.toCharArray(); return helper(str, 0, s.length(), k); &#125; private int helper(char[] str, int start, int end, int k)&#123; if(end &lt; start) return 0; if(end - start &lt; k) return 0; int[] count = new int[26]; for(int i=start; i&lt;end; i++)&#123; int idx = str[i] - &apos;a&apos;; count[idx]++; &#125; for(int i=0; i&lt;26; i++)&#123; if(count[i] == 0) continue; if(count[i] &lt; k)&#123; for(int j=start; j&lt;end; j++)&#123; if(str[j] == i+&apos;a&apos;)&#123; int left = helper(str, start, j, k); int right = helper(str, j+1, end, k); return Math.max(left, right); &#125; &#125; &#125; &#125; return end - start; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[394. Decode String]]></title>
    <url>%2Fp%2F7131903c%2F</url>
    <content type="text"><![CDATA[40.8% https://leetcode.com/problems/decode-string/description/ Given an encoded string, return it’s decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4]. 12345Examples:s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;. 方法一： 我的代码实现： 1234567891011121314151617181920212223242526class Solution &#123;public: string decodeString(string s) &#123; int i = 0; return helper(s, i); &#125; string helper(string&amp; s, int&amp; i)&#123; string res; while(i&lt;s.size() &amp;&amp; s[i]!=']')&#123; if(!isdigit(s[i])) res += s[i++]; else&#123; int n = 0; while(i&lt;s.size() &amp;&amp; isdigit(s[i])) n = n*10 + s[i++] - '0'; i++; // skip '[' string t = helper(s, i); i++; // skip ']' while(n--&gt;0) res += t; &#125; &#125; return res; &#125;&#125;; 0ms, September 13, 2016 https://discuss.leetcode.com/topic/57228/0ms-simple-c-solution 12345678910111213141516171819202122232425class Solution &#123;public: string decodeString(string s, int&amp; i) &#123; string res; while(i&lt;s.length() &amp;&amp; s[i] != &apos;]&apos;)&#123; if(!isdigit(s[i])) res += s[i++]; else&#123; int n = 0; while(i &lt; s.length() &amp;&amp; isdigit(s[i])) n = n* 10 + s[i++] - &apos;0&apos;; i++; // [ string t = decodeString(s, i); i++; // ] while(n--&gt;0) res += t; &#125; &#125; return res; &#125; string decodeString(string s)&#123; int i = 0; return decodeString(s, i); &#125;&#125;; https://discuss.leetcode.com/topic/57899/clean-c-recursive-solution-with-explanation Clean C++ Recursive Solution with Explanation Every time we meet a ‘[‘, we treat it as a subproblem so call our recursive function to get the content in that ‘[‘ and ‘]’. After that, repeat that content for ‘num’ times.Every time we meet a ‘]’, we know a subproblem finished and just return the ‘word’ we got in this subproblem.Please notice that the ‘pos’ is passed by reference, use it to record the position of the original string we are looking at. 1234567891011121314151617181920212223242526class Solution &#123;public: string decodeString(string s) &#123; int pos = 0; return helper(pos, s); &#125; string helper(int&amp; pos, string s) &#123; int num=0; string word = ""; for(;pos&lt;s.size(); pos++) &#123; char cur = s[pos]; if(cur == '[') &#123; string curStr = helper(++pos, s); for(;num&gt;0;num--) word += curStr; &#125; else if (cur &gt;= '0' &amp;&amp; cur &lt;='9') &#123; num = num*10 + cur - '0'; &#125; else if (cur == ']') &#123; return word; &#125; else &#123; // Normal characters word += cur; &#125; &#125; return word; &#125;&#125;; 方法二： 主要学习栈的作用，体会其中的奥妙 我的代码实现： 1234567891011121314151617181920212223242526272829class Solution &#123;public: string decodeString(string s) &#123; string res; int num = 0, n = s.size(); stack&lt;string&gt; st1; stack&lt;int&gt; st2; for(int i=0; i&lt;n; i++)&#123; if(isdigit(s[i]))&#123; num = num*10 + s[i] - '0'; &#125;else if(isalpha(s[i]))&#123; res += s[i]; &#125;else if(s[i]=='[')&#123; st1.push(res); st2.push(num); res.clear(); num = 0; &#125;else&#123; string t=res; for(int j=0; j&lt;st2.top()-1; j++) res += t; res = st1.top() + res; st2.pop(); st1.pop(); &#125; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/63910/c-simple-and-clear-solution C++ simple and clear solution 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string decodeString(string s) &#123; stack&lt;string&gt; chars; stack&lt;int&gt; nums; string res; int num = 0; for(char c : s) &#123; if(isdigit(c)) &#123; num = num*10 + (c-'0'); &#125; else if(isalpha(c)) &#123; res.push_back(c); &#125; else if(c == '[') &#123; chars.push(res); nums.push(num); res = ""; num = 0; &#125; else if(c == ']') &#123; string tmp = res; for(int i = 0; i &lt; nums.top()-1; ++i) &#123; res += tmp; &#125; res = chars.top() + res; chars.pop(); nums.pop(); &#125; &#125; return res; &#125;&#125;; python32ms, September 13, 2016 https://discuss.leetcode.com/topic/57121/share-my-python-stack-simple-solution-easy-to-understand 123456789101112131415161718192021class Solution(object): def decodeString(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; stack = [] stack.append([&apos;&apos;, 1]) num = &apos;&apos; for ch in s: if ch.isdigit(): num += ch elif ch == &apos;[&apos;: stack.append([&apos;&apos;, int(num)]) num = &apos;&apos; elif ch == &apos;]&apos;: st, k = stack.pop() stack[-1][0] += st*k else: stack[-1][0] += ch return stack[0][0] java3ms, September 13, 2016 https://discuss.leetcode.com/topic/57159/simple-java-solution-using-stack 12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public String decodeString(String s) &#123; String res = &quot;&quot;; Stack&lt;Integer&gt; countStack = new Stack&lt;&gt;(); Stack&lt;String&gt; resStack = new Stack&lt;&gt;(); int idx = 0; while(idx&lt;s.length())&#123; if(Character.isDigit(s.charAt(idx)))&#123; int count = 0; while(Character.isDigit(s.charAt(idx)))&#123; count = 10 * count + (s.charAt(idx) - &apos;0&apos;); idx++; &#125; countStack.push(count); &#125; else if(s.charAt(idx) == &apos;[&apos;)&#123; resStack.push(res); res = &quot;&quot;; idx++; &#125; else if(s.charAt(idx) == &apos;]&apos;)&#123; StringBuilder temp = new StringBuilder (resStack.pop()); int repeatTimes = countStack.pop(); for(int i = 0; i &lt; repeatTimes; i++) temp.append(res); res = temp.toString(); idx++; &#125; else res += s.charAt(idx++); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>stack</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[393. UTF-8 Validation]]></title>
    <url>%2Fp%2Fcde6c978%2F</url>
    <content type="text"><![CDATA[34.9% https://leetcode.com/problems/utf-8-validation/?tab=Description A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules: For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one’s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10. 123456789This is how the UTF-8 encoding would work: Char. number range | UTF-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx Given an array of integers representing the data, return whether it is a valid utf-8 encoding. Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data. 123456Example 1:data = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.Return true.It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character. 12345678Example 2:data = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.Return false.The first 3 bits are all one&apos;s and the 4th bit is 0 means it is a 3-bytes character.The next byte is a continuation byte which starts with 10 and that&apos;s correct.But the second continuation byte does not start with 10, so it is invalid. 方法一： https://discuss.leetcode.com/topic/57195/concise-c-implementation Concise C++ implementation 123456789101112131415161718class Solution &#123;public: bool validUtf8(vector&lt;int&gt;&amp; data) &#123; int count = 0; for (auto c : data) &#123; if (count == 0) &#123; if ((c &gt;&gt; 5) == 0b110) count = 1; else if ((c &gt;&gt; 4) == 0b1110) count = 2; else if ((c &gt;&gt; 3) == 0b11110) count = 3; else if ((c &gt;&gt; 7)) return false; &#125; else &#123; if ((c &gt;&gt; 6) != 0b10) return false; count--; &#125; &#125; return count == 0; &#125;&#125;; 补充资料: C++ 的二进制语法与语义 转载请注明出处：http://www.cnblogs.com/Martinium/p/binary_literal.html 二进制的语法 C/C++ 默认数字使用十进制，八进制使用前缀 0， 十六进制使用前缀 0x 或 0X，二进制常数的提议被否决（引用 C 语言程序原理国际标准 的 6.4.4.1 章节字段 “A proposal to add binary constants was rejected due to lack of precedent and insufficient utility.”），一直没有二进制的表示方法，GCC 使用 0b/0B 前缀作为扩展，其实很多编译器都有这个扩展的，只是标准委员会一直没采纳。直到 C++14 才引进，可谓姗姗来迟啊。这种二进制语义 Java 7 也早些时候引入，Python 2.6 以及后来的 3 也引入，Python 为了避免十进制与八进制的混淆，一律用字母前缀，不分大小写，0b 为二进制，0o 为八进制，ox 为十六进制。Python2 升到 Python3 时果断丢弃了原来的八进制语义(也就是在 C/C++/Java 里面有 0 前缀的八进制的语义)。 表示方法 下面每行语句表达语义相同，只是选用不同的进制数表示。 1234int i = 0b101010; // binaryint i = 052; // octalint i = 42; // decimalint i = 0x2a; // hexadecimal 方法二： 根据题意，比较直白的写法 我的代码实现: 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool validUtf8(vector&lt;int&gt;&amp; data) &#123; if(data.empty()) return false; // if(data.size()==1) return !(data[0]&amp;(1&lt;&lt;7)); int i = 0, n = data.size(), cnt, flag; while(i&lt;n)&#123; flag = 1&lt;&lt;7; // (flag&amp;data[i])==0 而不是 flag &amp; data[i] == 0 // 位运算优先级低于关系运算符 if((flag &amp; data[i]) == 0)&#123; i++; &#125;else&#123; cnt = 0; while(flag&gt;2 &amp;&amp; (data[i] &amp; (flag&gt;&gt;1)))&#123; cnt++; flag = flag&gt;&gt;1; &#125; // 考虑[145] = [10010001]的情况 // 注意不能超过4长度 if(cnt==0 || cnt&gt;3) return false; for(int j=0; j&lt;cnt; j++)&#123; if(i+1&lt;n &amp;&amp; (data[i+1] &amp; (1&lt;&lt;7)) &amp;&amp; (data[i+1] &amp; (1&lt;&lt;6))==0)&#123; i++; continue; &#125; else return false; &#125; i++; &#125; &#125; return true; &#125;&#125;; https://discuss.leetcode.com/topic/58159/feeling-like-an-english-reading-comprehension-problem Feeling like an English reading comprehension problem Finally I see it is to judge a UTF-8 char sequence, while the rules described are for a single char. I feel more likely working on an English reading comprehension problem rather than algorithm.Sigh. https://discuss.leetcode.com/topic/57192/one-pass-simple-solution one pass simple solution 12345678910111213141516171819202122232425public bool ValidUtf8(int[] data) &#123; int bitCount = 0; foreach(int n in data)&#123; if(n &gt;= 192)&#123; if(bitCount != 0) return false; else if(n &gt;= 240) bitCount = 3; else if(n &gt;= 224) bitCount = 2; else bitCount = 1; &#125;else if(n &gt;= 128)&#123; bitCount--; if(bitCount &lt; 0) return false; &#125;else if(bitCount &gt; 0)&#123; return false; &#125; &#125; return bitCount == 0;&#125; https://discuss.leetcode.com/topic/58338/bit-manipulation-java-6ms Bit Manipulation, Java, 6ms 12345678910111213141516171819202122232425public boolean validUtf8(int[] data) &#123; if(data==null || data.length==0) return false; boolean isValid = true; for(int i=0;i&lt;data.length;i++) &#123; if(data[i]&gt;255) return false; // 1 after 8th digit, 100000000 int numberOfBytes = 0; if((data[i] &amp; 128) == 0) &#123; // 0xxxxxxx, 1 byte, 128(10000000) numberOfBytes = 1; &#125; else if((data[i] &amp; 224) == 192) &#123; // 110xxxxx, 2 bytes, 224(11100000), 192(11000000) numberOfBytes = 2; &#125; else if((data[i] &amp; 240) == 224) &#123; // 1110xxxx, 3 bytes, 240(11110000), 224(11100000) numberOfBytes = 3; &#125; else if((data[i] &amp; 248) == 240) &#123; // 11110xxx, 4 bytes, 248(11111000), 240(11110000) numberOfBytes = 4; &#125; else &#123; return false; &#125; for(int j=1;j&lt;numberOfBytes;j++) &#123; // check that the next n bytes start with 10xxxxxx if(i+j&gt;=data.length) return false; if((data[i+j] &amp; 192) != 128) return false; // 192(11000000), 128(10000000) &#125; i=i+numberOfBytes-1; &#125; return isValid;&#125; https://discuss.leetcode.com/topic/57178/o-n-solution-using-java O(n) solution using Java 12345678910111213141516171819202122232425public class Solution &#123; public boolean validUtf8(int[] data) &#123; int n = data.length; if (n == 0) return true; int skip = 0b10000000; int check = 0; for (int i = 0; i &lt; data.length; i++) &#123; if (check &gt; 0) &#123; if ((data[i] &amp; skip) == skip) check--; else return false; &#125; else &#123; check = getOneBitCountFromHead(data[i]); if (check &lt; 0) return false; &#125; &#125; return check == 0; &#125; private int getOneBitCountFromHead(int num) &#123; if ((num &amp; 0b11110000) == 0b11110000) return 3; if ((num &amp; 0b11100000) == 0b11100000) return 2; if ((num &amp; 0b11000000) == 0b11000000) return 1; if ((num &amp; 0b10000000) == 0b10000000) return -1; //error return 0; &#125;&#125; https://discuss.leetcode.com/topic/57964/short-n-clean-12-lines-python-solution Short’n’Clean 12-lines Python solution 12345678910111213141516171819def check(nums, start, size): for i in range(start + 1, start + size + 1): if i &gt;= len(nums) or (nums[i] &gt;&gt; 6) != 0b10: return False return Trueclass Solution(object): def validUtf8(self, nums, start=0): while start &lt; len(nums): first = nums[start] if (first &gt;&gt; 3) == 0b11110 and check(nums, start, 3): start += 4 elif (first &gt;&gt; 4) == 0b1110 and check(nums, start, 2): start += 3 elif (first &gt;&gt; 5) == 0b110 and check(nums, start, 1): start += 2 elif (first &gt;&gt; 7) == 0: start += 1 else: return False return True# 45 / 45 test cases passed.# Status: Accepted# Runtime: 89 ms https://discuss.leetcode.com/topic/57094/python-o-n-scan Python O(n) scan 123456789101112131415161718192021222324252627282930class Solution(object): def validUtf8(self, data): &quot;&quot;&quot; :type data: List[int] :rtype: bool &quot;&quot;&quot; if len(data) == 0: return True i = 0 while i &lt; len(data): if data[i] &lt; 128: i += 1 elif data[i] &gt;= 192 and data[i] &lt; 224 and len(data)-i&gt;=2: if data[i+1] &gt;= 128 and data[i+1] &lt; 192: i += 2 else: return False elif data[i] &gt;= 224 and data[i] &lt; 240 and len(data)-i&gt;=3: if data[i+1] &gt;= 128 and data[i+1] &lt; 192 and data[i+2] &gt;= 128 and data[i+2] &lt; 192: i += 3 else: return False elif data[i] &gt;= 240 and data[i] &lt; 248 and len(data)-i&gt;=4: if data[i+1] &gt;= 128 and data[i+1] &lt; 192 and data[i+2] &gt;= 128 and data[i+2] &lt; 192 and data[i+3] &gt;= 128 and data[i+3] &lt; 192: i += 4 else: return False else: return False return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>bit manipulation</tag>
        <tag>aaa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[392. Is Subsequence]]></title>
    <url>%2Fp%2Fd125e18f%2F</url>
    <content type="text"><![CDATA[44.2% https://leetcode.com/problems/is-subsequence/ Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~ = 500,000) string, and s is a short string (&lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ace” is a subsequence of “abcde” while “aec” is not). 123456789Example 1:s = &quot;abc&quot;, t = &quot;ahbgdc&quot;Return true.Example 2:s = &quot;axc&quot;, t = &quot;ahbgdc&quot;Return false. Follow up: If there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? 方法一： 常规动态规划 我的代码实现： 1234567891011121314151617class Solution &#123;public: bool isSubsequence(string s, string t) &#123; int m = s.size(), n = t.size(); if(m&gt;n) return false; if(m==0) return true; vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); for(int i=0; i&lt;=n; i++) dp[0][i] = true; for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) dp[i][j] = dp[i][j-1] || s[i-1]==t[j-1] &amp;&amp; dp[i-1][j-1]; return dp[m][n]; &#125;&#125;; 方法二： 双指针，贪心 我的代码实现： 1234567891011121314151617class Solution &#123;public: bool isSubsequence(string s, string t) &#123; int sn = s.size(), tn = t.size(); if(sn==0) return true; if(sn&gt;tn) return false; int si = 0, ti = 0; while(ti&lt;tn)&#123; if(s[si]==t[ti]) si++; ti++; if(si==sn) return true; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/57147/straight-forward-java-simple-solution/2 Just use two pointers: 1234567891011121314public class Solution &#123; public boolean isSubsequence(String s, String t) &#123; if (s.length() == 0) return true; int indexS = 0, indexT = 0; while (indexT &lt; t.length()) &#123; if (t.charAt(indexT) == s.charAt(indexS)) &#123; indexS++; if (indexS == s.length()) return true; &#125; indexT++; &#125; return false; &#125;&#125; pythonhttps://discuss.leetcode.com/topic/57100/2-lines-python Just testing whether all characters in s are also in t (in order). Based on falsetru’s code on StackOverflow which I improved a while ago, see here. http://stackoverflow.com/questions/24017363/how-to-test-if-one-string-is-a-subsequence-of-another/24017747#24017747 123def isSubsequence(self, s, t): t = iter(t) return all(c in t for c in s) https://discuss.leetcode.com/topic/57718/easy-to-understand-binary-search-solution 1234567891011121314151617181920212223242526272829from collections import defaultdictfrom bisect import bisect_leftclass Solution(object): def createMap(self, s): # create a map. key is char. value is index of apperance in acending order. posMap = defaultdict(list) for i, char in enumerate(s): posMap[char].append(i) return posMap def isSubsequence(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: bool &quot;&quot;&quot; posMap = self.createMap(t) # lowBound is the minimum index the current char has to be at. lowBound = 0 for char in s: if char not in posMap: return False charIndexList = posMap[char] # try to find an index that is larger than or equal to lowBound i = bisect_left(charIndexList, lowBound) if i == len(charIndexList): return False lowBound = charIndexList[i] + 1 return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
        <tag>dynamic programming</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[390. Elimination Game]]></title>
    <url>%2Fp%2F440d2f55%2F</url>
    <content type="text"><![CDATA[39.4% https://leetcode.com/problems/elimination-game/?tab=Description There is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list. Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers. We keep repeating the steps again, alternating left to right and right to left, until a single number remains. Find the last number that remains starting with a list of length n. 1234567891011Example:Input:n = 9,1 2 3 4 5 6 7 8 92 4 6 82 66Output:6 java https://discuss.leetcode.com/topic/59293/java-easiest-solution-o-logn-with-explanation JAVA: Easiest solution O(logN) with explanation 123456789101112131415public int lastRemaining(int n) &#123; boolean left = true; int remaining = n; int step = 1; int head = 1; while (remaining &gt; 1) &#123; if (left || remaining % 2 ==1) &#123; head = head + step; &#125; remaining = remaining / 2; step = step * 2; left = !left; &#125; return head;&#125; My idea is to update and record head in each turn. when the total number becomes 1, head is the only number left. When will head be updated? if we move from left if we move from right and the total remaining number % 2 == 1. like 2 4 6 8 10, we move from 10, we will take out 10, 6 and 2, head is deleted and move to 4. like 2 4 6 8 10 12, we move from 12, we will take out 12, 8, 4, head is still remaining 2 then we find a rule to update our head. example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Let us start with head = 1, left = true, step = 1 (times 2 each turn), remaining = n(24) we first move from left, we definitely need to move head to next position. (head = head + step) So after first loop we will have: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 - &gt; 2 4 6 8 10 12 14 16 18 20 22 24 head = 2, left = false, step = 1 * 2 = 2, remaining = remaining / 2 = 12 second loop, we move from right, in what situation we need to move head? only if the remaining % 2 == 1, in this case we have 12 % 2 == 0, we don’t touch head. so after this second loop we will have: 2 4 6 8 10 12 14 16 18 20 22 24 - &gt; 2 6 10 14 18 22 head = 2, left = true, step = 2 * 2 = 4, remaining = remaining / 2 = 6 third loop, we move from left, move head to next position after third loop we will have: 2 6 10 14 18 22 - &gt; 6 14 22 head = 6, left = false, step = 4 * 2 = 8, remaining = remaining / 2 = 3 fourth loop, we move from right, NOTICE HERE: we have remaining(3) % 2 == 1, so we know we need to move head to next position after this loop, we will have 6 14 22 - &gt; 14 head = 14, left = true, step = 8 * 2 = 16, remaining = remaining / 2 = 1 while loop end, return head https://discuss.leetcode.com/topic/61875/one-line-java-solution-based-on-josephus-problem one line java solution based on Josephus Problem This problem is similar to Josephus problem when k=2, the recursive version is easy after referring to the josephus problem on wiki.it is highly recommend to refer to Josephus problem first, because i am chinese, my english is poor, my explanation may not be good, but the wiki explanation is very good. 123public int lastRemaining(int n) &#123; return ((Integer.highestOneBit(n) - 1) &amp; (n | 0x55555555)) + 1;&#125; 1234567891011121314recursive versionfor example:1,2,3,4,...nif you start from the left to right, the result is ithen, if you start from right to left, the result is n+1-ifor n numbers, after one pass, there are n/2 left, each number is two times of the original,1,2,3,4,5,6,7,8,9after one pass2,4,6,8assume the result of 1,2,3,4 from left to right is f(4)then the result of 1,2,3,4 from right to left is 5-f(4)then the result of 2,4,6,8 from right to left is 2*(5-f(4))this is the formulaf(n)=2(1+n/2-f(n/2))* when n is 1, of course the result is 1 123public int lastRemaining(int n) &#123; return n == 1 ? 1 : 2 * (1 + n / 2 - lastRemaining(n / 2));&#125; non-recursive version: 123456789101112public int lastRemaining(int n) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (n &gt; 1) &#123; n /= 2; stack.push(n); &#125; int result = 1; while (!stack.isEmpty()) &#123; result = 2 * (1 + stack.pop() - result); &#125; return result;&#125; c https://discuss.leetcode.com/topic/58042/c-1-line-solution-with-explanation C 1 line solution with explanation After first elimination, all the rest numbers are even numbers.Divide by 2, we get a continuous new sequence from 1 to n / 2.For this sequence we start from right to left as the first elimination.Then the original result should be two times the mirroring result of lastRemaining(n / 2). 123int lastRemaining(int n) &#123; return n == 1 ? 1 : 2 * (1 + n / 2 - lastRemaining(n / 2));&#125; Great answer. In fact, we can prove that “ML(1…n) + MR(1…n) = 1 + n” holds for any n &gt;= 2, where ML(1…n) means removing elements from left to right first and MR(1…n) means removing elements from right to left first.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[389. Find the Difference]]></title>
    <url>%2Fp%2Fde632f96%2F</url>
    <content type="text"><![CDATA[51.3% https://leetcode.com/problems/find-the-difference/ Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t. 123456789101112&gt; Example:&gt; &gt; Input:&gt; s = &quot;abcd&quot;&gt; t = &quot;abcde&quot;&gt; &gt; Output:&gt; e&gt; &gt; Explanation:&gt; &apos;e&apos; is the letter that was added.&gt; javahttps://discuss.leetcode.com/topic/55912/java-solution-using-bit-manipulation12345678910public char findTheDifference(String s, String t) &#123; char c = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; c ^= s.charAt(i); &#125; for (int i = 0; i &lt; t.length(); ++i) &#123; c ^= t.charAt(i); &#125; return c;&#125; maybe a more elegant version:123456789public char findTheDifference(String s, String t) &#123; int n = t.length(); char c = t.charAt(n - 1); for (int i = 0; i &lt; n - 1; ++i) &#123; c ^= s.charAt(i); c ^= t.charAt(i); &#125; return c;&#125; https://discuss.leetcode.com/topic/56050/simple-java-8ms-solution-4-lines 123456789101112public class Solution &#123; public char findTheDifference(String s, String t) &#123; // Initialize variables to store sum of ASCII codes for // each string int charCodeS = 0, charCodeT = 0; // Iterate through both strings and char codes for (int i = 0; i &lt; s.length(); ++i) charCodeS += (int)s.charAt(i); for (int i = 0; i &lt; t.length(); ++i) charCodeT += (int)t.charAt(i); // Return the difference between 2 strings as char return (char)(charCodeT - charCodeS); &#125;&#125; cpphttps://discuss.leetcode.com/topic/55940/concise-c-solution-using-xor It is the same idea with 136. Single Number (https://leetcode.com/problems/single-number/) 123456789class Solution &#123;public: char findTheDifference(string s, string t) &#123; char r=0; for(char c:s) r ^=c; for(char c:t) r ^=c; return r; &#125;&#125;; my code1234567891011class Solution &#123;public: char findTheDifference(string s, string t) &#123; int res = 0; for(auto num:s) res ^= int(num); for(auto num:t) res ^= int(num); return char(res); &#125;&#125;; pythonhttps://discuss.leetcode.com/topic/55918/1-liners-and-2-liner-in-python Using XOR: 123class Solution(object): def findTheDifference(self, s, t): return chr(reduce(operator.xor, map(ord, s + t))) Using collections.Counter(): 123class Solution(object): def findTheDifference(self, s, t): return list((collections.Counter(t) - collections.Counter(s)))[0] A 2-liner here using sorted(): 1234class Solution(object): def findTheDifference(self, s, t): s, t = sorted(s), sorted(t) return t[-1] if s == t[:-1] else [x[1] for x in zip(s, t) if x[0] != x[1]][0] A few one-liners using sorted():1234return next((c for c, d in zip(sorted(t), sorted(s)) if c != d), max(t))return next(c for c, d in zip(sorted(t), sorted(s) + [None]) if c != d)return next(c for c, d in map(None, sorted(t), sorted(s)) if c != d)return filter(None, map(lambda c, d: c != d and c, sorted(t), sorted(s)))[0]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[387. First Unique Character in a String]]></title>
    <url>%2Fp%2Fb0afbaa8%2F</url>
    <content type="text"><![CDATA[46.1% https://leetcode.com/problems/first-unique-character-in-a-string/ Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. 12345678&gt; Examples:&gt; &gt; s = &quot;leetcode&quot;&gt; return 0.&gt; &gt; s = &quot;loveleetcode&quot;,&gt; return 2.&gt; Note: You may assume the string contain only lowercase letters. java29ms, August 28th, 2016 https://discuss.leetcode.com/topic/55148/java-7-lines-solution-29ms 1234567891011public class Solution &#123; public int firstUniqChar(String s) &#123; int freq[] = new int[26]; for(int i = 0; i &lt; s.length(); i++) freq[s.charAt(i) - &apos;a&apos;]++; for(int i = 0; i &lt; s.length(); i++) if(freq[s.charAt(i) - &apos;a&apos;] == 1) return i; return -1; &#125;&#125; cpp55ms, August 28th, 2016 https://discuss.leetcode.com/topic/55132/c-56ms-5-lines 12345678910class Solution &#123;public: int firstUniqChar(string s) &#123; int alphabet[26] = &#123;0&#125;; for (int i = 0; i &lt; s.size(); ++i)&#123;++alphabet[s[i] -&apos;a&apos;];&#125; int i = 0; while (i &lt; s.size() &amp;&amp; alphabet[s[i]-&apos;a&apos;] &gt; 1) ++i; return i == s.size() ? -1 : i; &#125;&#125;; pythonsolution 1: 240ms, August 28th, 2016 https://discuss.leetcode.com/topic/55099/python-very-easy-solution 12345678910class Solution(object): def firstUniqChar(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; for x in s: if s.find(x) == s.rfind(x): return s.find(x) return -1]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[385. Mini Parser]]></title>
    <url>%2Fp%2F74d3a5f8%2F</url>
    <content type="text"><![CDATA[30.6% https://leetcode.com/problems/mini-parser/ Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list – whose elements may also be integers or other lists. Note: You may assume that the string is well-formed: String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ]. 12345678910111213141516Example 1:Given s = &quot;324&quot;,You should return a NestedInteger object which contains a single integer 324.Example 2:Given s = &quot;[123,[456,[789]]]&quot;,Return a NestedInteger object containing a nested list with 2 elements:1. An integer containing value 123.2. A nested list containing two elements: i. An integer containing value 456. ii. A nested list with one element: a. An integer containing value 789. pythonPython using eval: 123456789def deserialize(self, s): def nestedInteger(x): if isinstance(x, int): return NestedInteger(x) lst = NestedInteger() for y in x: lst.add(nestedInteger(y)) return lst return nestedInteger(eval(s)) Python one-liner 12def deserialize(self, s): return NestedInteger(s) if isinstance(s, int) else reduce(lambda a, x: a.add(self.deserialize(x)) or a, s, NestedInteger()) if isinstance(s, list) else self.deserialize(eval(s)) Python Golf (136 bytes or 31 bytes) 1class Solution:deserialize=d=lambda S,s,N=NestedInteger:s&lt;[]and N(s)or s&lt;&apos;&apos;and reduce(lambda a,x:a.add(S.d(x))or a,s,N())or S.d(eval(s)) Or abusing how the judge judges (yes, this gets accepted): 1class Solution:deserialize=eval Python parsing char by char Here I turned the input string into a list with sentinel for convenience. 1234567891011121314151617def deserialize(self, s): def nestedInteger(): num = &apos;&apos; while s[-1] in &apos;1234567890-&apos;: num += s.pop() if num: return NestedInteger(int(num)) s.pop() lst = NestedInteger() while s[-1] != &apos;]&apos;: lst.add(nestedInteger()) if s[-1] == &apos;,&apos;: s.pop() s.pop() return lst s = list(&apos; &apos; + s[::-1]) return nestedInteger() cppC++ using istringstream 1234567891011121314151617181920212223class Solution &#123;public: NestedInteger deserialize(string s) &#123; istringstream in(s); return deserialize(in); &#125;private: NestedInteger deserialize(istringstream &amp;in) &#123; int number; if (in &gt;&gt; number) return NestedInteger(number); in.clear(); in.get(); NestedInteger list; while (in.peek() != &apos;]&apos;) &#123; list.add(deserialize(in)); if (in.peek() == &apos;,&apos;) in.get(); &#125; in.get(); return list; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[384. Shuffle an Array]]></title>
    <url>%2Fp%2Fd5588ca3%2F</url>
    <content type="text"><![CDATA[45.4% https://leetcode.com/problems/shuffle-an-array/ Shuffle a set of numbers without duplicates. 12345678910111213141516&gt; Example:&gt; &gt; // Init an array with set 1, 2, and 3.&gt; int[] nums = &#123;1,2,3&#125;;&gt; Solution solution = new Solution(nums);&gt; &gt; // Shuffle the array [1,2,3] and return its result. &gt; Any permutation of [1,2,3] must equally likely to be returned.&gt; solution.shuffle();&gt; &gt; // Resets the array back to its original configuration [1,2,3].&gt; solution.reset();&gt; &gt; // Returns the random shuffling of array [1,2,3].&gt; solution.shuffle();&gt; java314ms, September 13, 2016 https://discuss.leetcode.com/topic/53978/first-accepted-solution-java 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Random;public class Solution &#123; private int[] nums; private Random random; public Solution(int[] nums) &#123; this.nums = nums; random = new Random(); &#125; /** Resets the array to its original configuration and return it. */ public int[] reset() &#123; return nums; &#125; /** Returns a random shuffling of the array. */ public int[] shuffle() &#123; if(nums == null) return null; int[] a = nums.clone(); for(int j = 1; j&lt; a.length; j++)&#123; int i = random.nextInt(j+1); swap(a, i, j); &#125; return a; &#125; private void swap(int[] a, int i, int j)&#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125;&#125;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(nums); * int[] param_1 = obj.reset(); * int[] param_2 = obj.shuffle(); */ cpp375ms, September 13, 2016 https://discuss.leetcode.com/topic/53979/straight-forward-c-solution 1234567891011121314151617181920212223242526272829class Solution &#123; vector&lt;int&gt; nums;public: Solution(vector&lt;int&gt; nums) &#123; this-&gt;nums = nums; &#125; /** Resets the array to its original configuration and return it. */ vector&lt;int&gt; reset() &#123; return nums; &#125; /** Returns a random shuffling of the array. */ vector&lt;int&gt; shuffle() &#123; vector&lt;int&gt; result(nums); for(int i = 0; i&lt;result.size(); i++)&#123; int pos = rand()%(result.size()-i); swap(result[i+pos], result[i]); &#125; return result; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(nums); * vector&lt;int&gt; param_1 = obj.reset(); * vector&lt;int&gt; param_2 = obj.shuffle(); */ python688ms, September 13, 2016 https://discuss.leetcode.com/topic/53994/straight-forward-python-solution 123456789101112131415161718192021222324252627282930313233343536from random import shuffleclass Solution(object): def __init__(self, nums): &quot;&quot;&quot; :type nums: List[int] :type size: int &quot;&quot;&quot; self.nums = nums self.l = len(nums) self.ord = range(self.l) def reset(self): &quot;&quot;&quot; Resets the array to its original configuration and return it. :rtype: List[int] &quot;&quot;&quot; self.ord = range(self.l) return self.nums def shuffle(self): &quot;&quot;&quot; Returns a random shuffling of the array. :rtype: List[int] &quot;&quot;&quot; shuffle(self.ord) return [self.nums[i] for i in self.ord] # Your Solution object will be instantiated and called as such:# obj = Solution(nums)# param_1 = obj.reset()# param_2 = obj.shuffle()]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[383. Ransom Note]]></title>
    <url>%2Fp%2F5f4c6894%2F</url>
    <content type="text"><![CDATA[47.2% https://leetcode.com/problems/ransom-note/ Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note: You may assume that both strings contain only lowercase letters. 123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true cpp89ms, September 13, 2016 https://discuss.leetcode.com/topic/53865/two-ac-c-solutions-unordered_map-vector 123456789101112class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; unordered_map&lt;char, int&gt; map; for(int i = 0; i &lt; magazine.size(); ++i) ++map[magazine[i]]; for(int j = 0; j &lt; ransomNote.size(); ++j) if(--map[ransomNote[j]] &lt; 0) return false; return true; &#125;&#125;; 29ms, September 13, 2016 https://discuss.leetcode.com/topic/53865/two-ac-c-solutions-unordered_map-vector 123456789101112class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; vector&lt;int&gt; vec(26, 0); for (int i = 0; i &lt; magazine.size(); ++i) ++vec[magazine[i] - &apos;a&apos;]; for (int j = 0; j &lt; ransomNote.size(); ++j) if (--vec[ransomNote[j] - &apos;a&apos;] &lt; 0) return false; return true; &#125;&#125;; python265ms, September 13, 2016 https://discuss.leetcode.com/topic/53902/o-m-n-one-liner-python O(m+n) one-liner Python O(m+n) with m and n being the lengths of the strings. 12345678class Solution(object): def canConstruct(self, ransomNote, magazine): &quot;&quot;&quot; :type ransomNote: str :type magazine: str :rtype: bool &quot;&quot;&quot; return not collections.Counter(ransomNote) - collections.Counter(magazine) java24ms, September 13, 2016 https://discuss.leetcode.com/topic/53864/java-o-n-solution-easy-to-understand Java O(n) Solution—Easy to understand 12345678910111213public class Solution &#123; public boolean canConstruct(String ransomNote, String magazine) &#123; int[] arr = new int[26]; for(int i = 0; i&lt;magazine.length(); i++)&#123; arr[magazine.charAt(i) - &apos;a&apos;]++; &#125; for(int i = 0; i&lt;ransomNote.length(); i++)&#123; if(--arr[ransomNote.charAt(i)-&apos;a&apos;] &lt; 0) return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[382. Linked List Random Node]]></title>
    <url>%2Fp%2Ffebebfb0%2F</url>
    <content type="text"><![CDATA[46.4% https://leetcode.com/problems/linked-list-random-node/ Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? 1234567891011&gt; Example:&gt; &gt; // Init a singly linked list [1,2,3].&gt; ListNode head = new ListNode(1);&gt; head.next = new ListNode(2);&gt; head.next.next = new ListNode(3);&gt; Solution solution = new Solution(head);&gt; &gt; // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.&gt; solution.getRandom();&gt; java136ms, September 11, 2016 https://discuss.leetcode.com/topic/53738/o-n-time-o-1-space-java-solution 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; ListNode head = null; Random randomGenerator = null; /** @param head The linked list&apos;s head. Note that the head is guaranteed to be not null, so it contains at least one node. */ public Solution(ListNode head) &#123; this.head = head; this.randomGenerator = new Random(); &#125; /** Returns a random node&apos;s value. */ public int getRandom() &#123; ListNode result = null; ListNode current = head; for(int n = 1; current != null; n++)&#123; if(randomGenerator.nextInt(n) == 0)&#123; result = current; &#125; current = current.next; &#125; return result.val; &#125;&#125;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(head); * int param_1 = obj.getRandom(); */ cpp72ms, September 11, 2016 https://discuss.leetcode.com/topic/53812/using-reservoir-sampling-o-1-space-o-n-time-complexity-c 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;private: ListNode* head;public: /** @param head The linked list&apos;s head. Note that the head is guaranteed to be not null, so it contains at least one node. */ Solution(ListNode* head) &#123; this-&gt;head = head; &#125; /** Returns a random node&apos;s value. */ int getRandom() &#123; int res = head -&gt; val; ListNode * node = head-&gt;next; int i = 2; while(node)&#123; int j = rand()%i; if(j==0) res = node-&gt;val; i++; node = node-&gt;next; &#125; return res; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(head); * int param_1 = obj.getRandom(); */ python375ms, September 12, 2016 https://discuss.leetcode.com/topic/53736/o-1-space-python 12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def __init__(self, head): &quot;&quot;&quot; @param head The linked list&apos;s head. Note that the head is guaranteed to be not null, so it contains at least one node. :type head: ListNode &quot;&quot;&quot; self.head = head def getRandom(self): &quot;&quot;&quot; Returns a random node&apos;s value. :rtype: int &quot;&quot;&quot; import random res = -1 len = 0 head = self.head while head: if random.randint(0, len) == 0: res = head.val head = head.next len += 1 return res # Your Solution object will be instantiated and called as such:# obj = Solution(head)# param_1 = obj.getRandom()]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>reservoir sampling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[381. Insert Delete GetRandom O(1) - Duplicates allowed]]></title>
    <url>%2Fp%2F63f28c63%2F</url>
    <content type="text"><![CDATA[28.4% https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/ Design a data structure that supports all following operations in average O(1) time. Note: Duplicate elements are allowed. insert(val): Inserts an item val to the collection. remove(val): Removes an item val from the collection if present. getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains. 1234567891011121314151617181920212223&gt; Example:&gt; &gt; // Init an empty collection.&gt; RandomizedCollection collection = new RandomizedCollection();&gt; &gt; // Inserts 1 to the collection. Returns true as the collection did not contain 1.&gt; collection.insert(1);&gt; &gt; // Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].&gt; collection.insert(1);&gt; &gt; // Inserts 2 to the collection, returns true. Collection now contains [1,1,2].&gt; collection.insert(2);&gt; &gt; // getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.&gt; collection.getRandom();&gt; &gt; // Removes 1 from the collection, returns true. Collection now contains [1,2].&gt; collection.remove(1);&gt; &gt; // getRandom should return 1 and 2 both equally likely.&gt; collection.getRandom();&gt; python238ms, September 12, 2016 https://discuss.leetcode.com/topic/53896/frugal-python-code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class RandomizedCollection(object): def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.vals, self.idxs = [], collections.defaultdict(set) def insert(self, val): &quot;&quot;&quot; Inserts a value to the collection. Returns true if the collection did not already contain the specified element. :type val: int :rtype: bool &quot;&quot;&quot; self.vals.append(val) self.idxs[val].add(len(self.vals)-1) return len(self.idxs[val]) == 1 def remove(self, val): &quot;&quot;&quot; Removes a value from the collection. Returns true if the collection contained the specified element. :type val: int :rtype: bool &quot;&quot;&quot; if self.idxs[val]: out, ins = self.idxs[val].pop(), self.vals[-1] self.vals[out] = ins if self.idxs[ins]: self.idxs[ins].add(out) self.idxs[ins].discard(len(self.vals)-1) self.vals.pop() return True return False def getRandom(self): &quot;&quot;&quot; Get a random element from the collection. :rtype: int &quot;&quot;&quot; return random.choice(self.vals) # Your RandomizedCollection object will be instantiated and called as such:# obj = RandomizedCollection()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom()]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>hard</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[380. Insert Delete GetRandom O(1)]]></title>
    <url>%2Fp%2F8d4a81fe%2F</url>
    <content type="text"><![CDATA[38.8% https://leetcode.com/problems/insert-delete-getrandom-o1/ Design a data structure that supports all following operations in average O(1) time. insert(val): Inserts an item val to the set if not already present. remove(val): Removes an item val from the set if present. getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned. 1234567891011121314151617181920212223242526&gt; Example:&gt; &gt; // Init an empty set.&gt; RandomizedSet randomSet = new RandomizedSet();&gt; &gt; // Inserts 1 to the set. Returns true as 1 was inserted successfully.&gt; randomSet.insert(1);&gt; &gt; // Returns false as 2 does not exist in the set.&gt; randomSet.remove(2);&gt; &gt; // Inserts 2 to the set, returns true. Set now contains [1,2].&gt; randomSet.insert(2);&gt; &gt; // getRandom should return either 1 or 2 randomly.&gt; randomSet.getRandom();&gt; &gt; // Removes 1 from the set, returns true. Set now contains [2].&gt; randomSet.remove(1);&gt; &gt; // 2 was already in the set, so return false.&gt; randomSet.insert(2);&gt; &gt; // Since 1 is the only number in the set, getRandom always return 1.&gt; randomSet.getRandom();&gt; java169ms, September 12, 2016 https://discuss.leetcode.com/topic/53216/java-solution-using-a-hashmap-and-an-arraylist-along-with-a-follow-up-131-ms 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class RandomizedSet &#123; ArrayList&lt;Integer&gt; nums; HashMap&lt;Integer, Integer&gt; locs; java.util.Random rand = new java.util.Random(); /** Initialize your data structure here. */ public RandomizedSet() &#123; nums = new ArrayList&lt;Integer&gt;(); locs = new HashMap&lt;Integer, Integer&gt;(); &#125; /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ public boolean insert(int val) &#123; boolean contain = locs.containsKey(val); if(contain) return false; locs.put(val, nums.size()); nums.add(val); return true; &#125; /** Removes a value from the set. Returns true if the set contained the specified element. */ public boolean remove(int val) &#123; boolean contain = locs.containsKey(val); if(!contain) return false; int loc = locs.get(val); if(loc &lt; nums.size() - 1)&#123; int lastone = nums.get(nums.size()-1); nums.set(loc, lastone); locs.put(lastone, loc); &#125; locs.remove(val); nums.remove(nums.size()-1); return true; &#125; /** Get a random element from the set. */ public int getRandom() &#123; return nums.get(rand.nextInt(nums.size())); &#125;&#125;/** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet obj = new RandomizedSet(); * boolean param_1 = obj.insert(val); * boolean param_2 = obj.remove(val); * int param_3 = obj.getRandom(); */ cpp112ms, September 12, 2016 https://discuss.leetcode.com/topic/53286/ac-c-solution-unordered_map-vector 123456789101112131415161718192021222324252627282930313233343536373839404142class RandomizedSet &#123;public: /** Initialize your data structure here. */ RandomizedSet() &#123; &#125; /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ bool insert(int val) &#123; if(m.find(val) != m.end()) return false; nums.emplace_back(val); m[val] = nums.size() - 1; return true; &#125; /** Removes a value from the set. Returns true if the set contained the specified element. */ bool remove(int val) &#123; if(m.find(val)==m.end()) return false; int last = nums.back(); m[last] = m[val]; nums[m[val]] = last; nums.pop_back(); m.erase(val); return true; &#125; /** Get a random element from the set. */ int getRandom() &#123; return nums[rand() % nums.size()]; &#125;private: vector&lt;int&gt; nums; unordered_map&lt;int, int&gt; m;&#125;;/** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet obj = new RandomizedSet(); * bool param_1 = obj.insert(val); * bool param_2 = obj.remove(val); * int param_3 = obj.getRandom(); */ python145ms, September 12, 2016 https://discuss.leetcode.com/topic/53344/simple-solution-in-python 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class RandomizedSet(object): def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.nums, self.pos = [], &#123;&#125; def insert(self, val): &quot;&quot;&quot; Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool &quot;&quot;&quot; if val not in self.pos: self.nums.append(val) self.pos[val] = len(self.nums) - 1 return True return False def remove(self, val): &quot;&quot;&quot; Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool &quot;&quot;&quot; if val in self.pos: idx, last = self.pos[val], self.nums[-1] self.nums[idx], self.pos[last] = last, idx self.nums.pop() self.pos.pop(val, 0) return True return False def getRandom(self): &quot;&quot;&quot; Get a random element from the set. :rtype: int &quot;&quot;&quot; return self.nums[random.randint(0, len(self.nums)-1)] # Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom()]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[378. Kth Smallest Element in a Sorted Matrix]]></title>
    <url>%2Fp%2F9499e185%2F</url>
    <content type="text"><![CDATA[37.8% https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/#/description Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. 12345678910Example:matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13. Note: You may assume k is always valid, 1 ≤ k ≤ n^2. 可以像array一样输入，寻找第k大的元素，转换成array中的top k问题了。但是这种解法效率是O(nlogk)，下面有效率很高的解法，O(#row)的解法，找时间一定好好看看。我现在没有时间看了 49ms, 85.38%, October 18, 2016 https://discuss.leetcode.com/topic/52865/my-solution-using-binary-search-in-c My solution using Binary Search in C++ 12345678910111213141516171819202122232425262728class Solution &#123;public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; int n = matrix.size(); int le = matrix[0][0], ri = matrix[n - 1][n - 1]; int mid = 0; while (le &lt; ri) &#123; mid = le + (ri-le)/2; int num = 0; for (int i = 0; i &lt; n; i++) &#123; int pos = upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin(); num += pos; &#125; if (num &lt; k) &#123; le = mid + 1; &#125; else &#123; ri = mid; &#125; &#125; return le; &#125;&#125;; https://discuss.leetcode.com/topic/53126/o-n-from-paper-yes-o-rows O(n) from paper. Yes, O(#rows). It’s O(n) where n is the number of rows (and columns), not the number of elements. So it’s very efficient. The algorithm is from the paper Selection in X + Y and matrices with sorted rows and columns, which I first saw mentioned by @elmirap (thanks). The basic idea: Consider the submatrix you get by removing every second row and every second column. This has about a quarter of the elements of the original matrix. And the k-th element (k-th smallest I mean) of the original matrix is roughly the (k/4)-th element of the submatrix. So roughly get the (k/4)-th element of the submatrix and then use that to find the k-th element of the original matrix in O(n) time. It’s recursive, going down to smaller and smaller submatrices until a trivial 2×2 matrix. For more details I suggest checking out the paper, the first half is easy to read and explains things well. Or @zhiqing_xiao’s solution+explanation. Cool: It uses variants of saddleback search that you might know for example from the Search a 2D Matrix II problem. And it uses the median of medians algorithm for linear-time selection. Optimization: If k is less than n, we only need to consider the top-left k×k matrix. Similar if k is almost n2. So it’s even O(min(n, k, n^2-k)), I just didn’t mention that in the title because I wanted to keep it simple and because those few very small or very large k are unlikely, most of the time k will be “medium” (and average n2/2). Implementation: I implemented the submatrix by using an index list through which the actual matrix data gets accessed. If [0, 1, 2, …, n-1] is the index list of the original matrix, then [0, 2, 4, …] is the index list of the submatrix and [0, 4, 8, …] is the index list of the subsubmatrix and so on. This also covers the above optimization by starting with [0, 1, 2, …, k-1] when applicable. Application: I believe it can be used to easily solve the Find K Pairs with Smallest Sums problem in time O(k) instead of O(k log n), which I think is the best posted so far. I might try that later if nobody beats me to it (if you do, let me know :-). Update: I did that now. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution(object): def kthSmallest(self, matrix, k): # The median-of-medians selection function. def pick(a, k): if k == 1: return min(a) groups = (a[i:i+5] for i in range(0, len(a), 5)) medians = [sorted(group)[len(group) / 2] for group in groups] pivot = pick(medians, len(medians) / 2 + 1) smaller = [x for x in a if x &lt; pivot] if k &lt;= len(smaller): return pick(smaller, k) k -= len(smaller) + a.count(pivot) return pivot if k &lt; 1 else pick([x for x in a if x &gt; pivot], k) # Find the k1-th and k2th smallest entries in the submatrix. def biselect(index, k1, k2): # Provide the submatrix. n = len(index) def A(i, j): return matrix[index[i]][index[j]] # Base case. if n &lt;= 2: nums = sorted(A(i, j) for i in range(n) for j in range(n)) return nums[k1-1], nums[k2-1] # Solve the subproblem. index_ = index[::2] + index[n-1+n%2:] k1_ = (k1 + 2*n) / 4 + 1 if n % 2 else n + 1 + (k1 + 3) / 4 k2_ = (k2 + 3) / 4 a, b = biselect(index_, k1_, k2_) # Prepare ra_less, rb_more and L with saddleback search variants. ra_less = rb_more = 0 L = [] jb = n # jb is the first where A(i, jb) is larger than b. ja = n # ja is the first where A(i, ja) is larger than or equal to a. for i in range(n): while jb and A(i, jb - 1) &gt; b: jb -= 1 while ja and A(i, ja - 1) &gt;= a: ja -= 1 ra_less += ja rb_more += n - jb L.extend(A(i, j) for j in range(jb, ja)) # Compute and return x and y. x = a if ra_less &lt;= k1 - 1 else \ b if k1 + rb_more - n*n &lt;= 0 else \ pick(L, k1 + rb_more - n*n) y = a if ra_less &lt;= k2 - 1 else \ b if k2 + rb_more - n*n &lt;= 0 else \ pick(L, k2 + rb_more - n*n) return x, y # Set up and run the search. n = len(matrix) start = max(k - n*n + n-1, 0) k -= n*n - (n - start)**2 return biselect(range(start, min(n, start+k)), k, k)[0] https://discuss.leetcode.com/topic/52947/c-priority-queue-solution-o-klogn C++ priority queue solution O(klogn) 123456789101112131415161718192021222324252627282930313233class Solution &#123;public:struct compare&#123; bool operator()(const pair&lt;int,pair&lt;int, int&gt; &gt;&amp; a, const pair&lt;int,pair&lt;int, int&gt; &gt;&amp; b) &#123; return a.first&gt;b.first; &#125;&#125;; int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; arr, int k) &#123; int n=arr.size(),m=arr[0].size(); priority_queue&lt; pair&lt;int,pair&lt;int, int&gt; &gt;, vector&lt;pair&lt;int, pair&lt;int, int&gt; &gt; &gt;, compare &gt; p; for(int i=0;i&lt;n;i++) p.push(make_pair(arr[i][0],make_pair(i,0))); int x=k,ans; while(x--) &#123; int e=p.top().first; int i=p.top().second.first; int j=p.top().second.second; ans=e; p.pop(); if(j!=m-1) p.push(make_pair(arr[i][j+1],make_pair(i,j+1))); &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/54262/c-o-n-time-o-n-space-solution-with-detail-intuitive-explanation C++ O(n)-time O(n)-space solution with detail intuitive explanation This thread is inspired by @StefanPochmann’s thread, which mentioned Mirzaian and Arjoandi’s paper. Preparations When n==1 (i.e. the matrix is 1x1. n is the number of row), the problem is trival. Hencefore we only consider the case n&gt;=2.Rather than finding one k-th element from the matrix, we will select TWO elements (say, k0-th element and k1-th element) simultaneously, such that 0&lt;=k0&lt;=k1 &lt; n * n and k1-k0&lt;=4n. Obviously, if we can complete the aforementioned selection in O(n), we can find the k-th element in O(n) by simply letting k=k0=k1. Let x0 denote the k0-th element; let x1 denote the k1-th element. Obviously we have x0&lt;=x1.Now we will introduce how to select x0 and x1 in O(n). General idea: For an nxn matrix, where n is large, we try to select x0 and x1 in a recursive way. (Determine submatrix) This step constructs one submatrix, whose number of elements will be approximately a quarter of the original matrix. The submatrix is defined as every other row and every other column of the original matrix. The last row and the last column are included too (the reason will be stated in the sequel.) Then the dimension of the matrix is approximately (n/2) x (n/2). The submatrix is recorded by the indices in the original matrix. Example 1: the original matrix has indices {0, 1, 2, 3, 4}, then the submatrix has indices {0, 2, 4}. Example 2: the original matrix has indices {0,1, 2, 3, 4, 5}, then the submatrix has indices {0, 2,4, 5}. (Determine new k’s) This step determines two new k’s (denoted as k0_ and k1_) such that (i) k0_ is the largest possible integer to ensure k0_-th element in the new submatrix (denoted as x0_) is not greater than x0; (ii) k1_ is the smallest possible integer to ensure k1_-th element in the new submatrix (denoted as x1_) is not less than x1. This step is the most tricky step. 123k0_ = floor(k0 / 4)k1_ = floor(k1 / 4) + n + 1 (when n is even) floor((k1 + 2 * n + 1) / 4) (when n is odd) Picture: the way to determine k0_ and k1_: https://drive.google.com/open?id=0By2m48ItFbTeeDFvaS1WcV9qSWM The picture can also be founded here. Recall that we mentioned the last row and column shall always be included in the matrix. That is to ensure we can always found the x1_ such that x1_ &gt;= x1. (Call recursively) Obtainx0_ and x1_ by recursion. (Partition) Partition all elements in the original nxn elements into three parts: P1={e: e &lt; x0_}, P2={e: x0_ &lt;= e &lt; x1_ }, P3={e: x1_ &lt; e}. We only need to record the cardinality of P1 and P2 (denoted as |P1| and |P2| respectively), and the elements in P2. Obviously, the cardinality of P2 is O(n). (Get x0 and x1) From the definition of k0_ and k1_, we have |P1| &lt; k0 &lt;= |P1|+|P2|. When |P1| &lt; k0 &lt; |P1|+|P2|, x0 is the k0-|P1|-th element of P2; otherwise x0=x1_. x1 can be determined in a similar way. This action is also O(n). Complexities: Time: O(n) —– Apply T(n) = T(n/2) + O(n) in the Master’s Theorem. Space: O(n) C++ Accepted Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136class Solution &#123;public: int kthSmallest(const std::vector&lt;std::vector&lt;int&gt;&gt; &amp; matrix, int k) &#123; if (k == 1) // guard for 1x1 matrix &#123; return matrix.front().front(); &#125; size_t n = matrix.size(); std::vector&lt;size_t&gt; indices(n); std::iota(indices.begin(), indices.end(), 0); std::array&lt;size_t, 2&gt; ks = &#123; k - 1, k - 1 &#125;; // use zero-based indices std::array&lt;int, 2&gt; results = biSelect(matrix, indices, ks); return results[0]; &#125;private: // select two elements from four elements, recursively std::array&lt;int, 2&gt; biSelect( const std::vector&lt;std::vector&lt;int&gt;&gt; &amp; matrix, const std::vector&lt;size_t&gt; &amp; indices, const std::array&lt;size_t, 2&gt; &amp; ks) // Select both ks[0]-th element and ks[1]-th element in the matrix, // where k0 = ks[0] and k1 = ks[1] and n = indices.size() satisfie // 0 &lt;= k0 &lt;= k1 &lt; n*n and k1 - k0 &lt;= 4n-4 = O(n) and n&gt;=2 &#123; size_t n = indices.size(); if (n == 2u) // base case of resursion &#123; return biSelectNative(matrix, indices, ks); &#125; // update indices std::vector&lt;size_t&gt; indices_; for (size_t idx = 0; idx &lt; n; idx += 2) &#123; indices_.push_back(indices[idx]); &#125; if (n % 2 == 0) // ensure the last indice is included &#123; indices_.push_back(indices.back()); &#125; // update ks // the new interval [xs_[0], xs_[1]] should contain [xs[0], xs[1]] // but the length of the new interval should be as small as possible // therefore, ks_[0] is the largest possible index to ensure xs_[0] &lt;= xs[0] // ks_[1] is the smallest possible index to ensure xs_[1] &gt;= xs[1] std::array&lt;size_t, 2&gt; ks_ = &#123; ks[0] / 4, 0 &#125;; if (n % 2 == 0) // even &#123; ks_[1] = ks[1] / 4 + n + 1; &#125; else // odd &#123; ks_[1] = (ks[1] + 2 * n + 1) / 4; &#125; // call recursively std::array&lt;int, 2&gt; xs_ = biSelect(matrix, indices_, ks_); // Now we partipate all elements into three parts: // Part 1: &#123;e : e &lt; xs_[0]&#125;. For this part, we only record its cardinality // Part 2: &#123;e : xs_[0] &lt;= e &lt; xs_[1]&#125;. We store the set elementsBetween // Part 3: &#123;e : x &gt;= xs_[1]&#125;. No use. Discard. std::array&lt;int, 2&gt; numbersOfElementsLessThanX = &#123; 0, 0 &#125;; std::vector&lt;int&gt; elementsBetween; // [xs_[0], xs_[1]) std::array&lt;size_t, 2&gt; cols = &#123; n, n &#125;; // column index such that elem &gt;= x // the first column where matrix(r, c) &gt; b // the first column where matrix(r, c) &gt;= a for (size_t row = 0; row &lt; n; ++row) &#123; size_t row_indice = indices[row]; for (size_t idx : &#123;0, 1&#125;) &#123; while ((cols[idx] &gt; 0) &amp;&amp; (matrix[row_indice][indices[cols[idx] - 1]] &gt;= xs_[idx])) &#123; --cols[idx]; &#125; numbersOfElementsLessThanX[idx] += cols[idx]; &#125; for (size_t col = cols[0]; col &lt; cols[1]; ++col) &#123; elementsBetween.push_back(matrix[row_indice][indices[col]]); &#125; &#125; std::array&lt;int, 2&gt; xs; // the return value for (size_t idx : &#123;0, 1&#125;) &#123; size_t k = ks[idx]; if (k &lt; numbersOfElementsLessThanX[0]) // in the Part 1 &#123; xs[idx] = xs_[0]; &#125; else if (k &lt; numbersOfElementsLessThanX[1]) // in the Part 2 &#123; size_t offset = k - numbersOfElementsLessThanX[0]; std::vector&lt;int&gt;::iterator nth = std::next(elementsBetween.begin(), offset); std::nth_element(elementsBetween.begin(), nth, elementsBetween.end()); xs[idx] = (*nth); &#125; else // in the Part 3 &#123; xs[idx] = xs_[1]; &#125; &#125; return xs; &#125; // select two elements from four elements, using native way std::array&lt;int, 2&gt; biSelectNative( const std::vector&lt;std::vector&lt;int&gt;&gt; &amp; matrix, const std::vector&lt;size_t&gt; &amp; indices, const std::array&lt;size_t, 2&gt; &amp; ks) &#123; std::vector&lt;int&gt; allElements; for (size_t r : indices) &#123; for (size_t c : indices) &#123; allElements.push_back(matrix[r][c]); &#125; &#125; std::sort(allElements.begin(), allElements.end()); std::array&lt;int, 2&gt; results; for (size_t idx : &#123;0, 1&#125;) &#123; results[idx] = allElements[ks[idx]]; &#125; return results; &#125;&#125;; https://discuss.leetcode.com/topic/52886/c-solution-same-as-find-k-pairs-with-smaller-sums C++ solution same as Find K pairs with smaller sums 12345678910111213141516171819202122232425class Solution &#123;public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; auto comp = [&amp;matrix](pair&lt;int, int&gt; p1, pair&lt;int, int&gt; p2)&#123; return matrix[p1.first][p1.second] &gt; matrix[p2.first][p2.second]; &#125;; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, decltype(comp)&gt; que(comp); que.push(make_pair(0, 0)); int count = 1; while(count &lt; k)&#123; auto temp = que.top(); que.pop(); if(temp.first+1 &lt; matrix.size())&#123; que.push(make_pair(temp.first+1, temp.second)); &#125; if(temp.first == 0 &amp;&amp; temp.second+1 &lt; matrix[0].size())&#123; que.push(make_pair(temp.first, temp.second+1)); &#125; count++; &#125; auto t = que.top(); return matrix[t.first][t.second]; &#125;&#125;; https://discuss.leetcode.com/topic/52866/python-one-line-solution python one-line solution … life is too short to figure out more intelligent solution… 1234import heapqclass Solution(object): def kthSmallest(self, matrix, k): return list(heapq.merge(*matrix))[k-1] https://discuss.leetcode.com/topic/52912/binary-search-heap-and-sorting-comparison-with-concise-code-and-1-liners-python-72-ms Binary Search, Heap and Sorting comparison, with concise code and 1-liners, Python 72 ms For n X n matrix, Binary search (based on the solution from @光速小子) gives me 72 ms. The time complexity is O(n log(n) log(N)), where N is the search space that ranges from the smallest element to the biggest element. You can argue that int implies N = 2^32, so log(N) is constant. In a way, this is an O(n * log(n)) solution. The space complexity is constant. I thought this idea was weird for a while. Then I noticed the previous problem 377. Combination Sum IV is pretty much doing the same thing, so this idea may actually be intended. Here is a 8-liner implementation: 12345678910class Solution(object): def kthSmallest(self, matrix, k): lo, hi = matrix[0][0], matrix[-1][-1] while lo&lt;hi: mid = (lo+hi)//2 if sum(bisect.bisect_right(row, mid) for row in matrix) &lt; k: lo = mid+1 else: hi = mid return lo Heap solution gives me 176 ms. The time complexity is O(k log n), so the worst-case and average-case time complexity is O(n^2 log n). Space complexity is O(n). 12345678910class Solution(object): def kthSmallest(self, matrix, k): heap = [(row[0], i, 0) for i, row in enumerate(matrix)] heapq.heapify(heap) ret = 0 for _ in range(k): ret, i, j = heapq.heappop(heap) if j+1 &lt; len(matrix[0]): heapq.heappush(heap, (matrix[i][j+1], i, j+1)) return ret Sorting gives me 80ms. Time complexity of sorting an array of size n^2 is O(n^2 * log n). Space complexity is O(n^2). The difference is that Timsort implemented in Python is capable of taking advantage of existing partial orderings. Moving sorted data in bulk is always faster than comparing and moving individual data elements, due to modern hardware architecture. Time complexity is the same because merging n sorted arrays of size n is still O(n^2 * log n) in the worst case. 123456class Solution(object): def kthSmallest(self, matrix, k): l = [] for row in matrix: l += row return sorted(l)[k-1] Here are some O(n^3) (slow due to list concatenation) 1-liners: 123class Solution(object): def kthSmallest(self, matrix, k): return sorted(sum(matrix, []))[k-1] and 123class Solution(object): def kthSmallest(self, matrix, k): return sorted(reduce(lambda a,b:a+b, matrix))[k-1] Here are some O(n^2 * log n) 1-liners provided by @StefanPochmann 123return sorted(itertools.chain(*matrix))[k-1] return sorted(a for row in matrix for a in row)[k-1] return sorted(itertools.chain.from_iterable(matrix))[k-1] https://discuss.leetcode.com/topic/52862/share-my-python-solution-using-heap Share My Python Solution using Heap Algorithm h: list of tuple (element, row, index), which is initialised with first element of each row in the matrix. We maintain a heap. In the for loop, we get the smallest element v which is in row r, and replace v with the next element in the row r Time Complexity insert an element into heap: O(log(n)), where n is the width of the matrix find k the k-th element O(k) Overall: O(klog(n))123456789101112131415161718192021from heapq import heappush, heappop, heapreplace, heapifyclass Solution(object): def kthSmallest(self, matrix, k): &quot;&quot;&quot; :type matrix: List[List[int]] :type k: int :rtype: int &quot;&quot;&quot; h = [(row[0], row, 1) for row in matrix] heapify(h) # Since we want to find kth, we pop the first k elements for _ in xrange(k - 1): v, r, i = h[0] if i &lt; len(r): heapreplace(h, (r[i], r, i + 1)) else: heappop(h) return h[0][0]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[377. Combination Sum IV]]></title>
    <url>%2Fp%2F8a0b6e10%2F</url>
    <content type="text"><![CDATA[41.7% https://leetcode.com/problems/combination-sum-iv/Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: 123456789101112131415nums = [1, 2, 3]target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)Note that different sequences are counted as different combinations.Therefore the output is 7. Follow up:What if negative numbers are allowed in the given array?How does it change the problem?What limitation we need to add to the question to allow negative numbers? 解题思路 动态规划，目标为target，计算从0到target每一个的可能组合个数，然后依次计算，依次动态规划。 java 5ms, September 9, 2016https://discuss.leetcode.com/topic/52186/my-3ms-java-dp-solution 1234567891011121314151617public class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; Arrays.sort(nums); int[] res = new int[target+1]; for(int i=1; i&lt;res.length; i++)&#123; for(int num:nums)&#123; if(num &gt; i) break; else if(num == i) res[i] += 1; else res[i] += res[i-num]; &#125; &#125; return res[target]; &#125;&#125; 6ms, September 9, 2016https://discuss.leetcode.com/topic/52302/1ms-java-dp-solution-with-detailed-explanation 123456789101112public class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int[] comb = new int[target+1]; comb[0] = 1; for(int i=1; i&lt;comb.length; i++) for(int j=0; j&lt;nums.length; j++) if(i-nums[j] &gt;= 0) comb[i] += comb[i-nums[j]]; return comb[target]; &#125;&#125; cpp 3ms, September 9,2016https://discuss.leetcode.com/topic/52217/6-lines-c-dp-solution 1234567891011121314class Solution &#123;public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; result(target + 1); result[0] = 1; for(int i=1; i&lt;= target; ++i)&#123; for(int x:nums)&#123; if(i&gt;=x) result[i] += result[i-x]; &#125; &#125; return result[target]; &#125;&#125;; python 48ms, September 9, 2016https://discuss.leetcode.com/topic/52227/7-liner-in-python-and-follow-up-question 1234567891011121314class Solution(object): def combinationSum4(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; nums, combs = sorted(nums), [1]+[0]*target for i in range(target+1): for num in nums: if num &gt; i:break; if num == i: combs[i] += 1 if num &lt; i: combs[i] += combs[i-num] return combs[target]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[376. Wiggle Subsequence]]></title>
    <url>%2Fp%2F2fee1c09%2F</url>
    <content type="text"><![CDATA[34.9% https://leetcode.com/problems/wiggle-subsequence/ A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. 123456789101112&gt; Examples:&gt; Input: [1,7,4,9,2,5]&gt; Output: 6&gt; The entire sequence is a wiggle sequence.&gt; &gt; Input: [1,17,5,10,13,15,10,5,16,8]&gt; Output: 7&gt; There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].&gt; &gt; Input: [1,2,3,4,5,6,7,8,9]&gt; Output: 2&gt; Follow up: Can you do it in O(n) time? java0ms, September 11, 2016 https://discuss.leetcode.com/topic/51946/very-simple-java-solution-with-detail-explanation 123456789101112131415161718192021222324252627public class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; if(nums.length &lt; 2) return nums.length; int k = 0; while(k &lt; nums.length - 1 &amp;&amp; nums[k] == nums[k+1]) k++; if(k == nums.length - 1) return 1; int result = 2; boolean smallReq = nums[k] &lt; nums[k+1]; for(int i = k+1; i&lt;nums.length-1; i++)&#123; if(smallReq &amp;&amp; nums[i+1] &lt; nums[i])&#123; // nums[result] = nums[i+1]; result++; smallReq = !smallReq; &#125;else&#123; if(!smallReq &amp;&amp; nums[i+1] &gt; nums[i])&#123; // nums[result] = nums[i+1]; result++; smallReq = !smallReq; &#125; &#125; &#125; return result; &#125;&#125; cpp0ms, September 11, 2016 https://discuss.leetcode.com/topic/51893/two-solutions-one-is-dp-the-other-is-greedy-8-lines 1234567891011class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(), f=1, d=1; for(int i=1; i&lt;size; ++i)&#123; if(nums[i]&gt;nums[i-1]) f=d+1; else if(nums[i]&lt;nums[i-1]) d=f+1; &#125; return min(size, max(f,d)); &#125;&#125;; 13ms, September 11, 2016 https://discuss.leetcode.com/topic/51893/two-solutions-one-is-dp-the-other-is-greedy-8-lines 1234567891011121314151617181920class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; int size=nums.size(); if(size==0) return 0; vector&lt;int&gt; f(size, 1); vector&lt;int&gt; d(size, 1); for(int i=1; i&lt;size; ++i)&#123; for(int j=0; j&lt;i; ++j)&#123; if(nums[j]&lt;nums[i])&#123; f[i]=max(f[i], d[j]+1); &#125; else if(nums[j]&gt;nums[i])&#123; d[i]=max(d[i], f[j]+1); &#125; &#125; &#125; return max(d.back(), f.back()); &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[375. Guess Number Higher or Lower II]]></title>
    <url>%2Fp%2F2e2858d7%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/guess-number-higher-or-lower-ii/ We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number I picked is higher or lower. However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked. 1234567891011Example:n = 10, I pick 8.First round: You guess 5, I tell you that it&apos;s higher. You pay $5.Second round: You guess 7, I tell you that it&apos;s higher. You pay $7.Third round: You guess 9, I tell you that it&apos;s lower. You pay $9.Game over. 8 is the number I picked.You end up paying $5 + $7 + $9 = $21. Given a particular n ≥ 1, find out how much money you need to have to guarantee a win. Hint: The best strategy to play the game is to minimize the maximum loss you could possibly face. Another strategy is to minimize the expected loss. Here, we are interested in the first scenario. Take a small example (n = 3). What do you end up paying in the worst case? Check out this article if you’re still stuck. The purely recursive implementation of minimax would be worthless for even a small n. You MUST use dynamic programming. As a follow-up, how would you modify your code to solve the problem of minimizing the expected loss, instead of the worst-case loss? java https://discuss.leetcode.com/topic/51353/simple-dp-solution-with-explanation Simple DP solution with explanation~~ For each number x in range[i~j]we do: result_when_pick_x = x + max{DP([i~x-1]), DP([x+1, j])} –&gt; // the max means whenever you choose a number, the feedback is always bad and therefore leads you to a worse branch. then we get DP([i~ j]) = min{xi, … ,xj } –&gt; // this min makes sure that you are minimizing your cost. 123456789101112131415161718public class Solution &#123; public int getMoneyAmount(int n) &#123; int[][] table = new int[n+1][n+1]; return DP(table, 1, n); &#125; int DP(int[][] t, int s, int e)&#123; if(s &gt;= e) return 0; if(t[s][e] != 0) return t[s][e]; int res = Integer.MAX_VALUE; for(int x=s; x&lt;=e; x++)&#123; int tmp = x + Math.max(DP(t, s, x-1), DP(t, x+1, e)); res = Math.min(res, tmp); &#125; t[s][e] = res; return res; &#125;&#125; Here is a bottom up solution. 12345678910111213141516public class Solution &#123; public int getMoneyAmount(int n) &#123; int[][] table = new int[n+1][n+1]; for(int j=2; j&lt;=n; j++)&#123; for(int i=j-1; i&gt;0; i--)&#123; int globalMin = Integer.MAX_VALUE; for(int k=i+1; k&lt;j; k++)&#123; int localMax = k + Math.max(table[i][k-1], table[k+1][j]); globalMin = Math.min(globalMin, localMax); &#125; table[i][j] = i+1==j?i:globalMin; &#125; &#125; return table[1][n]; &#125;&#125; https://discuss.leetcode.com/topic/51358/java-dp-solution Java DP solution Definition of dp[i][j]: minimum number of money to guarantee win for subproblem [i, j]. Target: dp[1][n] Corner case: dp[i][i] = 0 (because the only element must be correct) Equation: we can choose k (i&lt;=k&lt;=j) as our guess, and pay price k. After our guess, the problem is divided into two subproblems. Notice we do not need to pay the money for both subproblems. We only need to pay the worst case (because the system will tell us which side we should go) to guarantee win. So dp[i][j] = min (i&lt;=k&lt;=j) { k + max(dp[i][k-1], dp[k+1][j]) } 1234567891011121314151617181920public class Solution &#123; public int getMoneyAmount(int n) &#123; if (n == 1) &#123; return 0; &#125; int[][] dp = new int[n + 1][n + 1]; for (int jminusi = 1; jminusi &lt; n; jminusi++) &#123; for (int i = 0; i + jminusi &lt;= n; i++) &#123; int j = i + jminusi; dp[i][j] = Integer.MAX_VALUE; for (int k = i; k &lt;= j; k++) &#123; dp[i][j] = Math.min(dp[i][j], k + Math.max(k - 1 &gt;= i ? dp[i][k - 1] : 0, j &gt;= k + 1 ? dp[k + 1][j] : 0)); &#125; &#125; &#125; return dp[1][n]; &#125;&#125; https://discuss.leetcode.com/topic/51494/java-commented-dp-solution Java commented DP solution Big Idea: Given any n, we make a guess k. Then we break the interval [1,n] into [1,k - 1] and [k + 1,n]. The min of worst case cost can be calculated recursively as cost[1,n] = k + max{cost[1,k - 1] + cost[k+1,n]}Also, it takes a while for me to wrap my head around “min of max cost”. My understand is that: you strategy is the best, but your luck is the worst. You only guess right when there is no possibilities to guess wrong. 12345678910111213141516171819202122232425262728293031public class Solution &#123; public int getMoneyAmount(int n) &#123; // all intervals are inclusive // uninitialized cells are assured to be zero // the zero column and row will be uninitialized // the illegal cells will also be uninitialized // add 1 to the length just to make the index the same as numbers used int[][] dp = new int[n + 1][n + 1]; // dp[i][j] means the min cost in the worst case for numbers (i...j) // iterate the lengths of the intervals since the calculations of longer intervals rely on shorter ones for (int l = 2; l &lt;= n; l++) &#123; // iterate all the intervals with length l, the start of which is i. Hence the interval will be [i, i + (l - 1)] for (int i = 1; i &lt;= n - (l - 1); i++) &#123; dp[i][i + (l - 1)] = Integer.MAX_VALUE; // iterate all the first guesses g for (int g = i; g &lt;= i + (l - 1); g++) &#123; int costForThisGuess; // since if g is the last integer, g + 1 does not exist, we have to separate this case // cost for [i, i + (l - 1)]: g (first guess) + max&#123;the cost of left part [i, g - 1], the cost of right part [g + 1, i + (l - 1)]&#125; if (g == n) &#123; costForThisGuess = dp[i][g - 1] + g; &#125; else &#123; costForThisGuess = g + Math.max(dp[i][g - 1], dp[g + 1][i + (l - 1)]); &#125; dp[i][i + (l - 1)] = Math.min(dp[i][i + (l - 1)], costForThisGuess); // keep track of the min cost among all first guesses &#125; &#125; &#125; return dp[1][n]; &#125;&#125; Any questions, suggestions &amp; criticism welcomed! cpp https://discuss.leetcode.com/topic/51487/an-o-n-2-dp-solution-quite-hard An O(n^2) DP Solution, Quite Hard. Algorithm description: http://artofproblemsolving.com/community/c296841h1273742 123456789101112131415161718192021222324252627#include &lt;vector&gt;#include &lt;deque&gt;using namespace std;class Solution &#123;public: int getMoneyAmount(int n) &#123; vector&lt;vector&lt;int&gt;&gt; u(n + 2, vector&lt;int&gt;(n + 2)); for (int b = 2; b &lt;= n; ++b) &#123; int k0 = b - 1; deque&lt;pair&lt;int, int&gt;&gt; v; for (int a = b - 1; a; --a) &#123; while (u[a][k0 - 1] &gt; u[k0 + 1][b]) &#123; if (!v.empty() &amp;&amp; v.front().second == k0) v.pop_front(); --k0; &#125; int vn = a + u[a + 1][b]; while (!v.empty() &amp;&amp; vn &lt; v.back().first) v.pop_back(); v.emplace_back(vn, a); int u1 = u[a][k0] + k0 + 1; int u2 = v.front().first; u[a][b] = u1 &lt; u2 ? u1 : u2; &#125; &#125; return u[1][n]; &#125;&#125;; python https://discuss.leetcode.com/topic/51356/two-python-solutions Two Python solutions To find out how much money I need to win the range lo..hi (the game starts with the range 1..n), I try each possible x in the range (except hi, which is pointless because hi-1 costs less and provides more information), calculate how much I need when using that x, and take the minimum of those amounts. Bottom-up dynamic programming: 1234567def getMoneyAmount(self, n): need = [[0] * (n+1) for _ in range(n+1)] for lo in range(n, 0, -1): for hi in range(lo+1, n+1): need[lo][hi] = min(x + max(need[lo][x-1], need[x+1][hi]) for x in range(lo, hi)) return need[1][n] Top-down with memoization, subclassing dict for convenience. Simpler than bottom-up because I don’t need to specify ranges/loops for lo and hi and don’t need to think about their orders and how big my DP matrix needs to be. On the other hand, it’s slower. Got the motivation to use tuples as indexes from @agave. I had used that myself sometimes in the past, but thought it would be very slow. Turns out it’s not that slow. I should do some timings to get a better feeling for it…123456789def getMoneyAmount(self, n): class Need(dict): def __missing__(self, (lo, hi)): if lo &gt;= hi: return 0 ret = self[lo, hi] = min(x + max(self[lo, x-1], self[x+1, hi]) for x in range(lo, hi)) return ret return Need()[1, n]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[374. Guess Number Higher or Lower]]></title>
    <url>%2Fp%2Fb1c1b834%2F</url>
    <content type="text"><![CDATA[34.3% https://leetcode.com/problems/guess-number-higher-or-lower/ We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): 1234&gt; -1 : My number is lower&gt; 1 : My number is higher&gt; 0 : Congrats! You got it!&gt; 12345&gt; Example:&gt; n = 10, I pick 6.&gt; &gt; Return 6.&gt; javasolution 1: 1ms, , 16 July 2016 https://discuss.leetcode.com/topic/51034/short-java-code-using-binary-search 1234567891011121314151617181920/* The guess API is defined in the parent class GuessGame. @param num, your guess @return -1 if my number is lower, 1 if my number is higher, otherwise return 0 int guess(int num); */public class Solution extends GuessGame &#123; public int guessNumber(int n) &#123; int i = 1, j = n; while(i &lt; j)&#123; int mid = i + (j - i) / 2; if(guess(mid) == 0) return mid; else if(guess(mid) == 1) i = mid + 1; else j = mid; &#125; return i; &#125;&#125; cppsolution 1: 0ms, , 16 July 2016 https://discuss.leetcode.com/topic/51184/0ms-c-binary-search 123456789101112131415161718192021// Forward declaration of guess API.// @param num, your guess// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0int guess(int num);class Solution &#123;public: int guessNumber(int n) &#123; int maxNumber = n, minNumber = 1; while(true)&#123; int meanNumber = (maxNumber - minNumber) / 2 + minNumber; int res = guess(meanNumber); if(res == 0) return meanNumber; else if(res == 1) minNumber = meanNumber + 1; else maxNumber = meanNumber - 1; &#125; &#125;&#125;; pythonsolution 1: 48ms, , 16 July 2016 https://discuss.leetcode.com/topic/51082/2-lines-as-usual 12345678910111213141516171819# The guess API is already defined for you.# @param num, your guess# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0# def guess(num):class Solution(object): def guessNumber(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; lo, hi = 1, n while lo &lt; hi: mid = (lo + hi) / 2 if guess(mid) == 1: lo = mid + 1 else: hi = mid return lo solution 2: 60ms, , 16 July 2016 https://discuss.leetcode.com/topic/51082/2-lines-as-usual 12345678910111213141516# The guess API is already defined for you.# @param num, your guess# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0# def guess(num):class Solution(object): def guessNumber(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; lo, hi = 1, n while lo &lt; hi: mid = (lo + hi) / 2 lo, hi = ((mid, mid), (mid+1, hi), (lo, mid-1))[guess(mid)] return lo]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[371. Sum of Two Integers]]></title>
    <url>%2Fp%2F4a61480f%2F</url>
    <content type="text"><![CDATA[51.2% https://leetcode.com/problems/sum-of-two-integers/?tab=Description Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. 12Example:Given a = 1 and b = 2, return 3. 方法一： 通过 a^b 可以知，1 0， 0 1均为1，0 0为0，但是1 1是0，本应该为1，且进一位。所以通过a^b之后，(a&amp;b)&lt;&lt;1 与刚才的 a^b形成两个数，和都等于这两个新数字的和。 我的代码实现： Oct 16， 2017 123456789101112class Solution &#123;public: int getSum(int a, int b) &#123; int sum = a; while(b)&#123; sum = a^b; b = (a&amp;b)&lt;&lt;1; a = sum; &#125; return sum; &#125;&#125;; https://discuss.leetcode.com/topic/49829/share-my-c-solutions-easy-to-understand 123456789101112class Solution &#123;public: int getSum(int a, int b) &#123; int sum = a; while(b)&#123; sum = a^b; b = (a&amp;b) &lt;&lt; 1; a = sum; &#125; return sum; &#125;&#125;; java https://discuss.leetcode.com/topic/49764/0ms-ac-java-solution 12345678910class Solution &#123;public: int getSum(int a, int b) &#123; if(b==0) return a; int sum, carry; sum = a^b; carry = (a&amp;b)&lt;&lt;1; return getSum(sum, carry); &#125;&#125;; https://discuss.leetcode.com/topic/49771/java-simple-easy-understand-solution-with-explanation 123456789101112131415161718192021222324252627282930313233343536373839// Iterativepublic int getSum(int a, int b) &#123; if (a == 0) return b; if (b == 0) return a; while (b != 0) &#123; int carry = a &amp; b; a = a ^ b; b = carry &lt;&lt; 1; &#125; return a;&#125;// Iterativepublic int getSubtract(int a, int b) &#123; while (b != 0) &#123; int borrow = (~a) &amp; b; a = a ^ b; b = borrow &lt;&lt; 1; &#125; return a;&#125;// Recursivepublic int getSum(int a, int b) &#123; return (b == 0) ? a : getSum(a ^ b, (a &amp; b) &lt;&lt; 1);&#125;// Recursivepublic int getSubtract(int a, int b) &#123; return (b == 0) ? a : getSubtract(a ^ b, (~a &amp; b) &lt;&lt; 1);&#125;// Get negative numberpublic int negate(int x) &#123; return ~x + 1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[368. Largest Divisible Subset]]></title>
    <url>%2Fp%2F7859b789%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/largest-divisible-subset/ Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0. If there are multiple solutions, return any subset is fine. 12345Example 1:nums: [1,2,3]Result: [1,2] (of course, [1,3] will also be ok) 12345Example 2:nums: [1,2,4,8]Result: [1,2,4,8] java https://discuss.leetcode.com/topic/49652/classic-dp-solution-similar-to-lis-o-n-2 Classic DP solution similar to LIS, O(n^2) Use DP to track max Set and pre index. 12345678910111213141516171819202122232425262728293031public class Solution &#123; public List&lt;Integer&gt; largestDivisibleSubset(int[] nums) &#123; int n = nums.length; int[] count = new int[n]; int[] pre = new int[n]; Arrays.sort(nums); int max = 0, index = -1; for (int i = 0; i &lt; n; i++) &#123; count[i] = 1; pre[i] = -1; for (int j = i - 1; j &gt;= 0; j--) &#123; if (nums[i] % nums[j] == 0) &#123; if (1 + count[j] &gt; count[i]) &#123; count[i] = count[j] + 1; pre[i] = j; &#125; &#125; &#125; if (count[i] &gt; max) &#123; max = count[i]; index = i; &#125; &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while (index != -1) &#123; res.add(nums[index]); index = pre[index]; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/49741/easy-understood-java-dp-solution-in-28ms-with-o-n-2-time Easy understood Java DP solution in 28ms with O(n^2) time The basic idea is like: 12341. Sort2. Find the length of longest subset3. Record the largest element of it.4. Do a loop from the largest element to nums[0], add every element belongs to the longest subset. The old version cant pass the test case [1,2,4,8,9,72] and [4,8,10,240], thanks for that @Yanning and @svcHere comes the revised version: 12345678910111213141516171819202122232425262728293031323334public static List&lt;Integer&gt; largestDivisibleSubset(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (nums == null || nums.length == 0) return res; Arrays.sort(nums); int[] dp = new int[nums.length]; dp[0] = 1; //for each element in nums, find the length of largest subset it has. for (int i = 1; i &lt; nums.length; i++)&#123; for (int j = i-1; j &gt;= 0; j--)&#123; if (nums[i] % nums[j] == 0)&#123; dp[i] = Math.max(dp[i],dp[j] + 1); &#125; &#125; &#125; //pick the index of the largest element in dp. int maxIndex = 0; for (int i = 1; i &lt; nums.length; i++)&#123; maxIndex = dp[i] &gt; dp[maxIndex] ? i : maxIndex; &#125; //from nums[maxIndex] to 0, add every element belongs to the largest subset. int temp = nums[maxIndex]; int curDp = dp[maxIndex]; for (int i = maxIndex; i &gt;= 0; i--)&#123; if (temp % nums[i] == 0 &amp;&amp; dp[i] == curDp)&#123; res.add(nums[i]); temp = nums[i]; curDp--; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/49424/java-solution-in-32ms-o-n-2-time-o-n-space Java Solution in 32ms O(N^2) time, O(N) space 123456789101112131415161718192021222324252627282930public class Solution &#123; public int[] largestDivisibleSubset(int[] nums) &#123; if(nums.length &lt; 2) return nums; else&#123; Arrays.sort(nums); int[] parent = new int[nums.length]; int[] count = new int[nums.length]; int max = 0, maxind = -1; for(int i = nums.length - 1; i &gt;= 0; i--)&#123; for(int j = i; j &lt; nums.length; j++)&#123; if(nums[j] % nums[i] == 0 &amp;&amp; count[i] &lt; 1 + count[j] )&#123; count[i] = 1 + count[j]; parent[i] = j; if(count[i] &gt; max)&#123; max = count[i]; maxind = i; &#125; &#125; &#125; &#125; int[] res = new int[max]; for(int i = 0; i &lt; max; i++)&#123; res[i] = nums[maxind]; maxind = parent[maxind]; &#125; return res; &#125; &#125;&#125; cpp https://discuss.leetcode.com/topic/49456/c-solution-with-explanations C++ Solution with Explanations The key concept here is:Given a set of integers that satisfies the property that each pair of integers inside the set are mutually divisible, for a new integer S, S can be placed into the set as long as it can divide the smallest number of the set or is divisible by the largest number of the set. For example, let’s say we have a set P = { 4, 8, 16 }, P satisfies the divisible condition. Now consider a new number 2, it can divide the smallest number 4, so it can be placed into the set; similarly, 32 can be divided by 16, the biggest number in P, it can also placed into P. Next, let’s define: EDIT: For clarification, the following definitions try to enlarge candidate solutions by appending a larger element at the end of each potential set, while my implementation below is prefixing a smaller element at the front of a set. Conceptually they are equivalent but by adding smaller elements at the front saves the trouble for keeping the correct increasing order for the final answer. Please refer to comments in code for more details. For an increasingly sorted array of integers a[1 .. n] T[n] = the length of the largest divisible subset whose largest number is a[n] T[n+1] = max{ 1 + T[i] if a[n+1] mod a[i] == 0 else 1 } Now, deducting T[n] becomes straight forward with a DP trick. For the final result we will need to maintain a backtrace array for the answer. Implementation in C++: 对于，从第一个到最后一位的循环，可以考虑是否可以倒着来，倒着或许更好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;int&gt; T(nums.size(), 0); vector&lt;int&gt; parent(nums.size(), 0); int m = 0; int mi = 0; // for(int i = 0; i &lt; nums.size(); ++i) // if extending by larger elements for(int i = nums.size() - 1; i &gt;= 0; --i) // iterate from end to start since it&apos;s easier to track the answer index &#123; // for(int j = i; j &gt;=0; --j) // if extending by larger elements for(int j = i; j &lt; nums.size(); ++j) &#123; // if(nums[i] % nums[j] == 0 &amp;&amp; T[i] &lt; 1 + T[j]) // if extending by larger elements // check every a[j] that is larger than a[i] if(nums[j] % nums[i] == 0 &amp;&amp; T[i] &lt; 1 + T[j]) &#123; // if a[j] mod a[i] == 0, it means T[j] can form a larger subset by putting a[i] into T[j] T[i] = 1 + T[j]; parent[i] = j; if(T[i] &gt; m) &#123; m = T[i]; mi = i; &#125; &#125; &#125; &#125; vector&lt;int&gt; ret; for(int i = 0; i &lt; m; ++i) &#123; ret.push_back(nums[mi]); mi = parent[mi]; &#125; // sort(ret.begin(), ret.end()); // if we go by extending larger ends, the largest &quot;answer&quot; element will come first since the candidate element we observe will become larger and larger as i increases in the outermost &quot;for&quot; loop above. // alternatively, we can sort nums in decreasing order obviously. return ret; &#125;&#125;; https://discuss.leetcode.com/topic/49456/c-solution-with-explanations/2 T[n] = the length of the largest divisible subset whose largest number is a[n] —- this is not true, T[n] should be the length of the largest divisible subset whose smallest number is a[n], not largest python https://discuss.leetcode.com/topic/49455/4-lines-in-python 4 lines in Python 12345def largestDivisibleSubset(self, nums): S = &#123;-1: set()&#125; for x in sorted(nums): S[x] = max((S[d] for d in S if x % d == 0), key=len) | &#123;x&#125; return list(max(S.values(), key=len)) My S[x] is the largest subset with x as the largest element, i.e., the subset of all divisors of x in the input. With S[-1] = emptyset as useful base case. Since divisibility is transitive, a multiple x of some divisor d is also a multiple of all elements in S[d], so it’s not necessary to explicitly test divisibility of x by all elements in S[d]. Testing x % d suffices. While storing entire subsets isn’t super efficient, it’s also not that bad. To extend a subset, the new element must be divisible by all elements in it, meaning it must be at least twice as large as the largest element in it. So with the 31-bit integers we have here, the largest possible set has size 31 (containing all powers of 2). https://discuss.leetcode.com/topic/49528/python-dp-n-2-solution Python dp n^2 solution We first do some math work. For two numbers, A and B, if A &lt; B, A % B must &gt; 0 (A != 0). The only chance A % B == 0 must be A &gt;= B. With this idea, we sort the list. Then, the question turns similar to no.300 longest increasing subsequence. For ith number, its largest divisible subset is the max of subset of any j from 0 - i-1 in which nums[i] % nums[j] == 0. 1234567891011121314151617181920212223242526272829303132class Solution(object): def largestDivisibleSubset(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; from copy import copy nums.sort() n = len(nums) if n == 0: return [] dp = [0] * n dp[0] = [nums[0]] #print(dp) for i in xrange(1, n): curNum = nums[i] maxSet = [] for j in xrange(i): if curNum % nums[j] == 0: localSet = copy(dp[j]) if len(localSet) &gt; len(maxSet): maxSet = localSet maxSet.append(nums[i]) dp[i] = maxSet #print(dp) #print(dp) res = [] for localSet in dp: if len(localSet) &gt; len(res): res = localSet return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[367. Valid Perfect Square]]></title>
    <url>%2Fp%2F4f3a3352%2F</url>
    <content type="text"><![CDATA[37.8% https://leetcode.com/problems/valid-perfect-square/ Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. 12345&gt; Example 1:&gt; &gt; Input: 16&gt; Returns: True&gt; 12345&gt; Example 2:&gt; &gt; Input: 14&gt; Returns: False&gt; javaSolution 1: 1ms, , June.28th, 2016 https://leetcode.com/discuss/110638/a-square-number-is-1-3-5-7-java-code 12345678910public class Solution &#123; public boolean isPerfectSquare(int num) &#123; int i = 1; while(num &gt; 0)&#123; num -= i; i += 2; &#125; return num == 0; &#125;&#125; cppSolution 1: 0ms, June.28th, 2016 https://leetcode.com/discuss/110671/3-4-short-lines-integer-newton-most-languages https://leetcode.com/discuss/58631/3-4-short-lines-integer-newton-every-language 123456789class Solution &#123;public: bool isPerfectSquare(int num) &#123; long r = num; while (r*r &gt; num) r = (r + num/r) / 2; return r*r == num; &#125;&#125;; pythonSolution 1: 48ms, June.28th, 2016 https://leetcode.com/discuss/110671/3-4-short-lines-integer-newton-most-languages https://leetcode.com/discuss/58631/3-4-short-lines-integer-newton-every-language 12345678910class Solution(object): def isPerfectSquare(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; r = num while r*r &gt; num: r = (r + num/r) / 2 return r * r == num]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>easy</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[365. Water and Jug Problem]]></title>
    <url>%2Fp%2F56d5deaf%2F</url>
    <content type="text"><![CDATA[26.5% https://leetcode.com/problems/water-and-jug-problem/ You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs. If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end. Operations allowed: Fill any of the jugs completely with water. Empty any of the jugs. Pour water from one jug into another till the other jug is completely full or the first jug itself is empty. 12345&gt; Example 1: (From the famous &quot;Die Hard&quot; example)&gt; &gt; Input: x = 3, y = 5, z = 4&gt; Output: True&gt; 12345&gt; Example 2:&gt; &gt; Input: x = 2, y = 6, z = 5&gt; Output: False&gt; javaSolution mine: 0ms, June.25th, 2016 123456789101112public class Solution &#123; public boolean canMeasureWater(int x, int y, int z) &#123; if (z==x+y || z==x || z==y || z==0) return true; if (x==0 || y==0 || z&gt;x+y || z%gcd(x, y)!= 0) return false; return true; &#125; private int gcd(int a, int b)&#123; return b == 0? a : gcd(b, a%b); &#125;&#125; cppSolution 1: 0ms, June.25th, 2016 123456789101112131415class Solution &#123;public: bool canMeasureWater(int x, int y, int z) &#123; if (z==x+y || z==x || z==y || z==0) return true; if (x==0 || y==0 || z&gt;x+y || z%gcd(x, y)!= 0) return false; return true; &#125; private: int gcd(int a, int b)&#123; return b == 0? a : gcd(b, a%b); &#125;&#125;; pythonSolution 1: 40ms, June.25th, 2016 12345678910111213141516class Solution(object): def canMeasureWater(self, x, y, z): &quot;&quot;&quot; :type x: int :type y: int :type z: int :rtype: bool &quot;&quot;&quot; if z == x+y or z == x or z == y or z == 0: return True if x == 0 or y == 0 or z &gt; x+y or z%self.gcd(x, y) != 0: return False return True def gcd(self, a, b): return a if b == 0 else self.gcd(b, a%b)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[363. Max Sum of Rectangle No Larger Than K]]></title>
    <url>%2Fp%2F57d07fd5%2F</url>
    <content type="text"><![CDATA[32.5% https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/description/ Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k. 123456Example:Given matrix = [ [1, 0, 1], [0, -2, 3]]k = 2 The answer is 2. Because the sum of rectangle [[0, 1], [-2, 3]] is 2 and 2 is the max number no larger than k (k = 2). Note: The rectangle inside the matrix must have an area &gt; 0. What if the number of rows is much larger than the number of columns? https://discuss.leetcode.com/topic/48875/accepted-c-codes-with-explanation-and-references Accepted C++ codes with explanation and references The naive solution is brute-force, which is O((mn)^2). In order to be more efficient, I tried something similar to Kadane’s algorithm. The only difference is that here we have upper bound restriction K. Here’s the easily understanding video link for the problem “find the max sum rectangle in 2D array”: Maximum Sum Rectangular Submatrix in Matrix dynamic programming/2D kadane (Trust me, it’s really easy and straightforward). Once you are clear how to solve the above problem, the next step is to find the max sum no more than K in an array. This can be done within O(nlogn), and you can refer to this article: max subarray sum no more than k. For the solution below, I assume that the number of rows is larger than the number of columns. Thus in general time complexity is O[min(m,n)^2 max(m,n) log(max(m,n))], space O(max(m, n)). 12345678910111213141516171819202122232425int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; if (matrix.empty()) return 0; int row = matrix.size(), col = matrix[0].size(), res = INT_MIN; for (int l = 0; l &lt; col; ++l) &#123; vector&lt;int&gt; sums(row, 0); for (int r = l; r &lt; col; ++r) &#123; for (int i = 0; i &lt; row; ++i) &#123; sums[i] += matrix[i][r]; &#125; // Find the max subarray no more than K set&lt;int&gt; accuSet; accuSet.insert(0); int curSum = 0, curMax = INT_MIN; for (int sum : sums) &#123; curSum += sum; set&lt;int&gt;::iterator it = accuSet.lower_bound(curSum - k); if (it != accuSet.end()) curMax = std::max(curMax, curSum - *it); accuSet.insert(curSum); &#125; res = std::max(res, curMax); &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/49781/no-real-dp-technique-actually-used-c-critically-commented No real DP technique actually used C++, critically commented The last section of the solution can be tricky, but read it carefully and I believe you can get it done! Good luck! 123456789101112131415161718192021222324252627282930class Solution &#123;public: int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; if(matrix.empty()) return 0; int rowSize = matrix.size(), colSize = matrix[0].size(); int ret = INT_MIN; for(int l = 0; l &lt; colSize; ++l) //starting leftmost column; &#123; vector&lt;int&gt; sums(rowSize, 0); //store the row pre-sums; for(int c = l; c &lt; colSize; ++c) //try different ending columns; &#123; for(int r = 0; r &lt; rowSize; ++r) //sum them up in rows; sums[r] += matrix[r][c]; set&lt;int&gt; sums_set; //store the sums from the starting top-left; sums_set.insert(0); //as a sentinel; int maxSum = INT_MIN, sum = 0; for(int i = 0; i &lt; rowSize; ++i) &#123; sum += sums[i]; //the sum from the starting top-left to current position; auto iter = sums_set.lower_bound(sum-k); //check the possible sum candidates; if(iter != sums_set.end()) maxSum = max(maxSum, sum-*iter); //found one, check it; sums_set.insert(sum); &#125; ret = max(ret, maxSum); &#125; &#125; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/48930/any-accepted-python-solution Any Accepted Python Solution? I got a TLE for the Python code below, because the time cost of bisect.insort is O(n) for a built-in list. The code was rejudged as accepted just now, but very slow… 1800ms+ 12345678910111213141516171819202122232425class Solution(object): def maxSumSubmatrix(self, matrix, k): &quot;&quot;&quot; :type matrix: List[List[int]] :type k: int :rtype: int &quot;&quot;&quot; m = len(matrix) n = len(matrix[0]) if m else 0 M = max(m, n) N = min(m, n) ans = None for x in range(N): sums = [0] * M for y in range(x, N): slist, num = [], 0 for z in range(M): sums[z] += matrix[z][y] if m &gt; n else matrix[y][z] num += sums[z] if num &lt;= k: ans = max(ans, num) i = bisect.bisect_left(slist, num - k) if i != len(slist): ans = max(ans, num - slist[i]) bisect.insort(slist, num) return ans or 0 Could anybody share a more efficient Python solution? Thank you :D]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>binary search</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[357. Count Numbers with Unique Digits]]></title>
    <url>%2Fp%2Fa3517303%2F</url>
    <content type="text"><![CDATA[45.4% https://leetcode.com/problems/count-numbers-with-unique-digits/#/description Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &lt; 10n. 123Example:Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x &lt; 100,excluding [11,22,33,44,55,66,77,88,99]) Hint: A direct way is to use the backtracking approach. Backtracking should contains three states which are (the current number, number of steps to get that number and a bitmask which represent which number is marked as visited so far in the current number). Start with state (0,0,0) and count all valid number till we reach number of steps equals to 10n. This problem can also be solved using a dynamic programming approach and some knowledge of combinatorics. Let f(k) = count of numbers with unique digits with length equals k. f(1) = 10, …, f(k) = 9 9 8 * … (9 - k + 2) [The first factor is 9 because a number cannot start with 0]. javaSolution 1: 0ms, June.15th, 2016 https://leetcode.com/discuss/107945/java-dp-o-n-solution 123456789101112131415public class Solution &#123; public int countNumbersWithUniqueDigits(int n) &#123; if (n == 0) return 1; int res = 10; int uniqueDigits = 9; int availableNumber = 9; while (n-- &gt; 1 &amp;&amp; availableNumber &gt; 0) &#123; uniqueDigits = uniqueDigits * availableNumber; res += uniqueDigits; availableNumber--; &#125; return res; &#125;&#125; cppSolution 1: 0ms, June.15th, 2016 https://leetcode.com/discuss/107945/java-dp-o-n-solution 12345678910111213141516class Solution &#123;public: int countNumbersWithUniqueDigits(int n) &#123; if(n==0) return 1; int res = 10; int uniqueDigits = 9; int availableNumber = 9; while(n--&gt;1 &amp;&amp; availableNumber&gt;0)&#123; uniqueDigits = uniqueDigits * availableNumber; res += uniqueDigits; availableNumber--; &#125; return res; &#125;&#125;; pythonSolution 1: 72ms, 9 / 9, June.15th, 2016 https://leetcode.com/discuss/108394/o-1-python-solution-with-cheat-sheet-p 12345678cheat_sheet = [1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771]class Solution(object): def countNumbersWithUniqueDigits(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; return cheat_sheet[n] if n&lt;11 else cheat_sheet[10]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[355. Design Twitter]]></title>
    <url>%2Fp%2F80702377%2F</url>
    <content type="text"><![CDATA[25.1% https://leetcode.com/problems/design-twitter/#/description Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods: postTweet(userId, tweetId): Compose a new tweet. getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. follow(followerId, followeeId): Follower follows a followee. unfollow(followerId, followeeId): Follower unfollows a followee. 1234567891011121314151617181920212223242526Example:Twitter twitter = new Twitter();// User 1 posts a new tweet (id = 5).twitter.postTweet(1, 5);// User 1&apos;s news feed should return a list with 1 tweet id -&gt; [5].twitter.getNewsFeed(1);// User 1 follows user 2.twitter.follow(1, 2);// User 2 posts a new tweet (id = 6).twitter.postTweet(2, 6);// User 1&apos;s news feed should return a list with 2 tweet ids -&gt; [6, 5].// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.twitter.getNewsFeed(1);// User 1 unfollows user 2.twitter.unfollow(1, 2);// User 1&apos;s news feed should return a list with 1 tweet id -&gt; [5],// since user 1 is no longer following user 2.twitter.getNewsFeed(1); https://discuss.leetcode.com/topic/48253/72ms-c-solution 72ms C++ solution Complexity: O(1) post/follow/unfollow, O(n + k log n) newsfeed for getting k tweets from n followed users, with the O(n) part coming from constructing the heap of followed users (see below), as correctly noted by @poligun. Use std::vector to store tweets, std::unordered_set to store followed users, std::unordered_map to associate each user with their tweets and followed users. Use a heap to merge most recent k tweets from followed users. std::make/push/pop_heap provide finer control than std::priority_queue. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Twitter&#123; struct Tweet &#123; int time; int id; Tweet(int time, int id) : time(time), id(id) &#123;&#125; &#125;; std::unordered_map&lt;int, std::vector&lt;Tweet&gt;&gt; tweets; // [u] = array of tweets by u std::unordered_map&lt;int, std::unordered_set&lt;int&gt;&gt; following; // [u] = array of users followed by u int time;public: Twitter() : time(0) &#123;&#125; void postTweet(int userId, int tweetId) &#123; tweets[userId].emplace_back(time++, tweetId); &#125; std::vector&lt;int&gt; getNewsFeed(int userId) &#123; std::vector&lt;std::pair&lt;Tweet*, Tweet*&gt;&gt; h; // pair of pointers (begin, current) for (auto&amp; u: following[userId]) &#123; auto&amp; t = tweets[u]; if (t.size() &gt; 0) h.emplace_back(t.data(), t.data() + t.size() - 1); &#125; auto&amp; t = tweets[userId]; // self if (t.size() &gt; 0) h.emplace_back(t.data(), t.data() + t.size() - 1); auto f = [](const std::pair&lt;Tweet*, Tweet*&gt;&amp; x, const std::pair&lt;Tweet*, Tweet*&gt;&amp; y) &#123; return x.second-&gt;time &lt; y.second-&gt;time; &#125;; std::make_heap(h.begin(), h.end(), f); const int n = 10; std::vector&lt;int&gt; o; o.reserve(n); for (int i = 0; (i &lt; n) &amp;&amp; !h.empty(); ++i) &#123; std::pop_heap(h.begin(), h.end(), f); auto&amp; hb = h.back(); o.push_back(hb.second-&gt;id); if (hb.first == hb.second--) h.pop_back(); else std::push_heap(h.begin(), h.end(), f); &#125; return o; &#125; void follow(int followerId, int followeeId) &#123; if (followerId != followeeId) following[followerId].insert(followeeId); &#125; void unfollow(int followerId, int followeeId) &#123; following[followerId].erase(followeeId); &#125;&#125;; https://discuss.leetcode.com/topic/47922/c-80ms-unordered_map-list-priority_queue-solution C++ 80ms unordered_map list priority_queue solution Time Complexity: n is number of user postTweet: O(1) getNewsFeed: O(n log n) follow: O(1) unfollow: O(1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Twitter &#123;private: struct tweet&#123; int userId; int tweetId; int timestamp; tweet(int x, int y, int z):userId(x), tweetId(y), timestamp(z)&#123;&#125;; &#125;; struct mycompare&#123; bool operator()(pair&lt;list&lt;tweet&gt;::iterator, list&lt;tweet&gt;::iterator&gt; p1, pair&lt;list&lt;tweet&gt;::iterator, list&lt;tweet&gt;::iterator&gt; p2)&#123; return p1.first-&gt;timestamp &lt; p2.first-&gt;timestamp; &#125; &#125;; int timelabel = 0; unordered_map&lt;int, unordered_set&lt;int&gt;&gt; follower_dict; unordered_map&lt;int, list&lt;tweet&gt;&gt; twitter_dict;public: /** Initialize your data structure here. */ Twitter() &#123;&#125; /** Compose a new tweet. */ void postTweet(int userId, int tweetId) &#123; follower_dict[userId].insert(userId); twitter_dict[userId].push_front(tweet(userId, tweetId, timelabel)); timelabel++; &#125; /** Retrieve the 10 most recent tweet ids in the user&apos;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */ vector&lt;int&gt; getNewsFeed(int userId) &#123; vector&lt;int&gt; res; if(follower_dict.find(userId) == follower_dict.end()) return res; priority_queue&lt; pair&lt;list&lt;tweet&gt;::iterator, list&lt;tweet&gt;::iterator&gt;, vector&lt;pair&lt;list&lt;tweet&gt;::iterator, list&lt;tweet&gt;::iterator&gt;&gt;, mycompare&gt; pq; for(auto it = follower_dict[userId].begin(); it != follower_dict[userId].end(); it++)&#123; if(twitter_dict[*it].begin() != twitter_dict[*it].end())&#123; pq.push(make_pair(twitter_dict[*it].begin(), twitter_dict[*it].end())); &#125; &#125; int index = 0; while(!pq.empty() &amp;&amp; index &lt; 10)&#123; auto tmp = pq.top(); pq.pop(); res.push_back(tmp.first-&gt;tweetId); if(++tmp.first != tmp.second)&#123; pq.push(tmp); &#125; index++; &#125; return res; &#125; /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ void follow(int followerId, int followeeId) &#123; follower_dict[followerId].insert(followerId); follower_dict[followerId].insert(followeeId); &#125; /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ void unfollow(int followerId, int followeeId) &#123; if(follower_dict.find(followerId) != follower_dict.end() &amp;&amp; followerId != followeeId)&#123; follower_dict[followerId].erase(followeeId); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/47838/python-solution Python solution 12345678910111213141516171819class Twitter(object): def __init__(self): self.timer = itertools.count(step=-1) self.tweets = collections.defaultdict(collections.deque) self.followees = collections.defaultdict(set) def postTweet(self, userId, tweetId): self.tweets[userId].appendleft((next(self.timer), tweetId)) def getNewsFeed(self, userId): tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | &#123;userId&#125;)) return [t for _, t in itertools.islice(tweets, 10)] def follow(self, followerId, followeeId): self.followees[followerId].add(followeeId) def unfollow(self, followerId, followeeId): self.followees[followerId].discard(followeeId) https://discuss.leetcode.com/topic/48166/simple-and-clean-python-code-o-logk-for-getting-news-feed Simple and Clean Python code, O(logK) for getting news feed 1234567891011121314151617181920212223242526272829303132333435363738394041424344import heapqclass Twitter(object): def __init__(self): self.time = 0 self.tweets = &#123;&#125; self.followee = &#123;&#125; def postTweet(self, user, tweet): self.time += 1 self.tweets[user] = self.tweets.get(user, []) + [(-self.time, tweet)] def getNewsFeed(self, user): h, tweets = [], self.tweets people = self.followee.get(user, set()) | set([user]) for person in people: if person in tweets and tweets[person]: time, tweet = tweets[person][-1] h.append((time, tweet, person, len(tweets[person]) - 1)) heapq.heapify(h) news = [] for _ in range(10): if h: time, tweet, person, idx = heapq.heappop(h) news.append(tweet) if idx: new_time, new_tweet = tweets[person][idx-1] heapq.heappush(h, (new_time, new_tweet, person, idx - 1)) return news def follow(self, follower, other): self.followee[follower] = self.followee.get(follower, set()) | set([other]) def unfollow(self, follower, other): if follower in self.followee: self.followee[follower].discard(other) K is the number of followee of user. We have O(log(K)) runtime for getting news feed because we do maximum 10 extractions in a heap that holds maximum K elements (similar to what is done in merge K linked lists). The other ops are obviously O(1). java175ms, 50.30%, September 22, 2016 https://discuss.leetcode.com/topic/48100/java-oo-design-with-most-efficient-function-getnewsfeed 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class Twitter &#123; private static int timeStamp = 0; private Map&lt;Integer, User&gt; userMap; private class Tweet&#123; public int id; public int time; public Tweet next; public Tweet(int id)&#123; this.id = id; time = timeStamp++; next = null; &#125; &#125; public class User&#123; public int id; public Set&lt;Integer&gt; followed; public Tweet tweet_head; public User(int id)&#123; this.id = id; followed = new HashSet&lt;&gt;(); follow(id); tweet_head = null; &#125; public void follow(int id)&#123; followed.add(id); &#125; public void unfollow(int id)&#123; followed.remove(id); &#125; public void post(int id)&#123; Tweet t = new Tweet(id); t.next = tweet_head; tweet_head = t; &#125; &#125; /** Initialize your data structure here. */ public Twitter() &#123; userMap = new HashMap&lt;Integer, User&gt;(); &#125; /** Compose a new tweet. */ public void postTweet(int userId, int tweetId) &#123; if(!userMap.containsKey(userId))&#123; User u = new User(userId); userMap.put(userId, u); &#125; userMap.get(userId).post(tweetId); &#125; /** Retrieve the 10 most recent tweet ids in the user&apos;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */ public List&lt;Integer&gt; getNewsFeed(int userId) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(!userMap.containsKey(userId)) return res; Set&lt;Integer&gt; users = userMap.get(userId).followed; PriorityQueue&lt;Tweet&gt; q = new PriorityQueue&lt;Tweet&gt;(users.size(), (a, b)-&gt;(b.time-a.time)); for(int user : users)&#123; Tweet t = userMap.get(user).tweet_head; if(t!=null) q.add(t); &#125; int n=0; while(!q.isEmpty() &amp;&amp; n &lt; 10)&#123; Tweet t = q.poll(); res.add(t.id); n++; if(t.next!=null) q.add(t.next); &#125; return res; &#125; /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ public void follow(int followerId, int followeeId) &#123; if(!userMap.containsKey(followerId))&#123; User u = new User(followerId); userMap.put(followerId, u); &#125; if(!userMap.containsKey(followeeId))&#123; User u = new User(followeeId); userMap.put(followeeId, u); &#125; userMap.get(followerId).follow(followeeId); &#125; /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ public void unfollow(int followerId, int followeeId) &#123; if(!userMap.containsKey(followerId) || followerId == followeeId) return; userMap.get(followerId).unfollow(followeeId); &#125;&#125;/** * Your Twitter object will be instantiated and called as such: * Twitter obj = new Twitter(); * obj.postTweet(userId,tweetId); * List&lt;Integer&gt; param_2 = obj.getNewsFeed(userId); * obj.follow(followerId,followeeId); * obj.unfollow(followerId,followeeId); */ python109ms, 66.92%, September 22, 2016 https://discuss.leetcode.com/topic/47838/python-solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Twitter(object): def __init__(self): &quot;&quot;&quot; Initialize your data structure here. &quot;&quot;&quot; self.timer = itertools.count(step=-1) self.tweets = collections.defaultdict(collections.deque) self.followees = collections.defaultdict(set) def postTweet(self, userId, tweetId): &quot;&quot;&quot; Compose a new tweet. :type userId: int :type tweetId: int :rtype: void &quot;&quot;&quot; self.tweets[userId].appendleft((next(self.timer), tweetId)) def getNewsFeed(self, userId): &quot;&quot;&quot; Retrieve the 10 most recent tweet ids in the user&apos;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. :type userId: int :rtype: List[int] &quot;&quot;&quot; tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | &#123;userId&#125;)) return [t for _, t in itertools.islice(tweets, 10)] def follow(self, followerId, followeeId): &quot;&quot;&quot; Follower follows a followee. If the operation is invalid, it should be a no-op. :type followerId: int :type followeeId: int :rtype: void &quot;&quot;&quot; self.followees[followerId].add(followeeId) def unfollow(self, followerId, followeeId): &quot;&quot;&quot; Follower unfollows a followee. If the operation is invalid, it should be a no-op. :type followerId: int :type followeeId: int :rtype: void &quot;&quot;&quot; self.followees[followerId].discard(followeeId) # Your Twitter object will be instantiated and called as such:# obj = Twitter()# obj.postTweet(userId,tweetId)# param_2 = obj.getNewsFeed(userId)# obj.follow(followerId,followeeId)# obj.unfollow(followerId,followeeId)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>hash table</tag>
        <tag>heap</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[354. Russian Doll Envelopes]]></title>
    <url>%2Fp%2F72cbf7b0%2F</url>
    <content type="text"><![CDATA[31.9% https://leetcode.com/problems/russian-doll-envelopes/ You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other) 1234Example:Given envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]). java https://discuss.leetcode.com/topic/47469/java-nlogn-solution-with-explanation Java NLogN Solution with Explanation Sort the array. Ascend on width and descend on height if width are same. Find the longest increasing subsequence based on height. Since the width is increasing, we only need to consider height. [3, 4] cannot contains [3, 3], so we need to put [3, 4] before [3, 3] when sorting otherwise it will be counted as an increasing number if the order is [3, 3], [3, 4] 123456789101112131415161718192021222324public int maxEnvelopes(int[][] envelopes) &#123; if(envelopes == null || envelopes.length == 0 || envelopes[0] == null || envelopes[0].length != 2) return 0; Arrays.sort(envelopes, new Comparator&lt;int[]&gt;()&#123; public int compare(int[] arr1, int[] arr2)&#123; if(arr1[0] == arr2[0]) return arr2[1] - arr1[1]; else return arr1[0] - arr2[0]; &#125; &#125;); int dp[] = new int[envelopes.length]; int len = 0; for(int[] envelope : envelopes)&#123; int index = Arrays.binarySearch(dp, 0, len, envelope[1]); if(index &lt; 0) index = -(index + 1); dp[index] = envelope[1]; if(index == len) len++; &#125; return len;&#125; https://discuss.leetcode.com/topic/47469/java-nlogn-solution-with-explanation/2 clever solution, here is my C++ version 12345678910111213141516171819202122class Solution &#123;public: static bool cmp_first(const pair&lt;int, int&gt;&amp; i, const pair&lt;int, int&gt;&amp; j) &#123; if (i.first == j.first) return i.second &gt; j.second; return i.first &lt; j.first; &#125; int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) &#123; vector&lt;int&gt; candidates; sort(envelopes.begin(), envelopes.end(), cmp_first); vector&lt;int&gt; dp; for (int i = 0; i &lt; envelopes.size(); ++i) &#123; auto itr = lower_bound(dp.begin(), dp.end(), envelopes[i].second); if (itr == dp.end()) &#123; dp.push_back(envelopes[i].second); &#125; else &#123; *itr = envelopes[i].second; &#125; &#125; return dp.size(); &#125;&#125;; What a concise and comprehensive explanation! Here is my Python code following your thought: 1234567891011121314from bisect import bisect_leftclass Solution(object): def maxEnvelopes(self, envelopes): if not envelopes: return 0 envelopes.sort(key=lambda x: (x[0], -x[1])) max_idx = 0 heights = [envelopes[0][1]] + [0] * (len(envelopes) - 1) for e in envelopes: idx = bisect_left(heights, e[1], hi=max_idx + 1) heights[idx] = e[1] max_idx = max(max_idx, idx) return max_idx + 1 https://discuss.leetcode.com/topic/47404/simple-dp-solution Simple DP solution 123456789101112131415161718192021222324252627282930313233public int maxEnvelopes(int[][] envelopes) &#123; if ( envelopes == null || envelopes.length == 0 || envelopes[0] == null || envelopes[0].length == 0)&#123; return 0; &#125; Arrays.sort(envelopes, new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] e1, int[] e2)&#123; return Integer.compare(e1[0], e2[0]); &#125; &#125;); int n = envelopes.length; int[] dp = new int[n]; int ret = 0; for (int i = 0; i &lt; n; i++)&#123; dp[i] = 1; for (int j = 0; j &lt; i; j++)&#123; if ( envelopes[i][0] &gt; envelopes[j][0] &amp;&amp; envelopes[i][1] &gt; envelopes[j][1])&#123; dp[i] = Math.max(dp[i], 1 + dp[j]); &#125; &#125; ret = Math.max(ret, dp[i]); &#125; return ret;&#125; https://discuss.leetcode.com/topic/47594/short-and-simple-java-solution-15-lines Short and simple Java solution (15 lines) 1234567891011121314public int maxEnvelopes(int[][] envelopes) &#123; Arrays.sort(envelopes, (a, b) -&gt; a[0] - b[0]); int max = 0; int dp [] = new int [envelopes.length]; for(int i = 0; i &lt; envelopes.length; i++)&#123; dp[i] = 1; for(int j = 0; j &lt; i; j++)&#123; if(envelopes[j][0] &lt; envelopes[i][0] &amp;&amp; envelopes[j][1] &lt; envelopes[i][1]) dp[i] = Math.max(dp[i], dp[j] + 1); &#125; max = Math.max(dp[i], max); &#125; return max;&#125; cpp https://discuss.leetcode.com/topic/47406/c-dp-version-time-o-n-2-space-o-n C++ DP version, Time O(N^2) Space O(N) 123456789101112131415161718192021222324bool cmp (pair&lt;int, int&gt; i, pair&lt;int, int&gt; j) &#123; if (i.first == j.first) return i.second &lt; j.second; return i.first &lt; j.first;&#125;class Solution &#123;public: int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) &#123; int N = envelopes.size(); vector&lt;int&gt; dp(N, 1); int mx = (N == 0) ? 0 : 1; sort(envelopes.begin(), envelopes.end(), cmp); for (int i = 0; i &lt; N; i++) &#123; for (int j = i - 1; j &gt;= 0; j--) &#123; if (envelopes[i].first &gt; envelopes[j].first &amp;&amp; envelopes[i].second &gt; envelopes[j].second) &#123; dp[i] = max(dp[i], dp[j] + 1); mx = max(dp[i], mx); &#125; &#125; &#125; return mx; &#125;&#125;; https://discuss.leetcode.com/topic/47684/c-9-line-short-and-clean-o-nlogn-solution-plus-classic-o-n-2-dp-solution C++ 9-line Short and Clean O(nlogn) solution (plus classic O(n^2) dp solution). 123456789101112131415161718///O(nlogn)struct Solution &#123; int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; es) &#123; sort(es.begin(), es.end(), [](pair&lt;int, int&gt; a, pair&lt;int, int&gt; b)&#123; return a.first &lt; b.first || (a.first == b.first &amp;&amp; a.second &gt; b.second);&#125;); vector&lt;int&gt; dp; for (auto e : es) &#123; auto iter = lower_bound(dp.begin(), dp.end(), e.second); if (iter == dp.end()) dp.push_back(e.second); else if (e.second &lt; *iter) *iter = e.second; &#125; return dp.size(); &#125;&#125;; 1234567891011121314///DPstruct Solution &#123; int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) &#123; if (envelopes.empty()) return 0; sort(envelopes.begin(), envelopes.end()); vector&lt;int&gt; dp(envelopes.size(), 1); for (int i = 0; i &lt; envelopes.size(); ++i) for (int j = 0; j &lt; i; ++j) if (envelopes[j].first &lt; envelopes[i].first &amp;&amp; envelopes[j].second &lt; envelopes[i].second) dp[i] = max(dp[i] , dp[j] + 1); return *max_element(dp.begin(), dp.end()); &#125;&#125;; python https://discuss.leetcode.com/topic/47443/clean-and-short-nlogn-solution Clean and short nlogn solution See more explanation in Longest Increasing Subsequence Size (N log N) 12345678910111213141516171819202122def maxEnvelopes(self, envelopes): def bin_search(A, key): l, r = 0, len(A) while l &lt; r: mid = (l+r)/2 if A[mid][1] &lt; key[1]: l = mid + 1 else: r = mid return l envelopes.sort( cmp = lambda x,y: x[0]-y[0] if x[0] != y[0] else y[1]-x[1]) n = len(envelopes) tails = [] for i in range(n): e = envelopes[i] p = bin_search(tails, e) if p == len(tails): tails.append(e) else: tails[p] = e return len(tails) https://discuss.leetcode.com/topic/48160/python-o-nlogn-o-n-solution-beats-97-with-explanation Python O(nlogn) O(n) solution, beats 97%, with explanation 123456789101112131415161718192021222324252627282930class Solution(object): def maxEnvelopes(self, envs): def liss(envs): def lmip(envs, tails, k): b, e = 0, len(tails) - 1 while b &lt;= e: m = (b + e) &gt;&gt; 1 if envs[tails[m]][1] &gt;= k[1]: e = m - 1 else: b = m + 1 return b tails = [] for i, env in enumerate(envs): idx = lmip(envs, tails, env) if idx &gt;= len(tails): tails.append(i) else: tails[idx] = i return len(tails) def f(x, y): return -1 if (x[0] &lt; y[0] or x[0] == y[0] and x[1] &gt; y[1]) else 1 envs.sort(cmp=f) return liss(envs)# Runtime: 100ms The idea is to order the envelopes and then calculate the longest increasing subsequence (LISS). We first sort the envelopes by width, and we also make sure that when the width is the same, the envelope with greater height comes first. Why? This makes sure that when we calculate the LISS, we don’t have a case such as [3, 4] [3, 5] (we could increase the LISS but this would be wrong as the width is the same. It can’t happen when [3, 5] comes first in the ordering). We could calculate the LISS using the standard DP algorithm (quadratic runtime), but we can just use the tails array method with a twist: we store the index of the tail, and we do leftmost insertion point as usual to find the right index in nlogn time. Why not rightmost? Think about the case [1, 1], [1, 1], [1, 1].]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>binary search</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[350. Intersection of Two Arrays II]]></title>
    <url>%2Fp%2F431b389%2F</url>
    <content type="text"><![CDATA[44.0% https://leetcode.com/problems/intersection-of-two-arrays-ii/ Given two arrays, write a function to compute their intersection. 12Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1’s size is small compared to nums2’s size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? 先排序 后两个指针遍历 算法复杂度n*logn，因为有排序。 使用hash表，复杂度为n，所以使用hash表，效果更好。 javaSolution 1: https://leetcode.com/discuss/103835/ac-solution-using-java-hashmap 7ms, 63.08%, June.5th, 2016 12345678910111213141516171819202122232425262728public class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; nums1.length; i++) &#123; if(map.containsKey(nums1[i])) map.put(nums1[i], map.get(nums1[i])+1); else map.put(nums1[i], 1); &#125; for(int i = 0; i &lt; nums2.length; i++) &#123; if(map.containsKey(nums2[i]) &amp;&amp; map.get(nums2[i]) &gt; 0) &#123; result.add(nums2[i]); map.put(nums2[i], map.get(nums2[i])-1); &#125; &#125; int[] r = new int[result.size()]; for(int i = 0; i &lt; result.size(); i++) &#123; r[i] = result.get(i); &#125; return r; &#125;&#125; cppSolution Mine: 12ms, 40.16%, June.5th, 2016 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; std::sort(nums1.begin(), nums1.end()); std::sort(nums2.begin(), nums2.end()); vector&lt;int&gt; ans; int i=0, j=0; while(i&lt;nums1.size()&amp;&amp;j&lt;nums2.size())&#123; if(nums1[i]&lt;nums2[j]) i++; else if(nums1[i]&gt;nums2[j]) j++; else&#123; ans.push_back(nums1[i]); i++; j++; &#125; &#125; return ans; &#125;&#125;; Solution 2: https://leetcode.com/discuss/103787/table-solution-pointers-solution-with-time-space-complexity 12ms, 40.16%, June.5th, 2016 1234567891011class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_map&lt;int,int&gt; dict; vector&lt;int&gt; res; for(int i=0; i&lt;nums1.size();i++) dict[nums1[i]]++; for(int j=0; j&lt;nums2.size();j++) if(--dict[nums2[j]] &gt;= 0) res.push_back(nums2[j]); return res; &#125;&#125;; pythonSolution 1: https://leetcode.com/discuss/104046/python-o-n-simple-solution 60ms, 61.07%, June.5th, 2016 12345678910111213141516class Solution(object): def intersect(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; result = [] n_dict = dict() for n in nums1: n_dict[n] = n_dict.get(n, 0) + 1 for n2 in nums2: if n_dict.get(n2, 0) &gt; 0: result.append(n2) n_dict[n2] = n_dict[n2] - 1 return result Solution 2: https://leetcode.com/discuss/103895/straightforward-python-solution-based-on-sort 62ms, 88.22%, June.5th, 2016 12345678910111213141516171819202122class Solution(object): def intersect(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; nums1.sort() nums2.sort() i=0 j=0 res = [] while i&lt;len(nums1) and j&lt;len(nums2): if nums1[i] == nums2[j]: res.append(nums1[i]) i += 1 j += 1 elif nums1[i] &lt; nums2[j]: i += 1 else: j += 1 return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
        <tag>binary search</tag>
        <tag>two pointers</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[349. Intersection of Two Arrays]]></title>
    <url>%2Fp%2Fa9978d3a%2F</url>
    <content type="text"><![CDATA[46.2% https://leetcode.com/problems/intersection-of-two-arrays/?tab=Description Given two arrays, write a function to compute their intersection. 12Example:Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note: Each element in the result must be unique. The result can be in any order. 方法一： 先排序，然后双指针遍历 12ms, 42.46%, June.5th, 2016 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; std::sort(nums1.begin(), nums1.end()); std::sort(nums2.begin(), nums2.end()); vector&lt;int&gt; ans; int i=0, j=0; while(i&lt;nums1.size() &amp;&amp; j&lt;nums2.size())&#123; if(nums1[i] &lt; nums2[j]) i++; else if(nums1[i] &gt; nums2[j]) j++; else &#123; if(!ans.size() ||ans.back() != nums1[i]) ans.push_back(nums1[i]); i++; j++; &#125; &#125; return ans; &#125;&#125;; 方法二： 一个list转为set，另一个遍历去set里找，找到加入res， 并且从set中删除。 12345678vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; set&lt;int&gt; s(nums1.begin(), nums1.end()); vector&lt;int&gt; out; for (int x : nums2) if (s.erase(x)) out.push_back(x); return out;&#125; 方法三： 一个建立hash表，遍历另一个，在表里，就加入res，从表里删除。 cpp https://discuss.leetcode.com/topic/45846/small-c-solution 12345678vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; set&lt;int&gt; s(nums1.begin(), nums1.end()); vector&lt;int&gt; out; for (int x : nums2) if (s.erase(x)) out.push_back(x); return out;&#125; https://leetcode.com/discuss/103224/my-c-solution-with-sort 12ms, 42.46%, June.5th, 2016 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; std::sort(nums1.begin(), nums1.end()); std::sort(nums2.begin(), nums2.end()); vector&lt;int&gt; ans; int i=0, j=0; while(i&lt;nums1.size() &amp;&amp; j&lt;nums2.size())&#123; if(nums1[i] &lt; nums2[j]) i++; else if(nums1[i] &gt; nums2[j]) j++; else &#123; if(!ans.size() ||ans.back() != nums1[i]) ans.push_back(nums1[i]); i++; j++; &#125; &#125; return ans; &#125;&#125;; https://leetcode.com/discuss/103365/8ms-concise-c-using-unordered_set 16ms, 17.41%, June.5th, 2016 8ms concise C++ using unordered_set 1234567891011121314class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_set&lt;int&gt; m(nums1.begin(), nums1.end()); vector&lt;int&gt; ans; for(auto a:nums2)&#123; if(m.count(a))&#123; ans.push_back(a); m.erase(a); &#125; &#125; return ans; &#125;&#125;; pythonSolution Mine: 52ms, 60 / 60, 76.78%, June.5th, 2016 1234567891011class Solution(object): def intersection(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; nums1 = set(nums1) nums2 = set(nums2) rtype = [i for i in nums1 if i in nums2] return rtype Solution 1: https://leetcode.com/discuss/103709/python-code-3-lines-using-set June.5th, 2016 12345678910class Solution(object):def intersection(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; nums1=set(nums1) nums2=set(nums2) return list(nums1&amp;nums2) Solution 2: https://leetcode.com/discuss/103709/python-code-3-lines-using-set 12345678class Solution(object): def intersection(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; return list(set(nums1) &amp; set(nums2)) https://discuss.leetcode.com/topic/45727/four-python-solutions-with-simple-explanation Solution 1: use set operation in python, one-line solution.12345678class Solution(object):def intersection(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; return list(set(nums1) &amp; set(nums2)) Solution 2: brute-force searching, search each element of the first list in the second list. (to be more efficient, you can sort the second list and use binary search to accelerate) 1234567891011class Solution(object):def intersection(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; res = [] for i in nums1: if i not in res and i in nums2: res.append(i) return res Solution 3: use dict/hashmap to record all nums appeared in the first list, and then check if there are nums in the second list have appeared in the map. 1234567891011121314151617class Solution(object):def intersection(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; res = [] map = &#123;&#125; for i in nums1: map[i] = map[i]+1 if i in map else 1 for j in nums2: if j in map and map[j] &gt; 0: res.append(j) map[j] = 0 return res Solution 4: sort the two list, and use two pointer to search in the lists to find common elements. 1234567891011121314151617181920212223class Solution(object):def intersection(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; res = [] nums1.sort() nums2.sort() i = j = 0 while (i &lt; len(nums1) and j &lt; len(nums2)): if nums1[i] &gt; nums2[j]: j += 1 elif nums1[i] &lt; nums2[j]: i += 1 else: if not (len(res) and nums1[i] == res[len(res)-1]): res.append(nums1[i]) i += 1 j += 1 return res javahttps://discuss.leetcode.com/topic/45685/three-java-solutions 7ms, 34.67%, June.5th, 2016 Use two hash sets Time complexity: O(n) 1234567891011121314151617181920public class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Set&lt;Integer&gt; intersect = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nums1.length; i++) &#123; set.add(nums1[i]); &#125; for (int i = 0; i &lt; nums2.length; i++) &#123; if (set.contains(nums2[i])) &#123; intersect.add(nums2[i]); &#125; &#125; int[] result = new int[intersect.size()]; int i = 0; for (Integer num : intersect) &#123; result[i++] = num; &#125; return result; &#125;&#125; https://discuss.leetcode.com/topic/45685/three-java-solutions Sort both arrays, use two pointers Time complexity: O(nlogn) 1234567891011121314151617181920212223242526public class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Arrays.sort(nums1); Arrays.sort(nums2); int i = 0; int j = 0; while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123; if (nums1[i] &lt; nums2[j]) &#123; i++; &#125; else if (nums1[i] &gt; nums2[j]) &#123; j++; &#125; else &#123; set.add(nums1[i]); i++; j++; &#125; &#125; int[] result = new int[set.size()]; int k = 0; for (Integer num : set) &#123; result[k++] = num; &#125; return result; &#125;&#125; https://discuss.leetcode.com/topic/45685/three-java-solutions Binary search Time complexity: O(nlogn) 12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Arrays.sort(nums2); for (Integer num : nums1) &#123; if (binarySearch(nums2, num)) &#123; set.add(num); &#125; &#125; int i = 0; int[] result = new int[set.size()]; for (Integer num : set) &#123; result[i++] = num; &#125; return result; &#125; public boolean binarySearch(int[] nums, int target) &#123; int low = 0; int high = nums.length - 1; while (low &lt;= high) &#123; int mid = low + (high - low) / 2; if (nums[mid] == target) &#123; return true; &#125; if (nums[mid] &gt; target) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; return false; &#125;&#125; https://discuss.leetcode.com/topic/45879/5ms-java-using-1-hashset-and-time-complexity-of-o-m-n12345678910111213141516171819public class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); //Add all elements to set from array 1 for(int i =0; i&lt; nums1.length; i++) set.add(nums1[i]); for(int j = 0; j &lt; nums2.length; j++) &#123; // If present in array 2 then add to res and remove from set if(set.contains(nums2[j])) &#123; res.add(nums2[j]); set.remove(nums2[j]); &#125; &#125; // Convert ArrayList to array int[] arr = new int[res.size()]; for (int i= 0; i &lt; res.size(); i++) arr[i] = res.get(i); return arr; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
        <tag>binary search</tag>
        <tag>two pointers</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[347. Top K Frequent Elements]]></title>
    <url>%2Fp%2Fde71a042%2F</url>
    <content type="text"><![CDATA[46.8% https://leetcode.com/problems/top-k-frequent-elements/#/description Given a non-empty array of integers, return the k most frequent elements. 12For example,Given [1,1,1,2,2,3] and k = 2, return [1,2]. Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size. 方法一： 使用map，存放number和frequency，使用最大堆，存入最大堆。当堆大于一定值时，把堆的top值的相关信息存入res。 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int,int&gt; map; for(int num : nums)&#123; map[num]++; &#125; vector&lt;int&gt; res; // pair&lt;first, second&gt;: first is frequency, second is number priority_queue&lt;pair&lt;int,int&gt;&gt; pq; for(auto it = map.begin(); it != map.end(); it++)&#123; pq.push(make_pair(it-&gt;second, it-&gt;first)); if(pq.size() &gt; (int)map.size() - k)&#123; res.push_back(pq.top().second); pq.pop(); &#125; &#125; return res; &#125;&#125;; 我的代码实现： 类似于leetcode 30 使用heap 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; map; for(auto num:nums) map[num]++; vector&lt;pair&lt;int, int&gt;&gt; v; // pair的定义学习 for(auto kv : map) v.push_back(make_pair(kv.first, kv.second)); // 学习make_pair函数 vector&lt;pair&lt;int, int&gt;&gt; res(v.begin(), v.begin()+k); for(int i=(k-2)/2; i&gt;=0; i--)&#123; miniheapify(res, i, k-1); &#125; int n = v.size(); for(int i=k; i&lt;n; i++)&#123; if(v[i].second &gt; res[0].second)&#123; res[0] = v[i]; miniheapify(res, 0, k-1); &#125; &#125; vector&lt;int&gt; ans; for(auto pr: res) ans.push_back(pr.first); return ans; &#125; void miniheapify(vector&lt;pair&lt;int,int&gt;&gt;&amp; res, int start, int end)&#123; if(start==end) return; int parent = start; int child = 2 * parent + 1; while(child &lt;= end)&#123; if(child+1 &lt;= end &amp;&amp; res[child+1].second &lt; res[child].second) child += 1; if(res[parent].second&gt;res[child].second)&#123; swap(res[parent], res[child]); parent = child; child = 2*parent+1; &#125;else&#123; break; &#125; &#125; &#125;&#125;; 方法二： 先得到一个map，key为值，value为个数。然后依照value进行排序，类似于剑指offer 30题。 不同的是此处麻烦一些，要用到pair，逻辑是一样的。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; map; for(auto num:nums) map[num]++; vector&lt;pair&lt;int, int&gt;&gt; v; // pair的定义学习 for(auto kv : map) v.push_back(make_pair(kv.first, kv.second)); // 学习make_pair函数 int start = 0, end = v.size()-1; int pos = partition(v, start, end); while(pos != k-1)&#123; if(pos &gt; k-1) end = pos - 1; else start = pos + 1; pos = partition(v, start, end); &#125; vector&lt;int&gt; res; for(int i=0; i&lt;k; i++) res.push_back(v[i].first); return res; &#125; int partition(vector&lt;pair&lt;int, int&gt;&gt;&amp; v, int start, int end)&#123; if(start == end) return start; int pos = start - 1; for(int i=start; i&lt;end; i++)&#123; // 注意：此处为start， 不是0 if(v[i].second &gt; v[end].second) swap(v[i], v[++pos]); &#125; swap(v[end], v[++pos]); return pos; &#125;&#125;; 40ms, , 20/20, May.3rd, 2016 https://leetcode.com/discuss/100562/o-log-k-unordered_map-and-priority_queue-maxheap-solution C++ O(n log(n-k)) unordered_map and priority_queue(maxheap) solution 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int,int&gt; map; for(int num : nums)&#123; map[num]++; &#125; vector&lt;int&gt; res; // pair&lt;first, second&gt;: first is frequency, second is number priority_queue&lt;pair&lt;int,int&gt;&gt; pq; for(auto it = map.begin(); it != map.end(); it++)&#123; pq.push(make_pair(it-&gt;second, it-&gt;first)); if(pq.size() &gt; (int)map.size() - k)&#123; res.push_back(pq.top().second); pq.pop(); &#125; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/44337/simple-c-solution-using-hash-table-and-bucket-sort Simple C++ solution using hash table and bucket sort 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; m; for (int num : nums) ++m[num]; vector&lt;vector&lt;int&gt;&gt; buckets(nums.size() + 1); for (auto p : m) buckets[p.second].push_back(p.first); vector&lt;int&gt; ans; for (int i = buckets.size() - 1; i &gt;= 0 &amp;&amp; ans.size() &lt; k; --i) &#123; for (int num : buckets[i]) &#123; ans.push_back(num); if (ans.size() == k) break; &#125; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/44313/3-ways-to-solve-this-problem 3 ways to solve this problem using heap 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; unordered_map&lt;int, int&gt; cnt; for (auto num : nums) cnt[num]++; for (auto kv : cnt) &#123; pq.push(&#123;kv.second, kv.first&#125;); while (pq.size() &gt; k) pq.pop(); &#125; vector&lt;int&gt; res; while (!pq.empty()) &#123; res.push_back(pq.top().second); pq.pop(); &#125; return res; &#125;&#125;; using selection algorithm 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; if (!nums.size()) return res; unordered_map&lt;int, int&gt; cnt; for (auto num : nums) cnt[num]++; vector&lt;pair&lt;int, int&gt;&gt; num_with_cnt; for (auto kv : cnt) &#123; num_with_cnt.push_back(&#123;kv.first, kv.second&#125;); &#125; kselection(num_with_cnt, 0, num_with_cnt.size()-1, k); for (int i = 0; i &lt; k &amp;&amp; i &lt; num_with_cnt.size(); ++i) &#123; res.push_back(num_with_cnt[i].first); &#125; return res; &#125; void kselection(vector&lt;pair&lt;int, int&gt;&gt;&amp; data, int start, int end, int k) &#123; if (start &gt;= end) return; auto pv = data[end]; int i = start; int j = start; while (i &lt; end) &#123; if (data[i].second &gt; pv.second) &#123; swap(data[i++], data[j++]); &#125; else &#123; ++i; &#125; &#125; swap(data[j], data[end]); int num = j - start + 1; if (num == k) return; else if (num &lt; k) &#123; kselection(data, j + 1, end, k - num); &#125; else &#123; kselection(data, start, j - 1, k); &#125; &#125;&#125;; using bucket sort 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; if (!nums.size()) return res; unordered_map&lt;int, int&gt; cnt; for (auto num : nums) cnt[num]++; vector&lt;vector&lt;int&gt;&gt; bucket(nums.size() + 1); for (auto kv : cnt) &#123; bucket[kv.second].push_back(kv.first); &#125; for (int i = bucket.size() - 1; i &gt;= 0; --i) &#123; for (int j = 0; j &lt; bucket[i].size(); ++j)&#123; res.push_back(bucket[i][j]); if (res.size() == k) return res; &#125; &#125; return res; &#125;&#125;; Mine Solution: 92ms, , May.3rd, 2016 123class Solution(object): def topKFrequent(self, nums, k): return [key for key, value in collections.Counter(nums).most_common(k)] Solution 1: https://leetcode.com/discuss/100553/1-line-python-solution-using-counter-most_common-method 123class Solution(object): def topKFrequent(self, nums, k): return [item[0] for item in collections.Counter(nums).most_common(k)] https://discuss.leetcode.com/topic/44237/java-o-n-solution-bucket-sort Java O(n) Solution - Bucket Sort Idea is simple. Build a array of list to be buckets with length 1 to sort. 1234567891011121314151617181920212223242526public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt;[] bucket = new List[nums.length + 1]; Map&lt;Integer, Integer&gt; frequencyMap = new HashMap&lt;Integer, Integer&gt;(); for (int n : nums) &#123; frequencyMap.put(n, frequencyMap.getOrDefault(n, 0) + 1); &#125; for (int key : frequencyMap.keySet()) &#123; int frequency = frequencyMap.get(key); if (bucket[frequency] == null) &#123; bucket[frequency] = new ArrayList&lt;&gt;(); &#125; bucket[frequency].add(key); &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int pos = bucket.length - 1; pos &gt;= 0 &amp;&amp; res.size() &lt; k; pos--) &#123; if (bucket[pos] != null) &#123; res.addAll(bucket[pos]); &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/48158/3-java-solution-using-array-maxheap-treemap 3 Java Solution using Array, MaxHeap, TreeMap use an array to save numbers into different bucket whose index is the frequency 12345678910111213141516171819202122232425262728public class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int n: nums)&#123; map.put(n, map.getOrDefault(n,0)+1); &#125; // corner case: if there is only one number in nums, we need the bucket has index 1. List&lt;Integer&gt;[] bucket = new List[nums.length+1]; for(int n:map.keySet())&#123; int freq = map.get(n); if(bucket[freq]==null) bucket[freq] = new LinkedList&lt;&gt;(); bucket[freq].add(n); &#125; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); for(int i=bucket.length-1; i&gt;0 &amp;&amp; k&gt;0; --i)&#123; if(bucket[i]!=null)&#123; List&lt;Integer&gt; list = bucket[i]; res.addAll(list); k-= list.size(); &#125; &#125; return res; &#125;&#125; use maxHeap. Put entry into maxHeap so we can always poll a number with largest frequency 123456789101112131415161718192021public class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int n: nums)&#123; map.put(n, map.getOrDefault(n,0)+1); &#125; PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; maxHeap = new PriorityQueue&lt;&gt;((a,b)-&gt;(b.getValue()-a.getValue())); for(Map.Entry&lt;Integer,Integer&gt; entry: map.entrySet())&#123; maxHeap.add(entry); &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while(res.size()&lt;k)&#123; Map.Entry&lt;Integer, Integer&gt; entry = maxHeap.poll(); res.add(entry.getKey()); &#125; return res; &#125;&#125; use treeMap. Use freqncy as the key so we can get all freqencies in order 123456789101112131415161718192021222324public class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int n: nums)&#123; map.put(n, map.getOrDefault(n,0)+1); &#125; TreeMap&lt;Integer, List&lt;Integer&gt;&gt; freqMap = new TreeMap&lt;&gt;(); for(int num : map.keySet())&#123; int freq = map.get(num); if(!freqMap.containsKey(freq))&#123; freqMap.put(freq, new LinkedList&lt;&gt;()); &#125; freqMap.get(freq).add(num); &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while(res.size()&lt;k)&#123; Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry = freqMap.pollLastEntry(); res.addAll(entry.getValue()); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>hash table</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[345. Reverse Vowels of a String]]></title>
    <url>%2Fp%2Fa758eca4%2F</url>
    <content type="text"><![CDATA[38.6% https://leetcode.com/problems/reverse-vowels-of-a-string/description/ Write a function that takes a string as input and reverse only the vowels of a string. 12345Example 1:Given s = &quot;hello&quot;, return &quot;holle&quot;.Example 2:Given s = &quot;leetcode&quot;, return &quot;leotcede&quot;. Note: The vowels does not include the letter “y”. 方法一： 双指针 1234567891011121314class Solution &#123;public: string reverseVowels(string s) &#123; if(s.empty()) return s; unordered_set&lt;char&gt; set = &#123;'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'&#125;; int i=0, j=s.size()-1; while(i&lt;j)&#123; while(i&lt;j &amp;&amp; set.find(s[i])==set.end()) i++; while(i&lt;j &amp;&amp; set.find(s[j])==set.end()) j--; swap(s[i++], s[j--]); &#125; return s; &#125;&#125;; 方法二： 使用find_first_of和find_last_of函数，效果更好。 12ms, , April.24th, 2016 https://leetcode.com/discuss/99047/super-clean-solution-using-find_first_of-and-find_last_of 123456789101112class Solution &#123;public: string reverseVowels(string s) &#123; int i = 0, j = s.size() - 1; while (i &lt; j) &#123; i = s.find_first_of(&quot;aeiouAEIOU&quot;, i); j = s.find_last_of(&quot;aeiouAEIOU&quot;, j); if (i &lt; j) swap(s[i++], s[j--]); &#125; return s; &#125;&#125;; 我的代码实现： 12345678910111213class Solution &#123;public: string reverseVowels(string s) &#123; if(s.empty()) return s; int i=0, j=s.size()-1; while(i&lt;j)&#123; i = s.find_first_of("aeiouAEIOU", i); j = s.find_last_of("aeiouAEIOU", j); if(i&lt;j) swap(s[i++], s[j--]); // 更新之后，要改变i和j的值，不能忘了 &#125; return s; &#125;&#125;; pythonSolution mine: 144ms, , April.24th, 2016 1234567891011121314151617181920class Solution(object): def reverseVowels(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; l = 0 r = len(s) - 1 s = list(s) vowels = &apos;aeiouAEIOU&apos; while l &lt; r: if s[l] in vowels and s[r] in vowels: s[l], s[r] = s[r], s[l] l += 1 r -= 1 elif s[l] not in vowels: l += 1 else: r -= 1 return &apos;&apos;.join(s) 104ms, ,April.24th, 2016 https://leetcode.com/discuss/98983/python-2-pointers-solution Python 2 Pointers Solution The idea is really simple. But I think my code is somewhat ugly in two ways: Convert string to list then convert back Pointer processing is verbose. 123456789101112131415class Solution(object): def reverseVowels(self, s): vowels = set([&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;, &apos;A&apos;, &apos;E&apos;, &apos;I&apos;, &apos;O&apos;, &apos;U&apos;]) s = list(s) ptr_1, ptr_2 = 0, len(s) - 1 while ptr_1 &lt; ptr_2: if s[ptr_1] in vowels and s[ptr_2] in vowels: s[ptr_1], s[ptr_2] = s[ptr_2], s[ptr_1] ptr_1 += 1 ptr_2 -= 1 if s[ptr_1] not in vowels: ptr_1 += 1 if s[ptr_2] not in vowels: ptr_2 -= 1 return &apos;&apos;.join(s) javahttps://discuss.leetcode.com/topic/43412/java-standard-two-pointer-solution In the inner while loop, don’t forget the condition “start less than end” while incrementing start and decrementing end. This is my friend’s google phone interview question. Cheers! update! May use a HashSet to reduce the look up time to O(1) 19ms, 17.67%123456789101112131415161718192021222324252627public class Solution &#123; public String reverseVowels(String s) &#123; if(s == null || s.length()==0) return s; String vowels = &quot;aeiouAEIOU&quot;; char[] chars = s.toCharArray(); int start = 0; int end = s.length()-1; while(start&lt;end)&#123; while(start&lt;end &amp;&amp; !vowels.contains(chars[start]+&quot;&quot;))&#123; start++; &#125; while(start&lt;end &amp;&amp; !vowels.contains(chars[end]+&quot;&quot;))&#123; end--; &#125; char temp = chars[start]; chars[start] = chars[end]; chars[end] = temp; start++; end--; &#125; return new String(chars); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[344. Reverse String]]></title>
    <url>%2Fp%2Fbaee5d2f%2F</url>
    <content type="text"><![CDATA[59.4% https://leetcode.com/problems/reverse-string/ Write a function that takes a string as input and returns the string reversed. 12Example:Given s = &quot;hello&quot;, return &quot;olleh&quot;. 方法一： 我的代码实现： 12345678910111213class Solution &#123;public: string reverseString(string s) &#123; if(s.empty()) return s; int l=0, r=s.size()-1; while(l&lt;r)&#123; swap(s[l], s[r]); l++; r--; &#125; return s; &#125;&#125;; 12ms, Apr.23rd, 2016 12345678910class Solution &#123;public: string reverseString(string s) &#123; int i = 0, j = s.size() - 1; while(i &lt; j)&#123; swap(s[i++], s[j--]); &#125; return s; &#125;&#125;; pythonhttps://discuss.leetcode.com/topic/58719/python-3-solutions-recursive-classic-pythonic 123456789101112131415161718192021222324# recursiveclass Solution(object): def reverseString(self, s): l = len(s) if l &lt; 2: return s return self.reverseString(s[l/2:]) + self.reverseString(s[:l/2])# classicclass SolutionClassic(object): def reverseString(self, s): r = list(s) i, j = 0, len(r) - 1 while i &lt; j: r[i], r[j] = r[j], r[i] i += 1 j -= 1 return &quot;&quot;.join(r)# pythonicclass SolutionPythonic(object): def reverseString(self, s): return s[::-1] javahttps://discuss.leetcode.com/topic/43296/java-simple-and-clean-with-explanations-6-solutions https://discuss.leetcode.com/topic/43296/java-simple-and-clean-with-explanations-6-solutions https://discuss.leetcode.com/topic/44869/java-easiest-method-2-line-code-attached-another-method https://discuss.leetcode.com/topic/43305/java-swapping-char-array]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[343. Integer Break]]></title>
    <url>%2Fp%2F91031138%2F</url>
    <content type="text"><![CDATA[45.3% https://leetcode.com/problems/integer-break/#/description Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get. For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4). Note: You may assume that n is not less than 2 and not larger than 58. Hint: There is a simple O(n) solution to this problem. You may check the breaking results of n ranging from 7 to 10 to discover the regularities. cpp0ms, , April.24, 2016 https://leetcode.com/discuss/98249/easy-to-understand-c-with-explanation 1234567891011class Solution &#123;public: int integerBreak(int n) &#123; if(n == 2) return 1; if(n == 3) return 2; if(n == 4) return 4; if(n == 5) return 6; if(n == 6) return 9; return 3 * integerBreak(n - 3); &#125;&#125;; python63ms, , April.24th, 2016 1234567class Solution(object): def integerBreak(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; return n - 1 if n &lt; 4 else 3 ** ((n-2)/3) * ((n-2)%3 + 2)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[342. Power of Four]]></title>
    <url>%2Fp%2F8d7568a5%2F</url>
    <content type="text"><![CDATA[37.9% https://leetcode.com/problems/power-of-four/#/description Given an integer (signed 32 bits), write a function to check whether it is a power of 4. 12Example:Given num = 16, return true. Given num = 5, return false. Follow up: Could you solve it without loops/recursion? 以0x开始的数据表示16进制，计算机中每位的权为16，即（16进制)10 = (10进制)1×16 方法一： Simplest C++ solution maybe? 2的幂 满足 num&amp;(num-1) == 0 0x 是零和x，表示十六进制 123456class Solution &#123;public: bool isPowerOfFour(int num) &#123; return !(num &amp; (num - 1)) &amp;&amp; (num &amp; 0x55555555); &#125;&#125;; 其他实现 O(1) one-line solution without loops 12345public class Solution &#123; public boolean isPowerOfFour(int num) &#123; return (num &gt; 0) &amp;&amp; ((num &amp; (num - 1)) == 0) &amp;&amp; ((num &amp; 0x55555555) == num); &#125;&#125; The basic idea is from power of 2, We can use “n&amp;(n-1) == 0” to determine if n is power of 2. For power of 4, the additional restriction is that in binary form, the only “1” should always located at the odd position. For example, 4^0 = 1, 4^1 = 100, 4^2 = 10000. So we can use “num &amp; 0x55555555==num” to check if “1” is located at the odd position. 方法二： 我的代码实现： 12345678class Solution &#123;public: bool isPowerOfFour(int num) &#123; // &amp; == 优先级 // '==' &gt; '!=' &gt; '&amp;' &gt; '^' &gt; '!' return num&gt;0 &amp;&amp; (num&amp;(num-1))==0 &amp;&amp; (num-1)%3==0; &#125;&#125;; 123456class Solution &#123;public: bool isPowerOfFour(int num) &#123; return ((num-1)&amp;num)==0 &amp;&amp; (num-1)%3==0; &#125;&#125;; It means that binary representation of 4, 16 etc. will be 4 = 0100, 16 = 00010000. If you subtract 1 from 4, 16, …. you will get something like 0011 for 4 and 00001111 for 16. Finally when you make &amp; you check that all the right bits is zero(it is one of the properties of numbers that is power of four). https://discuss.leetcode.com/topic/42914/1-line-c-solution-without-confusing-bit-manipulations 1 line C++ solution without confusing bit manipulations 123bool isPowerOfFour(int num) &#123; return num &gt; 0 &amp;&amp; (num &amp; (num - 1)) == 0 &amp;&amp; (num - 1) % 3 == 0;&#125; https://discuss.leetcode.com/topic/42855/o-1-one-line-solution-without-loops O(1) one-line solution without loops 12345public class Solution &#123; public boolean isPowerOfFour(int num) &#123; return (num &gt; 0) &amp;&amp; ((num &amp; (num - 1)) == 0) &amp;&amp; ((num &amp; 0x55555555) == num); &#125;&#125; The basic idea is from power of 2, We can use “n&amp;(n-1) == 0” to determine if n is power of 2. For power of 4, the additional restriction is that in binary form, the only “1” should always located at the odd position. For example, 4^0 = 1, 4^1 = 100, 4^2 = 10000. So we can use “num &amp; 0x55555555==num” to check if “1” is located at the odd position. https://discuss.leetcode.com/topic/44430/simple-c-o-1-solution-without-0x55555555 Simple C++ O(1) solution without 0x55555555 123456class Solution &#123;public: bool isPowerOfFour(int num) &#123; return ((num-1)&amp;num)==0 &amp;&amp; (num-1)%3==0; &#125;&#125;; https://discuss.leetcode.com/topic/43801/simplest-c-solution-maybe Simplest C++ solution maybe? 123456class Solution &#123;public: bool isPowerOfFour(int num) &#123; return !(num &amp; (num - 1)) &amp;&amp; (num &amp; 0x55555555); &#125;&#125;; https://discuss.leetcode.com/topic/45946/c-simple-code-with-comments-no-loops-recursion C++ simple code with comments (no loops/recursion) Idea is simple. Powers of four are 1, 4, 16.. or in binary, 0x0001, 0x0100, etc. Only one bit is ever set, and it’s always an odd bit. So simply check for that… This does not use any loops or recursion, is O(1) time and O(1) space. 12345678910class Solution &#123;public: bool isPowerOfFour(int num) &#123; // first check only one bit is set: if ((num &amp; (num -1)) != 0) return false; // next check if it&apos;s a bit in pos 1, 3, 5 ... 31 if (num &amp; 0x55555555) return true; return false; &#125;&#125;; https://discuss.leetcode.com/topic/42865/python-one-line-solution-with-explanations Python one line solution with explanations 12def isPowerOfFour(self, num): return num != 0 and num &amp;(num-1) == 0 and num &amp; 1431655765== num Consider the valid numbers within 32 bit, and turn them into binary form, they are: 123456789101112131415161100100001000000100000000100000000001000000000000100000000000000100000000000000001000000000000000000100000000000000000000100000000000000000000001000000000000000000000000100000000000000000000000000100000000000000000000000000001000000000000000000000000000000 Any other number not it the list should be considered as invalid.So if you XOR them altogether, you will get a mask value, which is: 11010101010101010101010101010101 (1431655765) Any number which is power of 4, it should be power of 2, I use num &amp;(num-1) == 0 to make sure of that.Obviously 0 is not power of 4, I have to check it.and finally I need to check that if the number ‘AND’ the mask value is itself, to make sure it’s in the list above. here comes the final code: return num != 0 and num &amp;(num-1) == 0 and num &amp; 1431655765== num]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[341. Flatten Nested List Iterator]]></title>
    <url>%2Fp%2Fc0e574ed%2F</url>
    <content type="text"><![CDATA[40.0% https://leetcode.com/problems/flatten-nested-list-iterator/#/description Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list – whose elements may also be integers or other lists. 1234Example 1:Given the list [[1,1],2,[1,1]],By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. 1234Example 2:Given the list [1,[4,[6]]],By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. Real iterator in Python, Java, C++ In my opinion an iterator shouldn’t copy the entire data (which some solutions have done) but just iterate over the original data structure. I keep the current progress in a stack. My hasNext tries to find an integer. My next returns it and moves on. I call hasNext in next because hasNext is optional. Some user of the iterator might call only next and never hasNext, e.g., if they know how many integers are in the structure or if they want to handle the ending with exception handling. Python Using a stack of [list, index] pairs. 123456789101112131415161718192021222324class NestedIterator(object): def __init__(self, nestedList): self.stack = [[nestedList, 0]] def next(self): self.hasNext() nestedList, i = self.stack[-1] self.stack[-1][1] += 1 return nestedList[i].getInteger() def hasNext(self): s = self.stack while s: nestedList, i = s[-1] if i == len(nestedList): s.pop() else: x = nestedList[i] if x.isInteger(): return True s[-1][1] += 1 s.append([x.getList(), 0]) return False Java Using a stack of ListIterators. 12345678910111213141516171819202122232425262728public class NestedIterator implements Iterator&lt;Integer&gt; &#123; public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123; lists = new Stack&lt;&gt;(); lists.push(nestedList.listIterator()); &#125; public Integer next() &#123; hasNext(); return lists.peek().next().getInteger(); &#125; public boolean hasNext() &#123; while (!lists.empty()) &#123; if (!lists.peek().hasNext()) &#123; lists.pop(); &#125; else &#123; NestedInteger x = lists.peek().next(); if (x.isInteger()) return lists.peek().previous() == x; lists.push(x.getList().listIterator()); &#125; &#125; return false; &#125; private Stack&lt;ListIterator&lt;NestedInteger&gt;&gt; lists;&#125; C++ Using stacks of begin and end iterators. 1234567891011121314151617181920212223242526272829303132class NestedIterator &#123;public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123; begins.push(nestedList.begin()); ends.push(nestedList.end()); &#125; int next() &#123; hasNext(); return (begins.top()++)-&gt;getInteger(); &#125; bool hasNext() &#123; while (begins.size()) &#123; if (begins.top() == ends.top()) &#123; begins.pop(); ends.pop(); &#125; else &#123; auto x = begins.top(); if (x-&gt;isInteger()) return true; begins.top()++; begins.push(x-&gt;getList().begin()); ends.push(x-&gt;getList().end()); &#125; &#125; return false; &#125;private: stack&lt;vector&lt;NestedInteger&gt;::iterator&gt; begins, ends;&#125;; https://discuss.leetcode.com/topic/41846/concise-c-without-storing-all-values-at-initialization Concise C++ without storing all values at initialization 123456789101112131415161718192021222324252627282930313233343536class NestedIterator &#123;private: stack&lt;NestedInteger&gt; nodes; public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123; int size = nestedList.size(); for(int i = size - 1; i &gt;= 0; --i) &#123; nodes.push(nestedList[i]); &#125; &#125;int next() &#123; int result = nodes.top().getInteger(); nodes.pop(); return result;&#125;bool hasNext() &#123; while(!nodes.empty()) &#123; NestedInteger curr = nodes.top(); if(curr.isInteger()) &#123; return true; &#125; nodes.pop(); vector&lt;NestedInteger&gt;&amp; adjs = curr.getList(); int size = adjs.size(); for(int i = size - 1; i &gt;= 0; --i) &#123; nodes.push(adjs[i]); &#125; &#125; return false; &#125;&#125;; The same idea as a DFS, the only tricky part probably is you have to find a value node to claim there is next. And to do that, you have to look through all the nodes in the worst case in the entire graph. So you just keep going until you find a value node; if you can’t, there is no next. https://discuss.leetcode.com/topic/45844/python-generators-solution Python Generators solution 123456789101112131415161718192021class NestedIterator(object): def __init__(self, nestedList): def gen(nestedList): for x in nestedList: if x.isInteger(): yield x.getInteger() else: for y in gen(x.getList()): yield y self.gen = gen(nestedList) def next(self): return self.value def hasNext(self): try: self.value = next(self.gen) return True except StopIteration: return False This assumes that the iterator is just used as described in the problem. Usually, hasNext should be both optional and idempotent, but a next+hasNext iterator is very unpythonic anyway, so I decided to not do that here, as I feel it would distract from the generator. And of course while this solution is (IMHO) somewhat cute, it passes each value through each level it’s nested in, so it’s not efficient. 32ms, , 44/44, April.24th, 2016 https://leetcode.com/discuss/98689/simple-cpp-solution 1234567891011121314151617181920212223242526class NestedIterator &#123;public: vector&lt;int&gt; a; int index = 0; NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123; convert(nestedList, nestedList.size()); &#125; void convert(vector&lt;NestedInteger&gt; &amp;nestedList, int size)&#123; int i; for(i = 0; i &lt; size; i++)&#123; if(nestedList[i].isInteger()) a.push_back(nestedList[i].getInteger()); else convert(nestedList[i].getList(), nestedList[i].getList().size()); &#125; &#125; int next() &#123; return a[index++]; &#125; bool hasNext() &#123; if(index &lt; a.size()) return 1; return 0; &#125;&#125;; 124ms, , 44/44, April.24th, 2016 https://leetcode.com/discuss/98134/share-my-cpp-and-python-solution-with-recursion 1234567891011121314151617181920212223242526272829303132333435363738class NestedIterator(object): def __init__(self, nestedList): self.my_list = [] self.index = 0 for i in nestedList: if i.isInteger() == True: self.my_list.append(i.getInteger()) else: self.read_list(i.getList()) &quot;&quot;&quot; Initialize your data structure here. :type nestedList: List[NestedInteger] &quot;&quot;&quot; def read_list(self,l): for i in l: if i.isInteger() == True: self.my_list.append(i.getInteger()) else: self.read_list(i.getList()) def next(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; re = self.my_list[self.index] self.index += 1 return re def hasNext(self): &quot;&quot;&quot; :rtype: bool &quot;&quot;&quot; if self.index == len(self.my_list): return False return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[338. Counting Bits]]></title>
    <url>%2Fp%2F3d05b48f%2F</url>
    <content type="text"><![CDATA[60.0% https://leetcode.com/problems/counting-bits/ Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. 123Example:For num = 5 you should return [0,1,1,2,1,2]. Follow up: It is very easy to come up with a solution with run time O(n* sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n). Can you do it like a boss? Do it without using any builtin function like __ builtin_popcount in c++ or in any other language. Hint: You should make use of what you have produced already. Divide the numbers in ranges like [2-3], [4-7], [8-15] and so on. And try to generate new range from previous. Or does the odd/even status of the number help you in calculating the number of 1s? 方法一： i&amp;(i-1) 是消除最小的一位1，取其个数，再加1。 考虑的是两段，最小的一位1，与这位1更新为0的数字，两段的个数的和。 12345678910class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; res(num+1, 0); for(int i=1; i&lt;=num; i++)&#123; res[i] = res[i&amp;(i-1)] + 1; &#125; return res; &#125;&#125;; 方法二： 分两段求个数，一段是最后一位，一段是除最后一位的前一段。 1234567891011class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; res(num+1, 0); res[1] = 1; for(int i=2; i&lt;=num; i++)&#123; res[i] = res[i%2] + res[i/2]; &#125; return res; &#125;&#125;; cpphttps://discuss.leetcode.com/topic/40262/four-lines-c-time-o-n-space-o-n Four lines, C++, time O(n), space O(n) 位运算 i&amp;(i-1)可以出掉最低位的一位1. i&amp;(i-1) drops the lowest set bit. For example: i = 14, its binary representation is 1110, so i-1 is 1101, i&amp;(i-1) = 1100, the number of “1” in its binary representation decrease one, so ret[i] = ret[i&amp;(i-1)] + 1. (Sorry, my English is so poor and I have tried my best to make it clearly, I hope you can understand my explanation) 12345678910class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; result(num+1, 0); result[0] = 0; for(int i=1; i&lt;=num; i++) result[i] += result[i&amp;(i-1)] + 1; return result; &#125;&#125;; 124ms, April.24th, 2016 1234567891011class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; result(num+1, 0); result[0] = 0; int i; for(i = 1; i &lt;= 2; i++) result[i] = 1; for(i = 3; i &lt;= num; i++) result[i] = result[i/2] + result[i%2]; return result; &#125;&#125;; pythonhttps://discuss.leetcode.com/topic/45331/simple-python-solution Simple Python Solution Code works by constantly extending a list with itself but with the values incremented by 1. Simple python solution that runs in O(n) time. Let me know if there are any ways to improve it. 12345678910111213def countBits(self, num): &quot;&quot;&quot; :type num: int :rtype: List[int] &quot;&quot;&quot; iniArr = [0] if num &gt; 0: amountToAdd = 1 while len(iniArr) &lt; num + 1: iniArr.extend([x+1 for x in iniArr]) return iniArr[0:num+1] A four liner that does the same thing as above. The above had a few redundancies. 1234567891011def countBits(self, num): &quot;&quot;&quot; :type num: int :rtype: List[int] &quot;&quot;&quot; answer = [0, 1] while len(answer) &lt;= num: answer.extend(map(lambda x:x+1, answer)) return answer[:num+1] javahttps://discuss.leetcode.com/topic/40162/three-line-java-solution An easy recurrence for this problem is f[i] = f[i / 2] + i % 2.12345678public class Solution &#123; public int[] countBits(int num) &#123; int[] ret = new int[1+num]; for(int i=1; i&lt;=num; ++i) ret[i] = ret[i&gt;&gt;1] + (i&amp;1); return ret; &#125;&#125; 12345678public class Solution &#123; public int[] countBits(int num) &#123; int[] ret = new int[1+num]; for(int i=1; i&lt;=num; ++i) ret[i] = ret[i&amp;(i-1)] + 1; return ret; &#125;&#125; https://discuss.leetcode.com/topic/41785/simple-java-o-n-solution-using-two-pointers Simple Java O(n) solution using two pointers This uses the hint from the description about using ranges. Basically, the numbers in one range are equal to 1 plus all of the numbers in the ranges before it. If you write out the binary numbers, you can see that numbers 8-15 have the same pattern as 0-7 but with a 1 at the front. My logic was to copy the previous values (starting at 0) until a power of 2 was hit (new range), at which point we just reset the t pointer back to 0 to begin the new range. 12345678910111213public int[] countBits(int num) &#123; int[] ret = new int[num+1]; ret[0] = 0; int pow = 1; for(int i = 1, t = 0; i &lt;= num; i++, t++) &#123; if(i == pow) &#123; pow *= 2; t = 0; &#125; ret[i] = ret[t] + 1; &#125; return ret;&#125; Question:Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. Thinking: We do not need check the input parameter, because the question has already mentioned that the number is non negative. How we do this? The first idea come up with is find the pattern or rules for the result. Therefore, we can get following pattern Index : 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 num : 0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4 Do you find the pattern? Obviously, this is overlap sub problem, and we can come up the DP solution. For now, we need find the function to implement DP. dp[0] = 0; dp[1] = dp[0] + 1; dp[2] = dp[0] + 1; dp[3] = dp[1] +1; dp[4] = dp[0] + 1; dp[5] = dp[1] + 1; dp[6] = dp[2] + 1; dp[7] = dp[3] + 1; dp[8] = dp[0] + 1;… This is the function we get, now we need find the other pattern for the function to get the general function. After we analyze the above function, we can getdp[0] = 0; dp[1] = dp[1-1] + 1; dp[2] = dp[2-2] + 1; dp[3] = dp[3-2] +1; dp[4] = dp[4-4] + 1; dp[5] = dp[5-4] + 1; dp[6] = dp[6-4] + 1; dp[7] = dp[7-4] + 1; dp[8] = dp[8-8] + 1;.. Obviously, we can find the pattern for above example, so now we get the general function dp[index] = dp[index - offset] + 1; Coding: 1234567891011public int[] countBits(int num) &#123; int result[] = new int[num + 1]; int offset = 1; for (int index = 1; index &lt; num + 1; ++index)&#123; if (offset * 2 == index)&#123; offset *= 2; &#125; result[index] = result[index - offset] + 1; &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[337. House Robber III]]></title>
    <url>%2Fp%2F28e4f58d%2F</url>
    <content type="text"><![CDATA[42.3% https://leetcode.com/problems/house-robber-iii/#/description The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. 1234567Example 1: 3 / \ 2 3 \ \ 3 1Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. 1234567Example 2: 3 / \ 4 5 / \ \ 1 3 1Maximum amount of money the thief can rob = 4 + 5 = 9. 方法一： https://discuss.leetcode.com/topic/40847/simple-c-solution Simple C++ solution 123456789101112131415161718class Solution &#123;public: int tryRob(TreeNode* root, int&amp; l, int&amp; r) &#123; if (!root) return 0; int ll = 0, lr = 0, rl = 0, rr = 0; l = tryRob(root-&gt;left, ll, lr); r = tryRob(root-&gt;right, rl, rr); return max(root-&gt;val + ll + lr + rl + rr, l + r); &#125; int rob(TreeNode* root) &#123; int l, r; return tryRob(root, l, r); &#125;&#125;; 我的代码实现: 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int rob(TreeNode* root) &#123; int l, r; return tryRob(root, l, r); &#125; int tryRob(TreeNode* root, int&amp; l, int&amp; r)&#123; if(!root) return 0; int ll=0, lr=0, rl=0, rr=0; l = tryRob(root-&gt;left, ll, lr); r = tryRob(root-&gt;right, rl, rr); return max(root-&gt;val + ll+lr+rl+rr, l+r); &#125;&#125;; Basically you want to compare which one is bigger between 1) you + sum of your grandchildren and 2) sum of your children. Personally I like my solution better than the most voted solution because I don’t need complex data structures like map. 方法二： 我的代码实现： 123456rob(i) = max(rob(i-1, l)+rob(i-1,r), rest(i-1, l)+rest(i-1, r)+value);rest(i) = max(rob(i-1, l)+rob(i-1,r), rest(i-1,l)+rest(i-1,r));rob(i)&gt;=rest(i);rest(i) = rob(i-1,l)+rob(i-1,r);rob(i) = max(rob(i-1, l)+rob(i-1,r), rest(i-1,l)+rest(i-1,r)+value); 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int rob(TreeNode* root) &#123; // second 后不加括号 return helper(root).second; &#125; pair&lt;int, int&gt; helper(TreeNode* root)&#123; // pair&lt;notrob, rob&gt; // 不偷和如果有必要就偷 if(!root) return make_pair(0, 0); pair&lt;int, int&gt; left = helper(root-&gt;left); pair&lt;int, int&gt; right = helper(root-&gt;right); int t1 = left.second + right.second; int t2 = max(t1, root-&gt;val+left.first+right.first); return make_pair(t1, t2); &#125;&#125;; https://discuss.leetcode.com/topic/39700/c-java-python-explanation C++, JAVA, PYTHON &amp; explanation Let f1(node) be the value of maximum money we can rob from the subtree with node as root ( we can rob node if necessary). f2(node) be the value of maximum money we can rob from the subtree with node as root but without robbing node. Then we have f2(node) = f1(node.left) + f1(node.right) and f1(node) = max( f2(node.left)+f2(node.right)+node.value, f2(node) ). C++ 1234567891011121314class Solution &#123;public: int rob(TreeNode* root) &#123; return robDFS(root).second; &#125; pair&lt;int, int&gt; robDFS(TreeNode* node)&#123; if( !node) return make_pair(0,0); auto l = robDFS(node-&gt;left); auto r = robDFS(node-&gt;right); int f2 = l.second + r.second; int f1 = max(f2, l.first + r.first + node-&gt;val); return make_pair(f2, f1); &#125;&#125;; PYTHON 123456789class Solution(object): def rob(self, root): return self.robDFS(root)[1]; def robDFS(self,node): if node is None: return (0,0) l = self.robDFS(node.left) r = self.robDFS(node.right) return (l[1] + r[1], max(l[1] + r[1], l[0] + r[0] + node.val)) https://discuss.leetcode.com/topic/39834/step-by-step-tackling-of-the-problem Step by step tackling of the problem Step I – Think naively At first glance, the problem exhibits the feature of “optimal substructure”: if we want to rob maximum amount of money from current binary tree (rooted at root), we surely hope that we can do the same to its left and right subtrees. So going along this line, let’s define the function rob(root) which will return the maximum amount of money that we can rob for the binary tree rooted at root; the key now is to construct the solution to the original problem from solutions to its subproblems, i.e., how to get rob(root) from rob(root.left), rob(root.right), … etc. Apparently the analyses above suggest a recursive solution. And for recursion, it’s always worthwhile figuring out the following two properties: Termination condition: when do we know the answer to rob(root) without any calculation? Of course when the tree is empty – we’ve got nothing to rob so the amount of money is zero. Recurrence relation: i.e., how to get rob(root) from rob(root.left), rob(root.right), … etc. From the point of view of the tree root, there are only two scenarios at the end: root is robbed or is not. If it is, due to the constraint that “we cannot rob any two directly-linked houses”, the next level of subtrees that are available would be the four “grandchild-subtrees” (root.left.left, root.left.right, root.right.left, root.right.right). However if root is not robbed, the next level of available subtrees would just be the two “child-subtrees” (root.left, root.right). We only need to choose the scenario which yields the larger amount of money. Here is the program for the ideas above: 123456789101112131415public int rob(TreeNode root) &#123; if (root == null) return 0; int val = 0; if (root.left != null) &#123; val += rob(root.left.left) + rob(root.left.right); &#125; if (root.right != null) &#123; val += rob(root.right.left) + rob(root.right.right); &#125; return Math.max(val + root.val, rob(root.left) + rob(root.right));&#125; However the solution runs very slowly (1186 ms) and barely got accepted. Step II – Think one step further In step I, we only considered the aspect of “optimal substructure”, but think little about the possibilities of overlapping of the subproblems. For example, to obtain rob(root), we need rob(root.left), rob(root.right), rob(root.left.left), rob(root.left.right), rob(root.right.left), rob(root.right.right); but to get rob(root.left), we also need rob(root.left.left), rob(root.left.right), similarly for rob(root.right). The naive solution above computed these subproblems repeatedly, which resulted in bad time performance. Now if you recall the two conditions for dynamic programming: “optimal substructure” + “overlapping of subproblems”, we actually have a DP problem. A naive way to implement DP here is to use a hash map to record the results for visited subtrees. And here is the improved solution: 1234567891011121314151617181920212223public int rob(TreeNode root) &#123; return robSub(root, new HashMap&lt;&gt;());&#125;private int robSub(TreeNode root, Map&lt;TreeNode, Integer&gt; map) &#123; if (root == null) return 0; if (map.containsKey(root)) return map.get(root); int val = 0; if (root.left != null) &#123; val += robSub(root.left.left, map) + robSub(root.left.right, map); &#125; if (root.right != null) &#123; val += robSub(root.right.left, map) + robSub(root.right.right, map); &#125; val = Math.max(val + root.val, robSub(root.left, map) + robSub(root.right, map)); map.put(root, val); return val;&#125; The runtime is sharply reduced to 9 ms, at the expense of O(n) space cost (n is the total number of nodes; stack cost for recursion is not counted). Step III – Think one step back In step I, we defined our problem as rob(root), which will yield the maximum amount of money that can be robbed of the binary tree rooted at root. This leads to the DP problem summarized in step II. Now let’s take one step back and ask why we have overlapping subproblems. If you trace all the way back to the beginning, you’ll find the answer lies in the way how we have defined rob(root). As I mentioned, for each tree root, there are two scenarios: it is robbed or is not. rob(root) does not distinguish between these two cases, so “information is lost as the recursion goes deeper and deeper”, which results in repeated subproblems. If we were able to maintain the information about the two scenarios for each tree root, let’s see how it plays out. Redefine rob(root) as a new function which will return an array of two elements, the first element of which denotes the maximum amount of money that can be robbed if root is not robbed, while the second element signifies the maximum amount of money robbed if it is robbed. Let’s relate rob(root) to rob(root.left) and rob(root.right)…, etc. For the 1st element of rob(root), we only need to sum up the larger elements of rob(root.left) and rob(root.right), respectively, since root is not robbed and we are free to rob its left and right subtrees. For the 2nd element of rob(root), however, we only need to add up the 1st elements of rob(root.left) and rob(root.right), respectively, plus the value robbed from root itself, since in this case it’s guaranteed that we cannot rob the nodes of root.left and root.right. As you can see, by keeping track of the information of both scenarios, we decoupled the subproblems and the solution essentially boiled down to a greedy one. Here is the program: 1234567891011121314151617public int rob(TreeNode root) &#123; int[] res = robSub(root); return Math.max(res[0], res[1]);&#125;private int[] robSub(TreeNode root) &#123; if (root == null) return new int[2]; int[] left = robSub(root.left); int[] right = robSub(root.right); int[] res = new int[2]; res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); res[1] = root.val + left[0] + right[0]; return res;&#125; https://discuss.leetcode.com/topic/47996/not-a-solution-but-can-be-helpful-for-people-wants-to-find-a-desired-job Not a solution, but can be helpful for people wants to find a desired job. Sorry that this blog is only in Chinese, I will try my best to get an English version soon. I don’t know if it is okay to post here, so admin, if there is some problem, please let me know, thanks. http://blog.csdn.net/liaozhen/article/details/51654605]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[336. Palindrome Pairs]]></title>
    <url>%2Fp%2F80eb86b9%2F</url>
    <content type="text"><![CDATA[25.3% https://leetcode.com/problems/palindrome-pairs/ Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome. 1234Example 1:Given words = [&quot;bat&quot;, &quot;tab&quot;, &quot;cat&quot;]Return [[0, 1], [1, 0]]The palindromes are [&quot;battab&quot;, &quot;tabbat&quot;] 1234Example 2:Given words = [&quot;abcd&quot;, &quot;dcba&quot;, &quot;lls&quot;, &quot;s&quot;, &quot;sssll&quot;]Return [[0, 1], [1, 0], [3, 2], [2, 4]]The palindromes are [&quot;dcbaabcd&quot;, &quot;abcddcba&quot;, &quot;slls&quot;, &quot;llssssll&quot;] 568ms, , April.26th, 2016 Easy to understand AC C++ solution O(n* k^2) using map Assumption: No duplicated string in the given dictionary Steps: Traverse the array, build map. Key is the reversed string, value is index in array (0 based) Edge case - check if empty string exists. It’s interesting that for given words {“a”, “”}, it’s expected to return two results [0,1] and [1,0]. Since my main logic can cover [0, 1] concatenate(“a”, “”), so as to cover the other situation concatenate(“”, “a”), I need to traverse the words array again, find the palindrome word candidate except “” itself, and add pair(“”, palindrome word) to the final answer. Main logic part. Partition the word into left and right, and see 1) if there exists a candidate in map equals the left side of current word, and right side of current word is palindrome, so concatenate(current word, candidate) forms a pair: left | right | candidate. 2) same for checking the right side of current word: candidate | left | right. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; palindromePairs(vector&lt;string&gt;&amp; words) &#123; unordered_map&lt;string, int&gt; dict; vector&lt;vector&lt;int&gt;&gt; ans; // build dictionary for(int i = 0; i &lt; words.size(); i++) &#123; string key = words[i]; reverse(key.begin(), key.end()); dict[key] = i; &#125; // edge case: if empty string &quot;&quot; exists, find all palindromes to become pairs (&quot;&quot;, self) if(dict.find(&quot;&quot;)!=dict.end())&#123; for(int i = 0; i &lt; words.size(); i++)&#123; if(i == dict[&quot;&quot;]) continue; if(isPalindrome(words[i])) ans.push_back(&#123;dict[&quot;&quot;], i&#125;); // 1) if self is palindrome, here ans covers concatenate(&quot;&quot;, self) &#125; &#125; for(int i = 0; i &lt; words.size(); i++) &#123; for(int j = 0; j &lt; words[i].size(); j++) &#123; string left = words[i].substr(0, j); string right = words[i].substr(j, words[i].size() - j); if(dict.find(left) != dict.end() &amp;&amp; isPalindrome(right) &amp;&amp; dict[left] != i) &#123; ans.push_back(&#123;i, dict[left]&#125;); // 2) when j = 0, left = &quot;&quot;, right = self, so here covers concatenate(self, &quot;&quot;) &#125; if(dict.find(right) != dict.end() &amp;&amp; isPalindrome(left) &amp;&amp; dict[right] != i) &#123; ans.push_back(&#123;dict[right], i&#125;); &#125; &#125; &#125; return ans; &#125; bool isPalindrome(string str)&#123; int i = 0; int j = str.size() - 1; while(i &lt; j) &#123; if(str[i++] != str[j--]) return false; &#125; return true; &#125;&#125;; https://discuss.leetcode.com/topic/51771/clean-c-implementation Clean C++ implementation 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; palindromePairs(vector&lt;string&gt;&amp; words) &#123; vector&lt;vector&lt;int&gt;&gt; result; unordered_map&lt;string, int&gt; dict; for(int i = 0; i &lt; words.size(); i++) &#123; dict[words[i]] = i; &#125; for(int i = 0; i &lt; words.size(); i++) &#123; for(int j = 0; j &lt;= words[i].length(); j++) &#123; //check the suffix word if(is_palindrome(words[i], j, words[i].size() - 1)) &#123; /** the suffix word can be null to all the word **/ string suffix = words[i].substr(0, j); reverse(suffix.begin(), suffix.end()); if(dict.find(suffix) != dict.end() &amp;&amp; i != dict[suffix]) &#123; result.push_back(&#123;i, dict[suffix]&#125;); &#125; &#125; //check the prefix word if(j &gt; 0 &amp;&amp; is_palindrome(words[i], 0, j - 1)) &#123; string prefix = words[i].substr(j); reverse(prefix.begin(), prefix.end()); if(dict.find(prefix) != dict.end() &amp;&amp; dict[prefix] != i) &#123; result.push_back(&#123;dict[prefix], i&#125;); &#125; &#125; &#125; &#125; return result; &#125; bool is_palindrome(string&amp; s, int start, int end) &#123; while(start &lt; end) &#123; if(s[start++] != s[end--]) &#123; return false; &#125; &#125; return true; &#125;&#125;; https://discuss.leetcode.com/topic/39526/python-solution 572ms, , 134/134, April.26th, 2016 Python solution~ 1234567891011121314wordict = &#123;&#125;res = [] for i in range(len(words)): wordict[words[i]] = ifor i in range(len(words)): for j in range(len(words[i])+1): tmp1 = words[i][:j] tmp2 = words[i][j:] if tmp1[::-1] in wordict and wordict[tmp1[::-1]]!=i and tmp2 == tmp2[::-1]: res.append([i,wordict[tmp1[::-1]]]) if j!=0 and tmp2[::-1] in wordict and wordict[tmp2[::-1]]!=i and tmp1 == tmp1[::-1]: res.append([wordict[tmp2[::-1]],i]) return res https://discuss.leetcode.com/topic/39584/accepted-python-solution-with-explanation Accepted Python Solution With Explanation The basic idea is to check each word for prefixes (and suffixes) that are themselves palindromes. If you find a prefix that is a valid palindrome, then the suffix reversed can be paired with the word in order to make a palindrome. It’s better explained with an example. 1words = [&quot;bot&quot;, &quot;t&quot;, &quot;to&quot;] Starting with the string “bot”. We start checking all prefixes. If “”, “b”, “bo”, “bot” are themselves palindromes. The empty string and “b” are palindromes. We work with the corresponding suffixes (“bot”, “ot”) and check to see if their reverses (“tob”, “to”) are present in our initial word list. If so (like the word to”to”), we have found a valid pairing where the reversed suffix can be prepended to the current word in order to form “to” + “bot” = “tobot”. You can do the same thing by checking all suffixes to see if they are palindromes. If so, then finding all reversed prefixes will give you the words that can be appended to the current word to form a palindrome. The process is then repeated for every word in the list. Note that when considering suffixes, we explicitly leave out the empty string to avoid counting duplicates. That is, if a palindrome can be created by appending an entire other word to the current word, then we will already consider such a palindrome when considering the empty string as prefix for the other word. 12345678910111213141516171819def is_palindrome(check): return check == check[::-1]words = &#123;word: i for i, word in enumerate(words)&#125;valid_pals = []for word, k in words.iteritems(): n = len(word) for j in range(n+1): pref = word[:j] suf = word[j:] if is_palindrome(pref): back = suf[::-1] if back != word and back in words: valid_pals.append([words[back], k]) if j != n and is_palindrome(suf): back = pref[::-1] if back != word and back in words: valid_pals.append([k, words[back]])return valid_pals]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>string</tag>
        <tag>hard</tag>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[335. Self Crossing]]></title>
    <url>%2Fp%2F3ae51c9d%2F</url>
    <content type="text"><![CDATA[24.4% https://leetcode.com/problems/self-crossing/#/description You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise. Write a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not. 12345678910Example 1:Given x = [2, 1, 1, 2],┌───┐│ │└───┼──&gt; │Return true (self crossing) 1234567891011Example 2:Given x = [1, 2, 3, 4],┌──────┐│ │││└────────────&gt;Return false (not self crossing) 123456789Example 3:Given x = [1, 1, 1, 1],┌───┐│ │└───┼&gt;Return true (self crossing) https://discuss.leetcode.com/topic/38635/the-best-submission-in-c-searching-for-the-crossing-patterns-is-the-key The best submission in C searching for the crossing patterns is the key After drawing a few crossing cases ourselves, we can simply find out there are two basic patterns: x[i-1]&lt;=x[i-3] &amp;&amp; x[i]&gt;=x[i-2] the ending circle line cross the beginning circle line in one circle; i&gt;=5 &amp;&amp; x[i-1]&lt;=x[i-3] &amp;&amp; x[i]&gt;=x[i-2]-x[i-4] the second line of the next circle cross the the beginning of the previous circle between two adjacent circles; But still that is not over yet, how about some special cases? How about the first line of the next circle and the previous circle? Yeah, the beginning line of the next circle can overlap the the first line of the previous circle - another two adjacent circles case: 1i&gt;=4 &amp;&amp; x[i-1]==x[i-3] &amp;&amp; x[i]&gt;=x[i-2]-x[i-4] Quite straightforward. Then we can test our patterns now, however soon we will find out that the second cases is not strong enough to cover all possible situations - the second line of the next circle crossing the previous circle at the its first line [3,3,3,2,1,1] is an example here, so x[i-2]&gt;=x[i-4] then must be added to our conditions;[3,3,4,4,10,4,4,,3,3] is another typical example for x[i-3]&lt;=x[i-1]+x[i-5] condition, which also should be added to make the constrained conditions stronger;At last, we make it! Bang! End of story with a very terse, clean and efficient code as follows. Updated: 2016-09-12 For better and easier reasoning, here is the thinking thread.Suppose i is the current line, then: i and i-3 can cross i and i-4 can cross i and i-5 can cross no more or no less just exactly the right combination. Now it’s time for us to restrict the conditions to make them just happen. i and i-3 1i&gt;=i-2 &amp;&amp; i-1&lt;=i-3 i and i-4 1i+i-4&gt;=i-2 &amp;&amp; i-1==i-3 i and i-5 1i+i-4&gt;=i-2 &amp;&amp; i-2&gt;=i-4 &amp;&amp; i-1+i-5&gt;=i-3 &amp;&amp; i-1&lt;=i-3 In C 12345678910bool isSelfCrossing(int* x, int size)&#123; for(int i = 3; i &lt; size; i++) &#123; if(x[i]&gt;=x[i-2] &amp;&amp; x[i-1]&lt;=x[i-3]) return true; if(i&gt;=4 &amp;&amp; x[i-1]==x[i-3] &amp;&amp; x[i]+x[i-4]&gt;=x[i-2]) return true; if(i&gt;=5 &amp;&amp; x[i-2]-x[i-4]&gt;=0 &amp;&amp; x[i]&gt;=x[i-2]-x[i-4] &amp;&amp; x[i-1]&gt;=x[i-3]-x[i-5] &amp;&amp; x[i-1]&lt;=x[i-3]) return true; &#125; return false;&#125; In C++ 1234567891011class Solution &#123;public: bool isSelfCrossing(vector&lt;int&gt;&amp; x) &#123; for(int i = 3; i &lt; x.size(); i++) &#123; if(x[i-1]&lt;=x[i-3] &amp;&amp; x[i]&gt;=x[i-2]) return true; if(i&gt;3 &amp;&amp; x[i]+x[i-4]&gt;=x[i-2] &amp;&amp; x[i-1]==x[i-3]) return true; if(i&gt;4 &amp;&amp; x[i-1]+x[i-5]&gt;=x[i-3] &amp;&amp; x[i-1]&lt;=x[i-3] &amp;&amp; x[i]+x[i-4]&gt;=x[i-2] &amp;&amp; x[i-4]&lt;=x[i-2]) return true; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/43622/c-simple-solution C++ simple solution 123456789101112131415161718192021222324252627class Solution&#123;public: bool isSelfCrossing(vector&lt;int&gt;&amp; x) &#123; x.insert(x.begin(), 4, 0); int len = x.size(); int i = 4; // outer spiral for (; i &lt; len &amp;&amp; x[i] &gt; x[i - 2]; i++); if (i == len) return false; // check border if (x[i] &gt;= x[i - 2] - x[i - 4]) &#123; x[i - 1] -= x[i - 3]; &#125; // inner spiral for (i++; i &lt; len &amp;&amp; x[i] &lt; x[i - 2]; i++); return i != len; &#125;&#125;; https://discuss.leetcode.com/topic/43622/c-simple-solution/2 This is why we need to “check border” and ajust the x[i-1] 1234if (x[i] &gt;= x[i - 2] - x[i - 4])&#123; x[i - 1] -= x[i - 3];&#125; Hope that helps~ https://discuss.leetcode.com/topic/38084/re-post-2-o-n-c-0ms-solutions Re-post: 2 O(N) C++ 0ms solutions 0ms, 11.44%, 29/29, April.26th, 2016 The first solution is well described in KuangYuan’s post and the idea is to enumerate all the self-crossing cases. Basically, there are three cases Case1: self-crossing is formed by the last 4 lines (like a closed rectangle) Case 2: self-crossing is formed by the last 5 lines (still like a closed rectangle with one edge having two moves) Case 3: self-crossing is formed by the last 6 lines (like two overlapped rectangles) 12345678910111213class Solution &#123;public: bool isSelfCrossing(vector&lt;int&gt;&amp; x) &#123; int len = x.size(),i; for(i=3; i&lt;len;++i) &#123; if(x[i]&gt;=x[i-2] &amp;&amp; x[i-1] &lt;= x[i-3]) return true; // case 1, the consecutive four lines form a cross if(i&gt;3 &amp;&amp; x[i-1]==x[i-3] &amp;&amp; x[i]+x[i-4]&gt;=x[i-2]) return true; // case 2, the consecutive five lines form a cross if(i&gt;4 &amp;&amp; x[i-2]&gt;=x[i-4] &amp;&amp; x[i-4]+x[i]&gt;=x[i-2] &amp;&amp; x[i-1]&lt;=x[i-3] &amp;&amp; x[i-5] + x[i-1]&gt;=x[i-3]) return true;// case 3, the consecutive six lines form a cross &#125; return false; &#125;&#125;; The second solution is to categorize all the non-self-crossing cases: basically we can only have two valid cases: one is “grow spiral” (which means the curve expands like spiral and there is no boundaries in x and y axis) and the other is “shrink spiral” (which means the spiral curve becomes smaller and smaller and the boundaries in x and y axis are the last move in that direction). The self-crossing cases can only happen in the “shrink” case and it happens only when x[i]&gt;=x[i-2]. The “grow” case can become a “shrink” case and that only happens when x[i]&lt;=x[i-2]. The “shrink” case can not change to a “grow” case. In the solution, we use a bool grow_spiral to indicate whether the current one is a “grow spiral”. if before x[i], it is a “shrink spiral”, we only need to check if a self-crossing happen (i.e. x[i]&gt;=x[i-2]); if it is a “grow spiral”, we check if x[i] changes from “grow” to “shrink” (i.e. x[i]&lt;=x[i-2]), we need to update the boundary x[i-1] (in some cases, it can be x[i-1]-x[i-3]). 12345678910111213141516171819class Solution &#123;public: bool isSelfCrossing(vector&lt;int&gt;&amp; x) &#123; int len = x.size(), i; if(len&lt;=3) return false; bool grow_spiral; for(i=3, grow_spiral = x[2]&gt;x[0]; i&lt;len;++i) &#123; if(!grow_spiral &amp;&amp; x[i]&gt;=x[i-2]) return true;//if it is a &quot;shrink&quot; case before x[i] and cross happens if(grow_spiral &amp;&amp; x[i]&lt;=x[i-2]) &#123; // if it is a grow case, and x[i] changes it to shrink grow_spiral = false; x[i-1] = x[i] + (i&gt;=4?x[i-4]:0)&lt;x[i-2]? x[i-1]:x[i-1]-x[i-3];// update boundary &#125; &#125; return false; &#125;&#125;; My special thank goes to hohomi for pointing out one bug in Solution 2 and I believe I fixed it. https://discuss.leetcode.com/topic/38068/another-python Another python… Checking out every six pack. Solution 1 1234def isSelfCrossing(self, x): return any(d &gt;= b &gt; 0 and (a &gt;= c or a &gt;= c-e &gt;= 0 and f &gt;= d-b) for a, b, c, d, e, f in ((x[i:i+6] + [0] * 6)[:6] for i in xrange(len(x)))) Solution 2 1234567def isSelfCrossing(self, x): b = c = d = e = 0 for a in x: if d &gt;= b &gt; 0 and (a &gt;= c or a &gt;= c-e &gt;= 0 and f &gt;= d-b): return True b, c, d, e, f = a, b, c, d, e return False 12345678910111213Explanation b b +----------------+ +----------------+ | | | | | | | | a c | | c | | | | a | | f +-----------&gt; | | | &lt;----+ d | | | | e | | | +-----------------------+ d Draw a line of length a. Then draw further lines of lengths b, c, etc. How does the a-line get crossed? From the left by the d-line or from the right by the f-line, see the above picture. I just encoded the criteria for actually crossing it. Two details: In both cases, d needs to be at least b. In the first case to cross the a-line directly, and in the second case to get behind it so that the f-line can cross it. So I factored out d &gt;= b. The “special case” of the e-line stabbing the a-line from below is covered because in that case, the f-line “crosses” it (note that even if there is no actual f-line, my code uses f = 0 and thus still finds that “crossing”). 44ms, 34.78%, 29/29, April.26th, 2016 https://leetcode.com/discuss/88153/another-python 123456789class Solution(object): def isSelfCrossing(self, x): &quot;&quot;&quot; :type x: List[int] :rtype: bool &quot;&quot;&quot; return any(d &gt;= b &gt; 0 and (a &gt;= c or a &gt;= c - e &gt;= 0 and f &gt;= d - b) \ for a, b, c, d, e, f in ((x[i:i+6] + [0] *6)[:6] \ for i in xrange(len(x))))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[334. Increasing Triplet Subsequence]]></title>
    <url>%2Fp%2F56530ef8%2F</url>
    <content type="text"><![CDATA[38.4% https://leetcode.com/problems/increasing-triplet-subsequence/#/description Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, ksuch that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false. Your algorithm should run in O(n) time complexity and O(1) space complexity. 123456Examples:Given [1, 2, 3, 4, 5],return true.Given [5, 4, 3, 2, 1],return false. java1ms, 34.32%, 61/61, April.26th, 2016 https://leetcode.com/discuss/86891/concise-java-solution-with-comments 1234567891011public class Solution &#123; public boolean increasingTriplet(int[] nums) &#123; int small = Integer.MAX_VALUE, big = Integer.MAX_VALUE; for(int n : nums)&#123; if(n &lt;= small) small = n; else if(n &lt;= big) big = n; else return true; &#125; return false; &#125;&#125; cpp8ms, 13.06%, 61/61, April.26th, 2016 https://leetcode.com/discuss/86593/clean-and-short-with-comments-c 123456789101112class Solution &#123;public: bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123; int c1 = INT_MAX, c2 = INT_MAX; for(int x : nums)&#123; if(x &lt;= c1) c1 = x; else if(x &lt;= c2) c2 = x; else return true; &#125; return false; &#125;&#125;; python52ms, 30.94%, 61/61, April.26th, 2016 https://leetcode.com/discuss/91827/python-easy-o-n-solution 123456789101112131415class Solution(object): def increasingTriplet(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; first = second = float(&apos;inf&apos;) for n in nums: if n &lt;= first: first = n elif n &lt;= second: second = n else: return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[332. Reconstruct Itinerary]]></title>
    <url>%2Fp%2F3d631603%2F</url>
    <content type="text"><![CDATA[28.4% https://leetcode.com/problems/reconstruct-itinerary/#/description Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”]. All airports are represented by three capital letters (IATA code). You may assume all tickets form at least one valid itinerary. 123Example 1:tickets = [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]Return [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]. 1234Example 2:tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]Return [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;].Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]. But it is larger in lexical order. https://discuss.leetcode.com/topic/36370/short-ruby-python-java-c Short Ruby / Python / Java / C++ Just Eulerian path. Greedy DFS, building the route backwards when retreating. More explanation and example under the codes. Iterative versions inspired by fangyang (I had only thought of recursion, d’oh). Python 1234567891011121314151617181920212223def findItinerary(self, tickets): targets = collections.defaultdict(list) for a, b in sorted(tickets)[::-1]: targets[a] += b, route = [] def visit(airport): while targets[airport]: visit(targets[airport].pop()) route.append(airport) visit(&apos;JFK&apos;) return route[::-1]Iterative version:def findItinerary(self, tickets): targets = collections.defaultdict(list) for a, b in sorted(tickets)[::-1]: targets[a] += b, route, stack = [], [&apos;JFK&apos;] while stack: while targets[stack[-1]]: stack += targets[stack[-1]].pop(), route += stack.pop(), return route[::-1] Java 12345678910111213141516171819202122232425262728293031public List&lt;String&gt; findItinerary(String[][] tickets) &#123; for (String[] ticket : tickets) targets.computeIfAbsent(ticket[0], k -&gt; new PriorityQueue()).add(ticket[1]); visit(&quot;JFK&quot;); return route;&#125;Map&lt;String, PriorityQueue&lt;String&gt;&gt; targets = new HashMap&lt;&gt;();List&lt;String&gt; route = new LinkedList();void visit(String airport) &#123; while(targets.containsKey(airport) &amp;&amp; !targets.get(airport).isEmpty()) visit(targets.get(airport).poll()); route.add(0, airport);&#125;Iterative version:public List&lt;String&gt; findItinerary(String[][] tickets) &#123; Map&lt;String, PriorityQueue&lt;String&gt;&gt; targets = new HashMap&lt;&gt;(); for (String[] ticket : tickets) targets.computeIfAbsent(ticket[0], k -&gt; new PriorityQueue()).add(ticket[1]); List&lt;String&gt; route = new LinkedList(); Stack&lt;String&gt; stack = new Stack&lt;&gt;(); stack.push(&quot;JFK&quot;); while (!stack.empty()) &#123; while (targets.containsKey(stack.peek()) &amp;&amp; !targets.get(stack.peek()).isEmpty()) stack.push(targets.get(stack.peek()).poll()); route.add(0, stack.pop()); &#125; return route;&#125; C++ 123456789101112131415161718vector&lt;string&gt; findItinerary(vector&lt;pair&lt;string, string&gt;&gt; tickets) &#123; for (auto ticket : tickets) targets[ticket.first].insert(ticket.second); visit(&quot;JFK&quot;); return vector&lt;string&gt;(route.rbegin(), route.rend());&#125;map&lt;string, multiset&lt;string&gt;&gt; targets;vector&lt;string&gt; route;void visit(string airport) &#123; while (targets[airport].size()) &#123; string next = *targets[airport].begin(); targets[airport].erase(targets[airport].begin()); visit(next); &#125; route.push_back(airport);&#125; Explanation First keep going forward until you get stuck. That’s a good main path already. Remaining tickets form cycles which are found on the way back and get merged into that main path. By writing down the path backwards when retreating from recursion, merging the cycles into the main path is easy - the end part of the path has already been written, the start part of the path hasn’t been written yet, so just write down the cycle now and then keep backwards-writing the path. Example: enter image description here From JFK we first visit JFK -&gt; A -&gt; C -&gt; D -&gt; A. There we’re stuck, so we write down A as the end of the route and retreat back to D. There we see the unused ticket to B and follow it: D -&gt; B -&gt; C -&gt; JFK -&gt; D. Then we’re stuck again, retreat and write down the airports while doing so: Write down D before the already written A, then JFK before the D, etc. When we’re back from our cycle at D, the written route is D -&gt; B -&gt; C -&gt; JFK -&gt; D -&gt; A. Then we retreat further along the original path, prepending C, A and finally JFK to the route, ending up with the route JFK -&gt; A -&gt; C -&gt; D -&gt; B -&gt; C -&gt; JFK -&gt; D -&gt; A. https://discuss.leetcode.com/topic/36721/short-c-dfs-iterative-44ms-solution-with-explanation-no-recursive-calls-no-backtracking Short C++ DFS iterative 44ms solution with explanation. No recursive calls, no backtracking. 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: vector&lt;string&gt; findItinerary(vector&lt;pair&lt;string, string&gt;&gt; tickets) &#123; // Each node (airport) contains a set of outgoing edges (destination). unordered_map&lt;string, multiset&lt;string&gt;&gt; graph; // We are always appending the deepest node to the itinerary, // so will need to reverse the itinerary in the end. vector&lt;string&gt; itinerary; if (tickets.size() == 0)&#123; return itinerary; &#125; // Construct the node and assign outgoing edges for (pair&lt;string, string&gt; eachTicket : tickets)&#123; graph[eachTicket.first].insert(eachTicket.second); &#125; stack&lt;string&gt; dfs; dfs.push(&quot;JFK&quot;); while (!dfs.empty())&#123; string topAirport = dfs.top(); if (graph[topAirport].empty())&#123; // If there is no more outgoing edges, append to itinerary // Two cases: // 1. If it searchs the terminal end first, it will simply get // added to the itinerary first as it should, and the proper route // will still be traversed since its entry is still on the stack. // 2. If it search the proper route first, the dead end route will also // get added to the itinerary first. itinerary.push_back(topAirport); dfs.pop(); &#125; else &#123; // Otherwise push the outgoing edge to the dfs stack and // remove it from the node. dfs.push(*(graph[topAirport].begin())); graph[topAirport].erase(graph[topAirport].begin()); &#125; &#125; // Reverse the itinerary. reverse(itinerary.begin(), itinerary.end()); return itinerary; &#125;&#125;; https://discuss.leetcode.com/topic/37631/c-non-recursive-o-n-time-o-n-space-solution-with-detail-explanations C++ non-recursive O(N)-time O(N)-space solution with detail explanations The idea of this algorithm, which was originally found in fangyang’s thread https://leetcode.com/discuss/84706/share-solution-java-greedy-stack-15ms-with-explanation, consists of two steps: Step 1: Store the flight in a hash map. (say m in the code below. This map enables us to find all possible destinations from a place in amortized constant time.) Step 2: Use a greedy and trace-back approach to find the optimal itinerary. Specifically, we use greedy method to find a lexicographically-smallest path until we can not move any further (the path can be stored in a vector, say march in the code below). Each time we reach such an exhaustive state, we find a place which is exactly the end of the itinerary. (The reason is, the path march is an optimal itinerary expect that some loops are omitted. The optimal itinerary can be obtained by inserting some loops into this path, which does not change the last vertex of the path.) Therefore, we can record the last vertex in another place (say results in the code below). So and so forth, the vector results stores the optimal itinerary reversely, since we always place the optimal last vertex at the end of this vector. Reversing the vertex results leads to the correct answer. Example:This example is originally shown in StefanPochmann’s thread https://leetcode.com/discuss/84659/short-ruby-python-java-c [ Source of this picture: http://www.stefan-pochmann.info/misc/reconstruct-itinerary.png ] In Step 2, we first march greedily, and get the vector march as: 1march: JFK -&gt; A -&gt; C -&gt; D -&gt; A (the red path) However, the optimal itinerary, is 1JFK -&gt; A -&gt; C -&gt; D( -&gt; B -&gt; C -&gt; JFK -&gt; D) -&gt; A where the loop (D -&gt; B -&gt; C -&gt; JFK -&gt; D) shall be inserted in the vector march. However, we have already found the last vertex A, Therefore, we can record this result. So march and results become 12march: JFK -&gt; A -&gt; C -&gt; Dresults: A Then we march greedily again, results in 12march: JFK -&gt; A -&gt; C -&gt; D -&gt; B -&gt; C -&gt; JFK -&gt; Dresults: A Now all edges are used. Before the final reversion, march and results become 12march: (empty)results: A &lt;- D &lt;- JFK &lt;- C &lt;- B &lt;- D &lt;- C &lt;- A &lt;- JFK Overall Complexities: Let N be the number of tickets. Let D be the largest outgoing degree of a vertex. Time: O(N log D) Step 1: O(N log D) Step 2: O(N). Each vertex needs to be put into march once and be moved from march to results. At the very end, results is reversed. Space: O(N) The map m needs to store all vertices. Code (40 ms): 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; findItinerary(vector&lt;pair&lt;string, string&gt;&gt; tickets) &#123; // Step 1: Store directed edges in a hash map unordered_map&lt;string, multiset&lt;string&gt;&gt; m; for (const pair&lt;string, string&gt; &amp; ticket : tickets) &#123; m[ticket.first].insert(ticket.second); &#125; // Step 2: March greedily and traceback vector&lt;string&gt; march = &#123; &quot;JFK&quot; &#125;; // the storage for greedy searching vector&lt;string&gt; results; // store the final results reversely while (march.empty() == false) &#123; string &amp; from = march.back(); if ((m.find(from) != m.end()) &amp;&amp; (m[from].empty() == false)) &#123; // march further multiset&lt;string&gt; &amp; to = m[from]; march.push_back(*(to.begin())); to.erase(to.begin()); &#125; else &#123; // can not march further, trace back results.push_back(march.back()); // archive the last place march.pop_back(); &#125; &#125; reverse(results.begin(), results.end()); // reverse the entries back return results; &#125;&#125;; https://discuss.leetcode.com/topic/46577/28ms-c-beat-100-short-and-elegant 28ms C++ beat 100% Short and Elegant. I think this algorithm is often called Fleury’s algorithm. But actually it is Hierholzer’s algorithm according to the wiki. Anyway, it works like this: Keep going one path until stuck, then retreat and push the vertices along the route to a stack until it reaches a vertex that has alternative paths, then go along that path and repeat the process.The assumption for this to work is there is guaranteed to exist one Euler path. (This problem is basically to find a Euler path of a graph). 1234567891011121314151617181920212223class Solution &#123; unordered_map&lt;string, priority_queue&lt;string, vector&lt;string&gt;, greater&lt;string&gt;&gt;&gt; graph; vector&lt;string&gt; result; void dfs(string vtex) &#123; auto &amp; edges = graph[vtex]; while (!edges.empty()) &#123; string to_vtex = edges.top(); edges.pop(); dfs(to_vtex); &#125; result.push_back(vtex); &#125;public: vector&lt;string&gt; findItinerary(vector&lt;pair&lt;string, string&gt;&gt; tickets) &#123; for (auto e : tickets) graph[e.first].push(e.second); dfs(&quot;JFK&quot;); reverse(result.begin(), result.end()); return result; &#125;&#125;; https://discuss.leetcode.com/topic/36445/c-solution-using-dfs C++ Solution using DFS 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;string&gt; findItinerary(vector&lt;pair&lt;string, string&gt;&gt; tickets) &#123; vector&lt;string&gt; ans; int n = tickets.size(); for(int i = 0; i &lt; n; ++ i)&#123; g[tickets[i].first].insert(tickets[i].second); &#125; dfs(&quot;JFK&quot;, ans, 1, n); // puts(&quot; -- &quot;); reverse(ans.begin(), ans.end()); return ans; &#125;private: void dfs(string u, vector&lt;string&gt; &amp;ans, int dep, int tot)&#123; while(g[u].size())&#123; string v = *g[u].begin(); g[u].erase(g[u].begin()); dfs(v, ans, dep + 1, tot); &#125; ans.push_back(u); &#125;private:unordered_map&lt;string, multiset&lt;string&gt; &gt; g;//unordered_map&lt;string, set&lt;string&gt;::iterator&gt; vis;&#125;; https://discuss.leetcode.com/topic/36403/python-dfs-backtracking Python Dfs Backtracking I use a dictionary to represent the tickets (start -&gt; [list of possible destinations]). Then, I start the route at JFK and I dfs from there. Since I do the dfs in sorted order, the first time that I find a possible route, I can return it and know that it is in the smallest lexigraphic order. Finally, note that the worked variable either contains None (as a result of a failed search) or the correct route. 123456789101112131415161718def findItinerary(self, tickets): d = defaultdict(list) for flight in tickets: d[flight[0]] += flight[1], self.route = [&quot;JFK&quot;] def dfs(start = &apos;JFK&apos;): if len(self.route) == len(tickets) + 1: return self.route myDsts = sorted(d[start]) for dst in myDsts: d[start].remove(dst) self.route += dst, worked = dfs(dst) if worked: return worked self.route.pop() d[start] += dst, return dfs() 108ms, 56.72%, 79/79, April.26th, 2016 https://leetcode.com/discuss/84659/short-ruby-python-java-c 12345678910111213141516class Solution(object): def findItinerary(self, tickets): &quot;&quot;&quot; :type tickets: List[List[str]] :rtype: List[str] &quot;&quot;&quot; targets = collections.defaultdict(list) for a, b in sorted(tickets)[::-1]: targets[a] += b, route = [] def visit(airport): while targets[airport]: visit(targets[airport].pop()) route.append(airport) visit(&apos;JFK&apos;) return route[::-1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>depth first search</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[331. Verify Preorder Serialization of a Binary Tree]]></title>
    <url>%2Fp%2Fd8b9d36f%2F</url>
    <content type="text"><![CDATA[35.6% https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/#/description One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #. 12345678tmp _9_ / \ 3 2 / \ / \ 4 1 # 6/ \ / \ / \# # # # # # For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where # represents a null node. Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree. Each comma separated value in the string must be either an integer or a character ‘#’ representing null pointer. You may assume that the input format is always valid, for example it could never contain two consecutive commas such as “1,,3”. 123Example 1:&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;Return true 123Example 2:&quot;1,#&quot;Return false 123Example 3:&quot;9,#,#,1&quot;Return false https://discuss.leetcode.com/topic/45326/c-4ms-solution-o-1-space-o-n-time C++ 4ms solution, O(1) space, O(n) time The capacity is the number of node that can be put in the tree. The initial value is 1, which means there can be a root. When adding a node, capacity–; When adding a non-NULL node, it means we obtains two more leafs, then capacity +=2. The final capacity should be equal to 0 12345678910111213141516class Solution &#123;public:bool isValidSerialization(string preorder) &#123; if (preorder.empty()) return false; preorder+=&apos;,&apos;; int sz=preorder.size(),idx=0; int capacity=1; for (idx=0;idx&lt;sz;idx++)&#123; if (preorder[idx]!=&apos;,&apos;) continue; capacity--; if (capacity&lt;0) return false; if (preorder[idx-1]!=&apos;#&apos;) capacity+=2; &#125; return capacity==0;&#125;&#125;; https://discuss.leetcode.com/topic/36100/straight-forward-c-solution-with-explanation Straight-forward C++ solution with explanation The idea is simple. Denote the number of null nodes as nullCnt, the number of actual nodes as nodeCnt. For a binary tree, the number of null nodes is always the number of actual nodes plus 1. nullCnt==nodeCnt+1; So, if nullCnt &gt; nodeCnt+1, the tree is invalid. if nullCnt &lt; nodeCnt+1, the tree is incomplete. if nullCnt==nodeCnt+1, the tree is complete and can’t be extended. We just need to keep track of nullCnt and nodeCnt as we go through the sequence and check these conditions above. Actually, recording nullCnt-nodeCnt is enough, so you can further improve the code. 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool isValidSerialization(string preorder) &#123; int nodeCnt=0,nullCnt=0; vector&lt;string&gt; v=splitStr(preorder,&apos;,&apos;); for(int i = 0; i&lt;v.size(); i++)&#123; if(v[i]==&quot;#&quot;) ++nullCnt; else ++nodeCnt; if(nullCnt&gt;=nodeCnt+1 &amp;&amp; i!=v.size()-1) return false; &#125; return nullCnt==nodeCnt+1; &#125; vector&lt;string&gt; splitStr(string str, char delimiter)&#123; vector&lt;string&gt; r; string tmpstr; while (!str.empty())&#123; int ind = str.find_first_of(delimiter); if (ind == -1)&#123; r.push_back(str); str.clear(); &#125; else&#123; r.push_back(str.substr(0, ind)); str = str.substr(ind + 1, str.size() - ind - 1); &#125; &#125; return r; &#125;&#125;; Edit: The algorithm scans the string one node at a time from the beginning, once it finds nullCnt&gt;nodeCnt+1, it stops and return false. If it finds nullCnt==nodeCnt+1, that means by now, the tree is valid(otherwise the algorithm would return false before this) and complete, if there are more nodes to come, it returns false; if it’s the last node, the algorithm returns true. If it finds nullCnt&lt; nodeCnt+1, that means the tree is incomplete but not invalid(or the algorithm would return false before this) by now, if this is the last node and no more nodes comes after it, the tree is invalid. Example: “#,1,#” 1st node is #, nullCnt==1, nodeCnt==0, nullCnt==nodeCnt+1, the tree is complete by now, but there are more nodes after it, so it’s invalid. “1, #” 1st node is 1, nullCnt==0, nodeCnt==1, nullCnt&lt; nodeCnt+1, the tree is incomplete, but there are more nodes after it, so we proceed, 2nd node is #, nullCnt==1, nodeCnt==1, nullCnt&lt; nodeCnt+1, the tree is incomplete and there are no more nodes left, so it’s invalid. Edit2: Why for a binary tree, nullCnt==nodeCnt+1? For an empty binary tree, nullCnt=1, nodeCnt=0, nullCnt==nodeCnt+1. Each time we add an actual node, we take the place of one null node and create two null nodes, so the net gain of null node is one, which is also the net gain of actual node. Thus, the actual nodes and null nodes will increase by the same amount, which means nullCnt==nodeCnt+1 will always hold. https://discuss.leetcode.com/topic/36034/6-lines-python-7-lines-java Python 1234567def isValidSerialization(self, preorder): need = 1 for val in preorder.split(&apos;,&apos;): if not need: return False need -= &apos; #&apos;.find(val) return not need Java 123456789public boolean isValidSerialization(String preorder) &#123; int need = 1; for (String val : preorder.split(&quot;,&quot;)) &#123; if (need == 0) return false; need -= &quot; #&quot;.indexOf(val); &#125; return need == 0;&#125; 52ms, 76.41%, 150/150, April.26th, 2016 https://leetcode.com/discuss/84257/simplest-python-solution-with-explanation-stack-recursion The simplest python solution with explanation (no stack, no recursion) We just need to remember how many empty slots we have during the process. Initially we have one ( for the root ). for each node we check if we still have empty slots to put it in. a null node occupies one slot. a non-null node occupies one slot before he creates two more. the net gain is one. 123456789101112131415161718192021222324252627282930class Solution(object): def isValidSerialization(self, preorder): &quot;&quot;&quot; :type preorder: str :rtype: bool &quot;&quot;&quot; # remember how many empty slots we have # non-null nodes occupy one slot but create two new slots # null nodes occupy one slot p = preorder.split(&apos;,&apos;) #initially we have one empty slot to put the root in it slot = 1 for node in p: # no empty slot to put the current node if slot == 0: return False # a null node? if node == &apos;#&apos;: # ocuppy slot slot -= 1 else: # create new slot slot += 1 #we don&apos;t allow empty slots at the end return slot==0 https://discuss.leetcode.com/topic/35977/simple-python-solution-using-stack-with-explanation Simple Python solution using stack. With Explanation. This is very simple problem if you use stacks. The key here is, when you see two consecutive “#” characters on stack, pop both of them and replace the topmost element on the stack with “#”. For example, preorder = 1,2,3,#,#,#,# Pass 1: stack = [1] Pass 2: stack = [1,2] Pass 3: stack = [1,2,3] Pass 4: stack = [1,2,3,#] Pass 5: stack = [1,2,3,#,#] -&gt; two #s on top so pop them and replace top with #. -&gt; stack = [1,2,#] Pass 6: stack = [1,2,#,#] -&gt; two #s on top so pop them and replace top with #. -&gt; stack = [1,#] Pass 7: stack = [1,#,#] -&gt; two #s on top so pop them and replace top with #. -&gt; stack = [#] If there is only one # on stack at the end of the string then return True else return False. Here is the code for that, 123456789101112131415161718192021222324252627282930313233class Solution(object):def isValidSerialization(self, preorder): &quot;&quot;&quot; :type preorder: str :rtype: bool &quot;&quot;&quot; stack = [] top = -1 preorder = preorder.split(&apos;,&apos;) for s in preorder: stack.append(s) top += 1 while(self.endsWithTwoHashes(stack,top)): h = stack.pop() top -= 1 h = stack.pop() top -= 1 if top &lt; 0: return False h = stack.pop() stack.append(&apos;#&apos;) #print stack if len(stack) == 1: if stack[0] == &apos;#&apos;: return True return Falsedef endsWithTwoHashes(self,stack,top): if top&lt;1: return False if stack[top]==&apos;#&apos; and stack[top-1]==&apos;#&apos;: return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[330. Patching Array]]></title>
    <url>%2Fp%2F51a621a8%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/patching-array/ Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required. 12345678Example 1:nums = [1, 3], n = 6Return 1.Combinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.Now if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].Possible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].So we only need 1 patch. 1234Example 2:nums = [1, 5, 10], n = 20Return 2.The two patches can be [2, 4]. 123Example 3:nums = [1, 2, 2], n = 5Return 0. https://discuss.leetcode.com/topic/35709/share-my-thinking-process Share my thinking process The question asked for the “minimum number of patches required”. In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? Think about this example: nums = [1, 2, 3, 9]. We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1…1 is patched completely. After encountered 2, we know 1…3 (1+2) is patched completely. After we encountered 3, we know 1…6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don’t miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 … 7. Any number greater than 7 won’t help here. Patching 8 will not help you get 7. So we have 7 numbers (1…7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1…13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1…22 is completely patched. If we still did’t reach n, we can then patch 23, which makes 1…45 (22+23) completely patched. We continue until we reach n. java https://discuss.leetcode.com/topic/35517/share-my-greedy-solution-by-java-with-simple-explanation-time-1-ms Share my greedy solution by Java with simple explanation (time: 1 ms) 1234567891011121314public static int minPatches(int[] nums, int n) &#123; long max = 0; int cnt = 0; for (int i = 0; max &lt; n;) &#123; if (i &gt;= nums.length || max &lt; nums[i] - 1) &#123; max += max + 1; cnt++; &#125; else &#123; max += nums[i]; i++; &#125; &#125; return cnt;&#125; The variable max records the maximal value that can be formed by the elements in nums and patched numbers. If max is less than nums[i] - 1 which means we need to patch a new number, we then patch max + 1. cpp https://leetcode.com/discuss/82822/solution-explanation Solution + explanation 8ms, 33.52%, 149/149, April.26th, 2016 Solution 123456789101112int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123; long miss = 1, added = 0, i = 0; while (miss &lt;= n) &#123; if (i &lt; nums.size() &amp;&amp; nums[i] &lt;= miss) &#123; miss += nums[i++]; &#125; else &#123; miss += miss; added++; &#125; &#125; return added;&#125; Explanation Let miss be the smallest sum in [0,n] that we might be missing. Meaning we already know we can build all sums in [0,miss). Then if we have a number num &lt;= miss in the given array, we can add it to those smaller sums to build all sums in [0,miss+num). If we don’t, then we must add such a number to the array, and it’s best to add miss itself, to maximize the reach. Example: Let’s say the input is nums = [1, 2, 4, 13, 43] and n = 100. We need to ensure that all sums in the range [1,100] are possible. Using the given numbers 1, 2 and 4, we can already build all sums from 0 to 7, i.e., the range [0,8). But we can’t build the sum 8, and the next given number (13) is too large. So we insert 8 into the array. Then we can build all sums in [0,16). Do we need to insert 16 into the array? No! We can already build the sum 3, and adding the given 13 gives us sum 16. We can also add the 13 to the other sums, extending our range to [0,29). And so on. The given 43 is too large to help with sum 29, so we must insert 29 into our array. This extends our range to [0,58). But then the 43 becomes useful and expands our range to [0,101). At which point we’re done. Another implementation, though I prefer the above one. 123456int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123; int count = 0, i = 0; for (long miss=1; miss &lt;= n; count++) miss += (i &lt; nums.size() &amp;&amp; nums[i] &lt;= miss) ? nums[i++] : miss; return count - i;&#125; https://discuss.leetcode.com/topic/45320/c-8ms-greedy-solution-with-explanation C++, 8ms, greedy solution with explanation show the algorithm with an example, let nums=[1 2 5 6 20], n = 50. Initial value: with 0 nums, we can only get 0 maximumly. Then we need to get 1, since nums[0]=1, then we can get 1 using [1]. now the maximum number we can get is 1. (actually, we can get all number no greater than the maximum number) 12number used [1], number added []can achieve 1~1 Then we need to get 2 (maximum number +1). Since nums[1]=2, we can get 2. Now we can get all number between 1 ~ 3 (3=previous maximum value + the new number 2). and 3 is current maximum number we can get. 12number used [1 2], number added []can achieve 1~3 Then we need to get 4 (3+1). Since nums[2]=5&gt;4; we need to add a new number to get 4. The optimal solution is to add 4 directly. In this case, we could achieve maximumly 7, using [1,2,4]. 12number used [1 2], number added [4]can achieve 1~7 Then we need to get 8 (7+1). Since nums[2]=5&lt;8, we can first try to use 5. Now the maximum number we can get is 7+5=12. Since 12&gt;8, we successfully get 8. 12number used [1 2 5], number added [4]can achieve 1~12 Then we need to get 13 (12+1), Since nums[3]=6&lt;13, we can first try to use 6. Now the maximum number we can get is 12+6=18. Since 18&gt;13, we successfully get 13. 12number used [1 2 5 6], number added [4]can achieve 1~18 Then we need to get 19 (18+1), Since nums[4]=20&gt;19, we need to add a new number to get 19. The optimal solution is to add 19 directly. In this case, we could achieve maximumly 37. 12number used [1 2 5 6], number added [4 19]can achieve 1~37 Then we need to get 38(37+1), Since nums[4]=20&lt;38, we can first try to use 20. Now the maximum number we can get is 37+20=57. Since 57&gt;38, we successfully get 38. 12number used [1 2 5 6 20], number added [4 19]can achieve 1~57 Since 57&gt;n=50, we can all number no greater than 50. The extra number we added are 4 and 19, so we return 2. The code is given as follows 123456789101112131415class Solution &#123; public: int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123; int cnt=0,i=0; long long maxNum=0; while (maxNum&lt;n)&#123; if (i&lt;nums.size() &amp;&amp; nums[i]&lt;=maxNum+1) maxNum+=nums[i++]; else&#123; maxNum+=maxNum+1;cnt++; &#125; &#125; return cnt; &#125;&#125;; https://discuss.leetcode.com/topic/36238/my-simple-accepted-c-solution My simple accepted C++ solution Idea: Check the content if the current one is within sum +1, which is the total sum of all previous existing numbers. If yes, we proceed and update sum. If not, we patch one number that is within sum + 1. Keep updating the sum until it reaches n. 12345678910111213141516171819202122232425int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123; int len = nums.size(); int sum = 0; int patch = 0; int count = 0; while (sum &lt; n) &#123; if (count != len &amp;&amp; nums[count] &lt;= sum + 1) &#123; sum += nums[count]; count ++; &#125; else &#123; patch ++; if (sum &gt; (INT_MAX - 1) / 2) &#123; sum = INT_MAX; &#125; else &#123; sum = sum * 2 + 1; &#125; &#125; &#125; return patch;&#125; python https://discuss.leetcode.com/topic/42901/simple-9-line-python-solution Simple 9-line Python Solution 12345678910111213141516class Solution(object): def minPatches(self, nums, n): &quot;&quot;&quot; :type nums: List[int] :type n: int :rtype: int &quot;&quot;&quot; miss, i, added = 1, 0, 0 while miss &lt;= n: if i &lt; len(nums) and nums[i] &lt;= miss: miss += nums[i] i += 1 else: miss += miss added += 1 return added https://discuss.leetcode.com/topic/35508/greedy-solution-in-python Greedy solution in Python I used a greedy algorithm. When traversing through the given number list, consider each number as a goal and resource. When in the for loop for the ith number, try to add some numbers so that you can represent every number in the range [ 1, nums[i] ). Then, add the ith number to your source for further loops. To reach the goal, suppose all the resource (the numbers smaller than the goal) sums to a number sum, then, sum+1 is what we don’t have. So we need to add a sum+1 to our resource. And now you can represent all the numbers not bigger than sum+sum+1. 1234567891011121314151617181920212223class Solution(object):def minPatches(self, nums, n): &quot;&quot;&quot; :type nums: List[int] :type n: int :rtype: int &quot;&quot;&quot; count = 0 sum = 0 for x in nums: if sum &gt;= n: return count while sum &lt; x-1: # x-1 is the goal; when reaches the goal, we can represent [1, x) count += 1 sum += sum + 1 # add a resource number if sum &gt;= n: return count sum += x while sum + 1 &lt;= n: count += 1 sum += sum + 1 return count Solution mine: 56ms, 33.02%, 149 / 149, April.26th, 2016 12345678910111213141516class Solution(object): def minPatches(self, nums, n): &quot;&quot;&quot; :type nums: List[int] :type n: int :rtype: int &quot;&quot;&quot; miss, added, i = 1, 0, 0 while miss &lt;= n: if i &lt; len(nums) and nums[i] &lt;= miss: miss += nums[i] i += 1 else: miss += miss added += 1 return added]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[329. Longest Increasing Path in a Matrix]]></title>
    <url>%2Fp%2F9c9202a6%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/longest-increasing-path-in-a-matrix/#/description Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). 123456789Example 1:nums = [ [9,9,4], [6,6,8], [2,1,1]]Return 4The longest increasing path is [1, 2, 6, 9]. 123456789Example 2:nums = [ [3,4,5], [3,2,6], [2,2,1]]Return 4The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed. cppSolution 1: 80ms, 75.11%, April.27th, 2016 https://leetcode.com/discuss/81234/solution-with-explanation-search-nearby-using-dfs-easy-read 1234567891011121314151617181920212223242526class Solution &#123;public: int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(); if(!m) return 0; int n = matrix[0].size(), maxSum = 0; vector&lt;vector&lt;int&gt; &gt; pathSum(m, vector&lt;int&gt;(n , 1)); for(int i = 0; i &lt; m; ++i) for(int j = 0; j &lt; n; ++j) if(pathSum[i][j] == 1) maxSum = max(maxSum, dfs(matrix, pathSum, m, n, i, j)); return maxSum; &#125;private: int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt; &gt; &amp;pathSum, int m, int n, int i, int j)&#123; if(pathSum[i][j] &gt; 1) return pathSum[i][j]; int res = 1; if(i - 1 &gt;= 0 &amp;&amp; matrix[i][j] &lt; matrix[i - 1][j]) res = max(res, 1 + dfs(matrix, pathSum, m, n, i - 1, j)); if(j - 1 &gt;= 0 &amp;&amp; matrix[i][j] &lt; matrix[i][j - 1]) res = max(res, 1 + dfs(matrix, pathSum, m, n, i, j - 1)); if(i + 1 &lt; m &amp;&amp; matrix[i][j] &lt; matrix[i + 1][j]) res = max(res, 1 + dfs(matrix, pathSum, m, n, i + 1, j)); if(j + 1 &lt; n &amp;&amp; matrix[i][j] &lt; matrix[i][j + 1]) res = max(res, 1 + dfs(matrix, pathSum, m, n, i, j + 1)); pathSum[i][j] = res; return res; &#125;&#125;; Solution 2: 429ms, 8.59%, April.27th, 2016 https://leetcode.com/discuss/81855/c-dp-dfs-solution-sharing 12345678910111213141516171819202122232425262728class Solution &#123;public: int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int rows = matrix.size(); if(!rows) return 0; int cols = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0)); std::function&lt;int(int, int)&gt; dfs = [&amp;](int x, int y)&#123; if(dp[x][y]) return dp[x][y]; vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; for(auto &amp;dir : dirs)&#123; int xx = x + dir[0], yy = y + dir[1]; if(xx &lt; 0 || xx &gt;= rows || yy &lt; 0 || yy &gt;= cols) continue; if(matrix[xx][yy] &lt;= matrix[x][y]) continue; dp[x][y] = std::max(dp[x][y], dfs(xx, yy)); &#125; return ++dp[x][y]; &#125;; int ret = 0; for(int i = 0; i &lt; rows; ++i)&#123; for(int j = 0; j &lt; cols; ++j) ret = std::max(ret, dfs(i, j)); &#125; return ret; &#125;&#125;; python312ms, 89.28%, 137 / 137, April.27th, 2016 https://leetcode.com/discuss/81747/python-solution-memoization-dp-288ms 123456789101112131415161718192021class Solution(object): def longestIncreasingPath(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: int &quot;&quot;&quot; def dfs(i, j): if not dp[i][j]: val = matrix[i][j] dp[i][j] = 1 + max( dfs(i - 1, j) if i and val &gt; matrix[i - 1][j] else 0, dfs(i + 1, j) if i &lt; M - 1 and val &gt; matrix[i + 1][j] else 0, dfs(i, j - 1) if j and val &gt; matrix[i][j - 1] else 0, dfs(i, j + 1) if j &lt; N - 1 and val &gt; matrix[i][j + 1] else 0 ) return dp[i][j] if not matrix or not matrix[0] : return 0 M, N = len(matrix), len(matrix[0]) dp = [[0]*N for i in xrange(M)] return max(dfs(x, y) for x in xrange(M) for y in xrange(N))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>depth first search</tag>
        <tag>topological sort</tag>
        <tag>memoization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[328. Odd Even Linked List]]></title>
    <url>%2Fp%2F80daf693%2F</url>
    <content type="text"><![CDATA[42.5% https://leetcode.com/problems/odd-even-linked-list/#/description Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. 123Example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL. Note: The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on … 方法一： 两个指针，分别指向奇偶序列的头部 再两个指针，分别随着链表向后走 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* oddEvenList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode *p1, *p2, *h2; p1 = head; p2 = p1-&gt;next; h2 = p2; while(p2!=NULL &amp;&amp; p2-&gt;next != NULL)&#123; p1-&gt;next = p2-&gt;next; p2-&gt;next = p2-&gt;next-&gt;next; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; p1-&gt;next = h2; return head; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* oddEvenList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* even = new ListNode(-1); ListNode* odd = new ListNode(-1); ListNode* cur = head, *p1 = even, *p2 = odd; while(cur)&#123; p1-&gt;next = cur; p2-&gt;next = cur-&gt;next; p1 = p1-&gt;next; p2 = p2-&gt;next; if(!cur-&gt;next || !cur-&gt;next-&gt;next) break; cur = cur-&gt;next-&gt;next; &#125; p1-&gt;next = odd-&gt;next; return even-&gt;next; &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/34837/simple-c-solution-o-n-time-o-1-space Simple C++ solution, O(n) time, O(1) space 1234567891011121314ListNode* oddEvenList(ListNode* head) &#123; if(!head) return head; ListNode *odd=head, *evenhead=head-&gt;next, *even = evenhead; while(even &amp;&amp; even-&gt;next) &#123; odd-&gt;next = odd-&gt;next-&gt;next; even-&gt;next = even-&gt;next-&gt;next; odd = odd-&gt;next; even = even-&gt;next; &#125; odd-&gt;next = evenhead; return head;&#125; https://discuss.leetcode.com/topic/34473/my-c-solution My c++ solution 123456789101112131415161718192021class Solution &#123;public:ListNode* oddEvenList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode *odd = head; ListNode *even_head = head-&gt;next; ListNode *even = even_head; while(even != NULL &amp;&amp; even-&gt;next != NULL) &#123; odd-&gt;next = even-&gt;next; odd = odd-&gt;next; even-&gt;next = odd-&gt;next; even = even-&gt;next; &#125; odd-&gt;next = even_head; return head;&#125;&#125;; https://discuss.leetcode.com/topic/34309/clear-python-solution Clear Python Solution 1234567891011def oddEvenList(self, head): dummy1 = odd = ListNode(0) dummy2 = even = ListNode(0) while head: odd.next = head even.next = head.next odd = odd.next even = even.next head = head.next.next if even else None odd.next = dummy2.next return dummy1.next https://discuss.leetcode.com/topic/36552/python-solution-with-two-pointers-o-n Python solution with two pointers O(N) 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def oddEvenList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if not head: return head odd=head even=head.next while even and even.next!=None: temp = even.next even.next = even.next.next temp.next = odd.next odd.next = temp odd=odd.next even=even.next return head read in two node at a time: first node(odd) goes into odd.next 2nd node(even).next = next even node (node.next.next) rinse and repeat so basically 1 - 2 - 3 - 4- 5- 6 -7-null odd = 1 even = 2 temp = 3 even(2).next = even.next.next(4) temp(3).next=odd(1).next(2) (this makes sure the end of odd always points to start of even) odd(1).next = temp(3) odd = odd.next(3) move the pointer even = even.next(4) move the pointer 1-3(odd)-2-4(even)-5-null 1-3-5(odd)-2-4-null(even) 1-3-5-7(odd)-2-4-6-null(even) 解题思路 head作为头部，每次只作为头部索引，然后引导odd和even，最后拼接，return python12345678910111213141516171819202122# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def oddEvenList(self, head): """ :type head: ListNode :rtype: ListNode """ dummy1 = odd = ListNode(0) dummy2 = even = ListNode(0) while head: odd.next = head even.next = head.next odd = odd.next even = even.next head = even.next if even else None odd.next = dummy2.next return dummy1.next java https://discuss.leetcode.com/topic/34280/straigntforward-java-solution-o-1-space-o-n-time123456789101112public ListNode oddEvenList(ListNode head) &#123; if(head==null||head.next==null) return head; ListNode odd=head,ehead=head.next,even=ehead; while(even!=null&amp;&amp;even.next!=null)&#123; odd.next=even.next; odd=odd.next; even.next=odd.next; even=even.next; &#125; odd.next=ehead; return head;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[327. Count of Range Sum]]></title>
    <url>%2Fp%2Fea34edb1%2F</url>
    <content type="text"><![CDATA[29.1% https://leetcode.com/problems/count-of-range-sum/?tab=Description Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive. Note: A naive algorithm of O(n2) is trivial. You MUST do better than that. 1234Example:Given nums = [-2, 5, -1], lower = -2, upper = 2,Return 3.The three ranges are : [0, 0], [2, 2], [0, 2] and their respective sums are: -2, -1, 2. cpp https://discuss.leetcode.com/topic/33993/8-line-multiset-c-solution-100ms-also-binary-search-tree-180ms-mergesort-52ms 8-line multiset C++ solution (100ms), also binary search tree (180ms) + mergesort(52ms) The basic idea is to use a multiset to save sum, where sum at i = nums[0]+…+ nums[i]. At each i, only those sum[j] that satisfies lower=&lt; sum[i]-sum[j]&lt;= upper can generate a valid range[j,i]. so we only need to calculate how many j (0=&lt; j&lt; i) satisfy sum[i]-upper=&lt; sum[j]&lt;=-sum[i]-lower. The STL multiset can take care of sort and find upper_bound, lower_bound j. Since the multiset is usually implemented with Red-black tree, so those operations should have complexity of O(logN). So in total, the complexity is O(NlogN) (except the distance part). At least it looks neat 123456789101112131415class Solution &#123;public: int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; multiset&lt;long long&gt; pSum; int res = 0, i; long long left, right, sum=0; for(i=0,pSum.insert(0); i&lt;nums.size(); ++i) &#123; sum +=nums[i]; res += std::distance(pSum.lower_bound(sum-upper), pSum.upper_bound(sum-lower)); pSum.insert(sum); &#125; return res; &#125;&#125;; In the comments made by StefanPochmann, there is concern that the STL distance function increases the total complexity to O(N^2), which is true. In the following version, I just show one possible way to fix that (O(1) distance function) if we implement the binary search tree by ourselves. Of course, the below version is not a balanced binary search tree, so the worst case is still O(N^2) even if the input is random, the average complexity is O(NlogN) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123;private: class BSTNode&#123; // Binary search tree implementation public: long long val; int cnt; // how many nodes with value of &quot;val&apos; int lCnt; // how many nodes on its left subtree BSTNode *left; BSTNode *right; BSTNode(long long x) &#123; val = x; cnt = 1; lCnt = 0; left = right = nullptr; &#125; &#125;; int getBound(BSTNode *root, long long x, bool includeSelf) &#123; // get the index of the last node that satisfy val&lt;x (includeSelf=false) or val&lt;=x (includeSelf = true) if(!root) return 0; if(root-&gt;val == x) return root-&gt;lCnt + (includeSelf?root-&gt;cnt:0); else if(root-&gt;val &gt; x) return getBound(root-&gt;left, x, includeSelf); else return root-&gt;cnt + root-&gt;lCnt + getBound(root-&gt;right, x, includeSelf); &#125; void insert(BSTNode*&amp; root, long long x) &#123; // insert a node to the tree if(!root) root = new BSTNode(x); else if(root-&gt;val == x) (root-&gt;cnt)++; else if(root-&gt;val &lt; x) insert(root-&gt;right,x); else&#123; ++(root-&gt;lCnt); insert(root-&gt;left,x); &#125; &#125; void deleteTree(BSTNode*root) &#123; //destroy the tree if(!root) return; deleteTree(root-&gt;left); deleteTree(root-&gt;right); delete root; &#125; public: int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; // same idea as the multiset version BSTNode *root= new BSTNode(0); int res = 0, i; long long left, right, sum=0; for(i=0; i&lt;nums.size(); ++i) &#123; sum +=nums[i]; res += getBound(root, sum-lower, true) - getBound(root, sum-upper, false); insert(root, sum); &#125; deleteTree(root); return res; &#125;&#125;; Another option is to multify mergesort to do counting. The code is as below and the complexity is O(NlogN) (52ms) 123456789101112131415161718192021222324252627282930313233class Solution &#123;private: int mergeSort(vector&lt;long long&gt;&amp;sum, int left, int right, int lower, int upper) &#123; int mid, i, res, j, k; if(left&gt;right) return 0; if(left==right) return ( (sum[left]&gt;=lower) &amp;&amp; (sum[left]&lt;=upper) )?1:0; else &#123; vector&lt;long long&gt; temp(right-left+1,0); mid = (left+right)/2; res = mergeSort(sum, left,mid, lower, upper) + mergeSort(sum, mid+1,right, lower, upper); // merge sort two halfs first, be careful about how to divide [left, mid] and [mid+1, right] for(i=left, j=k=mid+1; i&lt;=mid; ++i) &#123; // count the valid ranges [i,j], where i is in the first half and j is in the second half while(j&lt;=right &amp;&amp; sum[j]-sum[i]&lt;lower) ++j; while(k&lt;=right &amp;&amp; sum[k]-sum[i]&lt;=upper) ++k; res +=k-j; &#125; for(i=k=left, j=mid+1; k&lt;=right; ++k) //merge the sorted two halfs temp[k-left] = (i&lt;=mid) &amp;&amp; (j&gt;right || sum[i]&lt;sum[j])?sum[i++]:sum[j++]; for(k=left; k&lt;=right; ++k) // copy the sorted results back to sum sum[k] = temp[k-left]; return res; &#125; &#125;public: int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; int len = nums.size(), i; vector&lt;long long&gt; sum(len+1, 0); for(i=1; i&lt;=len; ++i) sum[i] = sum[i-1]+nums[i-1]; return mergeSort(sum, 1, len, lower, upper); &#125;&#125;; https://discuss.leetcode.com/topic/45522/c-merge-sort-solution-very-short C++ merge sort solution, very short 123456789101112131415161718192021222324class Solution &#123;public: int mergeSort(vector&lt;long&gt;&amp; sum, int lower, int upper, int low, int high) &#123; if(high-low &lt;= 1) return 0; int mid = (low+high)/2, m = mid, n = mid, count =0; count =mergeSort(sum,lower,upper,low,mid) +mergeSort(sum,lower,upper,mid,high); for(int i =low; i&lt; mid; i++) &#123; while(m &lt; high &amp;&amp; sum[m] - sum[i] &lt; lower) m++; while(n &lt; high &amp;&amp; sum[n] - sum[i] &lt;= upper) n++; count += n - m; &#125; inplace_merge(sum.begin()+low, sum.begin()+mid, sum.begin()+high); return count; &#125; int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; int len = nums.size(); vector&lt;long&gt; sum(len + 1, 0); for(int i =0; i&lt; len; i++) sum[i+1] = sum[i]+nums[i]; return mergeSort(sum, lower, upper, 0, len+1); &#125;&#125;; python https://discuss.leetcode.com/topic/33770/short-simple-o-n-log-n Short &amp; simple O(n log n) 1234567891011121314151617def countRangeSum(self, nums, lower, upper): first = [0] for num in nums: first.append(first[-1] + num) def sort(lo, hi): mid = (lo + hi) / 2 if mid == lo: return 0 count = sort(lo, mid) + sort(mid, hi) i = j = mid for left in first[lo:mid]: while i &lt; hi and first[i] - left &lt; lower: i += 1 while j &lt; hi and first[j] - left &lt;= upper: j += 1 count += j - i first[lo:hi] = sorted(first[lo:hi]) return count return sort(0, len(first)) First compute the prefix sums: first[m] is the sum of the first m numbers. Then the sum of any subarray nums[i:k] is simply first[k] - first[i]. So we just need to count those where first[k] - first[i] is in [lower,upper]. To find those pairs, I use mergesort with embedded counting. The pairs in the left half and the pairs in the right half get counted in the recursive calls. We just need to also count the pairs that use both halves. For each left in first[lo:mid] I find all right in first[mid:hi] so that right - left lies in [lower, upper]. Because the halves are sorted, these fitting right values are a subarray first[i:j]. With increasing left we must also increase right, meaning must we leave out first[i] if it’s too small and and we must include first[j] if it’s small enough. Besides the counting, I also need to actually merge the halves for the sorting. I let sorted do that, which uses Timsort and takes linear time to recognize and merge the already sorted halves. java https://discuss.leetcode.com/topic/33738/share-my-solution Share my solution First of all, let’s look at the naive solution. Preprocess to calculate the prefix sums S[i] = S(0, i), then S(i, j) = S[j] - S[i]. Note that here we define S(i, j) as the sum of range [i, j) where j exclusive and j &gt; i. With these prefix sums, it is trivial to see that with O(n^2) time we can find all S(i, j) in the range [lower, upper] Java - Naive Solution 123456789101112public int countRangeSum(int[] nums, int lower, int upper) &#123; int n = nums.length; long[] sums = new long[n + 1]; for (int i = 0; i &lt; n; ++i) sums[i + 1] = sums[i] + nums[i]; int ans = 0; for (int i = 0; i &lt; n; ++i) for (int j = i + 1; j &lt;= n; ++j) if (sums[j] - sums[i] &gt;= lower &amp;&amp; sums[j] - sums[i] &lt;= upper) ans++; return ans;&#125; However the naive solution is set to TLE intentionally Now let’s do better than this. Recall count smaller number after self where we encountered the problem count[i] = count of nums[j] - nums[i] &lt; 0 with j &gt; i Here, after we did the preprocess, we need to solve the problem count[i] = count of a &lt;= S[j] - S[i] &lt;= b with j &gt; i ans = sum(count[:]) Therefore the two problems are almost the same. We can use the same technique used in that problem to solve this problem. One solution is merge sort based; another one is Balanced BST based. The time complexity are both O(n log n). The merge sort based solution counts the answer while doing the merge. During the merge stage, we have already sorted the left half [start, mid) and right half [mid, end). We then iterate through the left half with index i. For each i, we need to find two indices k and j in the right half where j is the first index satisfy sums[j] - sums[i] &gt; upper and k is the first index satisfy sums[k] - sums[i] &gt;= lower.Then the number of sums in [lower, upper] is j-k. We also use another index t to copy the elements satisfy sums[t] &lt; sums[i] to a cache in order to complete the merge sort. Despite the nested loops, the time complexity of the “merge &amp; count” stage is still linear. Because the indices k, j, t will only increase but not decrease, each of them will only traversal the right half once at most. The total time complexity of this divide and conquer solution is then O(n log n). One other concern is that the sums may overflow integer. So we use long instead. Java - Merge Sort Solution 12345678910111213141516171819202122232425public int countRangeSum(int[] nums, int lower, int upper) &#123; int n = nums.length; long[] sums = new long[n + 1]; for (int i = 0; i &lt; n; ++i) sums[i + 1] = sums[i] + nums[i]; return countWhileMergeSort(sums, 0, n + 1, lower, upper);&#125;private int countWhileMergeSort(long[] sums, int start, int end, int lower, int upper) &#123; if (end - start &lt;= 1) return 0; int mid = (start + end) / 2; int count = countWhileMergeSort(sums, start, mid, lower, upper) + countWhileMergeSort(sums, mid, end, lower, upper); int j = mid, k = mid, t = mid; long[] cache = new long[end - start]; for (int i = start, r = 0; i &lt; mid; ++i, ++r) &#123; while (k &lt; end &amp;&amp; sums[k] - sums[i] &lt; lower) k++; while (j &lt; end &amp;&amp; sums[j] - sums[i] &lt;= upper) j++; while (t &lt; end &amp;&amp; sums[t] &lt; sums[i]) cache[r++] = sums[t++]; cache[r] = sums[i]; count += j - k; &#125; System.arraycopy(cache, 0, sums, start, t - start); return count;&#125; https://discuss.leetcode.com/topic/34108/summary-of-the-divide-and-conquer-based-and-binary-indexed-tree-based-solutions Summary of the Divide and Conquer based and Binary Indexed Tree based solutions Thanks for those contributing excellent ideas to this problem. Here is a quick summary of solutions based on either divide and conquer or binary indexed tree. To start, we already know there is a straightforward solution by computing each range sum and checking whether it lies in [lower, upper] or not. If the number of elements is n, we have n(n+1)/2 such range sums so the naive solution will end up with O(n^2) time complexity. Now we are asked to do better than that. So what are the targeted time complexities in your mind? When I first looked at the problem, my instinct is that O(n) solution is too ambitious, so I will target at linearithmic-like (O(n(logn)^b)) solutions. To get the logarithmic part, it’s natural to think of breaking down the original array, and that’s where the divide-and-conquer idea comes from. For this problem, we need some array to apply our divide and conquer algorithm. Without much thinking, we can do that directly with the input array (nums) itself. Since our problem also involves range sums and I believe you have the experience of computing range sums from prefix array of the input array, we might as well apply divide and conquer ideas on the prefix array. So I will give both the input-array based and prefix-array based divide&amp;conquer solutions. Let’s first look at input-array based divide&amp;conquer solution. Our original problem is like this: given an input array nums with length n and a range [lower, upper], find the total number of range sums that lie in the given range. Note the range [lower, upper] and the input array are both fixed. Therefore each range sum can be characterized by two indices i1 and i2 (i1 &lt;= i2), such that range sum S(i1, i2) is the summation of input elements with indices going from i1 up to i2 (both inclusive). Then our problem can be redefined in terms of the value ranges of i1 and i2. For example our original problem can be restated as finding the total number of range sums lying in the given range with 0 &lt;= i1 &lt;= i2 &lt;= n - 1, or in a symbolic way T(0, n-1). Now if we break our original input array into two subarrays, [0, m] and [m+1, n-1] with m = (n-1)/2, our original problem can be divided into three parts, depending on the values of i1 and i2. If i1 and i2 are both from the first subarray [0, m], we have a subproblem T(0, m); if i1 and i2 are both from the second subarray, we have a subproblem T(m+1, n-1); if i1 is from the first subarray and i2 from the second (note we assume i1 &lt;= i2, therefore we don’t have the other case with i2 from first subarray and i1 from second), then we have a new problem which I define as C. In summary we should have: T(0, n-1) = T(0, m) + T(m+1, n-1) + C Now from the master theorem, the time complexity of the new problem C should be better than O(n^2), otherwise we make no improvement by applying this divide&amp;conquer idea. So again, I will aim at linearithmic-like solutions for the new problem C: find the total number of range sums lying in the given range with each range sum starting from the first subarray and ending at the second subarray. First let’s try to compute all such range sums. The way I did it was first computing the prefix array of the second subarray and the suffix array (or “backward” prefix array if you like) of the first subarray. Then I can naively add each element in the suffix array to all elements in the prefix array to obtain all the possible range sums. Of course you end up with O(n^2) solution, as expected. So how can we approach it with better time complexity? Here are the facts I observed: for each element e in the suffix array, we need to add it to all elements in the prefix array. But the order in which we add it doesn’t matter. This implies that we can sort our prefix array. This can be done in O(nlogn) time. Now we have a sorted prefix array, do we still need to add the element e to all elements in the prefix array? The answer is no. Because our final goal is to compare the resulted range sums with the given range bounds lower and upper. It is equivalent to modifying the range bounds so we have new bounds (lower - e) and (upper - e) and leave the prefix array unchanged. Now we can compare these new bounds with the sorted prefix array, and I’m sure you can write your own binary search algorithm to do that. So for each element e in the suffix array, we can compute the modified range bounds and get the number of range sums in this new range in logn time. Therefore the total time will be O(nlogn). So in summary, our new problem C can be solved in O(nlogn) time and according to the master theorem, our original problem can be solved in O(n(logn)^2) time. The following is the complete java program: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public int countRangeSum(int[] nums, int lower, int upper) &#123; if (nums == null || nums.length == 0 || lower &gt; upper) return 0; return countRangeSumSub(nums, 0, nums.length - 1, lower, upper);&#125;private int countRangeSumSub(int[] nums, int l, int r, int lower, int upper) &#123; if (l == r) return nums[l] &gt;= lower &amp;&amp; nums[r] &lt;= upper ? 1 : 0; // base case int m = l + (r - l) / 2; long[] arr = new long[r - m]; // prefix array for the second subarray long sum = 0; int count = 0; for (int i = m + 1; i &lt;= r; i++) &#123; sum += nums[i]; arr[i - (m + 1)] = sum; // compute the prefix array &#125; Arrays.sort(arr); // sort the prefix array // Here we can compute the suffix array element by element. // For each element in the suffix array, we compute the corresponding // &quot;insertion&quot; indices of the modified bounds in the sorted prefix array // then the number of valid ranges sums will be given by the indices difference. // I modified the bounds to be &quot;double&quot; to avoid duplicate elements. sum = 0; for (int i = m; i &gt;= l; i--) &#123; sum += nums[i]; count += findIndex(arr, upper - sum + 0.5) - findIndex(arr, lower - sum - 0.5); &#125; return countRangeSumSub(nums, l, m, lower, upper) + countRangeSumSub(nums, m + 1, r, lower, upper) + count;&#125;// binary search functionprivate int findIndex(long[] arr, double val) &#123; int l = 0, r = arr.length - 1, m = 0; while (l &lt;= r) &#123; m = l + (r - l) / 2; if (arr[m] &lt;= val) &#123; l = m + 1; &#125; else &#123; r = m - 1; &#125; &#125; return l;&#125; (Next two parts will come in answers due to the limitation of maximum length of characters ) https://discuss.leetcode.com/topic/33734/java-segmenttree-solution-36ms Java SegmentTree Solution, 36ms Understand my segmentTree implementation is not optimized.Please feel free to give me suggestions. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Solution &#123; class SegmentTreeNode &#123; SegmentTreeNode left; SegmentTreeNode right; int count; long min; long max; public SegmentTreeNode(long min, long max) &#123; this.min = min; this.max = max; &#125; &#125; private SegmentTreeNode buildSegmentTree(Long[] valArr, int low, int high) &#123; if(low &gt; high) return null; SegmentTreeNode stn = new SegmentTreeNode(valArr[low], valArr[high]); if(low == high) return stn; int mid = (low + high)/2; stn.left = buildSegmentTree(valArr, low, mid); stn.right = buildSegmentTree(valArr, mid+1, high); return stn; &#125; private void updateSegmentTree(SegmentTreeNode stn, Long val) &#123; if(stn == null) return; if(val &gt;= stn.min &amp;&amp; val &lt;= stn.max) &#123; stn.count++; updateSegmentTree(stn.left, val); updateSegmentTree(stn.right, val); &#125; &#125; private int getCount(SegmentTreeNode stn, long min, long max) &#123; if(stn == null) return 0; if(min &gt; stn.max || max &lt; stn.min) return 0; if(min &lt;= stn.min &amp;&amp; max &gt;= stn.max) return stn.count; return getCount(stn.left, min, max) + getCount(stn.right, min, max); &#125; public int countRangeSum(int[] nums, int lower, int upper) &#123; if(nums == null || nums.length == 0) return 0; int ans = 0; Set&lt;Long&gt; valSet = new HashSet&lt;Long&gt;(); long sum = 0; for(int i = 0; i &lt; nums.length; i++) &#123; sum += (long) nums[i]; valSet.add(sum); &#125; Long[] valArr = valSet.toArray(new Long[0]); Arrays.sort(valArr); SegmentTreeNode root = buildSegmentTree(valArr, 0, valArr.length-1); for(int i = nums.length-1; i &gt;=0; i--) &#123; updateSegmentTree(root, sum); sum -= (long) nums[i]; ans += getCount(root, (long)lower+sum, (long)upper+sum); &#125; return ans; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>divide and conquer</tag>
        <tag>hard</tag>
        <tag>binary search tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[326. Power of Three]]></title>
    <url>%2Fp%2Fb3a4ad57%2F</url>
    <content type="text"><![CDATA[39.7% https://leetcode.com/problems/power-of-three/#/description Given an integer, write a function to determine if it is a power of three. Follow up: Could you do it without using any loop / recursion? 方法一： 我的代码实现： Oct 23， 2017 12345678class Solution &#123; int max3power = 1162261467;public: bool isPowerOfThree(int n) &#123; if(n&lt;=0 || n&gt;max3power) return false; return max3power%n == 0; &#125;&#125;; https://discuss.leetcode.com/topic/39293/without-log-and-o-1 Without log and O(1). 123456789class Solution &#123;public: int const Max3PowerInt = 1162261467; // 3^19, 3^20 = 3486784401 &gt; MaxInt32 int const MaxInt32 = 2147483647; // 2^31 - 1 bool isPowerOfThree(int n) &#123; if (n &lt;= 0 || n &gt; Max3PowerInt) return false; return Max3PowerInt % n == 0; &#125;&#125;; Typically, Log(x, y) is not O(1), it should be O(ln(N)), which just hides the loop/recursion . https://discuss.leetcode.com/topic/34990/1-line-c-no-recursion-loop 1 line C++ no recursion/loop 123456class Solution &#123;public: bool isPowerOfThree(int n) &#123; return fmod(log10(n)/log10(3), 1)==0; &#125;&#125;; https://discuss.leetcode.com/topic/33526/one-line-cheating One line (cheating) 12345public class Solution &#123;public bool IsPowerOfThree(int n) &#123; return n &gt; 0 &amp;&amp; (1162261467 % n == 0); &#125;&#125; https://discuss.leetcode.com/topic/43385/c-solution-no-loop-recursion C++ solution no loop / recursion 12345bool isPowerOfThree(int n) &#123; if (n&lt;=0) return false; int t = pow(3,(int)(log(INT_MAX)/log(3))); return (t%n == 0); &#125; t is maximum power of three https://discuss.leetcode.com/topic/36289/python-o-1-solution-96-6 Python O(1) Solution 96.6% 123class Solution(object): def isPowerOfThree(self, n): return n &gt; 0 and 1162261467 % n == 0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[324. Wiggle Sort II]]></title>
    <url>%2Fp%2F9fd1c6be%2F</url>
    <content type="text"><![CDATA[25.4% https://leetcode.com/problems/wiggle-sort-ii/?tab=Description Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]…. 123Example:(1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6]. (2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2]. Note: You may assume all input has valid answer. Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space? https://discuss.leetcode.com/topic/32929/o-n-o-1-after-median-virtual-indexing O(n)+O(1) after median — Virtual Indexing This post is mainly about what I call “virtual indexing” technique (I’m sure I’m not the first who came up with this, but I couldn’t find anything about it, so I made up a name as well. If you know better, let me know). Solution 12345678910111213141516171819202122void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); // Find a median. auto midptr = nums.begin() + n / 2; nth_element(nums.begin(), midptr, nums.end()); int mid = *midptr; // Index-rewiring. #define A(i) nums[(1+2*(i)) % (n|1)] // 3-way-partition-to-wiggly in O(n) time with O(1) space. int i = 0, j = 0, k = n - 1; while (j &lt;= k) &#123; if (A(j) &gt; mid) swap(A(i++), A(j++)); else if (A(j) &lt; mid) swap(A(j), A(k--)); else j++; &#125;&#125; Explanation First I find a median using nth_element. That only guarantees O(n) average time complexity and I don’t know about space complexity. I might write this myself using O(n) time and O(1) space, but that’s not what I want to show here. This post is about what comes after that. We can use three-way partitioning to arrange the numbers so that those larger than the median come first, then those equal to the median come next, and then those smaller than the median come last. Ordinarily, you’d then use one more phase to bring the numbers to their final positions to reach the overall wiggle-property. But I don’t know a nice O(1) space way for this. Instead, I embed this right into the partitioning algorithm. That algorithm simply works with indexes 0 to n-1 as usual, but sneaky as I am, I rewire those indexes where I want the numbers to actually end up. The partitioning-algorithm doesn’t even know that I’m doing that, it just works like normal (it just uses A(x) instead of nums[x]). Let’s say nums is [10,11,…,19]. Then after nth_element and ordinary partitioning, we might have this (15 is my median): 12index: 0 1 2 3 4 5 6 7 8 9number: 18 17 19 16 15 11 14 10 13 12 I rewire it so that the first spot has index 5, the second spot has index 0, etc, so that I might get this instead: 12index: 5 0 6 1 7 2 8 3 9 4number: 11 18 14 17 10 19 13 16 12 15 And 11 18 14 17 10 19 13 16 12 15 is perfectly wiggly. And the whole partitioning-to-wiggly-arrangement (everything after finding the median) only takes O(n) time and O(1) space. If the above description is unclear, maybe this explicit listing helps: 12345678910Accessing A(0) actually accesses nums[1].Accessing A(1) actually accesses nums[3].Accessing A(2) actually accesses nums[5].Accessing A(3) actually accesses nums[7].Accessing A(4) actually accesses nums[9].Accessing A(5) actually accesses nums[0].Accessing A(6) actually accesses nums[2].Accessing A(7) actually accesses nums[4].Accessing A(8) actually accesses nums[6].Accessing A(9) actually accesses nums[8]. Props to apolloydy’s solution, I knew the partitioning algorithm already but I didn’t know the name. And apolloydy’s idea to partition to reverse order happened to make the index rewiring simpler. https://discuss.leetcode.com/topic/41464/step-by-step-explanation-of-index-mapping-in-java Step by step explanation of index mapping in Java The virtual index idea in the post https://leetcode.com/discuss/77133/o-n-o-1-after-median-virtual-indexingis very brilliant! However, it takes me a while to understand why and how it works. There is no ‘nth_element’ in Java, but you can use ‘findKthLargest’ function from “https://leetcode.com/problems/kth-largest-element-in-an-array/&quot; to get the median element in average O(n) time and O(1) space. Assume your original array is {6,13,5,4,5,2}. After you get median element, the ‘nums’ is partially sorted such that the first half is larger or equal to the median, the second half is smaller or equal to the median, i.e 12313 6 5 5 4 2 M In the post https://leetcode.com/discuss/76965/3-lines-python-with-explanation-proof, we have learned that , to get wiggle sort, you want to put the number in the following way such that (1) elements smaller than the ‘median’ are put into the last even slots (2) elements larger than the ‘median’ are put into the first odd slots (3) the medians are put into the remaining slots. 123Index : 0 1 2 3 4 5Small half: M S S Large half: L L M M - Median, S-Small, L-Large. In this example, we want to put {13, 6, 5} in index 1,3,5 and {5,4,2} in index {0,2,4} The index mapping, (1 + 2 * index) % (n | 1) combined with ‘Color sort’, will do the job. After selecting the median element, which is 5 in this example, we continue as the following 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081Mapped_idx[Left] denotes the position where the next smaller-than median element will be inserted.Mapped_idx[Right] denotes the position where the next larger-than median element will be inserted.Step 1: Original idx: 0 1 2 3 4 5 Mapped idx: 1 3 5 0 2 4 Array: 13 6 5 5 4 2 Left i Right nums[Mapped_idx[i]] = nums[1] = 6 &gt; 5, so it is ok to put 6 in the first odd index 1. We increment i and left.Step 2: Original idx: 0 1 2 3 4 5 Mapped idx: 1 3 5 0 2 4 Array: 13 6 5 5 4 2 Left i Right nums[3] = 5 = 5, so it is ok to put 6 in the index 3. We increment i.Step 3: Original idx: 0 1 2 3 4 5 Mapped idx: 1 3 5 0 2 4 Array: 13 6 5 5 4 2 Left i Right nums[5] = 2 &lt; 5, so we want to put it to the last even index 4 (pointed by Right). So, we swap nums[Mapped_idx[i]] with nums[Mapped_idx[Right]], i.e. nums[5] with nums[4], and decrement Right. Step 4: Original idx: 0 1 2 3 4 5 Mapped idx: 1 3 5 0 2 4 Array: 13 6 5 5 2 4 Left i Right nums[5] = 4 &lt; 5, so we want to put it to the second last even index 2. So, we swap nums[5] with nums[2], and decrement Right. Step 5: Original idx: 0 1 2 3 4 5 Mapped idx: 1 3 5 0 2 4 Array: 13 6 4 5 2 5 Left i Right nums[5] = 5 &lt; 5, it is ok to put it there, we increment i.Step 6: Original idx: 0 1 2 3 4 5 Mapped idx: 1 3 5 0 2 4 Array: 13 6 4 5 2 5 Left i Right nums[0] = 13 &gt; 5, so, we want to put it to the next odd index which is 3 (pointed by &apos;Left&apos;). So, we swap nums[0] with nums[3], and increment &apos;Left&apos; and &apos;i&apos;.Step Final: Original idx: 0 1 2 3 4 5 Mapped idx: 1 3 5 0 2 4 Array: 5 6 4 13 2 5 Left i Righti &gt; Right, we get the final wiggle array 5 6 4 13 2 5 ! The code is the following: 12345678910111213141516171819202122232425public void wiggleSort(int[] nums) &#123; int median = findKthLargest(nums, (nums.length + 1) / 2); int n = nums.length; int left = 0, i = 0, right = n - 1; while (i &lt;= right) &#123; if (nums[newIndex(i,n)] &gt; median) &#123; swap(nums, newIndex(left++,n), newIndex(i++,n)); &#125; else if (nums[newIndex(i,n)] &lt; median) &#123; swap(nums, newIndex(right--,n), newIndex(i,n)); &#125; else &#123; i++; &#125; &#125;&#125;private int newIndex(int index, int n) &#123; return (1 + 2*index) % (n | 1);&#125; https://discuss.leetcode.com/topic/32861/3-lines-python-with-explanation-proof 3 lines Python, with Explanation / Proof Solution Roughly speaking I put the smaller half of the numbers on the even indexes and the larger half on the odd indexes. 1234def wiggleSort(self, nums): nums.sort() half = len(nums[::2]) nums[::2], nums[1::2] = nums[:half][::-1], nums[half:][::-1] Alternative, maybe nicer, maybe not: 1234def wiggleSort(self, nums): nums.sort() half = len(nums[::2]) - 1 nums[::2], nums[1::2] = nums[half::-1], nums[:half:-1] Explanation / Proof I put the smaller half of the numbers on the even indexes and the larger half on the odd indexes, both from right to left: 123456Example nums = [1,2,...,7] Example nums = [1,2,...,8] Small half: 4 . 3 . 2 . 1 Small half: 4 . 3 . 2 . 1 .Large half: . 7 . 6 . 5 . Large half: . 8 . 7 . 6 . 5-------------------------- --------------------------Together: 4 7 3 6 2 5 1 Together: 4 8 3 7 2 6 1 5 I want: Odd-index numbers are larger than their neighbors. Since I put the larger numbers on the odd indexes, clearly I already have: Odd-index numbers are larger than or equal to their neighbors. Could they be “equal to”? That would require some number M to appear both in the smaller and the larger half. It would be the largest in the smaller half and the smallest in the larger half. Examples again, where S means some number smaller than M and L means some number larger than M. 1234Small half: M . S . S . S Small half: M . S . S . S .Large half: . L . L . M . Large half: . L . L . L . M-------------------------- --------------------------Together: M L S L S M S Together: M L S L S L S M You can see the two M are quite far apart. Of course M could appear more than just twice, for example: 1234Small half: M . M . S . S Small half: M . S . S . S .Large half: . L . L . M . Large half: . L . M . M . M-------------------------- --------------------------Together: M L M L S M S Together: M L S M S M S M You can see that with seven numbers, three M are no problem. And with eight numbers, four M are no problem. Should be easy to see that in general, with n numbers, floor(n/2) times M is no problem. Now, if there were more M than that, then my method would fail. But… it would also be impossible: If n is even, then having more than n/2 times the same number clearly is unsolvable, because you’d have to put two of them next to each other, no matter how you arrange them. If n is odd, then the only way to successfully arrange a number appearing more than floor(n/2) times is if it appears exactly floor(n/2)+1 times and you put them on all the even indexes. And to have the wiggle-property, all the other numbers would have to be larger. But then we wouldn’t have an M in both the smaller and the larger half. So if the input has a valid answer at all, then my code will find one. https://discuss.leetcode.com/topic/32920/o-n-time-o-1-space-solution-with-detail-explanations O(n)-time O(1)-space solution with detail explanations Methodology: Idea 1. As @whnzinc pointed out in this thread, all elements in nums can be classified into three categories: (1) Larger than the median; (2) Equal to the median; (3) Smaller than the median. Note that it’s possible to find the median within O(n)-time and O(1)-space. Note: We can use nth_element to find the median, but it’s not O(n)-time and O(1)-space. For the sake of simplicity, I might use nth_element as well. Idea 2. As @StefanPochmann pointed out in this thread, we can arrange the elements in the three categories in a deterministic way. (1) Elements that are larger than the median: we can put them in the first few odd slots; (2) Elements that are smaller than the median: we can put them in the last few even slots; (3) Elements that equal the median: we can put them in the remaining slots. Update: According to @StefanPochmann’s thread, we can use a one-pass three-way partition to rearrange all elements. His idea is to re-map the indices into its destined indices, odd indices first and even indices follow. Example: 12Original Indices: 0 1 2 3 4 5 6 7 8 9 10 11Mapped Indices: 1 3 5 7 9 11 0 2 4 6 8 10 (its reverse mapping is) 12Mapped Indices: 0 1 2 3 4 5 6 7 8 9 10 11Original Indices: 6 0 7 1 8 2 9 3 10 4 11 5 (wiggled) In order to achieve this, we can use a function alike 123int map_index(int idx, int n) &#123; return (2 * idx + 1) % (n | 1);&#125; where (n | 1) calculates the nearest odd that is not less than n. Complexities: (On the condition that finding median is O(n)-time and O(1)-space) Time: O(n) Space: O(1) C++ (Updated, 44ms): 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) &#123; return; &#125; int n = nums.size(); // Step 1: Find the median vector&lt;int&gt;::iterator nth = next(nums.begin(), n / 2); nth_element(nums.begin(), nth, nums.end()); int median = *nth; // Step 2: Tripartie partition within O(n)-time &amp; O(1)-space. auto m = [n](int idx) &#123; return (2 * idx + 1) % (n | 1); &#125;; int first = 0, mid = 0, last = n - 1; while (mid &lt;= last) &#123; if (nums[m(mid)] &gt; median) &#123; swap(nums[m(first)], nums[m(mid)]); ++first; ++mid; &#125; else if (nums[m(mid)] &lt; median) &#123; swap(nums[m(mid)], nums[m(last)]); --last; &#125; else &#123; ++mid; &#125; &#125; &#125; &#125;; https://discuss.leetcode.com/topic/32882/short-simple-c Short simple C++ 123456void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; sorted(nums); sort(sorted.begin(), sorted.end()); for (int i=nums.size()-1, j=0, k=i/2+1; i&gt;=0; i--) nums[i] = sorted[i&amp;1 ? k++ : j++];&#125; Sort and then write the smaller half of the numbers on the even indexes and the larger half of the numbers on the odd indexes, both from the back. Example: 1234Small half: 4 . 3 . 2 . 1 . 0 .Large half: . 9 . 8 . 7 . 6 . 5----------------------------------Together: 4 9 3 8 2 7 1 6 0 5 So write nums from the back, interweaving sorted[0..4] (indexed by j) and sorted[5..9] (indexed by k). For more explanation/proof, see my equivalent Python solution. https://discuss.leetcode.com/topic/32923/simple-modulo-solution Simple modulo solution Once again I sort and then spread the numbers like in this example with nums=[0,1,…,9]: 1234Small half: 4 . 3 . 2 . 1 . 0 .Large half: . 9 . 8 . 7 . 6 . 5----------------------------------Together: 4 9 3 8 2 7 1 6 0 5 Just write the numbers 9, 8, 7, etc at indexes 1, 3, 5, etc. Use modulo to wrap around for the second round (the even indexes). Python 123def wiggleSort(self, nums): for i, num in enumerate(sorted(nums)[::-1]): nums[(1+2*i) % (len(nums)|1)] = num C++ 1234567void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; sorted(nums); sort(sorted.rbegin(), sorted.rend()); int n = nums.size(), m = n | 1; for (int i=0; i&lt;n; i++) nums[(1+2*i)%m] = sorted[i];&#125; Or: 1234567void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; sorted(nums); sort(sorted.rbegin(), sorted.rend()); int n = nums.size(), m = n | 1, i = -1; for (int num : sorted) nums[(i+=2)%m] = num;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[322. Coin Change]]></title>
    <url>%2Fp%2F283870ec%2F</url>
    <content type="text"><![CDATA[26.2% https://leetcode.com/problems/coin-change/#/description You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. 123Example 1:coins = [1, 2, 5], amount = 11return 3 (11 = 5 + 5 + 1) 123Example 2:coins = [2], amount = 3return -1. Note: You may assume that you have an infinite number of each kind of coin. 方法一： 动态规划 152ms, 44.44%, 180 / 180, April.27th, 2016 https://leetcode.com/discuss/76194/c-o-n-amount-time-o-amount-space-dp-solution [C++] O(n * amount) time O(amount) space DP solution 1234567891011121314class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; int Max = amount + 1; vector&lt;int&gt; dp(amount + 1, Max); dp[0] = 0; for(int i = 1; i &lt;= amount; i++)&#123; for(int j = 0; j &lt; coins.size(); j++) if(coins[j] &lt;= i) dp[i] = min(dp[i], dp[i - coins[j]] + 1); &#125; return dp[amount] &gt; amount ? -1 : dp[amount]; &#125;&#125;; 我的代码实现： 123456789101112131415161718class Solution &#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; if(amount&lt;=0) return 0; int n = coins.size(); if(n==0) return -1; vector&lt;int&gt; dp(amount+1, INT_MAX); dp[0] = 0; for(int i=0; i&lt;=amount; i++)&#123; for(int j=0; j&lt;n; j++) // 要判断前面的是否为INT_MAX if(coins[j]&lt;=i &amp;&amp; dp[i-coins[j]]!=INT_MAX) dp[i] = min(dp[i], dp[i-coins[j]]+1); &#125; // 此处需要判断一下，不能直接返回dp[amount] return dp[amount]==INT_MAX ? -1 : dp[amount]; &#125;&#125;; 方法二: 类似于方法一，dp算法，vector中保存的都是-1 其他思路相同，好处是返回值，直接返回了结果 https://discuss.leetcode.com/topic/32602/c-dp-solution-o-n-m-time-o-m-space C++ dp solution, O(N * M) time, O(M) space dp[i] means the solution of amount ‘i’. Initialise each element of the dp array to -1, then for each coin value c: 1). if i - c &lt; 0, do nothing. 2). if i - c &gt;= 0 and dp[i - c] != -1, means there is a solution of amount ‘i - c’, dp[i] = min(dp[i], dp[i - c] + 1) 12345678910111213141516class Solution&#123;public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; vector&lt;int&gt; dp(amount + 1, -1); dp[0] = 0; for (int i = 1; i &lt;= amount; ++i) for (auto &amp; c : coins) if (i - c &gt;= 0 &amp;&amp; dp[i - c] != -1) dp[i] = dp[i] &gt; 0 ? min(dp[i], dp[i - c] + 1) : dp[i - c] + 1; return dp[amount]; &#125;&#125;; https://discuss.leetcode.com/topic/32589/fast-python-bfs-solution Fast Python BFS Solution This solution is inspired by the BFS solution for problem Perfect Square. Since it is to find the least coin solution (like a shortest path from 0 to amount), using BFS gives results much faster than DP. 12345678910111213141516171819202122232425262728class Solution(object): def coinChange(self, coins, amount): &quot;&quot;&quot; :type coins: List[int] :type amount: int :rtype: int &quot;&quot;&quot; if amount == 0: return 0 value1 = [0] value2 = [] nc = 0 visited = [False]*(amount+1) visited[0] = True while value1: nc += 1 for v in value1: for coin in coins: newval = v + coin if newval == amount: return nc elif newval &gt; amount: continue elif not visited[newval]: visited[newval] = True value2.append(newval) value1, value2 = value2, [] return -1 https://discuss.leetcode.com/topic/32743/clean-dp-python-code Clean dp python code Assume dp[i] is the fewest number of coins making up amount i, then for every coin in coins, dp[i] = min(dp[i - coin] + 1). The time complexity is O(amount * coins.length) and the space complexity is O(amount) 123456789class Solution(object): def coinChange(self, coins, amount): MAX = float(&apos;inf&apos;) dp = [0] + [MAX] * amount for i in xrange(1, amount + 1): dp[i] = min([dp[i - c] if i - c &gt;= 0 else MAX for c in coins]) + 1 return [dp[amount], -1][dp[amount] == MAX] https://discuss.leetcode.com/topic/33840/fast-python-branch-and-bound-solution-beaten-99-python-submissions Fast python branch and bound solution, beaten 99% python submissions 12345678910111213141516171819202122232425262728293031323334353637383940414243def coinChange(self, coins, amount): if len(coins) == 0: return -1 if amount == 0: return 0 # try biggest coins first sortedCoins = sorted(coins, reverse=True) # upper bound on number of coins (+1 to represent the impossible case) upperBound = (amount + sortedCoins[-1] - 1) / sortedCoins[-1] + 1 self.bestNCoins = upperBound self.branchAndBoundSearch(sortedCoins, amount, 0) if self.bestNCoins == upperBound: return -1 else: return self.bestNCoinsdef branchAndBoundSearch(self, sortedCoins, amount, nCoins): # lower bound on number of coins, achieved using the biggest coin lowerBound = nCoins + (amount + sortedCoins[0] - 1) / sortedCoins[0] if lowerBound &gt; self.bestNCoins: return if len(sortedCoins) == 0: return # if amount matches the biggest coin, that is the solution if amount == sortedCoins[0] and nCoins + 1 &lt; self.bestNCoins: self.bestNCoins = nCoins + 1 return # try use the biggest coin if amount &gt; sortedCoins[0]: self.branchAndBoundSearch(sortedCoins, amount - sortedCoins[0], nCoins + 1) # else try not to use the biggest coin if len(sortedCoins) &gt; 1: self.branchAndBoundSearch(sortedCoins[1:], amount, nCoins) 308ms, 93.13%, 180 / 180, April.28th, 2016 https://leetcode.com/discuss/76737/clean-dp-python-code 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution(object): def coinChange(self, coins, amount): if len(coins) == 0: return -1 if amount == 0: return 0 # try biggest coins first sortedCoins = sorted(coins, reverse=True) # upper bound on number of coins (+1 to represent the impossible case) upperBound = (amount + sortedCoins[-1] - 1) / sortedCoins[-1] + 1 self.bestNCoins = upperBound self.branchAndBoundSearch(sortedCoins, amount, 0) if self.bestNCoins == upperBound: return -1 else: return self.bestNCoins def branchAndBoundSearch(self, sortedCoins, amount, nCoins): # lower bound on number of coins, achieved using the biggest coin lowerBound = nCoins + (amount + sortedCoins[0] - 1) / sortedCoins[0] if lowerBound &gt; self.bestNCoins: return if len(sortedCoins) == 0: return # if amount matches the biggest coin, that is the solution if amount == sortedCoins[0] and nCoins + 1 &lt; self.bestNCoins: self.bestNCoins = nCoins + 1 return # try use the biggest coin if amount &gt; sortedCoins[0]: self.branchAndBoundSearch(sortedCoins, amount - sortedCoins[0], nCoins + 1) # else try not to use the biggest coin if len(sortedCoins) &gt; 1: self.branchAndBoundSearch(sortedCoins[1:], amount, nCoins) solution 2: 1180ms, 180 / 180, April.28th, 2016 https://leetcode.com/discuss/76737/clean-dp-python-code 1234567891011121314class Solution(object): def coinChange(self, coins, amount): &quot;&quot;&quot; :type coins: List[int] :type amount: int :rtype: int &quot;&quot;&quot; MAX = float(&apos;inf&apos;) dp = [0] + [MAX] * amount for i in xrange(1, amount + 1): dp[i] = min([dp[i-c] + 1 if i - c &gt;= 0 else MAX for c in coins]) return dp[amount] if dp[amount] != MAX else -1]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[321. Create Maximum Number]]></title>
    <url>%2Fp%2F7a865502%2F</url>
    <content type="text"><![CDATA[24.5% https://leetcode.com/problems/create-maximum-number/ Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k &lt;= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits. You should try to optimize your time and space complexity. 12345Example 1:nums1 = [3, 4, 6, 5]nums2 = [9, 1, 2, 5, 8, 3]k = 5return [9, 8, 6, 5, 3] 12345Example 2:nums1 = [6, 7]nums2 = [6, 0, 4]k = 5return [6, 7, 6, 0, 4] 12345Example 3:nums1 = [3, 9]nums2 = [8, 9]k = 3return [9, 8, 9] cpp https://discuss.leetcode.com/topic/36805/c-16ms-fastest-beats-97 C++ 16ms, FASTEST, beats 97%. The basic idea: To create max number of length k from two arrays, you need to create max number of length i from array one and max number of length k-i from array two, then combine them together. After trying all possible i, you will get the max number created from two arrays. Optimization: Suppose nums1 = [3, 4, 6, 5], nums2 = [9, 1, 2, 5, 8, 3], the maximum number you can create from nums1 is [6, 5] with length 2. For nums2, it’s [9, 8, 3] with length 3. Merging the two sequence, we have [9, 8, 6, 5, 3], which is the max number we can create from two arrays without length constraint. If the required length k&lt;=5, we can simply trim the result to required length from front. For instance, if k=3, then [9, 8, 6] is the result. Suppose we need to create max number with length 2 from num = [4, 5, 3, 2, 1, 6, 0, 8]. The simple way is to use a stack, first we push 4 and have stack [4], then comes 5 &gt; 4, we pop 4 and push 5, stack becomes [5], 3 &lt; 5, we push 3, stack becomes [5, 3]. Now we have the required length 2, but we need to keep going through the array in case a larger number comes, 2 &lt; 3, we discard it instead of pushing it because the stack already grows to required size 2. 1 &lt; 3, we discard it. 6 &gt; 3, we pop 3, since 6 &gt; 5 and there are still elements left, we can continue to pop 5 and push 6, the stack becomes [6], since 0 &lt; 6, we push 0, the stack becomes [6, 0], the stack grows to required length again. Since 8 &gt; 0, we pop 0, although 8 &gt; 6, we can’t continue to pop 6 since there is only one number, which is 8, left, if we pop 6 and push 8, we can’t get to length 2, so we push 8 directly, the stack becomes [6, 8]. In the basic idea, we mentioned trying all possible length i. If we create max number for different i from scratch each time, that would be a waste of time. Suppose num = [4, 9, 3, 2, 1, 8, 7, 6], we need to create max number with length from 1 to 8. For i == 8, result is the original array. For i == 7, we need to drop 1 number from array, since 9 &gt; 4, we drop 4, the result is [9, 3, 2, 1, 8, 7, 6]. For i == 6, we need to drop 1 more number, 3 &lt; 9, skip, 2 &lt; 3, skip, 1 &lt; 2, skip, 8 &gt; 1, we drop 1, the result is [9, 3, 2, 8, 7, 6]. For i == 5, we need to drop 1 more, but this time, we needn’t check from beginning, during last scan, we already know [9, 3, 2] is monotonically non-increasing, so we check 8 directly, since 8 &gt; 2, we drop 2, the result is [9, 3, 8, 7, 6]. For i == 4, we start with 8, 8 &gt; 3, we drop 3, the result is [9, 8, 7, 6]. For i == 3, we start with 8, 8 &lt; 9, skip, 7 &lt; 8, skip, 6 &lt; 7, skip, by now, we’ve got maximum number we can create from num without length constraint. So from now on, we can drop a number from the end each time. The result is [9, 8, 7], For i == 2, we drop last number 7 and have [9, 8]. For i == 1, we drop last number 8 and have [9]. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Solution &#123;public: #define MIN(a,b) (a&lt;b?a:b) #define MAX(a,b) (a&gt;b?a:b) // create max number of length t from single non-empty vector void getMax(int* num, int&amp; len, int* result, int&amp; t, int&amp; sortedLen) &#123; int n, top = 0; result[0] = num[0]; const int need2drop = len - t; for (int i = 1; i &lt; len; ++i)&#123; n = num[i]; while (top &gt;= 0 &amp;&amp; result[top] &lt; n &amp;&amp; (i - top) &lt;= need2drop) --top; // i - top means already dropped i - top numbers if (i - top &gt; need2drop)&#123; sortedLen = MAX(1,top); while (++top &lt; t) result[top] = num[i++]; return; &#125; if (++top &lt; t) result[top] = n; else top = t - 1; &#125; &#125; // create max number of different length from single vector void dp(int *num, int len, int&amp;sortedLen, int&amp; minL, int&amp; maxL, int *res, int &amp;k)&#123; int j, *head, *prevhead = res; const int soi = sizeof(int); getMax(num, len, res, maxL,sortedLen); for (int l = maxL; l &gt; MAX(minL,1); --l)&#123; head = prevhead + k; memcpy(head, prevhead, l*soi); for (j = sortedLen; j &lt; l; ++j)&#123; if (head[j] &gt; head[j - 1])&#123; sortedLen = MAX(1, j - 1); memcpy(head + j - 1, prevhead + j, soi*(l - j)); break; &#125; &#125; if (j == l) sortedLen = l; prevhead = head; &#125; &#125; // merge max number created from single vector void merge(int* num1,int len1,int* num2,int len2,int* result,int&amp; resSize)&#123; int i = 0, j = 0, k = 0; while (i &lt; resSize)&#123; if (j &lt; len1 &amp;&amp; k &lt; len2)&#123; if (num1[j] &gt; num2[k]) result[i++] = num1[j++]; else if (num1[j] &lt; num2[k]) result[i++] = num2[k++]; else&#123; int remaining1 = len1 - j, remaining2 = len2 - k, tmp = num1[j]; int flag = memcmp(num1 + j, num2 + k, sizeof(int) * MIN(remaining1, remaining2)); flag = (flag == 0 ? (remaining1&gt;remaining2 ? 1 : -1) : flag); int * num = flag &gt; 0 ? num1 : num2; int &amp; cnt = flag &gt; 0 ? j : k; int len = flag &gt; 0 ? len1 : len2; while (num[cnt]==tmp &amp;&amp; cnt &lt; len &amp;&amp; i&lt;resSize) result[i++] = num[cnt++]; &#125; &#125; else if (j &lt; len1) result[i++] = num1[j++]; else result[i++] = num2[k++]; &#125; &#125; vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k)&#123; int soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size(), step = k*soi; int minL1 = MAX(0, k - len2), maxL1 = MIN(k, len1), minL2 = k - maxL1, maxL2 = k - minL1, range = maxL1 - minL1 + 1; int * res = new int[range * k * 2 + 2 * k], *dp1 = res + k, *dp2 = res + range*k+k, *tmp=res+range*2*k+k; memset(res, 0, step); int sortedLen1 = 1, sortedLen2 = 1; if (len1 == 0 &amp;&amp; len2 &gt; 0) getMax(&amp;nums2[0], len2, res, k, sortedLen2); else if (len1 &gt; 0 &amp;&amp; len2 == 0) getMax(&amp;nums1[0], len1, res, k, sortedLen2); else if (len1 &gt; 0 &amp;&amp; len2 &gt; 0)&#123; dp(&amp;nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k); dp(&amp;nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k); if (sortedLen1 + sortedLen2 &gt; k)&#123; merge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, tmp, k); vector&lt;int&gt; resv(tmp, tmp + k); delete[] res; return resv; &#125; for (int i = minL1; i &lt;= maxL1; ++i)&#123; merge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k); if (memcmp(res, tmp, step) &lt; 0) memcpy(res, tmp, step); &#125; &#125; vector&lt;int&gt; resv(res, res + k); delete[] res; return resv; &#125;&#125;; https://discuss.leetcode.com/topic/32298/short-python-ruby-c Translated it to C++ as well now. Not as short anymore, but still decent. And C++ allows different functions with the same name, so I chose to do that here to show how nicely the maxNumber(nums1, nums2, k) problem can be based on the problems maxNumber(nums, k) and maxNumber(nums1, nums2), which would make fine problems on their own. 1234567891011121314151617181920212223242526272829303132vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; int n1 = nums1.size(), n2 = nums2.size(); vector&lt;int&gt; best; for (int k1=max(k-n2, 0); k1&lt;=min(k, n1); ++k1) best = max(best, maxNumber(maxNumber(nums1, k1), maxNumber(nums2, k-k1))); return best;&#125;vector&lt;int&gt; maxNumber(vector&lt;int&gt; nums, int k) &#123; int drop = nums.size() - k; vector&lt;int&gt; out; for (int num : nums) &#123; while (drop &amp;&amp; out.size() &amp;&amp; out.back() &lt; num) &#123; out.pop_back(); drop--; &#125; out.push_back(num); &#125; out.resize(k); return out;&#125;vector&lt;int&gt; maxNumber(vector&lt;int&gt; nums1, vector&lt;int&gt; nums2) &#123; vector&lt;int&gt; out; while (nums1.size() + nums2.size()) &#123; vector&lt;int&gt;&amp; now = nums1 &gt; nums2 ? nums1 : nums2; out.push_back(now[0]); now.erase(now.begin()); &#125; return out;&#125; An alternative for maxNumber(nums1, nums2): 12345678vector&lt;int&gt; maxNumber(vector&lt;int&gt; nums1, vector&lt;int&gt; nums2) &#123; vector&lt;int&gt; out; auto i1 = nums1.begin(), end1 = nums1.end(); auto i2 = nums2.begin(), end2 = nums2.end(); while (i1 != end1 || i2 != end2) out.push_back(lexicographical_compare(i1, end1, i2, end2) ? *i2++ : *i1++); return out;&#125; python https://discuss.leetcode.com/topic/32298/short-python-ruby-c Short Python / Ruby / C++ 123456789101112131415161718def maxNumber(self, nums1, nums2, k): def prep(nums, k): drop = len(nums) - k out = [] for num in nums: while drop and out and out[-1] &lt; num: out.pop() drop -= 1 out.append(num) return out[:k] def merge(a, b): return [max(a, b).pop(0) for _ in a+b] return max(merge(prep(nums1, i), prep(nums2, k-i)) for i in range(k+1) if i &lt;= len(nums1) and k-i &lt;= len(nums2)) Solved it on my own but now I see others already posted this idea. Oh well, at least it’s short, particularly my merge function. The last two lines can be combined, but I find it rather ugly and not worth it:for i in range(max(k-len(nums2), 0), min(k, len(nums1))+1)) https://discuss.leetcode.com/topic/32281/share-my-python-solution-with-explanation Share my Python solution with explanation To create the max number from num1 and nums2 with k elements, we assume the final result combined by i numbers (denotes as left) from num1 and j numbers (denotes as right) from nums2, where i+j==k. Obviously, left and right must be the maximum possible number in num1 and num2 respectively. i.e. num1 = [6,5,7,1] and i == 2, then left must be [7,1]. The final result is the maximum possible merge of all left and right. So there’re 3 steps: iterate i from 0 to k. find max number from num1, num2 by select i , k-i numbers, denotes as left, right find max merge of left, right function maxSingleNumber select i elements from num1 that is maximum. The idea find the max number one by one. i.e. assume nums [6,5,7,1,4,2], selects = 3. 1st digit: find max digit in [6,5,7,1], the last two digits [4, 2] can not be selected at this moment. 2nd digits: find max digit in [1,4], since we have already selects 7, we should consider elements after it, also, we should leave one element out. 3rd digits: only one left [2], we select it. and function output [7,4,2] function mergeMax find the maximum combination of left, and right. 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution(object):def maxNumber(self, nums1, nums2, k): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :type k: int :rtype: List[int] &quot;&quot;&quot; n, m= len(nums1),len(nums2) ret = [0] * k for i in range(0, k+1): j = k - i if i &gt; n or j &gt; m: continue left = self.maxSingleNumber(nums1, i) right = self.maxSingleNumber(nums2, j) num = self.mergeMax(left, right) ret = max(num, ret) return retdef mergeMax(self, nums1, nums2): ans = [] while nums1 or nums2: if nums1 &gt; nums2: ans += nums1[0], nums1 = nums1[1:] else: ans += nums2[0], nums2 = nums2[1:] return ansdef maxSingleNumber(self, nums, selects): n = len(nums) ret = [-1] if selects &gt; n : return ret while selects &gt; 0: start = ret[-1] + 1 #search start end = n-selects + 1 #search end ret.append( max(range(start, end), key = nums.__getitem__)) selects -= 1 ret = [nums[item] for item in ret[1:]] return ret java https://discuss.leetcode.com/topic/32272/share-my-greedy-solution Share my greedy solution Many of the posts have the same algorithm. In short we can first solve 2 simpler problem Create the maximum number of one array Create the maximum number of two array using all of their digits. For an long and detailed explanation see my blog here. The algorithm is O((m+n)^3) in the worst case. It runs in 22 ms. 1234567891011121314151617181920212223242526272829303132public int[] maxNumber(int[] nums1, int[] nums2, int k) &#123; int n = nums1.length; int m = nums2.length; int[] ans = new int[k]; for (int i = Math.max(0, k - m); i &lt;= k &amp;&amp; i &lt;= n; ++i) &#123; int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k); if (greater(candidate, 0, ans, 0)) ans = candidate; &#125; return ans;&#125;private int[] merge(int[] nums1, int[] nums2, int k) &#123; int[] ans = new int[k]; for (int i = 0, j = 0, r = 0; r &lt; k; ++r) ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++]; return ans;&#125;public boolean greater(int[] nums1, int i, int[] nums2, int j) &#123; while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length &amp;&amp; nums1[i] == nums2[j]) &#123; i++; j++; &#125; return j == nums2.length || (i &lt; nums1.length &amp;&amp; nums1[i] &gt; nums2[j]);&#125;public int[] maxArray(int[] nums, int k) &#123; int n = nums.length; int[] ans = new int[k]; for (int i = 0, j = 0; i &lt; n; ++i) &#123; while (n - i + j &gt; k &amp;&amp; j &gt; 0 &amp;&amp; ans[j - 1] &lt; nums[i]) j--; if (j &lt; k) ans[j++] = nums[i]; &#125; return ans;&#125; http://52.20.106.37/create-maximum-number/ Create Maximum Number SolutionTo solve this problem, first let’s look at simpler version: Easy Version No. 1 Given one array of length n, create the maximum number of length k. The solution to this problem is Greedy with the help of stack. The recipe is as following Initialize a empty stack Loop through the array nums pop the top of stack if it is smaller than nums[i] until stack is empty the digits left is not enough to fill the stack to size k if stack size &lt; k push nums[i] Return stack Since the stack length is known to be k, it is very easy to use an array to simulate the stack.The time complexity is O(n) since each element is at most been pushed and popped once. Java 123456789public int[] maxArray(int[] nums, int k) &#123; int n = nums.length; int[] ans = new int[k]; for (int i = 0, j = 0; i &lt; n; ++i) &#123; while (n - i + j &gt; k &amp;&amp; j &gt; 0 &amp;&amp; ans[j - 1] &lt; nums[i]) j--; if (j &lt; k) ans[j++] = nums[i]; &#125; return ans;&#125; Easy Version No. 2 Given two array of length m and n, create maximum number of length k = m + n. OK, this version is a lot closer to our original problem with the exception that we will use all the digits we have. Still, for this version, Greedy is the first thing come to mind. We have k decisions to make, each time will just need to decide ans[i] is from which of the two. It seems obvious, we should always choose the larger one right? This is correct, but the problem is what should we do if they are equal? This is not so obvious. The correct answer is we need to see what behind the two to decide. For example, nums1 = [6, 7]nums2 = [6, 0, 4]k = 5ans = [6, 7, 6, 0, 4] We decide to choose the 6 from nums1 at step 1, because 7 &gt; 0. What if they are equal again? We continue to look the next digit until they are not equal. If all digits are equal then choose any one is ok. The procedure is like the merge in a merge sort. However due to the “look next until not equal”, the time complexity is O(nm). As @lixx2100 mentioned that it is possible to have a linear time merge algorithm based on suffix array. See here and here. But there isn’t a short implementation for suffix array construction in linear time. Java 12345678910111213private int[] merge(int[] nums1, int[] nums2, int k) &#123; int[] ans = new int[k]; for (int i = 0, j = 0, r = 0; r &lt; k; ++r) ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++]; return ans;&#125;public boolean greater(int[] nums1, int i, int[] nums2, int j) &#123; while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length &amp;&amp; nums1[i] == nums2[j]) &#123; i++; j++; &#125; return j == nums2.length || (i &lt; nums1.length &amp;&amp; nums1[i] &gt; nums2[j]);&#125; Final Solution Now let’s go back to the real problem. First, we divide the k digits required into two parts, i and k-i. We then find the maximum number of length i in one array and the maximum number of length k-i in the other array using the algorithm in section 1. Now we combine the two results in to one array using the algorithm in section 2. After that we compare the result with the result we have and keep the larger one as final answer. Java 12345678910public int[] maxNumber(int[] nums1, int[] nums2, int k) &#123; int n = nums1.length; int m = nums2.length; int[] ans = new int[k]; for (int i = Math.max(0, k - m); i &lt;= k &amp;&amp; i &lt;= n; ++i) &#123; int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k); if (greater(candidate, 0, ans, 0)) ans = candidate; &#125; return ans;&#125; https://discuss.leetcode.com/topic/32230/share-my-21ms-java-solution-with-comments Share my 21ms java solution with comments To find the maximum ,we can enumerate how digits we should get from nums1 , we suppose it is i. So , the digits from nums2 is K - i. And we can use a stack to get the get maximum number(x digits) from one array. OK, Once we choose two maximum subarray , we should combine it to the answer. It is just like merger sort, but we should pay attention to the case: the two digital are equal. we should find the digits behind it to judge which digital we should choose now. In other words,we should judge which subarry is bigger than the other. That’s all. If you have any question or suggest, I am happy you can comment on my blog : Create Maximum Number. Thanks, merry christmas :) update:use stack to find max sub array and it runs 21ms now.( thanks to @dietpepsi ) /* Created by hrwhisper on 2015/11/23. http://www.hrwhisper.me/leetcode-create-maximum-number/ / 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Solution &#123; public int[] maxNumber(int[] nums1, int[] nums2, int k) &#123; int get_from_nums1 = Math.min(nums1.length, k); int[] ans = new int[k]; for (int i = Math.max(k - nums2.length, 0); i &lt;= get_from_nums1; i++) &#123; int[] res1 = new int[i]; int[] res2 = new int[k - i]; int[] res = new int[k]; res1 = solve(nums1, i); res2 = solve(nums2, k - i); int pos1 = 0, pos2 = 0, tpos = 0; while (res1.length &gt; 0 &amp;&amp; res2.length &gt; 0 &amp;&amp; pos1 &lt; res1.length &amp;&amp; pos2 &lt; res2.length) &#123; if (compare(res1, pos1, res2, pos2)) res[tpos++] = res1[pos1++]; else res[tpos++] = res2[pos2++]; &#125; while (pos1 &lt; res1.length) res[tpos++] = res1[pos1++]; while (pos2 &lt; res2.length) res[tpos++] = res2[pos2++]; if (!compare(ans, 0, res, 0)) ans = res; &#125; return ans; &#125; public boolean compare(int[] nums1, int start1, int[] nums2, int start2) &#123; for (; start1 &lt; nums1.length &amp;&amp; start2 &lt; nums2.length; start1++, start2++) &#123; if (nums1[start1] &gt; nums2[start2]) return true; if (nums1[start1] &lt; nums2[start2]) return false; &#125; return start1 != nums1.length; &#125; public int[] solve(int[] nums, int k) &#123; int[] res = new int[k]; int len = 0; for (int i = 0; i &lt; nums.length; i++) &#123; while (len &gt; 0 &amp;&amp; len + nums.length - i &gt; k &amp;&amp; res[len - 1] &lt; nums[i]) &#123; len--; &#125; if (len &lt; k) res[len++] = nums[i]; &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[319. Bulb Switcher]]></title>
    <url>%2Fp%2Fb0914c42%2F</url>
    <content type="text"><![CDATA[42.0% https://leetcode.com/problems/bulb-switcher/#/description There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds. 12345678Example:Given n = 3. At first, the three bulbs are [off, off, off].After first round, the three bulbs are [on, on, on].After second round, the three bulbs are [on, off, on].After third round, the three bulbs are [on, off, off]. So you should return 1, because there is only one bulb is on. 方法一： 0ms, 2.80%, 35/35, April.24th, 2016 123456class Solution &#123;public: int bulbSwitch(int n) &#123; return sqrt(n); &#125;&#125;; python48ms, 15.20%, April.24th, 2016 1234567class Solution(object): def bulbSwitch(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; return int(n ** 0.5)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>brainteaser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[318. Maximum Product of Word Lengths]]></title>
    <url>%2Fp%2F27af2dd0%2F</url>
    <content type="text"><![CDATA[42.8% https://leetcode.com/problems/maximum-product-of-word-lengths/?tab=Description Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0. 1234Example 1:Given [&quot;abcw&quot;, &quot;baz&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;xtfn&quot;, &quot;abcdef&quot;]Return 16The two words can be &quot;abcw&quot;, &quot;xtfn&quot;. 1234Example 2:Given [&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;d&quot;, &quot;cd&quot;, &quot;bcd&quot;, &quot;abcd&quot;]Return 4The two words can be &quot;ab&quot;, &quot;cd&quot;. 1234Example 3:Given [&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;aaaa&quot;]Return 0No such pair of words. cpp https://discuss.leetcode.com/topic/31766/bit-shorter-c Bit shorter C++ Same algorithm as most, just written a bit shorter. 123456789101112int maxProduct(vector&lt;string&gt;&amp; words) &#123; vector&lt;int&gt; mask(words.size()); int result = 0; for (int i=0; i&lt;words.size(); ++i) &#123; for (char c : words[i]) mask[i] |= 1 &lt;&lt; (c - &apos;a&apos;); for (int j=0; j&lt;i; ++j) if (!(mask[i] &amp; mask[j])) result = max(result, int(words[i].size() * words[j].size())); &#125; return result;&#125; Update: Here’s an O(n+N) variation, where n is the number of words and N is the total number of characters in all words. Thanks to junhuangli for the suggestion. 123456789101112131415int maxProduct(vector&lt;string&gt;&amp; words) &#123; unordered_map&lt;int,int&gt; maxlen; for (string word : words) &#123; int mask = 0; for (char c : word) mask |= 1 &lt;&lt; (c - &apos;a&apos;); maxlen[mask] = max(maxlen[mask], (int) word.size()); &#125; int result = 0; for (auto a : maxlen) for (auto b : maxlen) if (!(a.first &amp; b.first)) result = max(result, a.second * b.second); return result;&#125; Or: (thanks to junhuangli’s further comment) 1234567891011121314int maxProduct(vector&lt;string&gt;&amp; words) &#123; unordered_map&lt;int,int&gt; maxlen; int result = 0; for (string word : words) &#123; int mask = 0; for (char c : word) mask |= 1 &lt;&lt; (c - &apos;a&apos;); maxlen[mask] = max(maxlen[mask], (int) word.size()); for (auto maskAndLen : maxlen) if (!(mask &amp; maskAndLen.first)) result = max(result, (int) word.size() * maskAndLen.second); &#125; return result;&#125; https://discuss.leetcode.com/topic/31753/116ms-c-solution-use-early-pruning-faster-than-most-o-n-2 116ms c++ solution use early pruning (faster than most O(N^2)) Sort the vector first according to the length of string. Then use some early pruning to fasten the process. The worst cases would still be O(N^2). It’s faster than most O(N^2) solutions. I don’t know whether we can do better. (Binary Search Seems Not work here) Any comments is welcomed. Update: We can use counting sort to improve the time complexity of sorting to O(N). 1234567891011121314151617181920212223242526class Solution &#123;public: int maxProduct(vector&lt;string&gt;&amp; words) &#123; int s=words.size(); if(s==0) return 0; vector&lt;int&gt; bit(s,0); sort(words.begin(), words.end(), compare); //sort the vector from longest to shortest for(int i=0; i&lt;s; i++)&#123; //bit manipulation for(int j=0; j&lt;words[i].size(); j++) bit[i] |=(1&lt;&lt;(words[i][j]-&apos;a&apos;)); &#125; int maxlength=0; for(int i=0; i&lt;s-1; i++)&#123; int si=words[i].size(); if(si*si&lt;=maxlength) break; //early pruning for(int j=i+1; j&lt;s; j++)&#123; int sj=words[j].size(); if(si*sj&lt;=maxlength) break; //early pruning if((bit[i]&amp;bit[j])==0) maxlength=si*sj; &#125; &#125; return maxlength; &#125; static bool compare(string a, string b)&#123; return a.size()&gt;b.size(); &#125;&#125;; https://discuss.leetcode.com/topic/40001/c-25-lines-96ms-straight-forward-solution C++, 25 lines, 96ms, straight-forward solution 12345678910111213141516171819202122232425262728class Solution &#123; public: int set_bit(string&amp; str)&#123; int mybits = 0; for (char c : str)&#123; mybits |= (1 &lt;&lt; (c-&apos;a&apos;)); if ((mybits == 0x3FFFFFF)) break; &#125; return mybits; &#125; int maxProduct(vector&lt;string&gt;&amp; words) &#123; int m_val = 0, w_size = words.size(); int m[w_size], m_w_size[w_size]; for(int i = 0; i &lt; w_size; i++) &#123; m[i] = set_bit(words[i]); m_w_size[i] = words[i].size(); &#125; for (int i = 0; i &lt; w_size; i++) for (int j = i+1; j &lt; w_size; j++) if ((m[i] &amp; m[j])==0) m_val = max((int)(m_w_size[i] * m_w_size[j]), m_val); return m_val; &#125;&#125;; python https://discuss.leetcode.com/topic/46685/python-solution-beats-99-67 Python solution, beats 99.67% 123456789class Solution(object): def maxProduct(self, words): d = &#123;&#125; for w in words: mask = 0 for c in set(w): mask |= (1 &lt;&lt; (ord(c) - 97)) d[mask] = max(d.get(mask, 0), len(w)) return max([d[x] * d[y] for x in d for y in d if not x &amp; y] or [0]) java https://discuss.leetcode.com/topic/35539/java-easy-version-to-understand JAVA———-Easy Version To Understand!!!!!!!!!!!!!!!!! 1234567891011121314151617181920public static int maxProduct(String[] words) &#123; if (words == null || words.length == 0) return 0; int len = words.length; int[] value = new int[len]; for (int i = 0; i &lt; len; i++) &#123; String tmp = words[i]; value[i] = 0; for (int j = 0; j &lt; tmp.length(); j++) &#123; value[i] |= 1 &lt;&lt; (tmp.charAt(j) - &apos;a&apos;); &#125; &#125; int maxProduct = 0; for (int i = 0; i &lt; len; i++) for (int j = i + 1; j &lt; len; j++) &#123; if ((value[i] &amp; value[j]) == 0 &amp;&amp; (words[i].length() * words[j].length() &gt; maxProduct)) maxProduct = words[i].length() * words[j].length(); &#125; return maxProduct;&#125; https://discuss.leetcode.com/topic/31769/32ms-java-ac-solution 32ms Java AC solution 12345678910111213141516171819202122232425262728293031public class Solution &#123; public int maxProduct(String[] words) &#123; int max = 0; Arrays.sort(words, new Comparator&lt;String&gt;()&#123; public int compare(String a, String b)&#123; return b.length() - a.length(); &#125; &#125;); int[] masks = new int[words.length]; // alphabet masks for(int i = 0; i &lt; masks.length; i++)&#123; for(char c: words[i].toCharArray())&#123; masks[i] |= 1 &lt;&lt; (c - &apos;a&apos;); &#125; &#125; for(int i = 0; i &lt; masks.length; i++)&#123; if(words[i].length() * words[i].length() &lt;= max) break; //prunning for(int j = i + 1; j &lt; masks.length; j++)&#123; if((masks[i] &amp; masks[j]) == 0)&#123; max = Math.max(max, words[i].length() * words[j].length()); break; //prunning &#125; &#125; &#125; return max; &#125;&#125; https://discuss.leetcode.com/topic/31739/bit-manipulation-java-o-n-2 Bit manipulation Java O(n^2) 12345678910111213141516171819public class Solution &#123; public int maxProduct(String[] words) &#123; int max = 0; int[] bytes = new int[words.length]; for(int i=0;i&lt;words.length;i++)&#123; int val = 0; for(int j=0;j&lt;words[i].length();j++)&#123; val |= 1&lt;&lt;(words[i].charAt(j)-&apos;a&apos;); &#125; bytes[i] = val; &#125; for(int i=0; i&lt;bytes.length; i++)&#123; for(int j=i+1; j&lt;bytes.length; j++)&#123; if((bytes[i] &amp; bytes[j])==0)max = Math.max(max,words[i].length()*words[j].length()); &#125; &#125; return max; &#125;&#125; Pre-process the word, use bit to represent the words. We can do this because we only need to compare if two words contains the same characters.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[316. Remove Duplicate Letters]]></title>
    <url>%2Fp%2Fccb269ad%2F</url>
    <content type="text"><![CDATA[29.6% https://leetcode.com/problems/remove-duplicate-letters/ Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. 123456Example:Given &quot;bcabc&quot;Return &quot;abc&quot;Given &quot;cbacdcbc&quot;Return &quot;acdb&quot; 方法一: 代码中有bug 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string removeDuplicateLetters(string s) &#123; string res = ""; unordered_map&lt;char, int&gt; map; int n = s.size(); for(int i=0; i&lt;n; i++) map[s[i]] = i; int i=0, j, k, l; while(i&lt;n &amp;&amp; map.size())&#123; char c = s[i]; j = min_index(map); for(k=i+1; k&lt;=j; k++)&#123; if(s[k]&lt;s[i])&#123; l = k; c = s[k]; &#125; &#125; res += c; map.erase(c); i = l+1; &#125; return res; &#125; int min_index(unordered_map&lt;char, int&gt;&amp; map)&#123; int index = map.size(); for(auto it=map.begin(); it!=map.end(); it++) index = min(index, it-&gt;second); return index; &#125;&#125;; https://discuss.leetcode.com/topic/31413/easy-to-understand-iterative-java-solution The basic idea is to find out the smallest result letter by letter (one letter at a time). Here is the thinking process for input “cbacdcbc”: find out the last appeared position for each letter;c - 7b - 6a - 2d - 4 find out the smallest index from the map in step 1 (a - 2); the first letter in the final result must be the smallest letter from index 0 to index 2; repeat step 2 to 3 to find out remaining letters. the smallest letter from index 0 to index 2: a the smallest letter from index 3 to index 4: c the smallest letter from index 4 to index 4: d the smallest letter from index 5 to index 6: bso the result is “acdb” Notes: after one letter is determined in step 3, it need to be removed from the “last appeared position map”, and the same letter should be ignored in the following stepsin step 3, the beginning index of the search range should be the index of previous determined letter plus one123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public String removeDuplicateLetters(String s) &#123; if (s == null || s.length() &lt;= 1) return s; Map&lt;Character, Integer&gt; lastPosMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; lastPosMap.put(s.charAt(i), i); &#125; char[] result = new char[lastPosMap.size()]; int begin = 0, end = findMinLastPos(lastPosMap); for (int i = 0; i &lt; result.length; i++) &#123; char minChar = &apos;z&apos; + 1; for (int k = begin; k &lt;= end; k++) &#123; if (lastPosMap.containsKey(s.charAt(k)) &amp;&amp; s.charAt(k) &lt; minChar) &#123; minChar = s.charAt(k); begin = k+1; &#125; &#125; result[i] = minChar; if (i == result.length-1) break; lastPosMap.remove(minChar); if (s.charAt(end) == minChar) end = findMinLastPos(lastPosMap); &#125; return new String(result); &#125; private int findMinLastPos(Map&lt;Character, Integer&gt; lastPosMap) &#123; if (lastPosMap == null || lastPosMap.isEmpty()) return -1; int minLastPos = Integer.MAX_VALUE; for (int lastPos : lastPosMap.values()) &#123; minLastPos = Math.min(minLastPos, lastPos); &#125; return minLastPos; &#125;&#125; cpp https://discuss.leetcode.com/topic/32172/c-simple-solution-easy-understanding C++ simple solution easy understanding 123456789101112131415161718string removeDuplicateLetters(string s) &#123; vector&lt;int&gt; cand(256, 0); vector&lt;bool&gt; visited(256, false); for (char c : s) cand[c]++; string result = &quot;0&quot;; for (char c : s) &#123; cand[c]--; if (visited[c]) continue; while (c &lt; result.back() &amp;&amp; cand[result.back()]) &#123; visited[result.back()] = false; result.pop_back(); &#125; result += c; visited[c] = true; &#125; return result.substr(1);&#125; I think this solution is really concise! But I want to add some detailed explainations to show why we do so to solve the problem, This problem is in fact similiar to the problem “Largest Rectangle under the histogram “ We need to keep the monotically decreasing substring that contains all the char in the s. So we just use a vector to mimic the stack! Just similiar to the previous many solutions that use the vector to simulate a stack. In fact this problem is also similiar to the problem that the maximum in the sliding windows, I strongly recommend you to grasp the sliding windows solutions. Here is the AC C++ implementation 12345678910111213141516171819202122class Solution &#123;public: string removeDuplicateLetters(string s) &#123; vector&lt;int&gt; dict(256, 0); vector&lt;bool&gt; visited(256, false); for(auto ch : s) dict[ch]++; string result = &quot;0&quot;; /** the key idea is to keep a monotically increasing sequence **/ for(auto c : s) &#123; dict[c]--; /** to filter the previously visited elements **/ if(visited[c]) continue; while(c &lt; result.back() &amp;&amp; dict[result.back()]) &#123; visited[result.back()] = false; result.pop_back(); &#125; result += c; visited[c] = true; &#125; return result.substr(1); &#125;&#125;; https://discuss.leetcode.com/topic/31436/short-16ms-o-n-c-solution-using-stack-which-can-be-optimized-down-to-4ms Short 16ms O(n) c++ solution using stack which can be optimized down to 4ms 12345678910111213141516171819202122232425class Solution &#123;public: string removeDuplicateLetters(string s) &#123; unordered_map&lt;char, int&gt; cnts; string ret; stack&lt;char&gt; stk; vector&lt;bool&gt; isVisited(26, false); for (char each : s) cnts[each] ++; for (int i = 0; i &lt; s.size(); cnts[s[i]] --, ++ i) &#123; if (isVisited[s[i] - &apos;a&apos;] || (!stk.empty() &amp;&amp; stk.top() == s[i])) continue; while (!stk.empty() &amp;&amp; stk.top() &gt; s[i] &amp;&amp; cnts[stk.top()] &gt; 0) &#123; isVisited[stk.top() - &apos;a&apos;] = false; stk.pop(); &#125; stk.push(s[i]); isVisited[s[i] - &apos;a&apos;] = true; &#125; while (!stk.empty()) &#123; ret.push_back(stk.top()); stk.pop(); &#125; reverse(ret.begin(), ret.end()); return ret; &#125;&#125;; python https://discuss.leetcode.com/topic/31561/some-python-solutions Some Python solutions Solutions inspired by those of others. Simpler but less efficient (all still get accepted, of course, in about 50 to 100 ms, normal for Python). Solution 1 Inspired by lixx2100’s explanation. 123456def removeDuplicateLetters(self, s): for c in sorted(set(s)): suffix = s[s.index(c):] if set(suffix) == set(s): return c + self.removeDuplicateLetters(suffix.replace(c, &apos;&apos;)) return &apos;&apos; Solution 2 Inspired by WHJ425’s explanation. 12345678def removeDuplicateLetters(self, s): result = &apos;&apos; while s: i = min(map(s.rindex, set(s))) c = min(s[:i+1]) result += c s = s[s.index(c):].replace(c, &apos;&apos;) return result Solution 3 Inspired by halibut735’s solution. 123456789def removeDuplicateLetters(self, s): rindex = &#123;c: i for i, c in enumerate(s)&#125; result = &apos;&apos; for i, c in enumerate(s): if c not in result: while c &lt; result[-1:] and i &lt; rindex[result[-1]]: result = result[:-1] result += c return result java https://discuss.leetcode.com/topic/31404/a-short-o-n-recursive-greedy-solution Given the string s, the greedy choice (i.e., the leftmost letter in the answer) is the smallest s[i], s.t.the suffix s[i .. ] contains all the unique letters. (Note that, when there are more than one smallest s[i]’s, we choose the leftmost one. Why? Simply consider the example: “abcacb”.) After determining the greedy choice s[i], we get a new string s’ from s by removing all letters to the left of s[i], removing all s[i]’s from s. We then recursively solve the problem w.r.t. s’. The runtime is O(26 * n) = O(n). 123456789101112public class Solution &#123; public String removeDuplicateLetters(String s) &#123; int[] cnt = new int[26]; int pos = 0; // the position for the smallest s[i] for (int i = 0; i &lt; s.length(); i++) cnt[s.charAt(i) - &apos;a&apos;]++; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) &lt; s.charAt(pos)) pos = i; if (--cnt[s.charAt(i) - &apos;a&apos;] == 0) break; &#125; return s.length() == 0 ? &quot;&quot; : s.charAt(pos) + removeDuplicateLetters(s.substring(pos + 1).replaceAll(&quot;&quot; + s.charAt(pos), &quot;&quot;)); &#125;&#125; https://discuss.leetcode.com/topic/32259/java-solution-using-stack-with-comments Java solution using Stack with comments 12345678910111213141516171819202122232425262728293031public String removeDuplicateLetters(String sr) &#123; int[] res = new int[26]; //will contain number of occurences of character (i+&apos;a&apos;) boolean[] visited = new boolean[26]; //will contain if character (i+&apos;a&apos;) is present in current result Stack char[] ch = sr.toCharArray(); for(char c: ch)&#123; //count number of occurences of character res[c-&apos;a&apos;]++; &#125; Stack&lt;Character&gt; st = new Stack&lt;&gt;(); // answer stack int index; for(char s:ch)&#123; index= s-&apos;a&apos;; res[index]--; //decrement number of characters remaining in the string to be analysed if(visited[index]) //if character is already present in stack, dont bother continue; //if current character is smaller than last character in stack which occurs later in the string again //it can be removed and added later e.g stack = bc remaining string abc then a can pop b and then c while(!st.isEmpty() &amp;&amp; s&lt;st.peek() &amp;&amp; res[st.peek()-&apos;a&apos;]!=0)&#123; visited[st.pop()-&apos;a&apos;]=false; &#125; st.push(s); //add current character and mark it as visited visited[index]=true; &#125; StringBuilder sb = new StringBuilder(); //pop character from stack and build answer string from back while(!st.isEmpty())&#123; sb.insert(0,st.pop()); &#125; return sb.toString();&#125; https://discuss.leetcode.com/topic/31424/15-ms-java-solution 15 ms Java solution for “cbacdcbc”, we counts each letter’s index: 1234a----2b----1,6c----0,3,5,7d----4 we go from a to d, to find the first letter who has a index smaller than the largest index of the rest. Here, index 2 of letter a is smaller than 6, 7, 4, so we first pick a; then we remove all index smaller than 2, and we have: 123b----6c----3,5,7d----4 the next round we pick c not b, why ? cuz 6 of b is larger than 4, but 3 of c is smaller than 4 and 6. 12b---6d---4 then we pick d and b to form “acdb” O(n) time to count index, and as we only have 26 letters, it’s about O(26 * 26) to find a candidate letter and O(n) time to remove all index. So I think the running time is O(n). 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Solution &#123; public String removeDuplicateLetters(String s) &#123; HashMap&lt;Character, ArrayList&lt;Integer&gt;&gt; counts = new HashMap&lt;Character, ArrayList&lt;Integer&gt;&gt;(); ArrayList&lt;Character&gt; keys = new ArrayList&lt;Character&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (!counts.containsKey(c)) &#123; counts.put(c, new ArrayList&lt;Integer&gt;()); keys.add(c); &#125; counts.get(c).add(i); &#125; Collections.sort(keys); StringBuilder sb = new StringBuilder(); while (!counts.isEmpty()) &#123; boolean found = true; for (int i = 0; i &lt; keys.size(); i++) &#123; int index = counts.get(keys.get(i)).get(0); for (int j = 0; j &lt; keys.size(); j++) &#123; ArrayList&lt;Integer&gt; count = counts.get(keys.get(j)); if (count.get(count.size() - 1) &lt; index) &#123; found = false; break; &#125; &#125; if (found) &#123; sb.append(keys.get(i)); counts.remove(keys.get(i)); keys.remove(i); for (int j = 0; j &lt; keys.size(); j++) &#123; ArrayList&lt;Integer&gt; count = counts.get(keys.get(j)); while (count.get(0) &lt; index) &#123; count.remove(0); &#125; &#125; break; &#125; found = true; &#125; &#125; return sb.toString(); &#125;&#125; https://discuss.leetcode.com/topic/43469/java-o-n-solution-using-stack-with-detail-explanation Java O(n) solution using stack with detail explanation First, given “bcabc”, the solution should be “abc”. If we think about this problem intuitively, you would sort of go from the beginning of the string and start removing one if there is still the same character left and a smaller character is after it. Given “bcabc”, when you see a ‘b’, keep it and continue with the search, then keep the following ‘c’, then we see an ‘a’. Now we get a chance to get a smaller lexi order, you can check if after ‘a’, there is still ‘b’ and ‘c’ or not. We indeed have them and “abc” will be our result. Come to the implementation, we need some data structure to store the previous characters ‘b’ and ‘c’, and we need to compare the current character with previous saved ones, and if there are multiple same characters, we prefer left ones. This calls for a stack. After we decided to use stack, the implementation becomes clearer. From the intuition, we know that we need to know if there are still remaining characters left or not. So we need to iterate the array and save how many each characters are there. A visited array is also required since we want unique character in the solution. The line while(!stack.isEmpty() &amp;&amp; stack.peek() &gt; c &amp;&amp; count[stack.peek()-‘a’] &gt; 0) checks that the queued character should be removed or not, like the ‘b’ and ‘c’ in the previous example. After removing the previous characters, push in the new char and mark the visited array. Time complexity: O(n), n is the number of chars in string. Space complexity: O(n) worst case. 1234567891011121314151617181920212223242526public String removeDuplicateLetters(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); int[] count = new int[26]; char[] arr = s.toCharArray(); for(char c : arr) &#123; count[c-&apos;a&apos;]++; &#125; boolean[] visited = new boolean[26]; for(char c : arr) &#123; count[c-&apos;a&apos;]--; if(visited[c-&apos;a&apos;]) &#123; continue; &#125; while(!stack.isEmpty() &amp;&amp; stack.peek() &gt; c &amp;&amp; count[stack.peek()-&apos;a&apos;] &gt; 0) &#123; visited[stack.peek()-&apos;a&apos;] = false; stack.pop(); &#125; stack.push(c); visited[c-&apos;a&apos;] = true; &#125; StringBuilder sb = new StringBuilder(); for(char c : stack) &#123; sb.append(c); &#125; return sb.toString();&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>stack</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[315. Count of Smaller Numbers After Self]]></title>
    <url>%2Fp%2F6c1c7aa1%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/count-of-smaller-numbers-after-self/?tab=Description You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. 123456789Example:Given nums = [5, 2, 6, 1]To the right of 5 there are 2 smaller elements (2 and 1).To the right of 2 there is only 1 smaller element (1).To the right of 6 there is 1 smaller element (1).To the right of 1 there is 0 smaller element.Return the array [2, 1, 1, 0]. cpp https://discuss.leetcode.com/topic/31288/c-o-nlogn-time-o-n-space-mergesort-solution-with-detail-explanation C++ O(nlogn)-Time O(n)-Space MergeSort Solution with Detail Explanation MergeSort-based solution is a standard way to solve problems related to inverse numbers. Here is an example to illustrate the general idea of MergeSort-based algorithm: Now we want to consider an array 16 4 1 8 7 5 2 9 First thing first, split the array into to subarrays: 126 4 1 87 5 2 9 and then calculate the inverse numbers within the group: 121 4(1) 6(1,4) 82 5(2) 7(2,5) 9 where the numbers in the parentheses are the numbers that should be counted when we calculate the inverse number.Now we need to merge these two arrays into one sorted array. The first element to be put into the sorted destination array is the “1” in the first array. 121 4(1) 6(1,4) 8 2 5(2) 7(2,5) 9 merged elements in the 2nd array = () The second element to merge is the “2” in the second array: 121 2 4(1) 6(1,4) 8 5(2) 7(2,5) 9 merged elements in the 2nd array = (2) The third element to merge is the “4” in the first array: 121 2 4(1,2) 6(1,4) 8 5(2) 7(2,5) 9 merged elements in the 2nd array = (2) When we merge the “4(1)”, we found that “4” is actually greater than all merged elements in the second array (i.e. [2]). Therefore, we also need to consider those elements. Therefore, the numbers in the parenthese of 2 become (1)+(2) = (1,2). Next step: 121 2 4(1,2) 5(2) 6(1,4) 8 7(2,5) 9 merged elements in the 2nd array = (2,5) Next (add the inverse number of element “6” by 2) 121 2 4(1,2) 5(2) 6(1,4,2,5) 8 7(2,5) 9 merged elements in the 2nd array = (2,5) So and so forth, finally reach 121 2 4(1,2) 5(2) 6(1,4,2,5) 7(2,5) 8(2,5,7) 9 merged elements in the 2nd array = (2,5,7,9) Additionally, when we need to count the inverse number, we do not need to record the exact elements, we only need to record the numbers. So, we can use a variable to record the number of “merged elements in the 2nd array” (for example, semilen in the code beneath) and the number of smaller elements of each element (for example, results[idx] in the code beneath). Complexities: Time: O(n log n) Space: O(n) C++ Accepted Code: 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;protected: void merge_countSmaller(vector&lt;int&gt;&amp; indices, int first, int last, vector&lt;int&gt;&amp; results, vector&lt;int&gt;&amp; nums) &#123; int count = last - first; if (count &gt; 1) &#123; int step = count / 2; int mid = first + step; merge_countSmaller(indices, first, mid, results, nums); merge_countSmaller(indices, mid, last, results, nums); vector&lt;int&gt; tmp; tmp.reserve(count); int idx1 = first; int idx2 = mid; int semicount = 0; while ((idx1 &lt; mid) || (idx2 &lt; last)) &#123; if ((idx2 == last) || ((idx1 &lt; mid) &amp;&amp; (nums[indices[idx1]] &lt;= nums[indices[idx2]]))) &#123; tmp.push_back(indices[idx1]); results[indices[idx1]] += semicount; ++idx1; &#125; else &#123; tmp.push_back(indices[idx2]); ++semicount; ++idx2; &#125; &#125; move(tmp.begin(), tmp.end(), indices.begin()+first); &#125; &#125;public: vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; results(n, 0); vector&lt;int&gt; indices(n, 0); iota(indices.begin(), indices.end(), 0); merge_countSmaller(indices, 0, n, results, nums); return results; &#125;&#125;; https://discuss.leetcode.com/topic/31291/c-short-solution-using-binary-indexed-tree-56-ms C++ short solution using binary indexed tree (56 ms) 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ret, clone = nums;; int len = (int) nums.size(); unordered_map&lt;int, int&gt; reflect; array.resize(len + 1); sort(clone.begin(), clone.end()); for (int i = 0; i &lt; len; ++ i) reflect[clone[i]] = i + 1; for (int i = len - 1; i &gt;= 0; -- i) &#123; clone[i] = query(reflect[nums[i]] - 1); add(reflect[nums[i]], 1); &#125; return clone; &#125; private: vector&lt;int&gt; array; inline int lowbit(int pos) &#123; return pos &amp; -pos; &#125; void add(int pos, int val) &#123; long len = array.size(); while (pos &lt; len) &#123; array[pos] += val; pos += lowbit(pos); &#125; &#125; int query(int pos) &#123; int ret = 0; while (pos &gt; 0) &#123; ret += array[pos]; pos -= lowbit(pos); &#125; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/36736/c-14-line-solution C++ 14 line solution 1234567891011121314class Solution &#123;public: vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; db; vector&lt;int&gt; result(nums.size()); for(int i = nums.size()-1; i &gt;= 0; i--) &#123; auto it = lower_bound(db.begin(), db.end(), nums[i]); result[i] = it - db.begin(); db.insert(it, nums[i]); &#125; return result; &#125;&#125;; python https://discuss.leetcode.com/topic/31162/mergesort-solution Mergesort solution The smaller numbers on the right of a number are exactly those that jump from its right to its left during a stable sort. So I do mergesort with added tracking of those right-to-left jumps. Update, new version 123456789101112131415def countSmaller(self, nums): def sort(enum): half = len(enum) / 2 if half: left, right = sort(enum[:half]), sort(enum[half:]) for i in range(len(enum))[::-1]: if not right or left and left[-1][1] &gt; right[-1][1]: smaller[left[-1][0]] += len(right) enum[i] = left.pop() else: enum[i] = right.pop() return enum smaller = [0] * len(nums) sort(list(enumerate(nums))) return smaller Old version 12345678910111213141516171819def countSmaller(self, nums): def sort(enum): half = len(enum) / 2 if half: left, right = sort(enum[:half]), sort(enum[half:]) m, n = len(left), len(right) i = j = 0 while i &lt; m or j &lt; n: if j == n or i &lt; m and left[i][1] &lt;= right[j][1]: enum[i+j] = left[i] smaller[left[i][0]] += j i += 1 else: enum[i+j] = right[j] j += 1 return enum smaller = [0] * len(nums) sort(list(enumerate(nums))) return smaller https://discuss.leetcode.com/topic/33908/3-ways-segment-tree-binary-indexed-tree-binary-search-tree-clean-python-code 3 ways (Segment Tree, Binary Indexed Tree, Binary Search Tree) clean python code Segment Tree 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class SegmentTreeNode(object): def __init__(self, val, start, end): self.val = val self.start = start self.end = end self.children = []class SegmentTree(object): def __init__(self, n): self.root = self.build(0, n - 1) def build(self, start, end): if start &gt; end: return root = SegmentTreeNode(0, start, end) if start == end: return root mid = start + end &gt;&gt; 1 root.children = filter(None, [ self.build(start, end) for start, end in ((start, mid), (mid + 1, end))]) return root def update(self, i, val, root=None): root = root or self.root if i &lt; root.start or i &gt; root.end: return root.val if i == root.start == root.end: root.val += val return root.val root.val = sum([self.update(i, val, c) for c in root.children]) return root.val def sum(self, start, end, root=None): root = root or self.root if end &lt; root.start or start &gt; root.end: return 0 if start &lt;= root.start and end &gt;= root.end: return root.val return sum([self.sum(start, end, c) for c in root.children])class Solution(object): def countSmaller(self, nums): hashTable = &#123;v: i for i, v in enumerate(sorted(set(nums)))&#125; tree, r = SegmentTree(len(hashTable)), [] for i in xrange(len(nums) - 1, -1, -1): r.append(tree.sum(0, hashTable[nums[i]] - 1)) tree.update(hashTable[nums[i]], 1) return r[::-1]Binary Indexed Treeclass BinaryIndexedTree(object): def __init__(self, n): self.sums = [0] * (n + 1) def update(self, i, val): while i &lt; len(self.sums): self.sums[i] += 1 i += i &amp; -i def sum(self, i): r = 0 while i &gt; 0: r += self.sums[i] i -= i &amp; -i return rclass Solution(object): def countSmaller(self, nums): hashTable = &#123;v: i for i, v in enumerate(sorted(set(nums)))&#125; tree, r = BinaryIndexedTree(len(hashTable)), [] for i in xrange(len(nums) - 1, -1, -1): r.append(tree.sum(hashTable[nums[i]])) tree.update(hashTable[nums[i]] + 1, 1) return r[::-1] Binary Search Tree 123456789101112131415161718192021222324252627282930313233343536373839404142434445class BinarySearchTreeNode(object): def __init__(self, val): self.val = val self.left = None self.right = None self.count = 1 self.leftTreeSize = 0class BinarySearchTree(object): def __init__(self): self.root = None def insert(self, val, root): if not root: self.root = BinarySearchTreeNode(val) return 0 if val == root.val: root.count += 1 return root.leftTreeSize if val &lt; root.val: root.leftTreeSize += 1 if not root.left: root.left = BinarySearchTreeNode(val) return 0 return self.insert(val, root.left) if not root.right: root.right = BinarySearchTreeNode(val) return root.count + root.leftTreeSize return root.count + root.leftTreeSize + self.insert( val, root.right)class Solution(object): def countSmaller(self, nums): tree = BinarySearchTree() return [ tree.insert(nums[i], tree.root) for i in xrange(len(nums) - 1, -1, -1) ][::-1] java 10ms, 80.82%, October 18, 2016 https://discuss.leetcode.com/topic/31405/9ms-short-java-bst-solution-get-answer-when-building-bst 9ms short Java BST solution get answer when building BST Every node will maintain a val sum recording the total of number on it’s left bottom side, dup counts the duplication. For example, [3, 2, 2, 6, 1], from back to beginning,we would have: 12345671(0, 1) \ 6(3, 1) / 2(0, 2) \ 3(0, 1) When we try to insert a number, the total number of smaller number would be adding dup and sum of the nodes where we turn right.for example, if we insert 5, it should be inserted on the way down to the right of 3, the nodes where we turn right is 1(0,1), 2,(0,2), 3(0,1), so the answer should be (0 + 1)+(0 + 2)+ (0 + 1) = 4 if we insert 7, the right-turning nodes are 1(0,1), 6(3,1), so answer should be (0 + 1) + (3 + 1) = 5 123456789101112131415161718192021222324252627282930313233public class Solution &#123; class Node &#123; Node left, right; int val, sum, dup = 1; public Node(int v, int s) &#123; val = v; sum = s; &#125; &#125; public List&lt;Integer&gt; countSmaller(int[] nums) &#123; Integer[] ans = new Integer[nums.length]; Node root = null; for (int i = nums.length - 1; i &gt;= 0; i--) &#123; root = insert(nums[i], root, ans, i, 0); &#125; return Arrays.asList(ans); &#125; private Node insert(int num, Node node, Integer[] ans, int i, int preSum) &#123; if (node == null) &#123; node = new Node(num, 0); ans[i] = preSum; &#125; else if (node.val == num) &#123; node.dup++; ans[i] = preSum + node.sum; &#125; else if (node.val &gt; num) &#123; node.sum++; node.left = insert(num, node.left, ans, i, preSum); &#125; else &#123; node.right = insert(num, node.right, ans, i, preSum + node.dup + node.sum); &#125; return node; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>divide and conquer</tag>
        <tag>binary search tree</tag>
        <tag>binary indexed tree</tag>
        <tag>segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[313. Super Ugly Number]]></title>
    <url>%2Fp%2Fe533ea3a%2F</url>
    <content type="text"><![CDATA[37.2% https://leetcode.com/problems/super-ugly-number Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4. Note: (1) 1 is a super ugly number for any given primes. (2) The given numbers in primes are in ascending order. (3) 0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000. (4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer. 方法一： 我的代码实现： 一个primes数组，一个primes对应的indexs数组，一个res数组 1234567891011121314151617class Solution &#123;public: int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123; int k = primes.size(); vector&lt;int&gt; indexs(k, 0); vector&lt;int&gt; res(n, INT_MAX); res[0] = 1; for(int i=1; i&lt;n; i++)&#123; for(int j=0; j&lt;k; j++) res[i] = min(res[i], res[indexs[j]]*primes[j]); for(int j=0; j&lt;k; j++) if(res[indexs[j]]*primes[j]==res[i]) indexs[j]++; &#125; return res[n-1]; &#125;&#125;; https://leetcode.com/problems/super-ugly-number/ Keep k pointers and update them in each iteration. Time complexity is O(kn). 123456789101112class Solution &#123;public: int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123; vector&lt;int&gt; index(primes.size(), 0), ugly(n, INT_MAX); ugly[0]=1; for(int i=1; i&lt;n; i++)&#123; for(int j=0; j&lt;primes.size(); j++) ugly[i]=min(ugly[i],ugly[index[j]]*primes[j]); for(int j=0; j&lt;primes.size(); j++) index[j]+=(ugly[i]==ugly[index[j]]*primes[j]); &#125; return ugly[n-1]; &#125;&#125;; 方法二: 其实跟方法一是一样的 156ms, 44.15%, May.3rd, 2016 https://leetcode.com/discuss/74625/112ms-c-solution-with-explanation 12345678910111213141516171819class Solution &#123;public: int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123; vector&lt;int&gt; superUglyNumbers; superUglyNumbers.push_back(1); int numPrimes = primes.size(); vector&lt;int&gt; idxs(numPrimes, 0); while(superUglyNumbers.size() &lt; n)&#123; int nextSuperUglyNumber = superUglyNumbers[idxs[0]] * primes[0]; for(int i = 0; i &lt; numPrimes; i++) nextSuperUglyNumber = min(nextSuperUglyNumber, superUglyNumbers[idxs[i]] * primes[i]); for(int i = 0; i &lt; numPrimes; i++) if(nextSuperUglyNumber == superUglyNumbers[idxs[i]] * primes[i]) idxs[i]++; superUglyNumbers.push_back(nextSuperUglyNumber); &#125; return superUglyNumbers[n-1]; &#125;&#125;; 164ms, 35.72%, 83 / 83, May.3rd, 2016 https://leetcode.com/discuss/72878/7-line-consice-o-kn-c-solution 123456789101112class Solution &#123;public: int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123; vector&lt;int&gt; index(primes.size(), 0), ugly(n, INT_MAX); ugly[0] = 1; for(int i = 1; i &lt; n; i++)&#123; for(int j = 0; j &lt; primes.size(); j++) ugly[i] = min(ugly[i], ugly[index[j]] * primes[j]); for(int j = 0; j &lt; primes.size(); j++) index[j] += (ugly[i] == ugly[index[j]] * primes[j]); &#125; return ugly[n-1]; &#125;&#125;; pythonSolution 1: 540ms, 76.45%, 83 / 83, May.3rd, 2016 https://leetcode.com/discuss/72763/python-generators-on-a-heap 1234567891011121314151617class Solution(object): def nthSuperUglyNumber(self, n, primes): &quot;&quot;&quot; :type n: int :type primes: List[int] :rtype: int &quot;&quot;&quot; uglies = [1] def gen(prime): for ugly in uglies: yield ugly * prime merged = heapq.merge(*map(gen, primes)) while len(uglies) &lt; n: ugly = next(merged) if ugly != uglies[-1]: uglies.append(ugly) return uglies[-1] javahttps://discuss.leetcode.com/topic/34841/java-three-methods-23ms-36-ms-58ms-with-heap-performance-explained Basic idea is same as ugly number II, new ugly number is generated by multiplying a prime with previous generated ugly number. One catch is need to remove duplicate Let’s start with the common solution from ugly number II 36 ms, Theoretically O(kN) 12345678910111213141516171819public int nthSuperUglyNumberI(int n, int[] primes) &#123; int[] ugly = new int[n]; int[] idx = new int[primes.length]; ugly[0] = 1; for (int i = 1; i &lt; n; i++) &#123; //find next ugly[i] = Integer.MAX_VALUE; for (int j = 0; j &lt; primes.length; j++) ugly[i] = Math.min(ugly[i], primes[j] * ugly[idx[j]]); //slip duplicate for (int j = 0; j &lt; primes.length; j++) &#123; while (primes[j] * ugly[idx[j]] &lt;= ugly[i]) idx[j]++; &#125; &#125; return ugly[n - 1];&#125; If you look at the above solution, it has redundant multiplication can be avoided, and also two for loops can be consolidated into one. This trade-off space for speed. 23 ms, Theoretically O(kN) 123456789101112131415161718192021public int nthSuperUglyNumber(int n, int[] primes) &#123; int[] ugly = new int[n]; int[] idx = new int[primes.length]; int[] val = new int[primes.length]; Arrays.fill(val, 1); int next = 1; for (int i = 0; i &lt; n; i++) &#123; ugly[i] = next; next = Integer.MAX_VALUE; for (int j = 0; j &lt; primes.length; j++) &#123; //skip duplicate and avoid extra multiplication if (val[j] == ugly[i]) val[j] = ugly[idx[j]++] * primes[j]; //find next ugly number next = Math.min(next, val[j]); &#125; &#125; return ugly[n - 1]; &#125; Can we do better? Theoretically yes, by keep the one candidates for each prime in a heap, it can improve the theoretical bound to O( log(k)N ), but in reality it’s 58 ms. I think it’s the result of using higher level object instead of primitive. Can be improved by writing an index heap (http://algs4.cs.princeton.edu/24pq/IndexMinPQ.java.html) 12345678910111213141516171819202122232425262728293031323334public int nthSuperUglyNumberHeap(int n, int[] primes) &#123; int[] ugly = new int[n]; PriorityQueue&lt;Num&gt; pq = new PriorityQueue&lt;&gt;(); for (int i = 0; i &lt; primes.length; i++) pq.add(new Num(primes[i], 1, primes[i])); ugly[0] = 1; for (int i = 1; i &lt; n; i++) &#123; ugly[i] = pq.peek().val; while (pq.peek().val == ugly[i]) &#123; Num nxt = pq.poll(); pq.add(new Num(nxt.p * ugly[nxt.idx], nxt.idx + 1, nxt.p)); &#125; &#125; return ugly[n - 1];&#125;private class Num implements Comparable&lt;Num&gt; &#123; int val; int idx; int p; public Num(int val, int idx, int p) &#123; this.val = val; this.idx = idx; this.p = p; &#125; @Override public int compareTo(Num that) &#123; return this.val - that.val; &#125;&#125; my code1234567891011121314151617181920public class Solution &#123; public int nthSuperUglyNumber(int n, int[] primes) &#123; int numPrimes = primes.length; int[] idxs = new int[numPrimes]; int[] superUglyNumber = new int[n]; superUglyNumber[0] = 1; for(int i=1; i&lt;n; i++)&#123; int nextUglyNumber = Integer.MAX_VALUE; for(int j=0; j&lt;numPrimes; j++) nextUglyNumber = Math.min(nextUglyNumber, superUglyNumber[idxs[j]]*primes[j]); for(int k=0; k&lt;numPrimes; k++) if(nextUglyNumber == superUglyNumber[idxs[k]]*primes[k]) idxs[k]++; superUglyNumber[i] = nextUglyNumber; &#125; return superUglyNumber[n-1]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[312. Burst Balloons]]></title>
    <url>%2Fp%2F20467241%2F</url>
    <content type="text"><![CDATA[41.9% https://leetcode.com/problems/burst-balloons/ Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] nums[i] nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely. Note:(1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100 12345678Example:Given [3, 1, 5, 8]Return 167nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 先戳破第一个气球，直到最后一个，即第n个。 重点是逆向思考，先第n个，再第n-1个，直到第一个。 一个vector&lt;vector&gt; dp dp[left][right]表示索引left至索引right里面，不戳破left和right，戳破[left+1, right-1]中任意顺序能获得的最大值。 假定最后戳破某一位i，则得到奖励nums[left]nums[i]nums[right]，并且获得dp[left][i]和dp[i][right]。而dp[i][left]又是类似于前一个问题，而且跟i关系不大。 下面两个方法分别是递归和迭代 方法一： 我的代码实现： 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; // insert插入时，第一位位置要使用迭代器 nums.insert(nums.begin(), 1); nums.push_back(1); int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, -1)); return dfs(nums, 0, n-1, dp); &#125; int dfs(vector&lt;int&gt;&amp; nums, int left, int right, vector&lt;vector&lt;int&gt;&gt;&amp; dp)&#123; if(left+1==right)&#123; dp[left][right] = 0; return 0; &#125; // 不要忘了这句话，不然超时 if(dp[left][right]&gt;=0) return dp[left][right]; // 使用变量前先声明 int ans = 0; for(int i=left+1; i&lt;right; i++) ans = max(ans, nums[left]*nums[i]*nums[right]+dfs(nums, left, i, dp)+dfs(nums, i, right, dp)); dp[left][right] = ans; return ans; &#125;&#125;; 方法二： 我的代码实现： 12345678910111213141516171819202122class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; nums.insert(nums.begin(), 1); nums.push_back(1); // 不要忘了声明 int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, -1)); for(int len=2; len&lt;=n; len++)&#123; // 比较大小时，用&lt;= 而不用 != for(int left=0; left+len&lt;=n; left++)&#123; int right = left + len - 1; int ans = 0; for(int i=left+1; i!=right; i++) ans = max(ans, nums[left]*nums[i]*nums[right]+dp[left][i]+dp[i][right]); dp[left][right] = ans; &#125; &#125; return dp[0][n-1]; &#125;&#125;; 方法一和方法二参考以下文章 https://discuss.leetcode.com/topic/41086/c-dp-detailed-explanation C++ dp detailed explanation the visualization help me to understand hope it can help you too. 1···················1 add two 1 at beginning and end of nums, each · represent each number in nums. len is the subinterval length, it grows from 1 to full length of orignal nums string. the following illustrations demonstrate how the subinterval shift from left to right. (len = 7 in the illustration) for each len, when shifted to rightmost, increase len and do the shift again. this way we can evaluate all possible subintervals. for each subinterval, in the innermost for loop, find which balloon to burst LAST that will give us the most coins for that subinterval. &lt;- IMPORTANT TO UNDERSTAND THIS dp[left][right] is the maximum coins we can get from left to right. note when left &gt; right, it is 0 12345678910111···················1 (len = 7)| |left right1···················1 | | left right 1···················1 | | left right for the example [3, 1, 5, 8], the dp matrix is updated like this 1234560 0 0 0 0 00 3 0 0 0 00 0 15 0 0 00 0 0 40 0 00 0 0 0 40 00 0 0 0 0 0 then 1234560 0 0 0 0 00 3 30 0 0 00 0 15 135 0 00 0 0 40 48 00 0 0 0 40 00 0 0 0 0 0 at last 1234560 0 0 0 0 00 3 30 159 167 00 0 15 135 159 00 0 0 40 48 00 0 0 0 40 00 0 0 0 0 0 the code is like most others. 12345678910111213141516class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); nums.insert(nums.begin(), 1); nums.push_back(1); vector&lt;vector&lt;int&gt;&gt; dp(nums.size(), vector&lt;int&gt;(nums.size(), 0)); for (int len = 1; len &lt;= n; ++len) for (int left = 1; left &lt;= n - len + 1; ++left) &#123; int right = left + len - 1; for (int k = left; k &lt;= right; ++k) dp[left][right] = max(dp[left][right], nums[left-1]*nums[k]*nums[right+1] + dp[left][k-1] + dp[k+1][right]); &#125; return dp[1][n]; &#125;&#125;; https://discuss.leetcode.com/topic/30746/share-some-analysis-and-explanations Share some analysis and explanations Be Naive FirstWhen I first get this problem, it is far from dynamic programming to me. I started with the most naive idea the backtracking. We have n balloons to burst, which mean we have n steps in the game. In the i th step we have n-i balloons to burst, i = 0~ n-1. Therefore we are looking at an algorithm of O(n!). Well, it is slow, probably works for n &lt; 12 only. Of course this is not the point to implement it. We need to identify the redundant works we did in it and try to optimize. Well, we can find that for any balloons left the maxCoins does not depends on the balloons already bursted. This indicate that we can use memorization (top down) or dynamic programming (bottom up) for all the cases from small numbers of balloon until n balloons. How many cases are there? For k balloons there are C(n, k) cases and for each case it need to scan the k balloons to compare. The sum is quite big still. It is better than O(n!) but worse than O(2^n). Better ideaWe then think can we apply the divide and conquer technique? After all there seems to be many self similar sub problems from the previous analysis. Well, the nature way to divide the problem is burst one balloon and separate the balloons into 2 sub sections one on the left and one one the right. However, in this problem the left and right become adjacent and have effects on the maxCoins in the future. Then another interesting idea come up. Which is quite often seen in dp problem analysis. That is reverse thinking. Like I said the coins you get for a balloon does not depend on the balloons already burst. Thereforeinstead of divide the problem by the first balloon to burst, we divide the problem by the last balloon to burst. Why is that? Because only the first and last balloons we are sure of their adjacent balloons before hand! For the first we have nums[i-1]nums[i]nums[i+1] for the last we have nums[-1]nums[i]nums[n]. OK. Think about n balloons if i is the last one to burst, what now? We can see that the balloons is again separated into 2 sections. But this time since the balloon i is the last balloon of all to burst, the left and right section now has well defined boundary and do not affect each other! Therefore we can do either recursive method with memoization or dp. FinalHere comes the final solutions. Note that we put 2 balloons with 1 as boundaries and also burst all the zero balloons in the first round since they won’t give any coins.The algorithm runs in O(n^3) which can be easily seen from the 3 loops in dp solution. Java D&amp;C with Memoization 12345678910111213141516171819202122public int maxCoins(int[] iNums) &#123; int[] nums = new int[iNums.length + 2]; int n = 1; for (int x : iNums) if (x &gt; 0) nums[n++] = x; nums[0] = nums[n++] = 1; int[][] memo = new int[n][n]; return burst(memo, nums, 0, n - 1);&#125;public int burst(int[][] memo, int[] nums, int left, int right) &#123; if (left + 1 == right) return 0; if (memo[left][right] &gt; 0) return memo[left][right]; int ans = 0; for (int i = left + 1; i &lt; right; ++i) ans = Math.max(ans, nums[left] * nums[i] * nums[right] + burst(memo, nums, left, i) + burst(memo, nums, i, right)); memo[left][right] = ans; return ans;&#125;// 12 ms Java DP 12345678910111213141516171819public int maxCoins(int[] iNums) &#123; int[] nums = new int[iNums.length + 2]; int n = 1; for (int x : iNums) if (x &gt; 0) nums[n++] = x; nums[0] = nums[n++] = 1; int[][] dp = new int[n][n]; for (int k = 2; k &lt; n; ++k) for (int left = 0; left &lt; n - k; ++left) &#123; int right = left + k; for (int i = left + 1; i &lt; right; ++i) dp[left][right] = Math.max(dp[left][right], nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]); &#125; return dp[0][n - 1];&#125;// 17 ms C++ DP 12345678910111213141516171819int maxCoinsDP(vector&lt;int&gt; &amp;iNums) &#123; int nums[iNums.size() + 2]; int n = 1; for (int x : iNums) if (x &gt; 0) nums[n++] = x; nums[0] = nums[n++] = 1; int dp[n][n] = &#123;&#125;; for (int k = 2; k &lt; n; ++k) &#123; for (int left = 0; left &lt; n - k; ++left) int right = left + k; for (int i = left + 1; i &lt; right; ++i) dp[left][right] = max(dp[left][right], nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]); &#125; return dp[0][n - 1];&#125;// 16 ms Python DP 1234567891011121314def maxCoins(self, iNums): nums = [1] + [i for i in iNums if i &gt; 0] + [1] n = len(nums) dp = [[0]*n for _ in xrange(n)] for k in xrange(2, n): for left in xrange(0, n - k): right = left + k for i in xrange(left + 1,right): dp[left][right] = max(dp[left][right], nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]) return dp[0][n - 1]# 528ms https://discuss.leetcode.com/topic/30738/c-dynamic-programming-o-n-3-32-ms-with-comments C++ dynamic programming, O(N^3), 32 ms, with comments 123456789101112131415161718192021222324252627int maxCoins(vector&lt;int&gt;&amp; nums) &#123; int N = nums.size(); nums.insert(nums.begin(), 1); nums.insert(nums.end(), 1); // rangeValues[i][j] is the maximum # of coins that can be obtained // by popping balloons only in the range [i,j] vector&lt;vector&lt;int&gt;&gt; rangeValues(nums.size(), vector&lt;int&gt;(nums.size(), 0)); // build up from shorter ranges to longer ranges for (int len = 1; len &lt;= N; ++len) &#123; for (int start = 1; start &lt;= N - len + 1; ++start) &#123; int end = start + len - 1; // calculate the max # of coins that can be obtained by // popping balloons only in the range [start,end]. // consider all possible choices of final balloon to pop int bestCoins = 0; for (int final = start; final &lt;= end; ++final) &#123; int coins = rangeValues[start][final-1] + rangeValues[final+1][end]; // coins from popping subranges coins += nums[start-1] * nums[final] * nums[end+1]; // coins from final pop if (coins &gt; bestCoins) bestCoins = coins; &#125; rangeValues[start][end] = bestCoins; &#125; &#125; return rangeValues[1][N];&#125; https://discuss.leetcode.com/topic/30934/my-c-code-dp-o-n-3-20ms My C++ code (DP, O(N^3)) 20ms The algorithm is well explained in 1 and I pretty much followed the same line. First version I got is recursion +backtracing (TLE) Second version I got is DP: instead of bursting ballons one by one, we do it in a reverse order, “de-burst” ballons one by one. In that order, the left and right neighbor of the “de-burst” ballon is known. However, the complexity is still high (~ order of C(n,n/2)) The real challenge is the outer boundaries (i.e. left, right neighbors vary with the burst order). The algorithm in 1 elegantly fixed that problem: fix left/right neighbors and doing DP from length=3 to nSize; 1234567891011121314151617class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; nums) &#123; int nSize = nums.size()+2, left, right, len, mid, temp, dpMax[nSize][nSize] =&#123;&#125;; nums.insert(nums.begin(),1); // two dummy &quot;1&quot; added to simplify DP nums.push_back(1); for(len=3; len&lt;=nSize; ++len) // lenght including left and right boudaries, for(left=0; left&lt;=nSize-len; ++left) //left boudary/neighbor for(right = left+len-1, mid=left+1, temp = nums[left]*nums[right]; mid&lt;right;++mid) //right boundary, mid is the last one to burst in the range (left, right) dpMax[left][right] = max(dpMax[left][right], dpMax[left][mid] + dpMax[mid][right] + nums[mid]*temp); nums.erase(nums.begin()); // recover nums nums.pop_back(); return dpMax[0][nSize-1]; &#125;&#125;; https://discuss.leetcode.com/topic/31178/python-dp-n-3-solutions Python DP N^3 Solutions Analysis:We need to find a way to divide the problems. If we start from the first balloon, we can’t determine the left/right for the number in each sub-problem, If we start from the last balloon, we can.We can see the transformation equation is very similar to the one for matrix multiplication. dp[i][j] = max(dp[i][j], nums[i] nums[k] nums[j] + dp[i][k] + dp[k][j]) # i &lt; k &lt; jThis is a typical interval DP problem. Because the order of the number extracted matters, we need to do a O(n^3) DP. If we only need to expand the interval to the left or right, we only need to do a O(n^2) DP. Top-down: 1234567891011121314151617181920class Solution(object): def maxCoins(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; nums = [1] + nums + [1] n = len(nums) dp = [[0] * n for _ in xrange(n)] def calculate(i, j): if dp[i][j] or j == i + 1: # in memory or gap &lt; 2 return dp[i][j] coins = 0 for k in xrange(i+1, j): # find the last balloon coins = max(coins, nums[i] * nums[k] * nums[j] + calculate(i, k) + calculate(k, j)) dp[i][j] = coins return coins return calculate(0, n-1) Bottom-up: 12345678910111213141516class Solution(object): def maxCoins(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; nums = [1] + nums + [1] # build the complete array n = len(nums) dp = [[0] * n for _ in xrange(n)] for gap in xrange(2, n): for i in xrange(n-gap): j = i + gap for k in xrange(i+1, j): dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j]) return dp[0][n-1] java https://discuss.leetcode.com/topic/30746/share-some-analysis-and-explanations Be Naive First When I first get this problem, it is far from dynamic programming to me. I started with the most naive idea the backtracking. We have n balloons to burst, which mean we have n steps in the game. In the i th step we have n-i balloons to burst, i = 0~ n-1. Therefore we are looking at an algorithm of O(n!). Well, it is slow, probably works for n &lt; 12 only. Of course this is not the point to implement it. We need to identify the redundant works we did in it and try to optimize. Well, we can find that for any balloons left the maxCoins does not depends on the balloons already bursted. This indicate that we can use memorization (top down) or dynamic programming (bottom up) for all the cases from small numbers of balloon until n balloons. How many cases are there? For k balloons there are C(n, k) cases and for each case it need to scan the k balloons to compare. The sum is quite big still. It is better than O(n!) but worse than O(2^n). Better idea We then think can we apply the divide and conquer technique? After all there seems to be many self similar sub problems from the previous analysis. Well, the nature way to divide the problem is burst one balloon and separate the balloons into 2 sub sections one on the left and one one the right. However, in this problem the left and right become adjacent and have effects on the maxCoins in the future. Then another interesting idea come up. Which is quite often seen in dp problem analysis. That is reverse thinking. Like I said the coins you get for a balloon does not depend on the balloons already burst. Thereforeinstead of divide the problem by the first balloon to burst, we divide the problem by the last balloon to burst. Why is that? Because only the first and last balloons we are sure of their adjacent balloons before hand! For the first we have nums[i-1]*nums[i]* nums[i+1] for the last we have nums[-1]*nums[i]*nums[n] . OK. Think about n balloons if i is the last one to burst, what now? We can see that the balloons is again separated into 2 sections. But this time since the balloon i is the last balloon of all to burst, the left and right section now has well defined boundary and do not affect each other! Therefore we can do either recursive method with memoization or dp. Final Here comes the final solutions. Note that we put 2 balloons with 1 as boundaries and also burst all the zero balloons in the first round since they won’t give any coins. The algorithm runs in O ( n\^3 ) which can be easily seen from the 3 loops in dp solution. Java D&amp;C with Memoization 1234567891011121314151617181920212223public class Solution &#123; public int maxCoins(int[] nums) &#123; if(nums.length == 0) return 0; int n = 1; int[] numss = new int[nums.length+2]; for(int i:nums) numss[n++] = i; numss[0] = numss[n++] = 1; int[][] dp = new int[n][n]; return dfs(numss, dp, 0, n-1); &#125; private int dfs(int[] numss, int[][] dp, int left, int right)&#123; if(left+1==right) return 0; if(dp[left][right]&gt;0) return dp[left][right]; int ans = 0; for(int i=left+1; i&lt;right; i++)&#123; ans = Math.max(ans, numss[left]*numss[i]*numss[right]+dfs(numss, dp, left, i) + dfs(numss, dp, i, right)); &#125; dp[left][right] = ans; return ans; &#125;&#125; Java DP 19ms, September 9, 2016https://discuss.leetcode.com/topic/30746/share-some-analysis-and-explanations 123456789101112131415161718192021public class Solution &#123; public int maxCoins(int[] nums) &#123; int[] numbers = new int [nums.length + 2]; int n = 1; for(int x:nums) if(x&gt;0) numbers[n++] = x; numbers[0] = numbers[n++] = 1; int[][] dp = new int[n][n]; for(int k=2; k&lt;n; ++k)&#123; for(int left = 0; left&lt;n-k; ++left)&#123; int right = left+k; for(int i = left+1; i&lt;right; ++i)&#123; dp[left][right] = Math.max(dp[left][right], numbers[left]*numbers[i]*numbers[right] + dp[left][i] + dp[i][right]); &#125; &#125; &#125; return dp[0][n-1]; &#125;&#125; cpp 19ms, September 9, 2016https://discuss.leetcode.com/topic/30746/share-some-analysis-and-explanations 12345678910111213141516171819202122class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; nums) &#123; int numbers[nums.size() + 2]; int n = 1; for(int x:nums) if(x &gt;0) numbers[n++] = x; numbers[0] = numbers[n++] = 1; int dp[n][n] = &#123;&#125;; for(int k = 2; k&lt;n; ++k)&#123; for(int left = 0; left&lt;n-k;++left)&#123; int right = left + k; for(int i = left+1; i&lt;right; ++i)&#123; dp[left][right] = max(dp[left][right], numbers[left]*numbers[i]*numbers[right] + dp[left][i] + dp[i][right]); &#125; &#125; &#125; return dp[0][n-1]; &#125;&#125;; python 416ms, September 9, 2016https://discuss.leetcode.com/topic/31178/python-dp-n-3-solutions 12345678910111213141516class Solution(object): def maxCoins(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; nums = [1] + nums + [1] n = len(nums) dp = [[0] *n for _ in xrange(n)] for gap in xrange(2, n): for i in xrange(n-gap): j = i + gap for k in xrange(i+1, j): dp[i][j] = max(dp[i][j], nums[i]*nums[k]*nums[j] + dp[i][k] + dp[k][j]) return dp[0][n-1] 972ms, September 9, 2016https://discuss.leetcode.com/topic/31178/python-dp-n-3-solutions 1234567891011121314151617181920class Solution(object): def maxCoins(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; nums = [1] + nums + [1] n = len(nums) dp = [[0]*n for _ in xrange(n)] def calculate(i, j): if dp[i][j] or j == i+1: return dp[i][j] coins = 0 for k in xrange(i+1, j): coins = max(coins, nums[i] * nums[k] * nums[j] + calculate(i, k) + calculate(k, j)) dp[i][j] = coins return coins return calculate(0, n-1)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>divide and conquer</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[310. Minimum Height Trees]]></title>
    <url>%2Fp%2F390d067f%2F</url>
    <content type="text"><![CDATA[28.6% For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. Format The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels). You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. 12345678910Example 1:Given n = 4, edges = [[1, 0], [1, 2], [1, 3]] 0 | 1 / \ 2 3return [1] 123456789101112Example 2:Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]] 0 1 2 \ | / 3 | 4 | 5return [3, 4] Hint: How many MHTs can a graph have at most? Note: (1) According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.” (2) The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>breadth first search</tag>
        <tag>aaa</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[309. Best Time to Buy and Sell Stock with Cooldown]]></title>
    <url>%2Fp%2F36465192%2F</url>
    <content type="text"><![CDATA[40.1% https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/#/description Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) 12345Example:prices = [1, 2, 3, 0, 2]maxProfit = 3transactions = [buy, sell, cooldown, buy, sell] cpp2ms, September 10, 2016 https://discuss.leetcode.com/topic/30421/share-my-thinking-process 123456789101112public class Solution &#123; public int maxProfit(int[] prices) &#123; int sell = 0, prev_sell = 0, buy = Integer.MIN_VALUE, prev_buy; for(int price:prices)&#123; prev_buy = buy; buy = Math.max(prev_sell - price, prev_buy); prev_sell = sell; sell = Math.max(prev_buy + price , prev_sell); &#125; return sell; &#125;&#125; python39ms, September 10, 2016 https://discuss.leetcode.com/topic/30421/share-my-thinking-process 123456789101112131415class Solution(object): def maxProfit(self, prices): &quot;&quot;&quot; :type prices: List[int] :rtype: int &quot;&quot;&quot; if len(prices) &lt; 2: return 0 sell, buy, prev_sell, prev_buy = 0, -prices[0], 0, 0 for price in prices: prev_buy = buy buy = max(prev_sell - price, prev_buy) prev_sell = sell sell = max(prev_buy + price, prev_sell) return sell]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[307. Range Sum Query - Mutable]]></title>
    <url>%2Fp%2Fd84dea00%2F</url>
    <content type="text"><![CDATA[19.1% https://leetcode.com/problems/range-sum-query-mutable/?tab=Description Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. 123456Example:Given nums = [1, 3, 5]sumRange(0, 2) -&gt; 9update(1, 2)sumRange(0, 2) -&gt; 8 Note: The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly. leetcode官方答案 https://leetcode.com/articles/range-sum-query-mutable/ cpp https://discuss.leetcode.com/topic/29939/c-solution-using-buckets-o-1-for-updating-and-o-n-0-5-for-query-in-the-worst-case-not-the-fast C++ solution using “buckets”. O(1) for updating and O(n^0.5) for query in the worst case (not the fast). The idea is using “buckets”. Assume the length of the input array is n, we can partition the whole array into m buckets, with each bucket having k=n/m elements. For each bucket, we record two kind of information: 1) a copy of elements in the bucket, 2) the sum of all the elements in the bucket. For example: If the input is [0,1,2,3,4,5,6,7,8,9], and we partition it into 4 buckets, formatted as {[numbers], sum}: bucket0: {[0, 1, 2], 3}bucket1: {[3, 4, 5], 12}bucket2: {[6, 7, 8], 21}bucket3: {[9], 9};Updating is easy. You just need to find the right bucket, modify the element value, and change the “sum” value in that bucket accordingly. The operation takes O(1) time. Summation is a little complicated. In the above example, let’s say we want to compute the sum in range [1, 7]. We can see, the numbers we want to accumulate are in bucket0, bucket1, and bucket2. Specifically, we only need parts of numbers in bucket0 and bucket2, and all the numbers in bucket1. Because the summation of all numbers in bucket1 have already been computed, we don’t need to compute it again. So, instead of doing (1+2) + (3+4+5) + (6+7), we can just do (1+2) + 12 + (6+7). We save two “+” operations. If you change the size of buckets, the number of saved “+” operations will be different. The questions is: What is the best size that can save the most “+” operations? Here is my analysis, which might be incorrect. We have: The number of buckets is m.The size of each bucket is k.The length of input array is n, and we have mk=n.In the worst case (the query is [0, n-1]), we will first add all the elements in bucket0, then add from bucket1 to bucket(m-2), and finally add all the elements in bucket(m-1), so we do 2k+m-2 “+” operations. We want to find the minimum value of 2k+m. Because 2km=2n, when 2k=m, 2k+m reaches the minimum value. (Need proof?) So we have m = sqrt(2n) and k=sqrt(n/2). Therefore, in the worst case, the best size of bucket is k=sqrt(n/2), and the complexity is O(2k+m-2)=O(2m-2)=O(m)=O(sqrt(2n))=O(n^0.5); Thank you for pointing out any mistake! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class NumArray &#123;public: struct Bucket &#123; int sum; vector&lt;int&gt; val; &#125;; int bucketNum; int bucketSize; vector&lt;Bucket&gt; Bs; NumArray(vector&lt;int&gt; &amp;nums) &#123; int size = nums.size(); int bucketNum = (int)sqrt(2*size); bucketSize = bucketNum/2; while(bucketSize * bucketNum&lt;size) ++bucketSize; Bs.resize(bucketNum); for(int i=0, k=0; i&lt;bucketNum; ++i) &#123; int temp = 0; Bs[i].val.resize(bucketSize); for(int j=0; j&lt;bucketSize &amp;&amp; k&lt;size; ++j, ++k) &#123; temp += nums[k]; Bs[i].val[j] = nums[k]; &#125; Bs[i].sum = temp; &#125; &#125; void update(int i, int val) &#123; int x = i / bucketSize; int y = i % bucketSize; Bs[x].sum += (val - Bs[x].val[y]); Bs[x].val[y] = val; &#125; int sumRange(int i, int j) &#123; int x1 = i / bucketSize; int y1 = i % bucketSize; int x2 = j / bucketSize; int y2 = j % bucketSize; int sum = 0; if(x1==x2) &#123; for(int a=y1; a&lt;=y2; ++a) &#123; sum += Bs[x1].val[a]; &#125; return sum; &#125; for(int a=y1; a&lt;bucketSize; ++a) &#123; sum += Bs[x1].val[a]; &#125; for(int a=x1+1; a&lt;x2; ++a) &#123; sum += Bs[a].sum; &#125; for(int b=0; b&lt;=y2; ++b) &#123; sum += Bs[x2].val[b]; &#125; return sum; &#125;&#125;; https://discuss.leetcode.com/topic/30120/c-segment-tree-update-and-sum-are-both-o-logn C++, Segment Tree,update and sum are both O(logn) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct SegmentTreeNode &#123; int start, end, sum; SegmentTreeNode* left; SegmentTreeNode* right; SegmentTreeNode(int a, int b):start(a),end(b),sum(0),left(nullptr),right(nullptr)&#123;&#125;&#125;;class NumArray &#123; SegmentTreeNode* root;public: NumArray(vector&lt;int&gt; &amp;nums) &#123; int n = nums.size(); root = buildTree(nums,0,n-1); &#125; void update(int i, int val) &#123; modifyTree(i,val,root); &#125; int sumRange(int i, int j) &#123; return queryTree(i, j, root); &#125; SegmentTreeNode* buildTree(vector&lt;int&gt; &amp;nums, int start, int end) &#123; if(start &gt; end) return nullptr; SegmentTreeNode* root = new SegmentTreeNode(start,end); if(start == end) &#123; root-&gt;sum = nums[start]; return root; &#125; int mid = start + (end - start) / 2; root-&gt;left = buildTree(nums,start,mid); root-&gt;right = buildTree(nums,mid+1,end); root-&gt;sum = root-&gt;left-&gt;sum + root-&gt;right-&gt;sum; return root; &#125; int modifyTree(int i, int val, SegmentTreeNode* root) &#123; if(root == nullptr) return 0; int diff; if(root-&gt;start == i &amp;&amp; root-&gt;end == i) &#123; diff = val - root-&gt;sum; root-&gt;sum = val; return diff; &#125; int mid = (root-&gt;start + root-&gt;end) / 2; if(i &gt; mid) &#123; diff = modifyTree(i,val,root-&gt;right); &#125; else &#123; diff = modifyTree(i,val,root-&gt;left); &#125; root-&gt;sum = root-&gt;sum + diff; return diff; &#125; int queryTree(int i, int j, SegmentTreeNode* root) &#123; if(root == nullptr) return 0; if(root-&gt;start == i &amp;&amp; root-&gt;end == j) return root-&gt;sum; int mid = (root-&gt;start + root-&gt;end) / 2; if(i &gt; mid) return queryTree(i,j,root-&gt;right); if(j &lt;= mid) return queryTree(i,j,root-&gt;left); return queryTree(i,mid,root-&gt;left) + queryTree(mid+1,j,root-&gt;right); &#125;&#125;;// Your NumArray object will be instantiated and called as such:// NumArray numArray(nums);// numArray.sumRange(0, 1);// numArray.update(1, 10);// numArray.sumRange(1, 2); https://discuss.leetcode.com/topic/34585/strongly-recommend-for-beginners-clean-c-implementation-with-detailed-explaination [strongly recommend for beginners]clean C++ implementation with detailed explaination Similiar C++ implementation based others’ posts. I have refered to the post from GeekForGeek http://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/ I think the key points are that you should set “i++” and understand the relationship of the children and parents. THE KEY POINTS idx is some index of BIT. r is a position in idx of the last digit 1 (from left to right) in binary notation. tree[idx] is sum of frequencies from index (idx – 2^r + 1) to index idx (look at the Table 1.1 for clarification). We also write that idx is responsible for indexes from (idx - 2^r + 1) to idx (note that responsibility is the key in our algorithm and is the way of manipulating the tree). FOR EXAMPLE Suppose we are looking for cumulative frequency of index 13 (for the first 13 elements). In binary notation, 13 is equal to 1101. Accordingly, we will calculate 1c[1101] = tree[1101] + tree[1100] + tree[1000] HOW TO GET THE FINAL LAST SET BIT There are times when we need to get just the last digit from a binary number, so we need an efficient way to do that. Let num be the integer whose last digit we want to isolate. In binary notation num can be represented as a1b, where a represents binary digits before the last digit and b represents zeroes after the last digit. 12345num=a1b-num= (a1b)¯ + 1 = a¯0b¯ + 1-num = (a1b)¯ + 1 = a¯0b¯ + 1 = a¯0(0…0)¯ + 1 = a¯0(1…1) + 1 = a¯1(0…0) = a¯1b. b consists of all zeroes, so b¯ consists of all ones. Finally we have 1so the last set bit : 00..1...00 = num &amp; -num Key ideas -1- get-function-details getSum(index): Returns sum of arr[0..index] 123456789101112131415// Returns sum of arr[0..index] using BITree[0..n]. It assumes that// BITree[] is constructed for given array arr[0..n-1] 1) Initialize sum as 0 and index as index+1. 2) Do following while index is greater than 0. ...a) Add BITree[index] to sum ...b) Go to parent of BITree[index]. Parent can be obtained by removing the last set bit from index, i.e., index = index - (index &amp; (-index)) 3) Return sum. Key ideas -2- update-value-function 123456789101112131415update(index, val): Updates BIT for operation arr[index] += val// Note that arr[] is not changed here. It changes// only BI Tree for the already made change in arr[].1) Initialize index as index+1.2) Do following while index is smaller than or equal to n. ...a) Add value to BITree[index] ...b) Go to parent of BITree[index]. Parent can be obtained by removing the last set bit from index, i.e., index = index + (index &amp; (-index)) Here is my final implementation. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class NumArray &#123; private: vector&lt;int&gt; _nums; vector&lt;int&gt; bit; int lower_bit(int i)&#123; return i&amp;-i; &#125; int query(int i)&#123; i++; int sum=0; while(i&gt;0)&#123; sum+=bit[i]; i-=lower_bit(i); &#125; return sum; &#125; void add(int i, int val)&#123; i++; while(i&lt;bit.size())&#123; bit[i]+=val; i+=lower_bit(i); &#125; &#125; public: NumArray(vector&lt;int&gt; &amp;nums) : _nums(nums) &#123; bit.resize(nums.size()+1); for(int i=0; i&lt;nums.size(); i++)&#123; add(i, nums[i]); &#125; &#125; void update(int i, int val) &#123; if(val!=_nums[i])&#123; add(i, val-_nums[i]); _nums[i]=val; &#125; &#125; int sumRange(int i, int j) &#123; return query(j)-query(i-1); &#125; &#125;; python https://discuss.leetcode.com/topic/30016/0-lines-python “0 lines” Python 1234class NumArray(object): def __init__(self, nums): self.update = nums.__setitem__ self.sumRange = lambda i, j: sum(nums[i:j+1]) I added two lines, but I also removed two lines, so zero overall, right? Just kidding :-P Not a serious solution, just showing some Python trickery. The sumRange takes linear time, but due to the test suite being weak, this solution gets accepted (in about 1200-1300ms). https://discuss.leetcode.com/topic/33747/148ms-python-solution-binary-indexed-tree 148ms Python solution, Binary Indexed Tree Use self.c to represent Binary Indexed Tree. Section sums are stored in self.c[1..len(nums)]. x &amp; -x is lowbit function, which will return x’s rightmost bit 1, e.g. lowbit(7) = 1, lowbit(20) = 4. self.c[1] = nums[0] self.c[2] = nums[0] + nums[1] self.c[3] = nums[2] self.c[4] = nums[0] + nums[1] + nums[2] + nums[3] self.c[5] = nums[4] self.c[6] = nums[4] + nums[5] self.c[7] = nums[6] self.c[8] = nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6] + nums[7] 1234567891011121314151617181920212223242526class NumArray(object): def __init__(self, nums): self.n = len(nums) self.a, self.c = nums, [0] * (self.n + 1) for i in range(self.n): k = i + 1 while k &lt;= self.n: self.c[k] += nums[i] k += (k &amp; -k) def update(self, i, val): diff, self.a[i] = val - self.a[i], val i += 1 while i &lt;= self.n: self.c[i] += diff i += (i &amp; -i) def sumRange(self, i, j): res, j = 0, j + 1 while j: res += self.c[j] j -= (j &amp; -j) while i: res -= self.c[i] i -= (i &amp; -i) return res https://discuss.leetcode.com/topic/45266/python-well-commented-solution-using-segment-trees Python: Well commented solution using Segment Trees This solution is based on the top voted solution by 2guotou, which is in Java. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&quot;&quot;&quot; The idea here is to build a segment tree. Each node stores the left and right endpoint of an interval and the sum of that interval. All of the leaves will store elements of the array and each internal node will store sum of leaves under it. Creating the tree takes O(n) time. Query and updates are both O(log n).&quot;&quot;&quot;#Segment tree nodeclass Node(object): def __init__(self, start, end): self.start = start self.end = end self.total = 0 self.left = None self.right = None class NumArray(object): def __init__(self, nums): &quot;&quot;&quot; initialize your data structure here. :type nums: List[int] &quot;&quot;&quot; #helper function to create the tree from input array def createTree(nums, l, r): #base case if l &gt; r: return None #leaf node if l == r: n = Node(l, r) n.total = nums[l] return n mid = (l + r) // 2 root = Node(l, r) #recursively build the Segment tree root.left = createTree(nums, l, mid) root.right = createTree(nums, mid+1, r) #Total stores the sum of all leaves under root #i.e. those elements lying between (start, end) root.total = root.left.total + root.right.total return root self.root = createTree(nums, 0, len(nums)-1) def update(self, i, val): &quot;&quot;&quot; :type i: int :type val: int :rtype: int &quot;&quot;&quot; #Helper function to update a value def updateVal(root, i, val): #Base case. The actual value will be updated in a leaf. #The total is then propogated upwards if root.start == root.end: root.total = val return val mid = (root.start + root.end) // 2 #If the index is less than the mid, that leaf must be in the left subtree if i &lt;= mid: updateVal(root.left, i, val) #Otherwise, the right subtree else: updateVal(root.right, i, val) #Propogate the changes after recursive call returns root.total = root.left.total + root.right.total return root.total return updateVal(self.root, i, val) def sumRange(self, i, j): &quot;&quot;&quot; sum of elements nums[i..j], inclusive. :type i: int :type j: int :rtype: int &quot;&quot;&quot; #Helper function to calculate range sum def rangeSum(root, i, j): #If the range exactly matches the root, we already have the sum if root.start == i and root.end == j: return root.total mid = (root.start + root.end) // 2 #If end of the range is less than the mid, the entire interval lies #in the left subtree if j &lt;= mid: return rangeSum(root.left, i, j) #If start of the interval is greater than mid, the entire inteval lies #in the right subtree elif i &gt;= mid + 1: return rangeSum(root.right, i, j) #Otherwise, the interval is split. So we calculate the sum recursively, #by splitting the interval else: return rangeSum(root.left, i, mid) + rangeSum(root.right, mid+1, j) return rangeSum(self.root, i, j) # Your NumArray object will be instantiated and called as such:# numArray = NumArray(nums)# numArray.sumRange(0, 1)# numArray.update(1, 10)# numArray.sumRange(1, 2) java https://discuss.leetcode.com/topic/29918/17-ms-java-solution-with-segment-tree 17 ms Java solution with segment tree 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class NumArray &#123; class SegmentTreeNode &#123; int start, end; SegmentTreeNode left, right; int sum; public SegmentTreeNode(int start, int end) &#123; this.start = start; this.end = end; this.left = null; this.right = null; this.sum = 0; &#125; &#125; SegmentTreeNode root = null; public NumArray(int[] nums) &#123; root = buildTree(nums, 0, nums.length-1); &#125; private SegmentTreeNode buildTree(int[] nums, int start, int end) &#123; if (start &gt; end) &#123; return null; &#125; else &#123; SegmentTreeNode ret = new SegmentTreeNode(start, end); if (start == end) &#123; ret.sum = nums[start]; &#125; else &#123; int mid = start + (end - start) / 2; ret.left = buildTree(nums, start, mid); ret.right = buildTree(nums, mid + 1, end); ret.sum = ret.left.sum + ret.right.sum; &#125; return ret; &#125; &#125; void update(int i, int val) &#123; update(root, i, val); &#125; void update(SegmentTreeNode root, int pos, int val) &#123; if (root.start == root.end) &#123; root.sum = val; &#125; else &#123; int mid = root.start + (root.end - root.start) / 2; if (pos &lt;= mid) &#123; update(root.left, pos, val); &#125; else &#123; update(root.right, pos, val); &#125; root.sum = root.left.sum + root.right.sum; &#125; &#125; public int sumRange(int i, int j) &#123; return sumRange(root, i, j); &#125; public int sumRange(SegmentTreeNode root, int start, int end) &#123; if (root.end == end &amp;&amp; root.start == start) &#123; return root.sum; &#125; else &#123; int mid = root.start + (root.end - root.start) / 2; if (end &lt;= mid) &#123; return sumRange(root.left, start, end); &#125; else if (start &gt;= mid+1) &#123; return sumRange(root.right, start, end); &#125; else &#123; return sumRange(root.right, mid+1, end) + sumRange(root.left, start, mid); &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/31599/java-using-binary-indexed-tree-with-clear-explanation Java using Binary Indexed Tree with clear explanation This is to share the explanation of the BIT and the meaning of the bit operations. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class NumArray &#123; /** * Binary Indexed Trees (BIT or Fenwick tree): * https://www.topcoder.com/community/data-science/data-science- * tutorials/binary-indexed-trees/ * * Example: given an array a[0]...a[7], we use a array BIT[9] to * represent a tree, where index [2] is the parent of [1] and [3], [6] * is the parent of [5] and [7], [4] is the parent of [2] and [6], and * [8] is the parent of [4]. I.e., * * BIT[] as a binary tree: * ______________* * ______* * __* __* * * * * * * indices: 0 1 2 3 4 5 6 7 8 * * BIT[i] = ([i] is a left child) ? the partial sum from its left most * descendant to itself : the partial sum from its parent (exclusive) to * itself. (check the range of &quot;__&quot;). * * Eg. BIT[1]=a[0], BIT[2]=a[1]+BIT[1]=a[1]+a[0], BIT[3]=a[2], * BIT[4]=a[3]+BIT[3]+BIT[2]=a[3]+a[2]+a[1]+a[0], * BIT[6]=a[5]+BIT[5]=a[5]+a[4], * BIT[8]=a[7]+BIT[7]+BIT[6]+BIT[4]=a[7]+a[6]+...+a[0], ... * * Thus, to update a[1]=BIT[2], we shall update BIT[2], BIT[4], BIT[8], * i.e., for current [i], the next update [j] is j=i+(i&amp;-i) //double the * last 1-bit from [i]. * * Similarly, to get the partial sum up to a[6]=BIT[7], we shall get the * sum of BIT[7], BIT[6], BIT[4], i.e., for current [i], the next * summand [j] is j=i-(i&amp;-i) // delete the last 1-bit from [i]. * * To obtain the original value of a[7] (corresponding to index [8] of * BIT), we have to subtract BIT[7], BIT[6], BIT[4] from BIT[8], i.e., * starting from [idx-1], for current [i], the next subtrahend [j] is * j=i-(i&amp;-i), up to j==idx-(idx&amp;-idx) exclusive. (However, a quicker * way but using extra space is to store the original array.) */ int[] nums; int[] BIT; int n; public NumArray(int[] nums) &#123; this.nums = nums; n = nums.length; BIT = new int[n + 1]; for (int i = 0; i &lt; n; i++) init(i, nums[i]); &#125; public void init(int i, int val) &#123; i++; while (i &lt;= n) &#123; BIT[i] += val; i += (i &amp; -i); &#125; &#125; void update(int i, int val) &#123; int diff = val - nums[i]; nums[i] = val; init(i, diff); &#125; public int getSum(int i) &#123; int sum = 0; i++; while (i &gt; 0) &#123; sum += BIT[i]; i -= (i &amp; -i); &#125; return sum; &#125; public int sumRange(int i, int j) &#123; return getSum(j) - getSum(i - 1); &#125;&#125;// Your NumArray object will be instantiated and called as such:// NumArray numArray = new NumArray(nums);// numArray.sumRange(0, 1);// numArray.update(1, 10);// numArray.sumRange(1, 2);]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>binary indexed tree</tag>
        <tag>segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[306. Additive Number]]></title>
    <url>%2Fp%2F6099572b%2F</url>
    <content type="text"><![CDATA[27.3% https://leetcode.com/problems/additive-number/?tab=Description Additive number is a string whose digits can form additive sequence. A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two. 12345678910For example:&quot;112358&quot; is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8&quot;199100199&quot; is also an additive number, the additive sequence is: 1, 99, 100, 199.1 + 99 = 100, 99 + 100 = 199Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid. Given a string containing only digits ‘0’-‘9’, write a function to determine if it’s an additive number. Follow up: How would you handle overflow for very large input integers? https://discuss.leetcode.com/topic/29872/0ms-concise-c-solution-perfectly-handles-the-follow-up-and-leading-0s 0ms concise C++ solution (perfectly handles the follow-up and leading 0s) use a helper function to add two strings. Choose first two number then recursively check. Note that the length of first two numbers can’t be longer than half of the initial string, so the two loops in the first function will end when i&gt;num.size()/2 and j&gt;(num.size()-i)/2, this will actually save a lot of time. Update the case of heading 0s e.g. “100010” should return false 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool isAdditiveNumber(string num) &#123; for(int i=1; i&lt;=num.size()/2; i++)&#123; for(int j=1; j&lt;=(num.size()-i)/2; j++)&#123; if(check(num.substr(0,i), num.substr(i,j), num.substr(i+j))) return true; &#125; &#125; return false; &#125; bool check(string num1, string num2, string num)&#123; if(num1.size()&gt;1 &amp;&amp; num1[0]==&apos;0&apos; || num2.size()&gt;1 &amp;&amp; num2[0]==&apos;0&apos;) return false; string sum=add(num1, num2); if(num==sum) return true; if(num.size()&lt;=sum.size() || sum.compare(num.substr(0,sum.size()))!=0) return false; else return check(num2, sum, num.substr(sum.size())); &#125; string add(string n, string m)&#123; string res; int i=n.size()-1, j=m.size()-1, carry=0; while(i&gt;=0 || j&gt;=0)&#123; int sum=carry+(i&gt;=0 ? (n[i--]-&apos;0&apos;) : 0) + (j&gt;=0? (m[j--]-&apos;0&apos;) : 0); res.push_back(sum%10+&apos;0&apos;); carry=sum/10; &#125; if(carry) res.push_back(carry+&apos;0&apos;); reverse(res.begin(), res.end()); return res; &#125; &#125;; https://discuss.leetcode.com/topic/29871/my-simple-c-non-recursion-solution My Simple C++ Non-recursion Solution 12345678910111213141516171819202122232425class Solution &#123;public: bool isAdditiveNumber(string num) &#123; for (int i = 1; i &lt; num.size(); ++i) &#123; for (int j = i + 1; j &lt; num.size(); ++j) &#123; string s1 = num.substr(0, i); string s2 = num.substr(i, j - i); long long d1 = atoll(s1.c_str()), d2 = atoll(s2.c_str()); if ((s1.size() &gt; 1 &amp;&amp; s1[0] == '0') || (s2.size() &gt; 1 &amp;&amp; s2[0] == '0')) continue; long long next = d1 + d2; string nexts = to_string(next); string now = s1 + s2 + nexts; while (now.size() &lt; num.size()) &#123; d1 = d2; d2 = next; next = d1 + d2; nexts = to_string(next); now += nexts; &#125; if (now == num) return true; &#125; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/29856/java-recursive-and-iterative-solutions Java Recursive and Iterative Solutions The idea is quite straight forward. Generate the first and second of the sequence, check if the rest of the string match the sum recursively. i and j are length of the first and second number. i should in the range of [0, n/2]. The length of their sum should &gt;= max(i,j) Java Recursive 12345678910111213141516171819202122232425import java.math.BigInteger;public class Solution &#123; public boolean isAdditiveNumber(String num) &#123; int n = num.length(); for (int i = 1; i &lt;= n / 2; ++i) &#123; if (num.charAt(0) == &apos;0&apos; &amp;&amp; i &gt; 1) return false; BigInteger x1 = new BigInteger(num.substring(0, i)); for (int j = 1; Math.max(j, i) &lt;= n - i - j; ++j) &#123; if (num.charAt(i) == &apos;0&apos; &amp;&amp; j &gt; 1) break; BigInteger x2 = new BigInteger(num.substring(i, i + j)); if (isValid(x1, x2, j + i, num)) return true; &#125; &#125; return false; &#125; private boolean isValid(BigInteger x1, BigInteger x2, int start, String num) &#123; if (start == num.length()) return true; x2 = x2.add(x1); x1 = x2.subtract(x1); String sum = x2.toString(); return num.startsWith(sum, start) &amp;&amp; isValid(x1, x2, start + sum.length(), num); &#125;&#125;// Runtime: 8ms Since isValid is a tail recursion it is very easy to turn it into a loop. Java Iterative 123456789101112131415161718192021222324public class Solution &#123; public boolean isAdditiveNumber(String num) &#123; int n = num.length(); for (int i = 1; i &lt;= n / 2; ++i) for (int j = 1; Math.max(j, i) &lt;= n - i - j; ++j) if (isValid(i, j, num)) return true; return false; &#125; private boolean isValid(int i, int j, String num) &#123; if (num.charAt(0) == &apos;0&apos; &amp;&amp; i &gt; 1) return false; if (num.charAt(i) == &apos;0&apos; &amp;&amp; j &gt; 1) return false; String sum; BigInteger x1 = new BigInteger(num.substring(0, i)); BigInteger x2 = new BigInteger(num.substring(i, i + j)); for (int start = i + j; start != num.length(); start += sum.length()) &#123; x2 = x2.add(x1); x1 = x2.subtract(x1); sum = x2.toString(); if (!num.startsWith(sum, start)) return false; &#125; return true; &#125;&#125;// Runtime: 9ms If no overflow, instead of BigInteger we can consider to use Long which is a lot faster. Java Iterative Using Long 123456789101112131415161718192021222324public class Solution &#123; public boolean isAdditiveNumber(String num) &#123; int n = num.length(); for (int i = 1; i &lt;= n / 2; ++i) for (int j = 1; Math.max(j, i) &lt;= n - i - j; ++j) if (isValid(i, j, num)) return true; return false; &#125; private boolean isValid(int i, int j, String num) &#123; if (num.charAt(0) == &apos;0&apos; &amp;&amp; i &gt; 1) return false; if (num.charAt(i) == &apos;0&apos; &amp;&amp; j &gt; 1) return false; String sum; Long x1 = Long.parseLong(num.substring(0, i)); Long x2 = Long.parseLong(num.substring(i, i + j)); for (int start = i + j; start != num.length(); start += sum.length()) &#123; x2 = x2 + x1; x1 = x2 - x1; sum = x2.toString(); if (!num.startsWith(sum, start)) return false; &#125; return true; &#125;&#125;// Runtime: 3ms https://discuss.leetcode.com/topic/30453/java-very-straightforward-solution-with-detailed-explanation Java very straightforward solution with detailed explanation The idea is quite straightforward: Choose the first number A, it can be the leftmost 1 up to i digits. i&lt;=(L-1)/2 because the third number should be at least as long as the first number Choose the second number B, it can be the leftmost 1 up to j digits excluding the first number. the limit for j is a little bit tricky, because we don’t know whether A or B is longer. The remaining string (with length L-j) after excluding A and B should have a length of at least max(length A, length B), where length A = i and length B = j-i, thus L-j &gt;= max(j-i, i) Calls the recursive checker function and returns true if passes the checker function, or continue to the next choice of B (A) until there is no more choice for B or A, in which case returns a false. Here is the code in Java: 12345678910111213141516171819202122232425262728293031323334public boolean isAdditiveNumber(String num) &#123; int L = num.length(); // choose the first number A for(int i=1; i&lt;=(L-1)/2; i++) &#123; // A cannot start with a 0 if its length is more than 1 if(num.charAt(0) == &apos;0&apos; &amp;&amp; i&gt;=2) break; //previous code: continue; // choose the second number B for(int j=i+1; L-j&gt;=j-i &amp;&amp; L-j&gt;=i; j++) &#123; // B cannot start with a 0 if its length is more than 1 if(num.charAt(i) == &apos;0&apos; &amp;&amp; j-i&gt;=2) break; // previous: continue; long num1 = Long.parseLong(num.substring(0, i)); // A long num2 = Long.parseLong(num.substring(i, j)); // B String substr = num.substring(j); // remaining string if(isAdditive(substr, num1, num2)) return true; // return true if passes isAdditive test // else continue; // continue for loop if does not pass isAdditive test &#125; &#125; return false; // does not pass isAdditive test, thus is not additive&#125;// Recursively checks if a string is additivepublic boolean isAdditive(String str, long num1, long num2) &#123; if(str.equals(&quot;&quot;)) return true; // reaches the end of string means a yes long sum = num1+num2; String s = ((Long)sum).toString(); if(!str.startsWith(s)) return false; // if string does not start with sum of num1 and num2, returns false return isAdditive(str.substring(s.length()), num2, sum); // recursively checks the remaining string&#125; If you are interested in my other posts, please feel free to check my Github page here: https://github.com/F-L-A-G/Algorithms-in-Java https://discuss.leetcode.com/topic/29868/backtracking-with-pruning-java-3-ms-solution-and-python-48-ms-solution Backtracking with Pruning: Java 3 ms Solution and Python 48 ms Solution Backtracking with Pruning. Java (3 ms): 12345678910111213141516171819202122232425public class Solution &#123; public boolean isAdditiveNumber(String num) &#123; if (num == null || num.length() &lt; 3) return false; int n = num.length(); for (int i = 1; i &lt; n; i++) &#123; if (i &gt; 1 &amp;&amp; num.charAt(0) == &apos;0&apos;) break; for (int j = i+1; j &lt; n; j++) &#123; int first = 0, second = i, third = j; if (num.charAt(second) == &apos;0&apos; &amp;&amp; third &gt; second+1) break; while (third &lt; n) &#123; Long result = (Long.parseLong(num.substring(first, second)) + Long.parseLong(num.substring(second, third)) ); if (num.substring(third).startsWith(result.toString())) &#123; first = second; second = third; third += result.toString().length(); &#125; else &#123; break; &#125; &#125; if (third == n) return true; &#125; &#125; return false; &#125;&#125; Python (48 ms): 12345678910111213141516171819202122232425class Solution(object): def isAdditiveNumber(self, num): &quot;&quot;&quot; :type num: str :rtype: bool &quot;&quot;&quot; if num is None or len(num) &lt; 3: return False n = len(num) for i in range(1, n): if i &gt; 1 and num[0] == &apos;0&apos;: break for j in range(i+1, n): first, second, third = 0, i, j if num[second] == &apos;0&apos; and third &gt; second + 1: break while third &lt; n: result = str(int(num[first:second]) + int(num[second:third])) if num[third:].startswith(result): first, second, third = second, third, third + len(result) else: break if third == n: return True return False python 72ms, 8.93%, October 18, 2016 https://discuss.leetcode.com/topic/29845/python-solution Just trying all possibilities for the first two numbers and checking whether the rest fits. 123456789101112131415def isAdditiveNumber(self, num): n = len(num) for i, j in itertools.combinations(range(1, n), 2): a, b = num[:i], num[i:j] if b != str(int(b)): continue while j &lt; n: c = str(int(a) + int(b)) if not num.startswith(c, j): break j += len(c) a, b = b, c if j == n: return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[304. Range Sum Query 2D - Immutable]]></title>
    <url>%2Fp%2F5ae4ba54%2F</url>
    <content type="text"><![CDATA[23.4% https://leetcode.com/problems/range-sum-query-2d-immutable/ Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8. 123456789101112Example:Given matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12 Note: You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 ≤ row2 and col1 ≤ col2. cpp https://discuss.leetcode.com/topic/29536/clean-c-solution-and-explaination-o-mn-space-with-o-1-time Clean C++ Solution and Explaination - O(mn) space with O(1) time Construct a 2D array sums[row+1][col+1] (notice: we add additional blank row sums[0][col+1]={0} and blank column sums[row+1][0]={0} to remove the edge case checking), so, we can have the following definition sums[i+1][j+1] represents the sum of area from matrix[0][0] to matrix[i][j] To calculate sums, the ideas as below 12345678910111213+-----+-+-------+ +--------+-----+ +-----+---------+ +-----+--------+| | | | | | | | | | | | || | | | | | | | | | | | |+-----+-+ | +--------+ | | | | +-----+ || | | | = | | + | | | - | |+-----+-+ | | | +-----+ | | || | | | | | | || | | | | | | |+---------------+ +--------------+ +---------------+ +--------------+ sums[i][j] = sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] + matrix[i-1][j-1] So, we use the same idea to find the specific area’s sum. 123456789+---------------+ +--------------+ +---------------+ +--------------+ +--------------+| | | | | | | | | | | | | || (r1,c1) | | | | | | | | | | | | || +------+ | | | | | | | +---------+ | +---+ || | | | = | | | - | | | - | (r1,c2) | + | (r1,c1) || | | | | | | | | | | | | || +------+ | +---------+ | +---+ | | | | || (r2,c2)| | (r2,c2)| | (r2,c1) | | | | |+---------------+ +--------------+ +---------------+ +--------------+ +--------------+ And we can have the following code 123456789101112131415161718192021class NumMatrix &#123;private: int row, col; vector&lt;vector&lt;int&gt;&gt; sums;public: NumMatrix(vector&lt;vector&lt;int&gt;&gt; &amp;matrix) &#123; row = matrix.size(); col = row&gt;0 ? matrix[0].size() : 0; sums = vector&lt;vector&lt;int&gt;&gt;(row+1, vector&lt;int&gt;(col+1, 0)); for(int i=1; i&lt;=row; i++) &#123; for(int j=1; j&lt;=col; j++) &#123; sums[i][j] = matrix[i-1][j-1] + sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] ; &#125; &#125; &#125; int sumRegion(int row1, int col1, int row2, int col2) &#123; return sums[row2+1][col2+1] - sums[row2+1][col1] - sums[row1][col2+1] + sums[row1][col1]; &#125;&#125;; https://discuss.leetcode.com/topic/29401/c-with-helper C++ with helper My accu[i][j] is the sum of matrix[0..i][0..j], and a(i, j) helps with edge cases. 12345678910111213141516171819class NumMatrix &#123;public: NumMatrix(vector&lt;vector&lt;int&gt;&gt; &amp;matrix) &#123; accu = matrix; for (int i=0; i&lt;matrix.size(); ++i) for (int j=0; j&lt;matrix[0].size(); ++j) accu[i][j] += a(i-1, j) + a(i, j-1) - a(i-1, j-1); &#125; int sumRegion(int row1, int col1, int row2, int col2) &#123; return a(row2, col2) - a(row1-1, col2) - a(row2, col1-1) + a(row1-1, col1-1); &#125;private: vector&lt;vector&lt;int&gt;&gt; accu; int a(int i, int j) &#123; return i &gt;= 0 &amp;&amp; j &gt;= 0 ? accu[i][j] : 0; &#125;&#125;; Afterthought Instead of 1accu[i][j] += a(i-1, j) + a(i, j-1) - a(i-1, j-1); I could use 1accu[i][j] += a(i, j) - sumRegion(i, j, i, j); which is shorter but I think less clear. I do like already using sumRegion in the precomputation, though. my code: 注意中间那句，n = m&gt;0? matrix[0].size() : 0;m可能为0的情况。 1234567891011121314151617181920212223242526class NumMatrix &#123;public: NumMatrix(vector&lt;vector&lt;int&gt;&gt; matrix) &#123; m = matrix.size(); n = m&gt;0? matrix[0].size() : 0; dp = vector&lt;vector&lt;int&gt;&gt;(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; dp[i+1][j+1] = matrix[i][j] + dp[i+1][j] + dp[i][j+1] - dp[i][j]; &#125; &#125; &#125; int sumRegion(int row1, int col1, int row2, int col2) &#123; return dp[row2+1][col2+1] + dp[row1][col1] - dp[row2+1][col1] - dp[row1][col2+1]; &#125;private: int m, n; vector&lt;vector&lt;int&gt;&gt; dp;&#125;;/** * Your NumMatrix object will be instantiated and called as such: * NumMatrix obj = new NumMatrix(matrix); * int param_1 = obj.sumRegion(row1,col1,row2,col2); */ python https://discuss.leetcode.com/topic/29354/sharing-my-python-solution Sharing My Python solution The idea is simple, just precompute sums for all matrices with (0, 0) as top left corner and (i, j) as bottom right corner. There are O(n^2) of these matrices, so we store them in a 2D table. In order to make code simpler, I add an extra column and row, filled with 0. 1234567891011121314class NumMatrix(object): def __init__(self, matrix): if matrix is None or not matrix: return n, m = len(matrix), len(matrix[0]) self.sums = [ [0 for j in xrange(m+1)] for i in xrange(n+1) ] for i in xrange(1, n+1): for j in xrange(1, m+1): self.sums[i][j] = matrix[i-1][j-1] + self.sums[i][j-1] + self.sums[i-1][j] - self.sums[i-1][j-1] def sumRegion(self, row1, col1, row2, col2): row1, col1, row2, col2 = row1+1, col1+1, row2+1, col2+1 return self.sums[row2][col2] - self.sums[row2][col1-1] - self.sums[row1-1][col2] + self.sums[row1-1][col1-1] java https://discuss.leetcode.com/topic/29355/clean-and-easy-to-understand-java-solution Clean and easy to understand java solution 1234567891011121314151617181920212223242526272829private int[][] dp;public NumMatrix(int[][] matrix) &#123; if( matrix == null || matrix.length == 0 || matrix[0].length == 0 )&#123; return; &#125; int m = matrix.length; int n = matrix[0].length; dp = new int[m + 1][n + 1]; for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1] -dp[i - 1][j - 1] + matrix[i - 1][j - 1] ; &#125; &#125;&#125;public int sumRegion(int row1, int col1, int row2, int col2) &#123; int iMin = Math.min(row1, row2); int iMax = Math.max(row1, row2); int jMin = Math.min(col1, col2); int jMax = Math.max(col1, col2); return dp[iMax + 1][jMax + 1] - dp[iMax + 1][jMin] - dp[iMin][jMax + 1] + dp[iMin][jMin]; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[303. Range Sum Query - Immutable]]></title>
    <url>%2Fp%2F8423b2f0%2F</url>
    <content type="text"><![CDATA[27.2% https://leetcode.com/problems/range-sum-query-immutable/ Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. 123456Example:Given nums = [-2, 0, 3, -5, 2, -1]sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function. cpp https://discuss.leetcode.com/topic/29206/5-lines-c-4-lines-python 5-lines C++, 4-lines Python The idea is fairly straightforward: create an array accu that stores the accumulated sum for nums such that accu[i] = nums[0] + … + nums[i - 1] in the initializer of NumArray. Then just return accu[j + 1] - accu[i] in sumRange. You may try the example in the problem statement to convince yourself of this idea. The code is as follows. C++ 1234567891011121314151617181920class NumArray &#123;public: NumArray(vector&lt;int&gt; &amp;nums) &#123; accu.push_back(0); for (int num : nums) accu.push_back(accu.back() + num); &#125; int sumRange(int i, int j) &#123; return accu[j + 1] - accu[i]; &#125;private: vector&lt;int&gt; accu;&#125;;// Your NumArray object will be instantiated and called as such:// NumArray numArray(nums);// numArray.sumRange(0, 1);// numArray.sumRange(1, 2); Python 123456789101112131415161718192021222324class NumArray(object): def __init__(self, nums): &quot;&quot;&quot; initialize your data structure here. :type nums: List[int] &quot;&quot;&quot; self.accu = [0] for num in nums: self.accu += self.accu[-1] + num, def sumRange(self, i, j): &quot;&quot;&quot; sum of elements nums[i..j], inclusive. :type i: int :type j: int :rtype: int &quot;&quot;&quot; return self.accu[j + 1] - self.accu[i]# Your NumArray object will be instantiated and called as such:# numArray = NumArray(nums)# numArray.sumRange(0, 1)# numArray.sumRange(1, 2) https://discuss.leetcode.com/topic/30269/c-o-1-queries-just-2-extra-lines-of-code C++ O(1) queries - just 2 extra lines of code 123456789101112class NumArray &#123;public: NumArray(vector&lt;int&gt; &amp;nums) : psum(nums.size()+1, 0) &#123; partial_sum( nums.begin(), nums.end(), psum.begin()+1); &#125; int sumRange(int i, int j) &#123; return psum[j+1] - psum[i]; &#125;private: vector&lt;int&gt; psum; &#125;; python https://discuss.leetcode.com/topic/29226/a-very-short-python-solution A very short Python solution 12345678class NumArray(object): def __init__(self, nums): self.dp = nums for i in xrange(1, len(nums)): self.dp[i] += self.dp[i-1] def sumRange(self, i, j): return self.dp[j] - (self.dp[i-1] if i &gt; 0 else 0) java https://discuss.leetcode.com/topic/29194/java-simple-o-n-init-and-o-1-query-solution Java simple O(n) init and O(1) query solution 123456789101112131415161718public class NumArray &#123; int[] nums; public NumArray(int[] nums) &#123; for(int i = 1; i &lt; nums.length; i++) nums[i] += nums[i - 1]; this.nums = nums; &#125; public int sumRange(int i, int j) &#123; if(i == 0) return nums[j]; return nums[j] - nums[i - 1]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[301. Remove Invalid Parentheses]]></title>
    <url>%2Fp%2Fc01b943b%2F</url>
    <content type="text"><![CDATA[34.9% https://leetcode.com/problems/remove-invalid-parentheses/#/description Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results. Note: The input string may contain letters other than the parentheses ( and ). 1234Examples:&quot;()())()&quot; -&gt; [&quot;()()()&quot;, &quot;(())()&quot;]&quot;(a)())()&quot; -&gt; [&quot;(a)()()&quot;, &quot;(a())()&quot;]&quot;)(&quot; -&gt; [&quot;&quot;] 方法一： https://discuss.leetcode.com/topic/28831/my-c-dfs-solution-16ms My C++ DFS Solution - 16ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: vector&lt;string&gt; removeInvalidParentheses(string s) &#123; unordered_set&lt;string&gt; result; int left_removed = 0; int right_removed = 0; for(auto c : s) &#123; if(c == &apos;(&apos;) &#123; ++left_removed; &#125; if(c == &apos;)&apos;) &#123; if(left_removed != 0) &#123; --left_removed; &#125; else &#123; ++right_removed; &#125; &#125; &#125; helper(s, 0, left_removed, right_removed, 0, &quot;&quot;, result); return vector&lt;string&gt;(result.begin(), result.end()); &#125;private: void helper(string s, int index, int left_removed, int right_removed, int pair, string path, unordered_set&lt;string&gt;&amp; result) &#123; if(index == s.size()) &#123; if(left_removed == 0 &amp;&amp; right_removed == 0 &amp;&amp; pair == 0) &#123; result.insert(path); &#125; return; &#125; if(s[index] != &apos;(&apos; &amp;&amp; s[index] != &apos;)&apos;) &#123; helper(s, index + 1, left_removed, right_removed, pair, path + s[index], result); &#125; else &#123; if(s[index] == &apos;(&apos;) &#123; if(left_removed &gt; 0) &#123; helper(s, index + 1, left_removed - 1, right_removed, pair, path, result); &#125; helper(s, index + 1, left_removed, right_removed, pair + 1, path + s[index], result); &#125; if(s[index] == &apos;)&apos;) &#123; if(right_removed &gt; 0) &#123; helper(s, index + 1, left_removed, right_removed - 1, pair, path, result); &#125; if(pair &gt; 0) &#123; helper(s, index + 1, left_removed, right_removed, pair - 1, path + s[index], result); &#125; &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/34996/recommend-for-beginners-clean-c-implementation-with-detailed-explaination [recommend for beginners]clean C++ implementation with detailed explaination 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: vector&lt;string&gt; removeInvalidParentheses(string s) &#123; int remove_left=0, remove_right=0, pair=0; /*** use the unordered_set to deal with the duplicate cases ***/ unordered_set&lt;string&gt; result; /*** calculate the remained # of left and right parentheses ***/ for(int i=0; i&lt;s.size(); i++)&#123; if(s[i]==&apos;(&apos;) remove_left++; else if(s[i]==&apos;)&apos;)&#123; if(remove_left &gt; 0) remove_left--; else remove_right++; &#125; &#125; help(0, 0, remove_left, remove_right, s, &quot;&quot;, result); /*** change the unordered_set to vector ***/ return vector&lt;string&gt;(result.begin(), result.end()); &#125; /*** pair : record the () pair count in the solution index : record the cur-position int the string s remove_left : the number of left parentheses needed to delete remove_right : the number of right parentheses needed to delete s : origninal input string solution : the current produced string result : stores all the satisfied solution string ***/ void help(int pair, int index, int remove_left, int remove_right, const string&amp; s, string solution, unordered_set&lt;string&gt;&amp; result)&#123; /*** end condition ***/ if(index==s.size())&#123; /*** check whether the remained string solution is right ***/ if(pair==0 &amp;&amp; remove_left==0 &amp;&amp; remove_right==0) result.insert(solution); return; &#125; /*** left-half-parentheses ***/ if(s[index]==&apos;(&apos;)&#123; /*** remove the left-half-parentheses ***/ if(remove_left &gt; 0) help(pair, index+1, remove_left-1, remove_right, s, solution, result); /*** keep the left-half-parentheses ***/ help(pair+1, index+1, remove_left, remove_right, s, solution+s[index], result); &#125; /*** right-half-parentheses ***/ else if(s[index]==&apos;)&apos;)&#123; /*** remove the right-half-parentheses ***/ if(remove_right &gt; 0) help(pair, index+1, remove_left, remove_right-1, s, solution, result); /*** keep the right-half-parentheses ***/ if(pair &gt; 0) help(pair-1, index+1, remove_left, remove_right, s, solution+s[index], result); &#125; /*** other-characters ***/ else&#123; help(pair, index+1, remove_left, remove_right, s, solution+s[index], result); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/28819/c-depth-limited-dfs-3ms-eliminate-duplicates-without-hashmap C++ Depth limited DFS 3ms. Eliminate duplicates without hashmap. num1 and num2 stand for the number of ‘(‘ and ‘)’ to remove respectively. Duplicates arise from consecutive ‘(‘ or ‘)’. We only get rid of the first one before going a level further. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;private: bool isValid(string s) &#123; int sum = 0; for(char &amp;c : s) &#123; if(c == &apos;(&apos;) ++sum; else if(c == &apos;)&apos;) --sum; if(sum &lt; 0) return false; &#125; return sum == 0; &#125;public: vector&lt;string&gt; removeInvalidParentheses(string s) &#123; int num1 = 0, num2 = 0; for(char &amp;c : s) &#123; num1 += c == &apos;(&apos;; if (num1 == 0) &#123; num2 += c == &apos;)&apos;; &#125; else &#123; num1 -= c == &apos;)&apos;; &#125; &#125; vector&lt;string&gt; ret; dfs(s, 0, num1, num2, ret); return ret; &#125; void dfs(string s, int beg, int num1, int num2, vector&lt;string&gt; &amp;ret) &#123; if(num1 == 0 &amp;&amp; num2 == 0) &#123; if(isValid(s)) ret.push_back(s); &#125; else &#123; for(int i = beg; i &lt; s.size(); ++i) &#123; string tmp = s; if(num2 == 0 &amp;&amp; num1 &gt; 0 &amp;&amp; tmp[i] == &apos;(&apos;) &#123; if(i == beg || tmp[i] != tmp[i - 1]) &#123; tmp.erase(i, 1); dfs(tmp, i, num1 - 1, num2, ret); &#125; &#125; if(num2 &gt; 0 &amp;&amp; tmp[i] == &apos;)&apos;) &#123; if(i == beg || tmp[i] != tmp[i - 1]) &#123; tmp.erase(i, 1); dfs(tmp, i, num1, num2 - 1, ret); &#125; &#125; &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/28833/short-python-bfs Short Python BFS Solution 1 Being lazy and using eval for checking: 12345678910111213def removeInvalidParentheses(self, s): level = &#123;s&#125; while True: valid = [] for s in level: try: eval(&apos;0,&apos; + filter(&apos;()&apos;.count, s).replace(&apos;)&apos;, &apos;),&apos;)) valid.append(s) except: pass if valid: return valid level = &#123;s[:i] + s[i+1:] for s in level for i in range(len(s))&#125; Update: Meh, ok, checking it myself isn’t that much longer, and it’s three times as fast: Solution 2 1234567891011121314151617def removeInvalidParentheses(self, s): def isvalid(s): ctr = 0 for c in s: if c == &apos;(&apos;: ctr += 1 elif c == &apos;)&apos;: ctr -= 1 if ctr &lt; 0: return False return ctr == 0 level = &#123;s&#125; while True: valid = filter(isvalid, level) if valid: return valid level = &#123;s[:i] + s[i+1:] for s in level for i in range(len(s))&#125; Solution 3 Just a mix of the above two. 12345678910111213def removeInvalidParentheses(self, s): def isvalid(s): try: eval(&apos;0,&apos; + filter(&apos;()&apos;.count, s).replace(&apos;)&apos;, &apos;),&apos;)) return True except: pass level = &#123;s&#125; while True: valid = filter(isvalid, level) if valid: return valid level = &#123;s[:i] + s[i+1:] for s in level for i in range(len(s))&#125; Solution 4 Yet another way to do isvalid. 123456789101112def removeInvalidParentheses(self, s): def isvalid(s): s = filter(&apos;()&apos;.count, s) while &apos;()&apos; in s: s = s.replace(&apos;()&apos;, &apos;&apos;) return not s level = &#123;s&#125; while True: valid = filter(isvalid, level) if valid: return valid level = &#123;s[:i] + s[i+1:] for s in level for i in range(len(s))&#125; https://discuss.leetcode.com/topic/29096/python-dp-solution Python DP Solution We can perceive the task as minimization the number of removed parenthesis and represent the solution as recursive with parameters si - ‘Start Index’ and oc - ‘Open Count’. DropCount = min(DropCount[si + 1][oc], DropCount[si + 1][oc + {1 if s[si] == ‘(‘ else -1}] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def minDrop(s, si, oc, cache, pseq): N = len(s) if oc &lt; 0: return N - si + 1 if si == N : if oc == 0: pseq[si][oc] = &#123;&apos;&apos;&#125; return oc if cache[si][oc] != -1: return cache[si][oc] if s[si] in &apos;()&apos;: dc0 = 1 + minDrop(s, si + 1, oc, cache, pseq) pseq0 = pseq[si + 1][oc] if s[si] == &apos;(&apos;: dc1 = minDrop(s, si + 1, oc + 1, cache, pseq) pseq1 = [&apos;(&apos; + x for x in pseq[si + 1][oc + 1]] else: dc1 = minDrop(s, si + 1, oc - 1, cache, pseq) pseq1 = [&apos;)&apos; + x for x in pseq[si + 1][oc - 1]] cache[si][oc] = min(dc0, dc1) # note &apos;=&apos; - in case of eqaulity we keep both combination sets if dc0 &gt;= dc1 : pseq[si][oc] = pseq[si][oc].union(pseq1) if dc0 &lt;= dc1 : pseq[si][oc] = pseq[si][oc].union(pseq0) else: cache[si][oc] = minDrop(s, si + 1, oc, cache, pseq) pseq[si][oc] = [s[si] + x for x in pseq[si + 1][oc]] return cache[si][oc]class Solution(object): def removeInvalidParentheses(self, s): &quot;&quot;&quot; :type s: str :rtype: List[str] &quot;&quot;&quot; N = len(s) cache = [[-1 for x in range(N)] for x in range(N)] pseq = [[set() for x in range(N + 1)] for x in range(N + 1)] c = minDrop(s, 0, 0, cache, pseq) return list(pseq[0][0]) 101ms, 40.15%, October 15, 2016 https://discuss.leetcode.com/topic/28827/share-my-java-bfs-solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public List&lt;String&gt; removeInvalidParentheses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(s == null) return res; Set&lt;String&gt; visited = new HashSet&lt;&gt;(); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(s); visited.add(s); boolean found = false; while(!queue.isEmpty())&#123; s = queue.poll(); if(isValid(s))&#123; res.add(s); found = true; &#125; if(found) continue; for(int i = 0; i&lt;s.length(); i++)&#123; if(s.charAt(i) != &apos;(&apos; &amp;&amp; s.charAt(i) != &apos;)&apos;) continue; String t = s.substring(0, i) + s.substring(i+1); if(!visited.contains(t))&#123; queue.add(t); visited.add(t); &#125; &#125; &#125; return res; &#125; boolean isValid(String s)&#123; int count = 0; for(int i=0; i&lt;s.length(); i++)&#123; char c = s.charAt(i); if(c==&apos;(&apos;) count++; if(c==&apos;)&apos; &amp;&amp; count -- == 0) return false; &#125; return count == 0; &#125;&#125; 3ms, 81.22%, October 15, 2016 https://discuss.leetcode.com/topic/34875/easy-short-concise-and-fast-java-dfs-3-ms-solution 123456789101112131415161718192021222324public class Solution &#123; public List&lt;String&gt; removeInvalidParentheses(String s) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); remove(s, ans, 0, 0, new char[]&#123;&apos;(&apos;, &apos;)&apos;&#125;); return ans; &#125; public void remove(String s, List&lt;String&gt; ans, int last_i, int last_j, char[] par)&#123; for(int stack = 0, i = last_i; i&lt;s.length(); ++i)&#123; if(s.charAt(i) == par[0]) stack++; if(s.charAt(i) == par[1]) stack--; if(stack &gt;= 0) continue; for(int j=last_j; j&lt;=i; ++j) if(s.charAt(j) == par[1] &amp;&amp; (j==last_j || s.charAt(j-1) != par[1])) remove(s.substring(0, j) + s.substring(j+1, s.length()), ans, i, j, par); return; &#125; String reversed = new StringBuilder(s).reverse().toString(); if(par[0] == &apos;(&apos;) remove(reversed, ans, 0, 0, new char[]&#123;&apos;)&apos;, &apos;(&apos;&#125;); else ans.add(reversed); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>depth first search</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[300. Longest Increasing Subsequence]]></title>
    <url>%2Fp%2F71a6e0e6%2F</url>
    <content type="text"><![CDATA[38.4% https://leetcode.com/problems/longest-increasing-subsequence/ Given an unsorted array of integers, find the length of longest increasing subsequence. 1234For example,Given [10, 9, 2, 5, 3, 7, 101, 18],The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? 腾讯地图面试题 方法一： dp算法 效率n**2 我的代码实现： 123456789101112131415161718class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int n = nums.size(); // dp[i]表示以nums[i]结尾的最长序列的个数 vector&lt;int&gt; dp(n, 1); for(int i=1; i&lt;n; i++) for(int j=i-1; j&gt;=0; j--) if(nums[i]&gt;nums[j]) dp[i] = max(dp[i], dp[j]+1); // dp[n-1]不是最大的，要把所有遍历才能找出来 int res = 1; for(int i=0; i&lt;n; i++) res = max(dp[i], res); return res; &#125;&#125;; 动态规划，设定一个vector 长度为n，每一位保存的是以第i位为结尾的最长序列的长度，依次更新。 最后dp的vector中的最大值为结果。 空间效率 n，时间效率n**2 我的代码实现: Dec 8th, 2017 123456789101112131415161718class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int n = nums.size(); vector&lt;int&gt; dp(n, 1); for(int i=1; i&lt;n; i++)&#123; for(int j=i-1; j&gt;=0; j--)&#123; if(nums[i]&gt;nums[j]) dp[i] = max(dp[i], dp[j]+1); &#125; &#125; int res = 0; for(int i=0; i&lt;n; i++) res = max(res, dp[i]); return res; &#125;&#125;; This is a classic problem and here is a DP solution for reference Please note a NLogN solution can be found in the following link Geek for Geek 123456789101112131415161718192021class Solution &#123;public: // There&apos;s a typical DP solution with O(N^2) Time and O(N) space // DP[i] means the result ends at i // So for dp[i], dp[i] is max(dp[j]+1), for all j &lt; i and nums[j] &lt; nums[i] int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; const int size = nums.size(); if (size == 0) &#123; return 0; &#125; vector&lt;int&gt; dp(size, 1); int res = 1; for (int i = 1; i &lt; size; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[j] &lt; nums[i]) &#123; dp[i] = max(dp[i], dp[j]+1); &#125; &#125; res = max (res, dp[i]); &#125; return res; &#125;&#125;; 我的实现 dp[k]定义为，以num[k]结尾的最长公共子序列的长度 然后初始值都设为1 最后要遍历一遍，才能得出res，因为每个结尾并不一样 1234567891011121314151617181920class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; if(n==1) return 1; vector&lt;int&gt; dp(n, 1); for(int i=1; i&lt;n; i++)&#123; for(int j=0; j&lt;i; j++)&#123; if(nums[i]&gt;nums[j]) dp[i] = max(dp[i], dp[j]+1); &#125; &#125; int res = 0; for(int k=0; k&lt;n; k++)&#123; res = max(res, dp[k]); &#125; return res; &#125;&#125;; 方法二： 从第一种解法可以看出，最关键的是最后一位。这里保存长度为k的字符串的最后一位。 另一种高效解法，时间效率:nlogn 我的代码实现： Dec 8th, 2017 123456789101112131415class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; vector&lt;int&gt; dp; for(auto num:nums)&#123; auto it = lower_bound(dp.begin(), dp.end(), num); if(it==dp.end()) dp.push_back(num); else *it = num; &#125; return dp.size(); &#125;&#125;; 我的代码实现： 12345678910111213141516class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; vector&lt;int&gt; v; for(size_t i = 0; i&lt;nums.size(); i++)&#123; auto it = lower_bound(v.begin(), v.end(), nums[i]); if(it==v.end()) v.push_back(nums[i]); else *it = nums[i]; &#125; return v.size(); &#125;&#125;; 9 lines C++ code with O(NlogN) complexity Inspired by http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/ 123456789101112class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; for(int i=0; i&lt;nums.size(); i++)&#123; auto it = std::lower_bound(res.begin(), res.end(), nums[i]); if(it==res.end()) res.push_back(nums[i]); else *it = nums[i]; &#125; return res.size(); &#125;&#125;; 关于lower_bound and upper_bound lower_bound: ‘ &gt;= val ‘ Return value Iterator pointing to the first element that is not less than value, or last if no such element is found. upper_bound: ‘ &gt; val ‘ Return value iterator pointing to the first element that is greater than value, or last if no such element is found. http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/ Longest Increasing Subsequence Size (N log N) Given an array of random numbers. Find longest increasing subsequence (LIS) in the array. I know many of you might have read recursive and dynamic programming (DP) solutions. There are few requests for O(N log N) algo in the forum posts. Recommended: Please solve it on “PRACTICE ” first, before moving on to the solution.For the time being, forget about recursive and DP solutions. Let us take small samples and extend the solution to large instances. Even though it may look complex at first time, once if we understood the logic, coding is simple. Consider an input array A = {2, 5, 3}. I will extend the array during explanation. By observation we know that the LIS is either {2, 3} or {2, 5}. Note that I am considering only strictly increasing sequences. Let us add two more elements, say 7, 11 to the array. These elements will extend the existing sequences. Now the increasing sequences are {2, 3, 7, 11} and {2, 5, 7, 11} for the input array {2, 5, 3, 7, 11}. Further, we add one more element, say 8 to the array i.e. input array becomes {2, 5, 3, 7, 11, 8}. Note that the latest element 8 is greater than smallest element of any active sequence (will discuss shortly about active sequences). How can we extend the existing sequences with 8? First of all, can 8 be part of LIS? If yes, how? If we want to add 8, it should come after 7 (by replacing 11). Since the approach is offline (what we mean by offline?), we are not sure whether adding 8 will extend the series or not. Assume there is 9 in the input array, say {2, 5, 3, 7, 11, 8, 7, 9 …}. We can replace 11 with 8, as there is potentially best candidate (9) that can extend the new series {2, 3, 7, 8} or {2, 5, 7, 8}. Our observation is, assume that the end element of largest sequence is E. We can add (replace) current element A[i] to the existing sequence if there is an element A[j] (j &gt; i) such that E &lt; A[i] &lt; A[j] or (E &gt; A[i] &lt; A[j] – for replace). In the above example, E = 11, A[i] = 8 and A[j] = 9. In case of our original array {2, 5, 3}, note that we face same situation when we are adding 3 to increasing sequence {2, 5}. I just created two increasing sequences to make explanation simple. Instead of two sequences, 3 can replace 5 in the sequence {2, 5}. I know it will be confusing, I will clear it shortly! The question is, when will it be safe to add or replace an element in the existing sequence? Let us consider another sample A = {2, 5, 3}. Say, the next element is 1. How can it extend the current sequences {2,3} or {2, 5}. Obviously, it can’t extend either. Yet, there is a potential that the new smallest element can be start of an LIS. To make it clear, consider the array is {2, 5, 3, 1, 2, 3, 4, 5, 6}. Making 1 as new sequence will create new sequence which is largest. The observation is, when we encounter new smallest element in the array, it can be a potential candidate to start new sequence. From the observations, we need to maintain lists of increasing sequences. In general, we have set of active lists of varying length. We are adding an element A[i] to these lists. We scan the lists (for end elements) in decreasing order of their length. We will verify the end elements of all the lists to find a list whose end element is smaller than A[i] (floor value). Our strategy determined by the following conditions, 12345678910111. If A[i] is smallest among all end candidates of active lists, we will start new active list of length 1.2. If A[i] is largest among all end candidates of active lists, we will clone the largest active list, and extend it by A[i].3. If A[i] is in between, we will find a list with largest end element that is smaller than A[i]. Clone and extend this list by A[i]. We will discard all other lists of same length as that of this modified list. Note that at any instance during our construction of active lists, the following condition is maintained. 1“end element of smaller list is smaller than end elements of larger lists”. It will be clear with an example, let us take example from wiki {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101A[0] = 0. Case 1. There are no active lists, create one.0.-----------------------------------------------------------------------------A[1] = 8. Case 2. Clone and extend.0.0, 8.-----------------------------------------------------------------------------A[2] = 4. Case 3. Clone, extend and discard.0.0, 4.0, 8. Discarded-----------------------------------------------------------------------------A[3] = 12. Case 2. Clone and extend.0.0, 4.0, 4, 12.-----------------------------------------------------------------------------A[4] = 2. Case 3. Clone, extend and discard.0.0, 2.0, 4. Discarded.0, 4, 12.-----------------------------------------------------------------------------A[5] = 10. Case 3. Clone, extend and discard.0.0, 2.0, 2, 10.0, 4, 12. Discarded.-----------------------------------------------------------------------------A[6] = 6. Case 3. Clone, extend and discard.0.0, 2.0, 2, 6.0, 2, 10. Discarded.-----------------------------------------------------------------------------A[7] = 14. Case 2. Clone and extend.0.0, 2.0, 2, 6.0, 2, 6, 14.-----------------------------------------------------------------------------A[8] = 1. Case 3. Clone, extend and discard.0.0, 1.0, 2. Discarded.0, 2, 6.0, 2, 6, 14.-----------------------------------------------------------------------------A[9] = 9. Case 3. Clone, extend and discard.0.0, 1.0, 2, 6.0, 2, 6, 9.0, 2, 6, 14. Discarded.-----------------------------------------------------------------------------A[10] = 5. Case 3. Clone, extend and discard.0.0, 1.0, 1, 5.0, 2, 6. Discarded.0, 2, 6, 9.-----------------------------------------------------------------------------A[11] = 13. Case 2. Clone and extend.0.0, 1.0, 1, 5.0, 2, 6, 9.0, 2, 6, 9, 13.-----------------------------------------------------------------------------A[12] = 3. Case 3. Clone, extend and discard.0.0, 1.0, 1, 3.0, 1, 5. Discarded.0, 2, 6, 9.0, 2, 6, 9, 13.-----------------------------------------------------------------------------A[13] = 11. Case 3. Clone, extend and discard.0.0, 1.0, 1, 3.0, 2, 6, 9.0, 2, 6, 9, 11.0, 2, 6, 9, 13. Discarded.-----------------------------------------------------------------------------A[14] = 7. Case 3. Clone, extend and discard.0.0, 1.0, 1, 3.0, 1, 3, 7.0, 2, 6, 9. Discarded.0, 2, 6, 9, 11.----------------------------------------------------------------------------A[15] = 15. Case 2. Clone and extend.0.0, 1.0, 1, 3.0, 1, 3, 7.0, 2, 6, 9, 11.0, 2, 6, 9, 11, 15. &lt;-- LIS List---------------------------------------------------------------------------- It is required to understand above strategy to devise an algorithm. Also, ensure we have maintained the condition, “end element of smaller list is smaller than end elements of larger lists“. Try with few other examples, before reading further. It is important to understand what happening to end elements. Algorithm: Querying length of longest is fairly easy. Note that we are dealing with end elements only. We need not to maintain all the lists. We can store the end elements in an array. Discarding operation can be simulated with replacement, and extending a list is analogous to adding more elements to array. We will use an auxiliary array to keep end elements. The maximum length of this array is that of input. In the worst case the array divided into N lists of size one (note that it does’t lead to worst case complexity). To discard an element, we will trace ceil value of A[i] in auxiliary array (again observe the end elements in your rough work), and replace ceil value with A[i]. We extend a list by adding element to auxiliary array. We also maintain a counter to keep track of auxiliary array length. Bonus: You have learnt Patience Sorting technique partially 🙂 Here is a proverb, “Tell me and I will forget. Show me and I will remember. Involve me and I will understand.” So, pick a suit from deck of cards. Find the longest increasing sub-sequence of cards from the shuffled suit. You will never forget the approach. 🙂 Update – 17 July, 2016: Quite impressive reponses from the readers and few sites referring the post, feeling happy as my hardwork helping others. It looks like readers are not doing any homework prior to posting comments. Requesting to run through some examples after reading the article, and please do your work on paper (don’t use editor/compiler). The request is to help yourself. Profess to ‘know’ is different from real understanding (no disrespect). Given below was my personal experience. Initial content preparation took roughly 6 hours to me. But, it was a good lesson. I finished initial code in an hour. When I start writing content to explain the reader, I realized I didn’t understand the cases. Took my note book (I have habit of maintaining binded note book to keep track of my rough work), and after few hours I filled nearly 15 pages of rough work. Whatever the content you are seeing in the gray colored example is from these pages. All the thought process for the solution triggered by a note in the book ‘Introduction to Algorithms by Udi Manber’, I strongly recommend to practice the book. I suspect, many readers might not get the logic behind CeilIndex (binary search). I leave it as an exercise to the reader to understand how it works. Run through few examples on paper. I realized I have already covered the algorithm in another post. Update – 5th August, 2016: The following link worth referring after you do your work. I got to know the link via my recently created Disqus profile. The link has explanation of approach mentioned in the Wiki. http://stackoverflow.com/questions/2631726/how-to-determine-the-longest-increasing-subsequence-using-dynamic-programming Given below is code to find length of LIS (updated to C++11 code, no C-style arrays), C++ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt; // Binary search (note boundaries in the caller)int CeilIndex(std::vector&lt;int&gt; &amp;v, int l, int r, int key) &#123; while (r-l &gt; 1) &#123; int m = l + (r-l)/2; if (v[m] &gt;= key) r = m; else l = m; &#125; return r;&#125; int LongestIncreasingSubsequenceLength(std::vector&lt;int&gt; &amp;v) &#123; if (v.size() == 0) return 0; std::vector&lt;int&gt; tail(v.size(), 0); int length = 1; // always points empty slot in tail tail[0] = v[0]; for (size_t i = 1; i &lt; v.size(); i++) &#123; if (v[i] &lt; tail[0]) // new smallest value tail[0] = v[i]; else if (v[i] &gt; tail[length-1]) // v[i] extends largest subsequence tail[length++] = v[i]; else // v[i] will become end candidate of an existing subsequence or // Throw away larger elements in all LIS, to make room for upcoming grater elements than v[i] // (and also, v[i] would have already appeared in one of LIS, identify the location and replace it) tail[CeilIndex(tail, -1, length-1, v[i])] = v[i]; &#125; return length;&#125; int main() &#123; std::vector&lt;int&gt; v&#123; 2, 5, 3, 7, 11, 8, 10, 13, 6 &#125;; std::cout &lt;&lt; "Length of Longest Increasing Subsequence is " &lt;&lt; LongestIncreasingSubsequenceLength(v) &lt;&lt; 'n'; return 0;&#125; Output: Length of Longest Increasing Subsequence is 6 Complexity: The loop runs for N elements. In the worst case (what is worst case input?), we may end up querying ceil value using binary search (log i) for many A[i]. Therefore, T(n) &lt; O( log N! ) = O(N log N). Analyse to ensure that the upper and lower bounds are also O( N log N ). The complexity is THETA (N log N). Exercises: Design an algorithm to construct the longest increasing list. Also, model your solution using DAGs. Design an algorithm to construct all increasing lists of equal longest size. Is the above algorithm an online algorithm? Design an algorithm to construct the longest decreasing list.. — Venki. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above. cpp https://discuss.leetcode.com/topic/28696/9-lines-c-code-with-o-nlogn-complexity 3ms, September 10, 2016 9 lines C++ code with O(NlogN) complexity Inspired by http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/ 123456789101112class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; for(int i=0; i&lt;nums.size(); i++)&#123; auto it = std::lower_bound(res.begin(), res.end(), nums[i]); if(it==res.end()) res.push_back(nums[i]); else *it = nums[i]; &#125; return res.size(); &#125;&#125;; https://discuss.leetcode.com/topic/28685/c-typical-dp-n-2-solution-and-nlogn-solution-from-geekforgeek [C++] Typical DP N^2 solution and NLogN solution from GeekForGeek This is a classic problem and here is a DP solution for reference Please note a NLogN solution can be found in the following link Geek for Geek 123456789101112131415161718192021class Solution &#123;public: // There&apos;s a typical DP solution with O(N^2) Time and O(N) space // DP[i] means the result ends at i // So for dp[i], dp[i] is max(dp[j]+1), for all j &lt; i and nums[j] &lt; nums[i] int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; const int size = nums.size(); if (size == 0) &#123; return 0; &#125; vector&lt;int&gt; dp(size, 1); int res = 1; for (int i = 1; i &lt; size; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[j] &lt; nums[i]) &#123; dp[i] = max(dp[i], dp[j]+1); &#125; &#125; res = max (res, dp[i]); &#125; return res; &#125;&#125;; http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/ Longest Increasing Subsequence Size (N log N) After few months of gap posting an algo. The current post is pending from long time, and many readers (e.g. here, here, here may be few more, I am not keeping track of all) are posting requests for explanation of the below problem. Given an array of random numbers. Find longest increasing subsequence (LIS) in the array. I know many of you might have read recursive and dynamic programming (DP) solutions. There are few requests for O(N log N) algo in the forum posts. For the time being, forget about recursive and DP solutions. Let us take small samples and extend the solution to large instances. Even though it may look complex at first time, once if we understood the logic, coding is simple. Consider an input array A = {2, 5, 3}. I will extend the array during explanation. By observation we know that the LIS is either {2, 3} or {2, 5}. Note that I am considering only strictly increasing sequences. Let us add two more elements, say 7, 11 to the array. These elements will extend the existing sequences. Now the increasing sequences are {2, 3, 7, 11} and {2, 5, 7, 11} for the input array {2, 5, 3, 7, 11}. Further, we add one more element, say 8 to the array i.e. input array becomes {2, 5, 3, 7, 11, 8}. Note that the latest element 8 is greater than smallest element of any active sequence (will discuss shortly about active sequences). How can we extend the existing sequences with 8? First of all, can 8 be part of LIS? If yes, how? If we want to add 8, it should come after 7 (by replacing 11). Since the approach is offline (what we mean by offline?), we are not sure whether adding 8 will extend the series or not. Assume there is 9 in the input array, say {2, 5, 3, 7, 11, 8, 7, 9 …}. We can replace 11 with 8, as there is potentially best candidate (9) that can extend the new series {2, 3, 7, 8} or {2, 5, 7, 8}. Our observation is, assume that the end element of largest sequence is E. We can add (replace) current element A[i] to the existing sequence if there is an element A[j] (j &gt; i) such that E &lt; A[i] &lt; A[j] or (E &gt; A[i] &lt; A[j] – for replace). In the above example, E = 11, A[i] = 8 and A[j] = 9. In case of our original array {2, 5, 3}, note that we face same situation when we are adding 3 to increasing sequence {2, 5}. I just created two increasing sequences to make explanation simple. Instead of two sequences, 3 can replace 5 in the sequence {2, 5}. I know it will be confusing, I will clear it shortly! The question is, when will it be safe to add or replace an element in the existing sequence? Let us consider another sample A = {2, 5, 3}. Say, the next element is 1. How can it extend the current sequences {2,3} or {2, 5}. Obviously, it can’t extend either. Yet, there is a potential that the new smallest element can be start of an LIS. To make it clear, consider the array is {2, 5, 3, 1, 2, 3, 4, 5, 6}. Making 1 as new sequence will create new sequence which is largest. The observation is, when we encounter new smallest element in the array, it can be a potential candidate to start new sequence. From the observations, we need to maintain lists of increasing sequences. In general, we have set of active lists of varying length. We are adding an element A[i] to these lists. We scan the lists (for end elements) in decreasing order of their length. We will verify the end elements of all the lists to find a list whose end element is smaller than A[i] (floor value). Our strategy determined by the following conditions, 1231. If A[i] is smallest among all end candidates of active lists, we will start new active list of length 1. 1232. If A[i] is largest among all end candidates of active lists, we will clone the largest active list, and extend it by A[i]. 12343. If A[i] is in between, we will find a list with largest end element that is smaller than A[i]. Clone and extend this list by A[i]. We will discard all other lists of same length as that of this modified list. Note that at any instance during our construction of active lists, the following condition is maintained. “end element of smaller list is smaller than end elements of larger lists”. It will be clear with an example, let us take example from wiki {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101A[0] = 0. Case 1. There are no active lists, create one.0.-----------------------------------------------------------------------------A[1] = 8. Case 2. Clone and extend.0.0, 8.-----------------------------------------------------------------------------A[2] = 4. Case 3. Clone, extend and discard.0.0, 4.0, 8. Discarded-----------------------------------------------------------------------------A[3] = 12. Case 2. Clone and extend.0.0, 4.0, 4, 12.-----------------------------------------------------------------------------A[4] = 2. Case 3. Clone, extend and discard.0.0, 2.0, 4. Discarded.0, 4, 12.-----------------------------------------------------------------------------A[5] = 10. Case 3. Clone, extend and discard.0.0, 2.0, 2, 10.0, 4, 12. Discarded.-----------------------------------------------------------------------------A[6] = 6. Case 3. Clone, extend and discard.0.0, 2.0, 2, 6.0, 2, 10. Discarded.-----------------------------------------------------------------------------A[7] = 14. Case 2. Clone and extend.0.0, 2.0, 2, 6.0, 2, 6, 14.-----------------------------------------------------------------------------A[8] = 1. Case 3. Clone, extend and discard.0.0, 1.0, 2. Discarded.0, 2, 6.0, 2, 6, 14.-----------------------------------------------------------------------------A[9] = 9. Case 3. Clone, extend and discard.0.0, 1.0, 2, 6.0, 2, 6, 9.0, 2, 6, 14. Discarded.-----------------------------------------------------------------------------A[10] = 5. Case 3. Clone, extend and discard.0.0, 1.0, 1, 5.0, 2, 6. Discarded.0, 2, 6, 9.-----------------------------------------------------------------------------A[11] = 13. Case 2. Clone and extend.0.0, 1.0, 1, 5.0, 2, 6, 9.0, 2, 6, 9, 13.-----------------------------------------------------------------------------A[12] = 3. Case 3. Clone, extend and discard.0.0, 1.0, 1, 3.0, 1, 5. Discarded.0, 2, 6, 9.0, 2, 6, 9, 13.-----------------------------------------------------------------------------A[13] = 11. Case 3. Clone, extend and discard.0.0, 1.0, 1, 3.0, 2, 6, 9.0, 2, 6, 9, 11.0, 2, 6, 9, 13. Discarded.-----------------------------------------------------------------------------A[14] = 7. Case 3. Clone, extend and discard.0.0, 1.0, 1, 3.0, 1, 3, 7.0, 2, 6, 9. Discarded.0, 2, 6, 9, 11.----------------------------------------------------------------------------A[15] = 15. Case 2. Clone and extend.0.0, 1.0, 1, 3.0, 1, 3, 7.0, 2, 6, 9, 11.0, 2, 6, 9, 11, 15. &lt;-- LIS List---------------------------------------------------------------------------- It is required to understand above strategy to devise an algorithm. Also, ensure we have maintained the condition, “end element of smaller list is smaller than end elements of larger lists“. Try with few other examples, before reading further. It is important to understand what happening to end elements. Algorithm: Querying length of longest is fairly easy. Note that we are dealing with end elements only. We need not to maintain all the lists. We can store the end elements in an array. Discarding operation can be simulated with replacement, and extending a list is analogous to adding more elements to array. We will use an auxiliary array to keep end elements. The maximum length of this array is that of input. In the worst case the array divided into N lists of size one (note that it does’t lead to worst case complexity). To discard an element, we will trace ceil value of A[i] in auxiliary array (again observe the end elements in your rough work), and replace ceil value with A[i]. We extend a list by adding element to auxiliary array. We also maintain a counter to keep track of auxiliary array length. Bonus: You have learnt Patience Sorting technique partially 🙂 Here is a proverb, “Tell me and I will forget. Show me and I will remember. Involve me and I will understand.” So, pick a suit from deck of cards. Find the longest increasing sub-sequence of cards from the shuffled suit. You will never forget the approach. 🙂 Update – 17 July, 2016: Quite impressive reponses from the readers and few sites referring the post, feeling happy as my hardwork helping others. It looks like readers are not doing any homework prior to posting comments. Requesting to run through some examples after reading the article, and please do your work on paper (don’t use editor/compiler). The request is to help yourself. Profess to ‘know’ is different from real understanding (no disrespect). Given below was my personal experience. Initial content preparation took roughly 6 hours to me. But, it was a good lesson. I finished initial code in an hour. When I start writing content to explain the reader, I realized I didn’t understand the cases. Took my note book (I have habit of maintaining binded note book to keep track of my rough work), and after few hours I filled nearly 15 pages of rough work. Whatever the content you are seeing in the gray colored example is from these pages. All the thought process for the solution triggered by a note in the book ‘Introduction to Algorithms by Udi Manber’, I strongly recommend to practice the book. I suspect, many readers might not get the logic behind CeilIndex (binary search). I leave it as an exercise to the reader to understand how it works. Run through few examples on paper. I realized I have already covered the algorithm in another post. Update – 5th August, 2016: The following link worth referring after you do your work. I got to know the link via my recently created Disqus profile. The link has explanation of approach mentioned in the Wiki. http://stackoverflow.com/questions/2631726/how-to-determine-the-longest-increasing-subsequence-using-dynamic-programming Given below is code to find length of LIS (updated to C++11 code, no C-style arrays), cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt; // Binary search (note boundaries in the caller)int CeilIndex(std::vector&lt;int&gt; &amp;v, int l, int r, int key) &#123; while (r-l &gt; 1) &#123; int m = l + (r-l)/2; if (v[m] &gt;= key) r = m; else l = m; &#125; return r;&#125; int LongestIncreasingSubsequenceLength(std::vector&lt;int&gt; &amp;v) &#123; if (v.size() == 0) return 0; std::vector&lt;int&gt; tail(v.size(), 0); int length = 1; // always points empty slot in tail tail[0] = v[0]; for (size_t i = 1; i &lt; v.size(); i++) &#123; if (v[i] &lt; tail[0]) // new smallest value tail[0] = v[i]; else if (v[i] &gt; tail[length-1]) // v[i] extends largest subsequence tail[length++] = v[i]; else // v[i] will become end candidate of an existing subsequence or // Throw away larger elements in all LIS, to make room for upcoming grater elements than v[i] // (and also, v[i] would have already appeared in one of LIS, identify the location and replace it) tail[CeilIndex(tail, -1, length-1, v[i])] = v[i]; &#125; return length;&#125; int main() &#123; std::vector&lt;int&gt; v&#123; 2, 5, 3, 7, 11, 8, 10, 13, 6 &#125;; std::cout &lt;&lt; &quot;Length of Longest Increasing Subsequence is &quot; &lt;&lt; LongestIncreasingSubsequenceLength(v) &lt;&lt; &apos;\n&apos;; return 0;&#125; java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Java program to find length of longest increasing subsequence// in O(n Log n) timeimport java.io.*;import java.util.*;import java.lang.Math; class LIS&#123; // Binary search (note boundaries in the caller) // A[] is ceilIndex in the caller static int CeilIndex(int A[], int l, int r, int key) &#123; while (r - l &gt; 1) &#123; int m = l + (r - l)/2; if (A[m]&gt;=key) r = m; else l = m; &#125; return r; &#125; static int LongestIncreasingSubsequenceLength(int A[], int size) &#123; // Add boundary case, when array size is one int[] tailTable = new int[size]; int len; // always points empty slot tailTable[0] = A[0]; len = 1; for (int i = 1; i &lt; size; i++) &#123; if (A[i] &lt; tailTable[0]) // new smallest value tailTable[0] = A[i]; else if (A[i] &gt; tailTable[len-1]) // A[i] wants to extend largest subsequence tailTable[len++] = A[i]; else // A[i] wants to be current end candidate of an existing // subsequence. It will replace ceil value in tailTable tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i]; &#125; return len; &#125; // Driver program to test above function public static void main(String[] args) &#123; int A[] = &#123; 2, 5, 3, 7, 11, 8, 10, 13, 6 &#125;; int n = A.length; System.out.println(&quot;Length of Longest Increasing Subsequence is &quot;+ LongestIncreasingSubsequenceLength(A, n)); &#125;&#125;/* This code is contributed by Devesh Agrawal*/ Output: 1Length of Longest Increasing Subsequence is 6 Complexity: The loop runs for N elements. In the worst case (what is worst case input?), we may end up querying ceil value using binary search (log i) for many A[i]. Therefore, T(n) &lt; O( log N! ) = O(N log N). Analyse to ensure that the upper and lower bounds are also O( N log N ). The complexity is THETA (N log N). Exercises: Design an algorithm to construct the longest increasing list. Also, model your solution using DAGs. Design an algorithm to construct all increasing lists of equal longest size. Is the above algorithm an online algorithm? Design an algorithm to construct the longest decreasing list.. — Venki. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above. python https://discuss.leetcode.com/topic/28738/java-python-binary-search-o-nlogn-time-with-explanation 42ms, September 10, 2016 12345678910111213141516171819class Solution(object): def lengthOfLIS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; tails = [0] * len(nums) size = 0 for x in nums: i, j = 0, size while i != j: m = (i + j) / 2 if tails[m] &lt; x: i = m + 1 else: j = m tails[i] = x size = max(i+1, size) return size java https://discuss.leetcode.com/topic/28719/short-java-solution-using-dp-o-n-log-n Short Java solution using DP O(n log n) 123456789101112131415public class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int[] dp = new int[nums.length]; int len = 0; for(int x : nums) &#123; int i = Arrays.binarySearch(dp, 0, len, x); if(i &lt; 0) i = -(i + 1); dp[i] = x; if(i == len) len++; &#125; return len; &#125;&#125; https://discuss.leetcode.com/topic/28738/java-python-binary-search-o-nlogn-time-with-explanation 2ms, September 10, 2016 Java/Python Binary search O(nlogn) time with explanation tails is an array storing the smallest tail of all increasing subsequences with length i+1 in tails[i].For example, say we have nums = [4,5,6,3], then all the available increasing subsequences are: 123len = 1 : [4], [5], [6], [3] =&gt; tails[0] = 3len = 2 : [4, 5], [5, 6] =&gt; tails[1] = 5len = 3 : [4, 5, 6] =&gt; tails[2] = 6 We can easily prove that tails is a increasing array. Therefore it is possible to do a binary search in tails array to find the one needs update. Each time we only do one of the two: 12(1) if x is larger than all tails, append it, increase the size by 1(2) if tails[i-1] &lt; x &lt;= tails[i], update tails[i] Doing so will maintain the tails invariant. The the final answer is just the size. 12345678910111213141516171819public class Solution &#123; public int lengthOfLIS(int[] nums) &#123; int[] tails = new int[nums.length]; int size = 0; for(int x:nums)&#123; int i=0, j = size; while(i != j)&#123; int m = (i+j) /2; if(tails[m] &lt; x) i = m + 1; else j = m; &#125; tails[i] = x; if(i==size) ++size; &#125; return size; &#125;&#125; https://discuss.leetcode.com/topic/30721/my-easy-to-understand-o-n-2-solution-using-dp-with-video-explanation My easy to understand O(n^2) solution using DP with video explanation This solution is taken from this great guy - https://www.youtube.com/watch?v=CE2b_-XfVDk 123456789101112131415161718192021222324252627282930313233343536373839public int lengthOfLIS(int[] nums) &#123; // Base case if(nums.length &lt;= 1) return nums.length; // This will be our array to track longest sequence length int T[] = new int[nums.length]; // Fill each position with value 1 in the array for(int i=0; i &lt; nums.length; i++) T[i] = 1; // Mark one pointer at i. For each i, start from j=0. for(int i=1; i &lt; nums.length; i++) &#123; for(int j=0; j &lt; i; j++) &#123; // It means next number contributes to increasing sequence. if(nums[j] &lt; nums[i]) &#123; // But increase the value only if it results in a larger value of the sequence than T[i] // It is possible that T[i] already has larger value from some previous j&apos;th iteration if(T[j] + 1 &gt; T[i]) &#123; T[i] = T[j] + 1; &#125; &#125; &#125; &#125; // Find the maximum length from the array that we just generated int longest = 0; for(int i=0; i &lt; T.length; i++) longest = Math.max(longest, T[i]); return longest;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[299. Bulls and Cows]]></title>
    <url>%2Fp%2Fee81c67e%2F</url>
    <content type="text"><![CDATA[33.8% https://leetcode.com/problems/bulls-and-cows/#/description You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number. 1234For example:Secret number: &quot;1807&quot;Friend&apos;s guess: &quot;7810&quot; Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.) Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”. Please note that both secret number and friend’s guess may contain duplicate digits, for example: 12Secret number: &quot;1123&quot;Friend&apos;s guess: &quot;0111&quot; In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”. You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal. javahttps://discuss.leetcode.com/topic/28463/one-pass-java-solution The idea is to iterate over the numbers in secret and in guess and count all bulls right away. For cows maintain an array that stores count of the number appearances in secret and in guess. Increment cows when either number from secret was already seen in guest or vice versa. 一个是secret 一个是guess，secret不同于guess时，每一个secret加一，每一个guess减一，secret的某一个值来时，该值个数小于0，则意味着guess的该值多于0个，cows++，另一个同理。 1234567891011121314151617public String getHint(String secret, String guess) &#123; int bulls = 0; int cows = 0; int[] numbers = new int[10]; for (int i = 0; i&lt;secret.length(); i++) &#123; int s = Character.getNumericValue(secret.charAt(i)); int g = Character.getNumericValue(guess.charAt(i)); if (s == g) bulls++; else &#123; if (numbers[s] &lt; 0) cows++; if (numbers[g] &gt; 0) cows++; numbers[s] ++; numbers[g] --; &#125; &#125; return bulls + &quot;A&quot; + cows + &quot;B&quot;;&#125; 4ms, 62.60%, 151 / 151, May.3rd, 2016 https://leetcode.com/discuss/67031/one-pass-java-solution 123456789101112131415public class Solution &#123; public String getHint(String secret, String guess) &#123; int bulls = 0; int cows = 0; int[] numbers = new int[10]; for(int i = 0; i &lt; secret.length(); i++)&#123; if(secret.charAt(i) == guess.charAt(i)) bulls++; else&#123; if(numbers[secret.charAt(i) - &apos;0&apos;]++ &lt; 0) cows++; if(numbers[guess.charAt(i) - &apos;0&apos;]-- &gt; 0) cows++; &#125; &#125; return bulls + &quot;A&quot; + cows + &quot;B&quot;; &#125;&#125; cpp4ms, 54.70%, 151 / 151, May.3rd, 2016 https://leetcode.com/discuss/66999/c-4ms-straight-forward-solution-two-pass-o-n-time 123456789101112131415161718192021class Solution &#123;public: string getHint(string secret, string guess) &#123; if(secret.empty()) return &quot;0A0B&quot;; int aCnt = 0, bCnt = 0; vector&lt;int&gt; sVec(10, 0), gVec(10, 0); for(int i = 0; i &lt; secret.size(); ++i)&#123; char c1 = secret[i]; char c2 = guess[i]; if(c1 == c2) ++aCnt; else&#123; ++sVec[c1 - &apos;0&apos;]; ++gVec[c2 - &apos;0&apos;]; &#125; &#125; for(int i = 0; i &lt; sVec.size(); ++i)&#123; bCnt += min(sVec[i], gVec[i]); &#125; return to_string(aCnt) + &apos;A&apos; + to_string(bCnt) + &apos;B&apos;; &#125;&#125;; my code 123456789101112131415161718192021class Solution &#123;public: string getHint(string secret, string guess) &#123; int len = secret.size(); int m=0, n=0; vector&lt;int&gt; temp_1(10, 0); vector&lt;int&gt; temp_2(10, 0); for(int i=0; i&lt;len; i++)&#123; if(secret[i]==guess[i]) m++; else&#123; temp_1[secret[i]-&apos;0&apos;]++; temp_2[guess[i]-&apos;0&apos;]++; &#125; &#125; for(int i=0; i&lt;10; i++)&#123; n += min(temp_1[i], temp_2[i]); &#125; return to_string(m)+&apos;A&apos;+to_string(n)+&apos;B&apos;; &#125;&#125;; python84ms, 38.96%, May.3rd, 2016https://leetcode.com/discuss/67037/python-3-lines-solution 12345678910class Solution(object): def getHint(self, secret, guess): &quot;&quot;&quot; :type secret: str :type guess: str :rtype: str &quot;&quot;&quot; s, g = collections.Counter(secret), collections.Counter(guess) a = sum(i == j for i, j in zip(secret, guess)) return &apos;%sA%sB&apos; % (a, sum((s &amp; g).values()) - a)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>hash table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[297. Serialize and Deserialize Binary Tree]]></title>
    <url>%2Fp%2Fcf7c0855%2F</url>
    <content type="text"><![CDATA[32.4% Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. 1234567For example, you may serialize the following tree 1 / \ 2 3 / \ 4 5 as “[1,2,3,null,null,4,5]”, just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. 剑指offer 62 题 https://discuss.leetcode.com/topic/28041/recursive-preorder-python-and-c-o-n Recursive preorder, Python and C++, O(n) Python 12345678910111213141516171819202122232425class Codec: def serialize(self, root): def doit(node): if node: vals.append(str(node.val)) doit(node.left) doit(node.right) else: vals.append(&apos;#&apos;) vals = [] doit(root) return &apos; &apos;.join(vals) def deserialize(self, data): def doit(): val = next(vals) if val == &apos;#&apos;: return None node = TreeNode(int(val)) node.left = doit() node.right = doit() return node vals = iter(data.split()) return doit() C++ 12345678910111213141516171819202122232425262728293031323334353637class Codec &#123;public: string serialize(TreeNode* root) &#123; ostringstream out; serialize(root, out); return out.str(); &#125; TreeNode* deserialize(string data) &#123; istringstream in(data); return deserialize(in); &#125;private: void serialize(TreeNode* root, ostringstream&amp; out) &#123; if (root) &#123; out &lt;&lt; root-&gt;val &lt;&lt; &apos; &apos;; serialize(root-&gt;left, out); serialize(root-&gt;right, out); &#125; else &#123; out &lt;&lt; &quot;# &quot;; &#125; &#125; TreeNode* deserialize(istringstream&amp; in) &#123; string val; in &gt;&gt; val; if (val == &quot;#&quot;) return nullptr; TreeNode* root = new TreeNode(stoi(val)); root-&gt;left = deserialize(in); root-&gt;right = deserialize(in); return root; &#125;&#125;; https://discuss.leetcode.com/topic/32470/clean-c-solution Clean C++ solution 12345678910111213141516171819202122232425262728293031class Codec &#123;public: // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; if (root == nullptr) return &quot;#&quot;; return to_string(root-&gt;val)+&quot;,&quot;+serialize(root-&gt;left)+&quot;,&quot;+serialize(root-&gt;right); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; return mydeserialize(data); &#125; TreeNode* mydeserialize(string&amp; data) &#123; if (data[0]==&apos;#&apos;) &#123; if(data.size() &gt; 1) data = data.substr(2); return nullptr; &#125; else &#123; TreeNode* node = new TreeNode(helper(data)); node-&gt;left = mydeserialize(data); node-&gt;right = mydeserialize(data); return node; &#125; &#125;private: int helper(string&amp; data) &#123; int pos = data.find(&apos;,&apos;); int val = stoi(data.substr(0,pos)); data = data.substr(pos+1); return val; &#125;&#125;; https://discuss.leetcode.com/topic/28011/c-accepted-o-n-easy-solution C++ Accepted O(n) Easy Solution Idea: Level-order traversal. Use ‘#’ to denote a nullptr. User ‘,’ to separate entries. The output is very similar to Leetcode’s default deserialization logic. Time Complexities: O(n) to serialize and O(n) to deserialize Space Complexities: O(n) to serialize and O(n) to deserialize 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Codec &#123;public: // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; queue&lt;TreeNode*&gt; q; q.push(root); string str; while (!q.empty()) &#123; if (q.front() == nullptr) &#123; str = str + &quot;#,&quot;; &#125; else &#123; q.push(q.front()-&gt;left); q.push(q.front()-&gt;right); str = str + to_string(q.front()-&gt;val) + &quot;,&quot;; &#125; q.pop(); &#125; return str; &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; TreeNode* root = nullptr; queue&lt;TreeNode**&gt; q; q.push(&amp;root); string::iterator first = data.begin(); while (first != data.end()) &#123; TreeNode** pp = q.front(); if (*first == &apos;#&apos;) &#123; // *pp = nullptr; advance(first, 2); &#125; else &#123; string::iterator last = find(first, data.end(), &apos;,&apos;); int val = stoi(string(first, last)); *pp = new TreeNode(val); q.push(&amp;((*pp)-&gt;left)); q.push(&amp;((*pp)-&gt;right)); first = next(last); &#125; q.pop(); &#125; return root; &#125;&#125;;// Your Codec object will be instantiated and called as such:// Codec codec;// codec.deserialize(codec.serialize(root)); https://discuss.leetcode.com/topic/28092/python-preorder-recursive-traversal Python preorder recursive traversal 123456789101112131415161718192021222324252627282930def serialize(self, root): preorder = &apos;&apos; if not root: preorder += &apos;,None&apos; return preorder preorder += &apos;,&apos;+str(root.val) preorder += self.serialize(root.left) preorder += self.serialize(root.right) return preorderdef deserialize(self, encode_data): pos = -1 data = encode_data[1:].split(&apos;,&apos;) for i in xrange(len(data)): if data[i] == &apos;None&apos;: data[i] = None else: data[i] = int(data[i]) root, count = self.buildTree(data, pos) return root def buildTree(self, data, pos): pos += 1 if pos &gt;= len(data) or data[pos]==None: return None, pos root = TreeNode(data[pos]) root.left, pos = self.buildTree(data, pos) root.right, pos = self.buildTree(data, pos) return root, pos 24ms, 70.13%, October 18, 2016 https://discuss.leetcode.com/topic/28029/easy-to-understand-java-solution 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Codec &#123; private static final String spliter = &quot;,&quot;; private static final String NN = &quot;X&quot;; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); buildString(root, sb); return sb.toString(); &#125; private void buildString(TreeNode node, StringBuilder sb)&#123; if(node == null) sb.append(NN).append(spliter); else&#123; sb.append(node.val).append(spliter); buildString(node.left, sb); buildString(node.right, sb); &#125; &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; Deque&lt;String&gt; nodes = new LinkedList&lt;&gt;(); nodes.addAll(Arrays.asList(data.split(spliter))); return buildTree(nodes); &#125; private TreeNode buildTree(Deque&lt;String&gt; nodes)&#123; String val = nodes.remove(); if(val.equals(NN)) return null; else&#123; TreeNode node = new TreeNode(Integer.valueOf(val)); node.left = buildTree(nodes); node.right = buildTree(nodes); return node; &#125; &#125;&#125;// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.deserialize(codec.serialize(root)); python239ms, 43.88%, October 18, 2016 https://discuss.leetcode.com/topic/28041/recursive-preorder-python-and-c-o-n 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Codec: def serialize(self, root): &quot;&quot;&quot;Encodes a tree to a single string. :type root: TreeNode :rtype: str &quot;&quot;&quot; def doit(node): if node: vals.append(str(node.val)) doit(node.left) doit(node.right) else: vals.append(&apos;#&apos;) vals = [] doit(root) return &apos; &apos;.join(vals) def deserialize(self, data): &quot;&quot;&quot;Decodes your encoded data to tree. :type data: str :rtype: TreeNode &quot;&quot;&quot; def doit(): val = next(vals) if val == &apos;#&apos;: return None node = TreeNode(int(val)) node.left = doit() node.right = doit() return node vals = iter(data.split()) return doit()# Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>tree</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[295. Find Median from Data Stream]]></title>
    <url>%2Fp%2F4e6b5bd8%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/find-median-from-data-stream/#/description Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. 1234Examples: [2,3,4] , the median is 3[2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far. 1234567For example:addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3) findMedian() -&gt; 2 https://discuss.leetcode.com/topic/27521/short-simple-java-c-python-o-log-n-o-1 Short simple Java/C++/Python, O(log n) + O(1) I keep two heaps (or priority queues): Max-heap small has the smaller half of the numbers. Min-heap large has the larger half of the numbers. This gives me direct access to the one or two middle values (they’re the tops of the heaps), so getting the median takes O(1) time. And adding a number takes O(log n) time. Supporting both min- and max-heap is more or less cumbersome, depending on the language, so I simply negate the numbers in the heap in which I want the reverse of the default order. To prevent this from causing a bug with -231 (which negated is itself, when using 32-bit ints), I use integer types larger than 32 bits. Using larger integer types also prevents an overflow error when taking the mean of the two middle numbers. I think almost all solutions posted previously have that bug. Update: These are pretty short already, but by now I wrote even shorter ones. Java 123456789101112131415161718class MedianFinder &#123; private Queue&lt;Long&gt; small = new PriorityQueue(), large = new PriorityQueue(); public void addNum(int num) &#123; large.add((long) num); small.add(-large.poll()); if (large.size() &lt; small.size()) large.add(-small.poll()); &#125; public double findMedian() &#123; return large.size() &gt; small.size() ? large.peek() : (large.peek() - small.peek()) / 2.0; &#125;&#125;; Props to larrywang2014’s solution for making me aware that I can use Queue in the declaration instead of PriorityQueue (that’s all I got from him, though (just saying because I just saw he changed his previously longer addNum and it’s now equivalent to mine)). C++ 1234567891011121314151617181920class MedianFinder &#123; priority_queue&lt;long&gt; small, large;public: void addNum(int num) &#123; small.push(num); large.push(-small.top()); small.pop(); if (small.size() &lt; large.size()) &#123; small.push(-large.top()); large.pop(); &#125; &#125; double findMedian() &#123; return small.size() &gt; large.size() ? small.top() : (small.top() - large.top()) / 2.0; &#125;&#125;; Big thanks to jianchao.li.fighter for telling me that C++’s priority_queue is a max-queue (see comments below). Python 123456789101112131415161718from heapq import *class MedianFinder: def __init__(self): self.heaps = [], [] def addNum(self, num): small, large = self.heaps heappush(small, -heappushpop(large, num)) if len(large) &lt; len(small): heappush(large, -heappop(small)) def findMedian(self): small, large = self.heaps if len(large) &gt; len(small): return float(large[0]) return (large[0] - small[0]) / 2.0 https://discuss.leetcode.com/topic/27522/java-python-two-heap-solution-o-log-n-add-o-1-find Java/Python two heap solution, O(log n) add, O(1) find The invariant of the algorithm is two heaps, small and large, each represent half of the current list. The length of smaller half is kept to be n / 2 at all time and the length of the larger half is either n / 2 or n / 2 + 1 depend on n’s parity. This way we only need to peek the two heaps’ top number to calculate median. Any time before we add a new number, there are two scenarios, (total n numbers, k = n / 2): 12(1) length of (small, large) == (k, k)(2) length of (small, large) == (k, k + 1) After adding the number, total (n + 1) numbers, they will become: 12(1) length of (small, large) == (k, k + 1)(2) length of (small, large) == (k + 1, k + 1) Here we take the first scenario for example, we know the large will gain one more item and small will remain the same size, but we cannot just push the item into large. What we should do is we push the new number into small and pop the maximum item from small then push it into large (all the pop and push here are heappop and heappush). By doing this kind of operations for the two scenarios we can keep our invariant. Therefore to add a number, we have 3 O(log n) heap operations. Luckily the heapq provided us a function “heappushpop” which saves some time by combine two into one. The document says: Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate call to heappop(). Alltogether, the add operation is O(logn), The findMedian operation is O(1). Note that the heapq in python is a min heap, thus we need to invert the values in the smaller half to mimic a “max heap”. A further observation is that the two scenarios take turns when adding numbers, thus it is possible to combine the two into one. For this please see stefan’s post Java 123456789101112131415161718192021private PriorityQueue&lt;Integer&gt; small = new PriorityQueue&lt;&gt;(Collections.reverseOrder());private PriorityQueue&lt;Integer&gt; large = new PriorityQueue&lt;&gt;();private boolean even = true;public double findMedian() &#123; if (even) return (small.peek() + large.peek()) / 2.0; else return small.peek();&#125;public void addNum(int num) &#123; if (even) &#123; large.offer(num); small.offer(large.poll()); &#125; else &#123; small.offer(num); large.offer(small.poll()); &#125; even = !even;&#125; Python 1234567891011121314151617181920212223from heapq import *class MedianFinder: def __init__(self): self.small = [] # the smaller half of the list, max heap (invert min-heap) self.large = [] # the larger half of the list, min heap def addNum(self, num): if len(self.small) == len(self.large): heappush(self.large, -heappushpop(self.small, -num)) else: heappush(self.small, -heappushpop(self.large, num)) def findMedian(self): if len(self.small) == len(self.large): return float(self.large[0] - self.small[0]) / 2.0 else: return float(self.large[0])# 18 / 18 test cases passed.# Status: Accepted# Runtime: 388 ms https://discuss.leetcode.com/topic/27541/very-short-o-log-n-o-1 Very Short, O(log n) + O(1) Same idea as before, but really exploiting the symmetry of the two heaps by switching them whenever a number is added. Still O(log n) for adding and O(1) for median. Partially inspired by peisi’s updated solution. Update: Added a new Java version (the first one). Java 1234567891011121314class MedianFinder &#123; Queue&lt;Integer&gt; q = new PriorityQueue(), z = q, t, Q = new PriorityQueue(Collections.reverseOrder()); public void addNum(int num) &#123; (t=Q).add(num); (Q=q).add((q=t).poll()); &#125; public double findMedian() &#123; return (Q.peek() + z.peek()) / 2.; &#125;&#125;; Or: 1234567891011121314class MedianFinder &#123; Queue[] q = &#123;new PriorityQueue(), new PriorityQueue(Collections.reverseOrder())&#125;; int i = 0; public void addNum(int num) &#123; q[i].add(num); q[i^=1].add(q[i^1].poll()); &#125; public double findMedian() &#123; return ((int)(q[1].peek()) + (int)(q[i].peek())) / 2.0; &#125;&#125;; Python 1234567891011121314from heapq import *class MedianFinder: def __init__(self): self.heaps = None, [], [] self.i = 1 def addNum(self, num): heappush(self.heaps[-self.i], -heappushpop(self.heaps[self.i], num * self.i)) self.i *= -1 def findMedian(self): return (self.heaps[self.i][0] * self.i - self.heaps[-1][0]) / 2.0 Or: 123456789101112131415from heapq import *class MedianFinder: def __init__(self): self.data = 1, [], [] def addNum(self, num): sign, h1, h2 = self.data heappush(h2, -heappushpop(h1, num * sign)) self.data = -sign, h2, h1 def findMedian(self): sign, h1, h2 = d = self.data return (h1[0] * sign - d[-sign][0]) / 2.0 https://discuss.leetcode.com/topic/27613/my-c-priority_queue-based-solution-140-ms My C++ priority_queue based solution (140 ms) The idea is to use two heaps (one max heap, one mn heap) to save the input data. firstQ is a max_heap to save the first half of the data with smaller values, and secQ is a min_heap to save the second half of the data with bigger values. Everytime when inserting a new value, we first compare if it is smaller than the top of firstQ (the largest value of the first half), if so, insert into firstQ. Otherwise, it belongs to the second half. After inserting, we have to balance the first half and the second half to make sure either they have the same length or the length difference is only 1.The median will be the mean of two top elements (when they have the same length) or the top element of the queue with a larger length. 1234567891011121314151617181920212223242526272829class MedianFinder &#123;private: priority_queue&lt;int&gt; firstQ; // max_heap for the first half priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; secQ; // min_heap for the second halfpublic: // Adds a number into the data structure. void addNum(int num) &#123; if(firstQ.empty() || (firstQ.top()&gt;num)) firstQ.push(num); // if it belongs to the smaller half else secQ.push(num); // rebalance the two halfs to make sure the length difference is no larger than 1 if(firstQ.size() &gt; (secQ.size()+1)) &#123; secQ.push(firstQ.top()); firstQ.pop(); &#125; else if(firstQ.size()+1&lt;secQ.size()) &#123; firstQ.push(secQ.top()); secQ.pop(); &#125; &#125; // Returns the median of current data stream double findMedian() &#123; if(firstQ.size() == secQ.size()) return firstQ.empty()?0:( (firstQ.top()+secQ.top())/2.0); else return (firstQ.size() &gt; secQ.size())? firstQ.top():secQ.top(); &#125;&#125;; https://discuss.leetcode.com/topic/27598/solution-using-binary-search-tree Solution using Binary Search Tree As the input numbers are random, so the height of the binary search tree is O(logN) We maintain every single node’s children’s size and it’s easy to implement because it just has add operation. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465struct BST &#123; struct node &#123; int val; int size; node* left, *right; node(int v) : size(1), val(v) &#123;&#125;; &#125; *Null, *root; BST() &#123; Null = new node(0); Null -&gt; size = 0; root = Null; &#125; void add(int val, node*&amp; R) &#123; if(R == Null) &#123; R = new node(val); R -&gt; left = R -&gt; right = Null; return; &#125; if(R-&gt;val &lt;= val) add(val, R-&gt;left); else add(val, R-&gt;right); R-&gt;size = R-&gt;left-&gt;size + R-&gt;right-&gt;size + 1; &#125; int rank(int k) &#123; node* t = root; while(true) &#123; int leftSize = t -&gt; left -&gt; size; if(leftSize == k) return t -&gt; val; if(leftSize &gt; k) &#123; t = t -&gt; left; &#125; else &#123; k = k - leftSize - 1; t = t -&gt; right; &#125; &#125; return -1; &#125;&#125;;class MedianFinder &#123;public: BST* bst; MedianFinder() &#123; bst = new BST(); &#125; // Adds a number into the data structure. void addNum(int num) &#123; bst-&gt;add(num, bst-&gt;root); &#125; // Returns the median of current data stream double findMedian() &#123; int sz = bst -&gt; root -&gt; size; if(sz % 2 == 0) &#123; return 1.0 * (bst -&gt; rank(sz / 2) + bst -&gt; rank(sz / 2 - 1)) / 2; &#125; else return bst-&gt;rank(sz / 2); &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>heap</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[292. Nim Game]]></title>
    <url>%2Fp%2Fb77dfaa9%2F</url>
    <content type="text"><![CDATA[54.9% https://leetcode.com/problems/nim-game/#/description You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. Hint: If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner? https://discuss.leetcode.com/topic/26999/theorem-all-4s-shall-be-false Theorem: all 4s shall be false Theorem: The first one who got the number that is multiple of 4 (i.e. n % 4 == 0) will lost, otherwise he/she will win. Proof: the base case: when n = 4, as suggested by the hint from the problem, no matter which number that that first player, the second player would always be able to pick the remaining number. For 1 4 &lt; n &lt; 2 4, (n = 5, 6, 7), the first player can reduce the initial number into 4 accordingly, which will leave the death number 4 to the second player. i.e. The numbers 5, 6, 7 are winning numbers for any player who got it first. Now to the beginning of the next cycle, n = 8, no matter which number that the first player picks, it would always leave the winning numbers (5, 6, 7) to the second player. Therefore, 8 % 4 == 0, again is a death number. Following the second case, for numbers between (24 = 8) and (34=12), which are 9, 10, 11, are winning numbers for the first player again, because the first player can always reduce the number into the death number 8. Following the above theorem and proof, the solution could not be simpler: 123public boolean canWinNim(int n) &#123; return n % 4 != 0 ;&#125; https://discuss.leetcode.com/topic/27109/one-line-o-1-solution-and-explanation One line O(1) solution and explanation suppose there are x stones left for first player (A), he can take 1,2,3 stones away, so second player B will have three cases to deal with (x -1), (x-2), (x-3). after he pick the stones, there will be 9 cases left for A. 123B (x-1) -&gt; A: (x-2), (x-3), (x-4)B (x-2) -&gt; A: (x-3), (x-4), (x-5)B (x-3) -&gt; A: (x-4), (x-5), (x-6) Now, if A can guarantee he win at either of three groups, then he can force B to into that one of the three states and A can end up in that particular group after B’s move. 1f(x) = (f(x-2)&amp;&amp;f(x-3)&amp;&amp;f(x-4)) || (f(x-3)&amp;&amp;f(x-4)&amp;&amp;f(x-5)) || (f(x-4)&amp;&amp;f(x-5)&amp;&amp;f(x-6)) if we examine the equation a little closer, we can find f(x - 4) is a critical point, if f(x-4) is false, then f(x) will be always false. we can also find out the initial conditions, f(1), f(2), f(3) will be true (A always win), and f(4) will be false. so based on previous equation and initial conditions f(5) = f(6) = f(7) = true, f(8) = false; obviously, f(1), f(2), f(3) can make all f(4n + 1), f(4n + 2), f(4n + 3) to be true, only f(4n) will be false then. so here we go our one line solution: 1return (n % 4 != 0); https://discuss.leetcode.com/topic/28437/1-liner-with-explanations 1 liner with explanations 1234567891011121314class Solution(object): def canWinNim(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; # strategy: the one with 4 remaining must loose # A, B players # if n == 4k, then at each round B can make A+B both take 4, # eventually leave 4 to A, A lose # if n == 4k + i (i &lt;= 3), then A can always take i first and B will # finanly lose as he faces above scenario like A return bool(n%4!=0) https://discuss.leetcode.com/topic/27696/1-line-0-ms-c-solution-with-explanation 1 line 0 ms C++ solution with explanation Explanation: At first this problem might seems a bit tough but it is easy and has a pattern which is as follow. I have applied the bottom up dynamic programming approach to fill the array and noticed that only number divisible by 4 are the positions where player1(playing first chance) is losing. 123456class Solution &#123;public: bool canWinNim(int n) &#123; return n%4 ; &#125;&#125;; Base case : If the numbers of stones are 1,2 or 3, then player 1 will win. If the numbers of stones are 4, then player 1 will lose irrespective of the number of stones he/she remove So lookup table will look like this : W[1]-&gt;W[2]-&gt;W[3]-&gt;L[4]. For num_stones=5, the player can either remove 1,2 or 3 stones i.e. the other player (player 2) will win if the number of stones left are 1,2 or 3 and will lose only when the number of stones left are 4 ( see the lookup table in step 1) . So, if Player1 remove 1 stone, the number of stones left will be 4, which will defeat player2. So, now the lookup entry for num_stones=5 will be W. Lookup now will look like this : W-&gt;W-&gt;W-&gt;L-&gt;W (for player 1-&gt; who is taking the first chance). Likewise, we can fill the complete lookup table by looking at the values at last three index. If anyone of them is L =&gt; Player 1 will win the game as he will remove only that many number of stones which will bring player 2 to the L position In the end, you will notice that only positions 4-&gt;8-&gt;12-&gt;16 will contain L for player 1 thus answer is simple n%4. https://discuss.leetcode.com/topic/30789/if-i-m-a-interviewer-i-prefer-the-candidates-using-burte-force-instead-of-math-method If I’m a interviewer, I prefer the candidates using burte force instead of math method. Because it is a “coding interview”, not acm/icpc or other competitions. Similar to Josephus Cycle, I prefer LinkedList Cycle than Mod-Method during interviews. Here’s a backtraking-dp solution. 12345678910111213141516171819202122232425262728public class Solution &#123; public boolean canWinNim(int n) &#123; if(n&gt;=134882061)&#123;//I have no any other ways,please forgive my unchastity(无节操)! return n%4 != 0; &#125; int[] array=new int[n+1]; return dfs(n, array); &#125; public boolean dfs(int n,int[] array)&#123; if(array[n]!=0)&#123; return array[n]==1?true:false; &#125; if(n&lt;=3)&#123; array[n]=1; return true; &#125;else&#123; for(int i=1;i&lt;=3;i++)&#123; if(!dfs(n-i,array))&#123; array[n-i]=-1; array[n]=1; return true; &#125; &#125; array[n]=-1; return false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>brainteaser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[290. Word Pattern]]></title>
    <url>%2Fp%2F1836af6%2F</url>
    <content type="text"><![CDATA[32.5% https://leetcode.com/problems/word-pattern/#/description Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Examples: pattern = “abba”, str = “dog cat cat dog” should return true. pattern = “abba”, str = “dog cat cat fish” should return false. pattern = “aaaa”, str = “dog cat cat dog” should return false. pattern = “abba”, str = “dog dog dog dog” should return false. Notes: You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. https://discuss.leetcode.com/topic/26376/short-c-read-words-on-the-fly Short C++, read words on the fly I think all previous C++ solutions read all words into a vector at the start. Here I read them on the fly. 123456789101112bool wordPattern(string pattern, string str) &#123; map&lt;char, int&gt; p2i; map&lt;string, int&gt; w2i; istringstream in(str); int i = 0, n = pattern.size(); for (string word; in &gt;&gt; word; ++i) &#123; if (i == n || p2i[pattern[i]] != w2i[word]) return false; p2i[pattern[i]] = w2i[word] = i + 1; &#125; return i == n;&#125; https://discuss.leetcode.com/topic/26316/short-in-python Short in Python This problem is pretty much equivalent to Isomorphic Strings. Let me reuse two old solutions. From here: 1234def wordPattern(self, pattern, str): s = pattern t = str.split() return map(s.find, s) == map(t.index, t) Improved version also from there: 123def wordPattern(self, pattern, str): f = lambda s: map(&#123;&#125;.setdefault, s, range(len(s))) return f(pattern) == f(str.split()) From here: 1234def wordPattern(self, pattern, str): s = pattern t = str.split() return len(set(zip(s, t))) == len(set(s)) == len(set(t)) and len(s) == len(t) Thanks to zhang38 for pointing out the need to check len(s) == len(t) here. https://discuss.leetcode.com/topic/26313/0ms-c-solution-using-istringstream-and-double-maps 0ms C++ solution using istringstream and double maps 123456789101112131415161718bool wordPattern(string pattern, string str) &#123; istringstream strcin(str); string s; vector&lt;string&gt; vs; while(strcin &gt;&gt; s) vs.push_back(s); if (pattern.size() != vs.size()) return false; map&lt;string, char&gt; s2c; map&lt;char, string&gt; c2s; for (int i = 0; i &lt; vs.size(); ++i) &#123; if (s2c[vs[i]] == 0 &amp;&amp; c2s[pattern[i]] == &quot;&quot;) &#123; s2c[vs[i]] = pattern[i]; c2s[pattern[i]] = vs[i]; continue; &#125; if (s2c[vs[i]] != pattern[i]) return false; &#125; return true;&#125; https://discuss.leetcode.com/topic/36612/my-solution-in-python My solution in python 1234567891011class Solution(object): def wordPattern(self, pattern, str): &quot;&quot;&quot; :type pattern: str :type str: str :rtype: bool &quot;&quot;&quot; x = str.split(&apos; &apos;) lsp = len(set(pattern)) lsx = len(set(x)) return len(x)==len(pattern) and lsx==lsp and lsp== len(set(zip(pattern, x))) please point out if there’s anything i should improve 2ms, 51.78%, October 18, 2016 https://discuss.leetcode.com/topic/26339/8-lines-simple-java 123456789101112public class Solution &#123; public boolean wordPattern(String pattern, String str) &#123; String[] words = str.split(&quot; &quot;); if(words.length!=pattern.length()) return false; Map index = new HashMap(); for(Integer i=0; i&lt;words.length; ++i) if(index.put(pattern.charAt(i), i) != index.put(words[i], i)) return false; return true; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[289. Game of Life]]></title>
    <url>%2Fp%2F4d6d4f2b%2F</url>
    <content type="text"><![CDATA[36.5% https://leetcode.com/problems/game-of-life/#/description According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.” Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Write a function to compute the next state (after one update) of the board given its current state. Follow up: Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems? https://discuss.leetcode.com/topic/26112/c-o-1-space-o-mn-time C++ O(1) space, O(mn) time Since the board has ints but only the 1-bit is used, I use the 2-bit to store the new state. At the end, replace the old state with the new state by shifting all values one bit to the right. 12345678910111213141516void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; int m = board.size(), n = m ? board[0].size() : 0; for (int i=0; i&lt;m; ++i) &#123; for (int j=0; j&lt;n; ++j) &#123; int count = 0; for (int I=max(i-1, 0); I&lt;min(i+2, m); ++I) for (int J=max(j-1, 0); J&lt;min(j+2, n); ++J) count += board[I][J] &amp; 1; if (count == 3 || count - board[i][j] == 3) board[i][j] |= 2; &#125; &#125; for (int i=0; i&lt;m; ++i) for (int j=0; j&lt;n; ++j) board[i][j] &gt;&gt;= 1;&#125; Note that the above count counts the live ones among a cell’s neighbors and the cell itself. Starting with int count = -board[i][j] counts only the live neighbors and allows the neat 1if ((count | board[i][j]) == 3) test. Thanks to aileenbai for showing that one in the comments. https://discuss.leetcode.com/topic/26176/c-ac-code-o-1-space-o-mn-time C++ AC Code O(1) space, O(mn) time 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Game of Life/*状态: 前一位表示下一代的状态,后一位表示当前的状态00: 死-&gt;死10: 死-&gt;活01: 活-&gt;死11: 活-&gt;活*/class Solution &#123;public: void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; int d[][2] = &#123;&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;&#125;; for(int i = 0; i &lt; board.size(); i++)&#123; for(int j = 0; j &lt; board[0].size(); j++)&#123; int live = 0; for(int k = 0; k &lt; 8; k++)&#123; int x = d[k][0] + i; int y = d[k][1] + j; if(x &lt; 0 || x &gt;= board.size() || y &lt; 0 || y &gt;= board[0].size()) &#123; continue; &#125; if(board[x][y] &amp; 1) &#123; live++; &#125; &#125; // 死的 if(board[i][j] == 0) &#123; if(live == 3)&#123; board[i][j] = 2; // 2 : (10) &#125; &#125; // 活的 else &#123; if(live &lt; 2 || live &gt; 3)&#123; board[i][j] = 1; // 1 : (01) &#125;else&#123; board[i][j] = 3; // 3 : (11) &#125; &#125; &#125; &#125; for(int i = 0; i &lt; board.size(); i++)&#123; for(int j=0; j &lt; board[0].size(); j++)&#123; board[i][j] &gt;&gt;=1; &#125; &#125; &#125;&#125;;enter code here https://discuss.leetcode.com/topic/26236/infinite-board-solution Infinite board solution For the second follow-up question, here’s a solution for an infinite board. Instead of a two-dimensional array of ones and zeros, I represent the board as a set of live cell coordinates. 123456789def gameOfLifeInfinite(self, live): ctr = collections.Counter((I, J) for i, j in live for I in range(i-1, i+2) for J in range(j-1, j+2) if I != i or J != j) return &#123;ij for ij in ctr if ctr[ij] == 3 or ctr[ij] == 2 and ij in live&#125; And here’s a wrapper that uses the above infinite board solution to solve the problem we have here at the OJ (submitted together, this gets accepted): 123456def gameOfLife(self, board): live = &#123;(i, j) for i, row in enumerate(board) for j, live in enumerate(row) if live&#125; live = self.gameOfLifeInfinite(live) for i, row in enumerate(board): for j in range(len(row)): row[j] = int((i, j) in live) https://discuss.leetcode.com/topic/27167/c-o-mn-time-o-1-space-sol C++ O(mn)-time, O(1)-space sol First this solution does not involve bit-manipulation and only involves addition of integers. The idea is to go through the matrix from top-left corner to the bottom-right corner, and check only 4 cells (“accumulate” scores “for both cells” if the other cell is originally a 1). Graphically speaking, it is like this: 123O O O O @ XX X X where the @ cell is the one that you are working on, 0 cells are those you have gone through (don’t work on them again!), and the X cells are those you have not gone through and should work on. For example, if one X cell is originally a 1, you should add C (a constant) to @ cell, and simultaneously if @ cell is originally a 1, you add C to that X cell. The constant C can be 2. If it is 2 then when you will find that after done working on the current cell if it’s value is 5 or 7 (cell @ is originally a 1 and have 2 or 3 neighbours) or 6 (cell @ is originally a 0 and have 3 neighbours), then you should reset it to be 1 (live), otherwise reset it to be zero (dead). And when accumulating scores, you know a cell is originally a 1 if it has odd-numbered score, and it is originally a 0 if it has even-numbered score. The code is 1234567891011121314151617181920212223242526class Solution &#123;public: void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; if(board.empty()) return; const int m = board.size(); const int n = board[0].size(); for(int i=0; i&lt;m; i++) &#123; for(int j=0; j&lt;n; j++) &#123; check(board,i,j,i+1,j-1); check(board,i,j,i+1,j); check(board,i,j,i+1,j+1); check(board,i,j,i,j+1); if(board[i][j]&gt;=5 &amp;&amp; board[i][j]&lt;=7) board[i][j]=1; else board[i][j]=0; &#125; &#125; &#125;private: void check(vector&lt;vector&lt;int&gt;&gt;&amp; board, int i, int j, int a, int b) &#123; const int m = board.size(); const int n = board[0].size(); if(a&gt;=m || b&lt;0 || b&gt;=n) return; if(board[i][j]%2!=0) board[a][b]+=2; if(board[a][b]%2!=0) board[i][j]+=2; &#125; &#125;; https://discuss.leetcode.com/topic/27098/python-solution-easy-to-understand Python solution, easy to understand.. 1234567891011121314151617181920212223242526272829300,2 are &quot;dead&quot;, and &quot;dead-&gt;live&quot;1,3 are &quot;live&quot;, and &quot;live-&gt;dead&quot;def gameOfLife(self, board): m,n = len(board), len(board[0]) for i in range(m): for j in range(n): if board[i][j] == 0 or board[i][j] == 2: if self.nnb(board,i,j) == 3: board[i][j] = 2 else: if self.nnb(board,i,j) &lt; 2 or self.nnb(board,i,j) &gt;3: board[i][j] = 3 for i in range(m): for j in range(n): if board[i][j] == 2: board[i][j] = 1 if board[i][j] == 3: board[i][j] = 0 def nnb(self, board, i, j): m,n = len(board), len(board[0]) count = 0 if i-1 &gt;= 0 and j-1 &gt;= 0: count += board[i-1][j-1]%2 if i-1 &gt;= 0: count += board[i-1][j]%2 if i-1 &gt;= 0 and j+1 &lt; n: count += board[i-1][j+1]%2 if j-1 &gt;= 0: count += board[i][j-1]%2 if j+1 &lt; n: count += board[i][j+1]%2 if i+1 &lt; m and j-1 &gt;= 0: count += board[i+1][j-1]%2 if i+1 &lt; m: count += board[i+1][j]%2 if i+1 &lt; m and j+1 &lt; n: count += board[i+1][j+1]%2 return count https://discuss.leetcode.com/topic/26117/ac-python-40-ms-solution-o-mn-time-o-1-extra-space AC Python 40 ms solution O(mn) time O(1) extra space 123456789101112131415161718192021222324def update(self, board, m, n, i, j): live = 0 for p in xrange(max(i - 1, 0), min(i + 2, m)): for q in xrange(max(j - 1, 0), min(j + 2, n)): live += board[p][q] &amp; 1 if live == 3 or live == board[i][j] + 3: board[i][j] += 2def gameOfLife(self, board): if not board or not board[0]: return m = len(board) n = len(board[0]) for i in xrange(m): for j in xrange(n): self.update(board, m, n, i, j) for i in xrange(m): for j in xrange(n): board[i][j] &gt;&gt;= 1# 22 / 22 test cases passed.# Status: Accepted# Runtime: 40 ms Everyone knows how to update this board if another m * n array is allowed. The O(1) space solution is just using the wasted bits in the original array. Instead of only 0 and 1 we now need the second bit for the updated value. The living condition is just by definition. Of course, writing everything together will save several lines of code. However, implement things like this, readability and expandability counts. As of the follow up question.For example your 3 * 3 initial board is the following: 1231 1 11 0 11 1 1 In the case of only 3 * 3 the next generation is: 1231 0 1 0 0 0 1 0 1 However in the case of a infinite board the next generation is: 123450 0 1 0 0 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 0 0 1 0 0 Question is how to you implement this expandable board. One solution of the infinity situation is using a upper level grid, a grid of grids, instead of only one grid of cells. Note that we can be lazy. We only initialize (allocate the memory for real) a certain grid if any cell in it is activated. The rest of the unused grid can be pointer only. 1ms, 11.45%, October 18, 2016 https://discuss.leetcode.com/topic/29054/easiest-java-solution-with-explanation 12345678910111213141516171819202122232425262728public class Solution &#123; public void gameOfLife(int[][] board) &#123; if(board == null || board.length == 0) return; int m = board.length, n = board[0].length; for(int i=0; i&lt;m; i++) for(int j=0; j&lt;n; j++)&#123; int lives = liveNeighbors(board, m, n, i, j); if(board[i][j] == 1 &amp;&amp; lives&gt;=2 &amp;&amp; lives &lt;= 3) board[i][j] = 3; if(board[i][j] == 0 &amp;&amp; lives == 3) board[i][j] = 2; &#125; for(int i=0; i&lt;m; i++) for(int j=0; j&lt;n; j++) board[i][j] &gt;&gt;= 1; &#125; public int liveNeighbors(int[][] board, int m, int n, int i, int j)&#123; int lives = 0; for(int x=Math.max(i-1, 0); x&lt;=Math.min(i+1, m-1); x++) for(int y=Math.max(j-1, 0); y&lt;=Math.min(j+1, n-1); y++) lives += board[x][y] &amp; 1; lives -= board[i][j] &amp; 1; return lives; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[284. Peeking Iterator]]></title>
    <url>%2Fp%2F8f8ef073%2F</url>
    <content type="text"><![CDATA[35.2% https://leetcode.com/problems/peeking-iterator/#/description Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation – it essentially peek() at the element that will be returned by the next call to next(). Here is an example. Assume that the iterator is initialized to the beginning of the list: [1, 2, 3]. Call next() gets you 1, the first element in the list. Now you call peek() and it returns 2, the next element. Calling next() after that still return 2. You call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false. Hint: Think of “looking ahead”. You want to cache the next element. Is one variable sufficient? Why or why not? Test your design with call order of peek() before next() vs next() before peek(). For a clean implementation, check out Google’s guava library source code. Follow up: How would you extend your design to be generic and work with all types, not just integer? 3ms, 3.96%, October 15, 2016 https://discuss.leetcode.com/topic/24909/simple-c-solution-1-line-per-method-without-extra-member-variables Simple C++ solution (1 line per method) without extra member variables Since Iterator has a copy constructor, we can just use it: 12345678910111213141516171819202122class PeekingIterator : public Iterator&#123;public: PeekingIterator(const vector&lt;int&gt; &amp;nums) : Iterator(nums) &#123; &#125; int peek() &#123; return Iterator(*this).next(); &#125; int next() &#123; return Iterator::next(); &#125; bool hasNext() const &#123; return Iterator::hasNext(); &#125;&#125;; https://discuss.leetcode.com/topic/25875/another-c-solution-with-one-line-in-peek-and-hasnext-ac Another C++ solution with one line in peek() and hasNext(), AC 12345678910111213141516171819202122232425class PeekingIterator : public Iterator &#123;private: int m_next; bool m_hasnext;public: PeekingIterator(const vector&lt;int&gt;&amp; nums) : Iterator(nums) &#123; m_hasnext = Iterator::hasNext(); if (m_hasnext) m_next = Iterator::next(); &#125; int peek() &#123; return m_next; &#125; int next() &#123; int t = m_next; m_hasnext = Iterator::hasNext(); if (m_hasnext) m_next = Iterator::next(); return t; &#125; bool hasNext() const &#123; return m_hasnext; &#125;&#125;; https://discuss.leetcode.com/topic/26190/my-4ms-c-supper-easy-solution My 4ms c++ supper easy solution 123456789101112131415161718192021222324252627class PeekingIterator : public Iterator &#123; public: PeekingIterator(const vector&lt;int&gt;&amp; nums) : Iterator(nums) &#123; // Initialize any member here. // **DO NOT** save a copy of nums and manipulate it directly. // You should only use the Iterator interface methods.&#125;// Returns the next element in the iteration without advancing the iterator.int peek() &#123; if(hasNext())&#123; Iterator it(*this); return it.next(); &#125;&#125;// hasNext() and next() should behave the same as in the Iterator interface.// Override them if needed.int next() &#123; Iterator::next();&#125;bool hasNext() const &#123; Iterator::hasNext();&#125;&#125;; https://discuss.leetcode.com/topic/24857/10-line-c-and-14-line-java-implementation 10-line C++ and 14-line Java Implementation 123456789101112131415161718192021222324class PeekingIterator : public Iterator &#123; bool hasPeeked; int peekedElem;public: PeekingIterator(const vector&lt;int&gt;&amp; num) : Iterator(num) &#123; hasPeeked = false; &#125; int peek() &#123; peekedElem = hasPeeked?peekedElem:Iterator::next(); hasPeeked = true; return peekedElem; &#125; int next() &#123; int nextElem = hasPeeked?peekedElem:Iterator::next(); hasPeeked = false; return nextElem; &#125; bool hasNext() const &#123; return hasPeeked||Iterator::hasNext(); &#125;&#125;; Java implementation, inspired by Google’s guava library source code. 123456789101112131415161718192021222324252627282930class PeekingIterator implements Iterator&lt;Integer&gt; &#123; private final Iterator&lt;Integer&gt; iterator; private boolean hasPeeked; private Integer peekedElement; public PeekingIterator(Iterator&lt;Integer&gt; iterator) &#123; if(iterator==null) throw new NullPointerException(); else this.iterator = iterator; &#125; public Integer peek() &#123; peekedElement = hasPeeked?peekedElement:iterator.next(); hasPeeked = true; return peekedElement; &#125; @Override public Integer next() &#123; int nextElem = hasPeeked?peekedElement:iterator.next(); hasPeeked = false; return nextElem; &#125; @Override public boolean hasNext() &#123; return hasPeeked || iterator.hasNext(); &#125;&#125; https://discuss.leetcode.com/topic/25308/simple-python-solution Simple Python Solution Store the next value outside the iterator. When next is called return the stored value and populate with next value from iterator. 123456789101112131415class PeekingIterator(object): def __init__(self, iterator): self.iter = iterator self.temp = self.iter.next() if self.iter.hasNext() else None def peek(self): return self.temp def next(self): ret = self.temp self.temp = self.iter.next() if self.iter.hasNext() else None return ret def hasNext(self): return self.temp is not None 111ms, 45.64%, October 15, 2016 https://discuss.leetcode.com/topic/24883/concise-java-solution 1234567891011121314151617181920212223242526272829303132// Java Iterator interface reference:// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.htmlclass PeekingIterator implements Iterator&lt;Integer&gt; &#123; private Integer next = null; private Iterator&lt;Integer&gt; iter; public PeekingIterator(Iterator&lt;Integer&gt; iterator) &#123; // initialize any member here. iter = iterator; if(iter.hasNext()) next = iter.next(); &#125; // Returns the next element in the iteration without advancing the iterator. public Integer peek() &#123; return next; &#125; // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. @Override public Integer next() &#123; Integer res = next; next = iter.hasNext() ? iter.next() : null; return res; &#125; @Override public boolean hasNext() &#123; return next != null; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[283. Move Zeroes]]></title>
    <url>%2Fp%2F59f0159a%2F</url>
    <content type="text"><![CDATA[48.7% https://leetcode.com/problems/move-zeroes/#/description Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. 方法一： 我的代码实现： Oct 17， 2017 12345678910111213class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int j=0; for(int i=0; i&lt;n; i++) if(nums[i]!=0) nums[j++] = nums[i]; for(;j&lt;n; j++) nums[j] = 0; return; &#125;&#125;; https://discuss.leetcode.com/topic/32632/my-simple-c-solution My simple C++ solution 123456789101112131415class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int j = 0; // move all the nonzero elements advance for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] != 0) &#123; nums[j++] = nums[i]; &#125; &#125; for (;j &lt; nums.size(); j++) &#123; nums[j] = 0; &#125; &#125;&#125;; 方法二： 类似于快排partition的用法 我的代码实现： Oct 21， 2017 12345678910class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int pos = -1; for(int i=0; i&lt;nums.size(); i++) if(nums[i]!=0) swap(nums[++pos], nums[i]); return; &#125;&#125;; https://discuss.leetcode.com/topic/24745/c-accepted-code C++ Accepted Code 123456789101112void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int last = 0, cur = 0; while(cur &lt; nums.size()) &#123; if(nums[cur] != 0) &#123; swap(nums[last], nums[cur]); last++; &#125; cur++; &#125;&#125; https://discuss.leetcode.com/topic/25077/one-line-c-code-20ms One line c++ code, 20ms The idea comes from the c++ erase/remove idiom. 123456class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; fill(remove(nums.begin(), nums.end(),0), nums.end(), 0); &#125;&#125;; https://discuss.leetcode.com/topic/25163/c-1-line-or-3-lines-clean-code C++ 1 line (or 3 lines) clean code 123456789void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; for (int i = 0, j = 0; i &lt; nums.size(); i++) if(nums[i] != 0) swap(nums[i], nums[j++]);&#125; void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; for (int i = 0, j = 0; i &lt; nums.size(); i++) &#123; if (nums[i] != 0) swap(nums[i], nums[j++]); &#125;&#125; https://discuss.leetcode.com/topic/28941/very-simple-python-solutions Very simple python solutions Solution 1: traverse and swap last 0 and last non 0 1234567891011class Solution(object): def moveZeroes(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; last0 = 0 for i in range(0,len(nums)): if (nums[i]!=0): nums[i],nums[last0] = nums[last0],nums[i] last0+=1 Solution 2 : one-liner from @toontong: use sort() with customized compare function 1234567class Solution(object): def moveZeroes(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; nums.sort(cmp=lambda a,b: 0 if b else -1)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[282. Expression Add Operators]]></title>
    <url>%2Fp%2F2290fe4%2F</url>
    <content type="text"><![CDATA[29.1% https://leetcode.com/problems/expression-add-operators/#/description Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value. 123456Examples: &quot;123&quot;, 6 -&gt; [&quot;1+2+3&quot;, &quot;1*2*3&quot;] &quot;232&quot;, 8 -&gt; [&quot;2*3+2&quot;, &quot;2+3*2&quot;]&quot;105&quot;, 5 -&gt; [&quot;1*0+5&quot;,&quot;10-5&quot;]&quot;00&quot;, 0 -&gt; [&quot;0+0&quot;, &quot;0-0&quot;, &quot;0*0&quot;]&quot;3456237490&quot;, 9191 -&gt; [] https://discuss.leetcode.com/topic/24478/17-lines-solution-dfs-c 17 lines solution, dfs (C++) 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;private: // cur: &#123;string&#125; expression generated so far. // pos: &#123;int&#125; current visiting position of num. // cv: &#123;long&#125; cumulative value so far. // pv: &#123;long&#125; previous operand value. // op: &#123;char&#125; previous operator used. void dfs(std::vector&lt;string&gt;&amp; res, const string&amp; num, const int target, string cur, int pos, const long cv, const long pv, const char op) &#123; if (pos == num.size() &amp;&amp; cv == target) &#123; res.push_back(cur); &#125; else &#123; for (int i=pos+1; i&lt;=num.size(); i++) &#123; string t = num.substr(pos, i-pos); long now = stol(t); if (to_string(now).size() != t.size()) continue; dfs(res, num, target, cur+&apos;+&apos;+t, i, cv+now, now, &apos;+&apos;); dfs(res, num, target, cur+&apos;-&apos;+t, i, cv-now, now, &apos;-&apos;); dfs(res, num, target, cur+&apos;*&apos;+t, i, (op == &apos;-&apos;) ? cv+pv - pv*now : ((op == &apos;+&apos;) ? cv-pv + pv*now : pv*now), pv*now, op); &#125; &#125; &#125;public: vector&lt;string&gt; addOperators(string num, int target) &#123; vector&lt;string&gt; res; if (num.empty()) return res; for (int i=1; i&lt;=num.size(); i++) &#123; string s = num.substr(0, i); long cur = stol(s); if (to_string(cur).size() != s.size()) continue; dfs(res, num, target, s, i, cur, cur, &apos;#&apos;); // no operator defined. &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/24487/accepted-c-solution Accepted C++ Solution 1234567891011121314151617181920212223242526272829void addOperators(vector&lt;string&gt;&amp; result, string nums, string t, long long last, long long curVal, int target) &#123; if (nums.length() == 0) &#123; if (curVal == target) result.push_back(t); return; &#125; for (int i = 1; i&lt;=nums.length(); i++) &#123; string num = nums.substr(0, i); if(num.length() &gt; 1 &amp;&amp; num[0] == &apos;0&apos;) return; string nextNum = nums.substr(i); if (t.length() &gt; 0) &#123; addOperators(result, nextNum, t + &quot;+&quot; + num, stoll(num), curVal + stoll(num), target); addOperators(result, nextNum, t + &quot;-&quot; + num, -stoll(num), curVal - stoll(num), target); addOperators(result, nextNum, t + &quot;*&quot; + num, last * stoll(num), (curVal - last) + (last * stoll(num)), target); &#125; else addOperators(result, nextNum, num, stoll(num), stoll(num), target); &#125;&#125;vector&lt;string&gt; addOperators(string num, int target) &#123; vector&lt;string&gt; result; addOperators(result, num, &quot;&quot;, 0, 0, target); return result;&#125; https://discuss.leetcode.com/topic/35751/recommend-for-beginners-clean-c-implementation-with-detailed-explanation [recommend for beginners]clean C++ implementation with detailed explanation 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;string&gt; addOperators(string num, int target) &#123; vector&lt;string&gt; result; if(num.size()==0) return result; help(result, &quot;&quot;, num, target, 0, 0, 0); return result; &#125; void help(vector&lt;string&gt; &amp;result, string path, string num, int target, int pos, long cur, long prev)&#123; if(pos==num.size())&#123; if(cur==target) result.push_back(path); return; &#125; for(int i=pos; i&lt;num.size(); i++)&#123; /*** corner-case-added-code ***/ if(num[pos]==&apos;0&apos; &amp;&amp; i&gt;pos) break; string _str=num.substr(pos, i-pos+1); long _value=stol(_str); if(pos==0) &#123; help(result, path+_str, num, target, i+1, _value, _value); &#125; else&#123; help(result, path+&quot;+&quot;+_str, num, target, i+1, cur+_value, _value); help(result, path+&quot;-&quot;+_str, num, target, i+1, cur-_value, -_value); help(result, path+&quot;*&quot;+_str, num, target, i+1, cur-prev+prev*_value, prev*_value); &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/24688/16ms-c-solution 16ms C++ solution The idea is to cut a value from the left of the string and then for each of operations ‘+’, ‘-‘, ‘*‘ repeat the procedure recursively. The trick is to pass the sum of all left summands and the product of rightmost factors. This allows to calculate the left sum and the right product on the next step depending on the next chosen operation. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; typedef long long int i64; string myS; const char* s; i64 target; int slen; public: vector&lt;string&gt; addOperators(const string&amp; num, int t) &#123; myS = num; slen = myS.size(); s = myS.c_str(); target = t; vector&lt;string&gt; res; char buf[slen*2+1]; int lmax = (s[0] == &apos;0&apos; ? 1 : slen); i64 v = 0; for (int l=1; l&lt;=lmax; ++l) &#123; int c = s[l-1]; v = v*10 + (c-&apos;0&apos;); // add next digit buf[l-1] = c; // only need to append the last digit processTail(0, v, l, buf, l, res); &#125; return res; &#125; void processTail(i64 prevsum, i64 last, int pos, char* buf, int bufpos, vector&lt;string&gt;&amp; res) &#123; if (pos == slen) &#123; // end of string // check the value and save if (prevsum+last == target) &#123; buf[bufpos] = 0; res.push_back(buf); &#125; return; &#125; int lmax = (s[pos] == &apos;0&apos; ? 1 : slen-pos); // don&apos;t allow multichar intergers starting from a &apos;0&apos; i64 v = 0; for (int l=1; l&lt;=lmax; ++l) &#123; int c = s[pos+l-1]; v = v*10 + (c-&apos;0&apos;); // add next digit to v buf[bufpos] = &apos;+&apos;; buf[bufpos+l] = c; // only need to append the last digit of v processTail(prevsum+last, v, pos+l, buf, bufpos+l+1, res); buf[bufpos] = &apos;-&apos;; processTail(prevsum+last, -v, pos+l, buf, bufpos+l+1, res); buf[bufpos] = &apos;*&apos;; processTail(prevsum, last*v, pos+l, buf, bufpos+l+1, res); &#125; &#125;&#125;; 2509ms, 25,85%, October 18, 2016 https://discuss.leetcode.com/topic/30089/clean-python-dfs-with-comments Clean Python DFS with comments dfs() parameters: num: remaining num string temp: temporally string with operators added cur: current result of “temp” string last: last multiply-level number in “temp”. if next operator is “multiply”, “cur” and “last” will be updated res: result to return 123456789101112131415161718def addOperators(self, num, target): res, self.target = [], target for i in range(1,len(num)+1): if i == 1 or (i &gt; 1 and num[0] != &quot;0&quot;): # prevent &quot;00*&quot; as a number self.dfs(num[i:], num[:i], int(num[:i]), int(num[:i]), res) # this step put first number in the string return resdef dfs(self, num, temp, cur, last, res): if not num: if cur == self.target: res.append(temp) return for i in range(1, len(num)+1): val = num[:i] if i == 1 or (i &gt; 1 and num[0] != &quot;0&quot;): # prevent &quot;00*&quot; as a number self.dfs(num[i:], temp + &quot;+&quot; + val, cur+int(val), int(val), res) self.dfs(num[i:], temp + &quot;-&quot; + val, cur-int(val), -int(val), res) self.dfs(num[i:], temp + &quot;*&quot; + val, cur-last+last*int(val), last*int(val), res) 282ms, 23.05%, October 18, 2016 https://discuss.leetcode.com/topic/24523/java-standard-backtrace-ac-solutoin-short-and-clear 12345678910111213141516171819202122232425262728public class Solution &#123; public List&lt;String&gt; addOperators(String num, int target) &#123; List&lt;String&gt; rst = new ArrayList&lt;String&gt;(); if(num==null || num.length() == 0) return rst; helper(rst, &quot;&quot;, num, target, 0, 0, 0); return rst; &#125; public void helper(List&lt;String&gt; rst, String path, String num, int target, int pos, long eval, long multed)&#123; if(pos == num.length())&#123; if(target == eval) rst.add(path); return; &#125; for(int i=pos; i&lt;num.length(); i++)&#123; if(i != pos &amp;&amp; num.charAt(pos) == &apos;0&apos;) break; long cur = Long.parseLong(num.substring(pos, i+1)); if(pos == 0) helper(rst, path+cur, num, target, i+1, cur, cur); else&#123; helper(rst, path + &quot;+&quot; + cur, num, target, i+1, eval+cur, cur); helper(rst, path + &quot;-&quot; + cur, num, target, i+1, eval-cur, -cur); helper(rst, path + &quot;*&quot; + cur, num, target, i+1, eval-multed+multed*cur, multed*cur); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>divide and conquer</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[279. Perfect Squares]]></title>
    <url>%2Fp%2F81d53cb4%2F</url>
    <content type="text"><![CDATA[35.8% https://leetcode.com/problems/perfect-squares/#/description Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n. For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9. https://discuss.leetcode.com/topic/24255/summary-of-4-different-solutions-bfs-dp-static-dp-and-mathematics Summary of 4 different solutions (BFS, DP, static DP and mathematics) Came up with the 2 solutions of breadth-first search and dynamic programming. Also “copied” StefanPochmann’s static dynamic programming solution (https://leetcode.com/discuss/56993/static-dp-c-12-ms-python-172-ms-ruby-384-ms) and davidtan1890’s mathematical solution (https://leetcode.com/discuss/57066/4ms-c-code-solve-it-mathematically) here with minor style changes and some comments. Thank Stefan and David for posting their nice solutions! 1.Dynamic Programming: 440ms 12345678910111213141516171819202122232425262728class Solution &#123;public: int numSquares(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; // cntPerfectSquares[i] = the least number of perfect square numbers // which sum to i. Note that cntPerfectSquares[0] is 0. vector&lt;int&gt; cntPerfectSquares(n + 1, INT_MAX); cntPerfectSquares[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; // For each i, it must be the sum of some number (i - j*j) and // a perfect square number (j*j). for (int j = 1; j*j &lt;= i; j++) &#123; cntPerfectSquares[i] = min(cntPerfectSquares[i], cntPerfectSquares[i - j*j] + 1); &#125; &#125; return cntPerfectSquares.back(); &#125;&#125;; 2.Static Dynamic Programming: 12ms 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int numSquares(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; // cntPerfectSquares[i] = the least number of perfect square numbers // which sum to i. Since cntPerfectSquares is a static vector, if // cntPerfectSquares.size() &gt; n, we have already calculated the result // during previous function calls and we can just return the result now. static vector&lt;int&gt; cntPerfectSquares(&#123;0&#125;); // While cntPerfectSquares.size() &lt;= n, we need to incrementally // calculate the next result until we get the result for n. while (cntPerfectSquares.size() &lt;= n) &#123; int m = cntPerfectSquares.size(); int cntSquares = INT_MAX; for (int i = 1; i*i &lt;= m; i++) &#123; cntSquares = min(cntSquares, cntPerfectSquares[m - i*i] + 1); &#125; cntPerfectSquares.push_back(cntSquares); &#125; return cntPerfectSquares[n]; &#125;&#125;; 3.Mathematical Solution: 4ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123; private: int is_square(int n) &#123; int sqrt_n = (int)(sqrt(n)); return (sqrt_n*sqrt_n == n); &#125; public: // Based on Lagrange&apos;s Four Square theorem, there // are only 4 possible results: 1, 2, 3, 4. int numSquares(int n) &#123; // If n is a perfect square, return 1. if(is_square(n)) &#123; return 1; &#125; // The result is 4 if and only if n can be written in the // form of 4^k*(8*m + 7). Please refer to // Legendre&apos;s three-square theorem. while ((n &amp; 3) == 0) // n%4 == 0 &#123; n &gt;&gt;= 2; &#125; if ((n &amp; 7) == 7) // n%8 == 7 &#123; return 4; &#125; // Check whether 2 is the result. int sqrt_n = (int)(sqrt(n)); for(int i = 1; i &lt;= sqrt_n; i++) &#123; if (is_square(n - i*i)) &#123; return 2; &#125; &#125; return 3; &#125; &#125;; 4.Breadth-First Search: 80ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class Solution &#123;public: int numSquares(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; // perfectSquares contain all perfect square numbers which // are smaller than or equal to n. vector&lt;int&gt; perfectSquares; // cntPerfectSquares[i - 1] = the least number of perfect // square numbers which sum to i. vector&lt;int&gt; cntPerfectSquares(n); // Get all the perfect square numbers which are smaller than // or equal to n. for (int i = 1; i*i &lt;= n; i++) &#123; perfectSquares.push_back(i*i); cntPerfectSquares[i*i - 1] = 1; &#125; // If n is a perfect square number, return 1 immediately. if (perfectSquares.back() == n) &#123; return 1; &#125; // Consider a graph which consists of number 0, 1,...,n as // its nodes. Node j is connected to node i via an edge if // and only if either j = i + (a perfect square number) or // i = j + (a perfect square number). Starting from node 0, // do the breadth-first search. If we reach node n at step // m, then the least number of perfect square numbers which // sum to n is m. Here since we have already obtained the // perfect square numbers, we have actually finished the // search at step 1. queue&lt;int&gt; searchQ; for (auto&amp; i : perfectSquares) &#123; searchQ.push(i); &#125; int currCntPerfectSquares = 1; while (!searchQ.empty()) &#123; currCntPerfectSquares++; int searchQSize = searchQ.size(); for (int i = 0; i &lt; searchQSize; i++) &#123; int tmp = searchQ.front(); // Check the neighbors of node tmp which are the sum // of tmp and a perfect square number. for (auto&amp; j : perfectSquares) &#123; if (tmp + j == n) &#123; // We have reached node n. return currCntPerfectSquares; &#125; else if ((tmp + j &lt; n) &amp;&amp; (cntPerfectSquares[tmp + j - 1] == 0)) &#123; // If cntPerfectSquares[tmp + j - 1] &gt; 0, this is not // the first time that we visit this node and we should // skip the node (tmp + j). cntPerfectSquares[tmp + j - 1] = currCntPerfectSquares; searchQ.push(tmp + j); &#125; else if (tmp + j &gt; n) &#123; // We don&apos;t need to consider the nodes which are greater ] // than n. break; &#125; &#125; searchQ.pop(); &#125; &#125; return 0; &#125;&#125;; https://discuss.leetcode.com/topic/23808/o-sqrt-n-in-ruby-c-c O(sqrt(n)) in Ruby, C++, C These solutions use some number theory (see explanation further down). C++ solution 123456789101112131415161718int numSquares(int n) &#123; while (n % 4 == 0) n /= 4; if (n % 8 == 7) return 4; bool min2 = false; for (int i=2; i&lt;=n; ++i) &#123; if (i &gt; n/i) i = n; int e = 0; while (n % i == 0) n /= i, ++e; if (e % 2 &amp;&amp; i % 4 == 3) return 3; min2 |= e % 2; &#125; return 1 + min2;&#125; C solution Inspired by kevin36’s solution. We don’t really need to compute the prime factorization. Knowing that four squares always suffice and using the three-squares test is enough. Single-square and sum-of-two-squares cases can be done simpler. 123456789101112int numSquares(int n) &#123; while (n % 4 == 0) n /= 4; if (n % 8 == 7) return 4; for (int a=0; a*a&lt;=n; ++a) &#123; int b = sqrt(n - a*a); if (a*a + b*b == n) return 1 + !!a; &#125; return 3;&#125; Explanation I happen to have given a little talk about just this topic a while back in a number theory seminar. This problem is completely solved, in the sense of being reduced to simple checks of a number’s prime factorization. A natural number is… … a square if and only if each prime factor occurs to an even power in the number’s prime factorization. … a sum of two squares if and only if each prime factor that’s 3 modulo 4 occurs to an even power in the number’s prime factorization. … a sum of three squares if and only if it’s not of the form 4a(8b+7) with integers a and b. … a sum of four squares. Period. No condition. You never need more than four. Of course single squares can also be identified by comparing a given number with the square of the rounded root of the number. The problem statement says “1, 4, 9, 16, …”, for some reason apparently excluding 0, but it really is a perfect square and the above theorems do consider it one. With that, you can for example always extend a sum of two squares a2+b2 to the sum of three squares a2+b2+02. Put differently, if n isn’t a sum of three squares, then it also isn’t a sum of two squares. So you can read the above statements as “… a sum of m (or fewer) squares”. Thanks to ruben3 for asking about this in the comments. In my above solutions, I first divide the given number by 4 as often as possible and then do the three-squares check. Dividing by 4 doesn’t affect the other checks, and the n % 8 == 7 is cheaper than the prime factorization, so this saves time in cases where we do need four squares. Armed with just the knowledge that you never need more than four squares, it’s also easy to write O(n) solutions, e.g.: 1234567891011int numSquares(int n) &#123; int ub = sqrt(n); for (int a=0; a&lt;=ub; ++a) &#123; for (int b=a; b&lt;=ub; ++b) &#123; int c = sqrt(n - a*a - b*b); if (a*a + b*b + c*c == n) return !!a + !!b + !!c; &#125; &#125; return 4;&#125; https://discuss.leetcode.com/topic/23812/static-dp-c-12-ms-python-172-ms-ruby-384-ms/2 Static DP, C++ 12 ms, Python 172 ms, Ruby 384 ms There are so many “large” test cases that it’s worthwhile to keep data between test cases rather than recomputing from scratch all the time. At least in the slower languages. My dp tells the numbers of squares needed for the first integers, and when asked about a new n, I extend dp just as much as necessary. C++ … 28 ms 12345678910int numSquares(int n) &#123; static vector&lt;int&gt; dp &#123;0&#125;; while (dp.size() &lt;= n) &#123; int m = dp.size(), squares = INT_MAX; for (int i=1; i*i&lt;=m; ++i) squares = min(squares, dp[m-i*i] + 1); dp.push_back(squares); &#125; return dp[n];&#125; C++ … 12 ms Switching the loops makes it less nice but faster: 12345678910int numSquares(int n) &#123; static vector&lt;int&gt; dp &#123;0&#125;; int m = dp.size(); dp.resize(max(m, n+1), INT_MAX); for (int i=1, i2; (i2 = i*i)&lt;=n; ++i) for (int j=max(m, i2); j&lt;=n; ++j) if (dp[j] &gt; dp[j-i2] + 1) dp[j] = dp[j-i2] + 1; return dp[n];&#125; Python … 172 ms 1234567class Solution(object): _dp = [0] def numSquares(self, n): dp = self._dp while len(dp) &lt;= n: dp += min(dp[-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1, return dp[n] There’s probably a cleaner way than using a global variable, but I’m new to Ruby and don’t know one. https://discuss.leetcode.com/topic/26262/short-python-solution-using-bfs/2 Short Python solution using BFS 1234567891011121314151617181920212223def numSquares(self, n): if n &lt; 2: return n lst = [] i = 1 while i * i &lt;= n: lst.append( i * i ) i += 1 cnt = 0 toCheck = &#123;n&#125; while toCheck: cnt += 1 temp = set() for x in toCheck: for y in lst: if x == y: return cnt if x &lt; y: break temp.add(x-y) toCheck = temp return cnt The basic idea of this solution is a BSF search for shortest path, take 12 as an example, as shown below, the shortest path is 12-8-4-0: https://discuss.leetcode.com/topic/23846/4ms-c-code-solve-it-mathematically 4ms C++ code - Solve it mathematically 123456789101112131415161718class Solution &#123; public: int is_square(int n)&#123; int temp = (int) sqrt(n); return temp * temp == n; &#125; int numSquares(int n) &#123; while ((n &amp; 3) == 0) //n%4 == 0 n &gt;&gt;= 2; if ((n &amp; 7) == 7) return 4; //n % 8 == 7 if(is_square(n)) return 1; int sqrt_n = (int) sqrt(n); for(int i = 1; i&lt;= sqrt_n; i++)&#123; if (is_square(n-i*i)) return 2; &#125; return 3; &#125; &#125;; UPDATE: in order to understand, I suggest u read: here is the Lagrange’s Four Square theorem - Limit the result to &lt;= 4: https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem And this article, in which you can also find the way to present a number as a sum of four squares: http://www.alpertron.com.ar/4SQUARES.HTM https://discuss.leetcode.com/topic/23906/o-sqrt-n-about-0-034-ms-and-0-018-ms/2 O(sqrt(n)), about 0.034 ms (and 0.018 ms) For better measurement, I wrapped the actual solution in a 10000-loop. This got accepted in 344 ms (every time in three submits), so without the wrapper it should take about 0.0344 ms. I tried a few variations and this is the fastest I managed to do. (Update: After qgambit2’s challenge, I optimized my my original approach and now that’s my fastest, with about 180 ms.) First I use the fact that four squares always suffice and the fact that four squares are only needed for numbers of the form 4a(8b+7). After that part, I know that the answer is 1, 2 or 3, and I try to build n as sum of one or two squares. For that, I use a kind of two-pointers-approach. Instead of going through squares a2 and checking whether n-a2 is a square (which would involve computing lots of square roots), imagine you start with a=02 and b=floor(sqrt(n))2 and as long as a&lt;=b, either make a the next larger square or make b the next smaller square, depending on whether the sum of the two squares is too small or too large (or return 2, if it’s exactly right). But in order to improve speed further, I use that squares are sums of consecutive odd numbers starting at 1 (for example, 25=1+3+5+7+9), and my a and b aren’t squares but the corresponding odd numbers. And instead of computing the sum of the two squares, I just add to or subtract from n, trying to reach zero. This way, my main part doesn’t even have multiplications. Just simple addition/subtraction and comparisons. The solution: 123456789101112131415161718int numSquaresReal(int n) &#123; while (n % 4 == 0) n /= 4; if (n % 8 == 7) return 4; int a = -1, b = sqrt(n); n -= b * b; b += b + 1; while (a &lt;= b) &#123; if (n &lt; 0) n += b -= 2; else if (n &gt; 0) n -= a += 2; else return a &lt; 0 ? 1 : 2; &#125; return 3;&#125; The wrapper for better time measurement: 123456int numSquares(int n) &#123; int sum = 0; for (int i=0; i&lt;10000; i++) sum += numSquaresReal(n); return sum / 10000;&#125; 488ms, 26.95%, June.15th, 2016 https://leetcode.com/discuss/62229/short-python-solution-using-bfs 12345678910111213141516171819202122232425262728class Solution(object): def numSquares(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n &lt; 2: return n lst = [] i = 1 while i * i &lt;= n: lst.append( i * i ) i += 1 cnt = 0 toCheck = &#123;n&#125; while toCheck: cnt += 1 temp = set() for x in toCheck: for y in lst: if x == y: return cnt if x &lt; y: break temp.add(x-y) toCheck = temp return cnt Solution 2: 208ms, 60.99%, June.15th, 2016 https://leetcode.com/discuss/56993/static-dp-c-12-ms-python-172-ms-ruby-384-ms 1234567891011class Solution(object): _dp = [0] def numSquares(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; dp = self._dp while len(dp) &lt;= n: dp += min(dp[-i*i] for i in range(1, int(len(dp)**0.5+1))) + 1, return dp[n]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[278. First Bad Version]]></title>
    <url>%2Fp%2F7b51cdf3%2F</url>
    <content type="text"><![CDATA[24.7% https://leetcode.com/problems/first-bad-version/#/description You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. 方法一: 二分查找 我的代码实现： Oct 13th, 2017 12345678910111213141516171819// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int l=1, r=n; if(isBadVersion(l)) return l; while(l&lt;r)&#123; int mid = l+(r-l)/2; if(isBadVersion(mid)) r = mid; else l = mid+1; &#125; return l; &#125;&#125;; https://discuss.leetcode.com/topic/38135/a-good-warning-to-me-to-use-start-end-start-2-to-avoid-overflow A good warning to me to use start+(end-start)/2 to avoid overflow Before this problem, I have always use 1mid = (start+end)) / 2; To get the middle value, but this can caused OVERFLOW ! when start and end are all about INT_MAX , then (start+end) of course will be overflow ! To avoid the problem we can use 1mid = start+(end-start)/2; Here is the AC implementation 1234567891011121314151617// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int start=0, end=n; cout&lt;&lt;end-start&lt;&lt;end; while(end-start&gt;1)&#123; int mid=start+(end-start)/2; /** mid = (start+end)) / 2; **/ if(isBadVersion(mid)) end=mid; else start=mid; &#125; return end; &#125;&#125;; https://discuss.leetcode.com/topic/25845/time-limit-exceed Time limit exceed Is there any difference between “ ( low + high ) / 2 “ and “ low + ( high - low ) / 2 “? When I use the first one, it told me “time limit exceed” but if I use the second one, it worked! https://discuss.leetcode.com/topic/23597/short-c-answer-and-minimize-api-calls Short C++ answer and minimize API calls 123456789101112class Solution &#123;public: int firstBadVersion(int n) &#123; int lower = 1, upper = n, mid; while(lower &lt; upper) &#123; mid = lower + (upper - lower) / 2; if(!isBadVersion(mid)) lower = mid + 1; /* Only one call to API */ else upper = mid; &#125; return lower; /* Because there will alway be a bad version, return lower here */ &#125;&#125;; https://discuss.leetcode.com/topic/23617/what-s-the-difference-between-left-right-2-and-left-right-left-2 What’s the difference between “(left + right) / 2” and “left + (right - left) / 2”? Below is my code, it got TLE. But I can’t see the difference between my code and this one except for how I calculated mid. So is there any difference between “(left + right) / 2” and “left + (right - left) / 2”? 1234567891011121314151617181920bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int left = 1; int right = n; int mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(isBadVersion(mid)) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left; &#125;&#125;; https://discuss.leetcode.com/topic/23607/1-liner-in-ruby-python 1-liner in Ruby / Python Python In Python I was only able to do it with a rather ugly wrapper: 12def firstBadVersion(self, n): return bisect.bisect(type(&apos;&apos;, (), &#123;&apos;__getitem__&apos;: lambda self, i: isBadVersion(i)&#125;)(), False, 0, n) Nicer, more readable version: 12345def firstBadVersion(self, n): class Wrap: def __getitem__(self, i): return isBadVersion(i) return bisect.bisect(Wrap(), False, 0, n) https://discuss.leetcode.com/topic/27365/python-understand-easily-from-binary-search-idea Python, understand (easily from Binary search idea) 123456789101112131415class Solution(object):def firstBadVersion(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; r = n-1 l = 0 while(l&lt;=r): mid = l + (r-l)/2 if isBadVersion(mid)==False: l = mid+1 else: r = mid-1 return l https://discuss.leetcode.com/topic/24175/my-0ms-c-solution-with-o-logn-time-and-o-1-space My 0ms c++ solution with O(logn) time and O(1) space 0ms, September 11, 2016 https://discuss.leetcode.com/topic/23597/short-c-answer-and-minimize-api-calls 123456789101112131415// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int lower = 1, upper = n, mid; while(lower &lt; upper)&#123; mid = lower + (upper - lower) / 2; if(!isBadVersion(mid)) lower = mid + 1; else upper = mid; &#125; return lower; &#125;&#125;; 35ms, September 11, 2016 my solution 12345678910111213141516171819# The isBadVersion API is already defined for you.# @param version, an integer# @return a bool# def isBadVersion(version):class Solution(object): def firstBadVersion(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; l, r = 1, n while l &lt; r: mid = l + (r-l)/2 if isBadVersion(mid) == False: l = mid + 1 else: r = mid return l 17ms, September 11, 2016 https://discuss.leetcode.com/topic/26272/o-lgn-simple-java-solution 1234567891011121314/* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int start = 1, end = n; while(start &lt; end)&#123; int mid = start + (end - start) / 2; if(!isBadVersion(mid)) start = mid + 1; else end = mid; &#125; return start; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[275. H-Index II]]></title>
    <url>%2Fp%2F79619e9a%2F</url>
    <content type="text"><![CDATA[34.4% https://leetcode.com/problems/h-index-ii/ Follow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm? Hint: Expected runtime complexity is in O(log n) and the input is sorted. 方法一： 二分查找 1234567891011121314151617class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; if(citations.empty()) return 0; int n = citations.size(); int left = 0, right = n-1; while(left&lt;=right)&#123; // &lt;= 不是 &lt; int mid = left + (right-left)/2; if(citations[mid]&gt;=n-mid)&#123; // &gt;= 而不是&gt; right = mid-1; &#125;else&#123; left = mid+1; &#125; &#125; return n-left; &#125;&#125;; cpp124ms, 60.19%, May.4th, 2016 https://leetcode.com/discuss/56109/space-easy-solution-with-detailed-explanations-java-python 1234567891011121314151617181920212223class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; int size = citations.size(); int first = 0; int mid; int count = size; int step; while(count &gt; 0)&#123; step = count / 2; mid = first + step; if(citations[mid] &lt; size - mid)&#123; first = mid + 1; count -= (step + 1); &#125; else count = step; &#125; return size - first; &#125;&#125;; python124ms, 60.19%, 82 / 82, May.4th, 2016 https://leetcode.com/discuss/56119/binary-search-in-python 123456789101112131415class Solution(object): def hIndex(self, citations): &quot;&quot;&quot; :type citations: List[int] :rtype: int &quot;&quot;&quot; N = len(citations) low, high = 0, N - 1 while low &lt;= high: mid = (low + high) / 2 if N - mid &gt; citations[mid]: low = mid + 1 else: high = mid - 1 return N - low 132ms, 46.76%, May.4th, 2016 https://leetcode.com/discuss/56109/space-easy-solution-with-detailed-explanations-java-python 123456789101112131415161718192021class Solution(object): def hIndex(self, citations): &quot;&quot;&quot; :type citations: List[int] :rtype: int &quot;&quot;&quot; length = len(citations) first = 0 count = length while count &gt; 0: step = count / 2 mid = first + step if citations[mid] &lt; length - mid: first = mid + 1 count -= (step + 1) else: count = step return length - first java12ms, 46.91%, May.4th, 2016 https://leetcode.com/discuss/56109/space-easy-solution-with-detailed-explanations-java-python 123456789101112131415161718192021222324public class Solution &#123; public int hIndex(int[] citations) &#123; int len = citations.length; int first = 0; int mid; int count = len; int step; while (count &gt; 0) &#123; step = count / 2; mid = first + step; if (citations[mid] &lt; len - mid) &#123; first = mid + 1; count -= (step + 1); &#125; else &#123; count = step; &#125; &#125; return len - first; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[274. H-Index]]></title>
    <url>%2Fp%2F1b8dbba0%2F</url>
    <content type="text"><![CDATA[32.8% https://leetcode.com/problems/h-index/#/description Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index. According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.” For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Hint: An easy approach is to sort the array first. What are the possible values of h-index? A faster approach is to use extra space. 方法一： May.4th https://leetcode.com/discuss/55969/o-n-time-c-solution-using-hash-table Line 20: control reaches end of non-void function [-Werror=return-type] 使用vector，index为引用量，值为篇数。时间效率O（n） 注意下面有一处是i–, 不要习惯性的写成i++ 根据长度n，最大的为n，由n依次递减查找，O（n）解法 123456789101112131415161718192021class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; if(citations.empty()) return 0; int n = citations.size(); vector&lt;int&gt; hash(n + 1, 0); for(int i = 0; i &lt; n; ++i)&#123; if(citations[i] &gt;= n) hash[n]++; else hash[citations[i]]++; &#125; int paper = 0; for(int i = n; i &gt;= 0; --i)&#123; paper += hash[i]; if(paper &gt;= i) return i; &#125; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; if(citations.empty()) return 0; int n = citations.size(); vector&lt;int&gt; v(n+1, 0); for(auto citation:citations)&#123; if(citation&gt;=n) v[n]++; else v[citation]++; &#125; int paper = 0; for(int i=n; i&gt;=0; i--)&#123; paper += v[i]; if(paper&gt;=i) return i; &#125; &#125;&#125;; 方法二： 直接按定义来，先排序，再依次判断 我的实现 1234567891011121314class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; if(citations.empty()) return 0; sort(citations.begin(), citations.end(), [](int a, int b)&#123;return a&gt;b;&#125;); int paper = 0; int n = citations.size(); for(; paper&lt;n; paper++)&#123; if(citations[paper]&lt;paper+1) return paper-1; &#125; return paper; &#125;&#125;; python Mine Solution: 48ms, 30.68%, May.4th, 2016 12345678910111213class Solution(object): def hIndex(self, citations): &quot;&quot;&quot; :type citations: List[int] :rtype: int &quot;&quot;&quot; if not citations: return 0 citations.sort(reverse = True) for key, value in enumerate(citations): if key + 1 &gt; value: return value elif key + 1 == len(citations) or key + 1 &gt;= citations[key + 1]: return key + 1 https://discuss.leetcode.com/topic/23810/python-o-n-lgn-time-with-sort-o-n-time-with-o-n-space Python O(n lgn) time with sort, O(n) time with O(n) space Sort 1234567def hIndex(self, citations): citations.sort() n = len(citations) for i in xrange(n): if citations[i] &gt;= (n-i): return n-i return 0 O(n) space, O(n) time 12345678910111213141516def hIndex(self, citations): n = len(citations) citeCount = [0] * (n+1) for c in citations: if c &gt;= n: citeCount[n] += 1 else: citeCount[c] += 1 i = n-1 while i &gt;= 0: citeCount[i] += citeCount[i+1] if citeCount[i+1] &gt;= i+1: return i+1 i -= 1 return 0 java4ms, 9.28%, 81 / 81, May.4th, 2016 https://leetcode.com/discuss/55958/my-easy-solution 123456789public class Solution &#123; public int hIndex(int[] citations) &#123; Arrays.sort(citations); int len = citations.length; for(int i=0; i&lt;len; i++) if(citations[i] &gt;= len - i) return len-i; return 0; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>hash table</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[273. Integer to English Words]]></title>
    <url>%2Fp%2F17e7ae89%2F</url>
    <content type="text"><![CDATA[21.5% https://leetcode.com/problems/integer-to-english-words/#/description Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1. 1234For example,123 -&gt; &quot;One Hundred Twenty Three&quot;12345 -&gt; &quot;Twelve Thousand Three Hundred Forty Five&quot;1234567 -&gt; &quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&quot; Hint: Did you see a pattern in dividing the number into chunk of words? For example, 123 and 123000. Group the number by thousands (3 digits). You can write a helper function that takes a number less than 1000 and convert just that chunk to words. There are many edge cases. What are some good test cases? Does your code work with input such as 0? Or 1000010? (middle chunk is zero and should not be printed out) https://discuss.leetcode.com/topic/24112/fairly-clear-4ms-c-solution Fairly Clear 4ms C++ solution 1234567891011121314151617181920212223class Solution &#123;public: static string numberToWords(int n) &#123; if(n == 0) return &quot;Zero&quot;; else return int_string(n).substr(1); &#125;private: static const char * const below_20[]; static const char * const below_100[]; static string int_string(int n) &#123; if(n &gt;= 1000000000) return int_string(n / 1000000000) + &quot; Billion&quot; + int_string(n - 1000000000 * (n / 1000000000)); else if(n &gt;= 1000000) return int_string(n / 1000000) + &quot; Million&quot; + int_string(n - 1000000 * (n / 1000000)); else if(n &gt;= 1000) return int_string(n / 1000) + &quot; Thousand&quot; + int_string(n - 1000 * (n / 1000)); else if(n &gt;= 100) return int_string(n / 100) + &quot; Hundred&quot; + int_string(n - 100 * (n / 100)); else if(n &gt;= 20) return string(&quot; &quot;) + below_100[n / 10 - 2] + int_string(n - 10 * (n / 10)); else if(n &gt;= 1) return string(&quot; &quot;) + below_20[n - 1]; else return &quot;&quot;; &#125; &#125;&#125;;const char * const Solution::below_20[] = &#123;&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;,&quot;Five&quot;,&quot;Six&quot;,&quot;Seven&quot;,&quot;Eight&quot;,&quot;Nine&quot;,&quot;Ten&quot;, &quot;Eleven&quot;,&quot;Twelve&quot;,&quot;Thirteen&quot;,&quot;Fourteen&quot;,&quot;Fifteen&quot;,&quot;Sixteen&quot;,&quot;Seventeen&quot;,&quot;Eighteen&quot;,&quot;Nineteen&quot;&#125;;const char * const Solution::below_100[] = &#123;&quot;Twenty&quot;, &quot;Thirty&quot;, &quot;Forty&quot;, &quot;Fifty&quot;, &quot;Sixty&quot;, &quot;Seventy&quot;, &quot;Eighty&quot;, &quot;Ninety&quot;&#125;; https://discuss.leetcode.com/topic/22949/c-solution-4ms C++ solution 4ms 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//8msstring helper(int&amp; num)&#123; const static char* less_ten[] = &#123; &quot;&quot;, &quot; One&quot;, &quot; Two&quot;, &quot; Three&quot;, &quot; Four&quot;, &quot; Five&quot;, &quot; Six&quot;, &quot; Seven&quot;, &quot; Eight&quot;, &quot; Nine&quot; &#125;; const static char* less_twenty[] = &#123; &quot; Ten&quot;, &quot; Eleven&quot;, &quot; Twelve&quot;, &quot; Thirteen&quot;, &quot; Fourteen&quot;, &quot; Fifteen&quot;, &quot; Sixteen&quot;, &quot; Seventeen&quot;, &quot; Eighteen&quot;, &quot; Nineteen&quot; &#125;; const static char* less_hundred[] = &#123; &quot;&quot;, &quot;&quot;, &quot; Twenty&quot;, &quot; Thirty&quot;, &quot; Forty&quot;, &quot; Fifty&quot;, &quot; Sixty&quot;, &quot; Seventy&quot;, &quot; Eighty&quot;, &quot; Ninety&quot; &#125;; int less_thousand = num % 1000; num /= 1000; string s; if (less_thousand != 0)&#123; int hundred = less_thousand / 100; less_thousand %= 100; int tenth = less_thousand / 10; int single = less_thousand % 10; if (hundred) s = s + less_ten[hundred] + &quot; Hundred&quot;; if (tenth)&#123; if (tenth == 1)&#123; s += less_twenty[single]; return s; &#125; else s += less_hundred[tenth]; &#125; if (single) s += less_ten[single]; &#125; return s; &#125; string numberToWords(int num) &#123; const static char* unit[] = &#123; &quot;&quot;, &quot; Thousand&quot;, &quot; Million&quot;, &quot; Billion&quot;, &quot; Triliion&quot; &#125;; string s; int i = 0; while (num)&#123; string part = helper(num); if(i++ == 0)&#123; s = part; &#125; else if (part.size()) s = part + unit[i] + s; &#125; s = s.size() ? s.substr(1) : &quot;Zero&quot;; return s; &#125; A faster version and maybe easier to understand (4ms): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647string helper(int num)&#123; const static char* less_ten[] = &#123; &quot;&quot;, &quot; One&quot;, &quot; Two&quot;, &quot; Three&quot;, &quot; Four&quot;, &quot; Five&quot;, &quot; Six&quot;, &quot; Seven&quot;, &quot; Eight&quot;, &quot; Nine&quot; &#125;; const static char* less_twenty[] = &#123; &quot; Ten&quot;, &quot; Eleven&quot;, &quot; Twelve&quot;, &quot; Thirteen&quot;, &quot; Fourteen&quot;, &quot; Fifteen&quot;, &quot; Sixteen&quot;, &quot; Seventeen&quot;, &quot; Eighteen&quot;, &quot; Nineteen&quot; &#125;; const static char* less_hundred[] = &#123; &quot;&quot;, &quot;&quot;, &quot; Twenty&quot;, &quot; Thirty&quot;, &quot; Forty&quot;, &quot; Fifty&quot;, &quot; Sixty&quot;, &quot; Seventy&quot;, &quot; Eighty&quot;, &quot; Ninety&quot; &#125;; string s; if (num != 0)&#123; //get hundredth, tenth, and single digit int hundred = num / 100; num %= 100; int tenth = num / 10; int single = num % 10; if (hundred) s = s + less_ten[hundred] + &quot; Hundred&quot;; if (tenth)&#123; if (tenth == 1)&#123; //special handling, choose from less_twenty based on value of single s += less_twenty[single]; return s; &#125; else s += less_hundred[tenth]; &#125; if (single) s += less_ten[single]; &#125; return s;&#125;string numberToWords(int num) &#123; const static char* unit[] = &#123; &quot;&quot;, &quot; Thousand&quot;, &quot; Million&quot;, &quot; Billion&quot; &#125;; int parts[4] = &#123;0&#125;; for(int i = 0; i &lt; 4; ++i)&#123; parts[i] = num % 1000; num /= 1000; &#125; string s; for(int i = 0; i &lt; 4; ++i)&#123; if(parts[i] == 0) continue; s = helper(parts[i]) + unit[i] + s; &#125; s = s.size() ? s.substr(1) : &quot;Zero&quot;; return s;&#125; https://discuss.leetcode.com/topic/22959/short-clean-c-code-with-explanation Short clean C++ code, with explanation Function hundredStr() produces a string from integer less than 100. And in numberToWords() it uses a for loop to set “Thousand”,”Million”,”Billion”. 1234567891011121314151617181920212223class Solution &#123;public: string hundredStr(int num)&#123; vector&lt;string&gt; arr1=&#123;&quot;&quot;,&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;,&quot;Four&quot;,&quot;Five&quot;,&quot;Six&quot;,&quot;Seven&quot;,&quot;Eight&quot;,&quot;Nine&quot;,&quot;Ten&quot;, &quot;Eleven&quot;,&quot;Twelve&quot;,&quot;Thirteen&quot;,&quot;Fourteen&quot;,&quot;Fifteen&quot;,&quot;Sixteen&quot;,&quot;Seventeen&quot;,&quot;Eighteen&quot;,&quot;Nineteen&quot;&#125;; vector&lt;string&gt; arr2=&#123;&quot;&quot;,&quot;&quot;,&quot;Twenty&quot;,&quot;Thirty&quot;,&quot;Forty&quot;,&quot;Fifty&quot;,&quot;Sixty&quot;,&quot;Seventy&quot;,&quot;Eighty&quot;,&quot;Ninety&quot;&#125;; string ret; ret=num%100&lt;20?arr1[num%100]:arr2[(num%100)/10]+(num%10?&quot; &quot;+arr1[num%10]:&quot;&quot;); if(num&gt;99)ret=arr1[num/100]+&quot; Hundred&quot;+(num%100?&quot; &quot;+ret:&quot;&quot;); return ret; &#125; string numberToWords(int num) &#123; string ret; vector&lt;string&gt; strarr=&#123;&quot;Thousand&quot;,&quot;Million&quot;,&quot;Billion&quot;&#125;; ret=hundredStr(num%1000); for(int i=0;i&lt;3;i++)&#123; num/=1000; ret=num%1000?hundredStr(num%1000)+&quot; &quot;+strarr[i]+&quot; &quot;+ ret:ret; &#125; while(ret.back()==&apos; &apos;)ret.pop_back(); return ret.empty()?&quot;Zero&quot;:ret; &#125;&#125;; https://discuss.leetcode.com/topic/23061/recursive-python Recursive Python 123456789101112131415def numberToWords(self, num): to19 = &apos;One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve &apos; \ &apos;Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen&apos;.split() tens = &apos;Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety&apos;.split() def words(n): if n &lt; 20: return to19[n-1:n] if n &lt; 100: return [tens[n/10-2]] + words(n%10) if n &lt; 1000: return [to19[n/100-1]] + [&apos;Hundred&apos;] + words(n%100) for p, w in enumerate((&apos;Thousand&apos;, &apos;Million&apos;, &apos;Billion&apos;), 1): if n &lt; 1000**(p+1): return words(n/1000**p) + [w] + words(n%1000**p) return &apos; &apos;.join(words(num)) or &apos;Zero&apos; https://discuss.leetcode.com/topic/39814/python-clean-solution Python Clean Solution 123456789101112131415161718192021222324def __init__(self): self.lessThan20 = [&quot;&quot;,&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;,&quot;Four&quot;,&quot;Five&quot;,&quot;Six&quot;,&quot;Seven&quot;,&quot;Eight&quot;,&quot;Nine&quot;,&quot;Ten&quot;,&quot;Eleven&quot;,&quot;Twelve&quot;,&quot;Thirteen&quot;,&quot;Fourteen&quot;,&quot;Fifteen&quot;,&quot;Sixteen&quot;,&quot;Seventeen&quot;,&quot;Eighteen&quot;,&quot;Nineteen&quot;] self.tens = [&quot;&quot;,&quot;Ten&quot;,&quot;Twenty&quot;,&quot;Thirty&quot;,&quot;Forty&quot;,&quot;Fifty&quot;,&quot;Sixty&quot;,&quot;Seventy&quot;,&quot;Eighty&quot;,&quot;Ninety&quot;] self.thousands = [&quot;&quot;,&quot;Thousand&quot;,&quot;Million&quot;,&quot;Billion&quot;]def numberToWords(self, num): if num == 0: return &quot;Zero&quot; res = &quot;&quot; for i in range(len(self.thousands)): if num % 1000 != 0: res = self.helper(num%1000) + self.thousands[i] + &quot; &quot; + res num /= 1000 return res.strip()def helper(self, num): if num == 0: return &quot;&quot; elif num &lt; 20: return self.lessThan20[num] + &quot; &quot; elif num &lt; 100: return self.tens[num/10] + &quot; &quot; + self.helper(num%10) else: return self.lessThan20[num/100] + &quot; Hundred &quot; + self.helper(num%100) 8ms, 26.68%, 17 July 2016 https://discuss.leetcode.com/topic/49124/the-simplest-recursive-solution-ever-yet-efficient-enough-in-c 123456789101112131415class Solution &#123;private: const vector&lt;string&gt; numerals&#123;&quot;Billion&quot;, &quot;Million&quot;, &quot;Thousand&quot;, &quot;Hundred&quot;, &quot;Ninety&quot;,&quot;Eighty&quot;, &quot;Seventy&quot;,&quot;Sixty&quot;, &quot;Fifty&quot;, &quot;Forty&quot;, &quot;Thirty&quot;, &quot;Twenty&quot;, &quot;Nineteen&quot;, &quot;Eighteen&quot;, &quot;Seventeen&quot;, &quot;Sixteen&quot;, &quot;Fifteen&quot;, &quot;Fourteen&quot;, &quot;Thirteen&quot;, &quot;Twelve&quot;,&quot;Eleven&quot;, &quot;Ten&quot;,&quot;Nine&quot;, &quot;Eight&quot;, &quot;Seven&quot;, &quot;Six&quot;, &quot;Five&quot;, &quot;Four&quot;, &quot;Three&quot;,&quot;Two&quot;, &quot;One&quot;&#125;; const vector&lt;int&gt; units = &#123;1000000000, 1000000, 1000, 100, 90, 80, 70, 60,50, 40,30,20,19, 18, 17, 16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1&#125;;public: string numberToWords(int num) &#123; if(num == 0) return &quot;Zero&quot;; int i = 0; for(; num &lt; units[i]; ++i) ; int upper = num/units[i]; int lower = num%units[i]; return (i&lt;4? numberToWords(upper) + &quot; &quot; : &quot;&quot;) + numerals[i] + (lower? &quot; &quot; + numberToWords(lower) : &quot;&quot;); &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>string</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[268. Missing Number]]></title>
    <url>%2Fp%2F4176e3e5%2F</url>
    <content type="text"><![CDATA[43.9% https://leetcode.com/problems/missing-number/#/description Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. 12For example,Given nums = [0, 1, 3] return 2. Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? 方法一： 位运算 美团面试遇到过 我的代码实现： 123456789101112class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int res = 0; for(int i=1; i&lt;=n; i++)&#123; res ^= nums[i-1]; res ^= i; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/22313/c-solution-using-bit-manipulation C++ solution using bit manipulation 123456789101112131415class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int result = nums.size(); int i=0; for(int num:nums)&#123; result ^= num; result ^= i; i++; &#125; return result; &#125;&#125;; There are several similar problems in the problem list. https://discuss.leetcode.com/topic/22305/1-lines-ruby-python-java-c 1+ lines Ruby, Python, Java, C++ Several different solutions, some with O(1) extra space, some with O(n). Sum of 0..n minus sum of the given numbers is the missing one. These only use O(1) extra space. Python 123def missingNumber(self, nums): n = len(nums) return n * (n+1) / 2 - sum(nums) Java 1234public int missingNumber(int[] nums) &#123; long n = nums.length; return (int) (n * (n+1) / 2 - IntStream.of(nums).sum());&#125; C++ 1234int missingNumber(vector&lt;int&gt;&amp; nums) &#123; long n = nums.size(); return n * (n+1) / 2 - accumulate(begin(nums), end(nums), 0);&#125; Using long for Java and C++ to prevent overflow (the n*(n+1) overflows ints already for n=46341, and then the /2 causes an actual wrong result). Xor-ing the given numbers and 0..n. These use O(n) extra space, but I like them anyway. Python 12def missingNumber(self, nums): return reduce(operator.xor, nums + range(len(nums)+1)) Xor-ing with O(1) space Saw this from ts before. Xoring 0..n results in [n, 1, n+1, 0][n % 4]. You can also spot the pattern by looking at xors of such ranges, and it’s easy to explain as well. Python 123def missingNumber(self, nums): n = len(nums) return reduce(operator.xor, nums) ^ [n, 1, n+1, 0][n % 4] Sum, without formula. Java and C++: 1234int miss = 0, i = 0;for (int num : nums) miss += ++i - num;return miss; In Java I believe this is safe, overflow might happen but not cause a wrong result (because another overflow will fix it). In C++ I believe it’s probably safe in the same way, except that that behavior isn’t defined in the standard(s) but is a de-facto standard anyway. In any case, I could just use 64-bit ints again to be safe. Set/array difference Don’t know about Ruby’s runtime, might not be linear. Python’s sets are hash sets and the difference is linear time on average. Don’t know about its worst case, and apparently neither does the TimeComplexity page. Python 12def missingNumber(self, nums): return (set(range(len(nums)+1)) - set(nums)).pop() https://discuss.leetcode.com/topic/25998/clear-c-solution-that-can-avoid-overflow Clear C++ solution that can avoid overflow 123456789class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int result = 0; for (int i = 0; i &lt; nums.size(); i++) result ^= nums[i]^(i+1); return result; &#125;&#125;; https://discuss.leetcode.com/topic/22366/simple-c-codes Simple C++ codes Using bit XOR operatons, just like the “find missing number (all elements except one occur twice, find the one that occurs once)” one The reason I didn’t use sum[1..n] - sum(nums) is that calculating sum has potential to cause overflow. XOR bit operation is much safer. 123456789class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int missing =0; for(int i=0; i&lt;nums.size();++i) missing ^= ((i+1)^nums[i]); return missing; &#125;&#125;; https://discuss.leetcode.com/topic/42439/1-line-python-solution 1 line Python Solution 123class Solution(object): def missingNumber(self, nums): return sum(range(len(nums)+1)) - sum(nums)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[264. Ugly Number II]]></title>
    <url>%2Fp%2Fff8ccd53%2F</url>
    <content type="text"><![CDATA[32.0% https://leetcode.com/problems/ugly-number-ii Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note that 1 is typically treated as an ugly number, and n does not exceed 1690. Hint: The naive approach is to call isUgly for every number until you reach the nth one. Most numbers are not ugly. Try to focus your effort on generating only the ugly ones. An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number. The key is how to maintain the order of the ugly numbers. Try a similar approach of merging from three sorted lists: L1, L2, and L3. Assume you have Uk, the kth ugly number. Then Uk+1 must be Min(L1 2, L2 3, L3 * 5). 方法一: my code： 123456789101112131415161718192021class Solution &#123;public: int nthUglyNumber(int n) &#123; if(n==1) return 1; vector&lt;int&gt; nums = &#123;1&#125;; int two=0, three=0, five=0; int i=1; while(i&lt;n)&#123; int cur = min(nums[five]*5, min(nums[three]*3, nums[two]*2)); nums.push_back(cur); if(cur==nums[two]*2) two++; if(cur==nums[three]*3) three++; if(cur==nums[five]*5) five++; i++; &#125; return nums[n-1]; &#125;&#125;; 我的代码实现： 123456789101112131415class Solution &#123;public: int nthUglyNumber(int n) &#123; vector&lt;int&gt; res(n, 1); int i2=0, i3=0, i5=0; for(int i=1; i&lt;n; i++)&#123; int cur = min(res[i2]*2, min(res[i3]*3, res[i5]*5)); res[i] = cur; if(res[i2]*2==cur) i2++; if(res[i3]*3==cur) i3++; if(res[i5]*5==cur) i5++; &#125; return res[n-1]; &#125;&#125;; 方法二: 36ms, 28.93%, May.3rd, 2016 https://leetcode.com/discuss/58186/elegant-c-solution-o-n-space-time-with-detailed-explanation 1234567891011121314class Solution &#123;public: int nthUglyNumber(int n) &#123; vector &lt;int&gt; results(1, 1); int i = 0, j = 0, k = 0; while(results.size() &lt; n)&#123; results.push_back(min(results[i] * 2, min(results[j] * 3, results[k] * 5))); if(results.back() == results[i] * 2) ++i; if(results.back() == results[j] * 3) ++j; if(results.back() == results[k] * 5) ++k; &#125; return results.back(); &#125;&#125;; cpp 20ms, 44.77%, May.3rd, 2016 123456789101112131415161718class Solution &#123;public: int nthUglyNumber(int n) &#123; if(n &lt;= 0) return false; // get rid of corner cases if(n == 1) return true; // base case int t2 = 0, t3 = 0, t5 = 0; //pointers for 2, 3, 5 vector&lt;int&gt; k(n); k[0] = 1; for(int i = 1; i &lt; n ; i ++) &#123; k[i] = min(k[t2]*2,min(k[t3]*3,k[t5]*5)); if(k[i] == k[t2]*2) t2++; if(k[i] == k[t3]*3) t3++; if(k[i] == k[t5]*5) t5++; &#125; return k[n-1]; &#125;&#125;; 20ms, 44.77%, May.3rd, 2016 https://leetcode.com/discuss/53225/c-one-pass-simple-solution 12345678910111213141516class Solution &#123;public: int nthUglyNumber(int n) &#123; if(n&lt;1) return 0; int id2 = 0, id3 = 0, id5 = 0, rst = 1; vector&lt;int&gt; buf; while(--n)&#123; buf.push_back(rst); int v2 = 2 * (buf[id2]), v3 = 3 * (buf[id3]), v5 = 5 * (buf[id5]); rst = min(v2, min(v3, v5)); id2 += (rst == v2), id3 += (rst == v3), id5 += (rst == v5); &#125; return rst; &#125;&#125;; python212ms, 67.75%, May.3rd, 2016 https://leetcode.com/discuss/57156/my-expressive-python-solution 1234567891011121314151617181920class Solution(object): def nthUglyNumber(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; ugly = [1] i2, i3, i5 = 0, 0, 0 while n &gt; 1: u2, u3, u5 = 2 * ugly[i2], 3 * ugly[i3], 5 * ugly[i5] umin = min((u2, u3, u5)) if umin == u2: i2 += 1 if umin == u3: i3 += 1 if umin == u5: i5 += 1 ugly.append(umin) n -= 1 return ugly[-1] javaThe idea of this solution is from this page:http://www.geeksforgeeks.org/ugly-numbers/ The ugly-number sequence is 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, …because every number can only be divided by 2, 3, 5, one way to look at the sequence is to split the sequence to three groups as below: 123(1) 1×2, 2×2, 3×2, 4×2, 5×2, …(2) 1×3, 2×3, 3×3, 4×3, 5×3, …(3) 1×5, 2×5, 3×5, 4×5, 5×5, … We can find that every subsequence is the ugly-sequence itself (1, 2, 3, 4, 5, …) multiply 2, 3, 5. Then we use similar merge method as merge sort, to get every ugly number from the three subsequence. Every step we choose the smallest one, and move one step after,including nums with same value. Thanks for this author about this brilliant idea. Here is my java solution 12345678910111213141516171819public class Solution &#123; public int nthUglyNumber(int n) &#123; int[] ugly = new int[n]; ugly[0] = 1; int index2 = 0, index3 = 0, index5 = 0; int factor2 = 2, factor3 = 3, factor5 = 5; for(int i=1;i&lt;n;i++)&#123; int min = Math.min(Math.min(factor2,factor3),factor5); ugly[i] = min; if(factor2 == min) factor2 = 2*ugly[++index2]; if(factor3 == min) factor3 = 3*ugly[++index3]; if(factor5 == min) factor5 = 5*ugly[++index5]; &#125; return ugly[n-1]; &#125;&#125; my code 12345678910111213141516171819public class Solution &#123; public int nthUglyNumber(int n) &#123; int i=0, j=0, k=0; int[] ugly = new int[n]; ugly[0] = 1; int idx=0; for(int l=1; l&lt;n; l++)&#123; int min = Math.min(ugly[i]*2, Math.min(ugly[j]*3, ugly[k]*5)); ugly[l] = min; if(min==ugly[i]*2) i++; if(min==ugly[j]*3) j++; if(min==ugly[k]*5) k++; &#125; return ugly[n-1]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[263. Ugly Number]]></title>
    <url>%2Fp%2F2e99b71d%2F</url>
    <content type="text"><![CDATA[38.7% https://leetcode.com/problems/ugly-number/#/description Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. Credits: 考虑要周全，题目要求丑数必须为正数，所以先除掉小于0的数字，不要忘了。 num%2 num&amp;1 num/2 num&gt;&gt;1 除以2的时候，尽量用位运算代替，效率较高 方法一： c / c++1234for (int i=2; i&lt;6 &amp;&amp; num; i++) while (num % i == 0) num /= i;return num == 1; 方法二： 8ms, 5.25%, May.2nd, 2016 https://leetcode.com/discuss/55542/4ms-short-c-solution 1234567891011class Solution &#123;public: bool isUgly(int num) &#123; if(num == 1) return true; if(num &lt;= 0) return false; while(num % 2 == 0) num /= 2; while(num % 3 == 0) num /= 3; while(num % 5 == 0) num /= 5; return num == 1; &#125;&#125;; 我的代码实现： 12345678910111213class Solution &#123;public: bool isUgly(int num) &#123; if(num&lt;=0) return false; while(num%2==0) num /= 2; while(num%3==0) num /= 3; while(num%5==0) num /= 5; return num==1; &#125;&#125;; 方法三： 8ms, 5.25%, May.2nd, 2016 https://leetcode.com/discuss/52703/2-4-lines-every-language 123456789class Solution &#123;public: bool isUgly(int num) &#123; for(int i=2; i&lt;6 &amp;&amp; num; i++) while(num % i == 0) num /= i; return num == 1; &#125;&#125;; python https://discuss.leetcode.com/topic/27421/my-python-solution 1234567891011def isUgly(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; if num &lt;= 0: return False for x in [2, 3, 5]: while num % x == 0: num = num / x return num == 1 Mine Solution: 64ms, 22.53%, May.2nd, 2016 123456789101112131415class Solution(object): def isUgly(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; if num &lt;= 0: return False while not (num % 2): num = num / 2 while not (num % 3): num = num / 3 while not (num % 5): num = num / 5 return True if num == 1 else False Solution 1: 68ms, 14.68%, May.2nd, 2016 https://leetcode.com/discuss/52703/2-4-lines-every-language 12345678910class Solution(object): def isUgly(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; for p in 2, 3, 5: while num % p == 0 &lt; num: num /= p return num == 1 Solution 2: 68ms, 14.68%, May.2nd, 2016 https://leetcode.com/discuss/97377/python-1-line-solution 12345678class Solution(object): def isUgly(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; #n = (2**30)*(3**20)*(5**13) = 4570198050078720000000000000L return False if num &lt; 1 or (4570198050078720000000000000L)%num != 0 else True Solution 3: 80ms, 4.65%, May.2nd, 2016 https://leetcode.com/discuss/64640/my-python-solution 123456789101112class Solution(object): def isUgly(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; if num &lt;= 0: return False for x in [2, 3, 5]: while num % x == 0: num /= x return num == 1 javahttps://discuss.leetcode.com/topic/25616/my-2ms-java-solution12345678public boolean isUgly(int num) &#123; if(num==1) return true; if(num==0) return false; while(num%2==0) num=num&gt;&gt;1; while(num%3==0) num=num/3; while(num%5==0) num=num/5; return num==1;&#125; https://discuss.leetcode.com/topic/21873/simple-java-solution-with-explanation idea: (1) basic cases: &lt;= 0 and == 1 (2) other cases: since the number can contain the factors of 2, 3, 5, I just remove those factors. So now, I have a number without any factors of 2, 3, 5. (3) after the removing, the number (new number) can contain a) the factor that is prime and meanwhile it is &gt;= 7, or b) the factor that is not the prime and the factor is not comprised of 2, 3 or 5. In both cases, it is false (not ugly number). For example, new number can be 11, 23 –&gt; not ugly number (case a)). new number also can be 49, 121 –&gt; not ugly number (case b)) 1234567891011121314public boolean isUgly(int num) &#123; if (num &lt;= 0) &#123;return false;&#125; if (num == 1) &#123;return true;&#125; if (num % 2 == 0) &#123; return isUgly(num/2); &#125; if (num % 3 == 0) &#123; return isUgly(num/3); &#125; if (num % 5 == 0) &#123; return isUgly(num/5); &#125; return false;&#125; https://discuss.leetcode.com/topic/33389/java-solution-greatest-divide-by-2-3-5 clean solution to greatest divide the num using 2, 3, and 5.12345678910111213141516public class Solution &#123; public static boolean isUgly(int num) &#123; if (num &lt;= 0) &#123; return false; &#125; int[] divisors = &#123;2, 3, 5&#125;; for(int d : divisors) &#123; while (num % d == 0) &#123; num /= d; &#125; &#125; return num == 1; &#125;&#125; my code: 123456789101112public class Solution &#123; public boolean isUgly(int num) &#123; if(num&lt;=0) return false; while(num%2 == 0) num /= 2; while(num%3 == 0) num /= 3; while(num%5 == 0) num /= 5; return num==1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[260. Single Number III]]></title>
    <url>%2Fp%2Fc6227aad%2F</url>
    <content type="text"><![CDATA[49.9% https://leetcode.com/problems/single-number-iii/?tab=Description Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. 123For example:Given nums = [1, 2, 1, 3, 2, 5], return [3, 5]. Note: The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity? 剑指offer 40 方法一： 求第一位非0， diff &amp;= -diff. -diff求的相反的数字，存储是补码， 取反加1. diff = 110 diff &amp; (-diff） = 010 https://discuss.leetcode.com/topic/21605/accepted-c-java-o-n-time-o-1-space-easy-solution-with-detail-explanations Accepted C++/Java O(n)-time O(1)-space Easy Solution with Detail Explanations Once again, we need to use XOR to solve this problem. But this time, we need to do it in two passes: In the first pass, we XOR all elements in the array, and get the XOR of the two numbers we need to find. Note that since the two numbers are distinct, so there must be a set bit (that is, the bit with value ‘1’) in the XOR result. Find out an arbitrary set bit (for example, the rightmost set bit). In the second pass, we divide all numbers into two groups, one with the aforementioned bit set, another with the aforementinoed bit unset. Two different numbers we need to find must fall into thte two distrinct groups. XOR numbers in each group, we can find a number in either group. Complexity: Time: O (n) Space: O (1) A Corner Case: When diff == numeric_limits::min(), -diff is also numeric_limits::min(). Therefore, the value of diff after executing diff &amp;= -diff is still numeric_limits::min(). The answer is still correct.C++: 123456789101112131415161718192021222324252627class Solution&#123;public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; // Pass 1 : // Get the XOR of the two numbers we need to find int diff = accumulate(nums.begin(), nums.end(), 0, bit_xor&lt;int&gt;()); // Get its last set bit diff &amp;= -diff; // Pass 2 : vector&lt;int&gt; rets = &#123;0, 0&#125;; // this vector stores the two numbers we will return for (int num : nums) &#123; if ((num &amp; diff) == 0) // the bit is not set &#123; rets[0] ^= num; &#125; else // the bit is set &#123; rets[1] ^= num; &#125; &#125; return rets; &#125;&#125;; 我的代码实现： 注意用&amp;还是用^ 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; int flag = 0; for(auto num:nums) flag ^= num; flag = flag&amp;-flag; int num1 = 0, num2 = 0; for(auto num:nums)&#123; if(num&amp;flag) num1 ^= num; else num2 ^= num; &#125; res.push_back(num1); res.push_back(num2); return res; &#125;&#125;; Thanks for reading :) Acknowledgements: Thank @jianchao.li.fighter for introducing this problem and for your encouragement. Thank @StefanPochmann for your valuable suggestions and comments. Your idea of diff &amp;= -diff is very elegent! And yes, it does not need to XOR for both group in the second pass. XOR for one group suffices. I revise my code accordingly. Thank @Nakagawa_Kanon for posting this question and presenting the same idea in a previous thread (prior to this thread). Thank @caijun for providing an interesting test case. 方法二： int lastBit = (aXorb &amp; (aXorb - 1)) ^ aXorb; https://discuss.leetcode.com/topic/21984/c-solution-o-n-time-and-o-1-space-easy-understaning-with-simple-explanation C++ solution O(n) time and O(1) space, easy-understaning with simple explanation 123456789101112vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; int aXorb = 0; // the result of a xor b; for (auto item : nums) aXorb ^= item; int lastBit = (aXorb &amp; (aXorb - 1)) ^ aXorb; // the last bit that a diffs b int intA = 0, intB = 0; for (auto item : nums) &#123; // based on the last bit, group the items into groupA(include a) and groupB if (item &amp; lastBit) intA = intA ^ item; else intB = intB ^ item; &#125; return vector&lt;int&gt;&#123;intA, intB&#125;; &#125; https://discuss.leetcode.com/topic/25382/sharing-explanation-of-the-solution Sharing explanation of the solution If you were stuck by this problem, it’s easy to find a solution in the discussion. However, usually, the solution lacks some explanations. I’m sharing my understanding here: The two numbers that appear only once must differ at some bit, this is how we can distinguish between them. Otherwise, they will be one of the duplicate numbers. One important point is that by XORing all the numbers, we actually get the XOR of the two target numbers (because XORing two duplicate numbers always results in 0). Consider the XOR result of the two target numbers; if some bit of the XOR result is 1, it means that the two target numbers differ at that location. Let’s say the at the ith bit, the two desired numbers differ from each other. which means one number has bit i equaling: 0, the other number has bit i equaling 1. Thus, all the numbers can be partitioned into two groups according to their bits at location i.the first group consists of all numbers whose bits at i is 0.the second group consists of all numbers whose bits at i is 1. Notice that, if a duplicate number has bit i as 0, then, two copies of it will belong to the first group. Similarly, if a duplicate number has bit i as 1, then, two copies of it will belong to the second group. by XoRing all numbers in the first group, we can get the first number. by XoRing all numbers in the second group, we can get the second number. https://discuss.leetcode.com/topic/43805/bit-manipulation-beats-99-62 Bit manipulation beats 99.62% Find the rightmost set bit, divide numbers into two groups. Each group will end up being one unique number. 12345678910111213141516171819202122232425262728public int[] singleNumber(int[] nums) &#123; int result[] = new int[2]; int xor = nums[0]; for (int i=1; i&lt;nums.length; i++) &#123; xor ^= nums[i]; &#125; int bit = xor &amp; ~(xor-1); int num1 = 0; int num2 = 0; for (int num : nums) &#123; if ((num &amp; bit) &gt; 0) &#123; num1 ^= num; &#125; else &#123; num2 ^= num; &#125; &#125; result[0] = num1; result[1] = num2; return result;&#125; https://discuss.leetcode.com/topic/34545/share-my-c-solution Share my C++ solution, assume that A and B are the two elements which we want to find; use XOR for all elements,the result is : r = A^B,we just need to distinguish A from B next step; if we can find a bit ‘1’ in r,then the bit in corresponding position in A and B must be different.We can use {last = r &amp; (~(r-1))} to get the last bit 1 int r; we use last to divide all numbers into two groups,then A and B must fall into the two distrinct groups.XOR elements in eash group,get the A and B. 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; int r = 0, n = nums.size(), i = 0, last = 0; vector&lt;int&gt; ret(2, 0); for (i = 0; i &lt; n; ++i) r ^= nums[i]; last = r &amp; (~(r - 1)); for (i = 0; i &lt; n; ++i) &#123; if ((last &amp; nums[i]) != 0) ret[0] ^= nums[i]; else ret[1] ^= nums[i]; &#125; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/21883/my-java-solution-adapted-from-the-commonest-solution-here My Java solution adapted from the commonest solution here I read @zhiqing_xiao ‘s post to get an idea about the solution. His solution is really smart and elegant, but it took me a while to get understand how “diff &amp;= -diff” works. I changed it a little bit to make it better understood, but it is totally based on his solution. Instead of using the right-most “1” of diff, I used the left-most “1” to divide groups. This should also do the trick. 123456789101112131415161718192021public class Solution &#123; public int[] singleNumber(int[] nums) &#123; int diff = 0; for(int num: nums)&#123; diff^=num; &#125; diff = Integer.highestOneBit(diff); int[] result = new int[2]; Arrays.fill(result,0); for(int num: nums)&#123; if((diff &amp; num) == 0)&#123; result[0] ^= num; &#125; else&#123; result[1] ^= num; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[258. Add Digits]]></title>
    <url>%2Fp%2F3ec955c1%2F</url>
    <content type="text"><![CDATA[50.6% Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. 123For example:Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime? Hint: A naive implementation of the above process is trivial. Could you come up with other methods? What are all the possible results? How do they occur, periodically or randomly? You may find this Wikipedia article useful. https://discuss.leetcode.com/topic/21498/accepted-c-o-1-time-o-1-space-1-line-solution-with-detail-explanations/2 Accepted C++ O(1)-time O(1)-space 1-Line Solution with Detail Explanations The problem, widely known as digit root problem, has a congruence formula: https://en.wikipedia.org/wiki/Digital_root#Congruence_formula For base b (decimal case b = 10), the digit root of an integer is: dr(n) = 0 if n == 0 dr(n) = (b-1) if n != 0 and n % (b-1) == 0 dr(n) = n mod (b-1) if n % (b-1) != 0 or dr(n) = 1 + (n - 1) % 9 Note here, when n = 0, since (n - 1) % 9 = -1, the return value is zero (correct). From the formula, we can find that the result of this problem is immanently periodic, with period (b-1). Output sequence for decimals (b = 10): ~ input: 0 1 2 3 4 … output: 0 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 …. Henceforth, we can write the following code, whose time and space complexities are both O(1). 123456class Solution &#123;public: int addDigits(int num) &#123; return 1 + (num - 1) % 9; &#125;&#125;; Thanks for reading. :) https://discuss.leetcode.com/topic/36921/c-3-lines-implementation C++ 3 lines implementation 12345678class Solution &#123;public: int addDigits(int num) &#123; if(num%9 == 0 &amp;&amp; num!=0) return 9; return (num%9); &#125;&#125;; https://discuss.leetcode.com/topic/28791/3-methods-for-python-with-explains 3 methods for python with explains Iteration method 12345678910111213class Solution(object):def addDigits(self, num):&quot;&quot;&quot;:type num: int:rtype: int&quot;&quot;&quot;while(num &gt;= 10): temp = 0 while(num &gt; 0): temp += num % 10 num /= 10 num = tempreturn num Digital Rootthis method depends on the truth: N=(a[0] 1 + a[1] 10 + …a[n] * 10 ^n),and a[0]…a[n] are all between [0,9] we set M = a[0] + a[1] + ..a[n] and another truth is that: 1 % 9 = 1 10 % 9 = 1 100 % 9 = 1 so N % 9 = a[0] + a[1] + ..a[n] means N % 9 = M so N = M (% 9) as 9 % 9 = 0,so we can make (n - 1) % 9 + 1 to help us solve the problem when n is 9.as N is 9, ( 9 - 1) % 9 + 1 = 9 12345678class Solution(object):def addDigits(self, num): &quot;&quot;&quot; :type num: int :rtype: int &quot;&quot;&quot; if num == 0 : return 0 else:return (num - 1) % 9 + 1 https://discuss.leetcode.com/topic/21834/o-1-solution-with-mod-operation O(1) solution with mod operation If an integer is like 100a+10b+c, then (100a+10b+c)%9=(a+99a+b+9b+c)%9=(a+b+c)%9 1234567class Solution: # @param &#123;integer&#125; num # @return &#123;integer&#125; def addDigits(self, num): if num==0: return 0 return num%9 if num%9!=0 else 9 https://discuss.leetcode.com/topic/30490/no-loop-recursion-o-1-runtime-just-one-line-python-code No loop/recursion, O(1) runtime, just one line python code 123class Solution(object): def addDigits(self, num): return num if num == 0 else num % 9 or 9]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[257. Binary Tree Paths]]></title>
    <url>%2Fp%2F900d76e0%2F</url>
    <content type="text"><![CDATA[36.4% Given a binary tree, return all root-to-leaf paths. 12345678910For example, given the following binary tree: 1 / \2 3 \ 5All root-to-leaf paths are:[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;] 方法一； https://discuss.leetcode.com/topic/21447/c-simple-4ms-recursive-solution C++ simple 4ms recursive solution 1234567891011121314151617void binaryTreePaths(vector&lt;string&gt;&amp; result, TreeNode* root, string t) &#123; if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123; result.push_back(t); return; &#125; if(root-&gt;left) binaryTreePaths(result, root-&gt;left, t + &quot;-&gt;&quot; + to_string(root-&gt;left-&gt;val)); if(root-&gt;right) binaryTreePaths(result, root-&gt;right, t + &quot;-&gt;&quot; + to_string(root-&gt;right-&gt;val));&#125;vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; result; if(!root) return result; binaryTreePaths(result, root, to_string(root-&gt;val)); return result;&#125; 方法二： 我的代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; res; if(!root) return res; vector&lt;int&gt; s = &#123;root-&gt;val&#125;; helper(root, res, s); return res; &#125; void helper(TreeNode* root, vector&lt;string&gt;&amp; res, vector&lt;int&gt;&amp; s)&#123; if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123; string t = to_string(s[0]); for(int i=1; i&lt;s.size(); i++) t += "-&gt;" + to_string(s[i]); res.push_back(t); return; &#125; if(root-&gt;left)&#123; s.push_back(root-&gt;left-&gt;val); helper(root-&gt;left, res, s); s.pop_back(); &#125; if(root-&gt;right)&#123; s.push_back(root-&gt;right-&gt;val); helper(root-&gt;right, res, s); s.pop_back(); &#125; s.pop_back(); &#125;&#125;; https://discuss.leetcode.com/topic/22133/my-java-and-c-solution-c-4ms My java and c++ solution,c++ 4ms this is a simple dfs+tree question,using preorder to visit tree will be fine. c++: 1234567891011121314151617181920212223class Solution &#123; public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; v; if(root) preorder(v,root,&quot;&quot;); return v; &#125; void preorder(vector&lt;string&gt;&amp; v,TreeNode* r,string t)&#123; if(!r) return; if(!t.empty()) t+=(&quot;-&gt;&quot;+to_string(r-&gt;val)); else t+=to_string(r-&gt;val); if(r-&gt;left||r-&gt;right)&#123; preorder(v,r-&gt;left,t); preorder(v,r-&gt;right,t); &#125;else&#123; v.push_back(t); &#125; &#125; &#125;; my java: 12345678910111213141516171819public class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; l=new ArrayList&lt;&gt;(); if(root!=null) pre(l,root,&quot;&quot;); return l; &#125; void pre(List&lt;String&gt; l,TreeNode r,String s)&#123; if(r==null)return; if(s.isEmpty()) s+=r.val; else s+=(&quot;-&gt;&quot;+r.val); if(r.left!=null||r.right!=null)&#123; pre(l,r.left,s); pre(l,r.right,s); &#125;else l.add(s); &#125;&#125; https://discuss.leetcode.com/topic/21559/python-solutions-dfs-stack-bfs-queue-dfs-recursively Python solutions (dfs+stack, bfs+queue, dfs recursively). 1234567891011121314# dfs + stackdef binaryTreePaths1(self, root): if not root: return [] res, stack = [], [(root, &quot;&quot;)] while stack: node, ls = stack.pop() if not node.left and not node.right: res.append(ls+str(node.val)) if node.right: stack.append((node.right, ls+str(node.val)+&quot;-&gt;&quot;)) if node.left: stack.append((node.left, ls+str(node.val)+&quot;-&gt;&quot;)) return res 1234567891011121314# bfs + queuedef binaryTreePaths2(self, root): if not root: return [] res, queue = [], collections.deque([(root, &quot;&quot;)]) while queue: node, ls = queue.popleft() if not node.left and not node.right: res.append(ls+str(node.val)) if node.left: queue.append((node.left, ls+str(node.val)+&quot;-&gt;&quot;)) if node.right: queue.append((node.right, ls+str(node.val)+&quot;-&gt;&quot;)) return res 123456789101112131415# dfs recursivelydef binaryTreePaths(self, root): if not root: return [] res = [] self.dfs(root, &quot;&quot;, res) return resdef dfs(self, root, ls, res): if not root.left and not root.right: res.append(ls+str(root.val)) if root.left: self.dfs(root.left, ls+str(root.val)+&quot;-&gt;&quot;, res) if root.right: self.dfs(root.right, ls+str(root.val)+&quot;-&gt;&quot;, res) 48ms, 64.24%, May.3rd, 2016 https://leetcode.com/discuss/52020/5-lines-recursive-python 5 lines recursive Python 123456def binaryTreePaths(self, root): if not root: return [] return [str(root.val) + &apos;-&gt;&apos; + path for kid in (root.left, root.right) if kid for path in self.binaryTreePaths(kid)] or [str(root.val)] 69ms, 5.30%, 209 / 209, May.3rd, 2016 https://leetcode.com/discuss/59288/8-lines-in-python-48ms 8 lines in python,48ms 12345678def binaryTreePaths(self, root): if not root: return [] if not root.left and not root.right: return [str(root.val)] treepaths = [str(root.val)+&apos;-&gt;&apos;+path for path in self.binaryTreePaths(root.left)] treepaths += [str(root.val)+&apos;-&gt;&apos;+path for path in self.binaryTreePaths(root.right)] return treepaths]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[242. Valid Anagram]]></title>
    <url>%2Fp%2Fda56d9f0%2F</url>
    <content type="text"><![CDATA[45.4% https://leetcode.com/problems/valid-anagram/?tab=Description Given two strings s and t, write a function to determine if t is an anagram of s. 123For example,s = &quot;anagram&quot;, t = &quot;nagaram&quot;, return true.s = &quot;rat&quot;, t = &quot;car&quot;, return false. Note: You may assume the string contains only lowercase alphabets. https://discuss.leetcode.com/topic/20303/2-c-solutions-with-explanations 2 C++ Solutions with Explanations 方法一: Hash Table This idea uses a hash table to record the times of appearances of each letter in the two strings s and t. For each letter in s, it increases the counter by 1 while for each letter in t, it decreases the counter by 1. Finally, all the counters will be 0 if they two are anagrams of each other. The first implementation uses the built-in unordered_map and takes 36 ms. 123456789101112131415class Solution &#123;public: bool isAnagram(string s, string t) &#123; if (s.length() != t.length()) return false; int n = s.length(); unordered_map&lt;char, int&gt; counts; for (int i = 0; i &lt; n; i++) &#123; counts[s[i]]++; counts[t[i]]--; &#125; for (auto count : counts) if (count.second) return false; return true; &#125;&#125;; 方法二： Since the problem statement says that “the string contains only lowercase alphabets”, we can simply use an array to simulate the unordered_map and speed up the code. The following implementation takes 12 ms. 123456789101112131415class Solution &#123;public: bool isAnagram(string s, string t) &#123; if (s.length() != t.length()) return false; int n = s.length(); int counts[26] = &#123;0&#125;; for (int i = 0; i &lt; n; i++) &#123; counts[s[i] - &apos;a&apos;]++; counts[t[i] - &apos;a&apos;]--; &#125; for (int i = 0; i &lt; 26; i++) if (counts[i]) return false; return true; &#125;&#125;; 我的实现： 1234567891011121314151617class Solution &#123;public: bool isAnagram(string s, string t) &#123; int m = s.size(); int n = t.size(); if(n&lt;m) return false; vector&lt;int&gt; tmp(26, 0); for(auto str:s) tmp[str-&apos;a&apos;]++; for(auto str:t)&#123; if(tmp[str-&apos;a&apos;]--==0) return false; &#125; return true; &#125;&#125;; 方法三： Sorting For two anagrams, once they are sorted in a fixed order, they will become the same. This code is much shorter (this idea can be done in just 1 line using Python as here). However, it takes much longer time — 76 ms in C++. 12345678class Solution &#123;public: bool isAnagram(string s, string t) &#123; sort(s.begin(), s.end()); sort(t.begin(), t.end()); return s == t; &#125;&#125;; https://discuss.leetcode.com/topic/20831/python-solutions-sort-and-dictionary Python solutions (sort and dictionary). 1234567def isAnagram1(self, s, t): dic1, dic2 = &#123;&#125;, &#123;&#125; for item in s: dic1[item] = dic1.get(item, 0) + 1 for item in t: dic2[item] = dic2.get(item, 0) + 1 return dic1 == dic2 1234567def isAnagram2(self, s, t): dic1, dic2 = [0]*26, [0]*26 for item in s: dic1[ord(item)-ord(&apos;a&apos;)] += 1 for item in t: dic2[ord(item)-ord(&apos;a&apos;)] += 1 return dic1 == dic2 12def isAnagram3(self, s, t): return sorted(s) == sorted(t) https://discuss.leetcode.com/topic/23973/0ms-c-solution-o-n-time 0ms C++solution,O(n)time 1234567891011bool isAnagram(string s, string t) &#123; int alp[26]=&#123;&#125;; for (int i = 0; i &lt; s.length(); i++) alp[s.at(i) - &apos;a&apos;]++; for (int i = 0; i &lt; t.length(); i++) alp[t.at(i) - &apos;a&apos;]--; for (int i=0;i&lt;26;i++) if (alp[i] != 0) return false; return true;&#125; https://discuss.leetcode.com/topic/20485/share-my-java-solution Share my java solution 123456789101112131415161718public class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length()!=t.length())&#123; return false; &#125; int[] count = new int[26]; for(int i=0;i&lt;s.length();i++)&#123; count[s.charAt(i)-&apos;a&apos;]++; count[t.charAt(i)-&apos;a&apos;]--; &#125; for(int i:count)&#123; if(i!=0)&#123; return false; &#125; &#125; return true; &#125;&#125; https://discuss.leetcode.com/topic/20314/accepted-java-o-n-solution-in-5-lines Accepted Java O(n) solution in 5 lines The idea is simple. It creates a size 26 int arrays as buckets for each letter in alphabet. It increments the bucket value with String s and decrement with string t. So if they are anagrams, all buckets should remain with initial value which is zero. So just checking that and return 123456789public class Solution &#123; public boolean isAnagram(String s, String t) &#123; int[] alphabet = new int[26]; for (int i = 0; i &lt; s.length(); i++) alphabet[s.charAt(i) - &apos;a&apos;]++; for (int i = 0; i &lt; t.length(); i++) alphabet[t.charAt(i) - &apos;a&apos;]--; for (int i : alphabet) if (i != 0) return false; return true; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[241. Different Ways to Add Parentheses]]></title>
    <url>%2Fp%2F58bae46e%2F</url>
    <content type="text"><![CDATA[42.2% https://leetcode.com/problems/different-ways-to-add-parentheses/#/description Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. 123456Example 1Input: &quot;2-1-1&quot;.((2-1)-1) = 0(2-(1-1)) = 2Output: [0, 2] 123456789Example 2Input: &quot;2*3-4*5&quot;(2*(3-(4*5))) = -34((2*3)-(4*5)) = -14((2*(3-4))*5) = -10(2*((3-4)*5)) = -10(((2*3)-4)*5) = 10Output: [-34, -14, -10, -10, 10] https://discuss.leetcode.com/topic/19906/c-4ms-recursive-dp-solution-with-brief-explanation 方法一： C++ 4ms Recursive &amp; DP solution with brief explanation Here is the basic recursive solution 一个是分治法 学习一下atoi(input.c_str())， atoi函数Convert string to integer substr(0, i) 0表示开始位置的index，i表示开index开始后的个数。 substr(i+1)，表示从i+1开始至字符串结尾。 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; result; int size = input.size(); for (int i = 0; i &lt; size; i++) &#123; char cur = input[i]; if (cur == &apos;+&apos; || cur == &apos;-&apos; || cur == &apos;*&apos;) &#123; // Split input string into two parts and solve them recursively vector&lt;int&gt; result1 = diffWaysToCompute(input.substr(0, i)); vector&lt;int&gt; result2 = diffWaysToCompute(input.substr(i+1)); for (auto n1 : result1) &#123; for (auto n2 : result2) &#123; if (cur == &apos;+&apos;) result.push_back(n1 + n2); else if (cur == &apos;-&apos;) result.push_back(n1 - n2); else result.push_back(n1 * n2); &#125; &#125; &#125; &#125; // if the input string contains only number，这种情况要考虑到 if (result.empty()) result.push_back(atoi(input.c_str())); return result; &#125;&#125;; 方法二： 类似于分治法，但是用到了dp，保存部分结果到一个map里，方便查询，节约了计算。 There are many repeating subquestions in this recursive method, therefore, we could use dynamic programming to avoid this situation by saving the results for subquestions. Here is the DP solution. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; unordered_map&lt;string, vector&lt;int&gt;&gt; dpMap; // 注意此处map的定义，key为string，value为vector&lt;int&gt; return computeWithDP(input, dpMap); &#125; vector&lt;int&gt; computeWithDP(string input, unordered_map&lt;string, vector&lt;int&gt;&gt; &amp;dpMap) &#123; vector&lt;int&gt; result; int size = input.size(); for (int i = 0; i &lt; size; i++) &#123; char cur = input[i]; if (cur == &apos;+&apos; || cur == &apos;-&apos; || cur == &apos;*&apos;) &#123; // Split input string into two parts and solve them recursively vector&lt;int&gt; result1, result2; string substr = input.substr(0, i); // check if dpMap has the result for substr if (dpMap.find(substr) != dpMap.end()) result1 = dpMap[substr]; else result1 = computeWithDP(substr, dpMap); substr = input.substr(i + 1); if (dpMap.find(substr) != dpMap.end()) // 学习字典的查找写法 result2 = dpMap[substr]; else result2 = computeWithDP(substr, dpMap); for (auto n1 : result1) &#123; for (auto n2 : result2) &#123; if (cur == &apos;+&apos;) result.push_back(n1 + n2); else if (cur == &apos;-&apos;) result.push_back(n1 - n2); else result.push_back(n1 * n2); &#125; &#125; &#125; &#125; // if the input string contains only number if (result.empty()) result.push_back(atoi(input.c_str())); // 这一步值得学习 // save to dpMap dpMap[input] = result; // 不要忘记这一步 return result; &#125;&#125;; https://discuss.leetcode.com/topic/19894/1-11-lines-python-9-lines-c 1-11 lines Python, 9 lines C++ Just doing it… Solution 1 … 48 ms 123456789101112def diffWaysToCompute(self, input): tokens = re.split(&apos;(\D)&apos;, input) nums = map(int, tokens[::2]) ops = map(&#123;&apos;+&apos;: operator.add, &apos;-&apos;: operator.sub, &apos;*&apos;: operator.mul&#125;.get, tokens[1::2]) def build(lo, hi): if lo == hi: return [nums[lo]] return [ops[i](a, b) for i in xrange(lo, hi) for a in build(lo, i) for b in build(i + 1, hi)] return build(0, len(nums) - 1) Solution 2 … 168 ms One-liner inspired by Soba. 12345def diffWaysToCompute(self, input): return [eval(`a`+c+`b`) for i, c in enumerate(input) if c in &apos;+-*&apos; for a in self.diffWaysToCompute(input[:i]) for b in self.diffWaysToCompute(input[i+1:])] or [int(input)] Solution 3 … 64 ms Faster version of solution 2. 12345def diffWaysToCompute(self, input): return [a+b if c == &apos;+&apos; else a-b if c == &apos;-&apos; else a*b for i, c in enumerate(input) if c in &apos;+-*&apos; for a in self.diffWaysToCompute(input[:i]) for b in self.diffWaysToCompute(input[i+1:])] or [int(input)] Solution 4 … 188 ms A code golf version of solution 2. 12diffWaysToCompute=d=lambda s,t:[eval(`a`+c+`b`)for i,c in enumerate(t)ifc&lt;&apos;0&apos;for a in s.d(t[:i])for b in s.d(t[i+1:])]or[int(t)] C++ … 8 ms C++ version of solution 3. 1234567891011vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; output; for (int i=0; i&lt;input.size(); i++) &#123; char c = input[i]; if (ispunct(c)) for (int a : diffWaysToCompute(input.substr(0, i))) for (int b : diffWaysToCompute(input.substr(i+1))) output.push_back(c==&apos;+&apos; ? a+b : c==&apos;-&apos; ? a-b : a*b); &#125; return output.size() ? output : vector&lt;int&gt;&#123;stoi(input)&#125;;&#125; https://discuss.leetcode.com/topic/22179/python-easy-to-understand-solution-divide-and-conquer Python easy to understand solution (divide and conquer). 1234567891011121314151617181920def diffWaysToCompute(self, input): if input.isdigit(): return [int(input)] res = [] for i in xrange(len(input)): if input[i] in &quot;-+*&quot;: res1 = self.diffWaysToCompute(input[:i]) res2 = self.diffWaysToCompute(input[i+1:]) for j in res1: for k in res2: res.append(self.helper(j, k, input[i])) return res def helper(self, m, n, op): if op == &quot;+&quot;: return m+n elif op == &quot;-&quot;: return m-n else: return m*n https://discuss.leetcode.com/topic/27532/14-line-c-solution 14-line c++ solution 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; ans; bool pureNum=true; for (int i=0; i&lt;input.length(); i++) if (input[i]&lt;&apos;0&apos; || input[i]&gt;&apos;9&apos;) &#123; pureNum=false; vector&lt;int&gt; L=diffWaysToCompute(input.substr(0, i)), R=diffWaysToCompute(input.substr(i+1, input.length()-i-1)); for (auto l : L) for (auto r : R) if (input[i]==&apos;+&apos;) ans.push_back(l+r); else if (input[i]==&apos;-&apos;) ans.push_back(l-r); else if (input[i]==&apos;*&apos;) ans.push_back(l*r); &#125; if (pureNum) ans.push_back(atoi(input.c_str())); return ans; &#125;&#125;; https://discuss.leetcode.com/topic/20516/c-solution-using-dp-easy-understanding C++ solution, using dp, easy understanding 123456789101112131415161718192021222324252627282930vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; data; vector&lt;char&gt; ops; int num = 0; char op = &apos; &apos;; istringstream ss(input + &quot;+&quot;); while(ss &gt;&gt; num &amp;&amp; ss &gt;&gt; op) &#123; data.push_back(num); ops.push_back(op); &#125; const int size_i = data.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(size_i, vector&lt;vector&lt;int&gt;&gt;(size_i, vector&lt;int&gt;())); for (int i = 0; i &lt; size_i; i += 1) for (int j = i; j &gt;= 0; j -= 1) &#123; if (i == j) &#123;dp[j][i].push_back(data[i]); continue;&#125; for (int k = j; k &lt; i; k += 1) &#123; for (auto left : dp[j][k]) for (auto right : dp[k+1][i]) &#123; int val = 0; switch(ops[k]) &#123; case &apos;+&apos;: val = left + right; break; case &apos;-&apos;: val = left - right; break; case &apos;*&apos;: val = left * right; break; &#125; dp[j][i].push_back(val); &#125; &#125; &#125; return dp[0][size_i-1];&#125; https://discuss.leetcode.com/topic/20814/python-solution-use-dp Python solution use dp First I extracted the numbers and operators in the expression. Assume there are d numbers and d-1 operators. dp[ i ][ j ] is all possible results of expression contains num[ i : j+1 ]. So the first loop we calculate expressions only have 2 numbers, then 3 numbers, then 4 numbers…. Let’s say we want to get the result of expression contains L numbers started from num[ j ] , we divide it by two half, the first one contains k numbers, and the second half contains L-k numbers. The result of the first half is dp[ j ][ j+k-1 ] and the second half is dp[j+k-1][ j+l-1]. dp[ i ][ j ] contains all combinations of x from dp[ j ][ j+k-1 ] and y from dp[ j+k-1: j+l-1 ], and k is from 1 to l-1. 1234567891011121314151617import reclass Solution: # @param &#123;string&#125; input # @return &#123;integer[]&#125; def diffWaysToCompute(self, input): num=re.split(&apos;\+|-|\*&apos;,input) opr=re.findall(r&apos;\+|-|\*&apos;,input) d=len(num) dp=[[[]for i in range(d)] for j in range(d)] op=&#123;&apos;+&apos;:lambda x,y:x+y, &apos;-&apos;:lambda x,y:x-y, &apos;*&apos;:lambda x,y:x*y&#125; for i in range(d): dp[i][i].append(int(num[i])) for l in range(2,d+1): for j in range(d+1-l): dp[j][j+l-1]=[op[opr[j+k-1]](x,y) for k in range(1,l) for x in dp[j][j+k-1] for y in dp[j+k][j+l-1]] return dp[0][d-1] 10ms, 15.08%, October 15, 2016 https://discuss.leetcode.com/topic/19901/a-recursive-java-solution-284-ms 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; List&lt;Integer&gt; ret = new LinkedList&lt;Integer&gt;(); for(int i=0; i&lt;input.length(); i++)&#123; if(input.charAt(i) == &apos;-&apos; || input.charAt(i) == &apos;*&apos; || input.charAt(i) == &apos;+&apos;)&#123; String part1 = input.substring(0, i); String part2 = input.substring(i+1); List&lt;Integer&gt; part1Ret = diffWaysToCompute(part1); List&lt;Integer&gt; part2Ret = diffWaysToCompute(part2); for(Integer p1 : part1Ret)&#123; for(Integer p2:part2Ret)&#123; int c = 0; switch(input.charAt(i))&#123; case &apos;+&apos;: c = p1+p2; break; case &apos;-&apos;:c = p1-p2; break; case &apos;*&apos;: c = p1*p2; break; &#125; ret.add(c); &#125; &#125; &#125; &#125; if(ret.size() == 0) ret.add(Integer.valueOf(input)); return ret; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>divide and conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[240. Search a 2D Matrix II]]></title>
    <url>%2Fp%2Fac205ce%2F</url>
    <content type="text"><![CDATA[38.0% https://leetcode.com/problems/search-a-2d-matrix-ii/#/description Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. 1234567891011121314For example,Consider the following matrix:[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]Given target = 5, return true.Given target = 20, return false. 方法一： 剑指offer 3 我的代码实现： 从右上角开始搜索 1234567891011121314151617181920212223class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; // int m = matrix.size(); // if(m==0) return false; // int n = matrix[0].size(); // if(n==0) return false; if(matrix.size()==0 || matrix[0].size()==0) return false; int m=matrix.size(), n=matrix[0].size(); if(target&lt;matrix[0][0] || target&gt;matrix[m-1][n-1]) return false; int i=0, j=n-1; while(i&lt;m &amp;&amp; j&gt;=0)&#123; if(target==matrix[i][j]) return true; else if(target&lt;matrix[i][j]) j--; else i++; &#125; return false; &#125;&#125;; 注意代码中 123if(matrix.size()==0 || matrix[0].size()==0) return false;int m=matrix.size(), n=matrix[0].size(); 替代 1234int m = matrix.size();if(m==0) return false;int n = matrix[0].size();if(n==0) return false; 对于矩阵是好用的 184ms, 78.57%, June.23th, 2016 https://leetcode.com/discuss/47528/c-with-o-m-n-complexity 12345678910111213141516171819class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int m = matrix.size(); if(m == 0) return false; int n = matrix[0].size(); int i = 0, j = n - 1; while(i &lt; m &amp;&amp; j &gt;= 0)&#123; if(matrix[i][j] == target) return true; else if(matrix[i][j] &gt; target) j--; else i++; &#125; return false; &#125;&#125;; Solution mine: 720ms, 10.08%, June.23th, 2016 123456789101112class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; for i in xrange(len(matrix)): for j in xrange(len(matrix[0])): if matrix[i][j] == target: return True return False Solution 1: 184ms, 40.60%, June.23th, 2016 https://leetcode.com/discuss/47571/4-lines-c-6-lines-ruby-7-lines-python-1-liners 12345678class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; return any(target in row for row in matrix) Solution 2: 124ms, 59.95%, June.23th, 2016 https://leetcode.com/discuss/47571/4-lines-c-6-lines-ruby-7-lines-python-1-liners 1234567891011121314class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; j = -1 for row in matrix: while j + len(row) and row[j] &gt; target: j -= 1 if row[j] == target: return True return False 13ms, 53.66%, June.23th, 2016 https://leetcode.com/discuss/48852/my-concise-o-m-n-java-solution 123456789101112131415161718public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if(matrix == null || matrix.length &lt; 1 || matrix[0].length &lt; 1) return false; int col = matrix[0].length - 1; int row = 0; while(col &gt;= 0 &amp;&amp; row &lt;= matrix.length - 1)&#123; if(target == matrix[row][col]) return true; else if(target &lt; matrix[row][col]) col--; else row++; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>divide and conquer</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[239. Sliding Window Maximum]]></title>
    <url>%2Fp%2Fd8741db0%2F</url>
    <content type="text"><![CDATA[32.0% https://leetcode.com/problems/sliding-window-maximum/#/description Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. 123456789101112For example,Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7Therefore, return the max sliding window as [3,3,5,5,6,7]. Note: You may assume k is always valid, ie: 1 ≤ k ≤ input array’s size for non-empty array. Follow up: Could you solve it in linear time? Hint: How about using a data structure such as deque (double-ended queue)? The queue size need not be the same as the window’s size. Remove redundant elements and the queue should store only elements that need to be considered. 剑指offer 65 方法一： 使用剑指offer 方法，使用了一个deque，双端开口的队列 deque的方法有pop_back, pop_front, front, back. 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; int n = nums.size(); if(k&lt;=0 || n&lt;1 || k&gt;n) return res; deque&lt;int&gt; dq; for(int i=0; i&lt;k; i++)&#123; while(!dq.empty() &amp;&amp; nums[i]&gt;nums[dq.back()]) dq.pop_back(); dq.push_back(i); &#125; for(int i=k; i&lt;n; i++)&#123; res.push_back(nums[dq.front()]); while(!dq.empty() &amp;&amp; nums[dq.back()]&lt;nums[i]) dq.pop_back(); if(!dq.empty() &amp;&amp; (i-dq.front())&gt;=k) //用if而不是while，因为每次进来一个最多只需要pop一个 dq.pop_front(); dq.push_back(i); &#125; res.push_back(nums[dq.front()]); return res; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; int n = nums.size(); if(n==0 || k&lt;=0 || n&lt;k) return res; deque&lt;int&gt; dq; for(int i=0; i&lt;k; i++)&#123; while(!dq.empty() &amp;&amp; nums[dq.back()]&lt;=nums[i]) dq.pop_back(); dq.push_back(i); &#125; for(int i=k; i&lt;n; i++)&#123; res.push_back(nums[dq.front()]); while(!dq.empty() &amp;&amp; nums[dq.back()]&lt;=nums[i]) dq.pop_back(); // 要检查dq是否为空 if(!dq.empty() &amp;&amp; dq.front()+k&lt;=i) dq.pop_front(); dq.push_back(i); &#125; if(!dq.empty()) res.push_back(nums[dq.front()]); return res; &#125;&#125;; 方法二： 对方法一代码进行了优化 Clean C++ O(n) solution using a deque The data structure used is know as Monotonic Queue. Click here for more information. You can also view more solution on Github 123456789101112131415class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt; dq; vector&lt;int&gt; ans; for (int i=0; i&lt;nums.size(); i++) &#123; if (!dq.empty() &amp;&amp; dq.front() == i-k) dq.pop_front(); while (!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i]) dq.pop_back(); dq.push_back(i); if (i&gt;=k-1) ans.push_back(nums[dq.front()]); &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/19067/clean-c-o-n-solution-using-a-deque 附注： 牛客网 https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&amp;tqId=11217&amp;tPage=4&amp;rp=4&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size) &#123; deque&lt;int&gt; dq; vector&lt;int&gt; res; for(int i=0; i&lt;num.size(); i++)&#123; if(!dq.empty() &amp;&amp; (i-dq.front())&gt;=size) dq.pop_front(); while(!dq.empty() &amp;&amp; num[i]&gt;=num[dq.back()]) dq.pop_back(); dq.push_back(i); if(i&gt;=size-1) res.push_back(num[dq.front()]); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/19297/this-is-a-typical-monotonic-queue-problem This is a typical monotonic queue problem Sliding window minimum/maximum = monotonic queue. I smelled the solution just when I read the title. This is essentially same idea as others’ deque solution, but this is much more standardized and modulized. If you ever need to use it in your real product, this code is definitely more preferable. What does Monoqueue do here: It has three basic options: push: push an element into the queue; O (1) (amortized) pop: pop an element out of the queue; O(1) (pop = remove, it can’t report this element) max: report the max element in queue;O(1) It takes only O(n) time to process a N-size sliding window minimum/maximum problem. Note: different from a priority queue (which takes O(nlogk) to solve this problem), it doesn’t pop the max element: It pops the first element (in original order) in queue. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Monoqueue&#123; deque&lt;pair&lt;int, int&gt;&gt; m_deque; //pair.first: the actual value, //pair.second: how many elements were deleted between it and the one before it. public: void push(int val) &#123; int count = 0; while(!m_deque.empty() &amp;&amp; m_deque.back().first &lt; val) &#123; count += m_deque.back().second + 1; m_deque.pop_back(); &#125; m_deque.emplace_back(val, count); &#125;; int max() &#123; return m_deque.front().first; &#125; void pop () &#123; if (m_deque.front().second &gt; 0) &#123; m_deque.front().second --; return; &#125; m_deque.pop_front(); &#125;&#125;;struct Solution &#123; vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; results; Monoqueue mq; k = min(k, (int)nums.size()); int i = 0; for (;i &lt; k - 1; ++i) //push first k - 1 numbers; &#123; mq.push(nums[i]); &#125; for (; i &lt; nums.size(); ++i) &#123; mq.push(nums[i]); // push a new element to queue; results.push_back(mq.max()); // report the current max in queue; mq.pop(); // pop first element in queue; &#125; return results; &#125;&#125;; https://discuss.leetcode.com/topic/19199/my-c-o-n-deque-based-solution-with-explanation My C++ O(n) deque based solution with explanation The basic idea is to use a deque (buffer) to save all currently potential “maximum” elements (i.e. the element in the current k-element window [i-k+1, i], and it is larger than the elements after itself). So for each i, we first pop up the elements that are no larger than nums[i] from buffer until we find one that is larger than nums[i] or the buffer is empty since those elements will be covered by nums[i] and can not be a maximum of any k-element window. Then we put nums[i] in the buffer. If i&gt;=k-1, we need to ouput the maximum for window [i-k+1, i], which is the front element of buffer. At last, we will check if the front element is nums[i-k+1], if so, we have to pop it up since it will be out of the window [i-k+2, i+1] in the next iteration. Since all the elements will be pushed into/ popped out of the buffer only once, so the time complexity is O(N). 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt; buffer; vector&lt;int&gt; res; for(auto i=0; i&lt;nums.size();++i) &#123; while(!buffer.empty() &amp;&amp; nums[i]&gt;=nums[buffer.back()]) buffer.pop_back(); buffer.push_back(i); if(i&gt;=k-1) res.push_back(nums[buffer.front()]); if(buffer.front()&lt;= i-k + 1) buffer.pop_front(); &#125; return res; &#125; https://discuss.leetcode.com/topic/23020/a-clear-solution-using-deque-c A clear solution using deque (C++) 12345678910111213141516171819class Solution &#123;public:vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt; q; vector&lt;int&gt; maxs; if(nums.empty()||k&lt;=0) return maxs; for(int i=0;i&lt;nums.size();i++)&#123; while(!q.empty()&amp;&amp;nums[q.back()]&lt;=nums[i]) q.pop_back(); q.push_back(i); if(q.front()&lt;=i-k) q.pop_front(); if(i&gt;=k-1) maxs.push_back(nums[q.front()]); &#125; return maxs;&#125;&#125;; https://discuss.leetcode.com/topic/19099/3-c-solutions 3 C++ Solutions O(NlogK) 12345678910111213vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; result; if (k == 0) return result; multiset&lt;int&gt; w; for (int i = 0, n = (int)nums.size(); i &lt; n; i++) &#123; if (i &gt;= k) w.erase(w.find(nums[i-k])); w.insert(nums[i]); if (i &gt;= k-1) result.push_back(*w.rbegin()); &#125; return result;&#125; O(NlogN) 12345678910111213vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; result; if (k == 0) return result; priority_queue&lt;pair&lt;int, int&gt;&gt; w; for (int i = 0, n = (int)nums.size(); i &lt; n; i++) &#123; while (!w.empty() &amp;&amp; w.top().second &lt;= i-k) w.pop(); w.push(make_pair(nums[i],i)); if (i &gt;= k-1) result.push_back(w.top().first); &#125; return result;&#125; O(N) 123456789101112131415vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; result; if (k == 0) return result; deque&lt;int&gt; w; for (int i = 0, n = (int)nums.size(); i &lt; n; i++) &#123; while (!w.empty() &amp;&amp; w.front() &lt;= i-k) w.pop_front(); while (!w.empty() &amp;&amp; nums[w.back()] &lt;= nums[i]) w.pop_back(); w.push_back(i); if (i &gt;= k-1) result.push_back(nums[w.front()]); &#125; return result;&#125; https://discuss.leetcode.com/topic/31686/a-concise-solution-using-deque A concise solution using deque 1234567891011121314151617vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; if (k &lt;= 0) return &#123;&#125;; vector&lt;int&gt; ans(nums.size() - k + 1); deque&lt;int&gt; dq; for (int i = 0; i &lt; nums.size(); ++i) &#123; // delete those nodes whose value less than the current value while (!dq.empty() &amp;&amp; nums[i] &gt; nums[dq.back()]) dq.pop_back(); dq.push_back(i); // delete the node pass the start of the window if (i - dq.front() + 1 &gt; k) dq.pop_front(); // assign result value if (i &gt;= k - 1) ans[i - k + 1] = nums[dq.front()]; &#125; return ans;&#125; https://discuss.leetcode.com/topic/19059/9-lines-ruby-11-lines-python-o-n 9 lines Ruby, 11 lines Python, O(n) Keep indexes of good candidates in deque d. The indexes in d are from the current window, they’re increasing, and their corresponding nums are decreasing. Then the first deque element is the index of the largest window value. For each index i: Pop (from the end) indexes of smaller elements (they’ll be useless). Append the current index. Pop (from the front) the index i - k, if it’s still in the deque (it falls out of the window). If our window has reached size k, append the current window maximum to the output. Ruby Apparently Ruby doesn’t have a deque, so I simulate one with an array, where s tells the start index of the queue in the array. 1234567891011def max_sliding_window(nums, k) d, s = [], 0 out = [] nums.each_index&#123; |i| d.pop while d[s] &amp;&amp; nums[d[-1]] &lt; nums[i] d &lt;&lt; i s += 1 if d[s] == i - k out &lt;&lt; nums[d[s]] if i &gt;= k - 1 &#125; outend Python 123456789101112def maxSlidingWindow(self, nums, k): d = collections.deque() out = [] for i, n in enumerate(nums): while d and nums[d[-1]] &lt; n: d.pop() d += i, if d[0] == i - k: d.popleft() if i &gt;= k - 1: out += nums[d[0]], return out Last three lines could be this, but for relatively large k it would waste space: 12out += nums[d[0]], return out[k-1:] 27ms, 31.12%, October 14, 2016 https://discuss.leetcode.com/topic/19055/java-o-n-solution-using-deque-with-explanation 123456789101112131415161718192021public class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; if(nums==null || k&lt;=0) return new int[0]; int n = nums.length; int[] r = new int[n-k+1]; int ri = 0; Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); for(int i=0; i&lt;nums.length; i++)&#123; while(!q.isEmpty() &amp;&amp; q.peek() &lt; i-k+1) q.poll(); while(!q.isEmpty()&amp;&amp;nums[q.peekLast()]&lt;nums[i]) q.pollLast(); q.offer(i); if(i&gt;=k-1) r[ri++] = nums[q.peek()]; &#125; return r; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[238. Product of Array Except Self]]></title>
    <url>%2Fp%2F8baaef8d%2F</url>
    <content type="text"><![CDATA[48.0% https://leetcode.com/problems/product-of-array-except-self/#/description Given an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). 1For example, given [1,2,3,4], return [24,12,8,6]. Follow up: Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.) 剑指offer 52 https://discuss.leetcode.com/topic/20434/o-n-time-and-o-1-space-c-solution-with-explanation O(n) time and O(1) space C++ solution with explanation 方法一： First, consider O(n) time and O(n) space solution. 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(); vector&lt;int&gt; fromBegin(n); fromBegin[0]=1; vector&lt;int&gt; fromLast(n); fromLast[0]=1; for(int i=1;i&lt;n;i++)&#123; fromBegin[i]=fromBegin[i-1]*nums[i-1]; fromLast[i]=fromLast[i-1]*nums[n-i]; &#125; vector&lt;int&gt; res(n); for(int i=0;i&lt;n;i++)&#123; res[i]=fromBegin[i]*fromLast[n-1-i]; &#125; return res; &#125;&#125;; 方法二： 空间从o（n）降低到o（1） 对从前至后的部分考虑保留前一个值，得到结果。 很巧妙地方法，节省了空间。 We just need to change the two vectors to two integers and note that we should do multiplying operations for two related elements of the results vector in each loop. 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(); int fromBegin=1; int fromLast=1; vector&lt;int&gt; res(n,1); for(int i=0;i&lt;n;i++)&#123; res[i]*=fromBegin; fromBegin*=nums[i]; res[n-1-i]*=fromLast; fromLast*=nums[n-1-i]; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/37927/how-from-o-n-to-o-1 How from O(N) to O(1) Here is the O(N) based C++ implementation 12345678910111213class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int len=nums.size(); vector&lt;int&gt; left(len, 1); vector&lt;int&gt; right(len, 1); vector&lt;int&gt; result(len, 0); for(int i=1; i&lt;len; i++) left[i]=left[i-1]*nums[i-1]; for(int i=len-2; i&gt;=0; i--) right[i]=right[i+1]*nums[i+1]; for(int i=0; i&lt;len; i++) result[i]=left[i]*right[i]; return result; &#125;&#125;; How to use O(1) ? By observing the above code, we can just for every position multiply it to its right position. Just the idea to think reversly ! 123456789101112131415class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(); int left=1, right=1; vector&lt;int&gt; result(n, 1); for(int i=0; i&lt;n; i++)&#123; result[i]*=left; result[n-1-i]*=right; left*=nums[i]; right*=nums[n-1-i]; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/18877/my-c-solution-o-n-time-with-no-extra-space My C++ solution, O(n) time with no extra space 1234567891011121314151617vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int N = nums.size(); vector&lt;int&gt; res(N,1); for(int i=0; i&lt;N; i++)&#123; if (i==0) res[i] = 1; else res[i] = res[i-1]*nums[i-1]; &#125; int r_prod = 1; for(int i=N-1; i&gt;=0; i--)&#123; res[i] *= r_prod; r_prod *= nums[i]; &#125; return res;&#125; https://discuss.leetcode.com/topic/18983/python-solution-accepted-o-n-time-o-1-space Python solution (Accepted), O(n) time, O(1) space 123456789101112131415class Solution: # @param &#123;integer[]&#125; nums # @return &#123;integer[]&#125; def productExceptSelf(self, nums): p = 1 n = len(nums) output = [] for i in range(0,n): output.append(p) p = p * nums[i] p = 1 for i in range(n-1,-1,-1): output[i] = output[i] * p p = p * nums[i] return output https://discuss.leetcode.com/topic/30115/very-easy-two-passes-solution Very easy two passes solution 1234567891011121314151617// two passes, O(2n)vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; ans(n, 1); for (int i = 1; i &lt; n; ++i) &#123; ans[i] = ans[i-1] * nums[i-1]; &#125; int m = 1; for (int i = n-1; i &gt;= 0; --i) &#123; ans[i] *= m; m *= nums[i]; &#125; return ans;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[237. Delete Node in a Linked List]]></title>
    <url>%2Fp%2Ffec895cd%2F</url>
    <content type="text"><![CDATA[45.8% Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function. Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4after calling your function. 方法一： We can’t really delete the node, but we can kinda achieve the same effect by instead removing the next node after copying its data into the node that we were asked to delete. 1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void deleteNode(ListNode* node) &#123; *node = *node-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/18752/1-3-lines-c-java-python-c-c-javascript-ruby 链表基本操作，记待删除节点为node令node.val = node.next.val，node.next = node.next.next即可python： 1234567891011121314# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = None class Solution(object): def deleteNode(self, node): &quot;&quot;&quot; :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. &quot;&quot;&quot; node.val = node.next.val node.next = node.next.next cpp: 1234567891011121314/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void deleteNode(ListNode* node) &#123; *node = *node-&gt;next; &#125;&#125;; java： 1234567891011121314/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[236. Lowest Common Ancestor of a Binary Tree]]></title>
    <url>%2Fp%2Fda126211%2F</url>
    <content type="text"><![CDATA[29.6% https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/#/description Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” 12345678tmp _______3______ / \ ___5__ ___1__ / \ / \ 6 _2 0 8 / \ 7 4 For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. 这道题，还有其他解法，可以思考方法二中的代码 重点题目 解法一： 我的代码实现： Dec 10th, 2017 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root==nullptr || root==p || root==q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if(left &amp;&amp; right) return root; return left!=nullptr?left:right; &#125;&#125;; 123456789101112class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root == NULL || root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if (left &amp;&amp; right) return root; return left? left:right; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root==NULL || root==p || root==q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if(left &amp;&amp; right) return root; return left?left:right; &#125;&#125;; 方法二: http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/ https://discuss.leetcode.com/topic/18561/4-lines-c-java-python-ruby 4 lines C++/Java/Python/Ruby Same solution in several languages. It’s recursive and expands the meaning of the function. If the current (sub)tree contains both p and q, then the function result is their LCA. If only one of them is in that subtree, then the result is that one of them. If neither are in that subtree, the result is null/None/nil. Update: I also wrote two iterative solutions now, one of them being a version of the solution here. They’re more complicated than this simple recursive solution, but I do find them interesting. C++ 123456TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (!root || root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); return !left ? right : !right ? left : root;&#125; Python 12345def lowestCommonAncestor(self, root, p, q): if root in (None, p, q): return root left, right = (self.lowestCommonAncestor(kid, p, q) for kid in (root.left, root.right)) return root if left and right else left or right Or using that None is considered smaller than any node: 12345def lowestCommonAncestor(self, root, p, q): if root in (None, p, q): return root subs = [self.lowestCommonAncestor(kid, p, q) for kid in (root.left, root.right)] return root if all(subs) else max(subs) Ruby 123456def lowest_common_ancestor(root, p, q) return root if [nil, p, q].index root left = lowest_common_ancestor(root.left, p, q) right = lowest_common_ancestor(root.right, p, q) left &amp;&amp; right ? root : left || rightend Java 123456public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); return left == null ? right : right == null ? left : root;&#125; https://discuss.leetcode.com/topic/27479/java-python-iterative-solution Java/Python iterative solution Python 1234567891011121314151617181920212223def lowestCommonAncestor(self, root, p, q): stack = [root] parent = &#123;root: None&#125; while p not in parent or q not in parent: node = stack.pop() if node.left: parent[node.left] = node stack.append(node.left) if node.right: parent[node.right] = node stack.append(node.right) ancestors = set() while p: ancestors.add(p) p = parent[p] while q not in ancestors: q = parent[q] return q# 31 / 31 test cases passed.# Status: Accepted# Runtime: 108 ms# 99.14% Java 12345678910111213141516171819202122232425262728public class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; Map&lt;TreeNode, TreeNode&gt; parent = new HashMap&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); parent.put(root, null); stack.push(root); while (!parent.containsKey(p) || !parent.containsKey(q)) &#123; TreeNode node = stack.pop(); if (node.left != null) &#123; parent.put(node.left, node); stack.push(node.left); &#125; if (node.right != null) &#123; parent.put(node.right, node); stack.push(node.right); &#125; &#125; Set&lt;TreeNode&gt; ancestors = new HashSet&lt;&gt;(); while (p != null) &#123; ancestors.add(p); p = parent.get(p); &#125; while (!ancestors.contains(q)) q = parent.get(q); return q; &#125;&#125; To find the lowest common ancestor, we need to find where is p and q and a way to track their ancestors. A parent pointer for each node found is good for the job. After we found both p and q, we create a set of p’s ancestors. Then we travel through q’s ancestors, the first one appears in p’s is our answer. https://discuss.leetcode.com/topic/18652/iterative-solutions-in-python-c Iterative Solutions in Python/C++ Solution 1 Same algorithm as my recursive solution (look there if you want some explanation), but iterative. I do a post-order traversal with a stack. Each stack element at first is a [node, parent] pair, where parent is the stack element of the node’s parent node. When the children of a parent get finished, their results are appended to their parent’s stack element. So when a parent gets finished, we have the results of its children/subtrees available (its stack element at that point is [node, parent, resultForLeftSubtree, resultForRightSubtree]). 12345678910111213def lowestCommonAncestor(self, root, p, q): answer = [] stack = [[root, answer]] while stack: top = stack.pop() (node, parent), subs = top[:2], top[2:] if node in (None, p, q): parent += node, elif not subs: stack += top, [node.right, top], [node.left, top] else: parent += node if all(subs) else max(subs), return answer[0] Solution 2 Here I find the paths to p and q and then find the last node where the paths match. I just came up with the path-building technique for this, and I find it quite neat and maybe it could be useful elsewhere. 1234567891011121314def lowestCommonAncestor(self, root, p, q): def path(root, goal): path, stack = [], [root] while True: node = stack.pop() if node: if node not in path[-1:]: path += node, if node == goal: return path stack += node, node.right, node.left else: path.pop() return next(a for a, b in zip(path(root, p), path(root, q))[::-1] if a == b) C++ version of Solution 1 I don’t use C++ much, so maybe there’s room for improvement with stuff that I don’t know. 1234567891011121314151617181920212223242526272829class Solution &#123; struct Frame &#123; TreeNode* node; Frame* parent; vector&lt;TreeNode*&gt; subs; &#125;;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; Frame answer; stack&lt;Frame&gt; stack; stack.push(&#123;root, &amp;answer&#125;); while (stack.size()) &#123; Frame *top = &amp;stack.top(), *parent = top-&gt;parent; TreeNode *node = top-&gt;node; if (!node || node == p || node == q) &#123; parent-&gt;subs.push_back(node); stack.pop(); &#125; else if (top-&gt;subs.empty()) &#123; stack.push(&#123;node-&gt;right, top&#125;); stack.push(&#123;node-&gt;left, top&#125;); &#125; else &#123; TreeNode *left = top-&gt;subs[0], *right = top-&gt;subs[1]; parent-&gt;subs.push_back(!left ? right : !right ? left : node); stack.pop(); &#125; &#125; return answer.subs[0]; &#125;&#125;; https://discuss.leetcode.com/topic/20063/accepted-24ms-dfs-c-solution-only-3-lines Accepted 24ms DFS c++ solution, only 3 lines. 12345678class Solution &#123;public: TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) &#123; if (root == p || root == q || root == NULL) return root; TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q), *right = lowestCommonAncestor(root-&gt;right, p, q); return left &amp;&amp; right ? root : left ? left : right; &#125;&#125;; https://discuss.leetcode.com/topic/18786/very-simple-dfs-c-solution-only-10-lines Very simple dfs c++ solution , only 10 lines 123456789101112131415TreeNode * dfsTraverse(TreeNode * root, TreeNode * p , TreeNode * q)&#123; if( root == p || root == q || root == NULL) return root; TreeNode * parent1 = dfsTraverse(root-&gt;left, p, q); TreeNode * parent2 = dfsTraverse(root-&gt;right, p, q); if( parent1 &amp;&amp; parent2) return root; else return parent1 ? parent1:parent2;&#125;TreeNode * lowestCommonAncestor(TreeNode * root, TreeNode * p, TreeNode * q)&#123; return dfsTraverse(root, p, q);&#125; https://discuss.leetcode.com/topic/26396/short-and-clean-c-solution Short and clean C++ solution Want to share my solution. 12345678910111213141516171819TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (!root || !p || !q) &#123; return NULL; &#125; if (root == p || root == q) &#123; return root; &#125; TreeNode* l = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* r = lowestCommonAncestor(root-&gt;right, p, q); if (l &amp;&amp; r) &#123; return root; &#125; return l? l : r;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[235. Lowest Common Ancestor of a Binary Search Tree]]></title>
    <url>%2Fp%2F6e0230a7%2F</url>
    <content type="text"><![CDATA[38.4% https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/#/description Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” 12345678tmp _______6______ / \ ___2__ ___8__ / \ / \ 0 _4 7 9 / \ 3 5 For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. https://discuss.leetcode.com/topic/18614/easy-c-recursive-and-iterative-solutions Easy C++ Recursive and Iterative Solutions 方法一： Well, remember to take advantage of the property of binary search trees, which is, node -&gt; left -&gt; val &lt; node -&gt; val &lt; node -&gt; right -&gt; val. Moreover, both p and q will be the descendants of the root of the subtree that contains both of them. And the root with the largest depth is just the lowest common ancestor. This idea can be turned into the following simple recursive code. 12345678910class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (p -&gt; val &lt; root -&gt; val &amp;&amp; q -&gt; val &lt; root -&gt; val) return lowestCommonAncestor(root -&gt; left, p, q); if (p -&gt; val &gt; root -&gt; val &amp;&amp; q -&gt; val &gt; root -&gt; val) return lowestCommonAncestor(root -&gt; right, p, q); return root; &#125;&#125;; 我的代码实现： 1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) return lowestCommonAncestor(root-&gt;left, p, q); if(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) return lowestCommonAncestor(root-&gt;right, p, q); return root; &#125;&#125;; 方法二： Of course, we can also solve it iteratively. 12345678910111213class Solution &#123; public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; TreeNode* cur = root; while (true) &#123; if (p -&gt; val &lt; cur -&gt; val &amp;&amp; q -&gt; val &lt; cur -&gt; val) cur = cur -&gt; left; else if (p -&gt; val &gt; cur -&gt; val &amp;&amp; q -&gt; val &gt; cur -&gt; val) cur = cur -&gt; right; else return cur; &#125; &#125;&#125;; 方法三： 使用236的方法 1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root==NULL || root==p || root==q) return root; TreeNode* l = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* r = lowestCommonAncestor(root-&gt;right, p, q); if(l &amp;&amp; r) return root; return l?l:r; &#125;&#125;; 3 lines with O(1) space, 1-Liners, Alternatives Just walk down from the whole tree’s root as long as both p and q are in the same subtree (meaning their values are both smaller or both larger than root’s). This walks straight from the root to the LCA, not looking at the rest of the tree, so it’s pretty much as fast as it gets. A few ways to do it: Iterative, O(1) space Python 1234def lowestCommonAncestor(self, root, p, q): while (root.val - p.val) * (root.val - q.val) &gt; 0: root = (root.left, root.right)[p.val &gt; root.val] return root Java 12345public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; while ((root.val - p.val) * (root.val - q.val) &gt; 0) root = p.val &lt; root.val ? root.left : root.right; return root;&#125; (in case of overflow, I’d do (root.val - (long)p.val) * (root.val - (long)q.val)) Different Python 12345def lowestCommonAncestor(self, root, p, q): a, b = sorted([p.val, q.val]) while not a &lt;= root.val &lt;= b: root = (root.left, root.right)[a &gt; root.val] return root “Long” Python, maybe easiest to understand 12345678def lowestCommonAncestor(self, root, p, q): while root: if p.val &lt; root.val &gt; q.val: root = root.left elif p.val &gt; root.val &lt; q.val: root = root.right else: return root Recursive Python 1234def lowestCommonAncestor(self, root, p, q): next = p.val &lt; root.val &gt; q.val and root.left or \ p.val &gt; root.val &lt; q.val and root.right return self.lowestCommonAncestor(next, p, q) if next else root Python One-Liner 123def lowestCommonAncestor(self, root, p, q): return root if (root.val - p.val) * (root.val - q.val) &lt; 1 else \ self.lowestCommonAncestor((root.left, root.right)[p.val &gt; root.val], p, q) Java One-Liner 1234public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; return (root.val - p.val) * (root.val - q.val) &lt; 1 ? root : lowestCommonAncestor(p.val &lt; root.val ? root.left : root.right, p, q);&#125; “Long” Python, maybe easiest to understand 123456def lowestCommonAncestor(self, root, p, q): if p.val &lt; root.val &gt; q.val: return self.lowestCommonAncestor(root.left, p, q) if p.val &gt; root.val &lt; q.val: return self.lowestCommonAncestor(root.right, p, q) return root https://discuss.leetcode.com/topic/22095/c-solution-40ms C++ solution . 40ms 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(!root)&#123; return NULL; &#125; // check if the current value is larger than both nodes , go left if(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)&#123; lowestCommonAncestor(root-&gt;left , p , q); // go right &#125;else if(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)&#123; lowestCommonAncestor(root-&gt;right , p , q); &#125;// my LCA else&#123; return root; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/18438/python-iterative-solution Python Iterative Solution 12345678910class Solution:def lowestCommonAncestor(self, root, p, q): while root: if root.val &gt; p.val and root.val &gt; q.val: root = root.left elif root.val &lt; p.val and root.val &lt; q.val: root = root.right else: return root https://discuss.leetcode.com/topic/19536/my-python-recursive-solution My Python recursive solution 1234567891011121314class Solution: # @param &#123;TreeNode&#125; root # @param &#123;TreeNode&#125; p # @param &#123;TreeNode&#125; q # @return &#123;TreeNode&#125; def lowestCommonAncestor(self, root, p, q): if not root or not p or not q: return None if (max(p.val, q.val) &lt; root.val): return self.lowestCommonAncestor(root.left, p, q) elif (min(p.val, q.val) &gt; root.val): return self.lowestCommonAncestor(root.right, p, q) else: return root]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[234. Palindrome Linked List]]></title>
    <url>%2Fp%2F8fba543e%2F</url>
    <content type="text"><![CDATA[32.0% https://leetcode.com/problems/palindrome-linked-list/#/description Given a singly linked list, determine if it is a palindrome. Follow up: Could you do it in O(n) time and O(1) space? 方法一： 将后半部分进行反转链表，则与前半部分应该是相同的。 所以第一步找到中间点，第二步反转，第三步进行比较。 https://discuss.leetcode.com/topic/18304/share-my-c-solution-o-n-time-and-o-1-memory Share my C++ solution, O(n) time and O(1) memory 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; if(head==NULL||head-&gt;next==NULL) return true; ListNode* slow=head; ListNode* fast=head; while(fast-&gt;next!=NULL&amp;&amp;fast-&gt;next-&gt;next!=NULL)&#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; &#125; slow-&gt;next=reverseList(slow-&gt;next); slow=slow-&gt;next; while(slow!=NULL)&#123; if(head-&gt;val!=slow-&gt;val) return false; head=head-&gt;next; slow=slow-&gt;next; &#125; return true; &#125; ListNode* reverseList(ListNode* head) &#123; ListNode* pre=NULL; ListNode* next=NULL; while(head!=NULL)&#123; next=head-&gt;next; head-&gt;next=pre; pre=head; head=next; &#125; return pre; &#125;&#125;; 我的代码实现 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; if(!head || !head-&gt;next) return true; ListNode* fast = head, *slow = head; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; ListNode* cur = slow-&gt;next; slow-&gt;next = NULL; while(cur)&#123; ListNode* nex = cur-&gt;next; cur-&gt;next = slow-&gt;next; slow-&gt;next = cur; cur = nex; &#125; fast = head; slow = slow-&gt;next; while(slow)&#123; if(fast-&gt;val != slow-&gt;val) return false; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return true; &#125;&#125;; https://discuss.leetcode.com/topic/27605/my-easy-understand-c-solution My easy understand C++ solution 123456789101112131415class Solution &#123;public: ListNode* temp; bool isPalindrome(ListNode* head) &#123; temp = head; return check(head); &#125; bool check(ListNode* p) &#123; if (NULL == p) return true; bool isPal = check(p-&gt;next) &amp; (temp-&gt;val == p-&gt;val); temp = temp-&gt;next; return isPal; &#125;&#125;; https://discuss.leetcode.com/topic/18533/reversing-a-list-is-not-considered-o-1-space Reversing a list is not considered “O(1) space” It is a common misunderstanding that the space complexity of a program is just how much the size of additional memory space being used besides input. An important prerequisite is neglected the above definition: the input has to be read-only. By definition, changing the input and change it back is not allowed (or the input size should be counted when doing so). Another way of determining the space complexity of a program is to simply look at how much space it has written to. Reversing a singly linked list requires writing to O(n) memory space, thus the space complexities for all “reverse-the-list”-based approaches are O(n), not O(1). Solving this problem in O(1) space is theoretically impossible due to two simple facts: (1) a program using O(1) space is computationally equivalent to a finite automata, or a regular expression checker; (2) the pumping lemma states that the set of palindrome strings does not form a regular set. Please change the incorrect problem statement. https://discuss.leetcode.com/topic/18293/11-lines-12-with-restore-o-n-time-o-1-space/2 11 lines, 12 with restore, O(n) time, O(1) space O(n) time, O(1) space. The second solution restores the list after changing it. Solution 1: Reversed first half == Second half? Phase 1: Reverse the first half while finding the middle. Phase 2: Compare the reversed first half with the second half. 123456789101112def isPalindrome(self, head): rev = None slow = fast = head while fast and fast.next: fast = fast.next.next rev, rev.next, slow = slow, rev, slow.next if fast: slow = slow.next while rev and rev.val == slow.val: slow = slow.next rev = rev.next return not rev Solution 2: Play Nice Same as the above, but while comparing the two halves, restore the list to its original state by reversing the first half back. Not that the OJ or anyone else cares. 12345678910111213def isPalindrome(self, head): rev = None fast = head while fast and fast.next: fast = fast.next.next rev, rev.next, head = head, rev, head.next tail = head.next if fast else head isPali = True while rev: isPali = isPali and rev.val == tail.val head, head.next, rev = rev, head, rev.next tail = tail.next return isPali https://discuss.leetcode.com/topic/18952/python-easy-to-understand-solution-with-comments-operate-nodes-directly Python easy to understand solution with comments (operate nodes directly). 1234567891011121314151617181920def isPalindrome(self, head): fast = slow = head # find the mid node while fast and fast.next: fast = fast.next.next slow = slow.next # reverse the second half node = None while slow: nxt = slow.next slow.next = node node = slow slow = nxt # compare the first and second half nodes while node: # while node and head: if node.val != head.val: return False node = node.next head = head.next return True https://discuss.leetcode.com/topic/18301/5-lines-python-o-n-time-and-space 5 lines Python, O(n) time and space I just realized that the O(1) space is only a follow-up, so here’s the obvious one without that. 123456def isPalindrome(self, head): vals = [] while head: vals += head.val, head = head.next return vals == vals[::-1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[233. Number of Digit One]]></title>
    <url>%2Fp%2Fbb8f353e%2F</url>
    <content type="text"><![CDATA[28.5% https://leetcode.com/problems/number-of-digit-one/#/description Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n. 123For example:Given n = 13,Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13. Hint: Beware of overflow. 剑指offer 52 方法一： https://discuss.leetcode.com/topic/41642/easy-to-understand-c-0ms-solution-with-detailed-explanation Easy to understand C++ 0ms solution with detailed explanation We start from basics: 12345f(9) = 1;f(99) = f(9) * 10 + 10(contributed by the most significant digit in range [10, 19]) = 20 f(999) = f(99) * 10 + 100(contributed by the most significant digit in range [100, 199]) = 300f(9999) = f(999) * 10 + 1000(contributed by the most significant digit in range [1000, 1999]) = 10 * 300 + 1000 = 4000... ... How about 23? 123 = [0, 9] + [10, 19] + [20, 23] [10, 19] can be reduced to solve f(9) + 10, because its most significant digit is 1. And [20, 23] can be reduced to solve f(3) + 0, because the most significant digit is 2, so this digit doesn’t contribute to final result.So now we know 1f(23) = f(9) * 2 + 10 + f(3) So now when we look at a number n (e.g. 2356), we look at the most significant digit(2), its divisor with highest 10’s power (1000), and its remainder (356), try to reduce to a smaller number iteratively. (1) Since most significant digit is 2, so we know range [0, 999], [1000, 1999] are included, so we add 2 * f(999). (2) Also, since we have [1000, 1999] covered, we should add extra 1000. (3) Then we look at range [2000, 2356], try to reduce it to [0, 356] by dropping most significant digit 2, it doesn’t impact the final result since most significant digit is 2 not 1. (4) Finally, we add f(356) So eventually, we have 1234f(2356) += (2356 / 1000) * f(1000 - 1) = 2 * f(999);f(2356) += (2356 / 1000 &gt; 1 ? 1000 : 0); f(2356) += (2356 / 1000 == 1 ? 356 + 1 : 0);f(2356) += f(356); Below is the code: 1234567891011121314151617181920212223242526class Solution &#123;public: int countDigitOne(int n) &#123; int ans = 0; if(n &lt;= 0) return 0; if(n &lt;= 9) return 1; unordered_map&lt;int, int&gt; mp; mp[9] = 1; for(int i = 9; i &lt;= (INT_MAX - 9) / 10; i = i * 10 + 9)&#123; mp[i*10 + 9] = mp[i] * 10 + (i + 1); // mp[99], mp[999], mp[9999], ... ... &#125; int nn = n, divisor = 1; while(nn / 10)&#123; nn /= 10; divisor *= 10; &#125; ans += (n / divisor) * mp[divisor - 1]; ans += (n / divisor &gt; 1) ? divisor : 0; ans += (n / divisor == 1) ? n % divisor + 1 : 0; ans += countDigitOne(n % divisor); return ans; &#125;&#125;; https://discuss.leetcode.com/topic/18054/4-lines-o-log-n-c-java-python 4+ lines, O(log n), C++/Java/Python Go through the digit positions one at a time, find out how often a “1” appears at each position, and sum those up. C++ solution 123456int countDigitOne(int n) &#123; int ones = 0; for (long long m = 1; m &lt;= n; m *= 10) ones += (n/m + 8) / 10 * m + (n/m % 10 == 1) * (n%m + 1); return ones;&#125; Explanation Let me use variables a and b to make the explanation a bit nicer. 12345678int countDigitOne(int n) &#123; int ones = 0; for (long long m = 1; m &lt;= n; m *= 10) &#123; int a = n/m, b = n%m; ones += (a + 8) / 10 * m + (a % 10 == 1) * (b + 1); &#125; return ones;&#125; Go through the digit positions by using position multiplier m with values 1, 10, 100, 1000, etc. For each position, split the decimal representation into two parts, for example split n=3141592 into a=31415 and b=92 when we’re at m=100 for analyzing the hundreds-digit. And then we know that the hundreds-digit of n is 1 for prefixes “” to “3141”, i.e., 3142 times. Each of those times is a streak, though. Because it’s the hundreds-digit, each streak is 100 long. So (a / 10 + 1) * 100 times, the hundreds-digit is 1. Consider the thousands-digit, i.e., when m=1000. Then a=3141 and b=592. The thousands-digit is 1 for prefixes “” to “314”, so 315 times. And each time is a streak of 1000 numbers. However, since the thousands-digit is a 1, the very last streak isn’t 1000 numbers but only 593 numbers, for the suffixes “000” to “592”. So (a / 10 * 1000) + (b + 1) times, the thousands-digit is 1. The case distincton between the current digit/position being 0, 1 and &gt;=2 can easily be done in one expression. With (a + 8) / 10 you get the number of full streaks, and a % 10 == 1 tells you whether to add a partial streak. Java version 123456public int countDigitOne(int n) &#123; int ones = 0; for (long m = 1; m &lt;= n; m *= 10) ones += (n/m + 8) / 10 * m + (n/m % 10 == 1 ? n%m + 1 : 0); return ones;&#125; Python version 123456def countDigitOne(self, n): ones, m = 0, 1 while m &lt;= n: ones += (n/m + 8) / 10 * m + (n/m % 10 == 1) * (n%m + 1) m *= 10 return ones Using sum or recursion it can also be a one-liner. Old solution Go through the digit positions from back to front. I found it ugly to explain, so I made up that above new solution instead. The n here is the new solution’s a, and the r here is the new solution’s b+1. Python 123456789def countDigitOne(self, n): ones = 0 m = r = 1 while n &gt; 0: ones += (n + 8) / 10 * m + (n % 10 == 1) * r r += n % 10 * m m *= 10 n /= 10 return ones Java 12345678910public int countDigitOne(int n) &#123; int ones = 0, m = 1, r = 1; while (n &gt; 0) &#123; ones += (n + 8) / 10 * m + (n % 10 == 1 ? r : 0); r += n % 10 * m; m *= 10; n /= 10; &#125; return ones;&#125; C++ 12345678910int countDigitOne(int n) &#123; int ones = 0, m = 1, r = 1; while (n &gt; 0) &#123; ones += (n + 8) / 10 * m + (n % 10 == 1) * r; r += n % 10 * m; m *= 10; n /= 10; &#125; return ones;&#125; https://discuss.leetcode.com/topic/27565/java-python-one-pass-solution-easy-to-understand Java/Python one pass solution easy to understand The idea is to calculate occurrence of 1 on every digit. There are 3 scenarios, for example 1if n = xyzdabc and we are considering the occurrence of one on thousand, it should be: 123(1) xyz * 1000 if d == 0(2) xyz * 1000 + abc + 1 if d == 1(3) xyz * 1000 + 1000 if d &gt; 1 iterate through all digits and sum them all will give the final answer Java 12345678910111213141516171819public int countDigitOne(int n) &#123; if (n &lt;= 0) return 0; int q = n, x = 1, ans = 0; do &#123; int digit = q % 10; q /= 10; ans += q * x; if (digit == 1) ans += n % x + 1; if (digit &gt; 1) ans += x; x *= 10; &#125; while (q &gt; 0); return ans;&#125;// 40 / 40 test cases passed.// Status: Accepted// Runtime: 0 ms Python 12345678910111213141516171819def countDigitOne(self, n): if n &lt;= 0: return 0 q, x, ans = n, 1, 0 while q &gt; 0: digit = q % 10 q /= 10 ans += q * x if digit == 1: ans += n % x + 1 elif digit &gt; 1: ans += x x *= 10 return ans# 40 / 40 test cases passed.# Status: Accepted# Runtime: 32 ms# 97.59% https://discuss.leetcode.com/topic/18068/0ms-o-lgn-accepted-c-solution-using-counting-principle-with-explanation 0ms o(lgn) accepted c++ solution using counting principle with explanation For every digit in n (Suppose n = 240315, the digits are 2, 4, 0, 3, 1, 5)，I respectively count the number of digit 1 assuming the position of current digit is 1 and other digits of n is arbitrary. For example, I select 3 in n as the current digit, and I suppose the position of 3 is 1. The highn is the number composed with the digits before the current digit. In the example, highn = 240; The lown is the number composed with the digits after the current digit. In the example, lown = 15. The lowc = 10 ^ (the number of lower digits). In the example, lowc = 100; As curn = 3 and curn &gt; 1, (highn 10 + 1) must be less than (highn 10 + curn). Then the higher part can be 0 ~ highn, the lower part can be 0 ~ (lowc-1), and the current result = (highn + 1) * lowc. 12345678910111213141516171819202122232425int countDigitOne(int n) &#123; long long int res(0); int highn(n), lowc(1), lown(0); while(highn &gt; 0)&#123; int curn = highn % 10; highn = highn / 10; if(1 == curn)&#123; //higher: 0~(highn-1); lower: 0 ~ (lowc-1) res += highn * lowc; //higher: highn ~ highn; lower:0~lown res += lown + 1; &#125;else if(0 == curn)&#123; //curn &lt; 1 //higher: 0~(highn-1); lower: 0 ~ (lowc-1) res += highn * lowc; &#125;else&#123; //curn &gt; 1 res += (highn + 1) * lowc; &#125; //update lown and lowc lown = curn * lowc + lown; lowc = lowc * 10; &#125; return res; &#125; https://discuss.leetcode.com/topic/22441/0-ms-recursive-solution 0 ms recursive solution 1234567891011121314int countDigitOne(int n) &#123; if(n&lt;1) return 0; if(n&gt;=1 &amp;&amp; n&lt;10) return 1; // x: first digit int y=1, x=n; while(!(x&lt;10))&#123; x/=10; y*=10; &#125; if(x==1) return n-y+1+countDigitOne(y-1)+countDigitOne(n%y); else return y+x*countDigitOne(y-1)+countDigitOne(n%y);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[232. Implement Queue using Stacks]]></title>
    <url>%2Fp%2F567717e2%2F</url>
    <content type="text"><![CDATA[35.6% https://leetcode.com/problems/implement-queue-using-stacks/#/description Implement the following operations of a queue using stacks. push(x) – Push element x to the back of queue. pop() – Removes the element from in front of queue. peek() – Get the front element. empty() – Return whether the queue is empty. Notes: You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). 方法一：使用两个栈，模拟队列，stack1存储新来的数据，当使用peek时，将stack1的数据都压入stack2，再求stack2的top就是peek数据，当需要pop时，只要先peek，然后再pop stack2就可以了，empty则最简单。 注意的地方，在pop()调用peek()，直接写 peek()就可以了。 pop调用peek得到返回的值，然后需要stack2再pop一下，不要忘了。 疑问：如果都是空的，调用pop会发生什么情况，输出栈的error还是不作处理呢？栈直接pop，是error还是什么？ 我的代码实现： Oct 10th, 2017 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MyQueue &#123;public: stack&lt;int&gt; st1, st2; /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; st1.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; int val = peek(); st2.pop(); return val; &#125; /** Get the front element. */ int peek() &#123; if(st2.empty())&#123; while(st1.size())&#123; int val = st1.top(); st2.push(val); st1.pop(); &#125; &#125; int val = st2.top(); return val; &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return st1.empty() &amp;&amp; st2.empty(); &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * bool param_4 = obj.empty(); */ 12345678910111213141516171819202122232425262728293031323334353637383940class MyQueue &#123;stack&lt;int&gt; stack1;stack&lt;int&gt; stack2;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; stack1.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; peek(); int val = stack2.top(); stack2.pop(); return val; &#125; /** Get the front element. */ int peek() &#123; if(stack2.empty())&#123; while(stack1.size()&gt;0)&#123; int val = stack1.top(); stack2.push(val); stack1.pop(); &#125; &#125; return stack2.top(); &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return stack1.empty() &amp;&amp; stack2.empty(); &#125;&#125;; https://discuss.leetcode.com/topic/17974/short-o-1-amortized-c-java-ruby Short O(1) amortized, C++ / Java / Ruby I have one input stack, onto which I push the incoming elements, and one output stack, from which I peek/pop. I move elements from input stack to output stack when needed, i.e., when I need to peek/pop but the output stack is empty. When that happens, I move all elements from input to output stack, thereby reversing the order so it’s the correct order for peek/pop. The loop in peek does the moving from input to output stack. Each element only ever gets moved like that once, though, and only after we already spent time pushing it, so the overall amortized cost for each operation is O(1). Java 12345678910111213141516171819202122232425class MyQueue &#123; Stack&lt;Integer&gt; input = new Stack(); Stack&lt;Integer&gt; output = new Stack(); public void push(int x) &#123; input.push(x); &#125; public void pop() &#123; peek(); output.pop(); &#125; public int peek() &#123; if (output.empty()) while (!input.empty()) output.push(input.pop()); return output.peek(); &#125; public boolean empty() &#123; return input.empty() &amp;&amp; output.empty(); &#125;&#125; C++ 123456789101112131415161718192021222324class Queue &#123; stack&lt;int&gt; input, output;public: void push(int x) &#123; input.push(x); &#125; void pop(void) &#123; peek(); output.pop(); &#125; int peek(void) &#123; if (output.empty()) while (input.size()) output.push(input.top()), input.pop(); return output.top(); &#125; bool empty(void) &#123; return input.empty() &amp;&amp; output.empty(); &#125;&#125;; https://discuss.leetcode.com/topic/19152/0-ms-c-solution-using-one-stack-w-explanation 0 ms C++ solution using one Stack w/ explanation. You can implement queue using just one stack by either making push process costlier or pop costlier. Since we have two functions (top() and pop()) which require the top element of the stack, well make the push() function costlier - that is, for pushing a new element, we recursively pop the stack till it is empty and push it at the bottom of the stack, and take advantage of the recursive call to push back in the popped elements once the recursive call hits the base condition and returns. This implementation makes pop() and peek() functions easier. pop() is just going to pop off the top element in stack and peek() will return the top most element. 12345678910111213141516171819202122232425262728293031323334353637class Queue &#123;public: stack&lt;int&gt; s; // Push element x to the back of queue. void push(int x) &#123; pushHelper(x); &#125; void pushHelper(int x)&#123; if(s.size()==0)&#123; s.push(x); return; &#125; int data; data = s.top(); s.pop(); pushHelper(x); s.push(data); return; &#125; // Removes the element from in front of queue. void pop(void) &#123; s.pop(); &#125; // Get the front element. int peek(void) &#123; return s.top(); &#125; // Return whether the queue is empty. bool empty(void) &#123; return (s.size()==0); &#125;&#125;; https://discuss.leetcode.com/topic/26163/share-my-python-solution-32ms Share my python solution (32ms) The idea is to simulate a queue using two stacks (same as previous posts). I use python list as the underlying data structure for stack and add a “move()” method to simplify code: it moves all elements of the “inStack” to the “outStack” when the “outStack” is empty. Here is the code 1234567891011121314151617181920212223242526272829303132333435363738394041class Queue(object): def __init__(self): &quot;&quot;&quot; initialize your data structure here. &quot;&quot;&quot; self.inStack, self.outStack = [], [] def push(self, x): &quot;&quot;&quot; :type x: int :rtype: nothing &quot;&quot;&quot; self.inStack.append(x) def pop(self): &quot;&quot;&quot; :rtype: nothing &quot;&quot;&quot; self.move() self.outStack.pop() def peek(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; self.move() return self.outStack[-1] def empty(self): &quot;&quot;&quot; :rtype: bool &quot;&quot;&quot; return (not self.inStack) and (not self.outStack) def move(self): &quot;&quot;&quot; :rtype nothing &quot;&quot;&quot; if not self.outStack: while self.inStack: self.outStack.append(self.inStack.pop()) https://discuss.leetcode.com/topic/17984/accepted-0ms-c-solution-with-two-std-stack-easy-understand Accepted 0ms c++ solution with two std::stack, easy understand. 1234567891011121314151617181920212223242526272829class Queue &#123;public: // Push element x to the back of queue. void push(int x) &#123; while (!nums.empty()) &#123; helper.push(nums.top()); nums.pop(); &#125; nums.push(x); while (!helper.empty()) &#123; nums.push(helper.top()); helper.pop(); &#125; &#125; // Removes the element from in front of queue. void pop(void) &#123; nums.pop(); &#125; // Get the front element. int peek(void) &#123; return nums.top(); &#125; // Return whether the queue is empty. bool empty(void) &#123; return nums.empty(); &#125;private: std::stack&lt;int&gt; helper, nums;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[231. Power of Two]]></title>
    <url>%2Fp%2F79f66f39%2F</url>
    <content type="text"><![CDATA[39.6% https://leetcode.com/problems/power-of-two/#/description Given an integer, write a function to determine if it is a power of two. 方法一： https://discuss.leetcode.com/topic/17857/using-n-n-1-trick Using n&amp;(n-1) trick Power of 2 means only one bit of n is ‘1’, so use the trick n&amp;(n-1)==0 to judge whether that is the case 1234567class Solution &#123;public: bool isPowerOfTwo(int n) &#123; if(n&lt;=0) return false; return !(n&amp;(n-1)); &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/19772/one-line-of-c One line of C++ I used n&amp;(n-1), but, attention the 0. 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; !(n&amp;(n-1)); &#125;&#125;; https://discuss.leetcode.com/topic/47195/4-different-ways-to-solve-iterative-recursive-bit-operation-math 4 different ways to solve – Iterative / Recursive / Bit operation / Math This question is not an difficult one, and there are many ways to solve it. Method 1: Iterative check if n can be divided by 2. If yes, divide n by 2 and check it repeatedly. 123if(n==0) return false;while(n%2==0) n/=2;return (n==1); Time complexity = O(log n) Method 2: Recursive 1return n&gt;0 &amp;&amp; (n==1 || (n%2==0 &amp;&amp; isPowerOfTwo(n/2))); Time complexity = O(log n) Method 3: Bit operation If n is the power of two: n = 2 ^ 0 = 1 = 0b0000…00000001, and (n - 1) = 0 = 0b0000…0000. n = 2 ^ 1 = 2 = 0b0000…00000010, and (n - 1) = 1 = 0b0000…0001. n = 2 ^ 2 = 4 = 0b0000…00000100, and (n - 1) = 3 = 0b0000…0011. n = 2 ^ 3 = 8 = 0b0000…00001000, and (n - 1) = 7 = 0b0000…0111. we have n &amp; (n-1) == 0b0000…0000 == 0 Otherwise, n &amp; (n-1) != 0. For example, n =14 = 0b0000…1110, and (n - 1) = 13 = 0b0000…1101. 1return n&gt;0 &amp;&amp; ((n &amp; (n-1)) == 0); Time complexity = O(1) Method 4: Math derivation Because the range of an integer = -2147483648 (-2^31) ~ 2147483647 (2^31-1), the max possible power of two = 2^30 = 1073741824. (1) If n is the power of two, let n = 2^k, where k is an integer. We have 2^30 = (2^k) * 2^(30-k), which means (2^30 % 2^k) == 0. (2) If n is not the power of two, let n = j*(2^k), where k is an integer and j is an odd number. We have (2^30 % j*(2^k)) == (2^(30-k) % j) != 0. 1return n&gt;0 &amp;&amp; (1073741824 % n == 0); Time complexity = O(1) https://discuss.leetcode.com/topic/26374/share-my-one-line-c Share my one line C++ 123456class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return n&gt;0 &amp;&amp; !(n&amp;(n-1)); &#125;&#125;; https://discuss.leetcode.com/topic/27934/python-one-line-solution Python one line solution 1234567class Solution(object): def isPowerOfTwo(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; return n &gt; 0 and not (n &amp; n-1)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>easy</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[230. Kth Smallest Element in a BST]]></title>
    <url>%2Fp%2F589d7851%2F</url>
    <content type="text"><![CDATA[42.7% https://leetcode.com/problems/kth-smallest-element-in-a-bst/#/description Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note: You may assume k is always valid, 1 ≤ k ≤ BST’s total elements. Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? Hint: Try to utilize the property of a BST. What if you could modify the BST node’s structure? The optimal runtime complexity is O(height of BST). 中序遍历后，BST的结果是从小至大排列的。 方法一：中序遍历，保存至数组，然后取第k个。 12345678910111213141516class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; vector&lt;int&gt; res; inorder(root, res); return res[k-1]; &#125; void inorder(TreeNode* root, vector&lt;int&gt;&amp; res)&#123; if(root)&#123; inorder(root-&gt;left, res); res.push_back(root-&gt;val); inorder(root-&gt;right, res); &#125; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; vector&lt;int&gt; res; inorder(root, res); if(k&lt;0 || k&gt;res.size()) return -1; return res[k-1]; &#125; void inorder(TreeNode* root, vector&lt;int&gt;&amp; res)&#123; if(root)&#123; inorder(root-&gt;left, res); res.push_back(root-&gt;val); inorder(root-&gt;right, res); &#125; &#125;&#125;; 方法二： 传入参数引用， 一次遍历。 123456789int kthSmallest(TreeNode* root, int k) &#123; return find(root, k);&#125;int find(TreeNode* root, int&amp; k) &#123; if (root) &#123; int x = find(root-&gt;left, k); return !k ? x : !--k ? root-&gt;val : find(root-&gt;right, k); &#125;&#125; 我的代码实现： 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; return helper(root, k); // heler函数就是找到第k个并返回 &#125; int helper(TreeNode* root, int&amp; k)&#123; if(root)&#123; int x = helper(root-&gt;left, k); if(k==0) return x; else if(--k==0) return root-&gt;val; else return helper(root-&gt;right, k); &#125; return -1; &#125;&#125;; https://discuss.leetcode.com/topic/17573/4-lines-in-c 4 Lines in C++. Go inorder and decrease k at each node. Stop the whole search as soon as k is zero, and then the k-th element is immediately returned all the way to the recursion top and to the original caller. Try the left subtree first. If that made k zero, then its answer is the overall answer and we return it right away. Otherwise, decrease k for the current node, and if that made k zero, then we return the current node’s value right away. Otherwise try the right subtree and return whatever comes back from there. 123456int kthSmallest(TreeNode* root, int&amp; k) &#123; if (root) &#123; int x = kthSmallest(root-&gt;left, k); return !k ? x : !--k ? root-&gt;val : kthSmallest(root-&gt;right, k); &#125;&#125; You might notice that I changed k from int to int&amp; because I didn’t feel like adding a helper just for that and the OJ doesn’t mind. Oh well, here is that now: 123456789int kthSmallest(TreeNode* root, int k) &#123; return find(root, k);&#125;int find(TreeNode* root, int&amp; k) &#123; if (root) &#123; int x = find(root-&gt;left, k); return !k ? x : !--k ? root-&gt;val : find(root-&gt;right, k); &#125;&#125; https://discuss.leetcode.com/topic/18689/share-my-c-iterative-alg Share my C++ iterative ALG. 1234567891011121314151617181920class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; stack&lt;TreeNode *&gt; st; TreeNode *p = root; while(p || !st.empty()) &#123; while(p) &#123; st.push(p); p = p-&gt;left; &#125; p = st.top(); if(--k == 0) return p-&gt;val; st.pop(); p = p-&gt;right; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/17577/c-solution-using-in-order-traversal C++ solution using in order traversal 12345678910111213141516171819class Solution &#123;public: void inorder(TreeNode* root, vector&lt;int&gt; &amp;res)&#123; if(!root) return; inorder(root-&gt;left, res); res.push_back(root-&gt;val); inorder(root-&gt;right,res); &#125; int kthSmallest(TreeNode* root, int k) &#123; if(!root) return -1; vector&lt;int&gt; arr; inorder(root, arr); return arr[k-1]; &#125;&#125;; 108ms, 27.49%, June.17th, 2016 https://leetcode.com/discuss/44731/pythonic-approach-with-generator Pythonic approach with generator With generator in python, one very straightforward solution might be: 123456789101112131415161718class Solution: # @param &#123;TreeNode&#125; root # @param &#123;integer&#125; k # @return &#123;integer&#125; def kthSmallest(self, root, k): for val in self.inorder(root): if k == 1: return val else: k -= 1 def inorder(self, root): if root is not None: for val in self.inorder(root.left): yield val yield root.val for val in self.inorder(root.right): yield val https://discuss.leetcode.com/topic/37222/python-easy-iterative-and-recursive-solution Python Easy Iterative and Recursive Solution Recursive: 123456789101112131415def kthSmallest(self, root, k): self.k = k self.res = None self.helper(root) return self.resdef helper(self, node): if not node: return self.helper(node.left) self.k -= 1 if self.k == 0: self.res = node.val return self.helper(node.right) Iterative: 1234567891011def kthSmallest(root, k): stack = [] while root or stack: while root: stack.append(root) root = root.left root = stack.pop() k -= 1 if k == 0: return root.val root = root.right https://discuss.leetcode.com/topic/17583/python-solution-using-iteration Python Solution using iteration 1234567891011121314151617class Solution: # @param &#123;TreeNode&#125; root # @param &#123;integer&#125; k # @return &#123;integer&#125; def kthSmallest(self, root, k): i=0 stack=[] node=root while node or stack: while node: stack.append(node) node=node.left node=stack.pop() i+=1 if i==k: return node.val node=node.right For the follow up question, I think we could add a variable to the TreeNode to record the size of the left subtree. When insert or delete a node in the left subtree, we increase or decrease it by 1. So we could know whether the kth smallest element is in the left subtree or in the right subtree by compare the size with k.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[229. Majority Element II]]></title>
    <url>%2Fp%2Fb53b72f4%2F</url>
    <content type="text"><![CDATA[28.0% https://leetcode.com/problems/majority-element-ii/description/ Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space. Hint: How many majority elements could it possibly have? Do you have a better hint? Suggest it! 还没有解决，需要学习下这个解法 https://discuss.leetcode.com/topic/17564/boyer-moore-majority-vote-algorithm-and-my-elaboration Boyer-Moore Majority Vote algorithm and my elaboration For those who aren’t familiar with Boyer-Moore Majority Vote algorithm,I found a great article (http://goo.gl/64Nams) that helps me to understand this fantastic algorithm!!Please check it out! The essential concepts is you keep a counter for the majority number X. If you find a number Y that is not X, the current counter should deduce 1. The reason is that if there is 5 X and 4 Y, there would be one (5-4) more X than Y. This could be explained as “4 X being paired out by 4 Y”. And since the requirement is finding the majority for more than ceiling of [n/3], the answer would be less than or equal to two numbers.So we can modify the algorithm to maintain two counters for two majorities. Followings are my sample Python code: 1234567891011121314151617181920class Solution:# @param &#123;integer[]&#125; nums# @return &#123;integer[]&#125;def majorityElement(self, nums): if not nums: return [] count1, count2, candidate1, candidate2 = 0, 0, 0, 1 for n in nums: if n == candidate1: count1 += 1 elif n == candidate2: count2 += 1 elif count1 == 0: candidate1, count1 = n, 1 elif count2 == 0: candidate2, count2 = n, 1 else: count1, count2 = count1 - 1, count2 - 1 return [n for n in (candidate1, candidate2) if nums.count(n) &gt; len(nums) // 3] https://discuss.leetcode.com/topic/17396/boyer-moore-majority-vote-algorithm-generalization Boyer-Moore Majority Vote algorithm generalization Boyer-Moore Majority Vote algorithm generalization to elements appear more than floor(n/k) times 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt; &amp;a) &#123; int y = 0, z = 1, cy = 0, cz = 0; for (auto x: a) &#123; if (x == y) cy++; else if (x == z) cz++; else if (! cy) y = x, cy = 1; else if (! cz) z = x, cz = 1; else cy--, cz--; &#125; cy = cz = 0; for (auto x: a) if (x == y) cy++; else if (x == z) cz++; vector&lt;int&gt; r; if (cy &gt; a.size()/3) r.push_back(y); if (cz &gt; a.size()/3) r.push_back(z); return r; &#125;&#125;; https://discuss.leetcode.com/topic/17721/my-c-solution My C++ Solution 1234567891011121314151617181920212223242526272829303132333435vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; int cnt1 = 0, cnt2 = 0, a=0, b=1; for(auto n: nums)&#123; if (a==n)&#123; cnt1++; &#125; else if (b==n)&#123; cnt2++; &#125; else if (cnt1==0)&#123; a = n; cnt1 = 1; &#125; else if (cnt2 == 0)&#123; b = n; cnt2 = 1; &#125; else&#123; cnt1--; cnt2--; &#125; &#125; cnt1 = cnt2 = 0; for(auto n: nums)&#123; if (n==a) cnt1++; else if (n==b) cnt2++; &#125; vector&lt;int&gt; res; if (cnt1 &gt; nums.size()/3) res.push_back(a); if (cnt2 &gt; nums.size()/3) res.push_back(b); return res;&#125; https://discuss.leetcode.com/topic/23689/my-o-n-time-solution-20ms/3 My O(n) time solution ,20ms My idea comes from Majority Vote algroithm,http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html.Now we vote two numbers simultaneously. if the next number is differents from them both.then the two numbers’ votes minus one. If some number’s vote comes zero,then vote the next number.Every time vote minus,it is the same that we remove the three numbers from the array.And the majority elemnts of original still are the majority elements in the end. So check t1 and t2 are the majority elements of original array at last. 12345678910111213141516171819202122vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; int t1,t2,n1=0,n2=0; //numbers t1 and t2,votes&apos; numbers n1,and n2. for(int i=0;i&lt;nums.size();++i) &#123; if(n1!=0&amp;&amp;t1==nums[i])&#123;++n1;continue;&#125; if(n2!=0&amp;&amp;t2==nums[i])&#123;++n2;continue;&#125; if(n1==0)&#123; t1=nums[i];++n1;continue;&#125; if(n2==0)&#123; t2=nums[i];++n2;continue;&#125; --n1;--n2; &#125; int z1=0,z2=0; for(int i=0;i&lt;nums.size();++i) &#123; if(n1&gt;0)&#123; if(nums[i]==t1) ++z1;&#125; if(n2&gt;0) &#123;if(nums[i]==t2) ++z2;&#125; &#125; vector&lt;int&gt; ret; //check t1 and t2. if(z1&gt;nums.size()/3) ret.push_back(t1); if(z2&gt;nums.size()/3) ret.push_back(t2); return ret; &#125; https://discuss.leetcode.com/topic/17409/6-lines-general-case-o-n-time-and-o-k-space 6 lines, general case O(N) time and O(k) space Solution I keep up to two candidates in my counter, so this fulfills the O(N) time and O(1) space requirements. 1234567def majorityElement(self, nums): ctr = collections.Counter() for n in nums: ctr[n] += 1 if len(ctr) == 3: ctr -= collections.Counter(set(ctr)) return [n for n in ctr if nums.count(n) &gt; len(nums)/3] Explanation Think of it this way: Find three different votes and hide them. Repeat until there aren’t three different votes left. A number that originally had more than one third of the votes now still has at least one vote, because to hide all of its votes you would’ve had to hide more than three times one third of the votes - more votes than there were. You can easily have false positives, though, so in the end check whether the remaining up to two candidates actually had more than one third of the votes. My code does just that: Collect (count) the votes for every number, but remove triples of three different votes on the fly, as soon as we have such a triple. Generalization to ⌊N/k⌋, still O(N) time but O(k) space For the general problem, looking for elements appearing more than ⌊N/k⌋ times for some positive integer k, I just have to change my 3 to k. Then it already works and takes takes O(k) space and O(kN) time. The O(kN) time does not come from the main loop, though. Yes, each ctr -= … does cost k, but I only have to do it at most N/k times. To put it in terms of the above explanation, I can’t hide a vote more than once. No, the culprit is my last line, counting each remaining candidate separately. If I count them at the same time, I get O(N) again. Here’s the full generalized code: 12345678def majorityElement(self, nums, k): ctr = collections.Counter() for n in nums: ctr[n] += 1 if len(ctr) == k: ctr -= collections.Counter(set(ctr)) ctr = collections.Counter(n for n in nums if n in ctr) return [n for n in ctr if ctr[n] &gt; len(nums)/k] https://discuss.leetcode.com/topic/17473/c-solution-for-elements-appear-more-than-floor-n-k-times C++ solution for elements appear more than floor(n/k) times 12345678910111213141516171819202122232425vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; return majorityElement(nums, 3);&#125;vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums, const int k) &#123; const int size_n = nums.size(); vector&lt;int&gt; result; unordered_map&lt;int, int&gt; cand; for (int i = 0; i &lt; size_n; i++) &#123; cand[nums[i]]++; if (cand.size() == k) &#123; for (auto it = cand.begin(); it != cand.end(); ) &#123; if (--(it-&gt;second) == 0) it = cand.erase(it); else it++; &#125; &#125; &#125; for (auto&amp; item : cand) item.second = 0; for (auto&amp; item : nums) &#123; if (cand.count(item) &gt; 0) cand[item]++; &#125; for (auto&amp; item : cand) &#123; if (item.second &gt; size_n / k) result.emplace_back(item.first); &#125; return result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[228. Summary Ranges]]></title>
    <url>%2Fp%2F62fcefb8%2F</url>
    <content type="text"><![CDATA[28.7% https://leetcode.com/problems/summary-ranges/description/ Given a sorted integer array without duplicates, return the summary of its ranges. 123456Example 1:Input: [0,1,2,4,5,7]Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]Example 2:Input: [0,2,3,4,6,8,9]Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;] 方法一： 我的代码实现： 1234567891011121314151617181920class Solution &#123;public: vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123; vector&lt;string&gt; res; int i=0, n=nums.size(); while(i&lt;n)&#123; int j = i; while(j+1&lt;n &amp;&amp; nums[j+1]==nums[j]+1) j++; if(j==i) res.push_back(to_string(nums[i])); else&#123; string s = to_string(nums[i]) + "-&gt;" + to_string(nums[j]); res.push_back(s); &#125; i = j+1; &#125; return res; &#125;&#125;; 0ms, 14.20%, June.18th, 2016 https://leetcode.com/discuss/42229/10-line-c-easy-understand 10 line c++ easy understand 12345678910111213vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123; const int size_n = nums.size(); vector&lt;string&gt; res; if ( 0 == size_n) return res; for (int i = 0; i &lt; size_n;) &#123; int start = i, end = i; while (end + 1 &lt; size_n &amp;&amp; nums[end+1] == nums[end] + 1) end++; if (end &gt; start) res.push_back(to_string(nums[start]) + &quot;-&gt;&quot; + to_string(nums[end])); else res.push_back(to_string(nums[start])); i = end+1; &#125; return res;&#125; https://discuss.leetcode.com/topic/17154/9-lines-c-0ms-solution 9 lines, c++, 0ms solution 1234567891011vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123; int i = 0, size = nums.size(); vector&lt;string&gt; result; while(i &lt; size)&#123; int j = 1; while(i + j &lt; size &amp;&amp; nums[i + j] - nums[i] == j) ++j; result.push_back(j &lt;= 1 ? to_string(nums[i]) : to_string(nums[i]) + &quot;-&gt;&quot; + to_string(nums[i + j - 1])); i += j; &#125; return result; &#125; https://discuss.leetcode.com/topic/17177/idea-1-liner-group-by-number-index Idea + 1-Liner: Group by number-index The Idea The difference between a number and its index identifies the range. Consider the given example input: 123numbers: [0, 1, 2, 4, 5, 7]indexes: [0, 1, 2, 3, 4, 5]subtract: [0, 0, 0, 1, 1, 2] You can see I have three differences (0, 1 and 2), corresponding to the three ranges. That can then be used to group the elements. Solution 1 Ruby and Python can exploit it particularly well, thanks to their groupby functions: Python: 123def summaryRanges(self, nums): return [re.sub(&apos;-&gt;.*&gt;&apos;, &apos;-&gt;&apos;, &apos;-&gt;&apos;.join(`n` for i, n in g)) for _, g in itertools.groupby(enumerate(nums), lambda (i, n): n-i)] Solution 2 Here I build two dicts, telling me the first and last number of each range. For the given example I get: 12first = &#123;0: 0, 1: 4, 2: 7&#125;last = &#123;0: 2, 1: 5, 2: 7&#125; The code: 1234def summaryRanges(self, nums): diff = [(n-i, n) for i, n in enumerate(nums)] first, last = dict(diff[::-1]), dict(diff) return [`n` + (&apos;-&gt;&apos;+`last[d]`)*(n&lt;last[d]) for d, n in sorted(first.items())] Solution 3 Storing [first, last] for each range in a dict (last being optional). 12345def summaryRanges(self, nums): ranges = collections.defaultdict(list) for i, n in enumerate(nums): ranges[n-i][1:] = n, return [&apos;-&gt;&apos;.join(map(str, r)) for r in sorted(ranges.values())] https://discuss.leetcode.com/topic/17094/6-lines-in-python 6 lines in Python Three versions of the same algorithm, all take O(n) time. Solution 1 Just collect the ranges, then format and return them. 1234567def summaryRanges(self, nums): ranges = [] for n in nums: if not ranges or n &gt; ranges[-1][-1] + 1: ranges += [], ranges[-1][1:] = n, return [&apos;-&gt;&apos;.join(map(str, r)) for r in ranges] Solution 2 A variation of solution 1, holding the current range in an extra variable r to make things easier. Note that r contains at most two elements, so the in-check takes constant time. 12345678def summaryRanges(self, nums): ranges, r = [], [] for n in nums: if n-1 not in r: r = [] ranges += r, r[1:] = n, return [&apos;-&gt;&apos;.join(map(str, r)) for r in ranges] Solution 3 A tricky short version. 12345678def summaryRanges(self, nums): ranges = r = [] for n in nums: if `n-1` not in r: r = [] ranges += r, r[1:] = `n`, return map(&apos;-&gt;&apos;.join, ranges) About the commas :-) Three people asked about them in the comments, so I’ll also explain it here as well. I have these two basic cases: 12ranges += [],r[1:] = n, Why the trailing commas? Because it turns the right hand side into a tuple and I get the same effects as these more common alternatives: 12345ranges += [[]]orranges.append([])r[1:] = [n] Without the comma, … ranges += [] wouldn’t add [] itself but only its elements, i.e., nothing. r[1:] = n wouldn’t work, because my n is not an iterable. Why do it this way instead of the more common alternatives I showed above? Because it’s shorter and faster (according to tests I did a while back). https://discuss.leetcode.com/topic/17934/my-easy-to-understand-python-solution My easy to understand Python solution 1234567891011121314151617def summaryRanges(self, nums): if not nums: return [] res, i, start = [], 0, 0 while i &lt; len(nums)-1: if nums[i]+1 != nums[i+1]: res.append(self.printRange(nums[start], nums[i])) start = i+1 i += 1 res.append(self.printRange(nums[start], nums[i])) return resdef printRange(self, l, r): if l == r: return str(l) else: return str(l) + &quot;-&gt;&quot; + str(r) Solution Mine: 40ms, 84.94%, June.18th, 2016 123456789101112131415161718192021222324252627class Solution(object): def summaryRanges(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[str] &quot;&quot;&quot; if not nums: return [] if len(nums)==1: return [str(nums[0])] rtype = [] p1 = 0 p2 = 0 n = len(nums) while p1 &lt; n-1: while p2 &lt; n-1 and nums[p2] + 1 == nums[p2+1]: p2 += 1 if p1 == p2: rtype.append(str(nums[p1])) else: tmp = str(nums[p1]) + &apos;-&gt;&apos; + str(nums[p2]) rtype.append(tmp) p2 += 1 p1 = p2 if p1 == n-1: rtype.append(str(nums[-1])) return rtype Solution 1: 48ms, 38.46%, June.18th, 2016 https://leetcode.com/discuss/42199/6-lines-in-python 123456789101112class Solution(object): def summaryRanges(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[str] &quot;&quot;&quot; ranges = [] for n in nums: if not ranges or n &gt; ranges[-1][-1] + 1: ranges += [], ranges[-1][1:] = n, return [&apos;-&gt;&apos;.join(map(str, i)) for i in ranges] 1ms, 5.00%, June.18th, 2016 https://leetcode.com/discuss/42290/accepted-java-solution-easy-to-understand 1234567891011121314151617public class Solution &#123; public List&lt;String&gt; summaryRanges(int[] nums) &#123; List&lt;String&gt; list = new ArrayList(); if(nums.length == 1)&#123; list.add(nums[0] + &quot;&quot;); return list; &#125; for(int i=0; i &lt; nums.length; i++)&#123; int a = nums[i]; while(i+1&lt;nums.length &amp;&amp; nums[i+1] - nums[i] ==1) i++; if(a != nums[i]) list.add(a + &quot;-&gt;&quot; + nums[i]); else list.add(a+&quot;&quot;); &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[227. Basic Calculator II]]></title>
    <url>%2Fp%2Fec140a05%2F</url>
    <content type="text"><![CDATA[28.5% https://leetcode.com/problems/basic-calculator-ii/#/description Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero. You may assume that the given expression is always valid. 1234Some examples:&quot;3+2*2&quot; = 7&quot; 3/2 &quot; = 1&quot; 3+5 / 2 &quot; = 5 Note: Do not use the eval built-in library function. 方法一： 学习一个str的方法，find_first_not_of find_first_not_of() isdigit函数，判断是否为数字 https://discuss.leetcode.com/topic/17323/my-16-ms-no-stack-one-pass-short-c-solution My 16 ms No stack One pass short C++ solution 12345678910111213141516171819202122232425262728class Solution &#123;public: int calculate(string s) &#123; int result = 0, cur_res = 0; char op = &apos;+&apos;; for(int pos = s.find_first_not_of(&apos; &apos;); pos &lt; s.size(); pos = s.find_first_not_of(&apos; &apos;, pos)) &#123; if(isdigit(s[pos])) &#123; int tmp = s[pos] - &apos;0&apos;; while(++pos &lt; s.size() &amp;&amp; isdigit(s[pos])) tmp = tmp*10 + (s[pos] - &apos;0&apos;); switch(op) &#123; case &apos;+&apos; : cur_res += tmp; break; case &apos;-&apos; : cur_res -= tmp; break; case &apos;*&apos; : cur_res *= tmp; break; case &apos;/&apos; : cur_res /= tmp; break; &#125; &#125; else &#123; if(s[pos] == &apos;+&apos; || s[pos] == &apos;-&apos;) &#123; result += cur_res; cur_res = 0; &#125; op = s[pos++]; &#125; &#125; return result + cur_res; &#125;&#125;; https://discuss.leetcode.com/topic/30568/c-stack-solution C++ stack solution. 12345678910111213141516171819202122232425262728293031int calculate(string s) &#123; stack&lt;int&gt; myStack; char sign = &apos;+&apos;; int res = 0, tmp = 0; for (unsigned int i = 0; i &lt; s.size(); i++) &#123; if (isdigit(s[i])) tmp = 10*tmp + s[i]-&apos;0&apos;; if (!isdigit(s[i]) &amp;&amp; !isspace(s[i]) || i == s.size()-1) &#123; if (sign == &apos;-&apos;) myStack.push(-tmp); else if (sign == &apos;+&apos;) myStack.push(tmp); else &#123; int num; if (sign == &apos;*&apos; ) num = myStack.top()*tmp; else num = myStack.top()/tmp; myStack.pop(); myStack.push(num); &#125; sign = s[i]; tmp = 0; &#125; &#125; while (!myStack.empty()) &#123; res += myStack.top(); myStack.pop(); &#125; return res;&#125; https://discuss.leetcode.com/topic/16807/17-lines-c-easy-20-ms 17 lines C++, easy, 20 ms If you don’t like the 44 - op ASCII trick, you can use op == ‘+’ ? 1 : -1 instead. And wow, I didn’t know C++ has or. I’m a Python guy and wrote that out of habit and only realized it after getting this accepted :-) 12345678910111213141516171819int calculate(string s) &#123; istringstream in(&apos;+&apos; + s + &apos;+&apos;); long long total = 0, term = 0, n; char op; while (in &gt;&gt; op) &#123; if (op == &apos;+&apos; or op == &apos;-&apos;) &#123; total += term; in &gt;&gt; term; term *= 44 - op; &#125; else &#123; in &gt;&gt; n; if (op == &apos;*&apos;) term *= n; else term /= n; &#125; &#125; return total;&#125; https://discuss.leetcode.com/topic/17213/my-28ms-c-code-with-two-stacks-one-for-op-one-for-oprand-extension-to-cover-also-given My 28ms C++ code with two stacks (one for op, one for oprand), extension to cover ‘(‘ &amp; ‘)’ also given Use two stacks : one to save operators, one to save oprands. Every time, if we get a digit, then update curNum, if we get an operator, then it means we get a complete oprand, which is saved in curNum; if the last operator is * or /, then calculate it, otherwise, just save curNum and s[i] (new operator) in the stacks. At last, the opS stack has only “+” &amp; “-“, which are the sign of the corresponding operands saved in numS. Then we do sum to get the result. 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int calculate(string s) &#123; stack&lt;char&gt; opS; stack&lt;int&gt; numS; s.push_back(&apos;)&apos;); // to make sure the last operand will be saved in the stack e.g. 1+2*3), 2*3 will be calculated and push in the stack opS.push(&apos;+&apos;); // sign for the first operand int i, curNum, len = s.size(), res =0; for(i=0,curNum=0; i&lt;len; ++i) &#123; if(isdigit(s[i])) curNum = curNum*10 + s[i] -&apos;0&apos;; // digit, recover the oprand else if(isspace(s[i])) continue; // skip the space else &#123; switch(opS.top()) &#123; case &apos;*&apos;: // if the last operator is * / , do calculation case &apos;/&apos;: curNum = opS.top()==&apos;/&apos;?numS.top()/curNum : numS.top()*curNum; opS.pop(); numS.pop(); &#125; numS.push(curNum); / curNum = 0; opS.push(s[i]); &#125; &#125; opS.pop(); // skip the &quot;)&quot; while(!opS.empty()) &#123;res += (opS.top()==&apos;-&apos;)? -numS.top(): numS.top(); opS.pop(); numS.pop();&#125; return res; &#125;&#125;; The below version covers both +-*/ and () 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123;public: int calculate(string s) &#123; stack&lt;char&gt; opS; stack&lt;int&gt; numS; s = &apos;(&apos; + s + &apos;)&apos;; int i, curNum = 0, len = s.size(); for(i=0; i&lt;len; ++i) &#123; if(isdigit(s[i])) curNum = curNum*10 + s[i] -&apos;0&apos;; else if(isspace(s[i])) continue; else if(s[i] == &apos;(&apos;) &#123; opS.push(&apos;(&apos;); opS.push(&apos;+&apos;); &#125; else &#123; switch(opS.top()) &#123; case &apos;*&apos;: case &apos;/&apos;: curNum = opS.top()==&apos;/&apos;?numS.top()/curNum : numS.top()*curNum; opS.pop(); numS.pop(); &#125; switch(s[i]) &#123; case &apos;)&apos;: if(&apos;-&apos;== opS.top()) curNum = -curNum; opS.pop(); while(opS.top()!=&apos;(&apos;) &#123; curNum += (opS.top()==&apos;-&apos;)? -numS.top(): numS.top(); opS.pop(); numS.pop(); &#125; opS.pop(); // skip &apos;(&apos; break; default: //+,-,*,/ opS.push(s[i]); numS.push(curNum); curNum = 0; &#125; &#125; &#125; return curNum; &#125;&#125;; https://discuss.leetcode.com/topic/22170/python-short-solution-with-stack Python short solution with stack. 212ms, 79.87%, September 22, 2016 1234567891011121314151617181920212223def calculate(self, s): if not s: return &quot;0&quot; stack, num, sign = [], 0, &quot;+&quot; for i in xrange(len(s)): if s[i].isdigit(): num = num*10+ord(s[i])-ord(&quot;0&quot;) if (not s[i].isdigit() and not s[i].isspace()) or i == len(s)-1: if sign == &quot;-&quot;: stack.append(-num) elif sign == &quot;+&quot;: stack.append(num) elif sign == &quot;*&quot;: stack.append(stack.pop()*num) else: tmp = stack.pop() if tmp//num &lt; 0 and tmp%num != 0: stack.append(tmp//num+1) else: stack.append(tmp//num) sign = s[i] num = 0 return sum(stack) https://discuss.leetcode.com/topic/16803/easy-7-12-lines-three-solutions Easy 7-12 lines, Three solutions Three quite different Python solutions. Solution 1: Split the splits (10 lines, 520 ms) Split the expression into terms on + and -. Split each term into numbers on * and /. 1234567891011def calculate(self, s): total = 0 outer = iter([&apos;+&apos;] + re.split(&apos;([+-])&apos;, s)) for addsub in outer: inner = iter([&apos;*&apos;] + re.split(&apos;([*/])&apos;, next(outer))) term = 1 for muldiv in inner: n = int(next(inner)) term = term*n if muldiv == &apos;*&apos; else term/n total += term if addsub == &apos;+&apos; else -term return total Solution 2: Process tokens from left to right (12 lines, 224 ms): Iterate over the tokens (numbers and operators), keeping track of the current total, the current term sign (+1 or -1), and the current term value. 12345678910111213def calculate(self, s): tokens = iter(re.findall(&apos;\d+|\S&apos;, s)) total, sign = 0, 1 for token in tokens: if token in &apos;+-&apos;: total += sign * term sign = &apos; +&apos;.find(token) elif token in &apos;*/&apos;: n = int(next(tokens)) term = term*n if token == &apos;*&apos; else term/n else: term = int(token) return total + sign * term I could make that one more space-efficient with 1tokens = (m.group() for m in re.finditer(&apos;\d+|\S&apos;, s)) but that’s less pretty and it actually increased the runtime by about 100 ms. Also, I could add + to the input (i.e., findall(…, s + ‘+’)), then I could just return total and wouldn’t have to add the final term there. Pretty much doesn’t change the runtime. Solution 3: First or second operation, repeat… (7 lines, 244 ms) As long as there is any operation left to do, do either the first or the second operation, depending on what they are. Implemented by putting the tokens in a list in reverse order, because making a change at the end of the list is O(1) and making a change at the start would be O(n). 12345678def calculate(self, s): t = re.findall(&apos;\d+|\S&apos;, s + &apos;+0&apos;)[::-1] t[::2] = map(int, t[::2]) while len(t) &gt; 3: i = len(t) - 5 + 2 * (t[-2] in &apos;*/&apos; or t[-4] not in &apos;*/&apos;) b, op, a = t[i:i+3] t[i:i+3] = a+b if op==&apos;+&apos; else a-b if op==&apos;-&apos; else a*b if op==&apos;*&apos; else a/b, return t[2]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[226. Invert Binary Tree]]></title>
    <url>%2Fp%2Ff3118605%2F</url>
    <content type="text"><![CDATA[51.8% https://leetcode.com/problems/invert-binary-tree/#/description 12345678910111213Invert a binary tree. 4 / \ 2 7 / \ / \1 3 6 9to 4 / \ 7 2 / \ / \9 6 3 1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off. 对应剑指offer 19题 三种方法：递归、DFS、BFS 方法一：递归 1234567891011121314public class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; final TreeNode left = root.left, right = root.right; root.left = invertTree(right); root.right = invertTree(left); return root; &#125;&#125; 我的实现： 1234567891011class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(root==NULL) return root; TreeNode* left = invertTree(root-&gt;left); TreeNode* right = invertTree(root-&gt;right); root-&gt;left = right; root-&gt;right = left; return root; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return root; TreeNode* left = invertTree(root-&gt;left); TreeNode* right = invertTree(root-&gt;right); root-&gt;right = left; root-&gt;left = right; return root; &#125;&#125;; 方法二：DFS，使用栈作为辅助，使用栈的方法是把root压入栈，栈不为空时，弹出当前栈顶，针对栈顶的左右节点进行反转，若左非空，左压入，右非空，右压入 1234567891011121314151617181920212223242526public class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; final Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) &#123; final TreeNode node = stack.pop(); final TreeNode left = node.left; node.left = node.right; node.right = left; if(node.left != null) &#123; stack.push(node.left); &#125; if(node.right != null) &#123; stack.push(node.right); &#125; &#125; return root; &#125;&#125; 方法三： BFS，层序遍历的方法，注意，要把层序当做先序，中序，后续遍历一样普通和容易想到的方法。 层序遍历，具体cpp实现，还需要再思考。 1234567891011121314151617181920212223242526public class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; final Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()) &#123; final TreeNode node = queue.poll(); final TreeNode left = node.left; node.left = node.right; node.right = left; if(node.left != null) &#123; queue.offer(node.left); &#125; if(node.right != null) &#123; queue.offer(node.right); &#125; &#125; return root; &#125;&#125; https://discuss.leetcode.com/topic/16138/recursive-and-non-recursive-c-both-4ms/3 Recursive and non-recursive C++ both 4ms Recursive 12345678TreeNode* invertTree(TreeNode* root) &#123; if (root) &#123; invertTree(root-&gt;left); invertTree(root-&gt;right); std::swap(root-&gt;left, root-&gt;right); &#125; return root;&#125; Non-Recursive 123456789101112131415TreeNode* invertTree(TreeNode* root) &#123; std::stack&lt;TreeNode*&gt; stk; stk.push(root); while (!stk.empty()) &#123; TreeNode* p = stk.top(); stk.pop(); if (p) &#123; stk.push(p-&gt;left); stk.push(p-&gt;right); std::swap(p-&gt;left, p-&gt;right); &#125; &#125; return root;&#125; https://discuss.leetcode.com/topic/16062/3-4-lines-python/4 3-4 lines Python 1234def invertTree(self, root): if root: root.left, root.right = self.invertTree(root.right), self.invertTree(root.left) return root Maybe make it four lines for better readability: 12345def invertTree(self, root): if root: invert = self.invertTree root.left, root.right = invert(root.right), invert(root.left) return root And an iterative version using my own stack: 12345678def invertTree(self, root): stack = [root] while stack: node = stack.pop() if node: node.left, node.right = node.right, node.left stack += node.left, node.right return root https://discuss.leetcode.com/topic/21271/python-solutions-recursively-dfs-bfs Python solutions (recursively, dfs, bfs). 1234567891011121314151617181920212223242526# recursivelydef invertTree1(self, root): if root: root.left, root.right = self.invertTree(root.right), self.invertTree(root.left) return root # BFSdef invertTree2(self, root): queue = collections.deque([(root)]) while queue: node = queue.popleft() if node: node.left, node.right = node.right, node.left queue.append(node.left) queue.append(node.right) return root # DFSdef invertTree(self, root): stack = [root] while stack: node = stack.pop() if node: node.left, node.right = node.right, node.left stack.extend([node.right, node.left]) return root https://discuss.leetcode.com/topic/16039/straightforward-dfs-recursive-iterative-bfs-solutions/3 Straightforward DFS recursive, iterative, BFS solutions As in many other cases this problem has more than one possible solutions: Lets start with straightforward - recursive DFS - it’s easy to write and pretty much concise. 1234567891011121314public class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; final TreeNode left = root.left, right = root.right; root.left = invertTree(right); root.right = invertTree(left); return root; &#125;&#125; The above solution is correct, but it is also bound to the application stack, which means that it’s no so much scalable - (you can find the problem size that will overflow the stack and crash your application), so more robust solution would be to use stack data structure. 1234567891011121314151617181920212223242526public class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; final Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) &#123; final TreeNode node = stack.pop(); final TreeNode left = node.left; node.left = node.right; node.right = left; if(node.left != null) &#123; stack.push(node.left); &#125; if(node.right != null) &#123; stack.push(node.right); &#125; &#125; return root; &#125;&#125; Finally we can easly convert the above solution to BFS - or so called level order traversal. 1234567891011121314151617181920212223242526public class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; final Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty()) &#123; final TreeNode node = queue.poll(); final TreeNode left = node.left; node.left = node.right; node.right = left; if(node.left != null) &#123; queue.offer(node.left); &#125; if(node.right != null) &#123; queue.offer(node.right); &#125; &#125; return root; &#125;&#125; If I can write this code, does it mean I can get job at Google? ;)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[225. Implement Stack using Queues]]></title>
    <url>%2Fp%2Fdb897a5%2F</url>
    <content type="text"><![CDATA[31.7% https://leetcode.com/problems/implement-stack-using-queues/#/description Implement the following operations of a stack using queues. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. empty() – Return whether the stack is empty. Notes: You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). 方法一: 使用一个队列，当push时，push进去，然后将队列中前面的都放到新来的后面，这样将来top货pop时，就可以只用调用front和pop函数了。 注意queue的函数，包括front，pop，push，size等。尤其注意可以用size()函数。 剑指 offer第7题 我的代码实现： Oct 10th, 2017 1234567891011121314151617181920212223242526272829303132333435363738394041424344class MyStack &#123;public: queue&lt;int&gt; que; /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; que.push(x); int n = que.size(); for(int i=0; i&lt;n-1; i++)&#123; int val = que.front(); que.pop(); que.push(val); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int val = que.front(); que.pop(); return val; &#125; /** Get the top element. */ int top() &#123; return que.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return que.empty(); &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * bool param_4 = obj.empty(); */ 12345678910111213141516171819202122232425262728293031323334class MyStack &#123; queue&lt;int&gt; que;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; que.push(x); for(int i=0; i&lt;que.size()-1; i++)&#123; que.push(que.front()); que.pop(); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int val = que.front(); que.pop(); return val; &#125; /** Get the top element. */ int top() &#123; return que.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return que.empty(); &#125;&#125;; 0ms, 11.57%, 20 July 2016 https://discuss.leetcode.com/topic/19227/a-simple-c-solution 123456789101112131415161718192021222324252627class Stack &#123;public: queue&lt;int&gt; que; // Push element x onto stack. void push(int x) &#123; que.push(x); for(int i=0; i&lt;que.size()-1; ++i)&#123; que.push(que.front()); que.pop(); &#125; &#125; // Removes the element on top of the stack. void pop() &#123; que.pop(); &#125; // Get the top element. int top() &#123; return que.front(); &#125; // Return whether the stack is empty. bool empty() &#123; return que.empty(); &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[224. Basic Calculator]]></title>
    <url>%2Fp%2Fe3f3672e%2F</url>
    <content type="text"><![CDATA[26.0% https://leetcode.com/problems/basic-calculator/?tab=Description Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces . You may assume that the given expression is always valid. 1234Some examples:&quot;1 + 1&quot; = 2&quot; 2-1 + 2 &quot; = 3&quot;(1+(4+5+2)-3)+(6+8)&quot; = 23 Note: Do not use the eval built-in library function. 需要继续学习 方法一： https://discuss.leetcode.com/topic/22359/16-ms-solution-in-c-with-stacks 16 ms solution in C++ with stacks 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int calculate(string s) &#123; stack &lt;int&gt; nums, ops; int num = 0; int rst = 0; int sign = 1; for (char c : s) &#123; if (isdigit(c)) &#123; num = num * 10 + c - &apos;0&apos;; &#125; else &#123; rst += sign * num; num = 0; if (c == &apos;+&apos;) sign = 1; if (c == &apos;-&apos;) sign = -1; if (c == &apos;(&apos;) &#123; nums.push(rst); ops.push(sign); rst = 0; sign = 1; &#125; if (c == &apos;)&apos; &amp;&amp; ops.size()) &#123; rst = ops.top() * rst + nums.top(); ops.pop(); nums.pop(); &#125; &#125; &#125; rst += sign * num; return rst; &#125;&#125;; 方法二： 26ms, September 13, 2016 https://discuss.leetcode.com/topic/15806/easy-18-lines-c-16-lines-python Easy 18 lines C++, 16 lines Python Keep a global running total and a stack of signs (+1 or -1), one for each open scope. The “global” outermost sign is +1. Each number consumes a sign. Each + and - causes a new sign. Each ( duplicates the current sign so it can be used for the first term inside the new scope. That’s also why I start with [1, 1] - the global sign 1 and a duplicate to be used for the first term, since expressions start like 3… or (…, not like +3… or +(…. Each ) closes the current scope and thus drops the current sign. Also see the example trace below my programs. C++: 1234567891011121314151617181920int calculate(string s) &#123; int total = 0; vector&lt;int&gt; signs(2, 1); for (int i=0; i&lt;s.size(); i++) &#123; char c = s[i]; if (c &gt;= &apos;0&apos;) &#123; int number = 0; while (i &lt; s.size() &amp;&amp; s[i] &gt;= &apos;0&apos;) number = 10 * number + s[i++] - &apos;0&apos;; total += signs.back() * number; signs.pop_back(); i--; &#125; else if (c == &apos;)&apos;) signs.pop_back(); else if (c != &apos; &apos;) signs.push_back(signs.back() * (c == &apos;-&apos; ? -1 : 1)); &#125; return total;&#125; Python: 1234567891011121314151617def calculate(self, s): total = 0 i, signs = 0, [1, 1] while i &lt; len(s): c = s[i] if c.isdigit(): start = i while i &lt; len(s) and s[i].isdigit(): i += 1 total += signs.pop() * int(s[start:i]) continue if c in &apos;+-(&apos;: signs += signs[-1] * (1, -1)[c == &apos;-&apos;], elif c == &apos;)&apos;: signs.pop() i += 1 return total Example trace: 123456789101112131415Here&apos;s an example trace for input 3-(2+(9-4)). remaining sign stack total3-(2+(9-4)) [1, 1] 0 -(2+(9-4)) [1] 3 (2+(9-4)) [1, -1] 3 2+(9-4)) [1, -1, -1] 3 +(9-4)) [1, -1] 1 (9-4)) [1, -1, -1] 1 9-4)) [1, -1, -1, -1] 1 -4)) [1, -1, -1] -8 4)) [1, -1, -1, 1] -8 )) [1, -1, -1] -4 ) [1, -1] -4 [1] -4 If you want to see traces for other examples, you can add this at the start inside the loop and after the loop (that’s for the Python solution, where it’s all easier): 1print &apos;%11s %-16s %2d&apos; % (s[i:], signs, total) https://discuss.leetcode.com/topic/15775/simple-c-in-24-ms Simple c++ in 24 ms 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int calculate(string s) &#123; // the given expression is always valid!!! // only + and - !!! // every + and - can be flipped base on it&apos;s depth in (). stack&lt;int&gt; signs; int sign = 1; int num = 0; int ans = 0; // always transform s into ( s ) signs.push(1); for (auto c : s) &#123; if (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) &#123; num = 10 * num + c - &apos;0&apos;; &#125; else if (c == &apos;+&apos; || c == &apos;-&apos;) &#123; ans = ans + signs.top() * sign * num; num = 0; sign = (c == &apos;+&apos; ? 1 : -1); &#125; else if (c == &apos;(&apos;) &#123; signs.push(sign * signs.top()); sign = 1; &#125; else if (c == &apos;)&apos;) &#123; ans = ans + signs.top() * sign * num; num = 0; signs.pop(); sign = 1; &#125; &#125; if (num) &#123; ans = ans + signs.top() * sign * num; &#125; return ans; &#125;&#125;; python https://discuss.leetcode.com/topic/25775/python-concise-solution-with-stack Python concise solution with stack. 12345678910111213141516171819def calculate(self, s): res, num, sign, stack = 0, 0, 1, [] for ss in s: if ss.isdigit(): num = 10*num + int(ss) elif ss in [&quot;-&quot;, &quot;+&quot;]: res += sign*num num = 0 sign = [-1, 1][ss==&quot;+&quot;] elif ss == &quot;(&quot;: stack.append(res) stack.append(sign) sign, res = 1, 0 elif ss == &quot;)&quot;: res += sign*num res *= stack.pop() res += stack.pop() num = 0 return res + num*sign https://discuss.leetcode.com/topic/37951/python-with-stack Python with stack This solution uses stack to store previous result and sign when encounter a “(“ For this problem storing sign is enough, and will be faster. 1234567891011121314151617def calculate(self, s): res, num, sign, stack = 0, 0, 1, [1] for i in s+&quot;+&quot;: if i.isdigit(): num = 10*num + int(i) elif i in &quot;+-&quot;: res += num * sign * stack[-1] sign = 1 if i==&quot;+&quot; else -1 num = 0 elif i == &quot;(&quot;: stack.append(sign * stack[-1]) sign = 1 elif i == &quot;)&quot;: res += num * sign * stack[-1] num = 0 stack.pop() return res https://discuss.leetcode.com/topic/15932/ac-python-solution AC Python Solution 123456789101112131415161718class Solution:def calculate(self, s): s = &apos;+(+&apos; + s + &apos;)&apos; s = s.replace(&apos;+-&apos;, &apos;-&apos;).replace(&apos;++&apos;, &apos;+&apos;) # for the corner case &apos;-5&apos;, &apos;+5&apos; stack = [] for i in s: if i == &apos;)&apos;: total = 0 while stack[-1] != &apos;(&apos;: total += int(stack.pop()) stack.pop() sign = 1 if stack.pop() == &apos;+&apos; else -1 stack.append(sign * total) elif i.isdigit() and stack[-1][-1] in &apos;+-0123456789&apos;: stack[-1] += i elif i != &apos; &apos;: stack.append(i) return stack[0] java https://discuss.leetcode.com/topic/15816/iterative-java-solution-with-stack Iterative Java solution with stack Simple iterative solution by identifying characters one by one. One important thing is that the input is valid, which means the parentheses are always paired and in order. Only 5 possible input we need to pay attention: digit: it should be one digit from the current number ‘+’: number is over, we can add the previous number and start a new number ‘-‘: same as above ‘(‘: push the previous result and the sign into the stack, set result to 0, just calculate the new result within the parenthesis. ‘)’: pop out the top two numbers from stack, first one is the sign before this pair of parenthesis, second is the temporary result before this pair of parenthesis. We add them together. Finally if there is only one number, from the above solution, we haven’t add the number to the result, so we do a check see if the number is zero. 1234567891011121314151617181920212223242526272829303132333435public int calculate(String s) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int result = 0; int number = 0; int sign = 1; for(int i = 0; i &lt; s.length(); i++)&#123; char c = s.charAt(i); if(Character.isDigit(c))&#123; number = 10 * number + (int)(c - &apos;0&apos;); &#125;else if(c == &apos;+&apos;)&#123; result += sign * number; number = 0; sign = 1; &#125;else if(c == &apos;-&apos;)&#123; result += sign * number; number = 0; sign = -1; &#125;else if(c == &apos;(&apos;)&#123; //we push the result first, then sign; stack.push(result); stack.push(sign); //reset the sign and result for the value in the parenthesis sign = 1; result = 0; &#125;else if(c == &apos;)&apos;)&#123; result += sign * number; number = 0; result *= stack.pop(); //stack.pop() is the sign before the parenthesis result += stack.pop(); //stack.pop() now is the result calculated before the parenthesis &#125; &#125; if(number != 0) result += sign * number; return result;&#125; https://discuss.leetcode.com/topic/15816/iterative-java-solution-with-stack/2 +1 for your concise and clean code. My solution seems to be really different from others.First I reformed the input expression by rules of: remove all ‘(‘, ‘)’, ‘ ‘; reverse the express string; add ‘+’ or ‘-‘ to the end of the express.By this approach, the reformed expression will be easy to handled. 1234&quot;1 + 1&quot; =&gt; &quot;1+1+&quot;&quot; 2-1 + 2 &quot; =&gt; &quot;2+1-2+&quot;&quot;(1+(4+5+2)-3)+(6+8)&quot; =&gt; &quot;8+6+3-2+5+4+1+&quot;&quot;2-(5-6)&quot; =&gt; &quot;6+5-2+&quot; Java code: 1234567891011121314151617181920212223242526272829303132333435363738public int calculate(String s) &#123; if(s == null) return 0; s = reform(s); int result = 0, num = 0, base = 1; for(char c: s.toCharArray()) switch(c)&#123; case &apos;+&apos;: result += num; num = 0; base = 1; break; case &apos;-&apos;: result -= num; num = 0; base = 1; break; default: num += (c - &apos;0&apos;) * base; base *= 10; &#125; return result;&#125;private String reform(String s) &#123; StringBuilder sb = new StringBuilder(); Stack&lt;Boolean&gt; stack = new Stack&lt;&gt;(); stack.push(true); boolean add = true; for(char c: s.toCharArray()) switch(c)&#123; case &apos; &apos;: break; case &apos;(&apos;: stack.push(add); break; case &apos;)&apos;: stack.pop(); break; case &apos;+&apos;: add = stack.peek(); sb.append(stack.peek() ? &apos;+&apos; : &apos;-&apos;); break; case &apos;-&apos;: add = !stack.peek(); sb.append(stack.peek() ? &apos;-&apos; : &apos;+&apos;); break; default: sb.append(c); &#125; if(sb.charAt(0) != &apos;+&apos; || sb.charAt(0) != &apos;-&apos;) sb.insert(0, &apos;+&apos;); return sb.reverse().toString();&#125; https://discuss.leetcode.com/topic/33044/java-easy-version-to-understand JAVA———–Easy Version To Understand!!!!! 123456789101112131415161718192021222324252627public static int calculate(String s) &#123; int len = s.length(), sign = 1, result = 0; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for (int i = 0; i &lt; len; i++) &#123; if (Character.isDigit(s.charAt(i))) &#123; int sum = s.charAt(i) - &apos;0&apos;; while (i + 1 &lt; len &amp;&amp; Character.isDigit(s.charAt(i + 1))) &#123; sum = sum * 10 + s.charAt(i + 1) - &apos;0&apos;; i++; &#125; result += sum * sign; &#125; else if (s.charAt(i) == &apos;+&apos;) sign = 1; else if (s.charAt(i) == &apos;-&apos;) sign = -1; else if (s.charAt(i) == &apos;(&apos;) &#123; stack.push(result); stack.push(sign); result = 0; sign = 1; &#125; else if (s.charAt(i) == &apos;)&apos;) &#123; result = result * stack.pop() + stack.pop(); &#125; &#125; return result;&#125; java28ms, September 13, 2016 https://discuss.leetcode.com/topic/33044/java-easy-version-to-understand 123456789101112131415161718192021222324252627public class Solution &#123; public int calculate(String s) &#123; int len = s.length(), sign = 1, result = 0; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for(int i = 0; i &lt; len; i++)&#123; if(Character.isDigit(s.charAt(i)))&#123; int sum = s.charAt(i) - &apos;0&apos;; while(i + 1 &lt; len &amp;&amp; Character.isDigit(s.charAt(i+1)))&#123; sum = sum * 10 + s.charAt(i+1) - &apos;0&apos;; i++; &#125; result += sum * sign; &#125;else if(s.charAt(i) == &apos;+&apos;) sign = 1; else if(s.charAt(i) == &apos;-&apos;) sign = -1; if(s.charAt(i)== &apos;(&apos;)&#123; stack.push(result); stack.push(sign); result = 0; sign = 1; &#125;else if(s.charAt(i) == &apos;)&apos;) result = result * stack.pop() + stack.pop(); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>hard</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[223. Rectangle Area]]></title>
    <url>%2Fp%2Ff73f178%2F</url>
    <content type="text"><![CDATA[32.3% https://leetcode.com/problems/rectangle-area/ Find the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure. Assume that the total area is never beyond the maximum possible value of int. 需要思考 cppsolution 1: 36ms, 20.98%, July 16th, 2016 https://discuss.leetcode.com/topic/17534/if-you-want-to-laugh-look-at-my-solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123;public: int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int area1 = (D - B)*(C - A); int area2 = (H - F)*(G - E); int area3; if (area1 == 0) &#123; return area2; &#125; if (area2 == 0) &#123; return area1; &#125; if ((A == D) &amp;&amp; (B == F) &amp;&amp; (C == G) &amp;&amp; (D == H)) &#123; return area1; &#125; if ((E &gt;= C) | (G &lt;= A) | (H &lt;= B) | (D &lt;= F)) &#123; //not overlapping return (area1 + area2); &#125; if (((G - E) &lt;= (C - A)) &amp;&amp; ((H - F) &lt;= (D - B)) &amp;&amp; (E &gt;= A) &amp;&amp; (F &gt;= B) &amp;&amp; (G &lt;= C) &amp;&amp; (D &gt;= H)) &#123; //rect2 is inside rect1 return area1; &#125; if (((C - A) &lt;= (G - E)) &amp;&amp; ((D - B) &lt;= (H - F)) &amp;&amp; (E &lt;= A) &amp;&amp; (B &gt;= F) &amp;&amp; (G &gt;= C) &amp;&amp; (H &gt;= D)) &#123; //rect1 is inside rect2 return area2; &#125; if ((F &gt;= B) &amp;&amp; (E &gt;= A) &amp;&amp; (G &gt;= C) &amp;&amp; (H &gt;= D)) &#123; //overlapping upper right corner area3 = (C - E)*(D - F); &#125; else if ((F &gt;= B) &amp;&amp; (E &lt;= A) &amp;&amp; (G &lt;= C) &amp;&amp; (H &gt;= D)) &#123; //overlapping upper left corner area3 = (G - A)*(D - F); &#125; else if ((F &lt;= B) &amp;&amp; (E &lt;= A) &amp;&amp; (G &lt;= C) &amp;&amp; (H &lt;= D)) &#123; //overlapping bottom left corner area3 = (G - A)*(H - B); &#125; else if ((F &lt;= B) &amp;&amp; (E &gt;= A) &amp;&amp; (G &gt;= C) &amp;&amp; (H &lt;= D)) &#123; //overlapping bottom right corner area3 = (H - B)*(C - E); &#125; else if (((C - A) &lt;= (G - E)) &amp;&amp; (H &lt;= D) &amp;&amp; (G &gt;= C) &amp;&amp; (E &lt;= A) &amp;&amp; (F &lt;= B)) &#123; //overlapping bottom side area3 = (C - A)*(H - B); &#125; else if (((C - A) &lt;= (G - E)) &amp;&amp; (H &gt;= D) &amp;&amp; (G &gt;= C) &amp;&amp; (E &lt;= A) &amp;&amp; (F &gt;= B)) &#123; //overlapping top side area3 = (C - A)*(D - F); &#125; else if (((D - B) &lt;= (H - F)) &amp;&amp; (E &lt;= A) &amp;&amp; (F &lt;= B) &amp;&amp; (H &gt;= D) &amp;&amp; (G &lt;= C)) &#123; //overlapping left side area3 = (G - A)*(D - B); &#125; else if (((D - B) &lt;= (H - F)) &amp;&amp; (E &gt;= A) &amp;&amp; (F &lt;= B) &amp;&amp; (H &gt;= D) &amp;&amp; (G &gt;= C)) &#123; //overlapping right side area3 = (C - E)*(D - B); &#125; else if (((C - A) &gt;= (G - E)) &amp;&amp; (E &gt;= A) &amp;&amp; (F &gt;= B) &amp;&amp; (C &gt;= G) &amp;&amp; (D &lt;= H)) &#123; //overlapping part of top side area3 = (G - E)*(D - F); &#125; else if (((C - A) &gt;= (G - E)) &amp;&amp; (A &lt;= E) &amp;&amp; (B &gt;= F) &amp;&amp; (G &lt;= C) &amp;&amp; (D &gt;= H)) &#123; //overlapping part of bottom side area3 = (G - E)*(H - B); &#125; else if (((D - B) &gt;= (H - F)) &amp;&amp; (E &lt;= A) &amp;&amp; (F &gt;= B) &amp;&amp; (G &lt;= C) &amp;&amp; (H &lt;= D)) &#123; //overlapping part of left side area3 = (G - A)*(H - F); &#125; else if (((D - B) &gt;= (H - F)) &amp;&amp; (E &gt;= A) &amp;&amp; (F &gt;= B) &amp;&amp; (G &gt;= C) &amp;&amp; (H &lt;= D)) &#123; //overlapping part of right side area3 = (C - E)*(H - F); &#125; else if (((G - E) &lt;= (C - A)) &amp;&amp; (E &gt;= A) &amp;&amp; (F &lt;= B) &amp;&amp; (G &lt;= C) &amp;&amp; (H &gt;= D)) &#123; //overlapping top and bottom area3 = (G - E)*(D - B); &#125; else if (((H - F) &lt;= (D - B)) &amp;&amp; (E &lt;= A) &amp;&amp; (F &gt;= B) &amp;&amp; (C &lt;= G) &amp;&amp; (D &gt;= H)) &#123; //overlapping left and right area3 = (C - A)*(H - F); &#125; return (area1 + area2 - area3); &#125;&#125;; pythonsolution 1: 136ms, 58.33%, 16 July 2016 https://discuss.leetcode.com/topic/22452/python-concise-solution 123456789101112131415class Solution(object): def computeArea(self, A, B, C, D, E, F, G, H): &quot;&quot;&quot; :type A: int :type B: int :type C: int :type D: int :type E: int :type F: int :type G: int :type H: int :rtype: int &quot;&quot;&quot; overlap = max(min(C, G) - max(A, E), 0) * max(min(D, H) - max(B, F), 0) return (A - C) * (B - D) + (E - G) * (F - H) - overlap javasolution 1: 5ms, 14.77%, 16 July 2016 https://discuss.leetcode.com/topic/15733/my-java-solution-sum-of-areas-overlapped-area 1234567891011121314151617public class Solution &#123; public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int areaOfSqrA = (C - A) * (D - B); int areaOfSqrB = (G - E) * (H - F); int left = Math.max(A, E); int right = Math.min(G, C); int bottom = Math.max(F, B); int top = Math.min(D, H); int overlap = 0; if(right &gt; left &amp;&amp; top &gt; bottom) overlap = (right - left) * (top - bottom); return areaOfSqrA + areaOfSqrB - overlap; &#125;&#125; solution 2: 6ms, 6.25%, 16 July 2016 https://discuss.leetcode.com/topic/17705/just-another-short-way 1234567public class Solution &#123; public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int left = Math.max(A, E), right = Math.max(Math.min(C, G), left); int bottom = Math.max(B, F), top = Math.max(Math.min(D, H), bottom); return (C - A) * (D - B) - (right - left) * (top - bottom) + (G - E) * (H - F); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[222. Count Complete Tree Nodes]]></title>
    <url>%2Fp%2Fada3754a%2F</url>
    <content type="text"><![CDATA[27.1% Given a complete binary tree, count the number of nodes. Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. 方法一： 本题是求完全二叉树节点的个数。完全二叉树，就是如果深度为d，那么d-1层至0层都是满二叉树，d层从左向右排列。完全二叉树，就是d层是满的。 高度为h的完全二叉树，节点数为12^h - 1 ，如果完全二叉树是满二叉树，就只这个结果。如果不是，就递归，两个相加。 我的代码实现： 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; if(!root) return 0; int hl = 0, hr = 0; TreeNode* left = root, * right = root; while(left)&#123; hl++; left = left-&gt;left; &#125; while(right)&#123; hr++; right = right-&gt;right; &#125; if(hl == hr) return pow(2, hl)-1; return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right); &#125;&#125;; https://discuss.leetcode.com/topic/15515/easy-short-c-recursive-solution Easy short c++ recursive solution 1234567891011121314151617181920212223class Solution &#123;public: int countNodes(TreeNode* root) &#123; if(!root) return 0; int hl=0, hr=0; TreeNode *l=root, *r=root; while(l) &#123;hl++;l=l-&gt;left;&#125; while(r) &#123;hr++;r=r-&gt;right;&#125; if(hl==hr) return pow(2,hl)-1; return 1+countNodes(root-&gt;left)+countNodes(root-&gt;right); &#125;&#125;; https://discuss.leetcode.com/topic/31457/a-very-clear-recursive-solution-isn-t-it A very clear recursive solution, isn’t it? 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; if(!root) return 0; int lh = height(root-&gt;left); int rh = height(root-&gt;right); if(lh == rh) return (1 &lt;&lt; lh) + countNodes(root-&gt;right); /*1(根节点) + (1&lt;&lt;lh)-1(完全左子树) + # of rightNode */ else return (1 &lt;&lt; rh) + countNodes(root-&gt;left); /*1(根节点) + (1&lt;&lt;rh)-1(完全右子树) + # of leftNode*/ &#125;private: int height(TreeNode *root)&#123; //get the height of a complete binary tree. if(!root) return 0; return 1 + height(root-&gt;left); &#125;&#125;; https://discuss.leetcode.com/topic/19215/simple-c-recursive-solution Simple C++ recursive solution 1234567891011121314151617181920int getLeftHeight(TreeNode* root) &#123; int height = 0; while(root) &#123; root = root-&gt;left; height++; &#125; return height;&#125;int countNodes(TreeNode* root) &#123; if(!root) return 0; int left_height = getLeftHeight(root-&gt;left); int right_height = getLeftHeight(root-&gt;right); if(left_height == right_height) return pow(2, left_height) + countNodes(root-&gt;right); return pow(2, right_height) + countNodes(root-&gt;left);&#125; https://discuss.leetcode.com/topic/23830/68ms-c-solution-using-binary-search-with-brief-explanation 68ms C++ solution using binary search with brief explanation. The thought is simple. We just consider the lowest level of the tree. The left child and right child just divide the tree lower than the current node to 2 part. So what this code do is first check the right most child of the current node’s left child. If this child is exist, we know that there may be more nodes on the right side of the tree. So we move the current node to it’s right child. And repeat until we reach the lowest level. 123456789101112131415161718192021222324int countNodes(TreeNode* root) &#123; if(!root) return 0; TreeNode *temp = root; int height = 0, count = 0, level; while(temp) &#123; temp = temp-&gt;left; height ++; &#125; temp = root; level = height - 2; while(level &gt;= 0) &#123; TreeNode *left = temp-&gt;left; for(int i = 0;i &lt; level;i ++) &#123; left = left-&gt;right; &#125; if(left) &#123; temp = temp-&gt;right; count += (1 &lt;&lt; level); &#125; else temp = temp-&gt;left; level --; &#125; if(temp) count ++; return (1 &lt;&lt; (height - 1)) + count - 1;&#125; https://discuss.leetcode.com/topic/17971/my-python-solution-in-o-lgn-lgn-time My python solution in O(lgn * lgn) time compare the depth between left sub tree and right sub tree. A, If it is equal, it means the left sub tree is a full binary tree B, It it is not , it means the right sub tree is a full binary tree 1234567891011121314151617class Solution: # @param &#123;TreeNode&#125; root # @return &#123;integer&#125; def countNodes(self, root): if not root: return 0 leftDepth = self.getDepth(root.left) rightDepth = self.getDepth(root.right) if leftDepth == rightDepth: return pow(2, leftDepth) + self.countNodes(root.right) else: return pow(2, rightDepth) + self.countNodes(root.left) def getDepth(self, root): if not root: return 0 return 1 + self.getDepth(root.left)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[221. Maximal Square]]></title>
    <url>%2Fp%2F9ceb5f12%2F</url>
    <content type="text"><![CDATA[27.8% https://leetcode.com/problems/maximal-square/ Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. 1234567For example, given the following matrix:1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Return 4. 需要思考 https://discuss.leetcode.com/topic/15328/easy-dp-solution-in-c-with-detailed-explanations-8ms-o-n-2-time-and-o-n-space Easy DP solution in C++ with detailed explanations (8ms, O(n^2) time and O(n) space) Well, this problem desires for the use of dynamic programming. They key to any DP problem is to come up with the state equation. In this problem, we define the state to be the maximal size of the square that can be achieved at point (i, j), denoted as P[i][j]. Remember that we use size instead of square as the state (square = size^2). Now let’s try to come up with the formula for P[i][j]. First, it is obvious that for the topmost row (i = 0) and the leftmost column (j = 0), P[i][j] = matrix[i][j]. This is easily understood. Let’s suppose that the topmost row of matrix is like [1, 0, 0, 1]. Then we can immediately know that the first and last point can be a square of size 1 while the two middle points cannot make any square, giving a size of 0. Thus, P = [1, 0, 0, 1], which is the same as matrix. The case is similar for the leftmost column. Till now, the boundary conditions of this DP problem are solved. Let’s move to the more general case for P[i][j] in which i &gt; 0 and j &gt; 0. First of all, let’s see another simple case in which matrix[i][j] = 0. It is obvious that P[i][j] = 0 too. Why? Well, since matrix[i][j] = 0, no square will contain matrix[i][j]. According to our definition of P[i][j], P[i][j] is also 0. Now we are almost done. The only unsolved case is matrix[i][j] = 1. Let’s see an example. Suppose matrix = [[0, 1], [1, 1]], it is obvious that P[0][0] = 0, P[0][1] = P[1][0] = 1, what about P[1][1]? Well, to give a square of size larger than 1 in P[1][1], all of its three neighbors (left, up, left-up) should be non-zero, right? In this case, the left-up neighbor P[0][0] = 0, so P[1][1] can only be 1, which means that it contains the square of itself. Now you are near the solution. In fact, P[i][j] = min(P[i - 1][j], P[i][j - 1], P[i - 1][j - 1]) + 1 in this case. Taking all these together, we have the following state equations. P[0][j] = matrix[0][j] (topmost row); P[i][0] = matrix[i][0] (leftmost column); For i &gt; 0 and j &gt; 0: if matrix[i][j] = 0, P[i][j] = 0; if matrix[i][j] = 1, P[i][j] = min(P[i - 1][j], P[i][j - 1], P[i - 1][j - 1]) + 1. Putting them into codes, and maintain a variable maxsize to record the maximum size of the square we have seen, we have the following (unoptimized) solution. 123456789101112131415161718192021222324int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; int m = matrix.size(); if (!m) return 0; int n = matrix[0].size(); vector&lt;vector&lt;int&gt; &gt; size(m, vector&lt;int&gt;(n, 0)); int maxsize = 0; for (int j = 0; j &lt; n; j++) &#123; size[0][j] = matrix[0][j] - &apos;0&apos;; maxsize = max(maxsize, size[0][j]); &#125; for (int i = 1; i &lt; m; i++) &#123; size[i][0] = matrix[i][0] - &apos;0&apos;; maxsize = max(maxsize, size[i][0]); &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (matrix[i][j] == &apos;1&apos;) &#123; size[i][j] = min(size[i - 1][j - 1], min(size[i - 1][j], size[i][j - 1])) + 1; maxsize = max(maxsize, size[i][j]); &#125; &#125; &#125; return maxsize * maxsize;&#125; Now let’s try to optimize the above solution. As can be seen, each time when we update size[i][j], we only need size[i][j - 1], size[i - 1][j - 1] (at the previous left column) and size[i - 1][j] (at the current column). So we do not need to maintain the full m*n matrix. In fact, keeping two columns is enough. Now we have the following optimized solution. 12345678910111213141516171819202122232425int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; int m = matrix.size(); if (!m) return 0; int n = matrix[0].size(); vector&lt;int&gt; pre(m, 0); vector&lt;int&gt; cur(m, 0); int maxsize = 0; for (int i = 0; i &lt; m; i++) &#123; pre[i] = matrix[i][0] - &apos;0&apos;; maxsize = max(maxsize, pre[i]); &#125; for (int j = 1; j &lt; n; j++) &#123; cur[0] = matrix[0][j] - &apos;0&apos;; maxsize = max(maxsize, cur[0]); for (int i = 1; i &lt; m; i++) &#123; if (matrix[i][j] == &apos;1&apos;) &#123; cur[i] = min(cur[i - 1], min(pre[i - 1], pre[i])) + 1; maxsize = max(maxsize, cur[i]); &#125; &#125; swap(pre, cur); fill(cur.begin(), cur.end(), 0); &#125; return maxsize * maxsize;&#125; Now you see the solution is finished? In fact, it can still be optimized! In fact, we need not maintain two vectors and one is enough. If you want to explore this idea, please refer to the answers provided by @stellari below. Moreover, in the code above, we distinguish between the 0-th row and other rows since the 0-th row has no row above it. In fact, we can make all the m rows the same by padding a 0 row on the top (in the following code, we pad a 0 on top of dp). Finally, we will have the following short code :) If you find it hard to understand, try to run it using your pen and paper and notice how it realizes what the two-vector solution does using only one vector. 123456789101112131415161718int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return 0; int m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; dp(m + 1, 0); int maxsize = 0, pre = 0; for (int j = 0; j &lt; n; j++) &#123; for (int i = 1; i &lt;= m; i++) &#123; int temp = dp[i]; if (matrix[i - 1][j] == &apos;1&apos;) &#123; dp[i] = min(dp[i], min(dp[i - 1], pre)) + 1; maxsize = max(maxsize, dp[i]); &#125; else dp[i] = 0; pre = temp; &#125; &#125; return maxsize * maxsize;&#125; This solution, since posted, has been suggested various improvements by kind people. For a more comprehensive collection of the solutions, please visit my technical blog. https://discuss.leetcode.com/topic/22185/clear-c-solution-no-extra-space-12-ms Clear C++ solution, no extra space, 12 ms. A square with ‘1’ means any ‘0’ will interrupt counting of it’s right/down/right-down, and ‘1’ will ‘inherit’ the existing counting result. Sine the target is a square, we shall take the smallest counting result from up/left/up-left. So for each element ‘0’, it doesn’t inherit previous accumulated counting; And for each element ‘1’, it takes the smallest number from left/up/left-up and add 1 to it 1234567891011121314151617int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; int rst = 0; for(int ii=0; ii&lt;matrix.size(); ++ii) &#123; for(int jj=0; jj&lt;matrix[0].size(); ++jj) &#123; int a = (ii&amp;&amp;jj) ? matrix[ii-1][jj-1] : 0; int b = (ii) ? matrix[ii-1][jj] : 0; int c = (jj) ? matrix[ii][jj-1] : 0; matrix[ii][jj] = (matrix[ii][jj]&gt;&apos;0&apos;) ? (min(a, min(b, c))+1) : 0; rst = max(rst, matrix[ii][jj]*matrix[ii][jj]); &#125; &#125; return rst;&#125; https://discuss.leetcode.com/topic/29332/20-lines-c-solution-using-dynamic-programming 20 lines C++ solution using dynamic programming 12345678910111213141516171819202122class Solution &#123;public:int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.size()==0) return 0; int maxSq=0; int nRow=matrix.size(); int nCol=matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(nRow+1,vector&lt;int&gt;(nCol+1,0)); //dp[i][j] represents max square ending at position (i-1, j-1) for(int i=1;i&lt;=nRow;++i)&#123; for(int j=1;j&lt;=nCol;++j)&#123; if(matrix[i-1][j-1]==&apos;1&apos;)&#123; dp[i][j]=min(min(dp[i-1][j-1],dp[i-1][j]),dp[i][j-1])+1; maxSq=max(maxSq,dp[i][j]); &#125; &#125; &#125; return maxSq*maxSq;&#125;&#125;; https://discuss.leetcode.com/topic/15373/6-lines-visual-explanation-o-mn 6 lines, Visual Explanation, O(mn) Explanation What’s the largest (full-of-ones-)square ending at (i,j), meaning lower right corner in row i, column j? Imagine there are 4x4 squares above, above-left and left of it: 1234567above above-left left 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 * * 1111* Clearly, if cell (i,j) itself is 1 as well, then there’s a 5x5 square ending at (i,j). And if there were 5x5 squares above, above-left and left of it, then we’d have a 6x6. So to find the largest square ending at (i,j), we just take the minimum size of squares ending at (i-1,j), (i-1,j-1) and (i,j-1), and add 1. Implementation - 164 ms I write the maximum sizes directly into the input matrix A. Cell A[i][j] will tell the side length of the largest square ending at (i,j). I go top to bottom and left to right, so (i-1,j), (i-1,j-1) and (i,j-1) have all been handled already. First thing I do for each cell is turn it into an integer, and then if it’s 1 and it’s not on the top or left border of the matrix, I determine its largest-square size as explained above. In the end, I return 0 for the empty matrix and otherwise the area of the largest square ending anywhere. 12345678class Solution: def maximalSquare(self, A): for i in range(len(A)): for j in range(len(A[i])): A[i][j] = int(A[i][j]) if A[i][j] and i and j: A[i][j] = min(A[i-1][j], A[i-1][j-1], A[i][j-1]) + 1 return len(A) and max(map(max, A)) ** 2 Smaller Version - 132 ms This version is a bit smaller and faster due to using more of Python and some “tricks”: 12345678class Solution: def maximalSquare(self, A): for i, r in enumerate(A): r = A[i] = map(int, r) for j, c in enumerate(r): if i * j * c: r[j] = min(A[i-1][j], r[j-1], A[i-1][j-1]) + 1 return max(map(max, A + [[0]])) ** 2 O(n) Extra Space - 128 ms Here’s a version that doesn’t overwrite the input matrix but uses two integer lists: s tells the sizes of the squares ending it the current row and p does the same for the previous row. 123456789101112class Solution: def maximalSquare(self, A): area = 0 if A: p = [0] * len(A[0]) for row in A: s = map(int, row) for j, c in enumerate(s[1:], 1): s[j] *= min(p[j-1], p[j], s[j-1]) + 1 area = max(area, max(s) ** 2) p = s return area Note that in Python with its integer and string objects, I’m not sure this actually saves space. But in other languages, overwriting the input array might not even be possible, and if it’s possible, it might take more space than a “O(n) Extra Space” variant. https://discuss.leetcode.com/topic/15381/my-c-code-8ms-dp-o-n-2-time-o-n-space My C++ code, 8ms (DP, O(n^2)time, O(n) space) The basic idea is to do DP: scan the matrix row by row (top down) and colume by colume (left to right) and for the position [i][j], the maximum square with the bottom-right corner sitting at [i][j] will have the edge length of 12area[i][j] = 0 if matrix[i][j] = &apos;0&apos; = min(area[i-1][j-1], area[i][j-1], area[i-1][j]) + 1 if matrix[i][j] = &apos;1&apos; For the case that matrix[i][j] = ‘1’, the algorithm tries to grow the square sitting at [i-1][j-1], area[i-1][j-1] by 1. However, it is also limitted by the bottom edge at row i and right edge at col j, which was represented by area[i][j-1] and area[i-1][j] repectively. We have to choose the min of those three values. The DP table works on a ping-pong mode to save memory since the area recursive equation only relys on i and i-1 rows. 1234567891011121314151617181920212223242526class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; int maxA = 0; const int m = matrix.size(); if(!m) return maxA; const int n = matrix[0].size(); if(!n) return maxA; int area[2][n]; // DP table to save the maximum square (with bottom-right corner at [i][j]) edge length int cur = 0, next =1; // ping-pog switch index fill_n(area[0],n,0); int i, j; for(i=0;i&lt;m;i++) &#123; area[next][0] = matrix[i][0] == &apos;1&apos;; // the first colume for(j=1; j&lt;n; j++) area[next][j] = matrix[i][j]==&apos;1&apos;? (min(area[cur][j-1],min(area[next][j-1],area[cur][j])) + 1):0; //DP update for(j=0; j&lt;n &amp;&amp; maxA&lt;=i; j++) if(maxA&lt;area[next][j]) maxA = area[next][j]; // find the maximum square for the current row cur = next; next = 1-cur; &#125; return maxA * maxA; &#125;&#125;; https://discuss.leetcode.com/topic/16851/share-my-concise-python-solution Share my concise python solution 123456789101112131415class Solution:# @param &#123;character[][]&#125; matrix# @return &#123;integer&#125;def maximalSquare(self, matrix): if not matrix: return 0 m , n = len(matrix),len(matrix[0]) dp = [[0 if matrix[i][j]==&apos;0&apos; else 1for j in xrange(n)]for i in xrange(m)] for i in xrange(1,m): for j in xrange(1,n): if matrix[i][j] ==&apos;1&apos;: dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1 else: dp[i][j] = 0 ans = max([max(i) for i in dp]) return ans ** 2]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[220. Contains Duplicate III]]></title>
    <url>%2Fp%2F86f6637a%2F</url>
    <content type="text"><![CDATA[19.3% https://leetcode.com/problems/contains-duplicate-iii/?tab=Description Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. 需要思考 方法一： 因为需要有序，所以使用的set，set也有lower_bound相关函数 学习set，排序的set，学习low_bound函数使用 比较直接，使用了lower_bound, upper_bound 如果要存在，肯定在两者之间 我的代码实现： 123456789101112131415161718192021class Solution &#123;public: bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123; if(nums.empty() || k&lt;=0 || t&lt;0) return false; // 对于int，经常出现溢出，不如long long set&lt;long long&gt; set; for(int i=0; i&lt;nums.size(); i++)&#123; long long num = nums[i]; auto itlow = set.lower_bound(num-t); auto itup = set.upper_bound(num+t); // 此处的迭代器没有 &lt; if(itlow!=itup) return true; set.insert(num); if(set.size()==k+1) set.erase(nums[i-k]); &#125; return false; &#125;&#125;; 下面的算法有一定的公式推导，但是也比较简单，原理是一致的。 https://discuss.leetcode.com/topic/18453/c-using-set-less-10-lines-with-simple-explanation C++ using set (less 10 lines), with simple explanation. 123456789101112bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123; set&lt;int&gt; window; // set is ordered automatically for (int i = 0; i &lt; nums.size(); i++) &#123; if (i &gt; k) window.erase(nums[i-k-1]); // keep the set contains nums i j at most k // |x - nums[i]| &lt;= t ==&gt; -t &lt;= x - nums[i] &lt;= t; auto pos = window.lower_bound(nums[i] - t); // x-nums[i] &gt;= -t ==&gt; x &gt;= nums[i]-t // x - nums[i] &lt;= t ==&gt; |x - nums[i]| &lt;= t if (pos != window.end() &amp;&amp; *pos - nums[i] &lt;= t) return true; window.insert(nums[i]); &#125; return false;&#125; https://discuss.leetcode.com/topic/15468/i-finally-got-ac-in-c I finally got AC in C++ Using a set container to keep the k+1-length array,which all elements are distinct.Before the container’s size reached k+1, we just find the first element that is not less than [nums[i]-t] and judge the element’s value whether it is less than [nums[i]+t]. Starting to move forward by erasing the head and adding element at the backend after the container’s size reached k+1. The existence of the first element ,which is not less than [nums[i]-t] and less than [nums[i]+t], is the prerequisite of existing other eligible elements. 123456789101112131415161718bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123; if (!k || t&lt;0 || nums.size()&lt;2) return false; set&lt;int&gt;record; auto nLen = nums.size(); for (int i = 0; i &lt; nLen;++i) &#123; if (i&gt;k) record.erase(nums[i - k - 1]); set&lt;int&gt;::iterator lower = record.lower_bound(nums[i] - t); if (lower != record.end() &amp;&amp; abs(nums[i] - *lower) &lt;= t) return true; record.insert(nums[i]); &#125; return false; &#125; https://discuss.leetcode.com/topic/15172/accept-c-solution Accept C++ Solution My idea is to preserve a sliding window containing nearest k numbers, and check if next number collides to the numbers in the window. 123456789101112131415161718192021222324class Solution &#123;public: bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123; if (nums.size() &lt; 2 || k == 0) return false; deque&lt;int&gt; windows_deq; multiset&lt;long&gt; windows; for (int i = 0; i &lt; nums.size(); i++) &#123; if (windows.size() &gt; k) &#123; int num = windows_deq.front(); windows_deq.pop_front(); windows.erase(windows.find(num)); &#125; auto it = windows.lower_bound((long)nums[i] - (long)t); if (it == windows.end() || *it &gt; (long)nums[i] + (long)t) &#123; // not found windows_deq.push_back(nums[i]); windows.insert(nums[i]); &#125; else return true; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/27608/java-python-one-pass-solution-o-n-time-o-n-space-using-buckets The idea is like the bucket sort algorithm. Suppose we have consecutive buckets covering the range of nums with each bucket a width of (t+1). If there are two item with difference &lt;= t, one of the two will happen: 12(1) the two in the same bucket(2) the two in neighbor buckets For detailed explanation see my blog here Python 12345678910111213141516171819202122def containsNearbyAlmostDuplicate(self, nums, k, t): if t &lt; 0: return False n = len(nums) d = &#123;&#125; w = t + 1 for i in xrange(n): m = nums[i] / w if m in d: return True if m - 1 in d and abs(nums[i] - d[m - 1]) &lt; w: return True if m + 1 in d and abs(nums[i] - d[m + 1]) &lt; w: return True d[m] = nums[i] if i &gt;= k: del d[nums[i - k] / w] return False# 30 / 30 test cases passed.# Status: Accepted# Runtime: 56 ms# 93.81% Java 123456789101112131415161718192021private long getID(long i, long w) &#123; return i &lt; 0 ? (i + 1) / w - 1 : i / w;&#125;public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; if (t &lt; 0) return false; Map&lt;Long, Long&gt; d = new HashMap&lt;&gt;(); long w = (long)t + 1; for (int i = 0; i &lt; nums.length; ++i) &#123; long m = getID(nums[i], w); if (d.containsKey(m)) return true; if (d.containsKey(m - 1) &amp;&amp; Math.abs(nums[i] - d.get(m - 1)) &lt; w) return true; if (d.containsKey(m + 1) &amp;&amp; Math.abs(nums[i] - d.get(m + 1)) &lt; w) return true; d.put(m, (long)nums[i]); if (i &gt;= k) d.remove(getID(nums[i - k], w)); &#125; return false;&#125; https://discuss.leetcode.com/topic/19991/o-n-python-using-buckets-with-explanation-10-lines O(n) Python using buckets with explanation, 10 lines. 12345678910111213141516171819def containsNearbyAlmostDuplicate(self, nums, k, t): # Bucket sort. Each bucket has size of t. For each number, the possible # candidate can only be in the same bucket or the two buckets besides. # Keep as many as k buckets to ensure that the difference is at most k. buckets = &#123;&#125; for i, v in enumerate(nums): # t == 0 is a special case where we only have to check the bucket # that v is in. bucketNum, offset = (v / t, 1) if t else (v, 0) for idx in xrange(bucketNum - offset, bucketNum + offset + 1): if idx in buckets and abs(buckets[idx] - nums[i]) &lt;= t: return True buckets[bucketNum] = nums[i] if len(buckets) &gt; k: # Remove the bucket which is too far away. Beware of zero t. del buckets[nums[i - k] / t if t else nums[i - k]] return False https://discuss.leetcode.com/topic/15190/python-ordereddict Python OrderedDict 123456789101112131415class Solution:def containsNearbyAlmostDuplicate(self, nums, k, t): if k &lt; 1 or t &lt; 0: return False dic = collections.OrderedDict() for n in nums: key = n if not t else n // t for m in (dic.get(key - 1), dic.get(key), dic.get(key + 1)): if m is not None and abs(n - m) &lt;= t: return True if len(dic) == k: dic.popitem(False) dic[key] = n return False java https://discuss.leetcode.com/topic/15199/ac-o-n-solution-in-java-using-buckets-with-explanation AC O(N) solution in Java using buckets with explanation As a followup question, it naturally also requires maintaining a window of size k. When t == 0, it reduces to the previous question so we just reuse the solution. Since there is now a constraint on the range of the values of the elements to be considered duplicates, it reminds us of doing a range check which is implemented in tree data structure and would take O(LogN) if a balanced tree structure is used, or doing a bucket check which is constant time. We shall just discuss the idea using bucket here. Bucketing means we map a range of values to the a bucket. For example, if the bucket size is 3, we consider 0, 1, 2 all map to the same bucket. However, if t == 3, (0, 3) is a considered duplicates but does not map to the same bucket. This is fine since we are checking the buckets immediately before and after as well. So, as a rule of thumb, just make sure the size of the bucket is reasonable such that elements having the same bucket is immediately considered duplicates or duplicates must lie within adjacent buckets. So this actually gives us a range of possible bucket size, i.e. t and t + 1. We just choose it to be t and a bucket mapping to be num / t. Another complication is that negative ints are allowed. A simple num / t just shrinks everything towards 0. Therefore, we can just reposition every element to start from Integer.MIN_VALUE. 1234567891011121314151617181920public class Solution &#123; public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; if (k &lt; 1 || t &lt; 0) return false; Map&lt;Long, Long&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; long remappedNum = (long) nums[i] - Integer.MIN_VALUE; long bucket = remappedNum / ((long) t + 1); if (map.containsKey(bucket) || (map.containsKey(bucket - 1) &amp;&amp; remappedNum - map.get(bucket - 1) &lt;= t) || (map.containsKey(bucket + 1) &amp;&amp; map.get(bucket + 1) - remappedNum &lt;= t)) return true; if (map.entrySet().size() &gt;= k) &#123; long lastBucket = ((long) nums[i - k] - Integer.MIN_VALUE) / ((long) t + 1); map.remove(lastBucket); &#125; map.put(bucket, remappedNum); &#125; return false; &#125;&#125; Edits: Actually, we can use t + 1 as the bucket size to get rid of the case when t == 0. It simplifies the code. The above code is therefore the updated version. https://discuss.leetcode.com/topic/15191/java-o-n-lg-k-solution Java O(N lg K) solution This problem requires to maintain a window of size k of the previous values that can be queried for value ranges. The best data structure to do that is Binary Search Tree. As a result maintaining the tree of size k will result in time complexity O(N lg K). In order to check if there exists any value of range abs(nums[i] - nums[j]) to simple queries can be executed both of time complexity O(lg K) Here is the whole solution using TreeMap. 12345678910111213141516171819202122232425public class Solution &#123; public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123; if (nums == null || nums.length == 0 || k &lt;= 0) &#123; return false; &#125; final TreeSet&lt;Integer&gt; values = new TreeSet&lt;&gt;(); for (int ind = 0; ind &lt; nums.length; ind++) &#123; final Integer floor = values.floor(nums[ind] + t); final Integer ceil = values.ceiling(nums[ind] - t); if ((floor != null &amp;&amp; floor &gt;= nums[ind]) || (ceil != null &amp;&amp; ceil &lt;= nums[ind])) &#123; return true; &#125; values.add(nums[ind]); if (ind &gt;= k) &#123; values.remove(nums[ind - k]); &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>binary search tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[219. Contains Duplicate II]]></title>
    <url>%2Fp%2F4c1e3175%2F</url>
    <content type="text"><![CDATA[31.8% https://leetcode.com/problems/contains-duplicate-ii/ Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. 方法一： 使用unordered_set，函数erase, insert 我的代码实现： 123456789101112131415class Solution &#123;public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123; if(k==0 || nums.empty()) return false; unordered_set&lt;int&gt; set; for(int i=0; i&lt;nums.size(); i++)&#123; if(set.find(nums[i])!=set.end()) return true; set.insert(nums[i]); if(set.size()==k+1) set.erase(nums[i-k]); &#125; return false; &#125;&#125;; 32ms, 47.64%, May.6th, 2016 https://leetcode.com/discuss/37851/c-solution-with-unordered_set 12345678910111213141516class Solution &#123;public: bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_set&lt;int&gt; s; if(k &lt;= 0) return false; if(k &gt;= nums.size()) k = nums.size() - 1; for(int i = 0; i &lt; nums.size(); i++)&#123; if(i &gt; k) s.erase(nums[i - k - 1]); if(s.find(nums[i]) != s.end()) return true; s.insert(nums[i]); &#125; return false; &#125;&#125;; python 52ms, 56.23%, May.6th, 2016 https://leetcode.com/discuss/54123/python-concise-solution-with-dictionary 12345678910111213class Solution(object): def containsNearbyDuplicate(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: bool &quot;&quot;&quot; dic = &#123;&#125; for i, v in enumerate(nums): if v in dic and i - dic[v] &lt;= k: return True dic[v] = i return False java 13ms, 44.06%, May.6th, 2016 https://leetcode.com/discuss/38445/simple-java-solution 12345678910public class Solution &#123; public boolean containsNearbyDuplicate(int[] nums, int k) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; if(i &gt; k) set.remove(nums[i-k-1]); if(!set.add(nums[i])) return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[218. The Skyline Problem]]></title>
    <url>%2Fp%2Fb0846169%2F</url>
    <content type="text"><![CDATA[26.2% https://leetcode.com/problems/the-skyline-problem/?tab=Description A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B). The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX, and Ri - Li &gt; 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0. For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] . The output is a list of “key points” (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], … ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour. For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]. Notes: The number of buildings in any input list is guaranteed to be in the range [0, 10000]. The input list is already sorted in ascending order by the left x position Li. The output list must be sorted by the x position. There must be no consecutive horizontal lines of equal height in the output skyline. For instance, […[2 3], [4 5], [7 5], [11 5], [12 7]…] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: […[2 3], [4 5], [12 7], …] 需要思考 方法一： https://discuss.leetcode.com/topic/39416/guaranteed-really-detailed-and-good-perfect-explanation-of-the-skyline-problem https://briangordon.github.io/2014/08/the-skyline-problem.html https://discuss.leetcode.com/topic/14939/my-c-code-using-one-priority-queue-812-ms My C++ code using one priority queue (812 ms) The idea is to do line sweep and just process the buildings only at the start and end points. The key is to use a priority queue to save all the buildings that are still “alive”. The queue is sorted by its height and end time (the larger height first and if equal height, the one with a bigger end time first). For each iteration, we first find the current process time, which is either the next new building start time or the end time of the top entry of the live queue. If the new building start time is larger than the top one end time, then process the one in the queue first (pop them until it is empty or find the first one that ends after the new building); otherswise, if the new building starts before the top one ends, then process the new building (just put them in the queue). After processing, output it to the resulting vector if the height changes. Complexity is the worst case O(NlogN) Not sure why my algorithm is so slow considering others’ Python solution can achieve 160ms, any commments? 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123; vector&lt;pair&lt;int, int&gt;&gt; res; int cur=0, cur_X, cur_H =-1, len = buildings.size(); priority_queue&lt; pair&lt;int, int&gt;&gt; liveBlg; // first: height, second, end time while(cur&lt;len || !liveBlg.empty()) &#123; // if either some new building is not processed or live building queue is not empty cur_X = liveBlg.empty()? buildings[cur][0]:liveBlg.top().second; // next timing point to process if(cur&gt;=len || buildings[cur][0] &gt; cur_X) &#123; //first check if the current tallest building will end before the next timing point // pop up the processed buildings, i.e. those have height no larger than cur_H and end before the top one while(!liveBlg.empty() &amp;&amp; ( liveBlg.top().second &lt;= cur_X) ) liveBlg.pop(); &#125; else &#123; // if the next new building starts before the top one ends, process the new building in the vector cur_X = buildings[cur][0]; while(cur&lt;len &amp;&amp; buildings[cur][0]== cur_X) // go through all the new buildings that starts at the same point &#123; // just push them in the queue liveBlg.push(make_pair(buildings[cur][2], buildings[cur][1])); cur++; &#125; &#125; cur_H = liveBlg.empty()?0:liveBlg.top().first; // outut the top one if(res.empty() || (res.back().second != cur_H) ) res.push_back(make_pair(cur_X, cur_H)); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/14939/my-c-code-using-one-priority-queue-812-ms/2 Very nice idea, keeping smaller buildings alive under larger ones even though they ended already. You have a few unnecessary things, though. If I’m not mistaken, mycompare just does the default ordering, vector is the default container for priority_queue, the if(len&gt;0) doesn’t help, and you don’t need a private section. I think removing that stuff would make your solution even better than it already is. About Python being faster: Yeah that’s right, Python is faster now. Deal with it :-P. More seriously, here’s the probable explanation. https://discuss.leetcode.com/topic/16511/share-my-divide-and-conquer-java-solution-464-ms Share my divide and conquer java solution, 464 ms Detailed explanation: http://www.geeksforgeeks.org/divide-and-conquer-set-7-the-skyline-problem/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Solution &#123; public List&lt;int[]&gt; getSkyline(int[][] buildings) &#123; if (buildings.length == 0) return new LinkedList&lt;int[]&gt;(); return recurSkyline(buildings, 0, buildings.length - 1); &#125; private LinkedList&lt;int[]&gt; recurSkyline(int[][] buildings, int p, int q) &#123; if (p &lt; q) &#123; int mid = p + (q - p) / 2; return merge(recurSkyline(buildings, p, mid), recurSkyline(buildings, mid + 1, q)); &#125; else &#123; LinkedList&lt;int[]&gt; rs = new LinkedList&lt;int[]&gt;(); rs.add(new int[] &#123; buildings[p][0], buildings[p][2] &#125;); rs.add(new int[] &#123; buildings[p][1], 0 &#125;); return rs; &#125; &#125; private LinkedList&lt;int[]&gt; merge(LinkedList&lt;int[]&gt; l1, LinkedList&lt;int[]&gt; l2) &#123; LinkedList&lt;int[]&gt; rs = new LinkedList&lt;int[]&gt;(); int h1 = 0, h2 = 0; while (l1.size() &gt; 0 &amp;&amp; l2.size() &gt; 0) &#123; int x = 0, h = 0; if (l1.getFirst()[0] &lt; l2.getFirst()[0]) &#123; x = l1.getFirst()[0]; h1 = l1.getFirst()[1]; h = Math.max(h1, h2); l1.removeFirst(); &#125; else if (l1.getFirst()[0] &gt; l2.getFirst()[0]) &#123; x = l2.getFirst()[0]; h2 = l2.getFirst()[1]; h = Math.max(h1, h2); l2.removeFirst(); &#125; else &#123; x = l1.getFirst()[0]; h1 = l1.getFirst()[1]; h2 = l2.getFirst()[1]; h = Math.max(h1, h2); l1.removeFirst(); l2.removeFirst(); &#125; if (rs.size() == 0 || h != rs.getLast()[1]) &#123; rs.add(new int[] &#123; x, h &#125;); &#125; &#125; rs.addAll(l1); rs.addAll(l2); return rs; &#125;&#125; https://discuss.leetcode.com/topic/25794/17-line-o-n-log-n-time-o-n-space-c-accepted-easy-solution-w-explanations 17-Line O(n log n)-time O(n)-space C++ Accepted Easy Solution w/ Explanations General idea: Step 1: Use a multimap to sort all boundary points. For a start point of an interval, let the height be positive; otherwise, let the height be negative. Time complexity: O(n log n) Step 2: Use a multiset (rather than a heap/priority_queue) to maintain the current set of heights to be considered. If a new start point is met, insert the height into the set, otherwise, delete the height. The current max height is the back() element of the multiset. For each point, the time complexity is O(log n). The overall time complexity is O(n log n). Step 3: Delete the points with equal heights. Time: O(n) Time Complexity: O(n log n) Space Complexity: O(n) C++ 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123; // Step 1: multimap&lt;int, int&gt; coords; for (const vector&lt;int&gt; &amp; building : buildings) &#123; coords.emplace(building[0], building[2]); coords.emplace(building[1], -building[2]); &#125; // Step 2: multiset&lt;int&gt; heights = &#123; 0 &#125;; map&lt;int, int&gt; corners; for (const pair&lt;int, int&gt; &amp; p : coords) &#123; if (p.second &gt; 0) &#123; heights.insert(p.second); &#125; else &#123; heights.erase(heights.find(-p.second)); &#125; int cur_y = *heights.rbegin(); corners[p.first] = cur_y; &#125; // Step 3: function&lt;bool(pair&lt;int, int&gt; l, pair&lt;int, int&gt; r)&gt; eq2nd = [](pair&lt;int, int&gt; l, pair&lt;int, int&gt; r)&#123; return l.second == r.second; &#125;; vector&lt;pair&lt;int, int&gt;&gt; results; unique_copy(corners.begin(), corners.end(), back_insert_iterator&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;(results), eq2nd); return results; &#125;&#125;; In fact, the last two steps can be merged together: Yet another solution (C++): 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123; multimap&lt;int, int&gt; coords; for (const vector&lt;int&gt; &amp; building : buildings) &#123; coords.emplace(building[0], building[2]); coords.emplace(building[1], -building[2]); &#125; multiset&lt;int&gt; heights = &#123; 0 &#125;; vector&lt;pair&lt;int, int&gt;&gt; corners; int x = -1; int y = 0; for (const pair&lt;int, int&gt; &amp; p : coords) &#123; if ((x &gt;= 0) &amp;&amp; (p.first != x) &amp;&amp; (corners.empty() || (corners.rbegin()-&gt;second != y))) &#123; corners.emplace_back(x, y); &#125; if (p.second &gt;= 0) &#123; heights.insert(p.second); &#125; else &#123; heights.erase(heights.find(-p.second)); &#125; x = p.first; y = *heights.rbegin(); &#125; if (!corners.empty()) &#123; corners.emplace_back(x, 0); &#125; return corners; &#125;&#125;; https://discuss.leetcode.com/topic/14987/108-ms-17-lines-body-explained 108 ms, 17 lines body, explained This is a Python version of my modification of dong.wang.1694’s brilliant C++ solution. It sweeps from left to right. But it doesn’t only keep heights of “alive buildings” in the priority queue and it doesn’t remove them as soon as their building is left behind. Instead, (height, right) pairs are kept in the priority queue and they stay in there as long as there’s a larger height in there, not just until their building is left behind. In each loop, we first check what has the smaller x-coordinate: adding the next building from the input, or removing the next building from the queue. In case of a tie, adding buildings wins, as that guarantees correctness (think about it :-). We then either add all input buildings starting at that x-coordinate or we remove all queued buildings ending at that x-coordinate or earlier (remember we keep buildings in the queue as long as they’re “under the roof” of a larger actually alive building). And then, if the current maximum height in the queue differs from the last in the skyline, we add it to the skyline. 123456789101112131415161718192021from heapq import *class Solution: def getSkyline(self, LRH): skyline = [] i, n = 0, len(LRH) liveHR = [] while i &lt; n or liveHR: if not liveHR or i &lt; n and LRH[i][0] &lt;= -liveHR[0][1]: x = LRH[i][0] while i &lt; n and LRH[i][0] == x: heappush(liveHR, (-LRH[i][2], -LRH[i][1])) i += 1 else: x = -liveHR[0][1] while liveHR and -liveHR[0][1] &lt;= x: heappop(liveHR) height = len(liveHR) and -liveHR[0][0] if not skyline or height != skyline[-1][1]: skyline += [x, height], return skyline https://discuss.leetcode.com/topic/35817/recommend-for-beginners-clean-c-implementation-with-detailed-explanation [recommend for beginners]clean C++ implementation with detailed explanation 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123; vector&lt;pair&lt;int, int&gt;&gt; edges; int left, right, height; for(int i=0; i&lt;buildings.size(); i++)&#123; left=buildings[i][0]; right=buildings[i][1]; height=buildings[i][2]; /*** make sure : for the same left point we use the bigger height ***/ edges.push_back(make_pair(left, -height)); edges.push_back(make_pair(right, height)); &#125; sort(edges.begin(), edges.end()); vector&lt;pair&lt;int, int&gt;&gt; result; /*** use the multiset to store the max height util current pos ***/ multiset&lt;int&gt; m; /*** left most height ***/ m.insert(0); int pre=0, cur=0; for(int i=0; i&lt;edges.size(); i++)&#123; pair&lt;int, int&gt; e=edges[i]; if(e.second &lt; 0) m.insert(-e.second); else m.erase(m.find(e.second)); cur=*(m.rbegin()); if(cur!=pre)&#123; result.push_back(make_pair(e.first, cur)); pre=cur; &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/26420/14-line-python-code-straightforward-easy-to-understand 14 line python code, straightforward &amp; easy to understand 123456789101112131415161718192021222324252627282930313233343536class Solution(object):def getSkyline(self, buildings): &quot;&quot;&quot; :type buildings: List[List[int]] :rtype: List[List[int]] &quot;&quot;&quot; def addsky(pos, hei): if sky[-1][1] != hei: sky.append([pos, hei]) sky = [[-1,0]] # possible corner positions position = set([b[0] for b in buildings] + [b[1] for b in buildings]) # live buildings live = [] i = 0 for t in sorted(position): # add the new buildings whose left side is lefter than position t while i &lt; len(buildings) and buildings[i][0] &lt;= t: heappush(live, (-buildings[i][2], buildings[i][1])) i += 1 # remove the past buildings whose right side is lefter than position t while live and live[0][1] &lt;= t: heappop(live) # pick the highest existing building at this moment h = -live[0][0] if live else 0 addsky(t, h) return sky[1:] https://discuss.leetcode.com/topic/34119/10-line-python-solution-104-ms 10-line Python solution, 104 ms Use an infinite vertical line x to scan from left to right. If max height changes, record [x, height] in res. Online judge is using Python 2.7.9 and there’s no max heap’s push and pop method, so we can use a min heap hp storing -H as “max heap”. Thanks to this discussion, set comprehension is faster and shorter than list(set((R, 0, None) for L, R, H in buildings)). 1234567891011def getSkyline(self, buildings): events = sorted([(L, -H, R) for L, R, H in buildings] + list(&#123;(R, 0, None) for _, R, _ in buildings&#125;)) res, hp = [[0, 0]], [(0, float(&quot;inf&quot;))] for x, negH, R in events: while x &gt;= hp[0][1]: heapq.heappop(hp) if negH: heapq.heappush(hp, (negH, R)) if res[-1][1] + hp[0][0]: res += [x, -hp[0][0]], return res[1:] https://discuss.leetcode.com/topic/22482/short-java-solution Short Java solution 1234567891011121314151617181920212223242526272829public List&lt;int[]&gt; getSkyline(int[][] buildings) &#123; List&lt;int[]&gt; result = new ArrayList&lt;&gt;(); List&lt;int[]&gt; height = new ArrayList&lt;&gt;(); for(int[] b:buildings) &#123; height.add(new int[]&#123;b[0], -b[2]&#125;); height.add(new int[]&#123;b[1], b[2]&#125;); &#125; Collections.sort(height, (a, b) -&gt; &#123; if(a[0] != b[0]) return a[0] - b[0]; return a[1] - b[1]; &#125;); Queue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; (b - a)); pq.offer(0); int prev = 0; for(int[] h:height) &#123; if(h[1] &lt; 0) &#123; pq.offer(-h[1]); &#125; else &#123; pq.remove(h[1]); &#125; int cur = pq.peek(); if(prev != cur) &#123; result.add(new int[]&#123;h[0], cur&#125;); prev = cur; &#125; &#125; return result;&#125; https://discuss.leetcode.com/topic/28482/once-for-all-explanation-with-clean-java-code-o-n-2-time-o-n-space Once for all, explanation with clean Java code(O(n^2)time, O(n) space) Though I came up with a solution using PriorityQueue and BST, this problems still confuses me. To make it more clear, I went through it several times and investigated several good solutions on this forum. Here is my explanation which tries to make understanding this easier and may help you write a bug-free solution quickly. When visiting all start points and end points in order: Observations: 12345678If a position is shadowed by other buildings 1. height of that building is larger than the building to which current position belong; 2. the start point of that building must be smaller(or equal to) than this position; 3. the end point of that building must be larger(or equal to) than this position; Tus we have: 12345671. when you reach a start point, the height of current building immediately takes effect which means it could possibly affect the contour or shadow others when mixed with other following buildings;2. when you reach a end point, the height of current building will stop its influences;3. our target exists at the position where height change happens and there is nothing above it shadowing it; Obviously, to implement the idea that ‘current height takes effect’ and ‘find out whether current height is shadowed by other buildings’, we need a mechanism to store current taking effect heights, meanwhile, figure out which one is the maximum, delete it if needed efficiently, which hints us to use a priority queue or BST. Thus, our algorithm could be summarised in following pseudo code: 12345678for position in sorted(all start points and all end points) if this position is a start point add its height else if this position is a end point delete its height compare current max height with previous max height, if different, add current position together with this new max height to our result, at the same time, update previous max height to current max height; To implement this algorithm, here are some concrete examples: In my implementation, I use a PriorityQueue to store end point values when visiting a start point, and store the [height, end point value] into a TreeMap. Thus: 1. when moving to next start point value, I can compare the next start point value with elements in PriorityQueue, thus achieving visiting all start points and end points in order(exploits the fact that start points are already sorted); 2. Meantime, I can get current max height from TreeMap in O(logn); 3. However, to delete a height when visiting a end point, I have to use &apos;map.values.remove()&apos; which is a method defined in Collection interface and tends to be slower(O(n) is this case, plz correct me if I&apos;m wrong); My code can be found at https://leetcode.com/discuss/62617/short-and-clean-java-solution-heap-and-treemap Following is wujin’s implementation(plz refer to https://leetcode.com/discuss/54201/short-java-solution). This one is quite straightforward, clean and clever.Firstly, please notice what we need to achieve: 12341. visit all start points and all end points in order;2. when visiting a point, we need to know whether it is a start point or a end point, based on which we can add a height or delete a height from our data structure; To achieve this, his implementation: 12341. use a int[][] to collect all [start point, - height] and [end point, height] for every building;2. sort it, firstly based on the first value, then use the second to break ties; Thus, 12341. we can visit all points in order;2. when points have the same value, higher height will shadow the lower one;3. we know whether current point is a start point or a end point based on the sign of its height; His code is as follows(clear and concise) as reference with my comment(again, https://leetcode.com/discuss/54201/short-java-solution): 123456789101112131415161718192021222324252627282930313233343536373839404142434445public List&lt;int[]&gt; getSkyline(int[][] buildings) &#123; List&lt;int[]&gt; result = new ArrayList&lt;&gt;(); List&lt;int[]&gt; height = new ArrayList&lt;&gt;(); for(int[] b:buildings) &#123; // start point has negative height value height.add(new int[]&#123;b[0], -b[2]&#125;); // end point has normal height value height.add(new int[]&#123;b[1], b[2]&#125;); &#125; // sort $height, based on the first value, if necessary, use the second to // break ties Collections.sort(height, (a, b) -&gt; &#123; if(a[0] != b[0]) return a[0] - b[0]; return a[1] - b[1]; &#125;); // Use a maxHeap to store possible heights Queue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; (b - a)); // Provide a initial value to make it more consistent pq.offer(0); // Before starting, the previous max height is 0; int prev = 0; // visit all points in order for(int[] h:height) &#123; if(h[1] &lt; 0) &#123; // a start point, add height pq.offer(-h[1]); &#125; else &#123; // a end point, remove height pq.remove(h[1]); &#125; int cur = pq.peek(); // current max height; // compare current max height with previous max height, update result and // previous max height if necessary if(prev != cur) &#123; result.add(new int[]&#123;h[0], cur&#125;); prev = cur; &#125; &#125; return result;&#125; Hopefully now, you can write a good solution in a blink with good understanding…]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>divide and conquer</tag>
        <tag>hard</tag>
        <tag>heap</tag>
        <tag>binary indexed tree</tag>
        <tag>segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[217. Contains Duplicate]]></title>
    <url>%2Fp%2F4dd031de%2F</url>
    <content type="text"><![CDATA[44.4% https://leetcode.com/problems/contains-duplicate/ Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. 方法一： 58ms, 31.23%, July 13th, 2016 123456class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; return nums.size() &gt; set&lt;int&gt;(nums.begin(), nums.end()).size(); &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/16706/basic-48ms-c-solution-with-unordered_map Basic 48ms C++ solution with unordered_map 12345678910111213class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) &#123; return false; &#125; unordered_map&lt;int,int&gt; mp; for (int i : nums) &#123; if (++mp[i] &gt; 1) &#123; return true; &#125; &#125; return false; &#125;&#125;; 方法三： 使用unordered_set 1234567891011121314class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return false; unordered_set&lt;int&gt; set; for(auto num:nums)&#123; if(set.find(num)!=set.end()) return true; set.insert(num); &#125; return false; &#125;&#125;; python 1234567class Solution(object): def containsDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; return len(nums) != len(set(nums)) java solution 1: 6ms, 79.29%, July 13th, 2016 123456789public class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; Arrays.sort(nums); for(int ind = 1; ind &lt; nums.length; ind++) if(nums[ind] == nums[ind-1]) return true; return false; &#125;&#125; solution 2: 15ms, 30.86%, July 13th, 2016 12345678910111213public class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; Set&lt;Integer&gt; distinct = new HashSet&lt;Integer&gt;(); for(int num : nums) &#123; if(distinct.contains(num)) &#123; return true; &#125; distinct.add(num); &#125; return false; &#125;&#125; solution 3: 10ms, 54.48%, July 13th, 2016 123456789public class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); for(int i : nums) if(!set.add(i)) return true; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[216. Combination Sum III]]></title>
    <url>%2Fp%2F76a270b0%2F</url>
    <content type="text"><![CDATA[43.2% https://leetcode.com/problems/combination-sum-iii/description/ Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. 1234567Example 1:Input: k = 3, n = 7Output:[[1,2,4]] 1234567Example 2:Input: k = 3, n = 9Output:[[1,2,6], [1,3,5], [2,3,4]] 方法一： 回溯法，我的代码实现 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; combination; helper(k, n, 1, combination, res); return res; &#125; void helper(int k, int target, int start, vector&lt;int&gt;&amp; combination, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(target==0 &amp;&amp; k==0)&#123; res.push_back(combination); return; &#125; if(k&lt;=0 || target&lt;0) return; for(int i=start; i&lt;10; i++)&#123; combination.push_back(i); helper(k-1, target-i, i+1, combination, res); combination.pop_back(); &#125; &#125;&#125;; Use backtrack c++ solution, easy to understand. 下段代码值得借鉴的是backtrack的判断条件 i&lt;=10-k &amp;&amp; i&lt;=target 123456789101112131415161718vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; backtrack(result, path, 1, k, n); return result;&#125;void backtrack(vector&lt;vector&lt;int&gt;&gt; &amp;result, vector&lt;int&gt; &amp;path, int start, int k, int target)&#123; if(target==0&amp;&amp;k==0)&#123; result.push_back(path); return; &#125; for(int i=start;i&lt;=10-k&amp;&amp;i&lt;=target;i++)&#123; path.push_back(i); backtrack(result,path,i+1,k-1,target-i); path.pop_back(); &#125;&#125; https://discuss.leetcode.com/topic/14641/my-c-solution-backtracking My C++ solution, backtracking. 123456789101112131415161718192021class Solution &#123;public: void combination(vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; sol, int k, int n) &#123; if (sol.size() == k &amp;&amp; n == 0) &#123; result.push_back(sol); return ; &#125; if (sol.size() &lt; k) &#123; for (int i = sol.empty() ? 1 : sol.back() + 1; i &lt;= 9; ++i) &#123; if (n - i &lt; 0) break; sol.push_back(i); combination(result, sol, k, n - i); sol.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; sol; combination(result, sol, k, n); return result; &#125;&#125;; https://discuss.leetcode.com/topic/25351/use-backtrack-c-solution-easy-to-understand Use backtrack c++ solution, easy to understand. 123456789101112131415161718vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; backtrack(result, path, 1, k, n); return result;&#125;void backtrack(vector&lt;vector&lt;int&gt;&gt; &amp;result, vector&lt;int&gt; &amp;path, int start, int k, int target)&#123; if(target==0&amp;&amp;k==0)&#123; result.push_back(path); return; &#125; for(int i=start;i&lt;=10-k&amp;&amp;i&lt;=target;i++)&#123; path.push_back(i); backtrack(result,path,i+1,k-1,target-i); path.pop_back(); &#125;&#125; 52ms, 43.32%, June.18th, 2016 https://leetcode.com/discuss/38132/concise-python-solution-using-dfs Concise python solution using DFS 1234567891011121314151617181920212223242526class Solution: # @param &#123;integer&#125; k # @param &#123;integer&#125; n # @return &#123;integer[][]&#125; def combinationSum3(self, k, n): if n &gt; sum([i for i in range(1, 11)]): return [] res = [] self.sum_help(k, n, 1, [], res) return res def sum_help(self, k, n, curr, arr, res): if len(arr) == k: if sum(arr) == n: res.append(list(arr)) return if len(arr) &gt; k or curr &gt; 9: return for i in range(curr, 10): arr.append(i) self.sum_help(k, n, i + 1, arr, res) arr.pop() https://discuss.leetcode.com/topic/14702/clean-1-6-7-liners-ac Clean 1/6/7-liners (AC) Batteries Included AC in 44ms First the obligatory “use the darn library” solution. Create all k-combinations of digits and keep those with sum n: 12345from itertools import combinationsclass Solution: def combinationSum3(self, k, n): return [c for c in combinations(range(1, 10), k) if sum(c) == n] Recursive AC in 48 ms But it’s more interesting to do it on your own. Here I use a recursive helper function getting the same k and n as the main function, and an additional cap under which all the numbers have to be: 123456789class Solution: def combinationSum3(self, k, n): def combs(k, n, cap): if not k: return [[]] * (not n) return [comb + [last] for last in range(1, cap) for comb in combs(k-1, n-last, last)] return combs(k, n, 10) Iterative AC in 56 ms And an iterative version doing pretty much the same thing, except this time I prepend elements on the left, and use the first element of a partial combination as the cap. 12345678class Solution: def combinationSum3(self, k, n): combs = [[]] for _ in range(k): combs = [[first] + comb for comb in combs for first in range(1, comb[0] if comb else 10)] return [c for c in combs if sum(c) == n] Reduce AC in 44 ms And here’s a “one-liner” version of the iterative solution using reduce instead of the loop: 12345678class Solution: def combinationSum3(self, k, n): return [c for c in reduce(lambda combs, _: [[first] + comb for comb in combs for first in range(1, comb[0] if comb else 10)], range(k), [[]]) if sum(c) == n] I note that all these solutions also correctly solve the cases with k=0 and/or n=0 (but leetcode sadly doesn’t test those). https://discuss.leetcode.com/topic/19100/easy-to-understand-python-solution-backtracking Easy to understand Python solution (backtracking). 123456789101112def combinationSum3(self, k, n): res = [] self.dfs(xrange(1,10), k, n, 0, [], res) return res def dfs(self, nums, k, n, index, path, res): if k &lt; 0 or n &lt; 0: # backtracking return if k == 0 and n == 0: res.append(path) for i in xrange(index, len(nums)): self.dfs(nums, k-1, n-nums[i], i+1, path+[nums[i]], res)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[215. Kth Largest Element in an Array]]></title>
    <url>%2Fp%2F85bb0f40%2F</url>
    <content type="text"><![CDATA[38.2% https://leetcode.com/problems/kth-largest-element-in-an-array/#/description Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. 12For example,Given [3,2,1,5,6,4] and k = 2, return 5. Note: You may assume k is always valid, 1 ≤ k ≤ array’s length. 总结： 方法一 : 先排序，后选出第k大的数字。面试肯定没啥用。 注意，对nums排序是，sort(nums.begin(), nums.end()), 不是sort(nums) 12345678class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); sort(nums.begin(), nums.end()); return nums[n - k]; &#125;&#125;; 我的代码实现: 12345678class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); int n = nums.size(); return nums[n-k]; &#125;&#125;; 方法二: 求最大k值，建最小堆，效率O(nlogk)，第一次建堆k，每次排除一个头部，并重新维护堆性质logk。 学习如何建堆，默认建最大堆，如何建立最小堆。同时make_heap(res.begin(), res.end())，而不是make_heap(res)， 类似于sort。 学习如何设置cmp函数。 123456789101112131415161718class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); vector&lt;int&gt; res(nums.begin(), nums.begin() + k); make_heap(res.begin(), res.end(), [](int&amp; a, int&amp; b) &#123; return a&gt;b; &#125;); for (int i = k; i&lt;n; i++) &#123; if (nums[i]&gt;res[0]) &#123; pop_heap(res.begin(), res.end(), [](int&amp; a, int&amp; b) &#123; return a&gt;b; &#125;); res.pop_back(); res.push_back(nums[i]); push_heap(res.begin(), res.end(), [](int&amp; a, int&amp; b) &#123; return a&gt;b; &#125;); &#125; &#125; sort_heap(res.begin(), res.end(), [](int&amp; a, int&amp; b) &#123; return a&gt;b; &#125;); return res[k-1]; &#125;&#125;; 我的实现 需要先建最小堆， 然后从k至最后遍历 如果大于最小值，替换了，然后维护最小堆的性质 遍历到最后，堆里面是最大的k个，堆的root是第k大的值。 返回res[0]就好。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; if(nums.size()&lt;k) return -1; // make heap vector&lt;int&gt; res(nums.begin(), nums.begin()+k); for(int i=(k-2)/2; i&gt;=0; i--)&#123; minHeapify(res, i, k-1); &#125; for(int i=k; i&lt;nums.size(); i++)&#123; if(nums[i]&gt;res[0])&#123; res[0] = nums[i]; minHeapify(res, 0, k-1); &#125; &#125; return res[0]; &#125; void minHeapify(vector&lt;int&gt;&amp; nums, int start, int end)&#123; if(start&gt;=end) return; int parent = start; int child = 2*parent+1; while(child&lt;=end)&#123; if(child+1&lt;=end &amp;&amp; nums[child+1]&lt;nums[child])&#123; child += 1; &#125; if(nums[child]&lt;nums[parent])&#123; swap(nums[child], nums[parent]); parent = child; child = 2*parent+1; &#125;else&#123; break; &#125; &#125; return; &#125;&#125;; 我的代码实现: 123456789101112131415161718192021222324252627282930class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; v(nums.begin(), nums.begin()+k); for(int i=(k-2)/2; i&gt;=0; i--) miniheapify(v, i, k-1); for(int i=k; i&lt;nums.size(); i++) if(nums[i]&gt;v[0])&#123; v[0] = nums[i]; miniheapify(v, 0, k-1); &#125; return v[0]; &#125; void miniheapify(vector&lt;int&gt;&amp; v, int start, int end)&#123; if(start&gt;=end) return; int parent = start, child = 2*parent+1; while(child&lt;=end)&#123; if(child+1&lt;=end &amp;&amp; v[child+1]&lt;v[child]) child += 1; if(v[child]&lt;v[parent])&#123; swap(v[child], v[parent]); parent = child; child = 2*parent+1; &#125;else break; &#125; &#125;&#125;; 方法三: 使用快排里的patition方法，直到分配到一遍的是k个，并且对此进行排序。 12345678910111213141516171819202122232425class Solution &#123; public: int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int pivot = nums[left]; int l = left + 1, r = right; while (l &lt;= r) &#123; if (nums[l] &lt; pivot &amp;&amp; nums[r] &gt; pivot) swap(nums[l++], nums[r--]); if (nums[l] &gt;= pivot) l++; if (nums[r] &lt;= pivot) r--; &#125; swap(nums[left], nums[r]); return r; &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int left = 0, right = nums.size() - 1; while (true) &#123; int pos = partition(nums, left, right); if (pos == k - 1) return nums[pos]; if (pos &gt; k - 1) right = pos - 1; else left = pos + 1; &#125; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int left=0, right = nums.size()-1; int index = partition(nums, left, right); while(index!=k-1)&#123; // 这里是k-1，而不是k，求第k，就是index==k-1 if(index&lt;k-1)&#123; left = index+1; &#125;else&#123; right = index-1; &#125; index = partition(nums, left, right); &#125; return nums[k-1]; &#125; int partition(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if(left == right) return left; int pos = left-1; for(int i=left; i &lt; right; i++)&#123; if(nums[i]&gt;=nums[right])&#123; pos++; swap(nums[pos], nums[i]); &#125; &#125; pos++; swap(nums[pos], nums[right]); return pos; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324252627class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); int left = 0, right = n-1; int pos = partition(nums, left, right); while(pos!=n-k)&#123; if(pos&lt;n-k) left = pos+1; else right = pos-1; pos = partition(nums, left, right); &#125; return nums[n-k]; &#125; int partition(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if(left&gt;=right) return left; int pos = left-1; for(int i=left; i&lt;right; i++) if(nums[i]&lt;=nums[right]) swap(nums[i], nums[++pos]); swap(nums[right], nums[++pos]); return pos; &#125;&#125;; 资料，如何设置最小堆的比较函数 http://stackoverflow.com/questions/14016921/comparator-for-min-heap-in-c 123456789101112131415161718192021222324252627#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;struct greater1&#123; bool operator()(const long&amp; a,const long&amp; b) const&#123; return a&gt;b; &#125;&#125;;int main() &#123; std::vector&lt;long&gt; humble; humble.push_back(15); humble.push_back(15); humble.push_back(9); humble.push_back(25); std::make_heap(humble.begin(), humble.end(), greater1()); while (humble.size()) &#123; std::pop_heap(humble.begin(),humble.end(),greater1()); long min = humble.back(); humble.pop_back(); std::cout &lt;&lt; min &lt;&lt; std::endl; &#125; return 0;&#125; cpp https://discuss.leetcode.com/topic/15256/4-c-solutions-using-partition-max-heap-priority_queue-and-multiset-respectively 4 C++ Solutions using Partition, Max-Heap, priority_queue and multiset respectively Well, this problem has a naive solution, which is to sort the array in descending order and return the k-1-th element. 1234567class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); return nums[k - 1]; &#125;&#125;; However, sorting algorithm gives O(nlogn) complexity. Suppose n = 10000 and k = 2, then we are doing a lot of unnecessary operations. In fact, this problem has at least two simple and faster solutions. Well, the faster solution has no mystery. It is also closely related to sorting. I will give two algorithms for this problem below, one using quicksort(specifically, the partition subroutine) and the other using heapsort. Quicksort In quicksort, in each iteration, we need to select a pivot and then partition the array into three parts: Elements smaller than the pivot; Elements equal to the pivot; Elements larger than the pivot. Now, let’s do an example with the array [3, 2, 1, 5, 4, 6] in the problem statement. Let’s assume in each time we select the leftmost element to be the pivot, in this case, 3. We then use it to partition the array into the above 3 parts, which results in [1, 2, 3, 5, 4, 6]. Now 3 is in the third position and we know that it is the third smallest element. Now, do you recognize that this subroutine can be used to solve this problem? In fact, the above partition puts elements smaller than the pivot before the pivot and thus the pivot will then be the k-th smallest element if it is at the k-1-th position. Since the problem requires us to find the k-th largest element, we can simply modify the partition to put elements larger than the pivot before the pivot. That is, after partition, the array becomes [5, 6, 4, 3, 1, 2]. Now we know that 3 is the 4-th largest element. If we are asked to find the 2-th largest element, then we know it is left to 3. If we are asked to find the 5-th largest element, then we know it is right to 3. So, in the average sense, the problem is reduced to approximately half of its original size, giving the recursion T(n) = T(n/2) + O(n) in which O(n) is the time for partition. This recursion, once solved, gives T(n) = O(n) and thus we have a linear time solution. Note that since we only need to consider one half of the array, the time complexity is O(n). If we need to consider both the two halves of the array, like quicksort, then the recursion will be T(n) = 2T(n/2) + O(n) and the complexity will be O(nlogn). Of course, O(n) is the average time complexity. In the worst case, the recursion may become T(n) = T(n - 1) + O(n) and the complexity will be O(n^2). Now let’s briefly write down the algorithm before writing our codes. Initialize left to be 0 and right to be nums.size() - 1; Partition the array, if the pivot is at the k-1-th position, return it (we are done); If the pivot is right to the k-1-th position, update right to be the left neighbor of the pivot; Else update left to be the right neighbor of the pivot. Repeat 2. Now let’s turn it into code. 12345678910111213141516171819202122232425class Solution &#123; public: int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int pivot = nums[left]; int l = left + 1, r = right; while (l &lt;= r) &#123; if (nums[l] &lt; pivot &amp;&amp; nums[r] &gt; pivot) swap(nums[l++], nums[r--]); if (nums[l] &gt;= pivot) l++; if (nums[r] &lt;= pivot) r--; &#125; swap(nums[left], nums[r]); return r; &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int left = 0, right = nums.size() - 1; while (true) &#123; int pos = partition(nums, left, right); if (pos == k - 1) return nums[pos]; if (pos &gt; k - 1) right = pos - 1; else left = pos + 1; &#125; &#125;&#125;; Heapsort Well, this problem still has a tag “heap”. If you are familiar with heapsort, you can solve this problem using the following idea: Build a max-heap for nums, set heap_size to be nums.size(); Swap nums[0] (after buding the max-heap, it will be the largest element) with nums[heap_size - 1] (currently the last element). Then decrease heap_size by 1 and max-heapify nums (recovering its max-heap property) at index 0; Repeat 2 for k times and the k-th largest element will be stored finally at nums[heap_size]. Now I paste my code below. If you find it tricky, I suggest you to read the Heapsort chapter of Introduction to Algorithms, which has a nice explanation of the algorithm. My code simply translates the pseudo code in that book :-) 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: inline int left(int idx) &#123; return (idx &lt;&lt; 1) + 1; &#125; inline int right(int idx) &#123; return (idx &lt;&lt; 1) + 2; &#125; void max_heapify(vector&lt;int&gt;&amp; nums, int idx) &#123; int largest = idx; int l = left(idx), r = right(idx); if (l &lt; heap_size &amp;&amp; nums[l] &gt; nums[largest]) largest = l; if (r &lt; heap_size &amp;&amp; nums[r] &gt; nums[largest]) largest = r; if (largest != idx) &#123; swap(nums[idx], nums[largest]); max_heapify(nums, largest); &#125; &#125; void build_max_heap(vector&lt;int&gt;&amp; nums) &#123; heap_size = nums.size(); for (int i = (heap_size &gt;&gt; 1) - 1; i &gt;= 0; i--) max_heapify(nums, i); &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; build_max_heap(nums); for (int i = 0; i &lt; k; i++) &#123; swap(nums[0], nums[heap_size - 1]); heap_size--; max_heapify(nums, 0); &#125; return nums[heap_size]; &#125;private: int heap_size;&#125; If we are allowed to use the built-in priority_queue, the code will be much more shorter :-) 123456789class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int&gt; pq(nums.begin(), nums.end()); for (int i = 0; i &lt; k - 1; i++) pq.pop(); return pq.top(); &#125;&#125;; Well, the priority_queue can also be replaced by multiset :-) 12345678910111213class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; multiset&lt;int&gt; mset; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; mset.insert(nums[i]); if (mset.size() &gt; k) mset.erase(mset.begin()); &#125; return *mset.begin(); &#125;&#125;; https://discuss.leetcode.com/topic/16970/4ms-c-solution-straightforward-to-find-largest-k-kind-like-a-partition-version 4ms c++ solution. straightforward to find largest k. kind like a partition version. 12345678910111213141516class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int cur=nums[k-1]; vector&lt;int&gt; bigger; vector&lt;int&gt; smaller; for(size_t i=0; i&lt;nums.size(); ++i)&#123; if(i==k-1) continue; if(nums[i]&gt;=cur) bigger.push_back(nums[i]); else smaller.push_back(nums[i]); &#125; if(bigger.size()==k-1) return cur; if(bigger.size()&gt;k-1) return findKthLargest(bigger,k); if(bigger.size()&lt;k-1) return findKthLargest(smaller,k-bigger.size()-1); &#125;&#125;; https://discuss.leetcode.com/topic/22159/python-different-solutions-with-comments-bubble-sort-selection-sort-heap-sort-and-quick-sort Python different solutions with comments (bubble sort, selection sort, heap sort and quick sort). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# O(nlgn) timedef findKthLargest1(self, nums, k): return sorted(nums, reverse=True)[k-1] # O(nk) time, bubble sort idea, TLEdef findKthLargest2(self, nums, k): for i in xrange(k): for j in xrange(len(nums)-i-1): if nums[j] &gt; nums[j+1]: # exchange elements, time consuming nums[j], nums[j+1] = nums[j+1], nums[j] return nums[len(nums)-k] # O(nk) time, selection sort ideadef findKthLargest3(self, nums, k): for i in xrange(len(nums), len(nums)-k, -1): tmp = 0 for j in xrange(i): if nums[j] &gt; nums[tmp]: tmp = j nums[tmp], nums[i-1] = nums[i-1], nums[tmp] return nums[len(nums)-k] # O(k+(n-k)lgk) time, min-heapdef findKthLargest4(self, nums, k): heap = [] for num in nums: heapq.heappush(heap, num) for _ in xrange(len(nums)-k): heapq.heappop(heap) return heapq.heappop(heap)# O(k+(n-k)lgk) time, min-heap def findKthLargest5(self, nums, k): return heapq.nlargest(k, nums)[k-1] # O(n) time, quick selectiondef findKthLargest(self, nums, k): # convert the kth largest to smallest return self.findKthSmallest(nums, len(nums)+1-k) def findKthSmallest(self, nums, k): if nums: pos = self.partition(nums, 0, len(nums)-1) if k &gt; pos+1: return self.findKthSmallest(nums[pos+1:], k-pos-1) elif k &lt; pos+1: return self.findKthSmallest(nums[:pos], k) else: return nums[pos] # choose the right-most element as pivot def partition(self, nums, l, r): low = l while l &lt; r: if nums[l] &lt; nums[r]: nums[l], nums[low] = nums[low], nums[l] low += 1 l += 1 nums[low], nums[r] = nums[r], nums[low] return low https://discuss.leetcode.com/topic/20740/share-my-python-solution-with-quickselect-idea Share my Python solution with QuickSelect idea 12345678910111213141516171819class Solution:# @param &#123;integer[]&#125; nums# @param &#123;integer&#125; k# @return &#123;integer&#125;def findKthLargest(self, nums, k): # QuickSelect idea: AC in 52 ms # --------------------------- # pivot = nums[0] left = [l for l in nums if l &lt; pivot] equal = [e for e in nums if e == pivot] right = [r for r in nums if r &gt; pivot] if k &lt;= len(right): return self.findKthLargest(right, k) elif (k - len(right)) &lt;= len(equal): return equal[0] else: return self.findKthLargest(left, k - len(right) - len(equal)) cppSolution 1: 20ms, 53,47%, June.18th, 2016 https://leetcode.com/discuss/38336/solutions-partition-priority_queue-multiset-respectively 12345678class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int N = nums.size(); sort(nums.begin(), nums.end()); return nums[N-k]; &#125;&#125;; pythonSolution Mine: 52ms, 88.30%, June.18th, 2016 123456789class Solution(object): def findKthLargest(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; nums.sort() return nums[-k] Solution 1: 3164ms, 7.6%, June.18th, 2016 https://leetcode.com/discuss/50389/share-my-python-solution-with-quickselect-idea 123456789101112131415161718class Solution(object): def findKthLargest(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; pivot = nums[0] left = [i for i in nums if i &lt; pivot] equal = [i for i in nums if i == pivot] right = [i for i in nums if i &gt; pivot] if k &lt;= len(right): return self.findKthLargest(right, k) elif k &lt;= len(right) + len(equal): return equal[0] else: return self.findKthLargest(left, k - len(right)-len(equal)) Solution 2: 60ms, 75.44%, June.18th, 2016 https://leetcode.com/discuss/53530/python-different-solutions-comments-bubble-selection-quick 12345678class Solution(object): def findKthLargest(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; return heapq.nlargest(k, nums)[k-1] 6ms, 72.82%, June.18th, 2016 12345678https://leetcode.com/discuss/36966/solution-explainedpublic class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; final int N = nums.length; Arrays.sort(nums); return nums[N-k]; &#125;&#125; java https://discuss.leetcode.com/topic/14597/solution-explained Solution explained This problem is well known and quite often can be found in various text books. You can take a couple of approaches to actually solve it: O(N lg N) running time + O(1) memory The simplest approach is to sort the entire input array and then access the element by it’s index (which is O(1)) operation: 12345public int findKthLargest(int[] nums, int k) &#123; final int N = nums.length; Arrays.sort(nums); return nums[N - k];&#125; O(N lg K) running time + O(K) memory Other possibility is to use a min oriented priority queue that will store the K-th largest values. The algorithm iterates over the whole input and maintains the size of priority queue. 123456789101112public int findKthLargest(int[] nums, int k) &#123; final PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(); for(int val : nums) &#123; pq.offer(val); if(pq.size() &gt; k) &#123; pq.poll(); &#125; &#125; return pq.peek();&#125; O(N) best case / O(N^2) worst case running time + O(1) memory The smart approach for this problem is to use the selection algorithm (based on the partion method - the same one as used in quicksort). 12345678910111213141516171819202122232425262728293031323334353637383940414243public int findKthLargest(int[] nums, int k) &#123; k = nums.length - k; int lo = 0; int hi = nums.length - 1; while (lo &lt; hi) &#123; final int j = partition(nums, lo, hi); if(j &lt; k) &#123; lo = j + 1; &#125; else if (j &gt; k) &#123; hi = j - 1; &#125; else &#123; break; &#125; &#125; return nums[k]; &#125; private int partition(int[] a, int lo, int hi) &#123; int i = lo; int j = hi + 1; while(true) &#123; while(i &lt; hi &amp;&amp; less(a[++i], a[lo])); while(j &gt; lo &amp;&amp; less(a[lo], a[--j])); if(i &gt;= j) &#123; break; &#125; exch(a, i, j); &#125; exch(a, lo, j); return j; &#125; private void exch(int[] a, int i, int j) &#123; final int tmp = a[i]; a[i] = a[j]; a[j] = tmp; &#125; private boolean less(int v, int w) &#123; return v &lt; w; &#125; O(N) guaranteed running time + O(1) space So how can we improve the above solution and make it O(N) guaranteed? The answer is quite simple, we can randomize the input, so that even when the worst case input would be provided the algorithm wouldn’t be affected. So all what it is needed to be done is to shuffle the input. 123456789101112131415161718192021222324252627public int findKthLargest(int[] nums, int k) &#123; shuffle(nums); k = nums.length - k; int lo = 0; int hi = nums.length - 1; while (lo &lt; hi) &#123; final int j = partition(nums, lo, hi); if(j &lt; k) &#123; lo = j + 1; &#125; else if (j &gt; k) &#123; hi = j - 1; &#125; else &#123; break; &#125; &#125; return nums[k]; &#125;private void shuffle(int a[]) &#123; final Random random = new Random(); for(int ind = 1; ind &lt; a.length; ind++) &#123; final int r = random.nextInt(ind + 1); exch(a, ind, r); &#125; &#125; There is also worth mentioning the Blum-Floyd-Pratt-Rivest-Tarjan algorithm that has a guaranteed O(N) running time.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>divide and conquer</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[214. Shortest Palindrome]]></title>
    <url>%2Fp%2Fd81a1f9f%2F</url>
    <content type="text"><![CDATA[23.5% https://leetcode.com/problems/shortest-palindrome/#/description Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. 12345For example:Given &quot;aacecaaa&quot;, return &quot;aaacecaaa&quot;.Given &quot;abcd&quot;, return &quot;dcbabcd&quot;. 此处需要思考 https://discuss.leetcode.com/topic/14526/c-8-ms-kmp-based-o-n-time-o-n-memory-solution C++ 8 ms KMP-based O(n) time &amp; O(n) memory solution We can construct the following string and run KMP algorithm on it: (s) + (some symbol not present in s) + (reversed string) After running KMP on that string as result we get a vector p with values of a prefix function for each character (for definition of a prefix function see KMP algorithm description). We are only interested in the last value because it shows us the largest suffix of the reversed string that matches the prefix of the original string. So basically all we left to do is to add the first k characters of the reversed string to the original string, where k is a difference between original string size and the prefix function for the last character of a constructed string. 123456789101112131415161718class Solution &#123;public: string shortestPalindrome(string s) &#123; string rev_s = s; reverse(rev_s.begin(), rev_s.end()); string l = s + &quot;#&quot; + rev_s; vector&lt;int&gt; p(l.size(), 0); for (int i = 1; i &lt; l.size(); i++) &#123; int j = p[i - 1]; while (j &gt; 0 &amp;&amp; l[i] != l[j]) j = p[j - 1]; p[i] = (j += l[i] == l[j]); &#125; return rev_s.substr(0, s.size() - p[l.size() - 1]) + s; &#125;&#125;; https://discuss.leetcode.com/topic/14770/my-easily-understandable-but-time-consuming-c-solution My easily understandable but time consuming C++ solution The key idea is to first reverse the string, then check the max length from n to 0 1234567891011121314class Solution &#123;public: string shortestPalindrome(string s) &#123; string s2=s; reverse(s2.begin(),s2.end()); int n=s.size(),l; for(l=n;l&gt;=0;l--) &#123; if(s.substr(0,l)==s2.substr(n-l)) break; &#125; return s2.substr(0,n-l)+s; &#125;&#125;; https://discuss.leetcode.com/topic/16275/accepted-4ms-c-solution-different-with-kmp-based-solution-and-easy-understand/2 Accepted 4ms c++ solution, different with KMP-based solution and easy understand. For this problem, KMP-based solution is a very typical and classic O(n) solution. Here is a different solution, it’s also O(n), and I think it is more easy to understand. In order to slove this problem, the key is to get the length of the longest palindromic prefix substring. if the length of s is len, and the length of the longest palindromic prefix substring is longest, the remaining substring will be s.substr(longest, len - longest), than we should reverse the remaining substring and adding it in front of s. For example, if s is “abacbbcda”, so the longest palindromic prefix substring is “aba”(not “cbbc” because it’s not prefix string), and the remaining substring is “cbbcda”, we reverse the remaining substring and get “adcbbc”, so the result is “adcbbc” + “abacbbcda”. The follow is my c++ solution, only 4ms. Please note that the condition in for loop is begin &lt;= len / 2 instead of begin &lt; len, because if begin &gt; len / 2, the substring can not be prefix string, so there is no need to continue. Update: I made wrong analysis, the complexity is O(N^2) but not O(N). Thanks very much for Sammax’s reminder. 123456789101112131415161718192021222324252627class Solution &#123;public: std::string shortestPalindrome(std::string s) &#123; int len = s.length(); if (len &lt; 2) return s; // calculate the length of the longest palindromic prefix substring. int longest = 1, start, end; for (int begin = 0; begin &lt;= len / 2;) &#123; start = end = begin; while (end &lt; len - 1 &amp;&amp; s[end + 1] == s[end]) ++end; begin = end + 1; while (end &lt; len - 1 &amp;&amp; start &gt; 0 &amp;&amp; s[end + 1] == s[start - 1]) &#123; ++end; --start; &#125; // start == 0 means the palindromic substring is also prefix string. if (start == 0 &amp;&amp; longest &lt; end - start + 1) longest = end - start + 1; &#125; // reverse the remaining substring and adding it in front of s. std::string remaining = s.substr(longest, len - longest); std::reverse(remaining.begin(), remaining.end()); return remaining + s; &#125;&#125;; 262ms, 29.90%, October 14, 2016 https://discuss.leetcode.com/topic/14542/ac-in-288-ms-simple-brute-force AC in 288 ms, simple brute force 12345def shortestPalindrome(self, s): r = s[::-1] for i in range(len(s) + 1): if s.startswith(r[i:]): return r[:i] + s Example: s = dedcba. Then r = abcded and I try these overlays (the part in (…) is the prefix I cut off, I just include it in the display for better understanding): 12345s dedcbar[0:] abcded Nope...r[1:] (a)bcded Nope...r[2:] (ab)cded Nope...r[3:] (abc)ded Yes! Return abc + dedcba 7ms, 69.02%, October 14, 2016 https://discuss.leetcode.com/topic/21068/my-7-lines-recursive-java-solution 123456789101112public class Solution &#123; public String shortestPalindrome(String s) &#123; int j = 0; for(int i = s.length() - 1; i&gt;=0; i--)&#123; if(s.charAt(i) == s.charAt(j)) j += 1; &#125; if(j == s.length()) return s; String suffix = s.substring(j); return new StringBuffer(suffix).reverse().toString() + shortestPalindrome(s.substring(0,j)) + suffix; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[213. House Robber II]]></title>
    <url>%2Fp%2Ff35c89e6%2F</url>
    <content type="text"><![CDATA[33.4% https://leetcode.com/problems/house-robber-ii/#/description Note: This is an extension of House Robber. After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 方法一： 与house robber i 类似，但是这个可以看做两个，一个是nums[2:],一个是nums[:-1]这两个偷盗情况。这样就可以随意像一个那么偷了。 https://discuss.leetcode.com/topic/14504/9-lines-0ms-o-1-space-c-solution 9-lines 0ms O(1)-Space C++ solution This problem is a little tricky at first glance. However, if you have finished the House Robber problem, this problem can simply be decomposed into two House Robber problems.Suppose there are n houses, since house 0 and n - 1 are now neighbors, we cannot rob them together and thus the solution is now the maximum of Rob houses 0 to n - 2; Rob houses 1 to n - 1. The code is as follows. Some edge cases (n &lt; 2) are handled explicitly. 123456789101112131415161718class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt; 2) return n ? nums[0] : 0; return max(robber(nums, 0, n - 2), robber(nums, 1, n - 1)); &#125;private: int robber(vector&lt;int&gt;&amp; nums, int l, int r) &#123; int pre = 0, cur = 0; for (int i = l; i &lt;= r; i++) &#123; int temp = max(pre + nums[i], cur); pre = cur; cur = temp; &#125; return cur; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; if(n==1) return nums[0]; int first = helper(nums, 0, n-2); int second = helper(nums, 1, n-1); return max(first, second); &#125; int helper(vector&lt;int&gt;&amp; nums, int start, int end)&#123; int r1 = 0, r2 = 0; int res = 0; for(int i=start; i&lt;=end; i++)&#123; res = max(r2, r1+nums[i]); r1 = r2; r2 = res; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/14325/twice-pass-solution-c Twice pass solution, C++ Twice pass: not rob nums[n-1] not rob nums[0] and the other is same as House Robber. 12345678910111213141516171819202122232425int rob(vector&lt;int&gt;&amp; nums)&#123; if(nums.size() == 0) return 0; if(nums.size() == 1) return nums[0]; int pre1 = 0, cur1 = 0; for(int i = 0; i &lt; nums.size() - 1; ++ i) &#123; int temp = pre1; pre1 = cur1; cur1 = max(temp + nums[i], pre1); &#125; int pre2 = 0, cur2 = 0; for(int i = 1; i &lt; nums.size(); ++ i) &#123; int temp = pre2; pre2 = cur2; cur2 = max(temp + nums[i], pre2); &#125; return max(cur1, cur2);&#125; https://discuss.leetcode.com/topic/20770/c-super-simple-0ms-solution-with-explanation [C++] Super Simple 0ms solution with explanation Since you cannot rob both the first and last house, just create two separate vectors, one excluding the first house, and another excluding the last house. The best solution generated from these two vectors using the original House Robber DP algorithm is the optimal one. 12345678910111213141516171819202122232425class Solution &#123;public: int robOriginal(vector&lt;int&gt;&amp; nums) &#123; int a = 0, b = 0, res = 0; for(int i = 0; i &lt; nums.size(); ++i)&#123; res = max(b + nums[i], a); b = a; a = res; &#125; return res; &#125; int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; if(nums.size() == 1) return nums[0]; vector&lt;int&gt; numsA(nums.begin() + 1, nums.end()); vector&lt;int&gt; numsB(nums.begin(), nums.end()-1); return max(robOriginal(numsA), robOriginal(numsB)); &#125;&#125;; https://discuss.leetcode.com/topic/18123/0ms-o-n-time-o-1-space-c-solution 0ms O(N) time O(1) space C++ solution This solution is based on house robber 1. The idea is that either the first house or the last house is not robbed. The final solution is max of (house robber without last element) and (house robber without the first element). Note endIndex is not inclusive in the second rob function. 1234567891011121314151617181920class Solution &#123;public:int rob(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; return max(rob(nums, 0, nums.size()-1), rob(nums, 1, 0));&#125;int rob(vector&lt;int&gt;&amp; nums, int startIndex, int endIndex) &#123; int p = 0, q = 0; for (int i = startIndex; i != endIndex; /* do nothing */) &#123; int tmp = p; p = max(p, q + nums[i]); q = tmp; i = (i + 1) % nums.size(); &#125; return p;&#125;&#125;; https://discuss.leetcode.com/topic/28279/simple-and-easy-c-solution-modified-from-the-best-solution-of-house-robber-easy Simple and easy C++ solution modified from the best solution of House Robber (Easy) 12345678910111213141516171819int rob_line(vector&lt;int&gt;&amp; nums, int start, int end) &#123; int odd_sum=0; int even_sum=0; for(int i=start; i&lt;end; i++) &#123; if(i%2) odd_sum = max(even_sum, odd_sum+nums[i]); else even_sum = max(odd_sum, even_sum+nums[i]); &#125; return max(odd_sum, even_sum);&#125;int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; else if(nums.size()==1) return nums[0]; else return max(rob_line(nums,0,nums.size()-1), rob_line(nums,1,nums.size()));&#125; 12345678910111213141516# Solution mine:# 48ms, 20.23%, 74/74, April.25th, 2016class Solution(object): def rob_ori(self, num): num = [0, 0] + num for i, n in enumerate(num[2:], start = 2) : num[i] = max(num[i-2] + n, num[i-1]) return num[-1] def rob(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if not nums: return 0 if len(nums) == 1: return nums[0] return max(self.rob_ori(nums[1:]), self.rob_ori(nums[:-1]))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[212. Word Search II]]></title>
    <url>%2Fp%2Fd7166e68%2F</url>
    <content type="text"><![CDATA[22.8% Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. 12345678910For example,Given words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] and board =[ [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;], [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;], [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;], [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]Return [&quot;eat&quot;,&quot;oath&quot;]. Note: You may assume that all inputs are consist of lowercase letters a-z. https://discuss.leetcode.com/topic/14301/my-c-trie-backtrace-based-solution-48-ms My C++ Trie + Backtrace based solution (48 ms) The idea is to use a Trie to build a prefix tree for words to simplify the search and do DFS to search all the possible strings. For Trie, 26 pointers to point the sub-strings and a bool leaf to indicate whether the current node is a leaf (i.e. a string in words) and also idx is used to save the index of words for the current node. For DFS, just check if the current position is visited before (board[i][j]==’X’), if so, return, check if there is a string with such prefix (nullptr == root-&gt;children[words[idx][pos]-‘a’]), if not, return; otherwise, check if the current searched string is a leaf of the trie (a string in words), if so, save it to res and set leaf of the trie node to false to indicate such string is already found. At last, move to its neighbors to continue the search. Remember to recover the char [i][j] at the end. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123; class Trie&#123; public: Trie *children[26]; // pointers to its substrings starting with &apos;a&apos; to &apos;z&apos; bool leaf; // if the node is a leaf, or if there is a word stopping at here int idx; // if it is a leaf, the string index of the array words Trie() &#123; this-&gt;leaf = false; this-&gt;idx = 0; fill_n(this-&gt;children, 26, nullptr); &#125; &#125;; public: void insertWords(Trie *root, vector&lt;string&gt;&amp; words, int idx) &#123; int pos = 0, len = words[idx].size(); while(pos&lt;len) &#123; if(nullptr == root-&gt;children[words[idx][pos]-&apos;a&apos;]) root-&gt;children[words[idx][pos]-&apos;a&apos;] = new Trie(); root = root-&gt;children[words[idx][pos++]-&apos;a&apos;]; &#125; root-&gt;leaf = true; root-&gt;idx = idx; &#125; Trie *buildTrie(vector&lt;string&gt;&amp; words) &#123; Trie *root = new Trie(); int i; for(i=0; i&lt;words.size();i++) insertWords(root, words, i); return root; &#125; void checkWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, int row, int col, Trie *root, vector&lt;string&gt; &amp;res, vector&lt;string&gt;&amp; words) &#123; char temp; if(board[i][j]==&apos;X&apos;) return; // visited before; if(nullptr == root-&gt;children[board[i][j]-&apos;a&apos;]) return ; // no string with such prefix else &#123; temp = board[i][j]; if(root-&gt;children[temp-&apos;a&apos;]-&gt;leaf) // if it is a leaf &#123; res.push_back(words[root-&gt;children[temp-&apos;a&apos;]-&gt;idx]); root-&gt;children[temp-&apos;a&apos;]-&gt;leaf = false; // set to false to indicate that we found it already &#125; board[i][j]=&apos;X&apos;; //mark the current position as visited// check all the possible neighbors if(i&gt;0) checkWords(board, i-1, j, row, col, root-&gt;children[temp-&apos;a&apos;], res, words); if((i+1)&lt;row) checkWords(board, i+1, j, row, col, root-&gt;children[temp-&apos;a&apos;], res, words); if(j&gt;0) checkWords(board, i, j-1, row, col, root-&gt;children[temp-&apos;a&apos;], res, words); if((j+1)&lt;col) checkWords(board, i, j+1, row, col, root-&gt;children[temp-&apos;a&apos;], res, words); board[i][j] = temp; // recover the current position &#125; &#125; vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123; vector&lt;string&gt; res; int row = board.size(); if(0==row) return res; int col = board[0].size(); if(0==col) return res; int wordCount = words.size(); if(0==wordCount) return res; Trie *root = buildTrie(words); int i,j; for(i =0 ; i&lt;row; i++) &#123; for(j=0; j&lt;col &amp;&amp; wordCount &gt; res.size(); j++) &#123; checkWords(board, i, j, row, col, root, res, words); &#125; &#125; return res; &#125; &#125;; Based on the comments received. I created another version with Trie node counter (thanks, zhiqing_xiao and gxyeecspku). However, for the current test set, it doesn’t help too much. Anyway, my version with Trie node counter. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123;private:class Trie&#123;public: Trie * children[26]; bool isLeaf; int wordIdx; int prefixCount; Trie() &#123; isLeaf = false; wordIdx = 0; prefixCount = 0; fill_n(children, 26, nullptr); &#125; ~Trie() &#123; for(auto i=0; i&lt;26; ++i) delete children[i]; &#125;&#125;; void insertWord(Trie *root, const vector&lt;string&gt;&amp; words, int idx) &#123; int i, childID, len = words[idx].size(); for(i=0, root-&gt;prefixCount++ ; i&lt;len; ++i) &#123; childID = words[idx][i]-&apos;a&apos;; if(!root-&gt;children[childID]) root-&gt;children[childID] = new Trie(); root = root-&gt;children[childID]; ++root-&gt;prefixCount; &#125; root-&gt;isLeaf = true; root-&gt;wordIdx = idx; &#125; Trie *buildTrie(const vector&lt;string&gt; &amp;words) &#123; Trie *root = new Trie(); for(int i=0; i &lt; words.size(); ++i) insertWord(root, words, i); return root; &#125; int dfs_Trie(vector&lt;string&gt; &amp;res, Trie *root, vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words, int row, int col) &#123; int detected = 0; if(root-&gt;isLeaf) &#123; ++detected; root-&gt;isLeaf = false; res.push_back(words[root-&gt;wordIdx]); &#125; if( row&lt;0 || row&gt;=board.size() || col&lt;0 || col&gt;=board[0].size() || board[row][col]==&apos;*&apos; || !root-&gt;children[ board[row][col]-&apos;a&apos;] || root-&gt;children[ board[row][col]-&apos;a&apos;]-&gt;prefixCount &lt;= 0 ) return detected; int curC = board[row][col] - &apos;a&apos;; board[row][col] = &apos;*&apos;; detected += dfs_Trie(res, root-&gt;children[curC], board, words, row-1, col) + dfs_Trie(res, root-&gt;children[curC], board, words, row+1, col) + dfs_Trie(res, root-&gt;children[curC], board, words, row, col - 1) + dfs_Trie(res, root-&gt;children[curC], board, words, row, col + 1) ; root-&gt;prefixCount -=detected; board[row][col] = curC+&apos;a&apos;; return detected; &#125; public: vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123; int M, N, wordNum = words.size(); vector&lt;string&gt; res; if( !(M = board.size()) || !(N = board[0].size()) || !wordNum) return res; Trie *root = buildTrie(words); for(auto i=0; i&lt;M &amp;&amp; root-&gt;prefixCount; ++i) for(auto j=0; j&lt;N; ++j) dfs_Trie(res, root, board, words, i, j); delete root; return res; &#125;&#125;; https://discuss.leetcode.com/topic/20210/my-ac-very-clean-c-code My AC very clean C++ code The idea is start from every position of the board, and then see if we can find a word starting from this position with checking if is_end is true in TrieNode structure 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class TrieNode&#123;public: bool is_end; vector&lt;TrieNode*&gt; children; TrieNode()&#123; is_end=false; children=vector&lt;TrieNode*&gt;(26, NULL); &#125; &#125;;class Trie&#123;public: TrieNode* getRoot()&#123;return root;&#125; Trie(vector&lt;string&gt;&amp; words)&#123; root=new TrieNode(); for(int i=0; i&lt;words.size(); ++i) addWord(words[i]); &#125; void addWord(const string&amp; word)&#123; TrieNode* cur=root; for(int i=0; i&lt;word.size(); ++i)&#123; int index=word[i]-&apos;a&apos;; if(cur-&gt;children[index]==NULL) cur-&gt;children[index]=new TrieNode(); cur=cur-&gt;children[index]; &#125; cur-&gt;is_end=true; &#125;private: TrieNode* root;&#125;;class Solution &#123;public: vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123; Trie* trie = new Trie(words); TrieNode* root=trie-&gt;getRoot(); set&lt;string&gt; result_set; for(int x=0; x&lt;board.size(); ++x) for(int y=0; y&lt;board[0].size(); ++y) findWords(board, x, y, root, &quot;&quot;, result_set); vector&lt;string&gt; result; for(auto it:result_set) result.push_back(it); return result; &#125;private: void findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, TrieNode* root, string word, set&lt;string&gt;&amp; result)&#123; if(x&lt;0||x&gt;=board.size()||y&lt;0||y&gt;=board[0].size() || board[x][y]==&apos; &apos;) return; if(root-&gt;children[board[x][y]-&apos;a&apos;] != NULL)&#123; word=word+board[x][y]; root=root-&gt;children[board[x][y]-&apos;a&apos;]; if(root-&gt;is_end) result.insert(word); char c=board[x][y]; board[x][y]=&apos; &apos;; findWords(board, x+1, y, root, word, result); findWords(board, x-1, y, root, word, result); findWords(board, x, y+1, root, word, result); findWords(board, x, y-1, root, word, result); board[x][y]=c; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/14307/27-lines-uses-complex-numbers 27 lines, uses complex numbers I first build the tree of words with root root and also represent the board a different way, namely as one-dimensional dictionary where the keys are complex numbers representing the row/column indexes. That makes further work with it easier. Looping over all board positions is just for z in board, the four neighbors of a board position z are just z + 1j**k (for k in 0 to 3), and I don’t need to check borders because board.get just returns “None” if I request an invalid position. After this preparation, I just take the tree and recursively dive with it into each board position. Similar to how you’d search a single word, but with the tree instead. 123456789101112131415161718192021222324252627class Solution: def findWords(self, board, words): root = &#123;&#125; for word in words: node = root for c in word: node = node.setdefault(c, &#123;&#125;) node[None] = True board = &#123;i + 1j*j: c for i, row in enumerate(board) for j, c in enumerate(row)&#125; found = [] def search(node, z, word): if node.pop(None, None): found.append(word) c = board.get(z) if c in node: board[z] = None for k in range(4): search(node[c], z + 1j**k, word + c) board[z] = c for z in board: search(root, z, &apos;&apos;) return found https://discuss.leetcode.com/topic/16782/python-code-use-trie-and-dfs-380ms Python code use trie and dfs 380ms 123456789101112131415161718192021222324252627282930313233class Solution: # @param &#123;character[][]&#125; board # @param &#123;string[]&#125; words # @return &#123;string[]&#125; def findWords(self, board, words): #make trie trie=&#123;&#125; for w in words: t=trie for c in w: if c not in t: t[c]=&#123;&#125; t=t[c] t[&apos;#&apos;]=&apos;#&apos; self.res=set() self.used=[[False]*len(board[0]) for _ in range(len(board))] for i in range(len(board)): for j in range(len(board[0])): self.find(board,i,j,trie,&apos;&apos;) return list(self.res) def find(self,board,i,j,trie,pre): if &apos;#&apos; in trie: self.res.add(pre) if i&lt;0 or i&gt;=len(board) or j&lt;0 or j&gt;=len(board[0]): return if not self.used[i][j] and board[i][j] in trie: self.used[i][j]=True self.find(board,i+1,j,trie[board[i][j]],pre+board[i][j]) self.find(board,i,j+1,trie[board[i][j]],pre+board[i][j]) self.find(board,i-1,j,trie[board[i][j]],pre+board[i][j]) self.find(board,i,j-1,trie[board[i][j]],pre+board[i][j]) self.used[i][j]=False https://discuss.leetcode.com/topic/22858/python-dfs-solution-directly-use-trie-implemented Python dfs solution (directly use Trie implemented). Here is an implementation based on Implement Trie in LeetCode. TrieNode, Trie, Solution are treated as seperated classes. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class TrieNode(): def __init__(self): self.children = collections.defaultdict(TrieNode) self.isWord = False class Trie(): def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for w in word: node = node.children[w] node.isWord = True def search(self, word): node = self.root for w in word: node = node.children.get(w) if not node: return False return node.isWord class Solution(object): def findWords(self, board, words): res = [] trie = Trie() node = trie.root for w in words: trie.insert(w) for i in xrange(len(board)): for j in xrange(len(board[0])): self.dfs(board, node, i, j, &quot;&quot;, res) return res def dfs(self, board, node, i, j, path, res): if node.isWord: res.append(path) node.isWord = False if i &lt; 0 or i &gt;= len(board) or j &lt; 0 or j &gt;= len(board[0]): return tmp = board[i][j] node = node.children.get(tmp) if not node: return board[i][j] = &quot;#&quot; self.dfs(board, node, i+1, j, path+tmp, res) self.dfs(board, node, i-1, j, path+tmp, res) self.dfs(board, node, i, j-1, path+tmp, res) self.dfs(board, node, i, j+1, path+tmp, res) board[i][j] = tmp 19ms, 90.34%, September 23, 2016 https://discuss.leetcode.com/topic/9826/my-19ms-accepted-c-code 123456789101112131415161718192021222324252627class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; m = board.size(); n = board[0].size(); for(int x=0; x&lt;m; x++) for(int y=0; y&lt;n; y++) if(isFound(board, word.c_str(), x, y)) return true; return false; &#125; private: int m; int n; bool isFound(vector&lt;vector&lt;char&gt;&gt;&amp; board, const char* w, int x, int y)&#123; if(x&lt;0||y&lt;0||x&gt;=m||y&gt;=n||board[x][y]==&apos;\0&apos;||*w!=board[x][y]) return false; if(*(w+1)==&apos;\0&apos;) return true; char t = board[x][y]; board[x][y] = &apos;\0&apos;; if(isFound(board, w+1, x-1, y)||isFound(board, w+1, x+1, y)||isFound(board, w+1, x, y-1)||isFound(board, w+1, x, y+1)) return true; board[x][y] = t; return false; &#125;&#125;; 47ms, September 23, 2016 https://discuss.leetcode.com/topic/7907/accepted-very-short-java-solution-no-additional-space 12345678910111213141516171819202122public class Solution &#123; public boolean exist(char[][] board, String word) &#123; char[] w= word.toCharArray(); for(int y=0; y&lt;board.length; y++) for(int x=0; x&lt;board[y].length; x++) if(exist(board, y, x, w, 0)) return true; return false; &#125; private boolean exist(char[][] board, int y, int x, char[] word, int i)&#123; if(i==word.length) return true; if(y&lt;0||x&lt;0||y==board.length||x==board[y].length) return false; if(board[y][x] != word[i]) return false; board[y][x] ^= 256; boolean exist = exist(board, y, x+1, word, i+1) || exist(board, y, x-1, word, i+1) || exist(board, y+1, x, word, i+1) || exist(board, y-1, x, word, i+1); board[y][x] ^= 256; return exist; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[211. Add and Search Word - Data structure design]]></title>
    <url>%2Fp%2F7bf4b9ae%2F</url>
    <content type="text"><![CDATA[21.1% Design a data structure that supports the following two operations: 12void addWord(word)bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. 123456789For example:addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true Note:You may assume that all words are consist of lowercase letters a-z. click to show hint. You should be familiar with how a Trie works. If not, please work on this problem: Implement Trie (Prefix Tree) first. https://discuss.leetcode.com/topic/15581/80ms-clear-c-code-with-detailed-explanations 80ms Clear C++ Code with Detailed Explanations This problem is an application of the Trie data structure. In the following, it is assumed that you have solved Implement Trie (Prefix Tree). Now, let’s first look at the TrieNode class. I define it as follows. 12345678class TrieNode &#123;public: bool isKey; TrieNode* children[26]; TrieNode(): isKey(false) &#123; memset(children, NULL, sizeof(TrieNode*) * 26); &#125;&#125;; The field isKey is to label whether the string comprised of characters starting from root to the current node is a key (word that has been added). In this problem, only lower-case letters a - z need to be considered, so each TrieNode has at most 26 children. I store it in an array of TrieNode*: children[i] corresponds to letter ‘a’ + i. The remaining code defines the constructor of the TrieNode class. Adding a word can be done in the same way as in Implement Trie (Prefix Tree). The basic idea is to create a TrieNode corresponding to each letter in the word. When we are done, label the last node to be a key (set isKey = true). The code is as follows. 123456789void addWord(string word) &#123; TrieNode* run = root; for (char c : word) &#123; if (!(run -&gt; children[c - &apos;a&apos;])) run -&gt; children[c - &apos;a&apos;] = new TrieNode(); run = run -&gt; children[c - &apos;a&apos;]; &#125; run -&gt; isKey = true;&#125; By the way, root is defined as private data of WordDictionary: 12private: TrieNode* root; And the WordDictionary class has a constructor to initialize root: 123WordDictionary() &#123; root = new TrieNode();&#125; Now we are left only with search. Let’s do it. The basic idea is still the same as typical search operations in a Trie. The critical part is how to deal with the dots .. Well, my solution is very naive in this place. Each time when we reach a ., just traverse all the children of the current node and recursively search the remaining substring in word starting from that children. So I define a helper function query for search that takes in a string and a starting node. And the initial call to query is like query(word, root). By the way, I pass a char* instead of string to query and it greatly speeds up the code. So the initial call to query is actually query(word.c_str(), root). Now I put all the codes together below. Hope it to be useful! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class TrieNode &#123;public: bool isKey; TrieNode* children[26]; TrieNode(): isKey(false) &#123; memset(children, NULL, sizeof(TrieNode*) * 26); &#125;&#125;;class WordDictionary &#123;public: WordDictionary() &#123; root = new TrieNode(); &#125; // Adds a word into the data structure. void addWord(string word) &#123; TrieNode* run = root; for (char c : word) &#123; if (!(run -&gt; children[c - &apos;a&apos;])) run -&gt; children[c - &apos;a&apos;] = new TrieNode(); run = run -&gt; children[c - &apos;a&apos;]; &#125; run -&gt; isKey = true; &#125; // Returns if the word is in the data structure. A word could // contain the dot character &apos;.&apos; to represent any one letter. bool search(string word) &#123; return query(word.c_str(), root); &#125;private: TrieNode* root; bool query(const char* word, TrieNode* node) &#123; TrieNode* run = node; for (int i = 0; word[i]; i++) &#123; if (run &amp;&amp; word[i] != &apos;.&apos;) run = run -&gt; children[word[i] - &apos;a&apos;]; else if (run &amp;&amp; word[i] == &apos;.&apos;) &#123; TrieNode* tmp = run; for (int j = 0; j &lt; 26; j++) &#123; run = tmp -&gt; children[j]; if (query(word + i + 1, run)) return true; &#125; &#125; else break; &#125; return run &amp;&amp; run -&gt; isKey; &#125;&#125;;// Your WordDictionary object will be instantiated and called as such:// WordDictionary wordDictionary;// wordDictionary.addWord(&quot;word&quot;);// wordDictionary.search(&quot;pattern&quot;); https://discuss.leetcode.com/topic/18578/c-using-trie-and-dfs-for-search-easy-understand-solution C++ using Trie and DFS for search. easy understand solution 12345678910111213141516171819202122232425262728293031323334struct Trie &#123; vector&lt;Trie *&gt; child; bool isWord; Trie() : isWord(false), child(vector&lt;Trie *&gt;(26, nullptr)) &#123;&#125; &#125;; Trie *root; WordDictionary() : root(new Trie()) &#123;&#125;void addWord(string word) &#123; const int size_w = word.size(); Trie *cur = root; for (int i = 0; i &lt; size_w; i++) &#123; int index = word[i] - &apos;a&apos;; if (!cur-&gt;child[index]) cur-&gt;child[index] = new Trie(); cur = cur-&gt;child[index]; &#125; cur-&gt;isWord = true;&#125;bool search(string word) &#123; return search(word.c_str(), root);&#125;bool search(const char *ch, TrieNode *cur) &#123; if (!cur) return false; if (*ch == &apos;\0&apos;) return cur-&gt;isWord; if (*ch != &apos;.&apos;) &#123; return search(ch+1, cur-&gt;child[*ch - &apos;a&apos;]); &#125; else &#123; for (int i = 0; i &lt;= 25; i++) &#123; if (search(ch+1, cur-&gt;child[i])) return true; &#125; return false; &#125;&#125; https://discuss.leetcode.com/topic/29809/python-168ms-beat-100-solution Python 168ms-beat-100% solution 12345678910111213141516171819202122class WordDictionary(object): def __init__(self): self.word_dict = collections.defaultdict(list) def addWord(self, word): if word: self.word_dict[len(word)].append(word) def search(self, word): if not word: return False if &apos;.&apos; not in word: return word in self.word_dict[len(word)] for v in self.word_dict[len(word)]: # match xx.xx.x with yyyyyyy for i, ch in enumerate(word): if ch != v[i] and ch != &apos;.&apos;: break else: return True return False The search function could be done in a more pythonic way, but I see that performance has suffered so I just wrote the raw logic by myself. https://discuss.leetcode.com/topic/14216/tree-solutions-18-20-lines Tree solutions, 18-20 lines 1234567891011121314151617181920class WordDictionary: def __init__(self): self.root = &#123;&#125; def addWord(self, word): node = self.root for char in word: node = node.setdefault(char, &#123;&#125;) node[None] = None def search(self, word): def find(word, node): if not word: return None in node char, word = word[0], word[1:] if char != &apos;.&apos;: return char in node and find(word, node[char]) return any(find(word, kid) for kid in node.values() if kid) return find(word, self.root) An iterative alternative for the search method: 12345678def search(self, word): nodes = [self.root] for char in word: nodes = [kid for node in nodes for key, kid in node.items() if char in (key, &apos;.&apos;) and kid] return any(None in node for node in nodes) And one that’s a bit longer but faster: 1234567def search(self, word): nodes = [self.root] for char in word: nodes = [kid for node in nodes for kid in ([node[char]] if char in node else filter(None, node.values()) if char == &apos;.&apos; else [])] return any(None in node for node in nodes) And a neat version where I append my end-marker to the word to simplify the final check: 123456789101112131415161718class WordDictionary: def __init__(self): self.root = &#123;&#125; def addWord(self, word): node = self.root for char in word: node = node.setdefault(char, &#123;&#125;) node[&apos;$&apos;] = None def search(self, word): nodes = [self.root] for char in word + &apos;$&apos;: nodes = [kid for node in nodes for kid in ([node[char]] if char in node else filter(None, node.values()) if char == &apos;.&apos; else [])] return bool(nodes) https://discuss.leetcode.com/topic/26944/python-solution-recursive-version-dfs Python solution recursive version (DFS) 123456789101112131415161718192021222324252627282930313233class TrieNode(object):def __init__(self): self.word = False self.children = &#123;&#125;class WordDictionary(object):def __init__(self): self.root = TrieNode()def addWord(self, word): node = self.root for c in word: if c not in node.children: node.children[c] = TrieNode() node = node.children[c] node.word = Truedef search(self, word): return self.searchFrom(self.root, word)def searchFrom(self, node, word): for i in xrange(len(word)): c = word[i] if c == &apos;.&apos;: for k in node.children: if self.searchFrom(node.children[k], word[i+1:]): return True return False elif c not in node.children: return False node = node.children[c] return node.word]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
        <tag>design</tag>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[210. Course Schedule II]]></title>
    <url>%2Fp%2Fe6c1d8e3%2F</url>
    <content type="text"><![CDATA[26.5% There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. 123For example:2, [[1,0]] There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] 14, [[1,0],[2,0],[3,1],[3,2]] There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3]. Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites. Hints: This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses. Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort. Topological sort could also be done via BFS. https://discuss.leetcode.com/topic/17276/20-lines-c-bfs-dfs-solutions 20+ lines C++ BFS/DFS Solutions Well, this problem is spiritually similar to to Course Schedule. You only need to store the nodes in the order you visit into a vector during BFS or DFS. Well, for DFS, a final reversal is required. BFS 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph = make_graph(numCourses, prerequisites); vector&lt;int&gt; degrees = compute_indegree(graph); queue&lt;int&gt; zeros; for (int i = 0; i &lt; numCourses; i++) if (!degrees[i]) zeros.push(i); vector&lt;int&gt; toposort; for (int i = 0; i &lt; numCourses; i++) &#123; if (zeros.empty()) return &#123;&#125;; int zero = zeros.front(); zeros.pop(); toposort.push_back(zero); for (int neigh : graph[zero]) &#123; if (!--degrees[neigh]) zeros.push(neigh); &#125; &#125; return toposort; &#125;private: vector&lt;unordered_set&lt;int&gt;&gt; make_graph(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph(numCourses); for (auto pre : prerequisites) graph[pre.second].insert(pre.first); return graph; &#125; vector&lt;int&gt; compute_indegree(vector&lt;unordered_set&lt;int&gt;&gt;&amp; graph) &#123; vector&lt;int&gt; degrees(graph.size(), 0); for (auto neighbors : graph) for (int neigh : neighbors) degrees[neigh]++; return degrees; &#125;&#125;; DFS 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph = make_graph(numCourses, prerequisites); vector&lt;int&gt; toposort; vector&lt;bool&gt; onpath(numCourses, false), visited(numCourses, false); for (int i = 0; i &lt; numCourses; i++) if (!visited[i] &amp;&amp; dfs(graph, i, onpath, visited, toposort)) return &#123;&#125;; reverse(toposort.begin(), toposort.end()); return toposort; &#125;private: vector&lt;unordered_set&lt;int&gt;&gt; make_graph(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph(numCourses); for (auto pre : prerequisites) graph[pre.second].insert(pre.first); return graph; &#125; bool dfs(vector&lt;unordered_set&lt;int&gt;&gt;&amp; graph, int node, vector&lt;bool&gt;&amp; onpath, vector&lt;bool&gt;&amp; visited, vector&lt;int&gt;&amp; toposort) &#123; if (visited[node]) return false; onpath[node] = visited[node] = true; for (int neigh : graph[node]) if (onpath[neigh] || dfs(graph, neigh, onpath, visited, toposort)) return true; toposort.push_back(node); return onpath[node] = false; &#125;&#125;; https://discuss.leetcode.com/topic/23925/python-dfs-bfs-solutions-with-comments Python dfs, bfs solutions with comments. BFS 123456789101112131415161718def findOrder1(self, numCourses, prerequisites): dic = &#123;i: set() for i in xrange(numCourses)&#125; neigh = collections.defaultdict(set) for i, j in prerequisites: dic[i].add(j) neigh[j].add(i) # queue stores the courses which have no prerequisites queue = collections.deque([i for i in dic if not dic[i]]) count, res = 0, [] while queue: node = queue.popleft() res.append(node) count += 1 for i in neigh[node]: dic[i].remove(node) if not dic[i]: queue.append(i) return res if count == numCourses else [] DFS 1234567891011121314151617def findOrder(self, numCourses, prerequisites): dic = collections.defaultdict(set) neigh = collections.defaultdict(set) for i, j in prerequisites: dic[i].add(j) neigh[j].add(i) stack = [i for i in xrange(numCourses) if not dic[i]] res = [] while stack: node = stack.pop() res.append(node) for i in neigh[node]: dic[i].remove(node) if not dic[i]: stack.append(i) dic.pop(node) return res if not dic else [] https://discuss.leetcode.com/topic/13982/c-using-3-colored-approach [C++] Using 3 colored approach Here, i have used 3 colored approach. Here w -&gt; represent white means vertex yet not visited.g -&gt; gray , it means it is under DFS recursion and we again found the same node. This means cycle exists and return false. b -&gt; black node when DFS is done visiting the node. This method checks cycle as well as keeps storing answer in stack in case cycle doesn’t exists. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Graph &#123; public: int v; list &lt;int&gt; *adj; Graph(int v) &#123; this-&gt;v=v; adj = new list&lt;int&gt; [v]; &#125; void addedges(int src , int dest) &#123; adj[dest].push_back(src); &#125; &#125;;class Solution &#123;public: stack &lt;int&gt; st; vector&lt;int&gt; findOrder(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; Graph g(numCourses); for (int i=0 ; i &lt; prerequisites.size() ; i++) g.addedges(prerequisites[i].first , prerequisites[i].second); vector &lt;int&gt; ans; if(!courseScheduleCheck(g)) return ans; while(!st.empty()) &#123; ans.push_back(st.top()); st.pop(); &#125; return ans; &#125; bool courseScheduleCheck(Graph g) &#123; int v = g.v; vector &lt;char&gt; visit(v,&apos;w&apos;); for(int i=0 ; i&lt;v;i++) &#123; if(visit[i]== &apos;w&apos;) if(iscycle(g,i,visit)) return false; &#125; return true; &#125; bool iscycle(Graph g , int i, vector &lt;char&gt; &amp; visit) &#123; list &lt;int&gt; ::iterator it; for(it = g.adj[i].begin() ; it!=g.adj[i].end() ; it++) &#123; if(visit[*it]== &apos;g&apos;) return true; else &#123; if(visit[*it] != &apos;b&apos;) &#123; visit[*it] = &apos;g&apos;; if(iscycle(g,*it,visit)) return true; &#125; &#125; &#125; visit[i]=&apos;b&apos;; st.push(i); return false; &#125; &#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>depth first search</tag>
        <tag>breadth first search</tag>
        <tag>graph</tag>
        <tag>topological sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[209. Minimum Size Subarray Sum]]></title>
    <url>%2Fp%2Fcf54181a%2F</url>
    <content type="text"><![CDATA[29.4% https://leetcode.com/problems/minimum-size-subarray-sum/ Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. 12For example, given the array [2,3,1,2,4,3] and s = 7,the subarray [4,3] has the minimal length under the problem constraint. More practice: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). 方法一： 我的代码实现： 1234567891011121314151617class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; int res = INT_MAX; int i=-1, j=0, sum=0; while(j&lt;n)&#123; sum += nums[j++]; while(sum&gt;=s)&#123; res = min(res, j-i-1); sum -= nums[++i]; &#125; &#125; return res==INT_MAX? 0 : res; &#125;&#125;; 8ms, 14.16%, June.24th, 2016 https://leetcode.com/discuss/42143/4ms-o-n-8ms-o-nlogn-c 1234567891011121314class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), start = 0, sum = 0, minlen = INT_MAX; for (int i = 0; i &lt; n; i++) &#123; sum += nums[i]; while (sum &gt;= s) &#123; minlen = min(minlen, i - start + 1); sum -= nums[start++]; &#125; &#125; return minlen == INT_MAX ? 0 : minlen; &#125;&#125;; 学习区： https://discuss.leetcode.com/topic/37844/o-n-template-for-minimum-size-subarray-sum-minimum-window-substring-longest-substring-without-repeating-characters O(N) template for Minimum Size Subarray Sum &amp; Minimum Window Substring &amp; Longest Substring Without Repeating Characters First , I will show you the solution of this problem, 123456789101112131415161718class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int start=0, end=0; int minLen=INT_MAX, sum=0; while(end&lt;nums.size())&#123; if(sum&lt;s) sum+=nums[end]; end++; while(sum&gt;=s)&#123; if(end-start&lt;minLen) minLen=end-start; sum-=nums[start]; start++; &#125; &#125; return minLen==INT_MAX ? 0 : minLen; &#125;&#125;; Next, let me show you the solution to the problem “Minimum Window Substring” 12345678910111213141516171819202122232425class Solution &#123;public: string minWindow(string s, string t) &#123; vector&lt;int&gt; v(128, 0); for(auto c:t) v[c]++; int start=0, end=0, counter=t.size(); int m_start=0, m_len=INT_MAX; while(end&lt;s.size())&#123; if(v[s[end]]&gt;0) counter--; v[s[end]]--; end++; /** loop from start to check whether we can find more short string **/ while(counter==0)&#123; if(m_len&gt;end-start)&#123; m_start=start; m_len=end-start; &#125; v[s[start]]++; if(v[s[start]]&gt;0) counter++; start++; &#125; &#125; return m_len==INT_MAX ? &quot;&quot; : s.substr(m_start, m_len); &#125;&#125;; The solution for the problem “Longest Substring Without Repeating Characters” can also be solved in the same pattern . Here is the solution for “Longest Substring Without Repeating Characters” 123456789101112131415161718class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; v(128, 0); int start=0, end=0; int m_len=INT_MIN; while(end&lt;s.size())&#123; if(v[s[end]]==0) m_len=max(m_len, end-start+1); v[s[end]]++; end++; while(v[s[end]]&gt;0)&#123; v[s[start]]--; start++; &#125; &#125; return m_len==INT_MIN ? 0 : m_len; &#125;&#125;; As you can see, they all follow the same pattern ! This post deserves your up vote! 1ms, 16.03%, June.24th, 2016 https://leetcode.com/discuss/45449/accepted-clean-java-o-n-solution-two-pointers 12345678910111213141516171819public class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; if(nums == null || nums.length == 0) return 0; int i = 0, j = 0, sum = 0, min = Integer.MAX_VALUE; while(j &lt; nums.length)&#123; sum += nums[j++]; while(sum &gt;= s)&#123; min = Math.min(min, j - i); sum -= nums[i++]; &#125; &#125; return min == Integer.MAX_VALUE ? 0 : min; &#125;&#125; 47ms, 96.87%, June.24th, 2016 https://leetcode.com/discuss/36384/python-o-n-and-o-n-log-n-solution 12345678910111213141516class Solution(object): def minSubArrayLen(self, s, nums): &quot;&quot;&quot; :type s: int :type nums: List[int] :rtype: int &quot;&quot;&quot; total = left = 0 result = len(nums) + 1 for right, n in enumerate(nums): total += n while total &gt;= s: result = min(result, right - left + 1) total -= nums[left] left += 1 return result if result &lt;= len(nums) else 0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>binary search</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[208. Implement Trie (Prefix Tree)]]></title>
    <url>%2Fp%2Fb78a563d%2F</url>
    <content type="text"><![CDATA[26.6% https://leetcode.com/problems/implement-trie-prefix-tree/#/description Implement a trie with insert, search, and startsWith methods. Note: You may assume that all inputs are consist of lowercase letters a-z. http://blog.csdn.net/lisonglisonglisong/article/details/45584721 关于前缀树，可以参考以上文章。 一、什么是Trie树 Trie树，又叫字典树、前缀树（Prefix Tree）、单词查找树 或 键树，是一种多叉树结构。如下图： 上图是一棵Trie树，表示了关键字集合{“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”} 。从上图可以归纳出Trie树的基本性质： 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。 每个节点的所有子节点包含的字符互不相同。 通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。 可以看出，Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做前缀树（Prefix Tree）。 二、Trie树的优缺点 Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。 优点 插入和查询的效率很高，都为O(m)，其中 m 是待插入/查询的字符串的长度。 -关于查询，会有人说 hash 表时间复杂度是O(1)不是更快？但是，哈希搜索的效率通常取决于 hash 函数的好坏，若一个坏的 hash 函数导致很多的冲突，效率并不一定比Trie树高。 Trie树中不同的关键字不会产生冲突。 Trie树只有在允许一个关键字关联多个值的情况下才有类似hash碰撞发生。 Trie树不用求 hash 值，对短字符串有更快的速度。通常，求hash值也是需要遍历字符串的。 Trie树可以对关键字按字典序排序。 缺点 当 hash 函数很好时，Trie树的查找效率会低于哈希搜索。 空间消耗比较大。 三、Trie树的应用 字符串检索 检索/查询功能是Trie树最原始的功能。思路就是从根节点开始一个一个字符进行比较： 如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）。 12345struct trie_node&#123; bool isKey; // 标记该节点是否代表一个关键字 trie_node *children[26]; // 各个子节点 &#125;; 词频统计 Trie树常被搜索引擎系统用于文本词频统计 。 12345struct trie_node&#123; int count; // 记录该节点代表的单词的个数 trie_node *children[26]; // 各个子节点 &#125;; 思路：为了实现词频统计，我们修改了节点结构，用一个整型变量count来计数。对每一个关键字执行插入操作，若已存在，计数加1，若不存在，插入后count置1。 注意：第一、第二种应用也都可以用 hash table 来做。 字符串排序 Trie树可以对大量字符串按字典序进行排序，思路也很简单：遍历一次所有关键字，将它们全部插入trie树，树的每个结点的所有儿子很显然地按照字母表排序，然后先序遍历输出Trie树中所有关键字即可。 前缀匹配 例如：找出一个字符串集合中所有以ab开头的字符串。我们只需要用所有字符串构造一个trie树，然后输出以a-&gt;b-&gt;开头的路径上的关键字即可。 trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。 作为其他数据结构和算法的辅助结构 如后缀树，AC自动机等。 https://discuss.leetcode.com/topic/13463/maybe-the-code-is-not-too-much-by-using-next-26-c Maybe the code is not too much by using “next[26]”, C++ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class TrieNode&#123;public: TrieNode *next[26]; bool is_word; // Initialize your data structure here. TrieNode(bool b = false) &#123; memset(next, 0, sizeof(next)); is_word = b; &#125;&#125;;class Trie&#123; TrieNode *root;public: Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. void insert(string s) &#123; TrieNode *p = root; for(int i = 0; i &lt; s.size(); ++ i) &#123; if(p -&gt; next[s[i] - &apos;a&apos;] == NULL) p -&gt; next[s[i] - &apos;a&apos;] = new TrieNode(); p = p -&gt; next[s[i] - &apos;a&apos;]; &#125; p -&gt; is_word = true; &#125; // Returns if the word is in the trie. bool search(string key) &#123; TrieNode *p = find(key); return p != NULL &amp;&amp; p -&gt; is_word; &#125; // Returns if there is any word in the trie // that starts with the given prefix. bool startsWith(string prefix) &#123; return find(prefix) != NULL; &#125;private: TrieNode* find(string key) &#123; TrieNode *p = root; for(int i = 0; i &lt; key.size() &amp;&amp; p != NULL; ++ i) p = p -&gt; next[key[i] - &apos;a&apos;]; return p; &#125;&#125;; https://discuss.leetcode.com/topic/13623/c-my-solution-easy-to-understand C++, My solution, easy to understand:) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** ** author: cxq ** weibo: http://weibo.com/chenxq1992 **/ class TrieNode &#123;public: char content; // the character included bool isend; // if the node is the end of a word int shared; // the number of the node shared ,convenient to implement delete(string key), not necessary in this problem vector&lt;TrieNode*&gt; children; // the children of the node // Initialize your data structure here. TrieNode():content(&apos; &apos;), isend(false), shared(0) &#123;&#125; TrieNode(char ch):content(ch), isend(false), shared(0) &#123;&#125; TrieNode* subNode(char ch) &#123; if (!children.empty()) &#123; for (auto child : children) &#123; if (child-&gt;content == ch) return child; &#125; &#125; return nullptr; &#125; ~TrieNode() &#123; for (auto child : children) delete child; &#125;&#125;;class Trie &#123;public: Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. void insert(string s) &#123; if (search(s)) return; TrieNode* curr = root; for (auto ch : s) &#123; TrieNode* child = curr-&gt;subNode(ch); if (child != nullptr) &#123; curr = child; &#125; else &#123; TrieNode *newNode = new TrieNode(ch); curr-&gt;children.push_back(newNode); curr = newNode; &#125; ++curr-&gt;shared; &#125; curr-&gt;isend = true; &#125; // Returns if the word is in the trie. bool search(string key) &#123; TrieNode* curr = root; for (auto ch : key) &#123; curr = curr-&gt;subNode(ch); if (curr == nullptr) return false; &#125; return curr-&gt;isend == true; &#125; // Returns if there is any word in the trie // that starts with the given prefix. bool startsWith(string prefix) &#123; TrieNode* curr = root; for (auto ch : prefix) &#123; curr = curr-&gt;subNode(ch); if (curr == nullptr) return false; &#125; return true; &#125; ~Trie() &#123; delete root; &#125;private: TrieNode* root;&#125;; https://discuss.leetcode.com/topic/14202/ac-python-solution AC Python Solution 1234567891011121314151617181920212223242526272829303132class TrieNode:# Initialize your data structure here.def __init__(self): self.children = collections.defaultdict(TrieNode) self.is_word = Falseclass Trie:def __init__(self): self.root = TrieNode()def insert(self, word): current = self.root for letter in word: current = current.children[letter] current.is_word = Truedef search(self, word): current = self.root for letter in word: current = current.children.get(letter) if current is None: return False return current.is_worddef startsWith(self, prefix): current = self.root for letter in prefix: current = current.children.get(letter) if current is None: return False return True https://discuss.leetcode.com/topic/20375/my-python-solution My python solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class TrieNode: # Initialize your data structure here. def __init__(self): self.word=False self.children=&#123;&#125; class Trie: def __init__(self): self.root = TrieNode() # @param &#123;string&#125; word # @return &#123;void&#125; # Inserts a word into the trie. def insert(self, word): node=self.root for i in word: if i not in node.children: node.children[i]=TrieNode() node=node.children[i] node.word=True # @param &#123;string&#125; word # @return &#123;boolean&#125; # Returns if the word is in the trie. def search(self, word): node=self.root for i in word: if i not in node.children: return False node=node.children[i] return node.word # @param &#123;string&#125; prefix # @return &#123;boolean&#125; # Returns if there is any word in the trie # that starts with the given prefix. def startsWith(self, prefix): node=self.root for i in prefix: if i not in node.children: return False node=node.children[i] return True # Your Trie object will be instantiated and called as such: # trie = Trie() # trie.insert(&quot;somestring&quot;) # trie.search(&quot;key&quot;) https://discuss.leetcode.com/topic/41687/compact-python-solution Compact Python solution 12345678910111213141516171819202122232425class TrieNode(object): def __init__(self): self.is_word = False self.children = collections.defaultdict(TrieNode)class Trie(object): def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for c in word: node = node.children[c] node.is_word = True def search(self, word, is_word=True): node = self.root for c in word: if c not in node.children: return False node = node.children[c] return node.is_word if is_word else True def startsWith(self, prefix): return self.search(prefix, False)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>design</tag>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[207. Course Schedule]]></title>
    <url>%2Fp%2F9a622bea%2F</url>
    <content type="text"><![CDATA[31.0% There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? 123For example:2, [[1,0]] There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. 12, [[1,0],[0,1]] There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites. Hints: This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses. Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort. Topological sort could also be done via BFS. https://discuss.leetcode.com/topic/17273/18-22-lines-c-bfs-dfs-solutions 18-22 lines C++ BFS/DFS Solutions As suggested by the hints, this problem is equivalent to detecting a cycle in the graph represented by prerequisites. Both BFS and DFS can be used to solve it using the idea of topological sort. If you find yourself unfamiliar with these concepts, you may refer to their wikipedia pages. Specifically, you may only need to refer to the link in the third hint to solve this problem. Since pair&lt;int, int&gt; is inconvenient for the implementation of graph algorithms, we first transform it to a graph. If course u is a prerequisite of course v, we will add a directed edge from node u to node v. BFS BFS uses the indegrees of each node. We will first try to find a node with 0 indegree. If we fail to do so, there must be a cycle in the graph and we return false. Otherwise we have found one. We set its indegree to be -1 to prevent from visiting it again and reduce the indegrees of all its neighbors by 1. This process will be repeated for n (number of nodes) times. If we have not returned false, we will return true. 12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph = make_graph(numCourses, prerequisites); vector&lt;int&gt; degrees = compute_indegree(graph); for (int i = 0; i &lt; numCourses; i++) &#123; int j = 0; for (; j &lt; numCourses; j++) if (!degrees[j]) break; if (j == numCourses) return false; degrees[j] = -1; for (int neigh : graph[j]) degrees[neigh]--; &#125; return true; &#125;private: vector&lt;unordered_set&lt;int&gt;&gt; make_graph(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph(numCourses); for (auto pre : prerequisites) graph[pre.second].insert(pre.first); return graph; &#125; vector&lt;int&gt; compute_indegree(vector&lt;unordered_set&lt;int&gt;&gt;&amp; graph) &#123; vector&lt;int&gt; degrees(graph.size(), 0); for (auto neighbors : graph) for (int neigh : neighbors) degrees[neigh]++; return degrees; &#125;&#125;; DFS For DFS, it will first visit a node, then one neighbor of it, then one neighbor of this neighbor… and so on. If it meets a node which was visited in the current process of DFS visit, a cycle is detected and we will return false. Otherwise it will start from another unvisited node and repeat this process till all the nodes have been visited. Note that you should make two records: one is to record all the visited nodes and the other is to record the visited nodes in the current DFS visit. The code is as follows. We use a vector visited to record all the visited nodes and another vector onpath to record the visited nodes of the current DFS visit. Once the current visit is finished, we reset the onpath value of the starting node to false. 1234567891011121314151617181920212223242526class Solution &#123;public: bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph = make_graph(numCourses, prerequisites); vector&lt;bool&gt; onpath(numCourses, false), visited(numCourses, false); for (int i = 0; i &lt; numCourses; i++) if (!visited[i] &amp;&amp; dfs_cycle(graph, i, onpath, visited)) return false; return true; &#125;private: vector&lt;unordered_set&lt;int&gt;&gt; make_graph(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; vector&lt;unordered_set&lt;int&gt;&gt; graph(numCourses); for (auto pre : prerequisites) graph[pre.second].insert(pre.first); return graph; &#125; bool dfs_cycle(vector&lt;unordered_set&lt;int&gt;&gt;&amp; graph, int node, vector&lt;bool&gt;&amp; onpath, vector&lt;bool&gt;&amp; visited) &#123; if (visited[node]) return false; onpath[node] = visited[node] = true; for (int neigh : graph[node]) if (onpath[neigh] || dfs_cycle(graph, neigh, onpath, visited)) return true; return onpath[node] = false; &#125;&#125;; https://discuss.leetcode.com/topic/13441/bfs-topological-sort-and-dfs-finding-cycle-by-c BFS(Topological Sort) and DFS(Finding cycle) by C++ BFS(Topological Sort) 12345678910111213141516171819202122232425bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites)&#123; vector&lt;unordered_set&lt;int&gt;&gt; matrix(numCourses); // save this directed graph for(int i = 0; i &lt; prerequisites.size(); ++ i) matrix[prerequisites[i][1]].insert(prerequisites[i][0]); vector&lt;int&gt; d(numCourses, 0); // in-degree for(int i = 0; i &lt; numCourses; ++ i) for(auto it = matrix[i].begin(); it != matrix[i].end(); ++ it) ++ d[*it]; for(int j = 0, i; j &lt; numCourses; ++ j) &#123; for(i = 0; i &lt; numCourses &amp;&amp; d[i] != 0; ++ i); // find a node whose in-degree is 0 if(i == numCourses) // if not find return false; d[i] = -1; for(auto it = matrix[i].begin(); it != matrix[i].end(); ++ it) -- d[*it]; &#125; return true;&#125; DFS(Finding cycle) 123456789101112131415161718192021222324bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites)&#123; vector&lt;unordered_set&lt;int&gt;&gt; matrix(numCourses); // save this directed graph for(int i = 0; i &lt; prerequisites.size(); ++ i) matrix[prerequisites[i][1]].insert(prerequisites[i][0]); unordered_set&lt;int&gt; visited; vector&lt;bool&gt; flag(numCourses, false); for(int i = 0; i &lt; numCourses; ++ i) if(!flag[i]) if(DFS(matrix, visited, i, flag)) return false; return true;&#125;bool DFS(vector&lt;unordered_set&lt;int&gt;&gt; &amp;matrix, unordered_set&lt;int&gt; &amp;visited, int b, vector&lt;bool&gt; &amp;flag)&#123; flag[b] = true; visited.insert(b); for(auto it = matrix[b].begin(); it != matrix[b].end(); ++ it) if(visited.find(*it) != visited.end() || DFS(matrix, visited, *it, flag)) return true; visited.erase(b); return false;&#125; https://discuss.leetcode.com/topic/18734/c-clean-code-for-dfs-solution-with-simple-comments C++ clean code for DFS solution with simple comments 12345678910111213141516171819202122bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prer) &#123; vector&lt;vector&lt;int&gt;&gt; gragh(numCourses); vector&lt;int&gt; visited(numCourses, 0); // White at initialization for (int i = 0; i &lt; prer.size(); i++) &#123; gragh[prer[i].second].push_back(prer[i].first); &#125; bool cycle = false; for (int i = 0; i &lt; numCourses; i++) &#123; if (cycle) return false; if (visited[i] == 0) dfs_top(i, gragh, visited, cycle); &#125; return !cycle;&#125;void dfs_top(int node, vector&lt;vector&lt;int&gt;&gt; &amp;gragh, vector&lt;int&gt; &amp;visited, bool &amp;cycle) &#123; if (visited[node] == 1) &#123;cycle = true; return;&#125; // cycle occurs, break the dfs chain and all return visited[node] = 1; //Gray, searching for (int i = 0; i &lt; gragh[node].size(); i++) &#123; dfs_top(gragh[node][i], gragh, visited, cycle); if (cycle) return; // do some pruning here &#125; visited[node] = 2; //Black Once finished.&#125; https://discuss.leetcode.com/topic/13412/python-20-lines-dfs-solution-sharing-with-explanation Python 20 lines DFS solution sharing with explanation 1234567891011121314151617181920def canFinish(self, numCourses, prerequisites): graph = [[] for _ in xrange(numCourses)] visit = [0 for _ in xrange(numCourses)] for x, y in prerequisites: graph[x].append(y) def dfs(i): if visit[i] == -1: return False if visit[i] == 1: return True visit[i] = -1 for j in graph[i]: if not dfs(j): return False visit[i] = 1 return True for i in xrange(numCourses): if not dfs(i): return False return True if node v has not been visited, then mark it as 0. if node v is being visited, then mark it as -1. If we find a vertex marked as -1 in DFS, then their is a ring. if node v has been visited, then mark it as 1. If a vertex was marked as 1, then no ring contains v or its successors. References: daoluan.net https://discuss.leetcode.com/topic/25964/ac-python-topological-sort-52-ms-solution-o-v-e-time-and-o-v-e-space AC Python topological sort 52 ms solution, O(V + E) time and O(V + E) space 1234567891011121314151617181920212223242526def canFinish(self, n, pres): from collections import deque ind = [[] for _ in xrange(n)] # indegree oud = [0] * n # outdegree for p in pres: oud[p[0]] += 1 ind[p[1]].append(p[0]) dq = deque() for i in xrange(n): if oud[i] == 0: dq.append(i) k = 0 while dq: x = dq.popleft() k += 1 for i in ind[x]: oud[i] -= 1 if oud[i] == 0: dq.append(i) return k == n# 34 / 34 test cases passed.# Status: Accepted# Runtime: 52 ms# 99.68% The topological sort is natural for this problem. We always take the courses with no unstudied prereqs and so on until no more courses we can take. The oud[i] is the number of prereqs for course i and indegree keep a list of courses require course i.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>depth first search</tag>
        <tag>breadth first search</tag>
        <tag>graph</tag>
        <tag>topological sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[206. Reverse Linked List]]></title>
    <url>%2Fp%2Fc9c8233c%2F</url>
    <content type="text"><![CDATA[44.1% https://leetcode.com/problems/reverse-linked-list Reverse a singly linked list. click to show more hints. Hint: A linked list can be reversed either iteratively or recursively. Could you implement both? Subscribe to see which companies asked this question 剑指offer 16 可以递归 可以迭代 方法一： 使用迭代的方法，保存三个指针。新建一个new_head， 12345678910111213141516class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* new_head = new ListNode(0); new_head -&gt; next = head; ListNode* pre = new_head; ListNode* cur = head; while (cur &amp;&amp; cur -&gt; next) &#123; ListNode* temp = pre -&gt; next; pre -&gt; next = cur -&gt; next; cur -&gt; next = cur -&gt; next -&gt; next; pre -&gt; next -&gt; next = temp; &#125; return new_head -&gt; next; &#125;&#125;; 方法二： 迭代 我的代码实现: Dec 7th, 2017 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* new_head = nullptr; while(head!=nullptr)&#123; ListNode* nex = head-&gt;next; head-&gt;next = new_head; new_head = head; head = nex; &#125; return new_head; &#125;&#125;; 保存两个指针，一个遍历的当前位置的指针，一个逆转的链表的头指针。在中间遍历的时候需要一个临时指针。 12345678910111213class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* pre = NULL; while (head) &#123; ListNode* next = head -&gt; next; head -&gt; next = pre; pre = head; head = next; &#125; return pre; &#125;&#125;; 我的代码实现 一个保存未来root的指针， 一个现在遍历到的节点的指针.遍历时，保存下一个节点。 1234567891011121314class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head==NULL || head-&gt;next==NULL) return head; ListNode* pre=NULL; while(head)&#123; ListNode* nex = head-&gt;next; head-&gt;next = pre; pre = head; head = nex; &#125; return pre; &#125;&#125;; 方法三： 递归 我的代码实现： Dec 7th, 2017 12345678910111213141516171819/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head==nullptr || head-&gt;next==nullptr) return head; ListNode* new_head = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return new_head; &#125;&#125;; 使用递归的方法，其中head-&gt;next-&gt;next是将head-&gt;next就是head的下一位，是反转后的最后一位的指针指向head，然后，head的下一位设置为NULL，就完成了。 12345678910class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (!head || !(head -&gt; next)) return head; ListNode* node = reverseList(head -&gt; next); head -&gt; next -&gt; next = head; head -&gt; next = NULL; return node; &#125;&#125;; 我的代码实现： 递归版 12345678910class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head==NULL || head-&gt;next==NULL) return head; ListNode* pre = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return pre; &#125;&#125;; 我的代码实现； 123456789101112131415161718/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* node = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return node; &#125;&#125;; 前两种是迭代，后一种是递归。 cpp https://discuss.leetcode.com/topic/17916/8ms-c-iterative-and-recursive-solutions-with-explanations 8ms C++ Iterative and Recursive Solutions with Explanations xWell, since the head pointer may also be modified, we create a new_head that points to it to facilitate the reverse process. For the example list 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 in the problem statement, it will become 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 (we init new_head -&gt; val to be 0). Then we set a pointer pre to new_head and another cur to head. Then we keep inserting cur -&gt; next after pre until cur becomes the last node. The code is follows. 12345678910111213141516class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* new_head = new ListNode(0); new_head -&gt; next = head; ListNode* pre = new_head; ListNode* cur = head; while (cur &amp;&amp; cur -&gt; next) &#123; ListNode* temp = pre -&gt; next; pre -&gt; next = cur -&gt; next; cur -&gt; next = cur -&gt; next -&gt; next; pre -&gt; next -&gt; next = temp; &#125; return new_head -&gt; next; &#125;&#125;; This link provides a more concise solution without using the new_head. The idea is to reverse one node at a time for the beginning of the list. The rewritten code is as follows. 12345678910111213class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* pre = NULL; while (head) &#123; ListNode* next = head -&gt; next; head -&gt; next = pre; pre = head; head = next; &#125; return pre; &#125;&#125;; Well, both of the above solutions are iterative. The hint has also suggested us to use recursion. In fact, the above link has a nice recursive solution, whose rewritten code is as follows. 12345678910class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if (!head || !(head -&gt; next)) return head; ListNode* node = reverseList(head -&gt; next); head -&gt; next -&gt; next = head; head -&gt; next = NULL; return node; &#125;&#125;; The basic idea of this recursive solution is to reverse all the following nodes after head. Then we need to set head to be the final node in the reversed list. We simply set its next node in the original list (head -&gt; next) to point to it and sets its next to be NULL. https://discuss.leetcode.com/topic/16162/c-solution-very-easy C++ solution .. very easy.. 12345678910111213class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode *temp = NULL , *nextNode = NULL; while(head)&#123; nextNode = head-&gt;next; head-&gt;next = temp; temp = head; head = nextNode; &#125; return temp; &#125;&#125;; my code: 1234567891011121314class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* new_head = new ListNode(0); new_head-&gt;next = NULL; while(head)&#123; ListNode* next = head-&gt;next; head-&gt;next = new_head-&gt;next; new_head-&gt;next = head; head = next; &#125; return new_head-&gt;next; &#125;&#125;; python https://discuss.leetcode.com/topic/14043/python-iterative-and-recursive-solution Python Iterative and Recursive Solution 1234567891011class Solution:# @param &#123;ListNode&#125; head# @return &#123;ListNode&#125;def reverseList(self, head): prev = None while head: curr = head head = head.next curr.next = prev prev = curr return prev Recursion 123456789101112class Solution:# @param &#123;ListNode&#125; head# @return &#123;ListNode&#125;def reverseList(self, head): return self._reverse(head)def _reverse(self, node, prev=None): if not node: return prev n = node.next node.next = prev return self._reverse(n, node) 12345678910111213141516171819# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ pre = None while head: next = head.next head.next = pre pre = head head = next return pre]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[204. Count Primes]]></title>
    <url>%2Fp%2F99ef7c25%2F</url>
    <content type="text"><![CDATA[26.2% https://leetcode.com/problems/count-primes/?tab=Description Description: Count the number of prime numbers less than a non-negative number, n. Hint: Let’s start with a isPrime function. To determine if a number is prime, we need to check if it is not divisible by any number less than n. The runtime complexity of isPrime function would be O(n) and hence counting the total prime numbers up to n would be O(n2). Could we do better? As we know the number must not be divisible by any number &gt; n / 2, we can immediately cut the total iterations half by dividing only up to n / 2. Could we still do better? Let’s write down all of 12’s factors: 12342 × 6 = 123 × 4 = 124 × 3 = 126 × 2 = 12 As you can see, calculations of 4 × 3 and 6 × 2 are not necessary. Therefore, we only need to consider factors up to √n because, if n is divisible by some number p, then n = p × q and since p ≤ q, we could derive that p ≤ √n. Our total runtime has now improved to O(n1.5), which is slightly better. Is there a faster approach? The Sieve of Eratosthenes is one of the most efficient ways to find all prime numbers up to n. But don’t let that name scare you, I promise that the concept is surprisingly simple. Sieve of Eratosthenes: algorithm steps for primes below 121. “Sieve of Eratosthenes Animation“ by SKopp is licensed under CC BY 2.0. We start off with a table of n numbers. Let’s look at the first number, 2. We know all multiples of 2 must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, all multiples of 3 such as 3 × 2 = 6, 3 × 3 = 9, … must not be primes, so we mark them off as well. Now we look at the next number, 4, which was already marked off. What does this tell you? Should you mark off all multiples of 4 as well? 4 is not a prime because it is divisible by 2, which means all multiples of 4 must also be divisible by 2 and were already marked off. So we can skip 4 immediately and go to the next number, 5. Now, all multiples of 5 such as 5 × 2 = 10, 5 × 3 = 15, 5 × 4 = 20, 5 × 5 = 25, … can be marked off. There is a slight optimization here, we do not need to start from 5 × 2 = 10. Where should we start marking off? In fact, we can mark off multiples of 5 starting at 5 × 5 = 25, because 5 × 2 = 10 was already marked off by multiple of 2, similarly 5 × 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is p, we can always mark off multiples of p starting at p2, then in increments of p: p2 + p, p2 + 2p, … Now what should be the terminating loop condition? It is easy to say that the terminating loop condition is p &lt; n, which is certainly correct but not efficient. Do you still remember Hint #3? Yes, the terminating loop condition can be p &lt; √n, as all non-primes ≥ √n must have already been marked off. When the loop terminates, all the numbers in the table that are non-marked are prime. The Sieve of Eratosthenes uses an extra O(n) memory and its runtime complexity is O(n log log n). For the more mathematically inclined readers, you can read more about its algorithm complexity on Wikipedia. 对于非质数，可以分解为多个质数的乘积，所以保存前面的质数，遇到下一个，只要检查是否能被前面保存的质数整除就可以判断是否为质数了。 方法一： 1234567891011121314151617public int countPrimes(int n) &#123; int count = 0; for (int i = 1; i &lt; n; i++) &#123; if (isPrime(i)) count++; &#125; return count;&#125;private boolean isPrime(int num) &#123; if (num &lt;= 1) return false; // Loop&apos;s ending condition is i * i &lt;= num instead of i &lt;= sqrt(num) // to avoid repeatedly calling an expensive function sqrt(). for (int i = 2; i * i &lt;= num; i++) &#123; if (num % i == 0) return false; &#125; return true;&#125; 方法二： 12345678910111213141516171819public int countPrimes(int n) &#123; boolean[] isPrime = new boolean[n]; for (int i = 2; i &lt; n; i++) &#123; isPrime[i] = true; &#125; // Loop&apos;s ending condition is i * i &lt; n instead of i &lt; sqrt(n) // to avoid repeatedly calling an expensive function sqrt(). for (int i = 2; i * i &lt; n; i++) &#123; if (!isPrime[i]) continue; for (int j = i * i; j &lt; n; j += i) &#123; // 此处方法不错，j = i*i; j&lt;n; j += i isPrime[j] = false; &#125; &#125; int count = 0; for (int i = 2; i &lt; n; i++) &#123; if (isPrime[i]) count++; &#125; return count;&#125; 我的代码实现： 123456789101112131415161718class Solution &#123;public: int countPrimes(int n) &#123; if(n&lt;=1) return 0; vector&lt;int&gt; v(n+1, 1); for(int i=2; i*i&lt;=n; i++)&#123; if(v[i]==0) continue; for(int j=i*i; j&lt;n; j+=i)&#123; v[j] = 0; &#125; &#125; int res = 0; for(int i=2; i&lt;n; i++) res += v[i]==1; return res; &#125;&#125;; 另一种实现: 学习一个是使用bool类型， vector 一个是count的使用return count(prime.begin(), prime.end(), true) https://discuss.leetcode.com/topic/17034/short-c-sieve-of-eratosthenes-solution Short C++ Sieve of Eratosthenes solution 123456789101112131415class Solution &#123;public: int countPrimes(int n) &#123; vector&lt;bool&gt; prime(n, true); prime[0] = false, prime[1] = false; for (int i = 0; i &lt; sqrt(n); ++i) &#123; if (prime[i]) &#123; for (int j = i*i; j &lt; n; j += i) &#123; prime[j] = false; &#125; &#125; &#125; return count(prime.begin(), prime.end(), true); &#125;&#125;; 方法三： https://discuss.leetcode.com/topic/12910/my-easy-one-round-c-code My easy one round c++ code 特别注意 if(i&gt;upper) continue;这句话，不加这句话会超时。对于大于sqrt（n）的不必再求。 1234567891011121314151617int countPrimes(int n) &#123; if (n&lt;=2) return 0; vector&lt;bool&gt; passed(n, false); int sum = 1; int upper = sqrt(n); for (int i=3; i&lt;n; i+=2) &#123; if (!passed[i]) &#123; sum++; //avoid overflow if (i&gt;upper) continue; for (int j=i*i; j&lt;n; j+=i) &#123; passed[j] = true; &#125; &#125; &#125; return sum;&#125; https://discuss.leetcode.com/topic/20525/simple-16-ms-10-line-c-solution-1-use-new-bool-array-2-only-traverse-odd-numbers-3-count-and-sieve-at-the-same-time Simple 16 ms,10 line C++ solution. 1.use new bool array 2. only traverse odd numbers 3.count and sieve at the same time use new bool array. 2. only traverse odd numbers. 3. count and sieve at the same time. trick 1, thanks to 27ms,16 lines, C++ solution trick 2, for the inspiration, thanks to my C solutions in 13ms,use Sieve of Eratosthenes and only test 6n-1 and 6n+1 trick 3, thanks to my C solutions in 44ms, time nearly O(n), and space nearly O(n) and my easy one round c++ code 123456789101112int countPrimes(int n) &#123; if (n &lt;= 2) return 0; int res=n&gt;&gt;1, m=sqrt(n-1); // intilize res to n/2, removes all even number(not 2) and 1 bool *table=new bool[n]; for(int i=3,j,step;i&lt;=m;i+=2) if(!table[i]) &#123; // i is an odd prime for(step=i&lt;&lt;1, j=i*i;j&lt;n;j+=step) // step=i*2, ignore even numbers if(!table[j]) &#123; table[j]=1; --res; &#125; &#125; delete []table; return res;&#125; python https://discuss.leetcode.com/topic/14036/fast-python-solution Fast Python Solution 123456789101112class Solution:# @param &#123;integer&#125; n# @return &#123;integer&#125;def countPrimes(self, n): if n &lt; 3: return 0 primes = [True] * n primes[0] = primes[1] = False for i in range(2, int(n ** 0.5) + 1): if primes[i]: primes[i * i: n: i] = [False] * len(primes[i * i: n: i]) return sum(primes)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[203. Remove Linked List Elements]]></title>
    <url>%2Fp%2F8392dc6%2F</url>
    <content type="text"><![CDATA[31.4% https://leetcode.com/problems/remove-linked-list-elements/#/description Remove all elements from a linked list of integers that have value val. 123ExampleGiven: 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, val = 6Return: 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5 方法一： 前面设置一个哑变量 学习一下 12ListNode *pseudo_head = new ListNode(0);pseudo_head-&gt;next = head; Concise C++ solution with pseudo ListHead 12345678910111213class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode *pseudo_head = new ListNode(0); pseudo_head-&gt;next = head; ListNode *cur = pseudo_head; while(cur)&#123; if(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next; else cur = cur-&gt;next; &#125; return pseudo_head-&gt;next; &#125;&#125;; 我的代码实现 1234567891011121314151617class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode* prehead = new ListNode(0); prehead-&gt;next = head; ListNode* cur = prehead; while(cur &amp;&amp; cur-&gt;next)&#123; ListNode* nex = cur-&gt;next; while(nex!=NULL &amp;&amp; nex-&gt;val==val) nex = nex-&gt;next; if(cur-&gt;next != nex) cur-&gt;next = nex; cur = nex; &#125; return prehead-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/19529/simple-and-elegant-solution-in-c Simple and elegant solution in C++ 123456789101112131415161718ListNode *removeElements(ListNode *head, int val)&#123; ListNode **list = &amp;head; while (*list != nullptr) &#123; if ((*list)-&gt;val == val) &#123; *list = (*list)-&gt;next; &#125; else &#123; list = &amp;(*list)-&gt;next; &#125; &#125; return head;&#125; Original recursive version: 123456789101112131415void removeHelper(ListNode *&amp;head, int val)&#123; if (head == nullptr) &#123; return; &#125; else if (head-&gt;val == val) &#123; head = head-&gt;next; &#125; else &#123; removeHelper(head-&gt;next, val); &#125;&#125; https://discuss.leetcode.com/topic/17550/concise-c-solution-with-pseudo-listhead Concise C++ solution with pseudo ListHead 12345678910111213class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode *pseudo_head = new ListNode(0); pseudo_head-&gt;next = head; ListNode *cur = pseudo_head; while(cur)&#123; if(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next; else cur = cur-&gt;next; &#125; return pseudo_head-&gt;next; &#125;&#125;; 2ms, 5.21%, October 15, 2016 https://discuss.leetcode.com/topic/12580/3-line-recursive-solution 1234567public class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if(head == null) return null; head.next = removeElements(head.next, val); return head.val == val ? head.next : head; &#125;&#125; 1ms, 48.64%, October 15, 2016 https://discuss.leetcode.com/topic/12725/ac-java-solution 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; ListNode fakeHead = new ListNode(-1); fakeHead.next = head; ListNode curr = head, prev = fakeHead; while(curr != null)&#123; if(curr.val == val) prev.next = curr.next; else prev = prev.next; curr = curr.next; &#125; return fakeHead.next; &#125;&#125; python116ms, 68.55%, October 15, 2016 https://discuss.leetcode.com/topic/12640/python-solution 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def removeElements(self, head, val): &quot;&quot;&quot; :type head: ListNode :type val: int :rtype: ListNode &quot;&quot;&quot; dummy = ListNode(-1) dummy.next = head next = dummy while next != None and next.next != None: if next.next.val == val: next.next = next.next.next else: next = next.next return dummy.next]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[202. Happy Number]]></title>
    <url>%2Fp%2Ff91a3fae%2F</url>
    <content type="text"><![CDATA[39.8% https://leetcode.com/problems/happy-number/description/ Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 12345671^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1 方法一： 从开始，遍历过的放入set，如果再出现一次，则肯定为false，如果到1，返回true。 123456789101112131415161718192021class Solution &#123;public: bool isHappy(int n) &#123; if(n&lt;=0) return false; if(n==1) return true; unordered_set&lt;int&gt; set; set.insert(n); while(n!=1)&#123; int sum = 0; while(n!=0)&#123; sum = sum + pow(n%10, 2); n /= 10; &#125; if(set.find(sum)!=set.end()) return false; set.insert(sum); n = sum; &#125; return true; &#125;&#125;; 另一种实现： 把一样放入table里，如果出现过，就判断是否等于1. 1的下一个还是1. 1234567891011121314151617181920class Solution &#123;public: bool isHappy(int n) &#123; int num=0; unordered_map&lt;int,bool&gt; table; table[n]=1; while(n!=1) &#123; while(n) &#123; num += (n%10) * (n%10); n/=10; &#125; if(table[num]) break; else table[num]=1; n=num;num=0; &#125; return 1==n; &#125;&#125;; 方法二： 比方法一差一些，因为没有保存，每次都去判断 12345678910111213bool isHappy(int n) &#123; int num=0; while(n!=1&amp;&amp;n!=4) &#123; while(n) &#123; num += (n%10) * (n%10); n/=10; &#125; n=num;num=0; &#125; return 1==n; &#125; https://discuss.leetcode.com/topic/30520/explanation-of-why-those-posted-algorithms-are-mathematically-valid Earlier posts gave the algorithm but did not explain why it is valid mathematically, and this is what this post is about: present a “short” mathematical proof. First of all, it is easy to argue that starting from a number I, if some value - say a - appears again during the process after k steps, the initial number I cannot be a happy number. Because a will continuously become a after every k steps. Therefore, as long as we can show that there is a loop after running the process continuously, the number is not a happy number. There is another detail not clarified yet: For any non-happy number, will it definitely end up with a loop during the process? This is important, because it is possible for a non-happy number to follow the process endlessly while having no loop. To show that a non-happy number will definitely generate a loop, we only need to show that for any non-happy number, all outcomes during the process are bounded by some large but finite integer N. If all outcomes can only be in a finite set (2,N], and since there are infinitely many outcomes for a non-happy number, there has to be at least one duplicate, meaning a loop! Suppose after a couple of processes, we end up with a large outcome O1 with D digits where D is kind of large, say D&gt;=4, i.e., O1 &gt; 999 (If we cannot even reach such a large outcome, it means all outcomes are bounded by 999 ==&gt; loop exists). We can easily see that after processing O1, the new outcome O2 can be at most 9^2D &lt; 100D, meaning that O2 can have at most 2+d(D) digits, where d(D) is the number of digits D have. It is obvious that 2+d(D) &lt; D. We can further argue that O1 is the maximum (or boundary) of all outcomes afterwards. This can be shown by contradictory: Suppose after some steps, we reach another large number O3 &gt; O1. This means we process on some number W &lt;= 999 that yields O3. However, this cannot happen because the outcome of W can be at most 9^23 &lt; 300 &lt; O1. Done. Please leave your comment if any question or suggestion. cpphttps://discuss.leetcode.com/topic/38728/0ms-c-solution-beats-97-4-perhaps-the-most-easy-one-to-understand I use three solutions: 1. hash table(8ms) 2. List circle detect method(4ms) 3.circle 1 and circle 4.Here is the url:https://en.wikipedia.org/wiki/Happy_number Based on the fact that circle of 1 is happy, circle of 4 is unhappy. Solution3: 12345678910111213bool isHappy(int n) &#123; int num=0; while(n!=1&amp;&amp;n!=4) &#123; while(n) &#123; num += (n%10) * (n%10); n/=10; &#125; n=num;num=0; &#125; return 1==n; &#125; Solution1: 1234567891011121314151617181920class Solution &#123;public: bool isHappy(int n) &#123; int num=0; unordered_map&lt;int,bool&gt; table; table[n]=1; while(n!=1) &#123; while(n) &#123; num += (n%10) * (n%10); n/=10; &#125; if(table[num]) break; else table[num]=1; n=num;num=0; &#125; return 1==n; &#125;&#125;; Solution2: 123456789101112131415161718192021222324class Solution &#123;public: bool isHappy(int n) &#123; int slow,fast; slow=fast=n; do&#123; slow = compute(slow); fast=compute(fast); fast=compute(fast); &#125;while(slow!=fast); return 1==slow; &#125;private: int compute(int n) &#123; int num=0; while(n) &#123; num += (n%10) * (n%10); n/=10; &#125; return num; &#125;&#125;; pythonSolution 1: 64ms, 42.28%, June.17th, 2016 https://leetcode.com/discuss/47623/my-python-solution 1234567891011121314class Solution(object): def isHappy(self, n): &quot;&quot;&quot; :type n: int :rtype: bool &quot;&quot;&quot; mem = set() while n != 1: n = sum([int(i)**2 for i in str(n)]) if n not in mem: mem.add(n) else: return False return True cSolution 1: 0ms, 44.72%, June.17th, 2016 https://leetcode.com/discuss/33014/4ms-5-line-c-code Using fact all numbers in [2, 6] are not happy (and all not happy numbers end on a cycle that hits this interval): 1234567891011bool isHappy(int n) &#123; while(n&gt;6)&#123; int next = 0; while(n)&#123; next += (n%10) * (n%10); n = n / 10; &#125; n = next; &#125; return n == 1;&#125; https://discuss.leetcode.com/topic/12587/my-solution-in-c-o-1-space-and-no-magic-math-property-involved I see the majority of those posts use hashset to record values. Actually, we can simply adapt the Floyd Cycle detection algorithm. I believe that many people have seen this in the Linked List Cycle detection problem. The following is my code: 123456789101112131415161718192021int digitSquareSum(int n) &#123; int sum = 0, tmp; while (n) &#123; tmp = n % 10; sum += tmp * tmp; n /= 10; &#125; return sum;&#125;bool isHappy(int n) &#123; int slow, fast; slow = fast = n; do &#123; slow = digitSquareSum(slow); fast = digitSquareSum(fast); fast = digitSquareSum(fast); &#125; while(slow != fast); if (slow == 1) return 1; else return 0;&#125; javahttps://discuss.leetcode.com/topic/25026/beat-90-fast-easy-understand-java-solution-with-brief-explanation The idea is to use one hash set to record sum of every digit square of every number occurred. Once the current sum cannot be added to set, return false; once the current sum equals 1, return true; 1234567891011121314151617181920public class Solution &#123; public boolean isHappy(int n) &#123; Set&lt;Integer&gt; inLoop = new HashSet&lt;Integer&gt;(); int squareSum,remain; while (inLoop.add(n)) &#123; squareSum = 0; while (n &gt; 0) &#123; remain = n%10; squareSum += remain*remain; n /= 10; &#125; if (squareSum == 1) return true; else n = squareSum; &#125; return false; &#125;&#125; https://discuss.leetcode.com/topic/12742/o-1-space-java-solution 123456789101112131415161718192021222324public class Solution &#123; public boolean isHappy(int n) &#123; int x = n; int y = n; while(x&gt;1)&#123; x = cal(x) ; if(x==1) return true ; y = cal(cal(y)); if(y==1) return true ; if(x==y) return false; &#125; return true ; &#125; public int cal(int n)&#123; int x = n; int s = 0; while(x&gt;0)&#123; s = s+(x%10)*(x%10); x = x/10; &#125; return s ; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[201. Bitwise AND of Numbers Range]]></title>
    <url>%2Fp%2Fee620e%2F</url>
    <content type="text"><![CDATA[33.3% https://leetcode.com/problems/bitwise-and-of-numbers-range/ Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. 1For example, given the range [5, 7], you should return 4. 方法一： 我的代码实现： 123456789101112class Solution &#123;public: int rangeBitwiseAnd(int m, int n) &#123; int cnt = 0; while(m!=n)&#123; m &gt;&gt;= 1; n &gt;&gt;= 1; cnt++; &#125; return m&lt;&lt;cnt; &#125;&#125;; 9ms, 44.28%, October 15, 2016 https://discuss.leetcode.com/topic/12133/bit-operation-solution-java Bit operation solution(JAVA) The idea is very simple: last bit of (odd number &amp; even number) is 0. when m != n, There is at least an odd number and an even number, so the last bit position result is 0. Move m and n rigth a position. Keep doing step 1,2,3 until m equal to n, use a factor to record the iteration time. 12345678910111213public class Solution &#123; public int rangeBitwiseAnd(int m, int n) &#123; if(m==0) return 0; int moveFactor = 1; while(m!=n)&#123; m &gt;&gt;= 1; n &gt;&gt;= 1; moveFactor &lt;&lt;= 1; &#125; return m * moveFactor; &#125;&#125; cpp 32ms, 64.35%, October 15, 2016 https://discuss.leetcode.com/topic/13508/one-line-c-solution One line C++ solution Consider the bits from low to high. if n &gt; m, the lowest bit will be 0, and then we could transfer the problem to sub-problem: rangeBitwiseAnd(m&gt;&gt;1, n&gt;&gt;1). 123456class Solution &#123;public: int rangeBitwiseAnd(int m, int n) &#123; return (n&gt;m) ? (rangeBitwiseAnd(m/2, n/2)&lt;&lt;1) : m; &#125;&#125;; https://discuss.leetcode.com/topic/17491/fast-three-line-c-solution-and-explanation-with-no-loops-or-recursion-and-one-extra-variable Fast three line C++ solution and explanation with no loops or recursion and one extra variable Whenever a bit changes when counting from m to n, that bit will be 0 in the AND of the range. So we consider the XOR x of m and n. The leftmost 1 bit in x is the last bit that changes at some point when counting from m to n. This bit and the bits to the right of it are all 0 in the AND of the range. We can easily fill all the bits to the right of that bit with 1s using the OR operations below to create a mask. This technique “smears” the 1 bits in x to the right. Then it’s just a matter of returning the rest of m excluding those bits (the bits in m that did not change when counting up to n), which is precisely the AND of the range from m to n. 12345678class Solution &#123;public: int rangeBitwiseAnd(int m, int n) &#123; unsigned int x = m ^ n; x |= x &gt;&gt; 1, x |= x &gt;&gt; 2, x |= x &gt;&gt; 4, x |= x &gt;&gt; 8, x |= x &gt;&gt; 16; return m &amp; ~x; &#125;&#125;; my code: 注意最后一行 n&lt;&lt; i， 不能为1&lt;&lt; i; 考虑m n都为0的情况。 123456789101112class Solution &#123;public: int rangeBitwiseAnd(int m, int n) &#123; int i = 0; while(m!=n)&#123; m&gt;&gt;=1; n&gt;&gt;=1; i++; &#125; return n&lt;&lt;i; &#125;&#125;; python 122ms, 75.44%, October 15, 2016 https://discuss.leetcode.com/topic/28538/java-python-easy-solution-with-explanation 12345678910111213class Solution(object): def rangeBitwiseAnd(self, m, n): &quot;&quot;&quot; :type m: int :type n: int :rtype: int &quot;&quot;&quot; i = 0 while m != n: m &gt;&gt;= 1 n &gt;&gt;= 1 i += 1 return n &lt;&lt; i]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[200. Number of Islands]]></title>
    <url>%2Fp%2Fa61d2ad8%2F</url>
    <content type="text"><![CDATA[33.0% https://leetcode.com/problems/number-of-islands/?tab=Description Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. 1234567Example 1:11110110101100000000Answer: 1 1234567Example 2:11000110000010000011Answer: 3 方法一： 深度优先遍历 我的代码实现： 123456789101112131415161718192021222324252627282930class Solution &#123;public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; if(grid.empty() || grid[0].empty()) return 0; int res = 0; for(int i=0; i&lt;grid.size(); i++)&#123; for(int j=0; j&lt;grid[0].size(); j++)&#123; if(grid[i][j]=='1')&#123; res++; helper(grid, i, j); &#125; &#125; &#125; return res; &#125; void helper(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j)&#123; // 此处是=，而不是==，区分 = 与 == grid[i][j] = '0'; if(i-1&gt;=0 &amp;&amp; grid[i-1][j]=='1') helper(grid, i-1, j); if(i+1&lt;grid.size() &amp;&amp; grid[i+1][j]=='1') helper(grid, i+1, j); if(j-1&gt;=0 &amp;&amp; grid[i][j-1]=='1') helper(grid, i, j-1); if(j+1&lt;grid[0].size() &amp;&amp; grid[i][j+1]=='1') helper(grid, i, j+1); &#125; &#125;; helper函数中的向左遍历和向下遍历，不能省略 否则对于样例，111,010, 111通不过，应该为1，输出却为2 https://discuss.leetcode.com/topic/11589/dfs-and-bfs-in-c DFS and BFS in C++ When we met a ‘1’, the answer add 1, we also need to search all ‘1’ which connected to it directly or indirectly, and change it to ‘0’. And we can use DFS or BFS to search. DFS 1234567891011121314151617181920212223242526272829303132class Solution&#123;public:int numIslands(vector&lt;vector&lt;char&gt;&gt; &amp;grid)&#123;if(grid.size() == 0 || grid[0].size() == 0)return 0; int res = 0; for(int i = 0; i &lt; grid.size(); ++ i) for(int j = 0; j &lt; grid[0].size(); ++ j) if(grid[i][j] == &apos;1&apos;) &#123; ++ res; DFS(grid, i, j); &#125; return res; &#125;private:void DFS(vector&lt;vector&lt;char&gt;&gt; &amp;grid, int x, int y)&#123; grid[x][y] = &apos;0&apos;; if(x &gt; 0 &amp;&amp; grid[x - 1][y] == &apos;1&apos;) DFS(grid, x - 1, y); if(x &lt; grid.size() - 1 &amp;&amp; grid[x + 1][y] == &apos;1&apos;) DFS(grid, x + 1, y); if(y &gt; 0 &amp;&amp; grid[x][y - 1] == &apos;1&apos;) DFS(grid, x, y - 1); if(y &lt; grid[0].size() - 1 &amp;&amp; grid[x][y + 1] == &apos;1&apos;) DFS(grid, x, y + 1);&#125;&#125;; BFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution&#123;public:int numIslands(vector&lt;vector&lt;char&gt;&gt; &amp;grid)&#123;if(grid.size() == 0 || grid[0].size() == 0)return 0; int res = 0; for(int i = 0; i &lt; grid.size(); ++ i) for(int j = 0; j &lt; grid[0].size(); ++ j) if(grid[i][j] == &apos;1&apos;) &#123; ++ res; BFS(grid, i, j); &#125; return res; &#125;private:void BFS(vector&lt;vector&lt;char&gt;&gt; &amp;grid, int x, int y)&#123;queue&lt;vector&lt;int&gt;&gt; q;q.push(&#123;x, y&#125;);grid[x][y] = &apos;0&apos;; while(!q.empty()) &#123; x = q.front()[0], y = q.front()[1]; q.pop(); if(x &gt; 0 &amp;&amp; grid[x - 1][y] == &apos;1&apos;) &#123; q.push(&#123;x - 1, y&#125;); grid[x - 1][y] = &apos;0&apos;; &#125; if(x &lt; grid.size() - 1 &amp;&amp; grid[x + 1][y] == &apos;1&apos;) &#123; q.push(&#123;x + 1, y&#125;); grid[x + 1][y] = &apos;0&apos;; &#125; if(y &gt; 0 &amp;&amp; grid[x][y - 1] == &apos;1&apos;) &#123; q.push(&#123;x, y - 1&#125;); grid[x][y - 1] = &apos;0&apos;; &#125; if(y &lt; grid[0].size() - 1 &amp;&amp; grid[x][y + 1] == &apos;1&apos;) &#123; q.push(&#123;x, y + 1&#125;); grid[x][y + 1] = &apos;0&apos;; &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/13045/my-accepted-c-solution-may-be-trivial My accepted c++ solution (may be trivial) 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: void contaminate(vector&lt;vector&lt;char&gt; &gt; &amp;grid, int i, int j)&#123; if(i&gt;0&amp;&amp;grid[i-1][j]==&apos;1&apos;)&#123; grid[i-1][j]=&apos;0&apos;; contaminate(grid, i-1, j); &#125; if(j&gt;0&amp;&amp;grid[i][j-1]==&apos;1&apos;)&#123; grid[i][j-1]=&apos;0&apos;; contaminate(grid, i, j-1); &#125; if(i&lt;grid.size()-1&amp;&amp;grid[i+1][j]==&apos;1&apos;)&#123; grid[i+1][j]=&apos;0&apos;; contaminate(grid, i+1, j); &#125; if(j&lt;grid[0].size()-1&amp;&amp;grid[i][j+1]==&apos;1&apos;)&#123; grid[i][j+1]=&apos;0&apos;; contaminate(grid, i, j+1); &#125; &#125; int numIslands(vector&lt;vector&lt;char&gt;&gt; &amp;grid) &#123; int n=grid.size(); if(n==0) return 0; int m=grid[0].size(); int cnt=0; for(int i=0; i&lt;n; i++)&#123; for(int j=0; j&lt;m; j++)&#123; if(grid[i][j]==&apos;1&apos;)&#123; cnt++; contaminate(grid, i, j); &#125; &#125; &#125; return cnt; &#125;&#125;; python 202ms, 15.49%, October 18, 2016 https://discuss.leetcode.com/topic/16749/7-lines-python-14-lines-java 7 lines Python, ~ 14 lines Java Sink and count the islands. Python Solution 12345678def numIslands(self, grid): def sink(i, j): if 0 &lt;= i &lt; len(grid) and 0 &lt;= j &lt; len(grid[i]) and grid[i][j] == &apos;1&apos;: grid[i][j] = &apos;0&apos; map(sink, (i+1, i-1, i, i), (j, j, j+1, j-1)) return 1 return 0 return sum(sink(i, j) for i in range(len(grid)) for j in range(len(grid[i]))) Java Solution 1 123456789101112131415161718public class Solution &#123; char[][] g; public int numIslands(char[][] grid) &#123; int islands = 0; g = grid; for (int i=0; i&lt;g.length; i++) for (int j=0; j&lt;g[i].length; j++) islands += sink(i, j); return islands; &#125; int sink(int i, int j) &#123; if (i &lt; 0 || i == g.length || j &lt; 0 || j == g[i].length || g[i][j] == &apos;0&apos;) return 0; g[i][j] = &apos;0&apos;; sink(i+1, j); sink(i-1, j); sink(i, j+1); sink(i, j-1); return 1; &#125;&#125; Java Solution 2 123456789101112131415161718public class Solution &#123; public int numIslands(char[][] grid) &#123; int islands = 0; for (int i=0; i&lt;grid.length; i++) for (int j=0; j&lt;grid[i].length; j++) islands += sink(grid, i, j); return islands; &#125; int sink(char[][] grid, int i, int j) &#123; if (i &lt; 0 || i == grid.length || j &lt; 0 || j == grid[i].length || grid[i][j] == &apos;0&apos;) return 0; grid[i][j] = &apos;0&apos;; for (int k=0; k&lt;4; k++) sink(grid, i+d[k], j+d[k+1]); return 1; &#125; int[] d = &#123;0, 1, 0, -1, 0&#125;;&#125; java https://discuss.leetcode.com/topic/13248/very-concise-java-ac-solution Very concise Java AC solution 1234567891011121314151617181920212223242526272829public class Solution &#123;private int n;private int m;public int numIslands(char[][] grid) &#123; int count = 0; n = grid.length; if (n == 0) return 0; m = grid[0].length; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++) if (grid[i][j] == &apos;1&apos;) &#123; DFSMarking(grid, i, j); ++count; &#125; &#125; return count;&#125;private void DFSMarking(char[][] grid, int i, int j) &#123; if (i &lt; 0 || j &lt; 0 || i &gt;= n || j &gt;= m || grid[i][j] != &apos;1&apos;) return; grid[i][j] = &apos;0&apos;; DFSMarking(grid, i + 1, j); DFSMarking(grid, i - 1, j); DFSMarking(grid, i, j + 1); DFSMarking(grid, i, j - 1);&#125;&#125; https://discuss.leetcode.com/topic/11590/simple-java-solution Simple Java Solution 12345678910111213141516171819202122232425public class NumberofIslands &#123; static int[] dx = &#123;-1,0,0,1&#125;; static int[] dy = &#123;0,1,-1,0&#125;; public static int numIslands(char[][] grid) &#123; if(grid==null || grid.length==0) return 0; int islands = 0; for(int i=0;i&lt;grid.length;i++) &#123; for(int j=0;j&lt;grid[i].length;j++) &#123; if(grid[i][j]==&apos;1&apos;) &#123; explore(grid,i,j); islands++; &#125; &#125; &#125; return islands; &#125; public static void explore(char[][] grid, int i, int j) &#123; grid[i][j]=&apos;x&apos;; for(int d=0;d&lt;dx.length;d++) &#123; if(i+dy[d]&lt;grid.length &amp;&amp; i+dy[d]&gt;=0 &amp;&amp; j+dx[d]&lt;grid[0].length &amp;&amp; j+dx[d]&gt;=0 &amp;&amp; grid[i+dy[d]][j+dx[d]]==&apos;1&apos;) &#123; explore(grid,i+dy[d],j+dx[d]); &#125; &#125; &#125;&#125; The algorithm works as follow: Scan each cell in the grid. If the cell value is ‘1’ explore that island. Mark the explored island cells with ‘x’. Once finished exploring that island, increment islands counter. The arrays dx[], dy[] store the possible moves from the current cell. Two land cells [‘1’] are considered from the same island if they are horizontally or vertically adjacent (possible moves (-1,0),(0,1),(0,-1),(1,0)). Two ‘1’ diagonally adjacent are not considered from the same island. https://discuss.leetcode.com/topic/20080/clear-easy-java-solution Clear &amp; Easy Java Solution 1234567891011121314151617181920212223242526public class Solution &#123; public int numIslands(char[][] grid) &#123; int count = 0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[i].length; j++) &#123; if (grid[i][j] == &apos;1&apos;) &#123; count++; clearRestOfLand(grid, i, j); &#125; &#125; &#125; return count; &#125; private void clearRestOfLand(char[][] grid, int i, int j) &#123; if (i &lt; 0 || j &lt; 0 || i &gt;= grid.length || j &gt;= grid[i].length || grid[i][j] == &apos;0&apos;) return; grid[i][j] = &apos;0&apos;; clearRestOfLand(grid, i+1, j); clearRestOfLand(grid, i-1, j); clearRestOfLand(grid, i, j+1); clearRestOfLand(grid, i, j-1); return; &#125;&#125; https://discuss.leetcode.com/topic/11705/simple-dfs-sulotion Simple DFS sulotion Dont need the extra space, and O(mn) 12345678910111213141516171819202122232425public int numIslands(char[][] grid) &#123; int islands = 0; if (grid != null &amp;&amp; grid.length != 0 &amp;&amp; grid[0].length != 0) &#123; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[0].length; j++) &#123; if (grid[i][j] == &apos;1&apos;) &#123; dfs(grid, i, j); islands++; &#125; &#125; &#125; &#125; return islands;&#125;private void dfs(char[][] grid, int x, int y) &#123; if (x &lt; 0 || grid.length &lt;= x || y &lt; 0 || grid[0].length &lt;= y || grid[x][y] != &apos;1&apos;) &#123; return; &#125; grid[x][y] = &apos;x&apos;; dfs(grid, x + 1, y); dfs(grid, x - 1, y); dfs(grid, x, y + 1); dfs(grid, x, y - 1);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>depth first search</tag>
        <tag>breadth first search</tag>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[199. Binary Tree Right Side View]]></title>
    <url>%2Fp%2Ffe12b283%2F</url>
    <content type="text"><![CDATA[39.5% https://leetcode.com/problems/binary-tree-right-side-view/#/description Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. 12345678For example:Given the following binary tree, 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;---You should return [1, 3, 4]. 方法一： 层序遍历/广度优先搜索 o(N)时间 o(N)空间 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; que; que.push(root); while(que.size())&#123; int n = que.size(); for(int i=0; i&lt;n; i++)&#123; TreeNode* cur = que.front(); que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); if(i==n-1) res.push_back(cur-&gt;val); &#125; &#125; return res; &#125;&#125;; 方法二： 递归，从先序遍历改造而来 https://discuss.leetcode.com/topic/11310/my-c-solution-modified-preorder-traversal My C++ solution, modified preorder traversal 12345678910111213141516class Solution &#123;public: void recursion(TreeNode *root, int level, vector&lt;int&gt; &amp;res) &#123; if(root==NULL) return ; if(res.size()&lt;level) res.push_back(root-&gt;val); recursion(root-&gt;right, level+1, res); recursion(root-&gt;left, level+1, res); &#125; vector&lt;int&gt; rightSideView(TreeNode *root) &#123; vector&lt;int&gt; res; recursion(root, 1, res); return res; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; res; helper(root, res, 0); return res; &#125; void helper(TreeNode* root, vector&lt;int&gt;&amp; res, int level)&#123; if(!root) return; if(res.size()==level) res.push_back(root-&gt;val); helper(root-&gt;right, res, level+1); helper(root-&gt;left, res, level+1); &#125;&#125;; https://discuss.leetcode.com/topic/23030/simple-c-solution-btw-i-like-clean-codes Simple C++ solution (BTW: I like clean codes) 123456789101112131415class Solution &#123;public: void dfs(TreeNode* root, int lv, vector&lt;int&gt; &amp;res)&#123; if(!root) return; if(lv&gt;=res.size()) res.push_back(root-&gt;val); dfs(root-&gt;right,lv+1,res); dfs(root-&gt;left,lv+1,res); &#125; vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; res; dfs(root, 0, res); return res; &#125;&#125;; https://discuss.leetcode.com/topic/11303/9ms-c-bfs-o-n-time-concise-with-explanation 9ms C++ BFS, O(n) time, concise with explanation 9ms C++ iterative, concise code with explanation Using a queue mQ to perform level order traversal. In the beginning of a level traversal, the last element is pushed into result array ret. The core idea is similar with Binary Tree Level Order Traversal O(n) time, O(logn) space 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode *root) &#123; queue&lt;TreeNode*&gt;mQ; vector&lt;int&gt; ret; if(!root)return ret; mQ.push(root); while(!mQ.empty())&#123; ret.push_back(mQ.back()-&gt;val); for(int i=mQ.size();i&gt;0;i--)&#123; TreeNode *tn=mQ.front(); mQ.pop(); if(tn-&gt;left)mQ.push(tn-&gt;left); if(tn-&gt;right)mQ.push(tn-&gt;right); &#125; &#125; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/16164/5-9-lines-python-48-ms 5-9 Lines Python, 48+ ms Solution 1: Recursive, combine right and left: 5 lines, 56 ms Compute the right view of both right and left left subtree, then combine them. For very unbalanced trees, this can be O(n^2), though. 123456def rightSideView(self, root): if not root: return [] right = self.rightSideView(root.right) left = self.rightSideView(root.left) return [root.val] + right + left[len(right):] Solution 2: Recursive, first come first serve: 9 lines, 48 ms DFS-traverse the tree right-to-left, add values to the view whenever we first reach a new record depth. This is O(n). 12345678910def rightSideView(self, root): def collect(node, depth): if node: if depth == len(view): view.append(node.val) collect(node.right, depth+1) collect(node.left, depth+1) view = [] collect(root, 0) return view Solution 3: Iterative, level-by-level: 7 lines, 48 ms Traverse the tree level by level and add the last value of each level to the view. This is O(n). 12345678def rightSideView(self, root): view = [] if root: level = [root] while level: view += level[-1].val, level = [kid for node in level for kid in (node.left, node.right) if kid] return view 1ms, 82.64%, July 14th, 2016 https://discuss.leetcode.com/topic/11768/my-simple-accepted-solution-java My simple accepted solution(JAVA) The core idea of this algorithm: Each depth of the tree only select one node. View depth is current size of result list. Here is the code: 1234567891011121314151617181920public class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); rightView(root, result, 0); return result; &#125; public void rightView(TreeNode curr, List&lt;Integer&gt; result, int currDepth)&#123; if(curr == null)&#123; return; &#125; if(currDepth == result.size())&#123; result.add(curr.val); &#125; rightView(curr.right, result, currDepth + 1); rightView(curr.left, result, currDepth + 1); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[198. House Robber]]></title>
    <url>%2Fp%2Fb015b294%2F</url>
    <content type="text"><![CDATA[37.9% https://leetcode.com/problems/house-robber/#/description You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 美团点评 面试 方法一： rob(i)表示偷了第i家，notrob(i) 不偷第i家。 rob(i) = rob(i-1)+nums[i] ,notrob(i) = max(rob(i-1), notrob(i-1)) 我的代码实现： 更新公式 rob(i) = max(rob(i-1), notrob(i-1)+nums[i]); notrob(i) = max(rob(i-1), notrob(i-1)); 123456789101112131415161718class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; if(n==1) return nums[0]; int rob = nums[0], notrob = 0; for(int i=1; i&lt;n; i++)&#123; int new_rob = max(rob, notrob+nums[i]); int new_notrob = max(rob, notrob); rob = new_rob; notrob = new_notrob; &#125; return max(rob, notrob); &#125;&#125;; 方法二： 由方法一进行推论可以得到 f(i+1) 表示偷到第i家的最大利益, f(0) = 0, f(1) = nums[1] 则f(i+1) = max(f(i), f(i-1)+nums[i]) https://discuss.leetcode.com/topic/32215/c-dp-solution-with-thinking-process-explanation C++ DP solution with thinking process explanation Following the same logic described in a post about Best Time to Buy and Sell Stock with Cooldown, we could try to solve this problem with DP. Define the following variables rob[i] means max profit for any robbing sequence before house i ending with rob rest[i] mean max profit for any robbing sequence before house i ending with rest We could get the following relationship, 12rob[i] = max(rob[i-1], rest[i-1] + value)rest[i] = max(rest[i-1], rob[i-1]) Furthermore, we always gain more profit when robbing the house. As a result, 12rob[i] &gt; rest[i]rest[i] = rob[i-1] substitute these into the original equations, we get 1rob[i] = max(rob[i-1], rob[i-2] + value) So we only need two values to keep track of the max profit. 12345678910111213class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; auto best = 0, prev_best = 0; for(auto num : nums) &#123; auto pbest = best; best = max(best, prev_best + num); prev_best = pbest; &#125; return best; &#125;&#125;; 我的代码实现： 123456789101112131415class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; int r1 = 0, r2 = 0; int r3 = 0; for(auto num:nums)&#123; r3 = max(r2, r1+num); r1 = r2; r2 = r3; &#125; return r3; &#125;&#125;; https://discuss.leetcode.com/topic/28369/the-correct-dp-solution The correct DP solution Here is the DP formula that leads to the right answer: M(k) = money at the kth house P(0) = 0 P(1) = M(1) P(k) = max(P(k−2) + M(k), P(k−1)) https://discuss.leetcode.com/topic/11110/c-1ms-o-1-space-very-simple-solution C 1ms, O(1)space, very simple solution 12345678910111213141516171819#define max(a, b) ((a)&gt;(b)?(a):(b))int rob(int num[], int n) &#123; int a = 0; int b = 0; for (int i=0; i&lt;n; i++) &#123; if (i%2==0) &#123; a = max(a+num[i], b); &#125; else &#123; b = max(a, b+num[i]); &#125; &#125; return max(a, b);&#125; https://discuss.leetcode.com/topic/17199/python-solution-3-lines Python solution, 3 lines. Based on the recursive formula: f(0) = nums[0] f(1) = max(num[0], num[1]) f(k) = max( f(k-2) + nums[k], f(k-1) ) 123456789class Solution: def rob(self, nums): last, now = 0, 0 for i in nums: last, now = now, max(last + i, now) return now https://discuss.leetcode.com/topic/12735/c-my-solution-dp C++,My solution,DP 123456789101112131415class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; const int n = nums.size(); if (n == 0) return 0; if (n == 1) return nums[0]; if (n == 2) return max(nums[0], nums[1]); vector&lt;int&gt; f(n, 0); f[0] = nums[0]; f[1] = max(nums[0], nums[1]); for (int i = 2; i &lt; n; ++i) f[i] = max(f[i-2] + nums[i], f[i-1]); return f[n-1]; &#125;&#125;; 44ms, 31.77%, 69/69, April.25, 2016 https://leetcode.com/discuss/76958/3-line-python-solution Python solution, 3 lines. Based on the recursive formula: 123f(0) = nums[0]f(1) = max(num[0], num[1])f(k) = max( f(k-2) + nums[k], f(k-1) ) 123456789class Solution: def rob(self, nums): last, now = 0, 0 for i in nums: last, now = now, max(last + i, now) return now my code rob[i] = notrob[i-1] + nums[i] notrob[i] = max(rob[i-1], notrob[i-1]) 12345678910111213class Solution(object): def rob(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if not nums: return 0 rob, notrob = 0, 0 for num in nums: temp = rob rob = notrob + num notrob = max(temp, notrob) return max(rob, notrob)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[191. Number of 1 Bits]]></title>
    <url>%2Fp%2F1f95eca1%2F</url>
    <content type="text"><![CDATA[38.8% https://leetcode.com/problems/number-of-1-bits/?tab=Description Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight). 12For example, the 32-bit integer ’11&apos; has binary representation00000000000000000000000000001011, so the function should return 3. 方法一： 我的代码实现： Oct 14， 2017 1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cnt = 0; while(n)&#123; n &amp;= n-1; cnt++; &#125; return cnt; &#125;&#125;; https://discuss.leetcode.com/topic/9915/short-code-of-c-o-m-by-time-m-is-the-count-of-1-s-and-another-several-method-of-o-1-time 12345678910int hammingWeight(uint32_t n)&#123; int res = 0; while(n) &#123; n &amp;= n - 1; ++ res; &#125; return res;&#125; my code 1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int res = 0; while(n)&#123; res += 1; n = n&amp;(n-1); &#125; return res; &#125;&#125;; java https://discuss.leetcode.com/topic/11385/simple-java-solution-bit-shifting 12345678public static int hammingWeight(int n) &#123; int ones = 0; while(n!=0) &#123; ones = ones + (n &amp; 1); n = n&gt;&gt;&gt;1; &#125; return ones;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[190. Reverse Bits]]></title>
    <url>%2Fp%2F60d7c33e%2F</url>
    <content type="text"><![CDATA[29.5% https://leetcode.com/problems/reverse-bits/?tab=Description Reverse bits of a given 32 bits unsigned integer. For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000). Follow up: If this function is called many times, how would you optimize it? Related problem: Reverse Integer 方法一： 我的代码实现： 对于大数，要用long long 1234567891011121314class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; long long res = 0; long long cur = 1; for(int i=0; i&lt;32; i++)&#123; res &lt;&lt;= 1; if(cur&amp;n) res |= 1; cur &lt;&lt;= 1; &#125; return res; &#125;&#125;; 注意：32位，不要使用while(n) 12345678910114ms, 51.95%, July 14th, 2016https://discuss.leetcode.com/topic/10298/the-concise-c-solution-9msclass Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; uint32_t result = 0; for(int i=0; i&lt;32; i++) result = (result&lt;&lt;1) + (n&gt;&gt;i &amp; 1); //此处+可以换成 | return result; &#125;&#125;; my code 注意优先级， ‘+’ &gt; ‘&gt;&gt;’ &gt; ‘&amp;’ &gt; ‘|’ 1234567891011class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; uint32_t res = 0; for(int i=0; i&lt;32; i++)&#123; res = (res&lt;&lt;1) | (n&amp;1); // &apos;|&apos;可以为&apos;+&apos;，但是如果没有括号，要注意优先级 n &gt;&gt;= 1; &#125; return res; &#125;&#125;; my code: 123456789101112class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; uint32_t res = 0; for(int i=0; i&lt;32; i++)&#123; res &lt;&lt;= 1; res |= n &amp; 1; n &gt;&gt;= 1; &#125; return res; &#125;&#125;; python 1234567891011112ms, 2.09%, July 14th, 2016https://discuss.leetcode.com/topic/10069/python-ac-with-63ms-3linesclass Solution(object): def reverseBits(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; oribin = &apos;&#123;0:032b&#125;&apos;.format(n) reversebin = oribin[::-1] return int(reversebin, 2) java 123456789101112132ms, 50.87%, July 14th, 2016https://discuss.leetcode.com/topic/12236/concise-java-solutionpublic class Solution &#123; // you need treat n as an unsigned value public int reverseBits(int n) &#123; int result = 0; for(int i=0; i &lt; 32; ++i)&#123; result = result &lt;&lt; 1 | (n &amp; 1); n &gt;&gt;&gt;= 1; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[189. Rotate Array]]></title>
    <url>%2Fp%2Fde5421e%2F</url>
    <content type="text"><![CDATA[23.8% https://leetcode.com/problems/rotate-array/ Rotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Hint: Could you do it in-place with O(1) extra space? Related problem: Reverse Words in a String II https://discuss.leetcode.com/topic/9237/3-line-using-reverse 方法一：三次反转 第一次 全部反转； 第二次反转左边的k个； 第三次右边的n-k个。 注意，cpp的内置reverse函数 我的代码实现： Oct 14， 2017 123456789101112class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); if(n==0 || k==0) return; reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin()+k%n); reverse(nums.begin()+k%n, nums.end()); return; &#125;&#125;; 因为是向右移k位，当移动nums.size()的时候，就与不移动nums.size()是一样的，所以k%=n 123456789class Solution &#123;public: void rotate(vector&lt;int&gt; &amp; nums, int k) &#123; int n = nums.size(); reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin()+k%n); reverse(nums.begin()+k%n, nums.end()); &#125;&#125;; https://discuss.leetcode.com/topic/9406/3-lines-of-c-in-one-pass-using-swap Every swap will put one number into its correct position, so the running time is O(n) For example, at first, nums[] is [1,2,3,4,5,6,7], n is 7, k is 3 after first outer loop, nums[] is [4,1,2,3], n is 4, k is 3 after second outer loop, nums[] is [4], n is 1, k is 0 loop ends. 方法二：前k个与最后k个互换，前k个正位了。再处理k+1至最后一位，与前一问题相同，继续前面的方法处理。12345678910class Solution &#123;public: void rotate(vector&lt;int&gt;&amp;nums, int k) &#123; int n = nums.size(); int start = 0; for (; k %= n; n -= k, start+=k) for (int i = 0; i &lt; k; i++) swap(nums[start+i], nums[start + n - k + i]); &#125;&#125;; https://discuss.leetcode.com/topic/9801/summary-of-c-solutions Make an extra copy and then rotate. Time complexity: O(n). Space complexity: O(n). 123456789101112131415class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); if(n==0 || k&lt;=0) return; vector&lt;int&gt; mycopy(n); for(int i=0; i&lt;n; i++) mycopy[i] = nums[i]; for(int i=0; i&lt;n; i++) nums[(i+k)%n] = mycopy[i]; &#125;&#125;; python236ms, 3.89%, June.22th, 2016 https://leetcode.com/discuss/29657/my-simple-python-code python内置方法 12345678910class Solution(object): def rotate(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; while k &gt; 0: nums.insert(0, nums.pop()) k -= 1 javahttps://discuss.leetcode.com/topic/14341/easy-to-read-java-solution 123456789101112131415161718public class Solution &#123; public void rotate(int[] nums, int k) &#123; k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); &#125; public void reverse(int[] nums, int start, int end) &#123; while (start &lt; end) &#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[188. Best Time to Buy and Sell Stock IV]]></title>
    <url>%2Fp%2F96f6f6%2F</url>
    <content type="text"><![CDATA[24.0% https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/ Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). java https://discuss.leetcode.com/topic/8984/a-concise-dp-solution-in-java A Concise DP Solution in Java The general idea is DP, while I had to add a “quickSolve” function to tackle some corner cases to avoid TLE. DP: t(i,j) is the max profit for up to i transactions by time j (0&lt;=i&lt;=K, 0&lt;=j&lt;=T). 1234567891011121314151617181920212223public int maxProfit(int k, int[] prices) &#123; int len = prices.length; if (k &gt;= len / 2) return quickSolve(prices); int[][] t = new int[k + 1][len]; for (int i = 1; i &lt;= k; i++) &#123; int tmpMax = -prices[0]; for (int j = 1; j &lt; len; j++) &#123; t[i][j] = Math.max(t[i][j - 1], prices[j] + tmpMax); tmpMax = Math.max(tmpMax, t[i - 1][j - 1] - prices[j]); &#125; &#125; return t[k][len - 1];&#125;private int quickSolve(int[] prices) &#123; int len = prices.length, profit = 0; for (int i = 1; i &lt; len; i++) // as long as there is a price gap, we gain a profit. if (prices[i] &gt; prices[i - 1]) profit += prices[i] - prices[i - 1]; return profit;&#125; https://discuss.leetcode.com/topic/26169/clean-java-dp-solution-with-comment Clean Java DP solution with comment 123456789101112131415161718192021222324252627282930313233/** * dp[i, j] represents the max profit up until prices[j] using at most i transactions. * dp[i, j] = max(dp[i, j-1], prices[j] - prices[jj] + dp[i-1, jj]) &#123; jj in range of [0, j-1] &#125; * = max(dp[i, j-1], prices[j] + max(dp[i-1, jj] - prices[jj])) * dp[0, j] = 0; 0 transactions makes 0 profit * dp[i, 0] = 0; if there is only one price data point you can&apos;t make any transaction. */public int maxProfit(int k, int[] prices) &#123; int n = prices.length; if (n &lt;= 1) return 0; //if k &gt;= n/2, then you can make maximum number of transactions. if (k &gt;= n/2) &#123; int maxPro = 0; for (int i = 1; i &lt; n; i++) &#123; if (prices[i] &gt; prices[i-1]) maxPro += prices[i] - prices[i-1]; &#125; return maxPro; &#125; int[][] dp = new int[k+1][n]; for (int i = 1; i &lt;= k; i++) &#123; int localMax = dp[i-1][0] - prices[0]; for (int j = 1; j &lt; n; j++) &#123; dp[i][j] = Math.max(dp[i][j-1], prices[j] + localMax); localMax = Math.max(localMax, dp[i-1][j] - prices[j]); &#125; &#125; return dp[k][n-1];&#125; https://discuss.leetcode.com/topic/24079/easy-understanding-and-can-be-easily-modified-to-different-situations-java-solution Easy understanding and can be easily modified to different situations Java Solution The basic idea is to create two tables. hold and unhold. hold[i][j] means the maximum profit with at most j transaction for 0 to i-th day. hold means you have a stock in your hand. unhold[i][j] means the maximum profit with at most j transaction for 0 to i-th day. unhold means you don’t have a stock in your hand. The equation is 123hold[i][j] = Math.max(unhold[i-1][j]-prices[i],hold[i-1][j]);unhold[i][j] = Math.max(hold[i-1][j-1]+prices[i],unhold[i-1][j]); when you sell your stock this is a transaction but when you buy a stock, it is not considered as a full transaction. so this is why the two equation look a little different. And we have to initiate hold table when k = 0. When the situation is you can not buy a new stock at the same day when you sell it. For example you can only buy a new stock after one day you sell it. The same idea. Another situation is when you have to pay a transaction fee for each transaction, just make a modification when you sell it, So just change the unhold equation a little. 12345678910111213141516171819202122232425262728public class Solution &#123; //hold[i][k] ith day k transaction have stock and maximum profit //unhold[i][k] ith day k transaction do not have stock at hand and maximum profit public int maxProfit(int k, int[] prices) &#123; if(k&gt;prices.length/2) return maxP(prices); int[][] hold = new int[prices.length][k+1]; int[][] unhold = new int[prices.length][k+1]; hold[0][0] = -prices[0]; for(int i=1;i&lt;prices.length;i++) hold[i][0] = Math.max(hold[i-1][0],-prices[i]); for(int j=1;j&lt;=k;j++) hold[0][j] = -prices[0]; for(int i=1;i&lt;prices.length;i++)&#123; for(int j=1;j&lt;=k;j++)&#123; hold[i][j] = Math.max(unhold[i-1][j]-prices[i],hold[i-1][j]); unhold[i][j] = Math.max(hold[i-1][j-1]+prices[i],unhold[i-1][j]); &#125; &#125; return Math.max(hold[prices.length-1][k],unhold[prices.length-1][k]); &#125; public int maxP(int[] prices)&#123; int res =0; for(int i=0;i&lt;prices.length;i++)&#123; if(i&gt;0 &amp;&amp; prices[i] &gt; prices[i-1])&#123; res += prices[i]-prices[i-1]; &#125; &#125; return res; &#125;&#125; cpp https://discuss.leetcode.com/topic/9522/c-solution-with-o-n-klgn-time-using-max-heap-and-stack C++ Solution with O(n + klgn) time using Max Heap and Stack We can find all adjacent valley/peak pairs and calculate the profits easily. Instead of accumulating all these profits like Buy&amp;Sell Stock II, we need the highest k ones. The key point is when there are two v/p pairs (v1, p1) and (v2, p2), satisfying v1 &lt;= v2 and p1 &lt;= p2, we can either make one transaction at [v1, p2], or make two at both [v1, p1] and [v2, p2]. The trick is to treat [v1, p2] as the first transaction, and [v2, p1] as the second. Then we can guarantee the right max profits in both situations, p2 - v1 for one transaction and p1 - v1 + p2 - v2 for two. Finding all v/p pairs and calculating the profits takes O(n) since there are up to n/2 such pairs. And extracting k maximums from the heap consumes another O(klgn). 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt; &amp;prices) &#123; int n = (int)prices.size(), ret = 0, v, p = 0; priority_queue&lt;int&gt; profits; stack&lt;pair&lt;int, int&gt; &gt; vp_pairs; while (p &lt; n) &#123; // find next valley/peak pair for (v = p; v &lt; n - 1 &amp;&amp; prices[v] &gt;= prices[v+1]; v++); for (p = v + 1; p &lt; n &amp;&amp; prices[p] &gt;= prices[p-1]; p++); // save profit of 1 transaction at last v/p pair, if current v is lower than last v while (!vp_pairs.empty() &amp;&amp; prices[v] &lt; prices[vp_pairs.top().first]) &#123; profits.push(prices[vp_pairs.top().second-1] - prices[vp_pairs.top().first]); vp_pairs.pop(); &#125; // save profit difference between 1 transaction (last v and current p) and 2 transactions (last v/p + current v/p), // if current v is higher than last v and current p is higher than last p while (!vp_pairs.empty() &amp;&amp; prices[p-1] &gt;= prices[vp_pairs.top().second-1]) &#123; profits.push(prices[vp_pairs.top().second-1] - prices[v]); v = vp_pairs.top().first; vp_pairs.pop(); &#125; vp_pairs.push(pair&lt;int, int&gt;(v, p)); &#125; // save profits of the rest v/p pairs while (!vp_pairs.empty()) &#123; profits.push(prices[vp_pairs.top().second-1] - prices[vp_pairs.top().first]); vp_pairs.pop(); &#125; // sum up first k highest profits for (int i = 0; i &lt; k &amp;&amp; !profits.empty(); i++) &#123; ret += profits.top(); profits.pop(); &#125; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/12250/share-my-c-dp-solution-with-o-kn-time-o-k-space-10ms Share my C++ DP solution with O(kn) time O(k) space, 10ms This is my DP solution: 123456789101112131415161718192021222324252627282930class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt; &amp;prices) &#123; int len = prices.size(); if (len&lt;2) return 0; if (k&gt;len/2)&#123; // simple case int ans = 0; for (int i=1; i&lt;len; ++i)&#123; ans += max(prices[i] - prices[i-1],0); &#125; return ans; &#125; int hold[k+1]; int rele[k+1]; for (int i=0;i&lt;=k;++i)&#123; hold[i] = INT_MIN; rele[i] = 0; &#125; int cur; for (int i=0; i&lt;len; ++i)&#123; cur = prices[i]; for(int j=k; j&gt;0; --j)&#123; rele[j] = max(rele[j],hold[j] + cur); hold[j] = max(hold[j],rele[j-1] - cur); &#125; &#125; return rele[k]; &#125;&#125;; Inspired by weijiac in Best Time to Buy and Sell Stock III https://leetcode.com/discuss/18330/is-it-best-solution-with-o-n-o-1 https://discuss.leetcode.com/topic/30242/o-n-time-8ms-accepted-solution-with-detailed-explanation-c O(n)-time 8ms Accepted Solution with Detailed Explanation (C++) The idea of this thread was originally proposed by @yishiluo in https://leetcode.com/discuss/26745/c-solution-with-o-n-klgn-time-using-max-heap-and-stack General idea: We use the term “valley” to denote a local minimum index of prices, and the term “peak” to denote a local maximum index of prices. Let (v1, p1) and (v2, p2) denote two successive valley-peak pairs of the prices, respectively. Consider the two cases: Case 1: prices[v1] &lt;= prices[v2] and prices[p1] &lt;= prices[p2]. In this case, if we can conduct one transaction, we will use (v1, p2). If we can conduct two transactions, we will use (v1, p1) and (v2, p2). Equivalently, we can consider (v1, p2) as one transaction opportunity, and (v2, p1) as another transaction opportunity. The key idea is that these two original valley-peak pairs provide two transaction opportunities: (v1, p2) and (v2, p1). Case 2: prices[v1] &gt;= prices[v2] or prices[p1] &gt;= prices[p2]. In this case, if we can conduct one transaction, we will use either (v1, p1) or (v2, p2). If we can conduct two transactions, we will use both (v1, p1) and (v2, p2). That is, these two valley-peak pairs provides two transaction opportunities: (v1, p1) and (v2, p2). The algorithm consists of two steps: Step 1: Find all transaction opportunities and record their profits. We use a stack vps to store the valley-peak pairs of the stock prices, wherein the valley value is sorted in ascending order. (The valley value at the top of the stack is the largest.) The profit of all transaction opportunities are recorded in the vector profits. The time complexity of this step is O(n). Step 2: Find the k most profitable transaction opportunities. The maximum profit we can get is the summation of the k opportunity. The time complexity of this step is O(n), too. Overall complexity: Time: O(n) Space: worse-case O(n) C++ code (Accepted 8ms) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; // Step 1: Find out all profit opportunities vector&lt;int&gt; profits; stack&lt;pair&lt;int, int&gt;&gt; vps; // valley-peak pairs int v; int p = -1; for (;;) &#123; // find next valley-peak pair for (v = p+1; (v+1 &lt; prices.size()) &amp;&amp; (prices[v] &gt;= prices[v+1]); ++v); for (p = v ; (p+1 &lt; prices.size()) &amp;&amp; (prices[p] &lt;= prices[p+1]); ++p); if (v == p) &#123; // v==p means that both v and p reach the end of the array break; &#125; // Consider two transactions (v1, p1) (back of the stack) and (v2, p2) (the new-found). // If prices[v1] &gt;= prices[v2], // it is meaningless to combine the two transactions. // Save of profit of (v1, p1), and pop it out of the record. while ((!vps.empty()) &amp;&amp; (prices[v] &lt;= prices[vps.top().first])) &#123; profits.push_back(prices[vps.top().second] - prices[vps.top().first]); vps.pop(); &#125; // If prices[v1]&lt;prices[v2] and prices[p1]&lt;prices[p2], // then it is meaningful to combine the two transactions // update (v1, p1) to (v1, p2), and save the profit of (v2, p1) while ((!vps.empty()) &amp;&amp; (prices[p] &gt;= prices[vps.top().second])) &#123; profits.push_back(prices[vps.top().second] - prices[v]); v = vps.top().first; vps.pop(); &#125; // save the new-found valley-peak pair vps.emplace(v, p); &#125; // save all remaining profits while (!vps.empty()) &#123; profits.push_back(prices[vps.top().second] - prices[vps.top().first]); vps.pop(); &#125; // Step 2: Calculate the k highest profits int ret; if (profits.size() &lt;= k) &#123; ret = accumulate(profits.begin(), profits.end(), 0); &#125; else &#123; nth_element(profits.begin(), profits.end() - k, profits.end()); ret = accumulate(profits.end() - k, profits.end(), 0); &#125; return ret; &#125;&#125;; python https://discuss.leetcode.com/topic/22245/well-explained-python-dp-with-comments Well explained Python DP with comments I think the general idea has been thoroughly explained by other brilliant leetcoders. All of the solutions are beautiful and concise. However, most of the them don’t look obvious to me, so I wrote this and hope it looks more straight forward.It’s O(kn), apparently not optimal. I name the key variables as local profit and global profit to make things much understandable (well, at least , to me). Performance is not too bad though. 1234567891011121314151617181920212223242526272829303132def maxProfit4(self, k, prices): n = len(prices) if n &lt; 2: return 0 # k is big enougth to cover all ramps. if k &gt;= n / 2: return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j &gt; 0) globalMax = [[0] * n for _ in xrange(k + 1)] for i in xrange(1, k + 1): # The max profit with i transations and selling stock on day j. localMax = [0] * n for j in xrange(1, n): profit = prices[j] - prices[j - 1] localMax[j] = max( # We have made max profit with (i - 1) transations in # (j - 1) days. # For the last transation, we buy stock on day (j - 1) # and sell it on day j. globalMax[i - 1][j - 1] + profit, # We have made max profit with (i - 1) transations in # (j - 1) days. # For the last transation, we buy stock on day j and # sell it on the same day, so we have 0 profit, apparently # we do not have to add it. globalMax[i - 1][j - 1], # + 0, # We have made profit in (j - 1) days. # We want to cancel the day (j - 1) sale and sell it on # day j. localMax[j - 1] + profit) globalMax[i][j] = max(globalMax[i][j - 1], localMax[j]) return globalMax[k][-1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[187. Repeated DNA Sequences]]></title>
    <url>%2Fp%2F11769ba3%2F</url>
    <content type="text"><![CDATA[30.1% All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. 123456For example,Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",Return:["AAAAACCCCC", "CCCCCAAAAA"]. 方法一: 我的代码实现: 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; vector&lt;string&gt; res; if(s.size()&lt;10) return res; unordered_set&lt;int&gt; set1, set2; unordered_map&lt;char, int&gt; map = &#123;&#123;'A', 0&#125;, &#123;'C', 1&#125;, &#123;'G', 2&#125;, &#123;'T', 3&#125;&#125;; for(int i=0; i&lt;=s.size()-10; i++)&#123; int k=0; for(int j=i; j&lt;i+10; j++)&#123; k &lt;&lt;= 2; k |= map[s[j]]; &#125; if(set1.find(k)!=set1.end() &amp;&amp; set2.find(k)==set2.end())&#123; res.push_back(s.substr(i, 10)); set2.insert(k); &#125; set1.insert(k); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/8894/clean-java-solution-hashmap-bits-manipulation Clean Java solution (hashmap + bits manipulation) 12345678910111213141516171819202122public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123; Set&lt;Integer&gt; words = new HashSet&lt;&gt;(); Set&lt;Integer&gt; doubleWords = new HashSet&lt;&gt;(); List&lt;String&gt; rv = new ArrayList&lt;&gt;(); char[] map = new char[26]; //map[&apos;A&apos; - &apos;A&apos;] = 0; map[&apos;C&apos; - &apos;A&apos;] = 1; map[&apos;G&apos; - &apos;A&apos;] = 2; map[&apos;T&apos; - &apos;A&apos;] = 3; for(int i = 0; i &lt; s.length() - 9; i++) &#123; int v = 0; for(int j = i; j &lt; i + 10; j++) &#123; v &lt;&lt;= 2; v |= map[s.charAt(j) - &apos;A&apos;]; &#125; if(!words.add(v) &amp;&amp; doubleWords.add(v)) &#123; rv.add(s.substring(i, i + 10)); &#125; &#125; return rv;&#125; https://discuss.leetcode.com/topic/8487/i-did-it-in-10-lines-of-c I did it in 10 lines of C++ The main idea is to store the substring as int in map to bypass the memory limits. There are only four possible character A, C, G, and T, but I want to use 3 bits per letter instead of 2. Why? It’s easier to code. A is 0x41, C is 0x43, G is 0x47, T is 0x54. Still don’t see it? Let me write it in octal. A is 0101, C is 0103, G is 0107, T is 0124. The last digit in octal are different for all four letters. That’s all we need! We can simply use s[i] &amp; 7 to get the last digit which are just the last 3 bits, it’s much easier than lookup table or switch or a bunch of if and else, right? We don’t really need to generate the substring from the int. While counting the number of occurrences, we can push the substring into result as soon as the count becomes 2, so there won’t be any duplicates in the result. 1234567891011vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; unordered_map&lt;int, int&gt; m; vector&lt;string&gt; r; int t = 0, i = 0, ss = s.size(); while (i &lt; 9) t = t &lt;&lt; 3 | s[i++] &amp; 7; while (i &lt; ss) if (m[t = t &lt;&lt; 3 &amp; 0x3FFFFFFF | s[i++] &amp; 7]++ == 1) r.push_back(s.substr(i - 10, 10)); return r;&#125; BTW, the OJ doesn’t seems to have test cases which the given string length is smaller than 9, so I didn’t check it to make the code simpler. Any suggestions? Update: I realised that I can use s[i] &gt;&gt; 1 &amp; 3 to get 2 bits, but then I won’t be able to remove the first loop as 1337c0d3r suggested. https://discuss.leetcode.com/topic/8487/i-did-it-in-10-lines-of-c/2 Neat idea. The additional 1 bit per letter still encode each substring in 10x3 = 30 bits, just under 4 bytes for a 32-bit integer. Your code could be further simplified. By observing that s[i] &amp; 7 is never 0, each of the first nine substrings with length &lt; 10 will have unique hash key and will never collide with other 10-letter long sequences. Therefore the first loop could be removed and be compacted into a single loop. 12345678vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; unordered_map&lt;int, int&gt; m; vector&lt;string&gt; r; for (int t = 0, i = 0; i &lt; s.size(); i++) if (m[t = t &lt;&lt; 3 &amp; 0x3FFFFFFF | s[i] &amp; 7]++ == 1) r.push_back(s.substr(i - 9, 10)); return r;&#125; Another observation is the mapped value need not be an integer counter, and could simply be a boolean to further save space. This requires some extra logic though: 12345678910111213141516vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; unordered_map&lt;int, bool&gt; m; vector&lt;string&gt; r; for (int t = 0, i = 0; i &lt; s.size(); i++) &#123; t = t &lt;&lt; 3 &amp; 0x3FFFFFFF | s[i] &amp; 7; if (m.find(t) != m.end()) &#123; if (m[t]) &#123; r.push_back(s.substr(i - 9, 10)); m[t] = false; &#125; &#125; else &#123; m[t] = true; &#125; &#125; return r;&#125; PS: OJ does have test cases which the given string has length that is less than 9. https://discuss.leetcode.com/topic/8487/i-did-it-in-10-lines-of-c/3 Concise solution! A little longer but more readable solution base on your idea. 1234567891011121314int str2int(string s) &#123; int str=0; for (int i = 0; i &lt; s.size(); ++i) str = (str&lt;&lt;3) +(s[i]&amp;7); return str;&#125;vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; vector&lt;string&gt; res; unordered_map&lt;int,int&gt; coll; for (int i = 0; i+10 &lt;= s.size(); ++i) if (coll[str2int(s.substr(i,10))]++ == 1) res.push_back(s.substr(i,10)); return res;&#125; https://discuss.leetcode.com/topic/27517/7-lines-simple-java-o-n 7 lines simple Java, O(n) 123456789public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123; Set seen = new HashSet(), repeated = new HashSet(); for (int i = 0; i + 9 &lt; s.length(); i++) &#123; String ten = s.substring(i, i + 10); if (!seen.add(ten)) repeated.add(ten); &#125; return new ArrayList(repeated);&#125; https://discuss.leetcode.com/topic/8539/short-java-rolling-hash-solution Short Java “rolling-hash” solution Hi guys! The idea is to use rolling hash technique or in case of string search also known as Rabin-Karp algorithm. As our alphabet A consists of only 4 letters we can be not afraid of collisions. The hash for a current window slice could be found in a constant time by subtracting the former first character times size of the A in the power of 9 and updating remaining hash by the standard rule: hash = hash*A.size() + curr_char. Check out the Java code below. Hope it helps! 12345678910111213141516public class Solution &#123; private static final Map&lt;Character, Integer&gt; A = new HashMap&lt;&gt;(); static &#123; A.put(&apos;A&apos;,0); A.put(&apos;C&apos;,1); A.put(&apos;G&apos;,2); A.put(&apos;T&apos;,3); &#125; private final int A_SIZE_POW_9 = (int) Math.pow(A.size(), 9); public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123; Set&lt;String&gt; res = new HashSet&lt;&gt;(); Set&lt;Integer&gt; hashes = new HashSet&lt;&gt;(); for (int i = 0, rhash = 0; i &lt; s.length(); i++) &#123; if (i &gt; 9) rhash -= A_SIZE_POW_9 * A.get(s.charAt(i-10)); rhash = A.size() * rhash + A.get(s.charAt(i)); if (i &gt; 8 &amp;&amp; !hashes.add(rhash)) res.add(s.substring(i-9,i+1)); &#125; return new ArrayList&lt;&gt;(res); &#125;&#125; https://discuss.leetcode.com/topic/18263/10-lines-c-code-8-ms-passed 10 lines C++ code, 8 ms passed! 123456789101112vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; char hashMap[1048576] = &#123;0&#125;; vector&lt;string&gt; ans; int len = s.size(),hashNum = 0; if (len &lt; 11) return ans; for (int i = 0;i &lt; 9;++i) hashNum = hashNum &lt;&lt; 2 | (s[i] - &apos;A&apos; + 1) % 5; for (int i = 9;i &lt; len;++i) if (hashMap[hashNum = (hashNum &lt;&lt; 2 | (s[i] - &apos;A&apos; + 1) % 5) &amp; 0xfffff]++ == 1) ans.push_back(s.substr(i-9,10)); return ans;&#125; https://discuss.leetcode.com/topic/10880/11ms-solution-with-unified-hash-fxn ~ 11ms Solution with Unified Hash Fxn Appricate for advice. 123456789101112131415161718192021222324252627282930313233343536373839404142vector&lt;string&gt; findRepeatedDnaSequences(string s)&#123; vector&lt;string&gt; ret; if ( s.length() &lt; 11 ) &#123; return ret; &#125; char table[1048576] = &quot;&quot;; unsigned int hash = 0U; for ( size_t i = 0; i &lt; 10; ++i ) &#123; /** &apos;A&apos; - &apos;A&apos; + 1 = 1 = 1 (mod 5) * &apos;C&apos; - &apos;A&apos; + 1 = 3 = 3 (mod 5) * &apos;G&apos; - &apos;A&apos; + 1 = 7 = 2 (mod 5) * &apos;T&apos; - &apos;A&apos; + 1 = 20 = 0 (mod 5) */ hash = ( hash &lt;&lt; 2 ) | ( ( s[i] - &apos;A&apos; + 1 ) % 5 ); &#125; table[hash] = 1; for ( size_t i = 10; i &lt; s.length(); ++i ) &#123; hash = ( ( hash &lt;&lt; 2 ) ^ ( ( s[ i - 10 ] - &apos;A&apos; + 1 ) % 5 ) &lt;&lt; 20 ) | ( ( s[i] - &apos;A&apos; + 1 ) % 5 ); if ( table[hash] == 0 ) &#123; table[hash] = 1; &#125; else if ( table[hash] == 1 ) &#123; table[hash] = 2; ret.push_back( string( s, i - 9, 10 ) ); &#125; &#125; return ret;&#125; https://discuss.leetcode.com/topic/31640/20-ms-solution-c-with-explanation 20 ms solution (C++) with explanation One obvious way to do this is to use a hash table mapping strings to counts. (e.g. H[“AAAAAAAAAA”] represents the number of times we have seen AAAAAAAAAA. This will work in O(n) time, but its useful to discuss why this is not a good solution: Runtime constant (from hashing): When using a hash table, there is a runtime hit for hashing the string. In this case, converting the string to a table index. That will presumably mean looking at each character of the string. Since each character is part of 10 different substrings (other than the end characters), that means 10n character reads. Still linear, but we can do better on the constant. Memory (values): There isn’t any reason to store a count. Each possible string has only 3 states we need to track: “never been seen”, “been seen once”, and “been seen more than once”. This requires only two bits to track – not the 4-8 bytes needed for an integer. Memory (keys): A hash table needs to store each key (to resolve collisions). At 10 bytes per key, thats 10*n bytes – a potential problem if n is every large, and completely unnecessary. Here is how we address the three problems: Hashing: We compute the hash ourselves, but take advantage of the overlapping. We treat each letter as a two-bit number. (Arbitrarily, A=0, C=1, G=2, T=3.) We treat ten consecutive letters as a 20-bit integer. We can calculate the first one with: 123int val = 0;for (int i=0; i &lt; 10; i++) val = (val &lt;&lt; 2) | char2val(s[i]); Now, to compute the next string: 1val = ((val &lt;&lt; 2) &amp; mask) | char2val(s[10]); Where: mask: 20 consecutive bits ((1 &lt;&lt; 21) -1). ((val &lt;&lt; 2) &amp; mask: shift everything over two bits, and get rid of the most significant bits. ((val &lt;&lt; 2) &amp; mask) | char2val(s[10]): Replace the right-most two bits with the character code.Much faster than looking at every character 10 times. Hash table: We instead use two bit-sets. There are 2^{21}-1 possible strings. We need a bit in each set for each possible string. The first set (S1) tells us if the string has been seen once or not. The second set (S2) tell us whether the string has been seen more than once. Code: 1234567891011121314151617181920212223242526272829303132333435363738vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; if (s.size() &lt;= 10) return vector&lt;string&gt;(); vector&lt;string&gt; R; bitset&lt;1&lt;&lt;20&gt; S1; bitset&lt;1&lt;&lt;20&gt; S2; int val = 0; for (int i=0; i &lt; 10; i++) // Calc. the has value for the first string. val = (val &lt;&lt; 2) | char2val(s[i]); S1.set(val); cout &lt;&lt; val &lt;&lt; &quot; | &quot;; int mask = (1 &lt;&lt; 20) - 1; for (int i=10; i &lt; s.size(); i++) &#123; // Calc the hash value for the string ending at position i. val = ((val &lt;&lt; 2) &amp; mask) | char2val(s[i]); if (S2[val]) continue; if (S1[val]) &#123; R.push_back(s.substr(i-10+1, 10)); S2.set(val); &#125; else S1.set(val); &#125; return R;&#125;int char2val(char c) &#123; switch (c) &#123; case &apos;A&apos;: return 0; case &apos;C&apos;: return 1; case &apos;G&apos;: return 2; case &apos;T&apos;: return 3; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>hash table</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[179. Largest Number]]></title>
    <url>%2Fp%2F7dd5a2b3%2F</url>
    <content type="text"><![CDATA[21.8% https://leetcode.com/problems/largest-number/?tab=Description Given a list of non negative integers, arrange them such that they form the largest number. 1For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330. Note: The result may be very large, so you need to return a string instead of an integer. 方法一： 剑指offer 33 我的代码实现： 1234567891011121314class Solution &#123;public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end(), [](int a, int b)&#123;return to_string(a)+to_string(b)&gt;to_string(b)+to_string(a);&#125;); string res; for(int i=0; i&lt;nums.size(); i++)z res += to_string(nums[i]); // 学习erase的用法 erase(pos, len) while(res.size()&gt;1 &amp;&amp; res[0]=='0') res.erase(0, 1); return res; &#125;&#125;; 转换成string，然后比较，相加，考虑第一个值为0的情况 https://discuss.leetcode.com/topic/7286/a-simple-c-solution A simple C++ solution 先变成字符串排序，然后累加，再进行删除前面的0 简单直接 此处学习to_string 的用法，还有erase的用法。 string此处用的begin(arr),不同于vector的arr.begin() 后面的比较也是引用 erase(0, 1) erase(start, end), 其中删除关系[start, end) 123456789101112131415class Solution &#123;public: string largestNumber(vector&lt;int&gt; &amp;num) &#123; vector&lt;string&gt; arr; for(auto i:num) arr.push_back(to_string(i)); sort(begin(arr), end(arr), [](string &amp;s1, string &amp;s2)&#123; return s1+s2&gt;s2+s1; &#125;); string res; for(auto s:arr) res+=s; while(res[0]==&apos;0&apos; &amp;&amp; res.length()&gt;1) res.erase(0,1); return res; &#125;&#125;; erase 的用法 iterator erase (iterator position); iterator erase (iterator first, iterator last); position Iterator pointing to a single element to be removed from the vector. Member types iterator and const_iterator are random access iterator types that point to elements. first, last Iterators specifying a range within the vector] to be removed: [first,last). i.e., the range includes all the elements between first and last, including the element pointed by first but not the one pointed by last. Member types iterator and const_iterator are random access iterator types that point to elements. 剑指offer 33把数组排成最小的数 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 方法一： 题目为正数，如果有0，则加上代码中注释的代码 整数转string的函数to_string(a) string可以相加 a+b 如果有必要，检查边界是否有0的情况 12345678910111213class Solution &#123;public: string PrintMinNumber(vector&lt;int&gt; numbers) &#123; string res = &quot;&quot;; sort(numbers.begin(), numbers.end(), [](int a, int b) &#123;return to_string(a)+to_string(b)&lt;to_string(b)+to_string(a);&#125;); for(auto num:numbers) res += to_string(num); //while(res[0]==&apos;0&apos; &amp;&amp; res.length()&gt;1) // res.erase(0,1); return res; &#125;&#125;; https://discuss.leetcode.com/topic/10920/share-a-short-code-in-c Share a short code in c++ 12345678910111213class Solution &#123;public: string largestNumber(vector&lt;int&gt; &amp;num) &#123; sort(num.begin(), num.end(), [](int a, int b)&#123; return to_string(a)+to_string(b) &gt; to_string(b)+to_string(a); &#125;); string ans; for(int i=0; i&lt;num.size(); i++)&#123; ans += to_string(num[i]); &#125; return ans[0]==&apos;0&apos; ? &quot;0&quot; : ans; &#125;&#125;; https://discuss.leetcode.com/topic/12293/simple-10-line-c-solution Simple 10-line C++ Solution 123456789101112131415class Solution &#123; public: string largestNumber(vector&lt;int&gt;&amp; nums) &#123; string ret; sort(nums.begin(),nums.end(), [](const int &amp;m,const int&amp;n)&#123; return to_string(m)+to_string(n)&gt;to_string(n)+to_string(m);&#125;); for(int i=0;i&lt;nums.size();++i)&#123; ret+=to_string(nums[i]); &#125; if(ret[0]==&apos;0&apos;) //for the case nums are all zeros return &quot;0&quot;; return ret; &#125; &#125;; https://discuss.leetcode.com/topic/7722/python-simple-solution-in-4-lines Python simple solution in 4 lines It’s all about comparison . We define a func that compares two strings a ,b. we consider a bigger than b if a+b &gt; b+a . then we sort the numbers and concatenate them . 12345678class Solution:# @param num, a list of integers# @return a stringdef largestNumber(self, num): comp=lambda a,b:1 if a+b&gt;b+a else -1 if a+b&lt;b+a else 0 num=map(str,num) num.sort(cmp=comp,reverse=True) return str(int(&quot;&quot;.join(num))) UPDATE More explanation 1-we define a function that compares two string (a,b) . we consider a bigger than b if a+b&gt;b+afor example : (a=”2”,b=”11”) a is bigger than b because “211” &gt;”112” 2-convert all elements of the list from int to string 3-sort the list descendingly using the comparing function we definedfor example sorting this list [“2”,”11”,”13”] using the function defined in step 1 would produce [“2”,”13”,”11”] 4-we concatatenate the list “21311” https://discuss.leetcode.com/topic/7235/my-3-lines-code-in-java-and-python My 3-lines code in Java and Python The logic is pretty straightforward. Just compare number by convert it to string. Thanks for Java 8, it makes code beautiful. Java: 1234567public class Solution &#123; public String largestNumber(int[] num) &#123; String[] array = Arrays.stream(num).mapToObj(String::valueOf).toArray(String[]::new); Arrays.sort(array, (String s1, String s2) -&gt; (s2 + s1).compareTo(s1 + s2)); return Arrays.stream(array).reduce((x, y) -&gt; x.equals(&quot;0&quot;) ? y : x + y).get(); &#125;&#125; Python: class Solution: 123456# @param num, a list of integers # @return a string def largestNumber(self, num): num = [str(x) for x in num] num.sort(cmp=lambda x, y: cmp(y+x, x+y)) return &apos;&apos;.join(num).lstrip(&apos;0&apos;) or &apos;0&apos; https://discuss.leetcode.com/topic/32442/share-my-fast-java-solution-beat-98-64 Share my fast JAVA solution, beat 98.64%! 1234567891011121314151617181920212223public class Solution &#123; public String largestNumber(int[] nums) &#123; if (nums == null || nums.length == 0) return &quot;&quot;; String[] strs = new String[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; strs[i] = nums[i]+&quot;&quot;; &#125; Arrays.sort(strs, new Comparator&lt;String&gt;() &#123; @Override public int compare(String i, String j) &#123; String s1 = i+j; String s2 = j+i; return s1.compareTo(s2); &#125; &#125;); if (strs[strs.length-1].charAt(0) == &apos;0&apos;) return &quot;0&quot;; String res = new String(); for (int i = 0; i &lt; strs.length; i++) &#123; res = strs[i]+res; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/8018/my-java-solution-to-share My Java Solution to share The idea here is basically implement a String comparator to decide which String should come first during concatenation. Because when you have 2 numbers (let’s convert them into String), you’ll face only 2 cases: 1234567For example:String s1 = &quot;9&quot;;String s2 = &quot;31&quot;;String case1 = s1 + s2; // 931String case2 = s2 + s1; // 319 Apparently, case1 is greater than case2 in terms of value.So, we should always put s1 in front of s2. I have received many good suggestions from you in this discussion. Below is the modified version of codes based on your suggestions: 123456789101112131415161718192021222324252627282930313233public class Solution &#123; public String largestNumber(int[] num) &#123; if(num == null || num.length == 0) return &quot;&quot;; // Convert int array to String array, so we can sort later on String[] s_num = new String[num.length]; for(int i = 0; i &lt; num.length; i++) s_num[i] = String.valueOf(num[i]); // Comparator to decide which string should come first in concatenation Comparator&lt;String&gt; comp = new Comparator&lt;String&gt;()&#123; @Override public int compare(String str1, String str2)&#123; String s1 = str1 + str2; String s2 = str2 + str1; return s2.compareTo(s1); // reverse order here, so we can do append() later &#125; &#125;; Arrays.sort(s_num, comp); // An extreme edge case by lc, say you have only a bunch of 0 in your int array if(s_num[0].charAt(0) == &apos;0&apos;) return &quot;0&quot;; StringBuilder sb = new StringBuilder(); for(String s: s_num) sb.append(s); return sb.toString(); &#125;&#125; In terms of Time and Space Complexity:Let’s assume:the length of input array is n,average length of Strings in s_num is k,Then, compare 2 strings will take O(k).Sorting will take O(nlgn)Appending to StringBuilder takes O(n).So total will be O(nklgnk) + O(n) = O(nklgnk). Space is pretty straight forward: O(n).]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[174. Dungeon Game]]></title>
    <url>%2Fp%2F77abb633%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/dungeon-game/ The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN. header 1 header 2 header 3 -2(K) -3 3 -5 -10 1 10 30 -5(P) Notes: The knight’s health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. https://discuss.leetcode.com/topic/6906/who-can-explain-why-from-the-bottom-right-corner-to-left-top Who can explain why “from the bottom right corner to left top.” Why we fill the table from the bottom right corner to left top? https://discuss.leetcode.com/topic/6912/c-dp-solution C++ DP solution 第一点，从右下角开始思考，从右下角开始思考。 同时注意，knight在路途中间不能没有血。 Use hp[i][j] to store the min hp needed at position (i, j), then do the calculation from right-bottom to left-up. Note: adding dummy row and column would make the code cleaner. 12345678910111213141516171819class Solution &#123;public: int calculateMinimumHP(vector&lt;vector&lt;int&gt; &gt; &amp;dungeon) &#123; int M = dungeon.size(); int N = dungeon[0].size(); // hp[i][j] represents the min hp needed at position (i, j) // Add dummy row and column at bottom and right side vector&lt;vector&lt;int&gt; &gt; hp(M + 1, vector&lt;int&gt;(N + 1, INT_MAX)); hp[M][N - 1] = 1; hp[M - 1][N] = 1; for (int i = M - 1; i &gt;= 0; i--) &#123; for (int j = N - 1; j &gt;= 0; j--) &#123; int need = min(hp[i + 1][j], hp[i][j + 1]) - dungeon[i][j]; hp[i][j] = need &lt;= 0 ? 1 : need; &#125; &#125; return hp[0][0]; &#125;&#125;; https://discuss.leetcode.com/topic/6912/c-dp-solution/4 We could reduce the 2-D DP matrix into 1-D 123456789101112131415class Solution &#123;public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123; int n=dungeon.size(),m=dungeon[0].size(); vector&lt;int&gt; dp(n+1,INT_MAX); dp[n-1]=1; for(int j=m-1;j&gt;=0;j--)&#123; for(int i=n-1;i&gt;=0;i--)&#123; dp[i]=min(dp[i],dp[i+1])-dungeon[i][j]; dp[i]=max(1,dp[i]); &#125; &#125; return dp[0]; &#125;&#125;; https://discuss.leetcode.com/topic/7633/best-solution-i-have-found-with-explanations Best solution I have found with explanations http://leetcodesolution.blogspot.com/2015/01/leetcode-dungeon-game.html seems pretty simple… and easy to understand explanations… It is easy to know that at grid P, since “ at any point his health point drops to 0 or below, he dies immediately”, the remaining health value should be at least 1, that is, initialHealth + dungeon &gt;= 1, we have initialHealth = max(1, 1 - dungeon[i][j]). (Notice, at any grid, the initial health should be at least 1 (for example, test case [1,0,0] require initial health 1 even though it has positive remaining health at grid[0][1] and grid[0][2]) Similarly, to satisfy the initial health of dungeon[i][j], the initial health of dungeon[i-1][j] (or dungeon[i][j-1]) should be at least initialHealth[i-1][j] + dungeon[i-1][j] = initialHealth[i][j], that is, initialHealth[i][j] = initialHealth[i][j] - dungeon[i-1][j]. In addition, if grid[i][j] can go both grid[i+1][j] and grid[i][j+1] to P, we should choose a path with less initial health between grid[i+1][j] and grid[i][j+1] since it require less initial health of grid[i][j].We can simply code the solution by having the dynamic programming equations. 1234567891011121314151617181920212223242526272829int calculateMinimumHP(vector &amp;dungeon) &#123; int m = dungeon.size(); int n = dungeon[0].size(); vector minInitHealth(m, vector&lt;int&gt;(n,0)); for(int i=m-1; i&gt;=0; i--) &#123; for (int j=n-1; j&gt;=0; j--) &#123; if (i == m-1 &amp;&amp; j == n-1) &#123; minInitHealth[i][j] = max(1, 1 - dungeon[i][j]); &#125; else if (i == m-1) &#123; minInitHealth[i][j] = max(1, minInitHealth[i][j+1] - dungeon[i][j]); &#125; else if (j == n-1) &#123; minInitHealth[i][j] = max(1, minInitHealth[i+1][j] - dungeon[i][j]); &#125; else &#123; minInitHealth[i][j] = max(1, min(minInitHealth[i+1][j],minInitHealth[i][j+1]) - dungeon[i][j]); &#125; &#125; &#125; return minInitHealth[0][0];&#125; https://discuss.leetcode.com/topic/7024/sharing-my-solution-with-o-n-space-o-mn-runtime Sharing my solution with O(n) space, O(mn) runtime Here is my solution using dp and rolling array –Dungeon Game: 12345678910111213int calculateMinimumHP(vector&lt;vector&lt;int&gt; &gt; &amp;dungeon) &#123; const int m = dungeon.size(); const int n = dungeon[0].size(); vector&lt;int&gt; dp(n + 1, INT_MAX); dp[n - 1] = 1; for(int i = m - 1; i &gt;= 0; --i) for(int j = n - 1; j &gt;= 0; --j) dp[j] = getMin(min(dp[j], dp[j + 1]) - dungeon[i][j]); return dp[0];&#125;int getMin(int n)&#123; return n &lt;= 0 ? 1 : n;&#125; Note: Update from right to left and from bottom up. https://discuss.leetcode.com/topic/19304/6-lines-16-ms-c-o-mn-time-o-n-space 6 lines, 16 ms, C++, O(mn) Time, O(n) Space, 12345678910struct Solution &#123; int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; d) &#123; vector&lt;int&gt; dp(d.size() + 1, INT_MAX); dp[d.size() - 1] = 1; for (int i = d[0].size() - 1; i &gt;= 0; --i) for (int j = d.size() - 1; j &gt;= 0; --j) dp[j] = max(1, min(dp[j + 1], dp[j]) - d[j][i]); return dp[0]; &#125;&#125;; https://discuss.leetcode.com/topic/26511/a-12-ms-c-solution-dp A 12 ms C++ solution, DP This problem is quite like #64 Minimum Path Sum. The trick is where is the Starting point. This problem ask us to find the least hp in top-left. So in the most optimistic situation, bottom-right value can be determined as 1. Then bottom-right is the starting point. 12345678910111213141516171819int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dun) &#123; if (!dun.size() || !dun[0].size()) return 1; int nrow = dun.size(); int ncol = dun[0].size(); vector&lt;int&gt; row(ncol + 1, INT_MAX); row[ncol - 1] = 1; int i, j, t; for (i = nrow - 1; i &gt;= 0; --i) &#123; for (j = ncol - 1; j &gt;= 0; --j) &#123; t = min(row[j], row[j + 1]) - dun[i][j]; row[j] = max(t, 1); //row[j]=smaller value from below and right, but no smaller than 1. &#125; &#125; return row[0];&#125; https://discuss.leetcode.com/topic/19179/6-lines-python-8-lines-ruby 6 lines Python, 8 lines Ruby Just some DP. Python 1234567def calculateMinimumHP(self, dungeon): n = len(dungeon[0]) need = [2**31] * (n-1) + [1] for row in dungeon[::-1]: for j in range(n)[::-1]: need[j] = max(min(need[j:j+2]) - row[j], 1) return need[0] Got accepted in 52 ms, faster than all other recent Python submissions (best was 56 ms, achieved by 5.7692%).]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>binary search</tag>
        <tag>dynamic programming</tag>
        <tag>aaa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[173. Binary Search Tree Iterator]]></title>
    <url>%2Fp%2F85cdceee%2F</url>
    <content type="text"><![CDATA[39.9% https://leetcode.com/problems/binary-search-tree-iterator/#/description Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. 方法一： 我的代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class BSTIterator &#123; stack&lt;TreeNode*&gt; mystack;public: BSTIterator(TreeNode *root) &#123; push_all(root); &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return !mystack.empty(); &#125; /** @return the next smallest number */ int next() &#123; TreeNode* cur = mystack.top(); mystack.pop(); // if(cur-&gt;right) push_all(cur-&gt;right); return cur-&gt;val; &#125;private: void push_all(TreeNode* node)&#123; for(;node!=NULL; node=node-&gt;left) mystack.push(node); &#125;&#125;;/** * Your BSTIterator will be called like this: * BSTIterator i = BSTIterator(root); * while (i.hasNext()) cout &lt;&lt; i.next(); */ https://discuss.leetcode.com/topic/6575/my-solutions-in-3-languages-with-stack My solutions in 3 languages with Stack I use Stack to store directed left children from root. When next() be called, I just pop one element and process its right child as new root. The code is pretty straightforward. So this can satisfy O(h) memory, hasNext() in O(1) time, But next() is O(h) time. I can’t find a solution that can satisfy both next() in O(1) time, space in O(h). Java: 1234567891011121314151617181920212223public class BSTIterator &#123; private Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); public BSTIterator(TreeNode root) &#123; pushAll(root); &#125; /** @return whether we have a next smallest number */ public boolean hasNext() &#123; return !stack.isEmpty(); &#125; /** @return the next smallest number */ public int next() &#123; TreeNode tmpNode = stack.pop(); pushAll(tmpNode.right); return tmpNode.val; &#125; private void pushAll(TreeNode node) &#123; for (; node != null; stack.push(node), node = node.left); &#125;&#125; C++: 12345678910111213141516171819202122232425class BSTIterator &#123; stack&lt;TreeNode *&gt; myStack;public: BSTIterator(TreeNode *root) &#123; pushAll(root); &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return !myStack.empty(); &#125; /** @return the next smallest number */ int next() &#123; TreeNode *tmpNode = myStack.top(); myStack.pop(); pushAll(tmpNode-&gt;right); return tmpNode-&gt;val; &#125;private: void pushAll(TreeNode *node) &#123; for (; node != NULL; myStack.push(node), node = node-&gt;left); &#125;&#125;; Python: 1234567891011121314151617181920class BSTIterator: # @param root, a binary search tree&apos;s root node def __init__(self, root): self.stack = list() self.pushAll(root) # @return a boolean, whether we have a next smallest number def hasNext(self): return self.stack # @return an integer, the next smallest number def next(self): tmpNode = self.stack.pop() self.pushAll(tmpNode.right) return tmpNode.val def pushAll(self, node): while node is not None: self.stack.append(node) node = node.left https://discuss.leetcode.com/topic/12265/my-solution-in-c-in-average-o-1-time-and-uses-o-h-memory My Solution in C++, in average O(1) time and uses O(h) memory 123456789101112131415161718192021222324252627282930313233343536class BSTIterator &#123;private: stack&lt;TreeNode*&gt; st;public: BSTIterator(TreeNode *root) &#123; find_left(root); &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; if (st.empty()) return false; return true; &#125; /** @return the next smallest number */ int next() &#123; TreeNode* top = st.top(); st.pop(); if (top-&gt;right != NULL) find_left(top-&gt;right); return top-&gt;val; &#125; /** put all the left child() of root */ void find_left(TreeNode* root) &#123; TreeNode* p = root; while (p != NULL) &#123; st.push(p); p = p-&gt;left; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/8154/morris-traverse-solution Morris traverse solution Traverse a BST from the smallest to the largest, then i solve this question simply use the inorder traversal.To implement a iterator means we should traverse the tree step by step, so just split the inorder traversal. 12345678910111213141516171819202122232425262728293031323334353637383940414243class BSTIterator &#123;public:BSTIterator(TreeNode *root) &#123; p = root;&#125;/** @return whether we have a next smallest number */bool hasNext() &#123; return p != NULL;&#125;/** @return the next smallest number */int next() &#123; TreeNode *tmp; int ret; while(p) &#123; if (p-&gt;left == NULL) &#123; ret = p-&gt;val; p = p-&gt;right; break; &#125; else &#123; tmp = p-&gt;left; while (tmp-&gt;right != NULL &amp;&amp; tmp-&gt;right != p) tmp = tmp-&gt;right; if (tmp-&gt;right == NULL) &#123; tmp-&gt;right = p; p = p-&gt;left; &#125; else &#123; ret = p-&gt;val; tmp-&gt;right = NULL; p = p-&gt;right; break; &#125; &#125; &#125; return ret;&#125;TreeNode *p;&#125;; https://discuss.leetcode.com/topic/24617/c-using-stack C++. using stack. 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class BSTIterator &#123;private: TreeNode *current = NULL; stack&lt;TreeNode*&gt; s;public: BSTIterator(TreeNode *root) &#123; // initialize the current pointer current = root; &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; while(current)&#123; s.push(current); current = current-&gt;left; &#125; if(s.empty())&#123; return false; &#125; return true; &#125; /** @return the next smallest number */ int next() &#123; TreeNode* node = s.top(); s.pop(); current = node-&gt;right; return node-&gt;val; &#125;&#125;;/** * Your BSTIterator will be called like this: * BSTIterator i = BSTIterator(root); * while (i.hasNext()) cout &lt;&lt; i.next(); */ The basic idea behind this solution is that we have to implement inorder iteratively but it will gets split into two functions i.e. hasNext and next.hasNext() will push all the left elements and check and return accordingly if elements are in the stack.next() will just pop() the top element from the stack and update the current pointer to right .For this we are taking a stack and a current pointer.But maybe I may be wrong in hasNext as the requirement of question is O(1) for hasNext() as well. Open for comments. https://discuss.leetcode.com/topic/6629/two-python-solutions-stack-and-generator Two Python solutions, stack and generator stack solution: 123456789101112131415161718def __init__(self, root): self.stack = [] while root: self.stack.append(root) root = root.left# @return a boolean, whether we have a next smallest numberdef hasNext(self): return len(self.stack) &gt; 0# @return an integer, the next smallest numberdef next(self): node = self.stack.pop() x = node.right while x: self.stack.append(x) x = x.left return node.val generator solution: 123456789101112131415161718192021222324def __init__(self, root): self.last = root while self.last and self.last.right: self.last = self.last.right self.current = None self.g = self.iterate(root)# @return a boolean, whether we have a next smallest numberdef hasNext(self): return self.current is not self.last# @return an integer, the next smallest numberdef next(self): return next(self.g) def iterate(self, node): if node is None: return for x in self.iterate(node.left): yield x self.current = node yield node.val for x in self.iterate(node.right): yield x]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>stack</tag>
        <tag>tree</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[172. Factorial Trailing Zeroes]]></title>
    <url>%2Fp%2F75ca0b86%2F</url>
    <content type="text"><![CDATA[35.3% https://leetcode.com/problems/factorial-trailing-zeroes/#/description Given an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. 4ms, 19.42%, July 15th, 2016 https://discuss.leetcode.com/topic/6516/my-one-line-solutions-in-3-languages 123456class Solution &#123;public: int trailingZeroes(int n) &#123; return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5); &#125;&#125;; 60ms, 31.23%, July 15th, 2016 https://discuss.leetcode.com/topic/6516/my-one-line-solutions-in-3-languages 1234567class Solution(object): def trailingZeroes(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; return 0 if n == 0 else n / 5 + self.trailingZeroes(n / 5) 2ms, 3.36%, July 15th, 2016 https://discuss.leetcode.com/topic/6516/my-one-line-solutions-in-3-languages 12345public class Solution &#123; public int trailingZeroes(int n) &#123; return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[169. Majority Element]]></title>
    <url>%2Fp%2Ffc93121c%2F</url>
    <content type="text"><![CDATA[45.4% https://leetcode.com/problems/majority-element/description/ Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 方法一： 剑指offer 29 基于partition的解法 我的代码实现： Oct 18， 2017 123456789101112131415161718192021222324252627282930class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return 0; if(n==1) return nums[0]; int l = 0, r = n-1; int pos = partition(nums, l, r); while(pos!=(n-1)/2)&#123; if(pos &gt; (n-1)/2)&#123; r = pos - 1; &#125;else&#123; l = pos + 1; &#125; pos = partition(nums, l, r); &#125; return nums[pos]; &#125; int partition(vector&lt;int&gt;&amp; nums, int l, int r)&#123; if(l&gt;=r) return l; int pos = l-1; for(int i=l; i&lt;r; i++) if(nums[i]&lt;nums[r]) swap(nums[i], nums[++pos]); swap(nums[++pos], nums[r]); return pos; &#125;&#125;; 我的实现 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return -1; int n = nums.size(); int mid = n/2; int left = 0, right = n-1; int index = partition(nums, left, right); while(index!=mid)&#123; if(index&lt;mid) left = index+1; else right = index-1; index = partition(nums, left, right); &#125; return nums[mid]; &#125; int partition(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if(left==right) return left; int pos = left-1; for(int i=left; i&lt;right; i++)&#123; if(nums[i]&lt;nums[right])&#123; swap(nums[i], nums[++pos]); &#125; &#125; swap(nums[++pos], nums[right]); return pos; &#125;&#125;; 方法二： 根据数组特点找出O(n)的解法 我的实现 根据cnt是否为0，来分开。 cnt不为0，则就根据是否同于res来进行增减cnt。 我的代码实现： Oct 18， 2017 123456789101112131415161718192021class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int n = nums.size(); if(n==1) return nums.back(); int res = nums[0], cnt = 1; for(int i=1; i&lt;n; i++)&#123; if(cnt==0)&#123; cnt = 1; res = nums[i]; &#125;else&#123; if(nums[i]==res) cnt++; else cnt--; &#125; &#125; return res; &#125;&#125;; 12345678910111213141516171819202122class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return nums[0]; int res; int cnt = 0; for(int i=0; i&lt;n; i++)&#123; if(cnt==0)&#123; res = nums[i]; cnt = 1; &#125;else&#123; if(res == nums[i])&#123; cnt++; &#125;else&#123; cnt--; &#125; &#125; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/8692/o-n-time-o-1-space-fastest-solution O(n) time O(1) space fastest solution 使用一个cnt来表示个数，是个很不错的选择，当一样时增加， 不同时减少。 12345678910111213141516public class Solution &#123; public int majorityElement(int[] num) &#123; int major=num[0], count = 1; for(int i=1; i&lt;num.length;i++)&#123; if(count==0)&#123; count++; major=num[i]; &#125;else if(major==num[i])&#123; count++; &#125;else count--; &#125; return major; &#125;&#125; https://discuss.leetcode.com/topic/17446/6-suggested-solutions-in-c-with-explanations 6 Suggested Solutions in C++ with Explanations Well, if you have got this problem accepted, you may have noticed that there are 7 suggested solutions for this problem. The following passage will implement 6 of them except the O(n^2) brute force algorithm. Hash Table The hash-table solution is very straightforward. We maintain a mapping from each element to its number of appearances. While constructing the mapping, we update the majority element based on the max number of appearances we have seen. Notice that we do not need to construct the full mapping when we see that an element has appeared more than n / 2 times. The code is as follows, which should be self-explanatory. 12345678910class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; counts; int n = nums.size(); for (int i = 0; i &lt; n; i++) if (++counts[nums[i]] &gt; n / 2) return nums[i]; &#125;&#125;; Sorting Since the majority element appears more than n / 2 times, the n / 2-th element in the sorted nums must be the majority element. This can be proved intuitively. Note that the majority element will take more than n / 2 positions in the sorted nums (cover more than half of nums). If the first of it appears in the 0-th position, it will also appear in the n / 2-th position to cover more than half of nums. It is similar if the last of it appears in the n - 1-th position. These two cases are that the contiguous chunk of the majority element is to the leftmost and the rightmost in nums. For other cases (imagine the chunk moves between the left and the right end), it must also appear in the n / 2-th position. The code is as follows, being very short if we use the system nth_element (thanks for @qeatzy for pointing out such a nice function). 1234567class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; nth_element(nums.begin(), nums.begin() + nums.size() / 2, nums.end()); return nums[nums.size() / 2]; &#125; &#125;; Randomization This is a really nice idea and works pretty well (16ms running time on the OJ, almost fastest among the C++ solutions). The proof is already given in the suggested solutions. The code is as follows, randomly pick an element and see if it is the majority one. 12345678910111213141516class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); srand(unsigned(time(NULL))); while (true) &#123; int idx = rand() % n; int candidate = nums[idx]; int counts = 0; for (int i = 0; i &lt; n; i++) if (nums[i] == candidate) counts++; if (counts &gt; n / 2) return candidate; &#125; &#125;&#125;; Divide and Conquer This idea is very algorithmic. However, the implementation of it requires some careful thought about the base cases of the recursion. The base case is that when the array has only one element, then it is the majority one. This solution takes 24ms. 123456789101112131415class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; return majority(nums, 0, nums.size() - 1); &#125;private: int majority(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left == right) return nums[left]; int mid = left + ((right - left) &gt;&gt; 1); int lm = majority(nums, left, mid); int rm = majority(nums, mid + 1, right); if (lm == rm) return lm; return count(nums.begin() + left, nums.begin() + right + 1, lm) &gt; count(nums.begin() + left, nums.begin() + right + 1, rm) ? lm : rm; &#125;&#125;; Moore Voting Algorithm A brilliant and easy-to-implement algorithm! It also runs very fast, about 20ms. 1234567891011121314class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int major, counts = 0, n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; if (!counts) &#123; major = nums[i]; counts = 1; &#125; else counts += (nums[i] == major) ? 1 : -1; &#125; return major; &#125;&#125;; Bit Manipulation Another nice idea! The key lies in how to count the number of 1’s on a specific bit. Specifically, you need a mask with a 1 on the i-the bit and 0 otherwise to get the i-th bit of each element in nums. The code is as follows. 1234567891011121314151617class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int major = 0, n = nums.size(); for (int i = 0, mask = 1; i &lt; 32; i++, mask &lt;&lt;= 1) &#123; int bitCounts = 0; for (int j = 0; j &lt; n; j++) &#123; if (nums[j] &amp; mask) bitCounts++; if (bitCounts &gt; n / 2) &#123; major |= mask; break; &#125; &#125; &#125; return major; &#125; &#125;; https://discuss.leetcode.com/topic/28601/java-solutions-sorting-hashmap-moore-voting-bit-manipulation Java solutions (sorting, hashmap, moore voting, bit manipulation). 12345// Sortingpublic int majorityElement1(int[] nums) &#123; Arrays.sort(nums); return nums[nums.length/2];&#125; 1234567891011121314151617// Hashtable public int majorityElement2(int[] nums) &#123; Map&lt;Integer, Integer&gt; myMap = new HashMap&lt;Integer, Integer&gt;(); //Hashtable&lt;Integer, Integer&gt; myMap = new Hashtable&lt;Integer, Integer&gt;(); int ret=0; for (int num: nums) &#123; if (!myMap.containsKey(num)) myMap.put(num, 1); else myMap.put(num, myMap.get(num)+1); if (myMap.get(num)&gt;nums.length/2) &#123; ret = num; break; &#125; &#125; return ret;&#125; 12345678910111213// Moore voting algorithmpublic int majorityElement3(int[] nums) &#123; int count=0, ret = 0; for (int num: nums) &#123; if (count==0) ret = num; if (num!=ret) count--; else count++; &#125; return ret;&#125; 1234567891011121314// Bit manipulation public int majorityElement(int[] nums) &#123; int[] bit = new int[32]; for (int num: nums) for (int i=0; i&lt;32; i++) if ((num&gt;&gt;(31-i) &amp; 1) == 1) bit[i]++; int ret=0; for (int i=0; i&lt;32; i++) &#123; bit[i]=bit[i]&gt;nums.length/2?1:0; ret += bit[i]*(1&lt;&lt;(31-i)); &#125; return ret;&#125; https://discuss.leetcode.com/topic/6251/c-solution-using-moore-s-voting-algorithm-o-n-runtime-comlexity-an-no-extra-array-or-hash-table C++ solution using Moore’s voting algorithm - O(n) runtime comlexity an no extra array or hash table This can be solved by Moore’s voting algorithm. Basic idea of the algorithm is if we cancel out each occurrence of an element e with all the other elements that are different from e then e will exist till end if it is a majority element. Below code loops through each element and maintains a count of the element that has the potential of being the majority element. If next element is same then increments the count, otherwise decrements the count. If the count reaches 0 then update the potential index to the current element and sets count to 1. 123456789101112int majorityElement(vector&lt;int&gt; &amp;num) &#123; int majorityIndex = 0; for (int count = 1, i = 1; i &lt; num.size(); i++) &#123; num[majorityIndex] == num[i] ? count++ : count--; if (count == 0) &#123; majorityIndex = i; count = 1; &#125; &#125; return num[majorityIndex];&#125; https://discuss.leetcode.com/topic/6286/share-my-solution-java-count-bits Share my solution [Java] - Count bits Definitely not the fastest solution but I post it here for your reference since it’s different from the rest I saw. The problem reminded me of the approach I followed at Single Number II (problem 137). We can iterate over the bits of all numbers and for every position find out if ones outnumber the zeros (among all numbers). If this is the case, the corresponding bit of the ret variable (which holds the result) is set. We essentially “construct” the number we look for. The following code is simple and should be easy to understand. 1234567891011121314151617public int majorityElement(int[] num) &#123; int ret = 0; for (int i = 0; i &lt; 32; i++) &#123; int ones = 0, zeros = 0; for (int j = 0; j &lt; num.length; j++) &#123; if ((num[j] &amp; (1 &lt;&lt; i)) != 0) &#123; ++ones; &#125; else ++zeros; &#125; if (ones &gt; zeros) ret |= (1 &lt;&lt; i); &#125; return ret;&#125; https://discuss.leetcode.com/topic/7684/an-easy-way-to-solve-the-problem-24ms An easy way to solve the problem ( 24ms ) Every number in the vector votes for itself, the majority number gets the most votes. Different number offsets the votes. 1234567891011121314int majorityElement(vector&lt;int&gt; &amp;num) &#123; int vote = num[0]; int count = 1; int size = num.size(); //vote from the second number for( int i = 1; i &lt; size; i++ ) &#123; if( count == 0 ) &#123; vote = num[i]; count++; &#125; else if( vote == num[i] ) count++; else count--; &#125; return vote; &#125; https://discuss.leetcode.com/topic/6287/one-line-solution-in-python One line solution in Python NOTICE that the majority element always exist in the array,so that the middle always is the answer 1return sorted(num)[len(num)/2]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>divide and conquer</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[167. Two Sum II - Input array is sorted]]></title>
    <url>%2Fp%2F360afcfa%2F</url>
    <content type="text"><![CDATA[47.6% https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/ Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. 12Input: numbers=&#123;2, 7, 11, 15&#125;, target=9Output: index1=1, index2=2 方法一： 双指针，不断收缩查找范围，来找到响应元素。 12345678910111213class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int lo=0, hi=numbers.size()-1; while(numbers[lo]+numbers[hi] != target)&#123; if(numbers[lo]+numbers[hi]&lt;target) lo++; else hi--; &#125; return vector&lt;int&gt;(&#123;lo+1, hi+1&#125;); &#125;&#125;; 我的代码实现： 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; vector&lt;int&gt; res; int left = 0, right = numbers.size()-1; while(left&lt;right)&#123; int sum = numbers[left] + numbers[right]; if(sum==target)&#123; res.push_back(left+1); res.push_back(right+1); return res; &#125;else if(sum&gt;target) right--; else left++; &#125; &#125;&#125;; 6ms, September 11, 2016 https://discuss.leetcode.com/topic/12660/a-simple-o-n-solution A simple O(n) solution We only have to shrink the range to find the pair: 12345678910111213class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int lo=0, hi=numbers.size()-1; while(numbers[lo]+numbers[hi] != target)&#123; if(numbers[lo]+numbers[hi]&lt;target) lo++; else hi--; &#125; return vector&lt;int&gt;(&#123;lo+1, hi+1&#125;); &#125;&#125;; https://discuss.leetcode.com/topic/7465/a-less-efficient-way-binary-search A less efficient way (binary search) I know that the best solution is using two pointers like what is done in the previous solution sharing. However, I see the tag contains “binary search”. I do not know if I misunderstand but is binary search a less efficient way for this problem. Say, fix the first element A[0] and do binary search on the remaining n-1 elements. If cannot find any element which equals target-A[0], Try A[1]. That is, fix A[1] and do binary search on A[2] ~ A[n-1]. Continue this process until we have the last two elements A[n-2] and A[n-1] . Does this gives a time complexity lg(n-1) + lg(n-2) + … + lg(1) ~ O(lg(n!)) ~ O(nlgn). So it is less efficient than the O(n) solution. Am I missing something here? The code also passes OJ. 123456789101112vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123; if(numbers.empty()) return &#123;&#125;; for(int i=0; i&lt;numbers.size()-1; i++) &#123; int start=i+1, end=numbers.size()-1, gap=target-numbers[i]; while(start &lt;= end) &#123; int m = start+(end-start)/2; if(numbers[m] == gap) return &#123;i+1,m+1&#125;; else if(numbers[m] &gt; gap) end=m-1; else start=m+1; &#125; &#125;&#125; https://discuss.leetcode.com/topic/7465/a-less-efficient-way-binary-search/6 My idea is to use binary search to find the largest number less than target and then use two pointers. https://discuss.leetcode.com/topic/32373/c-solution-simple-and-sweet C++ solution simple and sweet 1234567891011121314151617vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int l = 0; int r = numbers.size() -1; while(l &lt; r)&#123; if(numbers[l] + numbers[r] == target)&#123; vector&lt;int&gt; res&#123;l+1,r+1&#125;; return res; &#125; else if(numbers[l] + numbers[r] &gt; target)&#123; r--; &#125; else&#123; l++; &#125; &#125; &#125; https://discuss.leetcode.com/topic/21800/python-different-solutions-two-pointer-dictionary-binary-search Python different solutions (two-pointer, dictionary, binary search). 1234567891011# two-pointerdef twoSum1(self, numbers, target): l, r = 0, len(numbers)-1 while l &lt; r: s = numbers[l] + numbers[r] if s == target: return [l+1, r+1] elif s &lt; target: l += 1 else: r -= 1 1234567# dictionary def twoSum2(self, numbers, target): dic = &#123;&#125; for i, num in enumerate(numbers): if target-num in dic: return [dic[target-num]+1, i+1] dic[num] = i 12345678910111213# binary search def twoSum(self, numbers, target): for i in xrange(len(numbers)): l, r = i+1, len(numbers)-1 tmp = target - numbers[i] while l &lt;= r: mid = l + (r-l)//2 if numbers[mid] == tmp: return [i+1, mid+1] elif numbers[mid] &lt; tmp: l = mid+1 else: r = mid-1 my code 38ms, 89.75%, Dec.1st, 201612345678910111213141516class Solution(object): def twoSum(self, numbers, target): &quot;&quot;&quot; :type numbers: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; if len(numbers) &lt; 2: return [] i, j = 0, len(numbers)-1 while i &lt; j: if numbers[i] + numbers[j] &gt; target: j -= 1 elif numbers[i] + numbers[j] &lt; target: i += 1 else: return [i+1, j+1] 1ms, September 11, 2016 https://discuss.leetcode.com/topic/39962/java-7-line-simple-solution 1234567891011public class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int start = 0, end = numbers.length - 1; while(start &lt; end)&#123; if(numbers[start] + numbers[end] == target) break; if(numbers[start] + numbers[end] &lt; target) start++; else end--; &#125; return new int[]&#123;start+1, end+1&#125;; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>binary search</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[166. Fraction to Recurring Decimal]]></title>
    <url>%2Fp%2Fdff0e65f%2F</url>
    <content type="text"><![CDATA[17.1% Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. 12345For example,Given numerator = 1, denominator = 2, return &quot;0.5&quot;.Given numerator = 2, denominator = 1, return &quot;2&quot;.Given numerator = 2, denominator = 3, return &quot;0.(6)&quot;. Hint: No scary math, just apply elementary math knowledge. Still remember how to perform a long division? Try a long division on 4/9, the repeating part is obvious. Now try 4/333. Do you see a pattern? Be wary of edge cases! List out as many test cases as you can think of and test your code thoroughly. 方法一： 一个基本经验是，如果数字特别长，一定要转成long long 我的代码实现： 12345678910111213141516171819202122232425262728class Solution &#123;public: string fractionToDecimal(int numerator, int denominator) &#123; string res; if(numerator==0 || denominator==0) return to_string(0); if(numerator&lt;0&amp;&amp; denominator&gt;0 || numerator&gt;0&amp;&amp;denominator&lt;0) res = res + "-"; // 一个基本经验是，如果遇到数字可能会出现特别长的，一定要用long long long long nu = abs((long long)numerator); long long de = abs((long long)denominator); res += to_string(nu/de); if(nu%de==0) return res; res += "."; unordered_map&lt;int, int&gt; map; for(nu %= de; nu;nu %= de)&#123; if(map.find(nu)!=map.end())&#123; res.insert(map[nu], "("); res += ")"; break; &#125; map[nu] = res.size(); nu *= 10; res += to_string(nu/de); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/6079/accepted-cpp-solution-with-explainations Accepted cpp solution, with explainations 123456789101112131415161718192021222324252627282930313233343536373839404142434445// upgraded parameter typesstring fractionToDecimal(int64_t n, int64_t d) &#123; // zero numerator if (n == 0) return &quot;0&quot;; string res; // determine the sign if (n &lt; 0 ^ d &lt; 0) res += &apos;-&apos;; // remove sign of operands n = abs(n), d = abs(d); // append integral part res += to_string(n / d); // in case no fractional part if (n % d == 0) return res; res += &apos;.&apos;; unordered_map&lt;int, int&gt; map; // simulate the division process for (int64_t r = n % d; r; r %= d) &#123; // meet a known remainder // so we reach the end of the repeating part if (map.count(r) &gt; 0) &#123; res.insert(map[r], 1, &apos;(&apos;); res += &apos;)&apos;; break; &#125; // the remainder is first seen // remember the current position for it map[r] = res.size(); r *= 10; // append the quotient digit res += to_string(r / d); &#125; return res;&#125; https://discuss.leetcode.com/topic/17071/0ms-c-solution-with-detailed-explanations 0ms C++ Solution with Detailed Explanations Well, the key to this problem is on how to identify the recurring parts. After doing some examples using pen and paper, you may find that for the decimal parts to recur, the remainders should recur. So we need to maintain the remainders we have seen. Once we see a repeated remainder, we know that we have reached the end of the recurring parts and should enclose it with a ). However, we still need to insert the ( to the correct position. So we maintain a mapping from each remainder to the position of the corresponding quotient digit of it in the recurring parts. Then we use this mapping to retrieve the starting position of the recurring parts. Now we have solved the trickiest part of this problem. There are some remaining problems to solve to achieve a bug-free solution. Pay attention to the sign of the result; Handle cases that may cause overflow like numerator = -2147483648, denominator = -1 appropriately by using long long; Handle all the cases of (1) no fractional part; (2) fractional part does not recur; and (3) fractional part recurs respectively. To handle problem 3, we divide the division process into the integral part and the fractional part. For the fractional part, if it does not recur, then the remainder will become 0 at some point and we could return. If it does recur, the method metioned in the first paragraph has already handled it. Taking all these into considerations, we have the following code, which takes 0 ms :-) 1234567891011121314151617181920212223242526272829class Solution &#123;public: string fractionToDecimal(int numerator, int denominator) &#123; if (!numerator) return &quot;0&quot;; string res; if (numerator &lt; 0 ^ denominator &lt; 0) res += &apos;-&apos;; long numer = numerator &lt; 0 ? (long)numerator * (-1) : (long)numerator; long denom = denominator &lt; 0 ? (long)denominator * (-1) : (long)denominator; long integral = numer / denom; res += to_string(integral); long rmd = numer % denom; if (!rmd) return res; res += &apos;.&apos;; rmd *= 10; unordered_map&lt;long, long&gt; mp; while (rmd) &#123; long quotient = rmd / denom; if (mp.find(rmd) != mp.end()) &#123; res.insert(mp[rmd], 1, &apos;(&apos;); res += &apos;)&apos;; break; &#125; mp[rmd] = res.size(); res += to_string(quotient); rmd = (rmd % denom) * 10; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/7699/do-not-use-python-as-cpp-here-s-a-short-version-python-code Do not use python as cpp, here’s a short version python code Though python is slow, It is easy to write 12345678910111213141516class Solution:# @return a stringdef fractionToDecimal(self, numerator, denominator): n, remainder = divmod(abs(numerator), abs(denominator)) sign = &apos;-&apos; if numerator*denominator &lt; 0 else &apos;&apos; result = [sign+str(n), &apos;.&apos;] stack = [] while remainder not in stack: stack.append(remainder) n, remainder = divmod(remainder*10, abs(denominator)) result.append(str(n)) idx = stack.index(remainder) result.insert(idx+2, &apos;(&apos;) result.append(&apos;)&apos;) return &apos;&apos;.join(result).replace(&apos;(0)&apos;, &apos;&apos;).rstrip(&apos;.&apos;) and there’s no overflow https://discuss.leetcode.com/topic/9778/python-solution Python solution 123456789101112131415161718192021222324252627class Solution:# @return a stringdef fractionToDecimal(self, numerator, denominator): res=&quot;&quot; if numerator/denominator&lt;0: res+=&quot;-&quot; elif numerator%denominator==0: return str(numerator/denominator) numerator=abs(numerator) denominator=abs(denominator) res+=str(numerator/denominator) res+=&quot;.&quot; numerator%=denominator i=len(res) table=&#123;&#125; while numerator!=0: if numerator not in table.keys(): table[numerator]=i else: i=table[numerator] res=res[:i]+&quot;(&quot;+res[i:]+&quot;)&quot; return res numerator=numerator*10 res+=str(numerator/denominator) numerator%=denominator i+=1 return res Idea is to put every remainder into the hash table as a key, and the current length of the result string as the value. When the same remainder shows again, it’s circulating from the index of the value in the table.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>hash table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[165. Compare Version Numbers]]></title>
    <url>%2Fp%2F74b375a4%2F</url>
    <content type="text"><![CDATA[20.1% https://leetcode.com/problems/compare-version-numbers/ Compare two version numbers version1 and version2.If version1 &gt; version2 return 1, if version1 &lt; version2 return -1, otherwise return 0. You may assume that the version strings are non-empty and contain only digits and the . character.The . character does not represent a decimal point and is used to separate number sequences.For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision. 123Here is an example of version numbers ordering:0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37 方法一： 我的代码实现： 12345678910111213141516171819202122class Solution &#123;public: int compareVersion(string version1, string version2) &#123; int i = 0, j = 0; int num1 = 0, num2 = 0; int n1 = version1.size(), n2 = version2.size(); while(i&lt;n1 || j&lt;n2)&#123; while(i&lt;n1 &amp;&amp; version1[i]!='.') num1 = num1*10 + version1[i++]-'0'; while(j&lt;n2 &amp;&amp; version2[j]!='.') num2 = num2*10 + version2[j++] - '0'; if(num1&gt;num2) return 1; else if(num1&lt;num2) return -1; num1 = 0; num2 = 0; i++; j++; &#125; return 0; &#125;&#125;; 按照最简单的逻辑去做就行了。 12345678910111213141516171819202122232425262728293031int compareVersion(string version1, string version2) &#123; int i = 0; int j = 0; int n1 = version1.size(); int n2 = version2.size(); int num1 = 0; int num2 = 0; while(i&lt;n1 || j&lt;n2) // 此处用 ||，考虑1.0.1与1的情况 &#123; while(i&lt;n1 &amp;&amp; version1[i]!=&apos;.&apos;)&#123; num1 = num1*10+(version1[i]-&apos;0&apos;); i++; &#125; while(j&lt;n2 &amp;&amp; version2[j]!=&apos;.&apos;)&#123; num2 = num2*10+(version2[j]-&apos;0&apos;);; j++; &#125; if(num1&gt;num2) return 1; else if(num1 &lt; num2) return -1; num1 = 0; num2 = 0; i++; j++; &#125; return 0;&#125; cpphttps://discuss.leetcode.com/topic/11410/my-2ms-easy-solution-with-c-c 12345678910111213141516171819202122232425262728293031int compareVersion(string version1, string version2) &#123; int i = 0; int j = 0; int n1 = version1.size(); int n2 = version2.size(); int num1 = 0; int num2 = 0; while(i&lt;n1 || j&lt;n2) &#123; while(i&lt;n1 &amp;&amp; version1[i]!=&apos;.&apos;)&#123; num1 = num1*10+(version1[i]-&apos;0&apos;); i++; &#125; while(j&lt;n2 &amp;&amp; version2[j]!=&apos;.&apos;)&#123; num2 = num2*10+(version2[j]-&apos;0&apos;);; j++; &#125; if(num1&gt;num2) return 1; else if(num1 &lt; num2) return -1; num1 = 0; num2 = 0; i++; j++; &#125; return 0;&#125; https://discuss.leetcode.com/topic/6266/my-solutions-in-3-languages123456789101112131415161718192021class Solution &#123;public: int compareVersion(string version1, string version2) &#123; for (; version1 != version2; version1 = nextSubstr(version1), version2 = nextSubstr(version2)) &#123; int gap = stoi(version1) - stoi(version2); if (gap != 0) &#123; return gap &gt; 0 ? 1 : -1; &#125; &#125; return 0; &#125; string nextSubstr(string str) &#123; for (int i = 0; i &lt; str.size(); i++) &#123; if (str.at(i) == &apos;.&apos;) &#123; return str.substr(i + 1); &#125; &#125; return &quot;0&quot;; &#125;&#125;; https://discuss.leetcode.com/topic/8257/10-line-concise-solution-c This is a concise solution using stringstream to format string into int. 12345678910111213int compareVersion(string version1, string version2) &#123; for(auto&amp; w : version1) if (w == &apos;.&apos;) w=&apos; &apos;; for(auto&amp; w : version2) if (w == &apos;.&apos;) w=&apos; &apos;; istringstream s1(version1), s2(version2); while(1) &#123; int n1,n2; if (not(s1 &gt;&gt; n1) ) n1 = 0; if (not(s2 &gt;&gt; n2) ) n2 = 0; if (not s1 and not s2) return 0; if (n1&lt;n2) return -1; if (n1&gt;n2) return 1; &#125;&#125; pythonhttps://discuss.leetcode.com/topic/6266/my-solutions-in-3-languages1234567891011121314class Solution(object): def compareVersion(self, version1, version2): &quot;&quot;&quot; :type version1: str :type version2: str :rtype: int &quot;&quot;&quot; v1 = version1.split(&apos;.&apos;) v2 = version2.split(&apos;.&apos;) for i in range(max(len(v1), len(v2))): gap = (int(v1[i]) if i &lt; len(v1) else 0) - (int(v2[i]) if i &lt; len(v2) else 0) if gap != 0: return 1 if gap &gt; 0 else -1 return 0 https://discuss.leetcode.com/topic/18543/2-4-lines-python-3-different-ways Solution 1: Pad with izip_longest with fillvalue=0 123def compareVersion(self, version1, version2): splits = (map(int, v.split(&apos;.&apos;)) for v in (version1, version2)) return cmp(*zip(*itertools.izip_longest(*splits, fillvalue=0))) Solution 2: Pad with [0] * lengthDifference 1234def compareVersion(self, version1, version2): v1, v2 = (map(int, v.split(&apos;.&apos;)) for v in (version1, version2)) d = len(v2) - len(v1) return cmp(v1 + [0]*d, v2 + [0]*-d) Solution 3: Recursive, add zeros on the fly 12345def compareVersion(self, version1, version2): main1, _, rest1 = (&apos;0&apos; + version1).partition(&apos;.&apos;) main2, _, rest2 = (&apos;0&apos; + version2).partition(&apos;.&apos;) return cmp(int(main1), int(main2)) or \ len(rest1+rest2) and self.compareVersion(rest1, rest2) javahttps://discuss.leetcode.com/topic/6238/accepted-small-java-solution This code assumes that next level is zero if no mo levels in shorter version number. And than compare levels. 12345678910111213141516public int compareVersion(String version1, String version2) &#123; String[] levels1 = version1.split(&quot;\\.&quot;); String[] levels2 = version2.split(&quot;\\.&quot;); int length = Math.max(levels1.length, levels2.length); for (int i=0; i&lt;length; i++) &#123; Integer v1 = i &lt; levels1.length ? Integer.parseInt(levels1[i]) : 0; Integer v2 = i &lt; levels2.length ? Integer.parseInt(levels2[i]) : 0; int compare = v1.compareTo(v2); if (compare != 0) &#123; return compare; &#125; &#125; return 0;&#125; https://discuss.leetcode.com/topic/6266/my-solutions-in-3-languages123456789101112public class Solution &#123; public int compareVersion(String version1, String version2) &#123; String[] v1 = version1.split(&quot;\\.&quot;); String[] v2 = version2.split(&quot;\\.&quot;); for(int i=0; i&lt;Math.max(v1.length, v2.length); i++)&#123; int gap = (i &lt; v1.length ? Integer.parseInt(v1[i]) : 0) - (i &lt; v2.length ? Integer.parseInt(v2[i]) : 0); if(gap != 0) return gap &gt; 0 ? 1 : -1; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[164. Maximum Gap]]></title>
    <url>%2Fp%2F304b41e7%2F</url>
    <content type="text"><![CDATA[28.9% https://leetcode.com/problems/maximum-gap/?tab=Description Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Try to solve it in linear time/space. Return 0 if the array contains less than 2 elements. You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. 方法一: 类似于同排序 抽屉原则 https://discuss.leetcode.com/topic/13172/pigeon-hole-principle Pigeon hole principle Suppose you have n pigeons with labels and you put them into m holes based on their label with each hole of the same size. Why bother putting pigeons into holes? Because you want to disregard the distance between pigeons within each one hole. Only when at least one hole is empty can we disregard the distance between pigeons within each one hole and compute the maximum gap solely by the distance between pigeons in adjacent holes. We make sure that at least one hole is empty by using m=n-1 (i.e. n-2 pigeons in n-1 holes =&gt; at least one hole is empty). 123456789101112131415161718192021int maximumGap(vector&lt;int&gt;&amp; nums) &#123; const int n = nums.size(); if(n&lt;=1) return 0; int maxE = *max_element(nums.begin(),nums.end()); int minE = *min_element(nums.begin(),nums.end()); double len = double(maxE-minE)/double(n-1); vector&lt;int&gt; maxA(n,INT_MIN); vector&lt;int&gt; minA(n,INT_MAX); for(int i=0; i&lt;n; i++) &#123; int index = (nums[i]-minE)/len; maxA[index] = max(maxA[index],nums[i]); minA[index] = min(minA[index],nums[i]); &#125; int gap = 0, prev = maxA[0]; for(int i=1; i&lt;n; i++) &#123; if(minA[i]==INT_MAX) continue; gap = max(gap,minA[i]-prev); prev = maxA[i]; &#125; return gap; &#125; https://discuss.leetcode.com/topic/13172/pigeon-hole-principle/2 Great idea, get the essence of the problem. I’ll add some more explanations. We divide the range of array into array.size() interval, where k = (maximum-minimum) / n. [minimum, minimum + k), [minimum + k, minimum + 2k), … , [minimum + (n-1)k, maximum] And we uses two extra array “max_in_interval” and “min_in_interval” to record the maximum and minimum of each interval. First, let’s considering an uniformly distributed array of n numbers. By which I mean, [minimum, minimum + k), [minimum + k, minimum + 2k), … , [minimum + (n-1)k, maximum] n intervals each contains a single number. we could easily find the maximum gap by calculate min_in_interval[i+1] - max_in_interval[i] Now comes the most important observation. If any single interval contains more than 1 number, then there must be an empty interval, and maximum gap is larger than a single interval. By which I mean if multiple numbers appear in the same interval, we can safely ignore the numbers which lies in the middle of interval(not max_in_interval nor min_in_interval). Below comes my 16ms C++ AC solution. This is a minor defeact in it, but the test case does not catch it. I uses INT_MAX as a sentinel which should fails if the input array contains it as an element. 12345678910111213141516171819202122232425262728293031323334353637383940int maximumGap(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) return 0; int max = *max_element(nums.begin(), nums.end()); int min = *min_element(nums.begin(), nums.end()); double interval_length = double(max - min) / nums.size(); vector&lt;int&gt; max_in_interval(nums.size(), INT_MIN); vector&lt;int&gt; min_in_interval(nums.size(), INT_MAX); for (auto &amp;&amp;each : nums) &#123; size_t index = (each - min) / interval_length; // auto ceiling if (index == nums.size()) &#123; // in considering of float-point number round up index = nums.size() - 1; &#125; if (max_in_interval[index] &lt; each) &#123; max_in_interval[index] = each; &#125; if (min_in_interval[index] &gt; each) &#123; min_in_interval[index] = each; &#125; &#125; int gap = 0; int max_in_previous_interval = max_in_interval[0]; for (size_t i = 0; i &lt; nums.size() - 1; ++i) &#123; if (min_in_interval[i + 1] == INT_MAX) &#123; // skip the empty interval continue; &#125; else &#123; if (gap &lt; min_in_interval[i + 1] - max_in_previous_interval) &#123; gap = min_in_interval[i + 1] - max_in_previous_interval; &#125; max_in_previous_interval = max_in_interval[i + 1]; &#125; &#125; return gap;&#125; https://discuss.leetcode.com/topic/9986/my-c-code-12-ms-bucket-sort-o-n-time-and-space My C++ code (12 ms, “bucket sort”, O(n) time and space) The key is to use the fact that the lower bound of the gap is (maxV - minV )/ (sSize - 1). With such in mind, we can put all the num elements into different bucket with size (maxV - minV )/ (sSize - 1) (please note when such size is less than 1, then use 1 instead) and in such way, we only need to consider the min and max of each bucket and don’t need to worry the numbers in between of each bucket since the gaps among those elements are smaller than the bucket size, and then the lower bound of the gap, so they can not achieve the max gap. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: int maximumGap(vector&lt;int&gt; &amp;num) &#123; int sSize = num.size(); int i, res =0; int minV, maxV; int bucket_size, bucket_num, bucket_id; int maxGap = INT_MIN; int last_max; if(sSize&gt;1) &#123; minV = maxV = num[0]; for(i=1; i&lt;sSize; i++) &#123; if(minV &gt; num[i]) minV = num[i]; else if(maxV &lt; num[i]) maxV = num[i]; &#125; bucket_size = max(1, (maxV - minV )/ (sSize - 1))); bucket_num = (maxV - minV)/bucket_size + 1; if(bucket_num &lt;=1) return (maxV - minV); vector&lt;int&gt; bucket_max(bucket_num, INT_MIN); vector&lt;int&gt; bucket_min(bucket_num, INT_MAX); vector&lt;int&gt; bucket_count(bucket_num, 0); for(i=0; i&lt;sSize; i++) &#123; bucket_id = (num[i] - minV)/bucket_size; bucket_count[bucket_id]++; bucket_min[bucket_id] = bucket_min[bucket_id] &gt; num[i]? num[i]:bucket_min[bucket_id]; bucket_max[bucket_id] = bucket_max[bucket_id] &lt; num[i]? num[i]:bucket_max[bucket_id]; &#125; last_max = minV; for(i=0; i&lt;bucket_num; i++) &#123; if(bucket_count[i]&gt;0) &#123; maxGap = max(maxGap, bucket_min[i]- last_max); last_max = bucket_max[i]; &#125; &#125; return maxGap; &#125; return 0; &#125;&#125;; https://discuss.leetcode.com/topic/5996/i-solved-it-using-radix-sort I solved it using radix sort Since linear time and space is required and all nums are non-negative, radix sort seems to be fit.Here is the implementation. Any better ideas? 1234567891011121314151617181920212223242526class Solution: # @param num, a list of integer # @return an integer def maximumGap(self, num): if len(num) &lt; 2: return 0 num = self.radixSort(num) res = 0 for i in range(1, len(num)): res = max(num[i] - num[i - 1], res) return res def radixSort(self, num): for i in range(31): onebucket = [] zerobucket = [] needle = 1 &lt;&lt; i for j in range(len(num)): if num[j] &amp; needle != 0: onebucket.append(num[j]) else: zerobucket.append(num[j]) num = [] num += zerobucket num += onebucket return num https://discuss.leetcode.com/topic/41228/beat-99-81-java-coder Beat 99.81% java coder 12345678910111213141516171819202122232425262728public int maximumGap(int[] nums) &#123; int n = nums.length; if(n &lt; 2) return 0; int min = nums[0]; int max = nums[0]; for(int i = 1;i &lt; n;i++)&#123; if(min &gt; nums[i]) min = nums[i]; if(max &lt; nums[i]) max = nums[i]; &#125; int gap = (max-min)/(n-1); if(gap == 0) gap++; int len = (max-min)/gap+1; int [] tmax = new int [len]; int [] tmin = new int [len]; for(int i = 0;i &lt; n;i++)&#123; int index = (nums[i]-min)/gap; if(nums[i] &gt; tmax[index]) tmax[index] = nums[i]; if(tmin[index] == 0 || nums[i] &lt; tmin[index]) tmin[index] = nums[i]; &#125; int myMax = 0; for(int i = 0;i &lt; len;i++)&#123; if(myMax &lt; tmin[i]-min) myMax = tmin[i]-min; if(tmax[i] != 0) min = tmax[i]; &#125; return myMax;&#125; https://discuss.leetcode.com/topic/21003/12ms-c-suggested-solution 12ms C++ Suggested Solution This problem has a naive solution using sort and linear scan. The suggested solution uses the idea of bucket sort. The following is a C++ implementation of the suggested solution. Suppose all the n elements in nums fall within [l, u], the maximum gap will not be smaller than gap = (u - l) / (n - 1). However, this gap may become 0 and so we take the maximum of it with 1 to guarantee that the gap used to create the buckets is meaningful. Then there will be at most m = (u - l) / gap + 1 buckets. For each number num, it will fall in the k = (num - l) / gap bucket. After putting all elements of nums in the corresponding buckets, we can just scan the buckets to compute the maximum gap. The maximum gap is only dependent on the maximum number of the current bucket and the minimum number of the next neighboring bucket (the bucket should not be empty). So we only store the minimum and the maximum of each bucket. Each bucket is initialized as {minimum = INT_MAX, maximum = INT_MIN} and then updated while updating the buckets. Putting these together, we can have the following solution, barely a straight-forward implementation of the suggested solution. 1234567891011121314151617181920212223242526272829class Solution &#123;public: int maximumGap(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt; 2) return 0; auto lu = minmax_element(nums.begin(), nums.end()); int l = *lu.first, u = *lu.second; int gap = max((u - l) / (n - 1), 1); int m = (u - l) / gap + 1; vector&lt;int&gt; bucketsMin(m, INT_MAX); vector&lt;int&gt; bucketsMax(m, INT_MIN); for (int num : nums) &#123; int k = (num - l) / gap; if (num &lt; bucketsMin[k]) bucketsMin[k] = num; if (num &gt; bucketsMax[k]) bucketsMax[k] = num; &#125; int i = 0, j; gap = bucketsMax[0] - bucketsMin[0]; while (i &lt; m) &#123; j = i + 1; while (j &lt; m &amp;&amp; bucketsMin[j] == INT_MAX &amp;&amp; bucketsMax[j] == INT_MIN) j++; if (j == m) break; gap = max(gap, bucketsMin[j] - bucketsMax[i]); i = j; &#125; return gap; &#125;&#125;; https://discuss.leetcode.com/topic/34414/clean-c-implementation-of-3-linear-time-sort-alg-with-detailed-explaination Clean C++ implementation of 3 linear-time-sort-alg with detailed explaination As we can see, we should grasp all the 3 typical linear-time-sorting algorithm implementation.All the following 3 implementations have been modified from the GeeksForGeeks.I have change the counting sort implementation to support negative numbers.And the bucket support any float array input. counting sort [ stable ] [ support:+/- intergers ] radix sort [ use counting sort as sub-routine] [ support onlypositive intergers] bucket sort [support float : we need to change the array to in therange [0, 1) ] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/* counting sort Time O(N) Space O(N+range) *//* support : positive / negative arrays the last travese the array X : FORWARD-&gt;not stable BACKWARD-&gt;stable*/void countingSort(vector&lt;int&gt;&amp; X)&#123; int len = X.size(); int start = INT_MAX, end = INT_MIN; for (int i = 0; i &lt; len; i++)&#123; start = min(start, X[i]); end = max(end, X[i]); &#125; int range = end - start + 1; vector&lt;int&gt; count(range, 0); vector&lt;int&gt; result(len, 0); for (int i = 0; i &lt; len; i++)&#123; count[X[i]-start]++; &#125; for (int i = 1; i &lt; range; i++)&#123; count[i]=count[i-1]+count[i]; &#125; //for-ward traverse is not stable sorting //for (int i = 0; i &lt; len; i++) //back-ward traverse is stable sorting for (int i = len-1; i &gt;= 0; i--)&#123; //as we know that the count array recorded element should &apos;-1&apos; to get the index result[count[X[i] - start]-1] = X[i]; count[X[i] - start]--; &#125; for (int i = 0; i &lt; len; i++)&#123; X[i] = result[i]; &#125;&#125;/* Radix sort Time O(log(base,MAX)*(N+base)) Space O(constant) default:base=10 *//* support : only positive interger can only deal with positive integers or change the float number of the specified precision to intergers by multiplying 10^n */void countingSort(vector&lt;int&gt;&amp; X, int exp, int base)&#123; int len = X.size(); int start = INT_MAX, end = INT_MIN; for (int i = 0; i &lt; len; i++)&#123; start = min(start, (X[i] / exp)%base); end = max(end, (X[i] / exp) % base); &#125; int range = end - start + 1; vector&lt;int&gt; count(range, 0); vector&lt;int&gt; result(len, 0); for (int i = 0; i &lt; len; i++)&#123; count[(X[i] / exp) % base -start]++; &#125; for (int i = 1; i &lt; range; i++)&#123; count[i] = count[i - 1] + count[i]; &#125; //back-ward traverse is stable sorting for (int i = len - 1; i &gt;= 0; i--)&#123; //as we know that the count array recorded element should &apos;-1&apos; to get the index result[count[(X[i] / exp) % base -start] - 1] = X[i]; count[(X[i] / exp) % base - start]--; &#125; for (int i = 0; i &lt; len; i++)&#123; X[i] = result[i]; &#125;&#125;void radixSort(vector&lt;int&gt; &amp;X)&#123; int len = X.size(); int max_val = INT_MIN; int base = 10; for (int i = 0; i &lt; len; i++) max_val = max(X[i], max_val); for (int exp = 1; max_val / exp&gt;0; exp *= base)&#123; countingSort(X, exp, base); &#125;&#125;/* bubble sort Time Space *//* support : any float &amp; int numbers sort a large set of floating nubmers in range from 0.0 to 1.0 uniformly distributed across the range the key idea is : the insertion sort for all individual bucket is O(N)*/void bucketSort(vector&lt;float&gt;&amp; X)&#123; int len = X.size(); float max_val = X[0], min_val = X[0];; for (int i = 1; i &lt; len; i++) &#123; max_val = max(max_val, X[i]); min_val = min(min_val, X[i]); &#125; max_val++; vector&lt;vector&lt;float&gt;&gt; bucket(len, vector&lt;float&gt;()); for (int i = 0; i &lt; len; i++)&#123; int index = len*(X[i]-min_val)/(max_val-min_val); bucket[index].push_back(X[i]); &#125; for (int i = 0; i &lt; len; i++) sort(bucket[i].begin(), bucket[i].end()); int index = 0; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; bucket[i].size(); j++) X[index++] = bucket[i][j];&#125;/* test all the 3-linear-sorting-implementation */int main()&#123; vector&lt;int&gt; test1 = &#123; 11, -200, 14, -2000, 30, 400, 10, 22, 456 &#125;; countingSort(test1); cout &lt;&lt; endl&lt;&lt;&quot;counting Sort result: &quot;; for (int i = 0; i &lt; test1.size(); i++) cout &lt;&lt; test1[i] &lt;&lt;&quot; - &quot;; vector&lt;int&gt; test2 = &#123; 11, 200, 14, 2000, 30, 400, 10, 22, 456 &#125;; radixSort(test2); cout &lt;&lt; endl &lt;&lt; &quot;radix Sort result: &quot;; for (int i = 0; i &lt; test2.size(); i++) cout &lt;&lt; test2[i] &lt;&lt; &quot; - &quot;; vector&lt;float&gt; test3 = &#123; 11, -200, 14, -2000, 30, 400, 10, 22, 456 &#125;; bucketSort(test3); cout &lt;&lt; endl &lt;&lt; &quot;bucket Sort result: &quot;; for (int i = 0; i &lt; test3.size(); i++) cout &lt;&lt; test3[i] &lt;&lt; &quot; - &quot;; return 0;&#125; https://discuss.leetcode.com/topic/14353/my-concise-and-short-c-code-with-comment-explanation My concise and short c++ code with comment explanation 123456789101112131415161718192021222324252627int maximumGap(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if( n &lt; 2 ) return 0; int maxE = *max_element(nums.begin(),nums.end()); int minE = *min_element(nums.begin(),nums.end()); int len = maxE - minE; if( len &lt;= 1 ) return len; vector&lt;int&gt; buck_max(n, INT_MIN); vector&lt;int&gt; buck_min(n, INT_MAX); for(int i = 0; i &lt; n; i++) &#123; // note the divide and multiply order and the double cast // it&apos;s used to avoid the overflow and underflow during calculation int index = (double)( nums[i] - minE ) / len * ( n - 1 ); buck_max[index] = max(buck_max[index], nums[i]); buck_min[index] = min(buck_min[index], nums[i]); &#125; int gap = 0, pre = buck_max[0]; for(int i = 1; i &lt; n; i++) &#123; if( buck_max[i] == INT_MIN ) continue; gap = max(gap, buck_min[i] - pre); pre = buck_max[i]; &#125; return gap;&#125; https://discuss.leetcode.com/topic/5999/bucket-sort-java-solution-with-explanation-o-n-time-and-space [bucket sort] JAVA solution with explanation, O(N) time and space Suppose there are N elements in the array, the min value is min and the max value is max. Then the maximum gap will be no smaller than ceiling[(max - min ) / (N - 1)]. Let gap = ceiling[(max - min ) / (N - 1)]. We divide all numbers in the array into n-1 buckets, where k-th bucket contains all numbers in [min + (k-1)gap, min + k*gap). Since there are n-2 numbers that are not equal min or max and there are n-1 buckets, at least one of the buckets are empty. We only need to store the largest number and the smallest number in each bucket. After we put all the numbers into the buckets. We can scan the buckets sequentially and get the max gap.my blog for this problem 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public int maximumGap(int[] num) &#123; if (num == null || num.length &lt; 2) return 0; // get the max and min value of the array int min = num[0]; int max = num[0]; for (int i:num) &#123; min = Math.min(min, i); max = Math.max(max, i); &#125; // the minimum possibale gap, ceiling of the integer division int gap = (int)Math.ceil((double)(max - min)/(num.length - 1)); int[] bucketsMIN = new int[num.length - 1]; // store the min value in that bucket int[] bucketsMAX = new int[num.length - 1]; // store the max value in that bucket Arrays.fill(bucketsMIN, Integer.MAX_VALUE); Arrays.fill(bucketsMAX, Integer.MIN_VALUE); // put numbers into buckets for (int i:num) &#123; if (i == min || i == max) continue; int idx = (i - min) / gap; // index of the right position in the buckets bucketsMIN[idx] = Math.min(i, bucketsMIN[idx]); bucketsMAX[idx] = Math.max(i, bucketsMAX[idx]); &#125; // scan the buckets for the max gap int maxGap = Integer.MIN_VALUE; int previous = min; for (int i = 0; i &lt; num.length - 1; i++) &#123; if (bucketsMIN[i] == Integer.MAX_VALUE &amp;&amp; bucketsMAX[i] == Integer.MIN_VALUE) // empty bucket continue; // min value minus the previous value is the current gap maxGap = Math.max(maxGap, bucketsMIN[i] - previous); // update previous bucket value previous = bucketsMAX[i]; &#125; maxGap = Math.max(maxGap, max - previous); // updata the final max value gap return maxGap; &#125;&#125; https://discuss.leetcode.com/topic/22221/radix-sort-solution-in-java-with-explanation Radix sort solution in Java with explanation You can look at radix sort visualization here before reading the code: https://www.cs.usfca.edu/~galles/visualization/RadixSort.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123;public int maximumGap(int[] nums) &#123; if (nums == null || nums.length &lt; 2) &#123; return 0; &#125; // m is the maximal number in nums int m = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; m = Math.max(m, nums[i]); &#125; int exp = 1; // 1, 10, 100, 1000 ... int R = 10; // 10 digits int[] aux = new int[nums.length]; while (m / exp &gt; 0) &#123; // Go through all digits from LSB to MSB int[] count = new int[R]; for (int i = 0; i &lt; nums.length; i++) &#123; count[(nums[i] / exp) % 10]++; &#125; for (int i = 1; i &lt; count.length; i++) &#123; count[i] += count[i - 1]; &#125; for (int i = nums.length - 1; i &gt;= 0; i--) &#123; aux[--count[(nums[i] / exp) % 10]] = nums[i]; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; nums[i] = aux[i]; &#125; exp *= 10; &#125; int max = 0; for (int i = 1; i &lt; aux.length; i++) &#123; max = Math.max(max, aux[i] - aux[i - 1]); &#125; return max;&#125;&#125; The first step is to find the maximum value in nums array, it will be the threshold to end while loop. Then use the radix sort algorithm to sort based on each digit from Least Significant Bit (LSB) to Most Significant Bit (MSB), that’s exactly what’s showing in the link. (nums[i] / exp) % 10 is used to get the digit, for each digit, basically the digit itself serves as the index to access the count array. Count array stores the index to access aux array which stores the numbers after sorting based on the current digit. Finally, find the maximum gap from sorted array. Time and space complexities are both O(n). (Actually time is O(10n) at worst case for Integer.MAX_VALUE 2147483647)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[162. Find Peak Element]]></title>
    <url>%2Fp%2Feb35e778%2F</url>
    <content type="text"><![CDATA[36.3% https://leetcode.com/problems/find-peak-element/?tab=Description A peak element is an element that is greater than its neighbors. Given an input array where num[i] ≠ num[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that num[-1] = num[n] = -∞. 1For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2. Note: Your solution should be in logarithmic complexity. 方法一： my code: 题目要求log复杂度，这个是n复杂度，肯定是不够的。log复杂度肯定是二分搜索了。 1234567891011121314class Solution &#123;public: int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==1) return 0; for(int i=1; i&lt;n-1; i++) if(nums[i]&gt;nums[i-1] &amp;&amp; nums[i]&gt;nums[i+1]) return i; if(nums[0]&gt;nums[1]) return 0; if(nums[n-2]&lt;nums[n-1]) return n-1; &#125;&#125;; Sequential Search: 12345678910111213class Solution &#123;public: int findPeakElement(const vector&lt;int&gt; &amp;num) &#123; for(int i = 1; i &lt; num.size(); i ++) &#123; if(num[i] &lt; num[i-1]) &#123;// &lt; return i-1; &#125; &#125; return num.size()-1; &#125;&#125;; 方法二： 8ms, 4.79%, June.21th, 2016 https://leetcode.com/discuss/17793/find-the-maximum-by-binary-search-recursion-and-iteration Consider that each local maximum is one valid peak.My solution is to find one local maximum with binary search.Binary search satisfies the O(logn) computational complexity. Binary Search: recursion 123456789101112131415161718192021class Solution &#123;public:int findPeakElement(const vector&lt;int&gt; &amp;num) &#123; return Helper(num, 0, num.size()-1);&#125;int Helper(const vector&lt;int&gt; &amp;num, int low, int high)&#123; if(low == high) return low; else &#123; int mid1 = (low+high)/2; int mid2 = mid1+1; if(num[mid1] &gt; num[mid2]) return Helper(num, low, mid1); else return Helper(num, mid2, high); &#125;&#125;&#125;; 方法三： Binary Search: iteration 12345678910111213141516171819class Solution &#123;public: int findPeakElement(const vector&lt;int&gt; &amp;num) &#123; int low = 0; int high = num.size()-1; while(low &lt; high) &#123; int mid1 = (low+high)/2; int mid2 = mid1+1; if(num[mid1] &lt; num[mid2]) low = mid2; else high = mid1; &#125; return low; &#125;&#125;; cppSolution 1: 8ms, 4.79%, June.21th, 2016 https://leetcode.com/discuss/17793/find-the-maximum-by-binary-search-recursion-and-iteration 123456789class Solution &#123;public: int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; for(int i = 1; i &lt; nums.size(); i++) if(nums[i] &lt; nums[i-1]) return i-1; return nums.size() - 1; &#125;&#125;; Solution 2: 4ms, 84.77%, June.21th, 2016 https://leetcode.com/discuss/17793/find-the-maximum-by-binary-search-recursion-and-iteration 12345678910111213141516171819class Solution &#123;public: int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; return Helper(nums, 0, nums.size()-1); &#125; int Helper(const vector&lt;int&gt; &amp;nums, int low, int high)&#123; if(low == high) return low; else&#123; int mid1 = (low + high) / 2; int mid2 = mid1 + 1; if(nums[mid1] &gt; nums[mid2]) return Helper(nums, low, mid1); else return Helper(nums, mid2, high); &#125; &#125;&#125;; Solution 3: pythonSolution 1: 48ms, 82.40%, June.21th, 2016 https://leetcode.com/discuss/35744/my-clean-and-readable-python-solution 1234567891011121314151617181920class Solution(object): def findPeakElement(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; left = 0 right = len(nums)-1 while left &lt; right: mid = (left+right)/2 if nums[mid] &gt; nums[mid+1] and nums[mid] &gt; nums[mid-1]: return mid if nums[mid] &lt; nums[mid+1]: left = mid+1 else: right = mid-1 return left javaSolution 1: 0ms, 33.78%, June.21th, 2016 https://leetcode.com/discuss/18107/o-logn-solution-javacode 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public int findPeakElement(int[] num) &#123; return helper(num,0,num.length-1); &#125; public int helper(int[] num,int start,int end)&#123; if(start == end)&#123; return start; &#125;else if(start+1 == end)&#123; if(num[start] &gt; num[end]) return start; return end; &#125;else&#123; int m = (start+end)/2; if(num[m] &gt; num[m-1] &amp;&amp; num[m] &gt; num[m+1])&#123; return m; &#125;else if(num[m-1] &gt; num[m] &amp;&amp; num[m] &gt; num[m+1])&#123; return helper(num,start,m-1); &#125;else&#123; return helper(num,m+1,end); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[160. Intersection of Two Linked Lists]]></title>
    <url>%2Fp%2Fbf711257%2F</url>
    <content type="text"><![CDATA[30.2% https://leetcode.com/problems/intersection-of-two-linked-lists/description/ Write a program to find the node at which the intersection of two singly linked lists begins. 12345678For example, the following two linked lists:A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. 方法一： 剑指offer 37 Simple C++ solution (5 lines) Move cur1 (cur2) forward from headA (headB) and loop back to headB (headA), eventually cur1 and cur2 will meet at the intersection point or nullptr. 此代码的巧妙之处在于，1，头尾相接，2，判断条件是cur1!=cur2 12345678ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *cur1 = headA, *cur2 = headB; while(cur1 != cur2)&#123; cur1 = cur1?cur1-&gt;next:headB; cur2 = cur2?cur2-&gt;next:headA; &#125; return cur1;&#125; 我的代码实现： 1234567891011121314151617181920class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if(headA==NULL || headB==NULL) return NULL; ListNode* p1 = headA, *p2 = headB; if(p1==p2) return p1; while(p1 || p2)&#123; if(p1) p1 = p1-&gt;next; else p1 = headB; if(p2) p2 = p2-&gt;next; else p2 = headA; if(p1==p2) return p1; &#125; &#125;&#125;; 另一种实现方法 https://discuss.leetcode.com/topic/5527/my-accepted-simple-and-shortest-c-code-with-comments-explaining-the-algorithm-any-comments-or-improvements My accepted simple and shortest C++ code with comments explaining the algorithm. Any comments or improvements? 1234567891011121314151617181920212223242526272829ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *p1 = headA; ListNode *p2 = headB; if (p1 == NULL || p2 == NULL) return NULL; while (p1 != NULL &amp;&amp; p2 != NULL &amp;&amp; p1 != p2) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next; // // Any time they collide or reach end together without colliding // then return any one of the pointers. // if (p1 == p2) return p1; // // If one of them reaches the end earlier then reuse it // by moving it to the beginning of other list. // Once both of them go through reassigning, // they will be equidistant from the collision point. // if (p1 == NULL) p1 = headB; if (p2 == NULL) p2 = headA; &#125; return p1;&#125; cpp 46ms, 46.30%, October 15, 2016 https://discuss.leetcode.com/topic/5527/my-accepted-simple-and-shortest-c-code-with-comments-explaining-the-algorithm-any-comments-or-improvements My accepted simple and shortest C++ code with comments explaining the algorithm. Any comments or improvements? 1234567891011121314151617181920212223242526272829ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *p1 = headA; ListNode *p2 = headB; if (p1 == NULL || p2 == NULL) return NULL; while (p1 != NULL &amp;&amp; p2 != NULL &amp;&amp; p1 != p2) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next; // // Any time they collide or reach end together without colliding // then return any one of the pointers. // if (p1 == p2) return p1; // // If one of them reaches the end earlier then reuse it // by moving it to the beginning of other list. // Once both of them go through reassigning, // they will be equidistant from the collision point. // if (p1 == NULL) p1 = headB; if (p2 == NULL) p2 = headA; &#125; return p1;&#125; https://discuss.leetcode.com/topic/38444/simple-c-solution-5-lines Simple C++ solution (5 lines) Move cur1 (cur2) forward from headA (headB) and loop back to headB (headA), eventually cur1 and cur2 will meet at the intersection point or nullptr. 12345678ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *cur1 = headA, *cur2 = headB; while(cur1 != cur2)&#123; cur1 = cur1?cur1-&gt;next:headB; cur2 = cur2?cur2-&gt;next:headA; &#125; return cur1;&#125; python https://discuss.leetcode.com/topic/13419/concise-python-code-with-comments Concise python code with comments 1234567891011121314151617class Solution: # @param two ListNodes # @return the intersected ListNode def getIntersectionNode(self, headA, headB): if headA is None or headB is None: return None pa = headA # 2 pointers pb = headB while pa is not pb: # if either pointer hits the end, switch head and continue the second traversal, # if not hit the end, just move on to next pa = headB if pa is None else pa.next pb = headA if pb is None else pb.next return pa # only 2 ways to get out of the loop, they meet or the both hit the end=None the idea is if you switch head, the possible difference between length would be countered. On the second traversal, they either hit or miss. if they meet, pa or pb would be the node we are looking for, if they didn’t meet, they will hit the end at the same iteration, pa == pb == None, return either one of them is the same,None my code: 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): &quot;&quot;&quot; :type head1, head1: ListNode :rtype: ListNode &quot;&quot;&quot; if headA==None or headB==None: return None l1, l2 = headA, headB while l1 and l2 and l1!=l2: l1 = l1.next l2 = l2.next if l1==l2: return l1 if l1==None: l1=headB if l2==None: l2=headA return l1 java https://discuss.leetcode.com/topic/28067/java-solution-without-knowing-the-difference-in-len Java solution without knowing the difference in len! I found most solutions here preprocess linkedlists to get the difference in len.Actually we don’t care about the “value” of difference, we just want to make sure two pointers reach the intersection node at the same time. We can use two iterations to do that. In the first iteration, we will reset the pointer of one linkedlist to the head of another linkedlist after it reaches the tail node. In the second iteration, we will move two pointers until they points to the same node. Our operations in first iteration will help us counteract the difference. So if two linkedlist intersects, the meeting point in second iteration must be the intersection point. If the two linked lists have no intersection at all, then the meeting pointer in second iteration must be the tail node of both lists, which is null Below is my commented Java code: 12345678910111213141516public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; //boundary check if(headA == null || headB == null) return null; ListNode a = headA; ListNode b = headB; //if a &amp; b have different len, then we will stop the loop after second iteration while( a != b)&#123; //for the end of first iteration, we just reset the pointer to the head of another linkedlist a = a == null? headB : a.next; b = b == null? headA : b.next; &#125; return a;&#125; https://discuss.leetcode.com/topic/5492/concise-java-solution-o-1-memory-o-n-time Concise JAVA solution, O(1) memory O(n) time 1, Get the length of the two lists. 2, Align them to the same start point. 3, Move them together until finding the intersection point, or the end null 123456789101112131415161718192021222324252627public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; int lenA = length(headA), lenB = length(headB); // move headA and headB to the same start point while (lenA &gt; lenB) &#123; headA = headA.next; lenA--; &#125; while (lenA &lt; lenB) &#123; headB = headB.next; lenB--; &#125; // find the intersection until end while (headA != headB) &#123; headA = headA.next; headB = headB.next; &#125; return headA;&#125;private int length(ListNode node) &#123; int length = 0; while (node != null) &#123; node = node.next; length++; &#125; return length;&#125; 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode p1=headA, p2=headB; if(p1==null || p2==null) return null; while(p1!=null &amp;&amp; p2!=null &amp;&amp; p1!=p2)&#123; p1=p1.next; p2=p2.next; if(p1==p2) return p1; if(p1==null) p1=headB; if(p2==null) p2=headA; &#125; return p1; &#125;&#125; https://discuss.leetcode.com/topic/11626/share-my-simple-java-solution-o-n-time-o-1-space Share my simple java solution O(n) time, O(1) space Scan both lists For each list once it reaches the end, continue scanning the other list Once the two runner equal to each other, return the position Time O(n+m), space O(1) 1234567891011public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if( null==headA || null==headB ) return null; ListNode curA = headA, curB = headB; while( curA!=curB)&#123; curA = curA==null?headB:curA.next; curB = curB==null?headA:curB.next; &#125; return curA; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[159.Longest Substring with At Most Two Distinct Characters]]></title>
    <url>%2Fp%2F5c6ef69c%2F</url>
    <content type="text"><![CDATA[41.1% Given a string, find the length of the longest substring T that contains at most 2 distinct characters. For example, Given s = “eceba”, T is “ece” which its length is 3. 本题与 第3题，第76题都可以用同一个模板解决。 方法一: 12345678910int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; map(128,0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++&gt;0) counter++; while(counter&gt;0) if(map[s[begin++]]--&gt;1) counter--; d=max(d, end-begin); //while valid, update d &#125; return d; &#125; 我的代码实现，自己通过测试，但leetcode有锁，无法判断是否通过所有样例 123456789101112131415161718192021222324class Soulution&#123;public: int lengthOfLongestSubstringTwoDistinct(string s) &#123; int n = s.size(); if (n &lt;= 1) return n; int begin = 0, end = 0, d = 0, counter = 0; vector&lt;int&gt; indexs(256, 0); while (end &lt; n) &#123; if (indexs[s[end]] == 0) counter++; indexs[s[end]]++; end++; while (counter &gt; 2) &#123; if (indexs[s[begin]] == 1) counter--; indexs[s[begin]]--; begin++; &#125; d = max(d, end - begin); &#125; return d; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[155. Min Stack]]></title>
    <url>%2Fp%2F901eaa11%2F</url>
    <content type="text"><![CDATA[27.1% https://leetcode.com/problems/min-stack/ Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. 123456789Example:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 方法一： 两个栈，其中一个为辅助栈 123456789101112131415161718192021222324252627class MinStack &#123;private: stack&lt;int&gt; s1; stack&lt;int&gt; s2;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; s1.push(x); if(s2.empty() || x&lt;=getMin()) s2.push(x); &#125; void pop() &#123; if(s1.top() == getMin()) s2.pop(); s1.pop(); &#125; int top() &#123; return s1.top(); &#125; int getMin() &#123; return s2.top(); &#125;&#125;; 我的代码实现： 两个stack，注意stack有pop top方法，但是没有front方法 123456789101112131415161718192021222324252627282930313233343536373839class MinStack &#123;public: stack&lt;int&gt; st1; stack&lt;int&gt; st2; /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; st1.push(x); if(st2.empty() || x&lt;=st2.top()) st2.push(x); &#125; void pop() &#123; int x = st1.top(); if(x==st2.top()) st2.pop(); st1.pop(); &#125; int top() &#123; return st1.top(); &#125; int getMin() &#123; return st2.top(); &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 方法二： 一个stack 一个int min min表示当前的最小值，如果新的x不改变最小值，push进去。如果改变或者等于最小值，先把min压入，再把min更改为x，把x压入。 比如-2，0，-3则对应的是 [-2], -2 [-2, 0], -2 [-2, 0, -2, -3] -3 弹出 [-2, 0, -2, -3] -3 [-2, 0] -2 [-2] -2 这种思路好，只是增加了一些存储空间而已。 pop时，检查与min的关系。 我的代码实现： Dec 7th, 2017 12345678910111213141516171819202122232425262728293031323334353637383940414243class MinStack &#123; int min = INT_MAX; stack&lt;int&gt; stack1;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; if(x&lt;=min)&#123; stack1.push(min); min = x; &#125; stack1.push(x); &#125; void pop() &#123; int x = top(); stack1.pop(); if(x==min)&#123; min = stack1.top(); stack1.pop(); &#125; &#125; int top() &#123; return stack1.top(); &#125; int getMin() &#123; return min; &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 我的代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243class MinStack &#123;public: int min=INT_MAX; stack&lt;int&gt; st; /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; if(x&lt;=min)&#123; st.push(min); min = x; &#125; st.push(x); &#125; void pop() &#123; int x = st.top(); st.pop(); if(min == x)&#123; min = st.top(); st.pop(); &#125; &#125; int top() &#123; return st.top(); &#125; int getMin() &#123; return min; &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 注意这是java代码，找时间改写为c++版本 123456789101112131415161718192021222324252627class MinStack &#123; int min = Integer.MAX_VALUE; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); public void push(int x) &#123; // only push the old minimum value when the current // minimum value changes after pushing the new value x if(x &lt;= min)&#123; stack.push(min); min=x; &#125; stack.push(x); &#125; public void pop() &#123; // if pop operation could result in the changing of the current minimum value, // pop twice and change the current minimum value to the last minimum value. if(stack.pop() == min) min=stack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return min; &#125;&#125; 方法三： 一个stack，一个int min 此方法中，stack在空时，特殊处理。然后，对于新来的x，push其与min的差值，然后根据x与min 的差值决定更不更新min。pop时，相反处理。 相对于上一种方法，这种思想更加复杂一些，但是stack里保存的数据最少。 注意，java代码，找时间改写为c++版 12345678910111213141516171819202122232425262728293031323334353637383940public class MinStack &#123; long min; Stack&lt;Long&gt; stack; public MinStack()&#123; stack=new Stack&lt;&gt;(); &#125; public void push(int x) &#123; if (stack.isEmpty())&#123; stack.push(0L); min=x; &#125;else&#123; stack.push(x-min);//Could be negative if min value needs to change if (x&lt;min) min=x; &#125; &#125; public void pop() &#123; if (stack.isEmpty()) return; long pop=stack.pop(); if (pop&lt;0) min=min-pop;//If negative, increase the min value &#125; public int top() &#123; long top=stack.peek(); if (top&gt;0)&#123; return (int)(top+min); &#125;else&#123; return (int)(min); &#125; &#125; public int getMin() &#123; return (int)min; &#125;&#125; 56ms, September 13, 2016 https://discuss.leetcode.com/topic/18556/c-using-two-stacks-quite-short-and-easy-to-understand C++ using two stacks, quite short and easy to understand 123456789101112131415161718192021222324252627class MinStack &#123;private: stack&lt;int&gt; s1; stack&lt;int&gt; s2;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; s1.push(x); if(s2.empty() || x&lt;=getMin()) s2.push(x); &#125; void pop() &#123; if(s1.top() == getMin()) s2.pop(); s1.pop(); &#125; int top() &#123; return s1.top(); &#125; int getMin() &#123; return s2.top(); &#125;&#125;; https://discuss.leetcode.com/topic/28435/c-o-1-solution C++ O(1) solution 1234567891011121314151617181920212223242526272829class MinStack &#123;public: vector&lt;int&gt; a; vector&lt;int&gt; min; MinStack() &#123; min.push_back(2147483647); &#125; void push(int x) &#123; a.push_back(x); if (x &lt; min.back()) &#123; min.push_back(x); &#125; else &#123; min.push_back(min.back()); &#125; &#125; void pop() &#123; a.pop_back(); min.pop_back(); &#125; int top() &#123; return a.back(); &#125; int getMin() &#123; return min.back(); &#125;&#125;; https://discuss.leetcode.com/topic/11985/my-python-solution My Python solution 1234567891011121314151617181920212223242526272829303132class MinStack:def __init__(self): self.q = []# @param x, an integer# @return an integerdef push(self, x): curMin = self.getMin() if curMin == None or x &lt; curMin: curMin = x self.q.append((x, curMin));# @return nothingdef pop(self): self.q.pop()# @return an integerdef top(self): if len(self.q) == 0: return None else: return self.q[len(self.q) - 1][0]# @return an integerdef getMin(self): if len(self.q) == 0: return None else: return self.q[len(self.q) - 1][1] https://discuss.leetcode.com/topic/4953/share-my-java-solution-with-only-one-stack Share my Java solution with ONLY ONE stack The question is ask to construct One stack. So I am using one stack. The idea is to store the gap between the min value and the current value; The problem for my solution is the cast. I have no idea to avoid the cast. Since the possible gap between the current value and the min value could be Integer.MAX_VALUE-Integer.MIN_VALUE; 12345678910111213141516171819202122232425262728293031323334353637383940public class MinStack &#123; long min; Stack&lt;Long&gt; stack; public MinStack()&#123; stack=new Stack&lt;&gt;(); &#125; public void push(int x) &#123; if (stack.isEmpty())&#123; stack.push(0L); min=x; &#125;else&#123; stack.push(x-min);//Could be negative if min value needs to change if (x&lt;min) min=x; &#125; &#125; public void pop() &#123; if (stack.isEmpty()) return; long pop=stack.pop(); if (pop&lt;0) min=min-pop;//If negative, increase the min value &#125; public int top() &#123; long top=stack.peek(); if (top&gt;0)&#123; return (int)(top+min); &#125;else&#123; return (int)(min); &#125; &#125; public int getMin() &#123; return (int)min; &#125;&#125; https://discuss.leetcode.com/topic/7020/java-accepted-solution-using-one-stack Java accepted solution using one stack 123456789101112131415161718192021222324252627class MinStack &#123; int min = Integer.MAX_VALUE; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); public void push(int x) &#123; // only push the old minimum value when the current // minimum value changes after pushing the new value x if(x &lt;= min)&#123; stack.push(min); min=x; &#125; stack.push(x); &#125; public void pop() &#123; // if pop operation could result in the changing of the current minimum value, // pop twice and change the current minimum value to the last minimum value. if(stack.pop() == min) min=stack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return min; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[154. Find Minimum in Rotated Sorted Array II]]></title>
    <url>%2Fp%2F3156a2f3%2F</url>
    <content type="text"><![CDATA[36.5% https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/#/description Follow up for “Find Minimum in Rotated Sorted Array”:What if duplicates are allowed? Would this affect the run-time complexity? How and why?Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. The array may contain duplicates. 剑指offer 8， leetcode 153 方法一： 剑指offer解法，全面考虑问题，只有中间和两边三个值都相等时，才会出现无法判断情况，需要从头到尾遍历。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==1) return nums[0]; int left=0, right=n-1; int mid = left; while(nums[left]&gt;=nums[right])&#123; if(right-left==1)&#123; mid = right; break; &#125; mid = left+(right-left)/2; if(nums[left]==nums[mid] &amp;&amp; nums[mid]==nums[right]) return helper(nums, left, right); if(nums[left]&lt;=nums[mid]) left = mid; else if(nums[mid]&lt;=nums[right]) right = mid; &#125; return nums[mid]; &#125; int helper(vector&lt;int&gt; nums, int left, int right)&#123; int res = nums[left]; for(int i=left+1; i&lt;right+1; i++)&#123; res = min(nums[i], res); &#125; return res; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526272829class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int left=0, right=nums.size()-1; if(nums.size()==1) return nums[0]; while(nums[left]&gt;=nums[right])&#123; if(right-left==1) return nums[right]; int mid = left+(right-left)/2; if(nums[left]==nums[mid] &amp;&amp; nums[left]==nums[right]) return lineSearch(nums, left, right); if(nums[left]&gt;nums[mid])&#123; right = mid; &#125;else if(nums[left]&lt;=nums[mid])&#123; left = mid + 1; &#125; &#125; return nums[left]; &#125; int lineSearch(vector&lt;int&gt;&amp; nums, int left, int right)&#123; int pos = left; for(int i=left+1; i&lt;=right; i++)&#123; if(nums[i]&lt;nums[pos]) pos=i; &#125; return nums[pos]; &#125;&#125;; 方法二： 1234567891011121314151617181920212223class Solution &#123;public: int findMin(vector&lt;int&gt; &amp;num) &#123; int lo = 0; int hi = num.size() - 1; int mid = 0; while(lo &lt; hi) &#123; mid = lo + (hi - lo) / 2; if (num[mid] &gt; num[hi]) &#123; lo = mid + 1; &#125; else if (num[mid] &lt; num[hi]) &#123; hi = mid; &#125; else &#123; // when num[mid] and num[hi] are same hi--; &#125; &#125; return num[lo]; &#125;&#125;; When num[mid] == num[hi], we couldn’t sure the position of minimum in mid’s left or right, so just let upper bound reduce one. https://discuss.leetcode.com/topic/5182/rough-sketch-of-proof-why-o-lg-n-is-impossible Rough sketch of proof why O(lg N) is impossible Refer to this image: array config Big version here: http://postimg.org/image/asbbeo2c9/ There are generally 3 types of array config, assuming sorted from smallest to biggest. x-axis is the array index, y-axis is the element value. For non-duplicate case, you may use num[mid] &gt; num[end] to distinguish (1)&amp;(2) from (3), and thus safely eliminate half of the array, at each iteration. For dup case, it is not as straightforward (impossible?) to distinguish between (1), (2) and (3), and hence eliminate half of the array by doing O(1) comparison, at each iteration. 8ms, 20.55%, June.20th, 2016 https://leetcode.com/discuss/19746/my-pretty-simple-code-to-solve-it My pretty simple code to solve it 1234567891011121314151617181920212223class Solution &#123;public: int findMin(vector&lt;int&gt; &amp;num) &#123; int lo = 0; int hi = num.size() - 1; int mid = 0; while(lo &lt; hi) &#123; mid = lo + (hi - lo) / 2; if (num[mid] &gt; num[hi]) &#123; lo = mid + 1; &#125; else if (num[mid] &lt; num[hi]) &#123; hi = mid; &#125; else &#123; // when num[mid] and num[hi] are same hi--; &#125; &#125; return num[lo]; &#125;&#125;; When num[mid] == num[hi], we couldn’t sure the position of minimum in mid’s left or right, so just let upper bound reduce one. https://discuss.leetcode.com/topic/4253/one-simple-and-clear-method-with-o-1-space-and-worst-o-n-time One simple and clear method with O(1) space and worst O(n) time 123456789101112131415161718192021222324252627class Solution &#123;public: int findMin(vector&lt;int&gt; &amp;num) &#123; if(num.empty()) return 0; int i=0,j=num.size()-1; while(i&lt;j) &#123; int mid=(i+j)/2; if(num[j]&lt;num[mid])&#123; i=mid+1; &#125; else if(num[mid]&lt;num[j])&#123; j=mid; &#125; else&#123;//num[mid]==num[j] if(num[i]==num[mid])&#123;//linear complexity i++; j--; &#125; else j=mid; &#125; &#125; return num[j]; &#125;&#125;; https://discuss.leetcode.com/topic/4264/my-c-solution-24ms-is-there-any-better-solution My C++ solution 24ms is there any better solution ? 1234567891011121314151617181920212223class Solution &#123;public:int findMin(vector&lt;int&gt; &amp;num) &#123; int start = 0; int end = num.size()-1; int mid; while(start&lt;end)&#123; if(num[start]&lt;num[end]) break; mid = start+(end-start)/2; if(num[mid]&gt;num[end])&#123; start = mid+1; &#125; else if(num[mid]==num[end])&#123; start++; end--; &#125; else end= mid; &#125; return num[start]; &#125;&#125;; https://discuss.leetcode.com/topic/19165/8ms-13-lines-c-solution 8ms 13-lines C++ Solution This problem is more or less the same as Find Minimum in Rotated Sorted Array. And one key difference is as stated in the solution tag. That is, due to duplicates, we may not be able to throw one half sometimes. And in this case, we could just apply linear search and the time complexity will become O(n). The idea to solve this problem is still to use invariants. We set l to be the left pointer and r to be the right pointer. Since duplicates exist, the invatiant is nums[l] &gt;= nums[r] (if it does not hold, then nums[l] will simply be the minimum). We then begin binary search by comparing nums[l], nums[r] with nums[mid]. If nums[l] = nums[r] = nums[mid], simply apply linear search within nums[l..r]. If nums[mid] &lt;= nums[r], then the mininum cannot appear right to mid, so set r = mid; If nums[mid] &gt; nums[r], then mid is in the first larger half and r is in the second smaller half, so the minimum is to the right of mid: set l = mid + 1. The code is as follows. 123456789101112131415161718192021class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int l = 0, r = nums.size() - 1; while (nums[l] &gt;= nums[r]) &#123; int mid = (l &amp; r) + ((l ^ r) &gt;&gt; 1); if (nums[l] == nums[r] &amp;&amp; nums[mid] == nums[l]) return findMinLinear(nums, l, r); if (nums[mid] &lt;= nums[r]) r = mid; else l = mid + 1; &#125; return nums[l]; &#125; private: int findMinLinear(vector&lt;int&gt;&amp; nums, int l, int r) &#123; int minnum = nums[l]; for (int p = l + 1; p &lt;= r; p++) minnum = min(minnum, nums[p]); return minnum; &#125;&#125;; https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/ Python solution. Worst case O(N) 12345678910111213141516171819def findMin(self, nums): beg = 0 end = len(nums)-1 while beg &lt;= end: while beg &lt; end and nums[beg] == nums[beg + 1]: beg += 1 while end &gt; beg and nums[end] == nums[end - 1]: end -= 1 if beg == end: return nums[beg] mid = (beg+end)/2 if nums[mid] &gt; nums[end]: beg = mid + 1 else: end = mid return nums[beg] Solution Mime: 64ms, 20.87%, June.20th, 2016 1234567891011class Solution(object): def findMin(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; rtype = nums[0] for i in xrange(len(nums)): if nums[i] &lt; rtype: rtype = nums[i] return rtype Solution Mime: 52ms, 65.53%, June.20th, 2016 12345678910111213141516171819class Solution(object): def findMin(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; l = 0 r = len(nums) - 1 while(l &lt; r): if nums[l] &lt; nums[r]: return nums[l] mid = (l + r) / 2 if nums[mid] &gt; nums[r]: l = mid + 1 elif nums[mid] &lt; nums[r]: r = mid else: l += 1 return nums[l] 1ms, 6.02%, June.20th, 2016 https://leetcode.com/discuss/60147/super-simple-and-clean-java-binary-search 12345678910111213141516public class Solution &#123; public int findMin(int[] nums) &#123; int l = 0, r = nums.length-1; while (l &lt; r) &#123; int mid = (l + r) / 2; if (nums[mid] &lt; nums[r]) &#123; r = mid; &#125; else if (nums[mid] &gt; nums[r])&#123; l = mid + 1; &#125; else &#123; r--; //nums[mid]=nums[r] no idea, but we can eliminate nums[r]; &#125; &#125; return nums[l]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>binary search</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[153. Find Minimum in Rotated Sorted Array]]></title>
    <url>%2Fp%2F64895756%2F</url>
    <content type="text"><![CDATA[39.1% https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/#/description Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. 剑指offer 8 方法一： 我的代码实现： 12345678910111213141516171819202122class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return -1; if(n==1) return nums[0]; int left = 0, right = n-1; int mid = left; while(nums[left]&gt;nums[right])&#123; if(right-left==1)&#123; mid = right; break; &#125; mid = left + (right-left)/2; if(nums[left]&gt;nums[mid]) right = mid; else left = mid; &#125; return nums[mid]; &#125;&#125;; 剑指offer解法，有两种情况， nums[left] &lt; nums[right], 返回的结果就是nums[left] nums[left] &gt; nums[right]相对复杂一些。对于数组里只有两个的话，只要返回第二个就好了。否则，针对两种中间情况进行讨论就好了。 123456789101112131415161718192021class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==1) return nums[0]; int left=0, right=n-1; int mid = left; while(nums[left]&gt;nums[right])&#123; if(right-left==1)&#123; mid = right; break; &#125; mid = left+(right-left)/2; if(nums[left]&lt;nums[mid]) left = mid; else if(nums[mid]&lt;nums[right]) right = mid; &#125; return nums[mid]; &#125;&#125;; 我的代码实现： 1234567891011121314151617class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int left=0, right=nums.size()-1; while(nums[left]&gt;nums[right])&#123; if(right-left==1) return nums[right]; int mid = left+(right-left)/2; if(nums[mid]&lt;nums[right]) right = mid; else left = mid+1; &#125; return nums[left]; &#125;&#125;; 方法二： 我的代码实现： 123456789101112131415161718192021class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==0) return -1; if(n==1) return nums[0]; int left = 0, right = n-1; int mid; while(left&lt;right)&#123; if(nums[left]&lt;=nums[right]) return nums[left]; mid = left + (right-left)/2; // &lt;= 是考虑了left == mid的情况 if(nums[left]&lt;=nums[mid]) left = mid+1; else right = mid; &#125; return nums[left]; &#125;&#125;; 针对start和end进行循环，多重讨论而已。如果nums{start] &lt; nums[end]，则一定是顺序的了。返回结果。否则根据中间节点，选择讨论。得到两种情况。思路清晰明了。 123456789101112131415161718int findMin(vector&lt;int&gt; &amp;num) &#123; int start=0,end=num.size()-1; while (start&lt;end) &#123; if (num[start]&lt;num[end]) return num[start]; int mid = (start+end)/2; if (num[mid]&gt;=num[start]) &#123; start = mid+1; &#125; else &#123; end = mid; &#125; &#125; return num[start]; &#125; 方法三： 看起来挺厉害的一种方法啊。 12345678910111213141516171819202122class Solution &#123;public: int findMin(vector&lt;int&gt; &amp;num) &#123; int low = 0, high = num.size() - 1; // loop invariant: 1. low &lt; high // 2. mid != high and thus A[mid] != A[high] (no duplicate exists) // 3. minimum is between [low, high] // The proof that the loop will exit: after each iteration either the &apos;high&apos; decreases // or the &apos;low&apos; increases, so the interval [low, high] will always shrink. while (low &lt; high) &#123; auto mid = low + (high - low) / 2; if (num[mid] &lt; num[high]) // the mininum is in the left part high = mid; else if (num[mid] &gt; num[high]) // the mininum is in the right part low = mid + 1; &#125; return num[low]; &#125;&#125;; 4ms, 21.69%, June.19th, 2016 https://leetcode.com/discuss/13389/compact-and-clean-c-solution Compact and clean C++ solution Classic binary search problem. Looking at subarray with index [start,end]. We can find out that if the first member is less than the last member, there’s no rotation in the array. So we could directly return the first element in this subarray. If the first element is larger than the last one, then we compute the element in the middle, and compare it with the first element. If value of the element in the middle is larger than the first element, we know the rotation is at the second half of this array. Else, it is in the first half in the array. Welcome to put your comments and suggestions. 123456789101112131415161718int findMin(vector&lt;int&gt; &amp;num) &#123; int start=0,end=num.size()-1; while (start&lt;end) &#123; if (num[start]&lt;num[end]) return num[start]; int mid = (start+end)/2; if (num[mid]&gt;=num[start]) &#123; start = mid+1; &#125; else &#123; end = mid; &#125; &#125; return num[start]; &#125; Some corner cases will be discussed here https://discuss.leetcode.com/topic/14768/4ms-simple-c-code-with-explanation 4ms simple C++ code with explanation In this problem, we have only three cases. Case 1. The leftmost value is less than the rightmost value in the list: This means that the list is not rotated. e.g&gt; [1 2 3 4 5 6 7 ] Case 2. The value in the middle of the list is greater than the leftmost and rightmost values in the list. e.g&gt; [ 4 5 6 7 0 1 2 3 ] Case 3. The value in the middle of the list is less than the leftmost and rightmost values in the list. e.g&gt; [ 5 6 7 0 1 2 3 4 ] As you see in the examples above, if we have case 1, we just return the leftmost value in the list. If we have case 2, we just move to the right side of the list. If we have case 3 we need to move to the left side of the list. Following is the code that implements the concept described above. 123456789101112131415int findMin(vector&lt;int&gt;&amp; nums) &#123; int left = 0, right = nums.size() - 1; while(left &lt; right) &#123; if(nums[left] &lt; nums[right]) return nums[left]; int mid = (left + right)/2; if(nums[mid] &gt; nums[right]) left = mid + 1; else right = mid; &#125; return nums[left];&#125; https://discuss.leetcode.com/topic/5044/simplest-and-fastest-c-solution-o-lg-n-you-can-t-beat-this Simplest and fastest C++ solution O(lg N), you can’t beat this! Binary search: basically eliminate the impossible elements by half each time by exploiting the sorted property. 123456789int findMin(vector&lt;int&gt; &amp;num) &#123; int lo =0, hi = num.size()-1; while(lo&lt;hi)&#123; int mid=(lo+hi)/2; if(num[mid]&gt;num[hi]) lo=mid+1; else hi=mid; &#125; return num[lo];&#125; https://discuss.leetcode.com/topic/6112/a-concise-solution-with-proof-in-the-comment A concise solution with proof in the comment 12345678910111213141516171819202122class Solution &#123;public: int findMin(vector&lt;int&gt; &amp;num) &#123; int low = 0, high = num.size() - 1; // loop invariant: 1. low &lt; high // 2. mid != high and thus A[mid] != A[high] (no duplicate exists) // 3. minimum is between [low, high] // The proof that the loop will exit: after each iteration either the &apos;high&apos; decreases // or the &apos;low&apos; increases, so the interval [low, high] will always shrink. while (low &lt; high) &#123; auto mid = low + (high - low) / 2; if (num[mid] &lt; num[high]) // the mininum is in the left part high = mid; else if (num[mid] &gt; num[high]) // the mininum is in the right part low = mid + 1; &#125; return num[low]; &#125;&#125;; https://discuss.leetcode.com/topic/26884/9-line-python-clean-code 9-line python clean code Just use binary search 123456789101112131415class Solution(object): def findMin(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; i = 0 j = len(nums) - 1 while i &lt; j: m = i + (j - i) / 2 if nums[m] &gt; nums[j]: i = m + 1 else: j = m return nums[i] Solution Mine: 52ms, 50.58%, June.19th, 2016 1234567891011class Solution(object): def findMin(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; rtype = nums[0] for i in xrange(len(nums)-1): if nums[i] &gt; nums[i+1]: rtype = nums[i+1] return rtype Solution Mine: 64ms, 18.65%, June.19th, 2016 123456789101112131415class Solution(object): def findMin(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; l = 0 r = len(nums) - 1 while(l &lt; r): mid = (l + r) / 2 if nums[mid] &lt; nums[r]: r = mid else: l = mid + 1 return nums[l] Solution 1: 56ms, 34.04%, June.19th, 2016 https://leetcode.com/discuss/63514/9-line-python-clean-code 123456789101112131415class Solution(object): def findMin(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; l = 0 r = len(nums) - 1 while(l &lt; r): mid = (l + r) / 2 if nums[mid] &gt; nums[r]: l = mid + 1 else: r = mid return nums[l]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[152. Maximum Product Subarray]]></title>
    <url>%2Fp%2Fab8f143e%2F</url>
    <content type="text"><![CDATA[24.8% https://leetcode.com/problems/maximum-product-subarray/ Find the contiguous subarray within an array (containing at least one number) which has the largest product. 12For example, given the array [2,3,-2,4],the contiguous subarray [2,3] has the largest product = 6. 方法一： 与52题类似，那个是求和，这个是求积 我的代码实现： 123456789101112131415class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int res = nums[0]; int imin = nums[0], imax = nums[0]; for(int i=1; i&lt;nums.size(); i++)&#123; if(nums[i]&lt;0) swap(imin, imax); imin = min(nums[i], nums[i]*imin); imax = max(nums[i], nums[i]*imax); res = max(imax, res); &#125; return res; &#125;&#125;; 12345678910111213141516171819202122232425class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; // store the result that is the max we have found so far int r = nums[0], n = nums.size(); // imax/imin stores the max/min product of // subarray that ends with the current number A[i] for (int i = 1, imax = r, imin = r; i &lt; n; i++) &#123; // multiplied by a negative makes big number smaller, small number bigger // so we redefine the extremums by swapping them if (nums[i] &lt; 0) swap(imax, imin); // max/min product for the current number is either the current number itself // or the max/min by the previous number times the current one imax = max(nums[i], imax * nums[i]); imin = min(nums[i], imin * nums[i]); // the newly computed max value is a candidate for our global result r = max(r, imax); &#125; return r; &#125;&#125;; https://discuss.leetcode.com/topic/4417/possibly-simplest-solution-with-o-n-time-complexity Possibly simplest solution with O(n) time complexity 12345678910111213141516171819202122int maxProduct(int A[], int n) &#123; // store the result that is the max we have found so far int r = A[0]; // imax/imin stores the max/min product of // subarray that ends with the current number A[i] for (int i = 1, imax = r, imin = r; i &lt; n; i++) &#123; // multiplied by a negative makes big number smaller, small number bigger // so we redefine the extremums by swapping them if (A[i] &lt; 0) swap(imax, imin); // max/min product for the current number is either the current number itself // or the max/min by the previous number times the current one imax = max(A[i], imax * A[i]); imin = min(A[i], imin * A[i]); // the newly computed max value is a candidate for our global result r = max(r, imax); &#125; return r;&#125; my code: 12345678910111213141516class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int imax=nums[0], imin=nums[0]; int res=nums[0]; int tmax, tmin; for(int i=1; i&lt;nums.size(); i++)&#123; tmax = max(imax*nums[i], max(imin*nums[i], nums[i])); tmin = min(imax*nums[i], min(imin*nums[i], nums[i])); res = max(tmax, res); imax = tmax; imin = tmin; &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/22001/in-python-can-it-be-more-concise In Python, can it be more concise? 123456def maxProduct(nums): maximum=big=small=nums[0] for n in nums[1:]: big, small=max(n, n*big, n*small), min(n, n*big, n*small) maximum=max(maximum, big) return maximum java https://discuss.leetcode.com/topic/3607/sharing-my-solution-o-1-space-o-n-running-time Sharing my solution: O(1) space, O(n) running time 12345678910111213141516171819public int maxProduct(int[] A) &#123; if (A.length == 0) &#123; return 0; &#125; int maxherepre = A[0]; int minherepre = A[0]; int maxsofar = A[0]; int maxhere, minhere; for (int i = 1; i &lt; A.length; i++) &#123; maxhere = Math.max(Math.max(maxherepre * A[i], minherepre * A[i]), A[i]); minhere = Math.min(Math.min(maxherepre * A[i], minherepre * A[i]), A[i]); maxsofar = Math.max(maxhere, maxsofar); maxherepre = maxhere; minherepre = minhere; &#125; return maxsofar;&#125; Note: There’s no need to use O(n) space, as all that you need is a minhere and maxhere. (local max and local min), then you can get maxsofar (which is global max) from them. There’s a chapter in Programming Pearls 2 that discussed the MaxSubArray problem, the idea is similar. https://discuss.leetcode.com/topic/5161/simple-java-code Simple Java code Loop through the array, each time remember the max and min value for the previous product, the most important thing is to update the max and min value: we have to compare among max A[i], min A[i] as well as A[i], since this is product, a negative * negative could be positive. 1234567891011121314151617public class Solution &#123; public int maxProduct(int[] A) &#123; if (A == null || A.length == 0) &#123; return 0; &#125; int max = A[0], min = A[0], result = A[0]; for (int i = 1; i &lt; A.length; i++) &#123; int temp = max; max = Math.max(Math.max(max * A[i], min * A[i]), A[i]); min = Math.min(Math.min(temp * A[i], min * A[i]), A[i]); if (max &gt; result) &#123; result = max; &#125; &#125; return result; &#125;&#125; https://discuss.leetcode.com/topic/3581/share-my-dp-code-that-got-ac Share my DP code that got AC 123456789101112131415161718public class Solution &#123; public int maxProduct(int[] A) &#123; if (A == null || A.length == 0) &#123; return 0; &#125; int[] f = new int[A.length]; int[] g = new int[A.length]; f[0] = A[0]; g[0] = A[0]; int res = A[0]; for (int i = 1; i &lt; A.length; i++) &#123; f[i] = Math.max(Math.max(f[i - 1] * A[i], g[i - 1] * A[i]), A[i]); g[i] = Math.min(Math.min(f[i - 1] * A[i], g[i - 1] * A[i]), A[i]); res = Math.max(res, f[i]); &#125; return res; &#125;&#125; f[i] means maximum product that can be achieved ending with i g[i] means minimum product that can be achieved ending with i]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[151. Reverse Words in a String]]></title>
    <url>%2Fp%2Fc9db0a7a%2F</url>
    <content type="text"><![CDATA[15.7% https://leetcode.com/problems/reverse-words-in-a-string/ Given an input string, reverse the string word by word. 123For example,Given s = &quot;the sky is blue&quot;,return &quot;blue is sky the&quot;. Update (2015-02-12): For C programmers: Try to solve it in-place in O(1) space. Clarification: What constitutes a word? A sequence of non-space characters constitutes a word. Could the input string contain leading or trailing spaces? Yes. However, your reversed string should not contain leading or trailing spaces. How about multiple spaces between two words? Reduce them to a single space in the reversed string. 方法一： 我的代码实现： Oct 17， 2017 123456789101112131415161718192021class Solution &#123;public: void reverseWords(string &amp;s) &#123; if(s.empty()) return; reverse(s.begin(), s.end()); int start = 0; int i = 0; for(; i&lt;s.size(); i++)&#123; if(s[i]!=' ')&#123; if(start!=0) s[start++] = ' '; int j = i; while(j&lt;s.size() &amp;&amp; s[j]!=' ') s[start++] = s[j++]; reverse(s.begin()+start-(j-i), s.begin()+start); i = j; &#125; &#125; // s.erase(s.begin()+start) 只会删除指定点的字符 s.erase(s.begin()+start, s.end()); return; &#125;&#125;; 9ms, 28.03%, October 14, 2016 https://discuss.leetcode.com/topic/3298/in-place-simple-solution First, reverse the whole string, then reverse each word. 有疑问，为何最后使用erase，同时中间为何s[storeIndex++]=s[j++]? 1234567891011121314151617class Solution &#123;public: void reverseWords(string &amp;s) &#123; reverse(s.begin(), s.end()); int storeIndex = 0; for(int i=0; i&lt;s.size(); i++)&#123; if(s[i] != &apos; &apos;)&#123; if(storeIndex!=0) s[storeIndex++] = &apos; &apos;; int j = i; while(j &lt; s.size() &amp;&amp; s[j] != &apos; &apos;) s[storeIndex++] = s[j++]; reverse(s.begin()+storeIndex-(j-i), s.begin()+storeIndex); i = j; &#125; &#125; s.erase(s.begin()+storeIndex, s.end()); &#125;&#125;; https://discuss.leetcode.com/topic/5319/c-solution-in-place-runtime-o-n-memory-o-1 The idea is to ignore the extra spaces, reverse words one by one and reverse the whole string in the end.I think for the interview it is good to show that substr or istringstream can be used too.The idea is taken from here 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: // function to reverse any part of string from i to j (just one word or entire string) void reverseword(string &amp;s, int i, int j)&#123; while(i&lt;j)&#123; char t=s[i]; s[i++]=s[j]; s[j--]=t; &#125; &#125; void reverseWords(string &amp;s) &#123; int i=0, j=0; int l=0; int len=s.length(); int wordcount=0; while(true)&#123; while(i&lt;len &amp;&amp; s[i] == &apos; &apos;) i++; // skip spaces in front of the word if(i==len) break; if(wordcount) s[j++]=&apos; &apos;; l=j; while(i&lt;len &amp;&amp; s[i] != &apos; &apos;) &#123;s[j]=s[i]; j++; i++;&#125; reverseword(s,l,j-1); // reverse word in place wordcount++; &#125; s.resize(j); // resize result string reverseword(s,0,j-1); // reverse whole string &#125;&#125;; https://discuss.leetcode.com/topic/3087/accepted-simple-cpp-code-in-just-a-few-lines Accepted simple cpp code in just a few lines 1234567891011121314151617class Solution &#123;public: void reverseWords(string &amp;s) &#123; string result; int pos = 0; for (int i = 0; i &lt; s.size(); i ++)&#123; if (s[i] == &apos; &apos;)&#123; if (i &gt; pos ) result = s.substr(pos,i-pos)+ &quot; &quot; + result ; pos = i + 1; &#125; else if (i == s.size()-1) result = s.substr(pos,s.size()-pos)+&quot; &quot;+result; &#125; s = result.substr(0,result.size()-1) ; &#125;&#125;; https://discuss.leetcode.com/topic/10199/5-lines-c-using-stringstream 5 lines C++ using 1234567void reverseWords(string &amp;s) &#123; istringstream is(s); string tmp; is &gt;&gt; s; while(is &gt;&gt; tmp) s = tmp + &quot; &quot; + s; if(s[0] == &apos; &apos;) s = &quot;&quot;;&#125; javahttps://discuss.leetcode.com/topic/2742/my-accepted-java-solution I’m splitting on the regex for one-or-more whitespace, this takes care of multiple spaces/tabs/newlines/etc in the input. Since the input could have leading/trailing whitespace, which would result in empty matches, I first trim the input string. Now there could be three possibilities: The input is empty: “”, parts will contain [“”]. The for loop is skipped and “” + “” is returned. The input contains only one part: “a”, parts will contain [“a”]. The for loop is skipped and “” + “a” is returned. The input contains multiple parts: “a b c”, reverse the order of all but the first part: “c b “ in the for loop and return “c b “ + “a”. Obviously this is not the fastest or most memory efficient way to solve the problem, but optimizations should only be done when they are needed. Readable code is usually more important than efficient code. How to make it efficient? Use a StringBuilder to concatenate the string parts, instead of concatenating strings directly. This will (I assume) build something like a linked-list of string parts, and only allocate the new string when you need it, instead of on each concatenation. Iterate over the string, instead of using trim/split. Store the index of the last character in the word, when you find the first character, copy the substring to the output string. Instead of using substring, insert the word-characters directly in the StringBuilder. Assuming they’re using a linked-list or tree, this could be a whole last faster. 12345678910public class Solution &#123; public String reverseWords(String s) &#123; String[] parts = s.trim().split(&quot;\\s+&quot;); String out = &quot;&quot;; for (int i = parts.length - 1; i &gt; 0; i--) &#123; out += parts[i] + &quot; &quot;; &#125; return out + parts[0]; &#125;&#125; https://discuss.leetcode.com/topic/18189/clean-java-two-pointers-solution-no-trim-no-split-no-stringbuilder Clean Java two-pointers solution (no trim( ), no split( ), no StringBuilder) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Solution &#123; public String reverseWords(String s) &#123; if (s == null) return null; char[] a = s.toCharArray(); int n = a.length; // step 1. reverse the whole string reverse(a, 0, n - 1); // step 2. reverse each word reverseWords(a, n); // step 3. clean up spaces return cleanSpaces(a, n); &#125; void reverseWords(char[] a, int n) &#123; int i = 0, j = 0; while (i &lt; n) &#123; while (i &lt; j || i &lt; n &amp;&amp; a[i] == &apos; &apos;) i++; // skip spaces while (j &lt; i || j &lt; n &amp;&amp; a[j] != &apos; &apos;) j++; // skip non spaces reverse(a, i, j - 1); // reverse the word &#125; &#125; // trim leading, trailing and multiple spaces String cleanSpaces(char[] a, int n) &#123; int i = 0, j = 0; while (j &lt; n) &#123; while (j &lt; n &amp;&amp; a[j] == &apos; &apos;) j++; // skip spaces while (j &lt; n &amp;&amp; a[j] != &apos; &apos;) a[i++] = a[j++]; // keep non spaces while (j &lt; n &amp;&amp; a[j] == &apos; &apos;) j++; // skip spaces if (j &lt; n) a[i++] = &apos; &apos;; // keep only one space &#125; return new String(a).substring(0, i); &#125; // reverse a[] from a[i] to a[j] private void reverse(char[] a, int i, int j) &#123; while (i &lt; j) &#123; char t = a[i]; a[i++] = a[j]; a[j--] = t; &#125; &#125; &#125; https://discuss.leetcode.com/topic/11785/java-3-line-builtin-solution Java 3-line builtin solution 12345public String reverseWords(String s) &#123; String[] words = s.trim().split(&quot; +&quot;); Collections.reverse(Arrays.asList(words)); return String.join(&quot; &quot;, words);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[150. Evaluate Reverse Polish Notation]]></title>
    <url>%2Fp%2F37aff2ee%2F</url>
    <content type="text"><![CDATA[26.4% Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. 123Some examples: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] -&gt; ((2 + 1) * 3) -&gt; 9 [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] -&gt; (4 + (13 / 5)) -&gt; 6 https://discuss.leetcode.com/topic/1323/6-132-0-or-1 6/（-132）= 0 or -1 when I test [“10”,”6”,”9”,”3”,”+”,”-11”,””,”/“,””,”17”,”+”,”5”,”+”], in this program, the result I got is 12, I think I am right. Because when I calculate 6/(-132) = -1, not 0, so i think the result is 12 not 22. Accepted C++ recursive solution (56 ms) with explanation. Simplest possible? Algorithm: pop string from the end of the vector if it’s number, just return it if it’s operation, call function recursively for 2nd operand and 1st 12345678910111213int evalRPN(vector&lt;string&gt; &amp;n) &#123;string s = n.back(); n.pop_back();if ( s== &quot;&quot; || s==&quot;/&quot; || s==&quot;+&quot; || s == &quot;-&quot; )&#123;int r2 = evalRPN(n);int r1 = evalRPN(n);if ( s==&quot;&quot;) return r1*r2;if ( s==&quot;/&quot;) return r1/r2;if ( s==&quot;+&quot;) return r1+r2;if ( s==&quot;-&quot;) return r1-r2;&#125;elsereturn atoi(s.c_str());&#125; https://discuss.leetcode.com/topic/38178/fancy-c-lambda-expression-solution Fancy C++ lambda expression solution 123456789101112131415161718192021222324class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; unordered_map&lt;string, function&lt;int (int, int) &gt; &gt; map = &#123; &#123; &quot;+&quot; , [] (int a, int b) &#123; return a + b; &#125; &#125;, &#123; &quot;-&quot; , [] (int a, int b) &#123; return a - b; &#125; &#125;, &#123; &quot;*&quot; , [] (int a, int b) &#123; return a * b; &#125; &#125;, &#123; &quot;/&quot; , [] (int a, int b) &#123; return a / b; &#125; &#125; &#125;; std::stack&lt;int&gt; stack; for (string&amp; s : tokens) &#123; if (!map.count(s)) &#123; stack.push(stoi(s)); &#125; else &#123; int op1 = stack.top(); stack.pop(); int op2 = stack.top(); stack.pop(); stack.push(map[s](op2, op1)); &#125; &#125; return stack.top(); &#125;&#125;; https://discuss.leetcode.com/topic/21965/python-solution-with-comments-don-t-use-eval-function Python solution with comments (don’t use eval() function). 12345678910111213141516171819202122def evalRPN(self, tokens): stack = [] for t in tokens: if t not in [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;]: stack.append(int(t)) else: r, l = stack.pop(), stack.pop() if t == &quot;+&quot;: stack.append(l+r) elif t == &quot;-&quot;: stack.append(l-r) elif t == &quot;*&quot;: stack.append(l*r) else: # here take care of the case like &quot;1/-22&quot;, # in Python 2.x, it returns -1, while in # Leetcode it should return 0 if l*r &lt; 0 and l % r != 0: stack.append(l/r+1) else: stack.append(l/r) return stack.pop() https://discuss.leetcode.com/topic/15344/a-simple-python-solution-o-n-72ms A simple Python solution - O(n) 72ms 123456789101112131415161718192021222324class Solution: # @param &#123;string[]&#125; tokens # @return &#123;integer&#125; def __init__(self): self.operators = &#123; &apos;+&apos;: lambda y, x: x + y, &apos;-&apos;: lambda y, x: x - y, &apos;*&apos;: lambda y, x: x * y, &apos;/&apos;: lambda y, x: int(operator.truediv(x, y)) &#125; def evalRPN(self, tokens): if not tokens: return 0 stack = [] for token in tokens: if token in self.operators: stack.append(self.operators[token](stack.pop(), stack.pop())) else: stack.append(int(token)) return stack[0]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[149. Max Points on a Line]]></title>
    <url>%2Fp%2F138e238c%2F</url>
    <content type="text"><![CDATA[15.5% https://leetcode.com/problems/max-points-on-a-line/#/description Given n points on a 2D plane, find the maximum number of points that lie on the same straight line. https://discuss.leetcode.com/topic/6028/sharing-my-simple-solution-with-explanation Sharing my simple solution with explanation 1234567891011121314151617181920212223242526int maxPoints(vector&lt;Point&gt; &amp;points) &#123; int result = 0; for(int i = 0; i &lt; points.size(); i++)&#123; int samePoint = 1; unordered_map&lt;double, int&gt; map; for(int j = i + 1; j &lt; points.size(); j++)&#123; if(points[i].x == points[j].x &amp;&amp; points[i].y == points[j].y)&#123; samePoint++; &#125; else if(points[i].x == points[j].x)&#123; map[INT_MAX]++; &#125; else&#123; double slope = double(points[i].y - points[j].y) / double(points[i].x - points[j].x); map[slope]++; &#125; &#125; int localMax = 0; for(auto it = map.begin(); it != map.end(); it++)&#123; localMax = max(localMax, it-&gt;second); &#125; localMax += samePoint; result = max(result, localMax); &#125; return result;&#125; First, let’s talk about mathematics. How to determine if three points are on the same line? The answer is to see if slopes of arbitrary two pairs are the same. Second, let’s see what the minimum time complexity can be. Definitely, O(n^2). It’s because you have to calculate all slopes between any two points. Then let’s go back to the solution of this problem. In order to make this discussion simpler, let’s pick a random point A as an example. Given point A, we need to calculate all slopes between A and other points. There will be three cases: Some other point is the same as point A. Some other point has the same x coordinate as point A, which will result to a positive infinite slope. General case. We can calculate slope. We can store all slopes in a hash table. And we find which slope shows up mostly. Then add the number of same points to it. Then we know the maximum number of points on the same line for point A. We can do the same thing to point B, point C… Finally, just return the maximum result among point A, point B, point C… https://discuss.leetcode.com/topic/2709/c-o-n-2-solution-for-your-reference Hint by @stellari “For each point pi, calculate the slope of each line it forms with all other points with greater indices, i.e. pi+1, pi+2, …, and use a map to record how many lines have the same slope (If two lines have the same slope and share a common point, then the two lines must be the same one). By doing so, you can easily find how many points are on the same line that ends at pi in O(n). Thus the amortized running time of the whole algorithm is O(n^2).” In order to avoid using double type(the slope k) as map key, I used pair (int a, int b) as the key where a=pj.x-pi.x, b=pj.y-pi.y, and k=b/a. Using greatest common divider of a and b to divide both a, b ensures that lines with same slope have the same key. I also handled two special cases: (1) when two points are on a vertical line (2) when two points are the same. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: int maxPoints(vector&lt;Point&gt; &amp;points) &#123; if(points.size()&lt;2) return points.size(); int result=0; for(int i=0; i&lt;points.size(); i++) &#123; map&lt;pair&lt;int, int&gt;, int&gt; lines; int localmax=0, overlap=0, vertical=0; for(int j=i+1; j&lt;points.size(); j++) &#123; if(points[j].x==points[i].x &amp;&amp; points[j].y==points[i].y) &#123; overlap++; continue; &#125; else if(points[j].x==points[i].x) vertical++; else &#123; int a=points[j].x-points[i].x, b=points[j].y-points[i].y; int gcd=GCD(a, b); a/=gcd; b/=gcd; lines[make_pair(a, b)]++; localmax=max(lines[make_pair(a, b)], localmax); &#125; localmax=max(vertical, localmax); &#125; result=max(result, localmax+overlap+1); &#125; return result; &#125;private: int GCD(int a, int b) &#123; if(b==0) return a; else return GCD(b, a%b); &#125;&#125;; https://discuss.leetcode.com/topic/12877/20-line-c-o-n-2-hashing-solution The idea is straight forward. Calculate each slope between two points and handle two special cases: 1. vertical, 2. duplicate. 1234567891011121314151617181920212223242526class Solution &#123;public: int maxPoints(vector&lt;Point&gt;&amp; points) &#123; if(points.size()&lt;=2) return points.size(); int res=0; for(int i=0;i&lt;points.size()-1;i++) &#123; int numVertical=1,local=1,duplicate=0; unordered_map&lt;double,int&gt; map; for(int j=i+1;j&lt;points.size();j++) if(points[i].x==points[j].x) // special cases if(points[i].y==points[j].y) // duplicate duplicate++; else // vertical numVertical++; else &#123; double slope=(points[i].y-points[j].y)*1.0/(points[i].x-points[j].x); map[slope]==0?map[slope]=2:map[slope]++; local=max(local,map[slope]); &#125; local=max(local+duplicate,numVertical+duplicate); res=max(res,local); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/18447/16ms-28ms-c-solutions-with-explanations 16ms/28ms C++ Solutions with Explanations This problem has a naive idea, which is to traverse all possible pairs of two points and see how many other points fall in the line determined by them. This idea is of O(n^3) time complexity and will meet TLE. Well, let’s focus on lines instead of pairs of points. Could we just find out how many points fall in all possible lines? The answer is yes. Remember that a line is determined by its slope and intercept. In fact, if two lines with the same slope share a common point, then they are just the same line. So to determine a line, we need its slope and a point. Now comes the idea to solve this problem. We start from a specific point p, and compute all the slopes of the lines between p and the remaining points. Then those with the same slopes will be the same line. We can find out the maximum number of points fall on a line containing p. We exhaust all possible p’s and record the largest number we have seen. This number is just answer. Well, there are still two special cases to handle: Duplicate points: a pair of duplicate points give no determined line, so we just count the number of duplicates and add them to the result. Vertical lines: the slope of these lines is infinity mathematically. We simply set it to be INT_MAX in the following code. Now we have the following code, using an unordered_map&lt;float, int&gt; slopes to record how many points fall in the line of a specific slope and containing points[i]. Since all the operations of unordered_map is O(1), this code is of O(n^2) complexity. 12345678910111213141516171819202122232425class Solution &#123;public: int maxPoints(vector&lt;Point&gt;&amp; points) &#123; unordered_map&lt;float, int&gt; slopes; int maxp = 0, n = points.size(); for (int i = 0; i &lt; n; i++) &#123; slopes.clear(); int duplicate = 1; for (int j = i + 1; j &lt; n; j++) &#123; if (points[j].x == points[i].x &amp;&amp; points[j].y == points[i].y) &#123; duplicate++; continue; &#125; float slope = (points[j].x == points[i].x) ? INT_MAX : (float)(points[j].y - points[i].y) / (points[j].x - points[i].x); slopes[slope]++; &#125; maxp = max(maxp, duplicate); for (auto slope : slopes) if (slope.second + duplicate &gt; maxp) maxp = slope.second + duplicate; &#125; return maxp; &#125;&#125;; Well, since the representation of floating point numbers is sometimes inaccurate, we may use a more safer way to represent the slope (dy / dx), which is to record dx and dy in a pair&lt;int, int&gt;. However, once we use pair&lt;int, int&gt; for the key of the map, we cannot use an unordered_map since pair&lt;int, int&gt; is unhashable. We now change to map and the time complexity becomes O(n^2logn). Also, since dy = 4, dx = 2 and dy = 8, dx = 4 represents the same slope, we need to divide both of them by their gcd first. The code is as follows. The logic is the same of the one above, just introducing pair and gcd. 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public: int maxPoints(vector&lt;Point&gt;&amp; points) &#123; map&lt;pair&lt;int, int&gt;, int&gt; slopes; int maxp = 0, n = points.size(); for (int i = 0; i &lt; n; i++) &#123; slopes.clear(); int duplicate = 1; for (int j = i + 1; j &lt; n; j++) &#123; if (points[j].x == points[i].x &amp;&amp; points[j].y == points[i].y) &#123; duplicate++; continue; &#125; int dx = points[j].x - points[i].x; int dy = points[j].y - points[i].y; int dvs = gcd(dx, dy); slopes[make_pair(dx / dvs, dy / dvs)]++; &#125; maxp = max(maxp, duplicate); for (auto slope : slopes) if (slope.second + duplicate &gt; maxp) maxp = slope.second + duplicate; &#125; return maxp; &#125;private: int gcd(int num1, int num2) &#123; while (num2) &#123; int temp = num2; num2 = num1 % num2; num1 = temp; &#125; return num1; &#125;&#125;; https://discuss.leetcode.com/topic/21896/python-68-ms-code Python 68 ms code 1234567891011121314151617def maxPoints(self, points): l = len(points) m = 0 for i in range(l): dic = &#123;&apos;i&apos;: 1&#125; same = 0 for j in range(i+1, l): tx, ty = points[j].x, points[j].y if tx == points[i].x and ty == points[i].y: same += 1 continue if points[i].x == tx: slope = &apos;i&apos; else:slope = (points[i].y-ty) * 1.0 /(points[i].x-tx) if slope not in dic: dic[slope] = 1 dic[slope] += 1 m = max(m, max(dic.values()) + same)return m https://discuss.leetcode.com/topic/2979/a-java-solution-with-notes A line is determined by two factors,say y=ax+b If two points(x1,y1) (x2,y2) are on the same line(Of course). Consider the gap between two points. We have (y2-y1)=a(x2-x1),a=(y2-y1)/(x2-x1) a is a rational, b is canceled since b is a constant If a third point (x3,y3) are on the same line. So we must have y3=ax3+b Thus,(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a Since a is a rational, there exists y0 and x0, y0/x0=(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a So we can use y0&amp;x0 to track a line; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for a point. * class Point &#123; * int x; * int y; * Point() &#123; x = 0; y = 0; &#125; * Point(int a, int b) &#123; x = a; y = b; &#125; * &#125; */public class Solution&#123; public int maxPoints(Point[] points) &#123; if (points==null) return 0; if (points.length&lt;=2) return points.length; Map&lt;Integer,Map&lt;Integer,Integer&gt;&gt; map = new HashMap&lt;Integer,Map&lt;Integer,Integer&gt;&gt;(); int result=0; for (int i=0;i&lt;points.length;i++)&#123; map.clear(); int overlap=0,max=0; for (int j=i+1;j&lt;points.length;j++)&#123; int x=points[j].x-points[i].x; int y=points[j].y-points[i].y; if (x==0&amp;&amp;y==0)&#123; overlap++; continue; &#125; int gcd=generateGCD(x,y); if (gcd!=0)&#123; x/=gcd; y/=gcd; &#125; if (map.containsKey(x))&#123; if (map.get(x).containsKey(y))&#123; map.get(x).put(y, map.get(x).get(y)+1); &#125;else&#123; map.get(x).put(y, 1); &#125; &#125;else&#123; Map&lt;Integer,Integer&gt; m = new HashMap&lt;Integer,Integer&gt;(); m.put(y, 1); map.put(x, m); &#125; max=Math.max(max, map.get(x).get(y)); &#125; result=Math.max(result, max+overlap+1); &#125; return result; &#125; private int generateGCD(int a,int b)&#123; if (b==0) return a; else return generateGCD(b,a%b); &#125;&#125; https://discuss.leetcode.com/topic/24011/accepted-java-solution-easy-to-understand1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a point. * class Point &#123; * int x; * int y; * Point() &#123; x = 0; y = 0; &#125; * Point(int a, int b) &#123; x = a; y = b; &#125; * &#125; */public class Solution &#123; public int maxPoints(Point[] points) &#123; if(points.length &lt;= 0) return 0; if(points.length &lt;= 2) return points.length; int result = 0; for(int i = 0; i &lt; points.length; i++)&#123; HashMap&lt;Double, Integer&gt; hm = new HashMap&lt;Double, Integer&gt;(); int samex = 1; int samep = 0; for(int j = 0; j &lt; points.length; j++)&#123; if(j != i)&#123; if((points[j].x == points[i].x) &amp;&amp; (points[j].y == points[i].y))&#123; samep++; &#125; if(points[j].x == points[i].x)&#123; samex++; continue; &#125; double k = (double)(points[j].y - points[i].y) / (double)(points[j].x - points[i].x); if(hm.containsKey(k))&#123; hm.put(k,hm.get(k) + 1); &#125;else&#123; hm.put(k, 2); &#125; result = Math.max(result, hm.get(k) + samep); &#125; &#125; result = Math.max(result, samex); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>hash table</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[148. Sort List]]></title>
    <url>%2Fp%2F41f5a08%2F</url>
    <content type="text"><![CDATA[27.7% https://leetcode.com/problems/sort-list/?tab=Description Sort a linked list in O(n log n) time using constant space complexity. 归并排序 微信面试题：使用快速排序，对链表进行排序 方法一： 归并排序 https://discuss.leetcode.com/topic/17150/clean-and-short-merge-sort-solution-in-c Clean and short Merge sort Solution in c++ 12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* merge( ListNode* head1 , ListNode * head2)&#123; ListNode* d = new ListNode (0); // dummy node ListNode* e = d; while(head1||head2)&#123; if(head1 &amp;&amp; (!head2 || head1-&gt;val &lt;= head2 -&gt; val) )&#123; e=e-&gt;next= head1 ; head1 = head1 -&gt; next; &#125; if(head2 &amp;&amp; (!head1 || head2-&gt;val &lt; head1 -&gt; val) )&#123; e=e-&gt;next= head2 ; head2 = head2 -&gt; next; &#125; &#125; e-&gt;next = NULL; return d-&gt;next; &#125; ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* slow = head; ListNode* fast =head-&gt;next; while(fast &amp;&amp; fast-&gt;next)&#123; // to find middle node fast= fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; ListNode* headb = slow-&gt;next; // headb is start of 2nd half of list slow-&gt;next = NULL; return merge(sortList(head) , sortList(headb)); &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* fast = head, *slow = head; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; ListNode* tmp = slow-&gt;next; slow-&gt;next = NULL; ListNode* head1 = sortList(head); ListNode* head2 = sortList(tmp); ListNode* node = merge(head1, head2); return node; &#125; ListNode* merge(ListNode* head1, ListNode* head2)&#123; if(head1==NULL) return head2; if(head2==NULL) return head1; if(head1-&gt;val&lt;=head2-&gt;val)&#123; head1-&gt;next = merge(head1-&gt;next, head2); return head1; &#125;else&#123; head2-&gt;next = merge(head1, head2-&gt;next); return head2; &#125; &#125;&#125;; 方法二： 使用147题的插入排序，效率O(n^2)不能满足要求 超时 方法三： 归并排序 我的代码实现: 有bug 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* slow = head, *fast = head; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; fast = slow-&gt;next; slow-&gt;next = nullptr; sortList(head); sortList(fast); return merge(head, fast); &#125; ListNode* merge(ListNode* l1, ListNode* l2)&#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = merge(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = merge(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/10382/bottom-to-up-not-recurring-with-o-1-space-complextity-and-o-nlgn-time-complextity Bottom-to-up(not recurring) with o(1) space complextity and o(nlgn) time complextity this problem can be easily solved using recurrence and divide-and-conquer. But it consumes program stack to store the recurring function stack frame, actually it consumes o(lgn) space complexity. Recursion use up-to-bottom strategy , why not try the opposite way–bottom-to-up, luckily it works, it only consumes 0(1) space complexity and o(nlgn) time complextity. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Merge sort use bottom-up policy, * so Space Complexity is O(1) * Time Complexity is O(NlgN) * stable sort*/class Solution &#123;public: ListNode *sortList(ListNode *head) &#123; if(!head || !(head-&gt;next)) return head; //get the linked list&apos;s length ListNode* cur = head; int length = 0; while(cur)&#123; length++; cur = cur-&gt;next; &#125; ListNode dummy(0); dummy.next = head; ListNode *left, *right, *tail; for(int step = 1; step &lt; length; step &lt;&lt;= 1)&#123; cur = dummy.next; tail = &amp;dummy; while(cur)&#123; left = cur; right = split(left, step); cur = split(right,step); tail = merge(left, right, tail); &#125; &#125; return dummy.next; &#125;private: /** * Divide the linked list into two lists, * while the first list contains first n ndoes * return the second list&apos;s head */ ListNode* split(ListNode *head, int n)&#123; //if(!head) return NULL; for(int i = 1; head &amp;&amp; i &lt; n; i++) head = head-&gt;next; if(!head) return NULL; ListNode *second = head-&gt;next; head-&gt;next = NULL; return second; &#125; /** * merge the two sorted linked list l1 and l2, * then append the merged sorted linked list to the node head * return the tail of the merged sorted linked list */ ListNode* merge(ListNode* l1, ListNode* l2, ListNode* head)&#123; ListNode *cur = head; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &gt; l2-&gt;val)&#123; cur-&gt;next = l2; cur = l2; l2 = l2-&gt;next; &#125; else&#123; cur-&gt;next = l1; cur = l1; l1 = l1-&gt;next; &#125; &#125; cur-&gt;next = (l1 ? l1 : l2); while(cur-&gt;next) cur = cur-&gt;next; return cur; &#125;&#125;; https://discuss.leetcode.com/topic/3085/my-o-n-log-n-time-o-1-space-solution My O(n log n) time, O(1) space solution Nice problem. I use a non-recurisve way to write merge sort. For example, the size of ListNode is 8, Round #1 block_size = 1 (a1, a2), (a3, a4), (a5, a6), (a7, a8) Compare a1 with a2, a3 with a4 … Round #2 block_size = 2 (a1, a2, a3, a4), (a5, a6, a7, a8) merge two sorted arrays (a1, a2) and (a3, a4), then merge tow sorted arrays(a5, a6) and (a7, a8) Round #3 block_size = 4 (a1, a2, a3, a4, a5, a6, a7, a8) merge two sorted arrays (a1, a2, a3, a4), and (a5, a6, a7, a8) No need for round #4 cause block_size = 8 &gt;= n = 8 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: int count_size(ListNode *node)&#123; int n = 0; while (node != NULL)&#123; node = node-&gt;next; ++n; &#125; return n; &#125; ListNode *sortList(ListNode *head) &#123; int block_size = 1, n = count_size(head), iter = 0, i = 0, a = 0, b = 0; ListNode virtual_head(0); ListNode *last = NULL, *it = NULL, *A = NULL, *B = NULL, *tmp = NULL; virtual_head.next = head; while (block_size &lt; n)&#123; iter = 0; last = &amp;virtual_head; it = virtual_head.next; while (iter &lt; n)&#123; a = min(n - iter, block_size); b = min(n - iter - a, block_size); A = it; if (b != 0)&#123; for (i = 0; i &lt; a - 1; ++i) it = it-&gt;next; B = it-&gt;next; it-&gt;next = NULL; it = B; for (i = 0; i &lt; b - 1; ++i) it = it-&gt;next; tmp = it-&gt;next; it-&gt;next = NULL; it = tmp; &#125; while (A || B)&#123; if (B == NULL || (A != NULL &amp;&amp; A-&gt;val &lt;= B-&gt;val))&#123; last-&gt;next = A; last = last-&gt;next; A = A-&gt;next; &#125; else &#123; last-&gt;next = B; last = last-&gt;next; B = B-&gt;next; &#125; &#125; last-&gt;next = NULL; iter += a + b; &#125; block_size &lt;&lt;= 1; &#125; return virtual_head.next; &#125;&#125;; python https://discuss.leetcode.com/topic/30407/clean-python-code Clean python code 12345678910111213141516171819202122class Solution(object): def merge(self, h1, h2): dummy = tail = ListNode(None) while h1 and h2: if h1.val &lt; h2.val: tail.next, tail, h1 = h1, h1, h1.next else: tail.next, tail, h2 = h2, h2, h2.next tail.next = h1 or h2 return dummy.next def sortList(self, head): if not head or not head.next: return head pre, slow, fast = None, head, head while fast and fast.next: pre, slow, fast = slow, slow.next, fast.next.next pre.next = None return self.merge(*map(self.sortList, (head, slow))) java https://discuss.leetcode.com/topic/18100/java-merge-sort-solution Java merge sort solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public ListNode sortList(ListNode head) &#123; if (head == null || head.next == null) return head; // step 1. cut the list to two halves ListNode prev = null, slow = head, fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; prev = slow; slow = slow.next; fast = fast.next.next; &#125; prev.next = null; // step 2. sort each half ListNode l1 = sortList(head); ListNode l2 = sortList(slow); // step 3. merge l1 and l2 return merge(l1, l2); &#125; ListNode merge(ListNode l1, ListNode l2) &#123; ListNode l = new ListNode(0), p = l; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt; l2.val) &#123; p.next = l1; l1 = l1.next; &#125; else &#123; p.next = l2; l2 = l2.next; &#125; p = p.next; &#125; if (l1 != null) p.next = l1; if (l2 != null) p.next = l2; return l.next; &#125;&#125; https://discuss.leetcode.com/topic/643/i-have-a-pretty-good-mergesort-method-can-anyone-speed-up-the-run-time-or-reduce-the-memory-usage I have a pretty good MergeSort method. Can anyone speed up the run time or reduce the memory usage? 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode sortList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode f = head.next.next; ListNode p = head; while (f != null &amp;&amp; f.next != null) &#123; p = p.next; f = f.next.next; &#125; ListNode h2 = sortList(p.next); p.next = null; return merge(sortList(head), h2); &#125; public ListNode merge(ListNode h1, ListNode h2) &#123; ListNode hn = new ListNode(Integer.MIN_VALUE); ListNode c = hn; while (h1 != null &amp;&amp; h2 != null) &#123; if (h1.val &lt; h2.val) &#123; c.next = h1; h1 = h1.next; &#125; else &#123; c.next = h2; h2 = h2.next; &#125; c = c.next; &#125; if (h1 != null) c.next = h1; if (h2 != null) c.next = h2; return hn.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[147. Insertion Sort List]]></title>
    <url>%2Fp%2Fcd2ad8e1%2F</url>
    <content type="text"><![CDATA[32.2% Sort a linked list using insertion sort. 方法一： 常规的插入排序，改成针对链表排序。 插入排序，每次从后向前走，这里每次从前向后走，找到插入位置。因为链表插入时O(1)空间，所以一样的。 我的代码实现： Oct 11th, 2017 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(head==nullptr || head-&gt;next==nullptr) return head; ListNode* dummy = new ListNode(-1); ListNode* p1 = head, *p2 = dummy, *p3; while(p1!=nullptr)&#123; p2 = dummy; while(p2-&gt;next!=nullptr &amp;&amp; p2-&gt;next-&gt;val &lt;= p1-&gt;val)&#123; p2 = p2-&gt;next; &#125; p3 = p1-&gt;next; p1-&gt;next = p2-&gt;next; p2-&gt;next = p1; p1 = p3; &#125; return dummy-&gt;next; &#125;&#125;; my code 新建一个新节点，ListNode* dummy = new ListNode(0); 12345678910111213141516171819202122class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; if(head==NULL || head-&gt;next==NULL) return head; ListNode* cur; cur=head-&gt;next; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; head-&gt;next = NULL; while(cur!=NULL)&#123; ListNode* tmp = cur-&gt;next; head = dummy; while(head-&gt;next!=NULL &amp;&amp; head-&gt;next-&gt;val &lt; cur-&gt;val) head = head-&gt;next; cur-&gt;next = head-&gt;next; head-&gt;next = cur; cur = tmp; &#125; return dummy-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/8570/an-easy-and-clear-way-to-sort-o-1-space An easy and clear way to sort ( O(1) space ) 12345678910111213141516171819202122232425public ListNode insertionSortList(ListNode head) &#123; if( head == null )&#123; return head; &#125; ListNode helper = new ListNode(0); //new starter of the sorted list ListNode cur = head; //the node will be inserted ListNode pre = helper; //insert node between pre and pre.next ListNode next = null; //the next node will be inserted //not the end of input list while( cur != null )&#123; next = cur.next; //find the right place to insert while( pre.next != null &amp;&amp; pre.next.val &lt; cur.val )&#123; pre = pre.next; &#125; //insert between pre and pre.next cur.next = pre.next; pre.next = cur; pre = helper; cur = next; &#125; return helper.next; &#125; https://discuss.leetcode.com/topic/14916/explained-c-solution-24ms Explained C++ solution (24ms) Well, life gets difficult pretty soon whenever the same operation on array is transferred to linked list. First, a quick recap of insertion sort: Start from the second element (simply a[1] in array and the annoying head -&gt; next -&gt; val in linked list), each time when we see a node with val smaller than its previous node, we scan from the head and find the position that the current node should be inserted. Since a node may be inserted before head, we create a new_head that points to head. The insertion operation, however, is a little easier for linked list. Now comes the code: 1234567891011121314151617181920212223242526class Solution &#123; public: ListNode* insertionSortList(ListNode* head) &#123; ListNode* new_head = new ListNode(0); new_head -&gt; next = head; ListNode* pre = new_head; ListNode* cur = head; while (cur) &#123; if (cur -&gt; next &amp;&amp; cur -&gt; next -&gt; val &lt; cur -&gt; val) &#123; while (pre -&gt; next &amp;&amp; pre -&gt; next -&gt; val &lt; cur -&gt; next -&gt; val) pre = pre -&gt; next; /* Insert cur -&gt; next after pre.*/ ListNode* temp = pre -&gt; next; pre -&gt; next = cur -&gt; next; cur -&gt; next = cur -&gt; next -&gt; next; pre -&gt; next -&gt; next = temp; /* Move pre back to new_head. */ pre = new_head; &#125; else cur = cur -&gt; next; &#125; ListNode* res = new_head -&gt; next; delete new_head; return res; &#125;&#125;; https://discuss.leetcode.com/topic/1855/accepted-solution-using-java Accepted Solution using JAVA 12345678910111213141516public ListNode insertionSortList(ListNode head) &#123; ListNode helper=new ListNode(0); ListNode pre=helper; ListNode current=head; while(current!=null) &#123; pre=helper; while(pre.next!=null&amp;&amp;pre.next.val&lt;current.val) &#123; pre=pre.next; &#125; ListNode next=current.next; current.next=pre.next; pre.next=current; current=next; &#125; return helper.next;&#125; https://discuss.leetcode.com/topic/4932/python-time-limit-is-too-tight Python time limit is too tight I have basically the same code in python and java (see below). python got TLE, but java was accepted. I propose to relax the python time limit a little bit. Python 12345678910111213141516171819class Solution:# @param head, a ListNode# @return a ListNodedef insertionSortList(self, head): srt = None while head: node = head head = head.next node.next = None srt = self.insertTo(srt, node) return srt def insertTo(self, head, node): node.next = head head = node while node.next and node.val &gt; node.next.val: node.val, node.next.val = node.next.val, node.val node = node.next return head java 123456789101112131415161718192021222324public class Solution &#123; public ListNode insertionSortList(ListNode head) &#123; ListNode srt = null; while (head != null) &#123; ListNode node = head; head = head.next; node.next = null; srt = insertTo(srt, node); &#125; return srt; &#125; public ListNode insertTo(ListNode head, ListNode node) &#123; node.next = head; head = node; while (node.next != null &amp;&amp; node.val &gt; node.next.val) &#123; node.val = node.val ^ node.next.val; node.next.val = node.val ^ node.next.val; node.val = node.val ^ node.next.val; node = node.next; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[146. LRU Cache]]></title>
    <url>%2Fp%2F5f411b29%2F</url>
    <content type="text"><![CDATA[16.7% Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up: Could you do both operations in O(1) time complexity? 12345678910111213Example:LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 https://discuss.leetcode.com/topic/6812/c-11-code-74ms-hash-table-list C++11 code 74ms - Hash table + List There is a similar example in Java, but I wanted to share my solution using the new C++11 unordered_map and a list. The good thing about lists is that iterators are never invalidated by modifiers (unless erasing the element itself). This way, we can store the iterator to the corresponding LRU queue in the values of the hash map. Since using erase on a list with an iterator takes constant time, all operations of the LRU cache run in constant time. 12345678910111213141516171819202122232425262728293031323334353637383940class LRUCache &#123;public: LRUCache(int capacity) : _capacity(capacity) &#123;&#125; int get(int key) &#123; auto it = cache.find(key); if (it == cache.end()) return -1; touch(it); return it-&gt;second.first; &#125; void set(int key, int value) &#123; auto it = cache.find(key); if (it != cache.end()) touch(it); else &#123; if (cache.size() == _capacity) &#123; cache.erase(used.back()); used.pop_back(); &#125; used.push_front(key); &#125; cache[key] = &#123; value, used.begin() &#125;; &#125; private: typedef list&lt;int&gt; LI; typedef pair&lt;int, LI::iterator&gt; PII; typedef unordered_map&lt;int, PII&gt; HIPII; void touch(HIPII::iterator it) &#123; int key = it-&gt;first; used.erase(it-&gt;second.second); used.push_front(key); it-&gt;second.second = used.begin(); &#125; HIPII cache; LI used; int _capacity;&#125;; https://discuss.leetcode.com/topic/25792/clean-short-standard-c-solution-not-writing-c-in-c-like-all-other-lengthy-ones Clean Short Standard C++ solution – NOT writing C in C++ like all other lengthy ones I saw so many (or all) “C++” solutions posted here were not written in C++ at all. For those 200-line solutions, I don’t see the point in implementing a double-linked-list by themselves. If you are writing C++, please use STL! The code below is way cleaner, shorter and easier to read than most other C++ solutions posted here.And above all, it was written in a standard C++ way. 1234567891011121314151617181920212223242526272829303132class LRUCache&#123; size_t m_capacity; unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; m_map; //m_map_iter-&gt;first: key, m_map_iter-&gt;second: list iterator; list&lt;pair&lt;int, int&gt;&gt; m_list; //m_list_iter-&gt;first: key, m_list_iter-&gt;second: value;public: LRUCache(size_t capacity):m_capacity(capacity) &#123; &#125; int get(int key) &#123; auto found_iter = m_map.find(key); if (found_iter == m_map.end()) //key doesn&apos;t exist return -1; m_list.splice(m_list.begin(), m_list, found_iter-&gt;second); //move the node corresponding to key to front return found_iter-&gt;second-&gt;second; //return value of the node &#125; void set(int key, int value) &#123; auto found_iter = m_map.find(key); if (found_iter != m_map.end()) //key exists &#123; m_list.splice(m_list.begin(), m_list, found_iter-&gt;second); //move the node corresponding to key to front found_iter-&gt;second-&gt;second = value; //update value of the node return; &#125; if (m_map.size() == m_capacity) //reached capacity &#123; int key_to_del = m_list.back().first; m_list.pop_back(); //remove node in list; m_map.erase(key_to_del); //remove key in map &#125; m_list.emplace_front(key, value); //create new node in list m_map[key] = m_list.begin(); //create correspondence between key and node &#125;&#125;; https://discuss.leetcode.com/topic/4324/accepted-c-solution-296-ms Accepted C++ solution, 296 ms Solution is unusual - combination of 2 data structures - hash map and linked list.Algorithm: hash map holds iterators to linked list linked list holds key and value, key to access hash map items when item is accessed, it’s promoted - moved to the tail of the list - O(1) operation when item should be removed, we remove head of the list - O(1) operation when item is not promoted long time, it’s moved to the head of the list automatically get() - O(1) performance, set() - O(1) performance { 123456789101112131415161718192021222324252627282930313233343536373839404142434445class LRUCache&#123;private: struct item_t&#123; int key, val; item_t(int k, int v) :key(k), val(v)&#123;&#125; &#125;; typedef list&lt;item_t&gt; list_t; typedef unordered_map&lt;int, list_t::iterator&gt; map_t; map_t m_map; list_t m_list; int m_capacity;public: LRUCache(int capacity) : m_capacity(capacity) &#123; &#125; int get(int key) &#123; map_t::iterator i = m_map.find(key); if (i == m_map.end()) return -1; m_map[key] = promote(i-&gt;second); return m_map[key]-&gt;val; &#125; void set(int key, int value) &#123; map_t::iterator i = m_map.find(key); if (i != m_map.end())&#123; m_map[key] = promote(i-&gt;second); m_map[key]-&gt;val = value; &#125; else &#123; if (m_map.size() &lt; m_capacity)&#123; m_map[key] = m_list.insert(m_list.end(), item_t(key, value)); &#125; else &#123; m_map.erase(m_list.front().key); m_list.pop_front(); m_map[key] = m_list.insert(m_list.end(), item_t(key, value)); &#125; &#125; &#125; list_t::iterator promote(list_t::iterator i)&#123; list_t::iterator inew = m_list.insert(m_list.end(), *i); m_list.erase(i); return inew; &#125;&#125;;&#125; btw LeetCode, it was really hard to insert this code, after pressing {} button, class was improperly formatted. I inserted additional braces around class. https://discuss.leetcode.com/topic/12262/o-1-unordered_map-list-splice O(1) unordered_map + list + splice 12345678910111213141516171819202122232425262728293031323334353637383940class LRUCache &#123;private: // A list of (key, value) pairs list&lt;pair&lt;int, int&gt;&gt; items; // Map items to iterators (pointers) to list nodes unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; cache; // The capacity of the list int capacity;public: LRUCache(int capacity) : capacity(capacity) &#123;&#125; int get(int key) &#123; // If key is not found in hash map, return -1 if (cache.find(key) == cache.end()) return -1; // Move the (key, value) pair to the beginning of the list items.splice(items.begin(), items, cache[key]); return cache[key]-&gt;second; &#125; void set(int key, int value) &#123; // The key is not in the hash table if (cache.find(key) == cache.end()) &#123; // If the cache is full then delete the least recently // used item, which is at the end of the list if (items.size() == capacity) &#123; cache.erase(items.back().first); items.pop_back(); &#125; items.push_front(make_pair(key, value)); cache[key] = items.begin(); &#125; else &#123; // Update the value associated with the key cache[key]-&gt;second = value; // Move the (key, value) pair to the beginning of the list items.splice(items.begin(), items, cache[key]); &#125; &#125;&#125; https://discuss.leetcode.com/topic/14591/python-dict-double-linkedlist Python Dict + Double LinkedList 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Node:def __init__(self, k, v): self.key = k self.val = v self.prev = None self.next = Noneclass LRUCache:def __init__(self, capacity): self.capacity = capacity self.dic = dict() self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.headdef get(self, key): if key in self.dic: n = self.dic[key] self._remove(n) self._add(n) return n.val return -1def set(self, key, value): if key in self.dic: self._remove(self.dic[key]) n = Node(key, value) self._add(n) self.dic[key] = n if len(self.dic) &gt; self.capacity: n = self.head.next self._remove(n) del self.dic[n.key]def _remove(self, node): p = node.prev n = node.next p.next = n n.prev = pdef _add(self, node): p = self.tail.prev p.next = node self.tail.prev = node node.prev = p node.next = self.tail https://discuss.leetcode.com/topic/24757/python-concise-solution-with-comments-using-ordereddict Python concise solution with comments (Using OrderedDict). 1234567891011121314151617181920def __init__(self, capacity): self.dic = collections.OrderedDict() self.remain = capacitydef get(self, key): if key not in self.dic: return -1 v = self.dic.pop(key) self.dic[key] = v # set key as the newest one return vdef set(self, key, value): if key in self.dic: self.dic.pop(key) else: if self.remain &gt; 0: self.remain -= 1 else: # self.dic is full self.dic.popitem(last=False) self.dic[key] = value]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[145. Binary Tree Postorder Traversal]]></title>
    <url>%2Fp%2F4b821bfc%2F</url>
    <content type="text"><![CDATA[39.0% https://leetcode.com/problems/binary-tree-postorder-traversal/#/description Given a binary tree, return the postorder traversal of its nodes’ values. 12345678For example:Given binary tree &#123;1,#,2,3&#125;, 1 \ 2 / 3return [3,2,1]. Note: Recursive solution is trivial, could you do it iteratively? 方法一：递归，此方法可用于先序、中序、后续。但是面试时肯定是不够用的。 Recursive solution 时间空间复杂度 ： O(n) time and O(n) space (considering the spaces of function call stack); 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; helper(root, res); return res; &#125; void helper(TreeNode* root, vector&lt;int&gt;&amp; res)&#123; if(root)&#123; helper(root-&gt;left, res); helper(root-&gt;right, res); res.push_back(root-&gt;val); &#125; &#125;&#125;; 方法二：使用栈来保存要遍历的节点，后续是先左，后右，最后根。反过来，最后结果反转。 先根节点，然后再先右，再左。 先右，左节点就需要保存一下，所以先把左节点压入栈中，然后把右节点压入栈。 取出时，先取出右节点的，进行处理。处理完毕，再处理做节点的。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; stack&lt;TreeNode*&gt; nodeStack; vector&lt;int&gt; result; //base case if(root==NULL) return result; nodeStack.push(root); while(!nodeStack.empty()) &#123; TreeNode* node= nodeStack.top(); result.push_back(node-&gt;val); nodeStack.pop(); if(node-&gt;left) nodeStack.push(node-&gt;left); if(node-&gt;right) nodeStack.push(node-&gt;right); &#125; reverse(result.begin(),result.end()); return result; &#125;&#125;; 思路相同，另一种写法如下： 与上述代码的不同之处在于，没有反转，而是直接在vector前面插入一个value。 v.insert(v.begin(), val); 123456789101112131415161718vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; v; if (!root) return v; stack&lt;TreeNode *&gt; s; s.push(root); TreeNode *p = NULL; while(!s.empty()) &#123; p = s.top(); s.pop(); v.insert(v.begin(), p-&gt;val); if (p-&gt;left) s.push(p-&gt;left); if (p-&gt;right) s.push(p-&gt;right); &#125; return v;&#125; 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; stack; stack.push(root); while(!stack.empty())&#123; TreeNode* node = stack.top(); stack.pop(); res.push_back(node-&gt;val); if(node-&gt;left) stack.push(node-&gt;left); if(node-&gt;right) stack.push(node-&gt;right); &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 方法三：Iterative solution using stack — O(n) time and O(n) space; 我的代码实现: Dec 10th, 2017 12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; while(cur!=nullptr || !stack.empty())&#123; if(cur)&#123; res.push_back(cur-&gt;val); stack.push(cur); cur = cur-&gt;right; &#125;else&#123; TreeNode* tmp = stack.top(); stack.pop(); cur = tmp-&gt;left; &#125; &#125; // 最后不要忘记反转 reverse(res.begin(), res.end()); return res; &#125;&#125;; 1234567891011121314151617181920212223vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; stack&lt;TreeNode*&gt; toVisit; TreeNode* curNode = root; TreeNode* lastNode = NULL; while (curNode || !toVisit.empty()) &#123; if (curNode) &#123; toVisit.push(curNode); curNode = curNode -&gt; left; &#125; else &#123; TreeNode* topNode = toVisit.top(); if (topNode -&gt; right &amp;&amp; lastNode != topNode -&gt; right) curNode = topNode -&gt; right; else &#123; nodes.push_back(topNode -&gt; val); lastNode = topNode; toVisit.pop(); &#125; &#125; &#125; return nodes;&#125; 我的代码实现： 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; stack; while(root || stack.size())&#123; if(root)&#123; stack.push(root); res.push_back(root-&gt;val); root = root-&gt;right; &#125;else&#123; TreeNode* node = stack.top(); stack.pop(); root = node-&gt;left; &#125; &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 方法四：https://discuss.leetcode.com/topic/14473/0-ms-clear-c-solutions-iterative-recursive-morris-traversal-3-different-solutions Morris traversal 时间空间复杂度 ： O(n) time and O(1) space!!! Morris traversal: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void reverseNodes(TreeNode* start, TreeNode* end) &#123; if (start == end) return; TreeNode* x = start; TreeNode* y = start -&gt; right; TreeNode* z; while (x != end) &#123; z = y -&gt; right; y -&gt; right = x; x = y; y = z; &#125;&#125;void reverseAddNodes(TreeNode* start, TreeNode* end, vector&lt;int&gt;&amp; nodes) &#123; reverseNodes(start, end); TreeNode* node = end; while (true) &#123; nodes.push_back(node -&gt; val); if (node == start) break; node = node -&gt; right; &#125; reverseNodes(end, start);&#125;vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; TreeNode* dump = new TreeNode(0); dump -&gt; left = root; TreeNode* curNode = dump; while (curNode) &#123; if (curNode -&gt; left) &#123; TreeNode* predecessor = curNode -&gt; left; while (predecessor -&gt; right &amp;&amp; predecessor -&gt; right != curNode) predecessor = predecessor -&gt; right; if (!(predecessor -&gt; right)) &#123; predecessor -&gt; right = curNode; curNode = curNode -&gt; left; &#125; else &#123; reverseAddNodes(curNode -&gt; left, predecessor, nodes); predecessor -&gt; right = NULL; curNode = curNode -&gt; right; &#125; &#125; else curNode = curNode -&gt; right; &#125; return nodes;&#125; 我的代码实现： 按照先序遍历，先根再右再左，然后再对vector res进行reverse 访问时使用morris遍历 123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; TreeNode* cur = root; while(cur)&#123; if(cur-&gt;right)&#123; TreeNode* pre = cur-&gt;right; while(pre-&gt;left &amp;&amp; pre-&gt;left!=cur) pre = pre-&gt;left; if(pre-&gt;left==cur)&#123; pre-&gt;left = NULL; cur = cur-&gt;left; &#125;else&#123; res.push_back(cur-&gt;val); pre-&gt;left = cur; cur = cur-&gt;right; &#125; &#125;else&#123; res.push_back(cur-&gt;val); cur = cur-&gt;left; &#125; &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 先序、中序、后序的迭代方法总结： https://discuss.leetcode.com/topic/30632/preorder-inorder-and-postorder-iteratively-summarization Preorder, Inorder, and Postorder Iteratively Summarization Here I summarize the iterative implementation for preorder, inorder, and postorder traverse. PRE ORDER TRAVERSE 12345678910111213141516public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); TreeNode p = root; while(!stack.isEmpty() || p != null) &#123; if(p != null) &#123; stack.push(p); result.add(p.val); // Add before going to children p = p.left; &#125; else &#123; TreeNode node = stack.pop(); p = node.right; &#125; &#125; return result;&#125; IN ORDER TRAVERSE 12345678910111213141516public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); TreeNode p = root; while(!stack.isEmpty() || p != null) &#123; if(p != null) &#123; stack.push(p); p = p.left; &#125; else &#123; TreeNode node = stack.pop(); result.add(node.val); // Add after all left children p = node.right; &#125; &#125; return result;&#125; POST ORDER TRAVERSE 12345678910111213141516public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); TreeNode p = root; while(!stack.isEmpty() || p != null) &#123; if(p != null) &#123; stack.push(p); result.addFirst(p.val); // Reverse the process of preorder p = p.right; // Reverse the process of preorder &#125; else &#123; TreeNode node = stack.pop(); p = node.left; // Reverse the process of preorder &#125; &#125; return result;&#125; 0ms, 24.98%, July 14th, 2016 https://discuss.leetcode.com/topic/2919/my-accepted-code-with-explaination-does-anyone-have-a-better-idea My Accepted code with explaination. Does anyone have a better idea? 先进行类似于先序遍历，但是先跟后右再左，结果反转。 pre-order traversal is root-left-right, and post order is left-right-root. modify the code for pre-order to make it root-right-left, and then reverse the output so that we can get left-right-root . Create an empty stack, Push root node to the stack. Do following while stack is not empty. 2.1. pop an item from the stack and print it. 2.2. push the left child of popped item to stack. 2.3. push the right child of popped item to stack. reverse the ouput. 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; stack&lt;TreeNode*&gt; nodeStack; vector&lt;int&gt; result; //base case if(root==NULL) return result; nodeStack.push(root); while(!nodeStack.empty()) &#123; TreeNode* node= nodeStack.top(); result.push_back(node-&gt;val); nodeStack.pop(); if(node-&gt;left) nodeStack.push(node-&gt;left); if(node-&gt;right) nodeStack.push(node-&gt;right); &#125; reverse(result.begin(),result.end()); return result; &#125;&#125;; 4ms, 0.62%, July 14th, 2016 https://discuss.leetcode.com/topic/7427/a-very-concise-solution A very concise solution i have saw lots of post in this discussion, but most of them are not concise, just share mine for your reference, writing a concise code is very important 123456789101112131415161718vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; v; if (!root) return v; stack&lt;TreeNode *&gt; s; s.push(root); TreeNode *p = NULL; while(!s.empty()) &#123; p = s.top(); s.pop(); v.insert(v.begin(), p-&gt;val); if (p-&gt;left) s.push(p-&gt;left); if (p-&gt;right) s.push(p-&gt;right); &#125; return v;&#125; https://discuss.leetcode.com/topic/14473/0-ms-clear-c-solutions-iterative-recursive-morris-traversal-3-different-solutions 0 ms Clear C++ solutions — iterative, recursive, Morris traversal (3 different solutions!) Hi, this is a fundamental and yet classic problem. I share my three solutions here: Iterative solution using stack — O(n) time and O(n) space; Recursive solution — O(n) time and O(n) space (considering the spaces of function call stack); Morris traversal — O(n) time and O(1) space!!! Iterative solution using stack: 1234567891011121314151617181920212223vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; stack&lt;TreeNode*&gt; toVisit; TreeNode* curNode = root; TreeNode* lastNode = NULL; while (curNode || !toVisit.empty()) &#123; if (curNode) &#123; toVisit.push(curNode); curNode = curNode -&gt; left; &#125; else &#123; TreeNode* topNode = toVisit.top(); if (topNode -&gt; right &amp;&amp; lastNode != topNode -&gt; right) curNode = topNode -&gt; right; else &#123; nodes.push_back(topNode -&gt; val); lastNode = topNode; toVisit.pop(); &#125; &#125; &#125; return nodes;&#125; Recursive solution: 1234567891011void postorder(TreeNode* root, vector&lt;int&gt;&amp; nodes) &#123; if (!root) return; postorder(root -&gt; left, nodes); postorder(root -&gt; right, nodes); nodes.push_back(root -&gt; val);&#125;vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; postorder(root, nodes); return nodes;&#125; Morris traversal: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void reverseNodes(TreeNode* start, TreeNode* end) &#123; if (start == end) return; TreeNode* x = start; TreeNode* y = start -&gt; right; TreeNode* z; while (x != end) &#123; z = y -&gt; right; y -&gt; right = x; x = y; y = z; &#125;&#125;void reverseAddNodes(TreeNode* start, TreeNode* end, vector&lt;int&gt;&amp; nodes) &#123; reverseNodes(start, end); TreeNode* node = end; while (true) &#123; nodes.push_back(node -&gt; val); if (node == start) break; node = node -&gt; right; &#125; reverseNodes(end, start);&#125;vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; TreeNode* dump = new TreeNode(0); dump -&gt; left = root; TreeNode* curNode = dump; while (curNode) &#123; if (curNode -&gt; left) &#123; TreeNode* predecessor = curNode -&gt; left; while (predecessor -&gt; right &amp;&amp; predecessor -&gt; right != curNode) predecessor = predecessor -&gt; right; if (!(predecessor -&gt; right)) &#123; predecessor -&gt; right = curNode; curNode = curNode -&gt; left; &#125; else &#123; reverseAddNodes(curNode -&gt; left, predecessor, nodes); predecessor -&gt; right = NULL; curNode = curNode -&gt; right; &#125; &#125; else curNode = curNode -&gt; right; &#125; return nodes;&#125; 44ms, 81.02%, July 14th, 2016 https://discuss.leetcode.com/topic/17540/share-my-two-python-iterative-solutions-post-order-and-modified-preorder-then-reverse Share my two Python iterative solutions, post-order and modified preorder then reverse The first is by postorder using a flag to indicate whether the node has been visited or not. 123456789101112131415161718class Solution: # @param &#123;TreeNode&#125; root # @return &#123;integer[]&#125; def postorderTraversal(self, root): traversal, stack = [], [(root, False)] while stack: node, visited = stack.pop() if node: if visited: # add to result if visited traversal.append(node.val) else: # post-order stack.append((node, True)) stack.append((node.right, False)) stack.append((node.left, False)) return traversal The 2nd uses modified preorder (right subtree first). Then reverse the result. 123456789101112131415class Solution: # @param &#123;TreeNode&#125; root # @return &#123;integer[]&#125; def postorderTraversal(self, root): traversal, stack = [], [root] while stack: node = stack.pop() if node: # pre-order, right first traversal.append(node.val) stack.append(node.left) stack.append(node.right) # reverse result return traversal[::-1] https://discuss.leetcode.com/topic/2325/accepted-just-a-reversal-of-a-modified-pre-order-traversal Accepted – Just a reversal of a modified Pre-order traversal This is my accepted code. I found out that pre-order traversal is root-left-right, and post order is left-right-root. I modified the code for pre-order a little to make it root-right-left, and then reverse the output. I think others would have thought of it already, but anyways here’s my code… 123456789101112131415161718class Solution:# @param root, a tree node# @return a list of integersdef postorderTraversal(self, root): traversalInt = list() if root!=None: traversal = list() traversal.append(root) while len(traversal)&gt;0: probe = traversal[0] traversalInt.append(probe.val) traversal.remove(probe) if (probe.left != None): traversal.insert(0,probe.left) if (probe.right != None): traversal.insert(0,probe.right) return traversalInt[::-1] https://discuss.leetcode.com/topic/34258/iterative-method-to-do-three-kinds-of-traversal-just-like-recursive-method-only-changing-one-line-code Iterative method to do three kinds of traversal just like recursive method only changing one line code For three different kinds of traversal, we only need to change the order of tuples in one line as we’ve done this in the recursive solution which is very decent and classical. Just put (0, p[1]) in different position! For post-order traversal: 1234567def postorderTraversal(self, root): res, stack = [], [(1, root)] while stack: p = stack.pop() if not p[1]: continue stack.extend([(0, p[1]), (1, p[1].right), (1, p[1].left)]) if p[0] != 0 else res.append(p[1].val) return res For in-order traversal: 1234567def inorderTraversal(self, root): res, stack = [], [(1, root)] while stack: p = stack.pop() if not p[1]: continue stack.extend([(1, p[1].right), (0, p[1]), (1, p[1].left)]) if p[0] != 0 else res.append(p[1].val) return res For pre-order traversal: 1234567def preorderTraversal(self, root): res, stack = [], [(1, root)] while stack: p = stack.pop() if not p[1]: continue stack.extend([(1, p[1].right), (1, p[1].left), (0, p[1])]) if p[0] != 0 else res.append(p[1].val) return res https://discuss.leetcode.com/topic/44231/preorder-inorder-and-postorder-traversal-iterative-java-solution Preorder, Inorder and Postorder Traversal Iterative Java Solution Postorder traversal : Binary Tree Postorder Traversal 12345678910111213public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null) return list; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.empty())&#123; root = stack.pop(); list.add(0, root.val); if(root.left != null) stack.push(root.left); if(root.right != null) stack.push(root.right); &#125; return list;&#125; Preorder traversal : Binary Tree Preorder Traversal 12345678910111213public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null) return list; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.empty())&#123; root = stack.pop(); list.add(root.val); if(root.right != null) stack.push(root.right); if(root.left != null) stack.push(root.left); &#125; return list;&#125; Inorder traversal : Binary Tree Inorder Traversal 123456789101112131415public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null) return list; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(root != null || !stack.empty())&#123; while(root != null)&#123; stack.push(root); root = root.left; &#125; root = stack.pop(); list.add(root.val); root = root.right; &#125; return list;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>stack</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[144. Binary Tree Preorder Traversal]]></title>
    <url>%2Fp%2Fc601580f%2F</url>
    <content type="text"><![CDATA[43.8% https://leetcode.com/problems/binary-tree-preorder-traversal/#/description Given a binary tree, return the preorder traversal of its nodes’ values. 12345678For example:Given binary tree &#123;1,#,2,3&#125;, 1 \ 2 / 3return [1,2,3]. Note: Recursive solution is trivial, could you do it iteratively? 方法一：递归 O(n)时间 O(n)空间 123456789101112// recursive, but it&apos;s trivial...vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; preTraversal(root, v); return v;&#125;void preTraversal(TreeNode* root, vector&lt;int&gt;&amp; v)&#123; if(!root) return; v.push_back(root-&gt;val); preTraversal(root-&gt;left, v); preTraversal(root-&gt;right, v);&#125; 方法二：迭代方法，使用栈，遍历先根再左后右。存入栈，先右后左。很好理解。 Create an empty stack, Push root node to the stack. Do following while stack is not empty. 2.1. pop an item from the stack and print it.2.2. push the right child of popped item to stack.2.3. push the left child of popped item to stack. 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; stack&lt;TreeNode*&gt; nodeStack; vector&lt;int&gt; result; //base case if(root==NULL) return result; nodeStack.push(root); while(!nodeStack.empty()) &#123; TreeNode* node= nodeStack.top(); result.push_back(node-&gt;val); nodeStack.pop(); if(node-&gt;right) nodeStack.push(node-&gt;right); if(node-&gt;left) nodeStack.push(node-&gt;left); &#125; return result; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; stack; stack.push(root); while(!stack.empty())&#123; TreeNode* node = stack.top(); stack.pop(); res.push_back(node-&gt;val); if(node-&gt;right) stack.push(node-&gt;right); if(node-&gt;left) stack.push(node-&gt;left); &#125; return res; &#125;&#125;; 方法三： 使用栈，按照递归的方法遍历 我的代码实现： Dec 10th, 2017 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; while(stack.size() || cur)&#123; if(cur)&#123; res.push_back(cur-&gt;val); stack.push(cur); cur = cur-&gt;left; &#125;else&#123; TreeNode* tmp = stack.top(); stack.pop(); cur = tmp-&gt;right; &#125; &#125; return res; &#125;&#125;; 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; stack; while(root || stack.size())&#123; if(root)&#123; stack.push(root); res.push_back(root-&gt;val); root = root-&gt;left; &#125;else&#123; TreeNode* node = stack.top(); stack.pop(); root = node-&gt;right; &#125; &#125; return res; &#125;&#125;; 我的代码实现二: 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; while(cur || stack.size())&#123; if(cur)&#123; stack.push(cur); res.push_back(cur-&gt;val); cur = cur-&gt;left; &#125;else&#123; cur = stack.top(); stack.pop(); cur = cur-&gt;right; &#125; &#125; return res; &#125;&#125;; 方法四：morris traversal O(1)空间复杂度 O(n)时间复杂度 123456789101112131415161718192021222324// morris traversal， O(1) spacevector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root, *prev; while(temp)&#123; if(!temp-&gt;left)&#123; v.push_back(temp-&gt;val); temp = temp-&gt;right; &#125;else&#123; prev = temp-&gt;left; while(prev-&gt;right&amp;&amp;(prev-&gt;right != temp)) prev = prev-&gt;right; if(!prev-&gt;right)&#123; v.push_back(temp-&gt;val); prev-&gt;right = temp; temp = temp-&gt;left; &#125;else&#123; prev-&gt;right = NULL; temp = temp-&gt;right; &#125; &#125; &#125;&#125; 我的代码实现: 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; TreeNode* cur = root; while(cur)&#123; if(cur-&gt;left)&#123; TreeNode* pre = cur-&gt;left; while(pre-&gt;right &amp;&amp; pre-&gt;right!=cur) pre = pre-&gt;right; if(pre-&gt;right==cur)&#123; pre-&gt;right = NULL; cur = cur-&gt;right; &#125;else&#123; res.push_back(cur-&gt;val); pre-&gt;right = cur; cur = cur-&gt;left; &#125; &#125;else&#123; res.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125; return res; &#125;&#125;; 迭代方法总结，值得学习 https://discuss.leetcode.com/topic/44387/preorder-inorder-postorder-iterative-solution-by-c Preorder、inorder、postorder iterative solution by c++ preorder: 123456789101112131415vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; std::stack&lt;TreeNode*&gt; temp; while (root || !temp.empty()) &#123; while (root) &#123; temp.push(root); res.push_back(root-&gt;val); root = root-&gt;left; &#125; root = temp.top(); temp.pop(); root = root-&gt;right; &#125; return res;&#125; inorder: 123456789101112131415vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; std::stack&lt;TreeNode*&gt; temp; while (root || !temp.empty()) &#123; while (root) &#123; temp.push(root); root = root-&gt;left; &#125; root = temp.top(); temp.pop(); res.push_back(root-&gt;val); root = root-&gt;right; &#125; return res;&#125; postorder: 123456789101112131415vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; std::stack&lt;TreeNode*&gt; temp; while (root || !temp.empty()) &#123; while (root) &#123; temp.push(root); res.insert(res.begin(),root-&gt;val); root = root-&gt;right; &#125; root = temp.top(); temp.pop(); root = root-&gt;left; &#125; return res;&#125; https://discuss.leetcode.com/topic/2917/accepted-code-explaination-with-algo Accepted code. Explaination with Algo. Create an empty stack, Push root node to the stack. Do following while stack is not empty. 2.1. pop an item from the stack and print it.2.2. push the right child of popped item to stack.2.3. push the left child of popped item to stack. 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; stack&lt;TreeNode*&gt; nodeStack; vector&lt;int&gt; result; //base case if(root==NULL) return result; nodeStack.push(root); while(!nodeStack.empty()) &#123; TreeNode* node= nodeStack.top(); result.push_back(node-&gt;val); nodeStack.pop(); if(node-&gt;right) nodeStack.push(node-&gt;right); if(node-&gt;left) nodeStack.push(node-&gt;left); &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/12515/3-different-solutions 3 Different Solutions Recursive method with List as returning value: 12345678public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; pre = new LinkedList&lt;Integer&gt;(); if(root==null) return pre; pre.add(root.val); pre.addAll(preorderTraversal(root.left)); pre.addAll(preorderTraversal(root.right)); return pre;&#125; Recursive method with Helper method to have a List as paramater, so we can modify the parameter and don’t have to instantiate a new List at each recursive call: 1234567891011public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; pre = new LinkedList&lt;Integer&gt;(); preHelper(root,pre); return pre;&#125;public void preHelper(TreeNode root, List&lt;Integer&gt; pre) &#123; if(root==null) return; pre.add(root.val); preHelper(root.left,pre); preHelper(root.right,pre);&#125; Iterative method with Stack: 12345678910111213public List&lt;Integer&gt; preorderIt(TreeNode root) &#123; List&lt;Integer&gt; pre = new LinkedList&lt;Integer&gt;(); if(root==null) return pre; Stack&lt;TreeNode&gt; tovisit = new Stack&lt;TreeNode&gt;(); tovisit.push(root); while(!tovisit.empty()) &#123; TreeNode visiting = tovisit.pop(); pre.add(visiting.val); if(visiting.right!=null) tovisit.push(visiting.right); if(visiting.left!=null) tovisit.push(visiting.left); &#125; return pre;&#125; https://discuss.leetcode.com/topic/5748/easy-c-solution-using-stack Easy C++ solution using Stack 1234567891011121314151617181920212223class Solution &#123;public:vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; if (root==NULL) &#123; return vector&lt;int&gt;(); &#125; vector&lt;int&gt; result; stack&lt;TreeNode *&gt; treeStack; treeStack.push(root); while (!treeStack.empty()) &#123; TreeNode *temp = treeStack.top(); result.push_back(temp-&gt;val); treeStack.pop(); if (temp-&gt;right!=NULL) &#123; treeStack.push(temp-&gt;right); &#125; if (temp-&gt;left!=NULL) &#123; treeStack.push(temp-&gt;left); &#125; &#125; return result;&#125;&#125;; https://discuss.leetcode.com/topic/21936/4-solutions-in-c 4 solutions in c++ 123456789101112// recursive, but it&apos;s trivial...vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; preTraversal(root, v); return v;&#125;void preTraversal(TreeNode* root, vector&lt;int&gt;&amp; v)&#123; if(!root) return; v.push_back(root-&gt;val); preTraversal(root-&gt;left, v); preTraversal(root-&gt;right, v);&#125; 123456789101112131415// iterate, use stack to imitate recursivevector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root; stack&lt;TreeNode*&gt; s; s.push(root); while(!s.empty())&#123; temp = s.top(); s.pop(); v.push_back(temp-&gt;val); if(temp-&gt;right) s.push(temp-&gt;right); if(temp-&gt;left) s.push(temp-&gt;left); &#125;&#125; 12345678910111213141516vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root; stack&lt;TreeNode*&gt; s; while(true)&#123; while(temp)&#123; v.push_back(temp-&gt;val); if(temp-&gt;right) s.push(temp-&gt;right); temp = temp-&gt;left; &#125; if(s.empty()) break; temp = s.top(); s.pop(); &#125;;&#125; 123456789101112131415161718192021222324// morris traversal， O(1) spacevector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root, *prev; while(temp)&#123; if(!temp-&gt;left)&#123; v.push_back(temp-&gt;val); temp = temp-&gt;right; &#125;else&#123; prev = temp-&gt;left; while(prev-&gt;right&amp;&amp;(prev-&gt;right != temp)) prev = prev-&gt;right; if(!prev-&gt;right)&#123; v.push_back(temp-&gt;val); prev-&gt;right = temp; temp = temp-&gt;left; &#125;else&#123; prev-&gt;right = NULL; temp = temp-&gt;right; &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/7976/very-simple-iterative-python-solution Very simple iterative Python solution Classical usage of stack’s LIFO feature, very easy to grasp: 12345678910def preorderTraversal(self, root): ret = [] stack = [root] while stack: node = stack.pop() if node: ret.append(node.val) stack.append(node.right) stack.append(node.left) return ret https://discuss.leetcode.com/topic/6493/accepted-iterative-solution-in-java-using-stack Accepted iterative solution in Java using stack. Note that in this solution only right children are stored to stack. 123456789101112131415public List&lt;Integer&gt; preorderTraversal(TreeNode node) &#123; List&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; rights = new Stack&lt;TreeNode&gt;(); while(node != null) &#123; list.add(node.val); if (node.right != null) &#123; rights.push(node.right); &#125; node = node.left; if (node == null &amp;&amp; !rights.isEmpty()) &#123; node = rights.pop(); &#125; &#125; return list;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>stack</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[143. Reorder List]]></title>
    <url>%2Fp%2Ffa09b9a8%2F</url>
    <content type="text"><![CDATA[24.9% https://leetcode.com/problems/reorder-list/#/description Given a singly linked list L: L0→L1→…→Ln-1→Ln,reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You must do this in-place without altering the nodes’ values. 12For example,Given &#123;1,2,3,4&#125;, reorder it to &#123;1,4,2,3&#125;. 方法一： 按照题意，先找一半处，后一半反转，然后并入前一段。 我的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void reorderList(ListNode* head) &#123; if(!head || !head-&gt;next) return; ListNode* fast = head, * slow = head; while(fast-&gt;next!=NULL &amp;&amp; fast-&gt;next-&gt;next!=NULL)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; fast = slow-&gt;next; ListNode* pre = NULL; while(fast)&#123; ListNode* nex = fast-&gt;next; fast-&gt;next = pre; pre = fast; fast = nex; &#125; fast = pre; slow-&gt;next = NULL; slow = head; while(fast!=NULL)&#123; ListNode* nex = fast-&gt;next; fast-&gt;next = slow-&gt;next; slow-&gt;next = fast; slow = slow-&gt;next-&gt;next; fast = nex; &#125; return; &#125;&#125;; 49ms, September 22, 2016 https://discuss.leetcode.com/topic/7425/a-concise-o-n-time-o-1-in-place-solution A concise O(n) time, O(1) in place solution 1234567891011121314151617181920212223242526272829303132333435363738// O(N) time, O(1) space in totalvoid reorderList(ListNode *head) &#123; if (!head || !head-&gt;next) return; // find the middle node: O(n) ListNode *p1 = head, *p2 = head-&gt;next; while (p2 &amp;&amp; p2-&gt;next) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next-&gt;next; &#125; // cut from the middle and reverse the second half: O(n) ListNode *head2 = p1-&gt;next; p1-&gt;next = NULL; p2 = head2-&gt;next; head2-&gt;next = NULL; while (p2) &#123; p1 = p2-&gt;next; p2-&gt;next = head2; head2 = p2; p2 = p1; &#125; // merge two lists: O(n) for (p1 = head, p2 = head2; p1; ) &#123; auto t = p1-&gt;next; p1 = p1-&gt;next = p2; p2 = t; &#125; //for (p1 = head, p2 = head2; p2; ) &#123; // auto t = p1-&gt;next; // p1-&gt;next = p2; // p2 = p2-&gt;next; // p1 = p1-&gt;next-&gt;next = t; //&#125;&#125; https://discuss.leetcode.com/topic/4061/my-o-n-c-method-accepted My O(n) C++ Method, accepted Firstly, I split the list from the middle into two lists. One from head to middle, and the other from middle to the end. Then we reverse the second list. Finally we merge these two lists. O(n) time complexity and O(1) space complexity. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void reorderList(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL || head-&gt;next-&gt;next==NULL) return; //find the middle of the list, and split into two lists. ListNode *p=head,*q=head; while(p &amp;&amp; q &amp;&amp; q-&gt;next &amp;&amp; q-&gt;next-&gt;next)&#123; p=p-&gt;next; q=q-&gt;next-&gt;next; &#125; ListNode *mid = p-&gt;next; p-&gt;next=NULL; p=head; //reverse from the middle to the end ListNode *q1=mid, *q2,*q3; if(mid-&gt;next)&#123; q1=mid; q2=mid-&gt;next; while(q2)&#123; q3=q2-&gt;next; q2-&gt;next=q1; q1=q2; q2=q3; &#125; mid-&gt;next=NULL; &#125; q=q1; //merge these two list ListNode *s=p; p=p-&gt;next; while(p &amp;&amp; q)&#123; s-&gt;next=q; s=s-&gt;next; q=q-&gt;next; s-&gt;next=p; s=s-&gt;next; p=p-&gt;next; &#125; if(p)&#123; s-&gt;next=p; &#125; if(q)&#123; s-&gt;next=q; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/10894/share-a-consise-recursive-solution-in-c Share a consise recursive solution in C++ The recursive idea have been posted by yucheng.wang. Given a example, 1-&gt;2-&gt;3-&gt;4-&gt;5, the solution will reorder node(3), then reorder 2 and 4 to have (2-&gt;4-&gt;3), then 1 and 5 get have 1-&gt;5-&gt;2-&gt;4-&gt;3. Each call of reorderList(ListNode* head, int len) will return the last element after this reorderList() call. 123456789101112131415161718192021222324252627int getLength(ListNode *head)&#123;int len = 0;while( head != NULL )&#123;++len; head = head-&gt;next;&#125;return len;&#125;ListNode * reorderList(ListNode *head, int len)&#123; if(len == 0) return NULL; if( len == 1 ) return head; if( len == 2 ) return head-&gt;next; ListNode * tail = reorderList(head-&gt;next, len-2); ListNode * tmp = tail-&gt;next; tail-&gt;next = tail-&gt;next-&gt;next; tmp-&gt;next = head-&gt;next; head-&gt;next = tmp; return tail;&#125;void reorderList(ListNode *head) &#123; //recursive ListNode * tail = NULL; tail = reorderList(head, getLength(head));&#125; https://discuss.leetcode.com/topic/3345/a-python-solution-o-n-time-o-1-space A python solution O(n) time, O(1) space 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# Splits in place a list in two halves, the first half is &gt;= in size than the second.# @return A tuple containing the heads of the two halvesdef _splitList(head): fast = head slow = head while fast and fast.next: slow = slow.next fast = fast.next fast = fast.next middle = slow.next slow.next = None return head, middle# Reverses in place a list.# @return Returns the head of the new reversed listdef _reverseList(head): last = None currentNode = head while currentNode: nextNode = currentNode.next currentNode.next = last last = currentNode currentNode = nextNode return last# Merges in place two lists# @return The newly merged list.def _mergeLists(a, b): tail = a head = a a = a.next while b: tail.next = b tail = tail.next b = b.next if a: a, b = b, a return headclass Solution: # @param head, a ListNode # @return nothing def reorderList(self, head): if not head or not head.next: return a, b = _splitList(head) b = _reverseList(b) head = _mergeLists(a, b) https://discuss.leetcode.com/topic/13869/java-solution-with-3-steps Java solution with 3 steps This question is a combination of Reverse a linked list I &amp; II. It should be pretty straight forward to do it in 3 steps :) 1234567891011121314151617181920212223242526272829303132public void reorderList(ListNode head) &#123; if(head==null||head.next==null) return; //Find the middle of the list ListNode p1=head; ListNode p2=head; while(p2.next!=null&amp;&amp;p2.next.next!=null)&#123; p1=p1.next; p2=p2.next.next; &#125; //Reverse the half after middle 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 to 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4 ListNode preMiddle=p1; ListNode preCurrent=p1.next; while(preCurrent.next!=null)&#123; ListNode current=preCurrent.next; preCurrent.next=current.next; current.next=preMiddle.next; preMiddle.next=current; &#125; //Start reorder one by one 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4 to 1-&gt;6-&gt;2-&gt;5-&gt;3-&gt;4 p1=head; p2=preMiddle.next; while(p1!=preMiddle)&#123; preMiddle.next=p2.next; p2.next=p1.next; p1.next=p2; p1=p2.next; p2=preMiddle.next; &#125; &#125; https://discuss.leetcode.com/topic/18092/java-solution-with-3-steps Java solution with 3 steps 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; public void reorderList(ListNode head) &#123; if (head == null || head.next == null) return; // step 1. cut the list to two halves // prev will be the tail of 1st half // slow will be the head of 2nd half ListNode prev = null, slow = head, fast = head, l1 = head; while (fast != null &amp;&amp; fast.next != null) &#123; prev = slow; slow = slow.next; fast = fast.next.next; &#125; prev.next = null; // step 2. reverse the 2nd half ListNode l2 = reverse(slow); // step 3. merge the two halves merge(l1, l2); &#125; ListNode reverse(ListNode head) &#123; ListNode prev = null, curr = head, next = null; while (curr != null) &#123; next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; return prev; &#125; void merge(ListNode l1, ListNode l2) &#123; while (l1 != null) &#123; ListNode n1 = l1.next, n2 = l2.next; l1.next = l2; if (n1 == null) break; l2.next = n1; l1 = n1; l2 = n2; &#125; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[142. Linked List Cycle II]]></title>
    <url>%2Fp%2Fc5856708%2F</url>
    <content type="text"><![CDATA[31.0% https://leetcode.com/problems/linked-list-cycle-ii/?tab=Description Given a linked list, return the node where the cycle begins. If there is no cycle, return null. Note: Do not modify the linked list. Follow up: Can you solve it without using extra space? 方法一： 我的代码实现： 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(!head) return NULL; ListNode* slow = head, *fast = head; // 注意!fast表示fast为NULL的情况下为true，fast表示fast不为NULL // 区分!fast,fast,fast!=NULL这几种情况 while(fast &amp;&amp; fast-&gt;next)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(slow==fast)&#123; fast = head; while(fast!=slow)&#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return fast; &#125; &#125; return NULL; &#125;&#125;; 类似版本： 一个重点是，题目中要求循环开始的地方，所以当找到相遇的地方时，还要通过for循环找到最开始相遇的地方。 1234567891011121314151617181920212223class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head==NULL) return head; ListNode * slow, * fast; slow = head; fast = head; while(fast!=NULL &amp;&amp; fast-&gt;next!=NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(slow==fast)&#123; ListNode* slow2 = head; while(slow2!=slow)&#123; slow = slow-&gt;next; slow2 = slow2-&gt;next; &#125; return slow2; &#125; &#125; return NULL; &#125;&#125;; https://discuss.leetcode.com/topic/5284/concise-o-n-solution-by-using-c-with-detailed-alogrithm-description Concise O(n) solution by using C++ with Detailed Alogrithm Description Alogrithm Description:Step 1: Determine whether there is a cycle 1.1. Using a slow pointer that move forward 1 step each time 1.2. Using a fast pointer that move forward 2 steps each time 1.3. If the slow pointer and fast pointer both point to the same location after several moving steps, there is a cycle; 1.4. Otherwise, if (fast-&gt;next == NULL || fast-&gt;next-&gt;next == NULL), there has no cycle. Step 2: If there is a cycle, return the entry location of the cycle 2.1. L1 is defined as the distance between the head point and entry point 2.2. L2 is defined as the distance between the entry point and the meeting point 2.3. C is defined as the length of the cycle 2.4. n is defined as the travel times of the fast pointer around the cycle When the first encounter of the slow pointer and the fast pointer According to the definition of L1, L2 and C, we can obtain: the total distance of the slow pointer traveled when encounter is L1 + L2 the total distance of the fast pointer traveled when encounter is L1 + L2 + n * C Because the total distance the fast pointer traveled is twice as the slow pointer, Thus: 2 (L1+L2) = L1 + L2 + n C =&gt; L1 + L2 = n C =&gt; L1 = (n - 1) C + (C - L2) 快指针不会超过慢指针好几圈，因为如果当前节点没有相遇，则下一个节点一定会相遇。 It can be concluded that the distance between the head location and entry location is equal to the distance between the meeting location and the entry location along the direction of forward movement. So, when the slow pointer and the fast pointer encounter in the cycle, we can define a pointer “entry” that point to the head, this “entry” pointer moves one step each time so as the slow pointer. When this “entry” pointer and the slow pointer both point to the same location, this location is the node where the cycle begins. Here is the code: 123456789101112131415161718192021ListNode *detectCycle(ListNode *head) &#123; if (head == NULL || head-&gt;next == NULL) return NULL; ListNode *slow = head; ListNode *fast = head; ListNode *entry = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (slow == fast) &#123; // there is a cycle while(slow != entry) &#123; // found the entry location slow = slow-&gt;next; entry = entry-&gt;next; &#125; return entry; &#125; &#125; return NULL; // there has no cycle&#125; cpp 9ms, September 22, 2016 https://discuss.leetcode.com/topic/2975/o-n-solution-by-using-two-pointers-without-change-anything O(n) solution by using two pointers without change anything my solution is like this: using two pointers, one of them one step at a time. another pointer each take two steps. Suppose the first meet at step k,the length of the Cycle is r. so..2k-k=nr,k=nr Now, the distance between the start node of list and the start node of cycle is s. the distance between the start of list and the first meeting node is k(the pointer which wake one step at a time waked k steps).the distance between the start node of cycle and the first meeting node is m, so…s=k-m, s=nr-m=(n-1)r+(r-m),here we takes n = 1..so, using one pointer start from the start node of list, another pointer start from the first meeting node, all of them wake one step at a time, the first time they meeting each other is the start of the cycle. 12345678910111213141516171819202122232425262728class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head==NULL || head-&gt;next == NULL) return NULL; ListNode* firstp = head; ListNode* secondp = head; bool isCycle = false; while(firstp!=NULL &amp;&amp; secondp!=NULL)&#123; firstp = firstp-&gt;next; if(secondp-&gt;next==NULL) return NULL; secondp = secondp-&gt;next-&gt;next; if(firstp==secondp)&#123; isCycle = true; break; &#125; &#125; if(!isCycle) return NULL; firstp = head; while(firstp != secondp)&#123; firstp = firstp-&gt;next; secondp = secondp-&gt;next; &#125; return firstp; &#125;&#125;; https://discuss.leetcode.com/topic/33191/c-implementation-with-much-more-clear-and-strict-explanation-any-one-can-give-more-clear C++ implementation with much more clear and strict explanation ! any one can give more clear ? Just use the dummy head pointer and why first find the meeting point and then set the result-pointer at the dummy and move forward to find the result position.There are the reasons : 123456789101112131415161718192021222324252627282930set the [#cycle length = C ] [#length-from-head-to-cycle-start-point = L] [#cycle-start-point-meeting-point=S] [#meeting-point-clock-direction-to-cycle-start-point=Y] [#step needed to meeting=T]Then when they meet, we have 2 * T = T + N1 * C N1=0,1,2...so we get T = N1 * CAlso we have 2 * T = L + N2 * C + S N2=0,1,2...we can get N3 * C = L + S with C = S + Y N3 = 2 * N1 - N2so we have (N3 - 1) * C + S + Y = L + Sthen we have (N3 - 1) * C + Y = Ljust means that we can do the things that have been explained by others. We can move a node from head and node from the meeting point, then when they meet, it is the start point of the cycle. Here is the code : 123456789101112131415161718192021class Solution &#123; public: ListNode *detectCycle(ListNode *head) &#123; ListNode* dummy=new ListNode(-1); dummy-&gt;next=head; ListNode *slow=dummy, *fast=dummy; bool flag=false; while(fast &amp;&amp; fast-&gt;next)&#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(fast==slow) &#123; flag=true; break; &#125; &#125; if(!flag) return NULL; ListNode* result=dummy; while(result != slow)&#123; result=result-&gt;next; slow=slow-&gt;next;**strong text** &#125; return result; &#125; &#125;; my code: python 85ms, 51.12%, September 22, 2016 https://discuss.leetcode.com/topic/17521/share-my-python-solution-with-detailed-explanation Share my python solution with detailed explanation My solution consists of two parts. The first one checks if a cycle exists or not. The second one determines the entry of the cycle if it exists.The first part is inspired by this post. about Linked List Cycle IThe logic behind the 2nd part is like this: Consider the following linked list, where E is the cylce entry and X, the crossing point of fast and slow. 12345678H: distance from head to cycle entry ED: distance from E to XL: cycle length _____ / \head_____H______E \ \ / X_____/ If fast and slow both start at head, when fast catches slow, slow has traveled H+D and fast 2(H+D).Assume fast has traveled n loops in the cycle, we have:2H + 2D = H + D + L –&gt; H + D = nL –&gt; H = nL - DThus if two pointers start from head and X, respectively, one first reaches E, the other also reaches E.In my solution, since fast starts at head.next, we need to move slow one step forward in the beginning of part 2 123456789101112131415161718192021class Solution: # @param head, a ListNode # @return a list node def detectCycle(self, head): try: fast = head.next slow = head while fast is not slow: fast = fast.next.next slow = slow.next except: # if there is an exception, we reach the end and there is no cycle return None # since fast starts at head.next, we need to move slow one step forward slow = slow.next while head is not slow: head = head.next slow = slow.next return head https://discuss.leetcode.com/topic/5438/sharing-my-python-solution Sharing my Python solution Same idea as many other posts, just the python version: 12345678910111213def detectCycle(self, head): slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None while head != slow: slow = slow.next head = head.next return head java 1ms, September 22, 2016 https://discuss.leetcode.com/topic/19367/java-o-1-space-solution-with-detailed-explanation Java O(1) space solution with detailed explanation. Define two pointers slow and fast. Both start at head node, fast is twice as fast as slow. If it reaches the end it means there is no cycle, otherwise eventually it will eventually catch up to slow pointer somewhere in the cycle. Let the distance from the first node to the the node where cycle begins be A, and let say the slow pointer travels travels A+B. The fast pointer must travel 2A+2B to catch up. The cycle size is N. Full cycle is also how much more fast pointer has traveled than slow pointer at meeting point. 12A+B+N = 2A+2BN=A+B From our calculation slow pointer traveled exactly full cycle when it meets fast pointer, and since originally it travled A before starting on a cycle, it must travel A to reach the point where cycle begins! We can start another slow pointer at head node, and move both pointers until they meet at the beginning of a cycle. 123456789101112131415161718192021public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while (fast!=null &amp;&amp; fast.next!=null)&#123; fast = fast.next.next; slow = slow.next; if (fast == slow)&#123; ListNode slow2 = head; while (slow2 != slow)&#123; slow = slow.next; slow2 = slow2.next; &#125; return slow; &#125; &#125; return null; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[141. Linked List Cycle]]></title>
    <url>%2Fp%2F20f14e92%2F</url>
    <content type="text"><![CDATA[35.6% https://leetcode.com/problems/linked-list-cycle/description/ Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 方法一： 一个快指针，一个慢指针 https://discuss.leetcode.com/topic/4218/my-faster-and-slower-runner-solution My faster and slower runner solution 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ /** use faster and lower runner solution. (2 pointers) the faster one move 2 steps, and slower one move only one step. if there&apos;s a circle, the faster one will finally &quot;catch&quot; the slower one. (the distance between these 2 pointers will decrease one every time.) if there&apos;s no circle, the faster runner will reach the end of linked list. (NULL) */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head == NULL || head -&gt; next == NULL) return false; ListNode *fast = head; ListNode *slow = head; while(fast -&gt; next &amp;&amp; fast -&gt; next -&gt; next)&#123; fast = fast -&gt; next -&gt; next; slow = slow -&gt; next; if(fast == slow) return true; &#125; return false; &#125;&#125;; 我的代码实现一： 1234567891011121314class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head==NULL) return false; ListNode* slow, *fast; slow = head; fast = head-&gt;next; while(slow!=fast&amp;&amp;fast!=NULL &amp;&amp; fast-&gt;next!=NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow==fast; &#125;&#125;; 我的代码实现二： 123456789101112131415161718192021/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(!head || !head-&gt;next) return false; ListNode* slow = head, *fast = head-&gt;next; while(fast!=NULL &amp;&amp; fast-&gt;next!=NULL)&#123; if(slow==fast) return true; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/16098/except-ionally-fast-python Except-ionally fast Python Took 88 ms and the “Accepted Solutions Runtime Distribution” doesn’t show any faster Python submissions. The “trick” is to not check all the time whether we have reached the end but to handle it via an exception. “Easier to ask for forgiveness than permission.” The algorithm is of course Tortoise and hare. 12345678910def hasCycle(self, head): try: slow = head fast = head.next while slow is not fast: slow = slow.next fast = fast.next.next return True except: return False java https://discuss.leetcode.com/topic/12516/o-1-space-solution O(1) Space Solution 1234567891011public boolean hasCycle(ListNode head) &#123; if(head==null) return false; ListNode walker = head; ListNode runner = head; while(runner.next!=null &amp;&amp; runner.next.next!=null) &#123; walker = walker.next; runner = runner.next.next; if(walker==runner) return true; &#125; return false;&#125; Use two pointers, walker and runner. walker moves step by step. runner moves two steps at time. if the Linked List has a cycle walker and runner will meet at some point. 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head == null) return false; ListNode slow, fast; slow = head; fast = head; while(fast.next!=null &amp;&amp; fast.next.next != null)&#123; slow = slow.next; fast = fast.next.next; if(slow==fast) return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[140. Word Break II]]></title>
    <url>%2Fp%2F2ce5facb%2F</url>
    <content type="text"><![CDATA[23.3% https://leetcode.com/problems/word-break-ii/ Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words. Return all such possible sentences. 12345For example, givens = &quot;catsanddog&quot;,dict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;].A solution is [&quot;cats and dog&quot;, &quot;cat sand dog&quot;]. UPDATE (2017/1/4):The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. 还需要思考 方法一: https://discuss.leetcode.com/topic/12997/11ms-c-solution-concise 11ms C++ solution (concise) 1234567891011121314151617181920212223242526272829class Solution &#123; unordered_map&lt;string, vector&lt;string&gt;&gt; m; vector&lt;string&gt; combine(string word, vector&lt;string&gt; prev)&#123; for(int i=0;i&lt;prev.size();++i)&#123; prev[i]+=&quot; &quot;+word; &#125; return prev; &#125;public: vector&lt;string&gt; wordBreak(string s, unordered_set&lt;string&gt;&amp; dict) &#123; if(m.count(s)) return m[s]; //take from memory vector&lt;string&gt; result; if(dict.count(s))&#123; //a whole string is a word result.push_back(s); &#125; for(int i=1;i&lt;s.size();++i)&#123; string word=s.substr(i); if(dict.count(word))&#123; string rem=s.substr(0,i); vector&lt;string&gt; prev=combine(word,wordBreak(rem,dict)); result.insert(result.end(),prev.begin(), prev.end()); &#125; &#125; m[s]=result; //memorize return result; &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/35762/9-lines-python-10-lines-c 9 lines Python, 10 lines C++ 123456789101112vector&lt;string&gt; wordBreak(string s, unordered_set&lt;string&gt;&amp; wordDict) &#123; unordered_map&lt;int, vector&lt;string&gt;&gt; memo &#123;&#123;s.size(), &#123;&quot;&quot;&#125;&#125;&#125;; function&lt;vector&lt;string&gt;(int)&gt; sentences = [&amp;](int i) &#123; if (!memo.count(i)) for (int j=i+1; j&lt;=s.size(); j++) if (wordDict.count(s.substr(i, j-i))) for (string tail : sentences(j)) memo[i].push_back(s.substr(i, j-i) + (tail==&quot;&quot; ? &quot;&quot; : &apos; &apos; + tail)); return memo[i]; &#125;; return sentences(0);&#125; 方法三： 我的代码实现： 超时了 “aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa”[“a”,”aa”,”aaa”,”aaaa”,”aaaaa”,”aaaaaa”,”aaaaaaa”,”aaaaaaaa”,”aaaaaaaaa”,”aaaaaaaaaa”] 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; int n = s.size(); unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); unordered_map&lt;int, vector&lt;vector&lt;string&gt;&gt;&gt; memo; vector&lt;vector&lt;string&gt;&gt; tmp&#123;vector&lt;vector&lt;string&gt;&gt;(1, vector&lt;string&gt;(1, ""))&#125;; memo[0] = tmp; for(int i=1; i&lt;=n; i++)&#123; // 严格区分 ++ -- vector&lt;vector&lt;string&gt;&gt; v; bool flag = false; for(int j=i-1; j&gt;=0; j--)&#123; string word = s.substr(j, i-j); if(wordSet.find(word)!=wordSet.end() &amp;&amp; memo.find(j)!=memo.end())&#123; flag = true; for(auto cur:memo[j])&#123; cur.push_back(word); v.push_back(cur); &#125; &#125; &#125; if(flag) memo[i] = v; &#125; vector&lt;string&gt; res; for(int i=0; i&lt;memo[n].size(); i++)&#123; string t = memo[n][i][1]; for(int j=2; j&lt;memo[n][i].size(); j++) t += " " + memo[n][i][j]; res.push_back(t); &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/35762/9-lines-python-10-lines-c 9 lines Python, 10 lines C++ 12345678910def wordBreak(self, s, wordDict): memo = &#123;len(s): [&apos;&apos;]&#125; def sentences(i): if i not in memo: memo[i] = [s[i:j] + (tail and &apos; &apos; + tail) for j in range(i+1, len(s)+1) if s[i:j] in wordDict for tail in sentences(j)] return memo[i] return sentences(0) java https://discuss.leetcode.com/topic/27855/my-concise-java-solution-based-on-memorized-dfs My concise JAVA solution based on memorized DFS 18ms, 34.39%, Jan.13 2017 Explanation Using DFS directly will lead to TLE, so I just used HashMap to save the previous results to prune duplicated branches, as the following: 1234567891011121314151617181920212223242526public class Solution &#123; public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123; return DFS(s, wordDict, new HashMap&lt;String, LinkedList&lt;String&gt;&gt;()); &#125; // DFS function returns an array including all substrings derived from s. List&lt;String&gt; DFS(String s, List&lt;String&gt; wordDict, HashMap&lt;String, LinkedList&lt;String&gt;&gt;map) &#123; if (map.containsKey(s)) return map.get(s); LinkedList&lt;String&gt;res = new LinkedList&lt;String&gt;(); if (s.length() == 0) &#123; res.add(&quot;&quot;); return res; &#125; for (String word : wordDict) &#123; if (s.startsWith(word)) &#123; List&lt;String&gt;sublist = DFS(s.substring(word.length()), wordDict, map); for (String sub : sublist) res.add(word + (sub.isEmpty() ? &quot;&quot; : &quot; &quot;) + sub); &#125; &#125; map.put(s, res); return res; &#125;&#125; Brilliant idea, also can be simplified like this. 1234567891011121314151617181920212223public class Solution &#123;HashMap&lt;String, LinkedList&lt;String&gt;&gt; map = new HashMap&lt;String, LinkedList&lt;String&gt;&gt;();public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; if (map.containsKey(s)) return map.get(s); LinkedList&lt;String&gt; res = new LinkedList&lt;String&gt;(); if (s.length() == 0) &#123; res.add(&quot;&quot;); return res; &#125; for (String word : wordDict) &#123; if (s.startsWith(word)) &#123; List&lt;String&gt; sublist = wordBreak(s.substring(word.length()), wordDict); for (String sub : sublist) res.add(word + (sub.isEmpty() ? &quot;&quot; : &quot; &quot;) + sub); &#125; &#125; map.put(s, res); return res;&#125;&#125; https://discuss.leetcode.com/topic/9837/my-concise-answer My concise answer. 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; dict) &#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;(); for(int j = s.length() - 1; j &gt;= 0; j--)&#123; if(dict.contains(s.substring(j))) break; else&#123; if(j == 0) return result; &#125; &#125; for(int i = 0; i &lt; s.length()-1; i++) &#123; if(dict.contains(s.substring(0,i+1))) &#123; List&lt;String&gt; strs = wordBreak(s.substring(i+1,s.length()),dict); if(strs.size() != 0) for(Iterator&lt;String&gt; it = strs.iterator();it.hasNext();) &#123; result.add(s.substring(0,i+1)+&quot; &quot;+it.next()); &#125; &#125; &#125; if(dict.contains(s)) result.add(s); return result; &#125;&#125; https://discuss.leetcode.com/topic/8178/slightly-modified-dp-java-solution Slightly modified DP Java solution Hi guys! There’s a lot of concern in other posts about “aaaa…aab” test case that causes TLE when we run through our string not in reverse but from start to end. I’ve thought a bit on how to add a tiny modification and make just the whole thing more effective, not only pass the TLE case. The approach is the same as before: we loop through all possible prefixes checking if it in the dictionary and caching the results. But just before jumping into recursion we could also check that the right reminder has a prefix from the dictionary, because if it hasn’t then there’s no sense in splitting the reminder into sub-strings. It’s just a linear check, which I think also could be optimized with some caching but even without optimization the solution is accepted. And also the code looks quite understandable. 123456789101112131415161718192021222324252627public class Solution &#123; private final Map&lt;String, List&lt;String&gt;&gt; cache = new HashMap&lt;&gt;(); private boolean containsSuffix(Set&lt;String&gt; dict, String str) &#123; for (int i = 0; i &lt; str.length(); i++) &#123; if (dict.contains(str.substring(i))) return true; &#125; return false; &#125; public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; dict) &#123; if (cache.containsKey(s)) return cache.get(s); List&lt;String&gt; result = new LinkedList&lt;&gt;(); if (dict.contains(s)) result.add(s); for (int i = 1; i &lt; s.length(); i++) &#123; String left = s.substring(0,i), right = s.substring(i); if (dict.contains(left) &amp;&amp; containsSuffix(dict, right)) &#123; for (String ss : wordBreak(right, dict)) &#123; result.add(left + &quot; &quot; + ss); &#125; &#125; &#125; cache.put(s, result); return result; &#125;&#125; https://discuss.leetcode.com/topic/39833/java-6ms-simple-solution-beating-88 Java 6ms simple solution beating 88% 1234567891011121314151617181920212223242526272829public class Solution &#123; HashMap&lt;Integer, List&lt;String&gt;&gt; dp = new HashMap&lt;&gt;(); public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; int maxLength = -1; for(String ss : wordDict) maxLength = Math.max(maxLength, ss.length()); return addSpaces(s, wordDict, 0, maxLength); &#125; private List&lt;String&gt; addSpaces(String s, Set&lt;String&gt; wordDict, int start, int max)&#123; List&lt;String&gt; words = new ArrayList&lt;&gt;(); if(start == s.length()) &#123; words.add(&quot;&quot;); return words; &#125; for(int i = start + 1; i &lt;= max + start &amp;&amp; i &lt;= s.length(); i++)&#123; String temp = s.substring(start, i); if(wordDict.contains(temp))&#123; List&lt;String&gt; ll; if(dp.containsKey(i)) ll = dp.get(i); else ll = addSpaces(s, wordDict, i, max); for(String ss : ll) words.add(temp + (ss.equals(&quot;&quot;) ? &quot;&quot; : &quot; &quot;) + ss); &#125; &#125; dp.put(start, words); return words; &#125;&#125; https://discuss.leetcode.com/topic/3495/my-dp-solution-in-java My DP solution in JAVA Basically my idea is the following: Scan the the string from the tail Build possible solution for the current index based on DP results Return the solution when index==0 123456789101112131415161718192021222324public class Solution &#123; public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; dict) &#123; Map&lt;Integer, List&lt;String&gt;&gt; validMap = new HashMap&lt;Integer, List&lt;String&gt;&gt;(); // initialize the valid values List&lt;String&gt; l = new ArrayList&lt;String&gt;(); l.add(&quot;&quot;); validMap.put(s.length(), l); // generate solutions from the end for(int i = s.length() - 1; i &gt;= 0; i--) &#123; List&lt;String&gt; values = new ArrayList&lt;String&gt;(); for(int j = i + 1; j &lt;= s.length(); j++) &#123; if (dict.contains(s.substring(i, j))) &#123; for(String word : validMap.get(j)) &#123; values.add(s.substring(i, j) + (word.isEmpty() ? &quot;&quot; : &quot; &quot;) + word); &#125; &#125; &#125; validMap.put(i, values); &#125; return validMap.get(0); &#125;&#125; https://discuss.leetcode.com/topic/34260/java-dp-dfs-memoization-dfs-and-dp-pruning-solutions-with-analysis Java DP+DFS, Memoization+DFS, and DP Pruning Solutions with Analysis I’ve been struggling with this problem for a long time, and I’d love to share three different strategies I have tried to solve it. All of them are ACed. Method 1: DP + DFS. Very similar to Word Break I, but instead of using a boolean dp array, I used an array of Lists to maintain all of the valid start positions for every end position. Then just do classic backtracking to find all solutions. The time complexity is O(n*m) + O(n * number of solutions), where n is the length of the input string, m is the length of the longest word in the dictionary. The run time was 6ms. It is very efficient because DP is used to find out all the valid answers, and no time is wasted on doing the backtracking. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; List&lt;Integer&gt;[] starts = new List[s.length() + 1]; // valid start positions starts[0] = new ArrayList&lt;Integer&gt;(); int maxLen = getMaxLen(wordDict); for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = i - 1; j &gt;= i - maxLen &amp;&amp; j &gt;= 0; j--) &#123; if (starts[j] == null) continue; String word = s.substring(j, i); if (wordDict.contains(word)) &#123; if (starts[i] == null) &#123; starts[i] = new ArrayList&lt;Integer&gt;(); &#125; starts[i].add(j); &#125; &#125; &#125; List&lt;String&gt; rst = new ArrayList&lt;&gt;(); if (starts[s.length()] == null) &#123; return rst; &#125; dfs(rst, "", s, starts, s.length()); return rst;&#125;private void dfs(List&lt;String&gt; rst, String path, String s, List&lt;Integer&gt;[] starts, int end) &#123; if (end == 0) &#123; rst.add(path.substring(1)); return; &#125; for (Integer start: starts[end]) &#123; String word = s.substring(start, end); dfs(rst, " " + word + path, s, starts, start); &#125;&#125;private int getMaxLen(Set&lt;String&gt; wordDict) &#123; int max = 0; for (String s : wordDict) &#123; max = Math.max(max, s.length()); &#125; return max;&#125; Method 2: Memoization + Backtracking. Before I came up with Method 1, I also tried using a HashMap to memoize all the possible strings that can be formed starting from index i. I referred to this post from @Pixel_The time complexity is O(len(wordDict) ^ len(s / minWordLenInDict)) as @Pixel_ mentioned. The space complexity would be larger than other methods though. Here is my code: 1234567891011121314151617181920212223242526272829public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; HashMap&lt;Integer, List&lt;String&gt;&gt; memo = new HashMap&lt;&gt;(); // &lt;Starting index, rst list&gt; return dfs(s, 0, wordDict, memo);&#125;private List&lt;String&gt; dfs(String s, int start, Set&lt;String&gt; dict, HashMap&lt;Integer, List&lt;String&gt;&gt; memo) &#123; if (memo.containsKey(start)) &#123; return memo.get(start); &#125; List&lt;String&gt; rst = new ArrayList&lt;&gt;(); if (start == s.length()) &#123; rst.add(""); return rst; &#125; String curr = s.substring(start); for (String word: dict) &#123; if (curr.startsWith(word)) &#123; List&lt;String&gt; sublist = dfs(s, start + word.length(), dict, memo); for (String sub : sublist) &#123; rst.add(word + (sub.isEmpty() ? "" : " ") + sub); &#125; &#125; &#125; memo.put(start, rst); return rst;&#125; Method 3: DP Prunning + Backtracking. My very first solution is like this: using a boolean array to memoize whether a substring starting from position i to the end is breakable. This works well for worst cases like: s = “aaaaaaaaaaaab”, dict = [“a”, “aa”, “aaa”, “aaaa”]. However, for cases like: s = “aaaaaaaaaaaaa”, dict = [“a”, “aa”, “aaa”, “aaaa”], the time complexity is still O(2^n). Here is the code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public List&lt;String&gt; wordBreak(String s, Set&lt;String&gt; wordDict) &#123; List&lt;String&gt; rst = new ArrayList&lt;&gt;(); if (s == null || s.length() == 0 || wordDict == null) &#123; return rst; &#125; boolean[] canBreak = new boolean[s.length()]; Arrays.fill(canBreak, true); StringBuilder sb = new StringBuilder(); dfs(rst, sb, s, wordDict, canBreak, 0); return rst;&#125;private void dfs(List&lt;String&gt; rst, StringBuilder sb, String s, Set&lt;String&gt; dict, boolean[] canBreak, int start) &#123; if (start == s.length()) &#123; rst.add(sb.substring(1)); return; &#125; if (!canBreak[start]) &#123; return; &#125; for (int i = start + 1; i &lt;= s.length(); i++) &#123; String word = s.substring(start, i); if (!dict.contains(word)) continue; int sbBeforeAdd = sb.length(); sb.append(" " + word); int rstBeforeDFS = rst.size(); dfs(rst, sb, s, dict, canBreak, i); if (rst.size() == rstBeforeDFS) &#123; canBreak[i] = false; &#125; sb.delete(sbBeforeAdd, sb.length()); &#125;&#125;private int getMaxLen(Set&lt;String&gt; wordDict) &#123; int max = 0; for (String s : wordDict) &#123; max = Math.max(max, s.length()); &#125; return max;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[139. Word Break]]></title>
    <url>%2Fp%2Fc7e5d8ed%2F</url>
    <content type="text"><![CDATA[28.9% https://leetcode.com/problems/word-break/ Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words. 12345For example, givens = &quot;leetcode&quot;,dict = [&quot;leet&quot;, &quot;code&quot;].Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;. UPDATE (2017/1/4): The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. 方法一： 我的代码实现: 1234567891011121314151617181920212223class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; int n = s.size(); if(n==0) return true; vector&lt;bool&gt; dp(n+1, false); dp[0] = true; // vector to unordered_set的用法，重点学习一下 unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end()); for(int i=1; i&lt;=n; i++)&#123; for(int j=i-1; j&gt;=0; j--)&#123; if(dp[j])&#123; string word = s.substr(j, i-j); if(wordSet.find(word)!=wordSet.end())&#123; dp[i] = true; break; &#125; &#125; &#125; &#125; return dp[n]; &#125;&#125;; https://discuss.leetcode.com/topic/7299/c-dynamic-programming-simple-and-fast-solution-4ms-with-optimization 6ms, September 9, 2016 C++ Dynamic Programming simple and fast solution (4ms) with optimization We use a boolean vector dp[]. dp[i] is set to true if a valid word (word sequence) ends there. The optimization is to look from current position i back and only substring and do dictionary look up in case the preceding position j with dp[j] == true is found. 12345678910111213141516171819202122class Solution &#123;public: bool wordBreak(string s, unordered_set&lt;string&gt;&amp; wordDict) &#123; if(wordDict.size()==0) return false; vector&lt;bool&gt; dp(s.size()+1, false); dp[0]=true; for(int i=1; i&lt;=s.size(); i++)&#123; for(int j=i-1; j&gt;=0; j--)&#123; if(dp[j])&#123; string word = s.substr(j, i-j); if(wordDict.find(word)!=wordDict.end())&#123; dp[i] = true; break; &#125; &#125; &#125; &#125; return dp[s.size()]; &#125;&#125;; https://discuss.leetcode.com/topic/2545/a-solution-using-bfs A solution using BFS People have posted elegant solutions using DP. The solution I post below using BFS is no better than those. Just to share some new thoughts. We can use a graph to represent the possible solutions. The vertices of the graph are simply the positions of the first characters of the words and each edge actually represents a word. For example, the input string is “nightmare”, there are two ways to break it, “night mare” and “nightmare”. The graph would be 0–&gt;5–&gt;9 | _^ The question is simply to check if there is a path from 0 to 9. The most efficient way is traversing the graph using BFS with the help of a queue and a hash set. The hash set is used to keep track of the visited nodes to avoid repeating the same work. For this problem, the time complexity is O(n^2) and space complexity is O(n), the same with DP. This idea can be used to solve the problem word break II. We can simple construct the graph using BFS, save it into a map and then find all the paths using DFS. 12345678910111213141516171819202122232425262728bool wordBreak(string s, unordered_set&lt;string&gt; &amp;dict) &#123; // BFS queue&lt;int&gt; BFS; unordered_set&lt;int&gt; visited; BFS.push(0); while(BFS.size() &gt; 0) &#123; int start = BFS.front(); BFS.pop(); if(visited.find(start) == visited.end()) &#123; visited.insert(start); for(int j=start; j&lt;s.size(); j++) &#123; string word(s, start, j-start+1); if(dict.find(word) != dict.end()) &#123; BFS.push(j+1); if(j+1 == s.size()) return true; &#125; &#125; &#125; &#125; return false;&#125; python https://discuss.leetcode.com/topic/8109/simple-dp-solution-in-python-with-description Simple DP solution in Python with description 75ms, 18.48%, September 7, 2016 The idea is the following: d is an array that contains booleans d[i] is True if there is a word in the dictionary that ends at ith index of s AND d is also True at the beginning of the word Example: s = “leetcode” words = [“leet”, “code”] d[3] is True because there is “leet” in the dictionary that ends at 3rd index of “leetcode” d[7] is True because there is “code” in the dictionary that ends at the 7th index of “leetcode” AND d[3] is True The result is the last index of d.12345678910111213class Solution(object): def wordBreak(self, s, wordDict): &quot;&quot;&quot; :type s: str :type wordDict: Set[str] :rtype: bool &quot;&quot;&quot; d = [False] * len(s) for i in range(len(s)): for w in wordDict: if w == s[i-len(w)+1:i+1] and (d[i-len(w)] or i-len(w) == -1): d[i] = True return d[-1] https://discuss.leetcode.com/topic/16701/4-lines-in-python 4 lines in Python ok[i] tells whether s[:i] can be built. 12345def wordBreak(self, s, words): ok = [True] for i in range(1, len(s)+1): ok += any(ok[j] and s[j:i] in words for j in range(i)), return ok[-1] java https://discuss.leetcode.com/topic/6156/java-implementation-using-dp-in-two-ways 12ms, September 9, 2016 Java implementation using DP in two ways 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public boolean wordBreak(String s, Set&lt;String&gt; dict) &#123; boolean[] f = new boolean[s.length() + 1]; f[0] = true; /* First DP for(int i = 1; i &lt;= s.length(); i++)&#123; for(String str: dict)&#123; if(str.length() &lt;= i)&#123; if(f[i - str.length()])&#123; if(s.substring(i-str.length(), i).equals(str))&#123; f[i] = true; break; &#125; &#125; &#125; &#125; &#125;*/ //Second DP for(int i=1; i &lt;= s.length(); i++)&#123; for(int j=0; j &lt; i; j++)&#123; if(f[j] &amp;&amp; dict.contains(s.substring(j, i)))&#123; f[i] = true; break; &#125; &#125; &#125; return f[s.length()]; &#125;&#125; https://discuss.leetcode.com/topic/9615/dfs-with-path-memorizing-java-solution DFS with Path Memorizing Java Solution I write this method by what I learned from @mahdy in his post Decode Ways Use a set to record all position that cannot find a match in dict. That cuts down the run time of DFS to O(n^2) 12345678910111213141516171819202122232425public class Solution &#123; public boolean wordBreak(String s, Set&lt;String&gt; dict) &#123; // DFS Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); return dfs(s, 0, dict, set); &#125; private boolean dfs(String s, int index, Set&lt;String&gt; dict, Set&lt;Integer&gt; set)&#123; // base case if(index == s.length()) return true; // check memory if(set.contains(index)) return false; // recursion for(int i = index+1;i &lt;= s.length();i++)&#123; String t = s.substring(index, i); if(dict.contains(t)) if(dfs(s, i, dict, set)) return true; else set.add(i); &#125; set.add(index); return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[138. Copy List with Random Pointer]]></title>
    <url>%2Fp%2F9bcae609%2F</url>
    <content type="text"><![CDATA[26.5% https://leetcode.com/problems/copy-list-with-random-pointer/#/description A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. https://discuss.leetcode.com/topic/5831/2-clean-c-algorithms-without-using-extra-array-hash-table-algorithms-are-explained-step-by-step 2 clean C++ algorithms without using extra array/hash table. Algorithms are explained step by step. 123456789101112131415161718192021222324252627282930313233343536373839//// Here&apos;s how the 1st algorithm goes.// Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.// Step 1:// Build the 2nd list by creating a new node for each node in 1st list. // While doing so, insert each new node after it&apos;s corresponding node in the 1st list.// Step 2:// The new head is the 2nd node as that was the first inserted node.// Step 3:// Fix the random pointers in the 2nd list: (Remember that l1-&gt;next is actually l2)// l2-&gt;random will be the node in 2nd list that corresponds l1-&gt;random, // which is next node of l1-&gt;random.// Step 4:// Separate the combined list into 2: Splice out nodes that are part of second list. // Return the new head that we saved in step 2.//RandomListNode *copyRandomList(RandomListNode *head) &#123; RandomListNode *newHead, *l1, *l2; if (head == NULL) return NULL; for (l1 = head; l1 != NULL; l1 = l1-&gt;next-&gt;next) &#123; l2 = new RandomListNode(l1-&gt;label); l2-&gt;next = l1-&gt;next; l1-&gt;next = l2; &#125; newHead = head-&gt;next; for (l1 = head; l1 != NULL; l1 = l1-&gt;next-&gt;next) &#123; if (l1-&gt;random != NULL) l1-&gt;next-&gt;random = l1-&gt;random-&gt;next; &#125; for (l1 = head; l1 != NULL; l1 = l1-&gt;next) &#123; l2 = l1-&gt;next; l1-&gt;next = l2-&gt;next; if (l2-&gt;next != NULL) l2-&gt;next = l2-&gt;next-&gt;next; &#125; return newHead;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//// Here&apos;s how the 2nd algorithm goes.// Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.// Step 1:// Build the 2nd list by creating a new node for each node in 1st list. // While doing so, set the next pointer of the new node to the random pointer // of the corresponding node in the 1st list. And set the random pointer of the // 1st list&apos;s node to the newly created node.// Step 2:// The new head is the node pointed to by the random pointer of the 1st list.// Step 3:// Fix the random pointers in the 2nd list: (Remember that l1-&gt;random is l2)// l2-&gt;random will be the node in 2nd list that corresponds to the node in the // 1st list that is pointed to by l2-&gt;next, // Step 4:// Restore the random pointers of the 1st list and fix the next pointers of the // 2nd list. random pointer of the node in 1st list is the next pointer of the // corresponding node in the 2nd list. This is what we had done in the // 1st step and now we are reverting back. next pointer of the node in // 2nd list is the random pointer of the node in 1st list that is pointed to // by the next pointer of the corresponding node in the 1st list.// Return the new head that we saved in step 2.//RandomListNode *copyRandomList(RandomListNode *head) &#123; RandomListNode *newHead, *l1, *l2; if (head == NULL) return NULL; for (l1 = head; l1 != NULL; l1 = l1-&gt;next) &#123; l2 = new RandomListNode(l1-&gt;label); l2-&gt;next = l1-&gt;random; l1-&gt;random = l2; &#125; newHead = head-&gt;random; for (l1 = head; l1 != NULL; l1 = l1-&gt;next) &#123; l2 = l1-&gt;random; l2-&gt;random = l2-&gt;next ? l2-&gt;next-&gt;random : NULL; &#125; for (l1 = head; l1 != NULL; l1 = l1-&gt;next) &#123; l2 = l1-&gt;random; l1-&gt;random = l2-&gt;next; l2-&gt;next = l1-&gt;next ? l1-&gt;next-&gt;random : NULL; &#125; return newHead;&#125; https://discuss.leetcode.com/topic/22194/o-n-time-o-1-space-c O(n) time O(1) Space C++ 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode * head) &#123; RandomListNode * head_cp = nullptr, * cur = head, * cur_cp = nullptr; if (head == nullptr) return nullptr; while (cur != nullptr) &#123; cur_cp = new RandomListNode (cur-&gt;label); cur_cp-&gt;next = cur-&gt;next; cur-&gt;next = cur_cp; cur = cur_cp-&gt;next; &#125; cur = head; while (cur != nullptr) &#123; cur_cp = cur-&gt;next; if (cur-&gt;random) cur_cp-&gt;random = cur-&gt;random-&gt;next; cur = cur_cp -&gt;next; &#125; cur = head; head_cp = head-&gt;next; while (cur != nullptr) &#123; cur_cp = cur-&gt;next; cur-&gt;next = cur_cp-&gt;next; cur = cur-&gt;next; if (cur) cur_cp-&gt;next = cur-&gt;next; &#125; return head_cp; &#125;&#125;; https://discuss.leetcode.com/topic/12025/c-simple-recursive-solution C++ simple recursive solution 12345678910111213141516class Solution &#123;unordered_map&lt;RandomListNode*, RandomListNode*&gt; hmap;public:RandomListNode *copyRandomList(RandomListNode *head) &#123; if (!head) return NULL; if (hmap.find(head) != hmap.end()) return hmap.find(head)-&gt;second; RandomListNode* node = new RandomListNode(head-&gt;label); hmap[head] = node; node-&gt;next = copyRandomList(head-&gt;next); node-&gt;random = copyRandomList(head-&gt;random); return node;&#125;&#125;; https://discuss.leetcode.com/topic/7594/a-solution-with-constant-space-complexity-o-1-and-linear-time-complexity-o-n A solution with constant space complexity O(1) and linear time complexity O(N) An intuitive solution is to keep a hash table for each node in the list, via which we just need to iterate the list in 2 rounds respectively to create nodes and assign the values for their random pointers. As a result, the space complexity of this solution is O(N), although with a linear time complexity. As an optimised solution, we could reduce the space complexity into constant. The idea is to associate the original node with its copy node in a single linked list. In this way, we don’t need extra space to keep track of the new nodes. The algorithm is composed of the follow three steps which are also 3 iteration rounds. Iterate the original list and duplicate each node. The duplicate of each node follows its original immediately. Iterate the new list and assign the random pointer for each duplicated node. Restore the original list and extract the duplicated nodes. The algorithm is implemented as follows: 123456789101112131415161718192021222324252627282930313233343536373839404142434445public RandomListNode copyRandomList(RandomListNode head) &#123; RandomListNode iter = head, next; // First round: make copy of each node, // and link them together side-by-side in a single list. while (iter != null) &#123; next = iter.next; RandomListNode copy = new RandomListNode(iter.label); iter.next = copy; copy.next = next; iter = next; &#125; // Second round: assign random pointers for the copy nodes. iter = head; while (iter != null) &#123; if (iter.random != null) &#123; iter.next.random = iter.random.next; &#125; iter = iter.next.next; &#125; // Third round: restore the original list, and extract the copy list. iter = head; RandomListNode pseudoHead = new RandomListNode(0); RandomListNode copy, copyIter = pseudoHead; while (iter != null) &#123; next = iter.next.next; // extract the copy copy = iter.next; copyIter.next = copy; copyIter = copy; // restore the original list iter.next = next; iter = next; &#125; return pseudoHead.next;&#125; https://discuss.leetcode.com/topic/18086/java-o-n-solution Java O(n) solution 12345678910111213141516171819202122public RandomListNode copyRandomList(RandomListNode head) &#123; if (head == null) return null; Map&lt;RandomListNode, RandomListNode&gt; map = new HashMap&lt;RandomListNode, RandomListNode&gt;(); // loop 1. copy all the nodes RandomListNode node = head; while (node != null) &#123; map.put(node, new RandomListNode(node.label)); node = node.next; &#125; // loop 2. assign next and random pointers node = head; while (node != null) &#123; map.get(node).next = map.get(node.next); map.get(node).random = map.get(node.random); node = node.next; &#125; return map.get(head);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>hash table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[137. Single Number II]]></title>
    <url>%2Fp%2F3b63b6e2%2F</url>
    <content type="text"><![CDATA[40.5% https://leetcode.com/problems/single-number-ii/?tab=Description Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 方法一： 统计每一位的个数，模3，然后就是答案了 方法二： https://discuss.leetcode.com/topic/2031/challenge-me-thx Challenge me , thx 12345678public int singleNumber(int[] A) &#123; int ones = 0, twos = 0; for(int i = 0; i &lt; A.length; i++)&#123; ones = (ones ^ A[i]) &amp; ~twos; twos = (twos ^ A[i]) &amp; ~ones; &#125; return ones;&#125; https://discuss.leetcode.com/topic/11877/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers Detailed explanation and generalization of the bitwise operation method for single numbers Statement of our problem: “Given an array of integers, every element appears k (k &gt; 1) times except for one, which appears p times (p &gt;= 1, p % k != 0). Find that single one.” As others pointed out, in order to apply the bitwise operations, we should rethink how integers are represented in computers – by bits. To start, let’s consider only one bit for now. Suppose we have an array of 1-bit numbers (which can only be 0 or 1), we’d like to count the number of 1’s in the array such that whenever the counted number of 1 reaches a certain value, say k, the count returns to zero and starts over (In case you are curious, this k will be the same as the one in the problem statement above). To keep track of how many 1’s we have encountered so far, we need a counter. Suppose the counter has m bits in binary form: xm, …, x1 (from most significant bit to least significant bit). We can conclude at least the following four properties of the counter: There is an initial state of the counter, which for simplicity is zero; For each input from the array, if we hit a 0, the counter should remain unchanged; For each input from the array, if we hit a 1, the counter should increase by one; In order to cover k counts, we require 2^m &gt;= k, which implies m &gt;= logk. Here is the key part: how each bit in the counter (x1 to xm) changes as we are scanning the array. Note we are prompted to use bitwise operations. In order to satisfy the second property, recall what bitwise operations will not change the operand if the other operand is 0? Yes, you got it: x = x | 0 and x = x ^ 0. Okay, we have an expression now: x = x | i or x = x ^ i, where i is the scanned element from the array. Which one is better? We don’t know yet. So, let’s just do the actual counting: At the beginning, all bits of the counter is initialized to zero, i.e., xm = 0, …, x1 = 0. Since we are gonna choose bitwise operations that guarantee all bits of the counter remain unchanged if we hit 0’s, the counter will be 0 until we hit the first 1 in the array. After we hit the first 1, we got: xm = 0, …,x2 = 0, x1 = 1. Let’s continue until we hit the second 1, after which we have: xm = 0, …, x2 = 1, x1 = 0. Note that x1 changed from 1 to 0. For x1 = x1 | i, after the second count, x1 will still be 1. So it’s clear we should use x1 = x1 ^ i. What about x2, …, xm? The idea is to find the condition under which x2, …, xm will change their values. Take x2 as an example. If we hit a 1 and need to change the value of x2, what must be the value of x1 right before we do the change? The answer is: x1 must be 1 otherwise we shouldn’t change x2 because changing x1 from 0 to 1 will do the job. So x2 will change value only if x1 and i are both 1, or mathematically, x2 = x2 ^ (x1 &amp; i). Similarly xm will change value only when xm-1, …, x1 and i are all 1: xm = xm ^ (xm-1 &amp; … &amp; x1 &amp; i). Bingo, we’ve found the bitwise operations! However, you may notice that the bitwise operations found above will count from 0 until 2^m - 1, instead of k. If k &lt; 2^m - 1, we need some “cutting” mechanism to reinitialize the counter to 0 when the count reaches k. To this end, we apply bitwise AND to xm,…, x1 with some variable called mask, i.e., xm = xm &amp; mask, …, x1 = x1 &amp; mask. If we can make sure that mask will be 0 only when the count reaches k and be 1 for all other count cases, then we are done. How do we achieve that? Try to think what distinguishes the case with k count from all other count cases. Yes, it’s the count of 1’s! For each count, we have unique values for each bit of the counter, which can be regarded as its state. If we write k in its binary form: km,…, k1. we can construct mask as follows: 1mask = ~(y1 &amp; y2 &amp; ... &amp; ym), where yj = xj if kj = 1 and yj = ~xj if kj = 0 (j = 1 to m). 12345Let&apos;s do some examples:k = 3: k1 = 1, k2 = 1, mask = ~(x1 &amp; x2);k = 5: k1 = 1, k2 = 0, k3 = 1, mask = ~(x1 &amp; ~x2 &amp; x3); In summary, our algorithm will go like this: 123456789101112for (int i : array) &#123; xm ^= (xm-1 &amp; ... &amp; x1 &amp; i); xm-1 ^= (xm-2 &amp; ... &amp; x1 &amp; i); ..... x1 ^= i; mask = ~(y1 &amp; y2 &amp; ... &amp; ym) where yj = xj if kj = 1 and yj = ~xj if kj = 0 (j = 1 to m). xm &amp;= mask; ...... x1 &amp;= mask;&#125; Now it’s time to generalize our results from 1-bit number case to 32-bit integers. One straightforward way would be creating 32 counters for each bit in the integer. You’ve probably already seen this in other posted codes. But if we take advantage of bitwise operations, we may be able to manage all the 32 counters “collectively”. By saying “collectively” we mean using m 32-bit integers instead of 32 m-bit counters, where m is the minimum integer that satisfies m &gt;= logk. The reason is that bitwise operations apply only to each bit so operations on different bits are independent of each other(kind obvious, right?). This allows us to group the corresponding bits of the 32 counters into one 32-bit integer (for schematic steps, see comments below). Since each counter has m bits, we end up with m 32-bit integers. Therefore, in the algorithm developed above, we just need to regard x1 to xm as 32-bit integers instead of 1-bit numbers and we are done. Easy, hum? The last thing is what value we should return, or equivalently which one of x1 to xm will equal the single element. To get the correct answer, we need to understand what the m 32-bit integers x1 to xm represent. Take x1 as an example. x1 has 32 bits and let’s label them as r (r = 1 to 32), After we are done scanning the input array, the value for the r-th bit of x1 will be determined by the r-th bit of all the elements in the array (more specifically, suppose the total count of 1 for the r-th bit of all the elements in the array is q, q’ = q % k and in its binary form: q’m,…,q’1, then by definition the r-th bit of x1 will be equal to q’1). Now you can ask yourself this question: what does it imply if the r-th bit of x1 is 1? The answer is to find what can contribute to this 1. Will an element that appears k times contribute? No. Why? Because for an element to contribute, it has to satisfy at least two conditions at the same time: the r-th bit of this element is 1 and the number of appearance of this 1 is not an integer multiple of k. The first condition is trivial. The second comes from the fact that whenever the number of 1 hit is k, the counter will go back to zero, which means the corresponding bit in x1 will be reset to 0. For an element that appears k times, it’s impossible to meet these two conditions simultaneously so it won’t contribute. At last, only the single element which appears p (p % k != 0) times will contribute. If p &gt; k, then the first k * [p/k] ([p/k]denotes the integer part of p/k) single elements won’t contribute either. Then we can always set p’ = p % k and say the single element appears effectively p’ times. Let’s write p’ in its binary form: p’m, …, p’1. (note that p’ &lt; k, so it will fit into m bits). Here I claim the condition for x1 to equal the single element is p’1 = 1. Quick proof: if the r-th bit of x1 is 1, we can safely say the r-th bit of the single element is also 1. We are left to prove that if the r-th bit of x1 is 0, then the r-th bit of the single element can only be 0. Just suppose in this case the r-th bit of the single element is 1, let’s see what will happen. At the end of the scan, this 1 will be counted p’ times. If we write p’ in its binary form: p’m, …, p’1, then by definition the r-th bit of x1 will equal p’1, which is 1. This contradicts with the presumption that the r-th bit of x1 is 0. Since this is true for all bits in x1, we can conclude x1 will equal the single element if p’1 = 1. Similarly we can show xj will equal the single element if p’j = 1 (j = 1 to m). Now it’s clear what we should return. Just express p’ = p % k in its binary form and return any of the corresponding xj as long as p’j = 1. In total, the algorithm will run in O(n * logk) time and O(logk) space. Hope this helps! https://discuss.leetcode.com/topic/11877/detailed-explanation-and-generalization-of-the-bitwise-operation-method-for-single-numbers/2 Here is a list of few quick examples to show how the algorithm works: k = 2, p = 1. k is 2, then m = 1, we need only one 32-bit integer(x1) as the counter. And 2^m = k so we do not even need a mask! A complete java program will look like: 1234567public int singleNumber(int[] A) &#123; int x1 = 0; for (int i : A) &#123; x1 ^= i; &#125; return x1;&#125; k = 3, p = 1. k is 3, then m = 2, we need two 32-bit integers(x2, x1) as the counter. And 2^m &gt; k so we do need a mask. Write k in its binary form: k = ‘11’, then k1 = 1, k2 = 1, so we have mask = ~ (x1 &amp; x2). A complete java program will look like: 12345678910111213141516public int singleNumber(int[] A) &#123; int x1 = 0; int x2 = 0; int mask = 0; for (int i : A) &#123; x2 ^= x1 &amp; i; x1 ^= i; mask = ~(x1 &amp; x2); x2 &amp;= mask; x1 &amp;= mask; &#125; return x1; // p = 1, in binary form p = &apos;01&apos;, then p1 = 1, so we should return x1; // if p = 2, in binary form p = &apos;10&apos;, then p2 = 1, so we should return x2.&#125; k = 5, p = 3. k is 5, then m = 3, we need three 32-bit integers(x3, x2, x1) as the counter. And 2^m &gt; k so we need a mask. Write k in its binary form: k = ‘101’, then k1 = 1, k2 = 0, k3 = 1, so we have mask = ~(x1 &amp; ~x2 &amp; x3). A complete java program will look like: 123456789101112131415161718192021public int singleNumber(int[] A) &#123; int x1 = 0; int x2 = 0; int x3 = 0; int mask = 0; for (int i : A) &#123; x3 ^= x2 &amp; x1 &amp; i; x2 ^= x1 &amp; i; x1 ^= i; mask = ~(x1 &amp; ~x2 &amp; x3); x3 &amp;= mask; x2 &amp;= mask; x1 &amp;= mask; &#125; return x1; // p = 3, in binary form p = &apos;011&apos;, then p1 = p2 = 1, // so we can return either x1 or x2; // But if p = 4, in binary form p = &apos;100&apos;, then only p3 = 1, // which implies we can only return x3.&#125; You can easily come up with other examples. If you have any questions about the explanation, please let me know. I would appreciate your feedback. Thanks! https://discuss.leetcode.com/topic/22821/an-general-way-to-handle-all-this-sort-of-questions An General Way to Handle All this sort of questions. this kind of question the key idea is design a counter that record state. the problem can be every one occurs K times except one occurs M times. for this question, K =3 ,M = 1(or 2) .so to represent 3 state, we need two bit. let say it is a and b, and c is the incoming bit.then we can design a table to implement the state move. 12345678current incoming nexta b c a b0 0 0 0 00 1 0 0 11 0 0 1 00 0 1 0 10 1 1 1 01 0 1 0 0 like circuit design, we can find out what the next state will be with the incoming bit.( we only need find the ones)then we have for a to be 1, we have 1234current incoming nexta b c a b1 0 0 1 00 1 1 1 0 and this is can be represented by 1a=a&amp;~b&amp;~c + ~a&amp;b&amp;c and b can do the same we , and we find that 1b= ~a&amp;b&amp;~c+~a&amp;~b&amp;c and this is the final formula of a and b and just one of the result set, because for different state move table definition, we can generate different formulas, and this one is may not the most optimised. as you may see other’s answer that have a much simple formula, and that formula also corresponding to specific state move table. (if you like ,you can reverse their formula to a state move table, just using the same way but reversely) for this questions we need to find the except one as the question don’t say if the one appears one time or two time , so for ab both 1201 10 =&gt; 100 =&gt; 0 we should return a|b; this is the key idea , we can design any based counter and find the occurs any times except one . here is my code. with comment. 1234567891011121314151617181920212223public class Solution &#123; public int singleNumber(int[] nums) &#123; //we need to implement a tree-time counter(base 3) that if a bit appears three time ,it will be zero. //#curent income ouput //# ab c/c ab/ab //# 00 1/0 01/00 //# 01 1/0 10/01 //# 10 1/0 00/10 // a=~abc+a~b~c; // b=~a~bc+~ab~c; int a=0; int b=0; for(int c:nums)&#123; int ta=(~a&amp;b&amp;c)|(a&amp;~b&amp;~c); b=(~a&amp;~b&amp;c)|(~a&amp;b&amp;~c); a=ta; &#125; //we need find the number that is 01,10 =&gt; 1, 00 =&gt; 0. return a|b; &#125;&#125; this is a general solution . and it comes from the Circuit Design on course digital logic. https://discuss.leetcode.com/topic/43166/java-o-n-easy-to-understand-solution-easily-extended-to-any-times-of-occurance Java O(n) easy to understand solution, easily extended to any times of occurance The usual bit manipulation code is bit hard to get and replicate. I like to think about the number in 32 bits and just count how many 1s are there in each bit, and sum %= 3 will clear it once it reaches 3. After running for all the numbers for each bit, if we have a 1, then that 1 belongs to the single number, we can simply move it back to its spot by doing ans |= sum &lt;&lt; i; This has complexity of O(32n), which is essentially O(n) and very easy to think and implement. Plus, you get a general solution for any times of occurrence. Say all the numbers have 5 times, just do sum %= 5. 12345678910111213141516public int singleNumber(int[] nums) &#123; int ans = 0; for(int i = 0; i &lt; 32; i++) &#123; int sum = 0; for(int j = 0; j &lt; nums.length; j++) &#123; if(((nums[j] &gt;&gt; i) &amp; 1) == 1) &#123; sum++; sum %= 3; &#125; &#125; if(sum != 0) &#123; ans |= sum &lt;&lt; i; &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/2926/accepted-code-with-proper-explaination-does-anyone-have-a-better-idea Accepted code with proper Explaination. Does anyone have a better idea? The code makes use of 2 variables. ones - At any point of time, this variable holds XOR of all the elements which haveappeared “only” once.twos - At any point of time, this variable holds XOR of all the elements which haveappeared “only” twice. So if at any point time, A new number appears - It gets XOR’d to the variable “ones”. A number gets repeated(appears twice) - It is removed from “ones” and XOR’d to the variable “twos”. A number appears for the third time - It gets removed from both “ones” and “twos”. The final answer we want is the value present in “ones” - coz, it holds the unique element. So if we explain how steps 1 to 3 happens in the code, we are done.Before explaining above 3 steps, lets look at last three lines of the code, common_bit_mask = ~ (ones &amp; twos) ones &amp; = common_bit_mask twos &amp; = common_bit_mask All it does is, common 1’s between “ones” and “twos” are converted to zero. For simplicity, in all the below explanations - consider we have got only 4 elements in the array (one unique element and 3 repeated elements - in any order). Explanation for step 1 Lets say a new element(x) appears. CURRENT SITUATION - Both variables - “ones” and “twos” has not recorded “x”. Observe the statement “twos| = ones &amp; x”.Since bit representation of “x” is not present in “ones”, AND condition yields nothing. So “twos” does not get bit representation of “x”.But, in next step “ones ^= x” - “ones” ends up adding bits of “x”. Thus new element gets recorded in “ones” but not in “twos”. The last 3 lines of code as explained already, converts common 1’s b/w “ones” and “twos” to zeros.Since as of now, only “ones” has “x” and not “twos” - last 3 lines does nothing. Explanation for step 2. Lets say an element(x) appears twice. CURRENT SITUATION - “ones” has recorded “x” but not “twos”. Now due to the statement, “twos| = ones &amp; x” - “twos” ends up getting bits of x.But due to the statement, “ones ^ = x” - “ones” removes “x” from its binary representation. Again, last 3 lines of code does nothing.So ultimately, “twos” ends up getting bits of “x” and “ones” ends up losing bits of “x”. Explanation for step 3. Lets say an element(x) appears for the third time. CURRENT SITUATION - “ones” does not have bit representation of “x” but “twos” has. Though “ones &amp; x” does not yield nothing .. “twos” by itself has bit representation of “x”. So after this statement, “two” has bit representation of “x”.Due to “ones^=x”, after this step, “one” also ends up getting bit representation of “x”. Now last 3 lines of code removes common 1’s of “ones” and “twos” - which is the bit representation of “x”.Thus both “ones” and “twos” ends up losing bit representation of “x”. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public: // Let us take the example of &#123;3, 3, 2, 3&#125; to understand this int singleNumber(int A[], int n) &#123; int ones=0, twos =0; int common_bit_mask; for(int i=0; i&lt;n;i++) &#123; /* The expression &quot;one &amp; arr[i]&quot; gives the bits that are there in both &apos;ones&apos; and new element from arr[]. We add these bits to &apos;twos&apos; using bitwise OR Value of &apos;twos&apos; will be set as 0, 3, 3 and 1 after 1st, 2nd, 3rd and 4th iterations respectively */ twos= twos|(ones&amp;A[i]); /* XOR the new bits with previous &apos;ones&apos; to get all bits appearing odd number of times Value of &apos;ones&apos; will be set as 3, 0, 2 and 3 after 1st, 2nd, 3rd and 4th iterations respectively */ ones=ones^A[i]; /* The common bits are those bits which appear third time So these bits should not be there in both &apos;ones&apos; and &apos;twos&apos;. common_bit_mask contains all these bits as 0, so that the bits can be removed from &apos;ones&apos; and &apos;twos&apos; Value of &apos;common_bit_mask&apos; will be set as 00, 00, 01 and 10 after 1st, 2nd, 3rd and 4th iterations respectively */ common_bit_mask= ~(ones&amp;twos); /* Remove common bits (the bits that appear third time) from &apos;ones&apos; Value of &apos;ones&apos; will be set as 3, 0, 0 and 2 after 1st, 2nd, 3rd and 4th iterations respectively */ ones &amp;=common_bit_mask; /* Remove common bits (the bits that appear third time) from &apos;twos&apos; Value of &apos;twos&apos; will be set as 0, 3, 1 and 0 after 1st, 2nd, 3rd and 4th itearations respectively */ twos &amp;=common_bit_mask; &#125; return ones; &#125; &#125;; https://discuss.leetcode.com/topic/23584/a-general-c-solution-for-these-type-problems A general C++ solution for these type problems There are so many brilliant solutions for this problem used “| &amp; ^ ~”, and I have learned a lot from these solutions. Here is a general solution for who not familiar with “| &amp; ^ ~”. Q: Most elements appeared k times, except one. Find this “one”. 12345678910111213141516171819202122232425int singleNumber(vector&lt;int&gt;&amp; s) &#123; vector&lt;int&gt; t(32);////Made a array contain 32 elements. int sz = s.size(); int i, j, n; for (i = 0; i &lt; sz; ++i) &#123; n = s[i]; for (j = 31; j &gt;= 0; --j) &#123; t[j] += n &amp; 1;//Find the last digit. n &gt;&gt;= 1; if (!n) break; &#125; &#125; int res = 0; for (j = 31; j &gt;= 0; --j) &#123; n = t[j] % 3;//&quot;3&quot; represents k times. if (n) res += 1 &lt;&lt; (31 - j); &#125; return res;&#125; https://discuss.leetcode.com/topic/34725/my-own-explanation-of-bit-manipulation-method-might-be-easier-to-understand My own explanation of bit manipulation method, might be easier to understand Consider the following fact: Write all numbers in binary form, then for any bit 1 that appeared 3*n times (n is an integer), the bit can only present in numbers that appeared 3 times e.g. 0010 0010 0010 1011 1011 1011 1000 (assuming 4-bit integers)2(0010) and 11(1011) appeared 3 times, and digit counts are: 12345Digits 3 2 1 0Counts 4 0 6 3Counts%3 1 0 0 0 Counts on 2,1,0 are all times of 3, the only digit index that has Counts % 3 != 0 is 3 Therefore, to find the number that appeared only 1 or 2 times, we only need to extract all bits that has Counts %3 != 0 Now consider how we could do this by bit manipulation since counts % 3 has only 3 states: 0(00),1(01),2(10)we could use a TWO BIT COUNTER (Two, One) to represent Counts % 3, now we could do a little research on state transitions, for each bit, let B be the input bit, we can enumerate the all possible state transitions, Two+, One+ is the new state of Two, One. (here we need to use some knowledge in Digital Logic Design) 1234567891011121314151617Two One B Two+ One+0 0 0 0 00 0 1 0 10 1 0 0 10 1 1 1 01 0 0 1 01 0 1 0 01 1 0 X X (X represents we don&apos;t care)1 1 1 X X We could then draw the Karnaugh map to analyze the logic (https://en.wikipedia.org/wiki/Karnaugh_map), and then we get: 123One+ = (One ^ B) &amp; (~Two)Two+ = (~One+) &amp; (Two ^ B) Now for int_32, we need only 2 int_32 two represent Two and One for each bit and update Two and One using the rules derived above Code is here (C++): 12345678910111213class Solution &#123; public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int counterOne = 0; int counterTwo = 0; for (int i = 0; i &lt; nums.size(); i++)&#123; counterOne = (~counterTwo) &amp; (counterOne ^ nums[i]); counterTwo = (~counterOne) &amp; (counterTwo ^ nums[i]); &#125; return counterOne; &#125;&#125;; https://discuss.leetcode.com/topic/17629/the-simplest-solution-ever-with-clear-explanation The simplest solution ever with clear explanation The key to solve this problem is the count of 1s of each bit of all numbers. Take one bit number for example: nums = [1, 1, 1, 0, 0, 0, …, x] . All numbers are 0 or 1. We know that every number appears three times except for just one number. So, if the count of 1s in nums is 0, 3, 6, …, 3 n, then the single number is 0. And if the count of 1s in nums is 1, 4, 7, …, 3\n+1, then the single number is 1. So, for an array “ nums “ that contains only 0 or 1, the code to find the single number are: 1234count = 0for num in nums: count = (count + num) % 3return count To make “count” less than 3, mod “count” with 3 in every loop. Below is the procedure for finding the single number in [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]: 123456Table 1:++=======++===+===+===+===+===+===+===+===+===+===+===+===+===+====++|| num || | 1 | 0 | 1 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 ||++-------++---+---+---+---+---+---+---+---+---+---+---+---+---+----++|| count || 0 | 1 | 1 | 2 | 0 | 0 | 1 | 1 | 2 | 2 | 0 | 0 | 1 | 1* ||++=======++===+===+===+===+===+===+===+===+===+===+===+===+===+====++ So the single number is 1. We can write the calculate table for expression “count’ = (count + num) % 3”: 12345678910111213141516Table 2:++=======+=====+========++|| count | num | count&apos; ||++-------+-----+--------++|| 0 | 0 | 0 ||++-------+-----+--------++|| 1 | 0 | 1 ||++-------+-----+--------++|| 2 | 0 | 2 ||++-------+-----+--------++|| 0 | 1 | 1 ||++-------+-----+--------++|| 1 | 1 | 2 ||++-------+-----+--------++|| 2 | 1 | 0 ||++-------+-----+--------++ To extend this algorithm to 32bits number. We need to rewrite these code to bit operation expressions. And the key is rewriting the expression “ count’ = (count + num) % 3 “ to bit operation expressions. Write binary numbers of “ count “ and “ count’ “ in “Table 2”. And split their bits into two column: 12345678910111213141516171819Table 3:++=======+============+=====+============+========++|| | count | num | count&apos; | |||| count | (bin) | | (bin) | count&apos; |||| (dec) ++=====+=====+=====+=====+=====++ (dec) |||| || b1 | b0 | num | b1&apos; | b0&apos; || ||++-------++-----+-----+-----+-----+-----++--------++|| 0 || 0 | 0 | 0 | 0 | 0 || 0 ||++-------++-----+-----+-----+-----+-----++--------++|| 1 || 0 | 1 | 0 | 0 | 1 || 1 ||++-------++-----+-----+-----+-----+-----++--------++|| 2 || 1 | 0 | 0 | 1 | 0 || 2 ||++-------++-----+-----+-----+-----+-----++--------++|| 0 || 0 | 0 | 1 | 0 | 1 || 1 ||++-------++-----+-----+-----+-----+-----++--------++|| 1 || 0 | 1 | 1 | 1 | 0 || 2 ||++-------++-----+-----+-----+-----+-----++--------++|| 2 || 1 | 0 | 1 | 0 | 0 || 0 ||++=======++===========+=====+===========++========++ Here comes the hardest part of this solution. “Table 3” is a truth table, we need to use it to find the formulas to calculate “ b0’ “ and “ b1’ “: 12b0&apos; = f(b1, b0, num)b1&apos; = g(b1, b0, num) With observations, guesses, experiments and even some luck. Finally I got two simple and elegant formulas: 12b0&apos; = (b0 ^ num) &amp; (~b1)b1&apos; = (b1 ^ num) &amp; (~b0&apos;) The AC code: 123456789class Solution: # @param &#123;integer[]&#125; nums # @return &#123;integer&#125; def singleNumber(self, nums): b1, b0 = 0, 0 for num in nums: b0 = (b0 ^ num) &amp; (~b1) b1 = (b1 ^ num) &amp; (~b0) return b0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[136. Single Number]]></title>
    <url>%2Fp%2F66a2ee90%2F</url>
    <content type="text"><![CDATA[53.2% https://leetcode.com/problems/single-number/?tab=Description Given an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 方法一： 注意下面代码中res=0，不能是 int res，要给res赋一个初始值，否则出现错误。 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for(auto num:nums) res ^= num; return res; &#125;&#125;; 我的代码实现： 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for(auto num:nums) res ^= num; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/19563/python-different-solutions 1234567def singleNumber1(self, nums): dic = &#123;&#125; for num in nums: dic[num] = dic.get(num, 0)+1 for key, val in dic.items(): if val == 1: return key 12345def singleNumber2(self, nums): res = 0 for num in nums: res ^= num return res 12def singleNumber3(self, nums): return 2*sum(set(nums))-sum(nums) 12def singleNumber4(self, nums): return reduce(lambda x, y: x ^ y, nums) 12def singleNumber(self, nums): return reduce(operator.xor, nums) https://discuss.leetcode.com/topic/42358/1-line-simple-python-solution 123class Solution(object): def singleNumber(self, nums): return sum(list(set(nums)))*2 - sum(nums) my code12345678910class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; res = 0 for num in nums: res ^= num return res 1234567class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; return reduce((lambda x, y : x^y), nums) java 12345678public class Solution &#123; public int singleNumber(int[] nums) &#123; int res = 0; for(int i=0; i&lt;nums.length; i++) res ^= nums[i]; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[135. Candy]]></title>
    <url>%2Fp%2Fd0cc5467%2F</url>
    <content type="text"><![CDATA[24.2% https://leetcode.com/problems/candy/ There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? 方法一： A simple solution 1234567891011121314151617181920class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int size = ratings.size(); if(size&lt;=1) return size; vector&lt;int&gt; ret(size, 1); for(int i=1; i&lt;size; i++)&#123; if(ratings[i]&gt;ratings[i-1]) ret[i] = ret[i-1]+1; &#125; for(int i=size-1; i&gt;0; i--)&#123; if(ratings[i-1]&gt;ratings[i]) ret[i-1] = max(ret[i-1], ret[i]+1); &#125; int result = 0; for(int i=0; i&lt;size; i++) result += ret[i]; return result; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; auto n = ratings.size(); if(n==1) return 1; vector&lt;int&gt; v(n, 1); for(int i=1; i&lt;n; i++)&#123; if(ratings[i]&gt;ratings[i-1]) v[i] = v[i-1]+1; &#125; for(int i=n-2; i&gt;=0; i--)&#123; if(ratings[i]&gt;ratings[i+1]) v[i] = max(v[i], v[i+1]+1); &#125; int res = 0; for(int i=0; i&lt;n; i++) res += v[i]; return res; &#125;&#125;; https://discuss.leetcode.com/topic/5243/a-simple-solution A simple solution 1234567891011121314151617181920class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int size = ratings.size(); if(size&lt;=1) return size; vector&lt;int&gt; ret(size, 1); for(int i=1; i&lt;size; i++)&#123; if(ratings[i]&gt;ratings[i-1]) ret[i] = ret[i-1]+1; &#125; for(int i=size-1; i&gt;0; i--)&#123; if(ratings[i-1]&gt;ratings[i]) ret[i-1] = max(ret[i-1], ret[i]+1); &#125; int result = 0; for(int i=0; i&lt;size; i++) result += ret[i]; return result; &#125;&#125;; https://discuss.leetcode.com/topic/17722/two-c-solutions-given-with-explanation-both-with-o-n-time-one-with-o-1-space-the-other-with-o-n-space Two C++ solutions given with explanation (both with O(N) time, one with O(1) space, the other with O(N) space) The question requires us to make sure a child with a higher rate has more candies than its left and right neighbors. One simple solution is to do two scans: one foward scan (from 1 to N-1) to make sure child i has more candies than its left neighbor if its rate is higher than its left neighbor. After the forward scan, we can guarantee that the left neighbor relationship is correct but we have to do more to make the right neighbor relationship in order; so we do the backwarad scan (from N-2 to 0) to make child i has more candies than its right neighbor i+1 if its rate is higher than its right neighbor. In the following implementation, we need a O(N) array number to save the number of candies needed for children, so it has O(N) space complexity and we do two linear scans so the time complexity is O(N) 123456789101112131415161718192021class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int len = ratings.size(), res = 0, i; if(len&gt;0) &#123; vector&lt;int&gt; number(len,0); // to save the number of candies for child[0:N-1] number[0] = 1; // forward scan to calculate how many candies needed for child i to make sure it has more candies than its left neighbor if it has a higher rate, otherwise, give one candy to it for(i=1; i&lt;len;++i) number[i] = ratings[i]&gt;ratings[i-1]?number[i-1]+1:1;// backward scan to calculate to make sure child i has more candies than its right neighbor if it has a higher rate, pick the bigger one from forward and backward scans as the final number for child i for(i=len-2, res = number[len-1]; i&gt;=0;--i) &#123; if( (ratings[i]&gt;ratings[i+1]) &amp;&amp; number[i]&lt;(number[i+1]+1) ) number[i] = number[i+1]+1; res += number[i]; &#125; &#125; return res; &#125;&#125;; Now, the question is can we do better? Do we really need two scans? If we do only forward scan, then the problem is we can not guarantee the right neighbor relationship holds. i.e. we don’t know if the following order is descending (i&gt;i+1&gt;i+2&gt;…). and that may cause issues. To fix that, we will detect the dips (the points at which the order switchs from increasing to decreasng). We will make sure all the local dips (minimum points) has only one candy and update its previous neighbors (which has hgher rates than its rate) accordingly. To do such update, we need to know when the decrease starts, so we use pPos to save that starting points.So the solution becomes: do the forward scan, if it is in an increasing order (child i rate &gt; child i-1 order), check if it is a local dip (neg_peak == true): if so, update the candy number to make sure child i-1 has one candy. if not, just give one more candy to child i. If it is in an decreasing order (child i rate &lt; child i-1 order), just give one less candy to i. don’t forget at last, we still need to make sure child N-1 has one or more candy. So O(1) space , O(N) time 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; const int len = ratings.size(); if(len&lt;=1) return len; int i, pPos, res=1, peak=1; // peak: # candies given to the i-1 child bool neg_peak = false; // flag to indicate if it is a local dip for(i=1; i&lt;len;i++) &#123; if(ratings[i] &gt;= ratings[i-1]) &#123; // it is increasing if(neg_peak) &#123; // it is a local dip, we need to make sure i-1 has one candy res -= (peak-1) * (i-pPos - (peak&gt;0)); peak = 1; neg_peak = false; &#125; // update child i candy number, if equal, set to 1 peak = (ratings[i] == ratings[i-1])? 1:++peak; res += peak; &#125; else &#123; // decreasing, just give one less candy, if it is the starting point of a decrease, update pPos if(!neg_peak) &#123;pPos = i-1; neg_peak = true;&#125; res += --peak; &#125; &#125;// don&apos;t forget to update res, if the last one is a local dip return !neg_peak? res : res - (peak-1) * (i-pPos - (peak&gt;0)); &#125;&#125;; python https://discuss.leetcode.com/topic/21025/simple-python-solution-with-two-passes Simple python solution with two passes 1234567891011121314151617class Solution: # @param &#123;integer[]&#125; ratings # @return &#123;integer&#125; def candy(self, ratings): # use two pass scan from left to right and vice versa to keep the candy level up to now # similar to like the Trapping Rain Water question res = [1]*len(ratings) # also compatable with [] input lbase = rbase = 1 # left scan for i in xrange(1, len(ratings)): lbase = lbase + 1 if ratings[i] &gt; ratings[i-1] else 1 res[i] = lbase # right scan for i in xrange(len(ratings)-2, -1, -1): rbase = rbase + 1 if ratings[i] &gt; ratings[i+1] else 1 res[i] = max(rbase, res[i]) return sum(res) java https://discuss.leetcode.com/topic/25985/simple-o-n-java-solution-with-comments Simple O(n) Java solution with comments 12345678910111213141516public class Solution &#123; public int candy(int[] ratings) &#123; int candies[] = new int[ratings.length]; Arrays.fill(candies, 1); for(int i=1; i&lt;ratings.length; i++) if(ratings[i]&gt;ratings[i-1]) candies[i] = candies[i-1] + 1; for(int i=ratings.length-1; i&gt;0; i--) if(ratings[i-1]&gt;ratings[i]) candies[i-1] = Math.max(candies[i-1], candies[i]+1); int result = 0; for(int i=0; i&lt;ratings.length; i++) result += candies[i]; return result; &#125;&#125; 1234567891011121314151617public int candy(int[] ratings) &#123; int candies[] = new int[ratings.length]; Arrays.fill(candies, 1);// Give each child 1 candy for (int i = 1; i &lt; candies.length; i++)&#123;// Scan from left to right, to make sure right higher rated child gets 1 more candy than left lower rated child if (ratings[i] &gt; ratings[i - 1]) candies[i] = (candies[i - 1] + 1); &#125; for (int i = candies.length - 2; i &gt;= 0; i--) &#123;// Scan from right to left, to make sure left higher rated child gets 1 more candy than right lower rated child if (ratings[i] &gt; ratings[i + 1]) candies[i] = Math.max(candies[i], (candies[i + 1] + 1)); &#125; int sum = 0; for (int candy : candies) sum += candy; return sum;&#125; https://discuss.leetcode.com/topic/8208/one-pass-constant-space-java-solution One-pass constant space Java solution This solution picks each element from the input array only once. First, we give a candy to the first child. Then for each child we have three cases: His/her rating is equal to the previous one -&gt; give 1 candy. His/her rating is greater than the previous one -&gt; give him (previous + 1) candies. His/her rating is less than the previous one -&gt; don’t know what to do yet, let’s just count the number of such consequent cases. When we enter 1 or 2 condition we can check our count from 3. If it’s not zero then we know that we were descending before and we have everything to update our total candies amount: number of children in descending sequence of raitings - coundDown, number of candies given at peak - prev (we don’t update prev when descending). Total number of candies for “descending” children can be found through arithmetic progression formula (1+2+…+countDown). Plus we need to update our peak child if his number of candies is less then or equal to countDown. Here’s a pretty concise code below. 详情参考以下链接：http://www.allenlipeng47.com/blog/index.php/2016/07/21/candy/ But there is a O(n) time, O(1) space solution, which is pretty hard to understand. Let me try to explain this O(1) space solution.123456789101112131415161718192021222324252627public static int candy(int[] ratings) &#123; int pre = 1, countDown = 0, total = 1; for (int i = 1; i &lt; ratings.length; i++) &#123; if (ratings[i] &gt;= ratings[i - 1]) &#123; if (countDown &gt; 0) &#123; total += countDown * (countDown + 1) / 2; // progression part if (countDown &gt;= pre) &#123; // check if pre is tall enough total += countDown - pre + 1; &#125; pre = 1; // when ascending and there is countDown, prev should be 1 countDown = 0; &#125; pre = ratings[i] == ratings[i - 1] ? 1 : pre + 1; // when equals to previous one, set to 1. Else set to prev + 1 total += pre; &#125; else &#123; countDown++; &#125; &#125; if (countDown &gt; 0) &#123; // check if there is countDown in the end total += countDown * (countDown + 1) / 2; if (countDown &gt;= pre) &#123; total += countDown - pre + 1; &#125; &#125; return total;&#125; https://discuss.leetcode.com/topic/37924/very-simple-java-solution-with-detail-explanation Very Simple Java Solution with detail explanation 1We take ratings array as [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1] In the given problem each student will have at least 1 candy. So distribute 1 candy to each. 12ratings: [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]candies: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] Now traverse the array from left to right. If the rating of (n+1) child is greater than (n) child then set the candy of (n+1) child as one candy more than the (n) child candies. 12ratings: [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]candies: [1, 2, 1, 1, 2, 3, 4, 1, 1, 1, 2, 1] Now traverse the array from right to left. If the (n) child rating is more than (n+1) child and (n) child candies is less than one more than (n+1) child candies then update the candies of (n) child as 1+ (n+1) candies. 12ratings: [5, 6, 2, 2, 4, 8, 9, 5, 4, 0, 5, 1]candies: [1, 2, 1, 1, 2, 3, 4, 3, 2, 1, 2, 1] Total minimum candies: 23 123456789101112131415161718192021222324252627282930public int candy(int[] ratings) &#123; int sum=0; int[] a=new int[ratings.length]; for(int i=0;i&lt;a.length;i++) &#123; a[i]=1; &#125; for(int i=0;i&lt;ratings.length-1;i++) &#123; if(ratings[i+1]&gt;ratings[i]) &#123; a[i+1]=a[i]+1; &#125; &#125; for(int i=ratings.length-1;i&gt;0;i--) &#123; if(ratings[i-1]&gt;ratings[i]) &#123; if(a[i-1]&lt;(a[i]+1)) &#123; a[i-1]=a[i]+1; &#125; &#125; &#125; for(int i=0;i&lt;a.length;i++) &#123; sum+=a[i]; &#125; return sum; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[134. Gas Station]]></title>
    <url>%2Fp%2Fb124e3aa%2F</url>
    <content type="text"><![CDATA[29.3% https://leetcode.com/problems/gas-station/ There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1. Note: The solution is guaranteed to be unique. 具体原理及贪心算法还需要再思考 方法一： 我的代码实现: Oct 18，2017 1234567891011121314151617class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int start = gas.size()-1, end = 0; int sum = gas[start] - cost[start]; while(start&gt;end)&#123; if(sum&gt;=0)&#123; sum += gas[end] - cost[end]; end++; &#125;else&#123; start--; sum += gas[start] - cost[start]; &#125; &#125; return sum&gt;=0 ? start : -1; &#125;&#125;; My AC is O(1) space O(n) running time solution. Does anybody have posted this solution? I have got one solution to this problem. I am not sure whether somebody has already posted this solution. 1234567891011121314151617181920class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123; int start = gas.size()-1; int end = 0; int sum = gas[start] - cost[start]; // 注意此处初值的赋值 while (start &gt; end) &#123; if (sum &gt;= 0) &#123; sum += gas[end] - cost[end]; ++end; &#125; else &#123; --start; sum += gas[start] - cost[start]; &#125; &#125; return sum &gt;= 0 ? start : -1; &#125;&#125;; my code: 1234567891011121314151617181920class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int n = gas.size(), m = cost.size(); if(n!=m || m==n &amp;&amp; m==0) return -1; int start = n-1, end = 0; int cur_gas = gas[start]-cost[start]; while(end &lt;= start)&#123; if(cur_gas&gt;=0)&#123; cur_gas += gas[end] - cost[end]; end++; &#125; else&#123; start--; cur_gas += gas[start] - cost[start]; &#125; &#125; return cur_gas&gt;=0?start:-1; &#125;&#125;; cpp https://discuss.leetcode.com/topic/1344/share-some-of-my-ideas Share some of my ideas. I have thought for a long time and got two ideas: If car starts at A and can not reach B. Any station between A and B can not reach B.(B is the first station that A can not reach.) If the total number of gas is bigger than the total number of cost. There must be a solution. (Should I prove them?) Here is my solution based on those ideas: 123456789class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123; int start(0),total(0),tank(0); //if car fails at 'start', record the next station for(int i=0;i&lt;gas.size();i++) if((tank=tank+gas[i]-cost[i])&lt;0) &#123;start=i+1;total+=tank;tank=0;&#125; return (total+tank&lt;0)? -1:start; &#125;&#125;; https://discuss.leetcode.com/topic/5088/my-ac-is-o-1-space-o-n-running-time-solution-does-anybody-have-posted-this-solution My AC is O(1) space O(n) running time solution. Does anybody have posted this solution? I have got one solution to this problem. I am not sure whether somebody has already posted this solution. 1234567891011121314151617181920class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123; int start = gas.size()-1; int end = 0; int sum = gas[start] - cost[start]; while (start &gt; end) &#123; if (sum &gt;= 0) &#123; sum += gas[end] - cost[end]; ++end; &#125; else &#123; --start; sum += gas[start] - cost[start]; &#125; &#125; return sum &gt;= 0 ? start : -1; &#125;&#125;; https://discuss.leetcode.com/topic/39755/proof-of-if-total-gas-is-greater-than-total-cost-there-is-a-solution-c Proof of “if total gas is greater than total cost, there is a solution”. C++ We prove the following statement. If sum of all gas[i]-cost[i] is greater than or equal to 0, then there is a start position you can travel the whole circle.Let i be the index such that the the partial sum 1gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i] is the smallest, then the start position should be start=i+1 ( start=0 if i=n-1). Consider any other partial sum, for example, 1gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i]+gas[i+1]-cost[i+1] Since gas[0]-cost[0]+gas[1]-cost[1]+…+gas[i]-cost[i] is the smallest, we must have 1gas[i+1]-cost[i+1]&gt;=0 in order for gas[0]-cost[0]+gas[1]-cost[1]+…+gas[i]-cost[i]+gas[i+1]-cost[i+1] to be greater.The same reasoning gives that 1234gas[i+1]-cost[i+1]&gt;=0gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]&gt;=0.......gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]+...+gas[n-1]-cost[n-1]&gt;=0 What about for the partial sums that wraps around? 1234gas[0]-cost[0]+gas[1]-cost[1]+...+gas[j]-cost[j] + gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1]&gt;=gas[0]-cost[0]+gas[1]-cost[1]+...+gas[i]-cost[i] + gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1]&gt;=0 The last inequality is due to the assumption that the entire sum of gas[k]-cost[k] is greater than or equal to 0.So we have that all the partial sums 123456gas[i+1]-cost[i+1]&gt;=0,gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]&gt;=0,gas[i+1]-cost[i+1]+gas[i+2]-cost[i+2]+...+gas[n-1]-cost[n-1]&gt;=0,...gas[i+1]-cost[i+1]+...+gas[n-1]-cost[n-1] + gas[0]-cost[0]+gas[1]-cost[1]+...+gas[j]-cost[j]&gt;=0,... Thus i+1 is the position to start. Coding using this reasoning is as follows: 123456789101112131415class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int n = gas.size(); int total(0), subsum(INT_MAX), start(0); for(int i = 0; i &lt; n; ++i)&#123; total += gas[i] - cost[i]; if(total &lt; subsum) &#123; subsum = total; start = i + 1; &#125; &#125; return (total &lt; 0) ? -1 : (start%n); &#125;&#125;; https://discuss.leetcode.com/topic/8860/fully-commented-o-n-c-solution-enabled-by-a-single-observation-of-mine Fully-commented O(n) C++ solution enabled by a single observation of mine 123456789101112131415161718192021222324252627class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt; &amp;gas, vector&lt;int&gt; &amp;cost) &#123; int i, j, n = gas.size(); /* * If start from i, stop before station x -&gt; no station k from i + 1 to x - 1 can reach x. * Bcoz if so, i can reach k and k can reach x, then i reaches x. Contradiction. * Thus i can jump directly to x instead of i + 1, bringing complexity from O(n^2) to O(n). */ // start from station i for (i = 0; i &lt; n; i += j) &#123; int gas_left = 0; // forward j stations for (j = 1; j &lt;= n; j++) &#123; int k = (i + j - 1) % n; gas_left += gas[k] - cost[k]; if (gas_left &lt; 0) break; &#125; if (j &gt; n) return i; &#125; return -1; &#125;&#125;; https://discuss.leetcode.com/topic/29487/my-one-pass-solution My one pass solution. 123456789101112131415161718class Solution &#123;public:int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int size=gas.size(); int sum=0; int res=0; int total=0; for(int i=0; i&lt;size; ++i)&#123; sum+=gas[i]-cost[i]; if(sum&lt;0)&#123; total+=sum; sum=0; res=i+1; &#125; &#125; total+=sum; return total&lt;0?-1:res;&#125;&#125;; The idea is simple. Whenever the sum is negative, reset it and let the car start from next point. In the mean time, add up all of the left gas to total. If it’s negative finally, return -1 since it’s impossible to finish. If it’s non-negative, return the last point saved in res; https://discuss.leetcode.com/topic/5088/my-ac-is-o-1-space-o-n-running-time-solution-does-anybody-have-posted-this-solution 6ms, September 20, 2016 12345678910111213141516171819class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int start = gas.size() - 1; int end = 0; int sum = gas[start] - cost[start]; while(start &gt; end)&#123; if(sum &gt;= 0)&#123; sum += gas[end] - cost[end]; ++end; &#125; else&#123; --start; sum += gas[start] - cost[start]; &#125; &#125; return sum &gt;= 0 ? start : -1; &#125;&#125;; python https://discuss.leetcode.com/topic/27760/possibly-the-most-easiest-approach-o-n-one-variable-python 55ms, 32.89%, September 20, 2016 解析：sum（gas）&gt;= sum（gas），能保证存在一个位置，可以作为起点。如果从位置position开始进行旅行，这一段到某一点没有油了，则以position为起点的这一段肯定不存在作为起点的位置，否则走不完这一段，所以postion设为从下一个位置开始，其他的类似。my code的思想类似，不过是移动起点和终点的位置，如果小于0，起点向前移动，如果大于0，则起点向后移动。1234567891011121314151617class Solution(object): def canCompleteCircuit(self, gas, cost): &quot;&quot;&quot; :type gas: List[int] :type cost: List[int] :rtype: int &quot;&quot;&quot; if len(gas) == 0 or len(cost) == 0 or sum(gas) &lt; sum(cost): return -1 position = 0 balance = 0 for i in range(len(gas)): balance += gas[i] - cost[i] if balance &lt; 0: balance = 0 position = i+1 return position my code 1234567891011121314151617class Solution(object): def canCompleteCircuit(self, gas, cost): &quot;&quot;&quot; :type gas: List[int] :type cost: List[int] :rtype: int &quot;&quot;&quot; start, end = len(gas)-1, 0 cur = gas[start]-cost[start] while end&lt;start: if cur&lt;0: start -= 1 cur += gas[start] - cost[start] else: cur += gas[end] - cost[end] end += 1 return start if cur&gt;=0 else -1 java https://discuss.leetcode.com/topic/7247/my-o-n-time-o-1-extra-space-solution My O(N) time, O(1) extra space solution. 1234567891011121314151617181920public class Solution &#123;public int canCompleteCircuit(int[] gas, int[] cost) &#123; for(int i = 0; i &lt; gas.length; i++) &#123; gas[i] -= cost[i]; &#125; int sum = 0; int result = 0; int n = gas.length; for(int i = 0; i &lt; n * 2 - 1; i++) &#123; sum += gas[i % n]; if(sum &lt; 0) &#123; result = i + 1; if(result &gt;= n) &#123; return -1; &#125; sum = 0; &#125; &#125; return result;&#125; https://discuss.leetcode.com/topic/25289/straightforward-java-linear-solution-with-o-1-space-explanation-and-math-proof Straightforward Java Linear Solution with O(1) space, explanation and Math proof The algorithm is pretty easy to understand. Imagine we take a tour around this circle, the only condition that we can complete this trip is to have more fuel provided than costed in total. That’s what the first loop does. If we do have more fuel provided than costed, that means we can always find a start point around this circle that we could complete the journey with an empty tank. Hence, we check from the beginning of the array, if we can gain more fuel at the current station, we will maintain the start point, else, which means we will burn out of oil before reaching to the next station, we will start over at the next station. 1234567891011121314151617181920public int canCompleteCircuit(int[] gas, int[] cost) &#123; int tank = 0; for(int i = 0; i &lt; gas.length; i++) tank += gas[i] - cost[i]; if(tank &lt; 0) return - 1; int start = 0; int accumulate = 0; for(int i = 0; i &lt; gas.length; i++)&#123; int curGain = gas[i] - cost[i]; if(accumulate + curGain &lt; 0)&#123; start = i + 1; accumulate = 0; &#125; else accumulate += curGain; &#125; return start;&#125; https://discuss.leetcode.com/topic/25990/simple-o-n-java-solution-with-comments 1ms, September 20, 2016 123456789101112131415public class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int total = 0, tank = 0, index = 0; for(int i=0; i&lt;cost.length; i++)&#123; int cur = gas[i] - cost[i]; tank += cur; if(tank&lt;0)&#123; index = i+1; tank = 0; &#125; total += cur; &#125; return total &lt; 0 ? -1:index; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[132. Palindrome Partitioning II]]></title>
    <url>%2Fp%2Fc5f750e%2F</url>
    <content type="text"><![CDATA[23.7% https://leetcode.com/problems/palindrome-partitioning-ii/#/description Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. 12For example, given s = &quot;aab&quot;,Return 1 since the palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut. 13ms, September 22, 2016 https://discuss.leetcode.com/topic/2840/my-solution-does-not-need-a-table-for-palindrome-is-it-right-it-uses-only-o-n-space My solution does not need a table for palindrome, is it right ? It uses only O(n) space. 12345678910111213141516class Solution &#123;public: int minCut(string s) &#123; int n = s.size(); vector&lt;int&gt; cut(n+1, 0); // number of cuts for the first k characters for (int i = 0; i &lt;= n; i++) cut[i] = i-1; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; i-j &gt;= 0 &amp;&amp; i+j &lt; n &amp;&amp; s[i-j]==s[i+j] ; j++) // odd length palindrome cut[i+j+1] = min(cut[i+j+1],1+cut[i-j]); for (int j = 1; i-j+1 &gt;= 0 &amp;&amp; i+j &lt; n &amp;&amp; s[i-j+1] == s[i+j]; j++) // even length palindrome cut[i+j+1] = min(cut[i+j+1],1+cut[i-j+1]); &#125; return cut[n]; &#125;&#125;; https://discuss.leetcode.com/topic/2048/my-dp-solution-explanation-and-code My DP Solution ( explanation and code) Calculate and maintain 2 DP states: pal[i][j] , which is whether s[i..j] forms a pal d[i], which is the minCut for s[i..n-1] Once we comes to a pal[i][j]==true: if j==n-1, the string s[i..n-1] is a Pal, minCut is 0, d[i]=0; else: the current cut num (first cut s[i..j] and then cut the rest s[j+1…n-1]) is 1+d[j+1], compare it to the exisiting minCut num d[i], repalce if smaller. d[0] is the answer. 12345678910111213141516171819202122232425class Solution &#123; public: int minCut(string s) &#123; if(s.empty()) return 0; int n = s.size(); vector&lt;vector&lt;bool&gt;&gt; pal(n,vector&lt;bool&gt;(n,false)); vector&lt;int&gt; d(n); for(int i=n-1;i&gt;=0;i--) &#123; d[i]=n-i-1; for(int j=i;j&lt;n;j++) &#123; if(s[i]==s[j] &amp;&amp; (j-i&lt;2 || pal[i+1][j-1])) &#123; pal[i][j]=true; if(j==n-1) d[i]=0; else if(d[j+1]+1&lt;d[i]) d[i]=d[j+1]+1; &#125; &#125; &#125; return d[0]; &#125; &#125;; https://discuss.leetcode.com/topic/19298/two-c-versions-given-one-dp-28ms-one-manancher-like-algorithm-10-ms Two C++ versions given (one DP 28ms, one Manancher-like algorithm 10 ms) One typical solution is DP based. Such solution first constructs a two-dimensional bool array isPalin to indicate whether the sub-string s[i..j] is palindrome. To get such array, we need O(N^2) time complexity. Moreover, to get the minimum cuts, we need another array minCuts to do DP and minCuts[i] saves the minimum cuts found for the sub-string s[0..i-1]. minCuts[i] is initialized to i-1, which is the maximum cuts needed (cuts the string into one-letter characters) and minCuts[0] initially sets to -1, which is needed in the case that s[0..i-1] is a palindrome. When we construct isPalin array, we update minCuts everytime we found a palindrome sub-string, i.e. if s[i..j] is a palindrome, then minCuts[j+1] will be updated to the minimum of the current minCuts[j+1] and minCut[i]+1(i.e. cut s[0..j] into s[0,i-1] and s[i,j]). At last, we return minCuts[N].So the complexity is O(N^2). However, it can be further improved since as described above, we only update minCuts when we find a palindrome substring, while the DP algorithm spends lots of time to calculate isPalin, most of which is false (i.e. not a palindrome substring). If we can reduce such unnecessary calculation, then we can speed up the algorithm. This can be achieved with a Manancher-like solution, which is also given as following. 123456789101112131415161718192021222324252627// DP solutionclass Solution &#123;public: int minCut(string s) &#123; const int N = s.size(); if(N&lt;=1) return 0; int i,j; bool isPalin[N][N]; fill_n(&amp;isPalin[0][0], N*N, false); int minCuts[N+1]; for(i=0; i&lt;=N; ++i) minCuts[i] = i-1; for(j=1; j&lt;N; ++j) &#123; for(i=j; i&gt;=0; --i) &#123; if( (s[i] == s[j]) &amp;&amp; ( ( j-i &lt; 2 ) || isPalin[i+1][j-1] ) ) &#123; isPalin[i][j] = true; minCuts[j+1] = min(minCuts[j+1], 1 + minCuts[i]); &#125; &#125; &#125; return minCuts[N]; &#125;&#125;; The Manancher-like solution scan the array from left to right (for i loop) and only check those sub-strings centered at s[i]; once a non-palindrome string is found, it will stop and move to i+1. Same as the DP solution, minCUTS[i] is used to save the minimum cuts for s[0:i-1]. For each i, we do two for loops (for j loop) to check if the substrings s[i-j .. i+j] (odd-length substring) and s[i-j-1.. i+j] (even-length substring) are palindrome. By increasing j from 0, we can find all the palindrome sub-strings centered at i and update minCUTS accordingly. Once we meet one non-palindrome sub-string, we stop for-j loop since we know there no further palindrome substring centered at i. This helps us avoid unnecessary palindrome substring checks, as we did in the DP algorithm. Therefore, this version is faster. 123456789101112131415161718192021//Manancher-like solutionclass Solution &#123;public: int minCut(string s) &#123; const int N = s.size(); if(N&lt;=1) return 0; int i, j, minCUTS[N+1]; for(i=0; i&lt;=N; ++i) minCUTS[i] = i-1; for(i=1;i&lt;N;i++) &#123; for(j=0;(i-j)&gt;=0 &amp;&amp; (i+j)&lt;N &amp;&amp; s[i-j]== s[i+j]; ++j) // odd-length substrings minCUTS[i+j+1] = min(minCUTS[i+j+1], 1 + minCUTS[i-j]); for(j=0;(i-j-1)&gt;=0 &amp;&amp; (i+j)&lt;N &amp;&amp; s[i-j-1]== s[i+j]; ++j) // even-length substrings minCUTS[i+j+1] = min(minCUTS[i+j+1], 1 + minCUTS[i-j-1]); &#125; return minCUTS[N]; &#125;&#125;; https://discuss.leetcode.com/topic/22388/56-ms-python-with-explanation 56 ms python with explanation Algorithm (460 ms) credits go to: https://leetcode.com/discuss/9476/solution-does-not-need-table-palindrome-right-uses-only-space The main algorithm idea is if s[i,j] is a palindrome, then the minCut(s[:j]) is at most minCut(s[:i-1])+1. This literally needs to find out all possible palindromes in the list. The above post provides an efficient search algorithm. O(n) space and O(n^2) time complexity. Further acceleration (460 ms -&gt; 56 ms) credits go to: https://leetcode.com/discuss/43950/python-100ms-extra-dealing-super-cases-reduces-576ms-100ms The main idea for acceleration is to quickly check and exclude a few long palindrome tests.. 1234567891011121314151617181920def minCut(self, s): # acceleration if s == s[::-1]: return 0 for i in range(1, len(s)): if s[:i] == s[:i][::-1] and s[i:] == s[i:][::-1]: return 1 # algorithm cut = [x for x in range(-1,len(s))] # cut numbers in worst case (no palindrome) for i in range(len(s)): r1, r2 = 0, 0 # use i as origin, and gradually enlarge radius if a palindrome exists # odd palindrome while i-r1 &gt;= 0 and i+r1 &lt; len(s) and s[i-r1] == s[i+r1]: cut[i+r1+1] = min(cut[i+r1+1], cut[i-r1]+1) r1 += 1 # even palindrome while i-r2 &gt;= 0 and i+r2+1 &lt; len(s) and s[i-r2] == s[i+r2+1]: cut[i+r2+2] = min(cut[i+r2+2], cut[i-r2]+1) r2 += 1 return cut[-1] The following code simply implements the algorithm without any optimization (1800 ms), and should be easier to understand. O(n) space and O(n^3) time complexity. 1234567def minCut(self, s): cut = [x for x in range(-1,len(s))] for i in range(0,len(s)): for j in range(i,len(s)): if s[i:j] == s[j:i:-1]: cut[j+1] = min(cut[j+1],cut[i]+1) return cut[-1] https://discuss.leetcode.com/topic/32575/easiest-java-dp-solution-97-36 Easiest Java DP Solution (97.36%) This can be solved by two points: cut[i] is the minimum of cut[j - 1] + 1 (j &lt;= i), if [j, i] is palindrome. If [j, i] is palindrome, [j + 1, i - 1] is palindrome, and c[j] == c[i]. The 2nd point reminds us of using dp (caching). 1234a b a | c c j i j-1 | [j, i] is palindrome cut(j-1) + 1 Hope it helps! 123456789101112131415161718public int minCut(String s) &#123; char[] c = s.toCharArray(); int n = c.length; int[] cut = new int[n]; boolean[][] pal = new boolean[n][n]; for(int i = 0; i &lt; n; i++) &#123; int min = i; for(int j = 0; j &lt;= i; j++) &#123; if(c[j] == c[i] &amp;&amp; (j + 1 &gt; i - 1 || pal[j + 1][i - 1])) &#123; pal[j][i] = true; min = j == 0 ? 0 : Math.min(min, cut[j - 1] + 1); &#125; &#125; cut[i] = min; &#125; return cut[n - 1];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[131. Palindrome Partitioning]]></title>
    <url>%2Fp%2F505b452c%2F</url>
    <content type="text"><![CDATA[31.6% https://leetcode.com/problems/palindrome-partitioning/#/description Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. 1234567For example, given s = &quot;aab&quot;,Return[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] https://discuss.leetcode.com/topic/10955/clean-c-backtracking-solution Clean C++ backtracking solution The Idea is simple: loop through the string, check if substr(0, i) is palindrome. If it is, recursively call dfs() on the rest of sub string: substr(i+1, length). keep the current palindrome partition so far in the ‘path’ argument of dfs(). When reaching the end of string, add current partition in the result. 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt; &gt; ret; if(s.empty()) return ret; vector&lt;string&gt; path; dfs(0, s, path, ret); return ret; &#125; void dfs(int index, string&amp; s, vector&lt;string&gt;&amp; path, vector&lt;vector&lt;string&gt; &gt;&amp; ret) &#123; if(index == s.size()) &#123; ret.push_back(path); return; &#125; for(int i = index; i &lt; s.size(); ++i) &#123; if(isPalindrome(s, index, i)) &#123; path.push_back(s.substr(index, i - index + 1)); dfs(i+1, s, path, ret); path.pop_back(); &#125; &#125; &#125; bool isPalindrome(const string&amp; s, int start, int end) &#123; while(start &lt;= end) &#123; if(s[start++] != s[end--]) return false; &#125; return true; &#125;&#125;; https://discuss.leetcode.com/topic/15432/12ms-14-lines-c 12ms 14-lines C++ The problem has a nice structure that backtracking naturally fits in. The structure is, given a starting position idx, we search from idx till the end of the string s.length() - 1. Once we reach a position i such that the sub-string from idx to i (s.substr(idx, i - idx + 1)) is a palindrome, we add it to a temporary tmp. Then we recursively call the same function to process the remaining sub-string. Once we reach the end of the string, we add tmp into the result res of all the possible partitioning. Then, backtracking happens! Remember that at position i, we find s.substr(idx, i - idx + 1) to be a palindrome and we immediately add it to tmp. It is obvious that there may be some position j such that j &gt; i and s.substr(idx, j - idx + 1) is also a palindrome. So we need to recover to the state before adding s.substr(idx, i - idx + 1) to tmp and continue to find the next palindrome position after i. And we simply need to pop s.substr(idx, i - idx + 1) out of tmp to make things work. Putting these together, we can write down the following code, which should be self-explanatory. 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; tmp; getPartition(s, 0, tmp, res); return res; &#125;private: void getPartition(string&amp; s, int idx, vector&lt;string&gt;&amp; tmp, vector&lt;vector&lt;string&gt;&gt;&amp; res) &#123; if (idx == s.length()) &#123; res.push_back(tmp); return; &#125; for (int i = idx, n = s.length(); i &lt; n; i++) &#123; int l = idx, r = i; while (l &lt; r &amp;&amp; s[l] == s[r]) l++, r--; if (l &gt;= r) &#123; tmp.push_back(s.substr(idx, i - idx + 1)); getPartition(s, i + 1, tmp, res); tmp.pop_back(); &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/19370/1-liner-python-ruby 1-liner Python, Ruby Python: Broken into several physical lines for readability, but still one logical line and just one simple statement. 12345def partition(self, s): return [[s[:i]] + rest for i in xrange(1, len(s)+1) if s[:i] == s[i-1::-1] for rest in self.partition(s[i:])] or [[]] https://discuss.leetcode.com/topic/33425/python-recursive-iterative-backtracking-solution Python recursive/iterative backtracking solution Inspired by caikehe’s solution: 123456789101112131415def partition(self, s): res = [] self.dfs(s, [], res) return resdef dfs(self, s, path, res): if not s: res.append(path) return for i in range(1, len(s)+1): if self.isPal(s[:i]): self.dfs(s[i:], path+[s[:i]], res) def isPal(self, s): return s == s[::-1] https://discuss.leetcode.com/topic/6186/java-backtracking-solution Java: Backtracking solution. if the input is “aab”, check if [0,0] “a” is palindrome. then check [0,1] “aa”, then [0,2] “aab”.While checking [0,0], the rest of string is “ab”, use ab as input to make a recursive call. in this example, in the loop of i=l+1, a recursive call will be made with input = “ab”.Every time a recursive call is made, the position of l move right. How to define a correct answer? Think about DFS, if the current string to be checked (Palindrome) contains the last position, in this case “c”, this path is a correct answer, otherwise, it’s a false answer. line 13: is the boundary to check if the current string contains the last element.l&gt;=s.length() 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; List&lt;List&lt;String&gt;&gt; resultLst; ArrayList&lt;String&gt; currLst; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; resultLst = new ArrayList&lt;List&lt;String&gt;&gt;(); currLst = new ArrayList&lt;String&gt;(); backTrack(s,0); return resultLst; &#125; public void backTrack(String s, int l)&#123; if(currLst.size()&gt;0 //the initial str could be palindrome &amp;&amp; l&gt;=s.length())&#123; List&lt;String&gt; r = (ArrayList&lt;String&gt;) currLst.clone(); resultLst.add(r); &#125; for(int i=l;i&lt;s.length();i++)&#123; if(isPalindrome(s,l,i))&#123; if(l==i) currLst.add(Character.toString(s.charAt(i))); else currLst.add(s.substring(l,i+1)); backTrack(s,i+1); currLst.remove(currLst.size()-1); &#125; &#125; &#125; public boolean isPalindrome(String str, int l, int r)&#123; if(l==r) return true; while(l&lt;r)&#123; if(str.charAt(l)!=str.charAt(r)) return false; l++;r--; &#125; return true; &#125;&#125; https://discuss.leetcode.com/topic/2884/my-java-dp-only-solution-without-recursion-o-n-2 My Java DP only solution without recursion. O(n^2) 12345678910111213141516171819202122232425public class Solution &#123; public static List&lt;List&lt;String&gt;&gt; partition(String s) &#123; int len = s.length(); List&lt;List&lt;String&gt;&gt;[] result = new List[len + 1]; result[0] = new ArrayList&lt;List&lt;String&gt;&gt;(); result[0].add(new ArrayList&lt;String&gt;()); boolean[][] pair = new boolean[len][len]; for (int i = 0; i &lt; s.length(); i++) &#123; result[i + 1] = new ArrayList&lt;List&lt;String&gt;&gt;(); for (int left = 0; left &lt;= i; left++) &#123; if (s.charAt(left) == s.charAt(i) &amp;&amp; (i-left &lt;= 1 || pair[left + 1][i - 1])) &#123; pair[left][i] = true; String str = s.substring(left, i + 1); for (List&lt;String&gt; r : result[left]) &#123; List&lt;String&gt; ri = new ArrayList&lt;String&gt;(r); ri.add(str); result[i + 1].add(ri); &#125; &#125; &#125; &#125; return result[len]; &#125;&#125; Here the pair is to mark a range for the substring is a Pal. if pair[i][j] is true, that means sub string from i to j is pal. The result[i], is to store from beginng until current index i (Non inclusive), all possible partitions. From the past result we can determine current result. https://discuss.leetcode.com/topic/37756/java-dp-dfs-solution Java DP + DFS solution The normal dfs backtracking will need to check each substring for palindrome, but a dp array can be used to record the possible break for palindrome before we start recursion. Edit: Sharing my thought process: first, I ask myself that how to check if a string is palindrome or not, usually a two point solution scanning from front and back. Here if you want to get all the possible palindrome partition, first a nested for loop to get every possible partitions for a string, then a scanning for all the partitions. That’s a O(n^2) for partition and O(n^2) for the scanning of string, totaling at O(n^4) just for the partition. However, if we use a 2d array to keep track of any string we have scanned so far, with an addition pair, we can determine whether it’s palindrome or not by justing looking at that pair, which is this line if(s.charAt(i) == s.charAt(j) &amp;&amp; (i - j &lt;= 2 || dp[j+1][i-1])). This way, the 2d array dp contains the possible palindrome partition among all. second, based on the prescanned palindrome partitions saved in dp array, a simple backtrack does the job. 123456789101112131415161718192021222324252627282930public class Solution &#123; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); boolean[][] dp = new boolean[s.length()][s.length()]; for(int i = 0; i &lt; s.length(); i++) &#123; for(int j = 0; j &lt;= i; j++) &#123; if(s.charAt(i) == s.charAt(j) &amp;&amp; (i - j &lt;= 2 || dp[j+1][i-1])) &#123; dp[j][i] = true; &#125; &#125; &#125; helper(res, new ArrayList&lt;&gt;(), dp, s, 0); return res; &#125; private void helper(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; path, boolean[][] dp, String s, int pos) &#123; if(pos == s.length()) &#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i = pos; i &lt; s.length(); i++) &#123; if(dp[pos][i]) &#123; path.add(s.substring(pos,i+1)); helper(res, path, dp, s, i+1); path.remove(path.size()-1); &#125; &#125; &#125;&#125; 回溯法 https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/2 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list; &#125; public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125; &#125; public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[130. Surrounded Regions]]></title>
    <url>%2Fp%2F702b0957%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/surrounded-regions/?tab=Description Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’. A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region. 1234567891011For example,X X X XX O O XX X O XX O X XAfter running your function, the board should be:X X X XX X X XX X X XX O X X cpp23ms, 32.42%, October 14, 2016 https://discuss.leetcode.com/topic/17224/a-really-simple-and-readable-c-solution-only-cost-12ms A really simple and readable C++ solution，only cost 12ms First, check the four border of the matrix. If there is a element is ‘O’, alter it and all its neighbor ‘O’ elements to ‘1’. Then ,alter all the ‘O’ to ‘X’ At last,alter all the ‘1’ to ‘O’ 123456For example: X X X X X X X X X X X X X X O X -&gt; X X O X -&gt; X X X X X O X X X 1 X X X O X X X O X X X 1 X X X O X X 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int i, j; int row = board.size(); if(!row) return; int col = board[0].size(); for(i=0; i&lt;row; i++)&#123; check(board, i, 0, row, col); if(col&gt;1) check(board, i, col-1, row, col); &#125; for(j=1; j+1&lt;col; j++)&#123; check(board, 0, j, row, col); if(row&gt;1) check(board, row-1, j, row, col); &#125; for(i=0; i&lt;row; i++) for(j=0; j&lt;col; j++) if(board[i][j]==&apos;O&apos;) board[i][j] = &apos;X&apos;; for(i=0; i&lt;row; i++) for(j=0; j&lt;col; j++) if(board[i][j] == &apos;1&apos;) board[i][j] = &apos;O&apos;; &#125; void check(vector&lt;vector&lt;char&gt;&gt; &amp;vec, int i, int j, int row, int col)&#123; if(vec[i][j] == &apos;O&apos;)&#123; vec[i][j] = &apos;1&apos;; if(i&gt;1) check(vec, i-1, j, row, col); if(j&gt;1) check(vec, i, j-1, row, col); if(i+1&lt;row) check(vec, i+1, j, row, col); if(j+1&lt;col) check(vec, i, j+1, row, col); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/1944/solve-it-using-union-find Solve it using Union Find 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class UF&#123;private: int* id; // id[i] = parent of i int* rank; // rank[i] = rank of subtree rooted at i (cannot be more than 31) int count; // number of componentspublic: UF(int N) &#123; count = N; id = new int[N]; rank = new int[N]; for (int i = 0; i &lt; N; i++) &#123; id[i] = i; rank[i] = 0; &#125; &#125; ~UF() &#123; delete [] id; delete [] rank; &#125; int find(int p) &#123; while (p != id[p]) &#123; id[p] = id[id[p]]; // path compression by halving p = id[p]; &#125; return p; &#125; int getCount() &#123; return count; &#125; bool connected(int p, int q) &#123; return find(p) == find(q); &#125; void connect(int p, int q) &#123; int i = find(p); int j = find(q); if (i == j) return; if (rank[i] &lt; rank[j]) id[i] = j; else if (rank[i] &gt; rank[j]) id[j] = i; else &#123; id[j] = i; rank[i]++; &#125; count--; &#125;&#125;;class Solution &#123;public: void solve(vector&lt;vector&lt;char&gt;&gt; &amp;board) &#123; int n = board.size(); if(n==0) return; int m = board[0].size(); UF uf = UF(n*m+1); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if((i==0||i==n-1||j==0||j==m-1)&amp;&amp;board[i][j]==&apos;O&apos;) // if a &apos;O&apos; node is on the boundry, connect it to the dummy node uf.connect(i*m+j,n*m); else if(board[i][j]==&apos;O&apos;) // connect a &apos;O&apos; node to its neighbour &apos;O&apos; nodes &#123; if(board[i-1][j]==&apos;O&apos;) uf.connect(i*m+j,(i-1)*m+j); if(board[i+1][j]==&apos;O&apos;) uf.connect(i*m+j,(i+1)*m+j); if(board[i][j-1]==&apos;O&apos;) uf.connect(i*m+j,i*m+j-1); if(board[i][j+1]==&apos;O&apos;) uf.connect(i*m+j,i*m+j+1); &#125; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(!uf.connected(i*m+j,n*m))&#123; // if a &apos;O&apos; node is not connected to the dummy node, it is captured board[i][j]=&apos;X&apos;; &#125; &#125; &#125; &#125;&#125;; Hi. So here is my accepted code using Union Find data structure. The idea comes from the observation that if a region is NOT captured, it is connected to the boundry. So if we connect all the ‘O’ nodes on the boundry to a dummy node, and then connect each ‘O’ node to its neighbour ‘O’ nodes, then we can tell directly whether a ‘O’ node is captured by checking whether it is connected to the dummy node. For more about Union Find, the first assignment in the algo1 may help: https://www.coursera.org/course/algs4partI https://discuss.leetcode.com/topic/1944/solve-it-using-union-find/2 just another version in java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123; int[] unionSet; // union find set boolean[] hasEdgeO; // whether an union has an &apos;O&apos; which is on the edge of the matrix public void solve(char[][] board) &#123; if(board.length == 0 || board[0].length == 0) return; // init, every char itself is an union int height = board.length, width = board[0].length; unionSet = new int[height * width]; hasEdgeO = new boolean[unionSet.length]; for(int i = 0;i&lt;unionSet.length; i++) unionSet[i] = i; for(int i = 0;i&lt;hasEdgeO.length; i++)&#123; int x = i / width, y = i % width; hasEdgeO[i] = (board[x][y] == &apos;O&apos; &amp;&amp; (x==0 || x==height-1 || y==0 || y==width-1)); &#125; // iterate the matrix, for each char, union it + its upper char + its right char if they equals to each other for(int i = 0;i&lt;unionSet.length; i++)&#123; int x = i / width, y = i % width, up = x - 1, right = y + 1; if(up &gt;= 0 &amp;&amp; board[x][y] == board[up][y]) union(i,i-width); if(right &lt; width &amp;&amp; board[x][y] == board[x][right]) union(i,i+1); &#125; // for each char in the matrix, if it is an &apos;O&apos; and its union doesn&apos;t has an &apos;edge O&apos;, the whole union should be setted as &apos;X&apos; for(int i = 0;i&lt;unionSet.length; i++)&#123; int x = i / width, y = i % width; if(board[x][y] == &apos;O&apos; &amp;&amp; !hasEdgeO[findSet(i)]) board[x][y] = &apos;X&apos;; &#125; &#125; private void union(int x,int y)&#123; int rootX = findSet(x); int rootY = findSet(y); // if there is an union has an &apos;edge O&apos;,the union after merge should be marked too boolean hasEdgeO = this.hasEdgeO[rootX] || this.hasEdgeO[rootY]; unionSet[rootX] = rootY; this.hasEdgeO[rootY] = hasEdgeO; &#125; private int findSet(int x)&#123; if(unionSet[x] == x) return x; unionSet[x] = findSet(unionSet[x]); return unionSet[x]; &#125;&#125; https://discuss.leetcode.com/topic/18706/9-lines-python-148-ms 9 lines, Python 148 ms Phase 1: “Save” every O-region touching the border, changing its cells to ‘S’. Phase 2: Change every ‘S’ on the board to ‘O’ and everything else to ‘X’. 123456789101112def solve(self, board): if not any(board): return m, n = len(board), len(board[0]) save = [ij for k in range(m+n) for ij in ((0, k), (m-1, k), (k, 0), (k, n-1))] while save: i, j = save.pop() if 0 &lt;= i &lt; m and 0 &lt;= j &lt; n and board[i][j] == &apos;O&apos;: board[i][j] = &apos;S&apos; save += (i, j-1), (i, j+1), (i-1, j), (i+1, j) board[:] = [[&apos;XO&apos;[c == &apos;S&apos;] for c in row] for row in board] In case you don’t like my last line, you could do this instead: 123for row in board: for i, c in enumerate(row): row[i] = &apos;XO&apos;[c == &apos;S&apos;] https://discuss.leetcode.com/topic/2982/my-bfs-solution-c-28ms My BFS solution (C++ 28ms) The algorithm is quite simple: Use BFS starting from ‘O’s on the boundary and mark them as ‘B’, then iterate over the whole board and mark ‘O’ as ‘X’ and ‘B’ as ‘O’. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void bfsBoundary(vector&lt;vector&lt;char&gt; &gt;&amp; board, int w, int l)&#123; int width = board.size(); int length = board[0].size(); deque&lt;pair&lt;int, int&gt; &gt; q; q.push_back(make_pair(w, l)); board[w][l] = &apos;B&apos;; while (!q.empty()) &#123; pair&lt;int, int&gt; cur = q.front(); q.pop_front(); pair&lt;int, int&gt; adjs[4] = &#123;&#123;cur.first-1, cur.second&#125;, &#123;cur.first+1, cur.second&#125;, &#123;cur.first, cur.second-1&#125;, &#123;cur.first, cur.second+1&#125;&#125;; for (int i = 0; i &lt; 4; ++i) &#123; int adjW = adjs[i].first; int adjL = adjs[i].second; if ((adjW &gt;= 0) &amp;&amp; (adjW &lt; width) &amp;&amp; (adjL &gt;= 0) &amp;&amp; (adjL &lt; length) &amp;&amp; (board[adjW][adjL] == &apos;O&apos;)) &#123; q.push_back(make_pair(adjW, adjL)); board[adjW][adjL] = &apos;B&apos;; &#125; &#125; &#125;&#125;void solve(vector&lt;vector&lt;char&gt; &gt; &amp;board) &#123; int width = board.size(); if (width == 0) //Add this to prevent run-time error! return; int length = board[0].size(); if (length == 0) // Add this to prevent run-time error! return; for (int i = 0; i &lt; length; ++i) &#123; if (board[0][i] == &apos;O&apos;) bfsBoundary(board, 0, i); if (board[width-1][i] == &apos;O&apos;) bfsBoundary(board, width-1, i); &#125; for (int i = 0; i &lt; width; ++i) &#123; if (board[i][0] == &apos;O&apos;) bfsBoundary(board, i, 0); if (board[i][length-1] == &apos;O&apos;) bfsBoundary(board, i, length-1); &#125; for (int i = 0; i &lt; width; ++i) &#123; for (int j = 0; j &lt; length; ++j) &#123; if (board[i][j] == &apos;O&apos;) board[i][j] = &apos;X&apos;; else if (board[i][j] == &apos;B&apos;) board[i][j] = &apos;O&apos;; &#125; &#125;&#125; Note that one of the test cases is when the board is empty. So if you don’t check it in your code, you will encounter an run-time error. https://discuss.leetcode.com/topic/25010/java-dfs-boundary-cell-turning-solution-simple-and-clean-code-commented Java DFS + boundary cell turning solution, simple and clean code, commented. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void solve(char[][] board) &#123; if (board.length == 0 || board[0].length == 0) return; if (board.length &lt; 2 || board[0].length &lt; 2) return; int m = board.length, n = board[0].length; //Any &apos;O&apos; connected to a boundary can&apos;t be turned to &apos;X&apos;, so ... //Start from first and last column, turn &apos;O&apos; to &apos;*&apos;. for (int i = 0; i &lt; m; i++) &#123; if (board[i][0] == &apos;O&apos;) boundaryDFS(board, i, 0); if (board[i][n-1] == &apos;O&apos;) boundaryDFS(board, i, n-1); &#125; //Start from first and last row, turn &apos;0&apos; to &apos;*&apos; for (int j = 0; j &lt; n; j++) &#123; if (board[0][j] == &apos;O&apos;) boundaryDFS(board, 0, j); if (board[m-1][j] == &apos;O&apos;) boundaryDFS(board, m-1, j); &#125; //post-prcessing, turn &apos;O&apos; to &apos;X&apos;, &apos;*&apos; back to &apos;O&apos;, keep &apos;X&apos; intact. for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (board[i][j] == &apos;O&apos;) board[i][j] = &apos;X&apos;; else if (board[i][j] == &apos;*&apos;) board[i][j] = &apos;O&apos;; &#125; &#125;&#125;//Use DFS algo to turn internal however boundary-connected &apos;O&apos; to &apos;*&apos;;private void boundaryDFS(char[][] board, int i, int j) &#123; if (i &lt; 0 || i &gt; board.length - 1 || j &lt;0 || j &gt; board[0].length - 1) return; if (board[i][j] == &apos;O&apos;) board[i][j] = &apos;*&apos;; if (i &gt; 1 &amp;&amp; board[i-1][j] == &apos;O&apos;) boundaryDFS(board, i-1, j); if (i &lt; board.length - 2 &amp;&amp; board[i+1][j] == &apos;O&apos;) boundaryDFS(board, i+1, j); if (j &gt; 1 &amp;&amp; board[i][j-1] == &apos;O&apos;) boundaryDFS(board, i, j-1); if (j &lt; board[i].length - 2 &amp;&amp; board[i][j+1] == &apos;O&apos; ) boundaryDFS(board, i, j+1);&#125; https://discuss.leetcode.com/topic/6496/my-java-o-n-2-accepted-solution My Java O(n^2) accepted solution The idea is pretty simple: a ‘O’ marked cell cannot be captured whether: It is in contact with the border of the board or It is adjacent to an unflippable cell. So the algorithm is straightforward: Go around the border of the board When a ‘O’ cell is found mark it with ‘U’ and perform a DFS on its adjacent cells looking for other ‘O’ marked cells. When the entire border is processed scan again the board If a cell is marked as ‘O’ it wasn’t connected to unflippable cell. Hence capture it with ‘X’ If a cell is marked as ‘X’ nothing must be done. If a cell is marked as ‘U’ mark it as ‘O’ because it was an original ‘O’ marked cell which satisfied one of the above conditions.On a technical side regarding the code: In the problem statement it’s not specified that the board is rectangular. So different checks must performed when scanning the border. Since a pure recursive search causes stack overflow it’s necessary to make the DFS iterative using a stack to simulate recursion.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Solution &#123; static class Pair &#123; public int first; public int second; public Pair(int f, int s) &#123; first = f; second = s; &#125;&#125;public void solve(char[][] board) &#123; if(board == null || board.length == 0) &#123; return ; &#125; for(int i = 0; i &lt; board[0].length; ++i) &#123; if(board[0][i] == &apos;O&apos;) &#123; markUnflippable(board,0,i); &#125; &#125; for(int i = 0; i &lt; board[board.length-1].length; ++i) &#123; if(board[board.length-1][i] == &apos;O&apos;) &#123; markUnflippable(board,board.length-1,i); &#125; &#125; for(int i = 0 ; i &lt; board.length; ++i) &#123; if(board[i][0] == &apos;O&apos;) &#123; markUnflippable(board,i,0); &#125; &#125; for(int i =0; i &lt; board.length; ++i) &#123; if(board[i][board[i].length-1] == &apos;O&apos;) &#123; markUnflippable(board,i,board[i].length-1); &#125; &#125; // modify the board for(int i = 0; i &lt; board.length; ++i) &#123; for(int j = 0; j &lt; board[i].length; ++j) &#123; if(board[i][j] == &apos;O&apos;) &#123; board[i][j] = &apos;X&apos;; &#125; else if(board[i][j] == &apos;U&apos;) &#123; board[i][j] = &apos;O&apos;; &#125; &#125; &#125;&#125;public void markUnflippable(char[][] board, int r, int c) &#123; int[] dirX = &#123;-1,0,1,0&#125;; int[] dirY = &#123;0,1,0,-1&#125;; ArrayDeque&lt;Pair&gt; stack = new ArrayDeque&lt;&gt;(); stack.push(new Pair(r,c)); while(!stack.isEmpty()) &#123; Pair p = stack.pop(); board[p.first][p.second] = &apos;U&apos;; for(int i = 0; i &lt; dirX.length; ++i) &#123; if(p.first + dirX[i] &gt;= 0 &amp;&amp; p.first + dirX[i] &lt; board.length &amp;&amp; p.second + dirY[i] &gt;= 0 &amp;&amp; p.second +dirY[i] &lt; board[p.first + dirX[i]].length &amp;&amp; board[p.first+dirX[i]][p.second+dirY[i]] == &apos;O&apos;) &#123; stack.push(new Pair(p.first+dirX[i],p.second+dirY[i])); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>breadth first search</tag>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[129. Sum Root to Leaf Numbers]]></title>
    <url>%2Fp%2Fac2bd33a%2F</url>
    <content type="text"><![CDATA[35.5% https://leetcode.com/problems/sum-root-to-leaf-numbers/?tab=Description Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. 123456789For example, 1 / \ 2 3The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13.Return the sum = 12 + 13 = 25. 方法一： 56ms, 46.63%, July 15th, 2016 https://discuss.leetcode.com/topic/12048/5-ms-c-code-using-dfs 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int sumNumbers(TreeNode* root) &#123; if(!root) return 0; sum = 0; DFS(root, 0); return sum; &#125; void DFS(TreeNode *&amp;node, int currentSum)&#123; currentSum = currentSum * 10 + node-&gt;val; if(!node-&gt;left &amp;&amp; !node-&gt;right) sum += currentSum; if(node-&gt;left) DFS(node-&gt;left, currentSum); if(node-&gt;right) DFS(node-&gt;right, currentSum); &#125;private: int sum;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int sumNumbers(TreeNode* root) &#123; int res = 0, cur = 0; helper(root, res, cur); return res; &#125; void helper(TreeNode* root, int&amp; res, int cur)&#123; if(!root) return; cur = cur*10 + root-&gt;val; if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123; res += cur; return; &#125; helper(root-&gt;left, res, cur); helper(root-&gt;right, res, cur); &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/3025/one-of-the-easier-solution-using-preorder-traversal-recursion One of the easier solution using preorder traversal (recursion) The idea is to do a preorder traversal of the tree. In the preorder traversal, keep track of the value calculated till the current node, let this value be val. For every node, we update the val as val10 plus node’s data.* 123456789101112131415161718192021class Solution &#123;public: int sumNumbers(TreeNode *root) &#123; return sumNumberUtil(root,0); &#125; // preorder int sumNumberUtil(struct TreeNode* node, int val) &#123; if(node==NULL) return 0; val= val*10+node-&gt;val; if(node-&gt;left==NULL &amp;&amp; node-&gt;right==NULL) &#123; return val; &#125; return sumNumberUtil(node-&gt;left,val)+sumNumberUtil(node-&gt;right, val); &#125;&#125;; python 76ms, 10.56%, July 15th, 2016 https://discuss.leetcode.com/topic/21363/python-solutions-dfs-stack-bfs-queue-dfs-recursively Python solutions (dfs+stack, bfs+queue, dfs recursively). 123456789101112131415# dfs + stackdef sumNumbers1(self, root): if not root: return 0 stack, res = [(root, root.val)], 0 while stack: node, value = stack.pop() if node: if not node.left and not node.right: res += value if node.right: stack.append((node.right, value*10+node.right.val)) if node.left: stack.append((node.left, value*10+node.left.val)) return res 123456789101112131415# bfs + queuedef sumNumbers2(self, root): if not root: return 0 queue, res = collections.deque([(root, root.val)]), 0 while queue: node, value = queue.popleft() if node: if not node.left and not node.right: res += value if node.left: queue.append((node.left, value*10+node.left.val)) if node.right: queue.append((node.right, value*10+node.right.val)) return res 12345678910111213141516# recursively def sumNumbers(self, root): self.res = 0 self.dfs(root, 0) return self.res def dfs(self, root, value): if root: #if not root.left and not root.right: # self.res += value*10 + root.val self.dfs(root.left, value*10+root.val) #if not root.left and not root.right: # self.res += value*10 + root.val self.dfs(root.right, value*10+root.val) if not root.left and not root.right: self.res += value*10 + root.val java solution 1: 1ms, 28.00%, July 15th, 2016 https://discuss.leetcode.com/topic/6731/short-java-solution-recursion 1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public int sumNumbers(TreeNode root) &#123; return sum(root, 0); &#125; public int sum(TreeNode n, int s)&#123; if(n==null) return 0; if(n.right == null &amp;&amp; n.left == null) return s*10 + n.val; return sum(n.left, s*10+n.val) + sum(n.right, s*10 + n.val); &#125;&#125; solution 2: 1ms, 28.00%, July 15th, 2016 https://discuss.leetcode.com/topic/644/can-you-improve-this-algorithm Can you improve this algorithm? 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public int sumNumbers(TreeNode root) &#123; if (root == null) return 0; return sumR(root, 0); &#125; public int sumR(TreeNode root, int x) &#123; if (root.right == null &amp;&amp; root.left == null) return 10 * x + root.val; int val = 0; if (root.left != null) val += sumR(root.left, 10 * x + root.val); if (root.right != null) val += sumR(root.right, 10 * x + root.val); return val; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[128. Longest Consecutive Sequence]]></title>
    <url>%2Fp%2Fb1f32255%2F</url>
    <content type="text"><![CDATA[35.7% https://leetcode.com/problems/longest-consecutive-sequence/?tab=Description Given an unsorted array of integers, find the length of the longest consecutive elements sequence. 123For example,Given [100, 4, 200, 1, 3, 2],The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4. Your algorithm should run in O(n) complexity. 方法一： 排序，一个个的查找 my code: 先排序，然后依次查找，同时注意出现相同数字的处理。 但是达到不了题目要求的O（n） 12345678910111213141516171819202122232425class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0 || nums.size()==1) return nums.size(); sort(nums.begin(), nums.end()); int res=1; int tmp=1; int last = nums[0]; for(int i=1; i&lt;nums.size(); i++)&#123; if(nums[i]==nums[i-1]) continue; else if(nums[i]==last+1)&#123; tmp += 1; last = nums[i]; &#125; else&#123; res = max(tmp, res); tmp = 1; last = nums[i]; &#125; &#125; res = max(res, tmp); return res; &#125;&#125;; 方法二： 使用set，然而效率仍然是o（nlogn） https://discuss.leetcode.com/topic/16483/a-simple-c-solution-using-unordered_set-and-simple-consideration-about-this-problem A simple C++,solution using unordered_set.And simple consideration about this problem I have seen a lot of discussion about this problem.In my opinion,it is not correct to use set(which is ordered),because very time we insert an element to a ordered set,it will cost O(n),so the total complexity is O(nlogn),which violates the request of the problem.So here we use an unordered_set,and one is enough. Besides,to think about this problem,one principle issue we should realize is that usually when we want to reduce the time complexity,we have to increase the space complexity.In this case,if we want to access an element within O(1),we have to use hash table. 12345678910111213141516class Solution &#123;public: int longestConsecutive(vector&lt;int&gt; &amp;num) &#123; unordered_set&lt;int&gt; record(num.begin(),num.end()); int res = 1; for(int n : num)&#123; if(record.find(n)==record.end()) continue; record.erase(n); int prev = n-1,next = n+1; while(record.find(prev)!=record.end()) record.erase(prev--); while(record.find(next)!=record.end()) record.erase(next++); res = max(res,next-prev-1); &#125; return res; &#125;&#125;; my code： 123456789101112131415161718class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; set(nums.begin(), nums.end()); int ret = 1; for(auto &amp;n: nums) &#123; if(!set.count(n)) continue; set.erase(n); // 删除元素 int pre=n-1, next=n+1; while(set.count(pre)) set.erase(pre--); // set.count(n) 返回匹配给主键的元素的个数 while(set.count(next)) set.erase(next++); ret = max(ret, next-pre-1); &#125; return ret; &#125;&#125;; 方法三： 使用hashmap m[i]表示i为中间值的一段的长度的大小，初始为0 https://discuss.leetcode.com/topic/5333/possibly-shortest-cpp-solution-only-6-lines Possibly shortest cpp solution, only 6 lines. use a hash map to store boundary information of consecutive sequence for each element; there 4 cases when a new element i reached: neither i+1 nor i-1 has been seen: m[i]=1; both i+1 and i-1 have been seen: extend m[i+m[i+1]] and m[i-m[i-1]] to each other; only i+1 has been seen: extend m[i+m[i+1]] and m[i] to each other; only i-1 has been seen: extend m[i-m[i-1]] and m[i] to each other. 123456789int longestConsecutive(vector&lt;int&gt; &amp;num) &#123; unordered_map&lt;int, int&gt; m; int r = 0; for (int i : num) &#123; if (m[i]) continue; r = max(r, m[i] = m[i + m[i + 1]] = m[i - m[i - 1]] = m[i + 1] + m[i - 1] + 1); &#125; return r;&#125; 我的代码实现： 12345678910111213141516class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; map; int res = 0; for(int num:nums)&#123; if(map[num]) continue; int len = map[num-1] + map[num+1] + 1; map[num+map[num+1]] = len; map[num-map[num-1]] = len; map[num] = len; res = max(res, len); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/6408/13-line-c-solution 13-line C++ solution Thought I would share it here. May be useful for some one. The algorithm itself is pretty straightforward. But it benefited quite much from the neat expression of C++ idioms. Comments are appreciated! 12345678910111213int longestConsecutive(const vector&lt;int&gt; &amp;num) &#123; unordered_set&lt;int&gt; s(num.begin(), num.end()), searched; int longest = 0; for (int i: num) &#123; if (searched.find(i) != searched.end()) continue; searched.insert(i); int j = i - 1, k = i + 1; while (s.find(j) != s.end()) searched.insert(j--); while (s.find(k) != s.end()) searched.insert(k++); longest = max(longest, k - 1 - j); &#125; return longest;&#125; python https://discuss.leetcode.com/topic/15383/simple-o-n-with-explanation-just-walk-each-streak Simple O(n) with Explanation - Just walk each streak First turn the input into a set of numbers. That takes O(n) and then we can ask in O(1) whether we have a certain number. Then go through the numbers. If the number x is the start of a streak (i.e., x-1 is not in the set), then test y = x+1, x+2, x+3, … and stop at the first number y not in the set. The length of the streak is then simply y-x and we update our global best with that. Since we check each streak only once, this is overall O(n). This ran in 44 ms on the OJ, one of the fastest Python submissions. 12345678910def longestConsecutive(self, nums): nums = set(nums) best = 0 for x in nums: if x - 1 not in nums: y = x + 1 while y in nums: y += 1 best = max(best, y - x) return best https://discuss.leetcode.com/topic/10678/python-o-n-solution-using-sets Python O(n) solution using sets 12345678910111213141516171819202122class Solution: # @param num, a list of integer # @return an integer def longestConsecutive(self, num): num=set(num) maxLen=0 while num: n=num.pop() i=n+1 l1=0 l2=0 while i in num: num.remove(i) i+=1 l1+=1 i=n-1 while i in num: num.remove(i) i-=1 l2+=1 maxLen=max(maxLen,l1+l2+1) return maxLen java https://discuss.leetcode.com/topic/6148/my-really-simple-java-o-n-solution-accepted My really simple Java O(n) solution - Accepted We will use HashMap. The key thing is to keep track of the sequence length and store that in the boundary points of the sequence. For example, as a result, for sequence {1, 2, 3, 4, 5}, map.get(1) and map.get(5) should both return 5. Whenever a new element n is inserted into the map, do two things: See if n - 1 and n + 1 exist in the map, and if so, it means there is an existing sequence next to n. Variables left and right will be the length of those two sequences, while 0 means there is no sequence and n will be the boundary point later. Store (left + right + 1) as the associated value to key n into the map. Use left and right to locate the other end of the sequences to the left and right of n respectively, and replace the value with the new length. Everything inside the for loop is O(1) so the total time is O(n). Please comment if you see something wrong. Thanks. 123456789101112131415161718192021222324252627public int longestConsecutive(int[] num) &#123; int res = 0; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int n : num) &#123; if (!map.containsKey(n)) &#123; int left = (map.containsKey(n - 1)) ? map.get(n - 1) : 0; int right = (map.containsKey(n + 1)) ? map.get(n + 1) : 0; // sum: length of the sequence n is in int sum = left + right + 1; map.put(n, sum); // keep track of the max length res = Math.max(res, sum); // extend the length to the boundary(s) // of the sequence // will do nothing if n has no neighbors map.put(n - left, sum); map.put(n + right, sum); &#125; else &#123; // duplicates continue; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/29286/my-java-solution-using-unionfound My Java Solution using UnionFound 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Solution &#123; public int longestConsecutive(int[] nums) &#123; UF uf = new UF(nums.length); Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); // &lt;value,index&gt; for(int i=0; i&lt;nums.length; i++)&#123; if(map.containsKey(nums[i]))&#123; continue; &#125; map.put(nums[i],i); if(map.containsKey(nums[i]+1))&#123; uf.union(i,map.get(nums[i]+1)); &#125; if(map.containsKey(nums[i]-1))&#123; uf.union(i,map.get(nums[i]-1)); &#125; &#125; return uf.maxUnion(); &#125; &#125; class UF&#123; private int[] list; public UF(int n)&#123; list = new int[n]; for(int i=0; i&lt;n; i++)&#123; list[i] = i; &#125; &#125; private int root(int i)&#123; while(i!=list[i])&#123; list[i] = list[list[i]]; i = list[i]; &#125; return i; &#125; public boolean connected(int i, int j)&#123; return root(i) == root(j); &#125; public void union(int p, int q)&#123; int i = root(p); int j = root(q); list[i] = j; &#125; // returns the maxium size of union public int maxUnion()&#123; // O(n) int[] count = new int[list.length]; int max = 0; for(int i=0; i&lt;list.length; i++)&#123; count[root(i)] ++; max = Math.max(max, count[root(i)]); &#125; return max; &#125; &#125; https://discuss.leetcode.com/topic/9088/o-n-hashmap-java-solution O(n) HashMap Java Solution Use a hashmap to map a number to its longest consecutive sequence length, each time find a new consecutive sequence, only the begin number and end number need to be modified. 12345678910111213141516171819202122public class Solution &#123; public int longestConsecutive(int[] num) &#123; int longest = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0;i &lt; num.length;i++)&#123; // if there is no duplicates, these two lines can be commented if(map.containsKey(num[i])) continue; map.put(num[i],1); int end = num[i]; int begin = num[i]; if(map.containsKey(num[i]+1)) end = num[i] + map.get(num[i]+1); if(map.containsKey(num[i]-1)) begin = num[i] - map.get(num[i]-1); longest = Math.max(longest, end-begin+1); map.put(end, end-begin+1); map.put(begin, end-begin+1); &#125; return longest; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hard</tag>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[127. Word Ladder]]></title>
    <url>%2Fp%2Ffdab0eca%2F</url>
    <content type="text"><![CDATA[19.2% https://leetcode.com/problems/word-ladder/#/description Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. 12345678For example,Given:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,return its length 5. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. UPDATE (2017/1/20): The wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. https://discuss.leetcode.com/topic/16983/easy-76ms-c-solution-using-bfs Easy 76ms C++ Solution using BFS Well, this problem has a nice BFS structure. Let’s see the example in the problem statement. 12345start = &quot;hit&quot;end = &quot;cog&quot;dict = [&quot;hot&quot;, &quot;dot&quot;, &quot;dog&quot;, &quot;lot&quot;, &quot;log&quot;] Since only one letter can be changed at a time, if we start from “hit”, we can only change to those words which have only one different letter from it, like “hot”. Putting in graph-theoretic terms, we can say that “hot” is a neighbor of “hit”. The idea is simpy to begin from start, then visit its neighbors, then the non-visited neighbors of its neighbors… Well, this is just the typical BFS structure. To simplify the problem, we insert end into dict. Once we meet end during the BFS, we know we have found the answer. We maintain a variable dist for the current distance of the transformation and update it by dist++ after we finish a round of BFS search (note that it should fit the definition of the distance in the problem statement). Also, to avoid visiting a word for more than once, we erase it from dict once it is visited. The code is as follows. 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int ladderLength(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordDict) &#123; wordDict.insert(endWord); queue&lt;string&gt; toVisit; addNextWords(beginWord, wordDict, toVisit); int dist = 2; while (!toVisit.empty()) &#123; int num = toVisit.size(); for (int i = 0; i &lt; num; i++) &#123; string word = toVisit.front(); toVisit.pop(); if (word == endWord) return dist; addNextWords(word, wordDict, toVisit); &#125; dist++; &#125; &#125;private: void addNextWords(string word, unordered_set&lt;string&gt;&amp; wordDict, queue&lt;string&gt;&amp; toVisit) &#123; wordDict.erase(word); for (int p = 0; p &lt; (int)word.length(); p++) &#123; char letter = word[p]; for (int k = 0; k &lt; 26; k++) &#123; word[p] = &apos;a&apos; + k; if (wordDict.find(word) != wordDict.end()) &#123; toVisit.push(word); wordDict.erase(word); &#125; &#125; word[p] = letter; &#125; &#125; &#125;; The above code can still be speeded up if we also begin from end. Once we meet the same word from start and end, we know we are done. This link provides a nice two-end search solution. I rewrite the code below for better readability. Note that the use of two pointers phead and ptail save a lot of time. At each round of BFS, depending on the relative size of head and tail, we point phead to the smaller set to reduce the running time. 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int ladderLength(string beginWord, string endWord, unordered_set&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; head, tail, *phead, *ptail; head.insert(beginWord); tail.insert(endWord); int dist = 2; while (!head.empty() &amp;&amp; !tail.empty()) &#123; if (head.size() &lt; tail.size()) &#123; phead = &amp;head; ptail = &amp;tail; &#125; else &#123; phead = &amp;tail; ptail = &amp;head; &#125; unordered_set&lt;string&gt; temp; for (auto itr = phead -&gt; begin(); itr != phead -&gt; end(); itr++) &#123; string word = *itr; wordDict.erase(word); for (int p = 0; p &lt; (int)word.length(); p++) &#123; char letter = word[p]; for (int k = 0; k &lt; 26; k++) &#123; word[p] = &apos;a&apos; + k; if (ptail -&gt; find(word) != ptail -&gt; end()) return dist; if (wordDict.find(word) != wordDict.end()) &#123; temp.insert(word); wordDict.erase(word); &#125; &#125; word[p] = letter; &#125; &#125; dist++; swap(*phead, temp); &#125; return 0; &#125;&#125;; https://discuss.leetcode.com/topic/10372/share-my-two-end-bfs-in-c-80ms Share my two-end BFS in C++ 80ms. 12345678910111213141516171819202122232425262728293031323334353637383940//BFS， two-end method//traverse the path simultaneously from start node and end node, and merge in the middle//the speed will increase (logN/2)^2 times compared with one-end methodint ladderLength(string start, string end, unordered_set&lt;string&gt; &amp;dict) &#123; unordered_set&lt;string&gt; begSet, endSet, *set1, *set2; begSet.insert(start); endSet.insert(end); int h=1, K=start.size(); while(!begSet.empty()&amp;&amp;!endSet.empty())&#123; if(begSet.size()&lt;=endSet.size())&#123; //Make the size of two sets close for optimization set1=&amp;begSet; //set1 is the forward set set2=&amp;endSet; //set2 provides the target node for set1 to search &#125; else&#123; set1=&amp;endSet; set2=&amp;begSet; &#125; unordered_set&lt;string&gt; itmSet; //intermediate Set h++; for(auto i=set1-&gt;begin();i!=set1-&gt;end();i++)&#123; string cur=*i; for(int k=0;k&lt;K;k++)&#123; //iterate the characters in string cur char temp=cur[k]; for(int l=0;l&lt;26;l++)&#123; //try all 26 alphabets cur[k]=&apos;a&apos;+l; auto f=set2-&gt;find(cur); if(f!=set2-&gt;end())return h; f=dict.find(cur); if(f!=dict.end())&#123; itmSet.insert(cur); dict.erase(f); &#125; &#125; cur[k]=temp; &#125; &#125; swap(*set1, itmSet); &#125; return 0;&#125; https://discuss.leetcode.com/topic/43246/simple-to-understand-python-solution-using-list-preprocessing-and-bfs-beats-95 Simple to understand Python solution using list preprocessing and BFS, beats 95% 1234567891011121314151617181920212223242526272829303132from collections import dequeclass Solution(object): def ladderLength(self, beginWord, endWord, wordList): def construct_dict(word_list): d = &#123;&#125; for word in word_list: for i in range(len(word)): s = word[:i] + &quot;_&quot; + word[i+1:] d[s] = d.get(s, []) + [word] return d def bfs_words(begin, end, dict_words): queue, visited = deque([(begin, 1)]), set() while queue: word, steps = queue.popleft() if word not in visited: visited.add(word) if word == end: return steps for i in range(len(word)): s = word[:i] + &quot;_&quot; + word[i+1:] neigh_words = dict_words.get(s, []) for neigh in neigh_words: if neigh not in visited: queue.append((neigh, steps + 1)) return 0 d = construct_dict(wordList | set([beginWord, endWord])) return bfs_words(beginWord, endWord, d) https://discuss.leetcode.com/topic/42623/compact-python-solution Compact Python solution 123456789101112131415class Solution(object): def ladderLength(self, beginWord, endWord, wordList): wordList.add(endWord) queue = collections.deque([[beginWord, 1]]) while queue: word, length = queue.popleft() if word == endWord: return length for i in range(len(word)): for c in &apos;abcdefghijklmnopqrstuvwxyz&apos;: next_word = word[:i] + c + word[i+1:] if next_word in wordList: wordList.remove(next_word) queue.append([next_word, length + 1]) return 0 172ms, 78.99%, June.24th, 2016 https://leetcode.com/discuss/48083/share-python-solutions-concise-160ms-optimized-solution-100ms 12345678910111213141516171819202122232425class Solution(object): def ladderLength(self, beginWord, endWord, wordList): &quot;&quot;&quot; :type beginWord: str :type endWord: str :type wordList: Set[str] :rtype: int &quot;&quot;&quot; length = 2 front, back = set([beginWord]), set([endWord]) wordList.discard(beginWord) while front: # generate all valid transformations front = wordList &amp; (set(word[:index] + ch + word[index+1:] for word in front for index in range(len(beginWord)) for ch in &apos;abcdefghijklmnopqrstuvwxyz&apos;)) if front &amp; back: # there are common elements in front and back, done return length length += 1 if len(front) &gt; len(back): # swap front and back for better performance (fewer choices in generating nextSet) front, back = back, front # remove transformations from wordList to avoid cycle wordList -= front return 0 https://discuss.leetcode.com/topic/20965/java-solution-using-dijkstra-s-algorithm-with-explanation Java Solution using Dijkstra’s algorithm, with explanation 1234567891011121314151617181920212223242526public int ladderLength(String beginWord, String endWord, Set&lt;String&gt; wordDict) &#123; Set&lt;String&gt; reached = new HashSet&lt;String&gt;(); reached.add(beginWord); wordDict.add(endWord); int distance = 1; while (!reached.contains(endWord)) &#123; Set&lt;String&gt; toAdd = new HashSet&lt;String&gt;(); for (String each : reached) &#123; for (int i = 0; i &lt; each.length(); i++) &#123; char[] chars = each.toCharArray(); for (char ch = &apos;a&apos;; ch &lt;= &apos;z&apos;; ch++) &#123; chars[i] = ch; String word = new String(chars); if (wordDict.contains(word)) &#123; toAdd.add(word); wordDict.remove(word); &#125; &#125; &#125; &#125; distance++; if (toAdd.size() == 0) return 0; reached = toAdd; &#125; return distance;&#125; Basically I keep two sets of words, one set reached that represents the borders that have been reached with “distance” steps; another set wordDict that has not been reached. In the while loop, for each word in the reached set, I give all variations and check if it matches anything from wordDict, if it has a match, I add that word into toAdd set, which will be my “reached” set in the next loop, and remove the word from wordDict because I already reached it in this step. And at the end of while loop, I check the size of toAdd, which means that if I can’t reach any new String from wordDict, I won’t be able to reach the endWord, then just return 0. Finally if the endWord is in reached set, I return the current steps “distance”. The idea is that reached always contain only the ones we just reached in the last step, and wordDict always contain the ones that haven’t been reached. This is pretty much what Dijkstra’s algorithm does, or you can see this as some variation of BFS. ps: I get TLE at the first two submissions, because when I check if wordDict has any matches with reached set, I use two for loops and determine if any pair of words differ by one. That’s a huge slow-down because it’ll takes m (size of reached) n (size of wordDict) l (length of words) time, while in this solution, it takes 26 l m time. So when n is huge, this solution will be (n/26) times faster. https://discuss.leetcode.com/topic/20965/java-solution-using-dijkstra-s-algorithm-with-explanation/2 I think we can use a queue to replace the reached set, by which we can avoid duplicate check? 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int ladderLength(String beginWord, String endWord, Set&lt;String&gt; wordList) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.offer(beginWord); wordList.add(endWord); wordList.remove(beginWord); int level = 1; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0;i&lt;size;i++)&#123; String str = queue.poll(); if(str.equals(endWord))return level; for(String neighbor : neighbors(str,wordList))&#123; queue.offer(neighbor); &#125; &#125; level++; &#125; return 0; &#125; public List&lt;String&gt; neighbors(String s, Set&lt;String&gt; wordList)&#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); for(int i=0;i&lt;s.length();i++)&#123; char [] chars = s.toCharArray(); for(char ch = &apos;a&apos;; ch &lt;= &apos;z&apos;; ch++)&#123; chars[i] = ch; String word = new String(chars); if(wordList.remove(word))&#123; res.add(word); &#125; &#125; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/29303/two-end-bfs-in-java-31ms Two-end BFS in Java 31ms. Modified from Share my two-end BFS in C++ 80ms. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123;public int ladderLength(String beginWord, String endWord, Set&lt;String&gt; wordList) &#123; Set&lt;String&gt; beginSet = new HashSet&lt;String&gt;(), endSet = new HashSet&lt;String&gt;(); int len = 1; int strLen = beginWord.length(); HashSet&lt;String&gt; visited = new HashSet&lt;String&gt;(); beginSet.add(beginWord); endSet.add(endWord); while (!beginSet.isEmpty() &amp;&amp; !endSet.isEmpty()) &#123; if (beginSet.size() &gt; endSet.size()) &#123; Set&lt;String&gt; set = beginSet; beginSet = endSet; endSet = set; &#125; Set&lt;String&gt; temp = new HashSet&lt;String&gt;(); for (String word : beginSet) &#123; char[] chs = word.toCharArray(); for (int i = 0; i &lt; chs.length; i++) &#123; for (char c = &apos;a&apos;; c &lt;= &apos;z&apos;; c++) &#123; char old = chs[i]; chs[i] = c; String target = String.valueOf(chs); if (endSet.contains(target)) &#123; return len + 1; &#125; if (!visited.contains(target) &amp;&amp; wordList.contains(target)) &#123; temp.add(target); visited.add(target); &#125; chs[i] = old; &#125; &#125; &#125; beginSet = temp; len++; &#125; return 0;&#125;&#125; https://discuss.leetcode.com/topic/17890/another-accepted-java-solution-bfs Another accepted Java solution (BFS) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public int ladderLength(String start, String end, Set&lt;String&gt; dict) &#123; // Use queue to help BFS Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.add(start); queue.add(null); // Mark visited word Set&lt;String&gt; visited = new HashSet&lt;String&gt;(); visited.add(start); int level = 1; while (!queue.isEmpty()) &#123; String str = queue.poll(); if (str != null) &#123; // Modify str&apos;s each character (so word distance is 1) for (int i = 0; i &lt; str.length(); i++) &#123; char[] chars = str.toCharArray(); for (char c = &apos;a&apos;; c &lt;= &apos;z&apos;; c++) &#123; chars[i] = c; String word = new String(chars); // Found the end word if (word.equals(end)) return level + 1; // Put it to the queue if (dict.contains(word) &amp;&amp; !visited.contains(word)) &#123; queue.add(word); visited.add(word); &#125; &#125; &#125; &#125; else &#123; level++; if (!queue.isEmpty()) &#123; queue.add(null); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[126. Word Ladder II]]></title>
    <url>%2Fp%2F2dae1d4c%2F</url>
    <content type="text"><![CDATA[13.7% https://leetcode.com/problems/word-ladder-ii/#/description Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that: Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word. 1234567891011For example,Given:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Return [ [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;], [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;] ] Note: Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. UPDATE (2017/1/20): The wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes. https://discuss.leetcode.com/topic/16826/88ms-accepted-c-solution-with-two-end-bfs-68ms-for-word-ladder-and-88ms-for-word-ladder-ii 88ms! Accepted c++ solution with two-end BFS. 68ms for Word Ladder and 88ms for Word Ladder II In order to reduce the running time, we should use two-end BFS to slove the problem. Accepted 68ms c++ solution for Word Ladder. 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int ladderLength(std::string beginWord, std::string endWord, std::unordered_set&lt;std::string&gt; &amp;dict) &#123; if (beginWord == endWord) return 1; std::unordered_set&lt;std::string&gt; words1, words2; words1.insert(beginWord); words2.insert(endWord); dict.erase(beginWord); dict.erase(endWord); return ladderLengthHelper(words1, words2, dict, 1); &#125;private: int ladderLengthHelper(std::unordered_set&lt;std::string&gt; &amp;words1, std::unordered_set&lt;std::string&gt; &amp;words2, std::unordered_set&lt;std::string&gt; &amp;dict, int level) &#123; if (words1.empty()) return 0; if (words1.size() &gt; words2.size()) return ladderLengthHelper(words2, words1, dict, level); std::unordered_set&lt;std::string&gt; words3; for (auto it = words1.begin(); it != words1.end(); ++it) &#123; std::string word = *it; for (auto ch = word.begin(); ch != word.end(); ++ch) &#123; char tmp = *ch; for (*ch = &apos;a&apos;; *ch &lt;= &apos;z&apos;; ++(*ch)) if (*ch != tmp) if (words2.find(word) != words2.end()) return level + 1; else if (dict.find(word) != dict.end()) &#123; dict.erase(word); words3.insert(word); &#125; *ch = tmp; &#125; &#125; return ladderLengthHelper(words2, words3, dict, level + 1); &#125;&#125;; Accepted 88ms c++ solution for Word Ladder II. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution &#123;public: std::vector&lt;std::vector&lt;std::string&gt; &gt; findLadders(std::string beginWord, std::string endWord, std::unordered_set&lt;std::string&gt; &amp;dict) &#123; std::vector&lt;std::vector&lt;std::string&gt; &gt; paths; std::vector&lt;std::string&gt; path(1, beginWord); if (beginWord == endWord) &#123; paths.push_back(path); return paths; &#125; std::unordered_set&lt;std::string&gt; words1, words2; words1.insert(beginWord); words2.insert(endWord); std::unordered_map&lt;std::string, std::vector&lt;std::string&gt; &gt; nexts; bool words1IsBegin = false; if (findLaddersHelper(words1, words2, dict, nexts, words1IsBegin)) getPath(beginWord, endWord, nexts, path, paths); return paths; &#125;private: bool findLaddersHelper( std::unordered_set&lt;std::string&gt; &amp;words1, std::unordered_set&lt;std::string&gt; &amp;words2, std::unordered_set&lt;std::string&gt; &amp;dict, std::unordered_map&lt;std::string, std::vector&lt;std::string&gt; &gt; &amp;nexts, bool &amp;words1IsBegin) &#123; words1IsBegin = !words1IsBegin; if (words1.empty()) return false; if (words1.size() &gt; words2.size()) return findLaddersHelper(words2, words1, dict, nexts, words1IsBegin); for (auto it = words1.begin(); it != words1.end(); ++it) dict.erase(*it); for (auto it = words2.begin(); it != words2.end(); ++it) dict.erase(*it); std::unordered_set&lt;std::string&gt; words3; bool reach = false; for (auto it = words1.begin(); it != words1.end(); ++it) &#123; std::string word = *it; for (auto ch = word.begin(); ch != word.end(); ++ch) &#123; char tmp = *ch; for (*ch = &apos;a&apos;; *ch &lt;= &apos;z&apos;; ++(*ch)) if (*ch != tmp) if (words2.find(word) != words2.end()) &#123; reach = true; words1IsBegin ? nexts[*it].push_back(word) : nexts[word].push_back(*it); &#125; else if (!reach &amp;&amp; dict.find(word) != dict.end()) &#123; words3.insert(word); words1IsBegin ? nexts[*it].push_back(word) : nexts[word].push_back(*it); &#125; *ch = tmp; &#125; &#125; return reach || findLaddersHelper(words2, words3, dict, nexts, words1IsBegin); &#125; void getPath( std::string beginWord, std::string &amp;endWord, std::unordered_map&lt;std::string, std::vector&lt;std::string&gt; &gt; &amp;nexts, std::vector&lt;std::string&gt; &amp;path, std::vector&lt;std::vector&lt;std::string&gt; &gt; &amp;paths) &#123; if (beginWord == endWord) paths.push_back(path); else for (auto it = nexts[beginWord].begin(); it != nexts[beginWord].end(); ++it) &#123; path.push_back(*it); getPath(*it, endWord, nexts, path, paths); path.pop_back(); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/40902/clean-but-the-best-submission-68ms-in-c-well-commented Clean but the best-submission (68ms) in C++, well-commented 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution &#123; public: vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, unordered_set&lt;string&gt; &amp;dict) &#123; vector&lt;vector&lt;string&gt; &gt; paths; vector&lt;string&gt; path(1, beginWord); if (beginWord == endWord) //corner case; &#123; paths.push_back(path); return paths; &#125; unordered_set&lt;string&gt; forward, backward; forward.insert(beginWord); backward.insert(endWord); unordered_map&lt;string, vector&lt;string&gt; &gt; tree; bool reversed = false; //make sure the tree generating direction is consistent, since we have to start from the smaller set to accelerate; if (buildTree(forward, backward, dict, tree, reversed)) getPath(beginWord, endWord, tree, path, paths); return paths; &#125; private: bool buildTree(unordered_set&lt;string&gt; &amp;forward, unordered_set&lt;string&gt; &amp;backward, unordered_set&lt;string&gt; &amp;dict, unordered_map&lt;string, vector&lt;string&gt; &gt; &amp;tree, bool reversed) &#123; if (forward.empty()) return false; if (forward.size() &gt; backward.size()) return buildTree(backward, forward, dict, tree, !reversed); for (auto &amp;word: forward) dict.erase(word); for (auto &amp;word: backward) dict.erase(word); unordered_set&lt;string&gt; nextLevel; bool done = false; //in case of invalid further searching; for (auto &amp;it: forward) //traverse each word in the forward -&gt; the current level of the tree; &#123; string word = it; for (auto &amp;c: word) &#123; char c0 = c; //store the original; for (c = &apos;a&apos;; c &lt;= &apos;z&apos;; ++c) //try each case; &#123; if (c != c0) //avoid futile checking; &#123; if (backward.count(word)) //using count is an accelerating method; &#123; done = true; !reversed ? tree[it].push_back(word) : tree[word].push_back(it); //keep the tree generation direction consistent; &#125; else if (!done &amp;&amp; dict.count(word)) &#123; nextLevel.insert(word); !reversed ? tree[it].push_back(word) : tree[word].push_back(it); &#125; &#125; &#125; c = c0; //restore the word; &#125; &#125; return done || buildTree(nextLevel, backward, dict, tree, reversed); &#125; void getPath(string &amp;beginWord, string &amp;endWord, unordered_map&lt;string, vector&lt;string&gt; &gt; &amp;tree, vector&lt;string&gt; &amp;path, vector&lt;vector&lt;string&gt; &gt; &amp;paths) //using reference can accelerate; &#123; if (beginWord == endWord) paths.push_back(path); //till the end; else &#123; for (auto &amp;it: tree[beginWord]) &#123; path.push_back(it); getPath(it, endWord, tree, path, paths); //DFS retrieving the path; path.pop_back(); &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/43603/fast-and-clean-python-c-solution-using-double-bfs-beats-98 FAST AND CLEAN Python/C++ Solution using Double BFS, beats 98% If we know source and destination, we can build the word tree by going forward in one direction and backwards in the other. We stop when we have found that a word in the next level of BFS is in the other level, but first we need to update the tree for the words in the current level. Then we build the result by doing a DFS on the tree constructed by the BFS. The difference between normal and double BFS is that the search changes from O(k^d) to O(k^(d/2) + k^(d/2)). Same complexity class, right? Yeah, tell it to the Facebook guys that have to search in graphs with hundreds of thousands of nodes. 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): # Solution using double BFS def findLadders(self, begin, end, words_list): def construct_paths(source, dest, tree): if source == dest: return [[source]] return [[source] + path for succ in tree[source] for path in construct_paths(succ, dest, tree)] def add_path(tree, word, neigh, is_forw): if is_forw: tree[word] += neigh, else: tree[neigh] += word, def bfs_level(this_lev, oth_lev, tree, is_forw, words_set): if not this_lev: return False if len(this_lev) &gt; len(oth_lev): return bfs_level(oth_lev, this_lev, tree, not is_forw, words_set) for word in (this_lev | oth_lev): words_set.discard(word) next_lev, done = set(), False while this_lev: word = this_lev.pop() for c in string.ascii_lowercase: for index in range(len(word)): neigh = word[:index] + c + word[index+1:] if neigh in oth_lev: done = True add_path(tree, word, neigh, is_forw) if not done and neigh in words_set: next_lev.add(neigh) add_path(tree, word, neigh, is_forw) return done or bfs_level(next_lev, oth_lev, tree, is_forw, words_set) tree, path, paths = collections.defaultdict(list), [begin], [] is_found = bfs_level(set([begin]), set([end]), tree, True, words_list) return construct_paths(begin, end, tree) C++ code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283void add_to_tree(map&lt;string, vector&lt;string&gt;&gt;&amp; tree, string word, string neigh, bool forward) &#123; if (forward) tree[word].push_back(neigh); else tree[neigh].push_back(word);&#125;vector&lt;vector&lt;string&gt;&gt; construct_paths(map&lt;string, vector&lt;string&gt;&gt;&amp; tree, string start, string dest) &#123; if (start == dest) &#123; vector&lt;string&gt; res = &#123;start&#125;; vector&lt;vector&lt;string&gt;&gt; arr = &#123;res&#125;; return arr; &#125; vector&lt;vector&lt;string&gt;&gt; result; for (auto succ: tree[start]) &#123; for (auto path: construct_paths(tree, succ, dest)) &#123; path.insert(path.begin(), start); result.push_back(path); &#125; &#125; return result;&#125;bool bfs_levels(unordered_set&lt;string&gt;&amp; now, unordered_set&lt;string&gt;&amp; oth, bool&amp; forward, map&lt;string, vector&lt;string&gt;&gt;&amp; tree, unordered_set&lt;string&gt;&amp; words_list, vector&lt;char&gt;&amp; alphabet) &#123; if (not now.size()) return false; if (now.size() &gt; oth.size())&#123; forward = not forward; return bfs_levels(oth, now, forward, tree, words_list, alphabet); &#125; for (auto word: now) words_list.erase(word); for (auto word: oth) words_list.erase(word); bool done = false; unordered_set&lt;string&gt; next; for (string word: now) &#123; for (int i = 0; i &lt; word.size(); i++) &#123; for (char c: alphabet) &#123; auto neigh = word.substr(0, i) + c + word.substr(i+1); if (oth.count(neigh) &gt; 0) &#123; done = true; add_to_tree(tree, word, neigh, forward); &#125; else &#123; if (not done and words_list.count(neigh) &gt; 0) &#123; next.insert(neigh); add_to_tree(tree, word, neigh, forward); &#125; &#125; &#125; &#125; &#125; forward = not forward; return done or bfs_levels(oth, next, forward, tree, words_list, alphabet);&#125;class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, unordered_set&lt;string&gt; &amp;wordList) &#123; vector&lt;char&gt; alphabet(26); std::iota(alphabet.begin(), alphabet.end(), &apos;a&apos;); unordered_set&lt;string&gt; now = &#123;beginWord&#125;, oth = &#123;endWord&#125;; map&lt;string, vector&lt;string&gt;&gt; tree; bool forward = true; auto is_found = bfs_levels(now, oth, forward, tree, wordList, alphabet); return construct_paths(tree, beginWord, endWord); &#125;&#125;; https://discuss.leetcode.com/topic/8343/use-defaultdict-for-traceback-and-easy-writing-20-lines-python-code Use defaultdict for traceback and easy writing, 20 lines python code 1234567891011121314151617181920212223class Solution:# @param start, a string# @param end, a string# @param dict, a set of string# @return a list of lists of stringdef findLadders(self, start, end, dic): dic.add(end) level = &#123;start&#125; parents = collections.defaultdict(set) while level and end not in parents: next_level = collections.defaultdict(set) for node in level: for char in string.ascii_lowercase: for i in range(len(start)): n = node[:i]+char+node[i+1:] if n in dic and n not in parents: next_level[n].add(node) level = next_level parents.update(next_level) res = [[end]] while res and res[0][0] != start: res = [[p]+r for r in res for p in parents[r[0]]] return res Every level we use the defaultdict to get rid of the duplicates https://discuss.leetcode.com/topic/2857/share-two-similar-java-solution-that-accpted-by-oj Share two similar Java solution that Accpted by OJ. The solution contains two steps 1 Use BFS to construct a graph. 2. Use DFS to construct the paths from end to start.Both solutions got AC within 1s. The first step BFS is quite important. I summarized three tricks Using a MAP to store the min ladder of each word, or use a SET to store the words visited in current ladder, when the current ladder was completed, delete the visited words from unvisited. That’s why I have two similar solutions. Use Character iteration to find all possible paths. Do not compare one word to all the other words and check if they only differ by one character. One word is allowed to be inserted into the queue only ONCE. See my comments. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class Solution &#123; Map&lt;String,List&lt;String&gt;&gt; map; List&lt;List&lt;String&gt;&gt; results; public List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, Set&lt;String&gt; dict) &#123; results= new ArrayList&lt;List&lt;String&gt;&gt;(); if (dict.size() == 0) return results; int min=Integer.MAX_VALUE; Queue&lt;String&gt; queue= new ArrayDeque&lt;String&gt;(); queue.add(start); map = new HashMap&lt;String,List&lt;String&gt;&gt;(); Map&lt;String,Integer&gt; ladder = new HashMap&lt;String,Integer&gt;(); for (String string:dict) ladder.put(string, Integer.MAX_VALUE); ladder.put(start, 0); dict.add(end); //BFS: Dijisktra search while (!queue.isEmpty()) &#123; String word = queue.poll(); int step = ladder.get(word)+1;//&apos;step&apos; indicates how many steps are needed to travel to one word. if (step&gt;min) break; for (int i = 0; i &lt; word.length(); i++)&#123; StringBuilder builder = new StringBuilder(word); for (char ch=&apos;a&apos;; ch &lt;= &apos;z&apos;; ch++)&#123; builder.setCharAt(i,ch); String new_word=builder.toString(); if (ladder.containsKey(new_word)) &#123; if (step&gt;ladder.get(new_word))//Check if it is the shortest path to one word. continue; else if (step&lt;ladder.get(new_word))&#123; queue.add(new_word); ladder.put(new_word, step); &#125;else;// It is a KEY line. If one word already appeared in one ladder, // Do not insert the same word inside the queue twice. Otherwise it gets TLE. if (map.containsKey(new_word)) //Build adjacent Graph map.get(new_word).add(word); else&#123; List&lt;String&gt; list= new LinkedList&lt;String&gt;(); list.add(word); map.put(new_word,list); //It is possible to write three lines in one: //map.put(new_word,new LinkedList&lt;String&gt;(Arrays.asList(new String[]&#123;word&#125;))); //Which one is better? &#125; if (new_word.equals(end)) min=step; &#125;//End if dict contains new_word &#125;//End:Iteration from &apos;a&apos; to &apos;z&apos; &#125;//End:Iteration from the first to the last &#125;//End While //BackTracking LinkedList&lt;String&gt; result = new LinkedList&lt;String&gt;(); backTrace(end,start,result); return results; &#125; private void backTrace(String word,String start,List&lt;String&gt; list)&#123; if (word.equals(start))&#123; list.add(0,start); results.add(new ArrayList&lt;String&gt;(list)); list.remove(0); return; &#125; list.add(0,word); if (map.get(word)!=null) for (String s:map.get(word)) backTrace(s,start,list); list.remove(0); &#125;&#125; Another solution using two sets. This is similar to the answer in the most viewed thread. While I found my solution more readable and efficient. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Solution &#123; List&lt;List&lt;String&gt;&gt; results; List&lt;String&gt; list; Map&lt;String,List&lt;String&gt;&gt; map; public List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, Set&lt;String&gt; dict) &#123; results= new ArrayList&lt;List&lt;String&gt;&gt;(); if (dict.size() == 0) return results; int curr=1,next=0; boolean found=false; list = new LinkedList&lt;String&gt;(); map = new HashMap&lt;String,List&lt;String&gt;&gt;(); Queue&lt;String&gt; queue= new ArrayDeque&lt;String&gt;(); Set&lt;String&gt; unvisited = new HashSet&lt;String&gt;(dict); Set&lt;String&gt; visited = new HashSet&lt;String&gt;(); queue.add(start); unvisited.add(end); unvisited.remove(start); //BFS while (!queue.isEmpty()) &#123; String word = queue.poll(); curr--; for (int i = 0; i &lt; word.length(); i++)&#123; StringBuilder builder = new StringBuilder(word); for (char ch=&apos;a&apos;; ch &lt;= &apos;z&apos;; ch++)&#123; builder.setCharAt(i,ch); String new_word=builder.toString(); if (unvisited.contains(new_word))&#123; //Handle queue if (visited.add(new_word))&#123;//Key statement,Avoid Duplicate queue insertion next++; queue.add(new_word); &#125; if (map.containsKey(new_word))//Build Adjacent Graph map.get(new_word).add(word); else&#123; List&lt;String&gt; l= new LinkedList&lt;String&gt;(); l.add(word); map.put(new_word, l); &#125; if (new_word.equals(end)&amp;&amp;!found) found=true; &#125; &#125;//End:Iteration from &apos;a&apos; to &apos;z&apos; &#125;//End:Iteration from the first to the last if (curr==0)&#123; if (found) break; curr=next; next=0; unvisited.removeAll(visited); visited.clear(); &#125; &#125;//End While backTrace(end,start); return results; &#125; private void backTrace(String word,String start)&#123; if (word.equals(start))&#123; list.add(0,start); results.add(new ArrayList&lt;String&gt;(list)); list.remove(0); return; &#125; list.add(0,word); if (map.get(word)!=null) for (String s:map.get(word)) backTrace(s,start); list.remove(0); &#125; &#125; https://discuss.leetcode.com/topic/2857/share-two-similar-java-solution-that-accpted-by-oj Share two similar Java solution that Accpted by OJ. The solution contains two steps 1 Use BFS to construct a graph. 2. Use DFS to construct the paths from end to start.Both solutions got AC within 1s. The first step BFS is quite important. I summarized three tricks Using a MAP to store the min ladder of each word, or use a SET to store the words visited in current ladder, when the current ladder was completed, delete the visited words from unvisited. That’s why I have two similar solutions.Use Character iteration to find all possible paths. Do not compare one word to all the other words and check if they only differ by one character.One word is allowed to be inserted into the queue only ONCE. See my comments.public class Solution { Map&lt;String,List&gt; map; List&lt;List&gt; results; public List&lt;List&gt; findLadders(String start, String end, Set dict) { results= new ArrayList&lt;List&gt;(); if (dict.size() == 0) return results; int min=Integer.MAX_VALUE; Queue&lt;String&gt; queue= new ArrayDeque&lt;String&gt;(); queue.add(start); map = new HashMap&lt;String,List&lt;String&gt;&gt;(); Map&lt;String,Integer&gt; ladder = new HashMap&lt;String,Integer&gt;(); for (String string:dict) ladder.put(string, Integer.MAX_VALUE); ladder.put(start, 0); dict.add(end); //BFS: Dijisktra search while (!queue.isEmpty()) { String word = queue.poll(); int step = ladder.get(word)+1;//&apos;step&apos; indicates how many steps are needed to travel to one word. if (step&gt;min) break; for (int i = 0; i &lt; word.length(); i++){ StringBuilder builder = new StringBuilder(word); for (char ch=&apos;a&apos;; ch &lt;= &apos;z&apos;; ch++){ builder.setCharAt(i,ch); String new_word=builder.toString(); if (ladder.containsKey(new_word)) { if (step&gt;ladder.get(new_word))//Check if it is the shortest path to one word. continue; else if (step&lt;ladder.get(new_word)){ queue.add(new_word); ladder.put(new_word, step); }else;// It is a KEY line. If one word already appeared in one ladder, // Do not insert the same word inside the queue twice. Otherwise it gets TLE. if (map.containsKey(new_word)) //Build adjacent Graph map.get(new_word).add(word); else{ List&lt;String&gt; list= new LinkedList&lt;String&gt;(); list.add(word); map.put(new_word,list); //It is possible to write three lines in one: //map.put(new_word,new LinkedList&lt;String&gt;(Arrays.asList(new String[]{word}))); //Which one is better? } if (new_word.equals(end)) min=step; }//End if dict contains new_word }//End:Iteration from &apos;a&apos; to &apos;z&apos; }//End:Iteration from the first to the last }//End While //BackTracking LinkedList&lt;String&gt; result = new LinkedList&lt;String&gt;(); backTrace(end,start,result); return results; } private void backTrace(String word,String start,List&lt;String&gt; list){ if (word.equals(start)){ list.add(0,start); results.add(new ArrayList&lt;String&gt;(list)); list.remove(0); return; } list.add(0,word); if (map.get(word)!=null) for (String s:map.get(word)) backTrace(s,start,list); list.remove(0); } }Another solution using two sets. This is similar to the answer in the most viewed thread. While I found my solution more readable and efficient. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Solution &#123; List&lt;List&lt;String&gt;&gt; results; List&lt;String&gt; list; Map&lt;String,List&lt;String&gt;&gt; map; public List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, Set&lt;String&gt; dict) &#123; results= new ArrayList&lt;List&lt;String&gt;&gt;(); if (dict.size() == 0) return results; int curr=1,next=0; boolean found=false; list = new LinkedList&lt;String&gt;(); map = new HashMap&lt;String,List&lt;String&gt;&gt;(); Queue&lt;String&gt; queue= new ArrayDeque&lt;String&gt;(); Set&lt;String&gt; unvisited = new HashSet&lt;String&gt;(dict); Set&lt;String&gt; visited = new HashSet&lt;String&gt;(); queue.add(start); unvisited.add(end); unvisited.remove(start); //BFS while (!queue.isEmpty()) &#123; String word = queue.poll(); curr--; for (int i = 0; i &lt; word.length(); i++)&#123; StringBuilder builder = new StringBuilder(word); for (char ch=&apos;a&apos;; ch &lt;= &apos;z&apos;; ch++)&#123; builder.setCharAt(i,ch); String new_word=builder.toString(); if (unvisited.contains(new_word))&#123; //Handle queue if (visited.add(new_word))&#123;//Key statement,Avoid Duplicate queue insertion next++; queue.add(new_word); &#125; if (map.containsKey(new_word))//Build Adjacent Graph map.get(new_word).add(word); else&#123; List&lt;String&gt; l= new LinkedList&lt;String&gt;(); l.add(word); map.put(new_word, l); &#125; if (new_word.equals(end)&amp;&amp;!found) found=true; &#125; &#125;//End:Iteration from &apos;a&apos; to &apos;z&apos; &#125;//End:Iteration from the first to the last if (curr==0)&#123; if (found) break; curr=next; next=0; unvisited.removeAll(visited); visited.clear(); &#125; &#125;//End While backTrace(end,start); return results; &#125; private void backTrace(String word,String start)&#123; if (word.equals(start))&#123; list.add(0,start); results.add(new ArrayList&lt;String&gt;(list)); list.remove(0); return; &#125; list.add(0,word); if (map.get(word)!=null) for (String s:map.get(word)) backTrace(s,start); list.remove(0); &#125; &#125; https://discuss.leetcode.com/topic/27504/my-concise-java-solution-based-on-bfs-and-dfs My concise JAVA solution based on BFS and DFS Explanation The basic idea is: 1). Use BFS to find the shortest distance between start and end, tracing the distance of crossing nodes from start node to end node, and store node’s next level neighbors to HashMap; 2). Use DFS to output paths with the same distance as the shortest distance from distance HashMap: compare if the distance of the next level node equals the distance of the current node + 1. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, List&lt;String&gt; wordList) &#123; HashSet&lt;String&gt; dict = new HashSet&lt;String&gt;(wordList); List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();// Neighbors for every node HashMap&lt;String, Integer&gt; distance = new HashMap&lt;String, Integer&gt;();// Distance of every node from the start node ArrayList&lt;String&gt; solution = new ArrayList&lt;String&gt;(); dict.add(start); bfs(start, end, dict, nodeNeighbors, distance); dfs(start, end, dict, nodeNeighbors, distance, solution, res); return res;&#125;// BFS: Trace every node&apos;s distance from the start node (level by level).private void bfs(String start, String end, Set&lt;String&gt; dict, HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors, HashMap&lt;String, Integer&gt; distance) &#123; for (String str : dict) nodeNeighbors.put(str, new ArrayList&lt;String&gt;()); Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.offer(start); distance.put(start, 0); while (!queue.isEmpty()) &#123; int count = queue.size(); boolean foundEnd = false; for (int i = 0; i &lt; count; i++) &#123; String cur = queue.poll(); int curDistance = distance.get(cur); ArrayList&lt;String&gt; neighbors = getNeighbors(cur, dict); for (String neighbor : neighbors) &#123; nodeNeighbors.get(cur).add(neighbor); if (!distance.containsKey(neighbor)) &#123;// Check if visited distance.put(neighbor, curDistance + 1); if (end.equals(neighbor))// Found the shortest path foundEnd = true; else queue.offer(neighbor); &#125; &#125; &#125; if (foundEnd) break; &#125; &#125;// Find all next level nodes. private ArrayList&lt;String&gt; getNeighbors(String node, Set&lt;String&gt; dict) &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); char chs[] = node.toCharArray(); for (char ch =&apos;a&apos;; ch &lt;= &apos;z&apos;; ch++) &#123; for (int i = 0; i &lt; chs.length; i++) &#123; if (chs[i] == ch) continue; char old_ch = chs[i]; chs[i] = ch; if (dict.contains(String.valueOf(chs))) &#123; res.add(String.valueOf(chs)); &#125; chs[i] = old_ch; &#125; &#125; return res;&#125;// DFS: output all paths with the shortest distance.private void dfs(String cur, String end, Set&lt;String&gt; dict, HashMap&lt;String, ArrayList&lt;String&gt;&gt; nodeNeighbors, HashMap&lt;String, Integer&gt; distance, ArrayList&lt;String&gt; solution, List&lt;List&lt;String&gt;&gt; res) &#123; solution.add(cur); if (end.equals(cur)) &#123; res.add(new ArrayList&lt;String&gt;(solution)); &#125; else &#123; for (String next : nodeNeighbors.get(cur)) &#123; if (distance.get(next) == distance.get(cur) + 1) &#123; dfs(next, end, dict, nodeNeighbors, distance, solution, res); &#125; &#125; &#125; solution.remove(solution.size() - 1);&#125; Solution 1: 672ms, 40.34%, June.24th, 2016 https://leetcode.com/discuss/24191/defaultdict-for-traceback-and-easy-writing-lines-python-code 12345678910111213141516171819202122232425class Solution(object): def findLadders(self, beginWord, endWord, wordlist): &quot;&quot;&quot; :type beginWord: str :type endWord: str :type wordlist: Set[str] :rtype: List[List[int]] &quot;&quot;&quot; wordlist.add(endWord) level = &#123;beginWord&#125; parents = collections.defaultdict(set) while level and endWord not in parents: next_level = collections.defaultdict(set) for node in level: for char in string.ascii_lowercase: for i in range(len(beginWord)): n = node[:i]+char+node[i+1:] if n in wordlist and n not in parents: next_level[n].add(node) level = next_level parents.update(next_level) res = [[endWord]] while res and res[0][0] != beginWord: res = [[p]+r for r in res for p in parents[r[0]]] return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>string</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[125. Valid Palindrome]]></title>
    <url>%2Fp%2Feb15f900%2F</url>
    <content type="text"><![CDATA[25.7% https://leetcode.com/problems/valid-palindrome/#/description Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. 123For example,&quot;A man, a plan, a canal: Panama&quot; is a palindrome.&quot;race a car&quot; is not a palindrome. Note: Have you consider that the string might be empty? This is a good question to ask during an interview. For the purpose of this problem, we define empty string as valid palindrome. isalnum 是否数字字符 isalpha 是否字母字符 tolower/toupper 方法一： Here’s a clean C++ solution 123456789bool isPalindrome(string s) &#123; for (int i = 0, j = s.size() - 1; i &lt; j; i++, j--) &#123; // Move 2 pointers from each end until they collide while (isalnum(s[i]) == false &amp;&amp; i &lt; j) i++; // Increment left pointer if not alphanumeric while (isalnum(s[j]) == false &amp;&amp; i &lt; j) j--; // Decrement right pointer if no alphanumeric if (toupper(s[i]) != toupper(s[j])) return false; // Exit and return error if not match &#125; return true;&#125; 我的代码实现： 123456789101112131415class Solution &#123;public: bool isPalindrome(string s) &#123; int n = s.size(); if(n==0) return true; int i = 0, j = n-1; while(i&lt;j)&#123; while(i&lt;j &amp;&amp; !isalnum(s[i])) i++; while(i&lt;j &amp;&amp; !isalnum(s[j])) j--; if(toupper(s[i])!=toupper(s[j])) return false; i++; j--; &#125; return true; &#125;&#125;; https://discuss.leetcode.com/topic/5581/here-s-a-clean-c-solution Here’s a clean C++ solution 123456789bool isPalindrome(string s) &#123; for (int i = 0, j = s.size() - 1; i &lt; j; i++, j--) &#123; // Move 2 pointers from each end until they collide while (isalnum(s[i]) == false &amp;&amp; i &lt; j) i++; // Increment left pointer if not alphanumeric while (isalnum(s[j]) == false &amp;&amp; i &lt; j) j--; // Decrement right pointer if no alphanumeric if (toupper(s[i]) != toupper(s[j])) return false; // Exit and return error if not match &#125; return true;&#125; https://discuss.leetcode.com/topic/10862/passed-clean-c-code Passed clean c++ code 1234567891011bool isPalindrome(string s) &#123; int start=0, end=s.length()-1; while(start&lt;end) &#123; if (!isalnum(s[start])) start++; else if (!isalnum(s[end])) end--; else &#123; if (tolower(s[start++])!=tolower(s[end--])) return false; &#125; &#125; return true;&#125; https://discuss.leetcode.com/topic/22479/python-in-place-two-pointer-solution Python in-place two-pointer solution. 1234567891011def isPalindrome(self, s): l, r = 0, len(s)-1 while l &lt; r: while l &lt; r and not s[l].isalnum(): l += 1 while l &lt;r and not s[r].isalnum(): r -= 1 if s[l].lower() != s[r].lower(): return False l +=1; r -= 1 return True 80ms, 78.34%, April.23rd, 2016 https://leetcode.com/discuss/11241/challenge-shortest-possible-answer-python-palindrome-python 12345678class Solution(object): def isPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; newS = [i.lower() for i in s if i.isalnum()] return newS == newS[::-1] https://discuss.leetcode.com/topic/8282/accepted-pretty-java-solution-271ms Accepted pretty Java solution(271ms) 1234567891011121314151617181920212223242526public class Solution &#123; public boolean isPalindrome(String s) &#123; if (s.isEmpty()) &#123; return true; &#125; int head = 0, tail = s.length() - 1; char cHead, cTail; while(head &lt;= tail) &#123; cHead = s.charAt(head); cTail = s.charAt(tail); if (!Character.isLetterOrDigit(cHead)) &#123; head++; &#125; else if(!Character.isLetterOrDigit(cTail)) &#123; tail--; &#125; else &#123; if (Character.toLowerCase(cHead) != Character.toLowerCase(cTail)) &#123; return false; &#125; head++; tail--; &#125; &#125; return true; &#125;&#125; Solution 2: 12ms, 40.64%, April.23rd, 2016 https://leetcode.com/discuss/80399/7-lines-concise-and-easy-understand-c-solution 12345678910111213class Solution &#123;public: bool isPalindrome(string s) &#123; int l=0, r = s.size() - 1; while(l &lt;= r)&#123; while(!isalnum(s[l]) &amp;&amp; l &lt; r) l++; while(!isalnum(s[r]) &amp;&amp; l &lt; r) r--; if(toupper(s[l]) != toupper(s[r])) return false; l++, r--; &#125; return true; &#125;&#125;; Solution 3: 16ms, 10.11%, April.23rd, 2016 1234567891011121314class Solution &#123;public: bool isPalindrome(string s) &#123; transform(s.begin(), s.end(), s.begin(), ::tolower); auto left = s.begin(), right = s.end(); while(left &lt; right)&#123; if(!::isalnum(*left)) ++left; else if(!::isalnum(*right)) --right; else if(*left != *right) return false; else&#123;left++, right--;&#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[124. Binary Tree Maximum Path Sum]]></title>
    <url>%2Fp%2Fa3afbfd3%2F</url>
    <content type="text"><![CDATA[25.3% https://leetcode.com/problems/binary-tree-maximum-path-sum/?tab=Description Given a binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. 1234567For example:Given the below binary tree, 1 / \ 2 3Return 6. 面试360时遇到，核心提示，使用带参数的函数。 方法一： [recommend for beginners]clean C++ implementation with detailed explanation help函数，表征从root节点开始，至叶节点之间的最大value。 sum通过获取，help(root-&gt;left), help(root-&gt;right)， 再加上root-&gt;val的和为sum，与先前的sum比较，进行更新。 其中，help(root-&gt;left)&lt;=0时，此处应为0。 code 1： 1234567891011121314151617181920class Solution &#123; int sum;public: int maxPathSum(TreeNode* root) &#123; sum=INT_MIN; help(root); return sum; &#125; /*** return the max-value-ended-at-root-node ***/ int help(TreeNode* root)&#123; if(!root) return 0; int left = max(0, help(root-&gt;left)); int right = max(0, help(root-&gt;right)); /*** key parts : embedding the max-value-find in the recursion process ***/ sum = max(sum, left+right+root-&gt;val); /*** get the max-value-ended-at-root ***/ return max(left, right)+root-&gt;val; &#125;&#125;; code 2： 1234567891011121314151617class Solution &#123; int maxToRoot(TreeNode *root, int &amp;re) &#123; if (!root) return 0; int l = maxToRoot(root-&gt;left, re); int r = maxToRoot(root-&gt;right, re); if (l &lt; 0) l = 0; if (r &lt; 0) r = 0; if (l + r + root-&gt;val &gt; re) re = l + r + root-&gt;val; return root-&gt;val += max(l, r); &#125;public: int maxPathSum(TreeNode *root) &#123; int max = -2147483648; maxToRoot(root, max); return max; &#125;&#125;; code 3： 我自己的代码 逻辑还是很简单的，但是要考虑周全，不然ac不过去。 res表示最长路径的大小，然后在helper函数中，传的是地址。 helper中是树的先序遍历。root==NULL自不必说。helper函数返回当前节点出发至下面任意节点之间的最大的值得大小。当前的root对应的的值为cur，要考虑这个大小，就要考虑左节点出发的大小，右节点的大小，这时，更新下res的大小，通过当前节点的加上左右分支的节点的最大值，为cur_max去更新res的值。然后返回值呢，就是左节点右节点的最大值与0的最大值加上cur，因为返回值是通过当前节点的一条分支的最大值。 1234567891011121314151617181920class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; if(root==NULL) return 0; int res = INT_MIN; // 初始值设置为INT_MIN，而不是0，否则负数会出错误结果。 helper(root, res); return res; &#125; int helper(TreeNode* root, int &amp; res)&#123; if(root==NULL) return 0; int cur = root-&gt;val; int left = helper(root-&gt;left, res); int right = helper(root-&gt;right, res); int cur_max = max(left,0) + max(right, 0) + cur; res = max(cur_max, res); return max(max(left, right), 0)+cur; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; int res = INT_MIN; helper(root, res); return res; &#125; int helper(TreeNode* root, int &amp; res)&#123; if(!root) return 0; int left = helper(root-&gt;left, res); int right = helper(root-&gt;right, res); left = max(left, 0); right = max(right, 0); res = max(left+right+root-&gt;val, res); return max(left, right)+root-&gt;val; &#125;&#125;; 方法二： 这种方法与上一种逻辑上是一样的，不同的是，一是res在全局变量（是这个名字？？），更重要的是它设定了一个res的初始值，就避免了使用INT_MIN。 12345678910111213141516class Solution &#123; int res;public: int depth(TreeNode *root)&#123; if(root==NULL) return 0; int a=depth(root-&gt;left), b=depth(root-&gt;right); res=max(res,a+b+root-&gt;val);//if *root is the top node in the path return max(0,max(a, b)+root-&gt;val);//if *root is in the path, if this branch a burden or a plus &#125; int maxPathSum(TreeNode *root) &#123; if(root==NULL) return 0; res=root-&gt;val; depth(root); return res; &#125;&#125;; https://discuss.leetcode.com/topic/5508/simple-o-n-algorithm-with-one-traversal-through-the-tree Simple O(n) algorithm with one traversal through the tree 1234567891011121314151617class Solution &#123; int maxToRoot(TreeNode *root, int &amp;re) &#123; if (!root) return 0; int l = maxToRoot(root-&gt;left, re); int r = maxToRoot(root-&gt;right, re); if (l &lt; 0) l = 0; if (r &lt; 0) r = 0; if (l + r + root-&gt;val &gt; re) re = l + r + root-&gt;val; return root-&gt;val += max(l, r); &#125;public: int maxPathSum(TreeNode *root) &#123; int max = -2147483648; maxToRoot(root, max); return max; &#125;&#125;; update the val of each node of the tree bottom-up, the new val of TreeNode *x stands for the max sum started from any node in subtree x and ended in x, mataining the re for result in traversal at the same time. https://discuss.leetcode.com/topic/5508/simple-o-n-algorithm-with-one-traversal-through-the-tree/5 Good solution! Essentially same as mine, but I don’t see why you update the val of each node, since each node is visited only once. In my version, I just return the maximum path ending at the root of the current tree while potentially updating the value of the global maximum with the path that links left and right. 1234567891011121314151617class Solution &#123;public: int maxPathSum(TreeNode *root) &#123; int max = numeric_limits&lt;int&gt;::min(); maxPathAndGlobalUpdate(root, &amp;max); return max; &#125;private: int maxPathAndGlobalUpdate(TreeNode *root, int* _global_max) &#123; if (root == nullptr) return 0; int&amp; global_max = *_global_max; int l = max(0, maxPathAndGlobalUpdate(root-&gt;left, &amp;global_max)); int r = max(0, maxPathAndGlobalUpdate(root-&gt;right, &amp;global_max)); global_max = max(global_max, l + r + root-&gt;val); return root-&gt;val + max(l, r); &#125;&#125;; 42ms, 15.55%, October 14, 2016 A very concise recursive solution https://discuss.leetcode.com/topic/7325/a-very-concise-recursive-solution 12345678910111213141516class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; int maxPath = INT_MIN; dfsMaxPath(root, maxPath); return maxPath; &#125; int dfsMaxPath(TreeNode *root, int &amp;maxPath)&#123; if(!root) return 0; int l = max(0, dfsMaxPath(root-&gt;left, maxPath)); int r = max(0, dfsMaxPath(root-&gt;right, maxPath)); maxPath = max(maxPath, l+r+root-&gt;val); return root-&gt;val + max(l, r); &#125;&#125;; https://discuss.leetcode.com/topic/2644/accepted-o-n-solution Accepted O(n) solution The idea is based on the solution of max sum of a sequence array, Here is the explaination of the code: Have a recursive method which traverse the binary tree, it also return the max possible sum of left branch and right branch saperately. for example, For node A, when it’s left and right node recusive call returned, we will know the max possible sum of left branch, right branch. Have a CheckMax function which will compare the sequence sum and record the max history. For node A, check whether left branch + this node + right branch is the maximum, check whether left branch + this node is max， check whether right branch + this node is max. When recursive method return, we should only return the max sum of one path - either the left branch + this node, or the right branch + this node. So that this is still a single path and can be used to link by node A’s parent node. It’s accepted by OL. Let me know if you have any question 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public: int maxPathSum(TreeNode *root) &#123; if(!root) return 0; maxSum = root-&gt;val; recNodes(root); return maxSum; &#125; protected: int recNodes(TreeNode* node) &#123; int numl=0,numr=0; if (node-&gt;left) numl = recNodes(node-&gt;left); if (node-&gt;right) numr = recNodes(node-&gt;right); //choose the max path, either left or right int value = node-&gt;val; int sumWhole = checkMax(value,numl+numr); int sumLeft = numl&gt;0?checkMax(value,numl):value; int sumRight = numr&gt;0?checkMax(value,numr):value; return max(sumLeft,sumRight); &#125; int checkMax(int value, int sum) &#123; if(sum&gt;0) sum+=value; else sum=value; if(sum&gt;maxSum) maxSum = sum; return sum; &#125; int maxSum; &#125;; https://discuss.leetcode.com/topic/35300/recommend-for-beginners-clean-c-implementation-with-detailed-explanation [recommend for beginners]clean C++ implementation with detailed explanation 1234567891011121314151617181920class Solution &#123; int sum;public: int maxPathSum(TreeNode* root) &#123; sum=INT_MIN; help(root); return sum; &#125; /*** return the max-value-ended-at-root-node ***/ int help(TreeNode* root)&#123; if(!root) return 0; int left = max(0, help(root-&gt;left)); int right = max(0, help(root-&gt;right)); /*** key parts : embedding the max-value-find in the recursion process ***/ sum = max(sum, left+right+root-&gt;val); /*** get the max-value-ended-at-root ***/ return max(left, right)+root-&gt;val; &#125;&#125;; https://discuss.leetcode.com/topic/11112/clean-c-solution Clean c++ solution 12345678910111213141516class Solution &#123; int res;public: int depth(TreeNode *root)&#123; if(root==NULL) return 0; int a=depth(root-&gt;left), b=depth(root-&gt;right); res=max(res,a+b+root-&gt;val);//if *root is the top node in the path return max(0,max(a, b)+root-&gt;val);//if *root is in the path, if this branch a burden or a plus &#125; int maxPathSum(TreeNode *root) &#123; if(root==NULL) return 0; res=root-&gt;val; depth(root); return res; &#125;&#125;; 2ms, 42.51%, October 14, 2016 https://discuss.leetcode.com/topic/4407/accepted-short-solution-in-java 1234567891011121314151617public class Solution &#123; int maxValue; public int maxPathSum(TreeNode root) &#123; maxValue = Integer.MIN_VALUE; maxPathDown(root); return maxValue; &#125; private int maxPathDown(TreeNode node)&#123; if(node == null) return 0; int left = Math.max(0, maxPathDown(node.left)); int right = Math.max(0, maxPathDown(node.right)); maxValue = Math.max(maxValue, left+right+node.val); return Math.max(left, right) + node.val; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[123. Best Time to Buy and Sell Stock III]]></title>
    <url>%2Fp%2F3ac663d0%2F</url>
    <content type="text"><![CDATA[28.6% https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 方法一： 微策略面试题 我的代码实现： Oct 17, 2017 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; v = &#123;INT_MIN, 0, INT_MIN, 0&#125;; for(auto price:prices)&#123; v[0] = max(v[0], -price); v[1] = max(v[1], v[0]+price); v[2] = max(v[2], v[1]-price); v[3] = max(v[3], v[2]+price); &#125; return max(v[1], v[3]); &#125;&#125;; My C++ solution (O(N) time, O(1) space, 8ms) It is similar to other buy/sell problems. just do DP and define an array of states to track the current maximum profits at different stages. For example, in the below code states[][0]: one buy states[][1]: one buy, one sell states[][2]: two buys, one sell states[][3]: two buy, two sells The states transistions occurs when buy/sell operations are executed. For example, state[][0] can move to state[][1] via one sell operation. 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int states[2][4] = &#123;INT_MIN, 0, INT_MIN, 0&#125;; // 0: 1 buy, 1: one buy/sell, 2: 2 buys/1 sell, 3, 2 buys/sells int len = prices.size(), i, cur = 0, next =1; for(i=0; i&lt;len; ++i) &#123; states[next][0] = max(states[cur][0], -prices[i]); states[next][1] = max(states[cur][1], states[cur][0]+prices[i]); states[next][2] = max(states[cur][2], states[cur][1]-prices[i]); states[next][3] = max(states[cur][3], states[cur][2]+prices[i]); swap(next, cur); &#125; return max(states[cur][1], states[cur][3]); &#125;&#125;; 方法二： 高效、简便、容易想到的方法 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); if(n&lt;2) return 0; vector&lt;int&gt; dp1(n, 0); vector&lt;int&gt; dp2(n, 0); int minPrice = INT_MAX; int maxProfit1 = 0; for(int i=0; i&lt;n; i++)&#123; minPrice = min(minPrice, prices[i]); maxProfit1 = max(maxProfit1, prices[i]-minPrice); dp1[i] = maxProfit1; &#125; int maxPrice = INT_MIN; int maxProfit2 = 0; for(int i=n-1; i&gt;=0; i--)&#123; maxPrice = max(maxPrice, prices[i]); maxProfit2 = max(maxProfit2, maxPrice-prices[i]); dp2[i] = maxProfit2; &#125; int maxProfit = 0; for(int i=0; i&lt;n; i++)&#123; maxProfit = max(maxProfit, dp1[i]+dp2[i]); &#125; return maxProfit; &#125;&#125;; cpp https://discuss.leetcode.com/topic/19750/my-c-solution-o-n-time-o-1-space-8ms My C++ solution (O(N) time, O(1) space, 8ms) It is similar to other buy/sell problems. just do DP and define an array of states to track the current maximum profits at different stages. For example, in the below code states[][0]: one buy states[][1]: one buy, one sell states[][2]: two buys, one sell states[][3]: two buy, two sells The states transistions occurs when buy/sell operations are executed. For example, state[][0] can move to state[][1] via one sell operation. 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int states[2][4] = &#123;INT_MIN, 0, INT_MIN, 0&#125;; // 0: 1 buy, 1: one buy/sell, 2: 2 buys/1 sell, 3, 2 buys/sells int len = prices.size(), i, cur = 0, next =1; for(i=0; i&lt;len; ++i) &#123; states[next][0] = max(states[cur][0], -prices[i]); states[next][1] = max(states[cur][1], states[cur][0]+prices[i]); states[next][2] = max(states[cur][2], states[cur][1]-prices[i]); states[next][3] = max(states[cur][3], states[cur][2]+prices[i]); swap(next, cur); &#125; return max(states[cur][1], states[cur][3]); &#125;&#125;; https://discuss.leetcode.com/topic/27426/a-solution-not-so-dynamic-programming A solution not so dynamic programming. I think the most difficult part is how to connect the first transaction to the second transaction. The final target is to get the maximum value of profit2. You must try to get money as much as possible after you buy the stock second time. Then after the second time of sell, with the as high as possible price, you get the maximum profit. 1234567891011121314151617class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int size=prices.size(); int profit1=0; int profit2=0; int o1=INT_MAX; int o2=INT_MIN; for(int i=0; i&lt;size; ++i)&#123; o1=min(o1, prices[i]); profit1=max(profit1, prices[i]-o1); o2=max(o2, profit1-prices[i]); profit2=max(profit2, prices[i]+o2); &#125; return profit2; &#125;&#125;; https://discuss.leetcode.com/topic/902/don-t-need-dp-to-solve-it-within-o-n Don’t need DP to solve it within O(n) Don’t need DP to solve this problem. It is still O(n) and basically use the same algorithm solving “Stock I” four times. Get the max profit with one transaction to the full array. Keep down the start and end positions. the start and end positions will be included in the result of two transaction. It falls into two categories:A) it is one full transaction, B) they belong to two separate transactions(start belongs to first transaction and end belongs to second transaction). if A)– get max profit with one transaction to subarray from 0 to start ; get max profit with one transaction to subarray from end to prices.length. if B)– get the max profit with one transaction within start and end in reverse order return the max profit in those cases. https://discuss.leetcode.com/topic/41049/clear-c-solution Clear c++ solution 123456789101112int maxProfit(vector&lt;int&gt;&amp; prices) &#123; //It&apos;s wrong if you choose the minimum price for buy2 , but you can maximize the left money. // int buy1 = INT_MIN, sale1 = 0, buy2 = INT_MIN, sale2 = 0; for(int i=0; i&lt;prices.size(); i++)&#123; //the more money left, the happier you will be buy1 = max(buy1, -prices[i]); //left money after buy1 sale1 = max(sale1, prices[i] + buy1); //left money after sale1 buy2 = max(buy2, sale1 - prices[i]); //left money after buy2 sale2 = max(sale2, prices[i] + buy2); //left money after sale2 &#125; return sale2;&#125; https://discuss.leetcode.com/topic/42087/why-don-t-we-make-our-life-easier Why don’t we make our life easier The idea is very basic. At most two transactions means we can break at any time point and compute the max revenue before this time point and after this time point. For every possible time point, we choose the maximum. Note that right_max start from the last time point, which is just like a mirror algorithm from the Best Time to Buy and Sell Stock I 123456789101112131415161718192021222324252627int maxProfit(vector&lt;int&gt;&amp; prices) &#123; vector&lt;int&gt; left_max; vector&lt;int&gt; right_max; int n = prices.size(); if(n == 0)&#123; return 0; &#125; int cur_min = prices[0]; int max_r = 0; for(int i = 0; i &lt; n; i++)&#123; max_r = max(max_r, prices[i] - cur_min); left_max.push_back(max_r); cur_min = min(cur_min, prices[i]); &#125; int cur_max = prices[n-1]; max_r = 0; for(int i = n-1; i &gt;= 0; i--)&#123; max_r = max(max_r, cur_max - prices[i]); right_max.insert(right_max.begin(), max_r); cur_max = max(cur_max, prices[i]); &#125; int sum_max = 0; for(int i = 0; i &lt; n; i++)&#123; sum_max = max(sum_max, left_max[i] + right_max[i]); &#125; return sum_max;&#125; python https://discuss.leetcode.com/topic/6811/python-dp-solution-120ms Python DP solution, 120ms Two passes through the list, O(n) time, O(n) space: 12345678910111213141516171819202122232425def maxProfit(self, prices): if not prices: return 0 # forward traversal, profits record the max profit # by the ith day, this is the first transaction profits = [] max_profit = 0 current_min = prices[0] for price in prices: current_min = min(current_min, price) max_profit = max(max_profit, price - current_min) profits.append(max_profit) # backward traversal, max_profit records the max profit # after the ith day, this is the second transaction total_max = 0 max_profit = 0 current_max = prices[-1] for i in range(len(prices) - 1, -1, -1): current_max = max(current_max, prices[i]) max_profit = max(max_profit, current_max - prices[i]) total_max = max(total_max, max_profit + profits[i]) return total_max https://discuss.leetcode.com/topic/51468/7-liner-in-python-beats-99 7-liner in Python, beats 99% 1234567891011121314class Solution(object): def maxProfit(self, p): if not p: return 0 sell, buyd, n, minp, maxp = [0], [0], len(p), p[0], p[-1] for i in range(1, n): minp, maxp = min(minp, p[i]), max(maxp, p[n-i-1]) sell.append(max(sell[i-1], p[i] - minp)) buyd.append(max(buyd[i-1], maxp - p[n-i-1])) return max(sell[i] + buyd[n-i-1] for i in range(n))# 198 / 198 test cases passed.# Status: Accepted# Runtime: 56 ms java https://discuss.leetcode.com/topic/5934/is-it-best-solution-with-o-n-o-1 Is it Best Solution with O(n), O(1). The thinking is simple and is inspired by the best solution from Single Number II (I read through the discussion after I use DP). Assume we only have 0 money at first; 4 Variables to maintain some interested ‘ceilings’ so far: The maximum of if we’ve just buy 1st stock, if we’ve just sold 1nd stock, if we’ve just buy 2nd stock, if we’ve just sold 2nd stock. Very simple code too and work well. I have to say the logic is simple than those in Single Number II. 12345678910111213public class Solution &#123; public int maxProfit(int[] prices) &#123; int hold1 = Integer.MIN_VALUE, hold2 = Integer.MIN_VALUE; int release1 = 0, release2 = 0; for(int i:prices)&#123; // Assume we only have 0 money at first release2 = Math.max(release2, hold2+i); // The maximum if we&apos;ve just sold 2nd stock so far. hold2 = Math.max(hold2, release1-i); // The maximum if we&apos;ve just buy 2nd stock so far. release1 = Math.max(release1, hold1+i); // The maximum if we&apos;ve just sold 1nd stock so far. hold1 = Math.max(hold1, -i); // The maximum if we&apos;ve just buy 1st stock so far. &#125; return release2; ///Since release1 is initiated as 0, so release2 will always higher than release1. &#125;&#125; https://discuss.leetcode.com/topic/4766/a-clean-dp-solution-which-generalizes-to-k-transactions A clean DP solution which generalizes to k transactions Solution is commented in the code. Time complexity is O(kn), space complexity can be O(n) because this DP only uses the result from last step. But for cleaness this solution still used O(kn) space complexity to preserve similarity to the equations in the comments. 12345678910111213141516171819202122232425class Solution &#123;public: int maxProfit(vector&lt;int&gt; &amp;prices) &#123; // f[k, ii] represents the max profit up until prices[ii] (Note: NOT ending with prices[ii]) using at most k transactions. // f[k, ii] = max(f[k, ii-1], prices[ii] - prices[jj] + f[k-1, jj]) &#123; jj in range of [0, ii-1] &#125; // = max(f[k, ii-1], prices[ii] + max(f[k-1, jj] - prices[jj])) // f[0, ii] = 0; 0 times transation makes 0 profit // f[k, 0] = 0; if there is only one price data point you can&apos;t make any money no matter how many times you can trade if (prices.size() &lt;= 1) return 0; else &#123; int K = 2; // number of max transation allowed int maxProf = 0; vector&lt;vector&lt;int&gt;&gt; f(K+1, vector&lt;int&gt;(prices.size(), 0)); for (int kk = 1; kk &lt;= K; kk++) &#123; int tmpMax = f[kk-1][0] - prices[0]; for (int ii = 1; ii &lt; prices.size(); ii++) &#123; f[kk][ii] = max(f[kk][ii-1], prices[ii] + tmpMax); tmpMax = max(tmpMax, f[kk-1][ii] - prices[ii]); maxProf = max(f[kk][ii], maxProf); &#125; &#125; return maxProf; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/4766/a-clean-dp-solution-which-generalizes-to-k-transactions/2 Brilliant solution! a small point: there is no need to track maxProf. we can simply return f[K][prices.size()-1] https://discuss.leetcode.com/topic/4766/a-clean-dp-solution-which-generalizes-to-k-transactions/9 Brilliant solution! Thanks for sharing~ Minor point, but f[kk-1][0] is just 0. I’d also explain the algorithm a little differently, something like the following: 123456// dpProfit[t][i]: maximum Profit using at most t transactions up to day i (including day i)// dpProfit[t][i] = max(dpProfit[t][i - 1], prices[i] - prices[j] + dpProfit[t - 1][j]) for all j in range [0, i - 1]// = max(dpProfit[t][i - 1], prices[i] + max(dpProfit[t - 1][j] - prices[j])) for all j in range [0, i - 1]// = max(dpProfit[t][i - 1], prices[i] + max prev [t - 1] trans profit at the corresponding j in range [0, i - 1] less price at j)// maxPreProfitLessI inside loop iterations// Note: subtracting price at j is for the last additional transaction to sell at day i https://discuss.leetcode.com/topic/39751/my-explanation-for-o-n-solution My explanation for O(N) solution! First assume that we have no money, so buy1 means that we have to borrow money from others, we want to borrow less so that we have to make our balance as max as we can(because this is negative). sell1 means we decide to sell the stock, after selling it we have price[i] money and we have to give back the money we owed, so we have price[i] - |buy1| = prices[i ] + buy1, we want to make this max. buy2 means we want to buy another stock, we already have sell1 money, so after buying stock2 we have buy2 = sell1 - price[i] money left, we want more money left, so we make it max sell2 means we want to sell stock2, we can have price[i] money after selling it, and we have buy2 money left before, so sell2 = buy2 + prices[i], we make this max. So sell2 is the most money we can have. Hope it is helpful and welcome quesions! 12345678910public int maxProfit(int[] prices) &#123; int sell1 = 0, sell2 = 0, buy1 = Integer.MIN_VALUE, buy2 = Integer.MIN_VALUE; for (int i = 0; i &lt; prices.length; i++) &#123; buy1 = Math.max(buy1, -prices[i]); sell1 = Math.max(sell1, buy1 + prices[i]); buy2 = Math.max(buy2, sell1 - prices[i]); sell2 = Math.max(sell2, buy2 + prices[i]); &#125; return sell2; &#125; https://discuss.leetcode.com/topic/32288/2ms-java-dp-solution 2ms Java DP Solution Sorry for my poor English 12345678910111213141516public int maxProfit(int[] prices) &#123; // these four variables represent your profit after executing corresponding transaction // in the beginning, your profit is 0. // when you buy a stock ,the profit will be deducted of the price of stock. int firstBuy = Integer.MIN_VALUE, firstSell = 0; int secondBuy = Integer.MIN_VALUE, secondSell = 0; for (int curPrice : prices) &#123; if (firstBuy &lt; -curPrice) firstBuy = -curPrice; // the max profit after you buy first stock if (firstSell &lt; firstBuy + curPrice) firstSell = firstBuy + curPrice; // the max profit after you sell it if (secondBuy &lt; firstSell - curPrice) secondBuy = firstSell - curPrice; // the max profit after you buy the second stock if (secondSell &lt; secondBuy + curPrice) secondSell = secondBuy + curPrice; // the max profit after you sell the second stock &#125; return secondSell; // secondSell will be the max profit after passing the prices&#125; https://discuss.leetcode.com/topic/7028/java-solution-with-just-two-traverses Java solution with just two traverses. Go from left to right and calculate max profit for each index (i). Go from right to left and calculate max profit for (i). Add max right profit for (i) and max left profit for (i-1) and check if it’s max profit. 123456789101112131415161718192021222324252627public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) return 0; int lenght = prices.length; int[] leftProfit = new int[lenght]; int leftMaxProfit = 0; int leftMin = prices[0]; for (int i=0; i&lt;lenght; i++) &#123; if (prices[i] &lt; leftMin) leftMin = prices[i]; if (prices[i] - leftMin &gt; leftMaxProfit) leftMaxProfit = prices[i]-leftMin; leftProfit[i] = leftMaxProfit; &#125; int maxProfit = 0; int rightMaxProfit = 0; int rightMax = prices[lenght-1]; for (int i=lenght-1; i&gt;=0; i--) &#123; if (prices[i] &gt; rightMax) rightMax = prices[i]; if (rightMax - prices[i] &gt; rightMaxProfit) rightMaxProfit = rightMax - prices[i]; int currentProfit = rightMaxProfit + (i&gt;0 ? leftProfit[i-1] : 0); if (currentProfit &gt; maxProfit) &#123; maxProfit = currentProfit; &#125; &#125; return maxProfit;&#125; my code dp1中的dp[i] 表示从第一天至第i天，只卖出一次的最大收益。 dp2中的dp[i] 表示从第i天至最后一天，只卖出一次的最大收益。 dp1从前向后，dp2从后向前 12345678910111213141516171819202122232425262728public class Solution &#123; public int maxProfit(int[] prices) &#123; int[] dp1 = new int[prices.length]; int[] dp2 = new int[prices.length]; int minprice = Integer.MAX_VALUE; int maxprofit = 0; for(int i=0; i&lt;prices.length; i++)&#123; if(prices[i] &lt; minprice) minprice = prices[i]; else maxprofit = Math.max(maxprofit, prices[i]-minprice); dp1[i] = maxprofit; &#125; int maxprice = Integer.MIN_VALUE; maxprofit = 0; for(int j=prices.length-1; j&gt;=0; j--)&#123; if(prices[j] &gt; maxprice) maxprice = prices[j]; else maxprofit = Math.max(maxprofit, maxprice-prices[j]); dp2[j] = maxprofit; &#125; maxprofit = 0; for(int i=0; i&lt;prices.length; i++) maxprofit = Math.max(maxprofit, dp1[i]+dp2[i]); return maxprofit; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[122. Best Time to Buy and Sell Stock II]]></title>
    <url>%2Fp%2Ffca87911%2F</url>
    <content type="text"><![CDATA[46.0% https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 方法一： 我的代码实现： 123456789class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0; for(int i = 1; i&lt;prices.size(); i++) res += max(prices[i]-prices[i-1], 0); return res; &#125;&#125;; Second, suppose the first sequence is “a &lt;= b &lt;= c &lt;= d”, the profit is “d - a = (b - a) + (c - b) + (d - c)” without a doubt. And suppose another one is “a &lt;= b &gt;= b’ &lt;= c &lt;= d”, the profit is not difficult to be figured out as “(b - a) + (d - b’)”. So you just target at monotone sequences. 12345678910class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int maxprofit = 0; for(size_t i=1; i&lt;prices.size(); i++)&#123; maxprofit += max(prices[i]-prices[i-1], 0); &#125; return maxprofit; &#125;&#125;; python Basically, if tomorrow’s price is higher than today’s, we buy it today and sell tomorrow. Otherwise, we don’t. Here is the code: 1234567class Solution(object): def maxProfit(self, prices): &quot;&quot;&quot; :type prices: List[int] :rtype: int &quot;&quot;&quot; return sum(max(prices[i+1]-prices[i], 0) for i in range(len(prices)-1)) java Algorithm This solution follows the logic used in Approach 2 itself, but with only a slight variation. In this case, instead of looking for every peak following a valley, we can simply go on crawling over the slope and keep on adding the profit obtained from every consecutive transaction. In the end,we will be using the peaks and valleys effectively, but we need not track the costs corresponding to the peaks and valleys along with the maximum profit, but we can directly keep on adding the difference between the consecutive numbers of the array if the second number is larger than the first one, and at the total sum we obtain will be the maximum profit. This approach will simplify the solution. This can be made clearer by taking this example: [1, 7, 2, 3, 6, 7, 6, 7] The graph corresponding to this array is: If we analyze the graph, we notice that the points of interest are the consecutive valleys and peaks. Complexity Analysis Time complexity : O(n)O(n). Single pass. Space complexity : O(1)O(1). Constant space required. 12345678910111213141516171819public class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices.length==0) return 0; int i=0; int maxprofit = 0; int valley = prices[0]; int peak = prices[0]; while(i&lt;prices.length-1)&#123; while(i&lt;prices.length-1 &amp;&amp; prices[i]&gt;=prices[i+1]) i++; valley = prices[i]; while(i&lt;prices.length-1 &amp;&amp; prices[i]&lt;=prices[i+1]) i++; peak = prices[i]; maxprofit += peak - valley; &#125; return maxprofit; &#125;&#125; https://leetcode.com/articles/best-time-buy-and-sell-stock-ii/ Algorithm This solution follows the logic used in Approach 2 itself, but with only a slight variation. In this case, instead of looking for every peak following a valley, we can simply go on crawling over the slope and keep on adding the profit obtained from every consecutive transaction. In the end,we will be using the peaks and valleys effectively, but we need not track the costs corresponding to the peaks and valleys along with the maximum profit, but we can directly keep on adding the difference between the consecutive numbers of the array if the second number is larger than the first one, and at the total sum we obtain will be the maximum profit. This approach will simplify the solution. This can be made clearer by taking this example: [1, 7, 2, 3, 6, 7, 6, 7] The graph corresponding to this array is: From the above graph, we can observe that the sum A+B+CA+B+C is equal to the difference DD corresponding to the difference between the heights of the consecutive peak and valley. Complexity Analysis Time complexity : O(n)O(n). Single pass. Space complexity: O(1)O(1). Constant space needed. 12345678910public class Solution &#123; public int maxProfit(int[] prices) &#123; int maxprofit = 0; for(int i=1; i&lt;prices.length; i++)&#123; if(prices[i] - prices[i-1] &gt; 0) maxprofit += prices[i] - prices[i-1]; &#125; return maxprofit; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[121. Best Time to Buy and Sell Stock]]></title>
    <url>%2Fp%2F588afc94%2F</url>
    <content type="text"><![CDATA[40.0% https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. 123456Example 1:Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) 123456Example 2:Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. 两种思路： 寻找低谷与峰值之间的差。设置一个变量为低谷，vally，另一个变量为目前找到的最大值，maxsofar，则从头开始遍历，如果当前值小于vally，则此值与vally的差为负，所以vally改为当前值，如果当前值大于vally，则计算当前值与vally的差。一次遍历。 第二种思路，重新设置一个数组，记录邻近两个数字的差，类似于寻找最长的数组。 方法一： 微策略面试题 我的代码实现： Oct 17， 2017 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int minPrice = INT_MAX; int maxPro = 0; for(auto price:prices)&#123; minPrice = min(price, minPrice); maxPro = max(maxPro, price - minPrice); &#125; return maxPro; &#125;&#125;; https://discuss.leetcode.com/topic/5863/sharing-my-simple-and-clear-c-solution Sharing my simple and clear C++ solution 123456789int maxProfit(vector&lt;int&gt; &amp;prices) &#123; int maxPro = 0; int minPrice = INT_MAX; // 此处不能用prices[0]代替，如果用，需要先判断prices.size()与0的关系 for(int i = 0; i &lt; prices.size(); i++)&#123; minPrice = min(minPrice, prices[i]); maxPro = max(maxPro, prices[i] - minPrice); &#125; return maxPro;&#125; minPrice is the minimum price from day 0 to day i. And maxPro is the maximum profit we can get from day 0 to day i. How to get maxPro? Just get the larger one between current maxPro and prices[i] - minPrice. 方法二： https://discuss.leetcode.com/topic/5863/sharing-my-simple-and-clear-c-solution/5 Very nice solution! But it still can be optimized. We only need to calculate either maxProfit or minPrice not both in every loop. Running time can be dropped by 33% percent. 1234567891011121314public int maxProfit(int[] prices) &#123; if(prices == null || prices.length &lt; 2) return 0; int maxProfit = 0, minPrice = prices[0]; for(int i = 1; i &lt; prices.length; i++) &#123; if(prices[i] &gt; prices[i - 1]) &#123; maxProfit = Math.max(maxProfit, prices[i] - minPrice); &#125; else &#123; minPrice = Math.min(minPrice, prices[i]); &#125; &#125; return maxProfit;&#125; cpp https://discuss.leetcode.com/topic/5863/sharing-my-simple-and-clear-c-solution Sharing my simple and clear C++ solution 123456789int maxProfit(vector&lt;int&gt; &amp;prices) &#123; int maxPro = 0; int minPrice = INT_MAX; for(int i = 0; i &lt; prices.size(); i++)&#123; minPrice = min(minPrice, prices[i]); maxPro = max(maxPro, prices[i] - minPrice); &#125; return maxPro;&#125; minPrice is the minimum price from day 0 to day i. And maxPro is the maximum profit we can get from day 0 to day i. How to get maxPro? Just get the larger one between current maxPro and prices[i] - minPrice. https://discuss.leetcode.com/topic/5863/sharing-my-simple-and-clear-c-solution/5 Very nice solution! But it still can be optimized. We only need to calculate either maxProfit or minPrice not both in every loop. Running time can be dropped by 33% percent. 1234567891011121314public int maxProfit(int[] prices) &#123; if(prices == null || prices.length &lt; 2) return 0; int maxProfit = 0, minPrice = prices[0]; for(int i = 1; i &lt; prices.length; i++) &#123; if(prices[i] &gt; prices[i - 1]) &#123; maxProfit = Math.max(maxProfit, prices[i] - minPrice); &#125; else &#123; minPrice = Math.min(minPrice, prices[i]); &#125; &#125; return maxProfit;&#125; https://discuss.leetcode.com/topic/42716/5-line-cpp-solution 5 line CPP solution 12345678int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int maxPro = 0, minPrice = INT_MAX; for(int i = 0; i &lt; prices.size(); i++) &#123; minPrice = min(minPrice, prices[i]); maxPro = max(prices[i] - minPrice, maxPro); &#125; return maxPro;&#125; python https://discuss.leetcode.com/topic/33241/easy-o-n-python-solution Easy O(n) Python solution 1234567def maxProfit(prices): max_profit, min_price = 0, float(&apos;inf&apos;) for price in prices: min_price = min(min_price, price) profit = price - min_price max_profit = max(max_profit, profit) return max_profit java Algorithm Say the given array is: [7, 1, 5, 3, 6, 4] If we plot the numbers of the given array on a graph, we get: The points of interest are the peaks and valleys in the given graph. We need to find the largest peak following the smallest valley. We can maintain two variables - minprice and maxprofit corresponding to the smallest valley and maximum profit (maximum difference between selling price and minprice) obtained so far respectively. Complexity Analysis Time complexity : O(n)O(n). Only a single pass is needed. Space complexity : O(1)O(1). Only two variables are used. 针对每个点，与最小点比差值，如果最小点小于当前值，可以看其差值是否可以做最小值，如果最小点大于当前最小值，当前值可以作为最小值。 关键在于对每一个值遍历。12345678910111213public class Solution &#123; public int maxProfit(int[] prices) &#123; int minprice = Integer.MAX_VALUE; int maxprofit = 0; for(int i=0; i&lt;prices.length; i++)&#123; if(prices[i]&lt;minprice) minprice = prices[i]; else if(prices[i] - minprice &gt; maxprofit) maxprofit = prices[i] - minprice; &#125; return maxprofit; &#125;&#125; my code: 1234567891011121314public class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices.length&lt;=1) return 0; int valley=prices[0]; int maxprofit = 0; for(int i=1; i&lt;prices.length; i++)&#123; if(prices[i-1]&gt;prices[i]) valley = Math.min(valley, prices[i]); else if(prices[i]-valley&gt;maxprofit) maxprofit = prices[i]-valley; &#125; return maxprofit; &#125;&#125; https://discuss.leetcode.com/topic/19853/kadane-s-algorithm-since-no-one-has-mentioned-about-this-so-far-in-case-if-interviewer-twists-the-input The logic to solve this problem is same as “max subarray problem” using Kadane’s Algorithm. Since no body has mentioned this so far, I thought it’s a good thing for everybody to know. All the straight forward solution should work, but if the interviewer twists the question slightly by giving the difference array of prices, Ex: for {1, 7, 4, 11}, if he gives {0, 6, -3, 7}, you might end up being confused. Here, the logic is to calculate the difference (maxCur += prices[i] - prices[i-1]) of the original array, and find a contiguous subarray giving maximum profit. If the difference falls below 0, reset it to zero. maxCur = current maximum value maxSoFar = maximum value found so far 12345678public int maxProfit(int[] prices) &#123; int maxCur = 0, maxSoFar = 0; for(int i = 1; i &lt; prices.length; i++) &#123; maxCur = Math.max(0, maxCur += prices[i] - prices[i-1]); maxSoFar = Math.max(maxCur, maxSoFar); &#125; return maxSoFar;&#125; https://discuss.leetcode.com/topic/19853/kadane-s-algorithm-since-no-one-has-mentioned-about-this-so-far-in-case-if-interviewer-twists-the-input/2 Please refer to this for more details on the algorithm : https://en.wikipedia.org/wiki/Maximum_subarray_problem]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[120. Triangle]]></title>
    <url>%2Fp%2F9545f0d7%2F</url>
    <content type="text"><![CDATA[32.8% https://leetcode.com/problems/triangle/?tab=Description Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. 12345678For example, given the following triangle[ [2], [3,4], [6,5,7], [4,1,8,3]]The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note:Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. C++ top-down and bottom-up solutions 方法一： top down 1234567891011121314// top-down int minimumTotal1(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; res(triangle.size(), triangle[0][0]); for (unsigned int i = 1; i &lt; triangle.size(); i++) for (int j = i; j &gt;= 0; j--) &#123; if (j == 0) res[0] += triangle[i][j]; else if (j == i) res[j] = triangle[i][j] + res[j-1]; else res[j] = triangle[i][j] + min(res[j-1], res[j]); &#125; return *min_element(res.begin(), res.end());&#125; 方法二： bottom up 我的代码实现: Oct 17, 2017 123456789101112class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int n = triangle.size(); if(n==0) return 0; for(int i=n-2; i&gt;=0; i--)&#123; for(int j=0; j&lt;triangle[i].size(); j++) triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]); &#125; return triangle[0][0]; &#125;&#125;; 12345678// bottom-upint minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; res = triangle.back(); for (int i = triangle.size()-2; i &gt;= 0; i--) for (unsigned int j = 0; j &lt;= i; j++) res[j] = triangle[i][j] + min(res[j], res[j+1]); return res[0];&#125; cpp https://discuss.leetcode.com/topic/1669/dp-solution-for-triangle DP Solution for Triangle This problem is quite well-formed in my opinion. The triangle has a tree-like structure, which would lead people to think about traversal algorithms such as DFS. However, if you look closely, you would notice that the adjacent nodes always share a ‘branch’. In other word, there are overlapping subproblems. Also, suppose x and y are ‘children’ of k. Once minimum paths from x and y to the bottom are known, the minimum path starting from k can be decided in O(1), that is optimal substructure. Therefore, dynamic programming would be the best solution to this problem in terms of time complexity. What I like about this problem even more is that the difference between ‘top-down’ and ‘bottom-up’ DP can be ‘literally’ pictured in the input triangle. For ‘top-down’ DP, starting from the node on the very top, we recursively find the minimum path sum of each node. When a path sum is calculated, we store it in an array (memoization); the next time we need to calculate the path sum of the same node, just retrieve it from the array. However, you will need a cache that is at least the same size as the input triangle itself to store the pathsum, which takes O(N^2) space. With some clever thinking, it might be possible to release some of the memory that will never be used after a particular point, but the order of the nodes being processed is not straightforwardly seen in a recursive solution, so deciding which part of the cache to discard can be a hard job. ‘Bottom-up’ DP, on the other hand, is very straightforward: we start from the nodes on the bottom row; the min pathsums for these nodes are the values of the nodes themselves. From there, the min pathsum at the ith node on the kth row would be the lesser of the pathsums of its two children plus the value of itself, i.e.: 1minpath[k][i] = min( minpath[k+1][i], minpath[k+1][i+1]) + triangle[k][i]; Or even better, since the row minpath[k+1] would be useless after minpath[k] is computed, we can simply set minpath as a 1D array, and iteratively update itself: 12For the kth level:minpath[i] = min( minpath[i], minpath[i+1]) + triangle[k][i]; Thus, we have the following solution 12345678910111213int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) &#123; int n = triangle.size(); vector&lt;int&gt; minlen(triangle.back()); for (int layer = n-2; layer &gt;= 0; layer--) // For each layer &#123; for (int i = 0; i &lt;= layer; i++) // Check its every &apos;node&apos; &#123; // Find the lesser of its two children, and sum the current value in the triangle with it. minlen[i] = min(minlen[i], minlen[i+1]) + triangle[layer][i]; &#125; &#125; return minlen[0];&#125; https://discuss.leetcode.com/topic/6671/bottom-up-5-line-c-solution Bottom Up 5 line C++ Solution 1234567891011class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) &#123; vector&lt;int&gt; mini = triangle[triangle.size()-1]; for ( int i = triangle.size() - 2; i&gt;= 0 ; --i ) for ( int j = 0; j &lt; triangle[i].size() ; ++ j ) mini[j] = triangle[i][j] + min(mini[j],mini[j+1]); return mini[0]; &#125;&#125;; https://discuss.leetcode.com/topic/29834/c-top-down-and-bottom-up-solutions C++ top-down and bottom-up solutions 1234567891011121314// top-down int minimumTotal1(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; res(triangle.size(), triangle[0][0]); for (unsigned int i = 1; i &lt; triangle.size(); i++) for (int j = i; j &gt;= 0; j--) &#123; if (j == 0) res[0] += triangle[i][j]; else if (j == i) res[j] = triangle[i][j] + res[j-1]; else res[j] = triangle[i][j] + min(res[j-1], res[j]); &#125; return *min_element(res.begin(), res.end());&#125; 12345678// bottom-upint minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; res = triangle.back(); for (int i = triangle.size()-2; i &gt;= 0; i--) for (unsigned int j = 0; j &lt;= i; j++) res[j] = triangle[i][j] + min(res[j], res[j+1]); return res[0];&#125; https://discuss.leetcode.com/topic/19834/my-c-code-bottom-up-dp-8ms My C++ code (Bottom up DP, 8ms) Just do bottom up DP, it is easier and cleaner than top-down DP. 12345678910class Solution &#123; public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; for(int i= triangle.size()-2; i&gt;=0; --i) for(int j=0; j&lt;triangle[i].size();++j) triangle[i][j] += min(triangle[i+1][j],triangle[i+1][j+1]); return triangle[0][0]; &#125; &#125;; 123456789101112// another version, without modifying the input arrayclass Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; res(triangle[triangle.size()-1]); for(int i= triangle.size()-2; i&gt;=0; --i) for(int j=0; j&lt;triangle[i].size();++j) res[j] = triangle[i][j] + min(res[j],res[j+1]); return res[0]; &#125;&#125;; my code: 12345678910111213141516171819class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; if(triangle.size()==0) return 0; if(triangle.size()==1) return triangle[0][0]; for(int i=1; i&lt;triangle.size(); i++)&#123; for(int j=0; j&lt;triangle[i].size(); j++)&#123; if(j==0) triangle[i][j] += triangle[i-1][j]; else if(j==triangle[i].size()-1) triangle[i][j] += triangle[i-1][j-1]; else triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j]); &#125; &#125; int res = triangle[triangle.size()-1][0]; for(auto num:triangle[triangle.size()-1])&#123; res = min(res, num); &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/19754/python-easy-to-understand-solutions-top-down-bottom-up Python easy to understand solutions (top-down, bottom-up). 123456789101112131415# O(n*n/2) space, top-down def minimumTotal1(self, triangle): if not triangle: return res = [[0 for i in xrange(len(row))] for row in triangle] res[0][0] = triangle[0][0] for i in xrange(1, len(triangle)): for j in xrange(len(triangle[i])): if j == 0: res[i][j] = res[i-1][j] + triangle[i][j] elif j == len(triangle[i])-1: res[i][j] = res[i-1][j-1] + triangle[i][j] else: res[i][j] = min(res[i-1][j-1], res[i-1][j]) + triangle[i][j] return min(res[-1]) 12345678910111213# Modify the original triangle, top-downdef minimumTotal2(self, triangle): if not triangle: return for i in xrange(1, len(triangle)): for j in xrange(len(triangle[i])): if j == 0: triangle[i][j] += triangle[i-1][j] elif j == len(triangle[i])-1: triangle[i][j] += triangle[i-1][j-1] else: triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j]) return min(triangle[-1]) 12345678# Modify the original triangle, bottom-updef minimumTotal3(self, triangle): if not triangle: return for i in xrange(len(triangle)-2, -1, -1): for j in xrange(len(triangle[i])): triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]) return triangle[0][0] 123456789# bottom-up, O(n) spacedef minimumTotal(self, triangle): if not triangle: return res = triangle[-1] for i in xrange(len(triangle)-2, -1, -1): for j in xrange(len(triangle[i])): res[j] = min(res[j], res[j+1]) + triangle[i][j] return res[0] https://discuss.leetcode.com/topic/13970/one-liner-in-python One-liner in Python Solution 12def minimumTotal(self, t): return reduce(lambda a,b:[f+min(d,e)for d,e,f in zip(a,a[1:],b)],t[::-1])[0] Explanation Starting with the bottom row, I move upwards, always combining the current row and the next upper row. At the end, I have combined everything into the top row and simply return its only element. Here’s a longer version with meaningful variable names: 123456def minimumTotal(self, triangle): def combine_rows(lower_row, upper_row): return [upper + min(lower_left, lower_right) for upper, lower_left, lower_right in zip(upper_row, lower_row, lower_row[1:])] return reduce(combine_rows, triangle[::-1])[0] Solution mine: 60ms, 57.14%, June.22th, 2016 1234567891011121314class Solution(object): def minimumTotal(self, triangle): &quot;&quot;&quot; :type triangle: List[List[int]] :rtype: int &quot;&quot;&quot; if not triangle: return 0 for i in xrange(1, len(triangle)): triangle[i][0] += triangle[i-1][0] triangle[i][-1] += triangle[i-1][-1] for j in xrange(1, i): triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j]) return min(triangle[-1]) java https://discuss.leetcode.com/topic/8077/my-8-line-dp-java-code-4-meaningful-lines-with-o-1-space My 8 line DP Java code(4 meaningful lines) with O(1) space 12345678public class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; for(int i = triangle.size() - 2; i &gt;= 0; i--) for(int j = 0; j &lt;= i; j++) triangle.get(i).set(j, triangle.get(i).get(j) + Math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1))); return triangle.get(0).get(0); &#125;&#125; The idea is simple. Go from bottom to top. We start form the row above the bottom row [size()-2]. Each number add the smaller number of two numbers that below it. And finally we get to the top we the smallest sum. https://discuss.leetcode.com/topic/22254/7-lines-neat-java-solution 7 lines neat Java Solution 123456789public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int[] A = new int[triangle.size()+1]; for(int i=triangle.size()-1;i&gt;=0;i--)&#123; for(int j=0;j&lt;triangle.get(i).size();j++)&#123; A[j] = Math.min(A[j],A[j+1])+triangle.get(i).get(j); &#125; &#125; return A[0];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[119. Pascal's Triangle II]]></title>
    <url>%2Fp%2Ffb36f4c4%2F</url>
    <content type="text"><![CDATA[35.5% https://leetcode.com/problems/pascals-triangle-ii/?tab=Description Given an index k, return the kth row of the Pascal’s triangle. 12For example, given k = 3,Return [1,3,3,1]. Note: Could you optimize your algorithm to use only O(k) extra space? 方法一： 我的代码实现： Oct 17, 2017 12345678910class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; res(rowIndex+1, 1); for(int i=2; i&lt;=rowIndex; i++) for(int j=i-1; j&gt;0; j--) res[j] = res[j] + res[j-1]; return res; &#125;&#125;; 1234567891011class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; A(rowIndex+1, 0); A[0] = 1; for(int i=1; i&lt;rowIndex+1; i++) for(int j=i; j&gt;=1; j--) A[j] += A[j-1]; return A; &#125;&#125;; my code: 根据规则，同时从后向前加，就完成了。 12345678910111213class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; res(rowIndex+1, 0); res[0] = 1; for(int i=0; i&lt;rowIndex; i++)&#123; for(int j=i+1; j&gt;0; j--)&#123; res[j] += res[j-1]; &#125; &#125; return res; &#125;&#125;; java 3ms, 23.13%, June.21th, 2016 https://leetcode.com/discuss/40144/my-8-lines-java-solution-use-arraylist 123456789101112public class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); for(int i = 0;i&lt;rowIndex+1;i++) &#123; res.add(1); for(int j=i-1;j&gt;0;j--) &#123; res.set(j, res.get(j-1)+res.get(j)); &#125; &#125; return res; &#125;&#125; cpp 0ms, 21.63%, June.21th, 2016 https://leetcode.com/discuss/8364/here-is-my-brief-o-k-solution 1234567891011class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; A(rowIndex+1, 0); A[0] = 1; for(int i=1; i&lt;rowIndex+1; i++) for(int j=i; j&gt;=1; j--) A[j] += A[j-1]; return A; &#125;&#125;; my code: 根据规则，同时从后向前加，就完成了。 12345678910111213class Solution &#123;public: vector&lt;int&gt; getRow(int rowIndex) &#123; vector&lt;int&gt; res(rowIndex+1, 0); res[0] = 1; for(int i=0; i&lt;rowIndex; i++)&#123; for(int j=i+1; j&gt;0; j--)&#123; res[j] += res[j-1]; &#125; &#125; return res; &#125;&#125;; python Solution 1: 40ms, 94.22%, June.21th, 2016 https://leetcode.com/discuss/38977/very-simple-python-solution 12345678910class Solution(object): def getRow(self, rowIndex): &quot;&quot;&quot; :type rowIndex: int :rtype: List[int] &quot;&quot;&quot; row = [1] for i in range(1, rowIndex+1): row = list(map(lambda x, y: x+y, [0]+row, row +[0])) return row]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[118. Pascal's Triangle]]></title>
    <url>%2Fp%2Fe2b46218%2F</url>
    <content type="text"><![CDATA[37.2% https://leetcode.com/problems/pascals-triangle/ Given numRows, generate the first numRows of Pascal’s triangle. 12345678910For example, given numRows = 5,Return[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 方法一： 我的代码实现： October 17， 2017 1234567891011121314class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; if(numRows==0) return vector&lt;vector&lt;int&gt;&gt;(); vector&lt;vector&lt;int&gt;&gt; res(numRows, vector&lt;int&gt;(1, 1)); for(int i=2; i&lt;=numRows; i++)&#123; res[i-1].resize(i); res[i-1][0] = res[i-1][i-1] = 1; for(int j=0; j&lt;i-2; j++) res[i-1][j+1] = res[i-2][j] + res[i-2][j+1]; &#125; return res; &#125;&#125;; resize这个函数好用，同时想明白逻辑r[i][j] = r[i-1][j-1] + r[i-1][j]，就可以实现了。 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; r(numRows); for(int i = 0; i&lt;numRows; i++)&#123; r[i].resize(i+1); r[i][0] = r[i][i] = 1; for(int j=1; j&lt;i; j++) r[i][j] = r[i-1][j-1] + r[i-1][j]; &#125; return r; &#125;&#125;; 2ms, 3.04%, June.21th, 2016 https://leetcode.com/discuss/20606/my-concise-solution-in-java 12345678910111213141516public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; allrows = new ArrayList&lt;List&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; row = new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;numRows;i++) &#123; row.add(0, 1); for(int j=1;j&lt;row.size()-1;j++) row.set(j, row.get(j)+row.get(j+1)); allrows.add(new ArrayList&lt;Integer&gt;(row)); &#125; return allrows; &#125;&#125; 0ms, 26.23%, June.21th, 2016 https://leetcode.com/discuss/13921/maybe-shortest-c-solution resize这个函数好用，同时想明白逻辑r[i][j] = r[i-1][j-1] + r[i-1][j]，就可以实现了。 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; r(numRows); for(int i = 0; i&lt;numRows; i++)&#123; r[i].resize(i+1); r[i][0] = r[i][i] = 1; for(int j=1; j&lt;i; j++) r[i][j] = r[i-1][j-1] + r[i-1][j]; &#125; return r; &#125;&#125;; 68ms, 9.44%, June.21th, 2016 https://leetcode.com/discuss/54525/python-4-lines-short-solution-using-map 123456789101112class Solution(object): def generate(self, numRows): &quot;&quot;&quot; :type numRows: int :rtype: List[List[int]] &quot;&quot;&quot; if numRows == 0: return [] res = [[1]] for i in range(1, numRows): res += [map(lambda x, y:x+y, res[-1] + [0], [0] + res[-1])] return res]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[117. Populating Next Right Pointers in Each Node II]]></title>
    <url>%2Fp%2Fb4ed2826%2F</url>
    <content type="text"><![CDATA[38.6% https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/#/description Follow up for problem “Populating Next Right Pointers in Each Node”. What if the given tree could be any binary tree? Would your previous solution still work? Note: You may only use constant extra space. 12345678910111213For example,Given the following binary tree, 1 / \ 2 3 / \ \ 4 5 7After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ \ 4-&gt; 5 -&gt; 7 -&gt; NULL 方法一： Simple 40ms c++ o(n) ,o(1) solution with only one while loop Thanks for liji94188 for adding the explanation: It’s a BFS traversal. now pointer is the current level traveler and head is the left most element at next level and the tail is the right most element at next level till now. We move now pointer at current level and populate the the next-link at its children level. (Here the gist is we can move now to its next because this relationship was already populated in the previous round). 三个指针，now指向当前位置，针对now的下一层进行做运算，其中，head指针指向now下一位的首位，tail指针从head开始移动，在移动中完成了链接操作，最终移动至now下一层的尾部。然后将now指向head，head和tail置NULL。 1234567891011121314151617181920void connect(TreeLinkNode *root) &#123; TreeLinkNode *now, *tail, *head; now = root; head = tail = NULL; while(now) &#123; if (now-&gt;left) if (tail) tail = tail-&gt;next =now-&gt;left; else head = tail = now-&gt;left; if (now-&gt;right) if (tail) tail = tail-&gt;next =now-&gt;right; else head = tail = now-&gt;right; if(!(now = now-&gt;next)) &#123; now = head; head = tail=NULL; &#125; &#125;&#125; 我自己的实现，跟上面代码是一样的，分开写，更容易理解。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(root==NULL) return; TreeLinkNode* now=root, *head=NULL, *tail=NULL; while(now)&#123; if(now-&gt;left)&#123; if(tail)&#123; tail-&gt;next = now-&gt;left; tail = tail-&gt;next; &#125;else&#123; tail = now-&gt;left; head = tail; &#125; &#125; if(now-&gt;right)&#123; if(tail)&#123; tail-&gt;next = now-&gt;right; tail = tail-&gt;next; &#125;else&#123; tail = now-&gt;right; head = tail; &#125; &#125; now = now-&gt;next; if(!now)&#123; now = head; head = NULL; tail = NULL; &#125; &#125; &#125;&#125;; 我的代码实现: 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return; TreeLinkNode* now = root, *head = NULL, *tail=NULL; while(now)&#123; if(now-&gt;left)&#123; if(!tail)&#123; head = now-&gt;left; tail = head; &#125;else&#123; tail-&gt;next = now-&gt;left; tail = tail-&gt;next; &#125; &#125; if(now-&gt;right)&#123; if(!tail)&#123; head = now-&gt;right; tail = head; &#125;else&#123; tail-&gt;next = now-&gt;right; tail = tail-&gt;next; &#125; &#125; now = now-&gt;next; if(!now)&#123; now = head; head = NULL; tail = NULL; &#125; &#125; &#125;&#125;; 方法二： 使用层序遍历，queue 123456789101112131415161718192021222324252627282930313233/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return; queue&lt;TreeLinkNode*&gt; que; if(root-&gt;left) que.push(root-&gt;left); if(root-&gt;right) que.push(root-&gt;right); while(que.size()&gt;0)&#123; int n = que.size(); TreeLinkNode* lastNode = que.front(); que.pop(); if(lastNode-&gt;left) que.push(lastNode-&gt;left); if(lastNode-&gt;right) que.push(lastNode-&gt;right); for(int i=1; i&lt;n; i++)&#123; TreeLinkNode* cur = que.front(); lastNode-&gt;next = cur; que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); lastNode = cur; &#125; &#125; return; &#125;&#125;; 我的代码实现: 12345678910111213141516171819202122232425262728293031323334/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return; // 用队列还是栈，要仔细思考，这里使用队列 queue&lt;TreeLinkNode*&gt; que; que.push(root); while(que.size())&#123; int n = que.size(); TreeLinkNode* pre = que.front(); que.pop(); if(pre-&gt;left) que.push(pre-&gt;left); if(pre-&gt;right) que.push(pre-&gt;right); for(int i=1; i&lt;n; i++)&#123; TreeLinkNode* cur = que.front(); que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); pre-&gt;next = cur; pre = cur; &#125; &#125; return; &#125;&#125;; https://discuss.leetcode.com/topic/18119/simple-40ms-c-o-n-o-1-solution-with-only-one-while-loop Simple 40ms c++ o(n) ,o(1) solution with only one while loop Thanks for liji94188 for adding the explanation: It’s a BFS traversal. now pointer is the current level traveler and head is the left most element at next level and the tail is the right most element at next level till now. We move now pointer at current level and populate the the next-link at its children level. (Here the gist is we can move now to its next because this relationship was already populated in the previous round). 三个指针，now指向当前位置，针对now的下一层进行做运算，其中，head指针指向now下一位的首位，tail指针从head开始移动，在移动中完成了链接操作，最终移动至now下一层的尾部。然后将now指向head，head和tail置NULL。 1234567891011121314151617181920void connect(TreeLinkNode *root) &#123; TreeLinkNode *now, *tail, *head; now = root; head = tail = NULL; while(now) &#123; if (now-&gt;left) if (tail) tail = tail-&gt;next =now-&gt;left; else head = tail = now-&gt;left; if (now-&gt;right) if (tail) tail = tail-&gt;next =now-&gt;right; else head = tail = now-&gt;right; if(!(now = now-&gt;next)) &#123; now = head; head = tail=NULL; &#125; &#125;&#125; https://discuss.leetcode.com/topic/9735/just-convert-common-bfs-solution-to-o-1-space-a-simple-python-code Just convert common BFS solution to O(1) space, a simple python code common BFS 12345678910111213141516class Solution:# @param root, a tree link node# @return nothingdef connect(self, root): if not root: return queue, level = collections.deque([root]), collections.deque() while queue: node = queue.popleft() if node.left: level.append(node.left) if node.right: level.append(node.right) node.next = queue[0] if queue else None if not queue and level: queue, level = level, queue O(1) space 123456789101112131415161718192021class Solution:# @param root, a tree link node# @return nothingdef connect(self, root): queue, level, curr = root, None, None while queue: if queue.left: if not level: level = curr = queue.left else: curr.next = queue.left curr = curr.next if queue.right: if not level: level = curr = queue.right else: curr.next = queue.right curr = curr.next queue = queue.next if not queue and level: queue, level, curr = level, None, None Use a fake head can save a few lines https://discuss.leetcode.com/topic/27792/ac-python-o-1-space-solution-12-lines-and-easy-to-understand AC Python O(1) space solution 12 lines and easy to understand The algorithm is a BFS or level order traversal. We go through the tree level by level. node is the pointer in the parent level, tail is the tail pointer in the child level.The parent level can be view as a singly linked list or queue, which we can traversal easily with a pointer.Connect the tail with every one of the possible nodes in child level, update it only if the connected node is not nil.Do this one level by one level. The whole thing is quite straightforward. Python 12345678910111213141516171819def connect(self, node): tail = dummy = TreeLinkNode(0) while node: tail.next = node.left if tail.next: tail = tail.next tail.next = node.right if tail.next: tail = tail.next node = node.next if not node: tail = dummy node = dummy.next# 61 / 61 test cases passed.# Status: Accepted# Runtime: 100 ms# 95.26% https://discuss.leetcode.com/topic/1106/o-1-space-o-n-complexity-iterative-solution O(1) space O(n) complexity Iterative Solution Just share my iterative solution with O(1) space and O(n) Time complexity 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; //based on level order traversal public void connect(TreeLinkNode root) &#123; TreeLinkNode head = null; //head of the next level TreeLinkNode prev = null; //the leading node on the next level TreeLinkNode cur = root; //current node of current level while (cur != null) &#123; while (cur != null) &#123; //iterate on the current level //left child if (cur.left != null) &#123; if (prev != null) &#123; prev.next = cur.left; &#125; else &#123; head = cur.left; &#125; prev = cur.left; &#125; //right child if (cur.right != null) &#123; if (prev != null) &#123; prev.next = cur.right; &#125; else &#123; head = cur.right; &#125; prev = cur.right; &#125; //move to next node cur = cur.next; &#125; //move to next level cur = head; head = null; prev = null; &#125; &#125;&#125; https://discuss.leetcode.com/topic/8447/simple-solution-using-constant-space Simple solution using constant space The idea is simple: level-order traversal. You can see the following code: 123456789101112131415public class Solution &#123; public void connect(TreeLinkNode root) &#123; while(root != null)&#123; TreeLinkNode tempChild = new TreeLinkNode(0); TreeLinkNode currentChild = tempChild; while(root!=null)&#123; if(root.left != null) &#123; currentChild.next = root.left; currentChild = currentChild.next;&#125; if(root.right != null) &#123; currentChild.next = root.right; currentChild = currentChild.next;&#125; root = root.next; &#125; root = tempChild.next; &#125; &#125;&#125; 1ms, 51.83%, September 25, 2016 https://discuss.leetcode.com/topic/8447/simple-solution-using-constant-space Java solution with constant space 1234567891011121314151617181920public void connect(TreeLinkNode root) &#123; TreeLinkNode dummyHead = new TreeLinkNode(0); TreeLinkNode pre = dummyHead; while (root != null) &#123; if (root.left != null) &#123; pre.next = root.left; pre = pre.next; &#125; if (root.right != null) &#123; pre.next = root.right; pre = pre.next; &#125; root = root.next; if (root == null) &#123; pre = dummyHead; root = dummyHead.next; dummyHead.next = null; &#125; &#125;&#125; https://discuss.leetcode.com/topic/36615/o-1-concise-fast-what-s-so-hard O(1). Concise. Fast. What’s so hard? This is definitely medium, not hard. Took me about 5 minutes, and some medium problems took me a few hours! Since you have to walk the tree in BFS order and you’re given extra references to help you do just that, it’s intuitive, it’s simple and it’s fast. The first level (root) is connected already, so you connect the next level and then you just walk through the linked list you’ve just created and so on. 12345678910111213141516public void connect(TreeLinkNode root) &#123; for (TreeLinkNode head = root; head != null; ) &#123; TreeLinkNode nextHead = new TreeLinkNode(0), nextTail = nextHead; for (TreeLinkNode node = head; node != null; node = node.next) &#123; if (node.left != null) &#123; nextTail.next = node.left; nextTail = node.left; &#125; if (node.right != null) &#123; nextTail.next = node.right; nextTail = node.right; &#125; &#125; head = nextHead.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[116. Populating Next Right Pointers in Each Node]]></title>
    <url>%2Fp%2F6168139a%2F</url>
    <content type="text"><![CDATA[36.9% https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ 1234567891011Given a binary tree struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; &#125;Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.Initially, all next pointers are set to NULL. Note: You may only use constant extra space. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children). 1234567891011121314For example,Given the following perfect binary tree, 1 / \ 2 3 / \ / \ 4 5 6 7After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \ 4-&gt;5-&gt;6-&gt;7 -&gt; NULL 24ms Easy Iterative and Recursive C++ Solutions 方法一： The idea is similar to a level-order traversal and remember to take full advantages of the prefect binary tree assumption in the problem statement. The code (iterative solution) is as follows. 1234567891011121314151617class Solution &#123;public: void connect(TreeLinkNode *root) &#123; TreeLinkNode* pre = root; TreeLinkNode* cur = NULL; while (pre) &#123; cur = pre; while (cur &amp;&amp; cur -&gt; left) &#123; cur -&gt; left -&gt; next = cur -&gt; right; if (cur -&gt; next) cur -&gt; right -&gt; next = cur -&gt; next -&gt; left; cur = cur -&gt; next; &#125; pre = pre -&gt; left; &#125; &#125; &#125;; 我的代码实现： 1234567891011121314151617181920212223242526272829303132/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return; // 排除只有一个root节点的情况，勿忘 TreeLinkNode* curhead = root; TreeLinkNode* nexhead = root-&gt;left; TreeLinkNode *tail = nexhead; while(nexhead)&#123; tail-&gt;next = curhead-&gt;right; tail = tail-&gt;next; while(curhead-&gt;next)&#123; curhead = curhead-&gt;next; tail-&gt;next = curhead-&gt;left; tail = tail-&gt;next; tail-&gt;next = curhead-&gt;right; tail = tail-&gt;next; &#125; curhead = nexhead; nexhead = nexhead-&gt;left; tail = nexhead; &#125; return; &#125;&#125;; 方法二： This problem can also be solved recursively. 12345678910111213class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (!root) return; if (root -&gt; left) &#123; root -&gt; left -&gt; next = root -&gt; right; if (root -&gt; next) root -&gt; right -&gt; next = root -&gt; next -&gt; left; &#125; connect(root -&gt; left); connect(root -&gt; right); &#125;&#125;; 方法三： 层序遍历的方法 1234567891011121314151617181920212223242526272829303132/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(!root || !root-&gt;left &amp;&amp; !root-&gt;right) return; queue&lt;TreeLinkNode*&gt; que; que.push(root); while(que.size()&gt;0)&#123; int n = que.size(); TreeLinkNode* lastNode = que.front(); que.pop(); if(lastNode-&gt;left) que.push(lastNode-&gt;left); if(lastNode-&gt;right) que.push(lastNode-&gt;right); for(int i=1; i&lt;n; i++)&#123; TreeLinkNode* cur = que.front(); que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); lastNode-&gt;next = cur; lastNode = cur; &#125; &#125; return; &#125;&#125;; https://discuss.leetcode.com/topic/1214/hint-for-o-1-space Hint for O(1) space If you don’t want a solution for O(1) space but just a hint, here it is: you need to make use of the next links that you’re creating. https://discuss.leetcode.com/topic/671/you-may-only-use-constant-extra-space-so-does-it-mean-we-cannot-use-recursion “You may only use constant extra space.” - So does it mean we cannot use recursion? Does anyone have an iteration method with constant space solution? https://discuss.leetcode.com/topic/671/you-may-only-use-constant-extra-space-so-does-it-mean-we-cannot-use-recursion/2 Here is solution from old discuss by skaugust. Thanks to skaugust! I’m confused why people are trying to use recursive solutions here. The problem states that you can only use constant space. To get to the leaf nodes, a recursive solution needs to be log2(n) calls deep, and each call has a call stack, which takes up memory. This means that a recursive solution isn’t constant memory, but O(log(n)) memory. To solve this, you just replace the recursive call with a while loop wrapping all of your logic. 1234567891011121314151617181920212223/* Go through parent level by its next pointer to generate children level next pointer */public class Solution &#123; public void connect(TreeLinkNode root) &#123; TreeLinkNode leftWall = root; while (leftWall != null) &#123; TreeLinkNode across = leftWall; while (across != null) &#123; if (across.left != null) &#123; across.left.next = across.right; &#125; if (across.right != null &amp;&amp; across.next != null) &#123; across.right.next = across.next.left; &#125; across = across.next; &#125; leftWall = leftWall.left; &#125; &#125;&#125; 19ms, 80.75%, September 25, 2016 https://discuss.leetcode.com/topic/2202/a-simple-accepted-solution A simple accepted solution 如果pre-&gt;left 为空怎么办？题目假设的是所有都有左右子树 12345678910111213141516171819202122232425/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(root==NULL) return; TreeLinkNode* pre = root; TreeLinkNode* cur = NULL; while(pre-&gt;left)&#123; cur = pre; while(cur)&#123; cur-&gt;left-&gt;next = cur-&gt;right; if(cur-&gt;next) cur-&gt;right-&gt;next = cur-&gt;next-&gt;left; cur = cur-&gt;next; &#125; pre = pre-&gt;left; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/9579/my-simple-non-iterative-c-code-with-o-1-memory My simple non-iterative C++ code with O(1) memory 12345678910111213141516void connect(TreeLinkNode *root) &#123; if(!root) return; while(root -&gt; left) &#123; TreeLinkNode *p = root; while(p) &#123; p -&gt; left -&gt; next = p -&gt; right; if(p -&gt; next) p -&gt; right -&gt; next = p -&gt; next -&gt; left; p = p -&gt; next; &#125; root = root -&gt; left; &#125;&#125; https://discuss.leetcode.com/topic/16547/7-lines-iterative-real-o-1-space 7 lines, iterative, real O(1) space Simply do it level by level, using the next-pointers of the current level to go through the current level and set the next-pointers of the next level. I say “real” O(1) space because of the many recursive solutions ignoring that recursion management needs space. 12345678def connect(self, root): while root and root.left: next = root.left while root: root.left.next = root.right root.right.next = root.next and root.next.left root = root.next root = next https://discuss.leetcode.com/topic/18432/24ms-easy-iterative-and-recursive-c-solutions 24ms Easy Iterative and Recursive C++ Solutions The idea is similar to a level-order traversal and remember to take full advantages of the prefect binary tree assumption in the problem statement. The code (iterative solution) is as follows. 1234567891011121314151617class Solution &#123;public: void connect(TreeLinkNode *root) &#123; TreeLinkNode* pre = root; TreeLinkNode* cur = NULL; while (pre) &#123; cur = pre; while (cur &amp;&amp; cur -&gt; left) &#123; cur -&gt; left -&gt; next = cur -&gt; right; if (cur -&gt; next) cur -&gt; right -&gt; next = cur -&gt; next -&gt; left; cur = cur -&gt; next; &#125; pre = pre -&gt; left; &#125; &#125; &#125;; This problem can also be solved recursively. 12345678910111213class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (!root) return; if (root -&gt; left) &#123; root -&gt; left -&gt; next = root -&gt; right; if (root -&gt; next) root -&gt; right -&gt; next = root -&gt; next -&gt; left; &#125; connect(root -&gt; left); connect(root -&gt; right); &#125;&#125;; 1ms, 29.64%, September 25, 2016 https://discuss.leetcode.com/topic/6221/java-solution-with-o-1-memory-o-n-time Java solution with O(1) memory+ O(n) time 123456789101112131415public class Solution &#123; public void connect(TreeLinkNode root) &#123; TreeLinkNode level_start=root; while(level_start!=null)&#123; TreeLinkNode cur=level_start; while(cur!=null)&#123; if(cur.left!=null) cur.left.next=cur.right; if(cur.right!=null &amp;&amp; cur.next!=null) cur.right.next=cur.next.left; cur=cur.next; &#125; level_start=level_start.left; &#125; &#125;&#125; https://discuss.leetcode.com/topic/12241/my-recursive-solution-java My recursive solution(Java) 12345678910111213public void connect(TreeLinkNode root) &#123; if(root == null) return; if(root.left != null)&#123; root.left.next = root.right; if(root.next != null) root.right.next = root.next.left; &#125; connect(root.left); connect(root.right);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[115. Distinct Subsequences]]></title>
    <url>%2Fp%2F5eae1966%2F</url>
    <content type="text"><![CDATA[30.9% https://leetcode.com/problems/distinct-subsequences/?tab=Description Given a string S and a string T, count the number of distinct subsequences of T in S. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not). 1234Here is an example:S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;Return 3. 方法一： 我的代码实现： Oct 17， 2017 123456789101112131415class Solution &#123;public: int numDistinct(string s, string t) &#123; int m = s.size(), n = t.size(); if(m&lt;n) return 0; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=0; i&lt;=m; i++)&#123; dp[i][0] = 1; &#125; for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) dp[i][j] = dp[i-1][j] + (s[i-1]==t[j-1]?dp[i-1][j-1]:0); return dp[m][n]; &#125;&#125;; 13ms, 55.07%, September 25, 2016 https://discuss.leetcode.com/topic/760/any-better-solution-that-takes-less-than-o-n-2-space-while-in-o-n-2-time Any better solution that takes less than O(n^2) space while in O(n^2) time? My solution is using O(n^2) space and running in O(n^2) time. I wonder is there a better way to do that which consumes less memory? I guess run time could not be improved though. Any thought/input would be highly appreciated, thanks! 123456789101112131415161718192021222324252627/** * Solution (DP): * We keep a m*n matrix and scanning through string S, while * m = T.length() + 1 and n = S.length() + 1 * and each cell in matrix Path[i][j] means the number of distinct subsequences of * T.substr(1...i) in S(1...j) * * Path[i][j] = Path[i][j-1] (discard S[j]) * + Path[i-1][j-1] (S[j] == T[i] and we are going to use S[j]) * or 0 (S[j] != T[i] so we could not use S[j]) * while Path[0][j] = 1 and Path[i][0] = 0. */int numDistinct(string S, string T) &#123; int m = T.length(); int n = S.length(); if (m &gt; n) return 0; // impossible for subsequence vector&lt;vector&lt;int&gt;&gt; path(m+1, vector&lt;int&gt;(n+1, 0)); for (int k = 0; k &lt;= n; k++) path[0][k] = 1; // initialization for (int j = 1; j &lt;= n; j++) &#123; for (int i = 1; i &lt;= m; i++) &#123; path[i][j] = path[i][j-1] + (T[i-1] == S[j-1] ? path[i-1][j-1] : 0); &#125; &#125; return path[m][n];&#125; my code: 搞清楚s t的区别，m n分别对应的关系，不要搞混了。 12345678910111213141516171819class Solution &#123;public: int numDistinct(string s, string t) &#123; if(t.empty()) return 1; if(s.empty()) return 0; int m = t.size(); int n = s.size(); if(m&gt;n) return 0; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=0; i&lt;=n; i++) dp[0][i] = 1; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; dp[i+1][j+1] = dp[i+1][j] + (t[i]==s[j]?dp[i][j] : 0); &#125; &#125; return dp[m][n]; &#125;&#125;; 方法二： 从上一种方法中，发现需要的空间复杂度还是可以降低的。 https://discuss.leetcode.com/topic/19778/7-10-lines-c-solutions-with-detailed-explanations-o-m-n-time-and-o-m-space 7-10 lines C++ Solutions with Detailed Explanations (O(m*n) time and O(m) space) Well, a dynamic programming problem. Let’s first define its state dp[i][j] to be the number of distinct subsequences of t[0..i - 1] in s[0..j - 1]. Then we have the following state equations: General case 1: dp[i][j] = dp[i][j - 1] if t[i - 1] != s[j - 1]; General case 2: dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1] if t[i - 1] == s[j - 1]; Boundary case 1: dp[0][j] = 1 for all j; Boundary case 2: dp[i][0] = 0 for all positive i. Now let’s give brief explanations to the four equations above. If t[i - 1] != s[j - 1], the distinct subsequences will not include s[j - 1] and thus all the number of distinct subsequences will simply be those in s[0..j - 2], which corresponds to dp[i][j - 1]; If t[i - 1] == s[j - 1], the number of distinct subsequences include two parts: those with s[j - 1] and those without; An empty string will have exactly one subsequence in any string :-) Non-empty string will have no subsequences in an empty string. Putting these together, we will have the following simple codes (just like translation :-)): 123456789101112class Solution &#123;public: int numDistinct(string s, string t) &#123; int m = t.length(), n = s.length(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt; (n + 1, 0)); for (int j = 0; j &lt;= n; j++) dp[0][j] = 1; for (int j = 1; j &lt;= n; j++) for (int i = 1; i &lt;= m; i++) dp[i][j] = dp[i][j - 1] + (t[i - 1] == s[j - 1] ? dp[i - 1][j - 1] : 0); return dp[m][n]; &#125;&#125;; Notice that we keep the whole m*n matrix simply for dp[i - 1][j - 1]. So we can simply store that value in a single variable and further optimize the space complexity. The final code is as follows. 1234567891011121314151617class Solution &#123;public: int numDistinct(string s, string t) &#123; int m = t.length(), n = s.length(); vector&lt;int&gt; cur(m + 1, 0); cur[0] = 1; for (int j = 1; j &lt;= n; j++) &#123; int pre = 1; for (int i = 1; i &lt;= m; i++) &#123; int temp = cur[i]; cur[i] = cur[i] + (t[i - 1] == s[j - 1] ? pre : 0); pre = temp; &#125; &#125; return cur[m]; &#125;&#125;; java 16ms, 41.15%, September 25, 2016 https://discuss.leetcode.com/topic/9488/easy-to-understand-dp-in-java Easy to understand DP in Java The idea is the following: we will build an array mem where mem[i+1][j+1] means that S[0..j] contains T[0..i] that many times as distinct subsequences. Therefor the result will be mem[T.length()][S.length()]. we can build this array rows-by-rows: the first row must be filled with 1. That’s because the empty string is a subsequence of any string but only 1 time. So mem[0][j] = 1 for every j. So with this we not only make our lives easier, but we also return correct value if T is an empty string. the first column of every rows except the first must be 0. This is because an empty string cannot contain a non-empty string as a substring – the very first item of the array: mem[0][0] = 1, because an empty string contains the empty string 1 time. So the matrix looks like this: 12345678910test S 0123....jT +----------+ |1111111111|0 |0 |1 |0 |2 |0 |. |0 |. |0 |i |0 | From here we can easily fill the whole grid: for each (x, y), we check if S[x] == T[y] we add the previous item and the previous item in the previous row, otherwise we copy the previous item in the same row. The reason is simple: if the current character in S doesn’t equal to current character T, then we have the same number of distinct subsequences as we had without the new character. if the current character in S equal to the current character T, then the distinct number of subsequences: the number we had before plus the distinct number of subsequences we had with less longer T and less longer S.An example: S: [acdabefbc] and T: [ab] first we check with a: 1234test * * S = [acdabefbc]mem[1] = [0111222222] then we check with ab: 12345test * * ] S = [acdabefbc]mem[1] = [0111222222]mem[2] = [0000022244] And the result is 4, as the distinct subsequences are: 12345test S = [a b ] S = [a b ] S = [ ab ] S = [ a b ] See the code in Java: 1234567891011121314151617181920212223public int numDistinct(String S, String T) &#123; // array creation int[][] mem = new int[T.length()+1][S.length()+1]; // filling the first row: with 1s for(int j=0; j&lt;=S.length(); j++) &#123; mem[0][j] = 1; &#125; // the first column is 0 by default in every other rows but the first, which we need. for(int i=0; i&lt;T.length(); i++) &#123; for(int j=0; j&lt;S.length(); j++) &#123; if(T.charAt(i) == S.charAt(j)) &#123; mem[i+1][j+1] = mem[i][j] + mem[i+1][j]; &#125; else &#123; mem[i+1][j+1] = mem[i+1][j]; &#125; &#125; &#125; return mem[T.length()][S.length()];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[114. Flatten Binary Tree to Linked List]]></title>
    <url>%2Fp%2Fad56aabd%2F</url>
    <content type="text"><![CDATA[34.1% https://leetcode.com/problems/flatten-binary-tree-to-linked-list/ Given a binary tree, flatten it to a linked list in-place. 12345678910111213141516171819202122For example,Given 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 Hints: If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal. 方法一： 题目中要求转换为链表，实际上是Tree，只不过要求左分支都为0，右分支串联。 迭代 对于root， 把root的右节点接上右节点在先序遍历下的前驱节点。然后root右节点指向左节点，左节点设置为空，然后root指向下一个节点。依次迭代。 Share my simple NON-recursive solution, O(1) space complexity! 123456789101112131415161718192021222324class Solution &#123;public: void flatten(TreeNode *root) &#123; TreeNode*now = root; while (now) &#123; if(now-&gt;left) &#123; //Find current node&apos;s prenode that links to current node&apos;s right subtree TreeNode* pre = now-&gt;left; while(pre-&gt;right) &#123; pre = pre-&gt;right; &#125; pre-&gt;right = now-&gt;right; //Use current node&apos;s left subtree to replace its right subtree(original right //subtree is already linked by current node&apos;s prenode now-&gt;right = now-&gt;left; now-&gt;left = NULL; &#125; now = now-&gt;right; &#125; &#125;&#125;; 我的代码实现 12345678910111213141516171819class Solution &#123;public: void flatten(TreeNode* root) &#123; if(root==NULL) return; while(root)&#123; if(root-&gt;left)&#123; TreeNode* prev = root-&gt;left; while(prev-&gt;right!=NULL) prev = prev-&gt;right; prev-&gt;right = root-&gt;right; root-&gt;right = root-&gt;left; root-&gt;left = NULL; root = root-&gt;right; &#125;else&#123; root = root-&gt;right; &#125; &#125; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void flatten(TreeNode* root) &#123; if(!root || !root-&gt;left&amp;&amp;!root-&gt;right) return; TreeNode* curnode = root; while(curnode)&#123; if(curnode-&gt;left)&#123; TreeNode* pre = curnode-&gt;left; while(pre-&gt;right) pre = pre-&gt;right; pre-&gt;right = curnode-&gt;right; curnode-&gt;right = curnode-&gt;left; curnode-&gt;left = NULL; curnode = curnode-&gt;right; &#125;else&#123; curnode = curnode-&gt;right; &#125; &#125; return; &#125;&#125;; 我的代码实现： 优化后的代码，相对于上面，优化了if else语句，如果有cur-&gt;left,进行一定的处理 无论有没有cur-&gt;left，最后都要去cur-&gt;right 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void flatten(TreeNode* root) &#123; if(!root || !root-&gt;left&amp;&amp;!root-&gt;right) return; TreeNode* curnode = root; while(curnode)&#123; if(curnode-&gt;left)&#123; TreeNode* pre = curnode-&gt;left; while(pre-&gt;right) pre = pre-&gt;right; pre-&gt;right = curnode-&gt;right; curnode-&gt;right = curnode-&gt;left; curnode-&gt;left = NULL; &#125; curnode = curnode-&gt;right; &#125; return; &#125;&#125;; https://discuss.leetcode.com/topic/3995/share-my-simple-non-recursive-solution-o-1-space-complexity Share my simple NON-recursive solution, O(1) space complexity! 123456789101112131415161718192021222324class Solution &#123;public: void flatten(TreeNode *root) &#123; TreeNode*now = root; while (now) &#123; if(now-&gt;left) &#123; //Find current node&apos;s prenode that links to current node&apos;s right subtree TreeNode* pre = now-&gt;left; while(pre-&gt;right) &#123; pre = pre-&gt;right; &#125; pre-&gt;right = now-&gt;right; //Use current node&apos;s left subtree to replace its right subtree(original right //subtree is already linked by current node&apos;s prenode now-&gt;right = now-&gt;left; now-&gt;left = NULL; &#125; now = now-&gt;right; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/14481/8ms-non-recursive-no-stack-c-solution 8ms, Non-recursive, No stack, C++ solution 123456789101112131415void flatten(TreeNode *root) &#123; while (root) &#123; if (root-&gt;left &amp;&amp; root-&gt;right) &#123; TreeNode* t = root-&gt;left; while (t-&gt;right) t = t-&gt;right; t-&gt;right = root-&gt;right; &#125; if(root-&gt;left) root-&gt;right = root-&gt;left; root-&gt;left = NULL; root = root-&gt;right; &#125;&#125; https://discuss.leetcode.com/topic/19087/my-recursive-solution-is-easy-and-clean My recursive solution is easy and clean! 1234567891011void flatten(TreeNode* root) &#123; if (!root) return; flatten(root-&gt;left); flatten(root-&gt;right); TreeNode *tmp = root-&gt;right; root-&gt;right = root-&gt;left; root-&gt;left = nullptr; while (root-&gt;right) root = root-&gt;right; root-&gt;right = tmp;&#125; https://discuss.leetcode.com/topic/9933/16-lines-iterative-c-solution 16 lines iterative c++ solution 12345678910111213141516void flatten(TreeNode *root) &#123; while(root)&#123; if(root-&gt;left == NULL) root = root-&gt;right; else &#123; if(root-&gt;right)&#123; TreeNode *l = root-&gt;left; while(l-&gt;right) l = l-&gt;right; l-&gt;right = root-&gt;right; &#125; root-&gt;right = root-&gt;left; root-&gt;left = NULL; root = root-&gt;right; &#125; &#125;&#125; Inspired by Morris traversal. https://discuss.leetcode.com/topic/10606/an-inorder-python-solution An inorder python solution 12345678910111213141516171819202122232425262728class Solution:# @param root, a tree node# @return nothing, do it in placeprev = Nonedef flatten(self, root): if not root: return self.prev = root self.flatten(root.left) temp = root.right root.right, root.left = root.left, None self.prev.right = temp self.flatten(temp) * / n / \ left right \ * * \ p The idea is very simple. Suppose n is the current visiting node, and p is the previous node of preorder traversal to n.right. We just need to do the inorder replacement: n.left -&gt; NULL n.right - &gt; n.left p-&gt;right -&gt; n.right https://discuss.leetcode.com/topic/11444/my-short-post-order-traversal-java-solution-for-share My short post order traversal Java solution for share 1234567891011private TreeNode prev = null;public void flatten(TreeNode root) &#123; if (root == null) return; flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root;&#125; https://discuss.leetcode.com/topic/9936/straightforward-java-solution Straightforward Java Solution 12345678910111213141516public void flatten(TreeNode root) &#123; if (root == null) return; TreeNode left = root.left; TreeNode right = root.right; root.left = null; flatten(left); flatten(right); root.right = left; TreeNode cur = root; while (cur.right != null) cur = cur.right; cur.right = right; &#125; This solution is based on recursion. We simply flatten left and right subtree and paste each sublist to the right child of the root. (don’t forget to set left child to null) 3ms, 4.67%, September 25, 2016 https://discuss.leetcode.com/topic/5783/accepted-simple-java-solution-iterative 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public void flatten(TreeNode root) &#123; if(root==null) return; Stack&lt;TreeNode&gt; stk = new Stack&lt;TreeNode&gt;(); stk.push(root); while(!stk.isEmpty())&#123; TreeNode curr = stk.pop(); if(curr.right!=null) stk.push(curr.right); if(curr.left!=null) stk.push(curr.left); if(!stk.isEmpty()) curr.right = stk.peek(); curr.left = null; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[113. Path Sum II]]></title>
    <url>%2Fp%2F37ccb4d%2F</url>
    <content type="text"><![CDATA[32.1% https://leetcode.com/problems/path-sum-ii/?tab=Description Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. 1234567891011121314For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1return[ [5,4,11,2], [5,8,4,5]] 方法一： 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; paths; vector&lt;int&gt; path; dfs(root, path, paths, sum); return paths; &#125; void dfs(TreeNode* root, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; paths, int sum)&#123; if(!root) return; path.push_back(root-&gt;val); if(root-&gt;val==sum &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) paths.push_back(path); dfs(root-&gt;left, path, paths, sum-root-&gt;val); dfs(root-&gt;right, path, paths, sum-root-&gt;val); path.pop_back(); &#125;&#125;; 典型的深度优先搜索（回溯法），典型题目，需要牢记方法。 Well, a typical backtracking problem. The code is as follows. You may walk through it using the example in the problem statement to see how it works. 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; paths; vector&lt;int&gt; path; findPaths(root, sum, path, paths); return paths; &#125; private: void findPaths(TreeNode* node, int sum, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; paths)&#123; if(!node) return; path.push_back(node-&gt;val); if(!(node-&gt;left) &amp;&amp; !(node-&gt;right) &amp;&amp; sum == node-&gt;val) paths.push_back(path); findPaths(node-&gt;left, sum-node-&gt;val, path, paths); findPaths(node-&gt;right, sum-node-&gt;val, path, paths); path.pop_back(); &#125;&#125;; 12ms, September 21, 2016 https://discuss.leetcode.com/topic/18454/12ms-11-lines-c-solution 12ms 11-lines C++ Solution Well, a typical backtracking problem. The code is as follows. You may walk through it using the example in the problem statement to see how it works. 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; paths; vector&lt;int&gt; path; findPaths(root, sum, path, paths); return paths; &#125; private: void findPaths(TreeNode* node, int sum, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt;&gt;&amp; paths)&#123; if(!node) return; path.push_back(node-&gt;val); if(!(node-&gt;left) &amp;&amp; !(node-&gt;right) &amp;&amp; sum == node-&gt;val) paths.push_back(path); findPaths(node-&gt;left, sum-node-&gt;val, path, paths); findPaths(node-&gt;right, sum-node-&gt;val, path, paths); path.pop_back(); &#125;&#125;; https://discuss.leetcode.com/topic/8919/18-ms-c-recursive-solution 18 ms c++ recursive solution 12345678910111213141516171819202122232425262728vector&lt;vector&lt;int&gt; &gt; pathSum(TreeNode *root, int sum) &#123; vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; cur_path(0); pathSumRec(root, sum, result, cur_path); return result;&#125;// pass the current path as a reference and remember to pop out the last added element// this improves the performance by 5 timesvoid pathSumRec(TreeNode* root, int sum, vector&lt;vector&lt;int&gt; &gt;&amp; result, vector&lt;int&gt;&amp; cur_path) &#123; if (root == NULL) &#123; return; &#125; if (root-&gt;val == sum &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123; cur_path.push_back(root-&gt;val); result.push_back(cur_path); cur_path.pop_back(); return; &#125; int sum_left = sum - root-&gt;val; cur_path.push_back(root-&gt;val); pathSumRec(root-&gt;left, sum_left, result, cur_path); //cur_path.pop_back(); pathSumRec(root-&gt;right, sum_left, result, cur_path); cur_path.pop_back();&#125; 92ms, September 21, 2016 https://discuss.leetcode.com/topic/16607/short-python-solution Short python solution 12345678910111213141516class Solution(object): def pathSum(self, root, sum): &quot;&quot;&quot; :type root: TreeNode :type sum: int :rtype: List[List[int]] &quot;&quot;&quot; if not root: return [] if root.left == None and root.right == None: if sum == root.val: return [[root.val]] else: return [] a = self.pathSum(root.left, sum-root.val) + \ self.pathSum(root.right, sum - root.val) return [[root.val] + i for i in a] https://discuss.leetcode.com/topic/18444/python-solutions-recursively-bfs-queue-dfs-stack Python solutions (Recursively, BFS+queue, DFS+stack) 1234567891011121314151617181920212223def pathSum(self, root, sum): if not root: return [] res = [] self.dfs(root, sum, [], res) return res def dfs(self, root, sum, ls, res): if not root.left and not root.right and sum == root.val: ls.append(root.val) res.append(ls) if root.left: self.dfs(root.left, sum-root.val, ls+[root.val], res) if root.right: self.dfs(root.right, sum-root.val, ls+[root.val], res) def pathSum2(self, root, sum): if not root: return [] if not root.left and not root.right and sum == root.val: return [[root.val]] tmp = self.pathSum(root.left, sum-root.val) + self.pathSum(root.right, sum-root.val) return [[root.val]+i for i in tmp] 123456789101112131415# BFS + queue def pathSum3(self, root, sum): if not root: return [] res = [] queue = [(root, root.val, [root.val])] while queue: curr, val, ls = queue.pop(0) if not curr.left and not curr.right and val == sum: res.append(ls) if curr.left: queue.append((curr.left, val+curr.left.val, ls+[curr.left.val])) if curr.right: queue.append((curr.right, val+curr.right.val, ls+[curr.right.val])) return res 123456789101112131415# DFS + stack I def pathSum4(self, root, sum): if not root: return [] res = [] stack = [(root, sum-root.val, [root.val])] while stack: curr, val, ls = stack.pop() if not curr.left and not curr.right and val == 0: res.append(ls) if curr.right: stack.append((curr.right, val-curr.right.val, ls+[curr.right.val])) if curr.left: stack.append((curr.left, val-curr.left.val, ls+[curr.left.val])) return res 123456789101112131415# DFS + stack II def pathSum5(self, root, s): if not root: return [] res = [] stack = [(root, [root.val])] while stack: curr, ls = stack.pop() if not curr.left and not curr.right and sum(ls) == s: res.append(ls) if curr.right: stack.append((curr.right, ls+[curr.right.val])) if curr.left: stack.append((curr.left, ls+[curr.left.val])) return res https://discuss.leetcode.com/topic/5414/dfs-with-one-linkedlist-accepted-java-solution DFS with one LinkedList , accepted java solution 1234567891011121314151617181920212223public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; currentResult = new LinkedList&lt;Integer&gt;(); pathSum(root, sum, currentResult, result); return result; &#125; public void pathSum(TreeNode root, int sum, List&lt;Integer&gt; currentResult, List&lt;List&lt;Integer&gt;&gt; result)&#123; if(root == null) return; currentResult.add(new Integer(root.val)); if(root.left == null &amp;&amp; root.right == null &amp;&amp; sum == root.val)&#123; result.add(new LinkedList(currentResult)); currentResult.remove(currentResult.size() - 1); return; &#125;else&#123; pathSum(root.left, sum-root.val, currentResult, result); pathSum(root.right, sum-root.val, currentResult, result); &#125; currentResult.remove(currentResult.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[112. Path Sum]]></title>
    <url>%2Fp%2F17e12313%2F</url>
    <content type="text"><![CDATA[33.2% https://leetcode.com/problems/path-sum/description/ Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. 12345678910For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 方法一： 我的代码实现： Oct 17， 2017 12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(!root) return false; if(!root-&gt;left &amp;&amp; !root-&gt;right) return root-&gt;val == sum; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; code 1： 从根节点开始，如果根等于NULL，false，如果左右节点为空，并且根的值等于sum，那么为true，否则进行迭代。 12345678class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(root == NULL) return false; if(root-&gt;val == sum &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right ==NULL) return true; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; code 2： 我自己的代码 123456789class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(root==NULL) return false; if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return root-&gt;val == sum; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; 方法二： 迭代的方法，使用后序遍历的方法 By using postorder traversal In the postorder traversal, the node will be removed from the stack only when the right sub-tree has been visited. so the path will be stored in the stack. we can keep check the SUM, the length from root to leaf node.at leaf node, if SUM == sum, OK, return true. After postorder traversal, return false. I have compared this solution with recursion solutions. In the leetcode OJ, the run time of two solutions is very near. below is my iterator code. 12345678910111213141516171819202122232425262728class Solution &#123;public: bool hasPathSum(TreeNode *root, int sum) &#123; stack&lt;TreeNode *&gt; s; TreeNode *pre = NULL, *cur = root; int SUM = 0; while (cur || !s.empty()) &#123; while (cur) &#123; s.push(cur); SUM += cur-&gt;val; cur = cur-&gt;left; &#125; cur = s.top(); if (cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL &amp;&amp; SUM == sum) &#123; return true; &#125; if (cur-&gt;right &amp;&amp; pre != cur-&gt;right) &#123; cur = cur-&gt;right; &#125; else &#123; pre = cur; s.pop(); SUM -= cur-&gt;val; cur = NULL; &#125; &#125; return false; &#125;&#125;; 注意：本题答案来看，只有没有左右孩子节点的路径才算一条完整路径。 https://discuss.leetcode.com/topic/892/why-is-the-output-of-1-2-1-is-false 1234Why is the output of &quot;&#123;1, 2&#125;, 1&quot; is false? 12 The struct is like above, and the sum of right path is 1. Why the output is false? Additional: Find another problem: the output of “{1}, 1” is true…… why….. the question is “determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum”. So the condition is there is a path from the root to a leaf. For your tree, there is only one leaf (2) cpp https://leetcode.com/discuss/27236/3-lines-of-c-solution 12ms, 22.26%, June.17th, 2016 1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(root == NULL) return false; if(root-&gt;val == sum &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right ==NULL) return true; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; https://discuss.leetcode.com/topic/2455/accepted-by-using-postorder-traversal [Accepted] By using postorder traversal In the postorder traversal, the node will be removed from the stack only when the right sub-tree has been visited. so the path will be stored in the stack. we can keep check the SUM, the length from root to leaf node.at leaf node, if SUM == sum, OK, return true. After postorder traversal, return false. I have compared this solution with recursion solutions. In the leetcode OJ, the run time of two solutions is very near. below is my iterator code. 12345678910111213141516171819202122232425262728class Solution &#123;public: bool hasPathSum(TreeNode *root, int sum) &#123; stack&lt;TreeNode *&gt; s; TreeNode *pre = NULL, *cur = root; int SUM = 0; while (cur || !s.empty()) &#123; while (cur) &#123; s.push(cur); SUM += cur-&gt;val; cur = cur-&gt;left; &#125; cur = s.top(); if (cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL &amp;&amp; SUM == sum) &#123; return true; &#125; if (cur-&gt;right &amp;&amp; pre != cur-&gt;right) &#123; cur = cur-&gt;right; &#125; else &#123; pre = cur; s.pop(); SUM -= cur-&gt;val; cur = NULL; &#125; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/26599/share-my-3-lines-c-solution Share my 3 lines c++ solution 1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(!root) return false; if((root -&gt; val == sum) &amp;&amp; ((!root -&gt; left) &amp;&amp; (!root -&gt; right))) return true; return hasPathSum(root -&gt; left, sum - root -&gt; val) || hasPathSum(root -&gt; right, sum - root -&gt; val); &#125;&#125;; python 84ms, 29.07%, June.17th, 2016 https://leetcode.com/discuss/28873/short-python-recursive-solution-o-n 123456789101112131415161718# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): &quot;&quot;&quot; :type root: TreeNode :type sum: int :rtype: bool &quot;&quot;&quot; if not root: return False if not root.left and not root.right and root.val == sum: return True sum -= root.val return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum) https://discuss.leetcode.com/topic/18433/python-solutions-dfs-recursively-dfs-stack-bfs-queue Python solutions (DFS recursively, DFS+stack, BFS+queue) 123456789101112131415# DFS Recursively def hasPathSum1(self, root, sum): res = [] self.dfs(root, sum, res) return any(res) def dfs(self, root, target, res): if root: if not root.left and not root.right: if root.val == target: res.append(True) if root.left: self.dfs(root.left, target-root.val, res) if root.right: self.dfs(root.right, target-root.val, res) 123456789101112131415# DFS with stackdef hasPathSum2(self, root, sum): if not root: return False stack = [(root, root.val)] while stack: curr, val = stack.pop() if not curr.left and not curr.right: if val == sum: return True if curr.right: stack.append((curr.right, val+curr.right.val)) if curr.left: stack.append((curr.left, val+curr.left.val)) return False 123456789101112131415# BFS with queuedef hasPathSum(self, root, sum): if not root: return False queue = [(root, sum-root.val)] while queue: curr, val = queue.pop(0) if not curr.left and not curr.right: if val == 0: return True if curr.left: queue.append((curr.left, val-curr.left.val)) if curr.right: queue.append((curr.right, val-curr.right.val)) return False java The basic idea is to subtract the value of current node from sum until it reaches a leaf node and the subtraction equals 0, then we know that we got a hit. Otherwise the subtraction at the end could not be 0. 1ms, 9.51%, June.17th, 2016 https://leetcode.com/discuss/10456/accepted-my-recursive-solution-in-java 12345678910111213141516/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null) return false; if(root.left == null &amp;&amp; root.right == null &amp;&amp; sum - root.val == 0) return true; return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[111. Minimum Depth of Binary Tree]]></title>
    <url>%2Fp%2Fb1d96f1f%2F</url>
    <content type="text"><![CDATA[32.5% https://leetcode.com/problems/minimum-depth-of-binary-tree/ Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 方法一： 利用求树的深度的方法之一，使用一个队列的方法。 bfs，广度优先搜索 1234567891011121314151617181920212223class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(root==NULL) return 0; int res = 0; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty())&#123; res++; int n = que.size(); for(int i=0; i&lt;n; i++)&#123; TreeNode* cur = que.front(); que.pop(); if(cur-&gt;left==NULL &amp;&amp; cur-&gt;right==NULL) return res; if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); &#125; &#125; &#125;&#125;; 方法二： 同样是树的深度，深度优先遍历 123456789class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; if(!root-&gt;left) return 1 + minDepth(root-&gt;right); if(!root-&gt;right) return 1 + minDepth(root-&gt;left); return 1+min(minDepth(root-&gt;left),minDepth(root-&gt;right)); &#125;&#125;; 我的代码实现： 12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; if(!root-&gt;left) return 1+minDepth(root-&gt;right); if(!root-&gt;right) return 1+minDepth(root-&gt;left); return min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + 1; &#125;&#125;; 方法三： 利用一个helper函数，递归调用 123456789101112131415161718192021class Solution &#123;private: int depth;public: int minDepth(TreeNode* root) &#123; if(root==NULL) return 0; depth = 1; return helper(root, depth); &#125; int helper(TreeNode* root, int depth)&#123; if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return depth; else if(root-&gt;right!=NULL &amp;&amp; root-&gt;left!=NULL) return min(helper(root-&gt;left, depth+1), helper(root-&gt;right, depth+1)); else if(root-&gt;right!=NULL) return helper(root-&gt;right, depth+1); else return helper(root-&gt;left, depth+1); &#125;&#125;; cpp9ms, 41.83%, September 25, 2016 https://discuss.leetcode.com/topic/6767/my-concise-c-solution 123456789class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; if(!root-&gt;left) return 1 + minDepth(root-&gt;right); if(!root-&gt;right) return 1 + minDepth(root-&gt;left); return 1+min(minDepth(root-&gt;left),minDepth(root-&gt;right)); &#125;&#125;; my code: 123456789101112131415161718192021class Solution &#123;private: int depth;public: int minDepth(TreeNode* root) &#123; if(root==NULL) return 0; depth = 1; return helper(root, depth); &#125; int helper(TreeNode* root, int depth)&#123; if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return depth; else if(root-&gt;right!=NULL &amp;&amp; root-&gt;left!=NULL) return min(helper(root-&gt;left, depth+1), helper(root-&gt;right, depth+1)); else if(root-&gt;right!=NULL) return helper(root-&gt;right, depth+1); else return helper(root-&gt;left, depth+1); &#125;&#125;; 1ms, 15.51%, September 25, 2016 https://discuss.leetcode.com/topic/8723/my-4-line-java-solution 12345678public class Solution &#123; public int minDepth(TreeNode root) &#123; if(root==null) return 0; int left = minDepth(root.left); int right = minDepth(root.right); return(left==0||right==0)?left+right+1:Math.min(left, right)+1; &#125;&#125; 1ms, 15.51%, September 25, 2016 https://discuss.leetcode.com/topic/8723/my-4-line-java-solution 12345678public class Solution &#123; public int minDepth(TreeNode root) &#123; if(root==null) return 0; if(root.left == null) return minDepth(root.right)+1; if(root.right == null) return minDepth(root.left)+1; return Math.min(minDepth(root.left), minDepth(root.right)) + 1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[110. Balanced Binary Tree]]></title>
    <url>%2Fp%2F205e8441%2F</url>
    <content type="text"><![CDATA[36.5% https://leetcode.com/problems/balanced-binary-tree/?tab=Description Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 剑指offer 39 第二题 The bottom up O(N) solution would be better This problem is generally believed to have two solutions: the top down approach and the bottom up way. 方法一： 最简单最直接，根据题目定义来决策。 缺点：复杂度高，效率低。 1.The first method checks whether the tree is balanced strictly according to the definition of balanced binary tree: the difference between the heights of the two sub trees are not bigger than 1, and both the left sub tree and right sub tree are also balanced. With the helper function depth(), we could easily write the code; 12345678910111213141516class solution &#123;public: int depth (TreeNode *root) &#123; if (root == NULL) return 0; return max (depth(root -&gt; left), depth (root -&gt; right)) + 1; &#125; bool isBalanced (TreeNode *root) &#123; if (root == NULL) return true; int left=depth(root-&gt;left); int right=depth(root-&gt;right); return abs(left - right) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;; For the current node root, calling depth() for its left and right children actually has to access all of its children, thus the complexity is O(N). We do this for each node in the tree, so the overall complexity of isBalanced will be O(N^2). This is a top down approach. 方法二： 基于dfs的方法，自底向上的方法，每一步一个判断。 有点：效率高。 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; return depth(root)!=-1; &#125; int depth(TreeNode* root)&#123; if(!root) return 0; int l = depth(root-&gt;left); if(l==-1) return -1; int r = depth(root-&gt;right); if(r==-1) return -1; if(abs(l-r)&gt;1) return -1; return max(l, r)+1; &#125;&#125;; 2.The second method is based on DFS. Instead of calling depth() explicitly for each child node, we return the height of the current node in DFS recursion. When the sub tree of the current node (inclusive) is balanced, the function dfsHeight() returns a non-negative value as the height. Otherwise -1 is returned. According to the leftHeight and rightHeight of the two children, the parent node could check if the sub tree is balanced, and decides its return value. 1234567891011121314151617class solution &#123;public:int dfsHeight (TreeNode *root) &#123; if (root == NULL) return 0; int leftHeight = dfsHeight (root -&gt; left); if (leftHeight == -1) return -1; int rightHeight = dfsHeight (root -&gt; right); if (rightHeight == -1) return -1; if (abs(leftHeight - rightHeight) &gt; 1) return -1; return max (leftHeight, rightHeight) + 1; &#125; bool isBalanced(TreeNode *root) &#123; return dfsHeight (root) != -1; &#125;&#125;; In this bottom up approach, each node in the tree only need to be accessed once. Thus the time complexity is O(N), better than the first solution. 我的代码实现： 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; // 使用一个depth函数，如果符合则返回深度，否则返回-1 return depth(root)!=-1; &#125; int depth(TreeNode* root)&#123; if(!root) return 0; int left = depth(root-&gt;left); if(left==-1) return -1; int right = depth(root-&gt;right); if(right==-1) return -1; if(abs(left-right)&gt;1) return -1; return max(left, right) + 1; &#125;&#125;; 代码的另一种实现： 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; int depth = 0; return helper(root, &amp;depth); &#125; bool helper(TreeNode* root, int* depth)&#123; if(!root)&#123; depth = 0; return true; &#125; int left, right; if(helper(root-&gt;left, &amp;left)) return false; if(helper(root-&gt;right, &amp;right)) return false; if(abs(left-right)&gt;1) return false; * depth = max(left, right) + 1; return true; &#125;&#125;; 理解学习区 https://discuss.leetcode.com/topic/276/two-different-definitions-of-balanced-binary-tree-result-in-two-different-judgments Two different definitions of balanced binary tree result in two different judgments Input: {1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5} Output: false (based on balanced binary definition “no 2 leaf nodes differ in distance from the root by more than 1”) Expected: true (base on balanced binary definition “two subtrees of every node never differ by more than 1” ) From the problem description, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.Below is a representation of the tree input: {1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}: 1234567891011blank ____1____ / \ 2 2 / \ / \ 3 3 3 3 /\ /\ /\ 4 4 4 4 4 4 /\5 5 Let’s start with the root node (1). As you can see, left subtree’s depth is 5, while right subtree’s depth is 4. Therefore, the condition for a height-balanced binary tree holds for the root node. We continue the same comparison recursively for both left and right subtree, and we conclude that this is indeed a balanced binary tree. Additional Note: AVL Tree’s height-balanced definition is exactly the same as above definition, and its height-balancedness is more rigid compared to a Red Black Tree. As quoted from Wikipedia’s definition of AVL tree: In an AVL tree, the heights of the two child subtrees of any node differ by at most one…. For lookup-intensive applications, AVL trees are faster than red-black trees because they are more rigidly balanced. https://discuss.leetcode.com/topic/7798/the-bottom-up-o-n-solution-would-be-better The bottom up O(N) solution would be better This problem is generally believed to have two solutions: the top down approach and the bottom up way. 1.The first method checks whether the tree is balanced strictly according to the definition of balanced binary tree: the difference between the heights of the two sub trees are not bigger than 1, and both the left sub tree and right sub tree are also balanced. With the helper function depth(), we could easily write the code; 12345678910111213141516class solution &#123;public: int depth (TreeNode *root) &#123; if (root == NULL) return 0; return max (depth(root -&gt; left), depth (root -&gt; right)) + 1; &#125; bool isBalanced (TreeNode *root) &#123; if (root == NULL) return true; int left=depth(root-&gt;left); int right=depth(root-&gt;right); return abs(left - right) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;; For the current node root, calling depth() for its left and right children actually has to access all of its children, thus the complexity is O(N). We do this for each node in the tree, so the overall complexity of isBalanced will be O(N^2). This is a top down approach. 2.The second method is based on DFS. Instead of calling depth() explicitly for each child node, we return the height of the current node in DFS recursion. When the sub tree of the current node (inclusive) is balanced, the function dfsHeight() returns a non-negative value as the height. Otherwise -1 is returned. According to the leftHeight and rightHeight of the two children, the parent node could check if the sub treeis balanced, and decides its return value. 1234567891011121314151617class solution &#123;public:int dfsHeight (TreeNode *root) &#123; if (root == NULL) return 0; int leftHeight = dfsHeight (root -&gt; left); if (leftHeight == -1) return -1; int rightHeight = dfsHeight (root -&gt; right); if (rightHeight == -1) return -1; if (abs(leftHeight - rightHeight) &gt; 1) return -1; return max (leftHeight, rightHeight) + 1; &#125; bool isBalanced(TreeNode *root) &#123; return dfsHeight (root) != -1; &#125;&#125;; In this bottom up approach, each node in the tree only need to be accessed once. Thus the time complexity is O(N), better than the first solution. 1ms, 69.69%, September 25, 2016 https://discuss.leetcode.com/topic/11007/java-solution-based-on-height-check-left-and-right-node-in-every-recursion-to-avoid-further-useless-search Java solution based on height, check left and right node in every recursion to avoid further useless search 1234567891011121314151617public class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if(root == null) return true; return height(root) != -1; &#125; public int height(TreeNode node)&#123; if(node==null) return 0; int LH = height(node.left); if(LH == -1) return -1; int RH = height(node.right); if(RH == -1) return -1; if(LH-RH&lt;-1 || LH-RH &gt;1) return -1; return Math.max(LH, RH)+1; &#125;&#125; https://discuss.leetcode.com/topic/3746/accepted-o-n-solution Accepted O(n) solution We determine recursively the height of the root node but when the recursion is coming upwards we return UNBALANCED instead of the actual height if we know that the tree is already known to be unbalanced. We visit each node just once thus it has linear time complexity. 1234567891011121314151617181920private static final int UNBALANCED = -99;public boolean isBalanced(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return getHeight(root) != UNBALANCED;&#125;private int getHeight(TreeNode root) &#123; if (root == null) &#123; return -1; &#125; int l = getHeight(root.left); int r = getHeight(root.right); if (l == UNBALANCED || r == UNBALANCED || Math.abs(l-r) &gt; 1) &#123; return UNBALANCED; &#125; return 1 + Math.max(l,r);&#125; https://discuss.leetcode.com/topic/42953/very-simple-python-solutions-iterative-and-recursive-both-beat-90 VERY SIMPLE Python solutions (iterative and recursive), both beat 90% 1234567891011121314151617class Solution(object): def isBalanced(self, root): def check(root): if root is None: return 0 left = check(root.left) right = check(root.right) if left == -1 or right == -1 or abs(left - right) &gt; 1: return -1 return 1 + max(left, right) return check(root) != -1# 226 / 226 test cases passed.# Status: Accepted# Runtime: 80 ms Iterative, based on postorder traversal: 123456789101112131415161718192021222324class Solution(object): def isBalanced(self, root): stack, node, last, depths = [], root, None, &#123;&#125; while stack or node: if node: stack.append(node) node = node.left else: node = stack[-1] if not node.right or last == node.right: node = stack.pop() left, right = depths.get(node.left, 0), depths.get(node.right, 0) if abs(left - right) &gt; 1: return False depths[node] = 1 + max(left, right) last = node node = None else: node = node.right return True# 226 / 226 test cases passed.# Status: Accepted# Runtime: 84 ms https://discuss.leetcode.com/topic/1278/can-we-have-a-better-solution Can we have a better solution My solution for this problem is as follows: 123456789101112131415public class Solution &#123;public boolean isBalanced(TreeNode root) &#123; if (root == null) return true; if (Math.abs(depth(root.left) - depth(root.right)) &gt;1) return false; return isBalanced(root.left) &amp;&amp; isBalanced(root.right);&#125;private int depth(TreeNode root)&#123; if (root == null) return 0; return Math.max(depth(root.left), depth(root.right)) + 1;&#125;&#125; But it has two recursions, one for depth() and one for isBalanced(). Will there be a performance issue? 109ms, 32.19%, September 25, 2016 https://discuss.leetcode.com/topic/14752/a-simple-python-recursive-solution-172ms 1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isBalanced(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if not root: return True return abs(self.getHeight(root.left)-self.getHeight(root.right))&lt;2 and self.isBalanced(root.left) and self.isBalanced(root.right) def getHeight(self, root): if not root: return 0 return 1+max(self.getHeight(root.left), self.getHeight(root.right))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[109. Convert Sorted List to Binary Search Tree]]></title>
    <url>%2Fp%2F15b352ee%2F</url>
    <content type="text"><![CDATA[33.1% https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/ Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. 方法一: 先找到中间点，将左侧右侧断开。断开这一点值得学习，我们可以原有的数据结构。 我的代码实现： 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; *//** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* sortedListToBST(ListNode* head) &#123; if(!head) return nullptr; // 考虑只有一个元素的情况 if(!head-&gt;next) return new TreeNode(head-&gt;val); ListNode* pre=head, *slow=head, *fast=head; while(fast &amp;&amp; fast-&gt;next)&#123; pre = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; TreeNode* root = new TreeNode(slow-&gt;val); pre-&gt;next = nullptr; root-&gt;left = sortedListToBST(head); root-&gt;right = sortedListToBST(slow-&gt;next); return root; &#125;&#125;; https://discuss.leetcode.com/topic/10979/clean-c-solution-recursion-o-nlogn-with-comment Clean C++ solution. Recursion. O(nlogn). With comment Recursively build tree. find midpoint by fast/slow method, use middle node as root. build left child by first half of the list build right child by second half of the list (head is midpoint-&gt;next) 12345678910111213141516171819202122232425class Solution &#123;public: TreeNode *sortedListToBST(ListNode *head) &#123; if(!head) return NULL; if(!head-&gt;next) return new TreeNode(head-&gt;val); // fast/slow pointer to find the midpoint auto slow = head; auto fast = head; auto pre = head; while(fast &amp;&amp; fast-&gt;next) &#123; pre = slow; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; pre-&gt;next = 0; // break two halves // slow is the midpoint, use as root TreeNode* root = new TreeNode(slow-&gt;val); root-&gt;left = sortedListToBST(head); root-&gt;right = sortedListToBST(slow-&gt;next); return root; &#125;&#125;; 方法二： 这种方法还需要再思考。 https://discuss.leetcode.com/topic/3286/share-my-code-with-o-n-time-and-o-1-space Share my code with O(n) time and O(1) space count is a function to calculate the size of list. Key words: inorder traversal. 12345678910111213141516171819202122232425262728class Solution &#123;public: ListNode *list; int count(ListNode *node)&#123; int size = 0; while (node) &#123; ++size; node = node-&gt;next; &#125; return size; &#125; TreeNode *generate(int n)&#123; if (n == 0) return NULL; TreeNode *node = new TreeNode(0); node-&gt;left = generate(n / 2); node-&gt;val = list-&gt;val; list = list-&gt;next; node-&gt;right = generate(n - n / 2 - 1); return node; &#125; TreeNode *sortedListToBST(ListNode *head) &#123; this-&gt;list = head; return generate(count(head)); &#125;&#125;; https://discuss.leetcode.com/topic/6444/my-accepted-c-solution My Accepted C++ solution 1234567891011121314151617181920212223242526272829class Solution &#123;public: TreeNode *sortedListToBST(ListNode *head) &#123; return sortedListToBST( head, NULL ); &#125; private: TreeNode *sortedListToBST(ListNode *head, ListNode *tail) &#123; if( head == tail ) return NULL; if( head-&gt;next == tail ) // &#123; TreeNode *root = new TreeNode( head-&gt;val ); return root; &#125; ListNode *mid = head, *temp = head; while( temp != tail &amp;&amp; temp-&gt;next != tail ) // 寻找中间节点 &#123; mid = mid-&gt;next; temp = temp-&gt;next-&gt;next; &#125; TreeNode *root = new TreeNode( mid-&gt;val ); root-&gt;left = sortedListToBST( head, mid ); root-&gt;right = sortedListToBST( mid-&gt;next, tail ); return root; &#125;&#125;; https://discuss.leetcode.com/topic/2286/how-about-like-this How about like this? 1234567891011121314151617TreeNode *sortedListToBST(ListNode *head) &#123; if(head == NULL) return NULL; if(head-&gt;next == NULL) return new TreeNode(head-&gt;val); ListNode *step1 = head; ListNode *step2 = head-&gt;next; while(step2-&gt;next != NULL &amp;&amp; step2-&gt;next-&gt;next != NULL)&#123; step1 = step1-&gt;next; step2 = step2-&gt;next-&gt;next; &#125; TreeNode *root = new TreeNode(step1-&gt;next-&gt;val); ListNode *head2 = step1-&gt;next-&gt;next; delete step1-&gt;next; step1-&gt;next = NULL; root-&gt;left = sortedListToBST(head); root-&gt;right = sortedListToBST(head2); return root;&#125; https://discuss.leetcode.com/topic/21414/python-recursive-solution-with-detailed-comments-operate-linked-list-directly Python recursive solution with detailed comments (operate linked-list directly). recursively 12345678910111213141516171819202122def sortedListToBST(self, head): if not head: return if not head.next: return TreeNode(head.val) # here we get the middle point, # even case, like &apos;1234&apos;, slow points to &apos;2&apos;, # &apos;3&apos; is root, &apos;12&apos; belongs to left, &apos;4&apos; is right # odd case, like &apos;12345&apos;, slow points to &apos;2&apos;, &apos;12&apos; # belongs to left, &apos;3&apos; is root, &apos;45&apos; belongs to right slow, fast = head, head.next.next while fast and fast.next: fast = fast.next.next slow = slow.next # tmp points to root tmp = slow.next # cut down the left child slow.next = None root = TreeNode(tmp.val) root.left = self.sortedListToBST(head) root.right = self.sortedListToBST(tmp.next) return root https://discuss.leetcode.com/topic/35997/share-my-java-solution-1ms-very-short-and-concise Share my JAVA solution, 1ms, very short and concise. 123456789101112131415161718public TreeNode sortedListToBST(ListNode head) &#123; if(head==null) return null; return toBST(head,null);&#125;public TreeNode toBST(ListNode head, ListNode tail)&#123; ListNode slow = head; ListNode fast = head; if(head==tail) return null; while(fast!=tail&amp;&amp;fast.next!=tail)&#123; fast = fast.next.next; slow = slow.next; &#125; TreeNode thead = new TreeNode(slow.val); thead.left = toBST(head,slow); thead.right = toBST(slow.next,tail); return thead;&#125; https://discuss.leetcode.com/topic/8141/share-my-o-1-space-and-o-n-time-java-code Share my O(1) space and O(n) time Java code private ListNode node; 12345678910111213141516171819202122232425262728293031323334public TreeNode sortedListToBST(ListNode head) &#123; if(head == null)&#123; return null; &#125; int size = 0; ListNode runner = head; node = head; while(runner != null)&#123; runner = runner.next; size ++; &#125; return inorderHelper(0, size - 1);&#125;public TreeNode inorderHelper(int start, int end)&#123; if(start &gt; end)&#123; return null; &#125; int mid = start + (end - start) / 2; TreeNode left = inorderHelper(start, mid - 1); TreeNode treenode = new TreeNode(node.val); treenode.left = left; node = node.next; TreeNode right = inorderHelper(mid + 1, end); treenode.right = right; return treenode;&#125; https://discuss.leetcode.com/topic/24418/recursive-bst-construction-using-slow-fast-traversal-on-linked-list Recursive BST construction using slow-fast traversal on linked list 12345678910111213141516171819202122public TreeNode sortedListToBST(ListNode head) &#123; if(head == null) return null; ListNode fast = head; ListNode slow = head; ListNode prev =null; while(fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; prev =slow; slow=slow.next; &#125; TreeNode root = new TreeNode(slow.val); if(prev != null) prev.next = null; else head = null; root.left = sortedListToBST(head); root.right = sortedListToBST(slow.next); return root;&#125; Traverse the list to get the middle element and make that the root. left side of the list forms left sub-tree and right side of the middle element forms the right sub-tree.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[108. Convert Sorted Array to Binary Search Tree]]></title>
    <url>%2Fp%2F4e75dfe7%2F</url>
    <content type="text"><![CDATA[41.0% https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 方法一： 20ms, 24.24%, July 14th, 2016 https://discuss.leetcode.com/topic/6472/accepted-c-recursive-solution-within-a-single-method Accepted C++ recursive solution within a single method Recursively call the sortedArrayToBST() method providing new vector for each call to construct left and right children: 123456789101112131415161718class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return NULL; if(nums.size() == 1) return new TreeNode(nums[0]); int middle = nums.size()/2; TreeNode* root = new TreeNode(nums[middle]); vector&lt;int&gt; leftInts(nums.begin(), nums.begin() + middle); vector&lt;int&gt; rightInts(nums.begin()+middle+1, nums.end()); root-&gt;left = sortedArrayToBST(leftInts); root-&gt;right = sortedArrayToBST(rightInts); return root; &#125; &#125;; 方法二 ： https://discuss.leetcode.com/topic/24667/16-ms-c-solution 16 ms C++ solution 1234567891011121314class Solution &#123; TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums, int start, int end)&#123; if(end&lt;=start) return NULL; int midIdx=(end+start)/2; TreeNode* root=new TreeNode(nums[midIdx]); root-&gt;left=sortedArrayToBST(nums, start, midIdx); root-&gt;right=sortedArrayToBST(nums, midIdx+1,end); return root; &#125;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return sortedArrayToBST(nums, 0,nums.size()); &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return helper(nums, 0, nums.size()-1); &#125; TreeNode* helper(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if(left&gt;right) return NULL; int mid = left+(right-left)/2; TreeNode* root = new TreeNode(nums[mid]); root-&gt;left = helper(nums, left, mid-1); root-&gt;right = helper(nums, mid+1, right); return root; &#125;&#125;; 116ms, 24.46%, July 14th, 2016 https://discuss.leetcode.com/topic/10519/an-easy-python-solutio An easy Python solution The idea is to find the root first, then recursively build each left and right subtree 12345678910111213141516class Solution(object): def sortedArrayToBST(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: TreeNode &quot;&quot;&quot; if not nums: return None mid = len(nums) // 2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid+1:]) return root 0ms, 99.14%, July 14th, 2016 https://discuss.leetcode.com/topic/3158/my-accepted-java-solution My Accepted Java Solution Hi everyone, this is my accepted recursive Java solution. I get overflow problems at first because I didn’t use mid - 1 and mid + 1 as the bound. Hope this helps :) 1234567891011121314151617public class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; if(nums.length == 0) return null; TreeNode head = helper(nums, 0, nums.length-1); return head; &#125; public TreeNode helper(int[] nums, int low, int high)&#123; if(low &gt; high) return null; int mid = (low + high) / 2; TreeNode node = new TreeNode(nums[mid]); node.left = helper(nums, low, mid-1); node.right = helper(nums, mid+1, high); return node; &#125;&#125; https://discuss.leetcode.com/topic/14412/java-iterative-solution Java Iterative Solution I came up with the recursion solution first and tried to translate it into an iterative solution. It is very similar to doing a tree inorder traversal, I use three stacks - nodeStack stores the node I am going to process next, and leftIndexStack and rightIndexStack store the range where this node need to read from the nums. 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; int len = nums.length; if ( len == 0 ) &#123; return null; &#125; // 0 as a placeholder TreeNode head = new TreeNode(0); Deque&lt;TreeNode&gt; nodeStack = new LinkedList&lt;TreeNode&gt;() &#123;&#123; push(head); &#125;&#125;; Deque&lt;Integer&gt; leftIndexStack = new LinkedList&lt;Integer&gt;() &#123;&#123; push(0); &#125;&#125;; Deque&lt;Integer&gt; rightIndexStack = new LinkedList&lt;Integer&gt;() &#123;&#123; push(len-1); &#125;&#125;; while ( !nodeStack.isEmpty() ) &#123; TreeNode currNode = nodeStack.pop(); int left = leftIndexStack.pop(); int right = rightIndexStack.pop(); int mid = left + (right-left)/2; // avoid overflow currNode.val = nums[mid]; if ( left &lt;= mid-1 ) &#123; currNode.left = new TreeNode(0); nodeStack.push(currNode.left); leftIndexStack.push(left); rightIndexStack.push(mid-1); &#125; if ( mid+1 &lt;= right ) &#123; currNode.right = new TreeNode(0); nodeStack.push(currNode.right); leftIndexStack.push(mid+1); rightIndexStack.push(right); &#125; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[107. Binary Tree Level Order Traversal II]]></title>
    <url>%2Fp%2F7174bdf5%2F</url>
    <content type="text"><![CDATA[38.6% https://leetcode.com/problems/binary-tree-level-order-traversal-ii/#/description Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). 12345678910111213For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its bottom-up level order traversal as:[ [15,7], [9,20], [3]] 方法一： 本题类似于102题，只是最后结果给翻转一下就可以了。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty())&#123; int n = que.size(); vector&lt;int&gt; tmp; for(int i=0; i&lt;n; i++)&#123; TreeNode* cur = que.front(); que.pop(); tmp.push_back(cur-&gt;val); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); &#125; res.push_back(tmp); &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 方法二： 层序遍历，dfs，然后最后返回结果修改一下顺序就可以了。 6ms, 37.42%, September 25, 2016 https://discuss.leetcode.com/topic/1672/is-there-any-better-idea-than-doing-regular-level-order-traversal-and-reverse-the-result Is there any better idea than doing regular level order traversal and reverse the result? The way I see this problem is that it is EXACTLY the same as “Level-Order Traversal I” except that we need to reverse the final container for output, which is trivial. Is there a better idea that fits this problem specifically? The attached is my current recursive solution. In each function call, we pass in the current node and its level. If this level does not yet exist in the output container, then we should add a new empty level. Then, we add the current node to the end of the current level, and recursively call the function passing the two children of the current node at the next level. This algorithm is really a DFS, but it saves the level information for each node and produces the same result as BFS would. 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; res; void DFS(TreeNode* root, int level) &#123; if (root == NULL) return; if (level == res.size()) // The level does not exist in output &#123; res.push_back(vector&lt;int&gt;()); // Create a new level &#125; res[level].push_back(root-&gt;val); // Add the current value to its level DFS(root-&gt;left, level+1); // Go to the next level DFS(root-&gt;right,level+1); &#125; vector&lt;vector&lt;int&gt; &gt; levelOrderBottom(TreeNode *root) &#123; DFS(root, 0); return vector&lt;vector&lt;int&gt; &gt; (res.rbegin(), res.rend()); &#125;&#125;; https://discuss.leetcode.com/topic/10903/my-neat-solution-in-c My Neat Solution in C++ 123456789101112131415161718192021222324vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt; &gt; retVal; levelOrder(root, retVal, 0); reverse(retVal.begin(), retVal.end()); return retVal;&#125;void levelOrder(TreeNode* root, vector&lt;vector&lt;int&gt; &gt; &amp;v, int currLevel) &#123; if (root == NULL) &#123; return; &#125; if (v.empty() || currLevel &gt; (v.size() - 1)) &#123; v.push_back(vector&lt;int&gt;()); &#125; v[currLevel].push_back(root-&gt;val); levelOrder(root-&gt;left, v, currLevel + 1); levelOrder(root-&gt;right, v, currLevel + 1);&#125; https://discuss.leetcode.com/topic/27413/c-4ms-solution C++ 4ms solution! First version costs 8ms: 123456789101112131415void levelOrder(vector&lt;vector&lt;int&gt;&gt; &amp;ans, TreeNode *node, int level) &#123; if (!node) return; if (level &gt;= ans.size()) ans.push_back(&#123;&#125;); ans[level].push_back(node-&gt;val); levelOrder(ans,node-&gt;left,level+1); levelOrder(ans,node-&gt;right,level+1);&#125;vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ans; levelOrder(ans,root,0); reverse(ans.begin(),ans.end()); return ans;&#125; Second version costs 4ms: 123456789101112131415161718int depth(TreeNode *root) &#123; if (!root) return 0; return max(depth(root-&gt;left),depth(root-&gt;right))+1;&#125;void levelOrder(vector&lt;vector&lt;int&gt;&gt; &amp;ans, TreeNode *node, int level) &#123; if (!node) return; ans[level].push_back(node-&gt;val); levelOrder(ans,node-&gt;left,level-1); levelOrder(ans,node-&gt;right,level-1);&#125;vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; int d = depth(root); vector&lt;vector&lt;int&gt;&gt; ans(d,vector&lt;int&gt; &#123;&#125;); levelOrder(ans,root,d-1); return ans;&#125; https://discuss.leetcode.com/topic/17702/19-line-c-8ms-solution-very-easy 19 line C++ 8ms Solution, very easy 1234567891011121314151617181920class Solution &#123;protected: vector&lt;vector&lt;int&gt;&gt; ans; void dfs(TreeNode *root, int height)&#123; if (root == NULL) return; while (ans.size() &lt;= height) ans.push_back(vector&lt;int&gt;()); ans[height].push_back(root-&gt;val); dfs(root-&gt;left, height + 1); dfs(root-&gt;right, height + 1); &#125;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; dfs(root, 0); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; https://discuss.leetcode.com/topic/21276/python-solutions-dfs-recursively-dfs-stack-bfs-queue Python solutions (dfs recursively, dfs+stack, bfs+queue). dfs recursively 123456789101112def levelOrderBottom1(self, root): res = [] self.dfs(root, 0, res) return resdef dfs(self, root, level, res): if root: if len(res) &lt; level + 1: res.insert(0, []) res[-(level+1)].append(root.val) self.dfs(root.left, level+1, res) self.dfs(root.right, level+1, res) dfs + stack 123456789101112def levelOrderBottom2(self, root): stack = [(root, 0)] res = [] while stack: node, level = stack.pop() if node: if len(res) &lt; level+1: res.insert(0, []) res[-(level+1)].append(node.val) stack.append((node.right, level+1)) stack.append((node.left, level+1)) return res bfs + queue 123456789101112def levelOrderBottom(self, root): queue, res = collections.deque([(root, 0)]), [] while queue: node, level = queue.popleft() if node: if len(res) &lt; level+1: res.insert(0, []) res[-(level+1)].append(node.val) queue.append((node.left, level+1)) queue.append((node.right, level+1)) return resreply quote https://discuss.leetcode.com/topic/7651/my-dfs-and-bfs-java-solution My DFS and BFS java solution DFS solution: 123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList&lt;List&lt;Integer&gt;&gt;(); if(root == null) return wrapList; queue.offer(root); while(!queue.isEmpty())&#123; int levelNum = queue.size(); List&lt;Integer&gt; subList = new LinkedList&lt;Integer&gt;(); for(int i=0; i&lt;levelNum; i++) &#123; if(queue.peek().left != null) queue.offer(queue.peek().left); if(queue.peek().right != null) queue.offer(queue.peek().right); subList.add(queue.poll().val); &#125; wrapList.add(0, subList); &#125; return wrapList; &#125;&#125; BFS solution: 1234567891011121314151617public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList&lt;List&lt;Integer&gt;&gt;(); levelMaker(wrapList, root, 0); return wrapList; &#125; public void levelMaker(List&lt;List&lt;Integer&gt;&gt; list, TreeNode root, int level) &#123; if(root == null) return; if(level &gt;= list.size()) &#123; list.add(0, new LinkedList&lt;Integer&gt;()); &#125; levelMaker(list, root.left, level+1); levelMaker(list, root.right, level+1); list.get(list.size()-level-1).add(root.val); &#125; &#125; 1ms, 96.03%, September 25, 2016 https://discuss.leetcode.com/topic/7489/simple-java-solution-with-linkedlist 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; LinkedList&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;List&lt;Integer&gt;&gt;(); addLevel(list, 0, root); return list; &#125; private void addLevel(LinkedList&lt;List&lt;Integer&gt;&gt; list, int level, TreeNode node) &#123; if (node == null) return; if (list.size()-1 &lt; level) list.addFirst(new LinkedList&lt;Integer&gt;()); list.get(list.size()-1-level).add(node.val); addLevel(list, level+1, node.left); addLevel(list, level+1, node.right); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[106. Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <url>%2Fp%2F6f813868%2F</url>
    <content type="text"><![CDATA[31.2% https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/?tab=Description Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. 方法一： 检查边界条件 类似105题，剑指 offer第6题 1234567891011121314151617181920212223class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; int n = inorder.size(); if(n&lt;=0) return NULL; TreeNode* root = helper(inorder, postorder, 0, n-1, 0, n-1); return root; &#125; TreeNode* helper(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int is, int ie, int ps, int pe)&#123; if(is&gt;ie || ps&gt;pe) return NULL; TreeNode* root = new TreeNode(postorder[pe]); int pos=is; for(;pos&lt;=ie;pos++)&#123; if(inorder[pos]==postorder[pe]) break; &#125; root-&gt;left = helper(inorder, postorder, is, pos-1, ps, pos-is+ps-1); root-&gt;right = helper(inorder, postorder, pos+1, ie, ps+pos-is, pe-1); return root; &#125;&#125;; cpp my code: 借鉴105题，递归思路。 12345678910111213141516171819202122class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return create(inorder, postorder, 0, inorder.size()-1, 0, postorder.size()-1); &#125; TreeNode* create(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder, int is, int ie, int ps, int pe)&#123; if(is&gt;ie || ps&gt;pe) return NULL; TreeNode* root = new TreeNode(postorder[pe]); int pos; for(int i=ie; i&gt;=is; i--)&#123; if(inorder[i]==root-&gt;val)&#123; pos = i; break; &#125; &#125; root-&gt;left = create(inorder, postorder, is, pos-1, ps, ps+pos-is-1); root-&gt;right = create(inorder, postorder, pos+1, ie, ps+pos-is, pe-1); return root; &#125;&#125;; 方法二: 迭代法 待解决 https://discuss.leetcode.com/topic/4746/my-comprehension-of-o-n-solution-from-hongzhi My comprehension of O(n) solution from @hongzhi Below is the O(n) solution from @hongzhi but that discuss is closed now ‘cause @hongzhi says little about his code. https://oj.leetcode.com/discuss/6334/here-is-my-o-n-solution-is-it-neat I’ve modified some of and tried this code and got AC. Just share about some comprehension about his code. I’ve modified vtn(vector) to stn(stack) in that stack is probably what this algs means and needs. What matters most is the meaning of stn. Only nodes whoes left side hasn’t been handled will be pushed into stn. And inorder is organized as (inorder of left) root (inorder of right), And postorder is as (postorder of left) (postorder of right) root. So at the very begin, we only have root in stn and we check if inorder.back() == root-&gt;val and in most cases it’s false(see Note 1). Then we make this node root’s right sub-node and push it into stn. Note 1: this is actually (inorder of right).back() == (postorder of right).back(), so if only there’s no right subtree or the answer will always be false. Note 2: we delete one node from postorder as we push one into stn. Now we have [root, root’s right] as stn and we check inorder.back() == stn.top()-&gt;val again. true means inorder.back() is the root node and needs handled left case. false means inorder.back() is the next right sub-node So when we encounter a true, we will cache stn.top() as p and delete both nodes from inorder and stn. Then we check inorder.size(), if there’s no nodes left, it means p has no left node. Else the next node in inorder could be p’s left node or p’s father which equals to the now stn.top() (remember we popped p from stn above). If the latter happens, it means p has no left node and we need to move on to p’s father(stn.top()). If the former happens, it means p has one left node and it’s postorder.back(), so we put it to p’s left and delete it from the postorder and push the left node into stn ‘cause it should be the next check node as the postorder is organized as above. That’s all of it. The algs just build a binary tree. :) Inform me if there’s anything vague or wrong, I’m open to any suggestions. 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: TreeNode *buildTree(vector&lt;int&gt; &amp;inorder, vector&lt;int&gt; &amp;postorder) &#123; if(inorder.size() == 0)return NULL; TreeNode *p; TreeNode *root; stack&lt;TreeNode *&gt; stn; root = new TreeNode(postorder.back()); stn.push(root); postorder.pop_back(); while(true) &#123; if(inorder.back() == stn.top()-&gt;val) &#123; p = stn.top(); stn.pop(); inorder.pop_back(); if(inorder.size() == 0) break; if(stn.size() &amp;&amp; inorder.back() == stn.top()-&gt;val) continue; p-&gt;left = new TreeNode(postorder.back()); postorder.pop_back(); stn.push(p-&gt;left); &#125; else &#123; p = new TreeNode(postorder.back()); postorder.pop_back(); stn.top()-&gt;right = p; stn.push(p); &#125; &#125; return root; &#125;&#125;; https://discuss.leetcode.com/topic/5846/sharing-my-straightforward-recursive-solution Sharing my straightforward recursive solution TreeNode *buildTree(vector &amp;inorder, vector &amp;postorder) { return create(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);} TreeNode create(vector &amp;inorder, vector &amp;postorder, int is, int ie, int ps, int pe){ if(ps &gt; pe){ return nullptr; } TreeNode node = new TreeNode(postorder[pe]); int pos; for(int i = is; i &lt;= ie; i++){ if(inorder[i] == node-&gt;val){ pos = i; break; } } node-&gt;left = create(inorder, postorder, is, pos - 1, ps, ps + pos - is - 1); node-&gt;right = create(inorder, postorder, pos + 1, ie, pe - ie + pos, pe - 1); return node;}Actually, this problem is pretty similar as the previous one. Here is a like to that solution. https://discuss.leetcode.com/topic/1954/here-is-my-o-n-solution-is-it-neat Here is my O(n) solution. Is it neat? 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: TreeNode *buildTree(vector&lt;int&gt; &amp;inorder, vector&lt;int&gt; &amp;postorder) &#123; if(inorder.size() == 0)return NULL; TreeNode* p; TreeNode* root; vector&lt;int&gt; vint; vector&lt;TreeNode*&gt; vtn; root = new TreeNode(postorder.back()); vtn.push_back(root); postorder.pop_back(); while(true) &#123; if(inorder.back() == vtn.back()-&gt;val) &#123; p = vtn.back(); vtn.pop_back(); inorder.pop_back(); if(inorder.size() == 0) break; if(vtn.size()) if(inorder.back() == vtn.back()-&gt;val)continue; p-&gt;left = new TreeNode(postorder.back()); postorder.pop_back(); vtn.push_back(p-&gt;left); &#125; else &#123; p = new TreeNode(postorder.back()); postorder.pop_back(); vtn.back()-&gt;right = p; vtn.push_back(p); &#125; &#125; return root; &#125;&#125;; https://discuss.leetcode.com/topic/16861/my-c-solution My C++ Solution 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return helper(inorder,0,inorder.size(),postorder,0,postorder.size()); &#125;private: TreeNode* helper(vector&lt;int&gt;&amp; inorder,int i,int j,vector&lt;int&gt;&amp; postorder,int ii,int jj) &#123; // 每次取postorder的最后一个值mid，将其作为树的根节点 // 然后从inroder中找到mid，将其分割成为两部分，左边作为mid的左子树，右边作为mid的右子树 // tree: 8 4 10 3 6 9 11 // Inorder [3 4 6] 8 [9 10 11] // postorder [3 6 4] [9 11 10] 8 if(i &gt;= j || ii &gt;= jj) return NULL; int mid = postorder[jj - 1]; auto f = find(inorder.begin() + i,inorder.begin() + j,mid); int dis = f - inorder.begin() - i; TreeNode* root = new TreeNode(mid); root -&gt; left = helper(inorder,i,i + dis,postorder,ii,ii + dis); root -&gt; right = helper(inorder,i + dis + 1,j,postorder,ii + dis,jj - 1); return root; &#125;&#125;; python 222ms, 30.82%, September 25, 2016 https://discuss.leetcode.com/topic/10516/a-python-recursive-solution A Python recursive solution 123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, inorder, postorder): &quot;&quot;&quot; :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode &quot;&quot;&quot; if not inorder or not postorder: return None root = TreeNode(postorder.pop()) inorderIndex = inorder.index(root.val) root.right = self.buildTree(inorder[inorderIndex+1:], postorder) root.left = self.buildTree(inorder[:inorderIndex], postorder) return root https://discuss.leetcode.com/topic/21286/python-short-solution-recursively Python short solution (recursively). 1234567def buildTree(self, inorder, postorder): if inorder: ind = inorder.index(postorder.pop()) root = TreeNode(inorder[ind]) root.right = self.buildTree(inorder[ind+1:], postorder) root.left = self.buildTree(inorder[:ind], postorder) return root java https://discuss.leetcode.com/topic/3296/my-recursive-java-code-with-o-n-time-and-o-n-space My recursive Java code with O(n) time and O(n) space The the basic idea is to take the last element in postorder array as the root, find the position of the root in the inorder array; then locate the range for left sub-tree and right sub-tree and do recursion. Use a HashMap to record the index of root in the inorder array. 123456789101112131415161718192021public TreeNode buildTreePostIn(int[] inorder, int[] postorder) &#123; if (inorder == null || postorder == null || inorder.length != postorder.length) return null; HashMap&lt;Integer, Integer&gt; hm = new HashMap&lt;Integer,Integer&gt;(); for (int i=0;i&lt;inorder.length;++i) hm.put(inorder[i], i); return buildTreePostIn(inorder, 0, inorder.length-1, postorder, 0, postorder.length-1,hm);&#125;private TreeNode buildTreePostIn(int[] inorder, int is, int ie, int[] postorder, int ps, int pe, HashMap&lt;Integer,Integer&gt; hm)&#123; if (ps&gt;pe || is&gt;ie) return null; TreeNode root = new TreeNode(postorder[pe]); int ri = hm.get(postorder[pe]); TreeNode leftchild = buildTreePostIn(inorder, is, ri-1, postorder, ps, ps+ri-is-1, hm); TreeNode rightchild = buildTreePostIn(inorder,ri+1, ie, postorder, ps+ri-is, pe-1, hm); root.left = leftchild; root.right = rightchild; return root;&#125; https://discuss.leetcode.com/topic/3296/my-recursive-java-code-with-o-n-time-and-o-n-space/2 This is my version: similar idea, but no HashMap needed! (TreeNode end is the boundary of left subtree.) 1234567891011121314151617181920212223242526272829303132int pInorder; // index of inorder arrayint pPostorder; // index of postorder arrayprivate TreeNode buildTree(int[] inorder, int[] postorder, TreeNode end) &#123; if (pPostorder &lt; 0) &#123; return null; &#125; // create root node TreeNode n = new TreeNode(postorder[pPostorder--]); // if right node exist, create right subtree if (inorder[pInorder] != n.val) &#123; n.right = buildTree(inorder, postorder, n); &#125; pInorder--; // if left node exist, create left subtree if ((end == null) || (inorder[pInorder] != end.val)) &#123; n.left = buildTree(inorder, postorder, end); &#125; return n;&#125;public TreeNode buildTree(int[] inorder, int[] postorder) &#123; pInorder = inorder.length - 1; pPostorder = postorder.length - 1; return buildTree(inorder, postorder, null);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[105. Construct Binary Tree from Preorder and Inorder Traversal]]></title>
    <url>%2Fp%2Fbf9e0006%2F</url>
    <content type="text"><![CDATA[31.1% https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?tab=Description Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. 方法一： 根据preorder和inorder的特点，找规律。 剑指offer， 第6题 新建一个节点代码：TreeNode* node = new TreeNode(preorder[ps]); 1234567891011121314151617181920TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; return create(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);&#125;TreeNode* create(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int ps, int pe, int is, int ie)&#123; if(ps &gt; pe)&#123; return nullptr; &#125; TreeNode* node = new TreeNode(preorder[ps]); int pos; for(int i = is; i &lt;= ie; i++)&#123; if(inorder[i] == node-&gt;val)&#123; pos = i; break; &#125; &#125; node-&gt;left = create(preorder, inorder, ps + 1, ps + pos - is, is, pos - 1); node-&gt;right = create(preorder, inorder, pe - ie + pos + 1, pe, pos + 1, ie); return node;&#125; 方法二： https://discuss.leetcode.com/topic/10244/my-o-n-19ms-solution-without-recusion-hope-help-you My O(n)(19ms) solution without recusion. Hope help you! 12345678910111213141516171819202122232425class Solution &#123;public: TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; TreeNode *root=NULL; stack&lt;TreeNode *&gt; MyData; if(preorder.empty()) return root; root = new TreeNode(preorder[0]); MyData.push(root); int index = 0; for(int i=1; i&lt;=preorder.size(); i++) &#123; TreeNode *cur = MyData.top(); if((MyData.top()-&gt;val)!=inorder[index]) &#123; cur-&gt;left = new TreeNode(preorder[i]); MyData.push(cur-&gt;left); &#125; else &#123; while(!MyData.empty() &amp;&amp; ((MyData.top()-&gt;val)==inorder[index])) &#123; cur=MyData.top(); MyData.pop(); index++; &#125; if(index&lt;inorder.size()) &#123; cur-&gt;right = new TreeNode(preorder[i]); MyData.push(cur-&gt;right); &#125; &#125; &#125; return root; &#125;&#125;; https://discuss.leetcode.com/topic/16860/my-neat-c-solution My neat C++ solution 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: /* from Preorder and Inorder Traversal */ TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; return helper(preorder,0,preorder.size(),inorder,0,inorder.size()); &#125; TreeNode* helper(vector&lt;int&gt;&amp; preorder,int i,int j,vector&lt;int&gt;&amp; inorder,int ii,int jj) &#123; // tree 8 4 5 3 7 3 // preorder 8 [4 3 3 7] [5] // inorder [3 3 4 7] 8 [5] // 每次从 preorder 头部取一个值 mid，作为树的根节点 // 检查 mid 在 inorder 中 的位置，则 mid 前面部分将作为 树的左子树，右部分作为树的右子树 if(i &gt;= j || ii &gt;= j) return NULL; int mid = preorder[i]; auto f = find(inorder.begin() + ii,inorder.begin() + jj,mid); int dis = f - inorder.begin() - ii; TreeNode* root = new TreeNode(mid); root -&gt; left = helper(preorder,i + 1,i + 1 + dis,inorder,ii,ii + dis); root -&gt; right = helper(preorder,i + 1 + dis,j,inorder,ii + dis + 1,jj); return root; &#125;&#125;; cpp https://discuss.leetcode.com/topic/795/the-iterative-solution-is-easier-than-you-think The iterative solution is easier than you think! I din’t find iterative solutions discussed in the old Discuss. So, I thought, I will add my solution in here. The idea is as follows: Keep pushing the nodes from the preorder into a stack (and keep making the tree by adding nodes to the left of the previous node) until the top of the stack matches the inorder. At this point, pop the top of the stack until the top does not equal inorder (keep a flag to note that you have made a pop). Repeat 1 and 2 until preorder is empty. The key point is that whenever the flag is set, insert a node to the right and reset the flag. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; if(preorder.size()==0) return NULL; stack&lt;int&gt; s; stack&lt;TreeNode *&gt; st; TreeNode *t,*r,*root; int i,j,f; f=i=j=0; s.push(preorder[i]); root = new TreeNode(preorder[i]); st.push(root); t = root; i++; while(i&lt;preorder.size()) &#123; if(!st.empty() &amp;&amp; st.top()-&gt;val==inorder[j]) &#123; t = st.top(); st.pop(); s.pop(); f = 1; j++; &#125; else &#123; if(f==0) &#123; s.push(preorder[i]); t -&gt; left = new TreeNode(preorder[i]); t = t -&gt; left; st.push(t); i++; &#125; else &#123; f = 0; s.push(preorder[i]); t -&gt; right = new TreeNode(preorder[i]); t = t -&gt; right; st.push(t); i++; &#125; &#125; &#125; return root; &#125;&#125;; 33ms, 64.41%, September 25, 2016 https://discuss.leetcode.com/topic/5845/sharing-my-straightforward-recursive-solution Sharing my straightforward recursive solution 递归，直接了当 1234567891011121314151617181920TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) &#123; return create(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);&#125;TreeNode* create(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int ps, int pe, int is, int ie)&#123; if(ps &gt; pe)&#123; return nullptr; &#125; TreeNode* node = new TreeNode(preorder[ps]); int pos; for(int i = is; i &lt;= ie; i++)&#123; if(inorder[i] == node-&gt;val)&#123; pos = i; break; &#125; &#125; node-&gt;left = create(preorder, inorder, ps + 1, ps + pos - is, is, pos - 1); node-&gt;right = create(preorder, inorder, pe - ie + pos + 1, pe, pos + 1, ie); return node;&#125; The first element in preorder array can divide inorder array into two parts. Then we can divide preorder array into two parts. Make this element a node. And the left sub-tree of this node is the left part, right sub-tree of this node is the right part. This problem can be solved following this logic. python 199ms, 37.16%, September 25, 2016 https://discuss.leetcode.com/topic/21287/python-short-recursive-solution Python short recursive solution. 1234567def buildTree(self, preorder, inorder): if inorder: ind = inorder.index(preorder.pop(0)) root = TreeNode(inorder[ind]) root.left = self.buildTree(preorder, inorder[0:ind]) root.right = self.buildTree(preorder, inorder[ind+1:]) return root https://discuss.leetcode.com/topic/10474/a-python-recursive-solution A Python recursive solution The idea is to find the root first, and then recursively build each left and right subtree Only Solution 3 could pass the OJ, but theoretically they should all work … Solution 1 - clean and easy to understand, but Memory Limit Exceeded … 123456789101112131415161718192021222324# Definition for a binary tree node# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # @param preorder, a list of integers # @param inorder, a list of integers # @return a tree node # 1:59 def buildTree(self, preorder, inorder): if not preorder or not inorder: return None rootValue = preorder[0] root = TreeNode(rootValue) inorderIndex = inorder.index(rootValue) root.left = self.buildTree(preorder[1:inorderIndex+1], inorder[:inorderIndex]) root.right = self.buildTree(preorder[inorderIndex+1:], inorder[inorderIndex+1:]) return root Solution 2 - Same as solution one, but pass index instead of doing list slicing (and thus reduce the memory usage) 1234567891011121314151617181920212223class Solution: # @param preorder, a list of integers # @param inorder, a list of integers # @return a tree node # 1:59 def buildTree(self, preorder, inorder, preorderStart = 0, preorderEnd = None, inorderStart = 0, inorderEnd = None): if preorderEnd is None: preorderEnd = len(preorder) - 1 if inorderEnd is None: inorderEnd = len(inorder) - 1 if preorderStart &gt; len(preorder) - 1 or inorderStart &gt; inorderEnd: return None rootValue = preorder[preorderStart] root = TreeNode(rootValue) inorderIndex = inorder.index(rootValue) root.left = self.buildTree(preorder, inorder, preorderStart+1, inorderIndex, inorderStart, inorderIndex-1) root.right = self.buildTree(preorder, inorder, preorderStart+inorderIndex+1-inorderStart, preorderEnd, inorderIndex+1, inorderEnd) return root Solution 3 - Based on Solution 1, we don’t necessary need to slice the preorder array, when we are done with the left tree, the left half of the preorder array should already be empty 123456789101112131415161718192021222324# Definition for a binary tree node# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # @param preorder, a list of integers # @param inorder, a list of integers # @return a tree node # 1:59 def buildTree(self, preorder, inorder): if not preorder or not inorder: return None rootValue = preorder.pop(0) root = TreeNode(rootValue) inorderIndex = inorder.index(rootValue) root.left = self.buildTree(preorder, inorder[:inorderIndex]) root.right = self.buildTree(preorder, inorder[inorderIndex+1:]) return root java https://discuss.leetcode.com/topic/3695/my-accepted-java-solution My Accepted Java Solution Hi guys, this is my Java solution. I read this post, which is very helpful. The basic idea is here: Say we have 2 arrays, PRE and IN. Preorder traversing implies that PRE[0] is the root node. Then we can find this PRE[0] in IN, say it’s IN[5]. Now we know that IN[5] is root, so we know that IN[0] - IN[4] is on the left side, IN[6] to the end is on the right side. Recursively doing this on subarrays, we can build a tree out of it :) Hope this helps. 12345678910111213141516171819public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return helper(0, 0, inorder.length - 1, preorder, inorder);&#125;public TreeNode helper(int preStart, int inStart, int inEnd, int[] preorder, int[] inorder) &#123; if (preStart &gt; preorder.length - 1 || inStart &gt; inEnd) &#123; return null; &#125; TreeNode root = new TreeNode(preorder[preStart]); int inIndex = 0; // Index of current root in inorder for (int i = inStart; i &lt;= inEnd; i++) &#123; if (inorder[i] == root.val) &#123; inIndex = i; &#125; &#125; root.left = helper(preStart + 1, inStart, inIndex - 1, preorder, inorder); root.right = helper(preStart + inIndex - inStart + 1, inIndex + 1, inEnd, preorder, inorder); return root;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[104. Maximum Depth of Binary Tree]]></title>
    <url>%2Fp%2F22757163%2F</url>
    <content type="text"><![CDATA[51.2% https://leetcode.com/problems/maximum-depth-of-binary-tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 方法一： 深度优先遍历 My code of C++, Depth-first-search and Breadth-first-search Depth-first-search Only one line code. 1234int maxDepth(TreeNode *root)&#123; return root == NULL ? 0 : max(maxDepth(root -&gt; left), maxDepth(root -&gt; right)) + 1;&#125; 我的代码实现： 123456789101112131415/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; return root?max(maxDepth(root-&gt;left), maxDepth(root-&gt;right))+1:0; &#125;&#125;; 方法二： 广度优先搜索 使用一个队列，将root push进取，然后每次对队列的长度进行遍历，res++； Breadth-first-search Calculate the count of the last level. 注意：栈和队列，又都push pop,没有push_back,pop_back 12345678910111213141516171819202122232425int maxDepth(TreeNode *root)&#123; if(root == NULL) return 0; int res = 0; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty()) &#123; ++ res; for(int i = 0, n = q.size(); i &lt; n; ++ i) &#123; TreeNode *p = q.front(); q.pop(); if(p -&gt; left != NULL) q.push(p -&gt; left); if(p -&gt; right != NULL) q.push(p -&gt; right); &#125; &#125; return res;&#125; 我的代码实现： 其实就是层序遍历 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(root==NULL) return 0; queue&lt;TreeNode*&gt; que; que.push(root); int res = 0; while(!que.empty())&#123; res++; int n = que.size(); for(int i=0; i&lt;n; i++)&#123; TreeNode* cur = que.front(); que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); &#125; &#125; return res; &#125;&#125;; 学习一下queue的成员函数，有back，push，pop，没有push_back (constructor) Construct queue (public member function ) empty Test whether container is empty (public member function ) size Return size (public member function ) front Access next element (public member function ) back Access last element (public member function ) push Insert element (public member function ) emplace Construct and insert element (public member function ) pop Remove next element (public member function ) swap Swap contents (public member function ) 学习一下栈的成员函数，有pop push 等，没有push_back pop_back (constructor)Construct stack (public member function )emptyTest whether container is empty (public member function )sizeReturn size (public member function )topAccess next element (public member function )pushInsert element (public member function )emplaceConstruct and insert element (public member function )popRemove top element (public member function )swapSwap contents (public member function ) https://discuss.leetcode.com/topic/10317/my-code-of-c-depth-first-search-and-breadth-first-search My code of C++, Depth-first-search and Breadth-first-search Depth-first-search Only one line code. 1234int maxDepth(TreeNode *root)&#123; return root == NULL ? 0 : max(maxDepth(root -&gt; left), maxDepth(root -&gt; right)) + 1;&#125; Breadth-first-search Calculate the count of the last level. 12345678910111213141516171819202122232425int maxDepth(TreeNode *root)&#123; if(root == NULL) return 0; int res = 0; queue&lt;TreeNode *&gt; q; q.push(root); while(!q.empty()) &#123; ++ res; for(int i = 0, n = q.size(); i &lt; n; ++ i) &#123; TreeNode *p = q.front(); q.pop(); if(p -&gt; left != NULL) q.push(p -&gt; left); if(p -&gt; right != NULL) q.push(p -&gt; right); &#125; &#125; return res;&#125; python https://discuss.leetcode.com/topic/24177/1-line-ruby-and-python 1 line Ruby and Python Just a bit shorter/different than previous solutions. Python: 12def maxDepth(self, root): return 1 + max(map(self.maxDepth, (root.left, root.right))) if root else 0 java https://discuss.leetcode.com/topic/4087/simple-solution-using-java Simple solution using Java if the node does not exist, simply return 0. Otherwise, return the 1+the longer distance of its subtree. 123456public int maxDepth(TreeNode root) &#123; if(root==null)&#123; return 0; &#125; return 1+Math.max(maxDepth(root.left),maxDepth(root.right)); &#125; https://discuss.leetcode.com/topic/27017/clean-java-iterative-solution Clean Java Iterative Solution I do believe if you can think of an iterative solution, it’s always better than using a recursive one. And technical y every recursive solution can be converted into a equivalent iterative one. 123456789101112131415161718192021222324public int maxDepth(TreeNode root) &#123; if (root == null) return 0; Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;(); stack.push(root); int count = 0; while (!stack.isEmpty()) &#123; int size = stack.size(); while (size-- &gt; 0) &#123; TreeNode cur = stack.pop(); if (cur.left != null) stack.addLast(cur.left); if (cur.right != null) stack.addLast(cur.right); &#125; count++; &#125; return count;&#125; https://discuss.leetcode.com/topic/33826/two-java-iterative-solution-dfs-and-bfs Two Java Iterative solution DFS and BFS This is the iterative version of finding the depth. The recursive version is trivial, so expect the interviewer to ask for the iterative version. I used two stacks for the dfs one and a queue for the level-order traversal one. Level order one is faster. DFS 1234567891011121314151617181920212223242526public int maxDepth(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; value = new Stack&lt;&gt;(); stack.push(root); value.push(1); int max = 0; while(!stack.isEmpty()) &#123; TreeNode node = stack.pop(); int temp = value.pop(); max = Math.max(temp, max); if(node.left != null) &#123; stack.push(node.left); value.push(temp+1); &#125; if(node.right != null) &#123; stack.push(node.right); value.push(temp+1); &#125; &#125; return max;&#125;// 7ms BFS 1234567891011121314151617181920212223public int maxDepth(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int count = 0; while(!queue.isEmpty()) &#123; int size = queue.size(); while(size-- &gt; 0) &#123; TreeNode node = queue.poll(); if(node.left != null) &#123; queue.offer(node.left); &#125; if(node.right != null) &#123; queue.offer(node.right); &#125; &#125; count++; &#125; return count;&#125;// 3ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[103. Binary Tree Zigzag Level Order Traversal]]></title>
    <url>%2Fp%2Fa0a3d7c5%2F</url>
    <content type="text"><![CDATA[34.8% https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/ Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). 12345678910111213For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its zigzag level order traversal as:[ [3], [20,9], [15,7]] 方法一： 层序遍历，然后把相应的反转就可以了 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; q; // 首选把root压进去，不要忘了 q.push(root); while(q.size())&#123; int n = q.size(); vector&lt;int&gt; tmp; for(int i=0; i&lt;n; i++)&#123; // queue叫front，stack叫top，不要弄混了 TreeNode* cur = q.front(); q.pop(); tmp.push_back(cur-&gt;val); if(cur-&gt;left) q.push(cur-&gt;left); if(cur-&gt;right) q.push(cur-&gt;right); &#125; // 遍历一圈后，把结果压入 res.push_back(tmp); &#125; for(int i=0; i&lt;res.size(); i++) if(i%2) reverse(res[i].begin(), res[i].end()); return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>stack</tag>
        <tag>tree</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[102. Binary Tree Level Order Traversal]]></title>
    <url>%2Fp%2Fbeb6650a%2F</url>
    <content type="text"><![CDATA[37.7% https://leetcode.com/problems/binary-tree-level-order-traversal/?tab=Description Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). 12345678910111213For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its level order traversal as:[ [3], [9,20], [15,7]] 二叉树层序遍历 对于二叉树的先序、中序、后续遍历，应该掌握的非常牢靠。对于层序遍历，掌握的应该如同先序、中序、后续遍历一样。 方法一： 先序遍历，同时传入树的深度，如果树到达新的深度，则ret里加入一个新的vector. 1234567891011121314151617vector&lt;vector&lt;int&gt;&gt; ret;void buildVector(TreeNode *root, int depth)&#123; if(root == NULL) return; if(ret.size() == depth) ret.push_back(vector&lt;int&gt;()); ret[depth].push_back(root-&gt;val); buildVector(root-&gt;left, depth + 1); buildVector(root-&gt;right, depth + 1);&#125;vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; buildVector(root, 0); return ret;&#125; 方法二： 使用一个函数来辅助 递归调用 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(root==NULL) return res; vector&lt;TreeNode*&gt; cur = &#123;root&#125;; helper(cur, res); return res; &#125; void helper(vector&lt;TreeNode*&gt; cur, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(cur.size()==0) return; vector&lt;int&gt; tmp; vector&lt;TreeNode*&gt; nex; for(auto root:cur)&#123; tmp.push_back(root-&gt;val); if(root-&gt;left !=NULL) nex.push_back(root-&gt;left); if(root-&gt;right!=NULL) nex.push_back(root-&gt;right); &#125; res.push_back(tmp); helper(nex, res); return; &#125;&#125;; 方法三： 使用队列，非递归，中间使用一个marker，NULL表示间隔。 注意队列里是push和pop，没有push_back和pop_back. 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt; &gt; result; if (!root) return result; queue&lt;TreeNode*&gt; q; q.push(root); q.push(NULL); vector&lt;int&gt; cur_vec; while(!q.empty()) &#123; TreeNode* t = q.front(); q.pop(); if (t==NULL) &#123; result.push_back(cur_vec); cur_vec.resize(0); if (q.size() &gt; 0) &#123; q.push(NULL); &#125; &#125; else &#123; cur_vec.push_back(t-&gt;val); if (t-&gt;left) q.push(t-&gt;left); if (t-&gt;right) q.push(t-&gt;right); &#125; &#125; return result; &#125;&#125;; 方法四： 使用队列，针对每一层，一个保存至一个vector中，同时更新queue 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(!root) return res; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty())&#123; int n = que.size(); vector&lt;int&gt; tmp; for(int i=0; i&lt;n; i++)&#123; TreeNode* cur = que.front(); que.pop(); tmp.push_back(cur-&gt;val); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); &#125; res.push_back(tmp); &#125; return res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/4894/one-of-c-solutions-preorder One of C++ solutions (preorder) 先序遍历，同时ret在函数外面 1234567891011121314151617vector&lt;vector&lt;int&gt;&gt; ret;void buildVector(TreeNode *root, int depth)&#123; if(root == NULL) return; if(ret.size() == depth) ret.push_back(vector&lt;int&gt;()); ret[depth].push_back(root-&gt;val); buildVector(root-&gt;left, depth + 1); buildVector(root-&gt;right, depth + 1);&#125;vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; buildVector(root, 0); return ret;&#125; https://discuss.leetcode.com/topic/10469/c-solution-using-only-one-queue-use-a-marker-null C++ solution using only one queue / use a marker NULL 使用队列 先入先出，明显要使用队列 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; levelOrder(TreeNode *root) &#123; vector&lt;vector&lt;int&gt; &gt; result; if (!root) return result; queue&lt;TreeNode*&gt; q; q.push(root); q.push(NULL); vector&lt;int&gt; cur_vec; while(!q.empty()) &#123; TreeNode* t = q.front(); q.pop(); if (t==NULL) &#123; result.push_back(cur_vec); cur_vec.resize(0); if (q.size() &gt; 0) &#123; q.push(NULL); &#125; &#125; else &#123; cur_vec.push_back(t-&gt;val); if (t-&gt;left) q.push(t-&gt;left); if (t-&gt;right) q.push(t-&gt;right); &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/16900/short-8ms-c-solution-with-queue Short 8ms C++ solution with queue 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; if (!root) &#123; return &#123;&#125;; &#125; vector&lt;int&gt; row; vector&lt;vector&lt;int&gt; &gt; result; queue&lt;TreeNode*&gt; q; q.push(root); int count = 1; while (!q.empty()) &#123; if (q.front()-&gt;left) &#123; q.push(q.front()-&gt;left); &#125; if (q.front()-&gt;right) &#123; q.push(q.front()-&gt;right); &#125; row.push_back(q.front()-&gt;val), q.pop(); if (--count == 0) &#123; result.emplace_back(row), row.clear(); count = q.size(); &#125; &#125; return result; &#125;&#125;; my code: 其一，是vector&lt;TeeNode*&gt; 而不是vector 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(root==NULL) return res; vector&lt;TreeNode*&gt; cur = &#123;root&#125;; helper(cur, res); return res; &#125; void helper(vector&lt;TreeNode*&gt; cur, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(cur.size()==0) return; vector&lt;int&gt; tmp; vector&lt;TreeNode*&gt; nex; for(auto root:cur)&#123; tmp.push_back(root-&gt;val); if(root-&gt;left !=NULL) nex.push_back(root-&gt;left); if(root-&gt;right!=NULL) nex.push_back(root-&gt;right); &#125; res.push_back(tmp); helper(nex, res); return; &#125;&#125;; python https://discuss.leetcode.com/topic/26402/5-6-lines-fast-python-solution-48-ms 5-6 lines fast python solution (48 ms) level is a list of the nodes in the current level. Keep appending a list of the values of these nodes to ans and then updating level with all the nodes in the next level (kids) until it reaches an empty level. Python’s list comprehension makes it easier to deal with many conditions in a concise manner. Solution 1, (6 lines) 1234567def levelOrder(self, root): ans, level = [], [root] while root and level: ans.append([node.val for node in level]) LRpair = [(node.left, node.right) for node in level] level = [leaf for LR in LRpair for leaf in LR if leaf] return ans Solution 2, (5 lines), same idea but use only one list comprehension in while loop to get the next level 123456def levelOrder(self, root): ans, level = [], [root] while root and level: ans.append([node.val for node in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return ans Solution 3 (10 lines), just an expansion of solution 1&amp;2 for better understanding. 1234567891011def levelOrder(self, root): if not root: return [] ans, level = [], [root] while level: ans.append([node.val for node in level]) temp = [] for node in level: temp.extend([node.left, node.right]) level = [leaf for leaf in temp if leaf] return ans 82ms, 5.83%, September 23, 2016 https://discuss.leetcode.com/topic/26402/5-6-lines-fast-python-solution-48-ms 123456789101112131415161718# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrder(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[List[int]] &quot;&quot;&quot; ans, level = [], [root] while root and level: ans.append([node.val for node in level]) level = [kid for n in level for kid in (n.left, n.right) if kid] return ans java https://discuss.leetcode.com/topic/7647/java-solution-with-a-queue-used Java solution with a queue used 123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); List&lt;List&lt;Integer&gt;&gt; wrapList = new LinkedList&lt;List&lt;Integer&gt;&gt;(); if(root == null) return wrapList; queue.offer(root); while(!queue.isEmpty())&#123; int levelNum = queue.size(); List&lt;Integer&gt; subList = new LinkedList&lt;Integer&gt;(); for(int i=0; i&lt;levelNum; i++) &#123; if(queue.peek().left != null) queue.offer(queue.peek().left); if(queue.peek().right != null) queue.offer(queue.peek().right); subList.add(queue.poll().val); &#125; wrapList.add(subList); &#125; return wrapList; &#125;&#125; https://discuss.leetcode.com/topic/7332/java-solution-using-dfs Java Solution using DFS Nothing special. Just wanna provide a different way from BFS. 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); levelHelper(res, root, 0); return res; &#125; public void levelHelper(List&lt;List&lt;Integer&gt;&gt; res, TreeNode root, int height) &#123; if (root == null) return; if (height &gt;= res.size()) &#123; res.add(new LinkedList&lt;Integer&gt;()); &#125; res.get(height).add(root.val); levelHelper(res, root.left, height+1); levelHelper(res, root.right, height+1); &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[101. Symmetric Tree]]></title>
    <url>%2Fp%2F1260a346%2F</url>
    <content type="text"><![CDATA[37.5% https://leetcode.com/problems/symmetric-tree/ Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). 1234567For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \ 3 4 4 3 123456But the following [1,2,2,null,3,null,3] is not: 1 / \ 2 2 \ \ 3 3 Note: Bonus points if you could solve it both recursively and iteratively. 方法一： 迭代 我的代码实现： 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; return helper(root, root); &#125; bool helper(TreeNode* left, TreeNode* right)&#123; if(!left &amp;&amp; !right) return true; if(!left || !right) return false; return left-&gt;val == right-&gt;val &amp;&amp; helper(left-&gt;left, right-&gt;right) &amp;&amp; helper(left-&gt;right, right-&gt;left); &#125;&#125;; 方法二： 4ms, 25.42%, July 14th, 2016 使用两个队列，一个先root，再左再右的层序，一个先root，再右再左的遍历。 https://discuss.leetcode.com/topic/4332/my-c-accepted-code-in-16ms-with-iteration-solution 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; TreeNode *left, *right; if(!root) return true; queue&lt;TreeNode*&gt; q1, q2; q1.push(root-&gt;left); q2.push(root-&gt;right); while(!q1.empty() &amp;&amp; !q2.empty())&#123; left = q1.front(); q1.pop(); right = q2.front(); q2.pop(); if(left == NULL &amp;&amp; right == NULL) continue; if(left == NULL || right == NULL) return false; if(left-&gt;val != right-&gt;val) return false; q1.push(left-&gt;left); q1.push(left-&gt;right); q2.push(right-&gt;right); q2.push(right-&gt;left); &#125; return true; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; queue&lt;TreeNode*&gt; q1, q2; TreeNode* left, *right; q1.push(root-&gt;left); q2.push(root-&gt;right); while(!q1.empty() &amp;&amp; !q2.empty())&#123; left = q1.front(); // 使用变量前要先定义，不要忘了 TreNode* right = q2.front(); q1.pop(); // 要在下面的判断前pop，不然就进入了死循环了。 q2.pop(); if(!left &amp;&amp; !right) continue; //注意： 此处不同于递归，不能直接return true; if(!left || !right || left-&gt;val != right-&gt;val) return false; q1.push(left-&gt;left); q1.push(left-&gt;right); q2.push(right-&gt;right); q2.push(right-&gt;left); &#125; return true; &#125;&#125;; 4ms, 25.42%, July 14th, 2016 https://discuss.leetcode.com/topic/9503/15-lines-of-c-solution-8-ms 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; return helper(root-&gt;left, root-&gt;right); &#125; bool helper(TreeNode* p, TreeNode* q)&#123; if(!p &amp;&amp; !q) return true; else if(!p || !q) return false; if(p-&gt;val != q-&gt;val) return false; return helper(p-&gt;left, q-&gt;right) &amp;&amp; helper(p-&gt;right, q-&gt;left); &#125;&#125;; python 64ms, 31.10%, July 14th, 2016 https://discuss.leetcode.com/topic/8440/6line-ac-python 12345678910111213141516171819# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; def isSym(L, R): if not L and not R: return True if L and R and L.val == R.val: return isSym(L.left, R.right) and isSym(L.right, R.left) return False return isSym(root, root) my code 12345678910111213141516class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if not root: return True return self.helper(root.left, root.right) def helper(self, left, right): if not left and not right: return True if left and right: return left.val==right.val and self.helper(left.left, right.right) and self.helper(left.right, right.left) return False java 1ms, 25.80%, July 14th, 2016 https://discuss.leetcode.com/topic/28589/1ms-recursive-java-solution-easy-to-understand 123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root == null) return true; return isMirror(root.left, root.right); &#125; public boolean isMirror(TreeNode p, TreeNode q)&#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; return (p.val == q.val) &amp;&amp; isMirror(p.left, q.right) &amp;&amp; isMirror(p.right, q.left); &#125;&#125; 3ms, 5.59%, July 14th, 2016 Recursive and non-recursive solutions in Java https://discuss.leetcode.com/topic/5941/recursive-and-non-recursive-solutions-in-java Recursive–400ms: 1234567891011public boolean isSymmetric(TreeNode root) &#123; return root==null || isSymmetricHelp(root.left, root.right);&#125;private boolean isSymmetricHelp(TreeNode left, TreeNode right)&#123; if(left==null || right==null) return left==right; if(left.val!=right.val) return false; return isSymmetricHelp(left.left, right.right) &amp;&amp; isSymmetricHelp(left.right, right.left);&#125; Non-recursive(use Stack)–460ms: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root==null) return true; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode left, right; if(root.left!=null)&#123; if(root.right==null) return false; stack.push(root.left); stack.push(root.right); &#125; else if(root.right!=null)&#123; return false; &#125; while(!stack.empty())&#123; if(stack.size()%2!=0) return false; right = stack.pop(); left = stack.pop(); if(right.val!=left.val) return false; if(left.left!=null)&#123; if(right.right==null) return false; stack.push(left.left); stack.push(right.right); &#125; else if(right.right!=null)&#123; return false; &#125; if(left.right!=null)&#123; if(right.left==null) return false; stack.push(left.right); stack.push(right.left); &#125; else if(right.left!=null)&#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100. Same Tree]]></title>
    <url>%2Fp%2F7dcacf8f%2F</url>
    <content type="text"><![CDATA[45.6% https://leetcode.com/problems/same-tree/ Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 方法一： https://discuss.leetcode.com/topic/5972/here-s-a-c-recursion-solution-in-minimal-lines-of-code 123456789101112131415161718//// Algorithm for the recursion:// 1)// If one of the node is NULL then return the equality result of p an q.// This boils down to if both are NULL then return true, // but if one of them is NULL but not the other one then return false// 2)// At this point both root nodes represent valid pointers.// Return true if the root nodes have same value and // the left tree of the roots are same (recursion)// and the right tree of the roots are same (recursion). // Otherwise return false. //bool isSameTree(TreeNode *p, TreeNode *q) &#123; if (p == NULL || q == NULL) return (p == q); return (p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right));&#125; 我的代码实现： 1234567class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if(p==NULL &amp;&amp; q==NULL) return true; return p!=NULL &amp;&amp; q!=NULL &amp;&amp; p-&gt;val==q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125;&#125;; 方法二： 1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if(!p &amp;&amp; !q) return true; if(!p || !q) return false; return p-&gt;val == q-&gt;val &amp;&amp; isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); &#125;&#125;; python https://discuss.leetcode.com/topic/14561/shortest-simplest-python The “proper” way: 1234def isSameTree(self, p, q): if p and q: return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) return p is q The “tupleify” way: 1234def isSameTree(self, p, q): def t(n): return n and (n.val, t(n.left), t(n.right)) return t(p) == t(q) The first way as one-liner: 12def isSameTree(self, p, q): return p and q and p.val == q.val and all(map(self.isSameTree, (p.left, p.right), (q.left, q.right))) or p is q https://discuss.leetcode.com/topic/18353/python-recursive-solution-and-dfs-iterative-solution-with-stack-and-bfs-iterative-solution-with-queue Python Recursive solution and DFS Iterative solution with stack and BFS Iterative solution with queue 12345678910111213141516171819202122232425262728293031323334353637def isSameTree1(self, p, q): if p and q: return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) else: return p == q# DFS with stack def isSameTree2(self, p, q): stack = [(p, q)] while stack: node1, node2 = stack.pop() if not node1 and not node2: continue elif None in [node1, node2]: return False else: if node1.val != node2.val: return False stack.append((node1.right, node2.right)) stack.append((node1.left, node2.left)) return True # BFS with queue def isSameTree3(self, p, q): queue = [(p, q)] while queue: node1, node2 = queue.pop(0) if not node1 and not node2: continue elif None in [node1, node2]: return False else: if node1.val != node2.val: return False queue.append((node1.left, node2.left)) queue.append((node1.right, node2.right)) return True my code 12345678910class Solution(object): def isSameTree(self, p, q): &quot;&quot;&quot; :type p: TreeNode :type q: TreeNode :rtype: bool &quot;&quot;&quot; if not p and not q: return True return p!=None and q!=None and (p.val==q.val) and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) 其中 p!=None and q!=None，这一段，如果换成p and q，则结果不是false，而是null。 java https://discuss.leetcode.com/topic/4737/five-line-java-solution-with-recursion 123456789101112131415161718/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; if(p.val == q.val) return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); return false; &#125;&#125; https://discuss.leetcode.com/topic/9739/2-lines-java-code 12345public class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) return true; return p != null &amp;&amp; q != null &amp;&amp; p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[099. Recover Binary Search Tree]]></title>
    <url>%2Fp%2F3a244e25%2F</url>
    <content type="text"><![CDATA[29.0% https://leetcode.com/problems/recover-binary-search-tree/?tab=Description Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Note: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution? 方法一： 我的代码实现: 中序遍历，dfs 违反的，更新到first，如果first有值，更新到second。 中间second可能多次更新。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void recoverTree(TreeNode* root) &#123; TreeNode* first = nullptr, *second = nullptr; TreeNode* prev = nullptr; traverse(root, prev, first, second); swap(first-&gt;val, second-&gt;val); return; &#125; void traverse(TreeNode* root, TreeNode*&amp; prev, TreeNode*&amp; first, TreeNode*&amp; second)&#123; if(!root) return; traverse(root-&gt;left, prev, first, second); if(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val &amp;&amp; !first) first = prev; if(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val &amp;&amp; first) second = root; prev = root; // 不要忘记更新prev traverse(root-&gt;right, prev, first, second); return; &#125;&#125;; https://discuss.leetcode.com/topic/35013/recommend-for-beginners-clean-c-implementation-with-detailed-explaination [recommend for beginners]clean C++ implementation with detailed explaination Just use the “first” and “second” pointer to find the 2 nodes that violate the order. Then change the value of the first node ad the second node by their value. 12345678910111213141516171819class Solution &#123; TreeNode* first=NULL; TreeNode* second=NULL; TreeNode* prev = new TreeNode(INT_MIN);public: void recoverTree(TreeNode* root) &#123; help(root); swp(first-&gt;val, second-&gt;val); &#125; void help(TreeNode* root)&#123; if(root==NULL) return; help(root-&gt;left); if(first==NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val) first=prev; if(first!=NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val) second=root; prev=root; help(root-&gt;right); &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; TreeNode* first = NULL; TreeNode* second = NULL; TreeNode* prev = new TreeNode(INT_MIN);public: void recoverTree(TreeNode* root) &#123; helper(root); // 注意交换的是first-&gt;val，second-&gt;val swap(first-&gt;val, second-&gt;val); &#125; void helper(TreeNode* root)&#123; if(!root) return; helper(root-&gt;left); if(first==NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val) first=prev; if(first!=NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val) second=root; prev = root; helper(root-&gt;right); &#125;&#125;; 关于算法的解释： https://discuss.leetcode.com/topic/3988/no-fancy-algorithm-just-simple-and-powerful-in-order-traversal No Fancy Algorithm, just Simple and Powerful In-Order Traversal This question appeared difficult to me but it is really just a simple in-order traversal! I got really frustrated when other people are showing off Morris Traversal which is totally not necessary here. Let’s start by writing the in order traversal: 1234567private void traverse (TreeNode root) &#123; if (root == null) return; traverse(root.left); // Do some business traverse(root.right);&#125; So when we need to print the node values in order, we insert System.out.println(root.val) in the place of “Do some business”. What is the business we are doing here?We need to find the first and second elements that are not in order right? How do we find these two elements? For example, we have the following tree that is printed as in order traversal: 6, 3, 4, 5, 2 We compare each node with its next one and we can find out that 6 is the first element to swap because 6 &gt; 3 and 2 is the second element to swap because 2 &lt; 5. Really, what we are comparing is the current node and its previous node in the “in order traversal”. Let us define three variables, firstElement, secondElement, and prevElement. Now we just need to build the “do some business” logic as finding the two elements. See the code below: 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; TreeNode firstElement = null; TreeNode secondElement = null; // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized TreeNode prevElement = new TreeNode(Integer.MIN_VALUE); public void recoverTree(TreeNode root) &#123; // In order traversal to find the two elements traverse(root); // Swap the values of the two nodes int temp = firstElement.val; firstElement.val = secondElement.val; secondElement.val = temp; &#125; private void traverse(TreeNode root) &#123; if (root == null) return; traverse(root.left); // Start of &quot;do some business&quot;, // If first element has not been found, assign it to prevElement (refer to 6 in the example above) if (firstElement == null &amp;&amp; prevElement.val &gt;= root.val) &#123; firstElement = prevElement; &#125; // If first element is found, assign the second element to the root (refer to 2 in the example above) if (firstElement != null &amp;&amp; prevElement.val &gt;= root.val) &#123; secondElement = root; &#125; prevElement = root; // End of &quot;do some business&quot; traverse(root.right);&#125; And we are done, it is just that easy! https://discuss.leetcode.com/topic/19771/real-o-1-space-no-recursion-no-stack-etc-o-n-time-solution-48ms-c REAL O(1) Space (No recursion/No stack, etc) O(n) Time solution. 48ms C++ Someone complained that a recursion solution isn’t really a O(1) space solution. Ok, here comes the real O(1) solution. No recursion, no stack. Pure Morris traversal. 48 ms, C++ : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; TreeNode * wrong_node0 = nullptr, * wrong_node1 = nullptr, * prev = nullptr; void verify(TreeNode * cur) &#123; if (prev != nullptr &amp;&amp; prev -&gt; val &gt; cur -&gt; val) &#123; if (wrong_node0 == nullptr) &#123; wrong_node0 = prev; wrong_node1 = cur; // in case the tree has only 2 elements. &#125; else wrong_node1 = cur; &#125; prev = cur; &#125; void morrisInorder(TreeNode * root) &#123; TreeNode * cur = root; while (cur) &#123; if (cur-&gt;left == nullptr) &#123; verify(cur); cur = cur-&gt;right; continue; &#125; TreeNode * pred = cur-&gt;left; while (pred -&gt; right != nullptr &amp;&amp; pred -&gt; right != cur) pred = pred -&gt; right; //finding predecessor if (pred -&gt; right == nullptr) &#123; pred -&gt; right = cur; cur = cur -&gt; left; &#125;else &#123;//pred -&gt; right == cur; pred -&gt; right = nullptr; verify(cur); cur = cur -&gt; right; &#125; &#125; &#125; public: void recoverTree(TreeNode* root) &#123; morrisInorder(root); swap(wrong_node0-&gt;val, wrong_node1-&gt;val); &#125; &#125;; python https://discuss.leetcode.com/topic/16600/tree-deserializer-and-visualizer-for-python Tree Deserializer and Visualizer for Python Wrote some tools for my own local testing. For example1deserialize(&apos;[1,2,3,null,null,4,null,null,5]&apos;) will turn that into a tree and return the root as explained in the FAQ. I also wrote a visualizer. Two examples: 1drawtree(deserialize(&apos;[1,2,3,null,null,4,null,null,5]&apos;)): 1drawtree(deserialize(&apos;[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]&apos;)): Here’s the code. If you save it as a Python script and run it, it should as a demo show the above two pictures in turtle windows (one after the other). And you can of course import it from other scripts and then it will only provide the class/functions and not show the demo. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class TreeNode: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def __repr__(self): return &apos;TreeNode(&#123;&#125;)&apos;.format(self.val) def deserialize(string): if string == &apos;&#123;&#125;&apos;: return None nodes = [None if val == &apos;null&apos; else TreeNode(int(val)) for val in string.strip(&apos;[]&#123;&#125;&apos;).split(&apos;,&apos;)] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return rootdef drawtree(root): def height(root): return 1 + max(height(root.left), height(root.right)) if root else -1 def jumpto(x, y): t.penup() t.goto(x, y) t.pendown() def draw(node, x, y, dx): if node: t.goto(x, y) jumpto(x, y-20) t.write(node.val, align=&apos;center&apos;, font=(&apos;Arial&apos;, 12, &apos;normal&apos;)) draw(node.left, x-dx, y-60, dx/2) jumpto(x, y-20) draw(node.right, x+dx, y-60, dx/2) import turtle t = turtle.Turtle() t.speed(0); turtle.delay(0) h = height(root) jumpto(0, 30*h) draw(root, 0, 30*h, 40*h) t.hideturtle() turtle.mainloop() if __name__ == &apos;__main__&apos;: drawtree(deserialize(&apos;[1,2,3,null,null,4,null,null,5]&apos;)) drawtree(deserialize(&apos;[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]&apos;)) java https://discuss.leetcode.com/topic/3988/no-fancy-algorithm-just-simple-and-powerful-in-order-traversal No Fancy Algorithm, just Simple and Powerful In-Order Traversal This question appeared difficult to me but it is really just a simple in-order traversal! I got really frustrated when other people are showing off Morris Traversal which is totally not necessary here. Let’s start by writing the in order traversal: 1234567private void traverse (TreeNode root) &#123; if (root == null) return; traverse(root.left); // Do some business traverse(root.right);&#125; So when we need to print the node values in order, we insert System.out.println(root.val) in the place of “Do some business”. What is the business we are doing here? We need to find the first and second elements that are not in order right? How do we find these two elements? For example, we have the following tree that is printed as in order traversal: 6, 3, 4, 5, 2 We compare each node with its next one and we can find out that 6 is the first element to swap because 6 &gt; 3 and 2 is the second element to swap because 2 &lt; 5. Really, what we are comparing is the current node and its previous node in the “in order traversal”. Let us define three variables, firstElement, secondElement, and prevElement. Now we just need to build the “do some business” logic as finding the two elements. See the code below: 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; TreeNode firstElement = null; TreeNode secondElement = null; // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized TreeNode prevElement = new TreeNode(Integer.MIN_VALUE); public void recoverTree(TreeNode root) &#123; // In order traversal to find the two elements traverse(root); // Swap the values of the two nodes int temp = firstElement.val; firstElement.val = secondElement.val; secondElement.val = temp; &#125; private void traverse(TreeNode root) &#123; if (root == null) return; traverse(root.left); // Start of &quot;do some business&quot;, // If first element has not been found, assign it to prevElement (refer to 6 in the example above) if (firstElement == null &amp;&amp; prevElement.val &gt;= root.val) &#123; firstElement = prevElement; &#125; // If first element is found, assign the second element to the root (refer to 2 in the example above) if (firstElement != null &amp;&amp; prevElement.val &gt;= root.val) &#123; secondElement = root; &#125; prevElement = root; // End of &quot;do some business&quot; traverse(root.right);&#125; And we are done, it is just that easy! https://discuss.leetcode.com/topic/9305/detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer Detail Explain about How Morris Traversal Finds two Incorrect Pointer To understand this, you need to first understand Morris Traversal or Morris Threading Traversal.It take use of leaf nodes’ right/left pointer to achieve O(1) space Traversal on a Binary Tree.Below is a standard Inorder Morris Traversal, referred from http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html (a Chinese Blog, while the graphs are great for illustration) 123456789101112131415161718192021222324public void morrisTraversal(TreeNode root)&#123; TreeNode temp = null; while(root!=null)&#123; if(root.left!=null)&#123; // connect threading for root temp = root.left; while(temp.right!=null &amp;&amp; temp.right != root) temp = temp.right; // the threading already exists if(temp.right!=null)&#123; temp.right = null; System.out.println(root.val); root = root.right; &#125;else&#123; // construct the threading temp.right = root; root = root.left; &#125; &#125;else&#123; System.out.println(root.val); root = root.right; &#125; &#125; &#125; In the above code, System.out.println(root.val);appear twice, which functions as outputing the Node in ascending order (BST). Since these places are in order, replace them with 12345if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123; if(first==null)&#123;first = pre;second = root;&#125; else&#123;second = root;&#125; &#125;pre = root; each time, the pre node and root are in order as System.out.println(root.val); outputs them in order. Then, come to how to specify the first wrong node and second wrong node. When they are not consecutive, the first time we meet pre.val &gt; root.val ensure us the first node is the pre node, since root should be traversal ahead of pre, pre should be at least at small as root. The second time we meet pre.val &gt; root.val ensure us the second node is the root node, since we are now looking for a node to replace with out first node, which is found before. When they are consecutive, which means the case pre.val &gt; cur.val will appear only once. We need to take case this case without destroy the previous analysis. So the first node will still be pre, and the second will be just set to root. Once we meet this case again, the first node will not be affected. Below is the updated version on Morris Traversal. 123456789101112131415161718192021222324252627282930313233343536373839404142public void recoverTree(TreeNode root) &#123; TreeNode pre = null; TreeNode first = null, second = null; // Morris Traversal TreeNode temp = null; while(root!=null)&#123; if(root.left!=null)&#123; // connect threading for root temp = root.left; while(temp.right!=null &amp;&amp; temp.right != root) temp = temp.right; // the threading already exists if(temp.right!=null)&#123; if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123; if(first==null)&#123;first = pre;second = root;&#125; else&#123;second = root;&#125; &#125; pre = root; temp.right = null; root = root.right; &#125;else&#123; // construct the threading temp.right = root; root = root.left; &#125; &#125;else&#123; if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123; if(first==null)&#123;first = pre;second = root;&#125; else&#123;second = root;&#125; &#125; pre = root; root = root.right; &#125; &#125; // swap two node values; if(first!= null &amp;&amp; second != null)&#123; int t = first.val; first.val = second.val; second.val = t; &#125; &#125; https://discuss.leetcode.com/topic/29161/share-my-solutions-and-detailed-explanation-with-recursive-iterative-in-order-traversal-and-morris-traversal Share my solutions and detailed explanation with recursive/iterative in-order-traversal and Morris-traversal In-order traversal is really useful in BST. Following in-order traversal, we should have following order: prev.val &lt; curr.val. If not, then we found at least one incorrectly placed node So the basic idea is to visit the tree with in-order traversal and search for two swapped nodes. Then swap them back. Now the problem is if we found an incorrect pair where prev.val &gt; curr.val, how do we know which node is the incorrect one? The answer is it depends on whether we have found incorrect node before. So What is that? Since we get two elements that are swapped by mistake, there must be a smaller TreeNode get a larger value and a larger TreeNode get a smaller value. Their value are swapped, but the incorrect smaller node is still in smaller tree and incorrect larger node is still in larger tree. So we will visit the incorrect smaller node first, and this node will be detected when we compare its value with next.val, i.e. when it is treated as prev node. The incorrect larger node will be detected when we compare its value with prev.val. We don’t know if it is close or not close to incorrect smaller node, so we should continue search BST and update it if we found another incorrect node. Therefore if it is the first time we found an incorrect pair, the prev node must be the first incorrect node.If it is not the first time we found an incorrect pair, the curr node must be the second incorrect node, thoughwe may have corner case that two incorrect nodes are in same pair. Recursive in-order traversal based on above idea: public void recoverTree(TreeNode root) { 12345678910111213141516171819202122232425262728293031323334//use inorder traversal to detect incorrect node inOrder(root); int temp = first.val; first.val = second.val; second.val = temp;&#125;TreeNode prev = null;TreeNode first = null;TreeNode second = null;public void inOrder(TreeNode root)&#123; if(root == null) return; //search left tree inOrder(root.left); //in inorder traversal of BST, prev should always have smaller value than current value if(prev != null &amp;&amp; prev.val &gt;= root.val)&#123; //incorrect smaller node is always found as prev node if(first == null) first = prev; //incorrect larger node is always found as curr(root) node second = root; &#125; //update prev node prev = root; //search right tree inOrder(root.right);&#125; iterative in-order traversal based on above idea: 12345678910111213141516171819202122232425262728293031323334353637public void recoverTree(TreeNode root) &#123; TreeNode first = null; TreeNode second = null; TreeNode curr = root; TreeNode prev = null; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); while(!stack.isEmpty() || curr != null)&#123; if(curr != null)&#123; //visit curr&apos;s left subtree stack.push(curr); curr = curr.left; &#125;else&#123; //done left subtree of curr Node curr = stack.pop(); //compare curr.val with prev.val if we have one if(prev != null &amp;&amp; curr.val &lt;= prev.val)&#123; //incorrect smaller node is always found as prev node if(first == null) first = prev; //incorrect larger node is always found as curr node second = curr; &#125; //visit curr&apos;s right subtree prev = curr; curr = curr.right; &#125; &#125; //recover swapped nodes int temp = first.val; first.val = second.val; second.val = temp;&#125; Both recursive and iterative will occupy O(n) space in worst case, in which the tree is like a LinkedList To reduce the space to constant space, we have to use Morris-traversal. Morris-traversal is similar to recursive/iterative traversal, but we need to modify the tree structure during thetraversal. before we visiting the left tree of a root, we will build a back-edge between rightmost node in left tree and the root. So we can go back to the root node after we are done with the left tree. Then we locate the rightmost node in left subtree again, cut the back-edge, recover the tree structure and start visit right subtree. The detection of two incorrect TreeNodes is similar to iterative/recursive in-order traversal.We don’t use extra data structure here, so the space complexity is reduced to O(1) and the time complexity will be O(n) Morris-traversal based on above description: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void recoverTree(TreeNode root) &#123; //Morris-traversal TreeNode first = null; TreeNode second = null; TreeNode pred = null; //rightmost node in left tree TreeNode prev = null; TreeNode curr = root; while(curr != null)&#123; //for each node, we compare it with prev node as we did in in-order-traversal if(prev != null &amp;&amp; curr.val &lt;= prev.val)&#123; if(first == null) first = prev; second = curr; &#125; if(curr.left != null)&#123; //got left tree, then let&apos;s locate its rightmost node in left tree pred = curr.left; //we may have visited the left tree before, and connect the rightmost node with curr node (root node) while(pred.right != null &amp;&amp; pred.right != curr)&#123; pred = pred.right; &#125; if(pred.right == curr)&#123; //if this left tree has been visited before, then we are done with it //cut the connection with currNode and start visit curr&apos;s right tree pred.right = null; prev = curr; curr = curr.right; &#125;else&#123; //if this left tree has not been visited before, then we create a back edge from rightmost node // to curr node, so we can return to the start point after done the left tree pred.right = curr; curr = curr.left; &#125; &#125;else&#123; //no left tree, then just visit its right tree prev = curr; curr = curr.right; &#125; &#125; int temp = first.val; first.val = second.val; second.val = temp;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hard</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[098. Validate Binary Search Tree]]></title>
    <url>%2Fp%2F92064786%2F</url>
    <content type="text"><![CDATA[22.6% https://leetcode.com/problems/validate-binary-search-tree/?tab=Description Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. 12345Example 1: 2 / \ 1 3Binary tree [2,1,3], return true. 12345Example 2: 1 / \ 2 3Binary tree [1,2,3], return false. 方法一： 可以中序遍历，判断值是否由小到大。 先中序遍历，则遍历后必定满足是递增数组，否则不满足。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if(!root) return true; vector&lt;int&gt; v; inorder(root, v); int n = v.size(); for(int i=1; i&lt;n; i++) // 要求根大于左边，小于右边，所以是&lt;=，不是&lt; if(v[i]&lt;=v[i-1]) return false; return true; &#125; void inorder(TreeNode* root, vector&lt;int&gt;&amp; v)&#123; if(root)&#123; inorder(root-&gt;left, v); v.push_back(root-&gt;val); inorder(root-&gt;right, v); &#125; &#125;&#125;; 方法二： 我的代码实现： O(n)时间和空间 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; return helper(root, nullptr, nullptr); &#125; bool helper(TreeNode* root, TreeNode* left, TreeNode* right)&#123; if(!root) return true; if(left &amp;&amp; left-&gt;val&gt;=root-&gt;val) return false; if(right &amp;&amp; right-&gt;val&lt;=root-&gt;val) return false; bool l = helper(root-&gt;left, left, root); bool r = helper(root-&gt;right, root, right); return l&amp;r; &#125;&#125;; 可以root值小于最大值，大于最小值，下一个节点要满足以上了两个条件，并且小于或大于根的值。 https://discuss.leetcode.com/topic/18573/c-simple-recursive-solution C++ simple recursive solution 下面这个方法巧妙之处是使用了节点，可以判断是否为NULL 递归方法，在递归中就能确定结果了。 代码中使用了NULL，而不是 INT_MAX ，INT_MIN，这是一个优点。 12345678910bool isValidBST(TreeNode* root) &#123; return isValidBST(root, NULL, NULL);&#125;bool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) &#123; if(!root) return true; if(minNode &amp;&amp; root-&gt;val &lt;= minNode-&gt;val || maxNode &amp;&amp; root-&gt;val &gt;= maxNode-&gt;val) return false; return isValidBST(root-&gt;left, minNode, root) &amp;&amp; isValidBST(root-&gt;right, root, maxNode);&#125; 我的代码实现： 123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if(!root) return true; // 使用INT_MIN过不去，使用LONG_MIN就可以过去了 return helper(root, LONG_MIN, LONG_MAX); &#125; // 此处使用的是long类型 bool helper(TreeNode* root, long l, long r)&#123; if(!root) return true; if(root-&gt;val &lt;= l || root-&gt;val &gt;= r) return false; bool left = helper(root-&gt;left, l, root-&gt;val); bool right = helper(root-&gt;right, root-&gt;val, r); return left &amp;&amp; right; &#125;&#125;; 方法三： 我的代码实现： 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; TreeNode* prev = nullptr; return helper(root, prev); &#125; bool helper(TreeNode* root, TreeNode*&amp; prev)&#123; if(!root) return true; if(!helper(root-&gt;left, prev)) return false; if(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val) return false; prev = root; return helper(root-&gt;right, prev); &#125;&#125;; 判断当前节点与前一个节点 二叉搜索树中序遍历后是有序的，所以我们只需要判断中序遍历中，当前节点node和中序遍历的前一个节点prev的关系，全部满足才是BST，否则false。 1234567891011121314class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; TreeNode* prev = NULL; return validate(root, prev); &#125; bool validate(TreeNode* node, TreeNode* &amp;prev) &#123; if (node == NULL) return true; if (!validate(node-&gt;left, prev)) return false; if (prev != NULL &amp;&amp; prev-&gt;val &gt;= node-&gt;val) return false; prev = node; return validate(node-&gt;right, prev); &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; TreeNode* prev = NULL; return helper(root, prev); &#125; // 引用在后面，说明prev首先是一个引用，然后指向tree指针的引用 bool helper(TreeNode* node, TreeNode* &amp; prev)&#123; if(!node) return true; if(!helper(node-&gt;left, prev)) return false; if(prev &amp;&amp; prev-&gt;val &gt;= node-&gt;val) return false; prev = node; return helper(node-&gt;right, prev); &#125;&#125;; If we use in-order traversal to serialize a binary search tree, we can get a list of values in ascending order. It can be proved with the definition of BST. And here I use the reference of TreeNode pointer prev as a global variable to mark the address of previous node in the list. “In-order Traversal”: https://en.wikipedia.org/wiki/Tree_traversal#In-order If you know what INT_MAX or INT_MIN is, then it is no excuse for your carelessness. python https://discuss.leetcode.com/topic/10455/python-version-based-on-inorder-traversal 136ms, 5.82%, September 23, 2016 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; output = [] self.inOrder(root, output) for i in range(1, len(output)): if output[i-1] &gt;= output[i]: return False return True def inOrder(self, root, output): if root is None: return self.inOrder(root.left, output) output.append(root.val) self.inOrder(root.right, output) java 注意，不仅仅要左侧值小于根，根小于右侧，其实下面所有左侧值都要小于根，右侧值都要大于根。 java 最小最大的值，Long.MIN_VALUE, Long.MAX_VALUE. https://discuss.leetcode.com/topic/7179/my-simple-java-solution-in-3-lines My simple Java solution in 3 lines 1234567891011public class Solution &#123; public boolean isValidBST(TreeNode root) &#123; return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE); &#125; public boolean isValidBST(TreeNode root, long minVal, long maxVal) &#123; if (root == null) return true; if (root.val &gt;= maxVal || root.val &lt;= minVal) return false; return isValidBST(root.left, minVal, root.val) &amp;&amp; isValidBST(root.right, root.val, maxVal); &#125;&#125; Basically what I am doing is recursively iterating over the tree while defining interval &lt;minVal, maxVal&gt; for each node which value must fit in.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>tree</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[097. Interleaving String]]></title>
    <url>%2Fp%2Fa33cb2cc%2F</url>
    <content type="text"><![CDATA[24.1% https://leetcode.com/problems/interleaving-string/ Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. 1234567For example,Given:s1 = &quot;aabcc&quot;,s2 = &quot;dbbca&quot;,When s3 = &quot;aadbbcbcac&quot;, return true.When s3 = &quot;aadbbbaccc&quot;, return false. 本题是一道动态规划题目，建立一个s1.length * s2.length的动态规划数组。 方法一： 0ms, 89.51%, September 21, 2016 https://discuss.leetcode.com/topic/3532/my-dp-solution-in-c Here is some explanation: DP table represents if s3 is interleaving at (i+j)th position when s1 is at ith position, and s2 is at jth position. 0th position means empty string. So if both s1 and s2 is currently empty, s3 is empty too, and it is considered interleaving. If only s1 is empty, then if previous s2 position is interleaving and current s2 position char is equal to s3 current position char, it is considered interleaving. similar idea applies to when s2 is empty. when both s1 and s2 is not empty, then if we arrive i, j from i-1, j, then if i-1,j is already interleaving and i and current s3 position equal, it s interleaving. If we arrive i,j from i, j-1, then if i, j-1 is already interleaving and j and current s3 position equal. it is interleaving. 123456789101112131415161718192021class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if(s3.length()!=s1.length() + s2.length()) return false; bool table[s1.length()+1][s2.length()+1]; for(int i=0; i&lt;s1.length()+1; i++) for(int j=0; j&lt;s2.length()+1; j++)&#123; if(i==0&amp;&amp;j==0) table[i][j] = true; else if(i==0) table[i][j] = (table[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]); else if(j==0) table[i][j] = (table[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1]); else table[i][j] = (table[i-1][j] &amp;&amp; s1[i-1] == s3[i+j-1])||(table[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]); &#125; return table[s1.length()][s2.length()]; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if(s1.size()+s2.size()!=s3.size()) return false; // 等于还是不等于，要考虑清楚 int m = s1.size(), n = s2.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=1; i&lt;n+1; i++) dp[0][i] = dp[0][i-1] &amp;&amp; s3[i-1]==s2[i-1]; for(int i=1; i&lt;m+1; i++) dp[i][0] = dp[i-1][0] &amp;&amp; s3[i-1]==s1[i-1]; for(int i=1; i&lt;m+1; i++)&#123; for(int j=1; j&lt;n+1; j++)&#123; // 注意== 与 = 的区分 dp[i][j] = (dp[i-1][j] &amp;&amp; (s3[i+j-1]==s1[i-1])) || (dp[i][j-1] &amp;&amp; (s3[i+j-1]==s2[j-1])); &#125; &#125; return dp[m][n]; // (m=1)*(n+1)矩阵最后一位索引m，n而不是m+1，n+1 &#125;&#125;; 我的代码实现： 1234567891011121314151617class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; int m = s1.size(), n = s2.size(), l = s3.size(); if(m+n!=l) return false; vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=1; i&lt;=n; i++) dp[0][i] = dp[0][i-1] &amp;&amp; s2[i-1]==s3[i-1]; for(int i=1; i&lt;=m; i++) dp[i][0] = dp[i-1][0] &amp;&amp; s1[i-1]==s3[i-1]; for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) dp[i][j] = dp[i-1][j] &amp;&amp; s1[i-1]==s3[i+j-1] || dp[i][j-1] &amp;&amp; s2[j-1] == s3[i+j-1]; return dp[m][n]; &#125;&#125;; https://discuss.leetcode.com/topic/6562/8ms-c-solution-using-bfs-with-explanation If we expand the two strings s1 and s2 into a chessboard, then this problem can be transferred into a path seeking problem from the top-left corner to the bottom-right corner. The key is, each cell (y, x) in the board corresponds to an interval between y-th character in s1 and x-th character in s2. And adjacent cells are connected with like a grid. A BFS can then be efficiently performed to find the path. Better to illustrate with an example here: 123456789101112131415Say s1 = &quot;aab&quot; and s2 = &quot;abc&quot;. s3 = &quot;aaabcb&quot;. Then the board looks likeo--a--o--b--o--c--o| | | |a a a a| | | |o--a--o--b--o--c--o| | | |a a a a| | | |o--a--o--b--o--c--o| | | |b b b b| | | |o--a--o--b--o--c--o 123456789101112131415Each &quot;o&quot; is a cell in the board. We start from the top-left corner, and try to move right or down. If the next char in s3 matches the edge connecting the next cell, then we&apos;re able to move. When we hit the bottom-right corner, this means s3 can be represented by interleaving s1 and s2. One possible path for this example is indicated with &quot;x&quot;es below:x--a--x--b--o--c--o| | | |a a a a| | | |o--a--x--b--o--c--o| | | |a a a a| | | |o--a--x--b--x--c--x| | | |b b b b| | | |o--a--o--b--o--c--x Note if we concatenate the chars on the edges we went along, it’s exactly s3. And we went through all the chars in s1 and s2, in order, exactly once. Therefore if we view this board as a graph, such path finding problem is trivial with BFS. I use an unordered_map to store the visited nodes, which makes the code look a bit complicated. But a vector should be enough to do the job. Although the worse case timeis also O(mn), typically it doesn’t require us to go through every node to find a path. Therefore it’s faster than regular DP than average. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct MyPoint &#123; int y, x; bool operator==(const MyPoint &amp;p) const &#123; return p.y == y &amp;&amp; p.x == x; &#125;&#125;;namespace std &#123; template &lt;&gt; struct hash&lt;MyPoint&gt; &#123; size_t operator () (const MyPoint &amp;f) const &#123; return (std::hash&lt;int&gt;()(f.x) &lt;&lt; 1) ^ std::hash&lt;int&gt;()(f.y); &#125; &#125;;&#125;class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if (s1.size() + s2.size() != s3.size()) return false; queue&lt;MyPoint&gt; q; unordered_set&lt;MyPoint&gt; visited; bool isSuccessful = false; int i = 0; q.push(MyPoint &#123; 0, 0 &#125;); q.push(MyPoint &#123; -1, -1 &#125;); while (!(1 == q.size() &amp;&amp; -1 == q.front().x)) &#123; auto p = q.front(); q.pop(); if (p.y == s1.size() &amp;&amp; p.x == s2.size()) &#123; return true; &#125; if (-1 == p.y) &#123; q.push(p); i++; continue; &#125; if (visited.find(p) != visited.end()) &#123; continue; &#125; visited.insert(p); if (p.y &lt; s1.size()) &#123; // down if (s1[p.y] == s3[i]) &#123; q.push(MyPoint &#123; p.y + 1, p.x &#125;); &#125; &#125; if (p.x &lt; s2.size()) &#123; // right if (s2[p.x] == s3[i]) &#123; q.push(MyPoint &#123; p.y, p.x + 1 &#125;); &#125; &#125; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/17059/my-dp-c-solution-is-only-10-lines-with-o-n-space My dp C++ solution is only 10 lines with O(n) space! 12345678910111213141516class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; int m = s1.size(), n = s2.size(); if(m+n != s3.size()) return false; bool c[n+1] = &#123;true&#125;; int i, j = 0; while(j &lt; n &amp;&amp; s2[j] == s3[j]) c[++j] = true; for(i = 0; i &lt; m; ++i) &#123; c[0] = c[0] &amp; (s1[i] == s3[i]); for(j = 1; j &lt;= n; ++j) c[j] = ((s1[i] == s3[i+j]) &amp; c[j]) | ((s2[j-1] == s3[i+j]) &amp; c[j-1]); &#125; return c[n]; &#125;&#125;; https://discuss.leetcode.com/topic/4695/c-sharing-my-recursive-tle-and-dp-solution-30ms-easy-to-understand [C++] Sharing my recursive (TLE) and DP solution (30ms) - easy to understand. First, I’m a big recursion person. Here’s my first attempt which is purely recursive. At an intermediate stage, we can either match one char from s1 to one char from s3 and advance one pointer at s1 and s3. Or we can do the same with s2 and s3. I’m open to suggestions to my recursive code. One improvement could come from not having to call the strcmp function? 123456789101112131415class Solution &#123;public: bool isInterleave(char* s1, char* s2, char* s3) &#123; if (*s1==&apos;\0&apos; &amp;&amp; *s2==&apos;\0&apos;) return *s3==&apos;\0&apos;? true : false; else if (*s1==&apos;\0&apos;)&#123; return strcmp(s2,s3)==0 ? true : false; &#125; else if (*s2==&apos;\0&apos;)&#123; return strcmp(s1,s3)==0 ? true : false; &#125; return (*s1==*s3 &amp;&amp; isInterleave(s1+1,s2,s3+1)) | (*s2==*s3 &amp;&amp; isInterleave(s1,s2+1,s3+1)); &#125;&#125;; Here’s the DP version (30ms) as well. Unsurprisingly the DP solution passed the judge and it’s pretty efficient. The logic straightforward if you understood the recursive version since there’s 1:1 correspondence between the two code. I think it’s elegant since it doesn’t have any ugly if, else if shenanigans. 12345678910111213141516171819202122232425class Solution &#123;public: bool isInterleave(string s1, string s2, string s3)&#123; int n1 = s1.length(), n2 = s2.length(), n3 = s3.length(); if (n1+n2 != n3) return false; vector&lt;vector&lt;bool&gt;&gt; V(n1+1, vector&lt;bool&gt;(n2+1, false)); V[n1][n2] = (s3[n1+n2]==&apos;\0&apos;); // fill bottom for (int j=n2-1; j&gt;=0; j--) V[n1][j] = (s2[j]==s3[n1+j] &amp;&amp; V[n1][j+1]); // fill right for (int i=n1-1; i&gt;=0; i--) V[i][n2] = (s1[i]==s3[n2+i] &amp;&amp; V[i+1][n2]); // fill DP table from bottom right for (int j=n2-1; j&gt;=0; j--)&#123; for (int i=n1-1; i&gt;=0; i--)&#123; V[i][j] = (s1[i]==s3[i+j] &amp;&amp; V[i+1][j]) | (s2[j]==s3[i+j] &amp;&amp; V[i][j+1]); &#125; &#125; return V[0][0]; &#125;&#125;; python 112ms, 4.93%, September 21, 2016 https://discuss.leetcode.com/topic/19900/python-dp-solutions-o-m-n-o-n-space-bfs-dfs 12345678910111213141516171819202122# O(m*n) spaceclass Solution(object): def isInterleave(self, s1, s2, s3): &quot;&quot;&quot; :type s1: str :type s2: str :type s3: str :rtype: bool &quot;&quot;&quot; r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False dp = [[True for _ in xrange(c+1)] for _ in xrange(r+1)] for i in xrange(1, r+1): dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1] for j in xrange(1, c+1): dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1] for i in xrange(1, r+1): for j in xrange(1, c+1): dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i-1+j]) or \ (dp[i][j-1] and s2[j-1] == s3[i-1+j]) return dp[-1][-1] 123456789101112131415# O(2*n) spacedef isInterleave2(self, s1, s2, s3): l1, l2, l3 = len(s1)+1, len(s2)+1, len(s3)+1 if l1+l2 != l3+1: return False pre = [True for _ in xrange(l2)] for j in xrange(1, l2): pre[j] = pre[j-1] and s2[j-1] == s3[j-1] for i in xrange(1, l1): cur = [pre[0] and s1[i-1] == s3[i-1]] * l2 for j in xrange(1, l2): cur[j] = (cur[j-1] and s2[j-1] == s3[i+j-1]) or \ (pre[j] and s1[i-1] == s3[i+j-1]) pre = cur[:] return pre[-1] 12345678910111213# O(n) spacedef isInterleave3(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False dp = [True for _ in xrange(c+1)] for j in xrange(1, c+1): dp[j] = dp[j-1] and s2[j-1] == s3[j-1] for i in xrange(1, r+1): dp[0] = (dp[0] and s1[i-1] == s3[i-1]) for j in xrange(1, c+1): dp[j] = (dp[j] and s1[i-1] == s3[i-1+j]) or (dp[j-1] and s2[j-1] == s3[i-1+j]) return dp[-1] 123456789101112131415# DFS def isInterleave4(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False stack, visited = [(0, 0)], set((0, 0)) while stack: x, y = stack.pop() if x+y == l: return True if x+1 &lt;= r and s1[x] == s3[x+y] and (x+1, y) not in visited: stack.append((x+1, y)); visited.add((x+1, y)) if y+1 &lt;= c and s2[y] == s3[x+y] and (x, y+1) not in visited: stack.append((x, y+1)); visited.add((x, y+1)) return False 123456789101112131415# BFS def isInterleave(self, s1, s2, s3): r, c, l= len(s1), len(s2), len(s3) if r+c != l: return False queue, visited = [(0, 0)], set((0, 0)) while queue: x, y = queue.pop(0) if x+y == l: return True if x+1 &lt;= r and s1[x] == s3[x+y] and (x+1, y) not in visited: queue.append((x+1, y)); visited.add((x+1, y)) if y+1 &lt;= c and s2[y] == s3[x+y] and (x, y+1) not in visited: queue.append((x, y+1)); visited.add((x, y+1)) return False java 4ms, 68.74%, September 21, 2016 https://discuss.leetcode.com/topic/7728/dp-solution-in-java DP Solution in Java 123456789101112131415161718192021222324public class Solution &#123; public boolean isInterleave(String s1, String s2, String s3) &#123; if((s1.length()+s2.length()) !=s3.length()) return false; boolean[][] matrix = new boolean[s2.length()+1][s1.length()+1]; matrix[0][0] = true; for(int i = 1; i &lt; matrix[0].length; i++) matrix[0][i] = matrix[0][i-1] &amp;&amp; (s1.charAt(i-1) == s3.charAt(i-1)); for(int i=1; i&lt;matrix.length; i++) matrix[i][0] = matrix[i-1][0] &amp;&amp; (s2.charAt(i-1) == s3.charAt(i-1)); for(int i=1; i&lt;matrix.length; i++)&#123; for(int j=1; j&lt;matrix[0].length; j++)&#123; matrix[i][j] = (matrix[i-1][j] &amp;&amp; (s2.charAt(i-1)==s3.charAt(i+j-1))) || (matrix[i][j-1] &amp;&amp; (s1.charAt(j-1)==s3.charAt(i+j-1))); &#125; &#125; return matrix[s2.length()][s1.length()]; &#125;&#125; https://discuss.leetcode.com/topic/3436/my-accepted-java-recursive-solution-for-interleaving-string My Accepted Java Recursive Solution for interleaving string The private method isInterleave is the recursive method. it takes additional i1, i2, i3 as the start indexes of s1, s2, s3, so it solves the substring of s1, s2, s3 with those start indexes. The recursion starting condition is i1, i2, i3 are set to 0, means it solves the whole string. in each recursion, it will just check the first character in s3 with s2 and s1, if it equals s1, it will increase i3 and i1 to solve remain, if remain return true, this recursion will also return true. Same logic for s2. The end condition is when remain of either s1 or s2 is empty, then just compare remain of s3 with remain of s1 or s2, if they are equal, it will return true. A pure recursive solution will cause time limit exceed. We can optimize it by caching the false visited solutions in the visited set. That will short circuit many repeated search path. 12345678910111213141516171819202122232425262728public class Solution &#123; private static Set&lt;Integer&gt; visited; // The combination of i1, i2 has been visited and return false public static boolean isInterleave(String s1, String s2, String s3) &#123; if(s3.length() != s1.length() + s2.length()) return false; visited = new HashSet&lt;Integer&gt;(); return isInterleave(s1, 0, s2, 0, s3, 0); &#125; private static boolean isInterleave(String s1, int i1, String s2, int i2, String s3, int i3) &#123; int hash = i1 * s3.length() + i2; if(visited.contains(hash)) return false; if(i1 == s1.length()) return s2.substring(i2).equals(s3.substring(i3)); if(i2 == s2.length()) return s1.substring(i1).equals(s3.substring(i3)); if(s3.charAt(i3) == s1.charAt(i1) &amp;&amp; isInterleave(s1, i1+1, s2, i2, s3, i3+1) || s3.charAt(i3) == s2.charAt(i2) &amp;&amp; isInterleave(s1, i1, s2, i2+1, s3, i3+1)) return true; visited.add(hash); return false; &#125;&#125; https://discuss.leetcode.com/topic/31991/1ms-tiny-dfs-beats-94-57 To solve this problem, let’s look at if s1[0 ~ i] s2[0 ~ j] can be interleaved to s3[0 ~ k]. Start from indices0, 0, 0 and compare s1[i] == s3[k] or s2[j] == s3[k] Return valid only if either i or j match k and the remaining is also valid Caching is the key to performance. This is very similar to top down dp Only need to cache invalid[i][j] since most of the case s1[0 ~ i] and s2[0 ~ j] does not form s3[0 ~ k]. Also tested caching valid[i][j] the run time is also 1ms Many guys use substring but it’s duplicate code since substring itself is checking char by char. We are already doing so Hope it helps! 12345678910111213141516public boolean isInterleave(String s1, String s2, String s3) &#123; char[] c1 = s1.toCharArray(), c2 = s2.toCharArray(), c3 = s3.toCharArray(); int m = s1.length(), n = s2.length(); if(m + n != s3.length()) return false; return dfs(c1, c2, c3, 0, 0, 0, new boolean[m + 1][n + 1]);&#125;public boolean dfs(char[] c1, char[] c2, char[] c3, int i, int j, int k, boolean[][] invalid) &#123; if(invalid[i][j]) return false; if(k == c3.length) return true; boolean valid = i &lt; c1.length &amp;&amp; c1[i] == c3[k] &amp;&amp; dfs(c1, c2, c3, i + 1, j, k + 1, invalid) || j &lt; c2.length &amp;&amp; c2[j] == c3[k] &amp;&amp; dfs(c1, c2, c3, i, j + 1, k + 1, invalid); if(!valid) invalid[i][j] = true; return valid;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[096. Unique Binary Search Trees]]></title>
    <url>%2Fp%2Fd9eba394%2F</url>
    <content type="text"><![CDATA[40.1% https://leetcode.com/problems/unique-binary-search-trees/ Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? 12345678For example,Given n = 3, there are a total of 5 unique BST&apos;s. 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 方法一： 使用动态规划的方法，依次观察求解f(n)的个数，观察规律和公式。 https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there 0ms, September 9, 2016 https://discuss.leetcode.com/topic/17950/c-code-w-explanation C++ code w/ explanation 1234567891011121314class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; f; f.push_back(1); for (int i = 1; i &lt;= n; ++i) &#123; int t = 0; for (int j = 0; j &lt; i; ++j) t += f[j] * f[i-j-1]; f.push_back(t); &#125; return f.back(); &#125;&#125;; Consider f_i: choose 1 as the root, we have 0 node for the left tree, i-1 for the right; choose 2 as the root, we have 1 node for the left tree, i-2 for the right; … choose i as the root, we have i-1 nodes for the left tree, 0 for the right. Therefore, the recursive solution is f_i = \sum_{j=0}^{i-1} f_j f_{i-j-1} 我的代码实现： 12345678910111213class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; v(n+1, 0); v[0] = 1; v[1] = 1; for(int i=2; i&lt;=n; i++)&#123; for(int j=0; j&lt;=i; j++) v[i] += v[j] * v[i-j-1]; &#125; return v[n]; &#125;&#125;; 方法二： 使用直接计算公式，此处是 卡特兰数 https://discuss.leetcode.com/topic/5822/it-s-catalan-number http://en.wikipedia.org/wiki/Catalan_number 卡特兰数的另一个公式如下： https://discuss.leetcode.com/topic/5673/dp-problem-10-lines-with-comments Dp problem. 10+ lines with comments 123456789101112131415161718192021222324/** * Taking 1~n as root respectively: * 1 as root: # of trees = F(0) * F(n-1) // F(0) == 1 * 2 as root: # of trees = F(1) * F(n-2) * 3 as root: # of trees = F(2) * F(n-3) * ... * n-1 as root: # of trees = F(n-2) * F(1) * n as root: # of trees = F(n-1) * F(0) * * So, the formulation is: * F(n) = F(0) * F(n-1) + F(1) * F(n-2) + F(2) * F(n-3) + ... + F(n-2) * F(1) + F(n-1) * F(0) */int numTrees(int n) &#123; int dp[n+1]; dp[0] = dp[1] = 1; for (int i=2; i&lt;=n; i++) &#123; dp[i] = 0; for (int j=1; j&lt;=i; j++) &#123; dp[i] += dp[j-1] * dp[i-j]; &#125; &#125; return dp[n];&#125; https://discuss.leetcode.com/topic/13321/a-very-simple-and-straight-ans-based-on-math-catalan-number-o-n-times-o-1-space A very simple and straight ans based on Math,Catalan Number ,O(N) times,O(1)space 123456789int numTrees(int n) &#123; //cantalan树 //C(2n,n)/(n+1) long long ans =1; for(int i=n+1;i&lt;=2*n;i++)&#123; ans = ans*i/(i-n); &#125; return ans/(n+1);&#125; python 36ms, September 9, 2016 https://discuss.leetcode.com/topic/19670/python-solutions-dp-catalan-numbers Python solutions (DP + Catalan number) 12345678# DPdef numTrees1(self, n): res = [0] * (n+1) res[0] = 1 for i in xrange(1, n+1): for j in xrange(i): res[i] += res[j] * res[i-1-j] return res[n] 123# Catalan Number (2n)!/((n+1)!*n!) def numTrees(self, n): return math.factorial(2*n)/(math.factorial(n)*math.factorial(n+1)) java 0ms, September 9, 2016 https://discuss.leetcode.com/topic/8398/dp-solution-in-6-lines-with-explanation-f-i-n-g-i-1-g-n-i DP Solution in 6 lines with explanation. F(i, n) = G(i-1) * G(n-i) The problem can be solved in a dynamic programming way. I’ll explain the intuition and formulas in the following. Given a sequence 1…n, to construct a Binary Search Tree (BST) out of the sequence, we could enumerate each number i in the sequence, and use the number as the root, naturally, the subsequence 1…(i-1) on its left side would lay on the left branch of the root, and similarly the right subsequence (i+1)…n lay on the right branch of the root. We then can construct the subtree from the subsequence recursively. Through the above approach, we could ensure that the BST that we construct are all unique, since they have unique roots. The problem is to calculate the number of unique BST. To do so, we need to define two functions: G(n): the number of unique BST for a sequence of length n. F(i, n), 1 &lt;= i &lt;= n: the number of unique BST, where the number i is the root of BST, and the sequence ranges from 1 to n. As one can see, G(n) is the actual function we need to calculate in order to solve the problem. And G(n) can be derived from F(i, n), which at the end, would recursively refer to G(n). First of all, given the above definitions, we can see that the total number of unique BST G(n), is the sum of BST F(i) using each number i as a root.i.e. 1G(n) = F(1, n) + F(2, n) + ... + F(n, n). Particularly, the bottom cases, there is only one combination to construct a BST out of a sequence of length 1 (only a root) or 0 (empty tree).i.e. 1G(0)=1, G(1)=1. Given a sequence 1…n, we pick a number i out of the sequence as the root, then the number of unique BST with the specified root F(i), is the cartesian product of the number of BST for its left and right subtrees. For example, F(3, 7): the number of unique BST tree with number 3 as its root. To construct an unique BST out of the entire sequence [1, 2, 3, 4, 5, 6, 7] with 3 as the root, which is to say, we need to construct an unique BST out of its left subsequence [1, 2] and another BST out of the right subsequence [4, 5, 6, 7], and then combine them together (i.e. cartesian product). The tricky part is that we could consider the number of unique BST out of sequence [1,2] as G(2), and the number of of unique BST out of sequence [4, 5, 6, 7] as G(4). Therefore, F(3,7) = G(2) * G(4). i.e. 1F(i, n) = G(i-1) * G(n-i) 1 &lt;= i &lt;= n Combining the above two formulas, we obtain the recursive formula for G(n). i.e. 1G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0) In terms of calculation, we need to start with the lower number, since the value of G(n) depends on the values of G(0) … G(n-1). With the above explanation and formulas, here is the implementation in Java. 123456789101112public int numTrees(int n) &#123; int [] G = new int[n+1]; G[0] = G[1] = 1; for(int i=2; i&lt;=n; ++i) &#123; for(int j=1; j&lt;=i; ++j) &#123; G[i] += G[j-1] * G[i-j]; &#125; &#125; return G[n];&#125; c 0ms, September 9, 2016 https://discuss.leetcode.com/topic/5673/dp-problem-10-lines-with-comments 12345678910int numTrees(int n) &#123; int dp[n+1]; dp[0] = dp[1] = 1; for(int i=2; i&lt;=n; i++)&#123; dp[i] = 0; for(int j=1; j&lt;=i; j++) dp[i] += dp[j-1] * dp[i-j]; &#125; return dp[n];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[095. Unique Binary Search Trees II]]></title>
    <url>%2Fp%2F68405e1a%2F</url>
    <content type="text"><![CDATA[30.8% https://leetcode.com/problems/unique-binary-search-trees/?tab=Description Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? 12345678For example,Given n = 3, there are a total of 5 unique BST&apos;s. 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 方法一： 此题，与96题的区别在于，96题要求返回个数，此题要求返回所有结果。 使用递归的方法 https://discuss.leetcode.com/topic/9313/30-ms-c-solution 30 ms c++ solution 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;TreeNode *&gt; generateTrees(int n) &#123; if(n&lt;1) return vector&lt;TreeNode*&gt;(); return helper(1,n); &#125; vector&lt;TreeNode*&gt; helper(int s, int e) &#123; if (s &gt; e) &#123; return vector&lt;TreeNode*&gt;(1,NULL); &#125; vector&lt;TreeNode*&gt; result; for (int i=s; i &lt;= e; ++i) &#123; vector&lt;TreeNode*&gt; left, right; left = helper(s,i-1); right = helper(i+1,e); for (int j = 0; j &lt; left.size(); ++j) &#123; for (int k = 0; k &lt; right.size(); ++k) &#123; TreeNode* root = new TreeNode(i); root-&gt;left = left[j]; root-&gt;right = right[k]; result.push_back(root); &#125; &#125; &#125; return result; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if(n&lt;1) return vector&lt;TreeNode*&gt;(); // 对于复杂的问题，很多使用一个辅助函数，同时使用递归 return helper(1, n); &#125; // 注意区分ListNode TreeNode vector&lt;TreeNode*&gt; helper(int start, int end)&#123; if(end&lt;start) return vector&lt;TreeNode*&gt;(1, NULL); if(start==end)&#123; TreeNode* node = new TreeNode(start); vector&lt;TreeNode*&gt; res; res.push_back(node); return res; &#125; vector&lt;TreeNode*&gt; result; for(int i=start; i&lt;=end; i++)&#123; vector&lt;TreeNode*&gt; left = helper(start, i-1); vector&lt;TreeNode*&gt; right = helper(i+1, end); for(int j=0; j&lt;left.size(); j++)&#123; for(int k=0; k&lt;right.size(); k++)&#123; TreeNode* root = new TreeNode(i); root-&gt;left = left[j]; root-&gt;right = right[k]; result.push_back(root); &#125; &#125; &#125; return result; &#125;&#125;; cpp 19ms, 86.97%, September 23, 2016 https://discuss.leetcode.com/topic/6711/share-a-c-dp-solution-with-o-1-space Share a C++ DP solution with O(1) space The basic idea is that we can construct the result of n node tree just from the result of n-1 node tree.Here’s how we do it: only 2 conditions: 1) The nth node is the new root, so newroot-&gt;left = oldroot; 2) the nth node is not root, we traverse the old tree, every time the node in the old tree has a right child, we can perform: old node-&gt;right = nth node, nth node -&gt;left = right child; and when we reach the end of the tree, don’t forget we can also add the nth node here. One thing to notice is that every time we push a TreeNode in our result, I push the clone version of the root, and I recover what I do to the old node immediately. This is because you may use the old tree for several times. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public: TreeNode* clone(TreeNode* root)&#123; if(root == nullptr) return nullptr; TreeNode* newroot = new TreeNode(root-&gt;val); newroot-&gt;left = clone(root-&gt;left); newroot-&gt;right = clone(root-&gt;right); return newroot; &#125; vector&lt;TreeNode *&gt; generateTrees(int n) &#123; vector&lt;TreeNode *&gt; res(1,nullptr); for(int i = 1; i &lt;= n; i++)&#123; vector&lt;TreeNode *&gt; tmp; for(int j = 0; j&lt;res.size();j++)&#123; TreeNode* oldroot = res[j]; TreeNode* root = new TreeNode(i); TreeNode* target = clone(oldroot); root-&gt;left = target; tmp.push_back(root); if(oldroot!=nullptr)&#123; TreeNode* tmpold = oldroot; while(tmpold-&gt;right!=nullptr)&#123; TreeNode* nonroot = new TreeNode(i); TreeNode *tright = tmpold-&gt;right; tmpold-&gt;right = nonroot; nonroot-&gt;left = tright; TreeNode *target = clone(oldroot); tmp.push_back(target); tmpold-&gt;right = tright; tmpold = tmpold-&gt;right; &#125; tmpold-&gt;right = new TreeNode(i); TreeNode *target = clone(oldroot); tmp.push_back(target); tmpold-&gt;right = nullptr; &#125; &#125; res=tmp; &#125; return res; &#125; &#125;; https://discuss.leetcode.com/topic/4795/my-accepted-c-solution-recursive-less-than-30-lines My Accepted C++ solution (recursive, less than 30 lines) explaination: Given a tree which n nodes, it has the follwing form: (0)root(n-1) (1)root(n-2) (2)root(n-3) where (x) denotes the trees with x nodes. Now take n=3 for example. Given n=3, we have [1 2 3] in which each of them can be used as the tree root. when root=1: [1 # 2 # 3]; [1 # 3 2]; when root=2: [2 1 3]; when root=3: (similar with the situations when root=1.) Thus, if we write a recursive function who generates a group of trees in which the numbers range from f to t, we have to generate the left trees and right trees of each tree in the vector. I give the following recursive code and expect to see non-recursive ones. please! code: 123456789101112131415161718192021222324252627282930vector&lt;TreeNode *&gt; generateTree(int from, int to)&#123; vector&lt;TreeNode *&gt; ret; if(to - from &lt; 0) ret.push_back(0); if(to - from == 0) ret.push_back(new TreeNode(from)); if(to - from &gt; 0) &#123; for(int i=from; i&lt;=to; i++) &#123; vector&lt;TreeNode *&gt; l = generateTree(from, i-1); vector&lt;TreeNode *&gt; r = generateTree(i+1, to); for(int j=0; j&lt;l.size(); j++) &#123; for(int k=0; k&lt;r.size(); k++) &#123; TreeNode * h = new TreeNode (i); h-&gt;left = l[j]; h-&gt;right = r[k]; ret.push_back(h); &#125; &#125; &#125; &#125; return ret;&#125;vector&lt;TreeNode *&gt; generateTrees(int n) &#123; return generateTree(1, n);&#125; python https://discuss.leetcode.com/topic/15886/should-be-6-liner Should-be-6-Liner If only LeetCode had a TreeNode(val, left, right) constructor… sigh. Then I wouldn’t need to provide my own and my solution would be six lines instead of eleven. 123456789101112def generateTrees(self, n): def node(val, left, right): node = TreeNode(val) node.left = left node.right = right return node def trees(first, last): return [node(root, left, right) for root in range(first, last+1) for left in trees(first, root-1) for right in trees(root+1, last)] or [None] return trees(1, n) Or even just four lines, if it’s not forbidden to add an optional argument: 123456789101112def node(val, left, right): node = TreeNode(val) node.left = left node.right = right return nodeclass Solution: def generateTrees(self, last, first=1): return [node(root, left, right) for root in range(first, last+1) for left in self.generateTrees(root-1, first) for right in self.generateTrees(last, root+1)] or [None] Just another version, using loops instead of list comprehension: 123456789101112def generateTrees(self, n): def generate(first, last): trees = [] for root in range(first, last+1): for left in generate(first, root-1): for right in generate(root+1, last): node = TreeNode(root) node.left = left node.right = right trees += node, return trees or [None] return generate(1, n) java https://discuss.leetcode.com/topic/3079/a-simple-recursive-solution A simple recursive solution I start by noting that 1..n is the in-order traversal for any BST with nodes 1 to n. So if I pick i-th node as my root, the left subtree will contain elements 1 to (i-1), and the right subtree will contain elements (i+1) to n. I use recursive calls to get back all possible trees for left and right subtrees and combine them in all possible ways with the root. 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; return genTrees(1,n); &#125; public List&lt;TreeNode&gt; genTrees (int start, int end) &#123; List&lt;TreeNode&gt; list = new ArrayList&lt;TreeNode&gt;(); if(start&gt;end) &#123; list.add(null); return list; &#125; if(start == end)&#123; list.add(new TreeNode(start)); return list; &#125; List&lt;TreeNode&gt; left,right; for(int i=start;i&lt;=end;i++) &#123; left = genTrees(start, i-1); right = genTrees(i+1,end); for(TreeNode lnode: left) &#123; for(TreeNode rnode: right) &#123; TreeNode root = new TreeNode(i); root.left = lnode; root.right = rnode; list.add(root); &#125; &#125; &#125; return list; &#125;&#125; https://discuss.leetcode.com/topic/2940/java-solution-with-dp Java Solution with DP Here is my java solution with DP: 123456789101112131415161718192021222324252627282930313233public static List&lt;TreeNode&gt; generateTrees(int n) &#123; List&lt;TreeNode&gt;[] result = new List[n + 1]; result[0] = new ArrayList&lt;TreeNode&gt;(); if (n == 0) &#123; return result[0]; &#125; result[0].add(null); for (int len = 1; len &lt;= n; len++) &#123; result[len] = new ArrayList&lt;TreeNode&gt;(); for (int j = 0; j &lt; len; j++) &#123; for (TreeNode nodeL : result[j]) &#123; for (TreeNode nodeR : result[len - j - 1]) &#123; TreeNode node = new TreeNode(j + 1); node.left = nodeL; node.right = clone(nodeR, j + 1); result[len].add(node); &#125; &#125; &#125; &#125; return result[n];&#125;private static TreeNode clone(TreeNode n, int offset) &#123; if (n == null) &#123; return null; &#125; TreeNode node = new TreeNode(n.val + offset); node.left = clone(n.left, offset); node.right = clone(n.right, offset); return node;&#125; result[i] stores the result until length i. For the result for length i+1, select the root node j from 0 to i, combine the result from left side and right side. Note for the right side we have to clone the nodes as the value will be offsetted by j. https://discuss.leetcode.com/topic/8410/divide-and-conquer-f-i-g-i-1-g-n-i Divide-and-conquer. F(i) = G(i-1) * G(n-i) This problem is a variant of the problem of Unique Binary Search Trees. I provided a solution along with explanation for the above problem, in the question “DP solution in 6 lines with explanation” It is intuitive to solve this problem by following the same algorithm. Here is the code in a divide-and-conquer style. 1234567891011121314151617181920212223242526public List&lt;TreeNode&gt; generateTrees(int n) &#123; return generateSubtrees(1, n);&#125;private List&lt;TreeNode&gt; generateSubtrees(int s, int e) &#123; List&lt;TreeNode&gt; res = new LinkedList&lt;TreeNode&gt;(); if (s &gt; e) &#123; res.add(null); // empty tree return res; &#125; for (int i = s; i &lt;= e; ++i) &#123; List&lt;TreeNode&gt; leftSubtrees = generateSubtrees(s, i - 1); List&lt;TreeNode&gt; rightSubtrees = generateSubtrees(i + 1, e); for (TreeNode left : leftSubtrees) &#123; for (TreeNode right : rightSubtrees) &#123; TreeNode root = new TreeNode(i); root.left = left; root.right = right; res.add(root); &#125; &#125; &#125; return res;&#125; 5ms, 22.90%, September 23, 2016 https://discuss.leetcode.com/topic/8410/divide-and-conquer-f-i-g-i-1-g-n-i 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; List&lt;TreeNode&gt; tmp = new LinkedList&lt;TreeNode&gt;(); if(n==0) return tmp; return generateSubtrees(1, n); &#125; private List&lt;TreeNode&gt; generateSubtrees(int s, int e)&#123; List&lt;TreeNode&gt; res = new LinkedList&lt;TreeNode&gt;(); if(s&gt;e)&#123; res.add(null); return res; &#125; for(int i=s; i&lt;=e; ++i)&#123; List&lt;TreeNode&gt; leftSubtrees = generateSubtrees(s, i-1); List&lt;TreeNode&gt; rightSubtrees = generateSubtrees(i+1, e); for(TreeNode left:leftSubtrees)&#123; for(TreeNode right:rightSubtrees)&#123; TreeNode root = new TreeNode(i); root.left = left; root.right = right; res.add(root); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>dynamic programming</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[094. Binary Tree Inorder Traversal]]></title>
    <url>%2Fp%2Fa4c01477%2F</url>
    <content type="text"><![CDATA[44.5% https://leetcode.com/problems/binary-tree-inorder-traversal/#/description Given a binary tree, return the inorder traversal of its nodes’ values. For example:Given binary tree [1,null,2,3], 1 \ 2 / 3return [1,3,2]. Note: Recursive solution is trivial, could you do it iteratively? 方法一：递归版本，最简单 Dec 10th, 2017 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; helper(root, res); return res; &#125; void helper(TreeNode* root, vector&lt;int&gt;&amp; res)&#123; if(root!=nullptr)&#123; helper(root-&gt;left, res); res.push_back(root-&gt;val); helper(root-&gt;right, res); &#125; &#125;&#125;; 1234567891011void inorder(TreeNode* root, vector&lt;int&gt;&amp; nodes) &#123; if (!root) return; inorder(root -&gt; left, nodes); nodes.push_back(root -&gt; val); inorder(root -&gt; right, nodes);&#125;vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; inorder(root, nodes); return nodes;&#125; 我的代码实现： 12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; vector&lt;int&gt; res;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; if(!root) return res; // 虽然有返回值，但我们不使用 inorderTraversal(root-&gt;left); res.push_back(root-&gt;val); inorderTraversal(root-&gt;right); return res; &#125;&#125;; 方法二：迭代版本 使用栈 pCurrent指向当前节点。 如果当前节点不为空，压入栈，然后当前节点指向做节点。 当前节点为空，从栈中取出一个节点，节点值放入vector，当前节点指向右节点。 Dec 10th, 2017 123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; stack; TreeNode* cur = root; // 这个要满足两个条件，stack不为空且cur不为nullptr while(stack.size() || cur!=nullptr)&#123; if(cur!=nullptr)&#123; stack.push(cur); cur = cur-&gt;left; &#125;else&#123; TreeNode* tmp = stack.top(); stack.pop(); res.push_back(tmp-&gt;val); cur = tmp-&gt;right; &#125; &#125; return res; &#125;&#125;; 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; vector; stack&lt;TreeNode *&gt; stack; TreeNode *pCurrent = root; while(!stack.empty() || pCurrent) &#123; if(pCurrent) &#123; stack.push(pCurrent); pCurrent = pCurrent-&gt;left; &#125; else &#123; TreeNode *pNode = stack.top(); vector.push_back(pNode-&gt;val); stack.pop(); pCurrent = pNode-&gt;right; &#125; &#125; return vector; &#125;&#125;; 我的代码实现： 先把左边全部压入， 然后取出，放入一个节点，向上走，向右走。 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; stack; while(root || !stack.empty())&#123; if(root)&#123; stack.push(root); root = root-&gt;left; &#125;else&#123; TreeNode* node = stack.top(); stack.pop(); res.push_back(node-&gt;val); root = node-&gt;right; &#125; &#125; return res; &#125;&#125;; 方法三： Morris traversal: 12345678910111213141516171819202122232425vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; TreeNode* curNode = root; vector&lt;int&gt; nodes; while (curNode) &#123; if (curNode -&gt; left) &#123; TreeNode* predecessor = curNode -&gt; left; while (predecessor -&gt; right &amp;&amp; predecessor -&gt; right != curNode) predecessor = predecessor -&gt; right; if (!(predecessor -&gt; right)) &#123; predecessor -&gt; right = curNode; curNode = curNode -&gt; left; &#125; else &#123; predecessor -&gt; right = NULL; nodes.push_back(curNode -&gt; val); curNode = curNode -&gt; right; &#125; &#125; else &#123; nodes.push_back(curNode -&gt; val); curNode = curNode -&gt; right; &#125; &#125; return nodes;&#125; 我的代码实现: 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; TreeNode* cur = root; while(cur)&#123; if(cur-&gt;left)&#123; TreeNode* pre = cur-&gt;left; while(pre-&gt;right!=NULL &amp;&amp; pre-&gt;right!=cur) pre = pre-&gt;right; if(pre-&gt;right!=cur)&#123; pre-&gt;right = cur; cur = cur-&gt;left; &#125;else&#123; pre-&gt;right = NULL; res.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125;else&#123; res.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/3288/three-methods-to-solve-c Three Methods to Solve (C++) Method 1: Using one stack and the binary tree node will be changed. Easy ,not Practical 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; vector; if(!root) return vector; stack&lt;TreeNode *&gt; stack; stack.push(root); while(!stack.empty()) &#123; TreeNode *pNode = stack.top(); if(pNode-&gt;left) &#123; stack.push(pNode-&gt;left); pNode-&gt;left = NULL; &#125; else &#123; vector.push_back(pNode-&gt;val); stack.pop(); if(pNode-&gt;right) stack.push(pNode-&gt;right); &#125; &#125; return vector; &#125;&#125;; Method 2: Using one stack and one unordered_map, this will not changed the node. Better 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; vector; if(!root) return vector; unordered_map&lt;TreeNode *, bool&gt; map;//left child has been visited:true. stack&lt;TreeNode *&gt; stack; stack.push(root); while(!stack.empty()) &#123; TreeNode *pNode = stack.top(); if(pNode-&gt;left &amp;&amp; !map[pNode]) &#123; stack.push(pNode-&gt;left); map[pNode] = true; &#125; else &#123; vector.push_back(pNode-&gt;val); stack.pop(); if(pNode-&gt;right) stack.push(pNode-&gt;right); &#125; &#125; return vector; &#125;&#125;; Method 3: Using one stack and will not changed the node. Best(at least in this three solutions) 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; vector; stack&lt;TreeNode *&gt; stack; TreeNode *pCurrent = root; while(!stack.empty() || pCurrent) &#123; if(pCurrent) &#123; stack.push(pCurrent); pCurrent = pCurrent-&gt;left; &#125; else &#123; TreeNode *pNode = stack.top(); vector.push_back(pNode-&gt;val); stack.pop(); pCurrent = pNode-&gt;right; &#125; &#125; return vector; &#125;&#125;; https://discuss.leetcode.com/topic/14475/clear-c-solutions-iterative-recursive-and-morris-traversal-3-different-solutions Clear C++ solutions — iterative, recursive and Morris traversal (3 different solutions!) Hi, this is a fundamental and yet classic problem. I share my three solutions here: Iterative solution using stack — O(n) time and O(n) space; Recursive solution — O(n) time and O(n) space (considering the spaces of function call stack); Morris traversal — O(n) time and O(1) space!!! Iterative solution using stack: 123456789101112131415161718vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; stack&lt;TreeNode*&gt; toVisit; TreeNode* curNode = root; while (curNode || !toVisit.empty()) &#123; if (curNode) &#123; toVisit.push(curNode); curNode = curNode -&gt; left; &#125; else &#123; curNode = toVisit.top(); toVisit.pop(); nodes.push_back(curNode -&gt; val); curNode = curNode -&gt; right; &#125; &#125; return nodes;&#125; Recursive solution: 1234567891011void inorder(TreeNode* root, vector&lt;int&gt;&amp; nodes) &#123; if (!root) return; inorder(root -&gt; left, nodes); nodes.push_back(root -&gt; val); inorder(root -&gt; right, nodes);&#125;vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; nodes; inorder(root, nodes); return nodes;&#125; Morris traversal: 12345678910111213141516171819202122232425vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; TreeNode* curNode = root; vector&lt;int&gt; nodes; while (curNode) &#123; if (curNode -&gt; left) &#123; TreeNode* predecessor = curNode -&gt; left; while (predecessor -&gt; right &amp;&amp; predecessor -&gt; right != curNode) predecessor = predecessor -&gt; right; if (!(predecessor -&gt; right)) &#123; predecessor -&gt; right = curNode; curNode = curNode -&gt; left; &#125; else &#123; predecessor -&gt; right = NULL; nodes.push_back(curNode -&gt; val); curNode = curNode -&gt; right; &#125; &#125; else &#123; nodes.push_back(curNode -&gt; val); curNode = curNode -&gt; right; &#125; &#125; return nodes;&#125; https://discuss.leetcode.com/topic/21942/my-3-solutions-in-c My 3 solutions in c++ 123456789// recursive, it&apos;s trivial...vector&lt;int&gt; v;vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; if(!root) return v; inorderTraversal(root-&gt;left); v.push_back(root-&gt;val); inorderTraversal(root-&gt;right); return v;&#125; 12345678910111213141516171819// iterate, use stackvector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root; stack&lt;TreeNode*&gt; s; while(true)&#123; while(temp)&#123; s.push(temp); temp = temp-&gt;left; &#125; if(s.empty()) break; temp = s.top(); s.pop(); v.push_back(temp-&gt;val); temp = temp-&gt;right; &#125; return v;&#125; 123456789101112131415161718192021222324// iterate, morris traversal, without stackvector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; v; if(!root) return v; TreeNode* temp = root, *prev; while(temp)&#123; if(!temp-&gt;left)&#123; v.push_back(temp-&gt;val); temp = temp-&gt;right; &#125;else&#123; prev = temp-&gt;left; while(prev-&gt;right&amp;&amp;(prev-&gt;right != temp)) prev = prev-&gt;right; if(!prev-&gt;right)&#123; prev-&gt;right = temp; temp = temp-&gt;left; &#125;else&#123; v.push_back(temp-&gt;val); prev-&gt;right = NULL; temp = temp-&gt;right; &#125; &#125; &#125;&#125; python https://discuss.leetcode.com/topic/21350/python-recursive-and-iterative-solutions Python recursive and iterative solutions. 1234567891011# recursivelydef inorderTraversal1(self, root): res = [] self.helper(root, res) return res def helper(self, root, res): if root: self.helper(root.left, res) res.append(root.val) self.helper(root.right, res) 123456789101112# iteratively def inorderTraversal(self, root): res, stack = [], [] while True: while root: stack.append(root) root = root.left if not stack: return res node = stack.pop() res.append(node.val) root = node.right https://discuss.leetcode.com/topic/14640/simple-python-iterative-solution-by-using-a-visited-flag-o-n-56ms Simple Python iterative solution by using a visited flag - O(n) 56ms 123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # @param &#123;TreeNode&#125; root # @return &#123;integer[]&#125; def inorderTraversal(self, root): result, stack = [], [(root, False)] while stack: cur, visited = stack.pop() if cur: if visited: result.append(cur.val) else: stack.append((cur.right, False)) stack.append((cur, True)) stack.append((cur.left, False)) return result 48ms, 57.41%, June.16th, 2016 https://leetcode.com/discuss/51816/python-recursive-and-iterative-solutions 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def inorderTraversal(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; ans = [] stack = [] while stack or root: if root: stack.append(root) root = root.left else: tmpNode = stack.pop() ans.append(tmpNode.val) root = tmpNode.right return ans java https://discuss.leetcode.com/topic/6478/iterative-solution-in-java-simple-and-readable Iterative solution in Java - simple and readable 123456789101112131415161718public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode cur = root; while(cur!=null || !stack.empty())&#123; while(cur!=null)&#123; stack.add(cur); cur = cur.left; &#125; cur = stack.pop(); list.add(cur.val); cur = cur.right; &#125; return list;&#125; https://discuss.leetcode.com/topic/3402/morris-traversal-no-recursion-no-stack Morris Traversal——- NO RECURSION NO STACK 12345678910111213141516171819202122232425262728293031323334public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125;public class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if(root == null) return new ArrayList&lt;Integer&gt;(); List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); TreeNode pre = null; while(root != null)&#123; if(root.left == null)&#123; res.add(root.val); root = root.right; &#125;else&#123; pre = root.left; while(pre.right != null &amp;&amp; pre.right != root)&#123; pre = pre.right; &#125; if(pre.right == null)&#123; pre.right = root; root = root.left; &#125;else&#123; pre.right = null; res.add(root.val); root = root.right; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>hash table</tag>
        <tag>stack</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[093. Restore IP Addresses]]></title>
    <url>%2Fp%2F3f3a9681%2F</url>
    <content type="text"><![CDATA[26.2% https://leetcode.com/problems/restore-ip-addresses/ Given a string containing only digits, restore it by returning all possible valid IP address combinations. 1234For example:Given &quot;25525511135&quot;,return [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]. (Order does not matter) 方法一： 学习string的函数，substr、stoi int转string的函数，to_string 0ms, 85.96%, September 22, 2016 https://discuss.leetcode.com/topic/38342/who-can-beat-this-code 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; ret; string ans; for(int a=1; a&lt;=3; a++) for(int b=1; b&lt;=3; b++) for(int c=1; c&lt;=3; c++) for(int d=1; d&lt;=3; d++) if(a+b+c+d == s.length())&#123; int A = stoi(s.substr(0, a)); int B = stoi(s.substr(a, b)); int C = stoi(s.substr(a+b, c)); int D = stoi(s.substr(a+b+c, d)); if(A&lt;=255&amp;&amp;B&lt;=255&amp;&amp;C&lt;=255&amp;&amp;D&lt;=255) if((ans=to_string(A)+&quot;.&quot;+to_string(B)+&quot;.&quot;+to_string(C)+&quot;.&quot;+ to_string(D)).length() == s.length()+3) ret.push_back(ans); &#125; return ret; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; res; // 要注意时&lt;=还是&lt; for(int i=1; i&lt;=3; i++)&#123; for(int j=1; j&lt;=3; j++)&#123; for(int k=1; k&lt;=3; k++)&#123; for(int l=1; l&lt;=3; l++)&#123; if(i+k+j+l==s.size())&#123; int a = stoi(s.substr(0, i)); int b = stoi(s.substr(i, j)); int c = stoi(s.substr(i+j, k)); int d = stoi(s.substr(i+j+k, l)); // 要有&lt;=255这个判断 if(a&lt;=255 &amp;&amp; b&lt;=255 &amp;&amp; c&lt;=255 &amp;&amp; d&lt;=255)&#123; // 注意使用"."还是'.'，尤其注意c++时 string t = to_string(a)+"."+to_string(b)+"."+ to_string(c)+"."+to_string(d); if(t.size()==s.size()+3) res.push_back(t); &#125; &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125;; 方法二： dfs https://discuss.leetcode.com/topic/19274/share-0ms-neat-and-clear-c-solution-using-dfs Share 0ms neat and clear c++ solution using DFS 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; result; string ip; dfs(s,0,0,ip,result); //paras:string s,start index of s,step(from0-3),intermediate ip,final result return result; &#125; void dfs(string s,int start,int step,string ip,vector&lt;string&gt;&amp; result)&#123; if(start==s.size()&amp;&amp;step==4)&#123; ip.erase(ip.end()-1); //remove the last &apos;.&apos; from the last decimal number result.push_back(ip); return; &#125; if(s.size()-start&gt;(4-step)*3) return; if(s.size()-start&lt;(4-step)) return; int num=0; for(int i=start;i&lt;start+3;i++)&#123; num=num*10+(s[i]-&apos;0&apos;); if(num&lt;=255)&#123; ip+=s[i]; dfs(s,i+1,step+1,ip+&apos;.&apos;,result); &#125; if(num==0) break; &#125; &#125;&#125;; java 4ms, 58.66%, September 22, 2016 https://discuss.leetcode.com/topic/3919/my-code-in-java 3-loop divides the string s into 4 substring: s1, s2, s3, s4. Check if each substring is valid.In isValid, strings whose length greater than 3 or equals to 0 is not valid; or if the string’s length is longer than 1 and the first letter is ‘0’ then it’s invalid; or the string whose integer representation greater than 255 is invalid. 12345678910111213141516171819202122public class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); int len = s.length(); for(int i=1; i&lt;4&amp;&amp;i&lt;len-2; i++)&#123; for(int j=i+1; j&lt;i+4&amp;&amp; j&lt;len; j++)&#123; for(int k=j+1; k&lt;j+4&amp;&amp;k&lt;len; k++)&#123; String s1 = s.substring(0, i), s2 = s.substring(i, j), s3=s.substring(j,k), s4=s.substring(k,len); if(isValid(s1) &amp;&amp; isValid(s2) &amp;&amp; isValid(s3) &amp;&amp; isValid(s4)) res.add(s1+&quot;.&quot;+s2+&quot;.&quot;+s3+&quot;.&quot;+s4); &#125; &#125; &#125; return res; &#125; public boolean isValid(String s)&#123; if(s.length()&gt;3 || s.length()==0 || (s.charAt(0)==&apos;0&apos;&amp;&amp;s.length()&gt;1) || Integer.parseInt(s)&gt;255) return false; return true; &#125;&#125; https://discuss.leetcode.com/topic/4742/very-simple-dfs-solution Very simple DFS solution 1234567891011121314151617public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; solutions = new ArrayList&lt;String&gt;(); restoreIp(s, solutions, 0, &quot;&quot;, 0); return solutions;&#125;private void restoreIp(String ip, List&lt;String&gt; solutions, int idx, String restored, int count) &#123; if (count &gt; 4) return; if (count == 4 &amp;&amp; idx == ip.length()) solutions.add(restored); for (int i=1; i&lt;4; i++) &#123; if (idx+i &gt; ip.length()) break; String s = ip.substring(idx,idx+i); if ((s.startsWith(&quot;0&quot;) &amp;&amp; s.length()&gt;1) || (i==3 &amp;&amp; Integer.parseInt(s) &gt;= 256)) continue; restoreIp(ip, solutions, idx+i, restored+s+(count==3?&quot;&quot; : &quot;.&quot;), count+1); &#125;&#125; https://discuss.leetcode.com/topic/6304/my-concise-ac-java-code My concise AC java code the basic idea is to make three cuts into the string, separating it into four parts, each part contains 1 ~ 3 digits and it must be &lt; 255. 12345678910111213141516171819202122static List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; ans = new ArrayList&lt;String&gt;(); int len = s.length(); for (int i = 1; i &lt;=3; ++i)&#123; // first cut if (len-i &gt; 9) continue; for (int j = i+1; j&lt;=i+3; ++j)&#123; //second cut if (len-j &gt; 6) continue; for (int k = j+1; k&lt;=j+3 &amp;&amp; k&lt;len; ++k)&#123; // third cut int a,b,c,d; // the four int&apos;s seperated by &quot;.&quot; a = Integer.parseInt(s.substring(0,i)); b = Integer.parseInt(s.substring(i,j)); // notice that &quot;01&quot; can be parsed into 1. Need to deal with that later. c = Integer.parseInt(s.substring(j,k)); d = Integer.parseInt(s.substring(k)); if (a&gt;255 || b&gt;255 || c&gt;255 || d&gt;255) continue; String ip = a+&quot;.&quot;+b+&quot;.&quot;+c+&quot;.&quot;+d; if (ip.length()&lt;len+3) continue; // this is to reject those int&apos;s parsed from &quot;01&quot; or &quot;00&quot;-like substrings ans.add(ip); &#125; &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/20009/easy-java-code-of-backtracking-within-16-lines Easy Java code of backtracking within 16 lines 12345678910111213141516171819public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); helper(s,&quot;&quot;,res,0); return res; &#125; public void helper(String s, String tmp, List&lt;String&gt; res,int n)&#123; if(n==4)&#123; if(s.length()==0) res.add(tmp.substring(0,tmp.length()-1)); //substring here to get rid of last &apos;.&apos; return; &#125; for(int k=1;k&lt;=3;k++)&#123; if(s.length()&lt;k) continue; int val = Integer.parseInt(s.substring(0,k)); if(val&gt;255 || k!=String.valueOf(val).length()) continue; /*in the case 010 the parseInt will return len=2 where val=10, but k=3, skip this.*/ helper(s.substring(k),tmp+s.substring(0,k)+&quot;.&quot;,res,n+1); &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[092. Reverse Linked List II]]></title>
    <url>%2Fp%2F7b414406%2F</url>
    <content type="text"><![CDATA[30.0% https://leetcode.com/problems/reverse-linked-list-ii/?tab=Description Reverse a linked list from position m to n. Do it in-place and in one-pass. 1234For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. Note: Given m, n satisfy the following condition: 1 ≤ m ≤ n ≤ length of list. cpp 3ms, 7.08%, September 21, 2016 https://discuss.leetcode.com/topic/4980/share-my-14-lines-c-solution Share my 14 lines C++ solution 1234567891011121314151617ListNode *reverseBetween(ListNode *head, int m, int n) &#123; if(m==n)return head; n-=m; ListNode prehead(0); prehead.next=head; ListNode* pre=&amp;prehead; while(--m)pre=pre-&gt;next; ListNode* pstart=pre-&gt;next; while(n--) &#123; ListNode *p=pstart-&gt;next; pstart-&gt;next=p-&gt;next; p-&gt;next=pre-&gt;next; pre-&gt;next=p; &#125; return prehead.next;&#125; https://discuss.leetcode.com/topic/15034/12-lines-4ms-c 12-lines 4ms C++ The basic idea is as follows: (1) Create a new_head that points to head and use it to locate the immediate node before the m-th (notice that it is 1-indexed) node pre; (2) Set cur to be the immediate node after pre and at each time move the immediate node after cur (named move) to be the immediate node after pre. Repeat it for n - m times. 123456789101112131415161718class Solution &#123; public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; ListNode* new_head = new ListNode(0); new_head -&gt; next = head; ListNode* pre = new_head; for (int i = 0; i &lt; m - 1; i++) pre = pre -&gt; next; ListNode* cur = pre -&gt; next; for (int i = 0; i &lt; n - m; i++) &#123; ListNode* move = cur -&gt; next; cur -&gt; next = move -&gt; next; move -&gt; next = pre -&gt; next; pre -&gt; next = move; &#125; return new_head -&gt; next; &#125;&#125;; python 56ms, September 21, 2016 https://discuss.leetcode.com/topic/10378/python-one-pass-iterative-solution Python one pass iterative solution The idea is simple and intuitive: find linkedlist [m, n], reverse it, then connect m with n+1, connect n with m-1 1234567891011121314151617181920212223242526272829class Solution: # @param head, a ListNode # @param m, an integer # @param n, an integer # @return a ListNode def reverseBetween(self, head, m, n): if m == n: return head dummyNode = ListNode(0) dummyNode.next = head pre = dummyNode for i in range(m - 1): pre = pre.next # reverse the [m, n] nodes reverse = None cur = pre.next for i in range(n - m + 1): next = cur.next cur.next = reverse reverse = cur cur = next pre.next.next = cur pre.next = reverse return dummyNode.next https://discuss.leetcode.com/topic/27852/python-implementation-and-detailed-explanation Python implementation and detailed explanation For List with [1, 2, 3, 4, 5], supposed m == 2 and n == 4 Step1: The part I need to reversed is node 2 to node 4, which has n - m + 1 = 3 nodes. Therefore, I would like to maintain a window with n - m + 1 nodes with the window’s head whead and window’s tail wtail, then if whead is head, wtail would be the next n-m node from head. [123]45 =&gt; whead is 1 and wtail is 3 Step2: And to get to the right reversed portion we want, we need to shift the window m-1 times 1[234]5 =&gt; whead is 2 and wtail is 4 Step3: Isolate the nodes inside the window, reverse the window as Reverse Linked List Step4: combine the outside node with reversed node. To do so, I need to record the head outside the window ohead, and the tail outside the window otail ohead is 1, otail is 5 1-[432]-5 Implementation detail: Since in step 4, you need to let ohead.next = reversed_headIf you create a dummy node, you can save some lines for m == 1 cases, where ohead would be None and ohead.next would fail the program. 12345678910111213141516171819202122232425class Solution(object): def reverseBetween(self, head, m, n): if m &gt;= n: return head #Step 1# ohead = dummy = ListNode(0) whead = wtail = head dummy.next = head for i in range(n-m): wtail = wtail.next #Step 2# for i in range(m-1): ohead, whead, wtail = whead, whead.next, wtail.next #Step 3# otail, wtail.next = wtail.next, None revhead, revtail = self.reverse(whead) #Step 4# ohead.next, revtail.next = revhead, otail return dummy.next def reverse(self, head): pre, cur, tail = None, head, head while cur: cur.next, pre, cur = pre, cur, cur.next return pre, tail java 0ms, 13.07%, September 21, 2016 https://discuss.leetcode.com/topic/8976/simple-java-solution-with-clear-explanation Simple Java solution with clear explanation Simply just reverse the list along the way using 4 pointers: dummy, pre, start, then 123456789101112131415161718192021222324252627public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(head == null) return null; ListNode dummy = new ListNode(0); // create a dummy node to mark the head of this list dummy.next = head; ListNode pre = dummy; // make a pointer pre as a marker for the node before reversing for(int i = 0; i&lt;m-1; i++) pre = pre.next; ListNode start = pre.next; // a pointer to the beginning of a sub-list that will be reversed ListNode then = start.next; // a pointer to a node that will be reversed // 1 - 2 -3 - 4 - 5 ; m=2; n =4 ---&gt; pre = 1, start = 2, then = 3 // dummy-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 for(int i=0; i&lt;n-m; i++) &#123; start.next = then.next; then.next = pre.next; pre.next = then; then = start.next; &#125; // first reversing : dummy-&gt;1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4 // second reversing: dummy-&gt;1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish) return dummy.next; &#125; https://discuss.leetcode.com/topic/3250/share-my-java-code Share my Java code The basic idea is to build a sub-list when we hit Node m by adding the subsequent nodes to the head of the sub-list one by one until we hit Node n. Then connect the nodes before Node m, the sub-list and the nodes following Node n. 12345678910111213141516171819202122232425public ListNode reverseBetween(ListNode head, int m, int n) &#123; ListNode dummyhead = new ListNode(0); dummyhead.next = head; ListNode sublisthead = new ListNode(0); ListNode sublisttail = new ListNode(0); int count = 1; ListNode pre_cur = dummyhead, cur = head; while(count &lt;=n)&#123; ListNode temp = cur.next; if (count &lt; m) pre_cur = cur; else if (count == m)&#123; sublisttail = cur; sublisthead.next = cur; &#125;else if (count &gt; m)&#123; cur.next = sublisthead.next; sublisthead.next = cur; &#125; cur = temp; ++count; &#125; pre_cur.next = sublisthead.next; sublisttail.next = cur; return dummyhead.next;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[091. Decode Ways]]></title>
    <url>%2Fp%2F33438676%2F</url>
    <content type="text"><![CDATA[19.6% https://leetcode.com/problems/decode-ways/ A message containing letters from A-Z is being encoded to numbers using the following mapping: 1234&apos;A&apos; -&gt; 1&apos;B&apos; -&gt; 2...&apos;Z&apos; -&gt; 26 Given an encoded message containing digits, determine the total number of ways to decode it. For example,Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12). The number of ways decoding “12” is 2. 方法一： 两个两个的解决，一个一个的遍历，两个两个的验证，防止100这样的无法解析的。 对于数字，有两种解码方式。 一种是s[i-2] + ‘i-1, i’（i-1,i组合成一个字母），一种是s[i-1] + ‘i’ （i自己组合成一个方式） 首先，如果s[i] == ‘0’这种情况下，s[i-1]解码失效，设定值为0 然后’i-1,i’组合成一个字母的话， 就可以更新s[i]解码方式为s[i-1]和s[i-2]的和了 如果组合不成字母，则s[i] = s[i-1] 0ms, 73.36%, September 20, 2016 https://discuss.leetcode.com/topic/7025/a-concise-dp-solution 123456789101112131415161718192021class Solution &#123;public: int numDecodings(string s) &#123; if(!s.size() || s.front() == &apos;0&apos;) return 0; // r2: decode ways of s[i-2] , r1: decode ways of s[i-1] int r1 = 1, r2 = 1; for(int i=1; i&lt;s.size(); i++)&#123; // zero voids ways of the last because zero cannot be used separately if(s[i] == &apos;0&apos;) r1 = 0; // possible two-digit letter, so new r1 is sum of both while new r2 is the old r1 if(s[i-1] == &apos;1&apos; || s[i-1] == &apos;2&apos; &amp;&amp; s[i] &lt;= &apos;6&apos;)&#123; r1 = r1 + r2; r2 = r1 - r2; &#125; // one-digit letter, no new way added else r2 = r1; &#125; return r1; &#125;&#125;; 我的代码实现： 两个变量，r1， r2，一个是遍历到i时，r1表示，从开始至i-2位时的decode ways r2表示开始至i-1的decode ways 更新时，新的r1显然是等于r2。 新的r2，要从r1和r2及他们后面一两位的情况，是否合法去判断。 12345678910111213141516171819class Solution &#123;public: int numDecodings(string s) &#123; // string的函数front() if(s.empty() || s.front()=='0') return 0; int r1=1, r2=1; for(int i=1; i&lt;s.size(); i++)&#123; int nr2 = 0; if(s[i]!='0') nr2 += r2; if(s[i-1]=='1' || s[i-1]=='2'&amp;&amp;s[i]&lt;='6') nr2 += r1; r1 = r2; r2 = nr2; &#125; return r2; &#125;&#125;; 我的代码实现二: 1234567891011121314151617181920class Solution &#123;public: int numDecodings(string s) &#123; int n = s.size(); if(n&lt;1) return 0; // r1 i-2, r2 i-1 int r1 = 1, r2 = s[0]&gt;='1' &amp;&amp; s[1]&lt;='9' ? 1 : 0; for(int i=1; i&lt;n; i++)&#123; int nr1 = r2; int nr2 = 0; if(s[i]&gt;='1' &amp;&amp; s[i]&lt;='9') nr2 += r2; if(s[i-1]=='1' || s[i-1]=='2' &amp;&amp; s[i]&lt;='6') nr2 += r1; r1 = nr1; r2 = nr2; &#125; return r2; &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/15440/my-c-0ms-dp-solution-o-n My c++ 0ms DP solution O(n) 12345678910111213141516171819202122int n = s.size(); if(n == 0 || s[0] == &apos;0&apos;) return 0; if(n == 1) return 1; int res = 0,fn_1 = 1,fn_2 = 1; for(int i = 1;i &lt; n;i++)&#123; int temp = fn_1; if(isValid(s[i])&amp;&amp;isValid(s[i-1],s[i])) res+=fn_1+fn_2; if(!isValid(s[i])&amp;&amp;isValid(s[i-1],s[i])) res+=fn_2; if(isValid(s[i])&amp;&amp;!isValid(s[i-1],s[i])) res+=fn_1; if(!isValid(s[i])&amp;&amp;!isValid(s[i-1],s[i])) return 0; fn_1 = res; fn_2 = temp; res = 0; &#125; return fn_1;&#125;bool isValid(char a,char b)&#123; return a == &apos;1&apos;||(a == &apos;2&apos; &amp;&amp; b &lt;=&apos;6&apos;);&#125;bool isValid(char a)&#123; return a != &apos;0&apos;;&#125; python62ms, 23.31%, September 20, 2016 https://discuss.leetcode.com/topic/19042/1-liner-o-1-space w tells the number of ways v tells the previous number of ways d is the current digit p is the previous digit 12345678910class Solution(object): def numDecodings(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; v, w, p = 0, int(s&gt;&apos;&apos;), &apos;&apos; for d in s: v, w, p = w, (d&gt;&apos;0&apos;)*w + (9&lt;int(p+d)&lt;27)*v, d return w 12def numDecodings(self, s): return reduce(lambda(v,w,p),d:(w,(d&gt;&apos;0&apos;)*w+(9&lt;int(p+d)&lt;27)*v,d),s,(0,s&gt;&apos;&apos;,&apos;&apos;))[1]*1 java5ms, 27.87%, September 20, 2016 https://discuss.leetcode.com/topic/35840/java-clean-dp-solution-with-explanation I used a dp array of size n + 1 to save subproblem solutions. dp[0] means an empty string will have one way to decode, dp[1] means the way to decode a string of size 1. I then check one digit and two digit combination and save the results along the way. In the end, dp[n] will be the end result. 123456789101112131415161718public class Solution &#123; public int numDecodings(String s) &#123; if(s == null || s.length() == 0) return 0; int n = s.length(); int[] dp = new int[n+1]; dp[0] = 1; dp[1] = s.charAt(0) != &apos;0&apos; ? 1: 0; for(int i = 2; i&lt;=n; i++)&#123; int first = Integer.valueOf(s.substring(i-1, i)); int second = Integer.valueOf(s.substring(i-2, i)); if(first &gt;= 1 &amp;&amp; first &lt;= 9) dp[i] += dp[i-1]; if(second &gt;= 10 &amp;&amp; second &lt;= 26) dp[i] += dp[i-2]; &#125; return dp[n]; &#125;&#125; https://discuss.leetcode.com/topic/2562/dp-solution-java-for-reference DP Solution (Java) for reference 12345678910111213141516public class Solution &#123; public int numDecodings(String s) &#123; int n = s.length(); if (n == 0) return 0; int[] memo = new int[n+1]; memo[n] = 1; memo[n-1] = s.charAt(n-1) != &apos;0&apos; ? 1 : 0; for (int i = n - 2; i &gt;= 0; i--) if (s.charAt(i) == &apos;0&apos;) continue; else memo[i] = (Integer.parseInt(s.substring(i,i+2))&lt;=26) ? memo[i+1]+memo[i+2] : memo[i+1]; return memo[0]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[090. Subsets II]]></title>
    <url>%2Fp%2Ff25f3971%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/subsets-ii/ Given a collection of integers that might contain duplicates, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. 1234567891011For example,If nums = [1,2,2], a solution is:[ [2], [1], [1,2,2], [2,2], [1,2], []] 方法一： 回溯法 针对重复的，去除就好了。 https://discuss.leetcode.com/topic/13543/accepted-10ms-c-solution-use-backtracking-only-10-lines-easy-understand Accepted 10ms c++ solution use backtracking, only 10 lines, easy understand. The characteristics of C++ reference is an outstanding tool for backtracking algorithm! let us use [1,2,3,4] as an example to explain my solution: 12345678910subsets([1,2,3,4]) = [] // push(1) [1, subsets([2,3,4])] // if push N times in subsets([2,3,4]), the pop times is also N, so vec is also [1] after backtrack. // pop(), push(2) [2, subsets([3,4])] // pop(), push(3) [3, subsets([4])] // pop(), push(4) [4, subsets([])] // pop() Accepted 10ms c++ solution use backtracking for Subsets 12345678910111213141516171819class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; subsets(std::vector&lt;int&gt; &amp;nums) &#123; std::sort(nums.begin(), nums.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; vec; subsets(res, nums, vec, 0); return res; &#125;private: void subsets(std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;nums, std::vector&lt;int&gt; &amp;vec, int begin) &#123; res.push_back(vec); for (int i = begin; i != nums.size(); ++i) &#123; vec.push_back(nums[i]); subsets(res, nums, vec, i + 1); vec.pop_back(); &#125; &#125;&#125;; Accepted 10ms c++ solution use backtracking for Subsets II 1234567891011121314151617181920class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; subsetsWithDup(std::vector&lt;int&gt; &amp;nums) &#123; std::sort(nums.begin(), nums.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; vec; subsetsWithDup(res, nums, vec, 0); return res; &#125;private: void subsetsWithDup(std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;nums, std::vector&lt;int&gt; &amp;vec, int begin) &#123; res.push_back(vec); for (int i = begin; i != nums.size(); ++i) if (i == begin || nums[i] != nums[i - 1]) &#123; vec.push_back(nums[i]); subsetsWithDup(res, nums, vec, i + 1); vec.pop_back(); &#125; &#125;&#125;; 我的代码实现 加入了sort，防止nums={4，4，1，4}这种情况 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; subs; vector&lt;int&gt; sub; if(nums.empty()) return subs; sort(nums.begin(), nums.end()); dfs(subs, sub, 0, nums); return subs; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; subs, vector&lt;int&gt;&amp; sub, int k, vector&lt;int&gt;&amp; nums)&#123; subs.push_back(sub); for(int i=k; i&lt;nums.size(); i++)&#123; if(i!=k &amp;&amp; nums[i]==nums[i-1]) continue; sub.push_back(nums[i]); dfs(subs, sub, i+1, nums); sub.pop_back(); &#125; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs; vector&lt;int&gt; sub; dfs(nums, sub, subs, 0); return subs; &#125; void dfs(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; sub, vector&lt;vector&lt;int&gt;&gt;&amp; subs, int k)&#123; subs.push_back(sub); for(int i=k; i&lt;nums.size(); i++)&#123; if(i!=k &amp;&amp; nums[i]==nums[i-1]) continue; sub.push_back(nums[i]); dfs(nums, sub, subs, i+1); sub.pop_back(); &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/4661/c-solution-and-explanation C++ solution and explanation To solve this problem, it is helpful to first think how many subsets are there. If there is no duplicate element, the answer is simply 2^n, where n is the number of elements. This is because you have two choices for each element, either putting it into the subset or not. So all subsets for this no-duplicate set can be easily constructed:num of subset (1 to 2^0) empty set is the first subset (2^0+1 to 2^1) add the first element into subset from (1) (2^1+1 to 2^2) add the second element into subset (1 to 2^1) (2^2+1 to 2^3) add the third element into subset (1 to 2^2) …. (2^(n-1)+1 to 2^n) add the nth element into subset(1 to 2^(n-1)) Then how many subsets are there if there are duplicate elements? We can treat duplicate element as a spacial element. For example, if we have duplicate elements (5, 5), instead of treating them as two elements that are duplicate, we can treat it as one special element 5, but this element has more than two choices: you can either NOT put it into the subset, or put ONE 5 into the subset, or put TWO 5s into the subset. Therefore, we are given an array (a1, a2, a3, …, an) with each of them appearing (k1, k2, k3, …, kn) times, the number of subset is (k1+1)(k2+1)…(kn+1). We can easily see how to write down all the subsets similar to the approach above. 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; subsetsWithDup(vector&lt;int&gt; &amp;S) &#123; vector&lt;vector&lt;int&gt; &gt; totalset = &#123;&#123;&#125;&#125;; sort(S.begin(),S.end()); for(int i=0; i&lt;S.size();)&#123; int count = 0; // num of elements are the same while(count + i&lt;S.size() &amp;&amp; S[count+i]==S[i]) count++; int previousN = totalset.size(); for(int k=0; k&lt;previousN; k++)&#123; vector&lt;int&gt; instance = totalset[k]; for(int j=0; j&lt;count; j++)&#123; instance.push_back(S[i]); totalset.push_back(instance); &#125; &#125; i += count; &#125; return totalset; &#125;&#125;; https://discuss.leetcode.com/topic/3601/simple-iterative-solution Simple iterative solution If we want to insert an element which is a dup, we can only insert it after the newly inserted elements from last step. 123456789101112131415vector&lt;vector&lt;int&gt; &gt; subsetsWithDup(vector&lt;int&gt; &amp;S) &#123; sort(S.begin(), S.end()); vector&lt;vector&lt;int&gt;&gt; ret = &#123;&#123;&#125;&#125;; int size = 0, startIndex = 0; for (int i = 0; i &lt; S.size(); i++) &#123; startIndex = i &gt;= 1 &amp;&amp; S[i] == S[i - 1] ? size : 0; size = ret.size(); for (int j = startIndex; j &lt; size; j++) &#123; vector&lt;int&gt; temp = ret[j]; temp.push_back(S[i]); ret.push_back(temp); &#125; &#125; return ret;&#125; python https://discuss.leetcode.com/topic/8541/simple-python-solution-without-extra-space Simple python solution without extra space. 123456789101112class Solution: # @param num, a list of integer # @return a list of lists of integer def subsetsWithDup(self, S): res = [[]] S.sort() for i in range(len(S)): if i == 0 or S[i] != S[i - 1]: l = len(res) for j in range(len(res) - l, len(res)): res.append(res[j] + [S[i]]) return res if S[i] is same to S[i - 1], then it needn’t to be added to all of the subset, just add it to the last l subsets which are created by adding S[i - 1] java https://discuss.leetcode.com/topic/22638/very-simple-and-fast-java-solution Very simple and fast java solution 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; each = new ArrayList&lt;&gt;(); helper(res, each, 0, nums); return res;&#125;public void helper(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; each, int pos, int[] n) &#123; if (pos &lt;= n.length) &#123; res.add(each); &#125; int i = pos; while (i &lt; n.length) &#123; each.add(n[i]); helper(res, new ArrayList&lt;&gt;(each), i + 1, n); each.remove(each.size() - 1); i++; while (i &lt; n.length &amp;&amp; n[i] == n[i - 1]) &#123;i++;&#125; &#125; return;&#125; The Basic idea is: use “while (i &lt; n.length &amp;&amp; n[i] == n[i - 1]) {i++;}” to avoid the duplicate. For example, the input is 2 2 2 3 4. Consider the helper function. The process is: each.add(n[i]); –&gt; add first 2 (index 0) helper(res, new ArrayList&lt;&gt;(each), i + 1, n); –&gt; go to recursion part, list each is while (i &lt; n.length &amp;&amp; n[i] == n[i - 1]) {i++;} –&gt; after this, i == 3, add the element as in subset I https://discuss.leetcode.com/topic/16666/standard-dfs-java-solution Standard DFS Java Solution 123456789101112131415161718public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result= new ArrayList&lt;&gt;(); dfs(nums,0,new ArrayList&lt;Integer&gt;(),result); return result; &#125; public void dfs(int[] nums,int index,List&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; result)&#123; result.add(path); for(int i=index;i&lt;nums.length;i++)&#123; if(i&gt;index&amp;&amp;nums[i]==nums[i-1]) continue; List&lt;Integer&gt; nPath= new ArrayList&lt;&gt;(path); nPath.add(nums[i]); dfs(nums,i+1,nPath,result); &#125; &#125;&#125; https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; 12345678910111213141516171819public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i=start; i&lt;nums.length; i++)&#123; if(i==start || nums[i] != nums[i-1])&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i+1); tempList.remove(tempList.size()-1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[089. Gray Code]]></title>
    <url>%2Fp%2F57e82460%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/gray-code/ The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. 123456For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:00 - 001 - 111 - 310 - 2 Note: For a given n, a gray code sequence is not uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence according to the above definition. For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that. java https://discuss.leetcode.com/topic/8557/an-accepted-three-line-solution-in-java An accepted three line solution in JAVA 12345public List&lt;Integer&gt; grayCode(int n) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; 1&lt;&lt;n; i++) result.add(i ^ i&gt;&gt;1); return result;&#125; The idea is simple. G(i) = i^ (i/2). 1ms, September 20, 2016 https://discuss.leetcode.com/topic/3021/share-my-solution Share my solution My idea is to generate the sequence iteratively. For example, when n=3, we can get the result based on n=2.00,01,11,10 -&gt; (000,001,011,010 ) (110,111,101,100). The middle two numbers only differ at their highest bit, while the rest numbers of part two are exactly symmetric of part one. It is easy to see its correctness. Code is simple: 123456789101112public class Solution &#123; public List&lt;Integer&gt; grayCode(int n) &#123; List&lt;Integer&gt; rs = new ArrayList&lt;Integer&gt;(); rs.add(0); for(int i=0; i&lt;n; i++)&#123; int size = rs.size(); for(int k=size-1; k&gt;=0; k--) rs.add(rs.get(k) | 1&lt;&lt;i); &#125; return rs; &#125;&#125; cpp 3ms, 38.18%, September 20, 2016 https://discuss.leetcode.com/topic/1011/what-is-the-best-solution-for-gray-code-problem-no-extra-space-used-and-no-recursion What is the best solution for Gray Code problem? No extra space used and no recursion? I have a solution here which takes O(1) on space and no recursion used. Is this the best possible solution? (I combined the base cases in the loop as mike3 does. Thanks mike3!) 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; result(1, 0); for(int i=0; i&lt;n; i++)&#123; int curCount = result.size(); while(curCount)&#123; curCount--; int curNum = result[curCount]; curNum += (1&lt;&lt;i); result.push_back(curNum); &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/3997/share-my-simple-way-of-this-problem-_ Share my simple way of this problem^_^ 12345678910111213class Solution &#123;public: vector&lt;int&gt; grayCode(int n) &#123; int N(1 &lt;&lt; n), tmp; vector&lt;int&gt; result; for(int i(0); i &lt; N; i++) &#123; tmp = i &lt;&lt; 1; result.push_back((tmp^i) &gt;&gt; 1); &#125; return result; &#125;&#125;; As we known: 1Gi = Bi+1 xor Bi For example, trans binay ‘001’ to gray code: 1tmp = 001 &lt;&lt; 1 then, 1234bin 0 0 0 1tmp 0 0 1 0-xor------------ 0 0 1 1 and the gray code is: 10 0 1 1 &gt;&gt; 1 (ignore last bit) =&gt; 0 0 1 https://discuss.leetcode.com/topic/14776/4ms-simple-iterative-solution 4ms simple iterative solution 1234567891011vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; result = &#123; 0 &#125;; int t = 1; for(int i = 0; i&lt;n; i++) &#123; for(int j = result.size() - 1; j &gt;= 0; j--) result.push_back(result[j]^t); t &lt;&lt;= 1; &#125; return result;&#125; python 52ms, September 20, 2016 https://discuss.leetcode.com/topic/4883/one-liner-python-solution-with-demo-in-comments One-liner Python solution (with demo in comments) All you need is a bit of careful thought. Btw, it’s extremely useful to write down your thought/demo in comments before you actually start to write the code, especially during interview. Even if you do not solve the problem finally, the interviewer at least get to know what you’re thinking. And if you don’t get the problem right, he/she will have a chance to correct you. 1234567891011121314151617181920class Solution: # @return a list of integers &apos;&apos;&apos; from up to down, then left to right 0 1 11 110 10 111 101 100 start: [0] i = 0: [0, 1] i = 1: [0, 1, 3, 2] i = 2: [0, 1, 3, 2, 6, 7, 5, 4] &apos;&apos;&apos; def grayCode(self, n): results = [0] for i in range(n): results += [x + pow(2, i) for x in reversed(results)] return results]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[088. Merge Sorted Array]]></title>
    <url>%2Fp%2F505da9dc%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/merge-sorted-array/ Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 方法一： 常规解法，双指针分别指向尾部，从后向前，依次进行。 1234567891011121314151617class Solution &#123;public: void merge(int A[], int m, int B[], int n) &#123; int i=m-1; int j=n-1; int k = m+n-1; while(i &gt;=0 &amp;&amp; j&gt;=0) &#123; if(A[i] &gt; B[j]) A[k--] = A[i--]; else A[k--] = B[j--]; &#125; while(j&gt;=0) A[k--] = B[j--]; &#125;&#125;; 方法二： 类似于1，但是要思考清楚其中的逻辑。 j&gt;=0是必要条件，j &lt; 0就不进行循环了 对于i&gt;=0，并且nums1大的选择它，否则nums2 123456789class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int i = m - 1, j = n - 1, tar = m + n - 1; while (j &gt;= 0) &#123; nums1[tar--] = i &gt;= 0 &amp;&amp; nums1[i] &gt; nums2[j] ? nums1[i--] : nums2[j--]; &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/2461/this-is-my-ac-code-may-help-you This is my AC code, may help you 1234567891011121314151617class Solution &#123;public: void merge(int A[], int m, int B[], int n) &#123; int i=m-1; int j=n-1; int k = m+n-1; while(i &gt;=0 &amp;&amp; j&gt;=0) &#123; if(A[i] &gt; B[j]) A[k--] = A[i--]; else A[k--] = B[j--]; &#125; while(j&gt;=0) A[k--] = B[j--]; &#125;&#125;; https://discuss.leetcode.com/topic/16946/4ms-c-solution-with-single-loop 4ms C++ solution with single loop This code relies on the simple observation that once all of the numbers from nums2 have been merged into nums1, the rest of the numbers in nums1 that were not moved are already in the correct place. 123456789class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int i = m - 1, j = n - 1, tar = m + n - 1; while (j &gt;= 0) &#123; nums1[tar--] = i &gt;= 0 &amp;&amp; nums1[i] &gt; nums2[j] ? nums1[i--] : nums2[j--]; &#125; &#125;&#125;; 4ms, 10.91%, April.23rd, 2016 12345678910class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int ia = m - 1, ib = n - 1, ic = m + n - 1; while(ia &gt;= 0 &amp;&amp; ib &gt;= 0)&#123; nums1[ic--] = nums1[ia] &gt; nums2[ib] ? nums1[ia--] : nums2[ib--]; &#125; while(ib &gt;= 0) nums1[ic--] = nums2[ib--]; &#125;&#125;; 4ms, 10.91%, April.23rd, 2016 1234567class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; for(int i=m-1, j=n-1, k=m+n-1; j&gt;=0; ) nums1[k--] = i&gt;=0 &amp;&amp; nums1[i]&gt;nums2[j]? nums1[i--]: nums2[j--]; &#125;&#125;; https://discuss.leetcode.com/topic/11508/1-line-solution 1 Line Solution 1while(n&gt;0) A[m+n-1] = (m==0||B[n-1] &gt; A[m-1]) ? B[--n] : A[--m]; https://discuss.leetcode.com/topic/35761/2-lines-very-simple-c-solution 2 lines very simple C++ solution 1234void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; for(int i=m-1, j=n-1, k=m+n-1; j&gt;=0; ) nums1[k--] = i&gt;=0 &amp;&amp; nums1[i]&gt;nums2[j]? nums1[i--]: nums2[j--];&#125; python 52ms, 33.16%, April.23rd, 2016 https://leetcode.com/discuss/47608/beautiful-python-solution Beautiful Python Solution 123456789101112131415161718class Solution(object): def merge(self, nums1, m, nums2, n): &quot;&quot;&quot; :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. &quot;&quot;&quot; while m &gt; 0 and n &gt; 0: if nums1[m-1] &gt;= nums2[n-1]: nums1[m+n-1] = nums1[m-1] m -= 1 else: nums1[m+n-1] = nums2[n-1] n -= 1 if n &gt; 0: nums1[:n] = nums2[:n] java https://discuss.leetcode.com/topic/10257/3-line-java-solution 3 line Java Solution 12345public void merge(int A[], int m, int B[], int n) &#123; int i=m-1, j=n-1, k=m+n-1; while (i&gt;-1 &amp;&amp; j&gt;-1) A[k--]= (A[i]&gt;B[j]) ? A[i--] : B[j--]; while (j&gt;-1) A[k--]=B[j--];&#125; https://discuss.leetcode.com/topic/11919/share-my-accepted-java-solution Share my accepted Java solution! 1234567891011public class Solution &#123; public void merge(int A[], int m, int B[], int n) &#123; int i = m - 1, j = n - 1, k = m + n - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; A[k--] = A[i] &gt; B[j] ? A[i--] : B[j--]; &#125; while(j &gt;= 0) &#123; A[k--] = B[j--]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[087. Scramble String]]></title>
    <url>%2Fp%2Fae9f5ec9%2F</url>
    <content type="text"><![CDATA[29.2% https://leetcode.com/problems/scramble-string/ Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. 123456789Below is one possible representation of s1 = &quot;great&quot;: great / \ gr eat / \ / \g r e at / \ a t To scramble the string, we may choose any non-leaf node and swap its two children. 12345678910For example, if we choose the node &quot;gr&quot; and swap its two children, it produces a scrambled string &quot;rgeat&quot;. rgeat / \ rg eat / \ / \r g e at / \ a tWe say that &quot;rgeat&quot; is a scrambled string of &quot;great&quot;. 12345678910Similarly, if we continue to swap the children of nodes &quot;eat&quot; and &quot;at&quot;, it produces a scrambled string &quot;rgtae&quot;. rgtae / \ rg tae / \ / \r g ta e / \ t aWe say that &quot;rgtae&quot; is a scrambled string of &quot;great&quot;. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1. 方法一： 递归， 根据题意来进行判断。判断时排除字符个数都不相同的情况。 然后考虑各个叶子节点的交换。 3ms, 85.03%, September 22, 2016 https://discuss.leetcode.com/topic/14337/share-my-4ms-c-recursive-solution Share my 4ms c++ recursive solution Assume the strings are all lower case letters 123456789101112131415161718192021222324252627class Solution &#123;public: bool isScramble(string s1, string s2) &#123; if(s1 == s2) return true; int len = s1.length(); int count[26] = &#123;0&#125;; for(int i=0; i&lt;len; i++)&#123; count[s1[i]-&apos;a&apos;]++; count[s2[i]-&apos;a&apos;]--; &#125; for(int i=0; i&lt;26; i++)&#123; if(count[i]!=0) return false; &#125; for(int i=1; i&lt;=len-1; i++)&#123; if(isScramble(s1.substr(0, i), s2.substr(0, i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i))) return true; if(isScramble(s1.substr(0, i), s2.substr(len-i)) &amp;&amp; isScramble((s1.substr(i)), s2.substr(0, len-i))) return true; &#125; return false; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526class Solution &#123;public: bool isScramble(string s1, string s2) &#123; if(s1==s2) return true; int m = s1.size(), n = s2.size(); if(m!=n) return false; vector&lt;int&gt; v(26, 0); for(int i=0; i&lt;m; i++)&#123; v[s1[i]-'a']++; v[s2[i]-'a']--; &#125; // 下面是i&lt;26不是i&lt;m, 不要手误 for(int i=0; i&lt;26; i++) if(v[i]!=0) return false; for(int i=1; i&lt;m; i++)&#123; // substr(0, i)从index=0开始，顺着i个，及0至i-1。substr(i)从index=i的字符串 if(isScramble(s1.substr(0, i), s2.substr(0, i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i))) return true; // 下面是m-i，表明s1的前i个与s2的后i个是否相等 if(isScramble(s1.substr(0, i), s2.substr(m-i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(0, m-i))) return true; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/20094/my-c-solutions-recursion-with-cache-dp-recursion-with-cache-and-pruning-with-explanation-4ms My C++ solutions (recursion with cache , DP, recursion with cache and pruning) with explanation (4ms) The basic idea is to divide s1(s2) into two substrings with length k and len-k and check if the two substrings s1[0..k-1] and s1[k, len-1] are the scrambles of s2[0..k-1] and s2[k,len-1] or s2[len-k, len-1] and s2[0..len-k-1] via recursion. The straigtforward recursion will be very slow due to many repeated recursive function calls. To speed up the recursion, we can use an unordered_map isScramblePair to save intermediate results. The key used here is s1+s2, but other keys are also possible (e.g. using indices) 123456789101112131415161718192021222324252627282930class Solution &#123; bool DP_helper(unordered_map&lt;string, bool&gt; &amp;isScramblePair, string s1, string s2) &#123; int i,len = s1.size(); bool res = false; if(0==len) return true; else if(1==len) return s1 == s2; else &#123; if(isScramblePair.count(s1+s2)) return isScramblePair[s1+s2]; // checked before, return intermediate result directly if(s1==s2) res=true; else&#123; for(i=1; i&lt;len &amp;&amp; !res; ++i) &#123;//check s1[0..i-1] with s2[0..i-1] and s1[i..len-1] and s2[i..len-1] res = res || (DP_helper(isScramblePair, s1.substr(0,i), s2.substr(0,i)) &amp;&amp; DP_helper(isScramblePair, s1.substr(i,len-i), s2.substr(i,len-i))); //if no match, then check s1[0..i-1] with s2[len-k.. len-1] and s1[i..len-1] and s2[0..len-i] res = res || (DP_helper(isScramblePair, s1.substr(0,i), s2.substr(len-i,i)) &amp;&amp; DP_helper(isScramblePair, s1.substr(i,len-i), s2.substr(0,len-i))); &#125; &#125; return isScramblePair[s1+s2]= res; //save the intermediate results &#125; &#125; public: bool isScramble(string s1, string s2) &#123; unordered_map&lt;string, bool&gt; isScramblePair; return DP_helper(isScramblePair, s1, s2); &#125; &#125;; The recursive version has exponential complexity. To further improve the performance, we can use bottom-up DP, which is O(N^4) complexity. Here we build a table isS[len][i][j], which indicates whether s1[i..i+len-1] is a scramble of s2[j..j+len-1]. 123456789101112131415161718192021222324252627class Solution &#123;public: bool isScramble(string s1, string s2) &#123; int sSize = s1.size(), len, i, j, k; if(0==sSize) return true; if(1==sSize) return s1==s2; bool isS[sSize+1][sSize][sSize]; for(i=0; i&lt;sSize; ++i) for(j=0; j&lt;sSize; ++j) isS[1][i][j] = s1[i] == s2[j]; for(len=2; len &lt;=sSize; ++len) for(i=0; i&lt;=sSize-len; ++i) for(j=0; j&lt;=sSize-len; ++j) &#123; isS[len][i][j] = false; for(k=1; k&lt;len &amp;&amp; !isS[len][i][j]; ++k) &#123; isS[len][i][j] = isS[len][i][j] || (isS[k][i][j] &amp;&amp; isS[len-k][i+k][j+k]); isS[len][i][j] = isS[len][i][j] || (isS[k][i+len-k][j] &amp;&amp; isS[len-k][i][j+k]); &#125; &#125; return isS[sSize][0][0]; &#125;&#125;; Furhtermore, in many cases, we found we can terminate our recursion early by pruning: i.e. by first checking if s1 and s2 have the same character set before we do recursion: if not, just terminate without recursion. This observation leads us to the following Recursion+cache+pruning version. Here the key of the cache changes to idx1sSize +idx2 + lensSize*sSize; 123456789101112131415161718192021222324252627282930313233class Solution &#123;private: bool DP_helper(string &amp;s1, string &amp;s2, int idx1, int idx2, int len, char isS[]) &#123; int sSize = s1.size(),i, j, k, hist[26] , zero_count =0; if(isS[(len*sSize+idx1)*sSize+idx2]) return isS[(len*sSize+idx1)*sSize+idx2]==1; bool res = false; fill_n(hist, 26, 0); for(k=0; k&lt;len;++k) &#123; // check if s1[idx1:idx1+len-1] and s2[idx2:idx2+len-1] have same characters zero_count += (0==hist[s1[idx1+k]-&apos;a&apos;]) - (0== ++hist[s1[idx1+k]-&apos;a&apos;]); zero_count += (0==hist[s2[idx2+k]-&apos;a&apos;]) - (0== --hist[s2[idx2+k]-&apos;a&apos;]); &#125; if(zero_count) &#123;isS[(len*sSize+idx1)*sSize+idx2] = 2; return false;&#125; //if not, return directly if(len==1) &#123;isS[(len*sSize+idx1)*sSize+idx2] = 1; return true;&#125; for(k=1;k&lt;len &amp;&amp; !res;++k) //otherwise, recursion with cache &#123; res = res || (DP_helper(s1, s2, idx1, idx2, k, isS) &amp;&amp; DP_helper(s1, s2, idx1+k, idx2+k, len-k, isS) ); res = res || (DP_helper(s1, s2, idx1+len-k, idx2, k, isS) &amp;&amp; DP_helper(s1, s2, idx1, idx2+k, len-k, isS) ); &#125; isS[(len*sSize+idx1)*sSize+idx2] = res?1:2; return res; &#125;public: bool isScramble(string s1, string s2) &#123; const int sSize = s1.size(); if(0==sSize) return true; char isS[(sSize+1)*sSize*sSize]; fill_n(isS, (sSize+1)*sSize*sSize, 0); return DP_helper(s1, s2, 0, 0, sSize, isS); &#125;&#125;; https://discuss.leetcode.com/topic/1195/any-better-solution Any better solution? My AC code is as below. I think it’s not very efficient. Is there any better solution? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;private: bool anagram(string &amp;s1, string &amp;s2)&#123; if(s1.size() != s2.size()) return false; unordered_map&lt;char, int&gt; m; int n = s1.size(); for(int i = 0; i &lt; n; ++i)&#123; if(m.find(s1[i]) != m.end())&#123; ++m[s1[i]]; &#125;else&#123; m[s1[i]] = 1; &#125; &#125; for(int i = 0; i &lt; n; ++i)&#123; if(m.find(s2[i]) != m.end())&#123; --m[s2[i]]; if(m[s2[i]] &lt; 0)&#123; return false; &#125; &#125;else&#123; return false; &#125; &#125; return true; &#125;public: bool isScramble(string s1, string s2) &#123; if(s1.size() != s2.size()) return false; if(s1 == s2) return true; int n = s1.size(); for(int i = 1; i &lt; n; ++i)&#123; string s11 = s1.substr(0, i); string s12 = s1.substr(i, n - i); string s21 = s2.substr(0, i); string s22 = s2.substr(i, n - i); string s23 = s2.substr(n - i, i); string s24 = s2.substr(0, n - i); if(anagram(s11, s21) &amp;&amp; anagram(s12, s22) &amp;&amp; isScramble(s11, s21) &amp;&amp; isScramble(s12, s22) || anagram(s11, s23) &amp;&amp; anagram(s12, s24) &amp;&amp; isScramble(s11, s23) &amp;&amp; isScramble(s12, s24))&#123; return true; &#125; &#125; return false; &#125;&#125;; The main idea is: separate s1 into two parts, namely –s11–, ——–s12——– separate s2 into two parts, namely –s21–, ——–s22——–, and test the corresponding part (s11 and s21 &amp;&amp; s12 and s22) with isScramble. separate s2 into two parts, namely ——–s23——–, –s24–, and test the corresponding part (s11 and s24 &amp;&amp; s12 and s23) with isScramble. Note that before testing each sub-part with isScramble, anagram is used first to test if the corresponding parts are anagrams. If not, skip directly. https://discuss.leetcode.com/topic/8253/a-simple-solution-without-dp-in-c A simple solution without dp in C++ 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isScramble(string s1, string s2) &#123; int n = s1.length(); return judge(s1.c_str(), s2.c_str(), 0, n-1, 0, n-1); &#125; bool judge(const char* s1, const char* s2,int a,int b,int u, int v)&#123; if(b-a!=v-u) return false; if(b-a==0 &amp;&amp; s1[a]==s2[u]) return true; int cnt[256]=&#123;0&#125;; for(int i=a;i&lt;=b;++i)&#123; cnt[s1[i]]++; &#125; for(int i=u;i&lt;=v;++i)&#123; cnt[s2[i]]--; &#125; for(int i=0;i&lt;256;++i)&#123; if(cnt[i]!=0) return false; &#125; for(int i=a;i&lt;b;++i)&#123; if(judge(s1,s2,a,i,u,u+i-a) &amp;&amp; judge(s1,s2,i+1,b,v-(b-i-1),v))&#123; return true; &#125; if(judge(s1,s2,a,i,v-(i-a),v) &amp;&amp; judge(s1,s2,i+1,b,u,u+b-(i+1)))&#123; return true; &#125; &#125; return false; &#125;&#125;; Surprisingly, it runs very fast even without dynamic programming. python https://discuss.leetcode.com/topic/9726/python-recursive-solution Python recursive solution 1234567891011121314class Solution:# @return a booleandef isScramble(self, s1, s2): n, m = len(s1), len(s2) if n != m or sorted(s1) != sorted(s2): return False if n &lt; 4 or s1 == s2: return True f = self.isScramble for i in range(1, n): if f(s1[:i], s2[:i]) and f(s1[i:], s2[i:]) or \ f(s1[:i], s2[-i:]) and f(s1[i:], s2[:-i]): return True return False java 4ms, 91.08%, September 22, 2016 https://discuss.leetcode.com/topic/19158/accepted-java-solution Accepted Java solution 1234567891011121314151617181920public class Solution &#123; public boolean isScramble(String s1, String s2) &#123; if (s1.equals(s2)) return true; int[] letters = new int[26]; for (int i=0; i&lt;s1.length(); i++) &#123; letters[s1.charAt(i)-&apos;a&apos;]++; letters[s2.charAt(i)-&apos;a&apos;]--; &#125; for (int i=0; i&lt;26; i++) if (letters[i]!=0) return false; for (int i=1; i&lt;s1.length(); i++) &#123; if (isScramble(s1.substring(0,i), s2.substring(0,i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) return true; if (isScramble(s1.substring(0,i), s2.substring(s2.length()-i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(0,s2.length()-i))) return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[086. Partition List]]></title>
    <url>%2Fp%2Fdc466425%2F</url>
    <content type="text"><![CDATA[32.7% https://leetcode.com/problems/partition-list/ Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. 123For example,Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 方法一： 建立一个哑结点，这是这个方法的高明之处。 6ms, 29.86%, September 20, 2016 https://discuss.leetcode.com/topic/7005/very-concise-one-pass-solution 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; ListNode node1(0), node2(0); ListNode *p1 = &amp;node1, *p2 = &amp;node2; while(head)&#123; if(head-&gt;val &lt; x) p1 = p1-&gt;next = head; else p2 = p2 -&gt;next = head; head = head-&gt;next; &#125; p2-&gt;next = NULL; p1-&gt;next = node2.next; return node1.next; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; ListNode node1(0), node2(0); ListNode* p1 = &amp;node1, *p2 = &amp;node2; while(head)&#123; if(head-&gt;val &lt; x)&#123; p1-&gt;next = head; p1 = p1-&gt;next; &#125;else&#123; p2-&gt;next = head; p2 = p2-&gt;next; &#125; head = head-&gt;next; &#125; p1-&gt;next = node2.next; //此处用的是.,而不是-&gt;,为什么？ p2-&gt;next = NULL; return node1.next; // 此处也是.,不是-&gt;，因为不是指针？ &#125;&#125;; python 65ms, September 20, 2016 https://discuss.leetcode.com/topic/21417/python-concise-solution-with-dummy-nodes 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def partition(self, head, x): &quot;&quot;&quot; :type head: ListNode :type x: int :rtype: ListNode &quot;&quot;&quot; h1 = l1 = ListNode(0) h2 = l2 = ListNode(0) while head: if head.val &lt; x: l1.next = head l1 = l1.next else: l2.next = head l2 = l2.next head = head.next l2.next = None l1.next = h2.next return h1.next java 1ms, 4.45%, September 20, 2016 https://discuss.leetcode.com/topic/7795/concise-java-code-with-explanation-one-pass 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode partition(ListNode head, int x) &#123; ListNode dummy1 = new ListNode(0), dummy2 = new ListNode(0); ListNode curr1 = dummy1, curr2 = dummy2; while(head!=null)&#123; if(head.val&lt;x)&#123; curr1.next = head; curr1 = head; &#125;else&#123; curr2.next = head; curr2 = head; &#125; head = head.next; &#125; curr2.next = null; curr1.next = dummy2.next; return dummy1.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[085. Maximal Rectangle]]></title>
    <url>%2Fp%2Fba45e9ed%2F</url>
    <content type="text"><![CDATA[26.6% https://leetcode.com/problems/maximal-rectangle/ Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area. 1234567For example, given the following matrix:1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Return 6. 方法一: 9ms, 93.96%, September 23, 2016 https://discuss.leetcode.com/topic/6650/share-my-dp-solution Share my DP solution The DP solution proceeds row by row, starting from the first row. Let the maximal rectangle area at row i and column j be computed by [right(i,j) - left(i,j)]*height(i,j). All the 3 variables left, right, and height can be determined by the information from previous row, and also information from the current row. So it can be regarded as a DP solution. The transition equations are: 1234left(i,j) = max(left(i-1,j), cur_left), cur_left can be determined from the current rowright(i,j) = min(right(i-1,j), cur_right), cur_right can be determined from the current rowheight(i,j) = height(i-1,j) + 1, if matrix[i][j]==&apos;1&apos;;height(i,j) = 0, if matrix[i][j]==&apos;0&apos; The code is as below. The loops can be combined for speed but I separate them for more clarity of the algorithm. 123456789101112131415161718192021222324252627282930class Solution &#123;public:int maximalRectangle(vector&lt;vector&lt;char&gt; &gt; &amp;matrix) &#123; if(matrix.empty()) return 0; const int m = matrix.size(); const int n = matrix[0].size(); int left[n], right[n], height[n]; fill_n(left,n,0); fill_n(right,n,n); fill_n(height,n,0); int maxA = 0; for(int i=0; i&lt;m; i++) &#123; int cur_left=0, cur_right=n; for(int j=0; j&lt;n; j++) &#123; // compute height (can do this from either side) if(matrix[i][j]==&apos;1&apos;) height[j]++; else height[j]=0; &#125; for(int j=0; j&lt;n; j++) &#123; // compute left (from left to right) if(matrix[i][j]==&apos;1&apos;) left[j]=max(left[j],cur_left); else &#123;left[j]=0; cur_left=j+1;&#125; &#125; // compute right (from right to left) for(int j=n-1; j&gt;=0; j--) &#123; if(matrix[i][j]==&apos;1&apos;) right[j]=min(right[j],cur_right); else &#123;right[j]=n; cur_right=j;&#125; &#125; // compute the area of rectangle (can do this from either side) for(int j=0; j&lt;n; j++) maxA = max(maxA,(right[j]-left[j])*height[j]); &#125; return maxA;&#125;&#125;; If you think this algorithm is not easy to understand, you can try this example: 1230 0 0 1 0 0 0 0 0 1 1 1 0 0 0 1 1 1 1 1 0 The vector “left” and “right” from row 0 to row 2 are as follows row 0: 12l: 0 0 0 3 0 0 0r: 7 7 7 4 7 7 7 row 1: 12l: 0 0 2 3 2 0 0r: 7 7 5 4 5 7 7 row 2: 12l: 0 1 2 3 2 1 0r: 7 6 5 4 5 6 7 The vector “left” is computing the left boundary. Take (i,j)=(1,3) for example. On current row 1, the left boundary is at j=2. However, because matrix[1][3] is 1, you need to consider the left boundary on previous row as well, which is 3. So the real left boundary at (1,3) is 3. I hope this additional explanation makes things clearer. https://discuss.leetcode.com/topic/5806/sharing-my-straightforward-c-solution-with-o-n-2-time-with-explanation Sharing my straightforward C++ solution with O(n^2) time with explanation 12345678910111213141516171819202122232425262728293031323334353637int maximalRectangle(vector&lt;vector&lt;char&gt; &gt; &amp;matrix) &#123; if(matrix.empty())&#123; return 0; &#125; int maxRec = 0; vector&lt;int&gt; height(matrix[0].size(), 0); for(int i = 0; i &lt; matrix.size(); i++)&#123; for(int j = 0; j &lt; matrix[0].size(); j++)&#123; if(matrix[i][j] == &apos;0&apos;)&#123; height[j] = 0; &#125; else&#123; height[j]++; &#125; &#125; maxRec = max(maxRec, largestRectangleArea(height)); &#125; return maxRec;&#125;int largestRectangleArea(vector&lt;int&gt; &amp;height) &#123; stack&lt;int&gt; s; height.push_back(0); int maxSize = 0; for(int i = 0; i &lt; height.size(); i++)&#123; if(s.empty() || height[i] &gt;= height[s.top()])&#123; s.push(i); &#125; else&#123; int temp = height[s.top()]; s.pop(); maxSize = max(maxSize, temp * (s.empty() ? i : i - 1 - s.top())); i--; &#125; &#125; return maxSize;&#125; In order to solve this problem, I use the solution from “Largest Rectangle in Histogram”. Now I assume you already know how to solve “Largest Rectangle in Histogram”. We can regard a matrix as many histograms. For example, given a matrix below: 1 0 1 0 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 1 From top to bottom, we can find these histograms: Number 1: 1 0 1 0 Number 2: 0 1 0 1 Number 3: 0 2 1 0 Number 4: 1 0 2 0 Number 5: 2 0 3 1 Pass all of these histograms to the function which can solve “Largest Rectangle in Histogram”. And then find the maximum one. Finally, we get the answer. https://discuss.leetcode.com/topic/1122/my-o-n-3-solution-for-your-reference My O(n^3) solution for your reference 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int maximalRectangle(vector&lt;vector&lt;char&gt; &gt; &amp;matrix) &#123; int num_i=matrix.size(); if (num_i==0) return 0; int num_j=matrix[0].size(); if (num_j==0) return 0; vector&lt;vector&lt;int&gt;&gt; max_x(num_i,vector&lt;int&gt;(num_j,0)); //number of consecutive 1s to the left of matrix[i][j], including itself int area=0; for (int i=0;i&lt;num_i;i++)&#123; for (int j=0;j&lt;num_j;j++)&#123; if (matrix[i][j]==&apos;1&apos;)&#123; if (j==0) max_x[i][j]=1; else max_x[i][j]=max_x[i][j-1]+1; int y=1; int x=num_j; while((i-y+1&gt;=0)&amp;&amp;(matrix[i-y+1][j]==&apos;1&apos;))&#123; x=min(x, max_x[i-y+1][j]); area=max(area,x*y); y++; &#125; &#125; &#125; &#125; return area; &#125;&#125;; python https://discuss.leetcode.com/topic/27844/ac-python-dp-solutioin-120ms-based-on-largest-rectangle-in-histogram AC Python DP solutioin 120ms based on largest rectangle in histogram 12345678910111213141516171819202122def maximalRectangle(self, matrix): if not matrix or not matrix[0]: return 0 n = len(matrix[0]) height = [0] * (n + 1) ans = 0 for row in matrix: for i in xrange(n): height[i] = height[i] + 1 if row[i] == &apos;1&apos; else 0 stack = [-1] for i in xrange(n + 1): while height[i] &lt; height[stack[-1]]: h = height[stack.pop()] w = i - 1 - stack[-1] ans = max(ans, h * w) stack.append(i) return ans# 65 / 65 test cases passed.# Status: Accepted# Runtime: 120 ms# 100% The solution is based on largest rectangle in histogram solution. Every row in the matrix is viewed as the ground with some buildings on it. The building height is the count of consecutive 1s from that row to above rows. The rest is then the same as this solution for largest rectangle in histogram java https://discuss.leetcode.com/topic/1634/a-o-n-2-solution-based-on-largest-rectangle-in-histogram A O(n^2) solution based on Largest Rectangle in Histogram This question is similar as [Largest Rectangle in Histogram]: You can maintain a row length of Integer array H recorded its height of ‘1’s, and scan and update row by row to find out the largest rectangle of each row. For each row, if matrix[row][i] == ‘1’. H[i] +=1, or reset the H[i] to zero.and accroding the algorithm of [Largest Rectangle in Histogram], to update the maximum area. 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int maximalRectangle(char[][] matrix) &#123; if (matrix==null||matrix.length==0||matrix[0].length==0) return 0; int cLen = matrix[0].length; // column length int rLen = matrix.length; // row length // height array int[] h = new int[cLen+1]; h[cLen]=0; int max = 0; for (int row=0;row&lt;rLen;row++) &#123; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); for (int i=0;i&lt;cLen+1;i++) &#123; if (i&lt;cLen) if(matrix[row][i]==&apos;1&apos;) h[i]+=1; else h[i]=0; if (s.isEmpty()||h[s.peek()]&lt;=h[i]) s.push(i); else &#123; while(!s.isEmpty()&amp;&amp;h[i]&lt;h[s.peek()])&#123; int top = s.pop(); int area = h[top]*(s.isEmpty()?i:(i-s.peek()-1)); if (area&gt;max) max = area; &#125; s.push(i); &#125; &#125; &#125; return max; &#125;&#125; https://discuss.leetcode.com/topic/21772/my-java-solution-based-on-maximum-rectangle-in-histogram-with-explanation My java solution based on Maximum Rectangle in Histogram with explanation We can apply the maximum in histogram in each row of the 2D matrix. What we need is to maintain an int array for each row, which represent for the height of the histogram. Please refer to https://leetcode.com/problems/largest-rectangle-in-histogram/ first. Suppose there is a 2D matrix like 1 1 0 1 0 1 0 1 0 0 1 1 1 1 1 1 0 1 1 1 1 1 0 1 First initiate the height array as 1 1 0 1 0 1, which is just a copy of the first row. Then we can easily calculate the max area is 2. Then update the array. We scan the second row, when the matrix[1][i] is 0, set the height[i] to 0; else height[i] += 1, which means the height has increased by 1. So the height array again becomes 0 2 0 0 1 2. The max area now is also 2. Apply the same method until we scan the whole matrix. the last height arrays is 2 4 2 2 0 2, so the max area has been found as 2 * 4 = 8. Then reason we scan the whole matrix is that the maximum value may appear in any row of the height. Code as follows: 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123;public int maximalRectangle(char[][] matrix) &#123; if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0; int[] height = new int[matrix[0].length]; for(int i = 0; i &lt; matrix[0].length; i ++)&#123; if(matrix[0][i] == &apos;1&apos;) height[i] = 1; &#125; int result = largestInLine(height); for(int i = 1; i &lt; matrix.length; i ++)&#123; resetHeight(matrix, height, i); result = Math.max(result, largestInLine(height)); &#125; return result;&#125;private void resetHeight(char[][] matrix, int[] height, int idx)&#123; for(int i = 0; i &lt; matrix[0].length; i ++)&#123; if(matrix[idx][i] == &apos;1&apos;) height[i] += 1; else height[i] = 0; &#125;&#125; public int largestInLine(int[] height) &#123; if(height == null || height.length == 0) return 0; int len = height.length; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int maxArea = 0; for(int i = 0; i &lt;= len; i++)&#123; int h = (i == len ? 0 : height[i]); if(s.isEmpty() || h &gt;= height[s.peek()])&#123; s.push(i); &#125;else&#123; int tp = s.pop(); maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - 1 - s.peek())); i--; &#125; &#125; return maxArea;&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[084. Largest Rectangle in Histogram]]></title>
    <url>%2Fp%2F4e21238e%2F</url>
    <content type="text"><![CDATA[26.6% https://leetcode.com/problems/largest-rectangle-in-histogram/ Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. 123For example,Given heights = [2,1,5,6,2,3],return 10. 方法一: 效率o(nlogn) 我的代码实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int n = heights.size(); if(n==0) return 0; return largestArea(heights, 0, n-1); &#125; int largestArea(vector&lt;int&gt;&amp; heights, int start, int end)&#123; if(start == end) return heights[start]; int mid = start + (end-start)/2; int leftArea = largestArea(heights, start, mid); //这里必须是mid+1 不能是mid，否则不能ac // 想一想 end = left + 1, 左边是(left, left)， 右边是(left, left+1) // 右边永远无法结束 // 这个分治法的逻辑在于氛围两部分，左部分，右部分，穿越中间的部分 int rightArea = largestArea(heights, mid+1, end); int midArea = helper(heights, start, mid, end); return max(midArea, max(leftArea, rightArea)); &#125; int helper(vector&lt;int&gt;&amp; heights, int start, int mid, int end)&#123; int res = 0; int l = mid, r = mid+1, height = min(heights[l], heights[r]); while(l&gt;=start &amp;&amp; r&lt;=end)&#123; height = min(height, min(heights[l], heights[r])); res = max(res, height*(r-l+1)); if(l==start) r++; else if(r==end) l--; else&#123; if(heights[l-1]&gt;heights[r+1])&#123; l--; &#125;else&#123; r++; &#125; &#125; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/7491/simple-divide-and-conquer-ac-solution-without-segment-tree Simple Divide and Conquer AC solution without Segment Tree The idea is simple: for a given range of bars, the maximum area can either from left or right half of the bars, or from the area containing the middle two bars. For the last condition, expanding from the middle two bars to find a maximum area is O(n), which makes a typical Divide and Conquer solution with T(n) = 2T(n/2) + O(n). Thus the overall complexity is O(nlgn) for time and O(1) for space (or O(lgn) considering stack usage). Following is the code accepted with 44ms. I posted this because I didn’t find a similar solution, but only the RMQ idea which seemed less straightforward to me. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; int maxCombineArea(const vector&lt;int&gt; &amp;height, int s, int m, int e) &#123; // Expand from the middle to find the max area containing height[m] and height[m+1] int i = m, j = m+1; int area = 0, h = min(height[i], height[j]); while(i &gt;= s &amp;&amp; j &lt;= e) &#123; h = min(h, min(height[i], height[j])); area = max(area, (j-i+1) * h); if (i == s) &#123; ++j; &#125; else if (j == e) &#123; --i; &#125; else &#123; // if both sides have not reached the boundary, // compare the outer bars and expand towards the bigger side if (height[i-1] &gt; height[j+1]) &#123; --i; &#125; else &#123; ++j; &#125; &#125; &#125; return area; &#125; int maxArea(const vector&lt;int&gt; &amp;height, int s, int e) &#123; // if the range only contains one bar, return its height as area if (s == e) &#123; return height[s]; &#125; // otherwise, divide &amp; conquer, the max area must be among the following 3 values int m = s + (e-s)/2; // 1 - max area from left half int area = maxArea(height, s, m); // 2 - max area from right half area = max(area, maxArea(height, m+1, e)); // 3 - max area across the middle area = max(area, maxCombineArea(height, s, m, e)); return area; &#125;public: int largestRectangleArea(vector&lt;int&gt; &amp;height) &#123; if (height.empty()) &#123; return 0; &#125; return maxArea(height, 0, height.size()-1); &#125;&#125;; 方法二： 效率o（n） 使用栈保存index，保存比i小，但高度比ID 我的代码实现： 12345678910111213141516171819202122class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; // 学习针对某些原始输入进行一定的更改，比如后面加入0 heights.push_back(0); int res = 0; int height = 0; stack&lt;int&gt; stack; for(int i=0; i&lt;heights.size(); i++)&#123; // stack的top函数, 还有vector的back函数 // stack有top函数，没有back函数 while(stack.size() &amp;&amp; heights[stack.top()] &gt; heights[i])&#123; height = heights[stack.top()]; stack.pop(); int idx = stack.size() ? stack.top() : -1; res = max(res, (i-idx-1)*height); &#125; stack.push(i); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/3913/my-concise-c-solution-ac-90-ms My concise C++ solution, AC 90 ms I push a sentinel node back into the end of height to make the code logic more concise. 12345678910111213141516171819202122232425class Solution &#123; public: int largestRectangleArea(vector&lt;int&gt; &amp;height) &#123; int ret = 0; height.push_back(0); vector&lt;int&gt; index; for(int i = 0; i &lt; height.size(); i++) &#123; while(index.size() &gt; 0 &amp;&amp; height[index.back()] &gt;= height[i]) &#123; int h = height[index.back()]; index.pop_back(); int sidx = index.size() &gt; 0 ? index.back() : -1; if(h * (i-sidx-1) &gt; ret) ret = h * (i-sidx-1); &#125; index.push_back(i); &#125; return ret; &#125; &#125;; https://discuss.leetcode.com/topic/14406/my-concise-code-20ms-stack-based-o-n-one-trick-used My concise code (20ms, stack based, O(n)), one trick used The idea is simple, use a stack to save the index of each vector entry in a ascending order; once the current entry is smaller than the one with the index s.top(), then that means the rectangle with the height height[s.top()] ends at the current position, so calculate its area and update the maximum.The only trick I use to avoid checking whether the stack is empty (due to pop) and also avoiding emptying the stack at the end (i.e. after going through the vector, s is not empty and we have to consider those in the stack) is to put a dummy “0” at the beginning of vector “height” and the end of “height”: the first one makes sure the stack will never be empty (since all the height entries are &gt;=0) and the last one will flush all the remaining non-zero entries of the stack at the end of “for” iteration. This trick helps us keep the code concise. 1234567891011121314151617181920212223class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; height) &#123; height.insert(height.begin(),0); // dummy &quot;0&quot; added to make sure stack s will never be empty height.push_back(0); // dummy &quot;0&quot; added to clear the stack at the end int len = height.size(); int i, res = 0, idx; stack&lt;int&gt; s; // stack to save &quot;height&quot; index s.push(0); // index to the first dummy &quot;0&quot; for(i=1;i&lt;len;i++) &#123; while(height[i]&lt;height[idx = s.top()]) // if the current entry is out of order &#123; s.pop(); res = max(res, height[idx] * (i-s.top()-1) ); // note how the width is calculated, use the previous index entry &#125; s.push(i); &#125; height.erase(height.begin()); // remove two dummy &quot;0&quot; height.pop_back(); return res; &#125;&#125;; python 92ms, 71.82%, June.24th, 2016 https://leetcode.com/discuss/65647/ac-python-clean-solution-using-stack-76ms AC Python clean solution using stack 76ms 12345678910111213141516171819def largestRectangleArea(self, height): height.append(0) stack = [-1] ans = 0 for i in xrange(len(height)): while height[i] &lt; height[stack[-1]]: h = height[stack.pop()] w = i - stack[-1] - 1 ans = max(ans, h * w) stack.append(i) height.pop() return ans# 94 / 94 test cases passed.# Status: Accepted# Runtime: 76 ms# 97.34% The stack maintain the indexes of buildings with ascending height. Before adding a new building pop the building who is taller than the new one. The building popped out represent the height of a rectangle with the new building as the right boundary and the current stack top as the left boundary. Calculate its area and update ans of maximum area. Boundary is handled using dummy buildings. java https://discuss.leetcode.com/topic/7599/o-n-stack-based-java-solution O(n) stack based JAVA solution For explanation, please see http://www.geeksforgeeks.org/largest-rectangle-under-histogram/ 123456789101112131415161718public class Solution &#123; public int largestRectangleArea(int[] height) &#123; int len = height.length; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int maxArea = 0; for(int i = 0; i &lt;= len; i++)&#123; int h = (i == len ? 0 : height[i]); if(s.isEmpty() || h &gt;= height[s.peek()])&#123; s.push(i); &#125;else&#123; int tp = s.pop(); maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - 1 - s.peek())); i--; &#125; &#125; return maxArea; &#125;&#125; https://discuss.leetcode.com/topic/2424/my-modified-answer-from-geeksforgeeks-in-java My modified answer from GeeksforGeeks, in JAVA I was stuck and took an eye on Geeks4Geeks. I got the idea and tried to figure it out by myself…It takes me a lot of time to make it through…. EDITED: Now it is pretty concise…. 1234567891011121314151617181920212223242526public class Solution &#123;public int largestRectangleArea(int[] height) &#123; if (height==null) return 0;//Should throw exception if (height.length==0) return 0; Stack&lt;Integer&gt; index= new Stack&lt;Integer&gt;(); index.push(-1); int max=0; for (int i=0;i&lt;height.length;i++)&#123; //Start calculate the max value while (index.peek()&gt;-1) if (height[index.peek()]&gt;height[i])&#123; int top=index.pop(); max=Math.max(max,height[top]*(i-1-index.peek())); &#125;else break; index.push(i); &#125; while(index.peek()!=-1)&#123; int top=index.pop(); max=Math.max(max,height[top]*(height.length-1-index.peek())); &#125; return max;&#125;&#125; https://discuss.leetcode.com/topic/39151/5ms-o-n-java-solution-explained-beats-96 5ms O(n) Java solution explained (beats 96%) For any bar i the maximum rectangle is of width r - l - 1 where r - is the last coordinate of the bar to the right with height h[r] &gt;= h[i] and l - is the last coordinate of the bar to the left which height h[l] &gt;= h[i] So if for any i coordinate we know his utmost higher (or of the same height) neighbors to the right and to the left, we can easily find the largest rectangle: 1234int maxArea = 0;for (int i = 0; i &lt; height.length; i++) &#123; maxArea = Math.max(maxArea, height[i] * (lessFromRight[i] - lessFromLeft[i] - 1));&#125; The main trick is how to effectively calculate lessFromRight and lessFromLeft arrays. The trivial solution is to use O(n^2) solution and for each i element first find his left/right heighbour in the second inner loop just iterating back or forward: 123456789101112for (int i = 1; i &lt; height.length; i++) &#123; if (height[i] &gt; height[i - 1]) &#123; lessFromLeft[i] = i - 1; &#125; else &#123; int p = i - 1; while (p &gt;= 0 &amp;&amp; height[p] &gt;= height[i]) &#123; p--; &#125; lessFromLeft[i] = p; &#125; &#125; The only line change shifts this algorithm from O(n^2) to O(n) complexity: we don’t need to rescan each item to the left - we can reuse results of previous calculations and “jump” through indices in quick manner: 123while (p &gt;= 0 &amp;&amp; height[p] &gt;= height[i]) &#123; p = lessFromLeft[p];&#125; Here is the whole solution: 12345678910111213141516171819202122232425262728293031323334353637public int largestRectangleArea(int[] height) &#123; if (height == null || height.length == 0) &#123; return 0; &#125; int[] lessFromLeft = new int[height.length]; // idx of the first bar the left that is lower than current int[] lessFromRight = new int[height.length]; // idx of the first bar the right that is lower than current lessFromRight[height.length - 1] = height.length; lessFromLeft[0] = -1; for (int i = 1; i &lt; height.length; i++) &#123; if (height[i] &gt; height[i - 1]) &#123; lessFromLeft[i] = i - 1; &#125; else &#123; int p = i - 1; while (p &gt;= 0 &amp;&amp; height[p] &gt;= height[i]) p = lessFromLeft[p]; lessFromLeft[i] = p; &#125; &#125; for (int i = height.length - 2; i &gt;= 0; i--) &#123; if (height[i] &gt; height[i + 1]) &#123; lessFromRight[i] = i + 1; &#125; else &#123; int p = i + 1; while (p &lt; height.length &amp;&amp; height[p] &gt;= height[i]) p = lessFromRight[p]; lessFromRight[i] = p; &#125; &#125; int maxArea = 0; for (int i = 0; i &lt; height.length; i++) &#123; maxArea = Math.max(maxArea, height[i] * (lessFromRight[i] - lessFromLeft[i] - 1)); &#125; return maxArea;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hard</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[083. Remove Duplicates from Sorted List]]></title>
    <url>%2Fp%2Ff95633fb%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/remove-duplicates-from-sorted-list/ Given a sorted linked list, delete all duplicates such that each element appear only once. 123For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 方法一： 启示，只要比较跟前面的比较。 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* slow = head, *fast = head-&gt;next; // 要求slow &amp;&amp; slow-&gt;next 不是slow-&gt;next // 考虑问题要全面 while(slow &amp;&amp; slow-&gt;next)&#123; fast = slow-&gt;next; while(fast &amp;&amp; slow-&gt;val == fast-&gt;val) fast = fast-&gt;next; // 此处是fast 不是fast-&gt;next // 因为fast指向的是最后一个元素的下一位，而不是最后一个元素了 // 注意区分 slow-&gt;next = fast; slow = slow-&gt;next; &#125; return head; &#125;&#125;; 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* cur = head; while(cur!=NULL)&#123; ListNode* nex = cur-&gt;next; while(nex!=NULL &amp;&amp; nex-&gt;val==cur-&gt;val) nex = nex-&gt;next; cur-&gt;next = nex; cur = nex; &#125; return dummy-&gt;next; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode *cur = head; while(cur)&#123; while(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) cur-&gt;next = cur-&gt;next-&gt;next; cur = cur-&gt;next; &#125; return head; &#125;&#125;; 12ms, 80.53%, July 14th, 2016 https://discuss.leetcode.com/topic/2168/concise-solution-and-memory-freeing1234567891011121314151617181920/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode * cur = head; while(cur)&#123; while(cur-&gt;next &amp;&amp; cur-&gt;val == cur -&gt; next -&gt;val) cur -&gt;next = cur -&gt;next-&gt;next; cur = cur-&gt;next; &#125; return head; &#125;&#125;; python java 1ms, 17.66%, July 14th, 2016 https://discuss.leetcode.com/topic/14775/3-line-java-recursive-solution/2 123456789101112131415/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null) return head; head.next = deleteDuplicates(head.next); return head.val == head.next.val ? head.next : head; &#125;&#125; 2ms, 5.53%, July 14th, 2016 https://discuss.leetcode.com/topic/8345/my-pretty-solution-java 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode list = head; while(list != null)&#123; if(list.next == null) break; if(list.val == list.next.val) list.next = list.next.next; else list = list.next; &#125; return head; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[082. Remove Duplicates from Sorted List II]]></title>
    <url>%2Fp%2F89010df4%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/ Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. 123For example,Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 方法一： 8ms, 57.12%, July 14th, 2016 https://discuss.leetcode.com/topic/12892/simple-and-clear-c-recursive-solution/2 递归法 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head) return 0; if(!head-&gt;next) return head; int val = head-&gt;val; ListNode * p = head -&gt;next; if(p-&gt;val != val)&#123; head-&gt;next = deleteDuplicates(p); return head; &#125;else&#123; while(p &amp;&amp; p-&gt;val == val) p = p-&gt;next; return deleteDuplicates(p); &#125; &#125;&#125;; 方法二： 使用迭代的方法 我的代码实现： 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* slow = dummy, *fast; // 要保证slow和slow-&gt;next while(slow &amp;&amp; slow-&gt;next)&#123; fast = slow-&gt;next; while(fast-&gt;next &amp;&amp; slow-&gt;next-&gt;val == fast-&gt;next-&gt;val) fast = fast-&gt;next; if(fast!=slow-&gt;next) slow-&gt;next = fast-&gt;next; else slow = slow-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* cur = dummy; while(cur-&gt;next)&#123; ListNode* nex = cur-&gt;next; while(nex-&gt;next!=NULL &amp;&amp; nex-&gt;next-&gt;val == nex-&gt;val) nex = nex-&gt;next; if(cur-&gt;next!=nex) cur-&gt;next = nex-&gt;next; else cur = cur-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; python 72ms, 44.80%, July 14th, 2016 https://discuss.leetcode.com/topic/21369/python-in-place-solution-with-dummy-head-node/2 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteDuplicates(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; dummy = pre = ListNode(0) dummy.next = head while head and head.next: if head.val == head.next.val: while head and head.next and head.val == head.next.val: head = head.next head = head.next pre.next = head else: pre = pre.next head = head.next return dummy.next java 一个pre指针，一个cur指针，每次cur指针判断是否需要右移，如果没有移动的话，pre就向后移动，如果移动的话，建立pre与cur.next的关系。cur负责当前位置，pre负责前一个位置，每次循环，负责找出pre的next的位置。 https://discuss.leetcode.com/topic/3890/my-accepted-java-code 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head==null) return head; ListNode FakeHead = new ListNode(0); FakeHead.next = head; ListNode pre = FakeHead; ListNode cur = head; while(cur != null)&#123; while(cur.next != null &amp;&amp; cur.val == cur.next.val) cur = cur.next; if(pre.next == cur) pre = pre.next; else pre.next = cur.next; cur = cur.next; &#125; return FakeHead.next; &#125;&#125; 使用迭代的方法 if current node is not unique, return deleteDuplicates with head.next. If current node is unique, link it to the result of next list made by recursive call. https://discuss.leetcode.com/topic/5206/my-recursive-java-solution 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head == null) return null; if(head.next != null &amp;&amp; head.next.val == head.val)&#123; while(head.next!=null &amp;&amp; head.val == head.next.val) head = head.next; return deleteDuplicates(head.next); &#125;else head.next = deleteDuplicates(head.next); return head; &#125;&#125; 1ms, 20.48%, July 14th, 2016 https://discuss.leetcode.com/topic/5206/my-recursive-java-solution 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head == null) return null; if(head.next != null &amp;&amp; head.val == head.next.val)&#123; while(head.next != null &amp;&amp; head.val == head.next.val) head = head.next; return deleteDuplicates(head.next); &#125; else head.next = deleteDuplicates(head.next); return head; &#125;&#125; 1ms, 20.48%, July 14th, 2016 https://discuss.leetcode.com/topic/3890/my-accepted-java-code/2 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head==null) return null; ListNode FakeHead=new ListNode(0); FakeHead.next=head; ListNode pre=FakeHead; ListNode cur=head; while(cur!=null)&#123; while(cur.next!=null&amp;&amp;cur.val==cur.next.val)&#123; cur=cur.next; &#125; if(pre.next==cur)&#123; pre=pre.next; &#125; else&#123; pre.next=cur.next; &#125; cur=cur.next; &#125; return FakeHead.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[081. Search in Rotated Sorted Array II]]></title>
    <url>%2Fp%2Faabfef19%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/search-in-rotated-sorted-array-ii/ Follow up for “Search in Rotated Sorted Array”: What if duplicates are allowed? Would this affect the run-time complexity? How and why? Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. 1(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Write a function to determine if a given target is in the array. The array may contain duplicates. https://discuss.leetcode.com/topic/23382/medium-level-question-is-follow-up-for-a-hard-level-question Medium level question is follow up for a hard level question? It says this problem is a follow up for Search in Rotated Sorted Array. Search in Rotated Sorted Array is a hard level question. It is kinda un-intuitive for a medium level question to be a follow up for a hard question since I am doing all medium level questions first before I do hard level questions. If this problem is easier than Search in Rotated Sorted Array, then I think Search in Rotated Sorted Array should be the follow up problem for this, not the other way around. 方法一： 二分查找 面试奇虎360曾遇到过 beats 12.39% of cppsubmissions 我的代码实现： 对于重复的，这种是left++来实现。 1234567891011121314151617181920212223242526class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if(n==0) return false; int left = 0, right = n-1; while(left&lt;=right)&#123; int mid = left + (right-left)/2; if(nums[mid]==target) return true; if(nums[left]&lt;nums[mid])&#123; if(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid]) right = mid-1; else left = mid+1; &#125;else if(nums[left]&gt;nums[mid])&#123; if(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right]) left = mid+1; else right = mid-1; &#125;else left++; &#125; return false; &#125;&#125;; 有借鉴剑指offer 8的解法，对于left mid right三者相等的情况， 无法判断，只能顺序查找，所以单独顺序查找。 其他情况还是二分查找。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if(n==0) return false; int left = 0, right = n-1; while(left&lt;=right)&#123; int mid = left + (right-left)/2; if(nums[mid]==target) return true; if(nums[left]==nums[mid] &amp;&amp; nums[left]==nums[right])&#123; // 只能线性查找情况 return inorder_search(nums, left+1, right-1, target); &#125; if(nums[left]&lt;=nums[mid])&#123; if(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid]) right = mid-1; else left = mid+1; &#125;else if(nums[left]&gt;nums[mid])&#123; if(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right]) left = mid+1; else right = mid-1; &#125; &#125; return false; &#125; bool inorder_search(vector&lt;int&gt;&amp; nums, int left, int right, int target)&#123; if(left&gt;right) return false; for(int i=left; i&lt;=right; i++)&#123; if(nums[i]==target) return true; &#125; return false; &#125;&#125;; 其他代码实现方法 12345678910111213141516171819202122232425class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int first = 0, last = nums.size(); while(first != last)&#123; const int mid = first + (last - first) / 2; if(nums[mid] == target) return true; if(nums[first] &lt; nums[mid])&#123; if(nums[first] &lt;= target &amp;&amp; target &lt; nums[mid]) last = mid; else first = mid + 1; &#125;else if(nums[first] &gt; nums[mid])&#123; if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[last-1]) first = mid + 1; else last = mid; &#125; else // skip duplicate one first++; &#125; return false; &#125;&#125;; cpp https://discuss.leetcode.com/topic/8087/c-concise-log-n-solution C++ concise log(n) solution 12345678910111213141516171819202122class Solution &#123;public: bool search(int A[], int n, int target) &#123; int lo =0, hi = n-1; int mid = 0; while(lo&lt;hi)&#123; mid=(lo+hi)/2; if(A[mid]==target) return true; if(A[mid]&gt;A[hi])&#123; if(A[mid]&gt;target &amp;&amp; A[lo] &lt;= target) hi = mid; else lo = mid + 1; &#125;else if(A[mid] &lt; A[hi])&#123; if(A[mid]&lt;target &amp;&amp; A[hi] &gt;= target) lo = mid + 1; else hi = mid; &#125;else&#123; hi--; &#125; &#125; return A[lo] == target ? true : false; &#125;&#125;; https://discuss.leetcode.com/topic/16660/my-8ms-c-solution-o-logn-on-average-o-n-worst-case My 8ms C++ solution (o(logn) on average, o(n) worst case) The idea is the same as the previous one without duplicates 12345671) everytime check if targe == nums[mid], if so, we find it.2) otherwise, we check if the first half is in order (i.e. nums[left]&lt;=nums[mid]) and if so, go to step 3), otherwise, the second half is in order, go to step 4)3) check if target in the range of [left, mid-1] (i.e. nums[left]&lt;=target &lt; nums[mid]), if so, do search in the first half, i.e. right = mid-1; otherwise, search in the second half left = mid+1;4) check if target in the range of [mid+1, right] (i.e. nums[mid]&lt;target &lt;= nums[right]), if so, do search in the second half, i.e. left = mid+1; otherwise search in the first half right = mid-1;The only difference is that due to the existence of duplicates, we can have nums[left] == nums[mid] and in that case, the first half could be out of order (i.e. NOT in the ascending order, e.g. [3 1 2 3 3 3 3]) and we have to deal this case separately. In that case, it is guaranteed that nums[right] also equals to nums[mid], so what we can do is to check if nums[mid]== nums[left] == nums[right] before the original logic, and if so, we can move left and right both towards the middle by 1. and repeat. 123456789101112131415161718192021222324252627class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size()-1, mid; while(left&lt;=right) &#123; mid = (left + right) &gt;&gt; 1; if(nums[mid] == target) return true; // the only difference from the first one, trickly case, just updat left and right if( (nums[left] == nums[mid]) &amp;&amp; (nums[right] == nums[mid]) ) &#123;++left; --right;&#125; else if(nums[left] &lt;= nums[mid]) &#123; if( (nums[left]&lt;=target) &amp;&amp; (nums[mid] &gt; target) ) right = mid-1; else left = mid + 1; &#125; else &#123; if((nums[mid] &lt; target) &amp;&amp; (nums[right] &gt;= target) ) left = mid+1; else right = mid-1; &#125; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/19116/easy-c-solution-based-on-version-i-of-the-problem Easy C++ Solution based on Version I of the Problem For those who have already solved Search in Rotated Sorted Array, this problem can be solved similarly using codes for that problem and simply adding codes to skip the duplicates. For Search in Rotated Sorted Array, I post solutions in C/C++/Python here (C and C++ only needs 11 lines). Now, based on the above codes, you can solve this problem by simply adding two lines to skip duplicates both starting from left and right. 123456789101112131415161718192021class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; int l = 0, r = nums.size() - 1; while (l &lt;= r) &#123; while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; // skip duplicates from the left while (r &gt; l &amp;&amp; nums[r] == nums[r - 1]) r--; // skip duplicates from the right int mid = (l + r) / 2; if (nums[mid] == target) return true; if (nums[mid] &gt; target) &#123; if (nums[l] &lt;= target || nums[mid] &lt; nums[l]) r = mid - 1; else l = mid + 1; &#125; else &#123; if (nums[l] &gt; target || nums[mid] &gt;= nums[l]) l = mid + 1; else r = mid - 1; &#125; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/20593/python-easy-to-understand-solution-with-comments Python easy to understand solution (with comments). 1234567891011121314151617181920212223def search(self, nums, target): l, r = 0, len(nums)-1 while l &lt;= r: mid = l + (r-l)//2 if nums[mid] == target: return True while l &lt; mid and nums[l] == nums[mid]: # tricky part l += 1 # the first half is ordered if nums[l] &lt;= nums[mid]: # target is in the first half if nums[l] &lt;= target &lt; nums[mid]: r = mid - 1 else: l = mid + 1 # the second half is ordered else: # target is in the second half if nums[mid] &lt; target &lt;= nums[r]: l = mid + 1 else: r = mid - 1 return False java https://discuss.leetcode.com/topic/310/when-there-are-duplicates-the-worst-case-is-o-n-could-we-do-better When there are duplicates, the worst case is O(n). Could we do better? Since we will have some duplicate elements in this problem, it is a little tricky because sometimes we cannot decide whether to go to the left side or right side. So for this condition, I have to probe both left and right side simultaneously to decide which side we need to find the number. Only in this condition, the time complexity may be O(n). The rest conditions are always O(log n). For example: input: 113111111111, Looking for target 3. Is my solution correct? My code is as followed: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public boolean search(int[] A, int target) &#123; // IMPORTANT: Please reset any member data you declared, as // the same Solution instance will be reused for each test case. int i = 0; int j = A.length - 1; while(i &lt;= j)&#123; int mid = (i + j) / 2; if(A[mid] == target) return true; else if(A[mid] &lt; A[i])&#123; if(target &gt; A[j]) j = mid - 1; else if(target &lt; A[mid]) j = mid - 1; else i = mid + 1; &#125;else if(A[mid] &gt; A[i])&#123; if(target &lt; A[mid] &amp;&amp; target &gt;= A[i]) j = mid - 1; else i = mid + 1; &#125;else&#123; // A[mid] == A[i] if(A[mid] != A[j]) i = mid + 1; else&#123; boolean flag = true; for(int k = 1; mid - k &gt;= i &amp;&amp; mid + k &lt;= j; k++)&#123; if(A[mid] != A[mid - k])&#123; j = mid - k; flag = false; break; &#125;else if(A[mid] != A[mid + k])&#123; i = mid + k; flag = false; break; &#125; &#125; if(flag) return false; &#125; &#125; &#125; return false; &#125;&#125; https://discuss.leetcode.com/topic/25487/neat-java-solution-using-binary-search Neat JAVA solution using binary search 12345678910111213141516171819202122232425262728293031public boolean search(int[] nums, int target) &#123; int start = 0, end = nums.length - 1, mid = -1; while(start &lt;= end) &#123; mid = (start + end) / 2; if (nums[mid] == target) &#123; return true; &#125; //If we know for sure right side is sorted or left side is unsorted if (nums[mid] &lt; nums[end] || nums[mid] &lt; nums[start]) &#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) &#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125; //If we know for sure left side is sorted or right side is unsorted &#125; else if (nums[mid] &gt; nums[start] || nums[mid] &gt; nums[end]) &#123; if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) &#123; end = mid - 1; &#125; else &#123; start = mid + 1; &#125; //If we get here, that means nums[start] == nums[mid] == nums[end], then shifting out //any of the two sides won&apos;t change the result but can help remove duplicate from //consideration, here we just use end-- but left++ works too &#125; else &#123; end--; &#125; &#125; return false;&#125; In case anyone wonders, yes I agree that we don’t need to check two parts. It’s just that Doing that can slightly boost the performance, no asymptotic difference though.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[080. Remove Duplicates from Sorted Array II]]></title>
    <url>%2Fp%2F86a087%2F</url>
    <content type="text"><![CDATA[36.1% https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/ Follow up for “Remove Duplicates”: What if duplicates are allowed at most twice? 123456For example,Given sorted array nums = [1,1,1,2,2,3],Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn&apos;t matter what you leave beyond the new length. 方法一： 12345678910111213141516171819202122class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return n; int i=0, j=0; int index = 0; while(i&lt;n)&#123; j=i; while(j&lt;n &amp;&amp; nums[i]==nums[j]) j++; if(j==i+1)&#123; nums[index++] = nums[j-1]; &#125; else&#123; nums[index++] = nums[j-1]; nums[index++] = nums[j-1]; &#125; i = j; &#125; return index; &#125;&#125;; 怀疑下面的解法都是手误 cpp https://discuss.leetcode.com/topic/12892/simple-and-clear-c-recursive-solution Simple and clear c++ recursive solution 123456789101112131415161718class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (!head) return 0; if (!head-&gt;next) return head; int val = head-&gt;val; ListNode* p = head-&gt;next; if (p-&gt;val != val) &#123; head-&gt;next = deleteDuplicates(p); return head; &#125; else &#123; while (p &amp;&amp; p-&gt;val == val) p = p-&gt;next; return deleteDuplicates(p); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/7224/is-this-the-best-c-solution Is this the best C++ solution? 123456789101112131415161718192021222324class Solution &#123;public: ListNode *deleteDuplicates(ListNode *head) &#123; ListNode **runner = &amp;head; if(!head || !head-&gt;next)return head; while(*runner) &#123; if((*runner)-&gt;next &amp;&amp; (*runner)-&gt;next-&gt;val == (*runner)-&gt;val) &#123; ListNode *temp = *runner; while(temp &amp;&amp; (*runner)-&gt;val == temp-&gt;val) temp = temp-&gt;next; *runner = temp; &#125; else runner = &amp;((*runner)-&gt;next); &#125; return head; &#125;&#125;; 123456789101112131415class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int size=nums.size(); int i=0,j=0; while(i&lt;size)&#123; nums[j++]=nums[i]; while(i+2&lt;size &amp;&amp; nums[i]==nums[i+1] &amp;&amp; nums[i+1]==nums[i+2])&#123; i++; &#125; i++; &#125; return j; &#125;&#125;; python https://discuss.leetcode.com/topic/21369/python-in-place-solution-with-dummy-head-node Python in-place solution with dummy head node. 12345678910111213def deleteDuplicates(self, head): dummy = pre = ListNode(0) dummy.next = head while head and head.next: if head.val == head.next.val: while head and head.next and head.val == head.next.val: head = head.next head = head.next pre.next = head else: pre = pre.next head = head.next return dummy.next java https://discuss.leetcode.com/topic/3890/my-accepted-java-code My accepted Java code 1234567891011121314151617181920public ListNode deleteDuplicates(ListNode head) &#123; if(head==null) return null; ListNode FakeHead=new ListNode(0); FakeHead.next=head; ListNode pre=FakeHead; ListNode cur=head; while(cur!=null)&#123; while(cur.next!=null&amp;&amp;cur.val==cur.next.val)&#123; cur=cur.next; &#125; if(pre.next==cur)&#123; pre=pre.next; &#125; else&#123; pre.next=cur.next; &#125; cur=cur.next; &#125; return FakeHead.next; &#125; https://discuss.leetcode.com/topic/5206/my-recursive-java-solution My Recursive Java Solution 12345678910111213public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) return null; if (head.next != null &amp;&amp; head.val == head.next.val) &#123; while (head.next != null &amp;&amp; head.val == head.next.val) &#123; head = head.next; &#125; return deleteDuplicates(head.next); &#125; else &#123; head.next = deleteDuplicates(head.next); &#125; return head;&#125; if current node is not unique, return deleteDuplicates with head.next. If current node is unique, link it to the result of next list made by recursive call. Any improvement? https://discuss.leetcode.com/topic/24470/java-simple-and-clean-code-with-comment Java simple and clean code with comment 123456789101112131415161718192021public class Solution &#123;public ListNode deleteDuplicates(ListNode head) &#123; //use two pointers, slow - track the node before the dup nodes, // fast - to find the last node of dups. ListNode dummy = new ListNode(0), fast = head, slow = dummy; slow.next = fast; while(fast != null) &#123; while (fast.next != null &amp;&amp; fast.val == fast.next.val) &#123; fast = fast.next; //while loop to find the last node of the dups. &#125; if (slow.next != fast) &#123; //duplicates detected. slow.next = fast.next; //remove the dups. fast = slow.next; //reposition the fast pointer. &#125; else &#123; //no dup, move down both pointer. slow = slow.next; fast = fast.next; &#125; &#125; return dummy.next;&#125; &#125; https://discuss.leetcode.com/topic/11234/a-short-and-simple-java-solution A short and simple Java solution 12345678910111213141516public ListNode deleteDuplicates(ListNode head) &#123; ListNode dummy = new ListNode(0); ListNode d = dummy; while (head != null) &#123; if (head.next != null &amp;&amp; head.val == head.next.val) &#123; while (head.next != null &amp;&amp; head.val == head.next.val) head = head.next; &#125; else &#123; d.next = head; d = d.next; &#125; head = head.next; &#125; d.next = null; return dummy.next;&#125; 1-&gt;1-&gt;1-&gt;2-&gt;2-&gt;3 we skip all the 1’s and start the loop from 2 and also skip all the 2’s, and now head.val == 3; ponit d.next to the tail, end the loop]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[079. Word Search]]></title>
    <url>%2Fp%2F289213d2%2F</url>
    <content type="text"><![CDATA[26.8% https://leetcode.com/problems/word-search/ Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. 1234567891011For example,Given board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]word = &quot;ABCCED&quot;, -&gt; returns true,word = &quot;SEE&quot;, -&gt; returns true,word = &quot;ABCB&quot;, -&gt; returns false. 方法一： 我的代码实现: 123456789101112131415161718192021222324252627class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if(word.empty()) return true; if(board.size()==0 || board[0].size()==0) return false; for(int i=0; i&lt;board.size(); i++) for(int j=0; j&lt;board[0].size(); j++) if(helper(board, word, i, j, 0)) return true; return false; &#125; bool helper(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int i, int j, int k)&#123; int m=board.size(), n=board[0].size(); if(board[i][j]!=word[k]) return false; if(k==word.size()-1) return true; char c = board[i][j]; board[i][j] = '*'; bool res = false; if(j+1&lt;n) res = helper(board, word, i, j+1, k+1); if(!res &amp;&amp; i-1&gt;=0) res = helper(board, word, i-1, j, k+1); if(!res &amp;&amp; j-1&gt;=0) res = helper(board, word, i, j-1, k+1); if(!res &amp;&amp; i+1&lt;m) res = helper(board, word, i+1, j, k+1); board[i][j] = c; return res; &#125;&#125;; 典型的dfs，backtracking方法 My 19ms accepted C++ code 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt; &gt; &amp;board, string word) &#123; m=board.size(); n=board[0].size(); for(int x=0;x&lt;m;x++) for(int y=0;y&lt;n;y++) &#123; if(isFound(board,word.c_str(),x,y)) return true; &#125; return false; &#125;private: int m; int n; bool isFound(vector&lt;vector&lt;char&gt; &gt; &amp;board, const char* w, int x, int y) &#123; if(x&lt;0||y&lt;0||x&gt;=m||y&gt;=n||board[x][y]=='\0'||*w!=board[x][y]) return false; if(*(w+1)=='\0') return true; char t=board[x][y]; board[x][y]='\0'; if(isFound(board,w+1,x-1,y)||isFound(board,w+1,x+1,y)||isFound(board,w+1,x,y-1)||isFound(board,w+1,x,y+1)) return true; board[x][y]=t; return false; &#125;&#125;; My DFS + Backtracking C++ solution (16ms) Typical dfs+backtracking question. It compare board[row][col] with word[start], if they match, change board[row][col] to ‘*‘ to mark it as visited. Then move to the next one (i.e. word[start+1]) and compare it to the current neighbors ( doing it by recursion) 1234567891011121314151617181920212223242526272829class Solution &#123;private: bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, const string &amp;word, int start, int M, int N, int sLen) &#123; char curC; bool res = false; if( (curC = board[row][col]) != word[start]) return false; if(start==sLen-1) return true; board[row][col] = &apos;*&apos;; if(row&gt;0) res = dfs(board, row-1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; row &lt; M-1) res = dfs(board, row+1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; col &gt; 0) res = dfs(board, row, col-1, word, start+1, M, N, sLen); if(!res &amp;&amp; col &lt; N-1) res = dfs(board, row, col+1, word, start+1, M, N, sLen); board[row][col] = curC; return res; &#125; public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; int M,N,i,j,sLen = word.size(); if( (M=board.size()) &amp;&amp; (N=board[0].size()) &amp;&amp; sLen) &#123; for(i=0; i&lt;M; ++i) for(j=0; j&lt;N; ++j) if(dfs(board, i, j, word, 0, M, N, sLen)) return true; &#125; return false; &#125;&#125;; cpp https://discuss.leetcode.com/topic/9826/my-19ms-accepted-c-code My 19ms accepted C++ code 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt; &gt; &amp;board, string word) &#123; m=board.size(); n=board[0].size(); for(int x=0;x&lt;m;x++) for(int y=0;y&lt;n;y++) &#123; if(isFound(board,word.c_str(),x,y)) return true; &#125; return false; &#125;private: int m; int n; bool isFound(vector&lt;vector&lt;char&gt; &gt; &amp;board, const char* w, int x, int y) &#123; if(x&lt;0||y&lt;0||x&gt;=m||y&gt;=n||board[x][y]=='\0'||*w!=board[x][y]) return false; if(*(w+1)=='\0') return true; char t=board[x][y]; board[x][y]='\0'; if(isFound(board,w+1,x-1,y)||isFound(board,w+1,x+1,y)||isFound(board,w+1,x,y-1)||isFound(board,w+1,x,y+1)) return true; board[x][y]=t; return false; &#125;&#125;; https://discuss.leetcode.com/topic/19658/my-dfs-backtracking-c-solution-16ms My DFS + Backtracking C++ solution (16ms) Typical dfs+backtracking question. It compare board[row][col] with word[start], if they match, change board[row][col] to ‘*‘ to mark it as visited. Then move to the next one (i.e. word[start+1]) and compare it to the current neighbors ( doing it by recursion) 1234567891011121314151617181920212223242526272829class Solution &#123;private: bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, const string &amp;word, int start, int M, int N, int sLen) &#123; char curC; bool res = false; if( (curC = board[row][col]) != word[start]) return false; if(start==sLen-1) return true; board[row][col] = &apos;*&apos;; if(row&gt;0) res = dfs(board, row-1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; row &lt; M-1) res = dfs(board, row+1, col, word, start+1, M, N, sLen); if(!res &amp;&amp; col &gt; 0) res = dfs(board, row, col-1, word, start+1, M, N, sLen); if(!res &amp;&amp; col &lt; N-1) res = dfs(board, row, col+1, word, start+1, M, N, sLen); board[row][col] = curC; return res; &#125; public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; int M,N,i,j,sLen = word.size(); if( (M=board.size()) &amp;&amp; (N=board[0].size()) &amp;&amp; sLen) &#123; for(i=0; i&lt;M; ++i) for(j=0; j&lt;N; ++j) if(dfs(board, i, j, word, 0, M, N, sLen)) return true; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/22788/python-dfs-solution-with-comments Python dfs solution with comments. 12345678910111213141516171819202122def exist(self, board, word): if not board: return False for i in xrange(len(board)): for j in xrange(len(board[0])): if self.dfs(board, i, j, word): return True return False# check whether can find word, start at (i,j) position def dfs(self, board, i, j, word): if len(word) == 0: # all the characters are checked return True if i&lt;0 or i&gt;=len(board) or j&lt;0 or j&gt;=len(board[0]) or word[0]!=board[i][j]: return False tmp = board[i][j] # first character is found, check the remaining part board[i][j] = &quot;#&quot; # avoid visit agian # check whether can find &quot;word&quot; along one direction res = self.dfs(board, i+1, j, word[1:]) or self.dfs(board, i-1, j, word[1:]) \ or self.dfs(board, i, j+1, word[1:]) or self.dfs(board, i, j-1, word[1:]) board[i][j] = tmp return res https://discuss.leetcode.com/topic/12391/python-simple-dfs-solution Python simple dfs solution 1234567891011121314151617181920212223242526272829def exist(self, board, word): if not word: return True if not board: return False for i in range(len(board)): for j in range(len(board[0])): if self.exist_helper(board, word, i, j): return True return False def exist_helper(self, board, word, i, j): if board[i][j] == word[0]: if not word[1:]: return True board[i][j] = &quot; &quot; # indicate used cell # check all adjacent cells if i &gt; 0 and self.exist_helper(board, word[1:], i-1, j): return True if i &lt; len(board)-1 and self.exist_helper(board, word[1:], i+1, j): return True if j &gt; 0 and self.exist_helper(board, word[1:], i, j-1): return True if j &lt; len(board[0])-1 and self.exist_helper(board, word[1:], i, j+1): return True board[i][j] = word[0] # update the cell to its original value return False else: return False java https://discuss.leetcode.com/topic/7907/accepted-very-short-java-solution-no-additional-space Accepted very short Java solution. No additional space. Here accepted solution based on recursion. To save memory I decuded to apply bit mask for every visited cell. Please check board[y][x] ^= 256; 12345678910111213141516171819202122public boolean exist(char[][] board, String word) &#123; char[] w = word.toCharArray(); for (int y=0; y&lt;board.length; y++) &#123; for (int x=0; x&lt;board[y].length; x++) &#123; if (exist(board, y, x, w, 0)) return true; &#125; &#125; return false;&#125;private boolean exist(char[][] board, int y, int x, char[] word, int i) &#123; if (i == word.length) return true; if (y&lt;0 || x&lt;0 || y == board.length || x == board[y].length) return false; if (board[y][x] != word[i]) return false; board[y][x] ^= 256; boolean exist = exist(board, y, x+1, word, i+1) || exist(board, y, x-1, word, i+1) || exist(board, y+1, x, word, i+1) || exist(board, y-1, x, word, i+1); board[y][x] ^= 256; return exist;&#125; https://discuss.leetcode.com/topic/25591/simple-solution Simple solution 12345678910111213141516171819202122public boolean exist(char[][] board, String word) &#123; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[i].length; j++) &#123; if(exist(board, i, j, word, 0)) return true; &#125; &#125; return false;&#125;private boolean exist(char[][] board, int x, int y, String word, int start) &#123; if(start &gt;= word.length()) return true; if(x &lt; 0 || x &gt;= board.length || y &lt; 0 || y &gt;= board[0].length) return false; if (board[x][y] == word.charAt(start++)) &#123; char c = board[x][y]; board[x][y] = &apos;#&apos;; boolean res = exist(board, x + 1, y, word, start) || exist(board, x - 1, y, word, start) || exist(board, x, y + 1, word, start) || exist(board, x, y - 1, word, start); board[x][y] = c; return res; &#125; return false;&#125; https://discuss.leetcode.com/topic/21142/my-java-solution My Java solution 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; static boolean[][] visited; public boolean exist(char[][] board, String word) &#123; visited = new boolean[board.length][board[0].length]; for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[i].length; j++)&#123; if((word.charAt(0) == board[i][j]) &amp;&amp; search(board, word, i, j, 0))&#123; return true; &#125; &#125; &#125; return false; &#125; private boolean search(char[][]board, String word, int i, int j, int index)&#123; if(index == word.length())&#123; return true; &#125; if(i &gt;= board.length || i &lt; 0 || j &gt;= board[i].length || j &lt; 0 || board[i][j] != word.charAt(index) || visited[i][j])&#123; return false; &#125; visited[i][j] = true; if(search(board, word, i-1, j, index+1) || search(board, word, i+1, j, index+1) || search(board, word, i, j-1, index+1) || search(board, word, i, j+1, index+1))&#123; return true; &#125; visited[i][j] = false; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[078. Subsets]]></title>
    <url>%2Fp%2Fb92586e7%2F</url>
    <content type="text"><![CDATA[37.7% https://leetcode.com/problems/subsets/ Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. 12345678910111213For example,If nums = [1,2,3], a solution is:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 最标准解法，回溯法 位运算法，计算答案个数为2**n个，然后针对每一个，进行位运算，计算是否有相应位。 类似于动态规划，如果是0个数字，那肯定是空集。如果有一个元素，则要么是原答案空集，要么所有答案都加上这个新元素，所以每次翻倍。 方法一： my code: 回溯法：还需要再思考和理解 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs; vector&lt;int&gt; sub; genSubsets(nums, 0, sub, subs); return subs; &#125; void genSubsets(vector&lt;int&gt;&amp; nums, int start, vector&lt;int&gt;&amp; sub, vector&lt;vector&lt;int&gt;&gt;&amp; subs) &#123; subs.push_back(sub); for (int i = start; i &lt; nums.size(); i++) &#123; sub.push_back(nums[i]); genSubsets(nums, i + 1, sub, subs); sub.pop_back(); &#125; &#125;&#125;; 回溯法，我的实现 dfs表示，从0开始至n的一个回溯。 dfs(res, tmp, i+1, n, nums)表示从i+1开始的 可以看出，从start为第一个，开始，dfs一下后面的结果。 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; dfs(res, tmp, 0, nums.size(), nums); return res; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt;&amp; tmp, int start, int n, vector&lt;int&gt;&amp; nums)&#123; res.push_back(tmp); for(int i=start; i&lt;n; i++)&#123; tmp.push_back(nums[i]); dfs(res, tmp, i+1, n, nums); tmp.pop_back(); &#125; &#125;&#125;; 我的代码实现： 8.27.2017 12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; dfs(nums, res, tmp, 0); return res; &#125; void dfs(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, int k)&#123; res.push_back(tmp); if(k&gt;=nums.size()) return; for(int i=k; i&lt;nums.size(); i++)&#123; tmp.push_back(nums[i]); dfs(nums, res, tmp, i+1); tmp.pop_back(); &#125; &#125;&#125;; 方法二： 位运算： 12345678910111213141516class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int n = nums.size(); int subnum = pow(2, n); vector&lt;vector&lt;int&gt;&gt; res(subnum, vector&lt;int&gt;()); for(int i=0; i&lt;subnum; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if((i&gt;&gt;j)&amp;1) res[i].push_back(nums[j]); &#125; &#125; return res; &#125;&#125;; 方法三： 类似于dp的解法： 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs(1, vector&lt;int&gt;()); for (int i = 0; i &lt; nums.size(); i++) &#123; int n = subs.size(); for (int j = 0; j &lt; n; j++) &#123; subs.push_back(subs[j]); subs.back().push_back(nums[i]); &#125; &#125; return subs; &#125;&#125;; 下面这个discuss，很棒。 https://discuss.leetcode.com/topic/19110/c-recursive-iterative-bit-manipulation-solutions-with-explanations C++ Recursive/Iterative/Bit-Manipulation Solutions with Explanations Recursive (Backtracking) This is a typical problem that can be tackled by backtracking. Since backtracking has a more-or-less similar template, so I do not give explanations for this method. 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs; vector&lt;int&gt; sub; genSubsets(nums, 0, sub, subs); return subs; &#125; void genSubsets(vector&lt;int&gt;&amp; nums, int start, vector&lt;int&gt;&amp; sub, vector&lt;vector&lt;int&gt;&gt;&amp; subs) &#123; subs.push_back(sub); for (int i = start; i &lt; nums.size(); i++) &#123; sub.push_back(nums[i]); genSubsets(nums, i + 1, sub, subs); sub.pop_back(); &#125; &#125;&#125;; Iterative This problem can also be solved iteratively. Take [1, 2, 3] in the problem statement as an example. The process of generating all the subsets is like: Initially: [[]] Adding the first number to all the existed subsets: [[], [1]]; Adding the second number to all the existed subsets: [[], [1], [2], [1, 2]]; Adding the third number to all the existed subsets: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]. Have you got the idea :-) The code is as follows. 123456789101112131415class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; subs(1, vector&lt;int&gt;()); for (int i = 0; i &lt; nums.size(); i++) &#123; int n = subs.size(); for (int j = 0; j &lt; n; j++) &#123; subs.push_back(subs[j]); subs.back().push_back(nums[i]); &#125; &#125; return subs; &#125;&#125;; Bit Manipulation This is the most clever solution that I have seen. The idea is that to give all the possible subsets, we just need to exhaust all the possible combinations of the numbers. And each number has only two possibilities: either in or not in a subset. And this can be represented using a bit. There is also another a way to visualize this idea. That is, if we use the above example, 1 appears once in every two consecutive subsets, 2 appears twice in every four consecutive subsets, and 3 appears four times in every eight subsets, shown in the following (initially the 8 subsets are all empty): 1234567[], [], [], [], [], [], [], [][], [1], [], [1], [], [1], [], [1][], [1], [2], [1, 2], [], [1], [2], [1, 2][], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3] The code is as follows. 12345678910111213class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int num_subset = pow(2, nums.size()); vector&lt;vector&lt;int&gt; &gt; res(num_subset, vector&lt;int&gt;()); for (int i = 0; i &lt; nums.size(); i++) for (int j = 0; j &lt; num_subset; j++) if ((j &gt;&gt; i) &amp; 1) res[j].push_back(nums[i]); return res; &#125;&#125;; Well, just a final remark. For Python programmers, this may be an easy task in practice since the itertools package has a function combinations for it :-) https://discuss.leetcode.com/topic/19110/c-recursive-iterative-bit-manipulation-solutions-with-explanations/2 Interesting way to use the bit masks, building all subsets in parallel. I don’t think I’ve seen that before. Made me write a way to “only iterate over the 1-bits”: 1234for (int i = 0; i &lt; nums.size(); i++) for (int step = 1 &lt;&lt; i, start = 0; start &lt; num_subset; start += 2 * step) for (int j = start; j &lt; start + step; j++) res[j].push_back(nums[i]); Don’t know whether it’s faster. Overall, half of the bits are 1 anyway, so I save at most 50%. And I might have more overhead costs. Python’s combinations doesn’t quite do it, btw, it only creates subsets of a certain size. But it can be used, yes. Doesn’t help much compared to other solutions, though, as you can see here. And Ruby is even shorter :-) https://discuss.leetcode.com/topic/2764/my-solution-using-bit-manipulation My solution using bit manipulation 1234567891011121314class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt; &amp;S) &#123; sort (S.begin(), S.end()); int elem_num = S.size(); int subset_num = pow (2, elem_num); vector&lt;vector&lt;int&gt; &gt; subset_set (subset_num, vector&lt;int&gt;()); for (int i = 0; i &lt; elem_num; i++) for (int j = 0; j &lt; subset_num; j++) if ((j &gt;&gt; i) &amp; 1) subset_set[j].push_back (S[i]); return subset_set; &#125;&#125;; https://discuss.leetcode.com/topic/2764/my-solution-using-bit-manipulation/7 123456789101112131415161718192021222324252627282930313233343536This is an amazing solution.Learnt a lot.Let me try to explain this to those who didn&apos;t get the logic. Number of subsets for &#123;1 , 2 , 3 &#125; = 2^3 . why ? case possible outcomes for the set of subsets 1 -&gt; Take or dont take = 2 2 -&gt; Take or dont take = 2 3 -&gt; Take or dont take = 2 therefore , total = 2*2*2 = 2^3 = &#123; &#123; &#125; , &#123;1&#125; , &#123;2&#125; , &#123;3&#125; , &#123;1,2&#125; , &#123;1,3&#125; , &#123;2,3&#125; , &#123;1,2,3&#125; &#125;Lets assign bits to each outcome -&gt; First bit to 1 , Second bit to 2 and third bit to 3Take = 1Dont take = 0 0) 0 0 0 -&gt; Dont take 3 , Dont take 2 , Dont take 1 = &#123; &#125; 1) 0 0 1 -&gt; Dont take 3 , Dont take 2 , take 1 = &#123;1 &#125; 2) 0 1 0 -&gt; Dont take 3 , take 2 , Dont take 1 = &#123; 2 &#125; 3) 0 1 1 -&gt; Dont take 3 , take 2 , take 1 = &#123; 1 , 2 &#125; 4) 1 0 0 -&gt; take 3 , Dont take 2 , Dont take 1 = &#123; 3 &#125; 5) 1 0 1 -&gt; take 3 , Dont take 2 , take 1 = &#123; 1 , 3 &#125; 6) 1 1 0 -&gt; take 3 , take 2 , Dont take 1 = &#123; 2 , 3 &#125; 7) 1 1 1 -&gt; take 3 , take 2 , take 1 = &#123; 1 , 2 , 3 &#125; In the above logic ,Insert S[i] only if (j&gt;&gt;i)&amp;1 ==true &#123; j E &#123; 0,1,2,3,4,5,6,7 &#125; i = ith element in the input array &#125;element 1 is inserted only into those places where 1st bit of j is 1 if( j &gt;&gt; 0 &amp;1 ) ==&gt; for above above eg. this is true for sl.no.( j )= 1 , 3 , 5 , 7 element 2 is inserted only into those places where 2nd bit of j is 1 if( j &gt;&gt; 1 &amp;1 ) == for above above eg. this is true for sl.no.( j ) = 2 , 3 , 6 , 7element 3 is inserted only into those places where 3rd bit of j is 1 if( j &gt;&gt; 2 &amp; 1 ) == for above above eg. this is true for sl.no.( j ) = 4 , 5 , 6 , 7 Time complexity : O(n*2^n) , for every input element loop traverses the whole solution set length i.e. 2^n https://discuss.leetcode.com/topic/11373/c-8ms-simple-iterative-solution C++ 8ms simple iterative solution 1234567891011121314151617class Solution &#123;public:vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt; &amp;S) &#123; vector&lt;vector&lt;int&gt; &gt; res(1, vector&lt;int&gt;()); sort(S.begin(), S.end()); for (int i = 0; i &lt; S.size(); i++) &#123; int n = res.size(); for (int j = 0; j &lt; n; j++) &#123; res.push_back(res[j]); res.back().push_back(S[i]); &#125; &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/19561/python-easy-to-understand-solutions-dfs-recursively-bit-manipulation-iteratively Python easy to understand solutions (DFS recursively, Bit Manipulation, Iteratively). 12345678910# DFS recursively def subsets1(self, nums): res = [] self.dfs(sorted(nums), 0, [], res) return res def dfs(self, nums, index, path, res): res.append(path) for i in xrange(index, len(nums)): self.dfs(nums, i+1, path+[nums[i]], res) 1234567891011# Bit Manipulation def subsets2(self, nums): res = [] nums.sort() for i in xrange(1&lt;&lt;len(nums)): tmp = [] for j in xrange(len(nums)): if i &amp; 1 &lt;&lt; j: # if i &gt;&gt; j &amp; 1: tmp.append(nums[j]) res.append(tmp) return res 123456# Iterativelydef subsets(self, nums): res = [[]] for num in sorted(nums): res += [item+[num] for item in res] return res https://discuss.leetcode.com/topic/30867/simple-iteration-no-recursion-no-twiddling-explanation Simple iteration (no recursion, no twiddling) + explanation My idea was to start out with an empty subset and either take or don’t take the next element in the input array. Here’s how it goes down for input [1,2,3]: start with 1[] // empty set is always a subset then either take or not take the next element (1), this doubles the result size: 12[] // not take 1[1] // take 1 + new then take or not take the next element: 2 1234[] // not take 1, not take 2[2] // not take 1, take 2 + new[1] // take 1, not take 2[1,2] // take 1, take 2 + new and finally take or not take 3. 12345678[] // not take 1, not take 2, not take 3[3] // not take 1, not take 2, take 3 + new[2] // not take 1, take 2, not take 3[2,3] // not take 1, take 2, take 3 + new[1] // take 1, not take 2, not take 3[1,3] // take 1, not take 2, take 3 + new[1,2] // take 1, take 2, not take 3[1,2,3] // take 1, take 2, take 3 + new And we’re done, we have all 2^3 = 8 subsets generated. It is possible to generate these with a simple loop, there’s only one trick here, the variable size. It’s usually a good practice to cache method call results, but now it is cached for a different reason: because it changes in every iteration. If we don’t want to end up with an infinite loop, we have to remember how many results were available in the previous iteration, which is exactly the size() of the result at the beginning of the current iteration. 12345678910111213public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; Arrays.sort(nums); // make sure subsets are ordered List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); result.add(new ArrayList&lt;&gt;()); // start with empty set for (int i = 0; i &lt; nums.length; ++i) &#123; for (int j = 0, size = result.size(); j &lt; size; ++j) &#123; // remember List&lt;Integer&gt; subset = new ArrayList&lt;&gt;(result.get(j)); // copy a new one subset.add(nums[i]); // expand result.add(subset); // collect &#125; &#125; return result;&#125; It is also necessary to order the input to satisfy the requirement: 1Elements in a subset must be in non-descending order. Because i is increasing it means that whatever we take from nums will also be in increasing order. The other requirement: 1The solution set must not contain duplicate subsets. is automatically guaranteed by the input specification and the algorithm walking indices straight and once: 1Given a set of distinct integers, nums, return all possible subsets. [emphasis mine] java https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning) This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. Subsets : https://leetcode.com/problems/subsets/ 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Subsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Permutations : https://leetcode.com/problems/permutations/ 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/ 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum : https://leetcode.com/problems/combination-sum/ 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum II (can’t reuse same element) : https://leetcode.com/problems/combination-sum-ii/ 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Palindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/ 12345678910111213141516171819202122232425public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list;&#125;public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125;&#125;public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true;&#125; https://discuss.leetcode.com/topic/9031/simple-java-solution-with-for-each-loops Simple Java Solution with For-Each loops No messy indexing. Avoid the ConcurrentModificationException by using a temp list. 123456789101112131415161718public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] S) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); res.add(new ArrayList&lt;Integer&gt;()); Arrays.sort(S); for(int i : S) &#123; List&lt;List&lt;Integer&gt;&gt; tmp = new ArrayList&lt;&gt;(); for(List&lt;Integer&gt; sub : res) &#123; List&lt;Integer&gt; a = new ArrayList&lt;&gt;(sub); a.add(i); tmp.add(a); &#125; res.addAll(tmp); &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/10885/java-subsets-solution Java subsets solution 123456789101112131415161718192021222324public class Solution &#123;public List&lt;List&lt;Integer&gt;&gt; subsets(int[] S) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(S.length == 0)&#123; return result; &#125; Arrays.sort(S); dfs(S, 0, new ArrayList&lt;Integer&gt;(), result); return result;&#125;public void dfs(int[] s, int index, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result)&#123; result.add(new ArrayList&lt;Integer&gt;(path)); for(int i = index; i &lt; s.length; i++)&#123; path.add(s[i]); dfs(s, i+1, path, result); path.remove(path.size()-1); &#125;&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>backtracking</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[077. Combinations]]></title>
    <url>%2Fp%2F20864a35%2F</url>
    <content type="text"><![CDATA[39.6% https://leetcode.com/problems/combinations/ Given two integers n and k, return all possible combinations of k numbers out of 1 … n. 1234567891011For example,If n = 4 and k = 2, a solution is:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 方法一： 回溯法，dfs code 1： My shortest c++ solution,using dfs my idea is using backtracking ,every time I push a number into vector,then I push a bigger one into it; then i pop the latest one,and push a another bigger one… and if I has push k number into vector,I push this into result; this solution take 24 ms. 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt; &gt;res; if(n&lt;k)return res; vector&lt;int&gt; temp(0,k); combine(res,temp,0,0,n,k); return res; &#125; void combine(vector&lt;vector&lt;int&gt; &gt; &amp;res,vector&lt;int&gt; &amp;temp,int start,int num,int n ,int k)&#123; if(num==k)&#123; res.push_back(temp); return; &#125; for(int i = start;i&lt;n;i++)&#123; temp.push_back(i+1); combine(res,temp,i+1,num+1,n,k); temp.pop_back(); &#125; &#125;&#125;; code 2: 我的实现 经典的回溯法算法，一定要会。 my code： 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; if(n&lt;k) return res; dfs(res, tmp, 0, 0, n, k); return res; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; tmp, int start, int num, int n, int k)&#123; if(num==k)&#123; res.push_back(tmp); return; &#125; for(int i=start+1; i&lt;=n; i++)&#123; tmp.push_back(i); dfs(res, tmp, i, num+1, n, k); tmp.pop_back(); &#125; &#125;&#125;; code 3： https://discuss.leetcode.com/topic/22569/c-concise-recursive-solution-c-n-k-c-n-1-k-1-8ms C++ concise recursive solution C(n,k) -&gt;C(n-1,k-1) / 8ms 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; temp; combine(1,n,k,ans,temp); //call fuction to get combination of k numbers which range is 1-n return ans; &#125;private: void combine(int begin,int n, int k, vector&lt;vector&lt;int&gt;&gt; &amp;ans, vector&lt;int&gt;&amp; temp)&#123; if(k==0)&#123; ans.push_back(temp); return; &#125; //condition : n-i+1 is the range, range must greater than k for(int i=begin;n-i+1&gt;=k;i++)&#123; // for the ith iteration, get the combination of i and k-1 numbers differ from i. temp.push_back(i); combine(i+1,n,k-1,ans,temp);// get the combination of k-1 numbers which range is(i+1,n) temp.pop_back(); &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/26689/short-iterative-c-answer-8ms Short Iterative C++ Answer 8ms 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; result; int i = 0; vector&lt;int&gt; p(k, 0); while (i &gt;= 0) &#123; p[i]++; if (p[i] &gt; n) --i; else if (i == k - 1) result.push_back(p); else &#123; ++i; p[i] = p[i - 1]; &#125; &#125; return result; &#125;&#125;; 12ms, 27.43%, May.6th, 2016 https://leetcode.com/discuss/12915/my-shortest-c-solution-using-dfs My shortest c++ solution,using dfs my idea is using backtracking ,every time I push a number into vector,then I push a bigger one into it; then i pop the latest one,and push a another bigger one… and if I has push k number into vector,I push this into result; this solution take 24 ms. 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt; &gt;res; if(n&lt;k)return res; vector&lt;int&gt; temp(0,k); combine(res,temp,0,0,n,k); return res; &#125; void combine(vector&lt;vector&lt;int&gt; &gt; &amp;res,vector&lt;int&gt; &amp;temp,int start,int num,int n ,int k)&#123; if(num==k)&#123; res.push_back(temp); return; &#125; for(int i = start;i&lt;n;i++)&#123; temp.push_back(i+1); combine(res,temp,i+1,num+1,n,k); temp.pop_back(); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/22569/c-concise-recursive-solution-c-n-k-c-n-1-k-1-8ms C++ concise recursive solution C(n,k) -&gt;C(n-1,k-1) / 8ms 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; temp; combine(1,n,k,ans,temp); //call fuction to get combination of k numbers which range is 1-n return ans; &#125;private: void combine(int begin,int n, int k, vector&lt;vector&lt;int&gt;&gt; &amp;ans, vector&lt;int&gt;&amp; temp)&#123; if(k==0)&#123; ans.push_back(temp); return; &#125; //condition : n-i+1 is the range, range must greater than k for(int i=begin;n-i+1&gt;=k;i++)&#123; // for the ith iteration, get the combination of i and k-1 numbers differ from i. temp.push_back(i); combine(i+1,n,k-1,ans,temp);// get the combination of k-1 numbers which range is(i+1,n) temp.pop_back(); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/14626/1-liner-3-liner-4-liner 1-liner, 3-liner, 4-liner Library - AC in 64 ms First the obvious solution - Python already provides this functionality and it’s not forbidden, so let’s take advantage of it. 12345from itertools import combinationsclass Solution: def combine(self, n, k): return list(combinations(range(1, n+1), k)) Recursive - AC in 76 ms But doing it yourself is more interesting, and not that hard. Here’s a recursive version. 12345class Solution: def combine(self, n, k): if k == 0: return [[]] return [pre + [i] for i in range(1, n+1) for pre in self.combine(i-1, k-1)] Iterative - AC in 76 ms And here’s an iterative one. 123456class Solution: def combine(self, n, k): combs = [[]] for _ in range(k): combs = [[i] + c for c in combs for i in range(1, c[0] if c else n+1)] return combs Reduce - AC in 76 ms Same as that iterative one, but using reduce instead of a loop: 1234class Solution: def combine(self, n, k): return reduce(lambda C, _: [[i]+c for c in C for i in range(1, c[0] if c else n+1)], range(k), [[]]) https://discuss.leetcode.com/topic/25958/ac-python-backtracking-iterative-solution-60-ms AC Python backtracking iterative solution 60 ms 1234567891011121314151617181920def combine(self, n, k): ans = [] stack = [] x = 1 while True: l = len(stack) if l == k: ans.append(stack[:]) if l == k or x &gt; n - k + l + 1: if not stack: return ans x = stack.pop() + 1 else: stack.append(x) x += 1# 26 / 26 test cases passed.# Status: Accepted# Runtime: 60 ms# 98.51% Combinations is typical application for backtracking. Two conditions for back track: (1) the stack length is already k (2) the current value is too large for the rest slots to fit in since we are using ascending order to make sure the uniqueness of each combination. java https://discuss.leetcode.com/topic/11718/backtracking-solution-java Backtracking Solution Java 12345678910111213141516public static List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; combs = new ArrayList&lt;List&lt;Integer&gt;&gt;(); combine(combs, new ArrayList&lt;Integer&gt;(), 1, n, k); return combs;&#125;public static void combine(List&lt;List&lt;Integer&gt;&gt; combs, List&lt;Integer&gt; comb, int start, int n, int k) &#123; if(k==0) &#123; combs.add(new ArrayList&lt;Integer&gt;(comb)); return; &#125; for(int i=start;i&lt;=n;i++) &#123; comb.add(i); combine(combs, comb, i+1, n, k-1); comb.remove(comb.size()-1); &#125;&#125; https://discuss.leetcode.com/topic/12537/a-short-recursive-java-solution-based-on-c-n-k-c-n-1-k-1-c-n-1-k A short recursive Java solution based on C(n,k)=C(n-1,k-1)+C(n-1,k) Basically, this solution follows the idea of the mathematical formula C(n,k)=C(n-1,k-1)+C(n-1,k). Here C(n,k) is divided into two situations. Situation one, number n is selected, so we only need to select k-1 from n-1 next. Situation two, number n is not selected, and the rest job is selecting k from n-1. 123456789101112131415public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; if (k == n || k == 0) &#123; List&lt;Integer&gt; row = new LinkedList&lt;&gt;(); for (int i = 1; i &lt;= k; ++i) &#123; row.add(i); &#125; return new LinkedList&lt;&gt;(Arrays.asList(row)); &#125; List&lt;List&lt;Integer&gt;&gt; result = this.combine(n - 1, k - 1); result.forEach(e -&gt; e.add(n)); result.addAll(this.combine(n - 1, k)); return result; &#125;&#125; https://discuss.leetcode.com/topic/3943/dp-for-the-problem DP for the problem I didn’t see any DP solution for this problem, so I share mine: The idea is simple, if the combination k out of n (select k elements from [1,n]) is combine(k, n). Let’s consider how can we get combine(k, n) by adding the last element n to something we already have (combine(k - 1, n - 1) and combine(k, n - 1)). Actually, the combine(k, n) has two parts, one part is all combinations without n, it’s combine(k, n - 1), another is all combinations with n, which can be gotten by appending n to every element in combine(k - 1, n - 1). Note, the combine(i, i) is what we can get directly. Below is my code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Solution&#123; // Combine(n, n). private List&lt;Integer&gt; allContain(int n) &#123; final List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= n; ++i) &#123; result.add(i); &#125; return result; &#125; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;List&lt;Integer&gt;&gt;&gt; previous = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= n; ++i) &#123; previous.add(Collections.singletonList(Collections.&lt;Integer&gt;emptyList())); &#125; for (int i = 1; i &lt;= k; ++i) &#123; final List&lt;List&lt;List&lt;Integer&gt;&gt;&gt; current = new ArrayList&lt;&gt;(); current.add(Collections.singletonList(allContain(i))); // Combine(i, j). for (int j = i + 1; j &lt;= n; ++j) &#123; final List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Combine(i, j - 1). list.addAll(current.get(current.size() - 1)); // Comine(i - 1, j - 1). for (final List&lt;Integer&gt; item : previous.get(current.size())) &#123; final List&lt;Integer&gt; newItem = new ArrayList&lt;&gt;(item); newItem.add(j); list.add(newItem); &#125; current.add(list); &#125; previous = current; &#125; return (previous.size() == 0) ? Collections.&lt;List&lt;Integer&gt;&gt;emptyList() : previous.get(previous.size() - 1); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[076. Minimum Window Substring]]></title>
    <url>%2Fp%2F9aa229a6%2F</url>
    <content type="text"><![CDATA[25.7% https://leetcode.com/problems/minimum-window-substring/ Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). 1234For example,S = &quot;ADOBECODEBANC&quot;T = &quot;ABC&quot;Minimum window is &quot;BANC&quot;. Note:If there is no such window in S that covers all characters in T, return the empty string “”. If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S. Subscribe to see which companies asked this question 方法一： 我的代码实现，更容易理解逻辑，如下： 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string minWindow(string s, string t) &#123; int m = s.size(), n = t.size(); if(n&gt;m) return &quot;&quot;; vector&lt;int&gt; v(256, 0); for(int i=0; i&lt;n; i++) v[t[i]]++; int left = 0; int right = 0; int head = 0; int len = INT_MAX; int cnt = n; while(right&lt;m)&#123; if(v[s[right]]&gt;0) cnt--; v[s[right]]--; right++; while(cnt==0)&#123; // left++, 不考虑left&gt;=m 因为left不可能&gt;=m，否则cnt！=0 if(right-left&lt;len)&#123; head = left; len = right-left; &#125; if(v[s[left]]==0) cnt++; v[s[left]]++; left++; &#125; &#125; return len!=INT_MAX?s.substr(head, len):&quot;&quot;; &#125;&#125;; 重点方法，重点学习，并且带有模板 https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems 9ms, 86.18%, September 22, 2016 Here is a 10-line template that can solve most ‘substring’ problems I will first give the solution then show you the magic template. The code of solving this problem is below. It might be the shortest among all solutions provided in Discuss. 12345678910111213141516class Solution &#123;public: string minWindow(string s, string t) &#123; vector&lt;int&gt; map(128, 0); for(auto c:t) map[c]++; int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0; while(end&lt;s.size())&#123; if(map[s[end++]]--&gt;0) counter--; while(counter==0)&#123; if(end-begin&lt;d) d=end-(head=begin); if(map[s[begin++]]++==0) counter++; &#125; &#125; return d==INT_MAX?&quot;&quot;:s.substr(head, d); &#125;&#125;; Here comes the template. For most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers. The template is given below. 12345678910111213141516171819202122232425int findSubstring(string s)&#123; vector&lt;int&gt; map(128,0); int counter; // check whether the substring is valid int begin=0, end=0; //two pointers, one point to tail and one head int d; //the length of substring for() &#123; /* initialize the hash map here */ &#125; while(end&lt;s.size())&#123; if(map[s[end++]]-- ?)&#123; /* modify counter here */ &#125; while(/* counter condition */)&#123; /* update d here if finding minimum*/ //increase begin to make it invalid/valid again if(map[s[begin++]]++ ?)&#123; /*modify counter here*/ &#125; &#125; /* update d here if finding maximum*/ &#125; return d; &#125; One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop. The code of solving Longest Substring with At Most Two Distinct Characters is below: 12345678910int lengthOfLongestSubstringTwoDistinct(string s) &#123; vector&lt;int&gt; map(128, 0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++==0) counter++; while(counter&gt;2) if(map[s[begin++]]--==1) counter--; d=max(d, end-begin); &#125; return d; &#125; Longest Substring with At Most Two Distinct Characters （带锁） The code of solving Longest Substring Without Repeating Characters is below: Update 01.04.2016, thanks @weiyi3 for advise. 12345678910int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; map(128,0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++&gt;0) counter++; while(counter&gt;0) if(map[s[begin++]]--&gt;1) counter--; d=max(d, end-begin); //while valid, update d &#125; return d; &#125; I think this post deserves some upvotes! : ) code 2： 代码解读： 12345678910111213141516171819202122232425// S = &quot;ADOBECODEBANC&quot;// T = &quot;ABC&quot;class Solution &#123;public: string minWindow(string s, string t) &#123; vector&lt;int&gt; map(128, 0); for(auto c:t) map[c]++; int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0; while(end&lt;s.size())&#123; if(map[s[end++]]--&gt;0) counter--; while(counter==0)&#123; // 如果能进入count==0， 说明begin至end之间的包括t的所有字符 if(end-begin&lt;d)&#123; //简单的判断 head = begin; d = end - head; &#125; if(map[s[begin]]==0)&#123;// begin指向值的如果在此时是0，说明这个值一定是t的值，如果不是，值一定是负的，因为前面减了。 counter++; &#125; map[s[begin]]++; // 本来进入一个值是减的，减少一个值，这个map值的增加的 begin++; // 如果进入了满足counter==0状态，肯定要begin++，向前走的 &#125; &#125; return d==INT_MAX?&quot;&quot;:s.substr(head, d); &#125;&#125;; https://discuss.leetcode.com/topic/3107/accepted-o-n-solution https://oj.leetcode.com/discuss/5469/is-the-length-of-t-considered-constant-or-m Implementation of mike3’s idea 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: string minWindow(string S, string T) &#123; if (S.empty() || T.empty()) &#123; return &quot;&quot;; &#125; int count = T.size(); int require[128] = &#123;0&#125;; bool chSet[128] = &#123;false&#125;; for (int i = 0; i &lt; count; ++i) &#123; require[T[i]]++; chSet[T[i]] = true; &#125; int i = -1; int j = 0; int minLen = INT_MAX; int minIdx = 0; while (i &lt; (int)S.size() &amp;&amp; j &lt; (int)S.size()) &#123; if (count) &#123; i++; require[S[i]]--; if (chSet[S[i]] &amp;&amp; require[S[i]] &gt;= 0) &#123; count--; &#125; &#125; else &#123; if (minLen &gt; i - j + 1) &#123; minLen = i - j + 1; minIdx = j; &#125; require[S[j]]++; if (chSet[S[j]] &amp;&amp; require[S[j]] &gt; 0) &#123; count++; &#125; j++; &#125; &#125; if (minLen == INT_MAX) &#123; return &quot;&quot;; &#125; return S.substr(minIdx, minLen); &#125;&#125;; https://discuss.leetcode.com/topic/6026/sharing-my-straightforward-o-n-solution-with-explanation There are three key variables in my solution: 1unordered_map &lt;char, int&gt; map; unordered_map&lt;char, int&gt; window; int letterCounter; variable “map” is used to indicate what characters and how many characters are in T. variable “window” is to indicate what characters and how many characters are between pointer “slow” and pointer “fast”. Now let’s start. The first For loop is used to construct variable “map”. The second For loop is used to find the minimum window. The first thing we should do in the second For loop is to find a window which can cover T. I use “letterCounter” to be a monitor. If “letterCounter” is equal to T.length(), then we find this window. Before that, only the first If clause can be executed. However, after we find this window, the second If clause can also be executed. In the second If clause, we move “slow” forward in order to shrink the window size. Every time finding a smaller window, I update the result. At the end of program, I return result, which is the minimum window. 123456789101112131415161718192021222324252627282930313233string minWindow(string S, string T) &#123; string result; if(S.empty() || T.empty())&#123; return result; &#125; unordered_map&lt;char, int&gt; map; unordered_map&lt;char, int&gt; window; for(int i = 0; i &lt; T.length(); i++)&#123; map[T[i]]++; &#125; int minLength = INT_MAX; int letterCounter = 0; for(int slow = 0, fast = 0; fast &lt; S.length(); fast++)&#123; char c = S[fast]; if(map.find(c) != map.end())&#123; window[c]++; if(window[c] &lt;= map[c])&#123; letterCounter++; &#125; &#125; if(letterCounter &gt;= T.length())&#123; while(map.find(S[slow]) == map.end() || window[S[slow]] &gt; map[S[slow]])&#123; window[S[slow]]--; slow++; &#125; if(fast - slow + 1 &lt; minLength)&#123; minLength = fast - slow + 1; result = S.substr(slow, minLength); &#125; &#125; &#125; return result;&#125; python 232ms, 32.27%, September 23, 2016 12 lines Python https://discuss.leetcode.com/topic/20692/12-lines-python The current window is s[i:j] and the result window is s[I:J]. In need[c] I store how many times I need character c (can be negative) and missing tells how many characters are still missing. In the loop, first add the new character to the window. Then, if nothing is missing, remove as much as possible from the window start and then update the result.12345678910111213141516171819class Solution(object): def minWindow(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: str &quot;&quot;&quot; need, missing = collections.Counter(t), len(t) i = I = J = 0 for j, c in enumerate(s, 1): missing -= need[c] &gt; 0 need[c] -= 1 if not missing: while i&lt;j and need[s[i]] &lt; 0: need[s[i]] += 1 i += 1 if not J or j-i &lt;= J-I: I, J = i, j return s[I:J] https://discuss.leetcode.com/topic/6665/accepted-python-solution-using-hashtable Accepted Python solution using hashtable 1234567891011121314151617181920212223242526class Solution: # @return a string def minWindow(self, S, T): indices = &#123;&#125; for char in T: indices[char] = [] miss = list(T) start = 0 end = len(S) for i in range(len(S)): if S[i] in T: if S[i] not in miss and indices[S[i]] != []: indices[S[i]].pop(0) elif S[i] in miss: miss.remove(S[i]) indices[S[i]].append(i) if miss == []: maximum = max([x[-1] for x in indices.values()]) minimum = min([x[0] for x in indices.values()]) if maximum-minimum+1 &lt; end-start+1: start = minimum end = maximum if miss != []: return &quot;&quot; else: return S[start:end+1] Basically I kept a dictionary to record the index of each character of T. Each time I found a window, (when miss == []), I checked the length of this window by subtracting the maximum index and the minimum index of the characters. If this window is the smallest one so far, I record its beginning and ending index as “start” and “end.” java https://discuss.leetcode.com/topic/12492/share-my-neat-java-solution Share my neat java solution 123456789101112131415161718192021222324252627282930313233343536public String minWindow(String S, String T) &#123; if(S==null||S.isEmpty()||T==null||T.isEmpty()) return &quot;&quot;; int i=0, j=0; int[] Tmap=new int[256]; int[] Smap=new int[256]; for(int k=0; k&lt; T.length(); k++)&#123; Tmap[T.charAt(k)]++; &#125; int found=0; int length=Integer.MAX_VALUE; String res=&quot;&quot;; while(j&lt;S.length())&#123; if(found&lt;T.length())&#123; if(Tmap[S.charAt(j)]&gt;0)&#123; Smap[S.charAt(j)]++; if(Smap[S.charAt(j)]&lt;=Tmap[S.charAt(j)])&#123; found++; &#125; &#125; j++; &#125; while(found==T.length())&#123; if(j-i&lt;length)&#123; length=j-i; res=S.substring(i,j); &#125; if(Tmap[S.charAt(i)]&gt;0)&#123; Smap[S.charAt(i)]--; if(Smap[S.charAt(i)]&lt;Tmap[S.charAt(i)])&#123; found--; &#125; &#125; i++; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/21143/java-solution-using-two-pointers-hashmap Java solution. using two pointers + HashMap 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123;public String minWindow(String s, String t) &#123; if(s == null || s.length() &lt; t.length() || s.length() == 0)&#123; return &quot;&quot;; &#125; HashMap&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); for(char c : t.toCharArray())&#123; if(map.containsKey(c))&#123; map.put(c,map.get(c)+1); &#125;else&#123; map.put(c,1); &#125; &#125; int left = 0; int minLeft = 0; int minLen = s.length()+1; int count = 0; for(int right = 0; right &lt; s.length(); right++)&#123; if(map.containsKey(s.charAt(right)))&#123; map.put(s.charAt(right),map.get(s.charAt(right))-1); if(map.get(s.charAt(right)) &gt;= 0)&#123; count ++; &#125; while(count == t.length())&#123; if(right-left+1 &lt; minLen)&#123; minLeft = left; minLen = right-left+1; &#125; if(map.containsKey(s.charAt(left)))&#123; map.put(s.charAt(left),map.get(s.charAt(left))+1); if(map.get(s.charAt(left)) &gt; 0)&#123; count --; &#125; &#125; left ++ ; &#125; &#125; &#125; if(minLen&gt;s.length()) &#123; return &quot;&quot;; &#125; return s.substring(minLeft,minLeft+minLen);&#125;&#125; https://discuss.leetcode.com/topic/41308/java-4ms-bit-97-6 Java 4ms bit 97.6% Basically, there are two pointers for windows sliding. One for exploiting new matched substring, other pointer for expiring previous substring. 1234567891011121314151617181920212223242526272829303132333435363738public String minWindow(String s, String t) &#123; char[] s_array = s.toCharArray(); char[] t_array = t.toCharArray(); int[] map = new int[256]; int end = 0; int start = 0; int min_length = Integer.MAX_VALUE; for(int i = 0; i &lt; t_array.length; i++) map[t_array[i]] ++; int count = t_array.length; int min_start = 0; while(end &lt; s_array.length) &#123; if(map[s_array[end]] &gt; 0) &#123; count--; &#125; map[s_array[end]] --; while(count == 0) &#123; if((end - start + 1) &lt; min_length) &#123; min_length = end - start + 1; min_start = start; &#125; map[s_array[start]] ++; if(map[s_array[start]] &gt; 0)&#123; count ++; &#125; start++; &#125; end ++; &#125; if( min_start+min_length &gt; s_array.length) return &quot;&quot;; return s.substring(min_start, min_start+min_length); &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>string</tag>
        <tag>two pointers</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[075. Sort Colors]]></title>
    <url>%2Fp%2Fb84bd86e%2F</url>
    <content type="text"><![CDATA[37.0% https://leetcode.com/problems/sort-colors/ Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note:You are not suppose to use the library’s sort function for this problem. click to show follow up. Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with an one-pass algorithm using only constant space? 本题属于#三向快速排序#，可以参考#算法导论#。 方法一： 12345678910class Solution &#123;public: void sortColors(int A[], int n) &#123; int second=n-1, zero=0; for (int i=0; i&lt;=second; i++) &#123; while (A[i]==2 &amp;&amp; i&lt;second) swap(A[i], A[second--]); while (A[i]==0 &amp;&amp; i&gt;zero) swap(A[i], A[zero++]); &#125; &#125;&#125;; 我的实现： left定义为指向0的指针，right为2 i是遍历的指针指向的位置，从0开始。 如果nums[i]等于0， 则前面left指向0的尾部，left右边是1， 交换nums[i]与nums[++left]，nums[i]=1了相当于，num[++left]=0 如果nums[i]为2，则与尾部交换。由于交换后的结果不确定是几 所以此处i不增加 如果nums[i]为1，则默默增加i就行了。 left，right的初始定义值，借鉴的是算法导论里的方法。 1234567891011121314151617181920class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return; int left = -1, right = n; int i = 0; while(i&lt;right)&#123; if(nums[i]==0)&#123; swap(nums[++left], nums[i]); i++; &#125;else if(nums[i]==2)&#123; swap(nums[--right], nums[i]); &#125;else if(nums[i]==1)&#123; i++; &#125; &#125; return; &#125;&#125;; cpp https://discuss.leetcode.com/topic/5422/share-my-one-pass-constant-space-10-line-solution Share my one pass constant space 10-line solution The idea is to sweep all 0s to the left and all 2s to the right, then all 1s are left in the middle. 12345678910class Solution &#123;public: void sortColors(int A[], int n) &#123; int second=n-1, zero=0; for (int i=0; i&lt;=second; i++) &#123; while (A[i]==2 &amp;&amp; i&lt;second) swap(A[i], A[second--]); while (A[i]==0 &amp;&amp; i&gt;zero) swap(A[i], A[zero++]); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/6968/four-different-solutions Four different solutions 1234567891011121314// two pass O(m+n) spacevoid sortColors(int A[], int n) &#123; int num0 = 0, num1 = 0, num2 = 0; for(int i = 0; i &lt; n; i++) &#123; if (A[i] == 0) ++num0; else if (A[i] == 1) ++num1; else if (A[i] == 2) ++num2; &#125; for(int i = 0; i &lt; num0; ++i) A[i] = 0; for(int i = 0; i &lt; num1; ++i) A[num0+i] = 1; for(int i = 0; i &lt; num2; ++i) A[num0+num1+i] = 2;&#125; 123456789101112131415161718// one pass in place solutionvoid sortColors(int A[], int n) &#123; int n0 = -1, n1 = -1, n2 = -1; for (int i = 0; i &lt; n; ++i) &#123; if (A[i] == 0) &#123; A[++n2] = 2; A[++n1] = 1; A[++n0] = 0; &#125; else if (A[i] == 1) &#123; A[++n2] = 2; A[++n1] = 1; &#125; else if (A[i] == 2) &#123; A[++n2] = 2; &#125; &#125;&#125; 12345678910// one pass in place solutionvoid sortColors(int A[], int n) &#123; int j = 0, k = n - 1; for (int i = 0; i &lt;= k; ++i)&#123; if (A[i] == 0 &amp;&amp; i != j) swap(A[i--], A[j++]); else if (A[i] == 2 &amp;&amp; i != k) swap(A[i--], A[k--]); &#125;&#125; 12345678910// one pass in place solutionvoid sortColors(int A[], int n) &#123; int j = 0, k = n-1; for (int i=0; i &lt;= k; i++) &#123; if (A[i] == 0) swap(A[i], A[j++]); else if (A[i] == 2) swap(A[i--], A[k--]); &#125;&#125; https://discuss.leetcode.com/topic/36832/sharing-c-solution-with-good-explanation Sharing C++ solution with Good Explanation The solution requires the use of tracking 3 positions, the Low, Mid and High. We assume that the mid is the “Unknown” area that we must evaluate. If we encounter a 0, we know that it will be on the low end of the array, and if we encounter a 2, we know it will be on the high end of the array. To achieve this in one pass without preprocessing (counting), we simply traverse the unknown will generating the low and high ends. Take this example: Assume our input is: 1 0 2 2 1 0 (short for simplicity). Running the algorithm by hand would look something like: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647481 0 2 2 1 0^ ^L HMMid != 0 || 2Mid++1 0 2 2 1 0^ ^ ^L M HMid == 0Swap Low and MidMid++Low++0 1 2 2 1 0 ^ ^ ^ L M HMid == 2Swap High and MidHigh--0 1 0 2 1 2 ^ ^ ^ L M HMid == 0Swap Low and MidMid++Low++0 0 1 2 1 2 ^ ^ ^ L M HMid == 2Swap High and MidHigh--0 0 1 1 2 2 ^ ^ L M HMid &lt;= High is our exit case Implemented in C++, it looks like: 123456789101112131415161718192021222324252627282930class Solution &#123; public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int tmp = 0, low = 0, mid = 0, high = nums.size() - 1; while(mid &lt;= high) &#123; if(nums[mid] == 0) &#123; tmp = nums[low]; nums[low] = nums[mid]; nums[mid] = tmp; low++; mid++; &#125; else if(nums[mid] == 1) &#123; mid++; &#125; else if(nums[mid] == 2) &#123; tmp = nums[high]; nums[high] = nums[mid]; nums[mid] = tmp; high--; &#125; &#125; &#125;&#125;; my code: 1234567891011121314151617181920212223class Solution &#123;public: void sortColors(vector&lt;int&gt;&amp; nums) &#123; int lo = 0; int hi = nums.size()-1; int i=0; while(i&lt;=hi)&#123; if(nums[i]==2)&#123; swap(nums[i], nums[hi]); hi--; &#125; if(nums[i]==0)&#123; swap(nums[i], nums[lo]); lo++; i++; &#125; if(nums[i]==1)&#123; i++; &#125; &#125; return; &#125;&#125;; python https://discuss.leetcode.com/topic/26181/ac-python-in-place-one-pass-solution-o-n-time-o-1-space-no-swap-no-count AC Python in place one pass solution O(n) time O(1) space, no swap no count 12345678910111213141516def sortColors(self, nums): i = j = 0 for k in xrange(len(nums)): v = nums[k] nums[k] = 2 if v &lt; 2: nums[j] = 1 j += 1 if v == 0: nums[i] = 0 i += 1# 86 / 86 test cases passed.# Status: Accepted# Runtime: 44 ms# 84.03% Just like the Lomuto partition algorithm usually used in quick sort. We keep a loop invariant that [0,i) [i, j) [j, k) are 0s, 1s and 2s sorted in place for [0,k). Here “)” means exclusive. We don’t need to swap because we know the values we want. java https://discuss.leetcode.com/topic/19201/java-solution-both-2-pass-and-1-pass Java solution, both 2-pass and 1-pass 2-pass 两次遍历1-pass 一次遍历 123456789101112131415161718public void sortColors(int[] nums) &#123; // 1-pass int p1 = 0, p2 = nums.length - 1, index = 0; while (index &lt;= p2) &#123; if (nums[index] == 0) &#123; nums[index] = nums[p1]; nums[p1] = 0; p1++; &#125; if (nums[index] == 2) &#123; nums[index] = nums[p2]; nums[p2] = 2; p2--; index--; &#125; index++; &#125;&#125; 1234567891011121314public void sortColors(int[] nums) &#123; // 2-pass int count0 = 0, count1 = 0, count2 = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == 0) &#123;count0++;&#125; if (nums[i] == 1) &#123;count1++;&#125; if (nums[i] == 2) &#123;count2++;&#125; &#125; for(int i = 0; i &lt; nums.length; i++) &#123; if (i &lt; count0) &#123;nums[i] = 0;&#125; else if (i &lt; count0 + count1) &#123;nums[i] = 1;&#125; else &#123;nums[i] = 2;&#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[074. Search a 2D Matrix]]></title>
    <url>%2Fp%2F5049e182%2F</url>
    <content type="text"><![CDATA[35.1% https://leetcode.com/problems/search-a-2d-matrix/ Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. 12345678910For example,Consider the following matrix:[ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]Given target = 3, return true. 方法一： 二分搜索 我的实现 12345678910111213141516171819202122class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int m = matrix.size(); if(m==0) return false; int n = matrix[0].size(); if(n==0) return false; if(target&lt;matrix[0][0] || target&gt;matrix[m-1][n-1]) return false; int left = 0, right = m*n-1; while(left&lt;=right)&#123; int mid = left + (right-left)/2; if(matrix[mid/n][mid%n]==target) return true; else if(matrix[mid/n][mid%n]&gt;target) right = mid-1; else left = mid + 1; &#125; return false; &#125;&#125;; cpp 12ms, 24.93%, June.21th, 2016 https://leetcode.com/discuss/10735/dont-treat-it-as-a-2d-matrix-just-treat-it-as-a-sorted-list 12345678910111213141516class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int target) &#123; int n = matrix.size(); int m = matrix[0].size(); int l = 0, r = m * n - 1; while (l != r)&#123; int mid = (l + r - 1) &gt;&gt; 1; if (matrix[mid / m][mid % m] &lt; target) l = mid + 1; else r = mid; &#125; return matrix[r / m][r % m] == target; &#125;&#125;; Solution Mime: 12ms, 24.93%, June.21th, 2016 123456789101112131415161718class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int target) &#123; int n = matrix.size(); int m = matrix[0].size(); int l = 0, r = m * n - 1; while (l != r)&#123; int mid = (l + r - 1) &gt;&gt; 1; if (matrix[mid / m][mid % m] &lt; target) l = mid + 1; else if(matrix[mid / m][mid % m] &gt; target) r = mid; else return true; &#125; return matrix[r / m][r % m] == target; &#125;&#125;; python Solution Mine: 52ms, 65.89%, June.21th, 2016 123456789101112class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; for i in xrange(len(matrix)): for j in xrange(len(matrix[0])): if target == matrix[i][j]: return True return False 60ms, 31.27%, June.21th, 2016 https://leetcode.com/discuss/28208/a-python-binary-search-solution-o-logn 123456789101112131415161718192021222324class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; if not matrix or target is None: return False rows, cols = len(matrix), len(matrix[0]) low, high = 0, rows * cols - 1 while low &lt;= high: mid = (low + high) / 2 num = matrix[mid / cols][mid % cols] if num == target: return True elif num &lt; target: low = mid + 1 else: high = mid - 1 return False Solution Mine: 48ms, 85.27%, June.21th, 2016 1234567891011121314151617181920212223242526class Solution(object): def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; if not matrix or target is None: return False if target &lt; matrix[0][0] or target &gt; matrix[-1][-1]: return False rows, cols = len(matrix), len(matrix[0]) low, high = 0, rows * cols - 1 while low &lt;= high: mid = (low + high) / 2 num = matrix[mid / cols][mid % cols] if num == target: return True elif num &lt; target: low = mid + 1 else: high = mid - 1 return False java 1ms, 6.12%, June.21th, 2016 https://leetcode.com/discuss/15379/binary-search-on-an-ordered-matrix 123456789101112131415161718192021public class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int row_num = matrix.length; int col_num = matrix[0].length; int begin = 0, end = row_num * col_num - 1; while(begin &lt;= end)&#123; int mid = (begin + end) / 2; int mid_value = matrix[mid / col_num][mid % col_num]; if(mid_value == target) return true; else if(mid_value &lt; target) begin = mid + 1; else end = mid - 1; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[073. Set Matrix Zeroes]]></title>
    <url>%2Fp%2F87522f31%2F</url>
    <content type="text"><![CDATA[36.0% https://leetcode.com/problems/set-matrix-zeroes/ Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. Follow up: Did you use extra space? A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? 貌似剑指offer？ 方法一： 保存所有结果到第一行和第一列，遍历非第一行，非第一列，只要有出现0的就设置为0。 至于第一行第一列要不要设置为0，可以设置两个标志来判断。 https://discuss.leetcode.com/topic/5056/any-shorter-o-1-space-solution Any shorter O(1) space solution? My idea is simple: store states of each row in the first of that row, and store states of each column in the first of that column. Because the state of row0 and the state of column0 would occupy the same cell, I let it be the state of row0, and use another variable “col0” for column0. In the first phase, use matrix elements to set states in a top-down way. In the second phase, use states to set matrix elements in a bottom-up way. 1234567891011121314151617void setZeroes(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int col0 = 1, rows = matrix.size(), cols = matrix[0].size(); for (int i = 0; i &lt; rows; i++) &#123; if (matrix[i][0] == 0) col0 = 0; for (int j = 1; j &lt; cols; j++) if (matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0; &#125; for (int i = rows - 1; i &gt;= 0; i--) &#123; for (int j = cols - 1; j &gt;= 1; j--) if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0; if (col0 == 0) matrix[i][0] = 0; &#125;&#125; 我的代码实现： 多个循环，第一行，第一列，非第一行第一列，三个循环，清晰明了。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty()) return; int row0 = 1, col0 = 1; int rows = matrix.size(), cols = matrix[0].size(); for(int i=0; i&lt;cols; i++)&#123; if(matrix[0][i]==0)&#123; row0 = 0; break; &#125; &#125; for(int i=0; i&lt;rows; i++)&#123; if(matrix[i][0]==0)&#123; col0 = 0; break; &#125; &#125; for(int i=1; i&lt;rows; i++)&#123; for(int j=1; j&lt;cols; j++)&#123; if(matrix[i][j]==0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; for(int i=1; i&lt;rows; i++)&#123; for(int j=1; j&lt;cols; j++)&#123; if(matrix[i][0]==0 || matrix[0][j]==0) matrix[i][j] = 0; &#125; &#125; if(row0==0)&#123; for(int i=0; i&lt;cols; i++) matrix[0][i] = 0; &#125; if(col0==0)&#123; for(int i=0; i&lt;rows; i++) matrix[i][0] = 0; &#125; return; &#125;&#125;; https://discuss.leetcode.com/topic/7087/my-c-o-1-yoooooo My C++ O(1) yoooooo I find the last row which has 0, and use it to store the 0-collumns. Then go row by row set them to 0. Then go column by column set them to 0. Finally set the last row which has 0. It’s long but hey it’s O(1) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int H = matrix.size(); int W = matrix[0].size(); // find the last 0 row int last_0_row = -1; for (int y = H - 1; y &gt;= 0 &amp;&amp; last_0_row == -1; y--) for (int x = 0; x &lt; W; x++) if (matrix[y][x] == 0) &#123; last_0_row = y; break; &#125; if (last_0_row == -1) return; // go row by row for (int y = 0; y &lt; last_0_row; y++) &#123; bool this_is_a_0_row = false; for (int x = 0; x &lt; W; x++) &#123; if (matrix[y][x] == 0) &#123; this_is_a_0_row = true; matrix[last_0_row][x] = 0; &#125; &#125; if (this_is_a_0_row) for (int x = 0; x &lt; W; x++) &#123; matrix[y][x] = 0; &#125; &#125; // set collums to 0 for (int y = 0; y &lt; H; y++) for (int x = 0; x &lt; W; x++) &#123; if (matrix[last_0_row][x] == 0) matrix[y][x] = 0; &#125; // set the last 0 row for (int x = 0; x &lt; W; x++) &#123; matrix[last_0_row][x] = 0; &#125; &#125;&#125;; python 188ms, 49.31%, June.18th, 2016 https://leetcode.com/discuss/49003/o-1-space-solution-in-python O(1) space solution in Python 12345678910111213141516171819202122232425262728293031323334353637383940class Solution:# @param &#123;integer[][]&#125; matrix# @return &#123;void&#125; Do not return anything, modify matrix in-place instead.def setZeroes(self, matrix): m = len(matrix) if m == 0: return n = len(matrix[0]) row_zero = False for i in range(m): if matrix[i][0] == 0: row_zero = True col_zero = False for j in range(n): if matrix[0][j] == 0: col_zero = True for i in range(1, m): for j in range(1, n): if matrix[i][j] == 0: matrix[i][0] = 0 matrix[0][j] = 0 for i in range(1, m): if matrix[i][0] == 0: for j in range(1, n): matrix[i][j] = 0 for j in range(1, n): if matrix[0][j] == 0: for i in range(1, m): matrix[i][j] = 0 if col_zero: for j in range(n): matrix[0][j] = 0 if row_zero: for i in range(m): matrix[i][0] = 0 java https://discuss.leetcode.com/topic/15193/my-ac-java-o-1-solution-easy-to-read My AC java O(1) solution (easy to read) 123456789101112131415161718192021222324252627282930313233public class Solution &#123;public void setZeroes(int[][] matrix) &#123; boolean fr = false,fc = false; for(int i = 0; i &lt; matrix.length; i++) &#123; for(int j = 0; j &lt; matrix[0].length; j++) &#123; if(matrix[i][j] == 0) &#123; if(i == 0) fr = true; if(j == 0) fc = true; matrix[0][j] = 0; matrix[i][0] = 0; &#125; &#125; &#125; for(int i = 1; i &lt; matrix.length; i++) &#123; for(int j = 1; j &lt; matrix[0].length; j++) &#123; if(matrix[i][0] == 0 || matrix[0][j] == 0) &#123; matrix[i][j] = 0; &#125; &#125; &#125; if(fr) &#123; for(int j = 0; j &lt; matrix[0].length; j++) &#123; matrix[0][j] = 0; &#125; &#125; if(fc) &#123; for(int i = 0; i &lt; matrix.length; i++) &#123; matrix[i][0] = 0; &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/8807/my-java-o-1-solution-easy-to-understand My java O(1) solution (easy to understand) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Solution &#123; public void setZeroes(int[][] matrix) &#123; if(matrix==null)&#123; return; &#125; int m = matrix.length; int n = matrix[0].length; boolean rowHasZero = false; boolean colHasZero = false; for(int i=0; i&lt;n; i++)&#123; if(matrix[0][i]==0)&#123; rowHasZero = true; break; &#125; &#125; for(int i=0; i&lt;m; i++)&#123; if(matrix[i][0]==0)&#123; colHasZero = true; break; &#125; &#125; for(int i=1; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; if(matrix[i][j]==0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; for(int j=1;j&lt;n; j++)&#123; if(matrix[0][j]==0)&#123; nullifyCol(matrix, j, m, n); &#125; &#125; for(int i=1; i&lt;m; i++)&#123; if(matrix[i][0]==0)&#123; nullifyRow(matrix, i, m, n); &#125; &#125; if(rowHasZero)&#123; nullifyRow(matrix, 0, m, n); &#125; if(colHasZero)&#123; nullifyCol(matrix, 0, m, n); &#125; &#125; public void nullifyRow(int[][] matrix, int i, int m, int n)&#123; for(int col=0; col&lt;n; col++)&#123; matrix[i][col] = 0; &#125; &#125; public void nullifyCol(int[][] matrix, int j, int m, int n)&#123; for(int row=0; row&lt;m; row++)&#123; matrix[row][j] = 0; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[072. Edit Distance]]></title>
    <url>%2Fp%2F8e0e9f97%2F</url>
    <content type="text"><![CDATA[30.9% https://leetcode.com/problems/edit-distance/ Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) 12345You have the following 3 operations permitted on a word:a) Insert a characterb) Delete a characterc) Replace a character 方法一： 我的代码实现： 12345678910111213141516171819202122class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.size(); int n = word2.size(); if(n==0) return m; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=0; i&lt;m+1; i++) dp[i][0] = i; for(int j=0; j&lt;n+1; j++) dp[0][j] = j; for(int i=1; i&lt;m+1; i++)&#123; for(int j=1; j&lt;n+1; j++)&#123; if(word1[i-1] != word2[j-1]) dp[i][j] = min(min(dp[i][j-1], dp[i-1][j]), dp[i-1][j-1]) + 1; else dp[i][j] = dp[i-1][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; 根据题目分析问题，然后动态规划解决问题，很常规的一类 从中定义模式，两个的话，定义（m+1）*（n+1）的数组 19ms, 70.83%, September 21, 2016 https://discuss.leetcode.com/topic/17639/20ms-detailed-explained-c-solutions-o-n-space This is a classic problem of Dynamic Programming. We define the state dp[i][j] to be the minimum number of operations to convert word1[0..i - 1] to word2[0..j - 1]. The state equations have two cases: the boundary case and the general case. Note that in the above notations, both i and j take values starting from 1. For the boundary case, that is, to convert a string to an empty string, it is easy to see that the mininum number of operations to convert word1[0..i - 1] to “” requires at least i operations (deletions). In fact, the boundary case is simply: dp[i][0] = i; dp[0][j] = j. Now let’s move on to the general case, that is, convert a non-empty word1[0..i - 1] to another non-empty word2[0..j - 1]. Well, let’s try to break this problem down into smaller problems (sub-problems). Suppose we have already known how to convert word1[0..i - 2] to word2[0..j - 2], which is dp[i - 1][j - 1]. Now let’s consider word[i - 1] and word2[j - 1]. If they are euqal, then no more operation is needed and dp[i][j] = dp[i - 1][j - 1]. Well, what if they are not equal? If they are not equal, we need to consider three cases: Replace word1[i - 1] by word2[j - 1] (dp[i][j] = dp[i - 1][j - 1] + 1 (for replacement)); Delete word1[i - 1] and word1[0..i - 2] = word2[0..j - 1] (dp[i][j] = dp[i - 1][j] + 1 (for deletion)); Insert word2[j - 1] to word1[0..i - 1] and word1[0..i - 1] + word2[j - 1] = word2[0..j - 1] (dp[i][j] = dp[i][j - 1] + 1 (for insertion)). Make sure you understand the subtle differences between the equations for deletion and insertion. For deletion, we are actually converting word1[0..i - 2] to word2[0..j - 1], which costs dp[i - 1][j], and then deleting the word1[i - 1], which costs 1. The case is similar for insertion. Putting these together, we now have: dp[i][0] = i; dp[0][j] = j; dp[i][j] = dp[i - 1][j - 1], if word1[i - 1] = word2[j - 1]; dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i - 1][j] + 1, dp[i][j - 1] + 1), otherwise. The above state equations can be turned into the following code directly. 123456789101112131415161718class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.length(), n = word2.length(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=1; i&lt;=m; i++) dp[i][0] = i; for(int j=1; j&lt;=n; j++) dp[0][j] = j; for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = min(dp[i-1][j-1]+1, min(dp[i][j-1]+1, dp[i-1][j]+1)); return dp[m][n]; &#125;&#125;; 方法二： 我的代码实现 dp[i][j],只有三条路可以走，一个是从dp[i-1][j-1]不相等替换 相等就不变， 一个是dp[i][j-1]增加或删除，一个是dp[i-1][j]增加或删除 有两个string的时候，长度分别是m和n，要特别分清到底哪个是m，哪个是n 12345678910111213141516171819class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.size(); int n = word2.size(); if(n==0) return m; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i=0; i&lt;m+1; i++) dp[i][0] = i; for(int j=0; j&lt;n+1; j++) dp[0][j] = j; for(int i=1; i&lt;m+1; i++)&#123; for(int j=1; j&lt;n+1; j++)&#123; dp[i][j] = min(min(dp[i][j-1], dp[i-1][j])+1, word1[i-1]==word2[j-1]?dp[i-1][j-1]:dp[i-1][j-1]+1); &#125; &#125; return dp[m][n]; &#125;&#125;; 13ms, 86.67%, September 21, 2016 https://discuss.leetcode.com/topic/17639/20ms-detailed-explained-c-solutions-o-n-space Well, you may have noticed that each time when we update dp[i][j], we only need dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]. In fact, we need not maintain the full m*n matrix. Instead, maintaing one column is enough. The code can be optimized to O(m) or O(n) space, depending on whether you maintain a row or a column of the original matrix. The optimized code is as follows. 12345678910111213141516171819202122class Solution &#123;public: int minDistance(string word1, string word2) &#123; int m = word1.length(), n = word2.length(); vector&lt;int&gt; cur(m+1, 0); for(int i=1; i&lt;=m; i++) cur[i] = i; for(int j=1; j&lt;=n; j++)&#123; int pre = cur[0]; cur[0] = j; for(int i=1; i&lt;=m; i++)&#123; int temp = cur[i]; if(word1[i-1] == word2[j-1]) cur[i] = pre; else cur[i] = min(pre+1, min(cur[i]+1, cur[i-1]+1)); pre = temp; &#125; &#125; return cur[m]; &#125;&#125;; Well, if you find the above code hard to understand, you may first try to write a two-column version that explicitly maintains two columns (the previous column and the current column) and then simplify the two-column version into the one-column version like the above code :-) python 256ms, 35.52%, September 21, 2016 https://discuss.leetcode.com/topic/19877/python-solutions-o-m-n-o-n-space O(m*n) space 1234567891011121314151617class Solution(object): def minDistance(self, word1, word2): &quot;&quot;&quot; :type word1: str :type word2: str :rtype: int &quot;&quot;&quot; l1, l2 = len(word1)+1, len(word2)+1 dp = [[0 for _ in xrange(l2)] for _ in xrange(l1)] for i in xrange(l1): dp[i][0] = i for j in xrange(l2): dp[0][j] = j for i in xrange(1, l1): for j in xrange(1, l2): dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+(word1[i-1]!=word2[j-1])) return dp[-1][-1] 262ms, 32.79%, September 21, 2016 https://discuss.leetcode.com/topic/19877/python-solutions-o-m-n-o-n-space O(n) space with rolling array1234567891011121314151617class Solution(object): def minDistance(self, word1, word2): &quot;&quot;&quot; :type word1: str :type word2: str :rtype: int &quot;&quot;&quot; l1, l2 = len(word1)+1, len(word2)+1 pre = [0 for _ in xrange(l2)] for j in xrange(l2): pre[j] = j for i in xrange(1, l1): cur = [i]*l2 for j in xrange(1, l2): cur[j] = min(cur[j-1]+1, pre[j]+1, pre[j-1]+(word1[i-1] != word2[j-1])) pre = cur[:] return pre[-1] java 16ms, 31.71%, September 21, 2016 https://discuss.leetcode.com/topic/20922/java-dp-solution-o-nm Let following be the function definition :- 1234567891011f(i, j) := minimum cost (or steps) required to convert first i characters of word1 to first j characters of word2Case 1: word1[i] == word2[j], i.e. the ith the jth character matches.f(i, j) = f(i - 1, j - 1)Case 2: word1[i] != word2[j], then we must either insert, delete or replace, whichever is cheaperf(i, j) = 1 + min &#123; f(i, j - 1), f(i - 1, j), f(i - 1, j - 1) &#125;1. f(i, j - 1) represents insert operation2. f(i - 1, j) represents delete operation3. f(i - 1, j - 1) represents replace operation Here, we consider any operation from word1 to word2. It means, when we say insert operation, we insert a new character after word1 that matches the jth character of word2. So, now have to match i characters of word1 to j - 1 characters of word2. Same goes for other 2 operations as well. Note that the problem is symmetric. The insert operation in one direction (i.e. from word1 to word2) is same as delete operation in other. So, we could choose any direction. Above equations become the recursive definitions for DP. Base Case: 1f(0, k) = f(k, 0) = k Below is the direct bottom-up translation of this recurrent relation. It is only important to take care of 0-based index with actual code :- Time complexity : If n is the length of word1, m of word2, because of the two indented loops, it is O(nm)123456789101112131415161718192021222324252627public class Solution &#123; public int minDistance(String word1, String word2) &#123; int m = word1.length(); int n = word2.length(); int[][] cost = new int[m+1][n+1]; for(int i=0; i&lt;=m; i++) cost[i][0] = i; for(int j=0; j&lt;=n; j++) cost[0][j] = j; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(word1.charAt(i) == word2.charAt(j)) cost[i+1][j+1] = cost[i][j]; else&#123; int a = cost[i][j]; int b = cost[i][j+1]; int c = cost[i+1][j]; cost[i+1][j+1] = a &lt; b?(a&lt;c?a:c):(b&lt;c?b:c); cost[i+1][j+1]++; &#125; &#125; &#125; return cost[m][n]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[071. Simplify Path]]></title>
    <url>%2Fp%2F6cd51db6%2F</url>
    <content type="text"><![CDATA[25.4% https://leetcode.com/problems/simplify-path/ Given an absolute path for a file (Unix-style), simplify it. 123For example,path = &quot;/home/&quot;, =&gt; &quot;/home&quot;path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot; Corner Cases: Did you consider the case where path = “/../“? In this case, you should return “/“. Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“. In this case, you should ignore redundant slashes and return “/home/foo”. 方法一： https://discuss.leetcode.com/topic/2872/my-o-n-ac-code-just-need-to-handle-two-special-cases My O(n) AC code . just need to handle two special cases. traverse the string to record each folder name. two special cases: a.double dot:pop one. b.single dot: do nothing (don`t push it). 123456789101112131415161718192021222324252627string simplifyPath(string path) &#123; vector&lt;string&gt; nameVect; string name; path.push_back(&apos;/&apos;); for(int i=0;i&lt;path.size();i++)&#123; if(path[i]==&apos;/&apos;)&#123; if(name.size()==0)continue; if(name==&quot;..&quot;)&#123; //special case 1：double dot，pop dir if(nameVect.size()&gt;0)nameVect.pop_back(); &#125;else if(name==&quot;.&quot;)&#123;//special case 2:singel dot，don`t push &#125;else&#123; nameVect.push_back(name); &#125; name.clear(); &#125;else&#123; name.push_back(path[i]);//record the name &#125; &#125; string result; if(nameVect.empty())return &quot;/&quot;; for(int i=0;i&lt;nameVect.size();i++)&#123; result.append(&quot;/&quot;+nameVect[i]); &#125; return result;&#125; 我的代码实现： string的函数clear，append，push_back 给定的字符串可以更改的 1234567891011121314151617181920212223242526class Solution &#123;public: string simplifyPath(string path) &#123; vector&lt;string&gt; v; string name = ""; path.push_back('/'); // 针对原有string的首或尾进行改变，这是一种思路 int n = path.size(); // 长度改变了，所以要在改变后求长度，否则不对的 for(int i=0; i&lt;n; i++)&#123; if(path[i]=='/')&#123; if(name=="") continue; // 下面的大括号外，不要分号的 else if(name==".")&#123;&#125; //此处不能continue，因为要清空name，才下一步 else if(name=="..") &#123; if(!v.empty()) v.pop_back();&#125; else v.push_back(name); name.clear(); // 此处学会针对string的clear &#125;else&#123; name.push_back(path[i]); &#125; &#125; string res = ""; for(int i=0; i&lt;v.size(); i++) res.append("/" + v[i]); return v.empty()? "/" : res; &#125;&#125;; cpp 6ms, September 11, 2016 https://discuss.leetcode.com/topic/8678/c-10-lines-solution C++ 10-lines solution C++ also have getline which acts like Java’s split. I guess the code can comment itself. 123456789101112131415class Solution &#123;public: string simplifyPath(string path) &#123; string res, tmp; vector&lt;string&gt; stk; stringstream ss(path); while(getline(ss, tmp, &apos;/&apos;))&#123; if(tmp == &quot;&quot; or tmp == &quot;.&quot;) continue; if(tmp == &quot;..&quot; and !stk.empty()) stk.pop_back(); else if(tmp!=&quot;..&quot;) stk.push_back(tmp); &#125; for(auto str:stk) res += &quot;/&quot; + str; return res.empty() ? &quot;/&quot; : res; &#125;&#125;; python 82ms, September 11, 2016 https://discuss.leetcode.com/topic/41158/9-line-python-solution-easy-to-understand 9-line Python solution, easy to understand 12345678910111213141516class Solution(object): def simplifyPath(self, path): &quot;&quot;&quot; :type path: str :rtype: str &quot;&quot;&quot; stack = [] for token in path.split(&apos;/&apos;): if token in (&apos;&apos;, &apos;.&apos;): pass elif token == &apos;..&apos;: if stack: stack.pop() else: stack.append(token) return &apos;/&apos; + &apos;/&apos;.join(stack) java 18ms, September 11, 2016 https://discuss.leetcode.com/topic/7675/java-10-lines-solution-with-stack Java 10-lines solution with stack Hi guys! The main idea is to push to the stack every valid file name (not in {“”,”.”,”..”}), popping only if there’s smth to pop and we met “..”. I don’t feel like the code below needs any additional comments. 12345678910111213public class Solution &#123; public String simplifyPath(String path) &#123; Deque&lt;String&gt; stack = new LinkedList&lt;&gt;(); Set&lt;String&gt; skip = new HashSet&lt;&gt;(Arrays.asList(&quot;..&quot;, &quot;.&quot;, &quot;&quot;)); for(String dir : path.split(&quot;/&quot;))&#123; if(dir.equals(&quot;..&quot;) &amp;&amp; !stack.isEmpty()) stack.pop(); else if(!skip.contains(dir)) stack.push(dir); &#125; String res = &quot;&quot;; for(String dir:stack) res = &quot;/&quot; + dir + res; return res.isEmpty()? &quot;/&quot; : res; &#125;&#125; https://discuss.leetcode.com/topic/7014/accepted-solution-using-deque Accepted solution using Deque I think using Deque is probably the most intuitive way to solve this problem. 12345678910111213141516171819202122232425262728293031323334/** * Deque of strings (directories). * iterate path: * if &quot;/&quot;, continue, * if &quot;.&quot;, conitnue, * if &quot;..&quot;, poll last, * else, add a new directory * in the end, build result from deque. */public String simplifyPath(String path) &#123; Deque&lt;String&gt; deque = new LinkedList&lt;String&gt;(); String[] splits = path.split(&quot;/&quot;); for (String split : splits) &#123; // CATCH: must use &quot;equals()&quot; instead of &quot;==&quot;, // because &apos;split&apos; is a variable! // Also, &apos;split&apos; could be empty string. if (split.equals(&quot;&quot;)) continue; else if (split.equals(&quot;.&quot;)) continue; else if (split.equals(&quot;..&quot;)) deque.pollLast(); else deque.addLast(split); &#125; StringBuilder builder = new StringBuilder(); while (!deque.isEmpty()) &#123; String s = deque.pollFirst(); builder.append(&quot;/&quot;).append(s); &#125; if (builder.length() == 0) return &quot;/&quot;; return builder.toString();&#125; https://discuss.leetcode.com/topic/12767/ac-solution-in-java AC Solution in Java 12345678910111213141516public class Solution &#123; public String simplifyPath(String path) &#123; Set&lt;String&gt; isSkip = new HashSet&lt;&gt;(Arrays.asList(&quot;&quot;, &quot;.&quot;, &quot;..&quot;)); Deque&lt;String&gt; stack = new ArrayDeque&lt;&gt;(); for (String token : path.split(&quot;/&quot;)) &#123; if (token.equals(&quot;..&quot;) &amp;&amp; !stack.isEmpty()) stack.pop(); if (isSkip.contains(token)) continue; stack.push(token); &#125; StringBuilder sb = new StringBuilder(); while (!stack.isEmpty()) &#123; sb.append(&quot;/&quot; + stack.pollLast()); &#125; return sb.length() == 0 ? &quot;/&quot; : sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[070. Climbing Stairs]]></title>
    <url>%2Fp%2Ff1d6ecb9%2F</url>
    <content type="text"><![CDATA[39.0% https://leetcode.com/problems/climbing-stairs/ You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 方法一： 12345678910111213class Solution &#123;public: int climbStairs(int n) &#123; if(n&lt;0) return 0; int a=0, b=1; while(n--)&#123; int c = a+b; a = b; b = c; &#125; return b; &#125;&#125;; 相似题： 有一楼梯共m级，刚开始时你在第一级，若每次只能跨上一级或者二级，要走上m级，共有多少走法？注：规定从一级到一级有0种走法。给定一个正整数int n，请返回一个数，代表上楼的方式数。保证n小于等于100。为了防止溢出，请返回结果Mod 1000000007的值。 测试样例： 3 返回：2 my code: 123456789101112131415class GoUpstairs &#123;public: int countWays(int n) &#123; // write code here long long a=1, b=1, i=1; long long c; while(i&lt;n)&#123; c = a; a = (a+b)%1000000007; b = (c)%1000000007; i++; &#125; return b; &#125;&#125;; 其中，要求mod值，在最终结果处会溢出，所以在中间mod。 解析https://discuss.leetcode.com/topic/17002/3-4-short-lines-in-every-language Same simple algorithm written in every offered language. Variable a tells you the number of ways to reach the current step, and b tells you the number of ways to reach the next step. So for the situation one step further up, the old b becomes the new a, and the new b is the old a+b, since that new step can be reached by climbing 1 step from what b represented or 2 steps from what a represented. Ruby wins, and “the C languages” all look the same. java 123456public int climbStairs(int n) &#123; int a = 1, b = 1; while (n-- &gt; 0) a = (b += a) - a; return a;&#125; cpp 123456int climbStairs(int n) &#123; int a = 1, b = 1; while (n--) a = (b += a) - a; return a;&#125; python 12345def climbStairs(self, n): a = b = 1 for _ in range(n): a, b = b, a + b return a 评价：n–是亮点，不必单独设置一个变量i++ https://discuss.leetcode.com/topic/5371/basically-it-s-a-fibonacci Basically it’s a fibonacci. The problem seems to be a dynamic programming one. Hint: the tag also suggests that!Here are the steps to get the solution incrementally. Base cases: if n &lt;= 0, then the number of ways should be zero. if n == 1, then there is only way to climb the stair. if n == 2, then there are two ways to climb the stairs. One solution is one step by another; the other one is two steps at one time. The key intuition to solve the problem is that given a number of stairs n, if we know the number ways to get to the points [n-1] and [n-2] respectively, denoted as n1 and n2 , then the total ways to get to the point [n] is n1 + n2. Because from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there. There is NO overlapping between these two solution sets, because we differ in the final step. Now given the above intuition, one can construct an array where each node stores the solution for each number n. Or if we look at it closer, it is clear that this is basically a fibonacci number, with the starting numbers as 1 and 2, instead of 1 and 1. The implementation in Java as follows: 1234567891011121314151617public int climbStairs(int n) &#123; // base cases if(n &lt;= 0) return 0; if(n == 1) return 1; if(n == 2) return 2; int one_step_before = 2; int two_steps_before = 1; int all_ways = 0; for(int i=2; i&lt;n; i++)&#123; all_ways = one_step_before + two_steps_before; two_steps_before = one_step_before; one_step_before = all_ways; &#125; return all_ways;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[069. Sqrt(x)]]></title>
    <url>%2Fp%2Fae863641%2F</url>
    <content type="text"><![CDATA[27.9% https://leetcode.com/problems/sqrtx/ Implement int sqrt(int x). Compute and return the square root of x. 方法一： 基本方法，二分搜索 1234567891011121314151617class Solution &#123;public: int sqrt(int x) &#123; if (0 == x) return 0; int left = 1, right = x, ans; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (mid &lt;= x / mid) &#123; left = mid + 1; ans = mid; &#125; else &#123; right = mid - 1; &#125; &#125; return ans; &#125;&#125;; 我的代码实现： 1234567891011121314151617class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return x; // 先对特殊情况判断 int left=1, right=x, ans; while(left&lt;=right)&#123; // 判断条件left&lt;=right int mid = left + (right-left)/2; if(mid&lt;=x/mid)&#123; // 如果mid*mid可能超出int范围 left = mid + 1; ans = mid; &#125;else&#123; right = mid - 1; &#125; &#125; return ans; &#125;&#125;; 方法二： 我的代码实现： 123456789101112class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return 0; double res = x; double delta = 0.0001; while(abs(pow(res, 2)-x)&gt;delta)&#123; res = (res + x/res)/2; &#125; return int(res); &#125;&#125;; 1234567891011f(x) = ans^2 - x = 0f&apos;(x) = 2*ans y = f&apos;(ans)*(nex - ans) + f(ans)y = 0=&gt; nex = ans - f(ans) / f&apos;(ans)迭代方法 Newton方法，迭代 The key point is the average result is calculate by “ans = (ans + x / ans) / 2”; 12345678int sqrt(int x) &#123; double ans = x; double delta = 0.0001; while (fabs(pow(ans, 2) - x) &gt; delta) &#123; ans = (ans + x / ans) / 2; &#125; return ans;&#125; 我的代码实现： 123456789101112class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return x; double ans = x; // 注意此处用的是double，不是int double delta = 0.0001; // 用double，而不是int while(fabs(pow(ans,2) - x)&gt;delta)&#123; ans = (ans + x/ans)/2; &#125; return ans; &#125;&#125;; 方法三： 牛顿法的另一种实现 12345678910class Solution &#123;public: int mySqrt(int x) &#123; if(x==0) return 0; long long r = x; while(r*r &gt; x) r = (r+x/r)/2; return r; &#125;&#125;; https://discuss.leetcode.com/topic/24532/3-4-short-lines-integer-newton-every-language 3-4 short lines, Integer Newton, Every Language Quite a few people used Newton already, but I didn’t see someone make it this short. Same solution in every language. Explanation under the solutions. C++ and C 1234long r = x;while (r*r &gt; x) r = (r + x/r) / 2;return r; Python 1234r = xwhile r*r &gt; x: r = (r + x/r) / 2return r Java and C# 1234long r = x;while (r*r &gt; x) r = (r + x/r) / 2;return (int) r; Explanation Apparently, using only integer division for the Newton method works. And I guessed that if I start at x, the root candidate will decrease monotonically and never get too small. The above solutions all got accepted, and in C++ I also verified it locally on my PC for all possible inputs (0 to 2147483647): 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std;int mySqrt(int x) &#123; long long r = x; while (r*r &gt; x) r = (r + x/r) / 2; return r;&#125;int main() &#123; for (long long x=0; x&lt;=INT_MAX; ++x) &#123; long long r = mySqrt(x); if (r&lt;0 || r*r &gt; x || (r+1)*(r+1) &lt;= x) cout &lt;&lt; &quot;false: &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl; if (x % 10000000 == 0) cout &lt;&lt; x &lt;&lt; endl; &#125; cout &lt;&lt; &quot;all checked&quot; &lt;&lt; endl;&#125; https://discuss.leetcode.com/topic/1225/solve-this-problem-with-binary-search Solve this problem with Binary Search 1234567891011121314151617class Solution &#123;public: int sqrt(int x) &#123; if (0 == x) return 0; int left = 1, right = x, ans; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (mid &lt;= x / mid) &#123; left = mid + 1; ans = mid; &#125; else &#123; right = mid - 1; &#125; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/8689/newton-s-iterative-method-in-c Newton’s Iterative Method in C++ 12345678int sqrt(int x) &#123; double ans = x; double delta = 0.0001; while (fabs(pow(ans, 2) - x) &gt; delta) &#123; ans = (ans + x / ans) / 2; &#125; return ans;&#125; The key point is the average result is calculate by “ans = (ans + x / ans) / 2”; For instance, when calculate sqrt(2) : 12345Guess Result Quotient Average Result 1 2 / 1 = 2 (2 + 1) / 2 = 1.5 1.5 2 / 1.5 = 1.3333 (1.3333 + 1.5) / 2 = 1.4167 1.4167 2 / 1.4167 = 1.4118 (1.4167 + 1.4118) / 2 = 1.4142 ... ... https://discuss.leetcode.com/topic/19698/my-clean-c-code-8ms My clean C++ code 8ms Binary search and high is always converged to the one that 1 larger than the result. 123456789101112131415class Solution &#123;public: int mySqrt(int x) &#123; int low = 0, high = x, mid; if(x&lt;2) return x; // to avoid mid = 0 while(low&lt;high) &#123; mid = (low + high)/2; if(x/mid &gt;= mid) low = mid+1; else high = mid; &#125; return high-1; &#125;&#125;; python https://discuss.leetcode.com/topic/5472/newton-method-accepted-solution Newton method, accepted solution. 1234567891011class Solution:# @param x, an integer# @return an integerdef sqrt(self, x): i=1.0; while(True): j=(i+x/i)/2.0; if(abs(i-j)&lt; 0.000000000005): break; i=j; return int(j); java https://discuss.leetcode.com/topic/8680/a-binary-search-solution A Binary Search Solution Instead of using fancy Newton’s method, this plain binary search approach also works. 123456789101112131415public int sqrt(int x) &#123; if (x == 0) return 0; int left = 1, right = Integer.MAX_VALUE; while (true) &#123; int mid = left + (right - left)/2; if (mid &gt; x/mid) &#123; right = mid - 1; &#125; else &#123; if (mid + 1 &gt; x/(mid + 1)) return mid; left = mid + 1; &#125; &#125;&#125; https://discuss.leetcode.com/topic/2671/share-my-o-log-n-solution-using-bit-manipulation Share my O(log n) Solution using bit manipulation Basic Idea: Since sqrt(x) is composed of binary bits, I calculate sqrt(x) by deciding every bit from the most significant to least significant. Since an integer n can have O(log n) bits with each bit decided within constant time, this algorithm has time limit O(log n), actually, because an Integer can have at most 32 bits, I can also say this algorithm takes O(32)=O(1) time. 12345678910111213141516public int sqrt(int x) &#123; if(x==0) return 0; int h=0; while((long)(1&lt;&lt;h)*(long)(1&lt;&lt;h)&lt;=x) // firstly, find the most significant bit h++; h--; int b=h-1; int res=(1&lt;&lt;h); while(b&gt;=0)&#123; // find the remaining bits if((long)(res | (1&lt;&lt;b))*(long)(res |(1&lt;&lt;b))&lt;=x) res|=(1&lt;&lt;b); b--; &#125; return res;&#125; https://discuss.leetcode.com/topic/35357/share-my-2ms-and-4lines-java-code Share my 2ms and 4lines JAVA code, My idea is, for any non-negative number N, sqrt(N) = 2/2sqrt(N) =2sqrt(1/4)sqrt(N) = 2sqrt(N/4). And for the Ns that are not multiple of 4, for example, 9, 25 or 49, the actual result should be 1+2*sqrt(N/4), because we need to take remainders into account. 123456public int mySqrt(int x) &#123; if(x &lt; 4) return x == 0 ? 0 : 1; int res = 2 * mySqrt(x/4); if((res+1) * (res+1) &lt;= x &amp;&amp; (res+1) * (res+1) &gt;= 0) return res+1; return res;&#125; Hope it helps.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>easy</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[068. Text Justification]]></title>
    <url>%2Fp%2F91398cc3%2F</url>
    <content type="text"><![CDATA[19.1% https://leetcode.com/problems/text-justification/ Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly L characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words. 12345678910For example,words: [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]L: 16.Return the formatted lines as:[&quot;This is an&quot;,&quot;example of text&quot;,&quot;justification. &quot;] Note: Each word is guaranteed not to exceed L in length. click to show corner cases. Corner Cases: A line other than the last line might contain only one word. What should you do in this case? In this case, that line should be left-justified. https://discuss.leetcode.com/topic/7256/what-does-this-question-aim-to-teach What does this question aim to teach? In some of the texts that I have been able to find I see that this problem admits a dynamic programming solution that is superior to greedy solutions. (MSWord vs LATEX). I think, that to solve this question specifically (meaning something that OJ accepts) requires a greedy solution. As far as I understand the “idea” of text justification is not to distribute spaces as evenly as possible within all the words of an individual line; But instead lower the overall cost of the way you justify text, which means that even though you may have some lines that have uneven spaces between words than others, but this lowers the overall cost of a justification in other lines. In this question’s description the correct answer is described as a very specific way to do text justification that seems to be not what the superior solution is. Do you think its right to actually post this question as an exercise at all? What does this question aim to teach as far as good text justification algorithms are concerned? https://discuss.leetcode.com/topic/7256/what-does-this-question-aim-to-teach/4 it teaches you in the real world. Programmers are always been ask to deal with dirty works. cpp https://discuss.leetcode.com/topic/4189/share-my-concise-c-solution-less-than-20-lines Share my concise c++ solution - less than 20 lines 1234567891011121314151617vector&lt;string&gt; fullJustify(vector&lt;string&gt; &amp;words, int L) &#123; vector&lt;string&gt; res; for(int i = 0, k, l; i &lt; words.size(); i += k) &#123; for(k = l = 0; i + k &lt; words.size() and l + words[i+k].size() &lt;= L - k; k++) &#123; l += words[i+k].size(); &#125; string tmp = words[i]; for(int j = 0; j &lt; k - 1; j++) &#123; if(i + k &gt;= words.size()) tmp += &quot; &quot;; else tmp += string((L - l) / (k - 1) + (j &lt; (L - l) % (k - 1)), &apos; &apos;); tmp += words[i+j+1]; &#125; tmp += string(L - tmp.size(), &apos; &apos;); res.push_back(tmp); &#125; return res;&#125; For each line, I first figure out which words can fit in. According to the code, these words are words[i] through words[i+k-1]. Then spaces are added between the words. The trick here is to use mod operation to manage the spaces that can’t be evenly distrubuted: the first (L-l) % (k-1) gaps acquire an additional space. https://discuss.leetcode.com/topic/11507/share-my-2-ms-30-lines-solution Share my 2 ms, 30 lines solution 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;string&gt; fullJustify(vector&lt;string&gt; &amp;words, int L) &#123; vector&lt;string&gt; ans; int begin = 0; while (begin &lt; words.size()) &#123; int last = begin; int linesize = words[begin++].size(); while (begin &lt; words.size() &amp;&amp; linesize + 1 + words[begin].size() &lt;= L) &#123; linesize += 1 + words[begin].size(); begin++; &#125; int spaces = 1, extra = 0; if (begin &lt; words.size() &amp;&amp; begin != last + 1) &#123; spaces = (L - linesize) / (begin - last - 1) + 1; extra = (L - linesize) % (begin - last - 1); &#125; ans.push_back(words[last++]); while (extra--) &#123; ans.back().append(spaces+1, &apos; &apos;); ans.back().append(words[last++]); &#125; while (last &lt; begin) &#123; ans.back().append(spaces, &apos; &apos;); ans.back().append(words[last++]); &#125; ans.back().append(L-ans.back().size(), &apos; &apos;); &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/6946/easy-understanding-solution Easy understanding solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546vector&lt;string&gt; fullJustify(vector&lt;string&gt; &amp;words, int L) &#123; vector&lt;string&gt; ans, vs; string str; int len = 0; for (int i = 0; i &lt; words.size(); ++i) &#123; if (len + vs.size() + words[i].size() &lt;= L) &#123; // vs not full, need to get more words in the line vs.push_back(words[i]); len += words[i].size(); &#125; else &#123; // vs full, get the whole line if (vs.size() == 1) &#123; // just one word, the left justify str = vs[0]; str.append(L - str.size(), &apos; &apos;); ans.push_back(str); &#125; else if (vs.size() &gt; 1) &#123; // the first &quot;mod&quot; words get &quot;div+1&quot; spaces // the remaining words get &quot;div&quot; spaces int div = (L - len) / (vs.size() - 1); int mod = (L - len) % (vs.size() - 1); str = vs[0]; for (int j = 1; j &lt; vs.size(); ++j) &#123; if (j &lt;= mod) str.append(div+1, &apos; &apos;); // one more space else str.append(div, &apos; &apos;); str += vs[j]; &#125; ans.push_back(str); &#125; vs.clear(); vs.push_back(words[i]); len = words[i].size(); &#125; &#125; // the last line, left justified and no extra space is inserted between words str = vs[0]; for (int j = 1; j &lt; vs.size(); ++j) str += &apos; &apos; + vs[j]; str.append(L-str.size(), &apos; &apos;); ans.push_back(str); return ans;&#125; python 58ms, 18.55%, September 23, 2016 https://discuss.leetcode.com/topic/25970/concise-python-solution-10-lines Concise python solution, 10 lines. 1234567891011def fullJustify(self, words, maxWidth): res, cur, num_of_letters = [], [], 0 for w in words: if num_of_letters + len(w) + len(cur) &gt; maxWidth: for i in range(maxWidth - num_of_letters): cur[i%(len(cur)-1 or 1)] += &apos; &apos; res.append(&apos;&apos;.join(cur)) cur, num_of_letters = [], 0 cur += [w] num_of_letters += len(w) return res + [&apos; &apos;.join(cur).ljust(maxWidth)] How does it work? Well in the question statement, the sentence “Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right” was just a really long and awkward way to say round robin. The following line implements the round robin logic: 12for i in range(maxWidth - num_of_letters): cur[i%(len(cur)-1 or 1)] += &apos; &apos; What does this line do? Once you determine that there are only k words that can fit on a given line, you know what the total length of those words is num_of_letters. Then the rest are spaces, and there are (maxWidth - num_of_letters) of spaces. The “or 1” part is for dealing with the edge case len(cur) == 1. The following is my older solution for reference, longer and less clear. The idea is the same, but I did not figure out the nice way to distribute the space at the time. 1234567891011121314151617def fullJustify(self, words, maxWidth): res, cur, num_of_letters = [], [], 0 for w in words: if num_of_letters + len(w) + len(cur) &gt; maxWidth: if len(cur) == 1: res.append( cur[0] + &apos; &apos;*(maxWidth - num_of_letters) ) else: num_spaces = maxWidth - num_of_letters space_between_words, num_extra_spaces = divmod( num_spaces, len(cur)-1) for i in range(num_extra_spaces): cur[i] += &apos; &apos; res.append( (&apos; &apos;*space_between_words).join(cur) ) cur, num_of_letters = [], 0 cur += [w] num_of_letters += len(w) res.append( &apos; &apos;.join(cur) + &apos; &apos;*(maxWidth - num_of_letters - len(cur) + 1) ) return res https://discuss.leetcode.com/topic/36136/15-line-python-solution-40ms 15-line Python solution, 40ms 123456789101112131415161718def fullJustify(self, words, maxWidth): i, N, result = 0, len(words), [] while i &lt; N: # decide how many words to be put in one line oneLine, j, currWidth, positionNum, spaceNum = [words[i]], i + 1, len(words[i]), 0, maxWidth - len(words[i]) while j &lt; N and currWidth + 1 + len(words[j]) &lt;= maxWidth: oneLine.append(words[j]) currWidth += 1 + len(words[j]) spaceNum -= len(words[j]) positionNum, j = positionNum + 1, j + 1 i = j # decide the layout of one line if i &lt; N and positionNum: spaces = [&apos; &apos; * (spaceNum / positionNum + (k &lt; spaceNum % positionNum)) for k in range(positionNum)] + [&apos;&apos;] else: # last line or the line only has one word spaces = [&apos; &apos;] * positionNum + [&apos; &apos; * (maxWidth - currWidth)] result.append(&apos;&apos;.join([s for pair in zip(oneLine, spaces) for s in pair])) return result java https://discuss.leetcode.com/topic/9147/simple-java-solution Simple Java Solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public List&lt;String&gt; fullJustify(String[] words, int L) &#123; List&lt;String&gt; lines = new ArrayList&lt;String&gt;(); int index = 0; while (index &lt; words.length) &#123; int count = words[index].length(); int last = index + 1; while (last &lt; words.length) &#123; if (words[last].length() + count + 1 &gt; L) break; count += words[last].length() + 1; last++; &#125; StringBuilder builder = new StringBuilder(); int diff = last - index - 1; // if last line or number of words in the line is 1, left-justified if (last == words.length || diff == 0) &#123; for (int i = index; i &lt; last; i++) &#123; builder.append(words[i] + &quot; &quot;); &#125; builder.deleteCharAt(builder.length() - 1); for (int i = builder.length(); i &lt; L; i++) &#123; builder.append(&quot; &quot;); &#125; &#125; else &#123; // middle justified int spaces = (L - count) / diff; int r = (L - count) % diff; for (int i = index; i &lt; last; i++) &#123; builder.append(words[i]); if (i &lt; last - 1) &#123; for (int j = 0; j &lt;= (spaces + ((i - index) &lt; r ? 1 : 0)); j++) &#123; builder.append(&quot; &quot;); &#125; &#125; &#125; &#125; lines.add(builder.toString()); index = last; &#125; return lines; &#125;&#125; 3ms, 1.45%, September 22, 2016 https://discuss.leetcode.com/topic/4189/share-my-concise-c-solution-less-than-20-lines 1234567891011121314151617181920class Solution &#123;public: vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int L) &#123; vector&lt;string&gt; res; for(int i=0, k, l; i&lt;words.size(); i+=k)&#123; for(k=l=0; i+k&lt;words.size() and l+words[i+k].size() &lt;= L-k; k++)&#123; l += words[i+k].size(); &#125; string tmp = words[i]; for(int j=0; j&lt;k-1; j++)&#123; if(i+k&gt;=words.size()) tmp += &quot; &quot;; else tmp+=string((L-l)/(k-1) + (j&lt;(L-l)%(k-1)), &apos; &apos;); tmp += words[i+j+1]; &#125; tmp += string(L-tmp.size(), &apos; &apos;); res.push_back(tmp); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[067. Add Binary]]></title>
    <url>%2Fp%2Fde93a709%2F</url>
    <content type="text"><![CDATA[32.5% https://leetcode.com/problems/add-binary/ Given two binary strings, return their sum (also a binary string). 1234For example,a = &quot;11&quot;b = &quot;1&quot;Return &quot;100&quot;. 方法一： 根据最基本的规则运算，类似于链表求和 https://discuss.leetcode.com/topic/8981/short-code-by-c Short code by c++ 12345678910111213141516171819class Solution&#123;public: string addBinary(string a, string b) &#123; string s = &quot;&quot;; int c = 0, i = a.size() - 1, j = b.size() - 1; while(i &gt;= 0 || j &gt;= 0 || c == 1) &#123; c += i &gt;= 0 ? a[i --] - &apos;0&apos; : 0; c += j &gt;= 0 ? b[j --] - &apos;0&apos; : 0; s = char(c % 2 + &apos;0&apos;) + s; c /= 2; &#125; return s; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324class Solution &#123;public: string addBinary(string a, string b) &#123; if(a.empty()) return b; if(b.empty()) return a; int carry = 0; int i = a.size()-1; int j = b.size()-1; string res = ""; while(i&gt;=0 || j&gt;=0 || carry)&#123; int l = i&gt;=0? a[i]-'0' : 0; int r = j&gt;=0 ? b[j]-'0' : 0; carry = l+r+carry; res += char(carry%2 + '0'); carry /= 2; if(i&gt;=0) i--; if(j&gt;=0) j--; &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 4ms, 30.34%, 16 July 2016 https://discuss.leetcode.com/topic/16441/short-o-n-time-o-1-space-c-solution Short O(n) time, O(1) space C++ solution I just write the sum into the longer one of the inputs. Don’t worry about modifying them, as getting string means we’re getting copies. The “O(1) space” of course refers to the space I use in addition to input and output. If the output doesn’t need to be longer than the longer input, I even only use O(1) space in addition to only the input. 12345678910111213141516class Solution &#123;public: string addBinary(string a, string b) &#123; if (a.size() &lt; b.size()) swap(a, b); int i = a.size(), j = b.size(); while (i--) &#123; if (j) a[i] += b[--j] &amp; 1; if (a[i] &gt; &apos;1&apos;) &#123; a[i] -= 2; if (i) a[i-1]++; else a = &apos;1&apos; + a; &#125; &#125; return a; &#125;&#125;; python 76ms, 34.89%, 16 July, 2016 https://discuss.leetcode.com/topic/19383/one-line-python-solution 12345678class Solution(object): def addBinary(self, a, b): &quot;&quot;&quot; :type a: str :type b: str :rtype: str &quot;&quot;&quot; return bin(eval(&apos;0b&apos;+a) + eval(&apos;0b&apos;+b))[2:] 60ms, 80.04%, 16 July 2016 https://discuss.leetcode.com/topic/12116/simple-python-solution-76ms if int() function is allowed, the following code may be more simple. :) 12345678910class Solution(object): def addBinary(self, a, b): &quot;&quot;&quot; :type a: str :type b: str :rtype: str &quot;&quot;&quot; a = int(a, 2) b = int(b, 2) return (&apos;&apos; + bin(a+b))[2:] Simple Python Solution 76ms I assume using int and str is okay, I think this is easy to understand. 12345678910111213141516def addBinary(self, a, b): result = &apos;&apos; index = 0 carry = &apos;0&apos; while index &lt; max(len(a), len(b)) or carry == &apos;1&apos;: num_a = a[-1 - index] if index &lt; len(a) else &apos;0&apos; num_b = b[-1 - index] if index &lt; len(b) else &apos;0&apos; val = int(num_a) + int(num_b) + int(carry) result = str(val % 2) + result carry = &apos;1&apos; if val &gt; 1 else &apos;0&apos; index += 1 return result update No int and str version. 123456789101112131415161718192021222324252627class Solution:# @param a, a string# @param b, a string# @return a string# 75msdef addBinary(self, a, b): result = &apos;&apos; index = 0 carry = &apos;0&apos; while index &lt; max(len(a), len(b)) or carry == &apos;1&apos;: num_a = a[-1 - index] if index &lt; len(a) else &apos;0&apos; num_b = b[-1 - index] if index &lt; len(b) else &apos;0&apos; val = self.to_int(num_a) + self.to_int(num_b) + self.to_int(carry) result = &quot;%s%s&quot; % (val % 2, result) carry = &apos;1&apos; if val &gt; 1 else &apos;0&apos; index += 1 return resultdef to_int(self, c): if c == &apos;1&apos;: return 1 elif c == &apos;0&apos;: return 0 java https://discuss.leetcode.com/topic/13698/short-ac-solution-in-java-with-explanation Short AC solution in Java with explanation Computation from string usually can be simplified by using a carry as such. 123456789101112131415public class Solution &#123; public String addBinary(String a, String b) &#123; StringBuilder sb = new StringBuilder(); int i = a.length() - 1, j = b.length() -1, carry = 0; while (i &gt;= 0 || j &gt;= 0) &#123; int sum = carry; if (j &gt;= 0) sum += b.charAt(j--) - &apos;0&apos;; if (i &gt;= 0) sum += a.charAt(i--) - &apos;0&apos;; sb.append(sum % 2); carry = sum / 2; &#125; if (carry != 0) sb.append(carry); return sb.reverse().toString(); &#125;&#125; https://discuss.leetcode.com/topic/5172/simple-accepted-java-solution Simple accepted java solution Addition bits are calculated by xor. Carry bit is calculated as simple integer addition.1234567891011121314151617181920212223242526272829public class Solution &#123; public String addBinary(String a, String b) &#123; if(a == null || a.isEmpty()) &#123; return b; &#125; if(b == null || b.isEmpty()) &#123; return a; &#125; char[] aArray = a.toCharArray(); char[] bArray = b.toCharArray(); StringBuilder stb = new StringBuilder(); int i = aArray.length - 1; int j = bArray.length - 1; int aByte; int bByte; int carry = 0; int result; while(i &gt; -1 || j &gt; -1 || carry == 1) &#123; aByte = (i &gt; -1) ? Character.getNumericValue(aArray[i--]) : 0; bByte = (j &gt; -1) ? Character.getNumericValue(bArray[j--]) : 0; result = aByte ^ bByte ^ carry; carry = ((aByte + bByte + carry) &gt;= 2) ? 1 : 0; stb.append(result); &#125; return stb.reverse().toString(); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>easy</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[066. Plus One]]></title>
    <url>%2Fp%2F15c6dd1%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/plus-one/ Given a non-negative number represented as an array of digits, plus one to the number. The digits are stored such that the most significant digit is at the head of the list. https://discuss.leetcode.com/topic/987/to-avoid-confusion-please-mention-that-the-lowest-digit-is-on-the-right-end To avoid confusion, please mention that the lowest digit is on the right end The question description does not explicitly say that. I found that is the case. https://discuss.leetcode.com/topic/1264/missing-information Missing information When I started writing the solution I was thinking we were talking about binary digits, please add this information to the text of the problem. The numerical base requested. Would be cool to have a more general problem that also passes the numerical base to the function ;-) 方法一： 更改每一位，从最后一位向前走。 如果尾数是9，就改为0。 如果到某一位不是9，直接返回。 如果走到头都是9，则第一位改为1，最后加一位0. code 1： 12345678910111213141516171819void plusone(vector&lt;int&gt; &amp;digits)&#123; int n = digits.size(); for (int i = n - 1; i &gt;= 0; --i) &#123; if (digits[i] == 9) &#123; digits[i] = 0; &#125; else &#123; digits[i]++; return; &#125; &#125; digits[0] =1; digits.push_back(0); &#125; code 2： 1234567891011class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; for (int i=digits.size(); i--; digits[i] = 0) if (digits[i]++ &lt; 9) return digits; digits[0]++; digits.push_back(0); return digits; &#125;&#125;; java https://discuss.leetcode.com/topic/24288/my-simple-java-solution My Simple Java Solution 1234567891011121314151617public int[] plusOne(int[] digits) &#123; int n = digits.length; for(int i=n-1; i&gt;=0; i--) &#123; if(digits[i] &lt; 9) &#123; digits[i]++; return digits; &#125; digits[i] = 0; &#125; int[] newNumber = new int [n+1]; newNumber[0] = 1; return newNumber;&#125; https://discuss.leetcode.com/topic/19149/simple-java-solution Simple java solution 12345678910111213141516public int[] plusOne(int[] digits) &#123; for (int i = digits.length - 1; i &gt;=0; i--) &#123; if (digits[i] != 9) &#123; digits[i]++; break; &#125; else &#123; digits[i] = 0; &#125; &#125; if (digits[0] == 0) &#123; int[] res = new int[digits.length+1]; res[0] = 1; return res; &#125; return digits;&#125; https://discuss.leetcode.com/topic/41728/java-concise-solution-with-early-return Java concise solution with early return. 123456789101112public int[] plusOne(int[] digits) &#123; int carry = 1; for (int i = digits.length-1; i&gt;= 0; i--) &#123; digits[i] += carry; if (digits[i] &lt;= 9) // early return return digits; digits[i] = 0; &#125; int[] ret = new int[digits.length+1]; ret[0] = 1; return ret;&#125; 0ms, 38.09%, June.17th, 2016 http://www.itnose.net/news/172/6334216 12345678910111213141516171819202122232425public class Solution &#123; public int[] plusOne(int[] digits) &#123; int carry = 1; // 进位标志，下一位来的进位标志 int tmp; for (int i = digits.length - 1; i &gt;= 0; i--) &#123; tmp = digits[i]; digits[i] = (tmp + carry) % 10; // 计算当前位的新值 carry = (tmp + carry) / 10; // 计算新的进位 if (carry == 0) &#123; // 没有进位了就可以退出了 break; &#125; &#125; if (carry == 1) &#123; // 最后还有一个进位 int[] result = new int[digits.length + 1]; System.arraycopy(digits, 0, result, 1, digits.length); result[0] = carry;; return result; &#125; else &#123; return digits; &#125; &#125;&#125; cpp https://discuss.leetcode.com/topic/4556/is-it-a-simple-code-c Is it a simple code(C++)? 12345678910111213141516171819void plusone(vector&lt;int&gt; &amp;digits)&#123; int n = digits.size(); for (int i = n - 1; i &gt;= 0; --i) &#123; if (digits[i] == 9) &#123; digits[i] = 0; &#125; else &#123; digits[i]++; return; &#125; &#125; digits[0] =1; digits.push_back(0); &#125; https://discuss.leetcode.com/topic/9016/my-c-solution-with-few-lines My C++ Solution with few lines 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt; &amp;digits) &#123; bool carry = true; for(int i=digits.size()-1; i &gt;= 0 &amp;&amp; carry; i--) &#123; carry = (++digits[i]%=10) == 0; &#125; if(carry) &#123; digits.insert(digits.begin(), 1); &#125; return digits; &#125;&#125;; 4ms, 9.24%, June.17th, 2016 https://leetcode.com/discuss/14616/is-it-a-simple-code-c 1234567891011class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; for (int i=digits.size(); i--; digits[i] = 0) if (digits[i]++ &lt; 9) return digits; digits[0]++; digits.push_back(0); return digits; &#125;&#125;; python 46ms, 94.03%, June.17th, 2016 https://leetcode.com/discuss/18768/simple-python-solution-with-explanation-plus-one Simple Python solution with explanation (Plus One) 12345def plusOne(digits): num = 0 for i in range(len(digits)): num += digits[i] * pow(10, (len(digits)-1-i)) return [int(i) for i in str(num+1)] We’re given a list of digits, and the idea here is to convert that list to an integer, num. So each digit is multiplied by the proper place value and added to num. For example, if digits = [3, 8, 2, 5] then on the first iteration 3 is multiplied by 10 to the power of 4-1-0 = 3, so this results in 3000, which is added to num. Then 8 is multiplied by 10^2 and added to num, and so on. The last step is to add 1 to num, convert it to a list and return that list.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[065. Valid Number]]></title>
    <url>%2Fp%2Fdad046c3%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/valid-number/ Validate if a given string is numeric. 123456Some examples:&quot;0&quot; =&gt; true&quot; 0.1 &quot; =&gt; true&quot;abc&quot; =&gt; false&quot;1 a&quot; =&gt; false&quot;2e10&quot; =&gt; true Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. https://discuss.leetcode.com/topic/1095/the-worst-problem-i-have-ever-met-in-this-oj The worst problem i have ever met in this oj The description do not give a clear explantion of the definition of a valid Number, we just use more and more trick to get the right solution. It’s too bad, it’s waste of my time https://discuss.leetcode.com/topic/1095/the-worst-problem-i-have-ever-met-in-this-oj/4 +1 for the worst problem on OJ. This is definitely a valid interview question, but it requires heavy clarification through interaction. In a real interview, you have one and only one source to get all the missing information, a.k.a. your interviewer. On OJ, however, there is no interaction whatsoever except through trial and error. This, as far as I am concerned, is directly against the principle of ‘collecting all the info before implementing’. Internet searching also does not work since the word ‘numeric’ is not even defined in the question. No wonder this relatively easy (implementation-wise) problem has one of the lowest rates of acceptance. I would suggest OJ: provide all the details to let users focus on the implementation, or leave room for ambiguity but also suggest where the info can be collected, or provide an interactive applet or something like that on the page so that the user can try the string combinations that they are uncertain of before implementing. I think this is an easy thing to do, and it saves everybody’s time. java https://discuss.leetcode.com/topic/9490/clear-java-solution-with-ifs Clear Java solution with ifs All we need is to have a couple of flags so we can process the string in linear time: 123456789101112131415161718192021222324252627282930313233public boolean isNumber(String s) &#123; s = s.trim(); boolean pointSeen = false; boolean eSeen = false; boolean numberSeen = false; boolean numberAfterE = true; for(int i=0; i&lt;s.length(); i++) &#123; if(&apos;0&apos; &lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= &apos;9&apos;) &#123; numberSeen = true; numberAfterE = true; &#125; else if(s.charAt(i) == &apos;.&apos;) &#123; if(eSeen || pointSeen) &#123; return false; &#125; pointSeen = true; &#125; else if(s.charAt(i) == &apos;e&apos;) &#123; if(eSeen || !numberSeen) &#123; return false; &#125; numberAfterE = false; eSeen = true; &#125; else if(s.charAt(i) == &apos;-&apos; || s.charAt(i) == &apos;+&apos;) &#123; if(i != 0 &amp;&amp; s.charAt(i-1) != &apos;e&apos;) &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; return numberSeen &amp;&amp; numberAfterE;&#125; We start with trimming. If we see [0-9] we reset the number flags. We can only see . if we didn’t see e or .. We can only see e if we didn’t see e but we did see a number. We reset numberAfterE flag. We can only see + and - in the beginning and after an e any other character break the validation. At the and it is only valid if there was at least 1 number and if we did see an e then a number after it as well. So basically the number should match this regular expression: 1[-+]?(([0-9]+(.[0-9]*)?)|.[0-9]+)(e[-+]?[0-9]+)? https://discuss.leetcode.com/topic/8029/a-clean-design-solution-by-using-design-pattern A clean design solution By using design pattern This problem give me a good chance to convey the importance of good design. The problem is very vogue. The point here is not how you design a algorithm, it is how you handle all cases well. There is no a clear standard for whether is a number valid, is it .50 , 39. a legal float point number? Are there only valid formats given by the example? Is hex format such as 0x12ab legal? How about if we need to add another format such as roman number like “I, II , IV” as legal format. I found all solution are just plug logic into one function, there are lots of switch case, if else in there. It is problematic, easy for bugs, difficult to add new features, and of course, in-reusable, and here I propose a design to handle this problem easily and nicely. First we we can give out an interface for this problem: 1234interface NumberValidate &#123; boolean validate(String s);&#125; for any string, we call validate and it return whether the given string is a valid number. Follow we can create concrete implementation for this interface, such as IntegeValidator, FloatValidator, ScienceValidator. and then using chain of responsibility design patter (from book of GOF) , chain all those validator into a list, and feed the string to each one, if there is one validator return true, then the string is a valid number. The design has two advantages, one is easy to fix, for any corner cases or bug, we can locate the problem to specific validator, the effect of changing one validator will not sprint out to the all system, we call this as “encapsulation”. Second is easy to extend, if we need to verify hex format or roman number format , we just need to create new validator and add to the chain, we call this advantage as “close for modification open for extension”. Follow is code for the passed design: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295interface NumberValidate &#123; boolean validate(String s);&#125;abstract class NumberValidateTemplate implements NumberValidate&#123;public boolean validate(String s) &#123; if (checkStringEmpty(s)) &#123; return false; &#125; s = checkAndProcessHeader(s); if (s.length() == 0) &#123; return false; &#125; return doValidate(s); &#125; private boolean checkStringEmpty(String s) &#123; if (s.equals(&quot;&quot;)) &#123; return true; &#125; return false; &#125; private String checkAndProcessHeader(String value) &#123; value = value.trim(); if (value.startsWith(&quot;+&quot;) || value.startsWith(&quot;-&quot;)) &#123; value = value.substring(1); &#125; return value; &#125; protected abstract boolean doValidate(String s);&#125;class NumberValidator implements NumberValidate &#123; private ArrayList&lt;NumberValidate&gt; validators = new ArrayList&lt;NumberValidate&gt;(); public NumberValidator() &#123; addValidators(); &#125; private void addValidators() &#123; NumberValidate nv = new IntegerValidate(); validators.add(nv); nv = new FloatValidate(); validators.add(nv); nv = new HexValidate(); validators.add(nv); nv = new SienceFormatValidate(); validators.add(nv); &#125; @Override public boolean validate(String s) &#123; for (NumberValidate nv : validators) &#123; if (nv.validate(s) == true) &#123; return true; &#125; &#125; return false; &#125; &#125;class IntegerValidate extends NumberValidateTemplate&#123; protected boolean doValidate(String integer) &#123; for (int i = 0; i &lt; integer.length(); i++) &#123; if(Character.isDigit(integer.charAt(i)) == false) &#123; return false; &#125; &#125; return true; &#125;&#125;class HexValidate extends NumberValidateTemplate&#123; private char[] valids = new char[] &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;&#125;; protected boolean doValidate(String hex) &#123; hex = hex.toLowerCase(); if (hex.startsWith(&quot;0x&quot;)) &#123; hex = hex.substring(2); &#125; else &#123; return false; &#125; for (int i = 0; i &lt; hex.length(); i++) &#123; if (Character.isDigit(hex.charAt(i)) != true &amp;&amp; isValidChar(hex.charAt(i)) != true) &#123; return false; &#125; &#125; return true; &#125; private boolean isValidChar(char c) &#123; for (int i = 0; i &lt; valids.length; i++) &#123; if (c == valids[i]) &#123; return true; &#125; &#125; return false; &#125;&#125;class SienceFormatValidate extends NumberValidateTemplate&#123;protected boolean doValidate(String s) &#123; s = s.toLowerCase(); int pos = s.indexOf(&quot;e&quot;); if (pos == -1) &#123; return false; &#125; if (s.length() == 1) &#123; return false; &#125; String first = s.substring(0, pos); String second = s.substring(pos+1, s.length()); if (validatePartBeforeE(first) == false || validatePartAfterE(second) == false) &#123; return false; &#125; return true; &#125; private boolean validatePartBeforeE(String first) &#123; if (first.equals(&quot;&quot;) == true) &#123; return false; &#125; if (checkHeadAndEndForSpace(first) == false) &#123; return false; &#125; NumberValidate integerValidate = new IntegerValidate(); NumberValidate floatValidate = new FloatValidate(); if (integerValidate.validate(first) == false &amp;&amp; floatValidate.validate(first) == false) &#123; return false; &#125; return true; &#125; private boolean checkHeadAndEndForSpace(String part) &#123; if (part.startsWith(&quot; &quot;) || part.endsWith(&quot; &quot;)) &#123; return false; &#125; return true; &#125; private boolean validatePartAfterE(String second) &#123; if (second.equals(&quot;&quot;) == true) &#123; return false; &#125; if (checkHeadAndEndForSpace(second) == false) &#123; return false; &#125; NumberValidate integerValidate = new IntegerValidate(); if (integerValidate.validate(second) == false) &#123; return false; &#125; return true; &#125;&#125;class FloatValidate extends NumberValidateTemplate&#123; protected boolean doValidate(String floatVal) &#123; int pos = floatVal.indexOf(&quot;.&quot;); if (pos == -1) &#123; return false; &#125; if (floatVal.length() == 1) &#123; return false; &#125; NumberValidate nv = new IntegerValidate(); String first = floatVal.substring(0, pos); String second = floatVal.substring(pos + 1, floatVal.length()); if (checkFirstPart(first) == true &amp;&amp; checkFirstPart(second) == true) &#123; return true; &#125; return false; &#125; private boolean checkFirstPart(String first) &#123; if (first.equals(&quot;&quot;) == false &amp;&amp; checkPart(first) == false) &#123; return false; &#125; return true; &#125; private boolean checkPart(String part) &#123; if (Character.isDigit(part.charAt(0)) == false || Character.isDigit(part.charAt(part.length() - 1)) == false) &#123; return false; &#125; NumberValidate nv = new IntegerValidate(); if (nv.validate(part) == false) &#123; return false; &#125; return true; &#125;&#125;public class Solution &#123; public boolean isNumber(String s) &#123; NumberValidate nv = new NumberValidator(); return nv.validate(s); &#125;&#125; https://discuss.leetcode.com/topic/40983/java-logically-simple-flexible-and-clear-solution-including-rules-of-a-valid-number Java logically simple, flexible and clear solution including rules of a valid number The idea is to identify the rules of a valid number first, then set boolean variables to mark key characters and judge the validity. This solution is logically simple and easy to understand, and moreover, it is flexible to extend to the cases where a string of a valid number can accept any space appears anywhere, or/and the exponent can be a decimal number. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public boolean isNumber(String s) &#123; /** * isNumber(s)==true if and only if s=s1 or s1+&apos;e&apos;+s2, where s1, s2 * are valid strings of a number without the char &apos;e&apos;, and s2 is an * integer. * * &apos;e&apos; : valid_count=0~1; [boolean hasE] * * Valid chars in a string of a number without &apos;e&apos;: * * &apos; &apos; : valid_count=0~n; must appear at two ends * * &apos;+/-&apos; : valid_count=0~1; must be the first non-space valid char; * [boolean hasFirst] * * &apos;.&apos; : valid_count=0~1; cannot appear after &apos;e&apos;; [boolean hasDot] * * &apos;0~9&apos; : valid_count=1~n; [boolean hasDigit] */ s = s.trim(); int n = s.length(); if (n == 0) return false; boolean hasE, hasFirst, hasDot, hasDigit; hasE = hasFirst = hasDot = hasDigit = false; char c; for (int i = 0; i &lt; n; i++) &#123; c = s.charAt(i); if (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) &#123; hasFirst = hasDigit = true; continue; &#125; switch (c) &#123; /* * case &apos; &apos;: continue; */ // extend to accept any space everywhere case &apos;e&apos;: // already has &apos;e&apos; or no digit before &apos;e&apos; if (hasE || !hasDigit) return false; hasE = true; // reset for the exponential number hasFirst = hasDigit = false; hasDot = true; // the exponent must be an integer, hence // regard as if a dot exists already. Set // hasDot = false extending to accept any // (decimal) number as an exponent. continue; case &apos;+&apos;: case &apos;-&apos;: if (hasFirst) return false; hasFirst = true; continue; case &apos;.&apos;: if (hasDot) return false; hasFirst = hasDot = true; continue; default: return false; &#125; &#125; return hasDigit; &#125; https://discuss.leetcode.com/topic/2973/java-solution-with-one-line Java solution with one line 1return s.matches(&quot;(\\s*)[+-]?((\\.[0-9]+)|([0-9]+(\\.[0-9]*)?))(e[+-]?[0-9]+)?(\\s*)&quot;); cpp https://discuss.leetcode.com/topic/2710/a-simple-solution-in-cpp A simple solution in cpp The idea is pretty straightforward. A valid number is composed of the significand and the exponent (which is optional). As we go through the string, do the following things one by one: skip the leading whitespaces; check if the significand is valid. To do so, simply skip the leading sign and count the number of digits and the number of points. A valid significand has no more than one point and at least one digit. check if the exponent part is valid. We do this if the significand is followed by ‘e’. Simply skip the leading sign and count the number of digits. A valid exponent contain at least one digit. skip the trailing whitespaces. We must reach the ending 0 if the string is a valid number. 1234567891011121314151617181920212223242526272829303132bool isNumber(const char *s) &#123; int i = 0; // skip the whilespaces for(; s[i] == &apos; &apos;; i++) &#123;&#125; // check the significand if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; // skip the sign if exist int n_nm, n_pt; for(n_nm=0, n_pt=0; (s[i]&lt;=&apos;9&apos; &amp;&amp; s[i]&gt;=&apos;0&apos;) || s[i]==&apos;.&apos;; i++) s[i] == &apos;.&apos; ? n_pt++:n_nm++; if(n_pt&gt;1 || n_nm&lt;1) // no more than one point, at least one digit return false; // check the exponent if exist if(s[i] == &apos;e&apos;) &#123; i++; if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; // skip the sign int n_nm = 0; for(; s[i]&gt;=&apos;0&apos; &amp;&amp; s[i]&lt;=&apos;9&apos;; i++, n_nm++) &#123;&#125; if(n_nm&lt;1) return false; &#125; // skip the trailing whitespaces for(; s[i] == &apos; &apos;; i++) &#123;&#125; return s[i]==0; // must reach the ending 0 of the string&#125; https://discuss.leetcode.com/topic/30058/a-simple-solution-in-python-based-on-dfa A simple solution in Python based on DFA I was asked in the interview of linkedIn, writing it directly can be extremely complicated, for there are many special cases we have to deal with, and the code I wrote was messy. Then I failed to pass the interview. Here’s a clear solution. With DFA we can easily get our idea into shape and then debug, and the source code is clear and simple. 12345678910111213141516171819202122232425262728293031class Solution(object): def isNumber(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; #define a DFA state = [&#123;&#125;, &#123;&apos;blank&apos;: 1, &apos;sign&apos;: 2, &apos;digit&apos;:3, &apos;.&apos;:4&#125;, &#123;&apos;digit&apos;:3, &apos;.&apos;:4&#125;, &#123;&apos;digit&apos;:3, &apos;.&apos;:5, &apos;e&apos;:6, &apos;blank&apos;:9&#125;, &#123;&apos;digit&apos;:5&#125;, &#123;&apos;digit&apos;:5, &apos;e&apos;:6, &apos;blank&apos;:9&#125;, &#123;&apos;sign&apos;:7, &apos;digit&apos;:8&#125;, &#123;&apos;digit&apos;:8&#125;, &#123;&apos;digit&apos;:8, &apos;blank&apos;:9&#125;, &#123;&apos;blank&apos;:9&#125;] currentState = 1 for c in s: if c &gt;= &apos;0&apos; and c &lt;= &apos;9&apos;: c = &apos;digit&apos; if c == &apos; &apos;: c = &apos;blank&apos; if c in [&apos;+&apos;, &apos;-&apos;]: c = &apos;sign&apos; if c not in state[currentState].keys(): return False currentState = state[currentState][c] if currentState not in [3,5,8,9]: return False return True https://discuss.leetcode.com/topic/4219/c-my-thought-with-dfa [C++] My thought with DFA Code first 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool isNumber(string str) &#123; int state=0, flag=0; // flag to judge the special case &quot;.&quot; while(str[0]==&apos; &apos;) str.erase(0,1);//delete the prefix whitespace while(str[str.length()-1]==&apos; &apos;) str.erase(str.length()-1, 1);//delete the suffix whitespace for(int i=0; i&lt;str.length(); i++)&#123; if(&apos;0&apos;&lt;=str[i] &amp;&amp; str[i]&lt;=&apos;9&apos;)&#123; flag=1; if(state&lt;=2) state=2; else state=(state&lt;=5)?5:7; &#125; else if(&apos;+&apos;==str[i] || &apos;-&apos;==str[i])&#123; if(state==0 || state==3) state++; else return false; &#125; else if(&apos;.&apos;==str[i])&#123; if(state&lt;=2) state=6; else return false; &#125; else if(&apos;e&apos;==str[i])&#123; if(flag&amp;&amp;(state==2 || state==6 || state==7)) state=3; else return false; &#125; else return false; &#125; return (state==2 || state==5 || (flag&amp;&amp;state==6) || state==7); &#125;&#125;; DFA Thank @unknowcs, he came up with a brilliant provement in comments that making this a perfect DFA！ It’s just some states changes depend on inputs only. There 8 state in my states in my DFA.Below is my DFA transition diagram. DFA transition diagram or click picture hereDFA transition diagram There are 5 kind of inputs in my DFA: digit : number 0-9 for +,- : operator + or -(negative or positive) exp: e dot: . other: you can return false Immediately 4 final States in my DFA transition diagram : s2, s6, s7, s8 If the state change to final state at last, return true. s2 can accept digits only : +1 -23432 123 and etc s5 can accept exp expression: +2.4e+12 3e9 and etc s6 can accept decimals end with dot: 1. -42. and etc(careful, what if there exist only one dot “.” I use a variable flag judging weather there existing numbers. cause 0. and .0 is valid and . is invalid ) s7 can accept decimals: +12.23, 87., 132 It is clear how DFA works in my pictures. We just need to handle the inputs, and update the state according to DFA. https://discuss.leetcode.com/topic/17942/c-12-ms-give-some-invalid-examples-easily-understand C++ 12 ms,Give some invalid examples,easily understand 1234567891011121314151617181920212223class Solution &#123;public: bool isNumber(string s) &#123; //&quot;1 1&quot;is not valid, &quot;0x11&quot; is not valid, &quot;.&quot; is not valid, &quot;2e3.1&quot; is not valid, &quot;2e&quot; is not valid,&quot;1a&quot; is not valid,&quot;++1&quot; is not valid int n = s.size(); if(n == 0) return false; int i = 0; int count_num = 0,count_point = 0; while(s[i] == &apos; &apos;) i++; if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; while(isdigit(s[i]) || s[i] == &apos;.&apos;) s[i++] == &apos;.&apos;?count_point++:count_num++; if(count_point &gt; 1 || count_num &lt; 1) return false; if(s[i] == &apos;e&apos;)&#123; i++; count_num = 0;count_point = 0; if(s[i] == &apos;+&apos; || s[i] == &apos;-&apos;) i++; while(isdigit(s[i]) || s[i] == &apos;.&apos;) s[i++] == &apos;.&apos;?count_point++:count_num++; if(count_point &gt; 0 || count_num &lt; 1) return false; &#125; while(s[i] == &apos; &apos;) i++; return i == n; &#125;&#125;; python https://discuss.leetcode.com/topic/26746/easy-python-solution-68-ms-beats-100 Easy Python Solution 68 ms beats 100% 1234def isNumber(self, s): try: float(s) except ValueError: return False else: return True Easy Peasy :)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[064. Minimum Path Sum]]></title>
    <url>%2Fp%2Ff9fa56b2%2F</url>
    <content type="text"><![CDATA[37.5% https://leetcode.com/problems/minimum-path-sum/ Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. 方法一: 我的代码实现: 1234567891011121314151617class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(); for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(i&gt;0 &amp;&amp; j&gt;0) grid[i][j] += min(grid[i-1][j], grid[i][j-1]); else if(i==0 &amp;&amp; j&gt;0) grid[i][j] += grid[i][j-1]; else if(i&gt;0 &amp;&amp; j==0) grid[i][j] += grid[i-1][j]; &#125; &#125; return grid[m-1][n-1]; &#125;&#125;; https://discuss.leetcode.com/topic/15269/10-lines-28ms-o-n-space-dp-solution-in-c-with-explanations 10-lines 28ms O(n)-space DP solution in C++ with Explanations This is a typical DP problem. Suppose the minimum path sum of arriving at point (i, j) is S[i][j], then the state equation is S[i][j] = min(S[i - 1][j], S[i][j - 1]) + grid[i][j]. Well, some boundary conditions need to be handled. The boundary conditions happen on the topmost row (S[i - 1][j] does not exist) and the leftmost column (S[i][j - 1] does not exist). Suppose grid is like [1, 1, 1, 1], then the minimum sum to arrive at each point is simply an accumulation of previous points and the result is [1, 2, 3, 4]. Now we can write down the following (unoptimized) code. 12345678910111213141516class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); vector&lt;vector&lt;int&gt; &gt; sum(m, vector&lt;int&gt;(n, grid[0][0])); for (int i = 1; i &lt; m; i++) sum[i][0] = sum[i - 1][0] + grid[i][0]; for (int j = 1; j &lt; n; j++) sum[0][j] = sum[0][j - 1] + grid[0][j]; for (int i = 1; i &lt; m; i++) for (int j = 1; j &lt; n; j++) sum[i][j] = min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j]; return sum[m - 1][n - 1]; &#125;&#125;; 方法二: As can be seen, each time when we update sum[i][j], we only need sum[i - 1][j] (at the current column) and sum[i][j - 1] (at the left column). So we need not maintain the full m*n matrix. Maintaining two columns is enough and now we have the following code. 123456789101112131415161718class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); vector&lt;int&gt; pre(m, grid[0][0]); vector&lt;int&gt; cur(m, 0); for (int i = 1; i &lt; m; i++) pre[i] = pre[i - 1] + grid[i][0]; for (int j = 1; j &lt; n; j++) &#123; cur[0] = pre[0] + grid[0][j]; for (int i = 1; i &lt; m; i++) cur[i] = min(cur[i - 1], pre[i]) + grid[i][j]; swap(pre, cur); &#125; return pre[m - 1]; &#125;&#125;; Further inspecting the above code, it can be seen that maintaining pre is for recovering pre[i], which is simply cur[i] before its update. So it is enough to use only one vector. Now the space is further optimized and the code also gets shorter. 12345678910111213141516class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); vector&lt;int&gt; cur(m, grid[0][0]); for (int i = 1; i &lt; m; i++) cur[i] = cur[i - 1] + grid[i][0]; for (int j = 1; j &lt; n; j++) &#123; cur[0] += grid[0][j]; for (int i = 1; i &lt; m; i++) cur[i] = min(cur[i - 1], cur[i]) + grid[i][j]; &#125; return cur[m - 1]; &#125;&#125;; https://discuss.leetcode.com/topic/3403/dp-solution-linear-space DP Solution, Linear space You can only reach a cell by going from its left or top neighbor. 123456789101112131415161718192021class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) &#123; if(!grid.size())return 0; const int rows=grid.size(),cols=grid[0].size(); // r[i] == min path sum to previous row&apos;s column i. vector&lt;int&gt; r(cols,0); int i,j; r[0]=grid[0][0]; for(j=1;j&lt;cols;j++)&#123; r[j]=grid[0][j]+r[j-1]; &#125; for(i=1;i&lt;rows;i++)&#123; r[0]+=grid[i][0]; for(j=1;j&lt;cols;j++)&#123; r[j]=min(r[j-1],r[j])+grid[i][j]; &#125; &#125; return r[cols-1]; &#125;&#125;; https://discuss.leetcode.com/topic/448/minimum-path-sum-how-can-i-reduce-the-memory Minimum Path Sum ———How can I reduce the memory. Here is the idea: f[m][n] is a matrix store the min value of every location we canget. f[0][0] =grid[0][0], f[i][0]=f[i-1][0]+grid[i][0], f[0][j]=f[0][j-1]+grid[0][j] f[i][j]=min(f[i-1][j],f[i][j-1])+grid[i][j]. at last return the f[m-1][n-1] 1234567891011121314151617181920212223242526272829303132class Solution &#123; public: int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) &#123; // IMPORTANT: Please reset any member data you declared, as // the same Solution instance will be reused for each test case. int m=grid.size(); int n=grid[0].size(); int** f; f=new int*[m]; for(int i=0;i&lt;m;i)&#123; f[i]=new int[n]; &#125; f[0][0]=grid[0][0]; for(int i=1;i&lt;m;i++)&#123; f[i][0]=f[i-1][0]+grid[i][0]; &#125; for(int i=1;i&lt;n;i++)&#123; f[0][i]=f[0][i-1]+grid[0][i]; &#125; for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++) f[i][j]=min(f[i-1][j],f[i][j-1])+grid[i][j]; &#125; return f[m-1][n-1]; &#125; int min(int a,int b)&#123; if(a&gt;b) return b; else return a; &#125; &#125;; https://discuss.leetcode.com/topic/16654/c-easy-solution-using-dp-space-compexity-o-1 C++ easy solution using dp. space compexity : O(1) 123456789101112131415161718class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; a) &#123; int m=a.size(); if(m==0) return 0; int n= a[0].size(); for(int i = 0 ; i&lt;m; i++ )&#123; for(int j=0; j&lt;n ; j++)&#123; int left= (j==0) ? INT_MAX : a[i][j-1]; int up = (i==0) ? INT_MAX : a[i-1][j]; if(i==0 &amp;&amp; j==0) continue; a[i][j] += min(left, up ); &#125; &#125; return a[m-1][n-1]; &#125;&#125;; python https://leetcode.com/discuss/34905/simple-python-dp-70ms 76ms, 49.83%, June.20th, 2016 12345678910111213141516class Solution(object): def minPathSum(self, grid): &quot;&quot;&quot; :type grid: List[List[int]] :rtype: int &quot;&quot;&quot; m = len(grid) n = len(grid[0]) for i in xrange(1, n): grid[0][i] += grid[0][i-1] for i in xrange(1, m): grid[i][0] += grid[i-1][0] for i in xrange(1,m): for j in xrange(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[-1][-1] java https://discuss.leetcode.com/topic/5459/my-java-solution-using-dp-and-no-extra-space My java solution using DP and no extra space 1234567891011121314151617181920public int minPathSum(int[][] grid) &#123; int m = grid.length;// row int n = grid[0].length; // column for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == 0 &amp;&amp; j != 0) &#123; grid[i][j] = grid[i][j] + grid[i][j - 1]; &#125; else if (i != 0 &amp;&amp; j == 0) &#123; grid[i][j] = grid[i][j] + grid[i - 1][j]; &#125; else if (i == 0 &amp;&amp; j == 0) &#123; grid[i][j] = grid[i][j]; &#125; else &#123; grid[i][j] = Math.min(grid[i][j - 1], grid[i - 1][j]) + grid[i][j]; &#125; &#125; &#125; return grid[m - 1][n - 1];&#125; https://discuss.leetcode.com/topic/30575/my-8-lines-simple-solution My 8 lines simple solution 123456789int m = grid.length, n = grid[0].length;for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == 0 &amp;&amp; j != 0) grid[i][j] += grid[i][j-1]; if(i != 0 &amp;&amp; j == 0) grid[i][j] += grid[i-1][j]; if (i != 0 &amp;&amp; j != 0) grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]); &#125;&#125;return grid[m-1][n-1]; https://discuss.leetcode.com/topic/3184/ac-java-dp-solution-v-s-tle-dijstra-solution AC Java DP solution v.s. TLE Dijstra solution When I looked at this question, the first thought was the Dijkstra solution, which is a very fast algorithm to calculate the shortest path. But this solution got TLE in this question, while DP solution worked fine. I will talk about the Dijkstra solution first, as it’s the first though came into my mind, and there is already discussions on the DP solution. If you are not interested in the Dijkstra solution, you can jump to the latter part of this post, which is about the DP solution, which is accepted. DijkstraThe idea of Dijkstra algorithm is to divide the graph into 2 parts, visited and unvisited.For every node in the visited part has a dist value. Then we need to exam every edges across the visited part and the unvisited parts, which are edges that its start node is in the visited part, while its end node is in the unvisited part. What we are looking for is one edge, which has the minimum value of (dist(start node) + the edge’s value). Then we put this node into the visited part and exam the edges again. Following is the code. It uses a Java Heap, PriorityQueue to keep track of the minimum (dist(start node) + the edge’s value), but in this question, the edge value is in the node itself, which is the same for every edges ending to it, so actually the heap just keeps track of the mimimum dist(start node) of every unvisited nodes around the boarder between visited and unvisited. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Solution_dijkstra &#123;class PointComparator implements Comparator&lt;int[]&gt;&#123; int[][] dist; public PointComparator(int[][] dist)&#123; this.dist = dist; &#125; @Override public int compare(int[] o1, int[] o2) &#123; int[] point1 = (int[])o1; int[] point2 = (int[])o2; return Integer.valueOf(dist[point1[0]][point1[1]]) .compareTo(Integer.valueOf(dist[point2[0]][point2[1]])); &#125;&#125; public int minPathSum(int[][] grid) &#123; if(grid == null || grid.length == 0) return 0; int m = grid.length; int n = grid[0].length; boolean[][] visited = new boolean[m][n]; int[][] dist = new int[m][n]; for(int x = 0; x &lt; m; x++)&#123; for(int y = 0; y &lt; n; y++)&#123; dist[x][y] = Integer.MAX_VALUE; &#125; &#125; dist[0][0] = grid[0][0]; PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;( m*n, new PointComparator(dist)); pq.add(new int[]&#123;0, 0&#125;); while(!pq.isEmpty())&#123; int[] point = pq.poll(); int x = point[0]; int y = point[1]; int d = dist[x][y]; if(x == n-1 &amp;&amp; y == m-1)&#123; return d; &#125; visited[x][y] = true; if((y+1 &lt; n) &amp;&amp; !visited[x][y+1])&#123; dist[x][y+1] = min( dist[x][y+1], d + grid[x][y+1]); pq.add(new int[]&#123;x, y+1&#125;); &#125; if((x+1 &lt; m ) &amp;&amp; !visited[x+1][y])&#123; dist[x+1][y] = min( dist[x+1][y], d + grid[x+1][y]); pq.add(new int[]&#123;x+1, y&#125;); &#125; &#125; return 0; &#125;private int min(int i1, int i2)&#123; return i1 &lt; i2 ? i1 : i2;&#125;&#125; This solution got LTE error, mostly because of the priority queue and doesn’t consider the special condition here that it’s a grid and directed, which means a node can only be accessed from it’s left and upper nodes. Put all these into consideration, we have the DP solution. It’s essentially formula is dist(node) = min( dist(upper node), dist(left node)) + node’s value DPhere is the code: 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution_dp &#123;private int getDist(int[][] dist, int x, int y)&#123; if(x &lt; 0 || y &lt; 0)&#123; return Integer.MAX_VALUE; &#125; return dist[x][y]; &#125;private int min(int i1, int i2)&#123; return i1 &lt; i2 ? i1 : i2;&#125;public int minPathSum(int[][] grid) &#123; if(grid == null || grid.length == 0) return 0; int m = grid.length; int n = grid[0].length; int[][] dist = new int[m][n]; for(int x = 0; x &lt; m; x++)&#123; for(int y = 0; y &lt; n; y++)&#123; if(x == 0 &amp;&amp; y == 0)&#123; dist[0][0] = grid[0][0]; &#125;else&#123; dist[x][y] = min(getDist(dist, x-1, y), getDist(dist, x, y-1)) + grid[x][y]; &#125; &#125; &#125; return dist[m-1][n-1]; &#125;&#125; my code 1234567891011121314public class Solution &#123; public int minPathSum(int[][] grid) &#123; int m=grid.length; int n=grid[0].length; for(int i=0; i&lt;m; i++) for(int j=0; j&lt;n; j++)&#123; if(i==0 &amp;&amp; j==0) continue; if(i&gt;0 &amp;&amp; j==0) grid[i][j] += grid[i-1][j]; if(i==0 &amp;&amp; j&gt;0) grid[i][j] += grid[i][j-1]; if(i&gt;0 &amp;&amp; j&gt;0) grid[i][j] += Math.min(grid[i][j-1], grid[i-1][j]); &#125; return grid[m-1][n-1]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[063. Unique Paths II]]></title>
    <url>%2Fp%2F64df03c8%2F</url>
    <content type="text"><![CDATA[31.1% https://leetcode.com/problems/unique-paths-ii/ Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. 12345678910For example,There is one obstacle in the middle of a 3x3 grid as illustrated below.[ [0,0,0], [0,1,0], [0,0,0]]The total number of unique paths is 2. Note: m and n will be at most 100. 方法一： m*n，变为(m+1) * (n+1) ，然后（0,1）设为1，依次遍历就好了。 12345678910111213class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i = 1; i &lt;= m; ++i) for(int j = 1; j &lt;= n; ++j) if(!obstacleGrid[i-1][j-1]) dp[i][j] = dp[i-1][j] + dp[i][j-1]; return dp[m][n]; &#125;&#125;; 我的代码实现： 1234567891011121314151617class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i=1; i&lt;=m; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; if(obstacleGrid[i-1][j-1]) dp[i][j] = 0; else dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; 方法二： 上面的空间是O（mn），想法空间变为O（n）或者O（m）。 我的代码实现： Dec 7th, 2017 该方法主要是降低了空间复杂度，相对于下面的代码，这个借鉴了上面的思想，不是设置m个，而是m+1个。这样子就代码简洁和思路清晰多了。 注意代码中注释可能会犯的错。 1234567891011121314151617class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; if(obstacleGrid.empty() || obstacleGrid[0].empty()) return 0; int m = obstacleGrid[0].size(); vector&lt;int&gt; res(m+1, 0); res[1] = 1; // 不要忘了初始化 for(int i=0; i&lt;obstacleGrid.size(); i++) for(int j=0; j&lt;obstacleGrid[0].size(); j++) if(obstacleGrid[i][j]==0) //分清楚0还是1，条件 res[j+1] += res[j]; else res[j+1] = 0; return res[m];// m+1个最后一位是res[m],不是res[m+1] &#125;&#125;; 123456789101112131415161718192021222324252627class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); if(m==0 || n==0) return 0; vector&lt;int&gt; res(n, 0); if(obstacleGrid[0][0]==1) return 0; res[0] = 1; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(i==0 &amp;&amp; j==0) continue; if(i&gt;0 &amp;&amp; j==0)&#123; if(obstacleGrid[i][j]) res[j] = 0; &#125; if(j&gt;0)&#123; if(obstacleGrid[i][j]) res[j] = 0; else res[j] += res[j-1]; &#125; &#125; &#125; return res[n-1]; &#125;&#125;; cpp https://leetcode.com/discuss/13965/my-c-dp-solution-very-simple My C++ Dp solution , very simple! just use dp to find the answer , if there is a obstacle at (i,j), then dp[i][j] = 0. time is O(nm) , space is O(nm) . here is my code: 5ms, 8.13%, June.22th, 2016 12345678910111213class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i = 1; i &lt;= m; ++i) for(int j = 1; j &lt;= n; ++j) if(!obstacleGrid[i-1][j-1]) dp[i][j] = dp[i-1][j] + dp[i][j-1]; return dp[m][n]; &#125;&#125;; https://discuss.leetcode.com/topic/15267/4ms-o-n-dp-solution-in-c-with-explanations 4ms O(n) DP Solution in C++ with Explanations Well, this problem is similar to Unique Paths. The introduction of obstacles only changes the boundary conditions and make some points unreachable (simply set to 0). Denote the number of paths to arrive at point (i, j) to be P[i][j], the state equation is P[i][j] = P[i - 1][j] + P[i][j - 1] if obstacleGrid[i][j] != 1 and 0 otherwise. Now let’s finish the boundary conditions. In the Unique Paths problem, we initialize P[0][j] = 1, P[i][0] = 1 for all valid i, j. Now, due to obstacles, some boundary points are no longer reachable and need to be initialized to 0. For example, if obstacleGrid is like [0, 0, 1, 0, 0], then the last three points are not reachable and need to be initialized to be 0. The result is [1, 1, 0, 0, 0]. Now we can write down the following (unoptimized) code. Note that we pad the obstacleGrid by 1 and initialize dp[0][1] = 1 to unify the boundary cases. 12345678910111213class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt; &gt; dp(m + 1, vector&lt;int&gt; (n + 1, 0)); dp[0][1] = 1; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (!obstacleGrid[i - 1][j - 1]) dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; return dp[m][n]; &#125; &#125;; Well, the code is accepted but it has some obvious redundancy. There are two major concerns: Each time when we update path[i][j], we only need path[i - 1][j] (at the same column) and path[i][j - 1] (at the left column), so it is unnecessary to maintain the full m*n matrix. Maintaining two columns is enough.There are some cases that the loop can be terminated earlier. Suppose obstacleGrid = [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]], then we can see that it is impossible to reach the bottom-right corner after updating the second column since the number of paths to reach each element in the second column is 0.Taken these into considerations, we write down the following optimized code. 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;int&gt; pre(m, 0); vector&lt;int&gt; cur(m, 0); for (int i = 0; i &lt; m; i++) &#123; if (!obstacleGrid[i][0]) pre[i] = 1; else break; &#125; for (int j = 1; j &lt; n; j++) &#123; bool flag = false; if (!obstacleGrid[0][j]) &#123; cur[0] = pre[0]; if (cur[0]) flag = true; &#125; else cur[0] = 0; for (int i = 1; i &lt; m; i++) &#123; if (!obstacleGrid[i][j]) &#123; cur[i] = cur[i - 1] + pre[i]; if (cur[i]) flag = true; &#125; else cur[i] = 0; &#125; if (!flag) return 0; swap(pre, cur); &#125; return pre[m - 1]; &#125;&#125;; Further inspecting the above code, keeping two vectors only serve for the purpose of recovering pre[i], which is simply cur[i] before its update. So we can use only one vector and the space is further optimized. 12345678910111213141516171819202122232425262728class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;int&gt; cur(m, 0); for (int i = 0; i &lt; m; i++) &#123; if (!obstacleGrid[i][0]) cur[i] = 1; else break; &#125; for (int j = 1; j &lt; n; j++) &#123; bool flag = false; if (obstacleGrid[0][j]) cur[0] = 0; else flag = true; for (int i = 1; i &lt; m; i++) &#123; if (!obstacleGrid[i][j]) &#123; cur[i] += cur[i - 1]; if (cur[i]) flag = true; &#125; else cur[i] = 0; &#125; if (!flag) return 0; &#125; return cur[m - 1]; &#125;&#125;; python https://leetcode.com/discuss/19681/accepted-simple-python-in-place-solution Accepted simple Python in-place solution As below. Any comments on how to make it shorter? Thx! 68ms, 14.48%, June.22th, 20161234567891011121314151617class Solution(object): def uniquePathsWithObstacles(self, obstacleGrid): &quot;&quot;&quot; :type obstacleGrid: List[List[int]] :rtype: int &quot;&quot;&quot; m = len(obstacleGrid) n = len(obstacleGrid[0]) ResGrid = [[0 for x in range(n+1)] for x in range(m+1)] ResGrid[0][1] = 1 for i in range(1, m+1): for j in range(1, n+1): if not obstacleGrid[i-1][j-1]: ResGrid[i][j] = ResGrid[i][j-1] + ResGrid[i-1][j] return ResGrid[m][n] java https://leetcode.com/discuss/29816/short-java-solution Short JAVA solution 1ms, 22.20%, June.22th, 20161234567891011121314public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int width = obstacleGrid[0].length; int[] dp = new int[width]; dp[0] = 1; for(int[] row:obstacleGrid) for(int j=0; j&lt;width; j++) if(row[j] == 1) dp[j] = 0; else if(j&gt;0) dp[j] += dp[j-1]; return dp[width - 1]; &#125;&#125; https://discuss.leetcode.com/topic/4987/java-solution-using-dynamic-programming-o-1-space Java Solution using Dynamic Programming, O(1) space 12345678910111213141516171819202122232425262728public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; //Empty case if(obstacleGrid.length == 0) return 0; int rows = obstacleGrid.length; int cols = obstacleGrid[0].length; for(int i = 0; i &lt; rows; i++)&#123; for(int j = 0; j &lt; cols; j++)&#123; if(obstacleGrid[i][j] == 1) obstacleGrid[i][j] = 0; else if(i == 0 &amp;&amp; j == 0) obstacleGrid[i][j] = 1; else if(i == 0) obstacleGrid[i][j] = obstacleGrid[i][j - 1] * 1;// For row 0, if there are no paths to left cell, then its 0,else 1 else if(j == 0) obstacleGrid[i][j] = obstacleGrid[i - 1][j] * 1;// For col 0, if there are no paths to upper cell, then its 0,else 1 else obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]; &#125; &#125; return obstacleGrid[rows - 1][cols - 1]; &#125;&#125; https://discuss.leetcode.com/topic/9687/easy-java-solution-in-place-dp Easy Java solution, in-place, DP The idea is simple, set all obstacles to be 0 while doing the DP. No extra space is used. 123456789101112131415161718192021public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length; int n = obstacleGrid[0].length; obstacleGrid[0][0]^=1; for(int i = 1;i&lt;m;i++)&#123; obstacleGrid[i][0]=(obstacleGrid[i][0]==1)? 0:obstacleGrid[i-1][0]; &#125; for(int j = 1;j&lt;n;j++)&#123; obstacleGrid[0][j] =(obstacleGrid[0][j]==1)? 0: obstacleGrid[0][j-1]; &#125; for(int i = 1;i&lt;m;i++)&#123; for(int j =1;j&lt;n;j++)&#123; obstacleGrid[i][j] =(obstacleGrid[i][j]==1)? 0: obstacleGrid[i-1][j]+obstacleGrid[i][j-1]; &#125; &#125; return obstacleGrid[m-1][n-1]; &#125; &#125; my code动态规划 12345678910111213141516171819202122232425public class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; if(obstacleGrid.length == 0 || obstacleGrid[0].length == 0) return 0; int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[] ans = new int[n]; if(obstacleGrid[0][0]==1) return 0; ans[0] = 1; for(int i=0; i&lt;m; i++) for(int j=0; j&lt;n; j++)&#123; if(i==0 &amp;&amp; j==0) continue; if(i&gt;0 &amp;&amp; j==0)&#123; if(obstacleGrid[i][j]==1) ans[j] = 0; &#125; if(j&gt;0)&#123; if(obstacleGrid[i][j]==1) ans[j] = 0; else ans[j] += ans[j-1]; &#125; &#125; return ans[n-1]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[062. Unique Paths]]></title>
    <url>%2Fp%2F59afcf56%2F</url>
    <content type="text"><![CDATA[39.7% https://leetcode.com/problems/unique-paths/ A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 3 x 7 grid. How many possible unique paths are there? 解析 用dp算法或者使用公式，共m+n-2步，然后从中选取m-1步作为向右。 方法一： dp算法记录每一步有的方法数，以此类推。 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; if(m==0 || n==0) return 0; vector&lt;int&gt; dp(n, 1); for(int i=1; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; dp[j] += dp[j-1]; &#125; &#125; return dp[n-1]; &#125;&#125;; 类似的方法， 上面的更简单。 1234567891011121314class Solution &#123;public: int uniquePaths(int m, int n) &#123; if(m==0 || n==0) return 0; vector&lt;int&gt; dp(n, 0); dp[0] = 1; for(int i=0; i&lt;m; i++)&#123; for(int j=1; j&lt;n; j++)&#123; dp[j] += dp[j-1]; &#125; &#125; return dp[n-1]; &#125;&#125;; 方法二： 使用公式的话，记得定义值的类型要为double，否则数值就会出问题。 123456789101112131415class Solution &#123; public: int uniquePaths(int m, int n) &#123; int N = n + m - 2;// how much steps we need to do int k = m - 1; // number of steps that need to go down double res = 1; // here we calculate the total possible path number // Combination(N, k) = n! / (k!(n - k)!) // reduce the numerator and denominator and get // C = ( (n - k + 1) * (n - k + 2) * ... * n ) / k! for (int i = 1; i &lt;= k; i++) res = res * (N - k + i) / i; return (int)res; &#125; &#125;; my code: 1234567891011class Solution &#123;public: int uniquePaths(int m, int n) &#123; if(m==0 || n==0) return 0; double res = 1.0; for(int i=1; i&lt;=n-1; i++)&#123; res = res * (m-1+i) / i; &#125; return (int)res; &#125;&#125;; 方法三： m+1 * n+1数组 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); dp[0][1] = 1; for(int i=1; i&lt;=m; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m][n]; &#125;&#125;; cpp https://discuss.leetcode.com/topic/15265/0ms-5-lines-dp-solution-in-c-with-explanations 0ms, 5-lines DP Solution in C++ with Explanations This is a fundamental DP problem. First of all, let’s make some observations. Since the robot can only move right and down, when it arrives at a point, there are only two possibilities: It arrives at that point from above (moving down to that point); It arrives at that point from left (moving right to that point).Thus, we have the following state equations: suppose the number of paths to arrive at a point (i, j) is denoted as P[i][j], it is easily concluded that P[i][j] = P[i - 1][j] + P[i][j - 1]. The boundary conditions of the above equation occur at the leftmost column (P[i][j - 1] does not exist) and the uppermost row (P[i - 1][j] does not exist). These conditions can be handled by initialization (pre-processing) — initialize P[0][j] = 1, P[i][0] = 1 for all valid i, j. Note the initial value is 1 instead of 0! Now we can write down the following (unoptimized) code. 123456789class Solution &#123; int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt; &gt; path(m, vector&lt;int&gt; (n, 1)); for (int i = 1; i &lt; m; i++) for (int j = 1; j &lt; n; j++) path[i][j] = path[i - 1][j] + path[i][j - 1]; return path[m - 1][n - 1]; &#125;&#125;; As can be seen, the above solution runs in O(n^2) time and costs O(m*n) space. However, you may have observed that each time when we update path[i][j], we only need path[i - 1][j] (at the same column) and path[i][j - 1] (at the left column). So it is enough to maintain two columns (the current column and the left column) instead of maintaining the full m*n matrix. Now the code can be optimized to have O(min(m, n)) space complexity. 12345678910111213class Solution &#123; int uniquePaths(int m, int n) &#123; if (m &gt; n) return uniquePaths(n, m); vector&lt;int&gt; pre(m, 1); vector&lt;int&gt; cur(m, 1); for (int j = 1; j &lt; n; j++) &#123; for (int i = 1; i &lt; m; i++) cur[i] = cur[i - 1] + pre[i]; swap(pre, cur); &#125; return pre[m - 1]; &#125;&#125;; Further inspecting the above code, we find that keeping two columns is used to recover pre[i], which is just cur[i] before its update. So there is even no need to use two vectors and one is just enough. Now the space is further saved and the code also gets much shorter. 12345678910class Solution &#123; int uniquePaths(int m, int n) &#123; if (m &gt; n) return uniquePaths(n, m); vector&lt;int&gt; cur(m, 1); for (int j = 1; j &lt; n; j++) for (int i = 1; i &lt; m; i++) cur[i] += cur[i - 1]; return cur[m - 1]; &#125;&#125;; Well, till now, I guess you may even want to optimize it to O(1) space complexity since the above code seems to rely on only cur[i] and cur[i - 1]. You may think that 2 variables is enough? Well, it is not. Since the whole cur needs to be updated for n - 1 times, it means that all of its values need to be saved for next update and so two variables is not enough. https://leetcode.com/discuss/9110/my-ac-solution-using-formula 0ms, 17.54%, June.19th, 2016 Binomial coefficient: 123456789101112131415class Solution &#123; public: int uniquePaths(int m, int n) &#123; int N = n + m - 2;// how much steps we need to do int k = m - 1; // number of steps that need to go down double res = 1; // here we calculate the total possible path number // Combination(N, k) = n! / (k!(n - k)!) // reduce the numerator and denominator and get // C = ( (n - k + 1) * (n - k + 2) * ... * n ) / k! for (int i = 1; i &lt;= k; i++) res = res * (N - k + i) / i; return (int)res; &#125; &#125;; First of all you should understand that we need to do n + m - 2 movements : m - 1 down, n - 1 right, because we start from cell (1, 1). Secondly, the path it is the sequence of movements( go down / go right), therefore we can say that two paths are different when there is i-th (1 .. m + n - 2) movement in path1 differ i-th movement in path2. So, how we can build paths. Let’s choose (n - 1) movements(number of steps to the right) from (m + n - 2), and rest (m - 1) is (number of steps down). I think now it is obvious that count of different paths are all combinations (n - 1) movements from (m + n-2). python https://leetcode.com/discuss/63819/1-line-math-solution-python 1 Line Math Solution (Python) 48ms, 54.13%, June.19th, 201612345678class Solution(object): def uniquePaths(self, m, n): &quot;&quot;&quot; :type m: int :type n: int :rtype: int &quot;&quot;&quot; return math.factorial(m+n-2) / math.factorial(m-1) / math.factorial(n-1) https://discuss.leetcode.com/topic/6440/accpeted-simple-python-dp-solution Accpeted simple Python DP solution. 12345678class Solution: # @return an integer def uniquePaths(self, m, n): aux = [[1 for x in range(n)] for x in range(m)] for i in range(1, m): for j in range(1, n): aux[i][j] = aux[i][j-1]+aux[i-1][j] return aux[-1][-1] my code 1234567891011121314151617181920212248ms, 54.13%, June.19th, 2016class Solution(object): def uniquePaths(self, m, n): &quot;&quot;&quot; :type m: int :type n: int :rtype: int &quot;&quot;&quot; if m == 1 or n == 1: return 1 p1 = max(m-1, n-1) p2 = min(m-1, n-1) p3 = m + n - 2 res1 = 1 i = p3 while i &gt; p3 - p2: res1 *= i i -= 1 res2 = 1 while p2 &gt; 0: res2 *= p2 p2 -= 1 return res1 / res2 java https://discuss.leetcode.com/topic/5623/java-dp-solution-with-complexity-o-n-m Java DP solution with complexity O(n*m) 1234567891011121314151617public class Solution &#123; public int uniquePaths(int m, int n) &#123; Integer[][] map = new Integer[m][n]; for(int i = 0; i&lt;m;i++)&#123; map[i][0] = 1; &#125; for(int j= 0;j&lt;n;j++)&#123; map[0][j]=1; &#125; for(int i = 1;i&lt;m;i++)&#123; for(int j = 1;j&lt;n;j++)&#123; map[i][j] = map[i-1][j]+map[i][j-1]; &#125; &#125; return map[m-1][n-1]; &#125;&#125; The assumptions are When (n == 0||m == 0) the function always returns 1 since the robot can’t go left or up. For all other cells. The result = uniquePaths(m-1,n)+uniquePaths(m,n-1) Therefore I populated the edges with 1 first and use DP to get the full 2-D array. Please give any suggestions on improving the code. my code 1234567891011121314public class Solution &#123; public int uniquePaths(int m, int n) &#123; if(m == 0 || n == 0) return 0; int[] ans = new int[n]; for(int i=0; i&lt;n; i++) ans[i] = 1; for(int i=1; i&lt;m; i++) for(int j=1; j&lt;n; j++) ans[j] += ans[j-1]; return ans[n-1]; &#125;&#125; 123456789100ms, 84.01%, June.19th, 2016https://leetcode.com/discuss/9110/my-ac-solution-using-formulapublic class Solution &#123; public int uniquePaths(int m, int n) &#123; double value = 1; for(int i = 1; i &lt;= n-1; i++) value *= ((double)(m+i-1)/(double)i); return (int)Math.round(value); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[061. Rotate List]]></title>
    <url>%2Fp%2F61df86e1%2F</url>
    <content type="text"><![CDATA[24.3% https://leetcode.com/problems/rotate-list/ Given a list, rotate the list to the right by k places, where k is non-negative. 123For example:Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. 方法一： 先遍历一遍，求出长度 通过将尾节点与头结点相链接 然后向前走 len - k%len步，就可以了。 核心：一次遍历求长度，然后尾部相连 我的代码实现： Oct, 11th, 2017 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; // 是或||的关系，不是&amp;&amp; // k==0的情况要考虑到 if(!head || !head-&gt;next || k==0) return head; ListNode* p1 = head; int cnt = 1; while(p1-&gt;next)&#123; cnt++; p1 = p1-&gt;next; &#125; // 现除以cnt // 要移动的步数，需要用cnt-k k %= cnt; k = cnt -k; p1-&gt;next = head; while(k!=0)&#123; p1 = p1-&gt;next; k--; &#125; ListNode* node = p1-&gt;next; p1-&gt;next = nullptr; return node; &#125;&#125;; C++ simple algorithm with explanation Enumerate through the list to find the last node, count the size along the way. Make a loop, by connection last to first Get modulo of |k/size| - avoiding extra rotation Enumerate again size-k nodes Break the loop and return new head code: 123456789101112131415161718192021222324252627282930ListNode *rotateRight(ListNode *head, int k) &#123; if(head == NULL || head-&gt;next == NULL||k==0) return head; ListNode* node = head; int size =1; while(node-&gt;next != NULL) &#123; size++; node = node-&gt;next; &#125; //loop the list node-&gt;next=head; //handle the case of k&gt;size k = k%size; //find the node to break the loop at while(--size &gt;= k) &#123; node=node-&gt;next; &#125; ListNode* first = node-&gt;next; node-&gt;next=NULL; return first; &#125; 代码的另一种实现 My clean C++ code, quite standard (find tail and reconnect the list) There is no trick for this problem. Some people used slow/fast pointers to find the tail node but I don’t see the benefit (in the sense that it doesn’t reduce the pointer move op) to do so. So I just used one loop to find the length first. 12ms, September 11, 2016 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(!head) return head; int len=1; // number of nodes ListNode *newH, *tail; newH=tail=head; while(tail-&gt;next) // get the number of nodes in the list &#123; tail = tail-&gt;next; len++; &#125; tail-&gt;next = head; // circle the link if(k %= len) &#123; for(auto i=0; i&lt;len-k; i++) tail = tail-&gt;next; // the tail node is the (len-k)-th node (1st node is head) &#125; newH = tail-&gt;next; tail-&gt;next = NULL; return newH; &#125;&#125;; https://discuss.leetcode.com/topic/815/what-to-do-when-k-is-greater-than-size-of-list What to do when k is greater than size of list ? i am not getting that what i should do when K is greater than size of the list. https://discuss.leetcode.com/topic/815/what-to-do-when-k-is-greater-than-size-of-list/2 Let’s start with an example. Given [0,1,2], rotate 1 steps to the right -&gt; [2,0,1]. Given [0,1,2], rotate 2 steps to the right -&gt; [1,2,0]. Given [0,1,2], rotate 3 steps to the right -&gt; [0,1,2]. Given [0,1,2], rotate 4 steps to the right -&gt; [2,0,1]. So, no matter how big K, the number of steps is, the result is always the same as rotating K % n steps to the right. https://discuss.leetcode.com/topic/9161/i-think-the-description-of-this-problem-is-misleading I think the description of this problem is misleading. Recalling the problems about rotated array, this description is misleading. For those who have trouble understanding this problem like me, think of the SLL as a circle. cpp https://discuss.leetcode.com/topic/14470/my-clean-c-code-quite-standard-find-tail-and-reconnect-the-list My clean C++ code, quite standard (find tail and reconnect the list) There is no trick for this problem. Some people used slow/fast pointers to find the tail node but I don’t see the benefit (in the sense that it doesn’t reduce the pointer move op) to do so. So I just used one loop to find the length first. 12ms, September 11, 2016 12345678910111213141516171819202122232425class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(!head) return head; int len=1; // number of nodes ListNode *newH, *tail; newH=tail=head; while(tail-&gt;next) // get the number of nodes in the list &#123; tail = tail-&gt;next; len++; &#125; tail-&gt;next = head; // circle the link if(k %= len) &#123; for(auto i=0; i&lt;len-k; i++) tail = tail-&gt;next; // the tail node is the (len-k)-th node (1st node is head) &#125; newH = tail-&gt;next; tail-&gt;next = NULL; return newH; &#125;&#125;; https://discuss.leetcode.com/topic/7293/c-simple-algorithm-with-explanation C++ simple algorithm with explanation Enumerate through the list to find the last node, count the size along the way. Make a loop, by connection last to first Get modulo of |k/size| - avoiding extra rotation Enumerate again size-k nodes Break the loop and return new head code: 123456789101112131415161718192021222324252627282930ListNode *rotateRight(ListNode *head, int k) &#123; if(head == NULL || head-&gt;next == NULL||k==0) return head; ListNode* node = head; int size =1; while(node-&gt;next != NULL) &#123; size++; node = node-&gt;next; &#125; //loop the list node-&gt;next=head; //handle the case of k&gt;size k = k%size; //find the node to break the loop at while(--size &gt;= k) &#123; node=node-&gt;next; &#125; ListNode* first = node-&gt;next; node-&gt;next=NULL; return first; &#125; java 1ms, September 11, 2016 https://discuss.leetcode.com/topic/2861/share-my-java-solution-with-explanation Share my java solution with explanation Since n may be a large number compared to the length of list. So we need to know the length of linked list.After that, move the list after the (l-n%l )th node to the front to finish the rotation. Ex: {1,2,3} k=2 Move the list after the 1st node to the front Ex: {1,2,3} k=5, In this case Move the list after (3-5%3=1)st node to the front. So the code has three parts. Get the length Move to the (l-n%l)th node 3)Do the rotation 12345678910111213141516171819public ListNode rotateRight(ListNode head, int n) &#123; if (head==null||head.next==null) return head; ListNode dummy=new ListNode(0); dummy.next=head; ListNode fast=dummy,slow=dummy; int i; for (i=0;fast.next!=null;i++)//Get the total length fast=fast.next; for (int j=i-n%i;j&gt;0;j--) //Get the i-n%i th node slow=slow.next; fast.next=dummy.next; //Do the rotation dummy.next=slow.next; slow.next=null; return dummy.next;&#125; https://discuss.leetcode.com/topic/26364/clean-java-solution-with-brief-explanation Clean Java Solution with Brief Explanation The basic idea is to link the tail of the list with the head, make it a cycle. Then count to the rotate point and cut it. 123456789101112131415161718192021if (head == null) return head; ListNode copyHead = head; int len = 1; while (copyHead.next != null) &#123; copyHead = copyHead.next; len++; &#125; copyHead.next = head; for (int i = len - k % len; i &gt; 1; i--) head = head.next; copyHead = head.next; head.next = null; return copyHead;&#125; https://discuss.leetcode.com/topic/10991/my-short-java-solution-with-comments My short java solution with comments 1234567891011121314151617public ListNode rotateRight(ListNode head, int k) &#123; if(head==null||head.next==null||k==0) return head; //make it a cricle, break from k postion far from the head ListNode index=head; int len=1;// int len to record the length of list while(index.next!=null) &#123;index=index.next; len++;&#125; index.next=head; for(int i=0;i&lt;len-k%len;i++) &#123; index=index.next; &#125; ListNode result=index.next; index.next=null; return result;&#125; https://discuss.leetcode.com/topic/42445/java-clean-solution-only-one-pointer-used Java clean solution, only one pointer used I first used a ListNode p, and point it to the head, then move it to the end of the list, and at the same time get the length of the list. Then p.next = head; gives me a circle. At this time, by moving p for len-k times, it will be pointing to the node before the break point. Then all we need to do is record the next node as head, and break the circle with p.next = null. 12345678910111213141516171819public ListNode rotateRight(ListNode head, int k) &#123; if(head == null || k == 0) &#123; return head; &#125; ListNode p = head; int len = 1; while(p.next != null) &#123; p = p.next; len++; &#125; p.next = head; k %= len; for(int i = 0; i &lt; len - k; i++) &#123; p = p.next; &#125; head = p.next; p.next = null; return head;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[060. Permutation Sequence]]></title>
    <url>%2Fp%2F7d81a399%2F</url>
    <content type="text"><![CDATA[28.6% https://leetcode.com/problems/permutation-sequence/ The set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, 12345678We get the following sequence (ie, for n = 3):1. &quot;123&quot;2. &quot;132&quot;3. &quot;213&quot;4. &quot;231&quot;5. &quot;312&quot;6. &quot;321&quot; Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. 需要再思考 cpp https://discuss.leetcode.com/topic/3313/most-concise-c-solution-minimal-memory-required Most concise C++ solution, minimal memory required 1234567891011121314151617181920string getPermutation(int n, int k) &#123; int i,j,f=1; // left part of s is partially formed permutation, right part is the leftover chars. string s(n,&apos;0&apos;); for(i=1;i&lt;=n;i++)&#123; f*=i; s[i-1]+=i; // make s become 1234...n &#125; for(i=0,k--;i&lt;n;i++)&#123; f/=n-i; j=i+k/f; // calculate index of char to put at s[i] char c=s[j]; // remove c by shifting to cover up (adjust the right part). for(;j&gt;i;j--) s[j]=s[j-1]; k%=f; s[i]=c; &#125; return s;&#125; https://discuss.leetcode.com/topic/7002/sharing-my-straightforward-c-solution-with-explanation Sharing my straightforward C++ solution with explanation 12345678910111213141516171819202122232425string getPermutation(int n, int k) &#123; int pTable[10] = &#123;1&#125;; for(int i = 1; i &lt;= 9; i++)&#123; pTable[i] = i * pTable[i - 1]; &#125; string result; vector&lt;char&gt; numSet; numSet.push_back(&apos;1&apos;); numSet.push_back(&apos;2&apos;); numSet.push_back(&apos;3&apos;); numSet.push_back(&apos;4&apos;); numSet.push_back(&apos;5&apos;); numSet.push_back(&apos;6&apos;); numSet.push_back(&apos;7&apos;); numSet.push_back(&apos;8&apos;); numSet.push_back(&apos;9&apos;); while(n &gt; 0)&#123; int temp = (k - 1) / pTable[n - 1]; result += numSet[temp]; numSet.erase(numSet.begin() + temp); k = k - temp * pTable[n - 1]; n--; &#125; return result;&#125; In this program, pTable refers to permutation table and numSet refers to a set of numbers from 1 to 9. Before while loop, we need to initialize pTable and numSet, which is trivial. In while loop, we do these following things. 1 calculate which number we will use. 2 remove that number from numSet. 3 recalculate k. 4 n–. Finally, we return result. https://discuss.leetcode.com/topic/19181/0ms-c-12-line-concise-solution-no-recursion-no-helper-function 0ms C++ 12-line concise solution (no recursion, no helper function) Attached please find my solution. Idea: For an n-element permutation, there are (n-1)! permutations started with ‘1’, (n-1)! permutations started with ‘2’, and so forth. Therefore we can determine the value of the first element. After determining the first element, there are (n-1) candidates left. Then there are (n-2)! permutations started with the minimum element within the remaining set, and so forth. Complexities: Time complexity: O(n^2) Space complexity: O(n) 123456789101112131415161718192021222324252627class Solution &#123;public: string getPermutation(int n, int k) &#123; // initialize a dictionary that stores 1, 2, ..., n. This string will store the permutation. string dict(n, 0); iota(dict.begin(), dict.end(), &apos;1&apos;); // build up a look-up table, which stores (n-1)!, (n-2)!, ..., 1!, 0! vector&lt;int&gt; fract(n, 1); for (int idx = n - 3; idx &gt;= 0; --idx) &#123; fract[idx] = fract[idx + 1] * (n - 1 - idx); &#125; // let k be zero base --k; // the main part. string ret(n, 0); for (int idx = 0; idx &lt; n; ++idx) &#123; int select = k / fract[idx]; k %= fract[idx]; ret[idx] = dict[select]; dict.erase(next(dict.begin(), select)); // note that it is an O(n) operation &#125; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/37865/simple-0s-c-solution Simple 0s C++ solution since n will be between 1 and 9 inclusive. pre-calculate the factorials is faster. 12345678910111213141516class Solution &#123;public: string getPermutation(int n, int k) &#123; string res; string nums = &quot;123456789&quot;; int f[10] = &#123;1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880&#125;; --k; for (int i = n; i &gt;= 1; --i) &#123; int j = k / f[i - 1]; k %= f[i - 1]; res.push_back(nums[j]); nums.erase(nums.begin() + j); &#125; return res; &#125;&#125;; python 44ms, 90.94%, 17 July 2016 https://discuss.leetcode.com/topic/19269/share-my-python-solution-with-detailed-explanation Share my Python solution with detailed explanation The idea is as follow: For permutations of n, the first (n-1)! permutations start with 1, next (n-1)! ones start with 2, … and so on. And in each group of (n-1)! permutations, the first (n-2)! permutations start with the smallest remaining number, … take n = 3 as an example, the first 2 (that is, (3-1)! ) permutations start with 1, next 2 start with 2 and last 2 start with 3. For the first 2 permutations (123 and 132), the 1st one (1!) starts with 2, which is the smallest remaining number (2 and 3). So we can use a loop to check the region that the sequence number falls in and get the starting digit. Then we adjust the sequence number and continue. 123456789101112131415161718import mathclass Solution: # @param &#123;integer&#125; n # @param &#123;integer&#125; k # @return &#123;string&#125; def getPermutation(self, n, k): numbers = range(1, n+1) permutation = &apos;&apos; k -= 1 while n &gt; 0: n -= 1 # get the index of current digit index, k = divmod(k, math.factorial(n)) permutation += str(numbers[index]) # remove handled number numbers.remove(numbers[index]) return permutation https://discuss.leetcode.com/topic/1746/does-anyone-have-a-better-idea-share-my-accepted-python-code-here Does anyone have a better idea? Share my accepted python code here It’s obvious that if we try to come up with n! solutions one by one until it reach kth element - O(k), it will exceed the time limit. Therefore, I tried to implement a mathematical solution as follows: 1234567891011121314151617181920212223242526272829class Solution: # @return a string def getPermutation(self, n, k): ll = [str(i) for i in range(1,n+1)] # build a list of [&quot;1&quot;,&quot;2&quot;,...&quot;n&quot;] divisor = 1 for i in range(1,n): # calculate 1*2*3*...*(n-1) divisor *= i answer = &quot;&quot; while k&gt;0 and k&lt;=divisor*n: # there are only (divisor*n) solutions in total group_num = k/divisor k %= divisor if k&gt;0: # it&apos;s kth element of (group_num+1)th group choose = ll.pop(group_num) answer += choose else: # it&apos;s last element of (group_num)th group choose = ll.pop(group_num-1) answer += choose ll.reverse() # reverse the list to get DESC order for the last element to_add = &quot;&quot;.join(ll) answer += to_add break divisor/=len(ll) return answer Briefly take (n,k) = (4,21) for example, in the first iteration we divide the solution set into 4 groups: “1xxx”, “2xxx”, “3xxx”, and “4xxx”, while each group has 3! = 6 members. From 21/6 = 3…3, we know that the 21th element is the 3rd element in the (3+1)th group. In this group, we can divide it into 3 sub-groups again: “41xx”, “42xx” and “43xx”, and each group has 2!=2 members. Then, we calculate 3/2 and get 1…1, so it’s the 1st element of (1+1)nd sub-group - “421x”, and now it reach the base case with only one possibility - “4213”. Anyone pass the problem with different ideas? java https://discuss.leetcode.com/topic/17348/explain-like-i-m-five-java-solution-in-o-n “Explain-like-I’m-five” Java Solution in O(n) I’m sure somewhere can be simplified so it’d be nice if anyone can let me know. The pattern was that: say n = 4, you have {1, 2, 3, 4} If you were to list out all the permutations you have 1 + (permutations of 2, 3, 4) 2 + (permutations of 1, 3, 4) 3 + (permutations of 1, 2, 4) 4 + (permutations of 1, 2, 3) We know how to calculate the number of permutations of n numbers… n! So each of those with permutations of 3 numbers means there are 6 possible permutations. Meaning there would be a total of 24 permutations in this particular one. So if you were to look for the (k = 14) 14th permutation, it would be in the 3 + (permutations of 1, 2, 4) subset. To programmatically get that, you take k = 13 (subtract 1 because of things always starting at 0) and divide that by the 6 we got from the factorial, which would give you the index of the number you want. In the array {1, 2, 3, 4}, k/(n-1)! = 13/(4-1)! = 13/3! = 13/6 = 2. The array {1, 2, 3, 4} has a value of 3 at index 2. So the first number is a 3. Then the problem repeats with less numbers. The permutations of {1, 2, 4} would be: 1 + (permutations of 2, 4) 2 + (permutations of 1, 4) 4 + (permutations of 1, 2) But our k is no longer the 14th, because in the previous step, we’ve already eliminated the 12 4-number permutations starting with 1 and 2. So you subtract 12 from k.. which gives you 1. Programmatically that would be… k = k - (index from previous) (n-1)! = k - 2(n-1)! = 13 - 2*(3)! = 1 In this second step, permutations of 2 numbers has only 2 possibilities, meaning each of the three permutations listed above a has two possibilities, giving a total of 6. We’re looking for the first one, so that would be in the 1 + (permutations of 2, 4) subset. Meaning: index to get number from is k / (n - 2)! = 1 / (4-2)! = 1 / 2! = 0.. from {1, 2, 4}, index 0 is 1 so the numbers we have so far is 3, 1… and then repeating without explanations. {2, 4} k = k - (index from pervious) (n-2)! = k - 0 (n - 2)! = 1 - 0 = 1; third number’s index = k / (n - 3)! = 1 / (4-3)! = 1/ 1! = 1… from {2, 4}, index 1 has 4 Third number is 4 {2} k = k - (index from pervious) (n - 3)! = k - 1 (4 - 3)! = 1 - 1 = 0; third number’s index = k / (n - 4)! = 0 / (4-4)! = 0/ 1 = 0… from {2}, index 0 has 2 Fourth number is 2 Giving us 3142. If you manually list out the permutations using DFS method, it would be 3142. Done! It really was all about pattern finding. 12345678910111213141516171819202122232425262728293031323334public class Solution &#123;public String getPermutation(int n, int k) &#123; int pos = 0; List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); int[] factorial = new int[n+1]; StringBuilder sb = new StringBuilder(); // create an array of factorial lookup int sum = 1; factorial[0] = 1; for(int i=1; i&lt;=n; i++)&#123; sum *= i; factorial[i] = sum; &#125; // factorial[] = &#123;1, 1, 2, 6, 24, ... n!&#125; // create a list of numbers to get indices for(int i=1; i&lt;=n; i++)&#123; numbers.add(i); &#125; // numbers = &#123;1, 2, 3, 4&#125; k--; for(int i = 1; i &lt;= n; i++)&#123; int index = k/factorial[n-i]; sb.append(String.valueOf(numbers.get(index))); numbers.remove(index); k-=index*factorial[n-i]; &#125; return String.valueOf(sb);&#125;&#125; 4ms, 3.65%, 17 July 2016 https://discuss.leetcode.com/topic/5081/an-iterative-solution-for-reference An iterative solution for reference Recursion will use more memory, while this problem can be solved by iteration. I solved this problem before, but I didn’t realize that using k = k-1 would avoid dealing with case k%(n-1)!==0. Rewrote this code, should be pretty concise now. Only thing is that I have to use a list to store the remaining numbers, neither linkedlist nor arraylist are very efficient, anyone has a better idea? The logic is as follows: for n numbers the permutations can be divided to (n-1)! groups, for n-1 numbers can be divided to (n-2)! groups, and so on. Thus k/(n-1)! indicates the index of current number, and k%(n-1)! denotes remaining index for the remaining n-1 numbers.We keep doing this until n reaches 0, then we get n numbers permutations that is kth. 12345678910111213141516public String getPermutation(int n, int k) &#123; List&lt;Integer&gt; num = new LinkedList&lt;Integer&gt;(); for (int i = 1; i &lt;= n; i++) num.add(i); int[] fact = new int[n]; // factorial fact[0] = 1; for (int i = 1; i &lt; n; i++) fact[i] = i*fact[i-1]; k = k-1; StringBuilder sb = new StringBuilder(); for (int i = n; i &gt; 0; i--)&#123; int ind = k/fact[i-1]; k = k%fact[i-1]; sb.append(num.get(ind)); num.remove(ind); &#125; return sb.toString(); &#125; https://discuss.leetcode.com/topic/5081/an-iterative-solution-for-reference/2 Thanks for your post and explanation. I think linkedlist is as efficient as you can get in order to store the remaining numbers. Linkedlist may require counting index to get to the number, but it is more efficient than an array for removing elements. I haven’t seen a better solution yet. We can reduce the memory usage for factorial a little by using just one integer, since we are going down in factorial anyway. I think you meant “permutations can be divided into n groups with (n - 1)! elements in each group”. Thus, k / (n - 1)! is the index among current n groups, and k % (n - 1)! is the index for next iteration. 123456789101112131415public String getPermutation(int n, int k) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int i = 1; i &lt;= n; i++) list.add(i); int fact = 1; for (int i = 2; i &lt;= n; i++) fact *= i; // factorial StringBuilder strBuilder = new StringBuilder(); for (k--; n &gt; 0; n--) &#123; fact /= n; strBuilder.append(list.remove(k / fact)); k %= fact; &#125; return strBuilder.toString();&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[059. Spiral Matrix II]]></title>
    <url>%2Fp%2F3551638a%2F</url>
    <content type="text"><![CDATA[38.4% https://leetcode.com/problems/spiral-matrix-ii/ Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. 123456789For example,Given n = 3,You should return the following matrix:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 方法一: 借鉴54题的思想，类似的代码 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; if(n==0) return &#123;&#125;; if(n==1) return &#123;&#123;1&#125;&#125;; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n)); int i=1, up=0, down=n-1, left=0, right=n-1; while(true)&#123; for(int col=left; col&lt;=right; col++) res[up][col] = i++; if(++up&gt;down) break; for(int row=up; row&lt;=down; row++) res[row][right] = i++; if(--right&lt;left) break; for(int col=right; col&gt;=left; col--) res[down][col] = i++; if(--down&lt;up) break; for(int row=down; row&gt;=up; row--) res[row][left] = i++; if(++left&gt;right) break; &#125; return res; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; int cnt = 0; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); int left = 0, right = n-1, up = 0, down = n-1; while(true)&#123; for(int i=left; i&lt;=right; i++) res[up][i] = ++cnt; up++; if(up&gt;down) break; for(int j=up; j&lt;=down; j++) res[j][right] = ++cnt; right--; if(left&gt;right) break; for(int k=right; k&gt;=left; k--) res[down][k] = ++cnt; down--; if(up&gt;down) break; for(int l=down; l&gt;=up; l--) res[l][left] = ++cnt; left++; if(left&gt;right) break; &#125; return res; &#125;&#125;; cpp 4ms, 13.71%, June.19th, 2016 https://leetcode.com/discuss/21677/simple-c-solution-with-explaination 12345678910111213141516171819202122232425class Solution &#123; public: vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt; &gt; ret( n, vector&lt;int&gt;(n) ); int k = 1, i = 0; while( k &lt;= n * n ) &#123; int j = i; // four steps while( j &lt; n - i ) // 1. horizonal, left to right ret[i][j++] = k++; j = i + 1; while( j &lt; n - i ) // 2. vertical, top to bottom ret[j++][n-i-1] = k++; j = n - i - 2; while( j &gt; i ) // 3. horizonal, right to left ret[n-i-1][j--] = k++; j = n - i - 1; while( j &gt; i ) // 4. vertical, bottom to top ret[j--][i] = k++; i++; // next loop &#125; return ret; &#125; &#125;; 方法二： 修改判断条件在while条件里，不必每次都去判断是否跳出循环 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; int cnt = 0; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); int left = 0, right = n-1, up = 0, down = n-1; while(up&lt;=down &amp;&amp; left&lt;=right)&#123; for(int i=left; i&lt;=right; i++) res[up][i] = ++cnt; up++; for(int j=up; j&lt;=down; j++) res[j][right] = ++cnt; right--; for(int k=right; k&gt;=left; k--) res[down][k] = ++cnt; down--; for(int l=down; l&gt;=up; l--) res[l][left] = ++cnt; left++; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/2736/my-ac-solution-with-using-direction-variable My AC solution with using direction variable 12345678910111213141516171819202122232425vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) &#123; int dir = 0; vector&lt; vector&lt;int&gt; &gt; matrix(n, vector&lt;int&gt; (n, 0)); int i = 0, j = 0, k = 1; while (k &lt;= n * n) &#123; matrix[i][j] = k++; if (dir == 0)&#123; j++; if (j == n || matrix[i][j] != 0) dir = 1, j--, i++; &#125; else if (dir == 1) &#123; i++; if (i == n || matrix[i][j] != 0) dir = 2, i--, j--; &#125; else if (dir == 2) &#123; j--; if (j &lt; 0 || matrix[i][j] != 0) dir = 3, j++, i--; &#125; else if (dir == 3) &#123; i--; if (i &lt; 0 || matrix[i][j] != 0) dir = 0, i++, j++; &#125; &#125; return matrix; &#125; https://discuss.leetcode.com/topic/11317/simple-c-solution Simple C++ solution 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt; &gt; vv(n, vector&lt;int&gt;(n)); int rowStart = 0, rowEnd = n - 1; int colStart = 0, colEnd = n - 1; int cnt = 1; while(rowStart &lt;= rowEnd &amp;&amp; colStart &lt;= colEnd) &#123; for(int i = colStart; i&lt;= colEnd; i++) vv[rowStart][i] = cnt++; rowStart++; for(int i = rowStart; i&lt;= rowEnd; i++) vv[i][colEnd] = cnt++; colEnd--; for(int i = colEnd; i&gt;= colStart; i--) vv[rowEnd][i] = cnt++; rowEnd--; for(int i = rowEnd; i&gt;= rowStart; i--) vv[i][colStart] = cnt++; colStart++; &#125; return vv; &#125;&#125;; https://discuss.leetcode.com/topic/30057/c-concise-solution C++ concise solution. 1234567891011121314151617181920vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt; (n, 1)); int left, right, top, down, index; left = top = index = 0, right = down = n-1; while (left &lt;= right &amp;&amp; top &lt;= down) &#123; for (unsigned int j = left; j &lt;= right; j++) res[top][j] = ++index; top++; for (unsigned int i = top; i &lt;= down; i++) res[i][right] = ++index; right--; for (int j = right; j &gt;= left; j--) res[down][j] = ++index; down--; for (int i = down; i &gt;= top; i--) res[i][left] = ++index; left++; &#125; return res;&#125; python 56ms, 49.97%, June.19th, 2016 https://leetcode.com/discuss/46720/4-9-lines-python-solutions 4-9 lines Python solutions Solution 1: Build it inside-out - 44 ms, 5 lines Start with the empty matrix, add the numbers in reverse order until we added the number 1. Always rotate the matrix clockwise and add a top row: 123|| =&gt; |9| =&gt; |8| |6 7| |4 5| |1 2 3| |9| =&gt; |9 8| =&gt; |9 6| =&gt; |8 9 4| |8 7| |7 6 5| The code: 123456def generateMatrix(self, n): A, lo = [], n*n+1 while lo &gt; 1: lo, hi = lo - len(A), lo A = [range(lo, hi)] + zip(*A[::-1]) return A While this isn’t O(n^2), it’s actually quite fast, presumably due to me not doing much in Python but relying on zip and range and + being fast. I got it accepted in 44 ms, matching the fastest time for recent Python submissions (according to the submission detail page). Solution 2: Ugly inside-out - 48 ms, 4 lines Same as solution 1, but without helper variables. Saves a line, but makes it ugly. Also, because I access A[0][0], I had to handle the n=0 case differently. 12345def generateMatrix(self, n): A = [[n*n]] while A[0][0] &gt; 1: A = [range(A[0][0] - len(A), A[0][0])] + zip(*A[::-1]) return A * (n&gt;0) Solution 3: Walk the spiral - 52 ms, 9 lines Initialize the matrix with zeros, then walk the spiral path and write the numbers 1 to n*n. Make a right turn when the cell ahead is already non-zero. 12345678910def generateMatrix(self, n): A = [[0] * n for _ in range(n)] i, j, di, dj = 0, 0, 0, 1 for k in xrange(n*n): A[i][j] = k + 1 if A[(i+di)%n][(j+dj)%n]: di, dj = dj, -di i += di j += dj return A https://discuss.leetcode.com/topic/7739/if-we-can-t-write-data-to-the-matrix-we-change-the-direction-a-simple-python-solution If we can’t write data to the matrix, we change the direction,a simple python solution 1234567891011121314151617class Solution:# @return a list of lists of integerdef generateMatrix(self, n): matrix = [[0]*n for _ in range(n)] directions = ((0, 1), (1, 0), (0, -1), (-1, 0)) d = 0 y, x = 0, 0 for i in range(1, n*n+1): matrix[y][x] = i dy, dx = directions[d % 4] if -1 &lt; y+dy &lt; n and -1 &lt; x+dx &lt; n and matrix[y+dy][x+dx] == 0: y, x = y+dy, x+dx else: d += 1 dy, dx = directions[d % 4] y, x = y+dy, x+dx return matrix Change the direction If the we can’t write to the matrix java https://discuss.leetcode.com/topic/4362/my-super-simple-solution-can-be-used-for-both-spiral-matrix-i-and-ii My Super Simple Solution. Can be used for both Spiral Matrix I and II This is my solution for Spiral Matrix I, https://oj.leetcode.com/discuss/12228/super-simple-and-easy-to-understand-solution. If you can understand that, this one is a no brainer :) Guess what? I just made several lines of change (with comment “//change”) from that and I have the following AC code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public int[][] generateMatrix(int n) &#123; // Declaration int[][] matrix = new int[n][n]; // Edge Case if (n == 0) &#123; return matrix; &#125; // Normal Case int rowStart = 0; int rowEnd = n-1; int colStart = 0; int colEnd = n-1; int num = 1; //change while (rowStart &lt;= rowEnd &amp;&amp; colStart &lt;= colEnd) &#123; for (int i = colStart; i &lt;= colEnd; i ++) &#123; matrix[rowStart][i] = num ++; //change &#125; rowStart ++; for (int i = rowStart; i &lt;= rowEnd; i ++) &#123; matrix[i][colEnd] = num ++; //change &#125; colEnd --; for (int i = colEnd; i &gt;= colStart; i --) &#123; if (rowStart &lt;= rowEnd) matrix[rowEnd][i] = num ++; //change &#125; rowEnd --; for (int i = rowEnd; i &gt;= rowStart; i --) &#123; if (colStart &lt;= colEnd) matrix[i][colStart] = num ++; //change &#125; colStart ++; &#125; return matrix; &#125;&#125; Obviously, you could merge colStart and colEnd into rowStart and rowEnd because it is a square matrix. But this is easily extensible to matrices that are m*n. Hope this helps :) 0ms, 17.235, June.19th, 2016 https://leetcode.com/discuss/38659/share-my-java-solution Share my java solution 123456789101112131415161718192021222324252627public class Solution &#123; public static int[][] generateMatrix(int n) &#123; int[][] ret = new int[n][n]; int left = 0,top = 0; int right = n -1,down = n - 1; int count = 1; while (left &lt;= right) &#123; for (int j = left; j &lt;= right; j ++) &#123; ret[top][j] = count++; &#125; top ++; for (int i = top; i &lt;= down; i ++) &#123; ret[i][right] = count ++; &#125; right --; for (int j = right; j &gt;= left; j --) &#123; ret[down][j] = count ++; &#125; down --; for (int i = down; i &gt;= top; i --) &#123; ret[i][left] = count ++; &#125; left ++; &#125; return ret; &#125;&#125; https://discuss.leetcode.com/topic/9299/share-my-simple-solution-with-graphical-explanation-java Share my simple solution with graphical explanation - Java If n is odd, only the first direction will cover it (top left -&gt; right, shown as # in the graph), because the other three direction all start from the next position( +1 or -1). 1234567891011121314151617181920212223242526272829303132333435363738/** * -&gt; -&gt; -&gt; * ^ | * | | * &lt;- &lt;-- V * * # # # # * % $ * % $ * &amp; &amp; &amp; $ * */ public static int[][] generateMatrix(int n) &#123; int[][] res = new int[n][n]; int num = 1; int level = (int) Math.ceil(n / 2.); for(int i = 0; i &lt; level; i++) &#123; // top left -&gt; right, shown as # for(int j = i; j &lt; n - i; j++) res[i][j] = num++; // top right + 1 -&gt; bot, shown as $ for(int j = i + 1; j &lt; n - i; j++) res[j][n - i - 1] = num++; // bot right - 1 -&gt; left, shown as &amp; for(int j = n - i - 2; j &gt;= i; j--) res[n - i - 1][j] = num++; // bot left -1 -&gt; top + 1, shown as % for(int j = n - i - 2; j &gt; i; j--) res[j][i] = num++; &#125; return res; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[058. Length of Last Word]]></title>
    <url>%2Fp%2Fe32fb410%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/length-of-last-word/ Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. 123For example, Given s = &quot;Hello World&quot;,return 5. 方法一： code 1： 核心思想，从后向前遍历，从后遍历，这个想法很好。 很多时候从前向后可能有一定的麻烦，但是从后向前的遍历， 会收到很好的效果。 或许这就是所谓的逆向思维吧。 https://discuss.leetcode.com/topic/17312/7-lines-4ms-c-solution 7-lines 4ms C++ Solution Well, the basic idea is very simple. Start from the tail of s and move backwards to find the first non-space character. Then from this character, move backwards and count the number of non-space characters until we pass over the head of s or meet a space character. The count will then be the length of the last word. 123456789101112class Solution &#123;public: int lengthOfLastWord(string s) &#123; int len = 0, tail = s.length() - 1; while (tail &gt;= 0 &amp;&amp; s[tail] == &apos; &apos;) tail--; while (tail &gt;= 0 &amp;&amp; s[tail] != &apos; &apos;) &#123; len++; tail--; &#125; return len; &#125;&#125;; code 2: 12345678910111213141516class Solution &#123;public: int lengthOfLastWord(string s) &#123; if(s.empty()) return 0; int n = s.size(); int len = 0; int tail = n-1; while(tail&gt;=0 &amp;&amp; s[tail]==&apos; &apos;) tail--; while(tail&gt;=0 &amp;&amp; s[tail]!=&apos; &apos;)&#123; len++; tail--; &#125; return len; &#125;&#125;; python Solution mine: 40ms, 88.34%, June.23th, 2016 1234567class Solution(object): def lengthOfLastWord(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; return len(s.strip().split(&apos; &apos;)[-1]) https://discuss.leetcode.com/topic/7733/one-line-python-solution One line Python solution12def lengthOfLastWord(self, s): return len(s.rstrip(&apos; &apos;).split(&apos; &apos;)[-1]) java 1ms, 41.25%, June.23th, 2016 https://leetcode.com/discuss/18670/a-single-line-of-code-in-java A single line of Code in Java12345public class Solution &#123; public int lengthOfLastWord(String s) &#123; return s.trim().length()-s.trim().lastIndexOf(&quot; &quot;)-1; &#125;&#125; https://discuss.leetcode.com/topic/27201/my-3-line-0-ms-java-solution My 3 line 0 ms java solution12345public int lengthOfLastWord(String s) &#123; s = s.trim(); int lastIndex = s.lastIndexOf(&apos; &apos;) + 1; return s.length() - lastIndex; &#125; https://discuss.leetcode.com/topic/17762/228ms-java-solution 228ms Java Solution 1 - Use 2 loops. One to locate the last non-space character, one to count. 123456789101112131415161718public int lengthOfLastWord(String s) &#123; //228ms int lenIndex = s.length()-1; int len = 0; /*can also use while here, resulting in 264ms while (lenIndex&gt;=0 &amp;&amp; s.charAt(lenIndex)==&apos; &apos;) lenIndex--;*/ /*or use trim - 324ms s = s.trim();*/ for (int i=lenIndex; i&gt;=0 &amp;&amp; s.charAt(i)==&apos; &apos;; i--) lenIndex--; for (int i=lenIndex; i&gt;=0 &amp;&amp; s.charAt(i)!=&apos; &apos;; i--) len++; return len;&#125; 2 - Use split 1234//292ms String[] words = s.split(&quot; &quot;); if (words.length==0) return 0; else return words[words.length-1].length(); 3 - use lastIndexOf 12//308ms return s.trim().length() - s.trim().lastIndexOf(&quot; &quot;) - 1;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[057. Insert Interval]]></title>
    <url>%2Fp%2F65f5c34%2F</url>
    <content type="text"><![CDATA[26.7% https://leetcode.com/problems/insert-interval/ Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. 1234567Example 1:Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].Example 2:Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10]. 方法一： 头条代码 Easy and clean O(n) C++ solution Very easy to understand code as follows. First, put all intervals that are to the left of the inserted interval. Second, merge all intervals that intersect with the inserted interval. Finally, put all intervals that are to the right of the inserted interval. That’s it! You are done! 重点答案，简单直白高效 一个启示，未必只用一个while/for循环，可以前一段一个while，中间一个while，后面一个while，这样分开讨论的情况，很简洁，思路畅通。 针对相遇的情况，更改了newInterval的值，始终保持start最小，end最大，最后加入到结果中。 1234567891011121314151617181920class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int index = 0; while(index &lt; intervals.size() &amp;&amp; intervals[index].end &lt; newInterval.start)&#123; res.push_back(intervals[index++]); &#125; while(index &lt; intervals.size() &amp;&amp; intervals[index].start &lt;= newInterval.end)&#123; newInterval.start = min(newInterval.start, intervals[index].start); newInterval.end = max(newInterval.end, intervals[index].end); index++; &#125; res.push_back(newInterval); while(index &lt; intervals.size())&#123; res.push_back(intervals[index++]); &#125; return res; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; int n = intervals.size(); vector&lt;Interval&gt; res; int i = 0; while(i&lt;n &amp;&amp; intervals[i].end&lt;newInterval.start) res.push_back(intervals[i++]); while(i&lt;n &amp;&amp; intervals[i].start&lt;=newInterval.end)&#123; newInterval.start = min(newInterval.start, intervals[i].start); newInterval.end = max(newInterval.end, intervals[i].end); i++; &#125; res.push_back(newInterval); while(i&lt;n) res.push_back(intervals[i++]); return res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/12899/very-short-and-easy-to-understand-c-solution Very short and easy to understand C++ solution 12345678910111213141516171819vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; ret; auto it = intervals.begin(); for(; it!=intervals.end(); ++it)&#123; if(newInterval.end &lt; (*it).start) //all intervals after will not overlap with the newInterval break; else if(newInterval.start &gt; (*it).end) //*it will not overlap with the newInterval ret.push_back(*it); else&#123; //update newInterval bacause *it overlap with the newInterval newInterval.start = min(newInterval.start, (*it).start); newInterval.end = max(newInterval.end, (*it).end); &#125; &#125; // don&apos;t forget the rest of the intervals and the newInterval ret.push_back(newInterval); for(; it!=intervals.end(); ++it) ret.push_back(*it); return ret;&#125; My question is why this code need 500ms !? https://discuss.leetcode.com/topic/28015/elegant-c-stl-solution-using-equal_range-to-find-overlapped-intervals Elegant C++ STL solution, using “equal_range” to find overlapped intervals. 123456789101112131415161718class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; auto compare = [] (const Interval &amp;intv1, const Interval &amp;intv2) &#123; return intv1.end &lt; intv2.start; &#125;; auto range = equal_range(intervals.begin(), intervals.end(), newInterval, compare); auto itr1 = range.first, itr2 = range.second; if (itr1 == itr2) &#123; intervals.insert(itr1, newInterval); &#125; else &#123; itr2--; itr2-&gt;start = min(newInterval.start, itr1-&gt;start); itr2-&gt;end = max(newInterval.end, itr2-&gt;end); intervals.erase(itr1, itr2); &#125; return intervals; &#125;&#125;; https://discuss.leetcode.com/topic/24439/easy-and-clean-o-n-c-solution Easy and clean O(n) C++ solution Very easy to understand code as follows. First, put all intervals that are to the left of the inserted interval. Second, merge all intervals that intersect with the inserted interval. Finally, put all intervals that are to the right of the inserted interval. That’s it! You are done! 重点答案，简单直白高效 一个启示，未必只用一个while/for循环，可以前一段一个while，中间一个while，后面一个while，这样分开讨论的情况，很简洁，思路畅通。 针对相遇的情况，更改了newInterval的值，始终保持start最小，end最大，最后加入到结果中。 1234567891011121314151617181920class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int index = 0; while(index &lt; intervals.size() &amp;&amp; intervals[index].end &lt; newInterval.start)&#123; res.push_back(intervals[index++]); &#125; while(index &lt; intervals.size() &amp;&amp; intervals[index].start &lt;= newInterval.end)&#123; newInterval.start = min(newInterval.start, intervals[index].start); newInterval.end = max(newInterval.end, intervals[index].end); index++; &#125; res.push_back(newInterval); while(index &lt; intervals.size())&#123; res.push_back(intervals[index++]); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/17937/two-easy-o-n-c-solutions-with-explanations Two Easy O(n) C++ Solutions with Explanations By far the best solution I have seen is of O(n) time (some solutions claim to be of O(logn) turns out to be O(n)). One of the simplest ideas is to compare each interval in intervals (intervals[i]) with newInterval and then perform respective operations according to their relationships. If they overlap, merge them to newInterval; If intervals[i] is to the left of newInterval, push intervals[i] to the result vector; If newInterval is to the left of intervals[i], push newInterval and all the remaining intervals (intervals[i], …, intervals[n - 1]) to the result vector. The code is as follows. 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; vector&lt;Interval&gt; res; int n = intervals.size(); for (int i = 0; i &lt; n; i++) &#123; if (intervals[i].end &lt; newInterval.start) res.push_back(intervals[i]); else if (newInterval.end &lt; intervals[i].start) &#123; res.push_back(newInterval); for (int j = i; j &lt; n; j++) res.push_back(intervals[j]); return res; &#125; else newInterval = merge(intervals[i], newInterval); &#125; res.push_back(newInterval); return res; &#125;private: Interval merge(Interval&amp; interval1, Interval&amp; interval2) &#123; int start = min(interval1.start, interval2.start); int end = max(interval1.end, interval2.end); return Interval(start, end); &#125;&#125;; Another idea is to search for the two ends of the overlapping intervals using binary search. Then we only need to merge newInterval with the intervals at the two ends if they overlap. All the intervals within the two ends will be contained innewInterval. Let’s do the example in the problem statement: intervals = [1, 2], [3, 5], [6, 7], [8, 10], [12, 16] and newInterval = [4, 9]. We first find the rightmost interval with start smaller than that of newInterval, which is [3, 5]. Then we find the leftmost interval with end larger than that of newInterval, which is [8, 10]. Then all the intervals between them will be contained within newInterval (you may check this to convince yourself) and so can be safely ignored. We only need to check whether newInterval overlaps with the two intervals on the two ends and merge them if necessary. The complete code is as follows. 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; intervals, Interval newInterval) &#123; int n = intervals.size(), leftEnd, rightEnd, l, r; vector&lt;Interval&gt; res; // Find the rightmost interval with start smaller than that of newInterval for (l = 0, r = n - 1; l &lt;= r; ) &#123; int mid = l + ((r - l) &gt;&gt; 1); if (intervals[mid].start &gt; newInterval.start) r = mid - 1; else l = mid + 1; &#125; leftEnd = r; // Find the leftmost interval with end larger than that of newInterval for (l = 0, r = n - 1; l &lt;= r; ) &#123; int mid = l + ((r - l) &gt;&gt; 1); if (intervals[mid].end &lt; newInterval.end) l = mid + 1; else r = mid - 1; &#125; rightEnd = l; // Merge newInterval with intervals[leftEnd] and intervals[rightEnd] if necessary if (leftEnd &gt;= 0 &amp;&amp; intervals[leftEnd].end &gt;= newInterval.start) newInterval.start = intervals[leftEnd--].start; if (rightEnd &lt; n &amp;&amp; intervals[rightEnd].start &lt;= newInterval.end) newInterval.end = intervals[rightEnd++].end; // Save the intervals sequentially for (int i = 0; i &lt;= leftEnd; i++) res.push_back(intervals[i]); res.push_back(newInterval); for (int i = rightEnd; i &lt; n; i++) res.push_back(intervals[i]); return res; &#125;&#125;; python https://discuss.leetcode.com/topic/16988/7-lines-3-easy-solutions 7+ lines, 3 easy solutions Solution 1: (7 lines, 88 ms) Collect the intervals strictly left or right of the new interval, then merge the new one with the middle ones (if any) before inserting it between left and right ones. 12345678def insert(self, intervals, newInterval): s, e = newInterval.start, newInterval.end left = [i for i in intervals if i.end &lt; s] right = [i for i in intervals if i.start &gt; e] if left + right != intervals: s = min(s, intervals[len(left)].start) e = max(e, intervals[~len(right)].end) return left + [Interval(s, e)] + right Solution 2: (8 lines, 84 ms) Same algorithm as solution 1, but different implementation with only one pass and explicitly collecting the to-be-merged intervals. 123456789def insert(self, intervals, newInterval): s, e = newInterval.start, newInterval.end parts = merge, left, right = [], [], [] for i in intervals: parts[(i.end &lt; s) - (i.start &gt; e)].append(i) if merge: s = min(s, merge[0].start) e = max(e, merge[-1].end) return left + [Interval(s, e)] + right Solution 3: (11 lines, 80 ms) Same again, but collect and merge while going over the intervals once. 123456789101112def insert(self, intervals, newInterval): s, e = newInterval.start, newInterval.end left, right = [], [] for i in intervals: if i.end &lt; s: left += i, elif i.start &gt; e: right += i, else: s = min(s, i.start) e = max(e, i.end) return left + [Interval(s, e)] + right https://discuss.leetcode.com/topic/6976/o-n-python-solution O(n) Python solution 123456789101112131415161718192021class Solution: # @param intervals, a list of Intervals # @param newInterval, a Interval # @return a list of Interval def insert(self, intervals, newInterval): start = newInterval.start end = newInterval.end result = [] i = 0 while i &lt; len(intervals): if start &lt;= intervals[i].end: if end &lt; intervals[i].start: break start = min(start, intervals[i].start) end = max(end, intervals[i].end) else: result.append(intervals[i]) i += 1 result.append(Interval(start, end)) result += intervals[i:] return result 112ms, 19.91%, June.23th, 2016 123456789101112131415161718192021# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def insert(self, intervals, newInterval): &quot;&quot;&quot; :type intervals: List[Interval] :type newInterval: Interval :rtype: List[Interval] &quot;&quot;&quot; intervals.append(newInterval) rtype = [] for i in sorted(intervals, key = lambda x:x.start): if rtype and i.start &lt;= rtype[-1].end: rtype[-1].end = max(rtype[-1].end, i.end) else: rtype += i, return rtype java https://discuss.leetcode.com/topic/7808/short-and-straight-forward-java-solution Short and straight-forward Java solution Hi guys! Here’s a pretty straight-forward and concise solution below. 这个直白的解法，很喜欢，先针对intervals比较小的，未接触处理，然后进行中间相遇的处理，然后处理相遇后的。很直白，很简单。 123456789101112131415161718public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new LinkedList&lt;&gt;(); int i = 0; // add all the intervals ending before newInterval starts while (i &lt; intervals.size() &amp;&amp; intervals.get(i).end &lt; newInterval.start) result.add(intervals.get(i++)); // merge all overlapping intervals to one considering newInterval while (i &lt; intervals.size() &amp;&amp; intervals.get(i).start &lt;= newInterval.end) &#123; newInterval = new Interval( // we could mutate newInterval here also Math.min(newInterval.start, intervals.get(i).start), Math.max(newInterval.end, intervals.get(i).end)); i++; &#125; result.add(newInterval); // add the union of intervals we got // add all the rest while (i &lt; intervals.size()) result.add(intervals.get(i++)); return result;&#125; Hope it helps. https://discuss.leetcode.com/topic/12691/short-java-code Short java code 123456789101112131415161718public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new ArrayList&lt;Interval&gt;(); for (Interval i : intervals) &#123; if (newInterval == null || i.end &lt; newInterval.start) result.add(i); else if (i.start &gt; newInterval.end) &#123; result.add(newInterval); result.add(i); newInterval = null; &#125; else &#123; newInterval.start = Math.min(newInterval.start, i.start); newInterval.end = Math.max(newInterval.end, i.end); &#125; &#125; if (newInterval != null) result.add(newInterval); return result;&#125; https://discuss.leetcode.com/topic/41004/my-binary-search-approach-implementation-2ms My Binary Search Approach Implementation, 2ms I know this is a little messy. For clean and simple code, please use the O(n) approach. We have great answer here with just 3 while loops. The BS approach utilizes the ordered characteristic of the input. For me, I want to get the position of the interval that is the first to have start equal to or larger than the inserted interval’s start. Similarly, I get the position of the interval that is the first to have end equal to or larger than the new interval’s end. Then I can get the range of intervals that the new interval connects. There are some corner cases that need to be considered, i.e. when the new interval has no overlap with any of the existing intervals (smaller, larger, or the original list is empty). In these corner cases, we just don’t need to update the new interval. The code could possibly be cleaner and simpler without sacrificing the speed, or even with less time and space. Please let me know if you have any suggestions. Thank you! 123456789101112131415161718192021222324252627282930313233343536373839404142public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); if (intervals == null || newInterval == null) return result; int iStart = findStartPos(intervals, newInterval.start); int iEnd = findEndPos(intervals, newInterval.end); if (iStart &gt; 0 &amp;&amp; intervals.get(iStart - 1).end &gt;= newInterval.start) iStart--; if (iEnd == intervals.size() || intervals.get(iEnd).start &gt; newInterval.end) iEnd--; //If not in the corner cases, this condition should apply. if (iStart &lt;= iEnd) &#123; newInterval = new Interval(Math.min(newInterval.start, intervals.get(iStart).start),Math.max(newInterval.end, intervals.get(iEnd).end)); &#125; int i = 0; while (i &lt; iStart) result.add(intervals.get(i++)); result.add(newInterval); i = iEnd + 1; while (i &lt; intervals.size()) result.add(intervals.get(i++)); return result;&#125;private int findStartPos(List&lt;Interval&gt; intervals, int value) &#123; int l = 0, r = intervals.size() - 1; while (l &lt;= r) &#123; int m = (l + r) &gt;&gt; 1; if (intervals.get(m).start == value) return m; else if (intervals.get(m).start &lt; value) l = m + 1; else r = m - 1; &#125; return l;&#125;private int findEndPos(List&lt;Interval&gt; intervals, int value) &#123; int l = 0, r = intervals.size() - 1; while (l &lt;= r) &#123; int m = (l + r) &gt;&gt; 1; if (intervals.get(m).end == value) return m; else if (intervals.get(m).end &lt; value) l = m + 1; else r = m - 1; &#125; return l;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hard</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[056. Merge Intervals]]></title>
    <url>%2Fp%2F5eec50bd%2F</url>
    <content type="text"><![CDATA[28.9% https://leetcode.com/problems/merge-intervals/ Given a collection of intervals, merge all overlapping intervals. 123For example,Given [1,3],[2,6],[8,10],[15,18],return [1,6],[8,10],[15,18]. 方法一： 先排序，再一个个的处理。 重点学习： sort函数的用法 vector的back函数 max函数的用法 123456789101112131415class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; ins) &#123; if (ins.empty()) return vector&lt;Interval&gt;&#123;&#125;; vector&lt;Interval&gt; res; sort(ins.begin(), ins.end(), [](Interval a, Interval b)&#123;return a.start &lt; b.start;&#125;); res.push_back(ins[0]); for (int i = 1; i &lt; ins.size(); i++) &#123; if (res.back().end &lt; ins[i].start) res.push_back(ins[i]); else res.back().end = max(res.back().end, ins[i].end); &#125; return res; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324252627/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; int n = intervals.size(); if(n&lt;=1) return intervals; vector&lt;Interval&gt; res; sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;return a.start&lt;b.start;&#125;); res.push_back(intervals[0]); for(int i=1; i&lt;n; i++)&#123; if(intervals[i].start &gt; res.back().end)&#123; res.push_back(intervals[i]); &#125;else&#123; res.back().end = max(res.back().end, intervals[i].end); &#125; &#125; return res; &#125;&#125;; 我的代码实现: Dec 10th, 2017 1234567891011121314151617181920class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; vector&lt;Interval&gt; res; if(intervals.size()&lt;=1) return intervals; sort(intervals.begin(), intervals.end(), [](Interval a, Interval b)&#123;if(a.start&lt;b.start || (a.start==b.start) &amp;&amp; a.end&lt;b.end) return true; return false;&#125;); int s=intervals[0].start, e = intervals[0].end; for(int i=1; i&lt;intervals.size(); i++)&#123; if(e&lt;intervals[i].start)&#123; res.push_back(Interval(s, e)); s = intervals[i].start; e = intervals[i].end; &#125;else&#123; e = max(e, intervals[i].end); &#125; &#125; res.push_back(Interval(s, e)); return res; &#125;&#125;; cpp 20ms, 28.53%, June.22th, 2016 https://leetcode.com/discuss/49276/c-10-line-solution-easing-understanding C++ 10 line solution. easing understanding 先排序，然后开始开始遍历。 重点在于排序怎么写。 关于sort函数的用法，可以参考以下链接 http://www.cplusplus.com/reference/algorithm/sort/ http://www.cplusplus.com/articles/NhA0RXSz/ 123456789101112131415161718192021222324/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; ins) &#123; if (ins.empty()) return vector&lt;Interval&gt;&#123;&#125;; vector&lt;Interval&gt; res; sort(ins.begin(), ins.end(), [](Interval a, Interval b)&#123;return a.start &lt; b.start;&#125;); res.push_back(ins[0]); for (int i = 1; i &lt; ins.size(); i++) &#123; if (res.back().end &lt; ins[i].start) res.push_back(ins[i]); else res.back().end = max(res.back().end, ins[i].end); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/5765/my-easy-c-solution My easy C++ solution 12345678910111213141516171819202122static bool comp(const Interval&amp; a, const Interval&amp; b)&#123; return a.start &lt; b.start;&#125;vector&lt;Interval&gt; merge(vector&lt;Interval&gt; &amp;intervals) &#123; vector&lt;Interval&gt; result; if(intervals.empty())&#123; return result; &#125; sort(intervals.begin(), intervals.end(), comp); result.push_back(intervals[0]); for(int i = 1; i &lt; intervals.size(); i++)&#123; if(intervals[i].start &lt;= result.back().end)&#123; Interval temp(result.back().start, max(result.back().end, intervals[i].end)); result.pop_back(); result.push_back(temp); &#125; else&#123; result.push_back(intervals[i]); &#125; &#125; return result;&#125; https://discuss.leetcode.com/topic/20628/my-c-o-nlogn-solution-580ms My C++ O(NlogN) solution 580ms Just copy the input to res and do sorting (in ascending order of start). Then try to merge the sorted interval: cur is the last processed interval and i is the current to-be-processed interval. if cur is ahead of i and no overlapping, just copy i to cur+1, and update cur to cur+1, otherwise, merge interval cur and i and move to i+1. At last, we need to resize res to remove the redundent intervals. 12345678910111213141516class Solution &#123;public: vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; int len = intervals.size(),i,cur; vector&lt;Interval&gt; res(intervals); if(len&gt;1) &#123; std::sort(res.begin(), res.end(), [](Interval i, Interval j)&#123;return i.start&lt;j.start;&#125;); for(cur=0, i=1;i&lt;len; ++i) if(res[cur].end&lt;res[i].start) res[++cur] = res[i]; // no overlapping, copy to cur+1, else res[cur].end = max(res[cur].end, res[i].end); // cur and i overlap with each other, merge res.resize(cur+1); // resize to remove redundant intervals &#125; return res; &#125;&#125;; python 88ms, 81.79%, June.22th, 2016 https://leetcode.com/discuss/42344/7-lines-easy-python 7 lines, easy, Python Just go through the intervals sorted by start coordinate and either combine the current interval with the previous one if they overlap, or add it to the output by itself if they don’t. 12345678910111213141516171819# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def merge(self, intervals): &quot;&quot;&quot; :type intervals: List[Interval] :rtype: List[Interval] &quot;&quot;&quot; out = [] for i in sorted(intervals, key = lambda i: i.start): if out and i.start &lt;= out[-1].end: out[-1].end = max(out[-1].end, i.end) else: out += i, return out https://discuss.leetcode.com/topic/27383/short-python-solution Short python solution Sort the list first. Check if the new interval overlaps with the previous one in the output list. If yes, update it. Otherwise, append the new one. 12345678910111213class Solution(object): def merge(self, intervals): &quot;&quot;&quot; :type intervals: List[Interval] :rtype: List[Interval] &quot;&quot;&quot; if len(intervals) == 0: return [] intervals = sorted(intervals, key = lambda x: x.start) res = [intervals[0]] for n in intervals[1:]: if n.start &lt;= res[-1].end: res[-1].end = max(n.end, res[-1].end) else: res.append(n) return res java https://discuss.leetcode.com/topic/4319/a-simple-java-solution A simple Java solution The idea is to sort the intervals by their starting points. Then, we take the first interval and compare its end with the next intervals starts. As long as they overlap, we update the end to be the max end of the overlapping intervals. Once we find a non overlapping interval, we can add the previous “extended” interval and start over. Sorting takes O(n log(n)) and merging the intervals takes O(n). So, the resulting algorithm takes O(n log(n)). I used an anonymous comparator and a for-each loop to try to keep the code clean and simple. 123456789101112131415161718192021222324252627282930public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; if (intervals.size() &lt;= 1) return intervals; // Sort by ascending starting point using an anonymous Comparator Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval i1, Interval i2) &#123; return Integer.compare(i1.start, i2.start); &#125; &#125;); List&lt;Interval&gt; result = new LinkedList&lt;Interval&gt;(); int start = intervals.get(0).start; int end = intervals.get(0).end; for (Interval interval : intervals) &#123; if (interval.start &lt;= end) // Overlapping intervals, move the end if needed end = Math.max(end, interval.end); else &#123; // Disjoint intervals, add the previous one and reset bounds result.add(new Interval(start, end)); start = interval.start; end = interval.end; &#125; &#125; // Add the last interval result.add(new Interval(start, end)); return result;&#125; https://discuss.leetcode.com/topic/12788/a-clean-java-solution A clean java solution 1234567891011121314151617181920212223public class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; Collections.sort(intervals, new Comparator&lt;Interval&gt;()&#123; @Override public int compare(Interval obj0, Interval obj1) &#123; return obj0.start - obj1.start; &#125; &#125;); List&lt;Interval&gt; ret = new ArrayList&lt;&gt;(); Interval prev = null; for (Interval inter : intervals) &#123; if ( prev==null || inter.start&gt;prev.end ) &#123; ret.add(inter); prev = inter; &#125; else if (inter.end&gt;prev.end) &#123; // Modify the element already in list prev.end = inter.end; &#125; &#125; return ret; &#125;&#125; https://discuss.leetcode.com/topic/38628/beat-98-java-sort-start-end-respectively Beat 98% Java. Sort start &amp; end respectively. The idea is that for the result distinct Interval, the latter one’s start must &gt; previous one’s end. 123456789101112131415161718192021public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; // sort start&amp;end int n = intervals.size(); int[] starts = new int[n]; int[] ends = new int[n]; for (int i = 0; i &lt; n; i++) &#123; starts[i] = intervals.get(i).start; ends[i] = intervals.get(i).end; &#125; Arrays.sort(starts); Arrays.sort(ends); // loop through List&lt;Interval&gt; res = new ArrayList&lt;Interval&gt;(); for (int i = 0, j = 0; i &lt; n; i++) &#123; // j is start of interval. if (i == n - 1 || starts[i + 1] &gt; ends[i]) &#123; res.add(new Interval(starts[j], ends[i])); j = i + 1; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/8571/fast-ana-simple-java-code Fast ana simple java code The idea is to sort intervals based on start and iterate all itervals to merge them if: 1curr.end &gt;= iter.start The time complexity is : sort nO(logn)+ merge: O(n) = nO(logn) No Extra space except necessary result : ) 1234567891011121314151617181920212223public class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; List&lt;Interval&gt; res = new LinkedList&lt;Interval&gt;(); if(intervals.size()&lt;2) return intervals; Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval o1, Interval o2) &#123; return o1.start-o2.start; &#125; &#125;); Interval curr = intervals.get(0); for(Interval iter: intervals) &#123; if(curr.end &gt;= iter.start) &#123; curr.end = Math.max(curr.end,iter.end); &#125;else &#123; res.add(curr); curr = iter; &#125; &#125; res.add(curr); return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[055. Jump Game]]></title>
    <url>%2Fp%2F5ad5dd79%2F</url>
    <content type="text"><![CDATA[29.5% https://leetcode.com/problems/jump-game/ Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. 1234For example:A = [2,3,1,1,4], return true.A = [3,2,1,0,4], return false. 方法一： code 1： 12345678910class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int i = 0; for(int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + nums[i], reach); return i == n; &#125;&#125;; code 2： 我的实现 12345678910class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int i = 0; for(int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + nums[i], reach); return i == n; &#125;&#125;; cpp https://leetcode.com/discuss/15567/linear-and-simple-solution-in-c 12ms, 98.85%, June.22th, 2016 12345678910class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int i = 0; for(int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + nums[i], reach); return i == n; &#125;&#125;; https://discuss.leetcode.com/topic/4911/linear-and-simple-solution-in-c Linear and simple solution in C++ I just iterate and update the maximal index that I can reach 123456bool canJump(int A[], int n) &#123; int i = 0; for (int reach = 0; i &lt; n &amp;&amp; i &lt;= reach; ++i) reach = max(i + A[i], reach); return i == n;&#125; https://discuss.leetcode.com/topic/3443/simplest-o-n-solution-with-constant-space Simplest O(N) solution with constant space Idea is to work backwards from the last index. Keep track of the smallest index that can “jump” to the last index. Check whether the current index can jump to this smallest index. 1234567bool canJump(int A[], int n) &#123; int last=n-1,i,j; for(i=n-2;i&gt;=0;i--)&#123; if(i+A[i]&gt;=last)last=i; &#125; return last&lt;=0;&#125; https://discuss.leetcode.com/topic/21062/c-elegant-solution-o-n-time C++, elegant solution, O(n) time. 123456789101112bool canJump(vector&lt;int&gt;&amp; nums) &#123; int size=nums.size(); int step=nums[0]; for(int i=1;i&lt;size;++i)&#123; step--; if(step&lt;0) return false; if(nums[i]&gt;step) step=nums[i]; &#125; return true;&#125; my code 12345678910111213class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int m = 0; int cur_max = 1; while(m &lt; cur_max &amp;&amp; cur_max &lt; n)&#123; cur_max = max(nums[m]+m+1, cur_max); m += 1; &#125; return cur_max &gt; n-1; &#125;&#125;; my code 123456789101112131415class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return true; int loc = 0; for(int i=0; i&lt;n-1; i++)&#123; if(i&lt;=loc) loc = max(i+nums[i], loc); if(i&gt;loc) return false; &#125; return loc &gt;= n-1; &#125;&#125;; python https://leetcode.com/discuss/41420/1-6-lines-o-n-time-o-1-space 68ms, 46.69%, June.22th, 2016123456789101112class Solution(object): def canJump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; m = 0 for i, n in enumerate(nums): if i &gt; m: return False m = max(m, i+n) return True https://discuss.leetcode.com/topic/16704/1-6-lines-o-n-time-o-1-space 1-6 lines, O(n) time, O(1) space Solution 1 Going forwards. m tells the maximum index we can reach so far. 1234567def canJump(self, nums): m = 0 for i, n in enumerate(nums): if i &gt; m: return False m = max(m, i+n) return True Solution 2 One-liner version: 12def canJump(self, nums): return reduce(lambda m, (i, n): max(m, i+n) * (i &lt;= m), enumerate(nums, 1), 1) &gt; 0 Solution 3 Going backwards, most people seem to do that, here’s my version. 123456def canJump(self, nums): goal = len(nums) - 1 for i in range(len(nums))[::-1]: if i + nums[i] &gt;= goal: goal = i return not goal Solution 4 C version. 1234567bool canJump(int* nums, int n) &#123; int goal=n-1, i; for (i=n; i--;) if (i+nums[i] &gt;= goal) goal=i; return !goal;&#125; Solution mine: 96ms, 10.22%, June.22th, 2016 1234567891011121314class Solution(object): def canJump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; i = 0 max = 0 while i &lt; len(nums) and i &lt;= max: tmp = i + nums[i] if tmp &gt; max: max = tmp i += 1 return max &gt;= len(nums) - 1 Solution mine: 60ms, 79.56%, June.22th, 2016 12345678910111213class Solution(object): def canJump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; i = 0 m = 0 n = len(nums) while i &lt; n and i &lt;= m: m = max(i+nums[i], m) i += 1 return m &gt;= len(nums) -1 java https://leetcode.com/discuss/22560/java-solution-easy-to-understand 3ms, 26.71%, June.22th, 2016 Java Solution easy to understand 12345678910public class Solution &#123; public boolean canJump(int[] nums) &#123; int max = 0; for(int i = 0; i&lt; nums.length; i++)&#123; if(i &gt; max) return false; max = Math.max(nums[i] + i, max); &#125; return true; &#125;&#125; https://discuss.leetcode.com/topic/19931/6-line-java-solution-in-o-n 6 line java solution in O(n) The basic idea is this: at each step, we keep track of the furthest reachable index. The nature of the problem (eg. maximal jumps where you can hit a range of targets instead of singular jumps where you can only hit one target) is that for an index to be reachable, each of the previous indices have to be reachable. Hence, it suffices that we iterate over each index, and If we ever encounter an index that is not reachable, we abort and return false. By the end, we will have iterated to the last index. If the loop finishes, then the last index is reachable. 12345678public boolean canJump(int[] nums) &#123; int reachable = 0; for (int i=0; i&lt;nums.length; ++i) &#123; if (i &gt; reachable) return false; reachable = Math.max(reachable, i + nums[i]); &#125; return true;&#125; https://discuss.leetcode.com/topic/36578/java-98-percentile-solution Java 98% Percentile Solution The easiest way to think about this problem is to ask are the elements with a 0 value avoidable? this is the algorithm that I constructed to answer this question.Starting from the second to last element in the array we continue to decrement towards the start of the array. Only stopping if we hit an element with a value of 0; in this case we evaluate if there exist an element somewhere at the start of the array which has a jump value large enough to jump over this 0 value element. 1234567891011121314151617public class Solution &#123; public boolean canJump(int[] nums) &#123; if(nums.length &lt; 2) return true; for(int curr = nums.length-2; curr&gt;=0;curr--)&#123; if(nums[curr] == 0)&#123; int neededJumps = 1; while(neededJumps &gt; nums[curr])&#123; neededJumps++; curr--; if(curr &lt; 0) return false; &#125; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[054. Spiral Matrix]]></title>
    <url>%2Fp%2F50cae0bf%2F</url>
    <content type="text"><![CDATA[25.1% https://leetcode.com/problems/spiral-matrix/ Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. 123456789For example,Given the following matrix:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]You should return [1,2,3,6,9,8,7,4,5]. 方法一： 设置四个变量，up，down， left， right，控制边界，直到要跳出循环。 剑指offer，20题。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return &#123;&#125;; int m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; spiral(m * n); int u = 0, d = m - 1, l = 0, r = n - 1, k = 0; while (true) &#123; // up for (int col = l; col &lt;= r; col++) spiral[k++] = matrix[u][col]; if (++u &gt; d) break; // right for (int row = u; row &lt;= d; row++) spiral[k++] = matrix[row][r]; if (--r &lt; l) break; // down for (int col = r; col &gt;= l; col--) spiral[k++] = matrix[d][col]; if (--d &lt; u) break; // left for (int row = d; row &gt;= u; row--) spiral[k++] = matrix[row][l]; if (++l &gt; r) break; &#125; return spiral; &#125;&#125;; 我的代码实现； 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; if(matrix.empty() || matrix[0].empty()) return res; // right = matrix[0].size()-1 而不是matrix[0]-1 我们要的是index int left = 0, right = matrix[0].size()-1, up = 0, down = matrix.size()-1; // 这里设置为永远为true while(true)&#123; for(int i=left; i&lt;=right; i++) res.push_back(matrix[up][i]); up++; // 需要在这里判断一下是否跳出循环 if(up&gt;down) break; for(int j=up; j&lt;=down; j++) res.push_back(matrix[j][right]); right--; if(left&gt;right) break; for(int k=right; k&gt;=left; k--) res.push_back(matrix[down][k]); down--; if(up&gt;down) break; for(int l=down; l&gt;=up; l--) res.push_back(matrix[l][left]); left++; if(left&gt;right) break; &#125; return res; &#125;&#125;; 0ms, 15.19%, June.25th, 2016 https://leetcode.com/discuss/38974/a-concise-c-implementation-based-on-directions A concise C++ implementation based on Directions When traversing the matrix in the spiral order, at any time we follow one out of the following four directions: RIGHT DOWN LEFT UP. Suppose we are working on a 5 x 3 matrix as such: 0 1 2 3 4 56 7 8 9 1011 12 13 14 15 Imagine a cursor starts off at (0, -1), i.e. the position at ‘0’, then we can achieve the spiral order by doing the following: Go right 5 times Go down 2 times Go left 4 times Go up 1 times. Go right 3 times Go down 0 times -&gt; quit Notice that the directions we choose always follow the order ‘right-&gt;down-&gt;left-&gt;up’, and for horizontal movements, the number of shifts follows:{5, 4, 3}, and vertical movements follows {2, 1, 0}. Thus, we can make use of a direction matrix that records the offset for all directions, then an array of two elements that stores the number of shifts for horizontal and vertical movements, respectively. This way, we really just need one for loop instead of four. Another good thing about this implementation is that: If later we decided to do spiral traversal on a different direction (e.g. Counterclockwise), then we only need to change the Direction matrix; the main loop does not need to be touched. 1234567891011121314151617181920vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;vector&lt;int&gt; &gt; dirs&#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; vector&lt;int&gt; res; int nr = matrix.size(); if (nr == 0) return res; int nc = matrix[0].size(); if (nc == 0) return res; vector&lt;int&gt; nSteps&#123;nc, nr-1&#125;; int iDir = 0; // index of direction. int ir = 0, ic = -1; // initial position while (nSteps[iDir%2]) &#123; for (int i = 0; i &lt; nSteps[iDir%2]; ++i) &#123; ir += dirs[iDir][0]; ic += dirs[iDir][1]; res.push_back(matrix[ir][ic]); &#125; nSteps[iDir%2]--; iDir = (iDir + 1) % 4; &#125; return res;&#125; https://discuss.leetcode.com/topic/21090/0ms-clear-c-solution 0ms Clear C++ Solution The idea is just to add the elements in the spiral order. First the up-most row (u), then the right-most column (r), then the down-most row (d), and finally the left-most column (l). After finishing a row or a column, update the corresponding variable to continue the process. The code is as follows. 简单直接 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return &#123;&#125;; int m = matrix.size(), n = matrix[0].size(); vector&lt;int&gt; spiral(m * n); int u = 0, d = m - 1, l = 0, r = n - 1, k = 0; while (true) &#123; // up for (int col = l; col &lt;= r; col++) spiral[k++] = matrix[u][col]; if (++u &gt; d) break; // right for (int row = u; row &lt;= d; row++) spiral[k++] = matrix[row][r]; if (--r &lt; l) break; // down for (int col = r; col &gt;= l; col--) spiral[k++] = matrix[d][col]; if (--d &lt; u) break; // left for (int row = d; row &gt;= u; row--) spiral[k++] = matrix[row][l]; if (++l &gt; r) break; &#125; return spiral; &#125;&#125;; my code: 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.size()==0 || matrix[0].size()==0) return &#123;&#125;; int m = matrix.size(); int n = matrix[0].size(); vector&lt;int&gt; spiral(m*n, 0); int up=0, down=m-1, left=0, right=n-1, i=0; while(true)&#123; for(int col=left; col&lt;=right; col++) spiral[i++] = matrix[up][col]; if(++up&gt;down) break; for(int row=up; row&lt;=down; row++) spiral[i++] = matrix[row][right]; if(--right&lt;left) break; for(int col=right; col&gt;=left; col--) spiral[i++] = matrix[down][col]; if(--down&lt;up) break; for(int row=down; row&gt;=up; row--) spiral[i++] = matrix[row][left]; if(++left&gt;right) break; &#125; return spiral; &#125;&#125;; https://discuss.leetcode.com/topic/19034/1-liner-in-python 1-liner in Python Take the first row plus the spiral order of the rotated remaining matrix. Inefficient for large matrices, but here I got it accepted in 40 ms, one of the fastest Python submissions. 12def spiralOrder(self, matrix): return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1]) 52ms, 35.84%, June.25th, 2016 https://leetcode.com/discuss/17818/simple-python-solution-by-mutating-the-matrix Simple Python solution by mutating the matrix The con is mutating the matrix, if this is not allowed, we can make a deep copy of the matrix first. And of course it comes with the additional memory usage. 123456789101112131415161718class Solution(object): def spiralOrder(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: List[int] &quot;&quot;&quot; ret = [] while matrix: ret += matrix.pop(0) if matrix and matrix[0]: for row in matrix: ret.append(row.pop()) if matrix: ret += matrix.pop()[::-1] if matrix and matrix[0]: for row in matrix[::-1]: ret.append(row.pop(0)) return ret https://discuss.leetcode.com/topic/26242/ac-python-32ms-solution AC Python 32ms solution 1234567891011121314151617181920212223def spiralOrder(self, matrix): if not matrix or not matrix[0]: return [] ans = [] m, n = len(matrix), len(matrix[0]) u, d, l, r = 0, m - 1, 0, n - 1 while l &lt; r and u &lt; d: ans.extend([matrix[u][j] for j in xrange(l, r)]) ans.extend([matrix[i][r] for i in xrange(u, d)]) ans.extend([matrix[d][j] for j in xrange(r, l, -1)]) ans.extend([matrix[i][l] for i in xrange(d, u, -1)]) u, d, l, r = u + 1, d - 1, l + 1, r - 1 if l == r: ans.extend([matrix[i][r] for i in xrange(u, d + 1)]) elif u == d: ans.extend([matrix[u][j] for j in xrange(l, r + 1)]) return ans# 22 / 22 test cases passed.# Status: Accepted# Runtime: 32 ms# 100% https://discuss.leetcode.com/topic/3713/super-simple-and-easy-to-understand-solution Super Simple and Easy to Understand Solution This is a very simple and easy to understand solution. I traverse right and increment rowBegin, then traverse down and decrement colEnd, then I traverse left and decrement rowEnd, and finally I traverse up and increment colBegin. The only tricky part is that when I traverse left or up I have to check whether the row or col still exists to prevent duplicates. If anyone can do the same thing without that check, please let me know! Any comments greatly appreciated. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (matrix.length == 0) &#123; return res; &#125; int rowBegin = 0; int rowEnd = matrix.length-1; int colBegin = 0; int colEnd = matrix[0].length - 1; while (rowBegin &lt;= rowEnd &amp;&amp; colBegin &lt;= colEnd) &#123; // Traverse Right for (int j = colBegin; j &lt;= colEnd; j ++) &#123; res.add(matrix[rowBegin][j]); &#125; rowBegin++; // Traverse Down for (int j = rowBegin; j &lt;= rowEnd; j ++) &#123; res.add(matrix[j][colEnd]); &#125; colEnd--; if (rowBegin &lt;= rowEnd) &#123; // Traverse Left for (int j = colEnd; j &gt;= colBegin; j --) &#123; res.add(matrix[rowEnd][j]); &#125; &#125; rowEnd--; if (colBegin &lt;= colEnd) &#123; // Traver Up for (int j = rowEnd; j &gt;= rowBegin; j --) &#123; res.add(matrix[j][colBegin]); &#125; &#125; colBegin ++; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/22270/elegant-and-fast-java-solution-240ms Elegant and fast Java solution (240ms) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;List&lt;Integer&gt; spiralList = new ArrayList&lt;&gt;();if(matrix == null || matrix.length == 0) return spiralList;// declare indicesint top = 0;int bottom = matrix.length - 1;int left = 0;int right = matrix[0].length - 1;while(true)&#123; // 1. print top row for(int j=left; j &lt;=right;j++)&#123; spiralList.add(matrix[top][j]); &#125; top++; if(boundriesCrossed(left,right,bottom,top)) break; // 2. print rightmost column for(int i=top; i &lt;= bottom; i++)&#123; spiralList.add(matrix[i][right]); &#125; right--; if(boundriesCrossed(left,right,bottom,top)) break; // 3. print bottom row for(int j=right; j &gt;=left; j--)&#123; spiralList.add(matrix[bottom][j]); &#125; bottom--; if(boundriesCrossed(left,right,bottom,top)) break; // 4. print leftmost column for(int i=bottom; i &gt;= top; i--)&#123; spiralList.add(matrix[i][left]); &#125; left++; if(boundriesCrossed(left,right,bottom,top)) break; &#125;// end while truereturn spiralList;&#125;private boolean boundriesCrossed(int left,int right,int bottom,int top)&#123;if(left&gt;right || bottom&lt;top) return true;else return false;&#125; https://discuss.leetcode.com/topic/44784/clean-java-readable-human-friendly-code Clean Java, readable, human friendly code 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(matrix.length == 0 || matrix[0].length == 0) return res; int top = 0; int bottom = matrix.length-1; int left = 0; int right = matrix[0].length-1; while(true)&#123; for(int i = left; i &lt;= right; i++) res.add(matrix[top][i]); top++; if(left &gt; right || top &gt; bottom) break; for(int i = top; i &lt;= bottom; i++) res.add(matrix[i][right]); right--; if(left &gt; right || top &gt; bottom) break; for(int i = right; i &gt;= left; i--) res.add(matrix[bottom][i]); bottom--; if(left &gt; right || top &gt; bottom) break; for(int i = bottom; i &gt;= top; i--) res.add(matrix[i][left]); left++; if(left &gt; right || top &gt; bottom) break; &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[053. Maximum Subarray]]></title>
    <url>%2Fp%2Fe4eaff71%2F</url>
    <content type="text"><![CDATA[39.0% https://leetcode.com/problems/maximum-subarray/ Find the contiguous subarray within an array (containing at least one number) which has the largest sum. 12For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. click to show more practice. More practice: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 方法一： 动态规划 dp[n] 保存以nums[n]结尾的最大值，ans保存当前到n所有表中的最大值。 1234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; vector&lt;int&gt; dp(nums.size(), 0); dp[0] = nums[0]; int ans = nums[0]; for(int i=1; i&lt;nums.size(); i++)&#123; dp[i] = nums[i] + (dp[i-1]&gt;0?dp[i-1]:0); ans = max(ans, dp[i]); &#125; return ans; &#125;&#125;; 方法二： 与上面逻辑其实是类似的，保存一个当前最大值cur_sum，表示第i个位置之前，从i-1向前所能取得的最大值，并且以i-1结尾的， 全局最大值 max_sum表示0至i-1之前的最大值。到达第i位时，先更新当前最大值，再更新全局的。 1234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;0) return 0; int cur_sum = 0; int max_sum = INT_MIN; for(auto num:nums)&#123; cur_sum = max(cur_sum, 0) + num; max_sum = max(cur_sum, max_sum); &#125; return max_sum; &#125;&#125;; 我的代码实现： 通过初始化为第0位，避免了使用INT_MIN。 12345678910111213class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;1) return n; int cur_max = nums[0], all_max = nums[0]; for(int i=1; i&lt;n; i++)&#123; cur_max = max(cur_max+nums[i], nums[i]); all_max = max(all_max, cur_max); &#125; return all_max; &#125;&#125;; 我的代码实现: 123456789101112131415161718class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;1) return 0; if(n==1) return nums[0]; int cur_max = nums[0], res = nums[0]; int i=1; while(i&lt;n)&#123; // 仔细思考，这里是 max(nums[i], cur_max+nums[i]) // 而不是max(cur_max, cur_max+nums[i]); cur_max = max(nums[i], cur_max+nums[i]); res = max(res, cur_max); i++; &#125; return res; &#125;&#125;; cpp https://leetcode.com/discuss/11288/simplest-and-fastest-o-n-c-solution 8ms, 72.20%, June.18th, 2016 Simplest and fastest O(n) C++ solution Idea is very simple. Basically, keep adding each integer to the sequence until the sum drops below 0. If sum is negative, then should reset the sequence. 123456789101112class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int ans = nums[0], sum = 0; for(int i=0; i &lt; nums.size();i++)&#123; sum += nums[i]; ans = max(ans, sum); sum = max(sum, 0); &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/4175/share-my-solutions-both-greedy-and-divide-and-conquer Share my solutions - both greedy and divide and conquer greedy: 123456789101112class Solution &#123;public: int maxSubArray(int A[], int n) &#123; int sum = 0, min = 0, res = A[0]; for(int i = 0; i &lt; n; i++) &#123; sum += A[i]; if(sum - min &gt; res) res = sum - min; if(sum &lt; min) min = sum; &#125; return res; &#125;&#125;; The idea is to find the largest difference between the sums when you summing up the array from left to right. The largest difference corresponds to the sub-array with largest sum. I worked it out independently although It is very close to lucastan’s solution https://oj.leetcode.com/discuss/11288/simple-o-n-c-solution-no-dp-no-divide-and-conquer divide and conquer: 12345678910111213141516171819202122struct val &#123; int l, m, r, s; val(int l, int m, int r, int s):l(l), m(m), r(r), s(s)&#123;&#125;&#125;;class Solution &#123;public: val dac(int A[], int n) &#123; if(n == 1) return val(A[0], A[0], A[0], A[0]); val v1 = dac(A, n / 2), v2 = dac(A + n / 2, n - n / 2); int l, m, r, s; l = max(v1.l, v1.s + v2.l); m = max(v1.r + v2.l, max(v1.m, v2.m)); r = max(v2.r, v1.r + v2.s); s = v1.s + v2.s; return val(l, m, r, s); &#125; int maxSubArray(int A[], int n) &#123; val v = dac(A, n); return v.m; &#125;&#125;; the idea is: for each sub array we calculate 4 values in O(1) time based on the return values of its two halves. The meaning of the values: l: the sum of the sub array with largest sum starting from the first element m: the sum of the sub array with largest sum r: the sum of the sub array with largest sum ending at the last element s: the sum of the whole array the recursive relation is clear in the code. https://discuss.leetcode.com/topic/25396/c-an-clear-o-n-divide-and-conquer-solution-with-comments [C++] An clear O(n) divide and conquer solution with comments For each subarray, calculate four attributes: 1234mx (largest sum of this subarray), lmx(largest sum starting from the left most element), rmx(largest sum ending with the right most element), sum(the sum of the total subarray). The recurrence is: T(n) = 2T(n / 2) + O(1). So the running time of this algorithm is O(n). 123456789101112131415161718192021222324252627class Solution &#123;public: void maxSubArray(vector&lt;int&gt;&amp; nums, int l, int r, int&amp; mx, int&amp; lmx, int&amp; rmx, int&amp; sum) &#123; if (l == r) &#123; mx = lmx = rmx = sum = nums[l]; &#125; else &#123; int m = (l + r) / 2; int mx1, lmx1, rmx1, sum1; int mx2, lmx2, rmx2, sum2; maxSubArray(nums, l, m, mx1, lmx1, rmx1, sum1); maxSubArray(nums, m + 1, r, mx2, lmx2, rmx2, sum2); mx = max(max(mx1, mx2), rmx1 + lmx2); lmx = max(lmx1, sum1 + lmx2); rmx = max(rmx2, sum2 + rmx1); sum = sum1 + sum2; &#125; &#125; int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) &#123; return 0; &#125; int mx, lmx, rmx, sum; maxSubArray(nums, 0, nums.size() - 1, mx, lmx, rmx, sum); return mx; &#125;&#125;; https://discuss.leetcode.com/topic/426/how-to-solve-maximum-subarray-by-using-the-divide-and-conquer-approach How to solve “Maximum Subarray” by using the divide and conquer approach ? I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach. I cannot figure out how to do it with divide and conquer. You guys have ideas? https://discuss.leetcode.com/topic/426/how-to-solve-maximum-subarray-by-using-the-divide-and-conquer-approach/2 Step1. Select the middle element of the array. So the maximum subarray may contain that middle element or not. Step 2.1 If the maximum subarray does not contain the middle element, then we can apply the same algorithm to the the subarray to the left of the middle element and the subarray to the right of the middle element. Step 2.2 If the maximum subarray does contain the middle element, then the result will be simply the maximum suffix subarray of the left subarray plus the maximum prefix subarray of the right subarray Step 3 return the maximum of those three answer. Here is a sample code for divide and conquer solution. Please try to understand the algorithm before look at the code 1234567891011121314151617181920212223242526272829class Solution &#123;public: int maxSubArray(int A[], int n) &#123; // IMPORTANT: Please reset any member data you declared, as // the same Solution instance will be reused for each test case. if(n==0) return 0; return maxSubArrayHelperFunction(A,0,n-1); &#125; int maxSubArrayHelperFunction(int A[], int left, int right) &#123; if(right == left) return A[left]; int middle = (left+right)/2; int leftans = maxSubArrayHelperFunction(A, left, middle); int rightans = maxSubArrayHelperFunction(A, middle+1, right); int leftmax = A[middle]; int rightmax = A[middle+1]; int temp = 0; for(int i=middle;i&gt;=left;i--) &#123; temp += A[i]; if(temp &gt; leftmax) leftmax = temp; &#125; temp = 0; for(int i=middle+1;i&lt;=right;i++) &#123; temp += A[i]; if(temp &gt; rightmax) rightmax = temp; &#125; return max(max(leftans, rightans),leftmax+rightmax); &#125;&#125;; python https://leetcode.com/discuss/29296/a-python-solution 64ms, 49.06%, June.18th, 201612345678910111213class Solution(object): def maxSubArray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if not nums: return 0 cursum = maxsum = nums[0] for num in nums[1:]: cursum = max(num, num+cursum) maxsum = max(cursum, maxsum) return maxsum java https://discuss.leetcode.com/topic/6413/dp-solution-some-thoughts Analysis of this problem: Apparently, this is a optimization problem, which can be usually solved by DP. So when it comes to DP, the first thing for us to figure out is the format of the sub problem(or the state of each sub problem). The format of the sub problem can be helpful when we are trying to come up with the recursive relation. At first, I think the sub problem should look like: maxSubArray(int A[], int i, int j), which means the maxSubArray for A[i: j]. In this way, our goal is to figure out what maxSubArray(A, 0, A.length - 1) is. However, if we define the format of the sub problem in this way, it’s hard to find the connection from the sub problem to the original problem(at least for me). In other words, I can’t find a way to divided the original problem into the sub problems and use the solutions of the sub problems to somehow create the solution of the original one. So I change the format of the sub problem into something like: maxSubArray(int A[], int i), which means the maxSubArray for A[0:i ] which must has A[i] as the end element. Note that now the sub problem’s format is less flexible and less powerful than the previous one because there’s a limitation that A[i] should be contained in that sequence and we have to keep track of each solution of the sub problem to update the global optimal value. However, now the connect between the sub problem &amp; the original one becomes clearer: 1maxSubArray(A, i) = maxSubArray(A, i - 1) &gt; 0 ? maxSubArray(A, i - 1) : 0 + A[i]; And here’s the code 123456789101112131415public class Solution &#123; public int maxSubArray(int[] nums) &#123; int n = nums.length; int[] dp = new int[n]; dp[0] = nums[0]; int max = dp[0]; for(int i=1; i&lt;n; i++)&#123; dp[i] = nums[i] + (dp[i-1]&gt;0?dp[i-1]:0); max = Math.max(max, dp[i]); &#125; return max; &#125;&#125; https://leetcode.com/discuss/15805/accepted-o-n-solution-in-java 1ms, 69.50%, June.18th, 2016 Accepted O(n) solution in java this problem was discussed by Jon Bentley (Sep. 1984 Vol. 27 No. 9 Communications of the ACM P885) the paragraph below was copied from his paper (with a little modifications) algorithm that operates on arrays: it starts at the left end (element A[1]) and scans through to the right end (element A[n]), keeping track of the maximum sum subvector seen so far. The maximum is initially A[0]. Suppose we’ve solved the problem for A[1 .. i - 1]; how can we extend that to A[1 .. i]? The maximumsum in the first I elements is either the maximum sum in the first i - 1 elements (which we’ll call MaxSoFar), or it is that of a subvector that ends in position i (which we’ll call MaxEndingHere). MaxEndingHere is either A[i] plus the previous MaxEndingHere, or just A[i], whichever is larger. 12345678public static int maxSubArray(int[] A) &#123; int maxSoFar=A[0], maxEndingHere=A[0]; for (int i=1;i&lt;A.length;++i)&#123; maxEndingHere= Math.max(maxEndingHere+A[i],A[i]); maxSoFar=Math.max(maxSoFar, maxEndingHere); &#125; return maxSoFar;&#125; https://discuss.leetcode.com/topic/7447/o-n-java-solution O(n) Java solution The catch here is that we have to take care of negative value. The solution does 1 iteration with constant space and no DP. 1234567891011121314public class Solution &#123;public int maxSubArray(int[] A) &#123; int max = Integer.MIN_VALUE, sum = 0; for (int i = 0; i &lt; A.length; i++) &#123; if (sum &lt; 0) sum = A[i]; else sum += A[i]; if (sum &gt; max) max = sum; &#125; return max;&#125;&#125; https://discuss.leetcode.com/topic/27151/my-concise-o-n-dp-java-solution My concise O(n) DP JAVA Solution Explanation Although there’re some other simplified solutions, but DP solution can make the original thought for this problem clearer. In this solution, dp[i] means the largest sum among the subarrays whose last element is A[i]. Solution1. DP Solution - O(n) time, O(n) space 12345678public int maxSubArray(int[] A) &#123; int dp[] = new int[A.length]; int max = A[0]; dp[0] = A[0]; for (int i = 1; i &lt; A.length; i++) &#123; dp[i] = Math.max(dp[i-1] + A[i] ,A[i]); max = Math.max(max, dp[i]); &#125; return max;&#125; Solution2. Simplified DP Solution - O(n) time, O(1) space - Special thanks for TWiStErRob’s smart comment The basic idea is to check previous sum, reset it to 0 if it’s less than 0. 12345678public int maxSubArray(int[] A) &#123; int res = Integer.MIN_VALUE, sum = 0; for (int i = 0; i &lt; A.length; i++) &#123; sum = Math.max(sum, 0) + A[i]; res = Math.max(res, sum); &#125; return res;&#125; Solution3. Pre-Sum Array Solution - O(n) time, O(n) space The basic idea is to use pre-sum array, max = Math.max(max, sum[i] - minSum). (minSum is the minimum sum before A[i]) 123456789101112public int maxSubArray(int[] A) &#123; if (A == null || A.length == 0) return 0; int max = A[0], minSum = Integer.MAX_VALUE; int sum[] = new int[A.length]; sum[0] = A[0]; for (int i = 1; i &lt; A.length; i++) &#123; sum[i] = sum[i-1] + A[i]; minSum = Math.min(0, Math.min(minSum, sum[i-1])); max = Math.max(max, sum[i] - minSum); &#125; return max;&#125; https://discuss.leetcode.com/topic/42213/my-divide-and-conquer-solution-in-java-under-instruction-of-clrs-o-nlogn My Divide and Conquer Solution in Java under instruction of CLRS(O(nlogn)) 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123;//divdie and conquer public int maxSubArray(int[] nums) &#123; return Subarray(nums, 0 ,nums.length -1 ); &#125; public int Subarray(int[] A,int left, int right)&#123; if(left == right)&#123;return A[left];&#125; int mid = left + (right - left) / 2; int leftSum = Subarray(A,left,mid);// left part int rightSum = Subarray(A,mid+1,right);//right part int crossSum = crossSubarray(A,left,right);// cross part if(leftSum &gt;= rightSum &amp;&amp; leftSum &gt;= crossSum)&#123;// left part is max return leftSum; &#125; if(rightSum &gt;= leftSum &amp;&amp; rightSum &gt;= crossSum)&#123;// right part is max return rightSum; &#125; return crossSum; // cross part is max &#125; public int crossSubarray(int[] A,int left,int right)&#123; int leftSum = Integer.MIN_VALUE; int rightSum = Integer.MIN_VALUE; int sum = 0; int mid = left + (right - left) / 2; for(int i = mid; i &gt;= left ; i--)&#123; sum = sum + A[i]; if(leftSum &lt; sum)&#123; leftSum = sum; &#125; &#125; sum = 0; for(int j = mid + 1; j &lt;= right; j++)&#123; sum = sum + A[j]; if(rightSum &lt; sum)&#123; rightSum = sum; &#125; &#125; return leftSum + rightSum; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>divide and conquer</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[052. N-Queens II]]></title>
    <url>%2Fp%2F8e5f0d6d%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/n-queens-ii/ Follow up for N-Queens problem. Now, instead outputting board configurations, return the total number of distinct solutions. cpp https://discuss.leetcode.com/topic/19741/c-solution-dfs-easy-understanding C++ solution - DFS - easy understanding 1234567891011121314151617181920212223int totalNQueens(int n) &#123; vector&lt;bool&gt; col(n, true); vector&lt;bool&gt; anti(2*n-1, true); vector&lt;bool&gt; main(2*n-1, true); vector&lt;int&gt; row(n, 0); int count = 0; dfs(0, row, col, main, anti, count); return count;&#125;void dfs(int i, vector&lt;int&gt; &amp;row, vector&lt;bool&gt; &amp;col, vector&lt;bool&gt;&amp; main, vector&lt;bool&gt; &amp;anti, int &amp;count) &#123; if (i == row.size()) &#123; count++; return; &#125; for (int j = 0; j &lt; col.size(); j++) &#123; if (col[j] &amp;&amp; main[i+j] &amp;&amp; anti[i+col.size()-1-j]) &#123; row[i] = j; col[j] = main[i+j] = anti[i+col.size()-1-j] = false; dfs(i+1, row, col, main, anti, count); col[j] = main[i+j] = anti[i+col.size()-1-j] = true; &#125; &#125;&#125; https://discuss.leetcode.com/topic/19741/c-solution-dfs-easy-understanding/2 Nice job!I think row is useless, delete it is ok. 123456789101112131415161718192021222324252627282930class Solution &#123;public:int totalNQueens(int n) &#123; int count = 0; vector&lt;bool&gt; cols(n, true); vector&lt;bool&gt; main(2 * n - 1, true); vector&lt;bool&gt; anti(2 * n - 1, true); helper(0, count, cols, main, anti); return count;&#125;private:void helper(int s, int&amp; count, vector&lt;bool&gt;&amp; cols, vector&lt;bool&gt;&amp; main, vector&lt;bool&gt;&amp; anti)&#123; if (s == cols.size()) &#123; count++; return; &#125; for (int i = 0; i &lt; cols.size(); i++) &#123; if (cols[i] &amp;&amp; main[s + i] &amp;&amp; anti[s + cols.size() - 1 - i]) &#123; cols[i] = main[s + i] = anti[s + cols.size() - 1 - i] = false; helper(s + 1, count, cols, main, anti); cols[i] = main[s + i] = anti[s + cols.size() - 1 - i] = true; &#125; &#125;&#125;&#125;; And I want to share my 4ms Solution. The ideas are same but the diagonal conflict checking method diffes. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public:int totalNQueens(int n) &#123; int count = 0; vector&lt;bool&gt; mark(n); vector&lt;int&gt; cols(n, -1); for (int i = 0; i &lt; n; i++) &#123; cols[0] = i; mark[i] = true; helper(1, n, count, mark, cols); cols[0] = -1; mark[i] = false; &#125; return count;&#125;private:void helper(int s, int n, int&amp; count, vector&lt;bool&gt;&amp; mark, vector&lt;int&gt;&amp; cols)&#123; if (s == n) &#123; count++; return; &#125; for (int i = 0; i &lt; n; i++) &#123; if (!mark[i]) &#123; bool mark2 = true; for (int k = 0; k &lt; s; k++) &#123; if (abs(s - k) == abs(i - cols[k])) &#123; mark2 = false; break; &#125; &#125; if (mark2) &#123; cols[s] = i; mark[i] = true; helper(s + 1, n, count, mark, cols); cols[s] = -1; mark[i] = false; &#125; &#125; &#125;&#125;&#125;; https://discuss.leetcode.com/topic/38923/share-my-java-code-beats-97-83-run-times Share my Java code (beats 97.83% run times) 1234567891011121314151617181920212223242526272829/* 常规n-queens解法, 数答案个数. 用column标记此行之前的哪些column已经放置了queen. 棋盘坐标(row, col)对应column的第col位(LSB --&gt; MSB, 下同). 用diag标记此位置之前的哪些主对角线已经放置了queen. 棋盘坐标(row, col)对应diag的第(n - 1 + row - col)位. 用antiDiag标记此位置之前的哪些副对角线已经放置了queen. 棋盘坐标(row, col)对应antiDiag的第(row + col)位.*/public class Solution &#123; int count = 0; public int totalNQueens(int n) &#123; dfs(0, n, 0, 0, 0); return count; &#125; private void dfs(int row, int n, int column, int diag, int antiDiag) &#123; if (row == n) &#123; ++count; return; &#125; for (int i = 0; i &lt; n; ++i) &#123; boolean isColSafe = ((1 &lt;&lt; i) &amp; column) == 0; boolean isDiagSafe = ((1 &lt;&lt; (n - 1 + row - i)) &amp; diag) == 0; boolean isAntiDiagSafe = ((1 &lt;&lt; (row + i)) &amp; antiDiag) == 0; if (isColSafe &amp;&amp; isDiagSafe &amp;&amp; isAntiDiagSafe) &#123; dfs(row + 1, n, (1 &lt;&lt; i) | column, (1 &lt;&lt; (n - 1 + row - i)) | diag, (1 &lt;&lt; (row + i)) | antiDiag); &#125; &#125; &#125;&#125; cpp https://discuss.leetcode.com/topic/15329/shortest-c-solution-in-0ms Shortest C++ solution in 0ms Idea is to use vectors to keep track of invalid positions , so validity can be checked in O(1) and put a queen in each column 12345678910111213141516171819202122#include&lt;vector&gt;using namespace std;class Solution &#123;public: int find(int n, int left, int i, int r, vector&lt;int&gt;&amp;rows,vector&lt;int&gt;&amp;d1,vector&lt;int&gt;&amp;d2)&#123; if (left == 0) return 1; int j,sum=0; for (j=r; j&lt;n; j++)&#123; if (rows[j] || d1[i+j] || d2[n-1+i-j]) continue; rows[j]=d1[i+j]=d2[n-1+i-j]=1; sum += find(n, left-1, i+1, 0,rows,d1,d2 ); rows[j]=d1[i+j]=d2[n-1+i-j]=0; &#125; return sum; &#125; int totalNQueens(int n) &#123; vector&lt;int&gt; rows(n),d1(2*n-1),d2(2*n-1); return find(n,n,0,0,rows,d1,d2); &#125;&#125;; https://discuss.leetcode.com/topic/11348/my-concise-dfs-c-solution-using-three-unordered_map-int-bool My concise DFS C++ solution using three unordered_map&lt;int, bool&gt;. 1234567891011121314151617181920212223242526class Solution &#123;public: unordered_map&lt;int, bool&gt; column, obliqueLeft, obliqueRight; int total; void NQueensHelper(int row, int n) &#123; if (row == n+1) &#123; total++; return; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!column[i] &amp;&amp; !obliqueLeft[i + row] &amp;&amp; !obliqueRight[i - row]) &#123; column[i] = obliqueLeft[i + row] = obliqueRight[i - row] = true; NQueensHelper(row+1, n); column[i] = obliqueLeft[i + row] = obliqueRight[i - row] = false; &#125; &#125; &#125; int totalNQueens(int n) &#123; column.clear(); obliqueLeft.clear(); obliqueRight.clear(); total = 0; NQueensHelper(1, n); return total; &#125;&#125;; Each unordered_map represents whether column/left oblique line/right oblique line is occupied before. python https://discuss.leetcode.com/topic/22294/python-recursive-dfs-solution Python recursive dfs solution. The idea here is quite similar to N-Queens while we don’t need to record the path, and as the return value is a number not a list, it’s better to use a global variable to record the result. 12345678910111213141516171819def totalNQueens(self, n): self.res = 0 self.dfs([-1]*n, 0) return self.res def dfs(self, nums, index): if index == len(nums): self.res += 1 return for i in xrange(len(nums)): nums[index] = i if self.valid(nums, index): self.dfs(nums, index+1) def valid(self, nums, n): for i in xrange(n): if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i: return False return True 72ms, 85.33%, June.17th, 2016 1234567891011121314151617class Solution(object): def totalNQueens(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; def DFS(queens, xy_dif, xy_sum): p = len(queens) if p==n: result.append(queens) return None for q in range(n): if q not in queens and p-q not in xy_dif and p+q not in xy_sum: DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q]) result = [] DFS([],[],[]) return len(result) java https://discuss.leetcode.com/topic/5962/accepted-java-solution Accepted Java Solution 123456789101112131415161718192021222324252627282930313233343536373839404142/** * don&apos;t need to actually place the queen, * instead, for each row, try to place without violation on * col/ diagonal1/ diagnol2. * trick: to detect whether 2 positions sit on the same diagnol: * if delta(col, row) equals, same diagnol1; * if sum(col, row) equals, same diagnal2. */private final Set&lt;Integer&gt; occupiedCols = new HashSet&lt;Integer&gt;();private final Set&lt;Integer&gt; occupiedDiag1s = new HashSet&lt;Integer&gt;();private final Set&lt;Integer&gt; occupiedDiag2s = new HashSet&lt;Integer&gt;();public int totalNQueens(int n) &#123; return totalNQueensHelper(0, 0, n);&#125;private int totalNQueensHelper(int row, int count, int n) &#123; for (int col = 0; col &lt; n; col++) &#123; if (occupiedCols.contains(col)) continue; int diag1 = row - col; if (occupiedDiag1s.contains(diag1)) continue; int diag2 = row + col; if (occupiedDiag2s.contains(diag2)) continue; // we can now place a queen here if (row == n-1) count++; else &#123; occupiedCols.add(col); occupiedDiag1s.add(diag1); occupiedDiag2s.add(diag2); count = totalNQueensHelper(row+1, count, n); // recover occupiedCols.remove(col); occupiedDiag1s.remove(diag1); occupiedDiag2s.remove(diag2); &#125; &#125; return count;&#125; https://discuss.leetcode.com/topic/29626/easiest-java-solution-1ms-98-22 Easiest Java Solution (1ms, 98.22%) This is a classic backtracking problem. Start row by row, and loop through columns. At each decision point, skip unsafe positions by using three boolean arrays. Start going back when we reach row n. Just FYI, if using HashSet, running time will be at least 3 times slower! 123456789101112131415161718192021222324public class Solution &#123; int count = 0; public int totalNQueens(int n) &#123; boolean[] cols = new boolean[n]; // columns | boolean[] d1 = new boolean[2 * n]; // diagonals \ boolean[] d2 = new boolean[2 * n]; // diagonals / backtracking(0, cols, d1, d2, n); return count; &#125; public void backtracking(int row, boolean[] cols, boolean[] d1, boolean []d2, int n) &#123; if(row == n) count++; for(int col = 0; col &lt; n; col++) &#123; int id1 = col - row + n; int id2 = col + row; if(cols[col] || d1[id1] || d2[id2]) continue; cols[col] = true; d1[id1] = true; d2[id2] = true; backtracking(row + 1, cols, d1, d2, n); cols[col] = false; d1[id1] = false; d2[id2] = false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[051. N-Queens]]></title>
    <url>%2Fp%2Faa0d9b9e%2F</url>
    <content type="text"><![CDATA[31.1% https://leetcode.com/problems/n-queens/ The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively. 1234567891011121314For example,There exist two distinct solutions to the 4-queens puzzle:[ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] https://discuss.leetcode.com/topic/1154/the-description-should-give-a-clear-explanation-of-the-problem-of-n-queens The description should give a clear explanation of the problem of “n-queens” queens can attack other queen in the same row, same column, but i forget the diagonal.. = 。= 方法一： https://discuss.leetcode.com/topic/13617/accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand Accepted 4ms c++ solution use backtracking and bitmask, easy understand. In this problem, we can go row by row, and in each position, we need to check if the column, the 45° diagonal and the 135° diagonal had a queen before. Solution A: Directly check the validity of each position, 12ms: 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: std::vector&lt;std::vector&lt;std::string&gt; &gt; solveNQueens(int n) &#123; std::vector&lt;std::vector&lt;std::string&gt; &gt; res; std::vector&lt;std::string&gt; nQueens(n, std::string(n, &apos;.&apos;)); solveNQueens(res, nQueens, 0, n); return res; &#125;private: void solveNQueens(std::vector&lt;std::vector&lt;std::string&gt; &gt; &amp;res, std::vector&lt;std::string&gt; &amp;nQueens, int row, int &amp;n) &#123; if (row == n) &#123; res.push_back(nQueens); return; &#125; for (int col = 0; col != n; ++col) if (isValid(nQueens, row, col, n)) &#123; nQueens[row][col] = &apos;Q&apos;; solveNQueens(res, nQueens, row + 1, n); nQueens[row][col] = &apos;.&apos;; &#125; &#125; bool isValid(std::vector&lt;std::string&gt; &amp;nQueens, int row, int col, int &amp;n) &#123; //check if the column had a queen before. for (int i = 0; i != row; ++i) if (nQueens[i][col] == &apos;Q&apos;) return false; //check if the 45° diagonal had a queen before. for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) if (nQueens[i][j] == &apos;Q&apos;) return false; //check if the 135° diagonal had a queen before. for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; --i, ++j) if (nQueens[i][j] == &apos;Q&apos;) return false; return true; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; queens(n, string(n, '.')); helper(res, queens, 0, n); return res; &#125; void helper(vector&lt;vector&lt;string&gt;&gt;&amp; res, vector&lt;string&gt;&amp; queens, int row, int n)&#123; if(row==n)&#123; res.push_back(queens); return; &#125; for(int col=0; col&lt;n; col++)&#123; if(isvalid(queens, row, col, n))&#123; queens[row][col] = 'Q'; helper(res, queens, row+1, n); queens[row][col] = '.'; &#125; &#125; &#125; bool isvalid(vector&lt;string&gt;&amp; queens, int row, int col, int n)&#123; for(int i=0; i&lt;row; i++) if(queens[i][col]=='Q') return false; for(int i=row-1, j=col-1; i&gt;=0 &amp;&amp; j&gt;=0; i--, j--) if(queens[i][j]=='Q') return false; for(int i=row-1, j=col+1; i&gt;=0 &amp;&amp; j&lt;n; i--, j++) if(queens[i][j]=='Q') return false; return true; &#125;&#125;; Solution B: Use flag vectors as bitmask, 4ms: The number of columns is n, the number of 45° diagonals is 2 n - 1, the number of 135° diagonals is also 2 n - 1. When reach [row, col], the column No. is col, the 45° diagonal No. is row + col and the 135° diagonal No. is n - 1 + col - row. We can use three arrays to indicate if the column or the diagonal had a queen before, if not, we can put a queen in this position and continue. 12345678910111213141516171819202122232425262728293031323334/** | | | / / / \ \ \ * O O O O O O O O O * | | | / / / / \ \ \ \ * O O O O O O O O O * | | | / / / / \ \ \ \ * O O O O O O O O O * | | | / / / \ \ \ * 3 columns 5 45° diagonals 5 135° diagonals (when n is 3) */class Solution &#123;public: std::vector&lt;std::vector&lt;std::string&gt; &gt; solveNQueens(int n) &#123; std::vector&lt;std::vector&lt;std::string&gt; &gt; res; std::vector&lt;std::string&gt; nQueens(n, std::string(n, &apos;.&apos;)); std::vector&lt;int&gt; flag_col(n, 1), flag_45(2 * n - 1, 1), flag_135(2 * n - 1, 1); solveNQueens(res, nQueens, flag_col, flag_45, flag_135, 0, n); return res; &#125;private: void solveNQueens(std::vector&lt;std::vector&lt;std::string&gt; &gt; &amp;res, std::vector&lt;std::string&gt; &amp;nQueens, std::vector&lt;int&gt; &amp;flag_col, std::vector&lt;int&gt; &amp;flag_45, std::vector&lt;int&gt; &amp;flag_135, int row, int &amp;n) &#123; if (row == n) &#123; res.push_back(nQueens); return; &#125; for (int col = 0; col != n; ++col) if (flag_col[col] &amp;&amp; flag_45[row + col] &amp;&amp; flag_135[n - 1 + col - row]) &#123; flag_col[col] = flag_45[row + col] = flag_135[n - 1 + col - row] = 0; nQueens[row][col] = &apos;Q&apos;; solveNQueens(res, nQueens, flag_col, flag_45, flag_135, row + 1, n); nQueens[row][col] = &apos;.&apos;; flag_col[col] = flag_45[row + col] = flag_135[n - 1 + col - row] = 1; &#125; &#125;&#125;; But we actually do not need to use three arrays, we just need one. Now, when reach [row, col], the subscript of column is col, the subscript of 45° diagonal is n + row + col and the subscript of 135° diagonal is n + 2 * n - 1 + n - 1 + col - row. 123456789101112131415161718192021222324252627282930class Solution &#123;public: std::vector&lt;std::vector&lt;std::string&gt; &gt; solveNQueens(int n) &#123; std::vector&lt;std::vector&lt;std::string&gt; &gt; res; std::vector&lt;std::string&gt; nQueens(n, std::string(n, &apos;.&apos;)); /* flag[0] to flag[n - 1] to indicate if the column had a queen before. flag[n] to flag[3 * n - 2] to indicate if the 45° diagonal had a queen before. flag[3 * n - 1] to flag[5 * n - 3] to indicate if the 135° diagonal had a queen before. */ std::vector&lt;int&gt; flag(5 * n - 2, 1); solveNQueens(res, nQueens, flag, 0, n); return res; &#125;private: void solveNQueens(std::vector&lt;std::vector&lt;std::string&gt; &gt; &amp;res, std::vector&lt;std::string&gt; &amp;nQueens, std::vector&lt;int&gt; &amp;flag, int row, int &amp;n) &#123; if (row == n) &#123; res.push_back(nQueens); return; &#125; for (int col = 0; col != n; ++col) if (flag[col] &amp;&amp; flag[n + row + col] &amp;&amp; flag[4 * n - 2 + col - row]) &#123; flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 0; nQueens[row][col] = &apos;Q&apos;; solveNQueens(res, nQueens, flag, row + 1, n); nQueens[row][col] = &apos;.&apos;; flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 1; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/4007/accepted-auxillary-space-o-n-using-dfs-cpp Accepted : auxillary space O(n) , using dfs , cpp Space complexity : Instead of using a 2D array to represent the chess board, i am using a 1D array , the index of which would represent the row number and the value of arr at row index will be the column number for the correct position of the queen. i.e 12Instead of doing arr[row][col]=1i am using arr[row]=col ; where queen is positioned at (row,col); Logic : DFS for every column number ,ranging from 0 to n-1, for all the rows from 0 to n-1 and check the validity of queen position for every row,col combination(using isSafe function) isSafe function : It checks whether the queen in current position(r,c) is being attacked by any of the r-1 queens positioned in row numbers 0 through r-1. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; public: vector &lt; vector &lt;string&gt; &gt; sol; int limit; vector&lt;string&gt; toChessString(vector&lt;int&gt; arr) &#123; string s(arr.size(),&apos;.&apos;); vector&lt;string&gt; ans(arr.size(),s); for(int i=0 ; i&lt;arr.size() ; i++) ans[i][arr[i]]=&apos;Q&apos;; return ans; &#125; bool isSafe(vector&lt;int&gt; arr, int r , int c ) &#123; int check; for(int row=r-1,ldia=c-1,rdia=c+1 ; row&gt;=0 ; row--,ldia--,rdia++) &#123; check=arr[row]; if(check==c || check==ldia || check==rdia) return false; &#125; return true; &#125; void solveNqueen(vector&lt;int&gt; arr , int r , int c) &#123; if(r==limit) sol.push_back(toChessString(arr)); else &#123; for(int col=c ; col&lt;limit ; col++) &#123; arr[r]=col; if(isSafe(arr,r,col)) solveNqueen(arr,r+1,0); &#125; &#125; &#125; vector&lt;vector&lt;string&gt; &gt; solveNQueens(int n) &#123; vector&lt;int&gt; arr(n,0); limit=n; solveNqueen(arr,0,0); return sol; &#125; &#125;; https://discuss.leetcode.com/topic/7644/c-6ms-solution-use-bitmask C++ 6ms solution use bitmask 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; int n; string getNq(int p) &#123; string s(n, &apos;.&apos;); s[p] = &apos;Q&apos;; return s; &#125; void nQueens(int p, int l, int m, int r, vector&lt;vector&lt;string&gt;&gt; &amp;res) &#123; static vector&lt;string&gt; ans; if (p &gt;= n) &#123; res.push_back(ans); return ; &#125; int mask = l | m | r; for (int i = 0, b = 1; i &lt; n; ++ i, b &lt;&lt;= 1) if (!(mask &amp; b)) &#123; ans.push_back(getNq(i)); nQueens(p + 1, (l | b) &gt;&gt; 1, m | b, (r | b) &lt;&lt; 1, res); ans.pop_back(); &#125; &#125;public: vector&lt;vector&lt;string&gt; &gt; solveNQueens(int n) &#123; this-&gt;n = n; vector&lt;vector&lt;string&gt;&gt; res; nQueens(0, 0, 0, 0, res); return res; &#125;&#125;; python 108ms, 77.32%, June.16th, 2016 https://leetcode.com/discuss/49179/fast-short-and-easy-understand-python-solution-11-lines-76ms Fast, short, and easy-to-understand python solution, 11 lines, 76ms ideas: Use the DFS helper function to find solutions recursively. A solution will be found when the length of queens is equal to n ( queens is a list of the indices of the queens). In this problem, whenever a location (x, y) is occupied, any other locations (p, q ) where p + q == x + y or p - q == x - y would be invalid. We can use this information to keep track of the indicators (xy_dif and xy_sum ) of the invalid positions and then call DFS recursively with valid positions only. At the end, we convert the result (a list of lists; each sublist is the indices of the queens) into the desire format. 123456789101112def solveNQueens(self, n): def DFS(queens, xy_dif, xy_sum): p = len(queens) if p==n: result.append(queens) return None for q in range(n): if q not in queens and p-q not in xy_dif and p+q not in xy_sum: DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q]) result = [] DFS([],[],[]) return [ [&quot;.&quot;*i + &quot;Q&quot; + &quot;.&quot;*(n-i-1) for i in sol] for sol in result] https://discuss.leetcode.com/topic/9445/14-lines-python-code-dfs-solution 14 lines python code, DFS solution 1234567891011121314class Solution:# @return a list of lists of stringdef solveNQueens(self, n): stack, res = [[(0, i)] for i in range(n)], [] while stack: board = stack.pop() row = len(board) if row == n: res.append([&apos;&apos;.join(&apos;Q&apos; if i == c else &apos;.&apos; for i in range(n)) for r, c in board]) for col in range(n): if all(col != c and abs(row-r) != abs(col-c)for r, c in board): stack.append(board+[(row, col)]) return res https://discuss.leetcode.com/topic/22293/python-recursive-dfs-solution-with-comments Python recursive dfs solution with comments 123456789101112131415161718192021222324def solveNQueens(self, n): res = [] self.dfs([-1]*n, 0, [], res) return res # nums is a one-dimension array, like [1, 3, 0, 2] means# first queen is placed in column 1, second queen is placed# in column 3, etc.def dfs(self, nums, index, path, res): if index == len(nums): res.append(path) return # backtracking for i in xrange(len(nums)): nums[index] = i if self.valid(nums, index): # pruning tmp = &quot;.&quot;*len(nums) self.dfs(nums, index+1, path+[tmp[:i]+&quot;Q&quot;+tmp[i+1:]], res)# check whether nth queen can be placed in that columndef valid(self, nums, n): for i in xrange(n): if abs(nums[i]-nums[n]) == n -i or nums[i] == nums[n]: return False return True java https://discuss.leetcode.com/topic/8592/comparably-concise-java-code Comparably concise Java code Hi guys! I didn’t invent a wheel here. We just remember the busy columns and diagonals and recursively try to put the queen into the next row. But I think the code below is short enough to be reproduced in the interview. Hope it helps! 123456789101112131415161718192021222324252627public class Solution &#123; private void helper(int r, boolean[] cols, boolean[] d1, boolean[] d2, String[] board, List&lt;String[]&gt; res) &#123; if (r == board.length) res.add(board.clone()); else &#123; for (int c = 0; c &lt; board.length; c++) &#123; int id1 = r - c + board.length, id2 = 2*board.length - r - c - 1; if (!cols[c] &amp;&amp; !d1[id1] &amp;&amp; !d2[id2]) &#123; char[] row = new char[board.length]; Arrays.fill(row, &apos;.&apos;); row[c] = &apos;Q&apos;; board[r] = new String(row); cols[c] = true; d1[id1] = true; d2[id2] = true; helper(r+1, cols, d1, d2, board, res); cols[c] = false; d1[id1] = false; d2[id2] = false; &#125; &#125; &#125; &#125; public List&lt;String[]&gt; solveNQueens(int n) &#123; List&lt;String[]&gt; res = new ArrayList&lt;&gt;(); helper(0, new boolean[n], new boolean[2*n], new boolean[2*n], new String[n], res); return res; &#125;&#125; https://discuss.leetcode.com/topic/19470/my-easy-understanding-java-solution My easy understanding Java Solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; char[][] board = new char[n][n]; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) board[i][j] = &apos;.&apos;; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); dfs(board, 0, res); return res; &#125; private void dfs(char[][] board, int colIndex, List&lt;List&lt;String&gt;&gt; res) &#123; if(colIndex == board.length) &#123; res.add(construct(board)); return; &#125; for(int i = 0; i &lt; board.length; i++) &#123; if(validate(board, i, colIndex)) &#123; board[i][colIndex] = &apos;Q&apos;; dfs(board, colIndex + 1, res); board[i][colIndex] = &apos;.&apos;; &#125; &#125; &#125; private boolean validate(char[][] board, int x, int y) &#123; for(int i = 0; i &lt; board.length; i++) &#123; for(int j = 0; j &lt; y; j++) &#123; if(board[i][j] == &apos;Q&apos; &amp;&amp; (x + j == y + i || x + y == i + j || x == i)) return false; &#125; &#125; return true; &#125; private List&lt;String&gt; construct(char[][] board) &#123; List&lt;String&gt; res = new LinkedList&lt;String&gt;(); for(int i = 0; i &lt; board.length; i++) &#123; String s = new String(board[i]); res.add(s); &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/24329/share-my-java-dfs-solution-very-easy-to-understand Share my JAVA DFS solution very easy to understand 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; private Set&lt;Integer&gt; col = new HashSet&lt;Integer&gt;(); private Set&lt;Integer&gt; diag1 = new HashSet&lt;Integer&gt;(); private Set&lt;Integer&gt; diag2 = new HashSet&lt;Integer&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); dfs(res,new ArrayList&lt;String&gt;(), 0, n); return res; &#125; private void dfs(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; list, int row, int n)&#123; if (row == n)&#123; res.add(new ArrayList&lt;String&gt;(list)); return; &#125; for (int i = 0; i &lt; n; i++)&#123; if (col.contains(i) || diag1.contains(row + i) || diag2.contains(row - i)) continue; char[] charArray = new char[n]; Arrays.fill(charArray, &apos;.&apos;); charArray[i] = &apos;Q&apos;; String rowString = new String(charArray); list.add(rowString); col.add(i); diag1.add(row + i); diag2.add(row - i); dfs(res, list, row + 1, n); list.remove(list.size() - 1); col.remove(i); diag1.remove(row + i); diag2.remove(row - i); &#125; &#125;&#125; https://discuss.leetcode.com/topic/40881/93-concise-fast-and-clear-java-solution 93% concise, fast, and clear java solution The code has comment. 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; boolean[] //ocp0 = new boolean[n], //whether there&apos;s a queen ocupying nth row, I don&apos;t need it ocp90 = new boolean[n], //whether there&apos;s a queen ocupying nth column ocp45 = new boolean[2 * n - 1], // mark 45 degree occupation ocp135 = new boolean[2 * n - 1]; // mark 135 degree occupation List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;List&lt;String&gt;&gt;(); char[][] map = new char[n][n]; for (char[] tmp : map) Arrays.fill(tmp, &apos;.&apos;); //init solve(0, n, map, ans, ocp45, ocp90, ocp135); return ans; &#125; private void solve(int depth, int n, char[][] map, List&lt;List&lt;String&gt;&gt; ans, boolean[] ocp45, boolean[] ocp90, boolean[] ocp135) &#123; if (depth == n) &#123; addSolution(ans, map); return; &#125; for (int j = 0; j &lt; n; j++) if (!ocp90[j] &amp;&amp; !ocp45[depth + j] &amp;&amp; !ocp135[j - depth + n - 1]) &#123; ocp90[j] = true; ocp45[depth + j] = true; ocp135[j - depth + n - 1] = true; map[depth][j] = &apos;Q&apos;; solve(depth + 1, n, map, ans, ocp45, ocp90, ocp135); ocp90[j] = false; ocp45[depth + j] = false; ocp135[j - depth + n - 1] = false; map[depth][j] = &apos;.&apos;; &#125; &#125; private void addSolution(List&lt;List&lt;String&gt;&gt; ans, char[][] map) &#123; List&lt;String&gt; cur = new ArrayList&lt;String&gt;(); for (char[] i : map) cur.add(String.valueOf(i)); ans.add(cur); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[050. Pow(x, n)]]></title>
    <url>%2Fp%2Ff4cb4bf8%2F</url>
    <content type="text"><![CDATA[26.3% https://leetcode.com/problems/powx-n/ Implement pow(x, n). 解法如下： https://discuss.leetcode.com/topic/21837/5-different-choices-when-talk-with-interviewers After reading some good sharing solutions, I’d like to show them together. You can see different ideas in the code. nest myPow 1234567double myPow(double x, int n) &#123; if(n&lt;0) return 1/x * myPow(1/x, -(n+1)); if(n==0) return 1; if(n==2) return x*x; if(n%2==0) return myPow( myPow(x, n/2), 2); else return x*myPow( myPow(x, n/2), 2);&#125; double myPow 123456double myPow(double x, int n) &#123; if(n==0) return 1; double t = myPow(x,n/2); if(n%2) return n&lt;0 ? 1/x*t*t : x*t*t; else return t*t;&#125; double x 12345678double myPow(double x, int n) &#123; if(n==0) return 1; if(n&lt;0)&#123; n = -n; x = 1/x; &#125; return n%2==0 ? myPow(x*x, n/2) : x*myPow(x*x, n/2);&#125; iterative one 1234567891011121314double myPow(double x, int n) &#123; if(n==0) return 1; if(n&lt;0) &#123; n = -n; x = 1/x; &#125; double ans = 1; while(n&gt;0)&#123; if(n&amp;1) ans *= x; x *= x; n &gt;&gt;= 1; &#125; return ans;&#125; bit operation https://discuss.leetcode.com/topic/3636/my-answer-using-bit-operation-c-implementation In bit format and for a unsigned number, the number is represented as k02^0 + k12^1 + … +k31 2 ^31. Therefore, once we know the pow(x,2^0), pow(x,2^1), …, pow(x,2^31), we can get pow(x,n). And pow(x,2 ^ m) can be constructed easily as pow(x,2^m) = pow(x,2^(m-1)) pow(x,2^(m-1)). 123456789101112131415161718192021class Solution &#123;public: double pow(double x, int n) &#123; if(n&lt;0)&#123; x = 1.0/x; n = -n; &#125; int unsigned m = n; double tbl[32] = &#123;0&#125;; double result = 1; tbl[0] = x; for(int i=1;i&lt;32;i++)&#123; tbl[i] = tbl[i-1]*tbl[i-1]; &#125; for(int i=0;i&lt;32;i++)&#123; if( m &amp; (0x1&lt;&lt;i) ) result *= tbl[i]; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/17832/non-recursive-c-log-n-solution 1234567891011121314151617181920class Solution &#123;public: double myPow(double x, int n) &#123; double ans = 1; unsigned long long p; if (n &lt; 0) &#123; p = -n; x = 1 / x; &#125; else &#123; p = n; &#125; while (p) &#123; if (p &amp; 1) ans *= x; x *= x; p &gt;&gt;= 1; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/10572/8-lines-of-c-7-ms 123456789double pow(double x, int n) &#123; if (n==0) return 1; double t = pow(x,n/2); if (n%2) &#123; return n&lt;0 ? 1/x*t*t : x*t*t; &#125; else &#123; return t*t; &#125;&#125; python https://discuss.leetcode.com/topic/15630/shortest-python-guaranteed Surprisingly, I can just use Python’s existing pow like this: 12class Solution: myPow = pow That’s even shorter than the other more obvious “cheat”: 123class Solution: def myPow(self, x, n): return x ** n And to calm down the haters, here’s me “doing it myself”: Recursive: 123456789class Solution: def myPow(self, x, n): if not n: return 1 if n &lt; 0: return 1 / self.myPow(x, -n) if n % 2: return x * self.myPow(x, n-1) return self.myPow(x*x, n/2) Iterative: 123456789101112class Solution: def myPow(self, x, n): if n &lt; 0: x = 1 / x n = -n pow = 1 while n: if n &amp; 1: pow *= x x *= x n &gt;&gt;= 1 return pow java https://discuss.leetcode.com/topic/5425/short-and-easy-to-understand-solution 1234567891011public class Solution &#123; public double pow(double x, int n) &#123; if(n == 0) return 1; if(n&lt;0)&#123; n = -n; x = 1/x; &#125; return (n%2 == 0) ? pow(x*x, n/2) : x*pow(x*x, n/2); &#125;&#125; https://discuss.leetcode.com/topic/2836/o-logn-solution-in-java /* This is a simple solution based on divide and conquer */ 1234567891011121314151617public class Solution &#123; public double pow(double x, int m) &#123; double temp=x; if(m==0) return 1; temp=pow(x,m/2); if(m%2==0) return temp*temp; else &#123; if(m &gt; 0) return x*temp*temp; else return (temp*temp)/x; &#125; &#125; https://discuss.leetcode.com/topic/40546/iterative-log-n-solution-with-clear-explanation I couldn’t find a clear explanation for an interative Log(n) solution so here’s mine. The basic idea is to decompose the exponent into powers of 2, so that you can keep dividing the problem in half. For example, lets say N = 9 = 2^3 + 2^0 = 1001 in binary. Then: x^9 = x ^ (2 ^ 3) * x ^ (2 ^ 0) We can see that every time we encounter a 1 in the binary representation of N, we need to multiply the answer with x^(2^i) where i is the ith bit of the exponent. Thus, we can keep a running total of repeatedly squaring x - (x, x^2, x^4, x^8, etc) and multiply it by the answer when we see a 1. To handle the case where N=INTEGER_MIN we use a long (64-bit) variable. Below is solution: 123456789101112public class Solution &#123; public double MyPow(double x, int n) &#123; double ans = 1; long absN = Math.Abs((long)n); while(absN &gt; 0) &#123; if((absN&amp;1)==1) ans *= x; absN &gt;&gt;= 1; x *= x; &#125; return n &lt; 0 ? 1/ans : ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[049. Group Anagrams]]></title>
    <url>%2Fp%2F6810cb45%2F</url>
    <content type="text"><![CDATA[35.2% https://leetcode.com/problems/group-anagrams/description/ Given an array of strings, group anagrams together. 12345678For example, given: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;], Return:[ [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lower-case. 方法一： 排序号的str作为key，相应的队伍作为value的vector，然后map迭代器把这些都合并就可以了。 我的代码实现： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; vector&lt;vector&lt;string&gt;&gt; res; // 用vector&lt;string&gt; 而不是vector&lt;string&gt;() // 使用排序好string作为key unordered_map&lt;string, vector&lt;string&gt;&gt; map; for(auto str: strs)&#123; string key = helper(str); // 不管有没有key，都push_back map[key].push_back(str); &#125; // 学习map的迭代器的使用 for(auto it=map.begin(); it!=map.end(); it++)&#123; res.push_back(it-&gt;second); &#125; return res; &#125; string helper(string s)&#123; if(s.empty()) return s; int n = s.size(); vector&lt;int&gt; cnt(26, 0); for(int i=0; i&lt;n; i++) cnt[s[i]-'a']++; string t(n, 'a'); int p = 0; for(int i=0; i&lt;26; i++)&#123; for(int j=0; j&lt;cnt[i]; j++)&#123; t[p++] += i; &#125; &#125; return t; &#125;&#125;; https://discuss.leetcode.com/topic/307/what-does-it-mean-return-all-groups-but-the-return-result-is-vector-string-how-can-we-return-all-groups What does it mean “return all groups”? But the return result is vector? How can we return all groups? What does it mean “return all groups”? But the return result is vector? How can we return all groups? I mean, for example, we have such vector [“dog”,”cat”,”god”,”tac”]. What should I return? https://discuss.leetcode.com/topic/307/what-does-it-mean-return-all-groups-but-the-return-result-is-vector-string-how-can-we-return-all-groups/2 1337c0d3rReputation: 1,607UPDATE: The return type had been changed to a list of list to avoid confusion. An example would be [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”], return: 12345[ [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note that even a single word is included as a group containing a single element. And here is the original old post: It means return all group of anagrams being flatten into one single list. For the input [“dog”,”cat”,”god”,”tac”], it should return: [“dog”,”cat”,”god”,”tac”], as dog and god are one group of anagrams, and cat and tac are another group of anagrams. I will probably change the return format to a more intuitive manner sometime in the future, such as: 1234[ [&quot;dog&quot;, &quot;god&quot;], [&quot;cat&quot;, &quot;tac&quot;]] Until this change happens, you will have to deal with the slightly confusing way of returning a flatten list, which should not affect the algorithm itself. https://discuss.leetcode.com/topic/8269/why-not-list-of-list-of-strings-as-output Why not list of list of strings as output? Why the output is list and not a list of list. What If there are multiple groups of anagrams? cpp 68ms, 79.37%, September 21, 2016 https://discuss.leetcode.com/topic/21038/10-lines-76ms-easy-c-solution-updated-function-signature 10-lines 76ms Easy C++ Solution (Updated Function Signature) The function signature has been updated to return a more intuitive vector&lt;vector&gt; which treats a single string as a group of anagrams consisting of only itself. The idea is to use an unordered_map to store those strings that are anagrams. We use the sorted string as the key and the string itself as the value. The strings are stored in a multiset since there may be duplicates. Moreover, multiset will sort them by default as we desire. The code is as follows. 1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, multiset&lt;string&gt;&gt; mp; for (string s : strs) &#123; string t = s; sort(t.begin(), t.end()); mp[t].insert(s); &#125; vector&lt;vector&lt;string&gt;&gt; anagrams; for (auto m : mp) &#123; vector&lt;string&gt; anagram(m.second.begin(), m.second.end()); anagrams.push_back(anagram); &#125; return anagrams; &#125;&#125;; Update: as suggested by yswu1234 in the answer, general sort takes O(nlogn) time. In this problem, since the string only contains lower-case alphabets, we can write a sorting function using counting sort (O(n) time) to speed up the sorting process. I write a string sorting function strSort below and using it to sort the string achieves the overall running time 72ms for this problem. 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, multiset&lt;string&gt;&gt; mp; for (string s : strs) &#123; string t = strSort(s); mp[t].insert(s); &#125; vector&lt;vector&lt;string&gt;&gt; anagrams; for (auto m : mp) &#123; vector&lt;string&gt; anagram(m.second.begin(), m.second.end()); anagrams.push_back(anagram); &#125; return anagrams; &#125;private: string strSort(string&amp; s) &#123; int count[26] = &#123;0&#125;, n = s.length(); for (int i = 0; i &lt; n; i++) count[s[i] - &apos;a&apos;]++; int p = 0; string t(n, &apos;a&apos;); for (int j = 0; j &lt; 26; j++) for (int i = 0; i &lt; count[j]; i++) t[p++] += j; return t; &#125; &#125;; https://discuss.leetcode.com/topic/6053/sharing-my-very-concise-solution-with-explanation Sharing my very concise solution with explanation 1234567891011121314151617vector&lt;string&gt; anagrams(vector&lt;string&gt; &amp;strs) &#123; vector&lt;string&gt; result; vector&lt;string&gt; sortedStrs = strs; unordered_map&lt;string, vector&lt;int&gt;&gt; map; for(int i = 0; i &lt; strs.size(); i++)&#123; sort(sortedStrs[i].begin(), sortedStrs[i].end()); map[sortedStrs[i]].push_back(i); &#125; for(auto it = map.begin(); it != map.end(); it++)&#123; if(it-&gt;second.size() &gt; 1)&#123; for(int i = 0; i &lt; it-&gt;second.size(); i++)&#123; result.push_back(strs[it-&gt;second[i]]); &#125; &#125; &#125; return result;&#125; Here is basic idea for this problem. First, get a copy of “strs”. Let’s name this copy “sortedStrs”. Second, sort all strings in “sortedStrs”. And we have a hash map unordered_map&lt;string, vector&gt; map. Every string in “sortedStrs” will be recorded in this hash map with its position. In the second loop, we traverse this hash map. And find each value of which size is larger than 1. Then find the original string in “strs”. Done. https://discuss.leetcode.com/topic/26074/a-clean-c-solution-with-unordered_map A clean c++ solution with unordered_map vector&lt;vector&gt; groupAnagrams(vector&amp; strs) { 1234567891011121314unordered_map&lt;string, vector&lt;string&gt;&gt; count; int i = 0; for (auto s : strs) &#123; sort(s.begin(), s.end()); count[s].push_back(strs[i++]); &#125; vector&lt;vector&lt;string&gt;&gt; res; for (auto n : count)&#123; sort(n.second.begin(), n.second.end()); res.push_back(n.second); &#125; return res;&#125; python https://discuss.leetcode.com/topic/3297/2-line-python-solution-ac-with-350ms-some-useful-python-tricks 2-line Python solution, AC with 350ms (some useful Python tricks) 123def anagrams(self, strs): count = collections.Counter([tuple(sorted(s)) for s in strs]) return filter(lambda x: count[tuple(sorted(x))]&gt;1, strs) collections.Counter creates a counter object. A counter object is like a specific kind of dictionary where it is build for counting (objects that hashes to same value) tuple(sorted(s)) is used here so that anagrams will be hashed to the same value. tuple is used because sorted returns a list which cannot be hashed but tuples can be hashed filter: selects some elements of the list based on given function (first argument - a lambda function is given here) lambda function defined here returns True if number of anagrams of that elements is greater than 1 https://discuss.leetcode.com/topic/3297/2-line-python-solution-ac-with-350ms-some-useful-python-tricks/2 Here is another python solution which is 4-line but a little more concise and faster (~ 20ms faster) 12345def anagrams(self, strs): d = collections.defaultdict(list) for s in strs: d[tuple(sorted(s))].append(s) return [a for agram_group in d.values() if len(agram_group)&gt;1 for a in agram_group] collection.defaultdict is used instead of Counter. It is almost same as dict but you can set default value (the value when item is not found in the dictionary) list comprehension is used in the return statement in order to select anagrams which have more than 1 word and also to flatten the d.values() which is list of lists https://discuss.leetcode.com/topic/21052/1-line-ruby-python-for-updated-problem 1 line Ruby/Python for Updated Problem The problem just got updated, now asking for different results. Here are some solutions for the new version. All of them use the sorted string as the group identifier, so for example the words “leetcoder” and “electrode” both have the group identifier “cdeeelort” (or rather an array version of it), which is how I know that they’re anagrams of each other. Python solution 1 Sort and group by group identifier, then sort each group normally. 12def groupAnagrams(self, strs): return [sorted(g) for _, g in itertools.groupby(sorted(strs, key=sorted), sorted)] Or “breaking it down” to maybe make it more readable for beginners and because I just noticed that in Firefox it violates my self-imposed “no scrollbars” rule (I usually use Chrome and didn’t think it differed): 123def groupAnagrams(self, strs): groups = itertools.groupby(sorted(strs, key=sorted), sorted) return [sorted(members) for _, members in groups] Python solution 2 Using defaultdict to collect the groups. 12345def groupAnagrams(self, strs): groups = collections.defaultdict(list) for s in strs: groups[tuple(sorted(s))].append(s) return map(sorted, groups.values()) java 46ms, 4.52%, September 21, 2016 https://discuss.leetcode.com/topic/24494/share-my-short-java-solution Share my short JAVA solution 123456789101112131415public class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; if(strs == null || strs.length == 0) return new ArrayList&lt;List&lt;String&gt;&gt;(); Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); Arrays.sort(strs); for(String s: strs)&#123; char[] ca = s.toCharArray(); Arrays.sort(ca); String keyStr = String.valueOf(ca); if(!map.containsKey(keyStr)) map.put(keyStr, new ArrayList&lt;String&gt;()); map.get(keyStr).add(s); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values()); &#125;&#125; https://discuss.leetcode.com/topic/45639/java-beat-100-use-prime-number Java beat 100%!!! use prime number 12345678910111213141516171819202122public static List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; int[] prime = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103&#125;;//最多10609个z List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (String s : strs) &#123; int key = 1; for (char c : s.toCharArray()) &#123; key *= prime[c - &apos;a&apos;]; &#125; List&lt;String&gt; t; if (map.containsKey(key)) &#123; t = res.get(map.get(key)); &#125; else &#123; t = new ArrayList&lt;&gt;(); res.add(t); map.put(key, res.size() - 1); &#125; t.add(s); &#125; return res; &#125; https://discuss.leetcode.com/topic/12509/o-m-n-algorithm-using-hash-without-sort O(M * N) algorithm using hash, without sort() Assign a prime number for a to z, and then multiply all prime numbers together to form a hash value. 123456789101112131415161718192021222324private static final int[] PRIMES = new int[]&#123;2, 3, 5, 7, 11 ,13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 107&#125;;public List&lt;String&gt; anagrams(String[] strs) &#123; List&lt;String&gt; list = new LinkedList&lt;&gt;(); Map&lt;Integer, List&lt;String&gt;&gt; mapString = new HashMap&lt;&gt;(); int result = -1; for (int i = 0; i &lt; strs.length; i++)&#123; int mapping = 1; for (int j = 0, max = strs[i].length(); j &lt; max; j++) &#123; mapping *= PRIMES[strs[i].charAt(j) - &apos;a&apos;]; &#125; List&lt;String&gt; strings = mapString.get(mapping); if (strings == null) &#123; strings = new LinkedList&lt;&gt;(); mapString.put(mapping, strings); &#125; strings.add(strs[i]); &#125; for (List&lt;String&gt; mapList : mapString.values())&#123; if (mapList.size() &gt; 1) list.addAll(mapList); &#125; return list;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>hash table</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[048. Rotate Image]]></title>
    <url>%2Fp%2Ff0ab6b95%2F</url>
    <content type="text"><![CDATA[38.5% https://leetcode.com/problems/rotate-image/ You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up: Could you do this in-place? 方法一： https://leetcode.com/discuss/20589/a-common-method-to-rotate-the-image 两次反转，一次上下反转，一次侧着反转 学习revers函数 reverse(matrix.begin(), matrix.end()); A common method to rotate the image here give a common method to solve the image rotation problems. 12345678910111213141516171819202122/* * clockwise rotate * first reverse up to down, then swap the symmetry * 1 2 3 7 8 9 7 4 1 * 4 5 6 =&gt; 4 5 6 =&gt; 8 5 2 * 7 8 9 1 2 3 9 6 3*/void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; reverse(matrix.begin(), matrix.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125;/* * anticlockwise rotate * first reverse left to right, then swap the symmetry * 1 2 3 3 2 1 3 6 9 * 4 5 6 =&gt; 6 5 4 =&gt; 2 5 8 * 7 8 9 9 8 7 1 4 7*/ 1234567void anti_rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; for (auto vi : matrix) reverse(vi.begin(), vi.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125; 我的代码实现： 12345678910111213141516171819class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix.size()==0 || matrix[0].size()==0) return; int n = matrix.size(); if(n==1) return; for(int i=0; i&lt;(n+1)/2; i++)&#123; for(int j=0; j&lt;n; j++)&#123; swap(matrix[i][j], matrix[n-1-i][j]); &#125; &#125; for(int i=0; i&lt;n; i++)&#123; for(int j=i+1; j&lt;n; j++) swap(matrix[i][j], matrix[j][i]); &#125; return; &#125;&#125;; cpp 6ms, 7.71%, June.17th, 2016 https://leetcode.com/discuss/20589/a-common-method-to-rotate-the-image A common method to rotate the image here give a common method to solve the image rotation problems. 12345678910111213141516171819202122/* * clockwise rotate * first reverse up to down, then swap the symmetry * 1 2 3 7 8 9 7 4 1 * 4 5 6 =&gt; 4 5 6 =&gt; 8 5 2 * 7 8 9 1 2 3 9 6 3*/void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; reverse(matrix.begin(), matrix.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125;/* * anticlockwise rotate * first reverse left to right, then swap the symmetry * 1 2 3 3 2 1 3 6 9 * 4 5 6 =&gt; 6 5 4 =&gt; 2 5 8 * 7 8 9 9 8 7 1 4 7*/ 1234567void anti_rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; for (auto vi : matrix) reverse(vi.begin(), vi.end()); for (int i = 0; i &lt; matrix.size(); ++i) &#123; for (int j = i + 1; j &lt; matrix[i].size(); ++j) swap(matrix[i][j], matrix[j][i]); &#125;&#125; https://discuss.leetcode.com/topic/20921/4ms-few-lines-c-code-rotate-image-90-degree-for-o-1-space 4ms few lines C++ code Rotate Image 90 degree for O(1) space 1234567891011121314void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); int a = 0; int b = n-1; while(a&lt;b)&#123; for(int i=0;i&lt;(b-a);++i)&#123; swap(matrix[a][a+i], matrix[a+i][b]); swap(matrix[a][a+i], matrix[b][b-i]); swap(matrix[a][a+i], matrix[b-i][a]); &#125; ++a; --b; &#125; &#125; https://discuss.leetcode.com/topic/17645/6-lines-of-code-and-with-o-1-space-in-c 6 lines of code and with O(1) space in c++ First we transpose the matrix and then reverse every row: 12345678910void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; m) &#123; int n = m.size(); for(int i=0; i&lt;n; i++) for(int j=0; j&lt;i; j++) swap(m[i][j], m[j][i]); for(int i=0; i&lt;n; i++) reverse(m[i].begin(), m[i].end()); &#125; https://discuss.leetcode.com/topic/5564/share-my-inplace-solution Share my inplace solution 123456789101112131415161718192021class Solution &#123;public: //fold for the middle, fold for the diagnal void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; //find middle int mid = matrix.size()/2; int n = matrix.size(); //swap, i swap with matrix.size()-1-i for(int i = 0; i &lt; mid; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; swap(matrix[i][j], matrix[n-1-i][j]); &#125; &#125; //swap, i,j swap with j,i for(int i = 0; i &lt; n; i++)&#123; for(int j = i; j &lt; n; j++)&#123; swap(matrix[i][j], matrix[j][i]); &#125; &#125; &#125;&#125;; Fold matrix once to the middle line. Fold matrix one more time along the diagonal line. python https://discuss.leetcode.com/topic/15295/seven-short-solutions-1-to-7-lines Seven Short Solutions (1 to 7 lines) While these solutions are Python, I think they’re understandable/interesting for non-Python coders as well. But before I begin: No mathematician would call a matrix matrix, so I’ll use the usual A. Also, btw, the 40 ms reached by two of the solutions is I think the fastest achieved by Python solutions so far. Most Pythonic - [::-1] and zip - 44 ms The most pythonic solution is a simple one-liner using [::-1] to flip the matrix upside down and then zip to transpose it. It assigns the result back into A, so it’s “in-place” in a sense and the OJ accepts it as such, though some people might not. 123class Solution: def rotate(self, A): A[:] = zip(*A[::-1]) Most Direct - 52 ms A 100% in-place solution. It even reads and writes each matrix element only once and doesn’t even use an extra temporary variable to hold them. It walks over the “top-left quadrant” of the matrix and directly rotates each element with the three corresponding elements in the other three quadrants. Note that I’m moving the four elements in parallel and that [~ i] is way nicer than [n-1-i]. 1234567class Solution: def rotate(self, A): n = len(A) for i in range(n/2): for j in range(n-n/2): A[i][j], A[~j][i], A[~i][~j], A[j][~i] = \ A[~j][i], A[~i][~j], A[j][~i], A[i][j] Clean Most Pythonic - 56 ms While the OJ accepts the above solution, the the result rows are actually tuples, not lists, so it’s a bit dirty. To fix this, we can just apply list to every row: 123class Solution: def rotate(self, A): A[:] = map(list, zip(*A[::-1])) List Comprehension - 60 ms If you don’t like zip, you can use a nested list comprehension instead: 123class Solution: def rotate(self, A): A[:] = [[row[i] for row in A[::-1]] for i in range(len(A))] Almost as Direct - 40 ms If you don’t like the little repetitive code of the above “Most Direct” solution, we can instead do each four-cycle of elements by using three swaps of just two elements. 12345678class Solution: def rotate(self, A): n = len(A) for i in range(n/2): for j in range(n-n/2): for _ in &apos;123&apos;: A[i][j], A[~j][i], i, j = A[~j][i], A[i][j], ~j, ~i i = ~j Flip Flip - 40 ms Basically the same as the first solution, but using reverse instead of [::-1] and transposing the matrix with loops instead of zip. It’s 100% in-place, just instead of only moving elements around, it also moves the rows around. 123456class Solution: def rotate(self, A): A.reverse() for i in range(len(A)): for j in range(i): A[i][j], A[j][i] = A[j][i], A[i][j] Flip Flip, all by myself - 48 ms Similar again, but I first transpose and then flip left-right instead of upside-down, and do it all by myself in loops. This one is 100% in-place again in the sense of just moving the elements. 123456789class Solution: def rotate(self, A): n = len(A) for i in range(n): for j in range(i): A[i][j], A[j][i] = A[j][i], A[i][j] for row in A: for j in range(n/2): row[j], row[~j] = row[~j], row[j] java 0ms, 26.51%, June.17th, 2016 https://leetcode.com/discuss/27262/java-in-place-solution-with-explanation-easy-to-understand AC Java in place solution with explanation Easy to understand. The idea was firstly transpose the matrix and then flip it symmetrically. For instance, 1231 2 3 4 5 67 8 9 after transpose, it will be swap(matrix[i][j], matrix[j][i]) 1231 4 72 5 83 6 9 Then flip the matrix horizontally. (swap(matrix[i][j], matrix[i][matrix.length-1-j]) 1237 4 18 5 29 6 3 Hope this helps. 1234567891011121314151617181920public class Solution &#123; public void rotate(int[][] matrix) &#123; for(int i = 0; i&lt;matrix.length; i++)&#123; for(int j = i; j&lt;matrix[0].length; j++)&#123; int temp = 0; temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125; for(int i =0 ; i&lt;matrix.length; i++)&#123; for(int j = 0; j&lt;matrix.length/2; j++)&#123; int temp = 0; temp = matrix[i][j]; matrix[i][j] = matrix[i][matrix.length-1-j]; matrix[i][matrix.length-1-j] = temp; &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/20212/clear-java-solution Clear Java solution 12345678910111213public class Solution &#123;public void rotate(int[][] matrix) &#123; int n=matrix.length; for (int i=0; i&lt;n/2; i++) for (int j=i; j&lt;n-i-1; j++) &#123; int tmp=matrix[i][j]; matrix[i][j]=matrix[n-j-1][i]; matrix[n-j-1][i]=matrix[n-i-1][n-j-1]; matrix[n-i-1][n-j-1]=matrix[j][n-i-1]; matrix[j][n-i-1]=tmp; &#125; &#125;&#125; https://discuss.leetcode.com/topic/25989/a-simple-and-in-place-solution-in-java A Simple and In-Place Solution in Java 123456789101112131415161718192021222324public void rotate(int[][] matrix) &#123; if (matrix == null || matrix.length &lt;= 1) &#123; return; &#125; int n = matrix.length; for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &lt; n; j++) &#123; int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; int head = 0; int tail = n - 1; while (head &lt; tail) &#123; int temp = matrix[i][head]; matrix[i][head] = matrix[i][tail]; matrix[i][tail] = temp; head++; tail--; &#125; &#125;&#125; For example, if the matrix is: 1 2 3 4 5 6 7 8 9 then after the first for loop, it becomes: 1 4 7 2 5 8 3 6 9 then after the second for loop, it becomes: 7 4 1 8 5 2 9 6 3]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[047. Permutations II]]></title>
    <url>%2Fp%2F94a736fc%2F</url>
    <content type="text"><![CDATA[32.8% https://leetcode.com/problems/permutations-ii/ Given a collection of numbers that might contain duplicates, return all possible unique permutations. 1234567891011For example,[1,1,2] have the following unique permutations:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 方法一： 123456789101112131415161718192021class Solution &#123;public: void recursion(vector&lt;int&gt; nums, int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp; res)&#123; if(i==j-1)&#123; res.push_back(nums); return; &#125; for(int k=i; k&lt;j; k++)&#123; if(i!=k &amp;&amp; nums[i] == nums[k]) continue; swap(nums[i], nums[k]); recursion(nums, i+1, j, res); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; recursion(nums, 0, nums.size(), res); return res; &#125;&#125;; 方法二： 此方法通不过，有疑问 错误样例 Input: [2,2,1,1] Output: [[1,1,2,2],[1,2,1,2],[1,2,2,1],[1,2,2,1],[1,2,1,2],[2,1,1,2],[2,1,2,1],[2,2,1,1],[2,1,2,1],[2,1,1,2],[2,2,1,1]] Expected: [[1,1,2,2],[1,2,1,2],[1,2,2,1],[2,1,1,2],[2,1,2,1],[2,2,1,1]] 12345678910111213141516171819202122class Solution &#123;public: void recursion(vector&lt;int&gt;&amp; nums, int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp; res)&#123; if(i==j-1)&#123; res.push_back(nums); return; &#125; for(int k=i; k&lt;j; k++)&#123; if(i!=k &amp;&amp; nums[i] == nums[k]) continue; swap(nums[i], nums[k]); recursion(nums, i+1, j, res); swap(nums[i], nums[k]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; recursion(nums, 0, nums.size(), res); return res; &#125;&#125;; cpp 23ms, 98.52%, September 21, 2016 https://discuss.leetcode.com/topic/8831/a-simple-c-solution-in-only-20-lines A simple C++ solution in only 20 lines 123456789101112131415161718192021class Solution &#123;public: void recursion(vector&lt;int&gt; nums, int i, int j, vector&lt;vector&lt;int&gt;&gt; &amp; res)&#123; if(i==j-1)&#123; res.push_back(nums); return; &#125; for(int k=i; k&lt;j; k++)&#123; if(i!=k &amp;&amp; nums[i] == nums[k]) continue; swap(nums[i], nums[k]); recursion(nums, i+1, j, res); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; recursion(nums, 0, nums.size(), res); return res; &#125;&#125;; https://discuss.leetcode.com/topic/3194/a-non-recursive-c-implementation-with-o-1-space-cost A non-recursive C++ implementation with O(1) space cost 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permuteUnique(vector&lt;int&gt; &amp;S) &#123; // res.clear(); sort(S.begin(), S.end()); res.push_back(S); int j; int i = S.size()-1; while (1)&#123; for (i=S.size()-1; i&gt;0; i--)&#123; if (S[i-1]&lt; S[i])&#123; break; &#125; &#125; if(i == 0)&#123; break; &#125; for (j=S.size()-1; j&gt;i-1; j--)&#123; if (S[j]&gt;S[i-1])&#123; break; &#125; &#125; swap(S[i-1], S[j]); reverse(S, i, S.size()-1); res.push_back(S); &#125; return res; &#125; void reverse(vector&lt;int&gt; &amp;S, int s, int e)&#123; while (s&lt;e)&#123; swap(S[s++], S[e--]); &#125; &#125; vector&lt;vector&lt;int&gt; &gt; res;&#125;; Basically, assume we have “1234”, the idea is to increase the number in ascending order, so next is “1243”, next is “1324”, and so on. python https://discuss.leetcode.com/topic/32976/9-line-python-solution-with-1-line-to-handle-duplication-beat-99-of-others 9-line python solution with 1 line to handle duplication, beat 99% of others :-) Very similar to Permutation I, see explanations in https://leetcode.com/discuss/19510/my-ac-simple-iterative-java-python-solution. To handle duplication, just avoid inserting a number before any of its duplicates. 12345678910def permuteUnique(self, nums): ans = [[]] for n in nums: new_ans = [] for l in ans: for i in xrange(len(l)+1): new_ans.append(l[:i]+[n]+l[i:]) if i&lt;len(l) and l[i]==n: break #handles duplication ans = new_ans return ans https://discuss.leetcode.com/topic/32976/9-line-python-solution-with-1-line-to-handle-duplication-beat-99-of-others/2 Nice one! Here’s an even shorter and I think faster implementation, though. Got it accepted in 100 ms, achieving the coveted “Your runtime beats 100.00% of python submissions.” (Well, I tried five times, they were 112, 104, 100, 104 and 116 ms). 1234567def permuteUnique(self, nums): ans = [[]] for n in nums: ans = [l[:i]+[n]+l[i:] for l in ans for i in xrange((l+[n]).index(n)+1)] return ans And for fun, a one-liner version: 12def permuteUnique(self, nums): return reduce(lambda a,n:[l[:i]+[n]+l[i:]for l in a for i in xrange((l+[n]).index(n)+1)],nums,[[]]) https://discuss.leetcode.com/topic/7667/iterative-python-solution-without-using-set-111ms Iterative Python solution without using set, 111ms Duplication happens when we insert the duplicated element before and after the same element, to eliminate duplicates, just insert only after the same element. 123456789101112131415def permuteUnique(self, num): if not num: return [] num.sort() ret = [[]] for n in num: new_ret = [] l = len(ret[-1]) for seq in ret: for i in range(l, -1, -1): if i &lt; l and seq[i] == n: break new_ret.append(seq[:i] + [n] + seq[i:]) ret = new_ret return ret java https://discuss.leetcode.com/topic/31445/really-easy-java-solution-much-easier-than-the-solutions-with-very-high-vote Really easy Java solution, much easier than the solutions with very high vote Use an extra boolean array “ boolean[] used” to indicate whether the value is added to list. Sort the array “int[] nums” to make sure we can skip the same value. when a number has the same value with its previous, we can use this number only if his previous is used 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(nums==null || nums.length==0) return res; boolean[] used = new boolean[nums.length]; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Arrays.sort(nums); dfs(nums, used, list, res); return res; &#125; public void dfs(int[] nums, boolean[] used, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res)&#123; if(list.size()==nums.length)&#123; res.add(new ArrayList&lt;Integer&gt;(list)); return; &#125; for(int i=0;i&lt;nums.length;i++)&#123; if(used[i]) continue; if(i&gt;0 &amp;&amp;nums[i-1]==nums[i] &amp;&amp; !used[i-1]) continue; used[i]=true; list.add(nums[i]); dfs(nums,used,list,res); used[i]=false; list.remove(list.size()-1); &#125; &#125;&#125; https://discuss.leetcode.com/topic/5993/share-my-recursive-solution Share my recursive solution 1234567891011121314151617181920212223242526272829public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] num) &#123; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; current = new ArrayList&lt;Integer&gt;(); boolean[] visited = new boolean[num.length]; permute(result, current, num, visited); return result; &#125; private void permute(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; current, int[] num, boolean[] visited) &#123; if (current.size() == num.length) &#123; result.add(new ArrayList&lt;Integer&gt;(current)); return; &#125; for (int i=0; i&lt;visited.length; i++) &#123; if (!visited[i]) &#123; if (i &gt; 0 &amp;&amp; num[i] == num[i-1] &amp;&amp; visited[i-1]) &#123; return; &#125; visited[i] = true; current.add(num[i]); permute(result, current, num, visited); current.remove(current.size()-1); visited[i] = false; &#125; &#125; &#125;&#125; The idea to resolve duplicate is to ensure that for elements with the same value, we make sure that they are picked up in the ascending order of index. To implement this, every time we try to pick up some value, we just check if the previous element has the same value and is visited or not. If so, we just return! https://discuss.leetcode.com/topic/36221/share-my-java-code-with-detailed-explanantion Share my Java code with detailed explanantion 12345678910111213141516171819202122232425262728293031public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if (nums==null || nums.length==0) &#123; return ans; &#125; permute(ans, nums, 0); return ans; &#125; private void permute(List&lt;List&lt;Integer&gt;&gt; ans, int[] nums, int index) &#123; if (index == nums.length) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for (int num: nums) &#123; temp.add(num); &#125; ans.add(temp); return; &#125; Set&lt;Integer&gt; appeared = new HashSet&lt;&gt;(); for (int i=index; i&lt;nums.length; ++i) &#123; if (appeared.add(nums[i])) &#123; swap(nums, index, i); permute(ans, nums, index+1); swap(nums, index, i); &#125; &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int save = nums[i]; nums[i] = nums[j]; nums[j] = save; &#125;&#125; https://discuss.leetcode.com/topic/12923/short-iterative-java-solution Short iterative Java solution Hi guys! Here’s an iterative solution which doesn’t use nextPermutation helper. It builds the permutations for i-1 first elements of an input array and tries to insert the ith element into all positions of each prebuilt i-1 permutation. I couldn’t come up with more effective controling of uniqueness than just using a Set. See the code below! 12345678910111213141516171819public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] num) &#123; LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); res.add(new ArrayList&lt;&gt;()); for (int i = 0; i &lt; num.length; i++) &#123; Set&lt;String&gt; cache = new HashSet&lt;&gt;(); while (res.peekFirst().size() == i) &#123; List&lt;Integer&gt; l = res.removeFirst(); for (int j = 0; j &lt;= l.size(); j++) &#123; List&lt;Integer&gt; newL = new ArrayList&lt;&gt;(l.subList(0,j)); newL.add(num[i]); newL.addAll(l.subList(j,l.size())); if (cache.add(newL.toString())) res.add(newL); &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[046. Permutations]]></title>
    <url>%2Fp%2Fc83ab0f7%2F</url>
    <content type="text"><![CDATA[42.0% https://leetcode.com/problems/permutations/ Given a collection of distinct numbers, return all possible permutations. 12345678910For example,[1,2,3] have the following permutations:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 方法一：标准的回溯法 剑指offer 28 我的代码实现: 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; dfs(nums, res, 0); return res; &#125; void dfs(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; res, int k)&#123; if(k==nums.size()-1)&#123; res.push_back(nums); return; &#125; for(int i=k; i&lt;nums.size(); i++)&#123; swap(nums[k], nums[i]); dfs(nums, res, k+1); swap(nums[k], nums[i]); &#125; &#125;&#125;; 注意，倒数第三行，参数是begin+1, 不是i+1. permuteRecursive(nums, begin, result); 代表nums中0至begin-1已经排好序了，剩下的是begin至n-1 n = nums.size()-1 所以当begin = n时，则push进去。 然后，begin未排好，从begin开始，begin与后面的都交换一遍 每次交换后，调用permuteRecurive(nums, begin+1, res); 所以逻辑是很清晰的了。 My elegant recursive C++ solution with inline explanation This recursive solution is the my first response for this problem. I was surprised when I found no similar solution posted here. It is much easier to understand than DFS-based ones, at least in my opinion. Please find more explanations here. All comments are welcome. 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; result; permuteRecursive(num, 0, result); return result; &#125; // permute num[begin..end] // invariant: num[0..begin-1] have been fixed/permuted void permuteRecursive(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;result) &#123; if (begin &gt;= num.size()) &#123; // one permutation instance result.push_back(num); return; &#125; for (int i = begin; i &lt; num.size(); i++) &#123; swap(num[begin], num[i]); permuteRecursive(num, begin + 1, result); // reset swap(num[begin], num[i]); &#125; &#125;&#125;; 我的实现 经典回溯法 思考清楚过程 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;vector&lt;int&gt;&gt; res; helper(nums, 0, n, res); return res; &#125; void helper(vector&lt;int&gt;&amp; nums, int k, int n, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(k==n)&#123; res.push_back(nums); return; &#125; for(int i=k; i&lt;n; i++)&#123; swap(nums[k], nums[i]); helper(nums, k+1, n, res); // 此处变为k+1，不是i+1 swap(nums[k], nums[i]); &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/5881/my-elegant-recursive-c-solution-with-inline-explanation My elegant recursive C++ solution with inline explanation This recursive solution is the my first response for this problem. I was surprised when I found no similar solution posted here. It is much easier to understand than DFS-based ones, at least in my opinion. Please find more explanations here. All comments are welcome. 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; result; permuteRecursive(num, 0, result); return result; &#125; // permute num[begin..end] // invariant: num[0..begin-1] have been fixed/permuted void permuteRecursive(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;result) &#123; if (begin &gt;= num.size()) &#123; // one permutation instance result.push_back(num); return; &#125; for (int i = begin; i &lt; num.size(); i++) &#123; swap(num[begin], num[i]); permuteRecursive(num, begin + 1, result); // reset swap(num[begin], num[i]); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/6740/share-my-three-different-solutions Share my three different solutions 1234567891011121314151617181920// method 1: standard backtracing solutionvector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; ans; permutation(num, 0, ans); return ans;&#125;void permutation(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;ans) &#123; if (begin &gt;= num.size()) &#123; ans.push_back(num); return; &#125; // every number chosen to be the begin once for (int i = begin; i &lt; num.size(); ++i) &#123; swap(num[begin], num[i]); permutation(num, begin+1, ans); swap(num[begin], num[i]); &#125;&#125; 12345678910// method 2: using next_permutation to iterate all the permutaionsvector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; ans; sort(num.begin(), num.end()); ans.push_back(num); while(next_permutation(num.begin(), num.end())) ans.push_back(num); return ans;&#125; 12345678910111213141516171819202122232425262728// method 3: recursive dfsvector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; ans; dfs(num, ans); return ans;&#125;void dfs(vector&lt;int&gt; &amp;num, vector&lt;vector&lt;int&gt;&gt; &amp;ans) &#123; if (num.size() == 1) &#123; vector&lt;int&gt; tmp(num.begin(), num.end()); ans.push_back(tmp); return; &#125; vector&lt;vector&lt;int&gt; &gt; ans1; vector&lt;int&gt; num1(num.begin()+1, num.end()); dfs(num1, ans); for(int i = 0; i &lt; ans.size(); ++i) &#123; for(int j = 0; j &lt;= ans[i].size(); ++j) &#123; vector&lt;int&gt; tmp = ans[i]; tmp.insert(tmp.begin()+j, num[0]); ans1.push_back(tmp); &#125; &#125; ans = ans1;&#125; 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; result; permuteRecursive(num, 0, result); return result; &#125; // permute num[begin..end] // invariant: num[0..begin-1] have been fixed/permuted void permuteRecursive(vector&lt;int&gt; &amp;num, int begin, vector&lt;vector&lt;int&gt; &gt; &amp;result) &#123; if (begin &gt;= num.size()) &#123; // one permutation instance result.push_back(num); return; &#125; for (int i = begin; i &lt; num.size(); i++) &#123; swap(num[begin], num[i]); permuteRecursive(num, begin + 1, result); // reset swap(num[begin], num[i]); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/17277/one-liners-in-python One-Liners in Python Solution 1: Recursive, take any number as first Take any number as the first number and append any permutation of the other numbers. 1234def permute(self, nums): return [[n] + p for i, n in enumerate(nums) for p in self.permute(nums[:i] + nums[i+1:])] or [[]] Solution 2: Recursive, insert first number anywhere Insert the first number anywhere in any permutation of the remaining numbers. 1234def permute(self, nums): return nums and [p[:i] + [nums[0]] + p[i:] for p in self.permute(nums[1:]) for i in range(len(nums))] or [[]] Solution 3: Reduce, insert next number anywhere Use reduce to insert the next number anywhere in the already built permutations. 1234def permute(self, nums): return reduce(lambda P, n: [p[:i] + [n] + p[i:] for p in P for i in range(len(p)+1)], nums, [[]]) Solution 4: Using the library 12def permute(self, nums): return list(itertools.permutations(nums)) That returns a list of tuples, but the OJ accepts it anyway. If needed, I could easily turn it into a list of lists: 12def permute(self, nums): return map(list, itertools.permutations(nums)) 76ms, 93.03%, June.17th, 2016 https://leetcode.com/discuss/51398/simple-python-solution-dfs 12345678910111213141516class Solution(object): def permute(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; res = [] self.dfs(nums, [], res) return res def dfs(self, nums, path, res): if not nums: res.append(path) else: for i in xrange(len(nums)): self.dfs(nums[:i] + nums[i+1:], path+[nums[i]], res) java https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partioning) This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. Subsets : https://leetcode.com/problems/subsets/ 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Subsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Permutations : https://leetcode.com/problems/permutations/ 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/ 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum : https://leetcode.com/problems/combination-sum/ 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum II (can’t reuse same element) : https://leetcode.com/problems/combination-sum-ii/ 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Palindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/ 12345678910111213141516171819202122232425public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list;&#125;public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125;&#125;public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true;&#125; https://discuss.leetcode.com/topic/6377/my-ac-simple-iterative-java-python-solution 123456789My AC simple iterative java/python solutionthe basic idea is, to permute n numbers, we can add the nth number into the resulting List&lt;List&lt;Integer&gt;&gt; from the n-1 numbers, in every possible position.For example, if the input num[] is &#123;1,2,3&#125;: First, add 1 into the initial List&lt;List&lt;Integer&gt;&gt; (let&apos;s call it &quot;answer&quot;).Then, 2 can be added in front or after 1. So we have to copy the List&lt;Integer&gt; in answer (it&apos;s just &#123;1&#125;), add 2 in position 0 of &#123;1&#125;, then copy the original &#123;1&#125; again, and add 2 in position 1. Now we have an answer of &#123;&#123;2,1&#125;,&#123;1,2&#125;&#125;. There are 2 lists in the current answer.Then we have to add 3. first copy &#123;2,1&#125; and &#123;1,2&#125;, add 3 in position 0; then copy &#123;2,1&#125; and &#123;1,2&#125;, and add 3 into position 1, then do the same thing for position 3. Finally we have 2\*3=6 lists in answer, which is what we want. 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (num.length ==0) return ans; List&lt;Integer&gt; l0 = new ArrayList&lt;Integer&gt;(); l0.add(num[0]); ans.add(l0); for (int i = 1; i&lt; num.length; ++i)&#123; List&lt;List&lt;Integer&gt;&gt; new_ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for (int j = 0; j&lt;=i; ++j)&#123; for (List&lt;Integer&gt; l : ans)&#123; List&lt;Integer&gt; new_l = new ArrayList&lt;Integer&gt;(l); new_l.add(j,num[i]); new_ans.add(new_l); &#125; &#125; ans = new_ans; &#125; return ans;&#125; python version is more concise: 123456789def permute(self, nums): perms = [[]] for n in nums: new_perms = [] for perm in perms: for i in xrange(len(perm)+1): new_perms.append(perm[:i] + [n] + perm[i:]) ###insert n perms = new_perms return perms https://discuss.leetcode.com/topic/10812/share-my-short-iterative-java-solution Share my short iterative JAVA solution 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; permute(int[] num) &#123; LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;List&lt;Integer&gt;&gt;(); res.add(new ArrayList&lt;Integer&gt;()); for (int n : num) &#123; int size = res.size(); for (; size &gt; 0; size--) &#123; List&lt;Integer&gt; r = res.pollFirst(); for (int i = 0; i &lt;= r.size(); i++) &#123; List&lt;Integer&gt; t = new ArrayList&lt;Integer&gt;(r); t.add(i, n); res.add(t); &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/23036/java-clean-code-two-recursive-solutions Java Clean Code - Two recursive solutions Bottom up? approach - 280ms 1234567891011121314151617181920212223242526public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; permutations = new ArrayList&lt;&gt;(); if (nums.length == 0) &#123; return permutations; &#125; collectPermutations(nums, 0, new ArrayList&lt;&gt;(), permutations); return permutations; &#125; private void collectPermutations(int[] nums, int start, List&lt;Integer&gt; permutation, List&lt;List&lt;Integer&gt;&gt; permutations) &#123; if (permutation.size() == nums.length) &#123; permutations.add(permutation); return; &#125; for (int i = 0; i &lt;= permutation.size(); i++) &#123; List&lt;Integer&gt; newPermutation = new ArrayList&lt;&gt;(permutation); newPermutation.add(i, nums[start]); collectPermutations(nums, start + 1, newPermutation, permutations); &#125; &#125;&#125; Code flow 123456789101112131415nums = 1,2,3start = 0, permutation = []i = 0, newPermutation = [1] start = 1, permutation = [1] i = 0, newPermutation = [2, 1] start = 2, permutation = [2, 1] i = 0, newPermutation = [3, 2, 1] i = 1, newPermutation = [2, 3, 1] i = 2, newPermutation = [2, 1, 3] i = 1, newPermutation = [1, 2] start = 2, permutation = [1, 2] i = 0, newPermutation = [3, 1, 2] i = 1, newPermutation = [1, 3, 2] i = 2, newPermutation = [1, 2, 3] Base case and build approach - 524ms 1234567891011121314151617181920212223242526272829public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; return permute(Arrays.stream(nums).boxed().collect(Collectors.toList())); &#125; private List&lt;List&lt;Integer&gt;&gt; permute(List&lt;Integer&gt; nums) &#123; List&lt;List&lt;Integer&gt;&gt; permutations = new ArrayList&lt;&gt;(); if (nums.size() == 0) &#123; return permutations; &#125; if (nums.size() == 1) &#123; List&lt;Integer&gt; permutation = new ArrayList&lt;&gt;(); permutation.add(nums.get(0)); permutations.add(permutation); return permutations; &#125; List&lt;List&lt;Integer&gt;&gt; smallPermutations = permute(nums.subList(1, nums.size())); int first = nums.get(0); for(List&lt;Integer&gt; permutation : smallPermutations) &#123; for (int i = 0; i &lt;= permutation.size(); i++) &#123; List&lt;Integer&gt; newPermutation = new ArrayList&lt;&gt;(permutation); newPermutation.add(i, first); permutations.add(newPermutation); &#125; &#125; return permutations; &#125;&#125; Code flow 12345678910111213141516171819nums = 1,2,3smallPermutations(2, 3) smallPermutations(3) return [[3]] first = 2 permutation = [3] i = 0, newPermutation = [2, 3] i = 1, newPermutation = [3, 2] return [[2, 3], [3, 2]]first = 1 permutation = [2, 3] i = 0, newPermutation = [1, 2, 3] i = 1, newPermutation = [2, 1, 3] i = 2, newPermutation = [2, 3, 1] permutation = [3, 2] i = 0, newPermutation = [1, 3, 2] i = 1, newPermutation = [3, 1, 2] i = 2, newPermutation = [3, 2, 1] 回溯法 https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning1234567891011121314151617181920public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), nums); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] nums)&#123; if(tempList.size() == nums.length) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i=0; i&lt;nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size()-1); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[045. Jump Game II]]></title>
    <url>%2Fp%2Fded0cd97%2F</url>
    <content type="text"><![CDATA[26.2% https://leetcode.com/problems/jump-game-ii/ Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. 123456For example:Given array A = [2,3,1,1,4]The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.) Note: You can assume that you can always reach the last index. 方法一： 我的代码： lastJump，表示经过上一步之后，所能到达最远的点。 nextJump是step++之后，新的一段，能走的最远的点。 1234567891011121314151617class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==1) return 0; int lastJump = 0; int nextJump = 0; int step = 0; for(int i=0; i&lt;nums.size()-1; i++)&#123; nextJump = max(nextJump, i+nums[i]); if(lastJump == i)&#123; step++; lastJump = nextJump; &#125; &#125; return step; &#125;&#125;; my code 12345678910111213141516class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int step = 0; int e = 0; int ma = 0; for(int i=0; i&lt;nums.size()-1; i++)&#123; ma = max(i+nums[i], ma); if(i==e)&#123; step++; e = ma; &#125; &#125; return step; &#125;&#125;; cpp https://discuss.leetcode.com/topic/3191/o-n-bfs-solution O(n), BFS solution I try to change this problem to a BFS problem, where nodes in level i are all the nodes that can be reached in i-1th jump. for example. 2 3 1 1 4 , is 2|| 3 1|| 1 4 || clearly, the minimum jump of 4 is 2 since 4 is in level 3. my ac code. 1234567891011121314int jump(int A[], int n) &#123; if(n&lt;2)return 0; int level=0,currentMax=0,i=0,nextMax=0; while(currentMax-i+1&gt;0)&#123; //nodes count of current level&gt;0 level++; for(;i&lt;=currentMax;i++)&#123; //traverse current level , and update the max reach of next level nextMax=max(nextMax,A[i]+i); if(nextMax&gt;=n-1)return level; // if last element is in level+1, then the min jump=level &#125; currentMax=nextMax; &#125; return 0; &#125; https://leetcode.com/discuss/45992/10-lines-c-16ms-python-bfs-solutions-with-explanations 16ms, 22.73%, June.22th, 2016 10-lines C++ (16ms) / Python BFS Solutions with Explanations This problem has a nice BFS structure. Let’s illustrate it using the example nums = [2, 3, 1, 1, 4] in the problem statement. We are initially at position 0. Then we can move at most nums[0] steps from it. So, after one move, we may reach nums[1] = 3 or nums[2] = 1. So these nodes are reachable in 1 move. From these nodes, we can further move to nums[3] = 1 and nums[4] = 4. Now you can see that the target nums[4] = 4 is reachable in 2 moves. Putting these into codes, we keep two pointers start and end that record the current range of the starting nodes. Each time after we make a move, update start to be end + 1 and end to be the farthest index that can be reached in 1 move from the current [start, end]. To get an accepted solution, it is important to handle all the edge cases. And the following codes handle all of them in a unified way without using the unclean if statements :-) 1234567891011121314151617class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), start = 0, end = 0, step=0; while(end &lt; n - 1)&#123; step++; int maxend = end + 1; for(int i = start; i &lt; end + 1; i++)&#123; if(nums[i] + i &gt;= n - 1) return step; maxend = max(maxend, nums[i] + i); &#125; start = end + 1; end = maxend; &#125; return step; &#125;&#125;; https://discuss.leetcode.com/topic/5810/sharing-my-straightforward-c-solution Sharing my straightforward C++ solution 12345678910111213141516171819int jump(int A[], int n) &#123; if(n == 0)&#123; return 0; &#125; int maxReachPos = A[0]; int curMaxReachPos = A[0]; int curStep = 1; for(int i = 1; i &lt;= min(n, maxReachPos); i++)&#123; curMaxReachPos = max(curMaxReachPos, i + A[i]); if(i == n - 1)&#123; return curStep; &#125; if(i == maxReachPos)&#123; maxReachPos = curMaxReachPos; curStep++; &#125; &#125; return 0;&#125; The variable maxReachPos indicates the farthest reachable position and the variable curMaxReachPos indicates the current farthest reachable position. At the very beginning, both maxReachPos and curMaxReachPos are equal to A[0]. In the For loop, we keep updating curMaxReachPos while i &lt;= maxReachPos. However, if( i == n - 1), we return curStep, which is the minimum step. If i reaches the maxReachPos, we update maxReachPos with curMaxReachPos and increment curStep by one. Finally, if we can’t reach the end point, just return 0. python https://discuss.leetcode.com/topic/11761/easy-python-greedy-solution-with-explanation Easy Python Greedy solution with explanation 123456789101112131415class Solution:# @param A, a list of integers# @return an integerdef jump(self, A): last_max_reach, current_max_reach = 0 , 0 njump , i = 0 , 0 while current_max_reach &lt; len(A)-1: while i &lt;= last_max_reach: current_max_reach = max(i+A[i],current_max_reach) i+=1 if last_max_reach == current_max_reach: return -1 last_max_reach = current_max_reach njump+=1 return njump The basic thoughts underline is a greedy style. Every one more jump, you want to jump as far as possible.In Jump Game I, when you at position i, you care about what is the furthest position could be reached from i th position. but here in Jump Game II, instead you care about what would be the next furthest jump could be made when you could reach as far as ith position from last jump. So you iterate all positions could be reached from last jump till i th position to find it out. https://leetcode.com/discuss/45992/10-lines-c-16ms-python-bfs-solutions-with-explanations 86ms, 29.68%, June.22th, 201612345678910111213141516class Solution(object): def jump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n, start, end, step = len(nums), 0, 0, 0 while end &lt; n - 1: step += 1 maxend = end + 1 for i in range(start, end + 1): if i + nums[i] &gt;= n - 1: return step maxend = max(maxend, i + nums[i]) start, end = end + 1, maxend return step https://leetcode.com/discuss/45992/10-lines-c-16ms-python-bfs-solutions-with-explanations 84ms, 29.68%, June.22th, 2016 12345678910111213141516class Solution(object): def jump(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; n, start, end, step = len(nums), 0, 0, 0 while end &lt; n - 1: step += 1 maxend = end + 1 for i in range(start, end + 1): maxend = max(maxend, i + nums[i]) if maxend &gt;= n - 1: return step start, end = end + 1, maxend return step java https://discuss.leetcode.com/topic/11408/single-loop-simple-java-solution Single loop simple java solution 12345678910111213public int jump(int[] A) &#123; int step = 0; int e = 0; int max = 0; for(int i=0; i&lt;A.length-1; i++) &#123; max = Math.max(max, i+A[i]); if( i == e ) &#123; step++; e = max; &#125; &#125; return step;&#125; https://discuss.leetcode.com/topic/11408/single-loop-simple-java-solution/2 Very elegant method, but it took me a long time to understand. Some comment for the above: e: longest distance in current minimum step step: minimum steps for reaching e From i to e, even max is changed in a loop, it is reachable in one step. Help it will help : ) https://discuss.leetcode.com/topic/11408/single-loop-simple-java-solution/4 12345678910111213public int jump(int[] A) &#123; int step_count = 0; int last_jump_max = 0; int current_jump_max = 0; for(int i=0; i&lt;A.length-1; i++) &#123; current_jump_max = Math.max(current_jump_max, i+A[i]); if( i == last_jump_max ) &#123; step_count++; last_jump_max = current_jump_max; &#125; &#125; return step_count;&#125; https://discuss.leetcode.com/topic/4069/sharing-my-ac-java-solution Sharing My AC Java Solution Hi All, below is my AC solution: 12345678910111213141516171819public int jump(int[] A) &#123; int maxReach = A[0]; int edge = 0; int minstep = 0; for(int i = 1; i &lt; A.length; i++) &#123; if (i &gt; edge) &#123; minstep += 1; edge = maxReach; if(edge &gt; A.length - 1) return minstep; &#125; maxReach = Math.max(maxReach, A[i] + i); if (maxReach == i): return -1; &#125; return minstep;&#125; When iterate the array, I set an edge for the Search phase, which means that if I exceeds the edge, the minstep must add one and the maxReach will be update. And when the last index is within the range of the edge, output the minstep. [2, 3, 1, 1, 4] First, the edge is 0; Second, after start iterate the array, it exceeds the edge 0 when reaching the A[0] and update the edge to 2; Third, after it reach the A[2], it exceeds the edge 2 and update the new edge to the maxReach 4. Finally, end of the array is inside the edge, output the minstep. https://discuss.leetcode.com/topic/28470/concise-o-n-one-loop-java-solution-based-on-greedy Concise O(n) one loop JAVA solution based on Greedy Explanation The main idea is based on greedy. Let’s say the range of the current jump is [curBegin, curEnd], curFarthest is the farthest point that all points in [curBegin, curEnd] can reach. Once the current point reaches curEnd, then trigger another jump, and set the new curEnd with curFarthest, then keep the above steps, as the following: 1234567891011public int jump(int[] A) &#123; int jumps = 0, curEnd = 0, curFarthest = 0; for (int i = 0; i &lt; A.length - 1; i++) &#123; curFarthest = Math.max(curFarthest, i + A[i]); if (i == curEnd) &#123; jumps++; curEnd = curFarthest; &#125; &#125; return jumps;&#125; https://leetcode.com/discuss/30647/single-loop-simple-java-solution 3ms, 55.57%, June.22th, 2016123456789101112131415public class Solution &#123; public int jump(int[] nums) &#123; int sc = 0; int e = 0; int max = 0; for(int i=0; i&lt;nums.length-1; i++) &#123; max = Math.max(max, i+nums[i]); if( i == e ) &#123; sc++; e = max; &#125; &#125; return sc; &#125; &#125; my code 12345678910111213public class Solution &#123; public int jump(int[] nums) &#123; int step=0, cur=0, max=0; for(int i=0; i&lt;nums.length-1; i++)&#123; max = Math.max(max, i+nums[i]); if(i==cur)&#123; step += 1; cur = max; &#125; &#125; return step; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hard</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[044. Wildcard Matching]]></title>
    <url>%2Fp%2Fbcc0695c%2F</url>
    <content type="text"><![CDATA[20.4% https://leetcode.com/problems/wildcard-matching/ Implement wildcard pattern matching with support for ‘?’ and ‘*‘. 12345678910111213141516&apos;?&apos; Matches any single character.&apos;*&apos; Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;*&quot;) → trueisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;ab&quot;, &quot;?*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → false 方法一: 我的代码实现: 1234567891011121314151617181920212223class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.size(), n = p.size(); if(n==0) return m==0; vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=1; i&lt;=n; i++) dp[0][i] = dp[0][i-1] &amp;&amp; (p[i-1]=='*'); for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) if(p[j-1]!='*') dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]=='?'); else&#123; for(int k=i; k&gt;=0; k--)&#123; dp[i][j] = dp[i][j] || dp[k][j-1]; if(dp[i][j]==true) break; &#125; &#125; return dp[m][n]; &#125;&#125;; 方法二: 我的代码实现: 123456789101112131415161718class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.size(), n = p.size(); if(n==0) return m==0; vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=1; i&lt;=n; i++) dp[0][i] = dp[0][i-1] &amp;&amp; (p[i-1]=='*'); for(int i=1; i&lt;=m; i++) for(int j=1; j&lt;=n; j++) if(p[j-1]!='*') dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]=='?'); else dp[i][j] = dp[i-1][j] || dp[i][j-1]; return dp[m][n]; &#125;&#125;; 更新迭代公式解释： https://discuss.leetcode.com/topic/7266/c-dp-solution/2 Equation 1). means that if p[j-1] is not *, f(i,j) is determined by if s[0:i-2] matches p[0:j-2] and if (s[i-1]==p[j-1] or p[j-1]==’?’). Equation 2). means that if p[j-1] is , f(i,j) is true if either f(i,j-1) is true: s[0:i-1] matches p[0:j-2] and is not used here; or f(i-1,j) is true: s[0:i-2] matches p[0:j-1] and * is used to match s[i-1]. https://discuss.leetcode.com/topic/17901/accepted-c-dp-solution-with-a-trick Accepted C++ DP Solution with a Trick 1312ms, 28.41%, September 22, 2016 Updated: Since the OJ has relaxed the time constraint, the following DP solution is now accepted without the trick :-) Well, so many people has tried to solve this problem using DP. And almost all of them get TLE (if you see a C++ DP solution that gets accepted, please let me know ^_^). Well, this post aims at providing an accpted DP solution which uses a trick to get around the largest test case, insteaed of a solution that is fully correct. So please do not give me down votes for that :-) Let’s briefly summarize the idea of DP. We define the state P[i][j] to be whether s[0..i) matches p[0..j). The state equations are as follows: 121. P[i][j] = P[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;?&apos;), if p[j - 1] != &apos;*&apos;;2. P[i][j] = P[i][j - 1] || P[i - 1][j], if p[j - 1] == &apos;*&apos;. If you feel confused with the second equation, you may refer to this link. There is an explanation in the comments. We optimize the DP code to O(m) space by recording P[i - 1][j - 1] using a single variable pre. The trick to avoid TLE is to hard-code the result for the largest test case by 1if (n &gt; 30000) return false; The complete code is as follows. 123456789101112131415161718192021class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(), n = p.length(); if (n &gt; 30000) return false; // the trick vector&lt;bool&gt; cur(m + 1, false); cur[0] = true; for (int j = 1; j &lt;= n; j++) &#123; bool pre = cur[0]; // use the value before update cur[0] = cur[0] &amp;&amp; p[j - 1] == &apos;*&apos;; for (int i = 1; i &lt;= m; i++) &#123; bool temp = cur[i]; // record the value before update if (p[j - 1] != &apos;*&apos;) cur[i] = pre &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;?&apos;); else cur[i] = cur[i - 1] || cur[i]; pre = temp; &#125; &#125; return cur[m]; &#125;&#125;; 方法三: For those interested in a fully correct solution, this link has a nice Greedy solution. And I have rewritten the code below to fit the new C++ interface (changed from char* to string). 123456789101112131415161718192021222324class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(), n = p.length(); int i = 0, j = 0, asterisk = -1, match; while (i &lt; m) &#123; if (j &lt; n &amp;&amp; p[j] == &apos;*&apos;) &#123; match = i; asterisk = j++; &#125; else if (j &lt; n &amp;&amp; (s[i] == p[j] || p[j] == &apos;?&apos;)) &#123; i++; j++; &#125; else if (asterisk &gt;= 0) &#123; i = ++match; j = asterisk + 1; &#125; else return false; &#125; while (j &lt; n &amp;&amp; p[j] == &apos;*&apos;) j++; return j == n; &#125;&#125;; https://discuss.leetcode.com/topic/21577/my-three-c-solutions-iterative-16ms-dp-180ms-modified-recursion-88ms My three C++ solutions (iterative (16ms) &amp; DP (180ms) &amp; modified recursion (88ms)) The reason that the iterative solution is much faster for this case is we only need to save (and deal with) the positions (iStar for s, jStar for p) of the last “” we met. We only need to do traceback using iStar and jStar and all the previous “” can be ignored since the last “” will cover all the traceback cases for the previous “”.What we need to do are if the current p character is ‘’ (i.e. p[j]==’’), then we update iStar and jStar with the cureent i and j values. iStar/jStar will be used for traceback. Also we do –i to start the depth first search with the case that ‘*’ represents a null string. if p[j]!=’’, then we check if mismatch occurs (i.e. p[j]!=s[i] and p[j]!=’?’), if so we check if we met a ‘’ before (iStar&gt;=0), if not, then we return false since no match can achieve. Otherwise, we traceback to the positions at which the last ‘*’ happens and do the next possible dfs search (i.e. i = iStar++; j = jStar; remember to update iStar too to save the i position to try in the next traceback). The loop will quit when we reach the end of s. At last, we need to skip all the ‘*’ in p to see if we can reach the end of p. if so, match, otherwise mismatch 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool isMatch(string s, string p) &#123; int slen = s.size(), plen = p.size(), i, j, iStar=-1, jStar=-1; for(i=0,j=0 ; i&lt;slen; ++i, ++j) &#123; if(p[j]==&apos;*&apos;) &#123; //meet a new &apos;*&apos;, update traceback i/j info iStar = i; jStar = j; --i; &#125; else &#123; if(p[j]!=s[i] &amp;&amp; p[j]!=&apos;?&apos;) &#123; // mismatch happens if(iStar &gt;=0) &#123; // met a &apos;*&apos; before, then do traceback i = iStar++; j = jStar; &#125; else return false; // otherwise fail &#125; &#125; &#125; while(p[j]==&apos;*&apos;) ++j; return j==plen; &#125;&#125;; A DP solution is also given here. It has O(N^2) time complexity and O(N) space 12345678910111213141516171819class Solution &#123;public: bool isMatch(string s, string p) &#123; int pLen = p.size(), sLen = s.size(), i, j, k, cur, prev; if(!pLen) return sLen == 0; bool matched[2][sLen+1]; fill_n(&amp;matched[0][0], 2*(sLen+1), false); matched[0][0] = true; for(i=1; i&lt;=pLen; ++i) &#123; cur = i%2, prev= 1-cur; matched[cur][0]= matched[prev][0] &amp;&amp; p[i-1]==&apos;*&apos;; if(p[i-1]==&apos;*&apos;) for(j=1; j&lt;=sLen; ++j) matched[cur][j] = matched[cur][j-1] || matched[prev][j]; else for(j=1; j&lt;=sLen; ++j) matched[cur][j] = matched[prev][j-1] &amp;&amp; (p[i-1]==&apos;?&apos; || p[i-1]==s[j-1]) ; &#125; return matched[cur][sLen]; &#125;&#125;; A recursion version. A typical recursion version will give us TLE due to too many unnecessary recursive calls. As we explained, all the traceback recursive calls at the ‘’ we met (except the last ‘’) are unneccessary and should be avoided. In the below version, we use recLevel to track the recursion level (i.e the total ‘’ we met) and we also use curLevel to save the order of ‘’ we currently process. If it is not the last ‘’ we met (i.e if(recLevel&gt;curLevel+1) ), then we will return false directly ( if(recLevel&gt;curLevel+1) return false;) to skip all unneccessary recursion call at the ‘’ before the last ‘*’. 12345678910111213141516171819202122232425262728class Solution &#123;private: bool helper(const string &amp;s, const string &amp;p, int si, int pi, int &amp;recLevel) &#123; int sSize = s.size(), pSize = p.size(), i, curLevel = recLevel; bool first=true; while(si&lt;sSize &amp;&amp; (p[pi]==s[si] || p[pi]==&apos;?&apos;)) &#123;++pi; ++si;&#125; //match as many as possible if(pi == pSize) return si == sSize; // if p reaches the end, return if(p[pi]==&apos;*&apos;) &#123; // if a star is met while(p[++pi]==&apos;*&apos;); //skip all the following stars if(pi&gt;=pSize) return true; // if the rest of p are all star, return true for(i=si; i&lt;sSize; ++i) &#123; // then do recursion if(p[pi]!= &apos;?&apos; &amp;&amp; p[pi]!=s[i]) continue; if(first) &#123;++recLevel; first = false;&#125; if(helper(s, p, i, pi, recLevel)) return true; if(recLevel&gt;curLevel+1) return false; // if the currently processed star is not the last one, return &#125; &#125; return false; &#125;public: bool isMatch(string s, string p) &#123; int recLevel = 0; return helper(s, p, 0, 0, recLevel); &#125;&#125;; https://discuss.leetcode.com/topic/7266/c-dp-solution C++ DP solution It seems that only Greedy solution can pass all test cases (sorry if I omit any DP solution that passes all test cases). My DP solution also fails to pass the s=aaaaaaaaaaaaaa………….. (lots of a’s…). However, despite this very large case my DP solution passes all other cases. The idea is: f(i,j) == whether the first i chars of s match the first j chars of p. The transition equation is: 1231). if(p[j-1]!=&apos;*&apos;) f(i, j) = f(i-1, j-1) &amp;&amp; (s[i-1]==p[j-1] || p[j-1]==&apos;?&apos;)2). if(p[j-1]==&apos;*&apos;) f(i, j) = f(i, j-1) || f(i-1, j) 12345678910111213141516171819202122bool isMatch(const char *s, const char *p) &#123; const int m = strlen(s); const int n = strlen(p); if(m&gt;30000) return false; // to skip the large test case vector&lt;bool&gt; prev(n+1,false); // to save space, just O(n) space is used prev[0]=true; for(int j=1; j&lt;=n; j++) prev[j] = prev[j-1] &amp;&amp; p[j-1]==&apos;*&apos;; for(int i=1; i&lt;=m; i++) &#123; vector&lt;bool&gt; cur(n+1,false); for(int j=1; j&lt;=n; j++) &#123; if(p[j-1]==&apos;*&apos;) &#123; cur[j] = cur[j-1] || prev[j]; &#125; else &#123; cur[j] = prev[j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]==&apos;?&apos;); &#125; &#125; prev = cur; &#125; return prev[n];&#125; 12345678Equation 1). means that if p[j-1] is not *, f(i,j) is determinedby if s[0:i-2] matches p[0:j-2] and if (s[i-1]==p[j-1] orp[j-1]==&apos;?&apos;).Equation 2). means that if p[j-1] is *, f(i,j) is true if eitherf(i,j-1) is true: s[0:i-1] matches p[0:j-2] and * is not usedhere; or f(i-1,j) is true: s[0:i-2] matches p[0:j-1] and * isused to match s[i-1]. my code: 1234567891011121314class Solution &#123;public: bool isMatch(string s, string p) &#123; int m=0, n=0, match=0, startIdx=-1; while(m&lt;s.size())&#123; if(n&lt;p.size() &amp;&amp; (p[n]==&apos;?&apos; || p[n]==s[m]))&#123;m++; n++;&#125; else if(n&lt;p.size() &amp;&amp; p[n]==&apos;*&apos;)&#123;startIdx=n; match=m; n++;&#125; else if(startIdx!=-1)&#123;n=startIdx+1; match++; m=match;&#125; else return false; &#125; while(n&lt;p.size() &amp;&amp; p[n]==&apos;*&apos;) n++; return n==p.size(); &#125;&#125;; python https://discuss.leetcode.com/topic/9350/python-dp-solution Python DP solution 12345678910111213141516class Solution:# @return a booleandef isMatch(self, s, p): length = len(s) if len(p) - p.count(&apos;*&apos;) &gt; length: return False dp = [True] + [False]*length for i in p: if i != &apos;*&apos;: for n in reversed(range(length)): dp[n+1] = dp[n] and (i == s[n] or i == &apos;?&apos;) else: for n in range(1, length+1): dp[n] = dp[n-1] or dp[n] dp[0] = dp[0] and i == &apos;*&apos; return dp[-1] dp[n] means the substring s[:n] if match the pattern i dp[0] means the empty string ‘’ or s[:0] which only match the pattern ‘*’ use the reversed builtin because for every dp[n+1] we use the previous ‘dp’ add Java O(m*n) version code 1234567891011121314151617181920212223public boolean isMatch(String s, String p) &#123; int count = 0; for (char c : p.toCharArray()) &#123; if (c == &apos;*&apos;) count++; &#125; if (p.length() - count &gt; s.length()) return false; boolean[][] dp = new boolean[p.length() + 1][s.length() + 1]; dp[0][0] = true; for (int j = 1; j &lt;= p.length(); j++) &#123; char pattern = p.charAt(j - 1); dp[j][0] = dp[j - 1][0] &amp;&amp; pattern == &apos;*&apos;; for (int i = 1; i &lt;= s.length(); i++) &#123; char letter = s.charAt(i - 1); if (pattern != &apos;*&apos;) &#123; dp[j][i] = dp[j - 1][i - 1] &amp;&amp; (pattern == &apos;?&apos; || pattern == letter); &#125; else dp[j][i] = dp[j][i - 1] || dp[j - 1][i]; &#125; &#125; return dp[p.length()][s.length()];&#125; java http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html 123456789101112131415161718192021Analysis:For each element in sIf *s==*p or *p == ? which means this is a match, then goes to next element s++ p++.If p=='*', this is also a match, but one or many chars may be available, so let us save this *'s position and the matched s position.If not match, then we check if there is a * previously showed up, if there is no *, return false; if there is an *, we set current p to the next element of *, and set current s to the next saved s position.e.g.abed?b*d**a=?, go on, b=b, go on,e=*, save * position star=3, save s position ss = 3, p++e!=d, check if there was a *, yes, ss++, s=ss; p=star+1d=d, go on, meet the end.check the rest element in p, if all are *, true, else false;Note that in char array, the last is NOT NULL, to check the end, use "*p" or "*p=='\0'". https://discuss.leetcode.com/topic/3040/linear-runtime-and-constant-space-solution 60ms, 60.11%, September 22, 2016 1234567891011121314151617181920212223242526public class Solution &#123; public boolean isMatch(String str, String pattern) &#123; int s=0, p=0, match=0, starIdx=-1; while(s&lt;str.length())&#123; if(p&lt;pattern.length() &amp;&amp; (pattern.charAt(p)==&apos;?&apos; || str.charAt(s)==pattern.charAt(p)))&#123; s++; p++; &#125; else if(p&lt;pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;)&#123; starIdx = p; match = s; p++; &#125; else if(starIdx!=-1)&#123; p = starIdx + 1; match++; s = match; &#125; else return false; &#125; while(p&lt;pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;) p++; return p == pattern.length(); &#125;&#125; https://discuss.leetcode.com/topic/3040/linear-runtime-and-constant-space-solution Linear runtime and constant space solution I found this solution from http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html The basic idea is to have one pointer for the string and one pointer for the pattern. This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step. Here is Yu’s elegant solution in C++ 12345678910111213141516171819202122232425bool isMatch(const char *s, const char *p) &#123; const char* star=NULL; const char* ss=s; while (*s)&#123; //advancing both pointers when (both characters match) or (&apos;?&apos; found in pattern) //note that *p will not advance beyond its length if ((*p==&apos;?&apos;)||(*p==*s))&#123;s++;p++;continue;&#125; // * found in pattern, track index of *, only advancing pattern pointer if (*p==&apos;*&apos;)&#123;star=p++; ss=s;continue;&#125; //current characters didn&apos;t match, last pattern pointer was *, current pattern pointer is not * //only advancing pattern pointer if (star)&#123; p = star+1; s=++ss;continue;&#125; //current pattern pointer is not star, last patter pointer was not * //characters do not match return false; &#125; //check for remaining characters in pattern while (*p==&apos;*&apos;)&#123;p++;&#125; return !*p; &#125; Here is my re-write in Java 12345678910111213141516171819202122232425262728293031boolean comparison(String str, String pattern) &#123; int s = 0, p = 0, match = 0, starIdx = -1; while (s &lt; str.length())&#123; // advancing both pointers if (p &lt; pattern.length() &amp;&amp; (pattern.charAt(p) == &apos;?&apos; || str.charAt(s) == pattern.charAt(p)))&#123; s++; p++; &#125; // * found, only advancing pattern pointer else if (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;)&#123; starIdx = p; match = s; p++; &#125; // last pattern pointer was *, advancing string pointer else if (starIdx != -1)&#123; p = starIdx + 1; match++; s = match; &#125; //current pattern pointer is not star, last patter pointer was not * //characters do not match else return false; &#125; //check for remaining characters in pattern while (p &lt; pattern.length() &amp;&amp; pattern.charAt(p) == &apos;*&apos;) p++; return p == pattern.length();&#125; my code： 12345678910111213public class Solution &#123; public boolean isMatch(String s, String p) &#123; int m=0, n=0, match=0, startIdx=-1; while(m&lt;s.length())&#123; if(n&lt;p.length() &amp;&amp; (s.charAt(m)==p.charAt(n) || p.charAt(n)==&apos;?&apos;))&#123;m++; n++;&#125; else if(n&lt;p.length() &amp;&amp; p.charAt(n)==&apos;*&apos;)&#123;startIdx=n; match=m; n++;&#125; else if(startIdx!=-1)&#123;match++; m=match; n=startIdx+1;&#125; else return false; &#125; while(n&lt;p.length() &amp;&amp; p.charAt(n)==&apos;*&apos;)&#123;n++;&#125; return n==p.length(); &#125;&#125; https://discuss.leetcode.com/topic/22516/my-java-dp-solution-using-2d-table My java DP solution using 2D table 1234567891011121314151617181920212223public class Solution &#123; public boolean isMatch(String s, String p) &#123; boolean[][] match=new boolean[s.length()+1][p.length()+1]; match[s.length()][p.length()]=true; for(int i=p.length()-1;i&gt;=0;i--)&#123; if(p.charAt(i)!=&apos;*&apos;) break; else match[s.length()][i]=true; &#125; for(int i=s.length()-1;i&gt;=0;i--)&#123; for(int j=p.length()-1;j&gt;=0;j--)&#123; if(s.charAt(i)==p.charAt(j)||p.charAt(j)==&apos;?&apos;) match[i][j]=match[i+1][j+1]; else if(p.charAt(j)==&apos;*&apos;) match[i][j]=match[i+1][j]||match[i][j+1]; else match[i][j]=false; &#125; &#125; return match[0][0]; &#125;&#125; https://discuss.leetcode.com/topic/10794/my-java-dp-solution My Java DP Solution At first I cannot pass the the long ‘aaa…’ test case. Then I add more check and pass it. 123456789101112131415161718192021222324252627282930public class Solution &#123; public boolean isMatch(String s, String p) &#123; int m = s.length(), n = p.length(); int count = 0; for (int i = 0; i &lt; n; i++) &#123; if (p.charAt(i) == &apos;*&apos;) count++; &#125; if (count==0 &amp;&amp; m != n) return false; else if (n - count &gt; m) return false; boolean[] match = new boolean[m+1]; match[0] = true; for (int i = 0; i &lt; m; i++) &#123; match[i+1] = false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (p.charAt(i) == &apos;*&apos;) &#123; for (int j = 0; j &lt; m; j++) &#123; match[j+1] = match[j] || match[j+1]; &#125; &#125; else &#123; for (int j = m-1; j &gt;= 0; j--) &#123; match[j+1] = (p.charAt(i) == &apos;?&apos; || p.charAt(i) == s.charAt(j)) &amp;&amp; match[j]; &#125; match[0] = false; &#125; &#125; return match[m]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[043. Multiply Strings]]></title>
    <url>%2Fp%2Fd81212f5%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/multiply-strings/ Given two numbers represented as strings, return multiplication of the numbers as a string. Note: The numbers can be arbitrarily large and are non-negative. Converting the input string to integer is NOT allowed. You should NOT use internal library such as BigInteger. cpp 6ms, September 19, 2016 https://discuss.leetcode.com/topic/9449/brief-c-solution-using-only-strings-and-without-reversal Brief C++ solution using only strings and without reversal This is the standard manual multiplication algorithm. We use two nested for loops, working backward from the end of each input number. We pre-allocate our result and accumulate our partial result in there. One special case to note is when our carry requires us to write to our sum string outside of our for loop. At the end, we trim any leading zeros, or return 0 if we computed nothing but zeros. 123456789101112131415161718192021class Solution &#123;public: string multiply(string num1, string num2) &#123; string sum(num1.size() + num2.size(), &apos;0&apos;); for(int i = num1.size()-1; i &gt;= 0; --i)&#123; int carry = 0; for(int j = num2.size() - 1; j&gt;=0; --j)&#123; int tmp = (sum[i+j+1] -&apos;0&apos;) + (num1[i] - &apos;0&apos;)*(num2[j] - &apos;0&apos;) + carry; sum[i+j+1] = tmp%10 + &apos;0&apos;; carry = tmp/10; &#125; sum[i] += carry; &#125; size_t startpos = sum.find_first_not_of(&quot;0&quot;); if(string::npos!=startpos) return sum.substr(startpos); return &quot;0&quot;; &#125;&#125;; https://discuss.leetcode.com/topic/3456/one-easy-solution-with-c One Easy solution with C++ The key part is to use a vector to store all digits REVERSELY. after the calculation, find the rightmost NON-Zero digits and convert it to a string. 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: string multiply(string num1, string num2) &#123; unsigned int l1=num1.size(),l2=num2.size(); if (l1==0||l2==0) return &quot;0&quot;; vector&lt;int&gt; v(l1+l2,0); for (unsigned int i=0;i&lt;l1;i++)&#123; int carry=0; int n1=(int)(num1[l1-i-1]-&apos;0&apos;);//Calculate from rightmost to left for (unsigned int j=0;j&lt;l2;j++)&#123; int n2=(num2[l2-j-1]-&apos;0&apos;);//Calculate from rightmost to left int sum=n1*n2+v[i+j]+carry; carry=sum/10; v[i+j]=sum%10; &#125; if (carry&gt;0) v[i+l2]+=carry; &#125; int start=l1+l2-1; while(v[start]==0) start--; if (start==-1) return &quot;0&quot;; string s=&quot;&quot;; for (int i=start;i&gt;=0;i--) s+=(char)(v[i]+&apos;0&apos;); return s; &#125;&#125;; https://discuss.leetcode.com/topic/8500/very-concise-16-ms-c-solution Very concise 16 ms c++ solution See comments inline for explanation. 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string multiply(string num1, string num2) &#123; int i, j; int m = num1.size(), n = num2.size(); // max (m + n) digits vector&lt;int&gt; product(m + n, 0); string result; // reverse for ease of calc reverse(num1.begin(), num1.end()); reverse(num2.begin(), num2.end()); // digit i * digit j contributes to digit i + j for (i = 0; i &lt; m; i++) &#123; for (j = 0; j &lt; n; j++) &#123; product[i + j] += (num1[i] - &apos;0&apos;) * (num2[j] - &apos;0&apos;); product[i + j + 1] += product[i + j] / 10; product[i + j] %= 10; &#125; &#125; // remove leading 0; keep last 0 if all 0 for (i = m + n - 1; i &gt; 0 &amp;&amp; 0 == product[i]; i--) ; for (; i &gt;= 0; i--) result += to_string(product[i]); return result; &#125;&#125;; python 59ms, September 19, 2016 My solution 12345678class Solution(object): def multiply(self, num1, num2): &quot;&quot;&quot; :type num1: str :type num2: str :rtype: str &quot;&quot;&quot; return str(int(num1)*int(num2)) https://discuss.leetcode.com/topic/20883/simple-python-solution-18-lines Simple Python solution, 18 lines123456789101112131415161718def multiply(num1, num2): product = [0] * (len(num1) + len(num2)) pos = len(product)-1 for n1 in reversed(num1): tempPos = pos for n2 in reversed(num2): product[tempPos] += int(n1) * int(n2) product[tempPos-1] += product[tempPos]/10 product[tempPos] %= 10 tempPos -= 1 pos -= 1 pt = 0 while pt &lt; len(product)-1 and product[pt] == 0: pt += 1 return &apos;&apos;.join(map(str, product[pt:])) java 31ms, September 19, 2016 https://discuss.leetcode.com/topic/30508/easiest-java-solution-with-graph-explanation Easiest JAVA Solution with Graph Explanation Remember how we do multiplication? Start from right to left, perform multiplication on every pair of digits, and add them together. Let’s draw the process! From the following draft, we can immediately conclude: 1`num1[i] * num2[j]` will be placed at indices `[i + j`, `i + j + 1]` Here is my solution. Hope it helps! 123456789101112131415161718192021public class Solution &#123; public String multiply(String num1, String num2) &#123; int m = num1.length(), n = num2.length(); int[] pos = new int[m+n]; for(int i = m-1; i &gt;= 0; i--)&#123; for(int j = n-1; j&gt;=0; j--)&#123; int mul = (num1.charAt(i)-&apos;0&apos;) * (num2.charAt(j) -&apos;0&apos;); int p1 = i+j, p2 = i+j+1; int sum = mul + pos[p2]; pos[p1] += sum/10; pos[p2] = sum % 10; &#125; &#125; StringBuilder sb = new StringBuilder(); for(int p:pos) if(!(sb.length()==0 &amp;&amp; p==0)) sb.append(p); return sb.length() == 0?&quot;0&quot;:sb.toString(); &#125;&#125; https://discuss.leetcode.com/topic/13026/ac-solution-in-java-with-explanation AC solution in Java with explanation 1234567891011121314151617181920212223public class Solution &#123; public String multiply(String num1, String num2) &#123; int n1 = num1.length(), n2 = num2.length(); int[] products = new int[n1 + n2]; for (int i = n1 - 1; i &gt;= 0; i--) &#123; for (int j = n2 - 1; j &gt;= 0; j--) &#123; int d1 = num1.charAt(i) - &apos;0&apos;; int d2 = num2.charAt(j) - &apos;0&apos;; products[i + j + 1] += d1 * d2; &#125; &#125; int carry = 0; for (int i = products.length - 1; i &gt;= 0; i--) &#123; int tmp = (products[i] + carry) % 10; carry = (products[i] + carry) / 10; products[i] = tmp; &#125; StringBuilder sb = new StringBuilder(); for (int num : products) sb.append(num); while (sb.length() != 0 &amp;&amp; sb.charAt(0) == &apos;0&apos;) sb.deleteCharAt(0); return sb.length() == 0 ? &quot;0&quot; : sb.toString(); &#125;&#125; If we break it into steps, it will have the following steps. 1. compute products from each pair of digits from num1 and num2. 2. carry each element over. 3. output the solution. Things to note: The product of two numbers cannot exceed the sum of the two lengths. (e.g. 99 * 99 cannot be five digit) 123int d1 = num1.charAt(i) - &apos;0&apos;;int d2 = num2.charAt(j) - &apos;0&apos;;products[i + j + 1] += d1 * d2; https://discuss.leetcode.com/topic/10757/clear-java-solution-without-reversal Clear JAVA solution without reversal 123456789101112131415161718192021public String multiply(String num1, String num2) &#123; int len1 = num1.length(); int len2 = num2.length(); int[] product = new int[len1 + len2]; for (int i = len1 - 1; i &gt;= 0; i--) &#123; for (int j = len2 - 1; j &gt;= 0; j--) &#123; int index = len1 + len2 - i - j - 2; product[index] += (num1.charAt(i) - &apos;0&apos;) * (num2.charAt(j) - &apos;0&apos;); product[index + 1] += product[index] / 10; product[index] %= 10; &#125; &#125; StringBuilder stringBuilder = new StringBuilder(); for (int i = product.length - 1; i &gt; 0; i--) &#123; if (stringBuilder.length() == 0 &amp;&amp; product[i] == 0) continue; stringBuilder.append(product[i]); &#125; stringBuilder.append(product[0]); return stringBuilder.toString();&#125; https://discuss.leetcode.com/topic/21008/simple-clear-java-solution Simple &amp;&amp; clear java solution 12345678910111213141516171819202122232425public class Solution &#123; public String multiply(String num1, String num2) &#123; int len1 = num1.length(); int len2 = num2.length(); int len = len1 + len2; int[] mul = new int[len]; for (int i = len1 - 1; i &gt;= 0; i--) &#123; int a = num1.charAt(i) - &apos;0&apos;; int k = len2 + i; for (int j = len2 - 1; j &gt;= 0; j--) &#123; int b = num2.charAt(j) - &apos;0&apos;; int c = mul[k] + a * b; mul[k] = c % 10; mul[k - 1] = mul[k - 1] + c /10; k--; &#125; &#125; int i = 0; while(mul[i] == 0 &amp;&amp; i &lt; len - 1) i++; StringBuilder sb = new StringBuilder(); for (; i &lt; len; i++) sb.append(mul[i]); return sb.length() == 0 ? &quot;0&quot; : sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[042. Trapping Rain Water]]></title>
    <url>%2Fp%2F33f3f22a%2F</url>
    <content type="text"><![CDATA[36.7% https://leetcode.com/problems/trapping-rain-water/ Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. 12For example, Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! 方法一： https://discuss.leetcode.com/topic/5125/sharing-my-simple-c-code-o-n-time-o-1-space Sharing my simple c++ code: O(n) time, O(1) space Here is my idea: instead of calculating area by height*width, we can think it in a cumulative way. In other words, sum water amount of each bin(width=1). Search from left to right and maintain a max height of left and right separately, which is like a one-side wall of partial container. Fix the higher one and flow water from the lower part. For example, if current height of left is lower, we fill water in the left bin. Until left meets right, we filled the whole container. 123456789101112131415161718192021class Solution &#123;public: int trap(int A[], int n) &#123; int left=0; int right=n-1; int res=0; int maxleft=0, maxright=0; while(left&lt;=right)&#123; if(A[left]&lt;=A[right])&#123; if(A[left]&gt;=maxleft) maxleft=A[left]; else res+=maxleft-A[left]; left++; &#125; else&#123; if(A[right]&gt;=maxright) maxright= A[right]; else res+=maxright-A[right]; right--; &#125; &#125; return res; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if(n&lt;=1) return 0; int left=0, right=n-1; int maxleft = 0, maxright=0; int res = 0; while(left&lt;right)&#123; if(height[left]&lt;=height[right])&#123; if(height[left]&gt;maxleft) maxleft = height[left]; else res += maxleft - height[left]; left++; &#125;else&#123; if(height[right] &gt; maxright) maxright = height[right]; else res += maxright - height[right]; right--; &#125; &#125; return res; &#125;&#125;; 方法二： 三次遍历。 第一次遍历，查看当前位置i的从左侧看，左侧的挡板的最大值。第二次从右边向左遍历。 第三天遍历，计算当前位置有的水。 https://discuss.leetcode.com/topic/4136/a-different-o-n-approach-easy-to-understand-and-simple-code A different O(n) approach - easy to understand and simple code 123456789101112131415class Solution &#123;public: int trap(int a[], int n) &#123; int i, res = 0; if(!n) return res; vector&lt;int&gt; ltr(n, 0), rtl(n, 0); for(i = 1, ltr[0] = a[0]; i &lt; n; i++) ltr[i] = max(ltr[i-1], a[i]); for(i = n - 2, rtl[n-1] = a[n-1]; i &gt;= 0; i--) rtl[i] = max(rtl[i+1], a[i]); for(i = 0; i &lt; n; i++) res += min(ltr[i], rtl[i]) - a[i]; return res; &#125;&#125;; observation: scan A both from left to right and right to left, record the largest seen during the scan; then for each position the water level should be the min of the 2 large value. 我的代码实现： 12345678910111213141516171819class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if(n&lt;=1) return 0; vector&lt;int&gt; ltr(n, 0); vector&lt;int&gt; rtr(n, 0); int res = 0; ltr[0] = height[0]; for(int i=1; i&lt;n; i++) ltr[i] = max(ltr[i-1], height[i]); rtr[n-1] = height[n-1]; for(int j=n-2; j&gt;=0; j--) rtr[j] = max(rtr[j+1], height[j]); for(int k=0; k&lt;n; k++) res += min(ltr[k], rtr[k]) - height[k]; return res; &#125;&#125;; 官方解答 https://leetcode.com/articles/trapping-rain-water/#approach-3-using-stacks-accepted https://discuss.leetcode.com/topic/18731/7-lines-c-c 7 lines C / C++ Keep track of the already safe level and the total water so far. In each step, process and discard the lower one of the leftmost or rightmost elevation. C Changing the given parameters to discard the lower border. I’m quite fond of this one. 123456789int trap(int* height, int n) &#123; int level = 0, water = 0; while (n--) &#123; int lower = *height &lt; height[n] ? *height++ : height[n]; if (lower &gt; level) level = lower; water += level - lower; &#125; return water;&#125; Slight variation with two pointers (left and right). 123456789int trap(int* height, int n) &#123; int *L = height, *R = L+n-1, level = 0, water = 0; while (L &lt; R) &#123; int lower = *L &lt; *R ? *L++ : *R--; if (lower &gt; level) level = lower; water += level - lower; &#125; return water;&#125; C++ With left and right index. 123456789int trap(vector&lt;int&gt;&amp; height) &#123; int l = 0, r = height.size()-1, level = 0, water = 0; while (l &lt; r) &#123; int lower = height[height[l] &lt; height[r] ? l++ : r--]; level = max(level, lower); water += level - lower; &#125; return water;&#125; With left and right iterator. 12345678910int trap(vector&lt;int&gt;&amp; height) &#123; auto l = height.begin(), r = height.end() - 1; int level = 0, water = 0; while (l != r + 1) &#123; int lower = *l &lt; *r ? *l++ : *r--; level = max(level, lower); water += level - lower; &#125; return water;&#125; python https://discuss.leetcode.com/topic/18720/8-lines-c-c-java-python-solution 8-lines C/C++/Java/Python Solution Note: The following idea is in fact from the last answer in this link, which leads to a clean code. I just reorganize it and add some explanations. I hope it is Ok. The following are four solutions in C/C++/Java/Python respectively. The basic idea is that we set two pointers l and r to the left and right end of height. Then we get the minimum height (minHeight) of these pointers (similar to Container with Most Water due to the Leaking Bucket Effect) since the level of the water cannot be higher than it. Then we move the two pointers towards the center. If the coming level is less than minHeight, then it will hold some water. Fill the water until we meet some “barrier” (with height larger than minHeight) and update l and r to repeat this process in a new interval. C 1234567891011int trap(int* height, int heightSize) &#123; int l = 0, r = heightSize - 1, water = 0, minHeight = 0; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; height[l] &lt;= minHeight) water += minHeight - height[l++]; while (r &gt; l &amp;&amp; height[r] &lt;= minHeight) water += minHeight - height[r--]; minHeight = height[l] &lt;= height[r] ? height[l] : height[r]; &#125; return water;&#125; C++ 1234567891011121314class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(), l = 0, r = n - 1, water = 0, minHeight = 0; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; height[l] &lt;= minHeight) water += minHeight - height[l++]; while (r &gt; l &amp;&amp; height[r] &lt;= minHeight) water += minHeight - height[r--]; minHeight = min(height[l], height[r]); &#125; return water; &#125;&#125;; Java 12345678910111213public class Solution &#123; public int trap(int[] height) &#123; int n = height.length, l = 0, r = n - 1, water = 0, minHeight = 0; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; height[l] &lt;= minHeight) water += minHeight - height[l++]; while (r &gt; l &amp;&amp; height[r] &lt;= minHeight) water += minHeight - height[r--]; minHeight = Math.min(height[l], height[r]); &#125; return water; &#125;&#125; Python 123456789101112131415class Solution: # @param &#123;integer[]&#125; height # @return &#123;integer&#125; def trap(self, height): n = len(height) l, r, water, minHeight = 0, n - 1, 0, 0 while l &lt; r: while l &lt; r and height[l] &lt;= minHeight: water += minHeight - height[l] l += 1 while r &gt; l and height[r] &lt;= minHeight: water += minHeight - height[r] r -= 1 minHeight = min(height[l], height[r]) return water java https://discuss.leetcode.com/topic/3016/share-my-short-solution Share my short solution. Keep track of the maximum height from both forward directions backward directions, call them leftmax and rightmax. 1234567891011121314151617181920public int trap(int[] A)&#123; int a=0; int b=A.length-1; int max=0; int leftmax=0; int rightmax=0; while(a&lt;=b)&#123; leftmax=Math.max(leftmax,A[a]); rightmax=Math.max(rightmax,A[b]); if(leftmax&lt;rightmax)&#123; max+=(leftmax-A[a]); // leftmax is smaller than rightmax, so the (leftmax-A[a]) water can be stored a++; &#125; else&#123; max+=(rightmax-A[b]); b--; &#125; &#125; return max;&#125; 2ms, 20.31%, June.18th, 2016 https://leetcode.com/discuss/18022/sharing-my-java-code-o-n-time-o-1-space 12345678910111213141516171819202122public class Solution &#123; public int trap(int[] height) &#123; if(height.length &lt; 3) return 0; int ans = 0; int l = 0, r = height.length - 1; while(l &lt; r &amp;&amp; height[l] &lt; height[l+1]) l++; while(l &lt; r &amp;&amp; height[r] &lt; height[r-1]) r--; while(l &lt; r)&#123; int left = height[l]; int right = height[r]; if(left &lt;= right)&#123; while(l &lt; r &amp;&amp; left &gt; height[++l]) ans += left - height[l]; &#125;else&#123; while(l &lt; r &amp;&amp; right &gt; height[--r]) ans += right - height[r]; &#125; &#125; return ans; &#125;&#125; https://discuss.leetcode.com/topic/4939/a-stack-based-solution-for-reference-inspired-by-histogram A stack based solution for reference, inspired by Histogram Indeed this question can be solved in one pass and O(1) space, but it’s probably hard to come up with in a short interview. If you have read the stack O(n) solution for Largest Rectangle in Histogram, you will find this solution is very very similar. The main idea is : if we want to find out how much water on a bar(bot), we need to find out the left larger bar’s index (il), and right larger bar’s index(ir), so that the water is (min(A[il],A[ir])-A[bot])*(ir-il-1), use min since only the lower boundary can hold water, and we also need to handle the edge case that there is no il. To implement this we use a stack that store the indices with decreasing bar height, once we find a bar who’s height is larger, then let the top of the stack be bot, the cur bar is ir, and the previous bar is il. 1234567891011121314151617public int trap(int[] A) &#123; if (A==null) return 0; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int i = 0, maxWater = 0, maxBotWater = 0; while (i &lt; A.length)&#123; if (s.isEmpty() || A[i]&lt;=A[s.peek()])&#123; s.push(i++); &#125; else &#123; int bot = s.pop(); maxBotWater = s.isEmpty()? // empty means no il 0:(Math.min(A[s.peek()],A[i])-A[bot])*(i-s.peek()-1); maxWater += maxBotWater; &#125; &#125; return maxWater; &#125; https://discuss.leetcode.com/topic/5819/sharing-my-java-code-o-n-time-o-1-space Sharing my Java code: O(n) time, O(1) space 123456789101112131415161718192021222324252627public int trap(int[] A) &#123; if (A.length &lt; 3) return 0; int ans = 0; int l = 0, r = A.length - 1; // find the left and right edge which can hold water while (l &lt; r &amp;&amp; A[l] &lt;= A[l + 1]) l++; while (l &lt; r &amp;&amp; A[r] &lt;= A[r - 1]) r--; while (l &lt; r) &#123; int left = A[l]; int right = A[r]; if (left &lt;= right) &#123; // add volum until an edge larger than the left edge while (l &lt; r &amp;&amp; left &gt;= A[++l]) &#123; ans += left - A[l]; &#125; &#125; else &#123; // add volum until an edge larger than the right volum while (l &lt; r &amp;&amp; A[--r] &lt;= right) &#123; ans += right - A[r]; &#125; &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/7612/java-10-lines-accepted-code-o-n-time-o-1-space-is-there-a-better-solution JAVA 10 lines accepted code, O(n) time, O(1) space. Is there a better solution? Basically this solution runs two pointers from two sides to the middle, and the plank is used to record the height of the elevation within a certain range, plank height can only increase (or remain the same) from two sides to the middle. If the current pointer is pointing at a number that is less than the current plank height, the difference between plank height and the number would be the amount of water trapped. Otherwise, A[i] == plank, no water is trapped. 12345678910public class Solution &#123; public int trap(int[] A) &#123; int i = 0, j = A.length - 1, result = 0, plank = 0; while(i &lt;= j)&#123; plank = plank &lt; Math.min(A[i], A[j]) ? Math.min(A[i], A[j]) : plank; result = A[i] &gt;= A[j] ? result + (plank - A[j--]) : result + (plank - A[i++]); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
        <tag>hard</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[041. First Missing Positive]]></title>
    <url>%2Fp%2F257d685e%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/first-missing-positive/ Given an unsorted integer array, find the first missing positive integer. 123For example,Given [1,2,0] return 3,and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. 题意需要理解 答案需要思考 cpp https://discuss.leetcode.com/topic/8293/my-short-c-solution-o-1-space-and-o-n-time My short c++ solution, O(1) space, and O(n) time Put each number in its right place. For example: When we find 5, then swap it with A[4]. At last, the first place where its number is not right, return the place + 1. 12345678910111213141516class Solution&#123;public: int firstMissingPositive(int A[], int n) &#123; for(int i = 0; i &lt; n; ++ i) while(A[i] &gt; 0 &amp;&amp; A[i] &lt;= n &amp;&amp; A[A[i] - 1] != A[i]) swap(A[i], A[A[i] - 1]); for(int i = 0; i &lt; n; ++ i) if(A[i] != i + 1) return i + 1; return n + 1; &#125;&#125;; https://discuss.leetcode.com/topic/17035/my-c-solution-4-ms My c++ solution (4 ms) 12345678910111213141516class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; for(int i=0; i&lt;nums.size(); i++)&#123; if(i+1==nums[i]) continue; int x = nums[i]; while(x&gt;=1 &amp;&amp; x&lt;=nums.size() &amp;&amp; x!=nums[x-1])&#123; swap(x, nums[x-1]); &#125; &#125; for(int i=0; i&lt;nums.size(); i++)&#123; if(i+1!=nums[i]) return i+1; &#125; return nums.size()+1; &#125;&#125;; Since we can not use extra space, so thinking about using the nums vector itself to record a positive number occurred. https://discuss.leetcode.com/topic/3384/o-n-time-o-1-space-c O(n) time, O(1) space C++ Idea is to swap each positive integer you encounter to its “rightful” place at index (x-1) where x is the integer. It’s O(n) because you visit each integer in at most 2 unique loop iterations. 1234567891011121314151617181920class Solution &#123;public: int firstMissingPositive(int A[], int n) &#123; int i,j; for(i=0;i&lt;n;i++)&#123; int cur=A[i]; // if in place or non-pos or out of bounds, skip. if(cur==i+1||cur&lt;=0||cur&gt;n)continue; swap(A[i],A[cur-1]); // if not the same, then reprocess it. if(A[i]!=A[cur-1]) i--; &#125; for(i=0;i&lt;n;i++) if(A[i]!=i+1) return i+1; return n+1; &#125;&#125;; python https://discuss.leetcode.com/topic/1361/a-very-nice-solution-from-ants-aasma-stackoverflow A very nice solution (from Ants Aasma @stackoverflow) time complexity is O(N) and space complexity is O(1). Link: http://stackoverflow.com/questions/1586858/find-the-smallest-integer-not-in-a-list Posted by Ants Aasma on Oct 20 ‘09. The code is pasted here: 12345678910111213#Pass 1, move every value to the position of its valuefor cursor in range(N): target = array[cursor] while target &lt; N and target != array[target]: new_target = array[target] array[target] = target target = new_target#Pass 2, find first location where the index doesn&apos;t match the valuefor cursor in range(N): if array[cursor] != cursor: return cursorreturn N java https://discuss.leetcode.com/topic/2633/share-my-o-n-time-o-1-space-solution Share my O(n) time, O(1) space solution Share my O(n)/O(1) solution The basic idea is for any k positive numbers (duplicates allowed), the first missing positive number must be within [1,k+1]. The reason is like you put k balls into k+1 bins, there must be a bin empty, the empty bin can be viewed as the missing number. Unfortunately, there are 0 and negative numbers in the array, so firstly I think of using partition technique (used in quick sort) to put all positive numbers together in one side. This can be finished in O(n) time, O(1) space. After partition step, you get all the positive numbers lying within A[0,k-1]. Now, According to the basic idea, I infer the first missing number must be within [1,k+1]. I decide to use A[i] (0&lt;=i&lt;=k-1) to indicate whether the number (i+1) exists. But here I still have to main the original information A[i] holds. Fortunately, A[i] are all positive numbers, so I can set them to negative to indicate the existence of (i+1) and I can still use abs(A[i]) to get the original information A[i] holds. After step 2, I can again scan all elements between A[0,k-1] to find the first positive element A[i], that means (i+1) doesn’t exist, which is what I want. 12345678910111213141516171819202122232425262728293031323334353637383940public int firstMissingPositive(int[] A) &#123; int n=A.length; if(n==0) return 1; int k=partition(A)+1; int temp=0; int first_missing_Index=k; for(int i=0;i&lt;k;i++)&#123; temp=Math.abs(A[i]); if(temp&lt;=k) A[temp-1]=(A[temp-1]&lt;0)?A[temp-1]:-A[temp-1]; &#125; for(int i=0;i&lt;k;i++)&#123; if(A[i]&gt;0)&#123; first_missing_Index=i; break; &#125; &#125; return first_missing_Index+1;&#125;public int partition(int[] A)&#123; int n=A.length; int q=-1; for(int i=0;i&lt;n;i++)&#123; if(A[i]&gt;0)&#123; q++; swap(A,q,i); &#125; &#125; return q;&#125;public void swap(int[] A, int i, int j)&#123; if(i!=j)&#123; A[i]^=A[j]; A[j]^=A[i]; A[i]^=A[j]; &#125;&#125; https://discuss.leetcode.com/topic/10351/o-1-space-java-solution O(1) space Java Solution The key here is to use swapping to keep constant space and also make use of the length of the array, which means there can be at most n positive integers. So each time we encounter an valid integer, find its correct position and swap. Otherwise we continue. 12345678910111213141516171819public class Solution &#123; public int firstMissingPositive(int[] A) &#123; int i = 0; while(i &lt; A.length)&#123; if(A[i] == i+1 || A[i] &lt;= 0 || A[i] &gt; A.length) i++; else if(A[A[i]-1] != A[i]) swap(A, i, A[i]-1); else i++; &#125; i = 0; while(i &lt; A.length &amp;&amp; A[i] == i+1) i++; return i+1; &#125; private void swap(int[] A, int i, int j)&#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125;&#125; https://discuss.leetcode.com/topic/25441/beat-100-fast-elegant-java-index-based-solution-with-explanation Beat 100% Fast Elegant Java Index-Based Solution with Explanation The basic idea is to traversal and try to move the current value to position whose index is exactly the value (swap them). Then travelsal again to find the first unusal value, which can not be corresponding to its index. 12345678910111213141516171819202122232425262728293031public int firstMissingPositive(int[] nums) &#123; int i = 0, n = nums.length; while (i &lt; n) &#123; // If the current value is in the range of (0,length) and it&apos;s not at its correct position, // swap it to its correct position. // Else just continue; if (nums[i] &gt;= 0 &amp;&amp; nums[i] &lt; n &amp;&amp; nums[nums[i]] != nums[i]) swap(nums, i, nums[i]); else i++; &#125; int k = 1; // Check from k=1 to see whether each index and value can be corresponding. while (k &lt; n &amp;&amp; nums[k] == k) k++; // If it breaks because of empty array or reaching the end. K must be the first missing number. if (n == 0 || k &lt; n) return k; else // If k is hiding at position 0, K+1 is the number. return nums[0] == k ? k + 1 : k;&#125;private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[040. Combination Sum II]]></title>
    <url>%2Fp%2F217971c0%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/combination-sum-ii/ Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. 123456789For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 方法一： 回溯法，我的代码实现 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end()); vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; combination; helper(candidates, target, 0, combination, res); return res; &#125; void helper(vector&lt;int&gt;&amp; candidates, int target, int start, vector&lt;int&gt;&amp; combination, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(target==0)&#123; res.push_back(combination); return; &#125; if(target&lt;0 || start&gt;=candidates.size()) return; for(int i=start; i&lt;candidates.size(); i++)&#123; if(i!=start &amp;&amp; candidates[i]==candidates[i-1]) continue; combination.push_back(candidates[i]); helper(candidates, target-candidates[i], i+1, combination, res); // start+1 与 i+1 的区别 combination.pop_back(); &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/8916/c-backtracking-solution-with-detailed-explanation C++ backtracking solution with detailed explanation At the beginning, I stuck on this problem. After careful thought, I think this kind of backtracking contains a iterative component and a resursive component so I’d like to give more details to help beginners save time. The revursive component tries the elements after the current one and also tries duplicate elements. So we can get correct answer for cases like [1 1] 2. The iterative component checks duplicate combinations and skip it if it is. So we can get correct answer for cases like [1 1 1] 2. 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combinationSum2(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(num.begin(),num.end()); vector&lt;int&gt; local; findCombination(res, 0, target, local, num); return res; &#125; void findCombination(vector&lt;vector&lt;int&gt;&gt;&amp; res, const int order, const int target, vector&lt;int&gt;&amp; local, const vector&lt;int&gt;&amp; num) &#123; if(target==0) &#123; res.push_back(local); return; &#125; else &#123; for(int i = order;i&lt;num.size();i++) // iterative component &#123; if(num[i]&gt;target) return; if(i&amp;&amp;num[i]==num[i-1]&amp;&amp;i&gt;order) continue; // check duplicate combination local.push_back(num[i]), findCombination(res,i+1,target-num[i],local,num); // recursive componenet local.pop_back(); &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/17682/8ms-c-backtracking-easy-to-understand 8ms C++ backtracking easy to understand 12345678910111213141516171819vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; current; sort(candidates.begin(),candidates.end()); backTracking(candidates.begin(),current,res,candidates,target); return res;&#125;void backTracking(vector&lt;int&gt;::iterator n, vector&lt;int&gt;&amp; current,vector&lt;vector&lt;int&gt;&gt;&amp; res, const vector&lt;int&gt;&amp; candidates, int target)&#123; if(!target) res.push_back(current); else if(target&gt;0)&#123; for(;n!=candidates.end()&amp;&amp;*n&lt;=target;++n)&#123; current.push_back(*n); backTracking(n+1,current,res,candidates,target-*n); current.pop_back(); while(n+1!=candidates.end()&amp;&amp;*(n+1)==*n) ++n; &#125; &#125;&#125; https://discuss.leetcode.com/topic/3399/my-solution-without-using-set My solution without using set My idea is skip same number during recursion. Like Permutations II. Firstly sort num, then search from back for numbers sum to target. 1234567891011121314151617181920212223242526272829vector&lt;vector&lt;int&gt; &gt; combinationSum2(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(num.begin(), num.end()); vector&lt;int&gt; cur; find(num, target, num.size() - 1, res, cur); return res;&#125;void find(vector&lt;int&gt; &amp;num, int target, int end, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; cur)&#123; if (target == 0) &#123; res.push_back(cur); return; &#125; if (end &lt; 0 || num[end] * (end + 1) &lt; target) return; if (num[end] &lt;= target) &#123; cur.insert(cur.begin(), num[end]); find(num, target - num[end], end - 1, res, cur); cur.erase(cur.begin()); &#125; //find combinations ends at the first number different from num[end] int temp = num[end]; while (end &gt;= 0 &amp;&amp; num[end] == temp) end--; find(num, target, end, res, cur);&#125; 12ms, 57.77%, June.21th, 2016 https://leetcode.com/discuss/37071/accepted-16ms-c-solution-use-backtracking-easy-understand 1234567891011121314151617181920212223class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target) &#123; std::sort(candidates.begin(), candidates.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum2(candidates, target, res, combination, 0); return res; &#125;private: void combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin) &#123; if (!target) &#123; res.push_back(combination); return; &#125; for (int i = begin; i != candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) if (i == begin || candidates[i] != candidates[i - 1]) &#123; combination.push_back(candidates[i]); combinationSum2(candidates, target - candidates[i], res, combination, i + 1); combination.pop_back(); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/5777/dp-solution-in-python DP solution in Python I also did it with recursion, turns out the DP solution is 3~4 times faster. 12345678910def combinationSum2(self, candidates, target): candidates.sort() table = [None] + [set() for i in range(target)] for i in candidates: if i &gt; target: break for j in range(target - i, 0, -1): table[i + j] |= &#123;elt + (i,) for elt in table[j]&#125; table[i].add((i,)) return map(list, table[target]) https://discuss.leetcode.com/topic/11852/my-84ms-python-recursive-solution My 84ms python recursive solution. 1234567891011121314151617class Solution: def combinationSum2(self, candidates, target): candidates.sort() return self.search(candidates, 0 ,target) def search(self, candidates, start, target): if target==0: return [[]] res=[] for i in xrange(start,len(candidates)): if i!=start and candidates[i]==candidates[i-1]: continue if candidates[i]&gt;target: break for r in self.search(candidates, i+1, target-candidates[i]): res.append([candidates[i]]+r) return res https://discuss.leetcode.com/topic/47845/beating-98-python-solution-using-recursion-with-comments Beating 98% Python solution using recursion with comments 12345678910111213141516171819202122232425262728293031def combinationSum2(self, candidates, target): # Sorting is really helpful, se we can avoid over counting easily candidates.sort() result = [] self.combine_sum_2(candidates, 0, [], result, target) return result def combine_sum_2(self, nums, start, path, result, target): # Base case: if the sum of the path satisfies the target, we will consider # it as a solution, and stop there if not target: result.append(path) return for i in xrange(start, len(nums)): # Very important here! We don&apos;t use `i &gt; 0` because we always want # to count the first element in this recursive step even if it is the same # as one before. To avoid overcounting, we just ignore the duplicates # after the first element. if i &gt; start and nums[i] == nums[i - 1]: continue # If the current element is bigger than the assigned target, there is # no need to keep searching, since all the numbers are positive if nums[i] &gt; target: break # We change the start to `i + 1` because one element only could # be used once self.combine_sum_2(nums, i + 1, path + [nums[i]], result, target - nums[i]) java https://discuss.leetcode.com/topic/19845/java-solution-using-dfs-easy-understand Java solution using dfs, easy understand 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] cand, int target) &#123; Arrays.sort(cand); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;Integer&gt;(); dfs_com(cand, 0, target, path, res); return res;&#125;void dfs_com(int[] cand, int cur, int target, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (target == 0) &#123; res.add(new ArrayList(path)); return ; &#125; if (target &lt; 0) return; for (int i = cur; i &lt; cand.length; i++)&#123; if (i &gt; cur &amp;&amp; cand[i] == cand[i-1]) continue; path.add(path.size(), cand[i]); dfs_com(cand, i+1, target - cand[i], path, res); path.remove(path.size()-1); &#125;&#125; https://discuss.leetcode.com/topic/44037/combination-sum-i-ii-and-iii-java-solution-see-the-similarities-yourself Combination Sum I, II and III Java solution (see the similarities yourself) Combination Sum I 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(candidates); backtrack(list, new ArrayList&lt;Integer&gt;(), candidates, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] cand, int remain, int start) &#123; if (remain &lt; 0) return; /** no solution */ else if (remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for (int i = start; i &lt; cand.length; i++) &#123; tempList.add(cand[i]); backtrack(list, tempList, cand, remain-cand[i], i); tempList.remove(tempList.size()-1); &#125; &#125;&#125; Combination Sum II 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(candidates); backtrack(list, new ArrayList&lt;Integer&gt;(), candidates, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int[] cand, int remain, int start) &#123; if(remain &lt; 0) return; /** no solution */ else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for (int i = start; i &lt; cand.length; i++) &#123; if(i &gt; start &amp;&amp; cand[i] == cand[i-1]) continue; /** skip duplicates */ tempList.add(cand[i]); backtrack(list, tempList, cand, remain - cand[i], i+1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum III 1234567891011121314151617public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;Integer&gt;(), k, n, 1); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int k, int remain, int start) &#123; if(tempList.size() &gt; k) return; /** no solution */ else if(tempList.size() == k &amp;&amp; remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for (int i = start; i &lt;= 9; i++) &#123; tempList.add(i); backtrack(list, tempList, k, remain-i, i+1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; https://discuss.leetcode.com/topic/24059/java-short-and-recursive-clean-code Java - short and recursive, clean code. 123456789101112131415161718192021222324252627public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); List&lt;Integer&gt; comb = new ArrayList&lt;&gt;(); Arrays.sort(candidates); // need sort to make this work. combination(candidates, target, 0, comb, ans); return ans;&#125;private void combination(int[] candi, int target, int start, List&lt;Integer&gt; comb, List&lt;List&lt;Integer&gt;&gt; ans) &#123; for (int i = start; i &lt; candi.length; i++) &#123; if (i &gt; start &amp;&amp; candi[i] == candi[i - 1]) //remove duplicates. continue; if (candi[i] == target) &#123; //recursion exit. List&lt;Integer&gt; newComb = new ArrayList&lt;&gt;(comb); newComb.add(candi[i]); ans.add(newComb); &#125; else if (candi[i] &lt; target) &#123; //continue to look for the rest. List&lt;Integer&gt; newComb = new ArrayList&lt;&gt;(comb); newComb.add(candi[i]); combination(candi, target - candi[i], i + 1, newComb, ans); &#125; else break; //invalid path, return nothing. &#125;&#125; https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning 12345678910111213141516171819202122public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125; &#125; https://discuss.leetcode.com/topic/34364/java-solutions-beats-99-87 Java solutions beats 99,87% 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); calcCombinationSum2(candidates, 0, new int[candidates.length], 0, target, results); return results; &#125; private void calcCombinationSum2(int[] candidates, int cindex, int[] list, int lindex, int target, List&lt;List&lt;Integer&gt;&gt; results) &#123; if (target == 0) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; lindex; i++) &#123; result.add(list[i]); &#125; results.add(result); return; &#125; int prev = 0; for (int i = cindex; i &lt; candidates.length; i++) &#123; if (candidates[i] != prev) &#123; if (target - candidates[i] &lt; 0) &#123; break; &#125; list[lindex] = candidates[i]; calcCombinationSum2(candidates, i + 1, list, lindex + 1, target - candidates[i], results); prev = candidates[i]; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[039. Combination Sum]]></title>
    <url>%2Fp%2Ff5e0c04b%2F</url>
    <content type="text"><![CDATA[38.6% https://leetcode.com/problems/combination-sum/ Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. 1234567For example, given candidate set [2, 3, 6, 7] and target 7, A solution set is: [ [7], [2, 2, 3]] 方法一： 回溯法, 我的代码实现 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; tmp; sort(candidates.begin(), candidates.end()); helper(candidates, 0, target, tmp, res); return res; &#125; // 0至start-1之间的candidates已经用过了，只能从start开始用了 void helper(vector&lt;int&gt;&amp; candidates, int start, int target, vector&lt;int&gt;&amp; tmp, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(target==0)&#123; res.push_back(tmp); return; &#125;else if(target&lt;0 || start&gt;=candidates.size())&#123; return; &#125; for(int i=start; i&lt;candidates.size(); i++)&#123; tmp.push_back(candidates[i]); helper(candidates, i, target-candidates[i], tmp, res); tmp.pop_back(); &#125; &#125;&#125;; cpp 16ms, 71.93%, June.21th, 2016 https://leetcode.com/discuss/37071/accepted-16ms-c-solution-use-backtracking-easy-understand Accepted 16ms c++ solution use backtracking, easy understand. Accepted 16ms c++ solution use backtracking for Combination Sum: 12345678910111213141516171819202122class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum(std::vector&lt;int&gt; &amp;candidates, int target) &#123; std::sort(candidates.begin(), candidates.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum(candidates, target, res, combination, 0); return res; &#125;private: void combinationSum(std::vector&lt;int&gt; &amp;candidates, int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin) &#123; if (!target) &#123; res.push_back(combination); return; &#125; for (int i = begin; i != candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) &#123; combination.push_back(candidates[i]); combinationSum(candidates, target - candidates[i], res, combination, i); combination.pop_back(); &#125; &#125;&#125;; Accepted 12ms c++ solution use backtracking for Combination Sum II: 1234567891011121314151617181920212223class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target) &#123; std::sort(candidates.begin(), candidates.end()); std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum2(candidates, target, res, combination, 0); return res; &#125;private: void combinationSum2(std::vector&lt;int&gt; &amp;candidates, int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin) &#123; if (!target) &#123; res.push_back(combination); return; &#125; for (int i = begin; i != candidates.size() &amp;&amp; target &gt;= candidates[i]; ++i) if (i == begin || candidates[i] != candidates[i - 1]) &#123; combination.push_back(candidates[i]); combinationSum2(candidates, target - candidates[i], res, combination, i + 1); combination.pop_back(); &#125; &#125;&#125;; Accepted 0ms c++ solution use backtracking for Combination Sum III: 1234567891011121314151617181920212223class Solution &#123;public: std::vector&lt;std::vector&lt;int&gt; &gt; combinationSum3(int k, int n) &#123; std::vector&lt;std::vector&lt;int&gt; &gt; res; std::vector&lt;int&gt; combination; combinationSum3(n, res, combination, 1, k); return res; &#125;private: void combinationSum3(int target, std::vector&lt;std::vector&lt;int&gt; &gt; &amp;res, std::vector&lt;int&gt; &amp;combination, int begin, int need) &#123; if (!target) &#123; res.push_back(combination); return; &#125; else if (!need) return; for (int i = begin; i != 10 &amp;&amp; target &gt;= i * need + need * (need - 1) / 2; ++i) &#123; combination.push_back(i); combinationSum3(target - i, res, combination, i + 1, need - 1); combination.pop_back(); &#125; &#125;&#125;; https://discuss.leetcode.com/topic/6431/concise-backtracking-solution Concise Backtracking Solution We backtrack from successful searches as well because they are saved at the leafs of recursion tree 12345678910111213141516171819202122232425262728293031class Solution &#123;public: void search(vector&lt;int&gt;&amp; num, int next, vector&lt;int&gt;&amp; pSol, int target, vector&lt;vector&lt;int&gt; &gt;&amp; result) &#123; if(target == 0) &#123; result.push_back(pSol); return; &#125; if(next == num.size() || target - num[next] &lt; 0) return; pSol.push_back(num[next]); search(num, next, pSol, target - num[next], result); pSol.pop_back(); search(num, next + 1, pSol, target, result); &#125; vector&lt;vector&lt;int&gt; &gt; combinationSum(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt; &gt; result; sort(num.begin(), num.end()); vector&lt;int&gt; pSol; search(num, 0, pSol, target, result); return result; &#125;&#125;; https://discuss.leetcode.com/topic/4454/dynamic-programming-solution Dynamic Programming Solution It adapts the DP solution of coin change problem 12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; combinationSum(vector&lt;int&gt; &amp;candidates, int target) &#123; vector&lt; vector&lt; vector&lt;int&gt; &gt; &gt; combinations(target + 1, vector&lt;vector&lt;int&gt;&gt;()); combinations[0].push_back(vector&lt;int&gt;()); for (auto&amp; score : candidates) for (int j = score; j &lt;= target; j++) if (combinations[j - score].size() &gt; 0) &#123; auto tmp = combinations[j - score]; for (auto&amp; s : tmp) s.push_back(score); combinations[j].insert(combinations[j].end(), tmp.begin(), tmp.end()); &#125; auto ret = combinations[target]; for (int i = 0; i &lt; ret.size(); i++) sort(ret[i].begin(), ret[i].end()); return ret; &#125;&#125;; python 188ms, 27.12%, June.21th, 2016 https://leetcode.com/discuss/55666/python-dfs-solution Python dfs solution. 1234567891011121314151617181920class Solution(object): def combinationSum(self, candidates, target): &quot;&quot;&quot; :type candidates: List[int] :type target: int :rtype: List[List[int]] &quot;&quot;&quot; res = [] candidates.sort() self.dfs(candidates, target, [], res, 0) return res def dfs(self, nums, target, path, res, index): if target &lt; 0: return if target == 0: res.append(path) return for i in xrange(index, len(nums)): self.dfs(nums, target - nums[i], path + [nums[i]], res, i) 100ms, 88.35%, June.21th, 2016 https://leetcode.com/discuss/55666/python-dfs-solution 1234567891011121314151617181920class Solution(object): def combinationSum(self, candidates, target): &quot;&quot;&quot; :type candidates: List[int] :type target: int :rtype: List[List[int]] &quot;&quot;&quot; res = [] candidates.sort() self.dfs(candidates, target, [], res, 0) return res def dfs(self, nums, target, path, res, index): if target == 0: res.append(path) return for i in xrange(index, len(nums)): if nums[i] &gt; target: break self.dfs(nums, target - nums[i], path + [nums[i]], res, i) java https://discuss.leetcode.com/topic/46159/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning) This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. Subsets : https://leetcode.com/problems/subsets/ 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Subsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/ 12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; Permutations : https://leetcode.com/problems/permutations/ 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Permutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/ 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum : https://leetcode.com/problems/combination-sum/ 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Combination Sum II (can’t reuse same element) : https://leetcode.com/problems/combination-sum-ii/ 1234567891011121314151617181920public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, target, 0); return list; &#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int remain, int start)&#123; if(remain &lt; 0) return; else if(remain == 0) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, remain - nums[i], i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Palindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/ 12345678910111213141516171819202122232425public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), s, 0); return list;&#125;public void backtrack(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, int start)&#123; if(start == s.length()) list.add(new ArrayList&lt;&gt;(tempList)); else&#123; for(int i = start; i &lt; s.length(); i++)&#123; if(isPalindrome(s, start, i))&#123; tempList.add(s.substring(start, i + 1)); backtrack(list, tempList, s, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125; &#125;&#125;public boolean isPalindrome(String s, int low, int high)&#123; while(low &lt; high) if(s.charAt(low++) != s.charAt(high--)) return false; return true;&#125; 6ms, 66.615, June.21th, 2016 https://leetcode.com/discuss/22651/java-solution-using-recursive Java solution using recursive 12345678910111213141516171819202122public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); getResult(result, new ArrayList&lt;Integer&gt;(), candidates, target, 0); return result; &#125; private void getResult(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; cur, int candidates[], int target, int start)&#123; if(target &gt; 0)&#123; for(int i = start; i &lt; candidates.length &amp;&amp; target &gt;= candidates[i]; i++)&#123; cur.add(candidates[i]); getResult(result, cur, candidates, target - candidates[i], i); cur.remove(cur.size() - 1); &#125;//for &#125;//if else if(target == 0 )&#123; result.add(new ArrayList&lt;Integer&gt;(cur)); &#125;//else if &#125;&#125; https://discuss.leetcode.com/topic/8200/iterative-java-dp-solution Iterative Java DP solution Hi guys! The main idea reminds an approach for solving coins/knapsack problem - to store the result for all i &lt; target and create the solution from them. For that for each t from 1 to our target we try every candidate which is less or equal to t in ascending order. For each candidate “c” we run through all combinations for target t-c starting with the value greater or equal than c to avoid duplicates and store only ordered combinations. 123456789101112131415161718192021222324public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] cands, int t) &#123; Arrays.sort(cands); // sort candidates to try them in asc order List&lt;List&lt;List&lt;Integer&gt;&gt;&gt; dp = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= t; i++) &#123; // run through all targets from 1 to t List&lt;List&lt;Integer&gt;&gt; newList = new ArrayList(); // combs for curr i // run through all candidates &lt;= i for (int j = 0; j &lt; cands.length &amp;&amp; cands[j] &lt;= i; j++) &#123; // special case when curr target is equal to curr candidate if (i == cands[j]) newList.add(Arrays.asList(cands[j])); // if current candidate is less than the target use prev results else for (List&lt;Integer&gt; l : dp.get(i-cands[j]-1)) &#123; if (cands[j] &lt;= l.get(0)) &#123; List cl = new ArrayList&lt;&gt;(); cl.add(cands[j]); cl.addAll(l); newList.add(cl); &#125; &#125; &#125; dp.add(newList); &#125; return dp.get(t-1); &#125;&#125; Hope it helps! https://discuss.leetcode.com/topic/3043/a-solution-avoid-using-set A solution avoid using set Sort the candidates and we choose from small to large recursively, every time we add a candidate to our possible sub result, we subtract the target to a new smaller one. 12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(candidates); // sort the candidates // collect possible candidates from small to large to eliminate duplicates, recurse(new ArrayList&lt;Integer&gt;(), target, candidates, 0, ret); return ret;&#125;// the index here means we are allowed to choose candidates from that indexprivate void recurse(List&lt;Integer&gt; list, int target, int[] candidates, int index, List&lt;List&lt;Integer&gt;&gt; ret) &#123; if (target == 0) &#123; ret.add(list); return; &#125; for (int i = index; i &lt; candidates.length; i++) &#123; int newTarget = target - candidates[i]; if (newTarget &gt;= 0) &#123; List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(list); copy.add(candidates[i]); recurse(copy, newTarget, candidates, i, ret); &#125; else &#123; break; &#125; &#125;&#125; https://discuss.leetcode.com/topic/3043/a-solution-avoid-using-set/2 Slightly modified your solution, this will make the method run a little faster. 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(candidates); // sort the candidates // collect possible candidates from small to large to eliminate duplicates, recurse(new ArrayList&lt;Integer&gt;(), target, candidates, 0, ret); return ret;&#125;// the index here means we are allowed to choose candidates from that indexprivate void recurse(List&lt;Integer&gt; list, int target, int[] candidates, int index, List&lt;List&lt;Integer&gt;&gt; ret) &#123; if (target == 0) &#123; ret.add(list); return; &#125; for (int i = index; i &lt; candidates.length; i++) &#123; int newTarget = target - candidates[i]; if (newTarget &gt;= 0) &#123; List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(list); copy.add(candidates[i]); recurse(copy, newTarget, candidates, i, ret); &#125;else&#123;break;&#125; &#125; https://discuss.leetcode.com/topic/8364/java-solution-backtracking Java solution (backtracking) 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; private List&lt;List&lt;Integer&gt;&gt; solution; private List&lt;Integer&gt; curSolution; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; solution = new ArrayList&lt;List&lt;Integer&gt;&gt;(); curSolution = new ArrayList&lt;Integer&gt;(); Arrays.sort(candidates); backTrack(candidates, target, 0); return solution; &#125; private void backTrack(int[] candidates, int target, int lastIdx) &#123; if (target == 0) &#123; solution.add(new ArrayList&lt;&gt;(curSolution)); &#125; else if (target &lt; 0) &#123; return; &#125; else &#123; int i = lastIdx; while (i &lt; candidates.length) &#123; int candidate = candidates[i]; curSolution.add(candidate); backTrack(candidates, target - candidate, i); curSolution.remove(curSolution.size() - 1); while (i &lt; candidates.length &amp;&amp; candidates[i] == candidate) &#123; i++; &#125; &#125; &#125; &#125;&#125; https://discuss.leetcode.com/topic/4997/non-recursive-java-solution Non-Recursive JAVA solution 12345678910111213141516171819202122232425262728293031public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); int i=0, size = candidates.length, sum=0; Stack&lt;Integer&gt; combi = new Stack&lt;&gt;(), indices = new Stack&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); while (i &lt; size) &#123; if (sum + candidates[i]&gt;= target) &#123; if (sum + candidates[i] == target) &#123; combi.push(candidates[i]); result.add(new ArrayList&lt;&gt;(combi)); combi.pop(); &#125; // indices stack and combination stack should have the same size all the time if (!indices.empty())&#123; sum -= combi.pop(); i = indices.pop(); while (i == size-1 &amp;&amp; !indices.empty()) &#123; i = indices.pop(); sum -= combi.pop(); &#125; &#125; i++; &#125; else &#123; combi.push(candidates[i]); sum +=candidates[i]; indices.push(i); &#125; &#125; return result;&#125; https://discuss.leetcode.com/topic/6994/recursive-java-solution Recursive java solution 12345678910111213141516171819202122232425262728293031323334public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); // sort the array, so the result could be increasing order List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i = 0; i &lt; candidates.length; i++)&#123; // target smaller than current number, jump the current and rest of numbers if(target &lt; candidates[i]) continue; // if target is equal to the current number,add it to a new list and add that list to result else if(target == candidates[i])&#123; List&lt;Integer&gt; set = new ArrayList&lt;Integer&gt;(); set.add(candidates[i]); result.add(set); &#125; // if the target is smaller the current number,call this function again else&#123; // use modified array which not includes those numbers that before i to eliminate the duplicates int[] array = Arrays.copyOfRange(candidates,i,candidates.length); // call this function. pass the new target and modified array. List&lt;List&lt;Integer&gt;&gt; temp = combinationSum(array, target - candidates[i]); // for each list in the return list, add current number in the front of list, then add it to result // attention that if return list is null, this enhanced for loop will not perform. for(List&lt;Integer&gt; list:temp)&#123; list.add(0,candidates[i]); result.add(list); &#125; &#125; &#125; return result;&#125; They key point is passing new target and modified array. Pass the modified array to make sure no duplicates set. If the new target could not find a match number, the return list will be null, thus this null list will not be added to the result list.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[038. Count and Say]]></title>
    <url>%2Fp%2Ff2d63f47%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/count-and-say/ 1234567The count-and-say sequence is the sequence of integers beginning as follows:1, 11, 21, 1211, 111221, ...1 is read off as &quot;one 1&quot; or 11.11 is read off as &quot;two 1s&quot; or 21.21 is read off as &quot;one 2, then one 1&quot; or 1211.Given an integer n, generate the nth sequence. Note: The sequence of integers will be represented as a string. https://discuss.leetcode.com/topic/1296/please-change-the-misleading-description Please change the misleading description It seems not only me misunderstood the question. Please modify the description, since it’s frustrating if you are solving a “different” question. Thanks. https://discuss.leetcode.com/topic/2264/examples-of-nth-sequence Examples of nth sequence At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I’m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10: 1234567891011test 1. 1 2. 11 3. 21 4. 1211 5. 111221 6. 312211 7. 13112221 8. 1113213211 9. 31131211131221 10. 13211311123113112211 From the examples you can see, the (i+1)th sequence is the “count and say” of the ith sequence! Hope this helps! https://discuss.leetcode.com/topic/2526/i-suggest-we-should-add-the-description-the-1-is-the-1st-string-and-calculate-the-n-th-string I suggest we should add the description: The “1” is the 1st string, and calculate the n th string. Because usually we start from the 0 th item, so add this description to avoid misunderstanding. java 6ms, September 19, 2016 https://discuss.leetcode.com/topic/2309/show-an-answer-in-java Show an Answer in Java I found nobody answered this question in Java. Actually I got some trouble even this question is not so hard. Maybe many other people had some trouble too. So I put my answer here. @code StringBuilder.append() is the default way to append one string to another. While I have tried String.cancate(),which is not working properly. Any comment is welcomed. 12345678910111213141516171819202122232425public class Solution &#123; public String countAndSay(int n) &#123; StringBuilder curr = new StringBuilder(&quot;1&quot;); StringBuilder prev; int count; char say; for(int i=1; i&lt;n; i++)&#123; prev = curr; curr = new StringBuilder(); count = 1; say = prev.charAt(0); for(int j=1, len=prev.length(); j&lt;len; j++)&#123; if(prev.charAt(j)!=say)&#123; curr.append(count).append(say); count = 1; say = prev.charAt(j); &#125; else count++; &#125; curr.append(count).append(say); &#125; return curr.toString(); &#125;&#125; https://discuss.leetcode.com/topic/14543/straightforward-java-solution Straightforward Java Solution 123456789101112131415161718192021222324252627282930public class Solution &#123; public String countAndSay(int n) &#123; String s = &quot;1&quot;; for(int i = 1; i &lt; n; i++)&#123; s = countIdx(s); &#125; return s; &#125; public String countIdx(String s)&#123; StringBuilder sb = new StringBuilder(); char c = s.charAt(0); int count = 1; for(int i = 1; i &lt; s.length(); i++)&#123; if(s.charAt(i) == c)&#123; count++; &#125; else &#123; sb.append(count); sb.append(c); c = s.charAt(i); count = 1; &#125; &#125; sb.append(count); sb.append(c); return sb.toString(); &#125;&#125; cpp 3ms, September 19, 2016 https://discuss.leetcode.com/topic/20195/c-solution-easy-understand C++ solution easy-understand 1234567891011121314151617181920class Solution &#123;public: string countAndSay(int n) &#123; if(n==0) return &quot;&quot;; string res = &quot;1&quot;; while(--n)&#123; string cur = &quot;&quot;; for(int i=0; i&lt;res.size(); i++)&#123; int count = 1; while((i+1&lt;res.size())&amp;&amp;(res[i] == res[i+1]))&#123; count++; i++; &#125; cur += to_string(count) + res[i]; &#125; res = cur; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/2068/how-to-proof-the-count-is-always-less-than-10 How to proof the COUNT is always less than 10? At first, I solved this problem with the considering of the cases when COUNT is greater than 9, which can not be handled using:curString +=count+’0’;, since it is more than one digit. And I solved it using itoa. But when I thinked about the problem, it seems that the COUNT is always less than 10, even 4. Then I re-writed the solution and also accepted by OJ. Can you guys help me proof it?My code: 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string countAndSay(int n) &#123; string prevString; string curString = &quot;1&quot;; for (int i = 1; i&lt;n; ++i)&#123; prevString = curString; curString = &quot;&quot;; int count = 1; char digit = prevString[0]; for (int j = 1; j&lt;prevString.length(); ++j)&#123; if (prevString[j] == digit)&#123; ++count; &#125; else&#123; curString +=count+&apos;0&apos;; //myItoa(count); curString += digit; digit = prevString[j]; count = 1; &#125; &#125; curString += count+&apos;0&apos;;//myItoa(count); curString += digit; &#125; return curString; &#125;/*private: string myItoa(int i)&#123; string str; while (i)&#123; str += i%10+&apos;0&apos;; i /=10; &#125; reverse(str.begin(), str.end()); return str; &#125;*/&#125;; https://discuss.leetcode.com/topic/2068/how-to-proof-the-count-is-always-less-than-10/2 Proof by exhaustion and contrapositive: In order for a number greater than 4 to be created, there must be a series of numbers n&gt;4 in length all the same digit. Therefore, there is a subset of that series where the count would only reach 4. Because of this, any proof for the existence of a chain resulting in a number greater than 4 is also a proof for the existence of a 4-chain. Using the proof by contrapositive, this means that if 4-chains are proved to be impossible, then any n-chain with n&gt;4 is also impossible. In order to start with a chain with numbers greater than 4, you must assume that a 4-chain is possible in the first place, which is circular reasoning, and so cannot be used as an initial point. It is further impossible to have a negative value, since the counting numbers do not include them. Therefore, the only chains able to create a 4 (at least the first one) are 0000, 1111, 2222, or 3333. 10 0 0 0 -&gt; 40 The 0000 is read zero 0, zero 0, which must come from . Since there is nothing present, it could in theory occur anywhere in the string. However, since they would be next to each other, if the 0 is repeated as would be neccessary, the zeros would add together, resulting in just zero 0, leaving only 20, not 40. 11 1 1 1 -&gt; 41 The 1111 is read one 1, one 1 (or 11), which translates to 21, not 1111. This contradicts the assumption that there is a way to get 1111, and so prevents 4 or greater from appearing. Therefore, 1s cannot reach 4. 12 2 2 2 -&gt; 42 The 2222 is read two 2, two 2 (or 22 22), which is identical to the output. Since the input maps to itself, there is no way to leave that cycle, or it already would have. If 2222 exists in the input, then 2222 must have mapped to it. It cannot reach 42. Therefore, 2s cannot reach 4. 13 3 3 3 -&gt; 43 The 3333 is read three 3, three 3 (or 333 333). This in turn would require 333 333 333. This fails in two respects. First, that the previous inputs would not merge to 63 or 93. The second, that the sequence eventually traces back to the origin, 1. Since it keeps increasing in length as the number of rounds since the start decreases, it cannot have started at 1. Therefore, 3s cannot reach 4. As every possible case has been examined, and none can reach a 4 while starting at the given beginning (1), it is not possible for a 4-chain to occur, meaning a 4 cannot appear in any valid string for this problem. Further, as stated above, since a 4-chain is impossible, so too are all n-chains with n&gt;4, so no number greater than 4 can appear either. https://discuss.leetcode.com/topic/5377/c-solution-runtime-o-n-space-o-n C++ solution, runtime O(n), space O(n) Please see the comments in the code.The solution is quite straight-forward. We generate k-th string, and from k-th string we generate k+1-th string, until we generate n-th string.We use string-helper to save temporary result,I’m sure there is a way for in-place solution also. 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: std::string countAndSay(int n) &#123; if (0 == n) return &quot;&quot;; if (1 == n) return &quot;1&quot;; std::string res=&quot;1&quot;; std::string s; for (int i = 1; i &lt; n; i++)&#123; // run from starting to generate second string int len = res.size(); //cheack all digits in the string for (int j = 0; j &lt; len; j++)&#123; int count=1; // we have at least 1 occourence of each digit // get the number of times same digit occurred (be carefull with the end of the string) while ((j + 1 &lt; len) &amp;&amp; (res[j] == res[j + 1]))&#123; count++; j++; // we need to keep increasing the index inside of the string &#125; // add to new string &quot;count&quot;+&quot;digit itself&quot; s += std::to_string(count) + res[j]; &#125; // save temporary result res = s; // clean our string-helper s.clear(); &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/7800/c-iterative-solution-with-explanation-easy-to-understand C++ iterative solution with explanation, easy to understand. Renewed Solution The key point here is to find the maximum consecutive identical numbers, which means, for example: Say there is a array like this [1, 1, 2, 3, 4, 4, 5, 5, 5], we will need to divide the array into different segments like this, [1, 1], [2], [3], [4, 4], [5, 5, 5]. Only in this way, can we count the occurrence of each consecutive segments and convert them into “21 12 13 24 35”. The description of the problem is misleading and I struggled for a while, after some searching I found the right explanation. The number n has nothing to do with the algorithm directly, but but only control the number of iteration. The problem can be solved by using iterative algorithm. Code 1234567891011121314151617181920212223242526272829303132333435string countAndSay(int n)&#123; string curr_str; // The initial case, when n = 1 curr_str += &apos;1&apos;; // The iterative case, when n &gt; 1 for (int i = 0; i &lt; n - 1; i++) &#123; string buffer; // Handle the current string int index = 0; for (int index = 0; index &lt; curr_str.size(); ++index) &#123; // Count the occurance of each digit int cnt = 1; // At least one occurance while (index + 1 &lt; curr_str.size() and curr_str[index + 1] == curr_str[index]) &#123; index++; cnt++; &#125; buffer.push_back(cnt + &apos;0&apos;); buffer.push_back(curr_str[index]); &#125; // Update the current string curr_str = buffer; &#125; return curr_str;&#125; python 52ms, September 19, 2016 https://discuss.leetcode.com/topic/28084/simple-python-solution Idea here is keep track of the first letter in the sequence and count consecutive occurances. Once you encounter a new letter you add the previous count and letter to the chain. Repeat n-1 times (since we seeded the initial ‘1’ case). We always update temp after the inner loop since we will never have already added the last sequence. 12345678910111213141516171819class Solution(object): def countAndSay(self, n): &quot;&quot;&quot; :type n: int :rtype: str &quot;&quot;&quot; s = &apos;1&apos; for _ in range(n-1): let, temp, count = s[0], &apos;&apos;, 0 for l in s: if let == l: count += 1 else: temp += str(count) + let let = l count = 1 temp += str(count) + let s = temp return s https://discuss.leetcode.com/topic/28084/simple-python-solution Simple Python Solution Idea here is keep track of the first letter in the sequence and count consecutive occurances. Once you encounter a new letter you add the previous count and letter to the chain. Repeat n-1 times (since we seeded the initial ‘1’ case). We always update temp after the inner loop since we will never have already added the last sequence. 1234567891011121314def countAndSay(self, n): s = &apos;1&apos; for _ in range(n-1): let, temp, count = s[0], &apos;&apos;, 0 for l in s: if let == l: count += 1 else: temp += str(count)+let let = l count = 1 temp += str(count)+let s = temp return s https://discuss.leetcode.com/topic/32023/4-5-lines-python-solutions 4-5 lines Python solutions Solution 1 … using a regular expression 12345def countAndSay(self, n): s = &apos;1&apos; for _ in range(n - 1): s = re.sub(r&apos;(.)\1*&apos;, lambda m: str(len(m.group(0))) + m.group(1), s) return s Solution 2 … using a regular expression 123456def countAndSay(self, n): s = &apos;1&apos; for _ in range(n - 1): s = &apos;&apos;.join(str(len(group)) + digit for group, digit in re.findall(r&apos;((.)\2*)&apos;, s)) return s Solution 3 … using groupby 123456def countAndSay(self, n): s = &apos;1&apos; for _ in range(n - 1): s = &apos;&apos;.join(str(len(list(group))) + digit for digit, group in itertools.groupby(s)) return s]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[037. Sudoku Solver]]></title>
    <url>%2Fp%2Ff1a3dfa0%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/sudoku-solver/ Write a program to solve a Sudoku puzzle by filling the empty cells. Empty cells are indicated by the character ‘.’. You may assume that there will be only one unique solution. A sudoku puzzle… …and its solution numbers marked in red. https://discuss.leetcode.com/topic/2145/there-is-a-dancing-links-x-algorithm There is a Dancing Links X Algorithm Dr. Donald Knuth’s Dancing Links Algorithm solves an Exact Cover situation. The Exact Cover problem can be extended to a variety of applications that need to fill constraints. Sudoku is one such special case of the Exact Cover problem. NOTE:This is a very complicate solution. A Sudoku Solver in Java implementing Knuth’s Dancing Links Algorithm java 25ms, 54.00%, September 21, 2016 https://discuss.leetcode.com/topic/11327/straight-forward-java-solution-using-backtracking Straight Forward Java Solution Using Backtracking Try 1 through 9 for each cell. The time complexity should be 9 ^ m (m represents the number of blanks to be filled in), since each blank can have 9 choices. Details see comments inside code. Let me know your suggestions. Sorry for being late to answer the time complexity question 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public void solveSudoku(char[][] board) &#123; if(board == null || board.length == 0) return; solve(board); &#125; public boolean solve(char[][] board)&#123; for(int i=0; i&lt;board.length; i++)&#123; for(int j=0; j&lt;board[0].length; j++)&#123; if(board[i][j]==&apos;.&apos;)&#123; for(char c=&apos;1&apos;; c&lt;=&apos;9&apos;; c++)&#123; if(isValid(board, i, j, c))&#123; board[i][j] = c; if(solve(board)) return true; else board[i][j]=&apos;.&apos;; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; public boolean isValid(char[][] board, int i, int j, char c)&#123; for(int row = 0; row&lt;9; row++) if(board[row][j] == c) return false; for(int col = 0; col&lt;9; col++) if(board[i][col] == c) return false; for(int row = (i/3)*3; row &lt; (i/3)*3 + 3; row++) for(int col = (j/3)*3; col &lt; (j/3)*3+3; col++) if(board[row][col] == c) return false; return true; &#125;&#125; cpp https://discuss.leetcode.com/topic/7195/sharing-my-2ms-c-solution-with-comments-and-explanations Sharing my 2ms C++ solution with comments and explanations. Update: there’s a follow-up 0ms solution which is even more optimized This is one of the fastest Sudoku solvers I’ve ever written. It is compact enough - just 150 lines of C++ code with comments. I thought it’d be interesting to share it, since it combines several techniques like reactive network update propagation and backtracking with very aggressive pruning. The algorithm is online - it starts with an empty board and as you add numbers to it, it starts solving the Sudoku. Unlike in other solutions where you have bitmasks of allowed/disallowed values per row/column/square, this solution track bitmask for every(!) cell, forming a set of constraints for the allowed values for each particular cell. Once a value is written into a cell, new constraints are immediately propagated to row, column and 3x3 square of the cell. If during this process a value of other cell can be unambiguously deduced - then the value is set, new constraints are propagated, so on…. You can think about this as an implicit reactive network of cells. If we’re lucky (and we’ll be lucky for 19 of 20 of Sudokus published in magazines) then Sudoku is solved at the end (or even before!) processing of the input. Otherwise, there will be empty cells which have to be resolved. Algorithm uses backtracking for this purpose. To optimize it, algorithm starts with the cell with the smallest ambiguity. This could be improved even further by using priority queue (but it’s not implemented here). Backtracking is more or less standard, however, at each step we guess the number, the reactive update propagation comes back into play and it either quickly proves that the guess is unfeasible or significantly prunes the remaining search space. It’s interesting to note, that in this case taking and restoring snapshots of the compact representation of the state is faster than doing backtracking rollback by “undoing the moves”. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141class Solution &#123; struct cell // encapsulates a single cell on a Sudoku board &#123; uint8_t value; // cell value 1..9 or 0 if unset // number of possible (unconstrained) values for the cell uint8_t numPossibilities; // if bitset[v] is 1 then value can&apos;t be v bitset&lt;10&gt; constraints; cell() : value(0), numPossibilities(9),constraints() &#123;&#125;; &#125;; array&lt;array&lt;cell,9&gt;,9&gt; cells; // sets the value of the cell to [v] // the function also propagates constraints to other cells and deduce new values where possible bool set(int i, int j, int v) &#123; // updating state of the cell cell&amp; c = cells[i][j]; if (c.value == v) return true; if (c.constraints[v]) return false; c.constraints = bitset&lt;10&gt;(0x3FE); // all 1s c.constraints.reset(v); c.numPossibilities = 1; c.value = v; // propagating constraints for (int k = 0; k&lt;9; k++) &#123; // to the row: if (i != k &amp;&amp; !updateConstraints(k, j, v)) return false; // to the column: if (j != k &amp;&amp; !updateConstraints(i, k, v)) return false; // to the 3x3 square: int ix = (i / 3) * 3 + k / 3; int jx = (j / 3) * 3 + k % 3; if (ix != i &amp;&amp; jx != j &amp;&amp; !updateConstraints(ix, jx, v)) return false; &#125; return true; &#125; // update constraints of the cell i,j by excluding possibility of &apos;excludedValue&apos; // once there&apos;s one possibility left the function recurses back into set() bool updateConstraints(int i, int j, int excludedValue) &#123; cell&amp; c = cells[i][j]; if (c.constraints[excludedValue]) &#123; return true; &#125; if (c.value == excludedValue) &#123; return false; &#125; c.constraints.set(excludedValue); if (--c.numPossibilities &gt; 1) return true; for (int v = 1; v &lt;= 9; v++) &#123; if (!c.constraints[v]) &#123; return set(i, j, v); &#125; &#125; assert(false); &#125; // backtracking state - list of empty cells vector&lt;pair&lt;int, int&gt;&gt; bt; // find values for empty cells bool findValuesForEmptyCells() &#123; // collecting all empty cells bt.clear(); for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (!cells[i][j].value) bt.push_back(make_pair(i, j)); &#125; &#125; // making backtracking efficient by pre-sorting empty cells by numPossibilities sort(bt.begin(), bt.end(), [this](const pair&lt;int, int&gt;&amp;a, const pair&lt;int, int&gt;&amp;b) &#123; return cells[a.first][a.second].numPossibilities &lt; cells[b.first][b.second].numPossibilities; &#125;); return backtrack(0); &#125; // Finds value for all empty cells with index &gt;=k bool backtrack(int k) &#123; if (k &gt;= bt.size()) return true; int i = bt[k].first; int j = bt[k].second; // fast path - only 1 possibility if (cells[i][j].value) return backtrack(k + 1); auto constraints = cells[i][j].constraints; // slow path &gt;1 possibility. // making snapshot of the state array&lt;array&lt;cell,9&gt;,9&gt; snapshot(cells); for (int v = 1; v &lt;= 9; v++) &#123; if (!constraints[v]) &#123; if (set(i, j, v)) &#123; if (backtrack(k + 1)) return true; &#125; // restoring from snapshot, // note: computationally this is cheaper // than alternative implementation with undoing the changes cells = snapshot; &#125; &#125; return false; &#125;public: void solveSudoku(vector&lt;vector&lt;char&gt;&gt; &amp;board) &#123; cells = array&lt;array&lt;cell,9&gt;,9&gt;(); // clear array // Decoding input board into the internal cell matrix. // As we do it - constraints are propagated and even additional values are set as we go // (in the case if it is possible to unambiguously deduce them). for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != &apos;.&apos; &amp;&amp; !set(i, j, board[i][j] - &apos;0&apos;)) return; // sudoku is either incorrect or unsolvable &#125; &#125; // if we&apos;re lucky we&apos;ve already got a solution, // however, if we have empty cells we need to use backtracking to fill them if (!findValuesForEmptyCells()) return; // sudoku is unsolvable // copying the solution back to the board for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (cells[i][j].value) board[i][j] = cells[i][j].value + &apos;0&apos;; &#125; &#125; &#125;&#125;; https://discuss.leetcode.com/topic/13314/singapore-prime-minister-lee-hsien-loong-s-sudoku-solver-code-runs-in-1ms Singapore prime minister Lee Hsien Loong’s Sudoku Solver code runs in 1ms Singapore’s prime minister Lee Hsien Loong showcased his Sudoku Solver C code. You can read his original Facebook post here and another news reporting it here. I have made some slight modification to adapt it so it can be tested on LeetCode OJ. It passed all 6/6 test cases with a runtime of 1 ms. Pretty impressive for a prime minister, huh? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159// Original author: Hsien Loong Lee (http://bit.ly/1zfIGMc)// Slight modification by @1337c0d3r to adapt to run on LeetCode OJ.// https://leetcode.com/problems/sudoku-solver/int InBlock[81], InRow[81], InCol[81];const int BLANK = 0;const int ONES = 0x3fe; // Binary 1111111110int Entry[81]; // Records entries 1-9 in the grid, as the corresponding bit set to 1int Block[9], Row[9], Col[9]; // Each int is a 9-bit arrayint SeqPtr = 0;int Sequence[81];void SwapSeqEntries(int S1, int S2)&#123; int temp = Sequence[S2]; Sequence[S2] = Sequence[S1]; Sequence[S1] = temp;&#125;void InitEntry(int i, int j, int val)&#123; int Square = 9 * i + j; int valbit = 1 &lt;&lt; val; int SeqPtr2; // add suitable checks for data consistency Entry[Square] = valbit; Block[InBlock[Square]] &amp;= ~valbit; Col[InCol[Square]] &amp;= ~valbit; // Simpler Col[j] &amp;= ~valbit; Row[InRow[Square]] &amp;= ~valbit; // Simpler Row[i] &amp;= ~valbit; SeqPtr2 = SeqPtr; while (SeqPtr2 &lt; 81 &amp;&amp; Sequence[SeqPtr2] != Square) SeqPtr2++ ; SwapSeqEntries(SeqPtr, SeqPtr2); SeqPtr++;&#125;void PrintArray(char **board)&#123; int i, j, valbit, val, Square; char ch; Square = 0; for (i = 0; i &lt; 9; i++) &#123; for (j = 0; j &lt; 9; j++) &#123; valbit = Entry[Square++]; if (valbit == 0) ch = &apos;-&apos;; else &#123; for (val = 1; val &lt;= 9; val++) if (valbit == (1 &lt;&lt; val)) &#123; ch = &apos;0&apos; + val; break; &#125; &#125; board[i][j] = ch; &#125; &#125;&#125;int NextSeq(int S)&#123; int S2, Square, Possibles, BitCount; int T, MinBitCount = 100; for (T = S; T &lt; 81; T++) &#123; Square = Sequence[T]; Possibles = Block[InBlock[Square]] &amp; Row[InRow[Square]] &amp; Col[InCol[Square]]; BitCount = 0; while (Possibles) &#123; Possibles &amp;= ~(Possibles &amp; -Possibles); BitCount++; &#125; if (BitCount &lt; MinBitCount) &#123; MinBitCount = BitCount; S2 = T; &#125; &#125; return S2;&#125;void Place(int S, char** board)&#123; if (S &gt;= 81) &#123; PrintArray(board); return; &#125; int S2 = NextSeq(S); SwapSeqEntries(S, S2); int Square = Sequence[S]; int BlockIndex = InBlock[Square], RowIndex = InRow[Square], ColIndex = InCol[Square]; int Possibles = Block[BlockIndex] &amp; Row[RowIndex] &amp; Col[ColIndex]; while (Possibles) &#123; int valbit = Possibles &amp; (-Possibles); // Lowest 1 bit in Possibles Possibles &amp;= ~valbit; Entry[Square] = valbit; Block[BlockIndex] &amp;= ~valbit; Row[RowIndex] &amp;= ~valbit; Col[ColIndex] &amp;= ~valbit; Place(S + 1, board); Entry[Square] = BLANK; // Could be moved out of the loop Block[BlockIndex] |= valbit; Row[RowIndex] |= valbit; Col[ColIndex] |= valbit; &#125; SwapSeqEntries(S, S2);&#125;void solveSudoku(char **board, int m, int n) &#123; SeqPtr = 0; int i, j, Square; for (i = 0; i &lt; 9; i++) for (j = 0; j &lt; 9; j++) &#123; Square = 9 * i + j; InRow[Square] = i; InCol[Square] = j; InBlock[Square] = (i / 3) * 3 + ( j / 3); &#125; for (Square = 0; Square &lt; 81; Square++) &#123; Sequence[Square] = Square; Entry[Square] = BLANK; &#125; for (i = 0; i &lt; 9; i++) Block[i] = Row[i] = Col[i] = ONES; for (int i = 0; i &lt; 9; ++i) for (int j = 0; j &lt; 9; ++j) &#123; if (&apos;.&apos; != board[i][j]) InitEntry(i, j, board[i][j] - &apos;0&apos;); &#125; Place(SeqPtr, board);&#125; https://discuss.leetcode.com/topic/5002/a-simple-dfs-solution A simple DFS solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) &#123; return true; &#125; void solveSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) &#123; util(board, 0); &#125; bool util(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) &#123; if (pos &gt;= 81) return true; int i = pos / 9; int j = pos % 9; if (board[i][j] != &apos;.&apos;) return util(board, pos + 1); else &#123; for (char c = &apos;1&apos;; c &lt;= &apos;9&apos;; c++) &#123; if (!isInRow(board, i,c) &amp;&amp; !isInCol(board, j, c) &amp;&amp; !isInRec(board, i, j, c)) &#123; board[i][j] = c; if (util(board, pos + 1)) return true; else board[i][j] = &apos;.&apos;; &#125; &#125; return false; &#125; &#125; bool isInRow(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, char c) &#123; vector&lt;char&gt;&amp; row = board[i]; for (int k = 0; k &lt; 9; k++) &#123; if (row[k] == c) return true; &#125; return false; &#125; bool isInCol(vector&lt;vector&lt;char&gt;&gt;&amp; board,int j, char c) &#123; for (int k = 0; k &lt; 9; k++) &#123; if (board[k][j] == c) return true; &#125; return false; &#125; bool isInRec(vector&lt;vector&lt;char&gt;&gt;&amp; board, int i, int j, char c) &#123; int bigrow = i / 3, bigcol = j / 3; for (int m = 3 * bigrow; m &lt; 3 * (bigrow + 1); m++) &#123; for (int n = 3 * bigcol; n &lt; 3 * (bigcol + 1); n++) if (board[m][n] == c) return true; &#125; return false; &#125;&#125;; https://discuss.leetcode.com/topic/21103/simple-and-clean-solution-c Simple and Clean Solution / C++ 1234567891011121314151617181920212223242526272829303132bool check(vector&lt;vector&lt;char&gt;&gt; &amp;board, int i, int j, char val)&#123; int row = i - i%3, column = j - j%3; for(int x=0; x&lt;9; x++) if(board[x][j] == val) return false; for(int y=0; y&lt;9; y++) if(board[i][y] == val) return false; for(int x=0; x&lt;3; x++) for(int y=0; y&lt;3; y++) if(board[row+x][column+y] == val) return false; return true;&#125;bool solveSudoku(vector&lt;vector&lt;char&gt;&gt; &amp;board, int i, int j)&#123; if(i==9) return true; if(j==9) return solveSudoku(board, i+1, 0); if(board[i][j] != &apos;.&apos;) return solveSudoku(board, i, j+1); for(char c=&apos;1&apos;; c&lt;=&apos;9&apos;; c++) &#123; if(check(board, i, j, c)) &#123; board[i][j] = c; if(solveSudoku(board, i, j+1)) return true; board[i][j] = &apos;.&apos;; &#125; &#125; return false;&#125;public:void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;solveSudoku(board, 0, 0);&#125; https://discuss.leetcode.com/topic/27787/c-clear-solution-using-dfs-beating-90-c-coder C++ clear solution using dfs, beating 90% c++ coder. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: bool col[10][10],row[10][10],f[10][10]; bool flag = false; void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; memset(col,false,sizeof(col)); memset(row,false,sizeof(row)); memset(f,false,sizeof(f)); for(int i = 0; i &lt; 9;i++)&#123; for(int j = 0; j &lt; 9;j++)&#123; if(board[i][j] == &apos;.&apos;) continue; int temp = 3*(i/3)+j/3; int num = board[i][j]-&apos;0&apos;; col[j][num] = row[i][num] = f[temp][num] = true; &#125; &#125; dfs(board,0,0); &#125; void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,int i,int j)&#123; if(flag == true) return ; if(i &gt;= 9)&#123; flag = true; return ; &#125; if(board[i][j] != &apos;.&apos;)&#123; if(j &lt; 8) dfs(board,i,j+1); else dfs(board,i+1,0); if(flag) return; &#125; else&#123; int temp = 3*(i/3)+j/3; for(int n = 1; n &lt;= 9; n++)&#123; if(!col[j][n] &amp;&amp; !row[i][n] &amp;&amp; !f[temp][n])&#123; board[i][j] = n + &apos;0&apos;; col[j][n] = row[i][n] = f[temp][n] = true; if(j &lt; 8) dfs(board,i,j+1); else dfs(board,i+1,0); col[j][n] = row[i][n] = f[temp][n] = false; if(flag) return; &#125; &#125; board[i][j] = &apos;.&apos;; &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/18316/48ms-straitforward-python-dfs-solution-with-explanations 48ms straitforward python DFS solution with explanations It’s similar to how human solve Sudoku. create a hash table (dictionary) val to store possible values in every location. Each time, start from the location with fewest possible values, choose one value from it and then update the board and possible values at other locations. If this update is valid, keep solving (DFS). If this update is invalid (leaving zero possible values at some locations) or this value doesn’t lead to the solution, undo the updates and then choose the next value. Since we calculated val at the beginning and start filling the board from the location with fewest possible values, the amount of calculation and thus the runtime can be significantly reduced: The run time is 48-68 ms on LeetCode OJ, which seems to be among the fastest python solutions here. The PossibleVals function may be further simplified/optimized, but it works just fine for now. (it would look less lengthy if we are allowed to use numpy array for the board lol). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556def solveSudoku(self, board): self.board = board self.val = self.PossibleVals() self.Solver()def PossibleVals(self): a = &quot;123456789&quot; d, val = &#123;&#125;, &#123;&#125; for i in xrange(9): for j in xrange(9): ele = self.board[i][j] if ele != &quot;.&quot;: d[(&quot;r&quot;, i)] = d.get((&quot;r&quot;, i), []) + [ele] d[(&quot;c&quot;, j)] = d.get((&quot;c&quot;, j), []) + [ele] d[(i//3, j//3)] = d.get((i//3, j//3), []) + [ele] else: val[(i,j)] = [] for (i,j) in val.keys(): inval = d.get((&quot;r&quot;,i),[])+d.get((&quot;c&quot;,j),[])+d.get((i/3,j/3),[]) val[(i,j)] = [n for n in a if n not in inval ] return valdef Solver(self): if len(self.val)==0: return True kee = min(self.val.keys(), key=lambda x: len(self.val[x])) nums = self.val[kee] for n in nums: update = &#123;kee:self.val[kee]&#125; if self.ValidOne(n, kee, update): # valid choice if self.Solver(): # keep solving return True self.undo(kee, update) # invalid choice or didn&apos;t solve it =&gt; undo return False def ValidOne(self, n, kee, update): self.board[kee[0]][kee[1]] = n del self.val[kee] i, j = kee for ind in self.val.keys(): if n in self.val[ind]: if ind[0]==i or ind[1]==j or (ind[0]/3,ind[1]/3)==(i/3,j/3): update[ind] = n self.val[ind].remove(n) if len(self.val[ind])==0: return False return Truedef undo(self, kee, update): self.board[kee[0]][kee[1]]=&quot;.&quot; for k in update: if k not in self.val: self.val[k]= update[k] else: self.val[k].append(update[k]) return None https://discuss.leetcode.com/topic/7475/accepted-python-solution Accepted Python solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution: # @param board, a 9x9 2D array # Solve the Sudoku by modifying the input board in-place. # Do not return any value. def solveSudoku(self, board): self.board = board self.solve() def findUnassigned(self): for row in range(9): for col in range(9): if self.board[row][col] == &quot;.&quot;: return row, col return -1, -1 def solve(self): row, col = self.findUnassigned() #no unassigned position is found, puzzle solved if row == -1 and col == -1: return True for num in [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;]: if self.isSafe(row, col, num): self.board[row][col] = num if self.solve(): return True self.board[row][col] = &quot;.&quot; return False def isSafe(self, row, col, ch): boxrow = row - row%3 boxcol = col - col%3 if self.checkrow(row,ch) and self.checkcol(col,ch) and self.checksquare(boxrow, boxcol, ch): return True return False def checkrow(self, row, ch): for col in range(9): if self.board[row][col] == ch: return False return True def checkcol(self, col, ch): for row in range(9): if self.board[row][col] == ch: return False return True def checksquare(self, row, col, ch): for r in range(row, row+3): for c in range(col, col+3): if self.board[r][c] == ch: return False return True It’s a simple backtracking solution.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[036. Valid Sudoku]]></title>
    <url>%2Fp%2F7b8b841d%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/valid-sudoku/ Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. A partially filled sudoku which is valid. Note: A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. java 38ms, 6.81%, September 20, 2016 https://discuss.leetcode.com/topic/9748/shared-my-concise-java-code Shared my concise Java code 123456789101112131415161718public class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; for(int i=0; i&lt;9; i++)&#123; HashSet&lt;Character&gt; rows = new HashSet&lt;Character&gt;(); HashSet&lt;Character&gt; columns = new HashSet&lt;Character&gt;(); HashSet&lt;Character&gt; cube = new HashSet&lt;Character&gt;(); for(int j=0; j &lt; 9; j++)&#123; if(board[i][j] != &apos;.&apos; &amp;&amp; !rows.add(board[i][j])) return false; if(board[j][i] != &apos;.&apos; &amp;&amp; !columns.add(board[j][i])) return false; int RowIndex = 3*(i/3); int ColIndex = 3*(i%3); if(board[RowIndex+j/3][ColIndex+j%3]!=&apos;.&apos; &amp;&amp; !cube.add(board[RowIndex+j/3][ColIndex+j%3])) return false; &#125; &#125; return true; &#125;&#125; https://discuss.leetcode.com/topic/5803/sharing-my-easy-understand-java-solution-using-set Sharing my easy-understand java solution using set 1234567891011121314151617181920212223public class Solution &#123;public boolean isValidSudoku(char[][] board) &#123; for (int i=0; i&lt;9; i++) &#123; if (!isParticallyValid(board,i,0,i,8)) return false; if (!isParticallyValid(board,0,i,8,i)) return false; &#125; for (int i=0;i&lt;3;i++)&#123; for(int j=0;j&lt;3;j++)&#123; if (!isParticallyValid(board,i*3,j*3,i*3+2,j*3+2)) return false; &#125; &#125; return true;&#125;private boolean isParticallyValid(char[][] board, int x1, int y1,int x2,int y2)&#123; Set singleSet = new HashSet(); for (int i= x1; i&lt;=x2; i++)&#123; for (int j=y1;j&lt;=y2; j++)&#123; if (board[i][j]!=&apos;.&apos;) if(!singleSet.add(board[i][j])) return false; &#125; &#125; return true;&#125;&#125; Each time send the coordinates to check if the board is partially valid. https://discuss.leetcode.com/topic/27436/short-simple-java-using-strings Short+Simple Java using Strings Collect the set of things we see, encoded as strings. For example: ‘4’ in row 7 is encoded as “(4)7”.‘4’ in column 7 is encoded as “7(4)”.‘4’ in the top-right block is encoded as “0(4)2”.Scream false if we ever fail to add something because it was already added (i.e., seen before). 12345678910111213public boolean isValidSudoku(char[][] board) &#123; Set seen = new HashSet(); for (int i=0; i&lt;9; ++i) &#123; for (int j=0; j&lt;9; ++j) &#123; if (board[i][j] != &apos;.&apos;) &#123; String b = &quot;(&quot; + board[i][j] + &quot;)&quot;; if (!seen.add(b + i) || !seen.add(j + b) || !seen.add(i/3 + b + j/3)) return false; &#125; &#125; &#125; return true;&#125; Edit: Just occurred to me that we can also make it really clear and self-explaining. I’m loving it. 1234567891011121314public boolean isValidSudoku(char[][] board) &#123; Set seen = new HashSet(); for (int i=0; i&lt;9; ++i) &#123; for (int j=0; j&lt;9; ++j) &#123; char number = board[i][j]; if (number != &apos;.&apos;) if (!seen.add(number + &quot; in row &quot; + i) || !seen.add(number + &quot; in column &quot; + j) || !seen.add(number + &quot; in block &quot; + i/3 + &quot;-&quot; + j/3)) return false; &#125; &#125; return true;&#125; https://discuss.leetcode.com/topic/40078/yet-another-java-2ms-solution Yet another java 2ms solution 1234567891011121314151617181920public boolean isValidSudoku(char[][] board) &#123; int [] vset = new int [9]; int [] hset = new int [9]; int [] bckt = new int [9]; int idx = 0; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != &apos;.&apos;) &#123; idx = 1 &lt;&lt; (board[i][j] - &apos;0&apos;) ; if ((hset[i] &amp; idx) &gt; 0 || (vset[j] &amp; idx) &gt; 0 || (bckt[(i / 3) * 3 + j / 3] &amp; idx) &gt; 0) return false; hset[i] |= idx; vset[j] |= idx; bckt[(i / 3) * 3 + j / 3] |= idx; &#125; &#125; &#125; return true;&#125; cpp 16ms, 34.54%, September 20, 2016 https://discuss.leetcode.com/topic/8241/my-short-solution-by-c-o-n2 My short solution by C++. O(n2) Three flags are used to check whether a number appear. used1: check each row used2: check each column used3: check each sub-boxes 1234567891011121314class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int used1[9][9] = &#123;0&#125;, used2[9][9] = &#123;0&#125;, used3[9][9] = &#123;0&#125;; for(int i = 0; i&lt;board.size(); ++i) for(int j = 0; j &lt; board[i].size(); ++j) if(board[i][j] != &apos;.&apos;)&#123; int num = board[i][j] - &apos;0&apos; - 1, k = i/3*3 + j/3; if(used1[i][num] || used2[j][num] || used3[k][num]) return false; used1[i][num] = used2[j][num] = used3[k][num] = 1; &#125; return true; &#125;&#125;; https://discuss.leetcode.com/topic/20201/c-very-simple-and-easy-understand-using-bit-operation C++ very simple and easy understand. using bit operation 1234567891011121314151617bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; vector&lt;short&gt; col(9, 0); vector&lt;short&gt; block(9, 0); vector&lt;short&gt; row(9, 0); for (int i = 0; i &lt; 9; i++) for (int j = 0; j &lt; 9; j++) &#123; if (board[i][j] != &apos;.&apos;) &#123; int idx = 1 &lt;&lt; (board[i][j] - &apos;0&apos;); if (row[i] &amp; idx || col[j] &amp; idx || block[i/3 * 3 + j / 3] &amp; idx) return false; row[i] |= idx; col[j] |= idx; block[i/3 * 3 + j/3] |= idx; &#125; &#125; return true; &#125; https://discuss.leetcode.com/topic/15917/my-12-lines-c-c-solution-with-1-time-traversal-and-9x9x3-memory My 12 lines C/C++ solution with 1 time traversal and 9x9x3 memory 1234567891011121314int isValidSudoku(char** board, int boardRowSize, int boardColSize) &#123; int rows[9][9]=&#123;0&#125;; //rows[5][0] means whether number 1(&apos;0&apos;+1) in row 5 has appeared. int cols[9][9]=&#123;0&#125;; //cols[3][8] means whether number 9(&apos;8&apos;+1) in col 3 has appeared. int blocks[3][3][9]=&#123;0&#125;;//blocks[0][2][5] means whether number &apos;6&apos; in block 0,2 (row 0~2,col 6~8) has appeared. for(int r=0;r&lt;9;r++) //traverse board r,c for(int c=0;c&lt;9;c++) if(board[r][c]!=&apos;.&apos;)&#123; //skip all number &apos;.&apos; int number=board[r][c]-&apos;1&apos;; //calculate the number&apos;s index(board&apos;s number minus 1) if(rows[r][number]++) return 0; //if the number has already appeared once, return false. if(cols[c][number]++) return 0; if(blocks[r/3][c/3][number]++) return 0; &#125; return 1;&#125; python https://discuss.leetcode.com/topic/20016/1-7-lines-python-4-solutions 1-7 lines Python, 4 solutions Idea Just go through all you see (like “7 in row 3”) and check for duplicates. Solution 1 Using Counter. One logical line, seven physical lines. 12345678def isValidSudoku(self, board): return 1 == max(collections.Counter( x for i, row in enumerate(board) for j, c in enumerate(row) if c != &apos;.&apos; for x in ((c, i), (j, c), (i/3, j/3, c)) ).values() + [1]) The + [1] is only for the empty board, where max would get an empty list and complain. It’s not necessary to get it accepted here, as the empty board isn’t among the test cases, but it’s good to have. Solution 2 Using len(set). 123456def isValidSudoku(self, board): seen = sum(([(c, i), (j, c), (i/3, j/3, c)] for i, row in enumerate(board) for j, c in enumerate(row) if c != &apos;.&apos;), []) return len(seen) == len(set(seen)) Solution 3 Using any. 1234567def isValidSudoku(self, board): seen = set() return not any(x in seen or seen.add(x) for i, row in enumerate(board) for j, c in enumerate(row) if c != &apos;.&apos; for x in ((c, i), (j, c), (i/3, j/3, c))) Solution 4 Iterating a different way. 12345def isValidSudoku(self, board): seen = sum(([(c, i), (j, c), (i/3, j/3, c)] for i in range(9) for j in range(9) for c in [board[i][j]] if c != &apos;.&apos;), []) return len(seen) == len(set(seen)) https://discuss.leetcode.com/topic/20016/1-7-lines-python-4-solutions/2 Your solutions are briliant! Just another way to write Solution2: 1234567def isValidSudoku(self, board): seen = [] for i, row in enumerate(board): for j, c in enumerate(row): if c != &apos;.&apos;: seen += [(c,j),(i,c),(i/3,j/3,c)] return len(seen) == len(set(seen))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[035. Search Insert Position]]></title>
    <url>%2Fp%2F370b1fef%2F</url>
    <content type="text"><![CDATA[37.9% https://leetcode.com/problems/search-insert-position/ Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. 12345Here are few examples.[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 方法一： 评价：It’s just lower bound binary search. https://leetcode.com/discuss/39829/c-o-logn-binary-search-that-handles-duplicate C++ O(logn) Binary Search that handles duplicate If there are duplicate elements equal to target, my code will always return the one with smallest index. 1234567891011121314151617181920212223242526class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int low = 0, high = nums.size()-1; // Invariant: the desired index is between [low, high+1] while (low &lt;= high) &#123; int mid = low + (high-low)/2; if (nums[mid] &lt; target) low = mid+1; else high = mid-1; &#125; // (1) At this point, low &gt; high. That is, low &gt;= high+1 // (2) From the invariant, we know that the index is between [low, high+1], // so low &lt;= high+1. Follwing from (1), now we know low == high+1. // (3) Following from (2), the index is between [low, high+1] = [low, low], //which means that low is the desired index // Therefore, we return low as the answer. //You can also return high+1 as the result, //since low == high+1 return low; &#125;&#125;; 方法二： A simple CPP solution with lower_bound Actually, what we need here is std::lower_bound in C++ STL, which returns an iterator pointing to the first element that does not less than target. And then, things are quite simple: 123456class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; return lower_bound(nums.begin(), nums.end(), target) - nums.begin(); &#125;&#125;; Or we can implement an inline lower_bound: 123456789101112131415class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; auto first = nums.begin(), last = nums.end(); while (first &lt; last) &#123; auto mid = first + ((last - first) &gt;&gt; 1); if (*mid &lt; target) &#123; first = mid + 1; &#125; else &#123; last = mid; &#125; &#125; return first - nums.begin(); &#125;&#125;; cpp 8ms, 15.81%, June.18th, 2016 https://leetcode.com/discuss/39829/c-o-logn-binary-search-that-handles-duplicate C++ O(logn) Binary Search that handles duplicate If there are duplicate elements equal to target, my code will always return the one with smallest index. 12345678910111213141516171819202122class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int low = 0, high = nums.size()-1; // Invariant: the desired index is between [low, high+1] while (low &lt;= high) &#123; int mid = low + (high-low)/2; if (nums[mid] &lt; target) low = mid+1; else high = mid-1; &#125; // (1) At this point, low &gt; high. That is, low &gt;= high+1 // (2) From the invariant, we know that the index is between [low, high+1], so low &lt;= high+1. Follwing from (1), now we know low == high+1. // (3) Following from (2), the index is between [low, high+1] = [low, low], which means that low is the desired index // Therefore, we return low as the answer. You can also return high+1 as the result, since low == high+1 return low; &#125;&#125;; https://discuss.leetcode.com/topic/7648/my-8ms-accepted-code My 8ms accepted code. 1234567891011121314151617class Solution &#123;public: int searchInsert(int A[], int n, int target) &#123; int low = 0,high = n - 1; while (low &lt;= high)&#123; int mid = (low + high) / 2; if(A[mid]==target) return mid; else if (A[mid] &gt;target)&#123; high = mid - 1; &#125; else&#123; low = mid + 1; &#125; &#125; return low; &#125;&#125;; https://discuss.leetcode.com/topic/16628/a-simple-cpp-solution-with-lower_bound A simple CPP solution with lower_bound Actually, what we need here is std::lower_bound in C++ STL, which returns an iterator pointing to the first element that does not less than target. And then, things are quite simple: 123456class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; return lower_bound(nums.begin(), nums.end(), target) - nums.begin(); &#125;&#125;; Or we can implement an inline lower_bound: 123456789101112131415class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; auto first = nums.begin(), last = nums.end(); while (first &lt; last) &#123; auto mid = first + ((last - first) &gt;&gt; 1); if (*mid &lt; target) &#123; first = mid + 1; &#125; else &#123; last = mid; &#125; &#125; return first - nums.begin(); &#125;&#125;; https://discuss.leetcode.com/topic/20299/my-understanding-of-lower-bound-upper-bound-binary-search-in-c-thanks-to-two-post My understanding of (lower bound,upper bound) binary search, in C++, thanks to two post thanks to A simple CPP solution with lower_boundand C++ O(logn) Binary Search that handles duplicate, thanks to phu1ku ‘s answer on the second post. links for std::lower_bound and std::upper_bound 12345678910111213141516171819class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; /// return index of first one that comp(item,target)==true, or nums.size() if not found /// comp is greater or equal to for lower_bound /// comp is greater for upper_bound int first=0, last=nums.size(), mid; while (first&lt;last) &#123; mid=first+((last-first)&gt;&gt;1); // first&lt;=mid, mid&lt;last /// if comp(item,target)==false, advance first // if(nums[mid]&lt;=target) // for upper_bound if (nums[mid]&lt;target) // for lower_bound first=mid+1; // first always increases else /// else recede last last=mid; // last always decreases (even last-first==1) &#125; return first; &#125;&#125;; python https://discuss.leetcode.com/topic/25828/python-beats-98 Python beats 98% Once the left border is larger than key, than return index. Once the right border is less than key, then return index. 12345678910111213141516171819202122232425262728class Solution(object):def searchInsert(self, nums, key): if key &gt; nums[len(nums) - 1]: return len(nums) if key &lt; nums[0]: return 0 l, r = 0, len(nums) - 1 while l &lt;= r: m = (l + r)/2 if nums[m] &gt; key: r = m - 1 if r &gt;= 0: if nums[r] &lt; key: return r + 1 else: return 0 elif nums[m] &lt; key: l = m + 1 if l &lt; len(nums): if nums[l] &gt; key: return l else: return len(nums) else: return m https://discuss.leetcode.com/topic/30370/python-one-liner-48ms Python one liner 48ms 12345678class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; return len([x for x in nums if x&lt;target]) Solution Mine: 64ms, 5.76%, June.18th, 2016 123456789101112131415class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if target &lt;= nums[0]: return 0 if target &gt; nums[-1]: return len(nums) rtype = 0 while target &gt; nums[rtype]: rtype += 1 return rtype 48ms, 60.93%, June.18th, 2016 https://leetcode.com/discuss/61347/python-beats-98%25 123456789101112131415161718192021222324252627282930313233class Solution(object): def searchInsert(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if target &gt; nums[len(nums) - 1]: return len(nums) if target &lt; nums[0]: return 0 l, r = 0, len(nums) - 1 while l &lt;= r: m = (l + r)/2 if nums[m] &gt; target: r = m - 1 if r &gt;= 0: if nums[r] &lt; target: return r + 1 else: return 0 elif nums[m] &lt; target: l = m + 1 if l &lt; len(nums): if nums[l] &gt; target: return l else: return len(nums) else: return m java 0ms, 17.55%, June.18h, 2016 https://leetcode.com/discuss/23076/my-8-line-java-solution My 8 line Java solution 1234567891011public class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int low = 0, high = nums.length; while(low &lt; high)&#123; int mid = low + (high-low) / 2; if(nums[mid] &gt;= target) high = mid; else low = mid + 1; &#125; return low; &#125;&#125; https://discuss.leetcode.com/topic/31499/very-concise-and-efficient-solution-in-java Very concise and efficient solution in Java I have several solutions to this problem; this is the most concise and efficient one I have. 12345678910111213public class Solution &#123;public int searchInsert(int[] nums, int target) &#123; int low = 0, high = nums.length; while(low &lt; high) &#123; int mid = low + (high - low) / 2; if(nums[mid] &lt; target) low = mid + 1; else high = mid; &#125; return low;&#125;&#125; https://discuss.leetcode.com/topic/2661/simple-binary-search-solution Simple Binary Search Solution I think the solution does not need a lot of if statement. Only two cases: if found, just return current index if not found, return next index where the search end 12345678910int search(int A[], int start, int end, int target) &#123; if (start &gt; end) return start; int mid = (start + end) / 2; if (A[mid] == target) return mid; else if (A[mid] &gt; target) return search(A, start, mid - 1, target); else return search(A, mid + 1, end, target);&#125;int searchInsert(int A[], int n, int target) &#123; return search(A, 0, n - 1, target);&#125; https://discuss.leetcode.com/topic/4764/accepted-o-logn-java-solution-binary-search Accepted O(logN) Java solution, binary search 12345678910111213141516171819202122232425262728public class Solution &#123; public int searchInsert(int[] A, int target) &#123; if(A.length == 0)return 0; int left = 0, right = A.length - 1; int mid = 0; while(left &lt;= right)&#123; if(target&lt;A[left])return left; if(target&gt;A[right])return right+1; mid = (left+right)/2; if(A[mid]==target)return mid; else if(target &lt; A[mid])&#123; right = mid-1; &#125;else&#123; left = mid +1; &#125; &#125; return -1; &#125;&#125; https://discuss.leetcode.com/topic/20133/simple-java-solution Simple Java solution 1234567public int searchInsert(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &gt;= target) return i; &#125; return nums.length;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[034. Search for a Range]]></title>
    <url>%2Fp%2Fffb88a9b%2F</url>
    <content type="text"><![CDATA[34.1% https://leetcode.com/problems/search-for-a-range/ Given a sorted array of integers, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. 123For example,Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. 剑指offer 38 方法一： 先找最左侧边界，然后右侧边界 我的代码实现: 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int left, right; // 这里是nums.size() 不是nums.size()-1 int l = 0, r = nums.size(); while(l&lt;r)&#123; int mid = l+(r-l)/2; if(nums[mid]&gt;=target) r = mid; else l = mid+1; &#125; left = l; l = 0, r = nums.size(); while(l&lt;r)&#123; int mid = l+(r-l)/2; if(nums[mid]&lt;=target) l = mid+1; else r = mid; &#125; right = l; // lower_bound和upper_bound相等时，一定是不等于额 &gt;= &gt;相等 一定是大于 return left==right?vector&lt;int&gt;&#123;-1, -1&#125; : vector&lt;int&gt;&#123;left, right-1&#125;; &#125;&#125;; 还有就是学一下这种写法：vector {-1,-1} The standard and clean c++ binary search implementation. Yeah, binary search is quite simple, but many people write complex and error-prone code. 123456789101112131415161718192021vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int start = 0, end = nums.size(), mid, left, right; while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt;= target) end = mid; else start = mid + 1; &#125; left = start; start = 0, end = nums.size(); while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt; target) end = mid; else start = mid + 1; &#125; right = start; return left == right ? vector&lt;int&gt; &#123;-1,-1&#125; : vector&lt;int&gt; &#123;left,right-1&#125;;&#125; 方法二: 就是lower_bound upper_bound两个函数，但是要记得他们的边界，以及相应函数使用方法 还有使用迭代器求元素的位置索引的方法，以及返回vector怎么去初始化返回 1234567891011class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; auto itlow = lower_bound(nums.begin(), nums.end(), target); auto itup = upper_bound(nums.begin(), nums.end(), target); if(itlow==nums.end() || (*itlow)!=target) return &#123;-1, -1&#125;; else return &#123;itlow-nums.begin(), itup-nums.begin()-1&#125;; &#125;&#125;; cpp 12ms, 19.84%, June.22th, 2016 https://leetcode.com/discuss/18242/clean-iterative-solution-binary-searches-with-explanation Clean iterative solution with two binary searches (with explanation) The problem can be simply broken down as two binary searches for the begining and end of the range, respectively: First let’s find the left boundary of the range. We initialize the range to [i=0, j=n-1]. In each step, calculate the middle element [mid = (i+j)/2]. Now according to the relative value of A[mid] to target, there are three possibilities: If A[mid] &lt; target, then the range must begins on the right of mid (hence i = mid+1 for the next iteration) If A[mid] &gt; target, it means the range must begins on the left of mid (j = mid-1) If A[mid] = target, then the range must begins on the left of or at mid (j= mid) Since we would move the search range to the same side for case 2 and 3, we might as well merge them as one single case so that less code is needed: 12*. If A[mid] &gt;= target, j = mid; Surprisingly, 1 and 2* are the only logic you need to put in loop while (i &lt; j). When the while loop terminates, the value of i/j is where the start of the range is. Why? No matter what the sequence originally is, as we narrow down the search range, eventually we will be at a situation where there are only two elements in the search range. Suppose our target is 5, then we have only 7 possible cases: 1234567case 1: [5 7] (A[i] = target &lt; A[j])case 2: [5 3] (A[i] = target &gt; A[j])case 3: [5 5] (A[i] = target = A[j])case 4: [3 5] (A[j] = target &gt; A[i])case 5: [3 7] (A[i] &lt; target &lt; A[j])case 6: [3 4] (A[i] &lt; A[j] &lt; target)case 7: [6 7] (target &lt; A[i] &lt; A[j]) For case 1, 2 and 3, if we follow the above rule, since mid = i =&gt; A[mid] = target in these cases, then we would set j = mid. Now the loop terminates and i and j both point to the first 5. For case 4, since A[mid] &lt; target, then set i = mid+1. The loop terminates and both i and j point to 5. For all other cases, by the time the loop terminates, A[i] is not equal to 5. So we can easily know 5 is not in the sequence if the comparison fails. In conclusion, when the loop terminates, if A[i]==target, then i is the left boundary of the range; otherwise, just return -1; For the right of the range, we can use a similar idea. Again we can come up with several rules: If A[mid] &gt; target, then the range must begins on the left of mid (j = mid-1) If A[mid] &lt; target, then the range must begins on the right of mid (hence i = mid+1 for the next iteration) If A[mid] = target, then the range must begins on the right of or at mid (i= mid) Again, we can merge condition 2 and 3 into: 12* If A[mid] &lt;= target, then i = mid; However, the terminate condition on longer works this time. Consider the following case: 1[5 7], target = 5 Now A[mid] = 5, then according to rule 2, we set i = mid. This practically does nothing because i is already equal to mid. As a result, the search range is not moved at all! The solution is by using a small trick: instead of calculating mid as mid = (i+j)/2, we now do: 1mid = (i+j)/2+1 Why does this trick work? When we use mid = (i+j)/2, the mid is rounded to the lowest integer. In other words, mid is always biased towards the left. This means we could have i == mid when j - i == mid, but we NEVER have j == mid. So in order to keep the search range moving, you must make sure the new i is set to something different than mid, otherwise we are at the risk that i gets stuck. But for the new j, it is okay if we set it to mid, since it was not equal to mid anyways. Our two rules in search of the left boundary happen to satisfy these requirements, so it works perfectly in that situation. Similarly, when we search for the right boundary, we must make sure i won’t get stuck when we set the new i to i = mid. The easiest way to achieve this is by making mid biased to the right, i.e. mid = (i+j)/2+1. All this reasoning boils down to the following simple code: 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int i = 0, j = nums.size() - 1; vector&lt;int&gt; ret(2, -1); while(i &lt; j)&#123; int mid = (i + j) / 2; if(nums[mid] &lt; target) i = mid + 1; else j = mid; &#125; if(nums[i] != target) return ret; else ret[0] = i; j = nums.size() - 1; while(i &lt; j)&#123; int mid = (i + j) / 2 + 1; if(nums[mid] &gt; target) j = mid - 1; else i = mid; &#125; ret[1] = j; return ret; &#125;&#125;; https://discuss.leetcode.com/topic/19437/the-standard-and-clean-c-binary-search-implementation The standard and clean c++ binary search implementation. Yeah, binary search is quite simple, but many people write complex and error-prone code. 123456789101112131415161718192021vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int start = 0, end = nums.size(), mid, left, right; while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt;= target) end = mid; else start = mid + 1; &#125; left = start; start = 0, end = nums.size(); while (start &lt; end) &#123; mid = (start + end) / 2; if (nums[mid] &gt; target) end = mid; else start = mid + 1; &#125; right = start; return left == right ? vector&lt;int&gt; &#123;-1,-1&#125; : vector&lt;int&gt; &#123;left,right-1&#125;;&#125; python 56ms, 46.67%, June.22th, 2016 https://leetcode.com/discuss/18242/clean-iterative-solution-binary-searches-with-explanation 123456789101112131415161718192021222324252627282930class Solution(object): def searchRange(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; l, r = 0, len(nums) - 1 res = [-1, -1] while(l &lt; r): mid = (l + r) / 2 if nums[mid] &lt; target: l = mid + 1 else: r = mid if nums[l] != target: return res else: res[0] = l r = len(nums) - 1 while(l &lt; r): mid = (l + r) / 2 + 1 if nums[mid] &gt; target: r = mid - 1 else: l = mid res[1] = r return res 52ms, 65.78%, June.22th, 2016 https://leetcode.com/discuss/18242/clean-iterative-solution-binary-searches-with-explanation 123456789101112131415161718192021222324252627282930313233class Solution(object): def searchRange(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; if not nums: return [-1, -1] l, r = 0, len(nums) - 1 res = [-1, -1] while(l &lt; r): mid = (l + r) / 2 if nums[mid] &lt; target: l = mid + 1 else: r = mid if nums[l] != target: return res else: res[0] = l r = len(nums) - 1 while(l &lt; r): mid = (l + r) / 2 + 1 if nums[mid] &gt; target: r = mid - 1 else: l = mid res[1] = r return res https://discuss.leetcode.com/topic/16486/9-11-lines-o-log-n 9-11 lines O(log n) Solution 1 : Divide and Conquer with early breaks : 56 ms The O(log n) time isn’t quite obvious, so I’ll explain it below. Or you can take the challenge and prove it yourself :-) 12345678910def searchRange(self, nums, target): def search(lo, hi): if nums[lo] == target == nums[hi]: return [lo, hi] if nums[lo] &lt;= target &lt;= nums[hi]: mid = (lo + hi) / 2 l, r = search(lo, mid), search(mid+1, hi) return max(l, r) if -1 in l+r else [l[0], r[1]] return [-1, -1] return search(0, len(nums)-1) The search helper function returns an index range just like the requested searchRange function, but only searches in nums[lo..hi]. It first compares the end points and immediately returns [lo, hi] if that whole part of nums is full of target, and immediately returns [-1, -1] if target is outside the range. The interesting case is when target can be in the range but doesn’t fill it completely. In that case, we split the range in left and right half, solve them recursively, and combine their results appropriately. Why doesn’t this explode exponentially? Well, let’s call the numbers in the left half A, …, B and the numbers in the right half C, …, D. Now if one of them immediately return their [lo, hi] or [-1, -1], then this doesn’t explode. And if neither immediately returns, that means we have A &lt;= target &lt;= B and C &lt;= target &lt;= D. And since nums is sorted, we actually have target &lt;= B &lt;= C &lt;= target, so B = C = target. The left half thus ends with target and the right half starts with it. I highlight that because it’s important. Now consider what happens further. The left half gets halved again. Call the middle elements a and b, so the left half is A, …, a, b, …, B. Then a &lt;= target and: If a &lt; target, then the call analyzing A, …, a immediately returns [-1, -1] and we only look further into b, …, B which is again a part that ends with target. If a == target, then a = b = … = B = target and thus the call analyzing b, …, B immediately returns its [lo, hi] and we only look further into A, …, a which is again a part that ends with target.Same for the right half C, …, D. So in the beginning of the search, as long as target is only in at most one of the two halves (so the other immediately stops), we have a single path. And if we ever come across the case where target is in both halves, then we split into two paths, but then each of those remains a single path. And both paths are only O(log n) long, so we have overall runtime O(log n). This is btw based on us917’s solution. 1234567891011121314Solution 2 : Two binary searches : 56 msdef searchRange(self, nums, target): def search(n): lo, hi = 0, len(nums) while lo &lt; hi: mid = (lo + hi) / 2 if nums[mid] &gt;= n: hi = mid else: lo = mid + 1 return lo lo = search(target) return [lo, search(target+1)-1] if target in nums[lo:lo+1] else [-1, -1] Here, my helper function is a simple binary search, telling me the first index where I could insert a number n into nums to keep it sorted. Thus, if nums contains target, I can find the first occurrence with search(target). I do that, and if target isn’t actually there, then I return [-1, -1]. Otherwise, I ask search(target+1), which tells me the first index where I could insert target+1, which of course is one index behind the last index containing target, so all I have left to do is subtract 1. Solution 3 : Two binary searches, using the library Binary search is so good and common that many languages have it in their standard library and you just need to figure out how to apply it to the problem at hand. Python: 123def searchRange(self, nums, target): lo = bisect.bisect_left(nums, target) return [lo, bisect.bisect(nums, target)-1] if target in nums[lo:lo+1] else [-1, -1] C++: 123456vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; auto bounds = equal_range(nums.begin(), nums.end(), target); return *bounds.first != target ? vector&lt;int&gt; &#123;-1, -1&#125; : vector&lt;int&gt; &#123;bounds.first - nums.begin(), bounds.second - nums.begin() - 1&#125;;&#125; Or: 1234567vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = lower_bound(nums.begin(), nums.end(), target) - nums.begin(); if (nums[lo] != target) return vector&lt;int&gt; &#123;-1, -1&#125;; int hi = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1; return vector&lt;int&gt; &#123;lo, hi&#125;;&#125; Java: Well, Java decided to be annoying and offer Arrays.binSearch but with “If the array contains multiple elements with the specified value, there is no guarantee which one will be found”. So it’s useless for us. I’m not good at Java, though, so maybe I’m overlooking a way to still make it work. If you manage to do so, please let me know. java https://discuss.leetcode.com/topic/6327/a-very-simple-java-solution-with-only-one-binary-search-algorithm/2 A very simple Java solution, with only one binary search algorithm 12345678910111213141516171819202122232425262728public class Solution &#123; public int[] searchRange(int[] A, int target) &#123; int start = Solution.firstGreaterEqual(A, target); if (start == A.length || A[start] != target) &#123; return new int[]&#123;-1, -1&#125;; &#125; return new int[]&#123;start, Solution.firstGreaterEqual(A, target + 1) - 1&#125;; &#125; //find the first number that is greater than or equal to target. //could return A.length if target is greater than A[A.length-1]. //actually this is the same as lower_bound in C++ STL. private static int firstGreaterEqual(int[] A, int target) &#123; int low = 0, high = A.length; while (low &lt; high) &#123; int mid = low + ((high - low) &gt;&gt; 1); //low &lt;= mid &lt; high if (A[mid] &lt; target) &#123; low = mid + 1; &#125; else &#123; //should not be mid-1 when A[mid]==target. //could be mid even if A[mid]&gt;target because mid&lt;high. high = mid; &#125; &#125; return low; &#125;&#125; https://discuss.leetcode.com/topic/10692/simple-and-strict-o-logn-solution-in-java-using-recursion Simple and strict O(logn) solution in Java using recursion 123456789101112131415161718192021222324252627public class Solution &#123; public int[] searchRange(int[] A, int target) &#123; int[] range = &#123;A.length, -1&#125;; searchRange(A, target, 0, A.length - 1, range); if (range[0] &gt; range[1]) range[0] = -1; return range; &#125; public void searchRange(int[] A, int target, int left, int right, int[] range) &#123; if (left &gt; right) return; int mid = left + (right - left) / 2; if (A[mid] == target) &#123; if (mid &lt; range[0]) &#123; range[0] = mid; searchRange(A, target, left, mid - 1, range); &#125; if (mid &gt; range[1]) &#123; range[1] = mid; searchRange(A, target, mid + 1, right, range); &#125; &#125; else if (A[mid] &lt; target) &#123; searchRange(A, target, mid + 1, right, range); &#125; else &#123; searchRange(A, target, left, mid - 1, range); &#125; &#125;&#125; https://discuss.leetcode.com/topic/21783/easy-java-o-logn-solution Easy java O(logn) solution There must be two indices in the array. Which means, we can just simply apply to binary search twice to find each index of the target element. 12345678910111213141516171819202122232425262728293031323334353637383940public class Solution &#123;public int[] searchRange(int[] nums, int target) &#123; int[] result = new int[2]; result[0] = findFirst(nums, target); result[1] = findLast(nums, target); return result;&#125;private int findFirst(int[] nums, int target)&#123; int idx = -1; int start = 0; int end = nums.length - 1; while(start &lt;= end)&#123; int mid = (start + end) / 2; if(nums[mid] &gt;= target)&#123; end = mid - 1; &#125;else&#123; start = mid + 1; &#125; if(nums[mid] == target) idx = mid; &#125; return idx;&#125;private int findLast(int[] nums, int target)&#123; int idx = -1; int start = 0; int end = nums.length - 1; while(start &lt;= end)&#123; int mid = (start + end) / 2; if(nums[mid] &lt;= target)&#123; start = mid + 1; &#125;else&#123; end = mid - 1; &#125; if(nums[mid] == target) idx = mid; &#125; return idx;&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[033. Search in Rotated Sorted Array]]></title>
    <url>%2Fp%2Ff6d1f394%2F</url>
    <content type="text"><![CDATA[32.1% https://leetcode.com/problems/search-in-rotated-sorted-array/ Suppose a sorted array is rotated at some pivot unknown to you beforehand. 1(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 方法一： 二分查找 面试奇虎360曾遇到过 我的代码实现，最清晰最明了。 简单易懂。就按这个来了。 设定一个左index，一个右index。肯定要用到中间的index，即mid。 在循环里面，首先算出mid的值，然后如果中间值等于target，返回结果。否则就要搜索了。 怎么搜索呢，要分情况讨论，现在有的值是left，right，mid 和target，用什么分好呢？ 用不用target？答案是不用。要用left和mid这样的值来比较，判断当前所处的环境， 即左半部分的情况，看左边是上升，还是先上升后从最小值上升。 右边是上升还是从最小值上升。 1234567891011121314151617181920212223242526class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if(n==0) return -1; int left=0, right = n-1; while(left&lt;=right)&#123; int mid = left+(right-left)/2; if(nums[mid]==target) return mid; if(nums[left]&lt;=nums[mid])&#123; // 这里是&lt;= 而不是&lt;，因为left可能=mid的情况，否则不能通过。 if(target&gt;=nums[left] &amp;&amp; target&lt;nums[mid])&#123; right = mid-1; &#125;else&#123; left = mid+1; &#125; &#125;else&#123; if(target&gt;nums[mid] &amp;&amp; target&lt;=nums[right]) left = mid+1; else right = mid-1; &#125; &#125; return -1; &#125;&#125;; 方法二： Revised Binary Search 这种方法较好，最后return需要判断与target的关系 1234567891011121314151617181920212223public int search(int[] A, int target) &#123; int lo = 0; int hi = A.length - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if (A[mid] == target) return mid; if (A[lo] &lt;= A[mid]) &#123; if (target &gt;= A[lo] &amp;&amp; target &lt; A[mid]) &#123; hi = mid - 1; &#125; else &#123; lo = mid + 1; &#125; &#125; else &#123; if (target &gt; A[mid] &amp;&amp; target &lt;= A[hi]) &#123; lo = mid + 1; &#125; else &#123; hi = mid - 1; &#125; &#125; &#125; return A[lo] == target ? lo : -1;&#125; cpp https://discuss.leetcode.com/topic/7711/revised-binary-search Revised Binary Search 1234567891011121314151617181920212223public int search(int[] A, int target) &#123; int lo = 0; int hi = A.length - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if (A[mid] == target) return mid; if (A[lo] &lt;= A[mid]) &#123; if (target &gt;= A[lo] &amp;&amp; target &lt; A[mid]) &#123; hi = mid - 1; &#125; else &#123; lo = mid + 1; &#125; &#125; else &#123; if (target &gt; A[mid] &amp;&amp; target &lt;= A[hi]) &#123; lo = mid + 1; &#125; else &#123; hi = mid - 1; &#125; &#125; &#125; return A[lo] == target ? lo : -1;&#125; https://discuss.leetcode.com/topic/34491/clever-idea-making-it-simple Clever idea making it simple This very nice idea is from rantos22’s solution who sadly only commented “You are not expected to understand that :)”, which I guess is the reason it’s now it’s hidden among the most downvoted solutions. I present an explanation and a more usual implementation. Explanation Let’s say nums looks like this: [12, 13, 14, 15, 16, 17, 18, 19, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] Because it’s not fully sorted, we can’t do normal binary search. But here comes the trick: If target is let’s say 14, then we adjust nums to this, where “inf” means infinity:[12, 13, 14, 15, 16, 17, 18, 19, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf] If target is let’s say 7, then we adjust nums to this:[-inf, -inf, -inf, -inf, -inf, -inf, -inf, -inf, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] And then we can simply do ordinary binary search. Of course we don’t actually adjust the whole array but instead adjust only on the fly only the elements we look at. And the adjustment is done by comparing both the target and the actual element against nums[0]. Code If nums[mid] and target are “on the same side” of nums[0], we just take nums[mid]. Otherwise we use -infinity or +infinity as needed. 123456789101112131415161718int search(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, hi = nums.size(); while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; double num = (nums[mid] &lt; nums[0]) == (target &lt; nums[0]) ? nums[mid] : target &lt; nums[0] ? -INFINITY : INFINITY; if (num &lt; target) lo = mid + 1; else if (num &gt; target) hi = mid; else return mid; &#125; return -1;&#125; python https://discuss.leetcode.com/topic/13096/python-binary-search-solution-o-logn-48ms Python binary search solution - O(logn) - 48ms 123456789101112131415161718192021222324252627class Solution: # @param &#123;integer[]&#125; numss # @param &#123;integer&#125; target # @return &#123;integer&#125; def search(self, nums, target): if not nums: return -1 low, high = 0, len(nums) - 1 while low &lt;= high: mid = (low + high) / 2 if target == nums[mid]: return mid if nums[low] &lt;= nums[mid]: if nums[low] &lt;= target &lt;= nums[mid]: high = mid - 1 else: low = mid + 1 else: if nums[mid] &lt;= target &lt;= nums[high]: low = mid + 1 else: high = mid - 1 return -1 https://discuss.leetcode.com/topic/34467/pretty-short-c-java-ruby-python Pretty short C++/Java/Ruby/Python Explanation below the codes. Python: 123456789def search(self, nums, target): lo, hi = 0, len(nums) - 1 while lo &lt; hi: mid = (lo + hi) / 2 if (nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid]): lo = mid + 1 else: hi = mid return lo if target in nums[lo:lo+1] else -1 Python using bisect: 123456class Solution: def search(self, nums, target): self.__getitem__ = lambda i: \ (nums[0] &lt;= target) ^ (nums[0] &gt; nums[i]) ^ (target &gt; nums[i]) i = bisect.bisect_left(self, True, 0, len(nums)) return i if target in nums[i:i+1] else -1 C++: 1234567891011int search(vector&lt;int&gt;&amp; nums, int target) &#123; int lo = 0, hi = int(nums.size()) - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid])) lo = mid + 1; else hi = mid; &#125; return lo == hi &amp;&amp; nums[lo] == target ? lo : -1;&#125; Java: 1234567891011public int search(int[] nums, int target) &#123; int lo = 0, hi = nums.length - 1; while (lo &lt; hi) &#123; int mid = (lo + hi) / 2; if ((nums[0] &gt; target) ^ (nums[0] &gt; nums[mid]) ^ (target &gt; nums[mid])) lo = mid + 1; else hi = mid; &#125; return lo == hi &amp;&amp; nums[lo] == target ? lo : -1;&#125; Explanation My solutions use binary search guided by the following thoughts: Remember the array is sorted, except it might drop at one point. 12345678If nums[0] &lt;= nums[i], then nums[0..i] is sorted (in case of &quot;==&quot; it&apos;s just one element, and in case of &quot;&lt;&quot; there must be a drop elsewhere). So we should keep searching in nums[0..i] if the target lies in this sorted range, i.e., if nums[0] &lt;= target &lt;= nums[i].If nums[i] &lt; nums[0], then nums[0..i] contains a drop, and thus nums[i+1..end] is sorted and lies strictly between nums[i] and nums[0]. So we should keep searching in nums[0..i] if the target doesn&apos;t lie strictly between them, i.e., if target &lt;= nums[i] &lt; nums[0] or nums[i] &lt; nums[0] &lt;= target Those three cases look cyclic: 123nums[0] &lt;= target &lt;= nums[i] target &lt;= nums[i] &lt; nums[0] nums[i] &lt; nums[0] &lt;= target So I have the three checks (nums[0] &lt;= target), (target &lt;= nums[i]) and (nums[i] &lt; nums[0]), and I want to know whether exactly two of them are true. They can’t all be true or all be false (check it), so I just need to distinguish between “two true” and “one true”. Parity is enough for that, so instead of adding them I xor them, which is a bit shorter and particularly helpful in Java and Ruby, because those don’t let me add booleans but do let me xor them. (Actually while developing this I thought of permutations of nums[0], target and nums[i] and the permutation parity and saw those three checks as representing inversions, but I had trouble putting that into words and now find the above explanation much better. But it helped me get there, so I wanted to mention it here.) java https://discuss.leetcode.com/topic/3538/concise-o-log-n-binary-search-solution Concise O(log N) Binary search solution 1234567891011121314151617181920212223242526class Solution &#123;public: int search(int A[], int n, int target) &#123; int lo=0,hi=n-1; // find the index of the smallest value using binary search. // Loop will terminate since mid &lt; hi, and lo or hi will shrink by at least 1. // Proof by contradiction that mid &lt; hi: if mid==hi, then lo==hi and loop would have been terminated. while(lo&lt;hi)&#123; int mid=(lo+hi)/2; if(A[mid]&gt;A[hi]) lo=mid+1; else hi=mid; &#125; // lo==hi is the index of the smallest value and also the number of places rotated. int rot=lo; lo=0;hi=n-1; // The usual binary search and accounting for rotation. while(lo&lt;=hi)&#123; int mid=(lo+hi)/2; int realmid=(mid+rot)%n; if(A[realmid]==target)return realmid; if(A[realmid]&lt;target)lo=mid+1; else hi=mid-1; &#125; return -1; &#125;&#125;; https://discuss.leetcode.com/topic/16580/java-ac-solution-using-once-binary-search Java AC Solution using once binary search The idea is that when rotating the array, there must be one half of the array that is still in sorted order.For example, 6 7 1 2 3 4 5, the order is disrupted from the point between 7 and 1. So when doing binary search, we can make a judgement that which part is ordered and whether the target is in that range, if yes, continue the search in that half, if not continue in the other half. 1234567891011121314151617181920212223242526public class Solution &#123; public int search(int[] nums, int target) &#123; int start = 0; int end = nums.length - 1; while (start &lt;= end)&#123; int mid = (start + end) / 2; if (nums[mid] == target) return mid; if (nums[start] &lt;= nums[mid])&#123; if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) end = mid - 1; else start = mid + 1; &#125; if (nums[mid] &lt;= nums[end])&#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) start = mid + 1; else end = mid - 1; &#125; &#125; return -1; &#125;&#125; https://discuss.leetcode.com/topic/8889/binary-search-java-solusion-o-log-n Binary Search, Java Solusion. O(log(n)) 1234567891011121314151617181920212223242526public int search(int[] A, int target) &#123; if (A.length == 0) return -1; int L = 0, R = A.length-1; // if (target &lt; A[L] &amp;&amp; target &gt; A[R]) return -1; while (L &lt; R) &#123; int M = (L + R)/2; if (A[M] &lt;= A[R]) &#123; if (target &gt; A[M] &amp;&amp; target &lt;= A[R]) &#123; L = M+1; &#125; else &#123; R = M; &#125; &#125; else &#123; if (target &lt;= A[M] &amp;&amp; target &gt;= A[L]) &#123; R = M; &#125; else &#123; L = M+1; &#125; &#125; &#125; if (A[L] == target) return L; else return -1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[032. Longest Valid Parentheses]]></title>
    <url>%2Fp%2F3f681304%2F</url>
    <content type="text"><![CDATA[23.1% https://leetcode.com/problems/longest-valid-parentheses/ Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring. 12345For &quot;(()&quot;, the longest valid parentheses substring is &quot;()&quot;, which has length = 2.Another example is &quot;)()())&quot;, where the longest valid parentheses substring is &quot;()()&quot;, which has length = 4. 方法一： 这种方法很巧妙，用了栈，并且栈里存储索引位置 My O(n) solution using a stack The workflow of the solution is as below. Scan the string from beginning to end. If current character is ‘(‘, push its index to the stack. If current character is ‘)’ and the character at the index of the top of stack is ‘(‘, we just find a matching pair so pop from the stack. Otherwise, we push the index of ‘)’ to the stack. After the scan is done, the stack will only contain the indices of characters which cannot be matched. Then let’s use the opposite side - substring between adjacent indices should be valid parentheses. If the stack is empty, the whole input string is valid. Otherwise, we can scan the stack to get longest valid substring as described in step 3. 123456789101112131415161718192021222324252627282930class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.length(), longest = 0; stack&lt;int&gt; st; for(int i=0; i&lt;n; i++)&#123; if(s[i]==&apos;(&apos;) st.push(i); else&#123; if(!st.empty())&#123; if(s[st.top()]==&apos;(&apos;) st.pop(); else st.push(i); &#125; else st.push(i); &#125; &#125; if(st.empty()) longest = n; else&#123; int a=n, b=0; while(!st.empty())&#123; b = st.top(); st.pop(); longest = max(longest, a-b-1); a = b; &#125; longest = max(longest, a); &#125; return longest; &#125;&#125;; 我的代码实现: 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.size(); if(n==0) return 0; // 对于字符串，stack可以保存具体的字符，也可以保存index // 保存index就是一种常见的操作，本处就是保存的index stack&lt;int&gt; stack; for(int i=0; i&lt;n; i++)&#123; if(s[i]=='(') stack.push(i); else&#123; if(!stack.empty() &amp;&amp; s[stack.top()]=='(') stack.pop(); else stack.push(i); &#125; &#125; if(stack.empty()) return n; int start = 0, end = n, res = 0; while(!stack.empty())&#123; start = stack.top(); // 别忘了将stack的值给pop出去 stack.pop(); res = max(res, end-start-1); end = start; &#125; // 不重不漏， 这一步要考虑周全 res = max(res, start); return res; &#125;&#125;; 我的代码实现二: 对上面的代码优化了一下 12345678910111213141516171819202122232425262728class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.size(); if(n==0) return 0; // 对于字符串，stack可以保存具体的字符，也可以保存index // 保存index就是一种常见的操作，本处就是保存的index stack&lt;int&gt; stack; for(int i=0; i&lt;n; i++)&#123; if(s[i]==')' &amp;&amp; !stack.empty() &amp;&amp; s[stack.top()]=='(') stack.pop(); else stack.push(i); &#125; if(stack.empty()) return n; int start = 0, end = n, res = 0; while(!stack.empty())&#123; start = stack.top(); // 别忘了将stack的值给pop出去 stack.pop(); res = max(res, end-start-1); end = start; &#125; // 不重不漏， 这一步要考虑周全 res = max(res, start); return res; &#125;&#125;; cpp September 22, 2016 https://discuss.leetcode.com/topic/2289/my-o-n-solution-using-a-stack My O(n) solution using a stack The workflow of the solution is as below. Scan the string from beginning to end. If current character is ‘(‘, push its index to the stack. If current character is ‘)’ and the character at the index of the top of stack is ‘(‘, we just find a matching pair so pop from the stack. Otherwise, we push the index of ‘)’ to the stack. After the scan is done, the stack will only contain the indices of characters which cannot be matched. Then let’s use the opposite side - substring between adjacent indices should be valid parentheses. If the stack is empty, the whole input string is valid. Otherwise, we can scan the stack to get longest valid substring as described in step 3.123456789101112131415161718192021222324252627282930class Solution &#123;public: int longestValidParentheses(string s) &#123; int n = s.length(), longest = 0; stack&lt;int&gt; st; for(int i=0; i&lt;n; i++)&#123; if(s[i]==&apos;(&apos;) st.push(i); else&#123; if(!st.empty())&#123; if(s[st.top()]==&apos;(&apos;) st.pop(); else st.push(i); &#125; else st.push(i); &#125; &#125; if(st.empty()) longest = n; else&#123; int a=n, b=0; while(!st.empty())&#123; b = st.top(); st.pop(); longest = max(longest, a-b-1); a = b; &#125; longest = max(longest, a); &#125; return longest; &#125;&#125;; https://discuss.leetcode.com/topic/2426/my-dp-o-n-solution-without-using-stack My DP, O(n) solution without using stack My solution uses DP. The main idea is as follows: I construct a array longest[], for any longest[i], it stores the longest length of valid parentheses which is end at i. And the DP idea is : If s[i] is ‘(‘, set longest[i] to 0,because any string end with ‘(‘ cannot be a valid one. Else if s[i] is ‘)’ If s[i-1] is &apos;(&apos;, longest[i] = longest[i-2] + 2 Else if s[i-1] is &apos;)&apos; and s[i-longest[i-1]-1] == &apos;(&apos;, longest[i] = longest[i-1] + 2 + longest[i-longest[i-1]-2] For example, input “()(())”, at i = 5, longest array is [0,2,0,0,2,0], longest[5] = longest[4] + 2 + longest[1] = 6. 123456789101112131415161718192021int longestValidParentheses(string s) &#123; if(s.length() &lt;= 1) return 0; int curMax = 0; vector&lt;int&gt; longest(s.size(),0); for(int i=1; i &lt; s.length(); i++)&#123; if(s[i] == &apos;)&apos;)&#123; if(s[i-1] == &apos;(&apos;)&#123; longest[i] = (i-2) &gt;= 0 ? (longest[i-2] + 2) : 2; curMax = max(longest[i],curMax); &#125; else&#123; // if s[i-1] == &apos;)&apos;, combine the previous length. if(i-longest[i-1]-1 &gt;= 0 &amp;&amp; s[i-longest[i-1]-1] == &apos;(&apos;)&#123; longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 &gt;= 0)?longest[i-longest[i-1]-2]:0); curMax = max(longest[i],curMax); &#125; &#125; &#125; //else if s[i] == &apos;(&apos;, skip it, because longest[i] must be 0 &#125; return curMax; &#125; Updated: thanks to Philip0116, I have a more concise solution(though this is not as readable as the above one, but concise): 123456789101112int longestValidParentheses(string s) &#123; if(s.length() &lt;= 1) return 0; int curMax = 0; vector&lt;int&gt; longest(s.size(),0); for(int i=1; i &lt; s.length(); i++)&#123; if(s[i] == &apos;)&apos; &amp;&amp; i-longest[i-1]-1 &gt;= 0 &amp;&amp; s[i-longest[i-1]-1] == &apos;(&apos;)&#123; longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 &gt;= 0)?longest[i-longest[i-1]-2]:0); curMax = max(longest[i],curMax); &#125; &#125; return curMax; &#125; https://discuss.leetcode.com/topic/14690/my-simple-8ms-c-code My simple 8ms C++ code 1234567891011121314151617181920class Solution &#123;public: int longestValidParentheses(string s) &#123; stack&lt;int&gt; stk; stk.push(-1); int maxL=0; for(int i=0;i&lt;s.size();i++) &#123; int t=stk.top(); if(t!=-1&amp;&amp;s[i]==&apos;)&apos;&amp;&amp;s[t]==&apos;(&apos;) &#123; stk.pop(); maxL=max(maxL,i-stk.top()); &#125; else stk.push(i); &#125; return maxL; &#125;&#125;; https://discuss.leetcode.com/topic/2745/my-solution-using-one-stack-in-one-pass My solution using one stack in one pass Since any valid parentheses sequence starts from a ‘(‘ and ends at ‘)’, we can calculate new length when we meet a ‘)’. The key is to use a stack to store all the indices and the start position is always the one on top of the stack. See the code below for details. 12345678910111213141516171819202122// Using a stack. One passint longestValidParentheses(string s) &#123; vector&lt;int&gt; stack; int maxLen = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (s[i] == &apos;(&apos;) stack.push_back(i); else &#123; if (!stack.empty() &amp;&amp; s[stack.back()] == &apos;(&apos;) &#123; stack.pop_back(); int lastPos = -1; if (!stack.empty()) lastPos = stack.back(); int curLen = i - lastPos; maxLen = (maxLen &lt; curLen) ? curLen : maxLen; &#125; else stack.push_back(i); &#125; &#125; return maxLen;&#125; https://discuss.leetcode.com/topic/22287/constant-space-o-n-time-with-forward-and-backward-pass Constant space, O(n) time with forward and backward pass When right parentheses are more than left parentheses in the forward pass, we can discard previous parentheses. In the backward pass, when left parentheses are more than right parentheses, we can discard previous parentheses. 123456789101112131415161718192021222324252627282930313233343536373839404142434445int longestValidParentheses(string s) &#123; int longest = 0; int extra=0; int length=0; for(int i=0; i&lt;s.size(); i++) &#123; if(s[i] == &apos;(&apos;) &#123; extra++; length++; &#125; else &#123; if(extra&gt;0) &#123; extra--; length++; if(extra == 0) longest = max(longest, length); &#125; else &#123; extra = 0; length=0; &#125; &#125; &#125; length = 0; extra=0; for(int i=s.size()-1; i&gt;=0; i--) &#123; if(s[i] == &apos;)&apos;) &#123; extra++; length++; &#125; else &#123; if(extra&gt;0)&#123; extra--; length++; if(extra == 0) longest = max(longest, length); &#125; else &#123; extra = 0; length=0; &#125; &#125; &#125; return longest;&#125; python https://discuss.leetcode.com/topic/23559/pure-1d-dp-without-using-stack-python-with-detailed-explanation Pure 1D-DP without using stack (python) with detailed explanation 123456789101112131415161718192021222324252627class Solution(object): def longestValidParentheses(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; # use 1D DP # dp[i] records the longestValidParenthese EXACTLY ENDING at s[i] dp = [0 for x in xrange(len(s))] max_to_now = 0 for i in xrange(1,len(s)): if s[i] == &apos;)&apos;: # case 1: ()() if s[i-1] == &apos;(&apos;: # add nearest parentheses pairs + 2 dp[i] = dp[i-2] + 2 # case 2: (()) # i-dp[i-1]-1 is the index of last &quot;(&quot; not paired until this &quot;)&quot; elif i-dp[i-1]-1 &gt;= 0 and s[i-dp[i-1]-1] == &apos;(&apos;: if dp[i-1] &gt; 0: # content within current matching pair is valid # add nearest parentheses pairs + 2 + parentheses before last &quot;(&quot; dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2] else: # otherwise is 0 dp[i] = 0 max_to_now = max(max_to_now, dp[i]) return max_to_now java https://discuss.leetcode.com/topic/7234/simple-java-solution-o-n-time-one-stack Simple JAVA solution, O(n) time, one stack 12345678910111213141516171819public class Solution &#123; public int longestValidParentheses(String s) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int max=0; int left = -1; for(int j=0;j&lt;s.length();j++)&#123; if(s.charAt(j)==&apos;(&apos;) stack.push(j); else &#123; if (stack.isEmpty()) left=j; else&#123; stack.pop(); if(stack.isEmpty()) max=Math.max(max,j-left); else max=Math.max(max,j-stack.peek()); &#125; &#125; &#125; return max; &#125;&#125; https://discuss.leetcode.com/topic/7234/simple-java-solution-o-n-time-one-stack/3 Nice solution! Inspired by your solution. I changed a little to make it shorter and easier. 12345678910111213141516public class Solution &#123; public int longestValidParentheses(String s) &#123; LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); int result = 0; stack.push(-1); for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == &apos;)&apos; &amp;&amp; stack.size() &gt; 1 &amp;&amp; s.charAt(stack.peek()) == &apos;(&apos;) &#123; stack.pop(); result = Math.max(result, i - stack.peek()); &#125; else &#123; stack.push(i); &#125; &#125; return result; &#125;&#125; The idea is simple, we only update the result (max) when we find a “pair”. If we find a pair. We throw this pair away and see how big the gap is between current and previous invalid. EX: “( )( )” stack: -1, 0, when we get to index 1 “)”, the peek is “(“ so we pop it out and see what’s before “(“. In this example it’s -1. So the gap is “current_index” - (-1) = 2. The idea only update the result (max) when we find a “pair” and push -1 to stack first covered all edge cases. https://discuss.leetcode.com/topic/37982/my-easy-o-n-java-solution-with-explanation My easy O(n) java solution with explanation 1234567891011121314151617181920212223public class Solution &#123; public int longestValidParentheses(String s) &#123; int res=0; int tep=0; Stack&lt;Integer&gt; s1=new Stack&lt;&gt;(); int data[]=new int[s.length()]; for(int i=0;i&lt;s.length();i++)&#123; char c=s.charAt(i); if(c==&apos;(&apos;) s1.push(i); else&#123; if(!s1.empty())&#123; data[i]=1; data[s1.pop()]=1; &#125; &#125; &#125; for(int i:data)&#123; if(i==1) tep++; else &#123;res=Math.max(tep,res);tep=0;&#125; &#125; return Math.max(tep,res); &#125;&#125; Imaging we are coloring the original string, each substring that has valid parentheses is colored with ‘1’ and other characters are colored by ‘0’. For example “( ) ( ( ) “would become “11011”. Thus, the problem has converted to finding the longest subsequence that all elements are ‘1’, which could be easily solved. https://discuss.leetcode.com/topic/8305/simple-java-solution Simple Java solution. 123456789101112131415public int longestValidParentheses(String s) &#123; char[] S = s.toCharArray(); int[] V = new int[S.length]; int open = 0; int max = 0; for (int i=0; i&lt;S.length; i++) &#123; if (S[i] == &apos;(&apos;) open++; if (S[i] == &apos;)&apos; &amp;&amp; open &gt; 0) &#123; V[i] = 2 + V[i-1] + (i-2-V[i-1] &gt; 0 ? V[i-2-V[i-1]] : 0); open--; &#125; if (V[i] &gt; max) max = V[i]; &#125; return max;&#125; https://discuss.leetcode.com/topic/12200/explaining-solution-using-stack Explaining solution using Stack I have seen a lot of good answers but it is not immediately clear how they are achieving the result. I am going to make an attempt to explain my solution using a stack. Every time we encounter ‘(‘ we push the index onto the stack and when we encounter ‘)’ we pop the stack and use the current index minus the index at the top of the stack to be the current_length. we check against the max found so far and update if needed. Here is the code 1234567891011121314151617181920212223242526272829303132333435public static int longestValidParentheses(String s) &#123; Stack&lt;Integer&gt; bracketStack = new Stack&lt;Integer&gt;(); int max_len=0; int current_len=0; int last = -1; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == &apos;(&apos;) &#123; bracketStack.push(i); &#125; else&#123; if(!bracketStack.isEmpty()) &#123; bracketStack.pop(); if(!bracketStack.isEmpty()) current_len = i-bracketStack.peek(); else current_len=i-last; max_len = Math.max(max_len,current_len); &#125; else&#123; last = i; &#125; &#125; &#125; return max_len; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[031. Next Permutation]]></title>
    <url>%2Fp%2F3f16d422%2F</url>
    <content type="text"><![CDATA[28.8% https://leetcode.com/problems/next-permutation/ Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. 12345Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 方法一： 我的代码实现: 123456789101112131415161718192021222324252627class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return; int left = n-2; while(left&gt;=0)&#123; if(nums[left]&lt;nums[left+1]) break; left--; &#125; if(left&lt;0)&#123; reverse(nums.begin(), nums.end()); return; &#125; int right = n - 1; while(right&gt;=0)&#123; if(nums[right]&gt;nums[left]) break; right--; &#125; swap(nums[left], nums[right]); reverse(nums.begin()+left+1, nums.end()); return; &#125;&#125;; 我的代码实现: 1234567891011121314151617181920212223242526class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n==1) return; int i = n-2; while(i&gt;=0)&#123; if(nums[i+1]&gt;nums[i]) break; i--; &#125; if(i&lt;0)&#123; reverse(nums.begin(), nums.end()); return; &#125; int j = n-1; while(j&gt;0)&#123; if(nums[j]&gt;nums[i]) break; j--; &#125; swap(nums[i], nums[j]); reverse(nums.begin()+i+1, nums.end()); return; &#125;&#125;; 成熟的解法 第一步，从后向前，找到一个index k，k是第一个满足当前节点值大于下一个点的值。 就是说后面的都是递减的。 (如果找不到，说明已经是最大的数组了，而且都是逆序，反转返回即可) 第二步，从后向前找，找到一个index l，l是nums[l] &gt; nums[k]，也就是l是大于nums[k]的最大索引。 第三步，交换l和k对应的值 第四步，把从k+1开始到nums末尾的数组，进行反转reverse。 A simple algorithm from Wikipedia with C++ implementation (can be used in Permutations and Permutations II) Well, in fact the problem of next permutation has been studied long ago. From the Wikipedia page, in the 14th century, a man named Narayana Pandita gives the following classic and yet quite simple algorithm (with minor modifications in notations to fit the problem statement): Find the largest index k such that nums[k] &lt; nums[k + 1]. If no such index exists, the permutation is sorted in descending order, just reverse it to ascending order and we are done. For example, the next permutation of [3, 2, 1] is [1, 2, 3]. Find the largest index l greater than k such that nums[k] &lt; nums[l]. Swap the value of nums[k] with that of nums[l]. Reverse the sequence from nums[k + 1] up to and including the final element nums[nums.size() - 1]. Quite simple, yeah? Now comes the following code, which is barely a translation. Well, a final note here, the above algorithm is indeed powerful — it can handle the cases of duplicates! If you have tried the problems Permutations and Permutations II, then the following function is also useful. Both of Permutations and Permutations II can be solved easily using this function. Hints: sort nums in ascending order, add it to the result of all permutations and then repeatedly generate the next permutation and add it … until we get back to the original sorted condition. If you want to learn more, please visit this solution and that solution. 123456789101112131415161718192021222324class Solution &#123; void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int k = -1; for (int i = nums.size() - 2; i &gt;= 0; i--) &#123; if (nums[i] &lt; nums[i + 1]) &#123; k = i; break; &#125; &#125; if (k == -1) &#123; reverse(nums.begin(), nums.end()); return; &#125; int l = -1; for (int i = nums.size() - 1; i &gt; k; i--) &#123; if (nums[i] &gt; nums[k]) &#123; l = i; break; &#125; &#125; swap(nums[k], nums[l]); reverse(nums.begin() + k + 1, nums.end()); &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return; int left = -1; for(int i=n-2; i&gt;=0; i--) if(nums[i]&lt;nums[i+1])&#123; left = i; break; // break不能忘 &#125; if(left == -1)&#123; reverse(nums.begin(), nums.end()); return; &#125; int right; for(int j=n-1; j&gt;left; j--) if(nums[j]&gt;nums[left])&#123; right = j; break; // break不能忘 &#125; swap(nums[left], nums[right]); reverse(nums.begin()+left+1, nums.end()); return; &#125;&#125;; cpp https://discuss.leetcode.com/topic/15216/a-simple-algorithm-from-wikipedia-with-c-implementation-can-be-used-in-permutations-and-permutations-ii A simple algorithm from Wikipedia with C++ implementation (can be used in Permutations and Permutations II) Well, in fact the problem of next permutation has been studied long ago. From the Wikipedia page, in the 14th century, a man named Narayana Pandita gives the following classic and yet quite simple algorithm (with minor modifications in notations to fit the problem statement): Find the largest index k such that nums[k] &lt; nums[k + 1]. If no such index exists, the permutation is sorted in descending order, just reverse it to ascending order and we are done. For example, the next permutation of [3, 2, 1] is [1, 2, 3]. Find the largest index l greater than k such that nums[k] &lt; nums[l]. Swap the value of nums[k] with that of nums[l]. Reverse the sequence from nums[k + 1] up to and including the final element nums[nums.size() - 1]. Quite simple, yeah? Now comes the following code, which is barely a translation. Well, a final note here, the above algorithm is indeed powerful — it can handle the cases of duplicates! If you have tried the problems Permutations and Permutations II, then the following function is also useful. Both of Permutations and Permutations II can be solved easily using this function. Hints: sort nums in ascending order, add it to the result of all permutations and then repeatedly generate the next permutation and add it … until we get back to the original sorted condition. If you want to learn more, please visit this solution and that solution. 123456789101112131415161718192021222324class Solution &#123; void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int k = -1; for (int i = nums.size() - 2; i &gt;= 0; i--) &#123; if (nums[i] &lt; nums[i + 1]) &#123; k = i; break; &#125; &#125; if (k == -1) &#123; reverse(nums.begin(), nums.end()); return; &#125; int l = -1; for (int i = nums.size() - 1; i &gt; k; i--) &#123; if (nums[i] &gt; nums[k]) &#123; l = i; break; &#125; &#125; swap(nums[k], nums[l]); reverse(nums.begin() + k + 1, nums.end()); &#125;&#125;; https://discuss.leetcode.com/topic/8508/9-lines-of-c-code-with-comments 9 Lines of C++ code with Comments 1234567891011121314151617181920212223class Solution &#123;public: void nextPermutation(vector&lt;int&gt; &amp;num) &#123; if (num.empty()) return; // in reverse order, find the first number which is in increasing trend (we call it violated number here) int i; for (i = num.size()-2; i &gt;= 0; --i) &#123; if (num[i] &lt; num[i+1]) break; &#125; // reverse all the numbers after violated number reverse(begin(num)+i+1, end(num)); // if violated number not found, because we have reversed the whole array, then we are done! if (i == -1) return; // else binary search find the first number larger than the violated number auto itr = upper_bound(begin(num)+i+1, end(num), num[i]); // swap them, done! swap(num[i], *itr); &#125;&#125;; You might need to think for a while why this would work. https://discuss.leetcode.com/topic/19264/1-4-11-lines-c 1, 4, 11 lines C++ Solution 1 Just for info: There’s a library function that does the job, even going from totally reverse sorted to sorted: 123void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; next_permutation(begin(nums), end(nums));&#125; Solution 2 Using library functions for all building blocks of the algorithm. Very nice how they all play together, notice the total lack of +1/-1, it all fits exactly. 123456void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; auto i = is_sorted_until(nums.rbegin(), nums.rend()); if (i != nums.rend()) swap(*i, *upper_bound(nums.rbegin(), i, *i)); reverse(nums.rbegin(), i);&#125; Solution 3 Doing it all on my own (except swap, let’s not be silly): 12345678910111213void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int i = nums.size() - 1, k = i; while (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i]) i--; for (int j=i; j&lt;k; j++, k--) swap(nums[j], nums[k]); if (i &gt; 0) &#123; k = i--; while (nums[k] &lt;= nums[i]) k++; swap(nums[i], nums[k]); &#125;&#125; Solution 4 Ok, let’s be silly after all and not even use swap :-) 12345678910111213void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int i = nums.size() - 1, k = i, tmp; while (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i]) i--; for (int j=i; j&lt;k; j++, k--) tmp = nums[j], nums[j] = nums[k], nums[k] = tmp; if (i &gt; 0) &#123; k = i--; while (nums[k] &lt;= nums[i]) k++; tmp = nums[i], nums[i] = nums[k], nums[k] = tmp; &#125;&#125; https://discuss.leetcode.com/topic/7138/sharing-my-really-simple-solution-with-explanation Sharing my really simple solution with explanation 123456789101112131415161718void nextPermutation(vector&lt;int&gt; &amp;num) &#123; for(int i = num.size() - 2; i &gt;= 0; i--)&#123; if(num[i] &lt; num[i + 1])&#123; int pos; int diff = INT_MAX; for(int j = i + 1; j &lt; num.size(); j++)&#123; if(num[j] &gt; num[i] &amp;&amp; abs(num[i] - num[j]) &lt; diff)&#123; diff = abs(num[i] - num[j]); pos = j; &#125; &#125; swap(num[i], num[pos]); sort(num.begin() + i + 1, num.end()); return; &#125; &#125; sort(num.begin(), num.end());&#125; For this problem, coding is not a big deal. Algorithm is! Now let’s pick a number, for example, 24387651. what is the next permutation? 24513678. How can I get the answer? First step: find the first ascending digit from the back of the number. 3 &lt; 8 &gt; 7 &gt; 6 &gt; 5 &gt; 1. Then 3 is the digit. Second step: swap that digit with the next big digit in following digits. Which one is the next big digit in 87651? 5! So swap them. Now the number becomes 24587631. Third step: sort 87631 into 13678. The final answer is 24513678. 12ms, 10.84%, April.23rd, 2016 https://github.com/haoel/leetcode/blob/master/algorithms/cpp/nextPermutation/nextPermutation.cpp 123456789101112131415161718192021222324252627282930313233343536373839/* * Take a look the following continuous permutation, can you find the patern? * * 1 2 3 4 * 1 2 4 3 * 1 3 2 4 * 1 3 4 2 * 1 4 2 3 * 1 4 3 2 * 2 1 3 4 * ... * * The pattern can be descripted as below: * * 1) from n-1 to 0, find the first place [i-1] which num[i-1] &lt; num[i] * 2) from n-1 to i, find the first number from n-1 to i which &gt;= num[i-1] * 3) swap the 2) num with the num[i-1] * 4) sort the sub-array [i, n) //actuall sort is fine as well * * For example: * * 1 4 3 2 &lt;-- 1) find the first place which num[i-1] &lt; num[i] * ^ * * 1 4 3 2 &lt;-- 2) find the first number from n-1 to i which &gt;= num[i-1] * ^ ^ * * 2 4 3 1 &lt;-- 3) swap them * ^ ^ * * 2 4 3 1 &lt;-- 4) sort * ^ ^ * * 2 1 3 4 * * Edge Case: * * 4 3 2 1, the next permutation is 1 2 3 4 */ 12345678910111213141516171819202122class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt;= 1) return; for(int i = nums.size() - 1; i &gt; 0; i--)&#123; if(nums[i-1] &lt; nums[i])&#123; int j = nums.size() - 1; while(nums[i-1] &gt;= nums[j]) j--; int tmp = nums[j]; nums[j] = nums[i-1]; nums[i-1] = tmp; reverse(nums.begin()+i, nums.end()); return; &#125; if(i == 1)&#123; reverse(nums.begin(), nums.end()); return; &#125; &#125; &#125;&#125;; 12ms, 10.84%, April.23rd, 2016 http://blog.csdn.net/m6830098/article/details/17291259 123456class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; next_permutation(nums.begin(), nums.end()); &#125;&#125;; python https://discuss.leetcode.com/topic/52275/easy-python-solution-based-on-lexicographical-permutation-algorithm Easy python solution based on lexicographical permutation algorithm For the detailed algorithm and demonstration, please go to https://www.nayuki.io/page/next-lexicographical-permutation-algorithm The steps are shown in the picture below. 123456789101112131415161718192021222324252627282930class Solution(object): def nextPermutation(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; # find longest non-increasing suffix right = len(nums)-1 while nums[right] &lt;= nums[right-1] and right-1 &gt;=0: right -= 1 if right == 0: return self.reverse(nums,0,len(nums)-1) # find pivot pivot = right-1 successor = 0 # find rightmost succesor for i in range(len(nums)-1,pivot,-1): if nums[i] &gt; nums[pivot]: successor = i break # swap pivot and successor nums[pivot],nums[successor] = nums[successor],nums[pivot] # reverse suffix self.reverse(nums,pivot+1,len(nums)-1) def reverse(self,nums,l,r): while l &lt; r: nums[l],nums[r] = nums[r],nums[l] l += 1 r -= 1 60ms, 77.71%, April.23rd, 2016 https://leetcode.com/discuss/59874/two-pointer-solution-in-python-with-detail-expalanation Two-pointer solution in python with detail expalanation Credit goes to http://blog.csdn.net/m6830098/article/details/17291259 1234567891011121314151617181920212223class Solution(object): def nextPermutation(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. &quot;&quot;&quot; # Use two-pointers: two pointers start from back # first pointer j stop at descending point # second pointer i stop at value &gt; nums[j] # swap and sort rest if not nums: return None i = len(nums)-1 j = -1 # j is set to -1 for case `4321`, so need to reverse all in following step while i &gt; 0: if nums[i-1] &lt; nums[i]: # first one violates the trend j = i-1 break i-=1 for i in xrange(len(nums)-1, -1, -1): if nums[i] &gt; nums[j]: # nums[i], nums[j] = nums[j], nums[i] # swap position nums[j+1:] = sorted(nums[j+1:]) # sort rest return java https://discuss.leetcode.com/topic/2542/share-my-o-n-time-solution Share my O(n) time solution My idea is for an array: Start from its last element, traverse backward to find the first one with index i that satisfy num[i-1] &lt; num[i]. So, elements from num[i] to num[n-1] is reversely sorted. To find the next permutation, we have to swap some numbers at different positions, to minimize the increased amount, we have to make the highest changed position as high as possible. Notice that index larger than or equal to i is not possible as num[i,n-1] is reversely sorted. So, we want to increase the number at index i-1, clearly, swap it with the smallest number between num[i,n-1] that is larger than num[i-1]. For example, original number is 121543321, we want to swap the ‘1’ at position 2 with ‘2’ at position 7. The last step is to make the remaining higher position part as small as possible, we just have to reversely sort the num[i,n-1] The following is my code: 1234567891011121314151617181920212223242526272829303132333435363738394041public void nextPermutation(int[] num) &#123; int n=num.length; if(n&lt;2) return; int index=n-1; while(index&gt;0)&#123; if(num[index-1]&lt;num[index]) break; index--; &#125; if(index==0)&#123; reverseSort(num,0,n-1); return; &#125; else&#123; int val=num[index-1]; int j=n-1; while(j&gt;=index)&#123; if(num[j]&gt;val) break; j--; &#125; swap(num,j,index-1); reverseSort(num,index,n-1); return; &#125;&#125;public void swap(int[] num, int i, int j)&#123; int temp=0; temp=num[i]; num[i]=num[j]; num[j]=temp;&#125;public void reverseSort(int[] num, int start, int end)&#123; if(start&gt;end) return; for(int i=start;i&lt;=(end+start)/2;i++) swap(num,i,start+end-i);&#125; https://discuss.leetcode.com/topic/14124/sharing-my-clean-and-easy-understand-java-code-with-explanation Sharing my clean and easy-understand java code with explanation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public void nextPermutation(int[] nums) &#123; if(nums.length&lt;=1)&#123; return; &#125; int i= nums.length-1; for(;i&gt;=1;i--)&#123; if(nums[i]&gt;nums[i-1])&#123; //find first number which is smaller than it&apos;s after number break; &#125; &#125; if(i!=0)&#123; swap(nums,i-1); //if the number exist,which means that the nums not like&#123;5,4,3,2,1&#125; &#125; reverse(nums,i); &#125; private void swap(int[] a,int i)&#123; for(int j = a.length-1;j&gt;i;j--)&#123; if(a[j]&gt;a[i])&#123; int t = a[j]; a[j] = a[i]; a[i] = t; break; &#125; &#125; &#125; private void reverse(int[] a,int i)&#123;//reverse the number after the number we have found int first = i; int last = a.length-1; while(first&lt;last)&#123; int t = a[first]; a[first] = a[last]; a[last] = t; first ++; last --; &#125; &#125; &#125; 在当前序列中，从尾端往前寻找两个相邻元素，前一个记为first，后一个记为second，并且满足first 小于 second。然后再从尾端寻找另一个元素number，如果满足first 小于number，即将第first个元素与number元素对调，并将second元素之后（包括second）的所有元素颠倒排序，即求出下一个序列 example: 6，3，4，9，8，7，1 此时 first ＝ 4，second = 9 从尾巴到前找到第一个大于first的数字，就是7 交换4和7，即上面的swap函数，此时序列变成6，3，7，9，8，4，1 再将second＝9以及以后的序列重新排序，让其从小到大排序，使得整体最小，即reverse一下（因为此时肯定是递减序列） 得到最终的结果：6，3，7，1，4，8，9 https://discuss.leetcode.com/topic/30212/easiest-java-solution Easiest JAVA Solution Using a simple example, we can derive the following steps: 123456789101112131415161718192021public void nextPermutation(int[] A) &#123; if(A == null || A.length &lt;= 1) return; int i = A.length - 2; while(i &gt;= 0 &amp;&amp; A[i] &gt;= A[i + 1]) i--; // Find 1st id i that breaks descending order if(i &gt;= 0) &#123; // If not entirely descending int j = A.length - 1; // Start from the end while(A[j] &lt;= A[i]) j--; // Find rightmost first larger id j swap(A, i, j); // Switch i and j &#125; reverse(A, i + 1, A.length - 1); // Reverse the descending sequence&#125;public void swap(int[] A, int i, int j) &#123; int tmp = A[i]; A[i] = A[j]; A[j] = tmp;&#125;public void reverse(int[] A, int i, int j) &#123; while(i &lt; j) swap(A, i++, j--);&#125; https://discuss.leetcode.com/topic/30688/readable-code-without-confusing-i-j-and-with-explanation Readable code without confusing i/j, and with explanation Implementation based on description from Project Nayuki. I cannot describe it better than them: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123;/*0*/ public void nextPermutation(int[] nums) &#123; // pivot is the element just before the non-increasing (weakly decreasing) suffix/*2*/ int pivot = indexOfLastPeak(nums) - 1; // paritions nums into [prefix pivot suffix] if (pivot != -1) &#123; int nextPrefix = lastIndexOfGreater(nums, nums[pivot]); // in the worst case it&apos;s suffix[0] // next prefix must exist because pivot &lt; suffix[0], otherwise pivot would be part of suffix/*4*/ swap(nums, pivot, nextPrefix); // this minimizes the change in prefix &#125;/*5*/ reverseSuffix(nums, pivot + 1); // reverses the whole list if there was no pivot/*6*/ &#125; /** * Find the last element which is a peak. * In case there are multiple equal peaks, return the first of those. * @return first index of last peak *//*1*/ int indexOfLastPeak(int[] nums) &#123; for (int i = nums.length - 1; 0 &lt; i; --i) &#123; if (nums[i - 1] &lt; nums[i]) return i; &#125; return 0; &#125; /** @return last index where the &#123;@code num &gt; threshold&#125; or -1 if not found *//*3*/ int lastIndexOfGreater(int[] nums, int threshold) &#123; for (int i = nums.length - 1; 0 &lt;= i; --i) &#123; if (threshold &lt; nums[i]) return i; &#125; return -1; &#125; /** Reverse numbers starting from an index till the end. */ void reverseSuffix(int[] nums, int start) &#123; int end = nums.length - 1; while (start &lt; end) &#123; swap(nums, start++, end--); &#125; &#125; void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[030. Substring with Concatenation of All Words]]></title>
    <url>%2Fp%2Ff97ee9f9%2F</url>
    <content type="text"><![CDATA[22.0% https://leetcode.com/problems/substring-with-concatenation-of-all-words/ You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. 123456For example, given:s: &quot;barfoothefoobarman&quot;words: [&quot;foo&quot;, &quot;bar&quot;]You should return the indices: [0,9].(order does not matter). 与题目 76 类似， Minimum Window Substring cpp https://discuss.leetcode.com/topic/6617/an-o-n-solution-with-detailed-explanation An O(N) solution with detailed explanation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// travel all the words combinations to maintain a window// there are wl(word len) times travel// each time, n/wl words, mostly 2 times travel for each word// one left side of the window, the other right side of the window// so, time complexity O(wl * 2 * N/wl) = O(2N)vector&lt;int&gt; findSubstring(string S, vector&lt;string&gt; &amp;L) &#123; vector&lt;int&gt; ans; int n = S.size(), cnt = L.size(); if (n &lt;= 0 || cnt &lt;= 0) return ans; // init word occurence unordered_map&lt;string, int&gt; dict; for (int i = 0; i &lt; cnt; ++i) dict[L[i]]++; // travel all sub string combinations int wl = L[0].size(); for (int i = 0; i &lt; wl; ++i) &#123; int left = i, count = 0; unordered_map&lt;string, int&gt; tdict; for (int j = i; j &lt;= n - wl; j += wl) &#123; string str = S.substr(j, wl); // a valid word, accumulate results if (dict.count(str)) &#123; tdict[str]++; if (tdict[str] &lt;= dict[str]) count++; else &#123; // a more word, advance the window left side possiablly while (tdict[str] &gt; dict[str]) &#123; string str1 = S.substr(left, wl); tdict[str1]--; if (tdict[str1] &lt; dict[str1]) count--; left += wl; &#125; &#125; // come to a result if (count == cnt) &#123; ans.push_back(left); // advance one word tdict[S.substr(left, wl)]--; count--; left += wl; &#125; &#125; // not a valid word, reset all vars else &#123; tdict.clear(); count = 0; left = j + wl; &#125; &#125; &#125; return ans;&#125; 698ms, 47.43%, September 22, 2016 https://discuss.leetcode.com/topic/17943/naive-c-solution-using-two-unordered_map-about-20-lines Naive C++ Solution using two unordered_map (about 20 lines) I think the following code is self-explanatory enough. We use an unordered_map&lt;string, int&gt; counts to record the expected times of each word and another unordered_map&lt;string, int&gt; seen to record the times we have seen. Then we check for every possible position of i. Once we meet an unexpected word or the times of some word is larger than its expected times, we stop the check. If we finish the check successfully, push i to the result indexes. 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; unordered_map&lt;string, int&gt; counts; for(string word:words) counts[word]++; int n = s.length(), num = words.size(), len = words[0].length(); vector&lt;int&gt; indexes; for(int i=0; i&lt;n-num*len+1; i++)&#123; unordered_map&lt;string, int&gt; seen; int j = 0; for(;j&lt;num; j++)&#123; string word = s.substr(i+j*len, len); if(counts.find(word)!=counts.end())&#123; seen[word]++; if(seen[word]&gt;counts[word]) break; &#125; else break; &#125; if(j==num) indexes.push_back(i); &#125; return indexes; &#125;&#125;; https://discuss.leetcode.com/topic/7552/my-ac-c-code-o-n-complexity-26ms My AC c++ code, O(n) complexity, 26ms 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution &#123;// The general idea:// Construct a hash function f for L, f: vector&lt;string&gt; -&gt; int, // Then use the return value of f to check whether a substring is a concatenation // of all words in L.// f has two levels, the first level is a hash function f1 for every single word in L.// f1 : string -&gt; double// So with f1, L is converted into a vector of float numbers// Then another hash function f2 is defined to convert a vector of doubles into a single int.// Finally f(L) := f2(f1(L))// To obtain lower complexity, we require f1 and f2 can be computed through moving window.// The following corner case also needs to be considered:// f2(f1([&quot;ab&quot;, &quot;cd&quot;])) != f2(f1([&quot;ac&quot;, &quot;bd&quot;]))// There are many possible options for f2 and f1. // The following code only shows one possibility (probably not the best), // f2 is the function &quot;hash&quot; in the class,// f1([a1, a2, ... , an]) := int( decimal_part(log(a1) + log(a2) + ... + log(an)) * 1000000000 )public: // The complexity of this function is O(nW). double hash(double f, double code[], string &amp;word) &#123; double result = 0.; for (auto &amp;c : word) result = result * f + code[c]; return result; &#125; vector&lt;int&gt; findSubstring(string S, vector&lt;string&gt; &amp;L) &#123; uniform_real_distribution&lt;double&gt; unif(0., 1.); default_random_engine seed; double code[128]; for (auto &amp;d : code) d = unif(seed); double f = unif(seed) / 5. + 0.8; double value = 0; // The complexity of the following for loop is O(L.size( ) * nW). for (auto &amp;str : L) value += log(hash(f, code, str)); int unit = 1e9; int key = (value-floor(value))*unit; int nS = S.size(), nL = L.size(), nW = L[0].size(); double fn = pow(f, nW-1.); vector&lt;int&gt; result; if (nS &lt; nW) return result; vector&lt;double&gt; values(nS-nW+1); string word(S.begin(), S.begin()+nW); values[0] = hash(f, code, word); // Use a moving window to hash every word with length nW in S to a float number, // which is stored in vector values[] // The complexity of this step is O(nS). for (int i=1; i&lt;=nS-nW; ++i) values[i] = (values[i-1] - code[S[i-1]]*fn)*f + code[S[i+nW-1]]; // This for loop will run nW times, each iteration has a complexity O(nS/nW) // So the overall complexity is O(nW * (nS / nW)) = O(nS) for (int i=0; i&lt;nW; ++i) &#123; int j0=i, j1=i, k=0; double sum = 0.; // Use a moving window to hash every L.size() continuous words with length nW in S. // This while loop will terminate within nS/nW iterations since the increasement of j1 is nW, // So the complexity of this while loop is O(nS / nW). while(j1&lt;=nS-nW) &#123; sum += log(values[j1]); ++k; j1 += nW; if (k==nL) &#123; int key1 = (sum-floor(sum)) * unit; if (key1==key) result.push_back(j0); sum -= log(values[j0]); --k; j0 += nW; &#125; &#125; &#125; return result; &#125;&#125;; Though theoretically it has a very small chance to fail. python https://discuss.leetcode.com/topic/3018/hash-idea-and-exception-case Hash Idea and exception case The following python code is accepted by OJ. It is based on the following idea (assumption) We know that two multisets consist of same elements and size of the multisets are equal. if sum of hashes of all elements are the same for these multisets -&gt; those multisets are identical This is not true for same very very rare cases. Please describe such a case. 12345678def findSubstring(self, S, L): n = len(L) #num words w = len(L[0]) #length of each word t = n*w # total length hashsum = sum([hash(x) for x in L]) h = [hash(S[i:i+w])*(S[i:i+w] in L) for i in xrange(len(S)-w+1)] return [i for i in xrange(len(S)-t+1) if sum(h[i:i+t:w])==hashsum] https://discuss.leetcode.com/topic/26043/ac-python-80ms-solution-dictionary-and-two-pointers AC Python 80ms solution, dictionary and two pointers 1234567891011121314151617181920212223242526272829303132333435def _findSubstring(self, l, r, n, k, t, s, req, ans): curr = &#123;&#125; while r + k &lt;= n: w = s[r:r + k] r += k if w not in req: l = r curr.clear() else: curr[w] = curr[w] + 1 if w in curr else 1 while curr[w] &gt; req[w]: curr[s[l:l + k]] -= 1 l += k if r - l == t: ans.append(l)def findSubstring(self, s, words): if not s or not words or not words[0]: return [] n = len(s) k = len(words[0]) t = len(words) * k req = &#123;&#125; for w in words: req[w] = req[w] + 1 if w in req else 1 ans = [] for i in xrange(min(k, n - t + 1)): self._findSubstring(i, i, n, k, t, s, req, ans) return ans# 169 / 169 test cases passed.# Status: Accepted# Runtime: 80 ms# 98.60% First of all consider s as several series of words with length k starting at [0, k-1]. For example “barfoothe” with k = 3, can be view as [“bar”, “foo”, “the”] for i=0 and [“arf”, “oot”] for i = 1 and [“rfo”, “oth”] for i = 2.Thus we need to check each of these series and find out the valid index by definition. For each series, we just need to check if there exist a range [l, r) where the occurrence or “spectrum” of the words in the range is the same as our given word list’s “spectrum”. We use dictionary to store the spectrum and maintain it as we loop through s. collections.Counter class may save a bit of code on updating the counts of the dictionary. However plain dict wins on the speed. https://discuss.leetcode.com/topic/13630/99ms-python-o-kmn-solution 99ms Python O(kmn) Solution The idea comes from [https://leetcode.com/discuss/20151/an-o-n-solution-with-detailed-explanation] Using a counter and a sliding window, we push the window from left to right, counting the number of valid words in the window. When the number of a word in the window is more than the times it appears in words or we meet a invalid word, push the window. 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution:# @param &#123;string&#125; s# @param &#123;string[]&#125; words# @return &#123;integer[]&#125;def findSubstring(self, s, words): if len(words) == 0: return [] # initialize d, l, ans l = len(words[0]) d = &#123;&#125; for w in words: if w in d: d[w] += 1 else: d[w] = 1 i = 0 ans = [] # sliding window(s) for k in range(l): left = k subd = &#123;&#125; count = 0 for j in xrange(k, len(s)-l+1, l): tword = s[j:j+l] # valid word if tword in d: if tword in subd: subd[tword] += 1 else: subd[tword] = 1 count += 1 while subd[tword] &gt; d[tword]: subd[s[left:left+l]] -= 1 left += l count -= 1 if count == len(words): ans.append(left) # not valid else: left = j + l subd = &#123;&#125; count = 0 return ans Assuming we have k words in words, and there are m substrings in the string, the complexity is O(kmn) because we need to adjust the window when more valid words are found. This solution runs 99ms on OJ. java 180ms, September 22, 2016 https://discuss.leetcode.com/topic/6432/simple-java-solution-with-two-pointers-and-map Simple Java Solution with Two Pointers and Map My idea is pretty simple. Just build a map for the words and their relative count in L. Then we traverse through S to check whether there is a match. 12345678910111213141516171819202122232425262728public class Solution &#123; public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(s == null || words == null || words.length == 0) return res; int len = words[0].length(); Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); for(String word:words) map.put(word, map.containsKey(word)?map.get(word)+1:1); for(int i=0; i&lt;=s.length()-len*words.length; i++)&#123; Map&lt;String, Integer&gt; copy = new HashMap&lt;String, Integer&gt;(map); for(int j = 0; j&lt;words.length; j++)&#123; String str = s.substring(i+j*len, i+j*len+len); if(copy.containsKey(str))&#123; int count = copy.get(str); if(count == 1) copy.remove(str); else copy.put(str, count-1); if(copy.isEmpty())&#123; res.add(i); break; &#125; &#125; else break; &#125; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/35676/accepted-java-solution-12ms-with-explanation Accepted Java solution 12ms with explanation It’s not too hard to find some resemblance between this problem and minimum-window-substring. Actually the main difference is the fact that we are interested at some interval length: we want intervals with fixed length K * M, where K is the number of strings in the “words” array and M the length of each target string. In order to apply the same idea we used for that problem, all we need to do is to map each string from the “words” array to something we are able to index (I prefer to use hashing for this). Also, in order to speed up the algorithm, we can find all occurrences of those strings in S (which is equivalent to do it on demand, but we will potentially do the same matching twice). Notice that, we can simply apply these occurrences as they appear because we are assured that no word is contained by some other. Finally, we use all this information to process each possibility. Notice here that, the fact that all strings has the same length, implies that we have just M (being M the length of each target string) possible starting points, hence we end up performing M linear scans over array with length O(N/M) (being N the length of S) and that makes the scanning stage of the algorithm to be linear on the length of S. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; int N = s.length(); List&lt;Integer&gt; indexes = new ArrayList&lt;Integer&gt;(s.length()); if (words.length == 0) &#123; return indexes; &#125; int M = words[0].length(); if (N &lt; M * words.length) &#123; return indexes; &#125; int last = N - M + 1; //map each string in words array to some index and compute target counters Map&lt;String, Integer&gt; mapping = new HashMap&lt;String, Integer&gt;(words.length); int [][] table = new int[2][words.length]; int failures = 0, index = 0; for (int i = 0; i &lt; words.length; ++i) &#123; Integer mapped = mapping.get(words[i]); if (mapped == null) &#123; ++failures; mapping.put(words[i], index); mapped = index++; &#125; ++table[0][mapped]; &#125; //find all occurrences at string S and map them to their current integer, -1 means no such string is in words array int [] smapping = new int[last]; for (int i = 0; i &lt; last; ++i) &#123; String section = s.substring(i, i + M); Integer mapped = mapping.get(section); if (mapped == null) &#123; smapping[i] = -1; &#125; else &#123; smapping[i] = mapped; &#125; &#125; //fix the number of linear scans for (int i = 0; i &lt; M; ++i) &#123; //reset scan variables int currentFailures = failures; //number of current mismatches int left = i, right = i; Arrays.fill(table[1], 0); //here, simple solve the minimum-window-substring problem while (right &lt; last) &#123; while (currentFailures &gt; 0 &amp;&amp; right &lt; last) &#123; int target = smapping[right]; if (target != -1 &amp;&amp; ++table[1][target] == table[0][target]) &#123; --currentFailures; &#125; right += M; &#125; while (currentFailures == 0 &amp;&amp; left &lt; right) &#123; int target = smapping[left]; if (target != -1 &amp;&amp; --table[1][target] == table[0][target] - 1) &#123; int length = right - left; //instead of checking every window, we know exactly the length we want if ((length / M) == words.length) &#123; indexes.add(left); &#125; ++currentFailures; &#125; left += M; &#125; &#125; &#125; return indexes;&#125; https://discuss.leetcode.com/topic/32038/java-12ms-beats-100 Java 12ms beats 100% The two pointers method with hashmap is known by many other solutions. The idea is to slide the scan window as far as possible, and keep throwing the impossible cases based on the length test. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public List&lt;Integer&gt; findSubstring(String s, String[] words) &#123; /** * Let n=s.length, k=words[0].length traverse s with indices i, i+k, * i+2k, ... for 0&lt;=i&lt;k, so that the time complexity is O(n). */ List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int n = s.length(), m = words.length, k; if (n == 0 || m == 0 || (k = words[0].length()) == 0) return res; HashMap&lt;String, Integer&gt; wDict = new HashMap&lt;String, Integer&gt;(); for (String word : words) &#123; if (wDict.containsKey(word)) wDict.put(word, wDict.get(word) + 1); else wDict.put(word, 1); &#125; int i, j, start, x, wordsLen = m * k; HashMap&lt;String, Integer&gt; curDict = new HashMap&lt;String, Integer&gt;(); String test, temp; for (i = 0; i &lt; k; i++) &#123; curDict.clear(); start = i; if (start + wordsLen &gt; n) return res; for (j = i; j + k &lt;= n; j += k) &#123; test = s.substring(j, j + k); if (wDict.containsKey(test)) &#123; if (!curDict.containsKey(test)) &#123; curDict.put(test, 1); start = checkFound(res, start, wordsLen, j, k, curDict, s); continue; &#125; // curDict.containsKey(test) x = curDict.get(test); if (x &lt; wDict.get(test)) &#123; curDict.put(test, x + 1); start = checkFound(res, start, wordsLen, j, k, curDict, s); continue; &#125; // curDict.get(test)==wDict.get(test), slide start to // the next word of the first same word as test while (!(temp = s.substring(start, start + k)).equals(test)) &#123; decreaseCount(curDict, temp); start += k; &#125; start += k; if (start + wordsLen &gt; n) break; continue; &#125; // totally failed up to index j+k, slide start and reset all start = j + k; if (start + wordsLen &gt; n) break; curDict.clear(); &#125; &#125; return res; &#125; public int checkFound(List&lt;Integer&gt; res, int start, int wordsLen, int j, int k, HashMap&lt;String, Integer&gt; curDict, String s) &#123; if (start + wordsLen == j + k) &#123; res.add(start); // slide start to the next word decreaseCount(curDict, s.substring(start, start + k)); return start + k; &#125; return start; &#125; public void decreaseCount(HashMap&lt;String, Integer&gt; curDict, String key) &#123; // remove key if curDict.get(key)==1, otherwise decrease it by 1 int x = curDict.get(key); if (x == 1) curDict.remove(key); else curDict.put(key, x - 1); &#125; https://discuss.leetcode.com/topic/6593/accepted-recursive-solution-using-trie-tree Accepted recursive solution using Trie Tree The idea is quite simple. Just use a trie tree to accelerate testing whether a substring is valid. The value of each TrieNode is used to deal with duplication and to mark whether the word is used before. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static class TrieNode &#123; int value = 0; Map&lt;Character, TrieNode&gt; children = new HashMap&lt;Character, TrieNode&gt;(); &#125; TrieNode trie;// build a trie treepublic List&lt;Integer&gt; findSubstring(String S, String[] L) &#123; trie = buildTrie(L); int length = getTotalLength(L); List&lt;Integer&gt; result = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; S.length() - length + 1; i++) &#123; if (isSubString(S, i, i + length)) result.add(i); &#125; return result;&#125;private int getTotalLength(String[] L) &#123; int sum = 0; for (String l : L) sum += l.length(); return sum;&#125;private TrieNode buildTrie(String[] L) &#123; TrieNode root = new TrieNode(); for (String l : L) addWord(root, l); return root;&#125;private void addWord(TrieNode root, String s) &#123; TrieNode node = root; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); TrieNode next = node.children.get(c); if (next == null) &#123; next = new TrieNode(); node.children.put(c, next); &#125; node = next; &#125; node.value++;&#125;private boolean isSubString(String S, int start, int end) &#123; if (start == end) return true; // search in the trie tree TrieNode node = trie; for (int i = start; i &lt; end; i++) &#123; char c = S.charAt(i); if (node.children.get(c) == null) return false; node = node.children.get(c); if (node.value &gt; 0) &#123; // leaf &amp; can be used node.value--; // mark as used if (isSubString(S, i + 1, end)) &#123; node.value++; // mark as unused return true; &#125; node.value++; // mark as unused &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hash table</tag>
        <tag>string</tag>
        <tag>two pointers</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[029. Divide Two Integers]]></title>
    <url>%2Fp%2Fa87eef55%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/divide-two-integers/ Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT. cpp https://discuss.leetcode.com/topic/15568/detailed-explained-8ms-c-solution Detailed Explained 8ms C++ solution In this problem, we are asked to divide two integers. However, we are not allowed to use division, multiplication and mod operations. So, what else can we use? Yeah, bit manipulations. Let’s do an example and see how bit manipulations work. Suppose we want to divide 15 by 3, so 15 is dividend and 3 is divisor. Well, division simply requires us to find how many times we can subtract the divisor from the the dividend without making the dividend negative. Let’s get started. We subtract 3 from 15 and we get 12, which is positive. Let’s try to subtract more. Well, we shift 3 to the left by 1 bit and we get 6. Subtracting 6 from 15 still gives a positive result. Well, we shift again and get 12. We subtract 12 from 15 and it is still positive. We shift again, obtaining 24 and we know we can at most subtract 12. Well, since 12 is obtained by shifting 3 to left twice, we know it is 4 times of 3. How do we obtain this 4? Well, we start from 1 and shift it to left twice at the same time. We add 4 to an answer (initialized to be 0). In fact, the above process is like 15 = 3 * 4 + 3. We now get part of the quotient (4), with a remainder 3. Then we repeat the above process again. We subtract divisor = 3 from the remaining dividend = 3 and obtain 0. We know we are done. No shift happens, so we simply add 1 &lt;&lt; 0 to the answer. Now we have the full algorithm to perform division. According to the problem statement, we need to handle some exceptions, such as overflow. Well, two cases may cause overflow: divisor = 0; dividend = INT_MIN and divisor = -1 (because abs(INT_MIN) = INT_MAX + 1). Of course, we also need to take the sign into considerations, which is relatively easy. Putting all these together, we have the following code. 123456789101112131415161718192021class Solution &#123;public: int divide(int dividend, int divisor) &#123; if (!divisor || (dividend == INT_MIN &amp;&amp; divisor == -1)) return INT_MAX; int sign = ((dividend &lt; 0) ^ (divisor &lt; 0)) ? -1 : 1; long long dvd = labs(dividend); long long dvs = labs(divisor); int res = 0; while (dvd &gt;= dvs) &#123; long long temp = dvs, multiple = 1; while (dvd &gt;= (temp &lt;&lt; 1)) &#123; temp &lt;&lt;= 1; multiple &lt;&lt;= 1; &#125; dvd -= temp; res += multiple; &#125; return sign == 1 ? res : -res; &#125;&#125;; https://discuss.leetcode.com/topic/3421/simple-o-log-n-2-c-solution Simple O((log N) ^ 2) C++ solution Long division in binary: The outer loop reduces n by at least half each iteration. So It has O(log N) iterations. The inner loop has at most log N iterations. So the overall complexity is O(( log N)^2) typedef long long ll; 123456789101112131415int divide(int n_, int d_) &#123; ll ans=0; ll n=abs((ll)n_); ll d=abs((ll)d_); while(n&gt;=d)&#123; ll a=d; ll m=1; while((a&lt;&lt;1) &lt; n)&#123;a&lt;&lt;=1;m&lt;&lt;=1;&#125; ans+=m; n-=a; &#125; if((n_&lt;0&amp;&amp;d_&gt;=0)||(n_&gt;=0&amp;&amp;d_&lt;0)) return -ans; return ans;&#125; https://discuss.leetcode.com/topic/38191/summary-of-3-c-solutions Summary of 3 C++ solutions-1- log-based solution 123456789101112131415class Solution &#123;public: int divide(int dividend, int divisor) &#123; /** a/b = e^(ln(a))/e^(ln(b)) = e^(ln(a)-ln(b)) **/ if(dividend==0) return 0; if(divisor==0) return INT_MAX; double t1=log(fabs(dividend)); double t2=log(fabs(divisor)); long long result=double(exp(t1-t2)); if((dividend&lt;0) ^ (divisor&lt;0)) result=-result; if(result&gt;INT_MAX) result=INT_MAX; return result; &#125;&#125;; -2- Binary Index tree idea inspired solution, as we can decompose any result number to sum of the power of 2. Here is the C++ implementation. 123456789101112131415161718192021222324class Solution &#123;public: int divide(int dividend, int divisor) &#123; if(!divisor || (dividend==INT_MIN &amp;&amp; divisor==-1)) return INT_MAX; int sign=((dividend&lt;0)^(divisor&lt;0)) ? -1:1; long long m=labs(dividend); long long n=labs(divisor); int result=0; /** dvd &gt;= 2^k1*dvs + 2^k2*dvs ... **/ while(m&gt;=n)&#123; long long temp=n, count=1; while(m &gt;= (temp&lt;&lt;1))&#123; temp&lt;&lt;=1; count&lt;&lt;=1; &#125; m-=temp; result+=count; &#125; return sign==1?result:-result; &#125;&#125;; -3- concise version of the solution 2 1234567891011121314151617class Solution &#123;public: int divide(int dividend, int divisor) &#123; long long result=0; long long m=abs((long long)dividend); long long n=abs((long long)divisor); while(m&gt;=n)&#123; long long s=n, power=1; while((s&lt;&lt;1) &lt;= m) &#123; s&lt;&lt;=1; power&lt;&lt;=1; &#125; result+=power; m-=s; &#125; if( (dividend&gt;0) ^ (divisor&gt;0)) result = -result; return result&gt;INT_MAX ? INT_MAX:result; &#125;&#125;; python https://discuss.leetcode.com/topic/8714/clear-python-code Clear python code 12345678910111213141516class Solution:# @return an integerdef divide(self, dividend, divisor): positive = (dividend &lt; 0) is (divisor &lt; 0) dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend &gt;= divisor: temp, i = divisor, 1 while dividend &gt;= temp: dividend -= temp res += i i &lt;&lt;= 1 temp &lt;&lt;= 1 if not positive: res = -res return min(max(-2147483648, res), 2147483647) https://discuss.leetcode.com/topic/6966/15-line-easy-understand-solution-129ms 15 line easy understand solution. 129ms for example, if we want to calc (17/2) ret = 0; 17-2 ,ret+=1; left=15 15-4 ,ret+=2; left=11 11-8 ,ret+=4; left=3 3-2 ,ret+=1; left=1 ret=8; 123456789101112131415161718192021class Solution:# @return an integerdef divide(self, dividend, divisor): isMinus= ((dividend&lt;0 and divisor &gt;0) or (dividend&gt;0 and divisor &lt;0)); ret=0; dividend,divisor=abs(dividend),abs(divisor); c,sub=1,divisor; while(dividend &gt;= divisor): if(dividend&gt;=sub): dividend-=sub; ret+=c; sub=(sub&lt;&lt;1); c=(c&lt;&lt;1); else: sub=(sub&gt;&gt;1); c=(c&gt;&gt;1); if(isMinus): ret=-ret; return min(max(-2147483648,ret),2147483647); java https://discuss.leetcode.com/topic/23968/clean-java-solution-with-some-comment Clean Java solution with some comment. 12345678910111213141516171819202122232425262728293031323334353637383940public int divide(int dividend, int divisor) &#123; //Reduce the problem to positive long integer to make it easier. //Use long to avoid integer overflow cases. int sign = 1; if ((dividend &gt; 0 &amp;&amp; divisor &lt; 0) || (dividend &lt; 0 &amp;&amp; divisor &gt; 0)) sign = -1; long ldividend = Math.abs((long) dividend); long ldivisor = Math.abs((long) divisor); //Take care the edge cases. if (ldivisor == 0) return Integer.MAX_VALUE; if ((ldividend == 0) || (ldividend &lt; ldivisor)) return 0; long lans = ldivide(ldividend, ldivisor); int ans; if (lans &gt; Integer.MAX_VALUE)&#123; //Handle overflow. ans = (sign == 1)? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; else &#123; ans = (int) (sign * lans); &#125; return ans;&#125;private long ldivide(long ldividend, long ldivisor) &#123; // Recursion exit condition if (ldividend &lt; ldivisor) return 0; // Find the largest multiple so that (divisor * multiple &lt;= dividend), // whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason. // Think this as a binary search. long sum = ldivisor; long multiple = 1; while ((sum+sum) &lt;= ldividend) &#123; sum += sum; multiple += multiple; &#125; //Look for additional value for the multiple from the reminder (dividend - sum) recursively. return multiple + ldivide(ldividend - sum, ldivisor);&#125; https://discuss.leetcode.com/topic/8271/accepted-java-solution-with-comments Accepted Java solution with comments. 12345678910111213141516171819202122232425262728293031public int divide(int dividend, int divisor) &#123; long result = divideLong(dividend, divisor); return result &gt; Integer.MAX_VALUE ? Integer.MAX_VALUE : (int)result;&#125;// It&apos;s easy to handle edge cases when// operate with long numbers rather than intpublic long divideLong(long dividend, long divisor) &#123; // Remember the sign boolean negative = dividend &lt; 0 != divisor &lt; 0; // Make dividend and divisor unsign if (dividend &lt; 0) dividend = -dividend; if (divisor &lt; 0) divisor = -divisor; // Return if nothing to divide if (dividend &lt; divisor) return 0; // Sum divisor 2, 4, 8, 16, 32 .... times long sum = divisor; long divide = 1; while ((sum+sum) &lt;= dividend) &#123; sum += sum; divide += divide; &#125; // Make a recursive call for (devided-sum) and add it to the result return negative ? -(divide + divideLong((dividend-sum), divisor)) : (divide + divideLong((dividend-sum), divisor));&#125; https://discuss.leetcode.com/topic/3631/a-readable-java-implementation A readable Java implementation At first, I used dividend / divisor, just to check. But that was cheating. Then, I implemented a solution which failed the corner cases. I solved it by using long instead of int. But I felt that was also cheating. At last, I came up with this solution. It handles all the corner cases. Running time analysis after the code. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123; public int divide(int dividend, int divisor) &#123; if (divisor == 1) // Trival case 1 return dividend; // Use negative integers to avoid integer overflow if (dividend &gt; 0) return -divide(-dividend, divisor); if (divisor &gt; 0) return -divide(dividend, -divisor); if (dividend &gt; divisor) // Trivial case 2 return 0; if ((dividend == Integer.MIN_VALUE) &amp;&amp; (divisor == -1)) // Overflow case return Integer.MAX_VALUE; // Find the highest mult = (divisor * 2^shifts) which is &lt;= dividend // by shifting mult to the left without causing an overflow. // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations. int min_divisor = Integer.MIN_VALUE &gt;&gt; 1; int mult = divisor; // = divisor * 2^shifts int shifts = 0; while ((mult &gt;= min_divisor) &amp;&amp; (mult &gt; dividend)) &#123; mult &lt;&lt;= 1; ++shifts; &#125; // Compute the result by shifting mult to the right. // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations for the outer loop. // At most (log2(|dividend|) - log2(|divisor|) + 1) iterations for the inner loop // (in total, not per outer iteration). int result = 0; int power = 1 &lt;&lt; shifts; // = 2^shifts while (dividend &lt;= divisor) &#123; shifts = 0; while (mult &lt; dividend) &#123; mult &gt;&gt;= 1; ++shifts; &#125; dividend -= mult; power &gt;&gt;= shifts; result |= power; // Adds power to result &#125; return result; &#125;&#125; I see lots of people talking about O(log(n)) solutions. Since n is bounded by -2^31 and 2^31-1, I’m not sure the Big-Oh notation is appropriate here. Anyway, here’s a rough worst-case analysis of this code. The first loop runs (log2(|dividend|) - log2(|divisor|) + 1) times. There are 2 comparisons 1 bit shift 1 increment The second loop runs between 1 time and (log2(|dividend|) - log2(|divisor|) + 1) times. For worst-case, we take the latter. There are 1 comparison 1 assignment 1 substraction 1 bit shift 1 bitwise or The inner while loop runs (log2(|dividend|) - log2(|divisor|) + 1) times also (in total, not per outer loop iteration). There are 1 comparison 1 bit shift 1 increment So, roughly, the overall worst-case running time is 12(log2(dividend) - log2(divisor) + 1) operations. You can notice that (log2(|dividend|) - log2(|divisor|)) = log2(|result|). Thus, the running time is (worst-case) 12(log2(|result|) + 1) operations.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[028. Implement strStr()]]></title>
    <url>%2Fp%2F78eeb38d%2F</url>
    <content type="text"><![CDATA[27.5% https://leetcode.com/problems/implement-strstr/ Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 方法一：暴力法 1234567891011121314class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.size(), n = needle.size(); if(!haystack || !needle || m&lt;n) return -1; for(int i=0; ;i++)&#123; for(int j=0; ;j++)&#123; if(j==n-1) return i; if(i+j==m-1) return -1; if(haystack[i+j]!=needle[j]) break; &#125; &#125; &#125;&#125;; 我的代码实现： 123456789101112131415class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.size(), n = needle.size(); if(n==0) return 0; if(m==0 || m&lt;n) return -1; for(int i=0; ;i++)&#123; for(int j=0; ;j++)&#123; if(j==n) return i; if(i+j==m) return -1; if(haystack[i+j]!=needle[j]) break; &#125; &#125; &#125;&#125;; 方法二：KMP算法 先建立lps，然后使用kmp算法 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.length(), n = needle.length(); if (!n) return 0; vector&lt;int&gt; lps = kmpProcess(needle); for (int i = 0, j = 0; i &lt; m; ) &#123; if (haystack[i] == needle[j]) &#123; i++; j++; &#125; if (j == n) return i - j; if (i &lt; m &amp;&amp; haystack[i] != needle[j]) &#123; if (j) j = lps[j - 1]; else i++; &#125; &#125; return -1; &#125;private: vector&lt;int&gt; kmpProcess(string&amp; needle) &#123; int n = needle.length(); vector&lt;int&gt; lps(n, 0); for (int i = 1, len = 0; i &lt; n; ) &#123; if (needle[i] == needle[len]) lps[i++] = ++len; else if (len) len = lps[len - 1]; else lps[i++] = 0; &#125; return lps; &#125;&#125;; 完整实现代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// C++ program for implementation of KMP pattern searching// algorithm#include&lt;bits/stdc++.h&gt; void computeLPSArray(char *pat, int M, int *lps); // Prints occurrences of txt[] in pat[]void KMPSearch(char *pat, char *txt)&#123; int M = strlen(pat); int N = strlen(txt); // create lps[] that will hold the longest prefix suffix // values for pattern int lps[M]; // Preprocess the pattern (calculate lps[] array) computeLPSArray(pat, M, lps); int i = 0; // index for txt[] int j = 0; // index for pat[] while (i &lt; N) &#123; if (pat[j] == txt[i]) &#123; j++; i++; &#125; if (j == M) &#123; printf("Found pattern at index %d n", i-j); j = lps[j-1]; &#125; // mismatch after j matches else if (i &lt; N &amp;&amp; pat[j] != txt[i]) &#123; // Do not match lps[0..lps[j-1]] characters, // they will match anyway if (j != 0) j = lps[j-1]; else i = i+1; &#125; &#125;&#125; // Fills lps[] for given patttern pat[0..M-1]void computeLPSArray(char *pat, int M, int *lps)&#123; // length of the previous longest prefix suffix int len = 0; lps[0] = 0; // lps[0] is always 0 // the loop calculates lps[i] for i = 1 to M-1 int i = 1; while (i &lt; M) &#123; if (pat[i] == pat[len]) &#123; len++; lps[i] = len; i++; &#125; else // (pat[i] != pat[len]) &#123; // This is tricky. Consider the example. // AAACAAAA and i = 7. The idea is similar // to search step. if (len != 0) &#123; len = lps[len-1]; // Also, note that we do not increment // i here &#125; else // if (len == 0) &#123; lps[i] = 0; i++; &#125; &#125; &#125;&#125; // Driver program to test above functionint main()&#123; char *txt = "ABABDABACDABABCABAB"; char *pat = "ABABCABAB"; KMPSearch(pat, txt); return 0;&#125; 说明： http://www.cplusplus.com/reference/cstring/strstr/ 123strstrconst char * strstr ( const char * str1, const char * str2 ); char * strstr ( char * str1, const char * str2 ); Locate substring Returns a pointer to the first occurrence of str2 in str1, or a null pointer if str2 is not part of str1. The matching process does not include the terminating null-characters, but it stops there. KMP算法阅读资料 KMP on jBoxer’s blog; http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/ KMP on geeksforgeeks, with a well-commented C code. http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/ 阮一峰的博客 http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html https://discuss.leetcode.com/topic/6888/this-test-case-doesn-t-make-sense This test case doesn’t make sense. Input: “”, “”Output: -1Expected: 0 Basically there is nothing in the string, how do you get the index. If this test case is valid, then needle =””, haystack=”anything” could return any value. since empty is everywhere. cpp https://discuss.leetcode.com/topic/15569/explained-4ms-easy-c-solution Explained 4ms Easy C++ solution Well, the problem does not aim for an advanced algorithm like KMP but only a clean brute-force algorithm. So we can traverse all the possible starting points of haystack (from 0 to haystack.length() - needle.length()) and see if the following characters in haystack match those of needle. The code is as follows. 123456789101112131415class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.length(), n = needle.length(); if (!n) return 0; for (int i = 0; i &lt; m - n + 1; i++) &#123; int j = 0; for (; j &lt; n; j++) if (haystack[i + j] != needle[j]) break; if (j == n) return i; &#125; return -1; &#125;&#125;; Of course, you may challenge yourself implementing the KMP algorithm for this problem. KMP is a classic and yet notoriously hard-to-understand algorithm. However, I think the following two links give nice explanations. You may refer to them. KMP on jBoxer’s blog; http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/ KMP on geeksforgeeks, with a well-commented C code. http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/ I am sorry that I am still unable to give a personal explanation of the algorithm. I only read it from the two links above and mimic the code in the second link. My accepted C++ code using KMP is as follows. Well, it also takes 4ms -_- 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int strStr(string haystack, string needle) &#123; int m = haystack.length(), n = needle.length(); if (!n) return 0; vector&lt;int&gt; lps = kmpProcess(needle); for (int i = 0, j = 0; i &lt; m; ) &#123; if (haystack[i] == needle[j]) &#123; i++; j++; &#125; if (j == n) return i - j; if (i &lt; m &amp;&amp; haystack[i] != needle[j]) &#123; if (j) j = lps[j - 1]; else i++; &#125; &#125; return -1; &#125;private: vector&lt;int&gt; kmpProcess(string&amp; needle) &#123; int n = needle.length(); vector&lt;int&gt; lps(n, 0); for (int i = 1, len = 0; i &lt; n; ) &#123; if (needle[i] == needle[len]) lps[i++] = ++len; else if (len) len = lps[len - 1]; else lps[i++] = 0; &#125; return lps; &#125;&#125;; https://discuss.leetcode.com/topic/4340/my-c-code-that-implements-boyer-moore-string-search-got-accepted-in-12ms My c++ code that implements Boyer-Moore string search got accepted in 12ms. I implements Boyer-Moore string search algorithm and it turns out to be very efficient (accepted in 12ms). Boyer-Moore uses information gained by preprocessing the pattern string to skip as many alignments as possible. A shift is calculated by applying both rules: the bad character rule and the good suffix rule. The actual shifting offset is the maximum of the shifts calculated by these rules. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657char *strStr(char *haystack, char *needle) &#123; if(NULL==haystack||NULL==needle) return NULL; int plen = strlen(needle); int slen = strlen(haystack); if(0==plen) return haystack; else if(plen&gt;slen) return NULL; int badChar[256]; int np = 0; int i,j,k; for(i=0;i&lt;256;i++) badChar[i] = plen; while(np&lt;plen) &#123; badChar[*(needle+np)] = plen-np-1; np++; &#125; int* goodSuffix = new int[plen]; int prefix_index = plen; for(i=plen-1;i&gt;=0;i--) &#123; goodSuffix[i] = prefix_index; if(*(needle+i)==*(needle+plen-1-i)&amp;&amp;prefix_index==i+1) prefix_index = i; &#125; for(i=0;i&lt;plen-1;i++) &#123; j = plen-1, k = 0; while(k&lt;i&amp;&amp;*(needle+j)==*(needle+i-k)) &#123;j--;k++;&#125; if(*(needle+plen-1)==*(needle+i)) goodSuffix[j] = plen-1-i; &#125; goodSuffix[plen-1] = 0; int sp = 0; while(sp&lt;slen) &#123; i = plen-1; while(i&gt;=0&amp;&amp;*(haystack+sp+i)==*(needle+i)) i--; if(i&lt;0) return haystack+sp; int bj = badChar[*(haystack+sp+i)] - plen + i + 1; sp += (bj&gt;goodSuffix[i]?bj:goodSuffix[i]); &#125; delete goodSuffix; return NULL;&#125; https://discuss.leetcode.com/topic/31171/kmp-in-c-explanation-included KMP in C++, explanation included 123456789101112131415161718192021222324252627282930313233343536373839404142434445int strStr(string haystack, string needle) &#123; int nsize = needle.size(); int hsize = haystack.size(); if (nsize == 0) return 0; int *table = new int[nsize]; memset(table, 0, sizeof(int)*nsize); //building match table for (int i = 1, j = 0; i &lt; nsize - 1;)&#123; if (needle[i] != needle[j])&#123; if (j&gt;0)&#123; j = table[j - 1]; &#125; else&#123; i++; &#125; &#125; else&#123; table[i] = j + 1; i++; j++; &#125; &#125; //matching for (int i = 0, match_pos = 0; i &lt; hsize;)&#123; if (haystack[i] == needle[match_pos])&#123; if (match_pos == nsize - 1)&#123; return i - (nsize - 1); &#125; else&#123; i++; match_pos++; &#125; &#125; else&#123; if (match_pos == 0)&#123; i++; &#125; else&#123; match_pos = table[match_pos - 1]; &#125; &#125; &#125; delete[]table; return -1; &#125; I’ll talk about the basic idea behind KMP algorithm. First, some notations: Denote the pattern string as ps and the match table as table, ps and table use 0 based index. Denote substring of ps from index i to index j (i and j included) as substr(ps,i,j). Denote string1 is the same as string2 as string1==string2 The definition of my match table: table[i] when i&gt;0 means the max length of prefix of ps(0,i) which is the same as the suffix of ps(0,i). Or1table[i]=max&#123;k| substr(substr(ps,0,i),0,k-1) == substr(substr(ps,0,i),i-k+1,i), k&lt;=i&#125;. Also, we define table[i]=0. So, for string “aba”, table={0,0,1}. table[1]=0 is because no prefix equals suffix of “ab”. table[2]=1 is because prefix “a” equals suffix “a” of “aba”. for string “abcabce”, table={0,0,0,1,2,3,0}. table[4]=2 is because prefix “ab” equals suffix “ab” of “abcab” table[5]=3 is because prefix “abc” equals suffix “abc” of “abcabc” for string “aabaabaaa”, table={0,1,0,1,2,3,4,5,2}. How would this match table be helpful to string matching? Suppose we have a target string “abcabcdxxxxx” and a pattern “abcabce”.In the first round of matching, we start at first character and have 12abcabcdxxxxxabcabce We discover that ‘d’ and ‘e’ are different and string before that is the same, which is “abcabc”.if we move “abcabce” forward one character, we would be comparing 12abcabcdxxxxx abcabce let’s focus on the parts which are same in the previous round: 12abcabc abcabc we are actually comparing the suffix of length 5 of “abcabc”, which is “bcabc” and the prefix of length 5 of “abcabc”, which is “abcab”. However, table[5]==3 tells us the max length of suffix and prefix of “abcabc” which are same is 3, so suffix and prefixof length 5 can’t be the same. Thus, we can skip this round of comparing.Next, we move “abcabce” forward by another one character, we would be comparing 12abcabc abcabc Now, we are comparing suffix and prefix of length 4, since table[5]==3, we can skip this round.Next, we move “abcabce” forward by another one character, we would be comparing 12abcabc abcabc Now, we are comparing suffix and prefix of length 3, since table[5]==3, this is valid.Another property we can use to simply the matching process is that we already know the prefix and suffix of length 3 are the same, so we can start by comparing from the 4th charater in pattern, which is ‘a’, with the target string. To sum up, when the ps(pattern string) at index i(i&gt;0) failed to match ts(target string) at index j, which means substr(ps,0,i-1) matches, we start by comparing ps[table[i-1]] with ts[j]. python 35ms, 100.00%, September 6, 2016 https://discuss.leetcode.com/topic/29848/my-answer-by-python My answer by Python 1234567891011class Solution(object): def strStr(self, haystack, needle): &quot;&quot;&quot; :type haystack: str :type needle: str :rtype: int &quot;&quot;&quot; for i in range(len(haystack)-len(needle)+1): if haystack[i:i+len(needle)] == needle: return i return -1 c 0ms, 28.37%, September 6, 2016 https://discuss.leetcode.com/topic/6557/a-very-clean-solution-brute-force A very clean solution, brute-force 12345678910int strStr(char *haystack, char *needle) &#123; if (!haystack || !needle) return -1; for (int i = 0; ; ++i) &#123; for (int j = 0; ; ++j) &#123; if (needle[j] == 0) return i; if (haystack[i + j] == 0) return -1; if (haystack[i + j] != needle[j]) break; &#125; &#125; &#125; java 8ms, 28.67%, September 9, 2016 https://discuss.leetcode.com/topic/18839/elegant-java-solution Elegant Java solution 12345678910public class Solution &#123; public int strStr(String haystack, String needle) &#123; for(int i=0; ; i++) for(int j=0; ; j++)&#123; if(j == needle.length()) return i; if(i+j == haystack.length()) return -1; if(needle.charAt(j) != haystack.charAt(i+j)) break; &#125; &#125;&#125; https://discuss.leetcode.com/topic/9872/share-my-accepted-java-solution Share my accepted java solution 1234567891011121314151617public class Solution &#123; public int strStr(String haystack, String needle) &#123; int l1 = haystack.length(), l2 = needle.length(); if (l1 &lt; l2) &#123; return -1; &#125; else if (l2 == 0) &#123; return 0; &#125; int threshold = l1 - l2; for (int i = 0; i &lt;= threshold; ++i) &#123; if (haystack.substring(i,i+l2).equals(needle)) &#123; return i; &#125; &#125; return -1; &#125;&#125; https://discuss.leetcode.com/topic/3576/accepted-kmp-solution-in-java-for-reference Accepted KMP solution in java for reference 1234567891011121314151617181920212223242526272829303132333435public String strStr(String haystack, String needle) &#123; //KMP algorithms if(needle.equals(&quot;&quot;)) return haystack; if(haystack.equals(&quot;&quot;)) return null; char[] arr = needle.toCharArray(); int[] next = makeNext(arr); for(int i = 0, j = 0, end = haystack.length(); i &lt; end;)&#123; if(j == -1 || haystack.charAt(i) == arr[j])&#123; j++; i++; if(j == arr.length) return haystack.substring(i - arr.length); &#125; if(i &lt; end &amp;&amp; haystack.charAt(i) != arr[j]) j = next[j]; &#125; return null;&#125;private int[] makeNext(char[] arr)&#123; int len = arr.length; int[] next = new int[len]; next[0] = -1; for(int i = 0, j = -1; i + 1 &lt; len;)&#123; if(j == -1 || arr[i] == arr[j])&#123; next[i+1] = j+1; if(arr[i+1] == arr[j+1]) next[i+1] = next[j+1]; i++; j++; &#125; if(arr[i] != arr[j]) j = next[j]; &#125; return next;&#125; https://discuss.leetcode.com/topic/41463/java-easy-to-understand-solutions Java easy to understand solutions. 123456789101112131415161718public int strStr1(String haystack, String needle) &#123; return haystack.indexOf(needle);&#125;public int strStr(String haystack, String needle) &#123; if (haystack == null || needle == null) return -1; int l1 = haystack.length(); int l2 = needle.length(); for (int i = 0; i &lt; l1-l2+1; i++) &#123; int count = 0; while (count &lt; l2 &amp;&amp; haystack.charAt(i+count) == needle.charAt(count)) count++; if (count == l2) return i; &#125; return -1;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[027. Remove Element]]></title>
    <url>%2Fp%2F98cbed82%2F</url>
    <content type="text"><![CDATA[39.1% https://leetcode.com/problems/remove-element/ Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. 1234Example:Given input array nums = [3,2,2,3], val = 3Your function should return length = 2, with the first two elements of nums being 2. Hint: Try two pointers. Did you use the property of “the order of elements can be changed”? What happens when the elements to remove are rare? 方法一： https://discuss.leetcode.com/topic/17282/very-simple-and-optimal-c-solution Very simple and optimal c++ solution. 12345678910int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int cnt = 0; for(int i = 0 ; i &lt; nums.size() ; ++i) &#123; if(nums[i] == val) cnt++; else nums[i-cnt] = nums[i]; &#125; return nums.size()-cnt;&#125; 方法二： beats 4.4%,but the other 95.6% are same to you ~ including me 4ms, 4.44%, April.23rd, 2016 123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int index = 0; for(int i = 0; i &lt; nums.size(); ++i)&#123; if(nums[i] != val)&#123; nums[index++] = nums[i]; &#125; &#125; return index; &#125;&#125;; 4ms, 4.44%, April.23rd, 2016 123456class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; return distance(nums.begin(), remove(nums.begin(), nums.end(), val)); &#125;&#125;; 4ms, 4.44%, April.23rd, 2016 123456789101112131415class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int tail = nums.size() -1; int i = 0; while(i &lt;= tail)&#123; if(nums[i] == val)&#123; nums[i] = nums[tail--]; continue; &#125; i++; &#125; return tail+1; &#125;&#125;; 我的代码实现： 123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int n = nums.size(); if(n==0) return 0; int index = -1; for(int i=0; i&lt;n; i++) if(nums[i]!=val) nums[++index] = nums[i]; return index+1; &#125;&#125;; python https://discuss.leetcode.com/topic/27777/simple-python-o-n-two-pointer-in-place-solution Simple Python O(n) two pointer in place solution Starting from the left every time we find a value that is the target value we swap it out with an item starting from the right. We decrement end each time as we know that the final item is the target value and only increment start once we know the value is ok. Once start reaches end we know all items after that point are the target value so we can stop there. 12345678def removeElement(self, nums, val): start, end = 0, len(nums) - 1 while start &lt;= end: if nums[start] == val: nums[start], nums[end], end = nums[end], nums[start], end - 1 else: start +=1 return start 48ms, 45.02%, April.23rd, 2016 12345678910class Solution(object): def removeElement(self, nums, val): &quot;&quot;&quot; :type nums: List[int] :type val: int :rtype: int &quot;&quot;&quot; while(val in nums): nums.remove(val) return len(nums) 44ms, 71.09%, April.23rd, 2016 123456789101112class Solution(object): def removeElement(self, nums, val): &quot;&quot;&quot; :type nums: List[int] :type val: int :rtype: int &quot;&quot;&quot; try: while True: nums.remove(val) except: return len(nums) java https://discuss.leetcode.com/topic/1228/my-solution-for-your-reference My solution for your reference. 12345int removeElement(int A[], int n, int elem) &#123; int begin=0; for(int i=0;i&lt;n;i++) if(A[i]!=elem) A[begin++]=A[i]; return begin;&#125; https://discuss.leetcode.com/topic/10753/accepted-java-solution Accepted java solution 123456789101112public int removeElement(int[] A, int elem) &#123; int m = 0; for(int i = 0; i &lt; A.length; i++)&#123; if(A[i] != elem)&#123; A[m] = A[i]; m++; &#125; &#125; return m;&#125; https://discuss.leetcode.com/topic/5205/9-line-java-solution 9-line java solution The basic idea is when elem is found at index i, let A[i] = the last element in the modifying array, then repeat searching until elem is not found. 123456789public int removeElement(int[] A, int elem) &#123; int len = A.length; for (int i = 0 ; i&lt; len; ++i)&#123; while (A[i]==elem &amp;&amp; i&lt; len) &#123; A[i]=A[--len]; &#125; &#125; return len;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[026. Remove Duplicates from Sorted Array]]></title>
    <url>%2Fp%2Fca4383ce%2F</url>
    <content type="text"><![CDATA[35.5% https://leetcode.com/problems/remove-duplicates-from-sorted-array/ Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. 123456For example,Given input array nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn&apos;t matter what you leave beyond the new length. 方法一： beats 35.10% of cppsubmissions 1234567891011class Solution &#123; public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n &lt; 2) return n; int id = 1; for(int i = 1; i &lt; n; ++i) if(nums[i] != nums[i-1]) nums[id++] = nums[i]; return id; &#125;&#125;; 我的代码实现： 123456789101112class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n&lt;=1) return n; int index = 0; for(int i=1; i&lt;n; i++) if(nums[i]!=nums[index]) nums[++index] = nums[i]; return index+1; &#125;&#125;; https://discuss.leetcode.com/topic/17252/5-lines-c-java-nicer-loops 5 lines C++/Java, nicer loops I don’t like old-style indexed looping. I much prefer the “enhanced” (Java) / “range-based” (C++) loops, they make things much cleaner. C++ 1234567int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int i = 0; for (int n : nums) if (!i || n &gt; nums[i-1]) nums[i++] = n; return i;&#125; And to not need the !i check in the loop: 1234567int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int i = !nums.empty(); for (int n : nums) if (n &gt; nums[i-1]) nums[i++] = n; return i;&#125; https://discuss.leetcode.com/topic/8907/share-my-clean-c-code Share my clean C++ code 123456int count = 0;for(int i = 1; i &lt; n; i++)&#123; if(A[i] == A[i-1]) count++; else A[i-count] = A[i];&#125;return n-count; https://discuss.leetcode.com/topic/25354/simple-c-o-n-solution Simple C++ O(n) solution 12345678910int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int pos = 0; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (i == 0 || nums[i] != nums[pos - 1]) nums[pos++] = nums[i]; &#125; return pos;&#125; python https://discuss.leetcode.com/topic/12672/simple-python-solution-o-n Simple Python solution - O(n) 123456789101112131415class Solution: # @param a list of integers # @return an integer def removeDuplicates(self, A): if not A: return 0 newTail = 0 for i in range(1, len(A)): if A[i] != A[newTail]: newTail += 1 A[newTail] = A[i] return newTail + 1 java https://discuss.leetcode.com/topic/3102/my-solution-time-o-n-space-o-1 My Solution : Time O(n), Space O(1) 12345678910class Solution &#123; public: int removeDuplicates(int A[], int n) &#123; if(n &lt; 2) return n; int id = 1; for(int i = 1; i &lt; n; ++i) if(A[i] != A[i-1]) A[id++] = A[i]; return id; &#125;&#125;; https://discuss.leetcode.com/topic/17252/5-lines-c-java-nicer-loops Java 1234567public int removeDuplicates(int[] nums) &#123; int i = 0; for (int n : nums) if (i == 0 || n &gt; nums[i-1]) nums[i++] = n; return i;&#125; And to not need the i == 0 check in the loop: 1234567public int removeDuplicates(int[] nums) &#123; int i = nums.length &gt; 0 ? 1 : 0; for (int n : nums) if (n &gt; nums[i-1]) nums[i++] = n; return i;&#125; https://discuss.leetcode.com/topic/10262/5-lines-java-solution 5 lines Java solution 1234567public int removeDuplicates(int[] A) &#123; if (A.length==0) return 0; int j=0; for (int i=0; i&lt;A.length; i++) if (A[i]!=A[j]) A[++j]=A[i]; return ++j;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>easy</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[025. Reverse Nodes in k-Group]]></title>
    <url>%2Fp%2F6d6210c%2F</url>
    <content type="text"><![CDATA[30.0% https://leetcode.com/problems/reverse-nodes-in-k-group/ Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed. 1234567For example,Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 方法一： 此题目是25题的加强版 迭代，参考反转链表的方法 其实与206题，反转链表类似，但是多了几步。先遍历一遍，获得数目 https://discuss.leetcode.com/topic/9839/20-line-iterative-c-solution 20-line iterative C++ solution 1234567891011-1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 | | |pre cur nex -1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; 5 | | | pre cur nex -1 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5 | | | pre cur nex Above is how it works inside one group iteration(for example, k=3) 优化后的代码： Thanks to ciaoliang1992, the tmp pointer is no necessary, so the more concise solution is 12345678910111213141516171819202122232425class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;++i) &#123; cur-&gt;next=nex-&gt;next; nex-&gt;next=pre-&gt;next; pre-&gt;next=nex; nex=cur-&gt;next; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; 我的代码实现: 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if(!head || !head-&gt;next || k&lt;=1) return head; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* cur = dummy; int cnt = 0; // 有必要的时候可以遍历一遍链表，求出链表的长度 while(cur-&gt;next)&#123; cnt++; cur = cur-&gt;next; &#125; ListNode* pre = dummy, *nex; while(cnt/k)&#123; cur = pre-&gt;next; nex = cur-&gt;next; // 对于反转k个，需要的是k-1个后面的转到前面，而不是k个 for(int i=0; i&lt;k-1; i++)&#123; cur-&gt;next = nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; nex = cur-&gt;next; &#125; pre = cur; cnt -= k; &#125; return dummy-&gt;next; &#125;&#125;; 原始代码： 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *tmp, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;i++) &#123; tmp= nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; cur-&gt;next = tmp; nex = tmp; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; 我的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if(!head || !head-&gt;next || k&lt;=1) return head; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* cur = dummy; int cnt = 0; // 有必要的时候可以遍历一遍链表，求出链表的长度 while(cur-&gt;next)&#123; cnt++; cur = cur-&gt;next; &#125; ListNode* pre = dummy, *nex, *tmp; while(cnt/k)&#123; cur = pre-&gt;next; nex = cur-&gt;next; // 对于反转k个，需要的是k-1个后面的转到前面，而不是k个 for(int i=0; i&lt;k-1; i++)&#123; tmp = nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; cur-&gt;next = tmp; nex = cur-&gt;next; &#125; pre = cur; cnt -= k; &#125; return dummy-&gt;next; &#125;&#125;; 方法二： 递归 C++ Elegant and Small 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: ListNode* reverse(ListNode* first, ListNode* last) &#123; ListNode* prev = last; while ( first != last ) &#123; auto tmp = first-&gt;next; first-&gt;next = prev; prev = first; first = tmp; &#125; return prev; &#125; ListNode* reverseKGroup(ListNode* head, int k) &#123; auto node=head; for (int i=0; i &lt; k; ++i) &#123; if ( ! node ) return head; // nothing to do list too sort node = node-&gt;next; &#125; auto new_head = reverse( head, node); head-&gt;next = reverseKGroup( node, k); return new_head; &#125;&#125;; 我的实现： 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; int cnt = 0; auto node = head; while(cnt&lt;k)&#123; if(node==NULL) return head; cnt++; node = node-&gt;next; &#125; auto new_head = reverse(head, k); head-&gt;next = reverseKGroup(node, k); return new_head; &#125; ListNode* reverse(ListNode* head, int k)&#123; ListNode* pre = NULL; int cnt = 0; while(cnt&lt;k)&#123; ListNode* nex = head-&gt;next; head-&gt;next = pre; pre = head; head = nex; cnt++; &#125; return pre; &#125;&#125;; cpp 其实与206题，反转链表类似，但是多了几步。先遍历一遍，获得数目 https://discuss.leetcode.com/topic/9839/20-line-iterative-c-solution 20-line iterative C++ solution 1234567891011-1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 | | | | pre cur nex tmp-1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; 5 | | | | pre cur nex tmp-1 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5 | | | | pre cur nex tmp Above is how it works inside one group iteration(for example, k=3) 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *tmp, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;i++) &#123; tmp= nex-&gt;next; nex-&gt;next = pre-&gt;next; pre-&gt;next = nex; cur-&gt;next = tmp; nex = tmp; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; Thanks to ciaoliang1992, the tmp pointer is no necessary, so the more concise solution is 12345678910111213141516171819202122232425class Solution &#123;public: ListNode *reverseKGroup(ListNode *head, int k) &#123; if(head==NULL||k==1) return head; int num=0; ListNode *preheader = new ListNode(-1); preheader-&gt;next = head; ListNode *cur = preheader, *nex, *pre = preheader; while(cur = cur-&gt;next) num++; while(num&gt;=k) &#123; cur = pre-&gt;next; nex = cur-&gt;next; for(int i=1;i&lt;k;++i) &#123; cur-&gt;next=nex-&gt;next; nex-&gt;next=pre-&gt;next; pre-&gt;next=nex; nex=cur-&gt;next; &#125; pre = cur; num-=k; &#125; return preheader-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/25867/c-elegant-and-small C++ Elegant and Small 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: ListNode* reverse(ListNode* first, ListNode* last) &#123; ListNode* prev = last; while ( first != last ) &#123; auto tmp = first-&gt;next; first-&gt;next = prev; prev = first; first = tmp; &#125; return prev; &#125; ListNode* reverseKGroup(ListNode* head, int k) &#123; auto node=head; for (int i=0; i &lt; k; ++i) &#123; if ( ! node ) return head; // nothing to do list too sort node = node-&gt;next; &#125; auto new_head = reverse( head, node); head-&gt;next = reverseKGroup( node, k); return new_head; &#125;&#125;; https://discuss.leetcode.com/topic/17914/24ms-easy-c-iterative-solution-with-explanations 24ms Easy C++ Iterative Solution with Explanations Well, since the head pointer may also be modified, we create a new_head that points to it to facilitate the reverse process. For the example list 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 in the problem statement, it will become 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 (we init new_head -&gt; val to be 0). Then we set a pointer pre to new_head and another cur to head. Then we insert cur -&gt; next after pre for k - 1 times if the current node cur has at least k nodes after it (including itself). After reversing one k-group, we update pre to be cur and cur to be pre -&gt; next to reverse the next k-group. The code is as follows. 12345678910111213141516171819202122232425262728293031class Solution &#123; public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if (!hasKNodes(head, k)) return head; ListNode* new_head = new ListNode(0); new_head -&gt; next = head; ListNode* pre = new_head; ListNode* cur = head; while (hasKNodes(cur, k)) &#123; for (int i = 0; i &lt; k - 1; i++) &#123; ListNode* temp = pre -&gt; next; pre -&gt; next = cur -&gt; next; cur -&gt; next = cur -&gt; next -&gt; next; pre -&gt; next -&gt; next = temp; &#125; pre = cur; cur = pre -&gt; next; &#125; return new_head -&gt; next; &#125;private: bool hasKNodes(ListNode* node, int k) &#123; int cnt = 0; while (node) &#123; cnt++; if (cnt &gt;= k) return true; node = node -&gt; next; &#125; return false; &#125;&#125;; python https://discuss.leetcode.com/topic/31618/succinct-iterative-python-o-n-time-o-1-space Succinct iterative Python, O(n) time O(1) space Use a dummy head, and l, r : define reversing range pre, cur : used in reversing, standard reverse linked linked list method jump : used to connect last node in previous k-group to first node in following k-group 12345678910111213141516def reverseKGroup(self, head, k): dummy = jump = ListNode(0) dummy.next = l = r = head while True: count = 0 while r and count &lt; k: # use r to locate the range r = r.next count += 1 if count == k: # if size k satisfied, reverse the inner linked list pre, cur = r, l for _ in range(k): cur.next, cur, pre = pre, cur.next, cur # standard reversing jump.next, jump, l = pre, l, r # connect two k-groups else: return dummy.next https://discuss.leetcode.com/topic/6956/simple-python-solution-one-pass-no-additional-space-109ms Simple Python solution, one pass, no additional space, 109ms The key idea is to keep track of the next_head while reversing the group, tail of the current group is always the start node of the group, once the group reversing is done, next_head is available, simply connect it to tail. 12345678910111213141516171819202122232425def reverseKGroup(self, head, k): if head is None or k &lt; 2: return head next_head = head for i in range(k - 1): next_head = next_head.next if next_head is None: return head ret = next_head current = head while next_head: tail = current prev = None for i in range(k): if next_head: next_head = next_head.next _next = current.next current.next = prev prev = current current = _next tail.next = next_head or current return ret java https://discuss.leetcode.com/topic/7126/short-but-recursive-java-code-with-comments Short but recursive Java code with comments Hi, guys! Despite the fact that the approach is recursive, the code is less than 20 lines. :) 123456789101112131415161718192021public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode curr = head; int count = 0; while (curr != null &amp;&amp; count != k) &#123; // find the k+1 node curr = curr.next; count++; &#125; if (count == k) &#123; // if k+1 node is found curr = reverseKGroup(curr, k); // reverse list with k+1 node as head // head - head-pointer to direct part, // curr - head-pointer to reversed part; while (count-- &gt; 0) &#123; // reverse current k-group: ListNode tmp = head.next; // tmp - next head in direct part head.next = curr; // preappending &quot;direct&quot; head to the reversed list curr = head; // move head of reversed part to a new node head = tmp; // move &quot;direct&quot; head to the next node in direct part &#125; head = curr; &#125; return head;&#125; Hope it helps! https://discuss.leetcode.com/topic/5604/share-my-java-solution-with-comments-in-line Share my Java Solution with comments in line 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if (head==null||head.next==null||k&lt;2) return head; ListNode dummy = new ListNode(0); dummy.next = head; ListNode tail = dummy, prev = dummy,temp; int count; while(true)&#123; count =k; while(count&gt;0&amp;&amp;tail!=null)&#123; count--; tail=tail.next; &#125; if (tail==null) break;//Has reached the end head=prev.next;//for next cycle // prev--&gt;temp--&gt;...---&gt;....---&gt;tail--&gt;.... // Delete @temp and insert to the next position of @tail // prev--&gt;...--&gt;...--&gt;tail--&gt;head--&gt;... // Assign @temp to the next node of @prev // prev--&gt;temp--&gt;...--&gt;tail--&gt;...--&gt;... // Keep doing until @tail is the next node of @prev while(prev.next!=tail)&#123; temp=prev.next;//Assign prev.next=temp.next;//Delete temp.next=tail.next; tail.next=temp;//Insert &#125; tail=head; prev=head; &#125; return dummy.next; &#125;&#125; https://discuss.leetcode.com/topic/12364/non-recursive-java-solution-and-idea Non-recursive Java solution and idea Reference: http://www.cnblogs.com/lichen782/p/leetcode_Reverse_Nodes_in_kGroup.html First, build a function reverse() to reverse the ListNode between begin and end. See the explanation below: 123456789101112131415test /** * Reverse a link list between begin and end exclusively * an example: * a linked list: * 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 * | | * begin end * after call begin = reverse(begin, end) * * 0-&gt;3-&gt;2-&gt;1-&gt;4-&gt;5-&gt;6 * | | * begin end * @return the reversed list&apos;s &apos;begin&apos; node, which is the precedence of node end */ Then walk thru the linked list and apply reverse() iteratively. See the code below. 123456789101112131415161718192021222324252627282930313233343536public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode begin; if (head==null || head.next ==null || k==1) return head; ListNode dummyhead = new ListNode(-1); dummyhead.next = head; begin = dummyhead; int i=0; while (head != null)&#123; i++; if (i%k == 0)&#123; begin = reverse(begin, head.next); head = begin.next; &#125; else &#123; head = head.next; &#125; &#125; return dummyhead.next; &#125;public ListNode reverse(ListNode begin, ListNode end)&#123; ListNode curr = begin.next; ListNode next, first; ListNode prev = begin; first = curr; while (curr!=end)&#123; next = curr.next; curr.next = prev; prev = curr; curr = next; &#125; begin.next = prev; first.next = curr; return first;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[024. Swap Nodes in Pairs]]></title>
    <url>%2Fp%2F94079f17%2F</url>
    <content type="text"><![CDATA[38.3% https://leetcode.com/problems/swap-nodes-in-pairs/ Given a linked list, swap every two adjacent nodes and return its head. 12For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 方法一： 递归调用 Simple implementation with C++ 123456789101112131415class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(head == NULL) return NULL; if(head-&gt;next == NULL) return head; ListNode* next = head-&gt;next; head-&gt;next = swapPairs(next-&gt;next); next-&gt;next = head; return next; &#125;&#125;; 我的代码实现： 递归方法，实现起来最简单 123456789101112131415161718/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* nex = head-&gt;next; head-&gt;next = swapPairs(nex-&gt;next); nex-&gt;next = head; return nex; &#125;&#125;; 另一种实现 Very easy solution 123456789101112class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode *l=head; if(head&amp;&amp;head-&gt;next)&#123; l=head-&gt;next; head-&gt;next=swapPairs(l-&gt;next); l-&gt;next=head; &#125; return l; &#125;&#125;; 方法二： 我自己的方法，多定义几个变量，依次迭代。 12345678910111213141516class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode* dummy = new ListNode(0); dummy-&gt;next = head; ListNode* cur = dummy; while(cur-&gt;next!=NULL &amp;&amp; cur-&gt;next-&gt;next!=NULL)&#123; ListNode* n1=cur-&gt;next, *n2 = cur-&gt;next-&gt;next, *n3=cur-&gt;next-&gt;next-&gt;next; cur-&gt;next = n2; n2-&gt;next = n1; n1-&gt;next = n3; cur = n1; &#125; return dummy-&gt;next; &#125;&#125;; 我的代码实现： 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* cur = dummy, *first, *second; while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123; first = cur-&gt;next; second = cur-&gt;next-&gt;next; first-&gt;next = second-&gt;next; second-&gt;next = first; cur-&gt;next = second; cur = first; &#125; return dummy-&gt;next; &#125;&#125;; cpp 4ms, 3.56%, July 14th, 2016 https://discuss.leetcode.com/topic/18860/7-8-lines-c-python-ruby 7-8 lines C++ / Python / Ruby Three different implementations of the same algorithm, taking advantage of different strengths of the three languages. I suggest reading all three, even if you don’t know all three languages. All three of course work swap the current node with the next node by rearranging pointers, then move on to the next pair, and repeat until the end of the list. C++ Pointer-pointer pp points to the pointer to the current node. So at first, pp points to head, and later it points to the next field of ListNodes. Additionally, for convenience and clarity, pointers a and b point to the current node and the next node. We need to go from pp == a -&gt; b -&gt; (b-&gt;next) to pp == b -&gt; a -&gt; (b-&gt;next). The first three lines inside the loop do that, setting those three pointers (from right to left). The fourth line moves pp to the next pair. 12345678910ListNode* swapPairs(ListNode* head) &#123; ListNode **pp = &amp;head, *a, *b; while ((a = *pp) &amp;&amp; (b = a-&gt;next)) &#123; a-&gt;next = b-&gt;next; b-&gt;next = a; *pp = b; pp = &amp;(a-&gt;next); &#125; return head;&#125; Python Here, pre is the previous node. Since the head doesn’t have a previous node, I just use self instead. Again, a is the current node and b is the next node. To go from pre -&gt; a -&gt; b -&gt; b.next to pre -&gt; b -&gt; a -&gt; b.next, we need to change those three references. Instead of thinking about in what order I change them, I just change all three at once. 12345678def swapPairs(self, head): pre, pre.next = self, head while pre.next and pre.next.next: a = pre.next b = a.next pre.next, b.next, a.next = b, a, b.next pre = a return self.next https://discuss.leetcode.com/topic/29060/simple-implementation-with-c Simple implementation with C++ 123456789101112131415class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(head == NULL) return NULL; if(head-&gt;next == NULL) return head; ListNode* next = head-&gt;next; head-&gt;next = swapPairs(next-&gt;next); next-&gt;next = head; return next; &#125;&#125;; https://discuss.leetcode.com/topic/31626/very-easy-solution Very easy solution 123456789101112class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode *l=head; if(head&amp;&amp;head-&gt;next)&#123; l=head-&gt;next; head-&gt;next=swapPairs(l-&gt;next); l-&gt;next=head; &#125; return l; &#125;&#125;; python 4ms, 3.56%, July 14th, 2016 https://discuss.leetcode.com/topic/18860/7-8-lines-c-python-ruby 12345678910111213141516171819# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def swapPairs(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; pre, pre.next = self, head while pre.next and pre.next.next: a = pre.next b = a.next pre.next, b.next, a.next = b, a, b.next pre = a return self.next java 0ms, 6.43%, July 14th, 2016 https://discuss.leetcode.com/topic/4351/my-accepted-java-code-used-recursion My accepted java code. used recursion. 123456789101112131415161718/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if((head == null) || (head.next == null)) return head; ListNode n = head.next; head.next = swapPairs(head.next.next); n.next = head; return n; &#125;&#125; 0ms, 6.43%, July 14th, 2016 https://discuss.leetcode.com/topic/10649/my-simple-java-solution-for-share My accepted java code. used recursion. 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode current = dummy; while(current.next != null &amp;&amp; current.next.next != null)&#123; ListNode first = current.next; ListNode second = current.next.next; first.next = second.next; current.next = second; current.next.next = first; current = current.next.next; &#125; return dummy.next; &#125;&#125; https://discuss.leetcode.com/topic/41459/java-simple-recursive-solution Java simple recursive solution Starting to see that recursion is the perfect tool for (many) linked list problems (this one + merging list problem). 1234567891011121314151617181920/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode second = head.next; ListNode third = second.next; second.next = head; head.next = swapPairs(third); return second; &#125;&#125; https://discuss.leetcode.com/topic/5163/my-simple-recursive-solution My simple recursive solution My solution is quite simple. Just find the reverse job is the same for every 2 nodes. 12345678910public ListNode swapPairs(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode newhd = head.next; head.next = swapPairs(newhd.next); newhd.next = head; return newhd;&#125; https://discuss.leetcode.com/topic/39095/my-straight-forward-java-solution-without-recursion-or-dummy-nodes-0ms My straight-forward Java solution without recursion or dummy nodes (0ms) The idea is straightforward: use two pointers and swap a.next = b.next, b.next = a. Then continue the next pair, b = a.next.next, a=a.next Remember to check null Remember to track new head Remember to link the new pair after the prior nodes.Attached is the accepted code. 12345678910111213141516public class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head==null || head.next==null) return head; ListNode newHead = head.next, a=head,b=a.next,pre = null; while(a!=null &amp;&amp; b!=null)&#123; a.next = b.next; b.next = a; if(pre!=null) pre.next = b; if(a.next==null) break; b = a.next.next; pre = a; a = a.next; &#125; return newHead; &#125;&#125; AC, 0ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[023. Merge k Sorted Lists]]></title>
    <url>%2Fp%2F32640f57%2F</url>
    <content type="text"><![CDATA[26.4% https://leetcode.com/problems/merge-k-sorted-lists/ Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 方法一： 对这个vector&lt;ListNode*&gt; 的前两个，进行合并，然后合并结果， 放入vector中，再把vector的前两个删除。只要vector的size不为1， 一直循环。 注意，vector有erase的函数，示例如下：lists.erase(lists.begin()); 123456789101112131415161718192021222324252627ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; if(lists.empty())&#123; return nullptr; &#125; while(lists.size() &gt; 1)&#123; lists.push_back(mergeTwoLists(lists[0], lists[1])); lists.erase(lists.begin()); lists.erase(lists.begin()); &#125; return lists.front();&#125;ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(l1 == nullptr)&#123; return l2; &#125; if(l2 == nullptr)&#123; return l1; &#125; if(l1-&gt;val &lt;= l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125;&#125; 我的代码实现: 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; // 考虑异常，为空时 if(lists.empty()) return NULL; while(lists.size()&gt;1)&#123; ListNode* node = helper(lists[0], lists[1]); // 学习erase的用法，里面使用的是迭代器 lists.erase(lists.begin()); lists.erase(lists.begin()); lists.push_back(node); &#125; return lists[0]; &#125; ListNode* helper(ListNode* l1, ListNode* l2)&#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = helper(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = helper(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 方法二: vector erase效率堪忧，使用deque来解决 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; int n = lists.size(); if(n==0) return NULL; if(n==1) return lists[0]; deque&lt;ListNode*&gt; dq; for(auto node:lists) dq.push_back(node); while(dq.size()&gt;1)&#123; ListNode* l1 = dq.front(); dq.pop_front(); ListNode* l2 = dq.front(); dq.pop_front(); ListNode* l3 = merge(l1, l2); dq.push_back(l3); &#125; return dq.front(); &#125; ListNode* merge(ListNode* l1, ListNode* l2)&#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = merge(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = merge(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; cpp https://discuss.leetcode.com/topic/6882/sharing-my-straightforward-c-solution-without-data-structure-other-than-vector Sharing my straightforward C++ solution without data structure other than vector 123456789101112131415161718192021222324252627ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; if(lists.empty())&#123; return nullptr; &#125; while(lists.size() &gt; 1)&#123; lists.push_back(mergeTwoLists(lists[0], lists[1])); lists.erase(lists.begin()); lists.erase(lists.begin()); &#125; return lists.front();&#125;ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(l1 == nullptr)&#123; return l2; &#125; if(l2 == nullptr)&#123; return l1; &#125; if(l1-&gt;val &lt;= l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125;&#125; The second function is from Merge Two Sorted Lists. The basic idea is really simple. We can merge first two lists and then push it back. Keep doing this until there is only one list left in vector. Actually, we can regard this as an iterative divide-and-conquer solution. https://discuss.leetcode.com/topic/7160/brief-c-solution-with-priority_queue Brief C++ solution with priority_queue We just need to define a comparison struct for ListNodes, then managing the priority_queue is quite straightforward. After filling the priority_queue, if it is non-empty, we set the head and tail. Then we repeatedly pop the top off the queue and append that to the tail. If the next node is not null, we push it onto the queue. 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; struct compare &#123; bool operator()(const ListNode* l, const ListNode* r) &#123; return l-&gt;val &gt; r-&gt;val; &#125; &#125;; public: ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) &#123; priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, compare&gt; q; for (auto l : lists) &#123; if (l) &#123; q.push(l); &#125; &#125; if (q.empty()) &#123; return NULL; &#125; ListNode* result = q.top(); q.pop(); if (result-&gt;next) &#123; q.push(result-&gt;next); &#125; ListNode* tail = result; while (!q.empty()) &#123; tail-&gt;next = q.top(); q.pop(); tail = tail-&gt;next; if (tail-&gt;next) &#123; q.push(tail-&gt;next); &#125; &#125; return result; &#125;&#125;; python 128ms, 79.54%, September 4, 2016 https://discuss.leetcode.com/topic/23140/108ms-python-solution-with-heapq-and-avoid-changing-heap-size 108ms python solution with heapq and avoid changing heap size 123456789101112131415def mergeKLists(self, lists): from heapq import heappush, heappop, heapreplace, heapify dummy = node = ListNode(0) h = [(n.val, n) for n in lists if n] heapify(h) while h: v, n = h[0] if n.next is None: heappop(h) #only change heap size when necessary else: heapreplace(h, (n.next.val, n.next)) node.next = n node = node.next return dummy.next https://discuss.leetcode.com/topic/33609/10-line-python-solution-with-priority-queue 10-line python solution with priority queue 12345678910111213from Queue import PriorityQueueclass Solution(object): def mergeKLists(self, lists): dummy = ListNode(None) curr = dummy q = PriorityQueue() for node in lists: if node: q.put((node.val,node)) while q.qsize()&gt;0: curr.next = q.get()[1] curr=curr.next if curr.next: q.put((curr.next.val, curr.next)) return dummy.next java https://discuss.leetcode.com/topic/2780/a-java-solution-based-on-priority-queue A java solution based on Priority Queue If someone understand how priority queue works, then it would be trivial to walk through the codes. My question: is that possible to solve this question under the same time complexity without implementing the priority queue? 123456789101112131415161718192021222324252627282930313233public class Solution &#123; public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; if (lists==null||lists.size()==0) return null; PriorityQueue&lt;ListNode&gt; queue= new PriorityQueue&lt;ListNode&gt;(lists.size(),new Comparator&lt;ListNode&gt;()&#123; @Override public int compare(ListNode o1,ListNode o2)&#123; if (o1.val&lt;o2.val) return -1; else if (o1.val==o2.val) return 0; else return 1; &#125; &#125;); ListNode dummy = new ListNode(0); ListNode tail=dummy; for (ListNode node:lists) if (node!=null) queue.add(node); while (!queue.isEmpty())&#123; tail.next=queue.poll(); tail=tail.next; if (tail.next!=null) queue.add(tail.next); &#125; return dummy.next; &#125;&#125; https://discuss.leetcode.com/topic/2780/a-java-solution-based-on-priority-queue/4 I think my code’s complexity is also O(nlogk) and not using heap or priority queue, n means the total elements and k means the size of list. The mergeTwoLists functiony in my code comes from the problem Merge Two Sorted Lists whose complexity obviously is O(n), n is the sum of length of l1 and l2. To put it simpler, assume the k is 2^x, So the progress of combination is like a full binary tree, from bottom to top. So on every level of tree, the combination complexity is n, beacause every level have all n numbers without repetition. The level of tree is x, ie logk. So the complexity is O(nlogk). 12345678910for example, 8 ListNode, and the length of every ListNode is x1, x2,x3, x4, x5, x6, x7, x8, total is n.on level 3: x1+x2, x3+x4, x5+x6, x7+x8 sum: non level 2: x1+x2+x3+x4, x5+x6+x7+x8 sum: non level 1: x1+x2+x3+x4+x5+x6+x7+x8 sum: ntotal 3n, nlog8 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; ListNode head=null; ListNode former=null; while (l1!=null&amp;&amp;l2!=null) &#123; if (l1.val&gt;l2.val) &#123; if (former==null) former=l2; else former.next=l2; if (head==null) head=former; else former=former.next; l2=l2.next; &#125; else &#123; if (former==null) former=l1; else former.next=l1; if (head==null) head=former; else former=former.next; l1=l1.next; &#125; &#125; if (l2!=null) l1=l2; former.next=l1; return head; &#125; public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; if (lists.size()==0) return null; if (lists.size()==1) return lists.get(0); if (lists.size()==2) return mergeTwoLists(lists.get(0), lists.get(1)); return mergeTwoLists(mergeKLists(lists.subList(0, lists.size()/2)), mergeKLists(lists.subList(lists.size()/2, lists.size()))); &#125;&#125; 3ms, 91.70%, September 5, 2016 https://discuss.leetcode.com/topic/26095/my-simple-java-solution-use-recursion My simple java Solution use recursion 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; return partion(lists, 0, lists.length-1); &#125; public static ListNode partion(ListNode[] lists, int s, int e)&#123; if(s==e) return lists[s]; if(s&lt;e)&#123; int q = (s+e) / 2; ListNode l1 = partion(lists, s, q); ListNode l2 = partion(lists, q+1, e); return merge(l1, l2); &#125;else return null; &#125; public static ListNode merge(ListNode l1, ListNode l2)&#123; if(l1==null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val)&#123; l1.next = merge(l1.next, l2); return l1; &#125;else&#123; l2.next = merge(l1, l2.next); return l2; &#125; &#125;&#125; https://discuss.leetcode.com/topic/31276/simple-java-merge-sort Simple Java Merge Sort For this problem, use merge sort is simple and fast, I wonder why some guys solve it use PriorityQueue. I think the complexity is k n logk. Because the recursion depth is logK, and in each level, every element will be compared. 1234567891011121314151617public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) return null; return mergeKLists(lists, 0, lists.length - 1);&#125;private ListNode mergeKLists(ListNode[] lists, int start, int end) &#123; if (start == end) &#123; return lists[start]; &#125; else if (start &lt; end)&#123; int mid = (end - start) / 2 + start; ListNode left = mergeKLists(lists, start, mid); ListNode right = mergeKLists(lists, mid + 1, end); return mergeTwoLists(left, right); &#125; else &#123; return null; &#125;&#125; mergeTwoLists is base on the Merge Two Sorted Lists problem. https://discuss.leetcode.com/topic/8949/13-lines-in-java 13-lines in Java Hi guys! The approach is standard - PriorityQueue, but I noticed that solutions presented before are kind of a bit long. So that’s the concise version. :) Hope it helps! 1234567891011121314151617public class Solution &#123; public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; Queue&lt;ListNode&gt; heap = new PriorityQueue(new Comparator&lt;ListNode&gt;()&#123; @Override public int compare(ListNode l1, ListNode l2) &#123; return l1.val - l2.val; &#125; &#125;); ListNode head = new ListNode(0), tail = head; for (ListNode node : lists) if (node != null) heap.offer(node); while (!heap.isEmpty()) &#123; tail.next = heap.poll(); tail = tail.next; if (tail.next != null) heap.offer(tail.next); &#125; return head.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>divide and conquer</tag>
        <tag>hard</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[022. Generate Parentheses]]></title>
    <url>%2Fp%2Fa9da9348%2F</url>
    <content type="text"><![CDATA[33.4% https://leetcode.com/problems/generate-parentheses/ Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 方法一： The idea is intuitive. Use two integers to count the remaining left parenthesis (n) and the right parenthesis (m) to be added. At each function call add a left parenthesis if n &gt;0 and add a right parenthesis if m&gt;0. Append the result and terminate recursive calls when both m and n are zero. https://leetcode.com/discuss/14436/concise-recursive-c-solution 123456789101112131415161718class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; addingpar(res, &quot;&quot;, n, 0); return res; &#125; void addingpar(vector&lt;string&gt; &amp;v,string str, int n, int m)&#123; if(m==0 &amp;&amp; n==0)&#123; v.push_back(str); return; &#125; if(m&gt;0) addingpar(v, str+&quot;)&quot;, n, m-1); if(n&gt;0) addingpar(v, str+&quot;(&quot;, n-1, m+1); &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/15294/6-lines-c-3-4-ms-super-easy-to-understand 6 lines c++ 3~4 ms, super easy to understand 123456789101112vector&lt;string&gt; result;void helper(string str, int left, int right)&#123; if(left == 0 &amp;&amp; right == 0) result.push_back(str); if(left!=0) helper(str+&apos;(&apos;, left-1, right); if(right!=0 &amp;&amp; right &gt; left) helper(str+&apos;)&apos;, left, right-1);&#125; vector&lt;string&gt; generateParenthesis(int n) &#123; helper(&quot;&quot;,n,n); return result;&#125; 我的代码实现： 递归， 循环调用栈,消耗内存 1234567891011121314151617class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; helper(res, n, n, ""); return res; &#125; void helper(vector&lt;string&gt;&amp; res, int left, int right, string s)&#123; if(left==0 &amp;&amp; right==0) res.push_back(s); if(left!=0) helper(res, left-1, right, s+'('); if(right!=0 &amp;&amp; right&gt;left) helper(res, left, right-1, s+')'); &#125;&#125;; 方法三； dp解法 https://discuss.leetcode.com/topic/3474/an-iterative-method My method is DP. First consider how to get the result f(n) from previous result f(0)…f(n-1).Actually, the result f(n) will be put an extra () pair to f(n-1). Let the “(“ always at the first position, to produce a valid result, we can only put “)” in a way that there will be i pairs () inside the extra () and n - 1 - i pairs () outside the extra pair. Let us consider an example to get clear view: f(0): “” f(1): “(“f(0)”)” f(2): “(“f(0)”)”f(1), “(“f(1)”)” f(3): “(“f(0)”)”f(2), “(“f(1)”)”f(1), “(“f(2)”)” So f(n) = “(“f(0)”)”f(n-1) , “(“f(1)”)”f(n-2) “(“f(2)”)”f(n-3) … “(“f(i)”)”f(n-1-i) … “(f(n-1)”)” Below is my code: 我的代码实现： 123456789101112131415161718class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; // 注意定义及初始化的问题，vector&lt;string&gt;()，而不是vector&lt;string&gt; vector&lt;vector&lt;string&gt;&gt; dp(n+1, vector&lt;string&gt;()); // 学习此处的初始化 dp[0] = vector&lt;string&gt;&#123;""&#125;; for(int i=1; i&lt;=n; i++)&#123; for(int j=0; j&lt;i; j++) for(string first:dp[j]) for(string second:dp[i-j-1])&#123; string t = '(' + first + ')' + second; dp[i].push_back(t); &#125; &#125; return dp[n]; &#125;&#125;; cpp The idea is intuitive. Use two integers to count the remaining left parenthesis (n) and the right parenthesis (m) to be added. At each function call add a left parenthesis if n &gt;0 and add a right parenthesis if m&gt;0. Append the result and terminate recursive calls when both m and n are zero. https://leetcode.com/discuss/14436/concise-recursive-c-solution123456789101112131415161718class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; addingpar(res, &quot;&quot;, n, 0); return res; &#125; void addingpar(vector&lt;string&gt; &amp;v,string str, int n, int m)&#123; if(m==0 &amp;&amp; n==0)&#123; v.push_back(str); return; &#125; if(m&gt;0) addingpar(v, str+&quot;)&quot;, n, m-1); if(n&gt;0) addingpar(v, str+&quot;(&quot;, n-1, m+1); &#125;&#125;; python https://leetcode.com/discuss/43122/4-7-lines-python 4-7 lines Python p is the parenthesis-string built so far, left and right tell the number of left and right parentheses still to add, and parens collects the parentheses. Solution 1 I used a few “tricks”… how many can you find? :-) 1234567def generateParenthesis(self, n): def generate(p, left, right, parens=[]): if left: generate(p + &apos;(&apos;, left-1, right) if right &gt; left: generate(p + &apos;)&apos;, left, right-1) if not right: parens += p, return parens return generate(&apos;&apos;, n, n) Solution 2 Here I wrote an actual Python generator. I allow myself to put the yield q at the end of the line because it’s not that bad and because in “real life” I use Python 3 where I just say yield from generate(…). 12345678def generateParenthesis(self, n): def generate(p, left, right): if right &gt;= left &gt;= 0: if not right: yield p for q in generate(p + &apos;(&apos;, left-1, right): yield q for q in generate(p + &apos;)&apos;, left, right-1): yield q return list(generate(&apos;&apos;, n, n)) Solution 3 Improved version of this. Parameter open tells the number of “already opened” parentheses, and I continue the recursion as long as I still have to open parentheses (n &gt; 0) and I haven’t made a mistake yet (open &gt;= 0). 12345def generateParenthesis(self, n, open=0): if n &gt; 0 &lt;= open: return [&apos;(&apos; + p for p in self.generateParenthesis(n-1, open+1)] + \ [&apos;)&apos; + p for p in self.generateParenthesis(n, open-1)] return [&apos;)&apos; * open] * (not n) java The idea here is to only add ‘(‘ and ‘)’ that we know will guarantee us a solution (instead of adding 1 too many close). Once we add a ‘(‘ we will then discard it and try a ‘)’ which can only close a valid ‘(‘. Each of these steps are recursively called. https://leetcode.com/discuss/25063/easy-to-understand-java-backtracking-solution 1234567891011121314151617181920public class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); backtrack(list, &quot;&quot;, 0, 0, n); return list; &#125; public void backtrack(List&lt;String&gt; list, String str, int open, int close, int max)&#123; if(str.length() == max*2)&#123; list.add(str); return; &#125; if(open&lt;max) backtrack(list, str+&quot;(&quot;, open+1, close, max); if(close&lt;open) backtrack(list, str+&quot;)&quot;, open, close+1, max); &#125; &#125; https://discuss.leetcode.com/topic/3474/an-iterative-method An iterative method. My method is DP. First consider how to get the result f(n) from previous result f(0)…f(n-1).Actually, the result f(n) will be put an extra () pair to f(n-1). Let the “(“ always at the first position, to produce a valid result, we can only put “)” in a way that there will be i pairs () inside the extra () and n - 1 - i pairs () outside the extra pair. 1234567891011Let us consider an example to get clear view:f(0): &quot;&quot;f(1): &quot;(&quot;f(0)&quot;)&quot;f(2): &quot;(&quot;f(0)&quot;)&quot;f(1), &quot;(&quot;f(1)&quot;)&quot;f(3): &quot;(&quot;f(0)&quot;)&quot;f(2), &quot;(&quot;f(1)&quot;)&quot;f(1), &quot;(&quot;f(2)&quot;)&quot;So f(n) = &quot;(&quot;f(0)&quot;)&quot;f(n-1) , &quot;(&quot;f(1)&quot;)&quot;f(n-2) &quot;(&quot;f(2)&quot;)&quot;f(n-3) ... &quot;(&quot;f(i)&quot;)&quot;f(n-1-i) ... &quot;(f(n-1)&quot;)&quot; Below is my code: 12345678910111213141516171819202122232425262728public class Solution&#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;&gt;(); lists.add(Collections.singletonList(&quot;&quot;)); for (int i = 1; i &lt;= n; ++i) &#123; final List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; i; ++j) &#123; for (final String first : lists.get(j)) &#123; for (final String second : lists.get(i - 1 - j)) &#123; list.add(&quot;(&quot; + first + &quot;)&quot; + second); &#125; &#125; &#125; lists.add(list); &#125; return lists.get(lists.size() - 1); &#125;&#125; https://discuss.leetcode.com/topic/23229/java-dfs-way-solution Java DFS way solution 1234567891011121314151617181920public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); generateOneByOne(&quot;&quot;, list, n, n); return list;&#125;public void generateOneByOne(String sublist, List&lt;String&gt; list, int left, int right)&#123; if(left &gt; right)&#123; return; &#125; if(left &gt; 0)&#123; generateOneByOne( sublist + &quot;(&quot; , list, left-1, right); &#125; if(right &gt; 0)&#123; generateOneByOne( sublist + &quot;)&quot; , list, left, right-1); &#125; if(left == 0 &amp;&amp; right == 0)&#123; list.add(sublist); return; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[021. Merge Two Sorted Lists]]></title>
    <url>%2Fp%2F149a587d%2F</url>
    <content type="text"><![CDATA[39.2% https://leetcode.com/problems/merge-two-sorted-lists/ Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 剑指offer 17题 方法一： 简单的递归就行了 我的代码实现： Oct 11， 2017 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val &lt; l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 1234567891011121314class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(l1==NULL) return l2; if(l2==NULL) return l1; if(l1-&gt;val &lt;= l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125;else&#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; 方法二： 我的代码实现： 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125; cur = cur-&gt;next; &#125; if(l1) cur-&gt;next = l1; if(l2) cur-&gt;next = l2; return dummy-&gt;next; &#125;&#125;; 迭代形式的写法 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; ListNode dummy(INT_MIN); ListNode *tail = &amp;dummy; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; tail-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; tail-&gt;next = l2; l2 = l2-&gt;next; &#125; tail = tail-&gt;next; &#125; tail-&gt;next = l1 ? l1 : l2; return dummy.next; &#125;&#125;; 我的代码实现： 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125; // cur不要忘记前向走 cur = cur-&gt;next; &#125; // 对于链表，剩下的一部分特别好处理 cur-&gt;next = l1 ? l1 : l2; return dummy-&gt;next; &#125;&#125;; cpp https://discuss.leetcode.com/topic/2513/a-recursive-solution A recursive solution 123456789101112131415class Solution &#123;public: ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(l1 == NULL) return l2; if(l2 == NULL) return l1; if(l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l2-&gt;next, l1); return l2; &#125; &#125;&#125;; This solution is not a tail-recursive, the stack will overflow while the list is too long :) http://en.wikipedia.org/wiki/Tail_call 12ms, 7.11%, June.18th, 2016 https://leetcode.com/discuss/18986/14-line-clean-c-solution 14 line clean C++ Solution 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; ListNode dummy(INT_MIN); ListNode *tail = &amp;dummy; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; tail-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; tail-&gt;next = l2; l2 = l2-&gt;next; &#125; tail = tail-&gt;next; &#125; tail-&gt;next = l1 ? l1 : l2; return dummy.next; &#125;&#125;; https://discuss.leetcode.com/topic/4480/clean-simple-o-n-m-c-solution-without-dummy-head-and-recurtion Clean, simple O(n+m) C++ Solution, without dummy head and recurtion Please refer to the comments inline. 1234567891011121314151617181920212223242526ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) &#123; if(NULL == l1) return l2; if(NULL == l2) return l1; ListNode* head=NULL; // head of the list to return // find first element (can use dummy node to put this part inside of the loop) if(l1-&gt;val &lt; l2-&gt;val) &#123; head = l1; l1 = l1-&gt;next; &#125; else &#123; head = l2; l2 = l2-&gt;next; &#125; ListNode* p = head; // pointer to form new list // I use &amp;&amp; to remove extra IF from the loop while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val) &#123; p-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; p-&gt;next = l2; l2 = l2-&gt;next; &#125; p=p-&gt;next; &#125; // add the rest of the tail, done! if(l1) p-&gt;next=l1; else p-&gt;next=l2; return head;&#125; python https://leetcode.com/discuss/51679/python-solutions-iteratively-recursively-iteratively-place Python solutions (iteratively, recursively, iteratively in-place). 12345678910111213# iterativelydef mergeTwoLists1(self, l1, l2): dummy = cur = ListNode(0) while l1 and l2: if l1.val &lt; l2.val: cur.next = l1 l1 = l1.next else: cur.next = l2 l2 = l2.next cur = cur.next cur.next = l1 or l2 return dummy.next 12345678910# recursively def mergeTwoLists2(self, l1, l2): if not l1 or not l2: return l1 or l2 if l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2 123456789101112131415161718# in-place, iteratively def mergeTwoLists(self, l1, l2): if None in (l1, l2): return l1 or l2 dummy = cur = ListNode(0) dummy.next = l1 while l1 and l2: if l1.val &lt; l2.val: l1 = l1.next else: nxt = cur.next cur.next = l2 tmp = l2.next l2.next = nxt l2 = tmp cur = cur.next cur.next = l1 or l2 return dummy.next java https://discuss.leetcode.com/topic/5513/my-recursive-way-to-solve-this-problem-java-easy-understanding My recursive way to solve this problem(JAVA, easy understanding) Hello every one, here is my code, simple but works well: 123456789101112131415161718192021public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null)&#123; return l2; &#125; if(l2 == null)&#123; return l1; &#125; ListNode mergeHead; if(l1.val &lt; l2.val)&#123; mergeHead = l1; mergeHead.next = mergeTwoLists(l1.next, l2); &#125; else&#123; mergeHead = l2; mergeHead.next = mergeTwoLists(l1, l2.next); &#125; return mergeHead; &#125;&#125; https://discuss.leetcode.com/topic/45002/java-1-ms-4-lines-codes-using-recursion Java, 1 ms, 4 lines codes, using recursion 1234567891011public ListNode mergeTwoLists(ListNode l1, ListNode l2)&#123; if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val &lt; l2.val)&#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else&#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; https://discuss.leetcode.com/topic/5199/java-solution-for-reference Java solution for reference Similar to array, the difference is if any of two listnode is not null after first loop, we only need to add it as previous node’s next and no need to add them one by one. 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null &amp;&amp; l2 == null) &#123; return null; &#125; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; ListNode result = new ListNode(0); ListNode prev = result; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; prev.next = l1; l1 = l1.next; &#125; else &#123; prev.next = l2; l2 = l2.next; &#125; prev = prev.next; &#125; if (l1 != null) &#123; prev.next = l1; &#125; if (l2 != null) &#123; prev.next = l2; &#125; return result.next; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[020. Valid Parentheses]]></title>
    <url>%2Fp%2F44690127%2F</url>
    <content type="text"><![CDATA[32.5% https://leetcode.com/problems/valid-parentheses/ Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. 方法一： 使用栈，依次进行考虑。 My 0ms c++ solution using stack code 1： 1234567891011121314bool isValid(string s) &#123; stack&lt;char&gt; st; for(char c : s)&#123; if(c == &apos;(&apos;|| c == &apos;&#123;&apos; || c == &apos;[&apos;)&#123; st.push(c); &#125;else&#123; if(st.empty()) return false; if(c == &apos;)&apos; &amp;&amp; st.top() != &apos;(&apos;) return false; if(c == &apos;&#125;&apos; &amp;&amp; st.top() != &apos;&#123;&apos;) return false; if(c == &apos;]&apos; &amp;&amp; st.top() != &apos;[&apos;) return false; st.pop(); &#125; &#125; return st.empty(); 方法二: 我的代码实现: 12345678910111213141516171819class Solution &#123;public: bool isValid(string s) &#123; if(s.empty()) return true; stack&lt;char&gt; stack; unordered_map&lt;char, char&gt; map = &#123;&#123;'(', ')'&#125;, &#123;'[', ']'&#125;, &#123;'&#123;', '&#125;'&#125;&#125;; for(auto c:s)&#123; if(map.find(c)!=map.end()) stack.push(map[c]); else&#123; if(!stack.empty() &amp;&amp; stack.top()==c) stack.pop(); else return false; &#125; &#125; return stack.empty(); &#125;&#125;; 重点学一下，进一个map，及map的赋值操作。 1234567891011121314151617181920212223class Solution &#123; public: bool isValid(string s) &#123; map&lt;char, char&gt; parenth_dict; parenth_dict[&apos;(&apos;] = &apos;)&apos;; parenth_dict[&apos;&#123;&apos;] = &apos;&#125;&apos;; parenth_dict[&apos;[&apos;] = &apos;]&apos;; stack&lt;char&gt; aux; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos;(&apos; || s[i] == &apos;&#123;&apos; || s[i] == &apos;[&apos;) aux.push(s[i]); else if (aux.empty() || parenth_dict[aux.top()] != s[i]) return false; else aux.pop(); &#125; return aux.empty(); &#125;&#125;; java https://discuss.leetcode.com/topic/7813/my-easy-to-understand-java-solution-with-one-stack My easy to understand Java Solution with one stack 12345678910111213141516171819202122public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); // Iterate through string until empty for(int i = 0; i&lt;s.length(); i++) &#123; // Push any open parentheses onto stack if(s.charAt(i) == &apos;(&apos; || s.charAt(i) == &apos;[&apos; || s.charAt(i) == &apos;&#123;&apos;) stack.push(s.charAt(i)); // Check stack for corresponding closing parentheses, false if not valid else if(s.charAt(i) == &apos;)&apos; &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == &apos;(&apos;) stack.pop(); else if(s.charAt(i) == &apos;]&apos; &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == &apos;[&apos;) stack.pop(); else if(s.charAt(i) == &apos;&#125;&apos; &amp;&amp; !stack.empty() &amp;&amp; stack.peek() == &apos;&#123;&apos;) stack.pop(); else return false; &#125; // return true if no open parentheses left in stack return stack.empty(); &#125;&#125; https://discuss.leetcode.com/topic/27572/short-java-solution Short java solution1234567891011121314public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c : s.toCharArray()) &#123; if (c == &apos;(&apos;) stack.push(&apos;)&apos;); else if (c == &apos;&#123;&apos;) stack.push(&apos;&#125;&apos;); else if (c == &apos;[&apos;) stack.push(&apos;]&apos;); else if (stack.isEmpty() || stack.pop() != c) return false; &#125; return stack.isEmpty();&#125; https://discuss.leetcode.com/topic/9372/12-lines-of-java 12 lines of Java 123456789101112public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Integer&gt; p = new Stack&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++) &#123; int q = &quot;()&#123;&#125;[]&quot;.indexOf(s.substring(i, i + 1)); if(q % 2 == 1) &#123; if(p.isEmpty() || p.pop() != q - 1) return false; &#125; else p.push(q); &#125; return p.isEmpty(); &#125;&#125; https://discuss.leetcode.com/topic/27768/short-easy-to-follow-8ms-java-solution Short, Easy to Follow 8ms Java Solution 123456789101112public class Solution &#123; public boolean isValid(String s) &#123; int length; do &#123; length = s.length(); s = s.replace(&quot;()&quot;, &quot;&quot;).replace(&quot;&#123;&#125;&quot;, &quot;&quot;).replace(&quot;[]&quot;, &quot;&quot;); &#125; while(length != s.length()); return s.length() == 0; &#125;&#125; In this solution you essentially can remove parentheses that you know are valid until the string is empty. If the string is not empty, that means that the parentheses were malformed. https://discuss.leetcode.com/topic/47067/java-iterative-solution-beating-97 Java iterative solution beating 97% Just implement a simple stack using a char array and check that, for each closing bracket, there is its counterpart in the top of the stack. 1234567891011121314151617181920212223242526public class Solution &#123; public boolean isValid(String s) &#123; char[] stack = new char[s.length()]; int head = 0; for(char c : s.toCharArray()) &#123; switch(c) &#123; case &apos;&#123;&apos;: case &apos;[&apos;: case &apos;(&apos;: stack[head++] = c; break; case &apos;&#125;&apos;: if(head == 0 || stack[--head] != &apos;&#123;&apos;) return false; break; case &apos;)&apos;: if(head == 0 || stack[--head] != &apos;(&apos;) return false; break; case &apos;]&apos;: if(head == 0 || stack[--head] != &apos;[&apos;) return false; break; &#125; &#125; return head == 0; &#125;&#125; my code: 1234567891011121314151617181920212223public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); if(s==null || s.length()==0) return true; for(int i=0; i&lt;s.length(); i++)&#123; char tmp = s.charAt(i); if(!stack.empty() &amp;&amp; tmp==&apos;)&apos; &amp;&amp; stack.peek()==&apos;(&apos;) stack.pop(); else if(!stack.empty() &amp;&amp; tmp==&apos;]&apos; &amp;&amp; stack.peek()==&apos;[&apos;) stack.pop(); else if(!stack.empty() &amp;&amp; tmp==&apos;&#125;&apos; &amp;&amp; stack.peek()==&apos;&#123;&apos;) stack.pop(); else if(tmp==&apos;(&apos; || tmp==&apos;[&apos; || tmp==&apos;&#123;&apos;) stack.push(tmp); else return false; &#125; if(stack.empty()) return true; else return false; &#125;&#125; cpp https://discuss.leetcode.com/topic/13231/2ms-c-sloution 2ms C++ sloution Repetitive code but I guess this is clean, and easy to understand. This solution also accepts (and ignores) any characters other than parenthesis in the string. Hence, it can be used to check if the parenthesis matches in an equation for example. 1234567891011121314151617181920#include &lt;stack&gt;class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; paren; for (char&amp; c : s) &#123; switch (c) &#123; case &apos;(&apos;: case &apos;&#123;&apos;: case &apos;[&apos;: paren.push(c); break; case &apos;)&apos;: if (paren.empty() || paren.top()!=&apos;(&apos;) return false; else paren.pop(); break; case &apos;&#125;&apos;: if (paren.empty() || paren.top()!=&apos;&#123;&apos;) return false; else paren.pop(); break; case &apos;]&apos;: if (paren.empty() || paren.top()!=&apos;[&apos;) return false; else paren.pop(); break; default: ; // pass &#125; &#125; return paren.empty() ; &#125;&#125;; https://discuss.leetcode.com/topic/32413/my-0ms-c-solution-using-stack My 0ms c++ solution using stack 1234567891011121314bool isValid(string s) &#123; stack&lt;char&gt; st; for(char c : s)&#123; if(c == &apos;(&apos;|| c == &apos;&#123;&apos; || c == &apos;[&apos;)&#123; st.push(c); &#125;else&#123; if(st.empty()) return false; if(c == &apos;)&apos; &amp;&amp; st.top() != &apos;(&apos;) return false; if(c == &apos;&#125;&apos; &amp;&amp; st.top() != &apos;&#123;&apos;) return false; if(c == &apos;]&apos; &amp;&amp; st.top() != &apos;[&apos;) return false; st.pop(); &#125; &#125; return st.empty(); https://discuss.leetcode.com/topic/7188/sharing-my-simple-cpp-code-with-2ms Sharing my simple cpp code with 2ms 1234567891011121314151617181920212223class Solution &#123; public: bool isValid(string s) &#123; map&lt;char, char&gt; parenth_dict; parenth_dict[&apos;(&apos;] = &apos;)&apos;; parenth_dict[&apos;&#123;&apos;] = &apos;&#125;&apos;; parenth_dict[&apos;[&apos;] = &apos;]&apos;; stack&lt;char&gt; aux; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &apos;(&apos; || s[i] == &apos;&#123;&apos; || s[i] == &apos;[&apos;) aux.push(s[i]); else if (aux.empty() || parenth_dict[aux.top()] != s[i]) return false; else aux.pop(); &#125; return aux.empty(); &#125;&#125;; python https://discuss.leetcode.com/topic/6534/simple-python-solution-with-stack Simple Python solution with stack 1234567891011121314class Solution: # @return a boolean def isValid(self, s): stack = [] dict = &#123;&quot;]&quot;:&quot;[&quot;, &quot;&#125;&quot;:&quot;&#123;&quot;, &quot;)&quot;:&quot;(&quot;&#125; for char in s: if char in dict.values(): stack.append(char) elif char in dict.keys(): if stack == [] or dict[char] != stack.pop(): return False else: return False return stack == [] https://discuss.leetcode.com/topic/40897/python-is-this-a-cheating-method-accepted-with-40ms-easy-to-understand-but [Python] is this a cheating method? accepted with 40ms, easy to understand, but 1234567891011121314151617181920class Solution(object): def isValid(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; n = len(s) if n == 0: return True if n % 2 != 0: return False while &apos;()&apos; in s or &apos;&#123;&#125;&apos; in s or &apos;[]&apos; in s: s = s.replace(&apos;&#123;&#125;&apos;,&apos;&apos;).replace(&apos;()&apos;,&apos;&apos;).replace(&apos;[]&apos;,&apos;&apos;) if s == &apos;&apos;: return True else: return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[019. Remove Nth Node From End of List]]></title>
    <url>%2Fp%2F72420d7f%2F</url>
    <content type="text"><![CDATA[33.6% https://leetcode.com/problems/remove-nth-node-from-end-of-list/ Given a linked list, remove the nth node from the end of list and return its head. 12345For example,Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Try to do this in one pass. 类似于剑指offer 15 方法一： 4ms, 37.53%, September 3, 2016 https://discuss.leetcode.com/topic/5397/my-short-c-solution My short C++ solution 123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode** t1 = &amp;head, *t2 = head; for(int i=1; i&lt;n; ++i) t2 = t2-&gt;next; while(t2-&gt;next != NULL)&#123; t1 = &amp;((*t1)-&gt;next); t2 = t2 -&gt; next; &#125; *t1 = (*t1)-&gt;next; return head; &#125;&#125;; 方法二： 我的代码实现： 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; // 链表经常在头部设置一个哑变量， 针对一些特殊情况，非常有效 ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* fast = dummy, *slow = dummy; while(n&gt;0)&#123; fast = fast-&gt;next; n--; &#125; while(fast-&gt;next)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return dummy-&gt;next; &#125;&#125;; https://discuss.leetcode.com/topic/7753/c-solution-easy-to-understand-with-explanations C++ solution, easy to understand with explanations. Renewed SolutionThe difference between the final node and the to_be_delete node is N. And here the assumption is that n is always valid. fast pointer points to the node which is N step away from the to_be_delete node. slow pointer points to the to_be_delete node. The algorithms is described as below: Firstly, move fast pointer N step forward. Secondly,move fast and slow pointers simultaneously one step a time forward till the fast pointer reach the end, which will cause the slow pointer points to the previous node of the to_be_delete node. Finally, slow-&gt;next = slow-&gt;next-&gt;next. 1234567891011121314151617181920212223242526ListNode *removeNthFromEnd(ListNode *head, int n) &#123; if (!head) return nullptr; ListNode new_head(-1); new_head.next = head; ListNode *slow = &amp;new_head, *fast = &amp;new_head; for (int i = 0; i &lt; n; i++) fast = fast-&gt;next; while (fast-&gt;next) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; ListNode *to_de_deleted = slow-&gt;next; slow-&gt;next = slow-&gt;next-&gt;next; delete to_be_deleted; return new_head.next;&#125; Fixed : Added code for deleting the N-th node. java 1ms, 5.49%, September 3, 2016 https://discuss.leetcode.com/topic/7031/simple-java-solution-in-one-pass Simple Java solution in one pass A one pass solution can be done using pointers. Move one pointer fast –&gt; n+1 places forward, to maintain a gap of n between the two pointers and then move both at the same speed. Finally, when the fast pointer reaches the end, the slow pointer will be n+1 places behind - just the right spot for it to be able to skip the next node. Since the question gives that n is valid, not too many checks have to be put in place. Otherwise, this would be necessary. 12345678910111213141516171819public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode start = new ListNode(0); ListNode slow = start, fast = start; slow.next = head; //Move fast in front so that the gap between slow and fast becomes n for(int i=1; i&lt;=n+1; i++) &#123; fast = fast.next; &#125; //Move fast to the end, maintaining the gap while(fast != null) &#123; slow = slow.next; fast = fast.next; &#125; //Skip the desired node slow.next = slow.next.next; return start.next;&#125; 1ms, 5.49%, September 3, 2016 https://discuss.leetcode.com/topic/20745/my-one-pass-solution My one pass solution 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode h1 = head, h2=head; while(n--&gt;0) h2 = h2.next; if(h2==null) return head.next; h2=h2.next; while(h2!=null)&#123; h1 = h1.next; h2 = h2.next; &#125; h1.next = h1.next.next; return head; &#125;&#125; https://discuss.leetcode.com/topic/42339/java-solution-1ms-%E5%AE%B9%E6%98%93%E7%90%86%E8%A7%A3 Java solution 1ms 容易理解 12345678910111213141516//还是走的快的点(fastNode)与走得慢的点(slowNode)路程差的问题 public static ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode headNode = new ListNode(9527); headNode.next = head; ListNode fastNode = headNode; ListNode slowNode = headNode; while(fastNode.next != null)&#123; if(n &lt;= 0) slowNode = slowNode.next; fastNode = fastNode.next; n--; &#125; if(slowNode.next != null) slowNode.next = slowNode.next.next; return headNode.next; &#125; https://discuss.leetcode.com/topic/12125/my-simple-java-solution-in-one-pass My simple Java solution in one pass 123456789101112131415public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy=new ListNode(0); dummy.next=head; ListNode fast=dummy; ListNode slow=dummy; int temp=n; for(;fast.next!=null;temp--)&#123; if(temp&lt;=0)&#123; //control slow=slow.next; &#125; fast=fast.next; &#125; slow.next=slow.next.next;//delete Nth return dummy.next;&#125; python 39ms, 100.00%, September 3, 2016 https://discuss.leetcode.com/topic/14692/3-short-python-solutions Value-Shifting - AC in 64 ms My first solution is “cheating” a little. Instead of really removing the nth node, I remove the nth value. I recursively determine the indexes (counting from back), then shift the values for all indexes larger than n, and then always drop the head. 1234567891011class Solution: def removeNthFromEnd(self, head, n): def index(node): if not node: return 0 i = index(node.next) + 1 if i &gt; n: node.next.val = node.val return i index(head) return head.next Index and Remove - AC in 56 ms In this solution I recursively determine the indexes again, but this time my helper function removes the nth node. It returns two values. The index, as in my first solution, and the possibly changed head of the remaining list. 12345678class Solution: def removeNthFromEnd(self, head, n): def remove(head): if not head: return 0, head i, head.next = remove(head.next) return i+1, (head, head.next)[i+1 == n] return remove(head)[1] n ahead - AC in 48 ms The standard solution, but without a dummy extra node. Instead, I simply handle the special case of removing the head right after the fast cursor got its head start. 123456789101112class Solution: def removeNthFromEnd(self, head, n): fast = slow = head for _ in range(n): fast = fast.next if not fast: return head.next while fast.next: fast = fast.next slow = slow.next slow.next = slow.next.next return head]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[018. 4Sum]]></title>
    <url>%2Fp%2F964c48a1%2F</url>
    <content type="text"><![CDATA[25.9% https://leetcode.com/problems/4sum/ Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 12345678For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 方法一： 我的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); if(n&lt;4) return res; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-3; i++)&#123; if(i!=0 &amp;&amp; nums[i]==nums[i-1]) continue; if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target) break; // 此处为break； if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]&lt;target) continue; // 此处为continue; 注意区分 for(int j=i+1; j&lt;n-2; j++)&#123; if(j!=i+1 &amp;&amp; nums[j]==nums[j-1]) continue; if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; int k=j+1, l=n-1; while(k&lt;l)&#123; int sum = nums[i]+nums[j]+nums[k]+nums[l]; if(sum==target)&#123; res.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[k], nums[l]&#125;); while(k&lt;l &amp;&amp; nums[k+1]==nums[k]) k++; while(k&lt;l &amp;&amp; nums[l-1]==nums[l]) l--; k++; l--; &#125;else if(sum&gt;target) l--; else k++; &#125; &#125; &#125; return res; &#125;&#125;; 16ms, 91.80%, April.23rd, 2016 https://leetcode.com/discuss/87769/implementation-carefully-pruning-accelerates-from-100ms First thanks to the post from @cx1992 I will just say that with out the 2 using of the 123if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; The runing time without these two lines cost 100ms. But with these lines, cost 16ms ! Here is the final implementation 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; result; int n=nums.size(); if(n&lt;4) return result; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-3; i++)&#123; if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) continue; /** cut edge to accelerate the speed **/ if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target) break; // 此处加break if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]&lt;target) continue; for(int j=i+1; j&lt;n-2; j++)&#123; if(j&gt;i+1 &amp;&amp; nums[j]==nums[j-1]) continue; /** cut edge to accelerate the speed **/ if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; /** jia bi process **/ int start=j+1, end=n-1; while(start &lt; end)&#123; int sum=nums[start]+nums[end]+nums[i]+nums[j]; if(sum&lt;target) start++; else if(sum&gt;target) end--; else&#123; result.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[start], nums[end]&#125;); start++; end--; while(nums[start-1]==nums[start] &amp;&amp; start&lt;end) start++; while(nums[end+1]==nums[end] &amp;&amp; start&lt;end) end--; &#125; &#125; &#125; &#125; return result; &#125;&#125;; 另一种代码实现： https://discuss.leetcode.com/topic/28641/my-16ms-c-code My 16ms c++ code 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; total; int n = nums.size(); if(n&lt;4) return total; sort(nums.begin(),nums.end()); for(int i=0;i&lt;n-3;i++) &#123; if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue; if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target) break; if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]&lt;target) continue; for(int j=i+1;j&lt;n-2;j++) &#123; if(j&gt;i+1&amp;&amp;nums[j]==nums[j-1]) continue; if(nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target) break; if(nums[i]+nums[j]+nums[n-2]+nums[n-1]&lt;target) continue; int left=j+1,right=n-1; while(left&lt;right)&#123; int sum=nums[left]+nums[right]+nums[i]+nums[j]; if(sum&lt;target) left++; else if(sum&gt;target) right--; else&#123; total.push_back(vector&lt;int&gt;&#123;nums[i],nums[j],nums[left],nums[right]&#125;); do&#123;left++;&#125;while(nums[left]==nums[left-1]&amp;&amp;left&lt;right); do&#123;right--;&#125;while(nums[right]==nums[right+1]&amp;&amp;left&lt;right); &#125; &#125; &#125; &#125; return total; &#125;&#125;; 方法二： 100ms, 45.73%, Apr.23rd, 2016 http://c4fun.cn/blog/2014/03/20/leetcode-solution-02/ 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;vector&lt;int&gt; &gt; ans; sort(num.begin(), num.end()); for (int i = 0; i &lt; num.size(); i++) &#123; if (i &gt; 0 &amp;&amp; num[i] == num[i-1]) continue; for (int j = i + 1; j &lt; num.size(); j++) &#123; if (j &gt; i + 1 &amp;&amp; num[j] == num[j - 1]) continue; int l = j + 1, r = num.size() - 1; while (l &lt; r) &#123; int sum = num[i] + num[j] + num[l] + num[r]; if (sum == target) &#123; ans.push_back(&#123;num[i], num[j], num[l], num[r]&#125;); while (l &lt; r &amp;&amp; num[l] == num[l + 1]) l++; l++; while (l &lt; r &amp;&amp; num[r] == num[r - 1]) r--; r--; &#125; else if (sum &lt; target) &#123; l++; &#125; else &#123; r--; &#125; &#125; &#125; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/27445/lower-bound-n-3 Lower bound n^3 Some people say their solutions are O(n2 log n) or even O(n2), but… Consider cases where nums is the n numbers from 1 to n. =&gt; There are Θ(n4) different quadruplets (nC4, to be exact, so about n4 / 24). =&gt; There are Θ(n) possible sums (from 1+2+3+4 to (n-3)+(n-2)+(n-1)+n, so about 4n sums). =&gt; At least one sum must have Ω(n3) different quadruplets. =&gt; For that sum, we must generate those Ω(n3) quadruplets. =&gt; For these cases we have to do Ω(n3) work. =&gt; O(n2 log n) or even O(n2) are impossible. (I have seen some previous talk about this, but only in a few answers/comments and I found it lacking. So I thought there should be a question directly stating and proving it.) cpp https://discuss.leetcode.com/topic/3752/my-c-solution-using-hashtable My C++ solution using hashtable My idea is to sort num first, then build a hashtable with the key as the sum of the pair and the value as a vector storing all pairs of index of num that having the same sum. In this way, all elements stored in hashtable has a order that duplicate pairs are neighbors. Therefore scanning the vector in the hashtable we only put non duplicate elements into the final answer vvi. Is this method O(n^2) ? or Does anyone can improve it to O(n^2); 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution&#123; //using hashtable, avg O(n^2)public: vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target)&#123; vector&lt;vector&lt;int&gt; &gt; vvi; int n = num.size(); if(n &lt; 4) return vvi; sort(num.begin(), num.end()); unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt; &gt; mp; for(int i = 0; i &lt; n; i++)&#123; for(int j = i + 1; j &lt; n; j++)&#123; mp[num[i]+num[j]].push_back(make_pair(i,j)); &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; if(i&gt;0 &amp;&amp; num[i] == num[i-1]) continue; for(int j = i + 1; j &lt; n; j++)&#123; if(j &gt; i + 1 &amp;&amp; num[j] == num[j-1]) continue; int res = target - num[i] - num[j]; if(mp.count(res))&#123; for(auto it = mp[res].begin(); it != mp[res].end(); it++)&#123; int k = (*it).first, l = (*it).second; if(k &gt; j)&#123; // k&gt;j make sure that the second pair has bigger values than the first pair. if(!vvi.empty() &amp;&amp; num[i]==vvi.back()[0] &amp;&amp; num[j]==vvi.back()[1] &amp;&amp; num[k]==vvi.back()[2] &amp;&amp; num[l] == vvi.back()[3])&#123; continue; //if the obtained 4 elements are the same as previous one continue to next &#125; vector&lt;int&gt; vi=&#123;num[i], num[j], num[k], num[l]&#125;; vvi.push_back(vi); &#125; // if k&gt;j &#125;//for it &#125;//if &#125;// forj &#125;//for i return vvi; &#125; &#125;; python https://discuss.leetcode.com/topic/10995/share-my-python-code-run-time-200-20ms Share my python code, run time 200+- 20ms 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution: # @return a list of lists of length 4, [[val1,val2,val3,val4]] def fourSum(self, num, target): num.sort() result = [] for i in xrange(len(num)-3): if num[i] &gt; target/4.0: break if i &gt; 0 and num[i] == num[i-1]: continue target2 = target - num[i] for j in xrange(i+1, len(num)-2): if num[j] &gt; target2/3.0: break if j &gt; i+1 and num[j] == num[j-1]: continue k = j + 1 l = len(num) - 1 target3 = target2 - num[j] # we should use continue not break # because target3 changes as j changes if num[k] &gt; target3/2.0: continue if num[l] &lt; target3/2.0: continue while k &lt; l: sum_value = num[k] + num[l] if sum_value == target3: result.append([num[i], num[j], num[k], num[l]]) kk = num[k] k += 1 while k&lt;l and num[k] == kk: k += 1 ll = num[l] l -= 1 while k&lt;l and num[l] == ll: l -= 1 elif sum_value &lt; target3: k += 1 else: l -= 1 return result We can reduce run time by adding some restrictions. https://discuss.leetcode.com/topic/9078/twosum-twosum-foursum-a-simple-python-solution TwoSum+twoSum == fourSum, a simple python solution 12345678910111213141516class Solution:# @return a list of lists of length 4, [[val1,val2,val3,val4]]def fourSum(self, num, target): two_sum = collections.defaultdict(list) res = set() for (n1, i1), (n2, i2) in itertools.combinations(enumerate(num), 2): two_sum[i1+i2].append(&#123;n1, n2&#125;) for t in list(two_sum.keys()): if not two_sum[target-t]: continue for pair1 in two_sum[t]: for pair2 in two_sum[target-t]: if pair1.isdisjoint(pair2): res.add(tuple(sorted(num[i] for i in pair1 | pair2))) del two_sum[t] return [list(r) for r in res] https://discuss.leetcode.com/topic/10556/a-conise-python-solution-based-on-ksum A conise python solution based on ksum 12345678910111213141516171819202122232425262728class Solution: # @return a list of lists of length 4, [[val1,val2,val3,val4]] def fourSum(self, num, target): num.sort() def ksum(num, k, target): i = 0 result = set() if k == 2: j = len(num) - 1 while i &lt; j: if num[i] + num[j] == target: result.add((num[i], num[j])) i += 1 elif num[i] + num[j] &gt; target: j -= 1 else: i += 1 else: while i &lt; len(num) - k + 1: newtarget = target - num[i] subresult = ksum(num[i+1:], k - 1, newtarget) if subresult: result = result | set( (num[i],) + nr for nr in subresult) i += 1 return result return [list(t) for t in ksum(num, 4, target)] 148ms, 86.46%, April.23rd, 2016 https://leetcode.com/discuss/83152/python-beats-86-07%25-may-be-better python beats 86.07% may be better make sure nums[i]!=nums[i+1] to avoid duplication and unnecessary computations and whennums[i]*4 &gt; target,It’ll be impossible to get another answer. and when nums[j]*4 &lt; target,It should turn to next loop maybe in some situations:usenums[i]+nums[i+1]+nums[i+2]+nums[i+3]wil be better.I am just for convenience.. 1234567891011121314151617181920212223242526class Solution(object): def fourSum(self, nums, target): res, n, nums, limit = [], len(nums), sorted(nums), target &gt;&gt; 2 for i in xrange(n-3): if nums[i] &gt; limit: #limit 1 break if i != 0 and nums[i] == nums[i-1]: #remove duplicate continue for j in xrange(n-1,i+2,-1): #Reverse traversal if nums[j] &lt; limit: #limit 2 break if j != n -1 and nums[j] == nums[j+1]: #remove duplicate continue lo, hi, sum2 = i + 1, j - 1, nums[i] + nums[j] limit2 = (target - sum2) &gt;&gt; 1 while lo &lt; hi and nums[lo] &lt;= limit2 and nums[hi] &gt;= limit2: #limit 3 sum = sum2 + nums[lo] + nums[hi] if sum == target: res += (nums[i], nums[lo], nums[hi], nums[j]), while lo &lt; hi and nums[hi] == nums[hi-1]: #remove duplicate hi -= 1 while lo &lt; hi and nums[lo] == nums[lo+1]: #remove duplicate lo += 1 lo += sum &lt;= target hi -= sum &gt;= target return res https://discuss.leetcode.com/topic/22705/python-140ms-beats-100-and-works-for-n-sum-n-2 Python 140ms beats 100%, and works for N-sum (N&gt;=2) The core is to implement a fast 2-pointer to solve 2-sum, and recursion to reduce the N-sum to 2-sum. Some optimization was be made knowing the list is sorted. 1234567891011121314151617181920212223242526272829303132def fourSum(self, nums, target): nums.sort() results = [] self.findNsum(nums, target, 4, [], results) return resultsdef findNsum(self, nums, target, N, result, results): if len(nums) &lt; N or N &lt; 2: return # solve 2-sum if N == 2: l,r = 0,len(nums)-1 while l &lt; r: if nums[l] + nums[r] == target: results.append(result + [nums[l], nums[r]]) l += 1 r -= 1 while l &lt; r and nums[l] == nums[l - 1]: l += 1 while r &gt; l and nums[r] == nums[r + 1]: r -= 1 elif nums[l] + nums[r] &lt; target: l += 1 else: r -= 1 else: for i in range(0, len(nums)-N+1): # careful about range if target &lt; nums[i]*N or target &gt; nums[-1]*N: # take advantages of sorted list break if i == 0 or i &gt; 0 and nums[i-1] != nums[i]: # recursively reduce N self.findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results) return Just revisited and clean the code 12345678910111213141516171819202122232425def fourSum(self, nums, target): def findNsum(nums, target, N, result, results): if len(nums) &lt; N or N &lt; 2 or target &lt; nums[0]*N or target &gt; nums[-1]*N: # early termination return if N == 2: # two pointers solve sorted 2-sum problem l,r = 0,len(nums)-1 while l &lt; r: s = nums[l] + nums[r] if s == target: results.append(result + [nums[l], nums[r]]) l += 1 while l &lt; r and nums[l] == nums[l-1]: l += 1 elif s &lt; target: l += 1 else: r -= 1 else: # recursively reduce N for i in range(len(nums)-N+1): if i == 0 or (i &gt; 0 and nums[i-1] != nums[i]): findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results) results = [] findNsum(sorted(nums), target, 4, [], results) return results java https://discuss.leetcode.com/topic/29585/7ms-java-code-win-over-100 26ms, 97.32% 7ms java code win over 100% The first time win over 100%. Basic idea is using subfunctions for 3sum and 2sum, and keeping throwing all impossible cases. O(n^3) time complexity, O(1) extra space complexity.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); int len = nums.length; if (nums == null || len &lt; 4) return res; Arrays.sort(nums); int max = nums[len - 1]; if (4 * nums[0] &gt; target || 4 * max &lt; target) return res; int i, z; for (i = 0; i &lt; len; i++) &#123; z = nums[i]; if (i &gt; 0 &amp;&amp; z == nums[i - 1])// avoid duplicate continue; if (z + 3 * max &lt; target) // z is too small continue; if (4 * z &gt; target) // z is too large break; if (4 * z == target) &#123; // z is the boundary if (i + 3 &lt; len &amp;&amp; nums[i + 3] == z) res.add(Arrays.asList(z, z, z, z)); break; &#125; threeSumForFourSum(nums, target - z, i + 1, len - 1, res, z); &#125; return res; &#125; /* * Find all possible distinguished three numbers adding up to the target * in sorted array nums[] between indices low and high. If there are, * add all of them into the ArrayList fourSumList, using * fourSumList.add(Arrays.asList(z1, the three numbers)) */ public void threeSumForFourSum(int[] nums, int target, int low, int high, ArrayList&lt;List&lt;Integer&gt;&gt; fourSumList, int z1) &#123; if (low + 1 &gt;= high) return; int max = nums[high]; if (3 * nums[low] &gt; target || 3 * max &lt; target) return; int i, z; for (i = low; i &lt; high - 1; i++) &#123; z = nums[i]; if (i &gt; low &amp;&amp; z == nums[i - 1]) // avoid duplicate continue; if (z + 2 * max &lt; target) // z is too small continue; if (3 * z &gt; target) // z is too large break; if (3 * z == target) &#123; // z is the boundary if (i + 1 &lt; high &amp;&amp; nums[i + 2] == z) fourSumList.add(Arrays.asList(z1, z, z, z)); break; &#125; twoSumForFourSum(nums, target - z, i + 1, high, fourSumList, z1, z); &#125; &#125; /* * Find all possible distinguished two numbers adding up to the target * in sorted array nums[] between indices low and high. If there are, * add all of them into the ArrayList fourSumList, using * fourSumList.add(Arrays.asList(z1, z2, the two numbers)) */ public void twoSumForFourSum(int[] nums, int target, int low, int high, ArrayList&lt;List&lt;Integer&gt;&gt; fourSumList, int z1, int z2) &#123; if (low &gt;= high) return; if (2 * nums[low] &gt; target || 2 * nums[high] &lt; target) return; int i = low, j = high, sum, x; while (i &lt; j) &#123; sum = nums[i] + nums[j]; if (sum == target) &#123; fourSumList.add(Arrays.asList(z1, z2, nums[i], nums[j])); x = nums[i]; while (++i &lt; j &amp;&amp; x == nums[i]) // avoid duplicate ; x = nums[j]; while (i &lt; --j &amp;&amp; x == nums[j]) // avoid duplicate ; &#125; if (sum &lt; target) i++; if (sum &gt; target) j--; &#125; return; &#125;&#125; https://discuss.leetcode.com/topic/12368/clean-accepted-java-o-n-3-solution-based-on-3sum Clean accepted java O(n^3) solution based on 3sum 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] num, int target) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if(num.length&lt;4)return ans; Arrays.sort(num); for(int i=0; i&lt;num.length-3; i++)&#123; if(i&gt;0&amp;&amp;num[i]==num[i-1])continue; for(int j=i+1; j&lt;num.length-2; j++)&#123; if(j&gt;i+1&amp;&amp;num[j]==num[j-1])continue; int low=j+1, high=num.length-1; while(low&lt;high)&#123; int sum=num[i]+num[j]+num[low]+num[high]; if(sum==target)&#123; ans.add(Arrays.asList(num[i], num[j], num[low], num[high])); while(low&lt;high&amp;&amp;num[low]==num[low+1])low++; while(low&lt;high&amp;&amp;num[high]==num[high-1])high--; low++; high--; &#125; else if(sum&lt;target)low++; else high--; &#125; &#125; &#125; return ans; &#125;&#125; https://discuss.leetcode.com/topic/12893/on-average-o-n-2-and-worst-case-o-n-3-java-solution-by-reducing-4sum-to-2sum On average O(n^2) and worst case O(n^3) java solution by reducing 4Sum to 2Sum Basic idea is to reduce the 4Sum problem to 2Sum one. In order to achieve that, we can use an array (size of n^2) to store the pair sums and this array will act as the array in 2Sum case (Here n is the size of the original 1D array and it turned out that we do not even need to explicitly use the n^2 sized array ). We also use a hashmap to mark if a pair sum has been visited or not (the same as in the 2Sum case). The tricky part here is that we may have multiple pairs that result in the same pair sum. So we will use a list to group these pairs together. For every pair with a particular sum, check if the pair sum that is needed to get the target has been visited. If so, further check if there is overlapping between these two pairs. If not, record the result. Time complexity to get all the pairs is O(n^2). For each pair, if the pair sum needed to get the target has been visited, the time complexity will be O(k), where k is the maximum size of the lists holding pairs with visited pair sum. Therefore the total time complexity will be O(k*n^2). Now we need to determine the range of k. Basically the more distinct pair sums we get, the smaller k will be. If all the pair sums are different from each other, k will just be 1. However, if we have many repeated elements in the original 1D array, or in some extreme cases such as the elements form an arithmetic progression, k can be of the order of n (strictly speaking, for the repeated elements case, k can go as high as n^2, but we can get rid of many of them). On average k will be some constant between 1 and n for normal elements distribution in the original 1D array. So on average our algorithm will go in O(n^2) but with worst case of O(n^3). Here is the complete code in java: 1234567891011121314151617181920212223242526272829303132333435363738394041public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] num, int target) &#123; Arrays.sort(num); Map&lt;Integer, List&lt;int[]&gt;&gt; twoSumMap = new HashMap&lt;&gt;(); // for holding visited pair sums. All pairs with the same pair sum are grouped together Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;(); // for holding the results for (int i = 0; i &lt; num.length; i++) &#123; // get rid of repeated pair sums if (i &gt; 1 &amp;&amp; num[i] == num[i - 2]) continue; for (int j = i + 1; j &lt; num.length; j++) &#123; // get rid of repeated pair sums if (j &gt; i + 2 &amp;&amp; num[j] == num[j - 2]) continue; // for each pair sum, check if the pair sum that is needed to get the target has been visited. if (twoSumMap.containsKey(target - (num[i] + num[j]))) &#123; // if so, get all the pairs that contribute to this visited pair sum. List&lt;int[]&gt; ls = twoSumMap.get(target - (num[i] + num[j])); for (int[] pair : ls) &#123; // we have two pairs: one is indicated as (pair[0], pair[1]), the other is (i, j). // we first need to check if they are overlapping with each other. int m1 = Math.min(pair[0], i); // m1 will always be the smallest index int m2 = Math.min(pair[1], j); // m2 will be one of the middle two indices int m3 = Math.max(pair[0], i); // m3 will be one of the middle two indices int m4 = Math.max(pair[1], j); // m4 will always be the largest index if (m1 == m3 || m1 == m4 || m2 == m3 || m2 == m4) continue; // two pairs are overlapping, so just ignore this case res.add(Arrays.asList(num[m1], num[Math.min(m2, m3)], num[Math.max(m2, m3)], num[m4])); // else record the result &#125; &#125; // mark that we have visited current pair and add it to the corrsponding pair sum group. // here we&apos;ve encoded the pair indices i and j into an integer array of length 2. twoSumMap.computeIfAbsent(num[i] + num[j], key -&gt; new ArrayList&lt;&gt;()).add(new int[] &#123;i, j&#125;); &#125; &#125; return new ArrayList&lt;List&lt;Integer&gt;&gt;(res);&#125; https://discuss.leetcode.com/topic/46339/my-solution-generalized-for-ksums-in-java My solution generalized for kSums in JAVA General Idea If you have already read and implement the 3sum and 4sum by using the sorting approach: reduce them into 2sum at the end, you might already got the feeling that, all ksum problem can be divided into two problems: 2sum Problem Reduce K sum problem to K – 1 sum Problem Therefore, the ideas is simple and straightforward. We could use recursive to solve this problem. Time complexity is O(N^(K-1)). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; int len = 0; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; len = nums.length; Arrays.sort(nums); return kSum(nums, target, 4, 0); &#125; private ArrayList&lt;List&lt;Integer&gt;&gt; kSum(int[] nums, int target, int k, int index) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(index &gt;= len) &#123; return res; &#125; if(k == 2) &#123; int i = index, j = len - 1; while(i &lt; j) &#123; //find a pair if(target - nums[i] == nums[j]) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); temp.add(nums[i]); temp.add(target-nums[i]); res.add(temp); //skip duplication while(i&lt;j &amp;&amp; nums[i]==nums[i+1]) i++; while(i&lt;j &amp;&amp; nums[j-1]==nums[j]) j--; i++; j--; //move left bound &#125; else if (target - nums[i] &gt; nums[j]) &#123; i++; //move right bound &#125; else &#123; j--; &#125; &#125; &#125; else&#123; for (int i = index; i &lt; len - k + 1; i++) &#123; //use current number to reduce ksum into k-1sum ArrayList&lt;List&lt;Integer&gt;&gt; temp = kSum(nums, target - nums[i], k-1, i+1); if(temp != null)&#123; //add previous results for (List&lt;Integer&gt; t : temp) &#123; t.add(0, nums[i]); &#125; res.addAll(temp); &#125; while (i &lt; len-1 &amp;&amp; nums[i] == nums[i+1]) &#123; //skip duplicated numbers i++; &#125; &#125; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/33433/java-a-little-bit-faster-than-other-common-methods-9ms-beats-95 Java a little bit faster than other common methods (9ms, beats 95%) To avoid duplicate list items, I skip unnecessary indices at two locations: one at the end of the outer loop (i-loop) the other at the end of the inner loop (j-loop). To avoid useless computations, the following is kind of critical: the function return immediately when nums[i]*4 &gt; target the inner loop break immediately when nums[j]*4 &lt; target. These two lines save quite some time due to the set up of the test cases in OJ. 12345678910111213141516171819202122232425262728public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(nums); int second = 0, third = 0, nexti = 0, nextj = 0; for(int i=0, L=nums.length; i&lt;L-3; i++) &#123; if(nums[i]&lt;&lt;2 &gt; target) return list; // return immediately for(int j=L-1; j&gt;i+2; j--) &#123; if(nums[j]&lt;&lt;2 &lt; target) break; // break immediately int rem = target-nums[i]-nums[j]; int lo = i+1, hi=j-1; while(lo&lt;hi) &#123; int sum = nums[lo] + nums[hi]; if(sum&gt;rem) --hi; else if(sum&lt;rem) ++lo; else &#123; list.add(Arrays.asList(nums[i],nums[lo],nums[hi],nums[j])); while(++lo&lt;=hi &amp;&amp; nums[lo-1]==nums[lo]) continue; // avoid duplicate results while(--hi&gt;=lo &amp;&amp; nums[hi]==nums[hi+1]) continue; // avoid duplicate results &#125; &#125; while(j&gt;=1 &amp;&amp; nums[j]==nums[j-1]) --j; // skip inner loop &#125; while(i&lt;L-1 &amp;&amp; nums[i]==nums[i+1]) ++i; // skip outer loop &#125; return list; &#125;&#125; https://discuss.leetcode.com/topic/9712/4sum-c-solution-with-explanation-and-comparison-with-3sum-problem-easy-to-understand For the reference, please have a look at my explanation of 3Sum problem because the algorithm are exactly the same. The link is as blow. My 3Sum problem answer The key idea is to downgrade the problem to a 2Sum problem eventually. And the same algorithm can be expand to NSum problem. After you had a look at my explanation of 3Sum, the code below will be extremely easy to understand. 123456789101112131415161718192021222324252627public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] num, int target) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if(num.length&lt;4)return ans; Arrays.sort(num); for(int i=0; i&lt;num.length-3; i++)&#123; if(i&gt;0&amp;&amp;num[i]==num[i-1])continue; for(int j=i+1; j&lt;num.length-2; j++)&#123; if(j&gt;i+1&amp;&amp;num[j]==num[j-1])continue; int low=j+1, high=num.length-1; while(low&lt;high)&#123; int sum=num[i]+num[j]+num[low]+num[high]; if(sum==target)&#123; ans.add(Arrays.asList(num[i], num[j], num[low], num[high])); while(low&lt;high&amp;&amp;num[low]==num[low+1])low++; while(low&lt;high&amp;&amp;num[high]==num[high-1])high--; low++; high--; &#125; else if(sum&lt;target)low++; else high--; &#125; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[017. Letter Combinations of a Phone Number]]></title>
    <url>%2Fp%2F9a201804%2F</url>
    <content type="text"><![CDATA[34.7% https://leetcode.com/problems/letter-combinations-of-a-phone-number/ Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. 12Input:Digit string &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 方法一： 迭代的方法 My iterative sollution, very simple under 15 lines This is my solution, FYI 针对新来的一个数字，比如2=“abc”，从原有的res中的所有string都取出来，针对每一个都加一个a或b或c，再放入新的vector中，再把新的赋值给res。 12345678910111213141516171819class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.size()==0) return res; string charmap[10] = &#123;&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; res.push_back(&quot;&quot;); for (int i = 0; i &lt; digits.size(); i++) &#123; vector&lt;string&gt; tempres; string chars = charmap[digits[i] - &apos;0&apos;]; for (int c = 0; c &lt; chars.size();c++) for (int j = 0; j &lt; res.size();j++) tempres.push_back(res[j]+chars[c]); res = tempres; &#125; return res; &#125;&#125;; 我的代码实现: 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.empty()) return res; // string用双引号 单双引号要仔细考虑 unordered_map&lt;char, string&gt;map = &#123;&#123;'1', ""&#125;, &#123;'2', "abc"&#125;, &#123;'3', "def"&#125;, &#123;'4', "ghi"&#125;, &#123;'5', "jkl"&#125;, &#123;'6', "mno"&#125;, &#123;'7', "pqrs"&#125;, &#123;'8', "tuv"&#125;, &#123;'9', "wxyz"&#125;&#125;; string s = ""; dfs(digits, 0, s, res, map); return res; &#125; void dfs(string&amp; digits, int k, string&amp; s, vector&lt;string&gt;&amp; res, unordered_map&lt;char, string&gt;&amp; map)&#123; if(k==digits.size())&#123; res.push_back(s); return; &#125; for(auto c:map[digits[k]])&#123; // string 的push_back，pop_back方法 s.push_back(c); dfs(digits, k+1, s, res, map); s.pop_back(); &#125; &#125;&#125;; java https://discuss.leetcode.com/topic/8125/concise-o-n-2-java-solution Concise O(N^2) Java solution Hi guys! The idea is to sort an input array and then run through all indices of a possible first element of a triplet. For each possible first element we make a standard bi-directional 2Sum sweep of the remaining part of the array. Also we want to skip equal elements to avoid duplicates in the answer without making a set or smth like that. 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) &#123; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; num.length-2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; num[i] != num[i-1])) &#123; int lo = i+1, hi = num.length-1, sum = 0 - num[i]; while (lo &lt; hi) &#123; if (num[lo] + num[hi] == sum) &#123; res.add(Arrays.asList(num[i], num[lo], num[hi])); while (lo &lt; hi &amp;&amp; num[lo] == num[lo+1]) lo++; while (lo &lt; hi &amp;&amp; num[hi] == num[hi-1]) hi--; lo++; hi--; &#125; else if (num[lo] + num[hi] &lt; sum) lo++; else hi--; &#125; &#125; &#125; return res;&#125; Have a nice coding! https://discuss.leetcode.com/topic/28857/easiest-java-solution Easiest Java Solution Sort the array, iterate through the list, and use another two pointers to approach the target. 12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i + 2 &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; // skip same result continue; &#125; int j = i + 1, k = nums.length - 1; int target = -nums[i]; while (j &lt; k) &#123; if (nums[j] + nums[k] == target) &#123; res.add(Arrays.asList(nums[i], nums[j], nums[k])); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++; // skip same result while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--; // skip same result &#125; else if (nums[j] + nums[k] &gt; target) &#123; k--; &#125; else &#123; j++; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/45491/share-my-simple-java-solution Share my simple java solution 123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(nums.length &lt; 3) return result; Arrays.sort(nums); int i = 0; while(i &lt; nums.length - 2) &#123; if(nums[i] &gt; 0) break; int j = i + 1; int k = nums.length - 1; while(j &lt; k) &#123; int sum = nums[i] + nums[j] + nums[k]; if(sum == 0) result.add(Arrays.asList(nums[i], nums[j], nums[k])); if(sum &lt;= 0) while(nums[j] == nums[++j] &amp;&amp; j &lt; k); if(sum &gt;= 0) while(nums[k--] == nums[k] &amp;&amp; j &lt; k); &#125; while(nums[i] == nums[++i] &amp;&amp; i &lt; nums.length - 2); &#125; return result; &#125;&#125; https://discuss.leetcode.com/topic/26050/simple-o-n-2-two-pointers-java-solution Simple O(n^2) two pointers Java solution Runtime = O(n^2); Space = O(1) 12345678910111213141516171819202122232425262728public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] A) &#123; List&lt;List&lt;Integer&gt;&gt;res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (A == null || A.length == 0) return res; Arrays.sort(A); for (int i = 0; i &lt; A.length; i++) &#123; if (i - 1 &gt;= 0 &amp;&amp; A[i] == A[i - 1]) continue;// Skip equal elements to avoid duplicates int left = i + 1, right = A.length - 1; while (left &lt; right) &#123;// Two Pointers int sum = A[i] + A[left] + A[right]; if (sum == 0) &#123; res.add(Arrays.asList(A[i], A[left], A[right])); while (left + 1 &lt; right &amp;&amp; A[left] == A[left+1])// Skip equal elements to avoid duplicates left++; while (right -1 &gt; left &amp;&amp; A[right] == A[right-1])// Skip equal elements to avoid duplicates right--; left++; right--; &#125; else if (sum &lt; 0) &#123; left++; &#125; else &#123; right--; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/8465/my-java-solution-with-fifo-queue My java solution with FIFO queue1234567891011121314public List&lt;String&gt; letterCombinations(String digits) &#123; LinkedList&lt;String&gt; ans = new LinkedList&lt;String&gt;(); String[] mapping = new String[] &#123;&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; ans.add(&quot;&quot;); for(int i =0; i&lt;digits.length();i++)&#123; int x = Character.getNumericValue(digits.charAt(i)); while(ans.peek().length()==i)&#123; String t = ans.remove(); for(char s : mapping[x].toCharArray()) ans.add(t+s); &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/6380/my-recursive-solution-using-java My recursive solution using Java1234567891011121314151617181920public class Solution &#123; private static final String[] KEYS = &#123; &quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot; &#125;; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; ret = new LinkedList&lt;String&gt;(); combination(&quot;&quot;, digits, 0, ret); return ret; &#125; private void combination(String prefix, String digits, int offset, List&lt;String&gt; ret) &#123; if (offset &gt;= digits.length()) &#123; ret.add(prefix); return; &#125; String letters = KEYS[(digits.charAt(offset) - &apos;0&apos;)]; for (int i = 0; i &lt; letters.length(); i++) &#123; combination(prefix + letters.charAt(i), digits, offset + 1, ret); &#125; &#125; &#125; cpp https://discuss.leetcode.com/topic/8107/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments Share my AC C++ solution, around 50ms, O(N*N), with explanation and comments the key idea is the same as the TwoSum problem. When we fix the 1st number, the 2nd and 3rd number can be found following the same reasoning as TwoSum. The only difference is that, the TwoSum problem of LEETCODE has a unique solution. However, in ThreeSum, we have multiple duplicate solutions that can be found. Most of the OLE errors happened here because you could’ve ended up with a solution with so many duplicates. The naive solution for the duplicates will be using the STL methods like below : 12std::sort(res.begin(), res.end());res.erase(unique(res.begin(), res.end()), res.end()); But according to my submissions, this way will cause you double your time consuming almostly. A better approach is that, to jump over the number which has been scanned, no matter it is part of some solution or not. If the three numbers formed a solution, we can safely ignore all the duplicates of them. We can do this to all the three numbers such that we can remove the duplicates. Here’s my AC C++ Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; res; std::sort(num.begin(), num.end()); for (int i = 0; i &lt; num.size(); i++) &#123; int target = -num[i]; int front = i + 1; int back = num.size() - 1; while (front &lt; back) &#123; int sum = num[front] + num[back]; // Finding answer which start from number num[i] if (sum &lt; target) front++; else if (sum &gt; target) back--; else &#123; vector&lt;int&gt; triplet(3, 0); triplet[0] = num[i]; triplet[1] = num[front]; triplet[2] = num[back]; res.push_back(triplet); // Processing duplicates of Number 2 // Rolling the front pointer to the next different number forwards while (front &lt; back &amp;&amp; num[front] == triplet[1]) front++; // Processing duplicates of Number 3 // Rolling the back pointer to the next different number backwards while (front &lt; back &amp;&amp; num[back] == triplet[2]) rear--; &#125; &#125; // Processing duplicates of Number 1 while (i + 1 &lt; num.size() &amp;&amp; num[i + 1] == num[i]) i++; &#125; return res; &#125; https://discuss.leetcode.com/topic/15291/20-lines-68ms-c-solution-used-two-pointers-similar-to-2sum ~20 lines. 68ms. c++ solution. Used two pointers similar to 2sum 1234567891011121314151617181920212223242526272829303132vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt;=2) return &#123;&#125;; vector&lt;vector&lt;int&gt; &gt; rtn; sort(nums.begin(), nums.end()); for(int i =0; i &lt; nums.size();)&#123; int start = i+1, end = nums.size()-1; while(start &lt; end)&#123; if(nums[i]+nums[start]+nums[end] == 0)&#123; rtn.push_back(&#123;nums[i],nums[start],nums[end]&#125;); start++; end--; while((start &lt; end) &amp;&amp; nums[start] == nums[start-1]) start++; while((start &lt; end) &amp;&amp; nums[end] == nums[end+1]) end--; &#125;else if(nums[i]+nums[start]+nums[end]&lt;0)&#123; start++; while((start &lt; end) &amp;&amp; nums[start] == nums[start-1]) start++; &#125;else&#123; end--; while((start &lt; end) &amp;&amp; nums[end] == nums[end+1]) end--; &#125; &#125; i++; while((i &lt; nums.size()) &amp;&amp; nums[i] == nums[i-1]) i++; &#125; return rtn;&#125; Thanks to my friend Yang Li inspired me of using two pointers https://discuss.leetcode.com/topic/15291/20-lines-68ms-c-solution-used-two-pointers-similar-to-2sum/2 Excellent way to avoid duplicate triples! (I had previously collected them in a set and moved them to a vector in the end). Here’s my take on it (got it to run in 52 ms): 12345678910111213141516vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; triples; sort(nums.begin(), nums.end()); int i = 0, last = nums.size() - 1; while (i &lt; last) &#123; int a = nums[i], j = i+1, k = last; while (j &lt; k) &#123; int b = nums[j], c = nums[k], sum = a+b+c; if (sum == 0) triples.push_back(&#123;a, b, c&#125;); if (sum &lt;= 0) while (nums[j] == b &amp;&amp; j &lt; k) j++; if (sum &gt;= 0) while (nums[k] == c &amp;&amp; j &lt; k) k--; &#125; while (nums[i] == a &amp;&amp; i &lt; last) i++; &#125; return triples;&#125; https://discuss.leetcode.com/topic/3396/my-iterative-sollution-very-simple-under-15-lines My iterative sollution, very simple under 15 lines This is my solution, FYI 针对新来的一个数字，比如2=“abc”，从原有的res中的所有string都取出来，针对每一个都加一个a或b或c，再放入res。 12345678910111213141516171819class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.size()==0) return res; string charmap[10] = &#123;&quot;0&quot;, &quot;1&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; res.push_back(&quot;&quot;); for (int i = 0; i &lt; digits.size(); i++) &#123; vector&lt;string&gt; tempres; string chars = charmap[digits[i] - &apos;0&apos;]; for (int c = 0; c &lt; chars.size();c++) for (int j = 0; j &lt; res.size();j++) tempres.push_back(res[j]+chars[c]); res = tempres; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/13160/8-line-backtracking-function-c-solution 8-line Backtracking-Function C++ Solution Most concise backtracking function, no? 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.size()==0) return res; string local; vector&lt;vector&lt;char&gt;&gt; table(2,vector&lt;char&gt;()); table.push_back(vector&lt;char&gt;&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;); // index 2 table.push_back(vector&lt;char&gt;&#123;&apos;d&apos;,&apos;e&apos;,&apos;f&apos;&#125;); // 3 table.push_back(vector&lt;char&gt;&#123;&apos;g&apos;,&apos;h&apos;,&apos;i&apos;&#125;); table.push_back(vector&lt;char&gt;&#123;&apos;j&apos;,&apos;k&apos;,&apos;l&apos;&#125;); // 5 table.push_back(vector&lt;char&gt;&#123;&apos;m&apos;,&apos;n&apos;,&apos;o&apos;&#125;); table.push_back(vector&lt;char&gt;&#123;&apos;p&apos;,&apos;q&apos;,&apos;r&apos;,&apos;s&apos;&#125;); // 7 table.push_back(vector&lt;char&gt;&#123;&apos;t&apos;,&apos;u&apos;,&apos;v&apos;&#125;); table.push_back(vector&lt;char&gt;&#123;&apos;w&apos;,&apos;x&apos;,&apos;y&apos;,&apos;z&apos;&#125;); // 9 backtracking(table,res,local,0,digits); return res; &#125; void backtracking(const vector&lt;vector&lt;char&gt;&gt;&amp; table, vector&lt;string&gt;&amp; res, string&amp; local, int index, const string&amp; digits) &#123; if(index==digits.size()) res.push_back(local); else for(int i=0;i&lt;table[digits[index]-&apos;0&apos;].size();i++) &#123; local.push_back(table[digits[index]-&apos;0&apos;][i]); backtracking(table, res, local, index+1, digits); local.pop_back(); &#125; &#125;&#125;; python https://discuss.leetcode.com/topic/22619/python-easy-to-understand-solution-o-n-n-time Python easy to understand solution (O(n*n) time). 123456789101112131415161718192021def threeSum(self, nums): res = [] nums.sort() for i in xrange(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue l, r = i+1, len(nums)-1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s &lt; 0: l +=1 elif s &gt; 0: r -= 1 else: res.append((nums[i], nums[l], nums[r])) while l &lt; r and nums[l] == nums[l+1]: l += 1 while l &lt; r and nums[r] == nums[r-1]: r -= 1 l += 1; r -= 1 return res https://discuss.leetcode.com/topic/13703/straight-forward-python-ac-o-n-2-solution-with-decent-explanation Straight forward Python AC O(n^2) solution with decent explanation 1234567891011121314151617181920212223242526272829class Solution: # @param &#123;integer[]&#125; nums # @return &#123;integer[][]&#125; def threeSum(self, nums): if len(nums) &lt;3: # deal with special input return [] elif len(nums) == 3: if sum(nums) == 0: return [sorted(nums)] nums = sorted(nums) # sorted, O(nlgn) ans = [] for i in range(len(nums) -2): j = i+1 k = len(nums) -1 # hence i &lt; j &lt; k while j&lt;k: # if not cross line temp_sum = nums[i] + nums[j] + nums[k] if temp_sum == 0: ans.append((nums[i], nums[j], nums[k])) if temp_sum &gt; 0: # which means we need smaller sum, move k backward, remember we sort the array k -= 1 else: j += 1 return list(set(tuple(ans))) # I bet this is not the best way to eliminate duplicate solutions https://discuss.leetcode.com/topic/11783/one-line-python-solution 48ms, 58.58%, September 1, 2016 123456789101112131415161718class Solution(object): def letterCombinations(self, digits): &quot;&quot;&quot; :type digits: str :rtype: List[str] &quot;&quot;&quot; if digits == &apos;&apos;: return [] kvmaps = &#123; &apos;2&apos;:&apos;abc&apos;, &apos;3&apos;:&apos;def&apos;, &apos;4&apos;:&apos;ghi&apos;, &apos;5&apos;:&apos;jkl&apos;, &apos;6&apos;:&apos;mno&apos;, &apos;7&apos;:&apos;pqrs&apos;, &apos;8&apos;:&apos;tuv&apos;, &apos;9&apos;:&apos;wxyz&apos; &#125; return reduce(lambda acc, digit:[x+y for x in acc for y in kvmaps[digit]], digits, [&apos;&apos;])]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[016. 3Sum Closest]]></title>
    <url>%2Fp%2F473b519e%2F</url>
    <content type="text"><![CDATA[30.7% https://leetcode.com/problems/3sum-closest/ Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. 123For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 方法一： 先sort，然后一个指针，从头遍历，另外两个指针。 https://discuss.leetcode.com/topic/17215/c-solution-o-n-2-using-sort C++ solution O(n^2) using sort Sort the vector and then no need to run O(N^3) algorithm as each index has a direction to move. 1234567The code starts from this formation.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678if nums[first] + nums[second] + nums[third] is smaller than the target, we know we have to increase the sum. so only choice is moving the second index forward.----------------------------------------------------^ ^ ^| | || +- second third+-first 123456789if the sum is bigger than the target, we know that we need to reduce the sum. so only choice is moving &apos;third&apos; to backward. of course if the sum equals to target, we can immediately return the sum.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678when second and third cross, the round is done so start next round by moving &apos;first&apos; and resetting second and third.---------------------------------------------------- ^ ^ ^ | | | | +- second third +-first 123456789while doing this, collect the closest sum of each stage by calculating and comparing delta. Compare abs(target-newSum) and abs(target-closest). At the end of the process the three indexes will eventually be gathered at the end of the array.---------------------------------------------------- ^ ^ ^ | | `- third | +- second +-first if no exactly matching sum has been found so far, the value in closest will be the answer. 1234567891011121314151617181920212223int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size() &lt; 3) return 0; int closest = nums[0]+nums[1]+nums[2]; sort(nums.begin(), nums.end()); for(int first = 0 ; first &lt; nums.size()-2 ; ++first) &#123; if(first &gt; 0 &amp;&amp; nums[first] == nums[first-1]) continue; int second = first+1; int third = nums.size()-1; while(second &lt; third) &#123; int curSum = nums[first]+nums[second]+nums[third]; if(curSum == target) return curSum; if(abs(target-curSum)&lt;abs(target-closest)) &#123; closest = curSum; &#125; if(curSum &gt; target) &#123; --third; &#125; else &#123; ++second; &#125; &#125; &#125; return closest;&#125; https://discuss.leetcode.com/topic/36978/12-lines-concise-and-easy-understand-c-solultion 12 lines concise and easy understand c++ solultion 1234567891011121314151617class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; nums.size() - 2; i++)&#123; int j = i + 1, k = nums.size() - 1; while(j &lt; k)&#123; int num = nums[i] + nums[j] + nums[k]; if(abs(num - target) &lt; abs(res - target)) res = num; if(num &lt; target) j++; else k--; &#125; &#125; return res; &#125;&#125;; 我的代码实现: 123456789101112131415161718192021222324class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; // res 初始化为INT_MAX可能会导致各种意外，因为res要进行加减 // 容易超范围，最好的办法是任意初始化 int res = nums[0]+nums[1]+nums[2]; int n = nums.size(); sort(nums.begin(), nums.end()); for(int first=0; first&lt;n-2; first++)&#123; int second = first+1, third = n-1; while(second&lt;third)&#123; int cur = nums[first]+nums[second]+nums[third]; // 学习使用abs函数，用于求绝对值 if(abs(cur-target)&lt;abs(res-target)) res = cur; if(cur&lt;target) second++; else third--; &#125; &#125; return res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/1978/a-n-2-solution-can-we-do-better Here is a solution in Order(N^2). I got help from this post onstackoverflow Can we improve this time complexity ? Edit:Thanks @thr for pointing out that. I have corrected it and also renamed ‘mx’ by ‘ans’. 12345678910111213141516171819202122232425262728293031323334353637383940int threeSumClosest(vector&lt;int&gt; &amp;num, int target) &#123; vector&lt;int&gt; v(num.begin(), num.end()); // I didn&apos;t wanted to disturb original array. int n = 0; int ans = 0; int sum; sort(v.begin(), v.end()); // If less then 3 elements then return their sum while (v.size() &lt;= 3) &#123; return accumulate(v.begin(), v.end(), 0); &#125; n = v.size(); /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1] * v[i] &lt;= v[j] &lt;= v[k] always, because we sorted our array. * Now, for each number, v[i] : we look for pairs v[j] &amp; v[k] such that * absolute value of (target - (v[i] + v[j] + v[k]) is minimised. * if the sum of the triplet is greater then the target it implies * we need to reduce our sum, so we do K = K - 1, that is we reduce * our sum by taking a smaller number. * Simillarly if sum of the triplet is less then the target then we * increase out sum by taking a larger number, i.e. J = J + 1. */ ans = v[0] + v[1] + v[2]; for (int i = 0; i &lt; n-2; i++) &#123; int j = i + 1; int k = n - 1; while (j &lt; k) &#123; sum = v[i] + v[j] + v[k]; if (abs(target - ans) &gt; abs(target - sum)) &#123; ans = sum; if (ans == target) return ans; &#125; (sum &gt; target) ? k-- : j++; &#125; &#125; return ans;&#125; https://discuss.leetcode.com/topic/17215/c-solution-o-n-2-using-sort C++ solution O(n^2) using sort Sort the vector and then no need to run O(N^3) algorithm as each index has a direction to move. 1234567The code starts from this formation.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678if nums[first] + nums[second] + nums[third] is smaller than the target, we know we have to increase the sum. so only choice is moving the second index forward.----------------------------------------------------^ ^ ^| | || +- second third+-first 123456789if the sum is bigger than the target, we know that we need to reduce the sum. so only choice is moving &apos;third&apos; to backward. of course if the sum equals to target, we can immediately return the sum.----------------------------------------------------^ ^ ^| | || +- second third+-first 12345678when second and third cross, the round is done so start next round by moving &apos;first&apos; and resetting second and third.---------------------------------------------------- ^ ^ ^ | | | | +- second third +-first 123456789while doing this, collect the closest sum of each stage by calculating and comparing delta. Compare abs(target-newSum) and abs(target-closest). At the end of the process the three indexes will eventually be gathered at the end of the array.---------------------------------------------------- ^ ^ ^ | | `- third | +- second +-first if no exactly matching sum has been found so far, the value in closest will be the answer. 1234567891011121314151617181920212223int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size() &lt; 3) return 0; int closest = nums[0]+nums[1]+nums[2]; sort(nums.begin(), nums.end()); for(int first = 0 ; first &lt; nums.size()-2 ; ++first) &#123; if(first &gt; 0 &amp;&amp; nums[first] == nums[first-1]) continue; int second = first+1; int third = nums.size()-1; while(second &lt; third) &#123; int curSum = nums[first]+nums[second]+nums[third]; if(curSum == target) return curSum; if(abs(target-curSum)&lt;abs(target-closest)) &#123; closest = curSum; &#125; if(curSum &gt; target) &#123; --third; &#125; else &#123; ++second; &#125; &#125; &#125; return closest;&#125; https://discuss.leetcode.com/topic/36978/12-lines-concise-and-easy-understand-c-solultion 12 lines concise and easy understand c++ solultion 1234567891011121314151617class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; nums.size() - 2; i++)&#123; int j = i + 1, k = nums.size() - 1; while(j &lt; k)&#123; int num = nums[i] + nums[j] + nums[k]; if(abs(num - target) &lt; abs(res - target)) res = num; if(num &lt; target) j++; else k--; &#125; &#125; return res; &#125;&#125;; 12ms, 51.55%, Apr.23rd, 2016 https://github.com/haoel/leetcode/blob/master/algorithms/cpp/3SumClosest/3SumClosest.cpp 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int n = nums.size(); int distance = 2147483647; int result; for(int i=0; i&lt;n-2; i++)&#123; if(i&gt;0 &amp;&amp; nums[i-1]==nums[i]) continue; int a = nums[i]; int low = i+1; int high = n-1; while(low &lt; high)&#123; int b = nums[low]; int c = nums[high]; int sum = a + b + c; if(sum - target == 0) return target; else&#123; if(abs(sum - target) &lt; distance)&#123; distance = abs(sum - target); result = sum; &#125; if (sum - target &gt; 0)&#123; while(high &gt; 0 &amp;&amp; nums[high] == nums[high-1]) high--; high--; &#125;else&#123; while(low &lt; n-1 &amp;&amp; nums[low] == nums[low+1]) low++; low++; &#125; &#125; &#125; &#125; return result; &#125;&#125;; 28ms, 16.01%, Apr.23rd, 2016 https://leetcode.com/discuss/85999/12-lines-concise-and-easy-understand-c-solultion 1234567891011121314151617class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); int res = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; nums.size(); i++)&#123; int j = i + 1, k = nums.size() - 1; while(j &lt; k)&#123; int num = nums[i] + nums[j] + nums[k]; if(abs(num - target) &lt; abs(res - target)) res = num; if(num &lt; target) j++; else k--; &#125; &#125; return res; &#125;&#125;; python https://discuss.leetcode.com/topic/9815/python-o-n-2-solution Python O(N^2) solution 123456789101112131415161718192021class Solution: # @return an integer def threeSumClosest(self, num, target): num.sort() result = num[0] + num[1] + num[2] for i in range(len(num) - 2): j, k = i+1, len(num) - 1 while j &lt; k: sum = num[i] + num[j] + num[k] if sum == target: return sum if abs(sum - target) &lt; abs(result - target): result = sum if sum &lt; target: j += 1 elif sum &gt; target: k -= 1 return result https://discuss.leetcode.com/topic/20359/python-solution-two-pointer Python solution (two-pointer). 12345678910111213141516def threeSumClosest(self, nums, target): nums.sort() res = sum(nums[:3]) for i in xrange(len(nums)): l, r = i+1, len(nums)-1 while l &lt; r: s = sum((nums[i], nums[l], nums[r])) if abs(s-target) &lt; abs(res-target): res = s if s &lt; target: l += 1 elif s &gt; target: r -= 1 else: # break early return res return res 508ms, 2.61%, Apr.23rd, 2016 http://c4fun.cn/blog/2014/03/20/leetcode-solution-02/ 求集合中3个数能够得到的距离target最近的和 和3Sum一样，而且不用处理重复解问题了。 1234567891011121314151617181920class Solution(object): def threeSumClosest(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; nums.sort() ans = None for i in range(len(nums)): l, r = i + 1, len(nums) - 1 while l &lt; r: sum = nums[l] + nums[r] + nums[i] if ans is None or abs(sum - target) &lt; abs(ans - target): ans = sum if sum &lt;= target: l = l + 1 else: r = r - 1 return ans java https://discuss.leetcode.com/topic/5192/java-solution-with-o-n2-for-reference Java solution with O(n2) for reference Similar to 3 Sum problem, use 3 pointers to point current element, next element and the last element. If the sum is less than target, it means we have to add a larger element so next element move to the next. If the sum is greater, it means we have to add a smaller element so last element move to the second last element. Keep doing this until the end. Each time compare the difference between sum and target, if it is less than minimum difference so far, then replace result with it, otherwise keep iterating. 123456789101112131415161718192021public class Solution &#123; public int threeSumClosest(int[] num, int target) &#123; int result = num[0] + num[1] + num[num.length - 1]; Arrays.sort(num); for (int i = 0; i &lt; num.length - 2; i++) &#123; int start = i + 1, end = num.length - 1; while (start &lt; end) &#123; int sum = num[i] + num[start] + num[end]; if (sum &gt; target) &#123; end--; &#125; else &#123; start++; &#125; if (Math.abs(sum - target) &lt; Math.abs(result - target)) &#123; result = sum; &#125; &#125; &#125; return result; &#125;&#125; https://discuss.leetcode.com/topic/31117/7ms-and-o-n-2-java-solution 7ms and o(n^2) java solution My solution does not need compare each sum ,just need to compare possible sum ,so can save time. 123456789101112131415161718192021222324public class Solution &#123;public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int closest=nums[0]+nums[1]+nums[2]; int low,high; for(int i=0;i&lt;nums.length-1;i++)&#123; low=i+1; high=nums.length-1; while(low&lt;high)&#123; if(nums[low]+nums[high]==target-nums[i]) return target; else if(nums[low]+nums[high]&gt;target-nums[i])&#123; while(low&lt;high&amp;&amp;nums[low]+nums[high]&gt;target-nums[i]) high--; if(Math.abs(nums[i]+nums[low]+nums[high+1]-target)&lt;Math.abs(closest-target)) closest=nums[i]+nums[low]+nums[high+1]; &#125; else&#123; while(low&lt;high&amp;&amp;nums[low]+nums[high]&lt;target-nums[i]) low++; if(Math.abs(nums[i]+nums[low-1]+nums[high]-target)&lt;Math.abs(closest-target)) closest=nums[i]+nums[low-1]+nums[high]; &#125; &#125; &#125; return closest;&#125; https://discuss.leetcode.com/topic/35892/share-my-24-line-java-code-beats-94-57-run-times Share my 24-line Java code (beats 94.57% run times) 1234567891011121314151617181920212223242526public class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int diff = Integer.MAX_VALUE, closest = 0; for (int k=0; k&lt;nums.length-2; ++k) &#123; for (int i=k+1, j=nums.length-1; i&lt;j; ) &#123; int sum = nums[k] + nums[i] + nums[j]; if (sum == target) &#123; return target; &#125; else if (sum &gt; target) &#123; if (sum-target &lt; diff) &#123; diff = sum-target; closest = sum; &#125; --j; &#125; else &#123; if (target-sum &lt; diff) &#123; diff = target-sum; closest = sum; &#125; ++i; &#125; &#125; &#125; return closest; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[015. 3Sum]]></title>
    <url>%2Fp%2F6a4c11d8%2F</url>
    <content type="text"><![CDATA[21.2% https://leetcode.com/problems/3sum/ Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 1234567For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [[-1, 0, 1],[-1, -1, 2] ] 方法一： 先排序，然后以i进行遍历，然后放j和k两个指针遍历。 重点是考虑重复的情况，所以有两处考虑了重复的问题。 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); int n = nums.size(); for(int i=0; i&lt;n-2; i++)&#123; if(i!=0 &amp;&amp; nums[i]==nums[i-1]) continue; int target = 0 - nums[i]; int j=i+1, k=n-1; while(j&lt;k)&#123; if(nums[j]+nums[k]==target)&#123; vector&lt;int&gt; tmp&#123;nums[i], nums[j], nums[k]&#125;; res.push_back(tmp); while(j&lt;k &amp;&amp; nums[j]==tmp[1]) j++; while(j&lt;k &amp;&amp; nums[k]==tmp[2]) k--; &#125;else if(nums[j]+nums[k]&gt;target)&#123; k--; &#125;else j++; &#125; &#125; return res; &#125;&#125;; 我的代码实现一： 注意其中的重点，一个是要考虑重复，一个是要考虑跳出循环 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); if(n&lt;3) return res; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-2; i++)&#123; if(i!=0 &amp;&amp; nums[i]==nums[i-1]) // 考虑重复情况 continue; int left = i+1, right = n-1; while(left&lt;right)&#123; int sum = nums[i]+nums[left]+nums[right]; if(sum==0)&#123; vector&lt;int&gt; tmp = &#123;nums[i], nums[left], nums[right]&#125;; res.push_back(tmp); while(left+1&lt;right &amp;&amp; nums[left+1]==nums[left]) left++; // 此处要跳出循环，继续寻找 while(left&lt;right-1 &amp;&amp; nums[right-1]==nums[right]) right--; left++, right--; &#125;else if(sum&lt;0) left++; else right--; &#125; &#125; return res; &#125;&#125;; 我的代码实现二: 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); if(n&lt;3) return res; sort(nums.begin(), nums.end()); for(int i=0; i&lt;n-2; i++)&#123; // 考虑重复的情况 if(i!=0 &amp;&amp; nums[i]==nums[i-1]) continue; int target = - nums[i]; int left = i+1, right = n-1; while(left&lt;right)&#123; int sum = nums[left] + nums[right]; if(sum==target)&#123; res.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;); while(left&lt;right &amp;&amp; nums[left+1]==nums[left]) left++; while(left&lt;right &amp;&amp; nums[right-1]==nums[right]) right--; left++; right--; &#125; else if(sum&lt;target) left++; else right--; &#125; &#125; return res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/8107/share-my-ac-c-solution-around-50ms-o-n-n-with-explanation-and-comments the key idea is the same as the TwoSum problem. When we fix the 1st number, the 2nd and 3rd number can be found following the same reasoning as TwoSum. The only difference is that, the TwoSum problem of LEETCODE has a unique solution. However, in ThreeSum, we have multiple duplicate solutions that can be found. Most of the OLE errors happened here because you could’ve ended up with a solution with so many duplicates. The naive solution for the duplicates will be using the STL methods like below : 12std::sort(res.begin(), res.end());res.erase(unique(res.begin(), res.end()), res.end()); But according to my submissions, this way will cause you double your time consuming almostly. A better approach is that, to jump over the number which has been scanned, no matter it is part of some solution or not. If the three numbers formed a solution, we can safely ignore all the duplicates of them. We can do this to all the three numbers such that we can remove the duplicates. Here’s my AC C++ Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) &#123; vector&lt;vector&lt;int&gt; &gt; res; std::sort(num.begin(), num.end()); for (int i = 0; i &lt; num.size(); i++) &#123; int target = -num[i]; int front = i + 1; int back = num.size() - 1; while (front &lt; back) &#123; int sum = num[front] + num[back]; // Finding answer which start from number num[i] if (sum &lt; target) front++; else if (sum &gt; target) back--; else &#123; vector&lt;int&gt; triplet(3, 0); triplet[0] = num[i]; triplet[1] = num[front]; triplet[2] = num[back]; res.push_back(triplet); // Processing duplicates of Number 2 // Rolling the front pointer to the next different number forwards while (front &lt; back &amp;&amp; num[front] == triplet[1]) front++; // Processing duplicates of Number 3 // Rolling the back pointer to the next different number backwards while (front &lt; back &amp;&amp; num[back] == triplet[2]) rear--; &#125; &#125; // Processing duplicates of Number 1 while (i + 1 &lt; num.size() &amp;&amp; num[i + 1] == num[i]) i++; &#125; return res; &#125; 64ms, 23.81%, Apr.23rd, 2016 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt; vector&lt;int&gt; &gt; result; // 先排序 sort(nums.begin(), nums.end()); int n = nums.size(); for(int i=0; i&lt;n-2; i++)&#123; // 跳过重复项 if(i&gt;0 &amp;&amp; nums[i-1]==nums[i]) continue; int a = nums[i]; int low = i + 1; int high = n - 1; while(low &lt; high)&#123; int b = nums[low]; int c = nums[high]; if(a + b + c == 0)&#123; vector&lt;int&gt; v; v.push_back(a); v.push_back(b); v.push_back(c); result.push_back(v); // 继续寻找答案,忽略重复项，high，low各加1 while(low &lt; n-1 &amp;&amp; nums[low] == nums[low+1]) low++; while(high &gt; 0 &amp;&amp; nums[high] == nums[high-1]) high--; low++; high--; &#125;else if(a+b+c &gt; 0)&#123; while(high &gt; 0 &amp;&amp; nums[high] == nums[high-1]) high--; high--; &#125;else&#123; while(low &gt; 0 &amp;&amp; nums[low] == nums[low+1]) low++; low++; &#125; &#125; &#125; return result; &#125;&#125;; python 224ms, 44.36%, Apr.23rd, 2016 求3个数的和为target的所有解。 枚举第一个数，然后第二个数为这个数的后一个数，第三个数为最后一个数，如果和小于0，第二个数后移， 如大于0第三个数前移，等于0的话记录结果并且都向中间移。注意处理重复解。 123456789101112131415161718192021class Solution: # @return a list of lists of length 3, [[val1,val2,val3]] def threeSum(self, num): num.sort() ans = [] for i in range(len(num)): if (i &gt; 0 and num[i] == num[i-1]): continue l, r = i + 1, len(num) - 1 while l &lt; r: sum = num[l] + num[r] + num[i] if sum == 0: ans.append([num[i], num[l], num[r]]) while l &lt; r and num[l] == num[l + 1]: l = l + 1 while l &lt; r and num[r] == num[r - 1]: r = r - 1 l, r = l + 1, r - 1 elif sum &lt; 0: l = l + 1 else: r = r - 1 return ans java https://discuss.leetcode.com/topic/8125/concise-o-n-2-java-solution Concise O(N^2) Java solution Hi guys! The idea is to sort an input array and then run through all indices of a possible first element of a triplet. For each possible first element we make a standard bi-directional 2Sum sweep of the remaining part of the array. Also we want to skip equal elements to avoid duplicates in the answer without making a set or smth like that. Have a nice coding! 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) &#123; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; num.length-2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; num[i] != num[i-1])) &#123; int lo = i+1, hi = num.length-1, sum = 0 - num[i]; while (lo &lt; hi) &#123; if (num[lo] + num[hi] == sum) &#123; res.add(Arrays.asList(num[i], num[lo], num[hi])); while (lo &lt; hi &amp;&amp; num[lo] == num[lo+1]) lo++; while (lo &lt; hi &amp;&amp; num[hi] == num[hi-1]) hi--; lo++; hi--; &#125; else if (num[lo] + num[hi] &lt; sum) lo++; else hi--; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/28857/easiest-java-solution Easiest Java Solution Sort the array, iterate through the list, and use another two pointers to approach the target. 12345678910111213141516171819202122232425public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(nums); for (int i = 0; i + 2 &lt; nums.length; i++) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; // skip same result continue; &#125; int j = i + 1, k = nums.length - 1; int target = -nums[i]; while (j &lt; k) &#123; if (nums[j] + nums[k] == target) &#123; res.add(Arrays.asList(nums[i], nums[j], nums[k])); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++; // skip same result while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--; // skip same result &#125; else if (nums[j] + nums[k] &gt; target) &#123; k--; &#125; else &#123; j++; &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/45491/share-my-simple-java-solution Share my simple java solution 123456789101112131415161718192021public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if(nums.length &lt; 3) return result; Arrays.sort(nums); int i = 0; while(i &lt; nums.length - 2) &#123; if(nums[i] &gt; 0) break; int j = i + 1; int k = nums.length - 1; while(j &lt; k) &#123; int sum = nums[i] + nums[j] + nums[k]; if(sum == 0) result.add(Arrays.asList(nums[i], nums[j], nums[k])); if(sum &lt;= 0) while(nums[j] == nums[++j] &amp;&amp; j &lt; k); if(sum &gt;= 0) while(nums[k--] == nums[k] &amp;&amp; j &lt; k); &#125; while(nums[i] == nums[++i] &amp;&amp; i &lt; nums.length - 2); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[014. Longest Common Prefix]]></title>
    <url>%2Fp%2F58ae5420%2F</url>
    <content type="text"><![CDATA[31.5% https://leetcode.com/problems/longest-common-prefix/ Write a function to find the longest common prefix string amongst an array of strings. 方法一： First one: check from strs[0][0] to strs[i][0]. If matches, check strs[0][1] to strs[i][1]. Code: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=&quot;&quot;; int max=INT_MAX; for(auto&amp; s:strs) &#123; max=(max&gt;s.length())?s.length():max; &#125; for(int i=0;i&lt;max;i++) &#123; bool flag=true; char x=strs[0][i]; for(auto&amp; s:strs) &#123; if(s[i]!=x) &#123; flag=false; break; &#125; &#125; if(flag==false) return ans; ans+=x; &#125; return ans; &#125;&#125;; 代码的另一种写法： 12345678910111213class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string prefix = &quot;&quot;; for(int idx=0; strs.size()&gt;0;idx++)&#123; for(int i=0; i&lt;strs.size(); i++) if(idx&gt;=strs[i].size() || (i&gt;0&amp;&amp;strs[i][idx] != strs[i-1][idx])) return prefix; prefix+=strs[0][idx]; &#125; return prefix; &#125;&#125;; 我的代码实现： 12345678910111213141516171819class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string res = ""; int n = strs.size(); // 一定考虑是否有异常情况的可能性 if(n==0) return res; int i = 0; while(true)&#123; for(int j=0; j&lt;n; j++)&#123; if(i&gt;=strs[j].size() || j&gt;0 &amp;&amp; strs[j][i]!=strs[j-1][i])&#123; return res; &#125; &#125; res += strs[0][i]; i++; &#125; &#125;&#125;; 方法二： Second one: assume the prefix is strs[0]. Compair with strs[i], and cut the letters which don’t match. Code: 1234567891011121314151617181920212223class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=strs[0]; int max=INT_MAX; for(auto&amp; s:strs) &#123; if(s.length()==0) return &quot;&quot;; int i=0; for(i=0;i&lt;ans.length()&amp;&amp;i&lt;s.length();i++) &#123; if(s[i]!=ans[i]) break; &#125; ans=ans.substr(0,i); &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/13121/what-does-longest-common-prefix-mean What does Longest Common Prefix mean ? The problem statement is confusing and unclear. Can someone throw light on this ? Is it to find prefix between each pair of strings and return the one which is longest. Or all the strings has to have a common prefix? https://discuss.leetcode.com/topic/13121/what-does-longest-common-prefix-mean/2 It seems that it is not to check between pair of strings but on all the strings in the array. For example: {“a”,”a”,”b”} should give “” as there is nothing common in all the 3 strings. {“a”, “a”} should give “a” as a is longest common prefix in all the strings. {“abca”, “abc”} as abc {“ac”, “ac”, “a”, “a”} as a. Logic goes something like this: Pick a character at i=0th location and compare it with the character at that location in every string. If anyone doesn’t have that just return “” Else append that character in to the result. Increment i and do steps 1-3 till the length of that string. return result. Make sure proper checks are maintained to avoid index out of bounds error. cpp https://discuss.leetcode.com/topic/20991/accepted-c-6-lines-4ms Accepted c++ 6 lines 4ms 6ms, September 19, 2016 1234567891011class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string prefix = &quot;&quot;; for(int idx=0; strs.size()&gt;0;prefix+=strs[0][idx], idx++) for(int i=0; i&lt;strs.size(); i++) if(idx&gt;=strs[i].size() || (i&gt;0&amp;&amp;strs[i][idx] != strs[i-1][idx])) return prefix; return prefix; &#125;&#125;; https://discuss.leetcode.com/topic/16623/3-diffrent-c-solutions-each-one-costs-8ms 3 diffrent C++ solutions, each one costs 8ms. First one: check from strs[0][0] to strs[i][0]. If matches, check strs[0][1] to strs[i][1]. Code: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=&quot;&quot;; int max=INT_MAX; for(auto&amp; s:strs) &#123; max=(max&gt;s.length())?s.length():max; &#125; for(int i=0;i&lt;max;i++) &#123; bool flag=true; char x=strs[0][i]; for(auto&amp; s:strs) &#123; if(s[i]!=x) &#123; flag=false; break; &#125; &#125; if(flag==false) return ans; ans+=x; &#125; return ans; &#125;&#125;; Second one: assume the prefix is strs[0]. Compair with strs[i], and cut the letters which don’t match. Code: 1234567891011121314151617181920212223class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return &quot;&quot;; string ans=strs[0]; int max=INT_MAX; for(auto&amp; s:strs) &#123; if(s.length()==0) return &quot;&quot;; int i=0; for(i=0;i&lt;ans.length()&amp;&amp;i&lt;s.length();i++) &#123; if(s[i]!=ans[i]) break; &#125; ans=ans.substr(0,i); &#125; return ans; &#125;&#125;; Third one: use a Trie data structure to save the strs. Search the trie, and stops when a TrieNode has more than one son. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879Code:class TrieNode&#123;public: bool val; TrieNode* next[52]; int sons; TrieNode() :val(false), sons(0) &#123; for (int i = 0; i &lt; 52; i++) next[i] = nullptr; &#125;&#125;;class Trie&#123;private: TrieNode* putst(string&amp; s, TrieNode * node, int loc, TrieNode *father) &#123; if (s.length() == 0) &#123; node-&gt;val = true; node-&gt;sons++; return node; &#125; if (node == nullptr) &#123; node = new TrieNode(); if (father != nullptr) father-&gt;sons++; &#125; if (loc == s.length()) &#123; node-&gt;val = true; return node; &#125; if (s[loc] &gt;= &apos;a&apos;) node-&gt;next[s[loc] - &apos;a&apos;] = putst(s, node-&gt;next[s[loc] - &apos;a&apos;], loc + 1, node); else node-&gt;next[s[loc] - &apos;A&apos; + 26] = putst(s, node-&gt;next[s[loc] - &apos;A&apos; + 26], loc + 1, node); return node; &#125;public: TrieNode *root; void insert(string &amp; str)&#123; putst(str, root, 0, nullptr); &#125; Trie()&#123; root = new TrieNode(); &#125;&#125;;class Solution &#123;private: string findPre(TrieNode * node) &#123; if (node == nullptr || (node != nullptr&amp;&amp;node-&gt;sons &gt; 1)) return string(&quot;&quot;); int i = 0; for (i = 0; i &lt; 52; i++) &#123; if (node-&gt;next[i] != nullptr) break; &#125; if (i == 52) return string(&quot;&quot;); char temp1 = ((i&gt;25) ? (&apos;A&apos; + i) : (&apos;a&apos; + i)); string temp; temp.insert(temp.begin(), temp1); if (node-&gt;val) &#123; return string(&quot;&quot;); &#125; else &#123; return temp + findPre(node-&gt;next[i]); &#125; &#125;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; Trie a; for (auto&amp; str : strs) a.insert(str); return findPre(a.root); &#125;&#125;; python https://discuss.leetcode.com/topic/6308/simple-python-solution Simple Python solution 62ms, September 19, 2016 Might be a bit slow, but here’s my relatively elegant Python solution: 1234567891011121314class Solution(object): def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str] :rtype: str &quot;&quot;&quot; if not strs: return &apos;&apos; for i, letter_group in enumerate(zip(*strs)): if len(set(letter_group)) &gt; 1: return strs[0][:i] return min(strs) https://discuss.leetcode.com/topic/6308/simple-python-solution/2 Nice use of zip. Here’s my version, it ran in 58 ms. I was proud of myself for using reduce() appropriately: 123456789101112131415161718class Solution: def lcp(self, str1, str2): i = 0 while (i &lt; len(str1) and i &lt; len(str2)): if str1[i] == str2[i]: i = i+1 else: break return str1[:i] # @return a string def longestCommonPrefix(self, strs): if not strs: return &apos;&apos; else: return reduce(self.lcp,strs) https://discuss.leetcode.com/topic/27094/5-line-python-with-zip-and-len-set 5 line python with zip() and len(set()) Just for fun :) 1234567891011class Solution(object): def longestCommonPrefix(self, strs): &quot;&quot;&quot; :type strs: List[str]; rtype: str &quot;&quot;&quot; sz, ret = zip(*strs), &quot;&quot; # looping corrected based on @StefanPochmann&apos;s comment below for c in sz: if len(set(c)) &gt; 1: break ret += c[0] return ret https://discuss.leetcode.com/topic/21222/already-implemented-in-python Already implemented in Python 1234567import osclass Solution: # @param &#123;string[]&#125; strs # @return &#123;string&#125; def longestCommonPrefix(self, strs): return os.path.commonprefix(strs) java https://discuss.leetcode.com/topic/6987/java-code-with-13-lines Java code with 13 lines 1234567891011public String longestCommonPrefix(String[] strs) &#123; if(strs == null || strs.length == 0) return &quot;&quot;; String pre = strs[0]; int i = 1; while(i &lt; strs.length)&#123; while(strs[i].indexOf(pre) != 0) pre = pre.substring(0,pre.length()-1); i++; &#125; return pre;&#125; https://discuss.leetcode.com/topic/6987/java-code-with-13-lines/6 Since you seem to value the number of lines, why didn’t you use a for-loop? It saves three lines. 12345678public String longestCommonPrefix(String[] strs) &#123; if (strs.length == 0) return &quot;&quot;; String pre = strs[0]; for (int i = 1; i &lt; strs.length; i++) while(strs[i].indexOf(pre) != 0) pre = pre.substring(0,pre.length()-1); return pre;&#125; https://discuss.leetcode.com/topic/27913/sorted-the-array-java-solution-2-ms Sorted the array, Java solution, 2 ms Sort the array first, and then you can simply compare the first and last elements in the sorted array. 1234567891011121314151617181920public String longestCommonPrefix(String[] strs) &#123; StringBuilder result = new StringBuilder(); if (strs!= null &amp;&amp; strs.length &gt; 0)&#123; Arrays.sort(strs); char [] a = strs[0].toCharArray(); char [] b = strs[strs.length-1].toCharArray(); for (int i = 0; i &lt; a.length; i ++)&#123; if (b.length &gt; i &amp;&amp; b[i] == a[i])&#123; result.append(b[i]); &#125; else &#123; return result.toString(); &#125; &#125; return result.toString();&#125; https://discuss.leetcode.com/topic/12173/fast-and-simple-java-code-231ms Fast and simple Java code 231ms 1234567891011121314public class Solution &#123; public String longestCommonPrefix(List&lt;String&gt; strs) &#123; if(strs.size()==0) return &quot;&quot;; StringBuilder lcp=new StringBuilder(); for(int i=0;i&lt;strs.get(0).length();i++)&#123; char c=strs.get(0).charAt(i); for(String s:strs)&#123; if(s.length()&lt;i+1||c!=s.charAt(i)) return lcp.toString(); &#125; lcp.append(c); &#125; return lcp.toString(); &#125;&#125; https://discuss.leetcode.com/topic/40472/java-we-love-clear-code Java —— We Love Clear Code! 123456789101112public String longestCommonPrefix(String[] strs) &#123; if (strs == null) return null; if (strs.length == 0) return &quot;&quot;; Arrays.sort(strs); char[] first = strs[0].toCharArray(); char[] last = strs[strs.length - 1].toCharArray(); int i = 0, len = Math.min(first.length, last.length); while (i &lt; len &amp;&amp; first[i] == last[i]) i++; return strs[0].substring(0, i);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[013. Roman to Integer]]></title>
    <url>%2Fp%2F850f821a%2F</url>
    <content type="text"><![CDATA[46.0% https://leetcode.com/problems/roman-to-integer/ Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 方法一: 从后向前遍历，如果当前值大于右边，加上当前值，如果当前值小于右边，减去当前值。 https://leetcode.com/discuss/22867/clean-o-n-c-solution Clean O(n) c++ solution 80ms, 7.24%, May.4th, 2016 Problem is simpler to solve by working the string from back to front and using a map. Runtime speed is 88 ms. 12345678910111213141516class Solution &#123;public: int romanToInt(string s) &#123; unordered_map&lt;char, int&gt; T = &#123;&#123; &apos;I&apos;, 1&#125;, &#123;&apos;V&apos;, 5&#125;, &#123;&apos;X&apos;, 10&#125;, &#123;&apos;L&apos;, 50&#125;, &#123;&apos;C&apos;, 100&#125;, &#123;&apos;D&apos;, 500&#125;, &#123;&apos;M&apos;, 1000&#125;&#125;; int sum = T[s.back()]; for(int i = s.length() - 2; i &gt;= 0; --i)&#123; if(T[s[i]] &lt; T[s[i + 1]]) sum -= T[s[i]]; else sum += T[s[i]]; &#125; return sum; &#125;&#125;; 我的代码实现： 123456789101112131415161718class Solution &#123;public: int romanToInt(string s) &#123; int n = s.size(); if(n==0) return 0; // 学习map的初始化 map&lt;char, int&gt; map = &#123;&#123;'I',1&#125;, &#123;'V', 5&#125;, &#123;'X', 10&#125;, &#123;'L', 50&#125;, &#123;'C', 100&#125;, &#123;'D', 500&#125;, &#123;'M', 1000&#125;&#125;; int res = map[s[n-1]]; // 逆向思考问题，有时更容易解决 for(int i=n-2; i&gt;=0; i--) if(map[s[i]] &gt;= map[s[i+1]]) res += map[s[i]]; else res -= map[s[i]]; return res; &#125;&#125;; https://discuss.leetcode.com/topic/6127/my-easy-to-understand-c-solutions My easy-to-understand C++ solutions 1234567891011121314151617181920212223242526272829class Solution &#123;public: int romanToInt(string s) &#123; int num = 0; int size = s.size(); for (int i = 0; i &lt; size; i++) &#123; if (i &lt; (size - 1) &amp;&amp; romanCharToInt(s[i]) &lt; romanCharToInt(s[i + 1])) &#123; num -= romanCharToInt(s[i]); &#125; else &#123; num += romanCharToInt(s[i]); &#125; &#125; return num; &#125; int romanCharToInt(char c) &#123; switch (c) &#123; case &apos;I&apos;: return 1; case &apos;V&apos;: return 5; case &apos;X&apos;: return 10; case &apos;L&apos;: return 50; case &apos;C&apos;: return 100; case &apos;D&apos;: return 500; case &apos;M&apos;: return 1000; default: return 0; &#125; &#125;&#125;; The code is faster if the body of the for loop is replaced with: 12345678if (i &lt; (size - 1) &amp;&amp; ( &apos;I&apos; == s[i] &amp;&amp; (&apos;V&apos; == s[i + 1] || &apos;X&apos; == s[i + 1]) || &apos;X&apos; == s[i] &amp;&amp; (&apos;L&apos; == s[i + 1] || &apos;C&apos; == s[i + 1]) || &apos;C&apos; == s[i] &amp;&amp; (&apos;D&apos; == s[i + 1] || &apos;M&apos; == s[i + 1]) )) &#123; num -= romanCharToInt(s[i]);&#125; else &#123; num += romanCharToInt(s[i]);&#125; https://discuss.leetcode.com/topic/15224/simple-56ms-c-solution Simple 56ms C++ solution Processing the roman number from right to left turns out to be a bit easier since we can easily tell when to add or subtract: 123456789101112class Solution &#123;public: int romanToInt(string s) &#123; if (s.empty()) &#123; return 0; &#125; unordered_map&lt;char, int&gt; mp &#123; &#123;&apos;I&apos;, 1&#125;, &#123;&apos;V&apos;, 5&#125;, &#123;&apos;X&apos;, 10&#125;, &#123;&apos;L&apos;, 50&#125;, &#123;&apos;C&apos;, 100&#125;, &#123;&apos;D&apos;, 500&#125;, &#123;&apos;M&apos;, 1000&#125; &#125;; int sum = mp[s.back()]; for (int i = s.size() - 2; i &gt;= 0; --i) &#123; sum += mp[s[i]] &gt;= mp[s[i + 1]] ? mp[s[i]] : -mp[s[i]]; &#125; return sum; &#125;&#125;; https://discuss.leetcode.com/topic/30205/i-strongly-suggest-leetcode-explains-the-conversion-rule-clearer I strongly suggest leetcode explains the conversion rule clearer. It would help a lot for those who are not familiar with Roman numerals if the conversion rule is provided, or a conversion table similar to Roman Numerals Chart is given. python https://discuss.leetcode.com/topic/17110/my-straightforward-python-solution My Straightforward Python Solution 123456789101112class Solution:# @param &#123;string&#125; s# @return &#123;integer&#125;def romanToInt(self, s): roman = &#123;&apos;M&apos;: 1000,&apos;D&apos;: 500 ,&apos;C&apos;: 100,&apos;L&apos;: 50,&apos;X&apos;: 10,&apos;V&apos;: 5,&apos;I&apos;: 1&#125; z = 0 for i in range(0, len(s) - 1): if roman[s[i]] &lt; roman[s[i+1]]: z -= roman[s[i]] else: z += roman[s[i]] return z + roman[s[-1]] *Note: The trick is that the last letter is always added. Except the last one, if one letter is less than its latter one, this letter is subtracted. https://discuss.leetcode.com/topic/47179/4-lines-in-python 4 lines in Python d = {‘M’:1000, ‘D’:500, ‘C’:100, ‘L’:50, ‘X’:10, ‘V’:5, ‘I’:1} 12345def romanToInt(self, s): res, p = 0, &apos;I&apos; for c in s[::-1]: res, p = res - d[c] if d[c] &lt; d[p] else res + d[c], c return res https://leetcode.com/discuss/21888/python-solution Python solution 160ms, 85.18%, May.4th, 2016 12345678910111213141516171819class Solution(object): def romanToInt(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; romans = &#123;&apos;M&apos;:1000, &apos;D&apos;:500, &apos;C&apos;:100, &apos;L&apos;:50, &apos;X&apos;:10, &apos;V&apos;:5, &apos;I&apos;:1&#125; prev_value = running_total = 0 for i in xrange(len(s)-1, -1, -1): int_val = romans[s[i]] if int_val &lt; prev_value: running_total -= int_val else: running_total += int_val prev_value = int_val return running_total java https://discuss.leetcode.com/topic/821/my-solution-for-this-question-but-i-don-t-know-is-there-any-easier-way My solution for this question but I don’t know is there any easier way? count every Symbol and add its value to the sum, and minus the extra part of special cases. 1234567891011121314151617181920212223242526public int romanToInt(String s) &#123; int sum=0; if(s.indexOf(&quot;IV&quot;)!=-1)&#123;sum-=2;&#125; if(s.indexOf(&quot;IX&quot;)!=-1)&#123;sum-=2;&#125; if(s.indexOf(&quot;XL&quot;)!=-1)&#123;sum-=20;&#125; if(s.indexOf(&quot;XC&quot;)!=-1)&#123;sum-=20;&#125; if(s.indexOf(&quot;CD&quot;)!=-1)&#123;sum-=200;&#125; if(s.indexOf(&quot;CM&quot;)!=-1)&#123;sum-=200;&#125; char c[]=s.toCharArray(); int count=0; for(;count&lt;=s.length()-1;count++)&#123; if(c[count]==&apos;M&apos;) sum+=1000; if(c[count]==&apos;D&apos;) sum+=500; if(c[count]==&apos;C&apos;) sum+=100; if(c[count]==&apos;L&apos;) sum+=50; if(c[count]==&apos;X&apos;) sum+=10; if(c[count]==&apos;V&apos;) sum+=5; if(c[count]==&apos;I&apos;) sum+=1; &#125; return sum; &#125; https://leetcode.com/discuss/2369/solution-for-this-question-but-dont-know-there-any-easier-way/2 6ms, 97.91%, May.4th, 2016 My solution, only scan string once 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public int romanToInt(String s) &#123; int res = 0; for(int i = s.length() - 1; i &gt;= 0; i--)&#123; char c = s.charAt(i); switch(c)&#123; case &apos;I&apos;: res += (res &gt;= 5 ? -1 : 1); break; case &apos;V&apos;: res += 5; break; case &apos;X&apos;: res += 10 * (res &gt;= 50 ? -1 : 1); break; case &apos;L&apos;: res += 50; break; case &apos;C&apos;: res += 100 * (res &gt;= 500 ? -1 : 1); break; case &apos;D&apos;: res += 500; break; case &apos;M&apos;: res += 1000; break; &#125; &#125; return res; &#125;&#125; https://discuss.leetcode.com/topic/821/my-solution-for-this-question-but-i-don-t-know-is-there-any-easier-way/3 My solution, scan string once from tail to head. If s[i]’s corresponding integer is no less than the previous one, add it to the result; otherwise, subtract it from the result. 1234567891011121314151617181920int romanToInt(string s) &#123; unordered_map&lt;char, int&gt; charToInt = &#123; &#123; &apos;I&apos;, 1 &#125;, &#123; &apos;V&apos;, 5 &#125;, &#123; &apos;X&apos;, 10 &#125;, &#123; &apos;L&apos;, 50 &#125;, &#123; &apos;C&apos;, 100 &#125;, &#123; &apos;D&apos;, 500 &#125;, &#123; &apos;M&apos;, 1000 &#125; &#125;; int result = 0; int index = s.length() - 1; int preInt = 0; while (index &gt;= 0) &#123; char ch = s[index]; int curInt = charToInt[ch]; if (curInt &gt;= preInt) result += curInt; else result -= curInt; preInt = curInt; index--; &#125; return result;&#125; https://discuss.leetcode.com/topic/28471/7ms-solution-in-java-easy-to-understand 7ms solution in Java. easy to understand 123456789101112131415161718192021222324252627282930313233343536public int romanToInt(String s) &#123; int nums[]=new int[s.length()]; for(int i=0;i&lt;s.length();i++)&#123; switch (s.charAt(i))&#123; case &apos;M&apos;: nums[i]=1000; break; case &apos;D&apos;: nums[i]=500; break; case &apos;C&apos;: nums[i]=100; break; case &apos;L&apos;: nums[i]=50; break; case &apos;X&apos; : nums[i]=10; break; case &apos;V&apos;: nums[i]=5; break; case &apos;I&apos;: nums[i]=1; break; &#125; &#125; int sum=0; for(int i=0;i&lt;nums.length-1;i++)&#123; if(nums[i]&lt;nums[i+1]) sum-=nums[i]; else sum+=nums[i]; &#125; return sum+nums[nums.length-1];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>easy</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[012. Integer to Roman]]></title>
    <url>%2Fp%2F7da1ea45%2F</url>
    <content type="text"><![CDATA[45.0% https://leetcode.com/problems/integer-to-roman/ Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 方法一： 48ms, 15.75%, May.4th, 2016 12345678910class Solution &#123;public: string intToRoman(int num) &#123; vector&lt;string&gt;M&#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125;; vector&lt;string&gt;C&#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;; vector&lt;string&gt;X&#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;; vector&lt;string&gt;I&#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;; return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10]; &#125;&#125;; https://discuss.leetcode.com/topic/7061/sharing-my-really-simple-solution-with-explanation Sharing my really simple solution with explanation 12345678910111213141516string intToRoman(int num) &#123; string table[4][10] = &#123;&#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;, &#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;, &#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;, &#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125; &#125;; string result; int count = 0; while(num &gt; 0)&#123; int temp = num % 10; result = table[count][temp] + result; num /= 10; count++; &#125; return result;&#125; The basic idea is really simple: replace every digit in num by roman numerals. For example, we have a num: 2438. 2 –&gt; “MM” 4 –&gt; “CD” 3 –&gt; “XXX” 8 –&gt; “VIII” Then the result is “MMCDXXXVIII”. python https://discuss.leetcode.com/topic/32333/share-my-python-solution-96ms Share My Python Solution 96ms 124ms, 69.84%, May.4th, 2016 1234567891011class Solution(object): def intToRoman(self, num): &quot;&quot;&quot; :type num: int :rtype: str &quot;&quot;&quot; M = [&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;] C = [&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;] X = [&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;] I = [&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;] return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10] java https://leetcode.com/discuss/32626/simple-solution Simple Solution 10ms, 34.15%, 3999 / 3999, May.4th, 2016 123456789public class Solution &#123; public String intToRoman(int num) &#123; String M[] = &#123;&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;&#125;; String C[] = &#123;&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;&#125;; String X[] = &#123;&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;&#125;; String I[] = &#123;&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;&#125;; return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10]; &#125;&#125; https://discuss.leetcode.com/topic/20510/my-java-solution-easy-to-understand My java solution easy to understand Reference: http://blog.csdn.net/beiyeqingteng/article/details/8547565 1234567891011121314151617public class Solution &#123;public String intToRoman(int num) &#123; int[] values = &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; String[] strs = &#123;&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;&#125;; StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;values.length;i++) &#123; while(num &gt;= values[i]) &#123; num -= values[i]; sb.append(strs[i]); &#125; &#125; return sb.toString();&#125;&#125; https://discuss.leetcode.com/topic/20510/my-java-solution-easy-to-understand/3 Your function is not really optimal because you will ALWAYS iterate until the end of your values array even if your number becomes zero! Which is not optimal at all. In addition to that you didn’t even check if the input number has a valid roman representation. You had to check that (even if the exercice assumes that the number has it already), you can do that easily with one line. Here is an improvement of your function : 12345678910111213141516171819public static String intToRoman(int num)&#123; if (num &lt; 1 || num &gt; 3999) return &quot;&quot;; StringBuilder result = new StringBuilder(); String[] roman = &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;; int[] values = &#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 &#125;; int i = 0; //iterate until the number becomes zero, NO NEED to go until the last element in roman array while (num &gt;0) &#123; while ( num &gt;= values[i]) &#123; num -= values[i]; result.append(roman[i]); &#125; i++; &#125; return result.toString();&#125; As you see, you add just a simple line and you win an optimisation since the code will stop if the current number becomes zero (instead of doing additionnal iterations in the roman array). https://discuss.leetcode.com/topic/26543/easy-to-understand-java-solution Easy to understand Java solution 1234567891011121314151617public enum Type&#123; M(1000),CM(900),D(500),CD(400),C(100),XC(90),L(50),XL(40),X(10),IX(9),V(5),IV(4),I(1); private final int value; Type(int value) &#123; this.value = value; &#125;&#125;;public String intToRoman(int num) &#123; StringBuilder output = new StringBuilder(); for (Type t:Type.values()) &#123; while (num&gt;=t.value) &#123; output.append(t); num -= t.value; &#125; &#125; return output.toString();&#125; https://discuss.leetcode.com/topic/2858/share-my-iterative-solution Share my iterative Solution 1234567891011121314151617public String intToRoman(int num) &#123; int[] weights=&#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; String[] tokens=&#123;&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;&#125;; StringBuilder rs=new StringBuilder(&quot;&quot;); int start=0; while(num&gt;0)&#123; for(int i=start;i&lt;13;i++)&#123; if(num&gt;=weights[i])&#123; num-=weights[i]; rs.append(tokens[i]); break; &#125; start=i+1; // skip those impossible check, make it faster &#125; &#125; return rs.toString();&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[011. Container With Most Water]]></title>
    <url>%2Fp%2F971339dc%2F</url>
    <content type="text"><![CDATA[36.2% https://leetcode.com/problems/container-with-most-water/ Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container. https://discuss.leetcode.com/topic/29962/for-someone-who-is-not-so-clear-on-this-question For someone who is not so clear on this question 12345678910test y ^ | | a2 | | a3 an | a1 | | a5 | | | | | a4 | | | | | | | | .. | ---------------------------&gt; 0 1 2 3 4 5 .. n x For someone who is not clear on this question. It’s not like “https://leetcode.com/problems/trapping-rain-water/ “ Which is to get the total water for all the bars problem, It actually is to find the any 2 bars ai, aj, which hold most water together with x-axis. This post give a very good detail explanation as well. https://leetcode.com/discuss/37631/simple-and-clear-proof-explanation 方法一： 双指针 https://leetcode.com/discuss/41527/simple-and-fast-c-c-with-explanation 24ms, 61.49%, June.20th, 2016 Start by evaluating the widest container, using the first and the last line. All other possible containers are less wide, so to hold more water, they need to be higher. Thus, after evaluating that widest container, skip lines at both ends that don’t support a higher height. Then evaluate that new container we arrived at. Repeat until there are no more possible containers left. C++ 1234567891011int maxArea(vector&lt;int&gt;&amp; height) &#123; int water = 0; int i = 0, j = height.size() - 1; while (i &lt; j) &#123; int h = min(height[i], height[j]); water = max(water, (j - i) * h); while (height[i] &lt;= h &amp;&amp; i &lt; j) i++; while (height[j] &lt;= h &amp;&amp; i &lt; j) j--; &#125; return water;&#125; 我的代码实现一： 12345678910111213141516class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int left = 0, right = height.size()-1; int maxArea=0, minHeight=0; // 要设置初始值，后续有max while(left&lt;right)&#123; minHeight = min(height[right], height[left]); // 使用max， 而不是直接等于(right-left)*minHeight,因为变化之后可能变小 // 因为不满足left&lt;right的情况 maxArea = max(maxArea, (right-left)*minHeight); while(left&lt;right &amp;&amp; height[left]&lt;=minHeight) left++; while(left&lt;right &amp;&amp; height[right]&lt;=minHeight) right--; &#125; return maxArea; &#125;&#125;; 我的代码实现二： 12345678910111213141516class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); if(n&lt;2) return 0; int left = 0, right = n-1; int res = 0, h = 0; while(left&lt;right)&#123; h = min(height[left], height[right]); res = max(res, h*(right-left)); while(left&lt;right &amp;&amp; height[left]&lt;=h) left++; while(left&lt;right &amp;&amp; height[right]&lt;=h) right--; &#125; return res; &#125;&#125;; https://discuss.leetcode.com/topic/3462/yet-another-way-to-see-what-happens-in-the-o-n-algorithm Yet another way to see what happens in the O(n) algorithm The O(n) solution with proof by contradiction doesn’t look intuitive enough to me. Before moving on, read the algorithm first if you don’t know it yet. Here’s another way to see what happens in a matrix representation: Draw a matrix where the row is the first line, and the column is the second line. For example, say n=6. In the figures below, x means we don’t need to compute the volume for that case: (1) On the diagonal, the two lines are overlapped; (2) The lower left triangle area of the matrix is symmetric to the upper right area. 123456789101112We start by computing the volume at (1,6), denoted by o. Now if the left line is shorter than the right line, then all the elements left to (1,6) on the first row have smaller volume, so we don&apos;t need to compute those cases (crossed by ---). 1 2 3 4 5 61 x ------- o2 x x3 x x x 4 x x x x5 x x x x x6 x x x x x x 1234567891011Next we move the left line and compute (2,6). Now if the right line is shorter, all cases below (2,6) are eliminated. 1 2 3 4 5 61 x ------- o2 x x o3 x x x |4 x x x x |5 x x x x x |6 x x x x x x 1234567891011And no matter how this o path goes, we end up only need to find the max value on this path, which contains n-1 cases. 1 2 3 4 5 61 x ------- o2 x x - o o o3 x x x o | |4 x x x x | |5 x x x x x |6 x x x x x x Hope this helps. I feel more comfortable seeing things this way. https://discuss.leetcode.com/topic/4552/very-simple-o-n-solution Very simple O(n) solution The idea is : to compute area, we need to take min(height[i],height[j]) as our height. Thus if height[i]&lt;height[j], then the expression min(height[i],height[j]) will always lead to at maximum height[i] for all other j(i being fixed), hence no point checking them. Similarly when height[i]&gt;height[j] then all the other i’s can be ignored for that particular j. 123456789101112131415161718class Solution &#123;public: int maxArea(vector&lt;int&gt; &amp;height) &#123; int j=height.size()-1,i=0,mx=0; while(i&lt;j) &#123; mx=max(mx,((j-i)*(min(height[i],height[j])))); if(height[i]&lt;height[j]) i++; else if(height[i]&gt;=height[j]) j--; &#125; return mx; &#125;&#125;; https://discuss.leetcode.com/topic/42122/c-o-n-solution-with-thought-process-applying-simple-bucket-theory C++ O(n) solution with thought process applying simple bucket theory The brute force solution can definitely lead us to the right answer just by doing too many redundant comparisons. When two pointer approach comes to mind, it is intuitive to set both pointers i, j at each end of this array, and move them strategically to the middle of array, update the answer during this process return the answer when we reach the end of array. Suppose now we have the scenarios below: 1237, 5, 6, 9i j When i = 1, j = 4, 1ans = min(7, 9) * (4 - 1) = 21 What’s next? Should we move i or j? We notice that to calculate the area, the height is really identified by the smaller number / shorter end between the two ends, since it’s required that you may not slant the water, so it sounds like Bucket theory: how much water a bucket can contain depends on the shortest plank. So, as to find the next potential maximum area, we disregard the shorter end by moving it to the next position. So in the above case, the next status is to move i to the left, 1237, 5, 6, 9 i j update: 12area (i, j) = area(2, 4) = min(5, 9) * (4 - 2) = 10ans = max(21, 10) = 21 You may notice that, if we move j instead, you actually get a larger area for length of 2: 1area (i, j) = area(1, 3) = min(7, 6) * (3 - 1) = 18 Does that mean this approach will not work? If you look at this way, we move pointer as to get the next potential max, so it doesn’t need to be the maximum for all combinations with length l. Even though 18 is greater than 10, it’s smaller than 21 right? So don’t worry, we can move on to find the next potential maximum result. Now we need to prove, why disregard the shorter end can safely lead us to the right answer by doing a little maths. 12Given an array: a1, a2, a3, a4, ai, ......, aj, ......, an i j Assume the maximum area so far is ans, we prove that 12&quot;By moving shorter end pointer further doesn&apos;t eliminate the final answer (with two ends at maxi, maxj respectively) in our process&quot; Suppose we have two ends at (i, j) respectively at this moment: (i) If the final answer equals what we have already achieved, it’s done! In this scenario, we must have 1maxi &lt;= i, maxj &gt;= j (ii) Otherwise, we know as we move any pointer further, the length of the next rectangle decreases, so the height needs to increase as to result in a larger area. So we have 1min(height[maxi], height[maxj]) &gt; min(height[i], height[j]) So the smaller one in height[i], height[j] won’t become any end in the maximum rectangle, so it’s safe to move forward without it. Till now, it has been proved that this approach can work in O(n) time since we advance one end towards the middle in each iteration, and update ans takes constant time in each iteration. 12345678910111213class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int ans = 0; int i = 0, j = height.size() - 1; while(i &lt; j)&#123; ans = max(ans, (j - i) * min(height[i], height[j])); height[i] &gt; height[j] ? j-- : i++; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/12843/my-short-and-easy-c-code-in-o-n My short and easy c++ code in O(n) 12345678910111213class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int i=0,j=height.size()-1,ans = 0; while(j&gt;i) &#123; ans = max(min(height[i],height[j])*(j-i),ans); if(height[i]&gt;height[j]) j--; else i++; &#125; return ans; &#125;&#125;; python https://discuss.leetcode.com/topic/14940/simple-and-clear-proof-explanation Simple and clear proof/explanation I’ve seen some “proofs” for the common O(n) solution, but I found them very confusing and lacking. Some even didn’t explain anything but just used lots of variables and equations and were like “Tada! See?”. I think mine makes more sense: Idea / Proof: The widest container (using first and last line) is a good candidate, because of its width. Its water level is the height of the smaller one of first and last line.All other containers are less wide and thus would need a higher water level in order to hold more water.The smaller one of first and last line doesn’t support a higher water level and can thus be safely removed from further consideration. Further explanation: Variables i and j define the container under consideration. We initialize them to first and last line, meaning the widest container. Variable water will keep track of the highest amount of water we managed so far. We compute j - i, the width of the current container, and min(height[i], height[j]), the water level that this container can support. Multiply them to get how much water this container can hold, and update water accordingly. Next remove the smaller one of the two lines from consideration, as justified above in “Idea / Proof”. Continue until there is nothing left to consider, then return the result. Implementation: (Python) 1234567891011class Solution: def maxArea(self, height): i, j = 0, len(height) - 1 water = 0 while i &lt; j: water = max(water, (j - i) * min(height[i], height[j])) if height[i] &lt; height[j]: i += 1 else: j -= 1 return water java https://discuss.leetcode.com/topic/25004/easy-concise-java-o-n-solution-with-proof-and-explanation Easy Concise Java O(N) Solution with Proof and Explanation AKA, the general idea to find some max is to go through all cases where max value can possibly occur and keep updating the max value. The efficiency of the scan depends on the size of cases you plan to scan.To increase efficiency, all we need to do is to find a smart way of scan to cut off the useless cases and meanwhile 100% guarantee the max value can be reached through the rest of cases. In this problem, the smart scan way is to set two pointers initialized at both ends of the array. Every time move the smaller value pointer to inner array. Then after the two pointers meet, all possible max cases have been scanned and the max situation is 100% reached somewhere in the scan. Following is a brief prove of this. Given a1,a2,a3…..an as input array. Lets assume a10 and a20 are the max area situation. We need to prove that a10 can be reached by left pointer and during the time left pointer stays at a10, a20 can be reached by right pointer. That is to say, the core problem is to prove: when left pointer is at a10 and right pointer is at a21, the next move must be right pointer to a20. Since we are always moving the pointer with the smaller value, i.e. if a10 &gt; a21, we should move pointer at a21 to a20, as we hope. Why a10 &gt;a21? Because if a21&gt;a10, then area of a10 and a20 must be less than area of a10 and a21. Because the area of a10 and a21 is at least height[a10] (21-10) while the area of a10 and a20 is at most height[a10] (20-10). So there is a contradiction of assumption a10 and a20 has the max area. So, a10 must be greater than a21, then next move a21 has to be move to a20. The max cases must be reached. 123456789101112131415public int maxArea(int[] height) &#123; int left = 0, right = height.length - 1; int maxArea = 0; while (left &lt; right) &#123; maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left)); if (height[left] &lt; height[right]) left++; else right--; &#125; return maxArea;&#125; https://discuss.leetcode.com/topic/33498/java-3ms-solution-with-step-by-step-explanations-beats-85 Java 3ms solution with step-by-step explanations (beats 85%) It took me quite some time to finally optimize my solution from 21ms to 3ms :( If you have difficulty understanding the following code, check this link for a detailed explanation. 12345678910111213141516public int maxArea(int[] height) &#123; int L = height.length, lo = 0, hi = L-1; int max = 0; while(lo&lt;hi) &#123; int loMax = height[lo], hiMax = height[hi]; int candidate = (hi-lo) * (loMax&lt;hiMax ? loMax : hiMax); max = candidate &gt; max ? candidate : max; if(height[lo]&lt;=height[hi]) while(lo&lt;hi &amp;&amp; height[lo]&lt;=loMax) ++lo; else while(hi&gt;lo &amp;&amp; height[hi]&lt;=hiMax) --hi; &#125; return max;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[010. Regular Expression Matching]]></title>
    <url>%2Fp%2F34b0b346%2F</url>
    <content type="text"><![CDATA[23.9% https://leetcode.com/problems/regular-expression-matching/ 123456789101112131415161718Implement regular expression matching with support for &apos;.&apos; and &apos;*&apos;.&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;aa&quot;, &quot;.*&quot;) → trueisMatch(&quot;ab&quot;, &quot;.*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true 方法一： 优先考虑递归 递归方法 学习string的substr的用法 My concise recursive and DP solutions with full explanation in C++ Please refer to my blog post if you have any comment. Wildcard matching problem can be solved similarly. 12345678910111213class Solution &#123;public: bool isMatch(string s, string p) &#123; if (p.empty()) return s.empty(); if (&apos;*&apos; == p[1]) // x* matches empty string or at least one character: x* -&gt; xx* // *s is to ensure s is non-empty return (isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p)); else return !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; my code: 12345678910class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.empty()) return s.empty(); if(p.size()&gt;1 &amp;&amp; p[1]==&apos;*&apos;)&#123; return isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0]==p[0] || p[0]==&apos;.&apos;) &amp;&amp; isMatch(s.substr(1), p); &#125;else return !s.empty() &amp;&amp; (s[0]==p[0] || p[0]==&apos;.&apos;) &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; 我的代码实现二: 12345678910class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.empty()) return s.empty(); if(p.size()&gt;1 &amp;&amp; p[1]=='*') return isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0]==p[0] || p[0]=='.') &amp;&amp; isMatch(s.substr(1), p); // 要检查s是否为空，不能忘记 return !s.empty() &amp;&amp; (s[0]==p[0] || p[0]=='.') &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; 方法二： dp mn 设置(m+1) (n+1)的长度，多的一行表示空的时候的结果。 经常有上述做法。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: bool isMatch(string s, string p) &#123; /** * f[i][j]: if s[0..i-1] matches p[0..j-1] * if p[j - 1] != &apos;*&apos; * f[i][j] = f[i - 1][j - 1] &amp;&amp; s[i - 1] == p[j - 1] * if p[j - 1] == &apos;*&apos;, denote p[j - 2] with x * f[i][j] is true iff any of the following is true * 1) &quot;x*&quot; repeats 0 time and matches empty: f[i][j - 2] * 2) &quot;x*&quot; repeats &gt;= 1 times and matches &quot;x*x&quot;: s[i - 1] == x &amp;&amp; f[i - 1][j] * &apos;.&apos; matches any single character */ int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; f(m + 1, vector&lt;bool&gt;(n + 1, false)); f[0][0] = true; for (int i = 1; i &lt;= m; i++) f[i][0] = false; // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is &apos;*&apos; and p[0..j - 3] matches empty for (int j = 1; j &lt;= n; j++) f[0][j] = j &gt; 1 &amp;&amp; &apos;*&apos; == p[j - 1] &amp;&amp; f[0][j - 2]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (p[j - 1] != &apos;*&apos;) f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || &apos;.&apos; == p[j - 1]); else // p[0] cannot be &apos;*&apos; so no need to check &quot;j &gt; 1&quot; here f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || &apos;.&apos; == p[j - 2]) &amp;&amp; f[i - 1][j]; return f[m][n]; &#125;&#125;; 我的代码实现 : 与方法一类似 都是每次要么增长s，要么增长p 以当前位置是否为*作为判断条件 1234567891011121314151617181920class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.empty()) return s.empty(); int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m+1, vector&lt;bool&gt;(n+1, false)); dp[0][0] = true; for(int i=2; i&lt;=n; i++) dp[0][i] = p[i-1]=='*' &amp;&amp; dp[0][i-2]; for(int i=1; i&lt;=m; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; if(p[j-1]=='*') dp[i][j] = dp[i][j-2] || dp[i-1][j] &amp;&amp; (s[i-1]==p[j-2] || p[j-2]=='.'); else dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]=='.'); &#125; &#125; return dp[m][n]; &#125;&#125;; 相似题目：正则表达式匹配请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 方法一： 使用递归 123456789101112131415161718192021222324class Solution &#123;public: bool match(char* str, char* pattern) &#123; if(str==NULL || pattern==NULL) return false; return helper(str, pattern); &#125; bool helper(char* str, char* pattern)&#123; if(*str==&apos;\0&apos; &amp;&amp; *pattern==&apos;\0&apos;) return true; if(*str!=&apos;\0&apos; &amp;&amp; *pattern==&apos;\0&apos;) return false; if(*(pattern+1)==&apos;*&apos;)&#123; if(*pattern==*str || (*pattern==&apos;.&apos; &amp;&amp; *str!=&apos;\0&apos;))&#123; return helper(str+1, pattern+2) || helper(str+1, pattern) || helper(str, pattern+2); &#125;else&#123; return helper(str, pattern+2); &#125; &#125; if(*str==*pattern || (*pattern==&apos;.&apos; &amp;&amp; *str!=&apos;\0&apos;)) return helper(str+1, pattern+1); return false; &#125;&#125;; https://discuss.leetcode.com/topic/6183/my-concise-recursive-and-dp-solutions-with-full-explanation-in-c My concise recursive and DP solutions with full explanation in C++ Please refer to my blog post if you have any comment. Wildcard matching problem can be solved similarly. 递归方法 12345678910111213class Solution &#123;public: bool isMatch(string s, string p) &#123; if (p.empty()) return s.empty(); if (&apos;*&apos; == p[1]) // x* matches empty string or at least one character: x* -&gt; xx* // *s is to ensure s is non-empty return (isMatch(s, p.substr(2)) || !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p)); else return !s.empty() &amp;&amp; (s[0] == p[0] || &apos;.&apos; == p[0]) &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;; dp： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: bool isMatch(string s, string p) &#123; /** * f[i][j]: if s[0..i-1] matches p[0..j-1] * if p[j - 1] != &apos;*&apos; * f[i][j] = f[i - 1][j - 1] &amp;&amp; s[i - 1] == p[j - 1] * if p[j - 1] == &apos;*&apos;, denote p[j - 2] with x * f[i][j] is true iff any of the following is true * 1) &quot;x*&quot; repeats 0 time and matches empty: f[i][j - 2] * 2) &quot;x*&quot; repeats &gt;= 1 times and matches &quot;x*x&quot;: s[i - 1] == x &amp;&amp; f[i - 1][j] * &apos;.&apos; matches any single character */ int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; f(m + 1, vector&lt;bool&gt;(n + 1, false)); f[0][0] = true; for (int i = 1; i &lt;= m; i++) f[i][0] = false; // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is &apos;*&apos; and p[0..j - 3] matches empty for (int j = 1; j &lt;= n; j++) f[0][j] = j &gt; 1 &amp;&amp; &apos;*&apos; == p[j - 1] &amp;&amp; f[0][j - 2]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (p[j - 1] != &apos;*&apos;) f[i][j] = f[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || &apos;.&apos; == p[j - 1]); else // p[0] cannot be &apos;*&apos; so no need to check &quot;j &gt; 1&quot; here f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || &apos;.&apos; == p[j - 2]) &amp;&amp; f[i - 1][j]; return f[m][n]; &#125;&#125;; 16ms, 60.02%, September 21, 2016 https://discuss.leetcode.com/topic/17852/9-lines-16ms-c-dp-solutions-with-explanations 9-lines 16ms C++ DP Solutions with Explanations This problem has a typical solution using Dynamic Programming. We define the state P[i][j] to be true if s[0..i) matches p[0..j) and false otherwise. Then the state equations are: P[i][j] = P[i - 1][j - 1], if p[j - 1] != ‘*’ &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == ‘.’); P[i][j] = P[i][j - 2], if p[j - 1] == ‘*’ and the pattern repeats for 0 times; P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == ‘.’), if p[j - 1] == ‘*’ and the pattern repeats for at least 1 times. Putting these together, we will have the following code. 1234567891011121314class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.length(), n = p.length(); vector&lt;vector&lt;bool&gt; &gt; dp(m + 1, vector&lt;bool&gt; (n + 1, false)); dp[0][0] = true; for (int i = 0; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (p[j - 1] == &apos;*&apos;) dp[i][j] = dp[i][j - 2] || (i &gt; 0 &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == &apos;.&apos;) &amp;&amp; dp[i - 1][j]); else dp[i][j] = i &gt; 0 &amp;&amp; dp[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;.&apos;); return dp[m][n]; &#125;&#125;; https://discuss.leetcode.com/topic/2818/the-shortest-ac-code The shortest AC code. 1.’.’ is easy to handle. if p has a ‘.’, it can pass any single character in s except ‘\0’. 2.’’ is a totally different problem. if p has a ‘’ character, it can pass any length of first-match characters in s including ‘\0’. 12345678910111213141516171819class Solution &#123; public: bool matchFirst(const char *s, const char *p)&#123; return (*p == *s || (*p == &apos;.&apos; &amp;&amp; *s != &apos;\0&apos;)); &#125;bool isMatch(const char *s, const char *p) &#123; if (*p == &apos;\0&apos;) return *s == &apos;\0&apos;; //empty if (*(p + 1) != &apos;*&apos;) &#123;//without * if(!matchFirst(s,p)) return false; return isMatch(s + 1, p + 1); &#125; else &#123; //next: with a * if(isMatch(s, p + 2)) return true; //try the length of 0 while ( matchFirst(s,p) ) //try all possible lengths if (isMatch(++s, p + 2))return true; &#125;&#125;&#125;; https://discuss.leetcode.com/topic/21370/my-4ms-c-dp-solution-another-recursive-version-also-given-72ms My 4ms C++ DP solution (another recursive version also given 72ms) Just to build a DP table checked, where checked[i][j] indicates whether s[0..i-1] matches with p[0..j-1]. The recursive relationship is as below: To match with the empty string s[0..0] (i.e. to make checked[0][j]), P[0..j-1] has to meet: p[j-1]==’*’ (to cancel p[j-2]) and checked[0][j-2] == true; To match with the string s[0..i-1] (i.e. to make checked[i][j]), P[0..j-1] has to meet: if p[j-1] ==’*’, then j must be larger than 1 (j&gt;1) and checked[i][j-2] (i.e. p[j-2] cancelled by ‘*’) checked[i-1][j] &amp;&amp; (s[i-1] ==p[j-2] || p[j-2] ==’.’) (s[i-1] matches with p[j-2] or ‘.’, ) if p[j-1] !=’*’, checked[i-1][j-1] &amp;&amp; (s[i-1] ==p[j-1] || p[j-1] ==’.’)(i.e. s[i-1] matches with p[j-1] or ‘.’) 123456789101112131415161718192021class Solution &#123; public: bool isMatch(string s, string p) &#123; int sSize = s.size(), pSize = p.size(), i, j; bool checked[sSize+1][pSize+1]; // fill_n(&amp;matched[0][0], (sSize+1)*(pSize+1), false); for(j=2, checked[0][0]=true, checked[0][1]= false; j&lt;=pSize; ++j) // match s[0..0] checked[0][j] = p[j-1] == &apos;*&apos;? checked[0][j-2] : false; for(i=1; i&lt;=sSize; ++i) for(j=1, checked[i][0]=false; j&lt;=pSize; ++j) &#123; if(p[j-1]==&apos;*&apos;) // case (1) checked[i][j] = (j&gt;1) &amp;&amp; ( checked[i][j-2] || ( ( checked[i-1][j]) &amp;&amp; (s[i-1]== p[j-2] || p[j-2] == &apos;.&apos;)) ); else // case (2) checked[i][j] = checked[i-1][j-1] &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == &apos;.&apos;); &#125; return checked[sSize][pSize]; &#125; &#125;; A recursive version, divide cases into two groups (if the next p char is ‘*’ or not) 123456789101112131415161718192021222324class Solution &#123;private: bool helper(const string &amp;s, const string &amp;p, int sS, int pS) &#123; int sSize = s.size(), pSize = p.size(), i, j; if(pS==pSize) return sS ==sSize; // if p goes to its end, then only if s also goes to its end to return true; if(p[pS+1]!=&apos;*&apos;) &#123; if( sS&lt;sSize &amp;&amp; (p[pS]==s[sS] || p[pS] == &apos;.&apos;)) return helper(s, p, sS+1, pS+1); &#125; else &#123; if(helper(s, p, sS,pS+2)) return true; while(sS&lt;sSize &amp;&amp; (p[pS]==s[sS] || p[pS] == &apos;.&apos;)) if(helper(s,p, ++sS, pS+2)) return true; &#125; return false; &#125;public: bool isMatch(string s, string p) &#123; helper(s, p, 0, 0); &#125;&#125;; python https://discuss.leetcode.com/topic/22948/my-dp-approach-in-python-with-comments-and-unittest My DP approach in Python with comments and unittest I shared my DP approach with comments and provided some unit tests for it. Some statements in the approach directly affect some corner cases, for example, comment out line 22-23, then the unittest test_symbol_0 will fail. Hope this script helps us better understand the problem. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import unittestclass Solution(object): def isMatch(self, s, p): # The DP table and the string s and p use the same indexes i and j, but # table[i][j] means the match status between p[:i] and s[:j], i.e. # table[0][0] means the match status of two empty strings, and # table[1][1] means the match status of p[0] and s[0]. Therefore, when # refering to the i-th and the j-th characters of p and s for updating # table[i][j], we use p[i - 1] and s[j - 1]. # Initialize the table with False. The first row is satisfied. table = [[False] * (len(s) + 1) for _ in range(len(p) + 1)] # Update the corner case of matching two empty strings. table[0][0] = True # Update the corner case of when s is an empty string but p is not. # Since each &apos;*&apos; can eliminate the charter before it, the table is # vertically updated by the one before previous. [test_symbol_0] for i in range(2, len(p) + 1): table[i][0] = table[i - 2][0] and p[i - 1] == &apos;*&apos; for i in range(1, len(p) + 1): for j in range(1, len(s) + 1): if p[i - 1] != &quot;*&quot;: # Update the table by referring the diagonal element. table[i][j] = table[i - 1][j - 1] and \ (p[i - 1] == s[j - 1] or p[i - 1] == &apos;.&apos;) else: # Eliminations (referring to the vertical element) # Either refer to the one before previous or the previous. # I.e. * eliminate the previous or count the previous. # [test_symbol_1] table[i][j] = table[i - 2][j] or table[i - 1][j] # Propagations (referring to the horizontal element) # If p&apos;s previous one is equal to the current s, with # helps of *, the status can be propagated from the left. # [test_symbol_2] if p[i - 2] == s[j - 1] or p[i - 2] == &apos;.&apos;: table[i][j] |= table[i][j - 1] return table[-1][-1]class TestSolution(unittest.TestCase): def test_none_0(self): s = &quot;&quot; p = &quot;&quot; self.assertTrue(Solution().isMatch(s, p)) def test_none_1(self): s = &quot;&quot; p = &quot;a&quot; self.assertFalse(Solution().isMatch(s, p)) def test_no_symbol_equal(self): s = &quot;abcd&quot; p = &quot;abcd&quot; self.assertTrue(Solution().isMatch(s, p)) def test_no_symbol_not_equal_0(self): s = &quot;abcd&quot; p = &quot;efgh&quot; self.assertFalse(Solution().isMatch(s, p)) def test_no_symbol_not_equal_1(self): s = &quot;ab&quot; p = &quot;abb&quot; self.assertFalse(Solution().isMatch(s, p)) def test_symbol_0(self): s = &quot;&quot; p = &quot;a*&quot; self.assertTrue(Solution().isMatch(s, p)) def test_symbol_1(self): s = &quot;a&quot; p = &quot;ab*&quot; self.assertTrue(Solution().isMatch(s, p)) def test_symbol_2(self): # E.g. # s a b b # p 1 0 0 0 # a 0 1 0 0 # b 0 0 1 0 # * 0 1 1 1 s = &quot;abb&quot; p = &quot;ab*&quot; self.assertTrue(Solution().isMatch(s, p))if __name__ == &quot;__main__&quot;: unittest.main() https://discuss.leetcode.com/topic/6739/fast-python-solution-with-backtracking-and-caching-dp-solution Fast Python solution with backtracking and caching + DP solution Takes about 174ms: 123456789101112131415161718cache = &#123;&#125;def isMatch(self, s, p): if (s, p) in self.cache: return self.cache[(s, p)] if not p: return not s if p[-1] == &apos;*&apos;: if self.isMatch(s, p[:-2]): self.cache[(s, p)] = True return True if s and (s[-1] == p[-2] or p[-2] == &apos;.&apos;) and self.isMatch(s[:-1], p): self.cache[(s, p)] = True return True if s and (p[-1] == s[-1] or p[-1] == &apos;.&apos;) and self.isMatch(s[:-1], p[:-1]): self.cache[(s, p)] = True return True self.cache[(s, p)] = False return False DP version: 1234567891011121314def isMatch(self, s, p): dp = [[False] * (len(s) + 1) for _ in range(len(p) + 1)] dp[0][0] = True for i in range(1, len(p)): dp[i + 1][0] = dp[i - 1][0] and p[i] == &apos;*&apos; for i in range(len(p)): for j in range(len(s)): if p[i] == &apos;*&apos;: dp[i + 1][j + 1] = dp[i - 1][j + 1] or dp[i][j + 1] if p[i - 1] == s[j] or p[i - 1] == &apos;.&apos;: dp[i + 1][j + 1] |= dp[i + 1][j] else: dp[i + 1][j + 1] = dp[i][j] and (p[i] == s[j] or p[i] == &apos;.&apos;) return dp[-1][-1] https://discuss.leetcode.com/topic/40371/easy-dp-java-solution-with-detailed-explanation Easy DP Java Solution with detailed Explanation This Solution use 2D DP. beat 90% solutions, very simple. Here are some conditions to figure out, then the logic can be very straightforward. 1234567891, If p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1];2, If p.charAt(j) == &apos;.&apos; : dp[i][j] = dp[i-1][j-1];3, If p.charAt(j) == &apos;*&apos;: here are two sub conditions: 1 if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty 2 if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == &apos;.&apos;: dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a or dp[i][j] = dp[i][j-1] // in this case, a* counts as single a or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty Here is the solution 12345678910111213141516171819202122232425262728293031public boolean isMatch(String s, String p) &#123; if (s == null || p == null) &#123; return false; &#125; boolean[][] dp = new boolean[s.length()+1][p.length()+1]; dp[0][0] = true; for (int i = 0; i &lt; p.length(); i++) &#123; if (p.charAt(i) == &apos;*&apos; &amp;&amp; dp[0][i-1]) &#123; dp[0][i+1] = true; &#125; &#125; for (int i = 0 ; i &lt; s.length(); i++) &#123; for (int j = 0; j &lt; p.length(); j++) &#123; if (p.charAt(j) == &apos;.&apos;) &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == s.charAt(i)) &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == &apos;*&apos;) &#123; if (p.charAt(j-1) != s.charAt(i) &amp;&amp; p.charAt(j-1) != &apos;.&apos;) &#123; dp[i+1][j+1] = dp[i+1][j-1]; &#125; else &#123; dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]); &#125; &#125; &#125; &#125; return dp[s.length()][p.length()];&#125; https://discuss.leetcode.com/topic/12289/clean-java-solution Clean Java Solution 1234567891011121314151617181920212223public boolean isMatch(String s, String p) &#123; if (p.isEmpty()) &#123; return s.isEmpty(); &#125; if (p.length() == 1 || p.charAt(1) != &apos;*&apos;) &#123; if (s.isEmpty() || (p.charAt(0) != &apos;.&apos; &amp;&amp; p.charAt(0) != s.charAt(0))) &#123; return false; &#125; else &#123; return isMatch(s.substring(1), p.substring(1)); &#125; &#125; //P.length() &gt;=2 while (!s.isEmpty() &amp;&amp; (s.charAt(0) == p.charAt(0) || p.charAt(0) == &apos;.&apos;)) &#123; if (isMatch(s, p.substring(2))) &#123; return true; &#125; s = s.substring(1); &#125; return isMatch(s, p.substring(2));&#125; https://discuss.leetcode.com/topic/2601/my-ac-dp-solution-for-this-problem-asking-for-improvements My AC DP solution for this problem, asking for improvements. 123456789101112131415161718192021222324252627282930public boolean isMatch(String s, String p) &#123; int m = s.length(); int n = p.length(); if (s == null || p == null) &#123; return false; &#125; boolean[][] OPT = new boolean[m+1][n+1]; OPT[0][0] = true; for (int i = 1; i &lt;= m; i++) &#123; OPT[i][0] = false; &#125; for (int j = 1; j &lt;= n; j++) &#123; OPT[0][j] = (p.charAt(j-1) == &apos;*&apos;) &amp;&amp; (j-2 &gt;= 0) &amp;&amp; OPT[0][j-2]; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; OPT[i][j] = ((OPT[i-1][j-1]) &amp;&amp; equals(s, p, i-1, j-1)) || ((OPT[i-1][j] || OPT[i][j-1]) &amp;&amp; (p.charAt(j-1) == &apos;*&apos;) &amp;&amp; equals(s, p, i-1, j-2)) || ((p.charAt(j-1) == &apos;*&apos;) &amp;&amp; (j-2 &gt;= 0) &amp;&amp; OPT[i][j-2]); &#125; &#125; return OPT[m][n];&#125; private boolean equals(String s, String p, int si, int pi) { return (s.charAt(si) == p.charAt(pi) || p.charAt(pi) == ‘.’);}Basically, the OPT[i][j] means preceding substring of length i of s and length j of p. For any two substrings, the value of OPT[i][j] can be from one of following four cases: case 1: OPT[i-1][j-1] is true, and ith character of s is equal to j th character of p. Or j th character of p is ‘.’ case 2: OPT[i-1][j] is true, then my pattern now is ‘*’ and preceding character is equal to incoming character of s case 3: OPT[i][j-1] is true, then my pattern now is ‘*’ which can match an empty string case 4: OPT[i][j-2] is true, and the pattern like (a*) matches an empty stringbase case is the OPT[0][0], OPT[i][0], OPT[0][j]. https://discuss.leetcode.com/topic/2601/my-ac-dp-solution-for-this-problem-asking-for-improvements/2 I found I was using the exact algorithm as you did. So I post one for your references.It has no additional brace. It is very difficult to write a pretty code in string operations by Java due to .charAt(). By the way Your value assignment in the nested loop is indeed a pain to read(At least for me ). I do suggest you to give more lines on that part. 1234567891011121314151617181920212223242526272829303132333435363738public class RegularExpressionMatching &#123; public boolean isMatch(String s, String p) &#123; if (s==null&amp;&amp;p==null) return true; if (s.length()==0&amp;&amp;p.length()==0) return true; boolean[][] matrix = new boolean[s.length()+1][p.length()+1]; matrix[0][0]=true; for (int i=1;i&lt;=s.length();i++) matrix[i][0]=false; for (int j=1;j&lt;=p.length();j++) if (p.charAt(j-1)==&apos;*&apos;&amp;&amp;j&gt;1) matrix[0][j]=matrix[0][j-2]; else matrix[0][j]=false; for (int i=1;i&lt;=s.length();i++) for (int j=1;j&lt;=p.length();j++) if (p.charAt(j-1)==s.charAt(i-1)||p.charAt(j-1)==&apos;.&apos;) matrix[i][j]=matrix[i-1][j-1]; else if (p.charAt(j-1)==&apos;*&apos;&amp;&amp;j&gt;1) if (p.charAt(j-2)==s.charAt(i-1)||p.charAt(j-2)==&apos;.&apos;) matrix[i][j]=matrix[i-1][j]||matrix[i][j-2]||matrix[i][j-1]; //matrix[i-1][j]:abb vs ab*: depends on ab vs ab* //matrix[i][j-2] a vs ab* depends on a vs a //matrix[i][j-1] ab vs ab*: depends on ab vs ab else matrix[i][j]=matrix[i][j-2]; else matrix[i][j]=false; return matrix[s.length()][p.length()]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
        <tag>dynamic programming</tag>
        <tag>backtracking</tag>
        <tag>hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[009. Palindrome Number]]></title>
    <url>%2Fp%2Fc3ad93e8%2F</url>
    <content type="text"><![CDATA[35.4% https://leetcode.com/problems/palindrome-number/ Determine whether an integer is a palindrome. Do this without extra space. click to show spoilers. Some hints:Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 方法一： 先特殊情况，负数，最后一位为0且数值不等于0，排除。 然后翻转得到值 判断情况，相等，或者等于rev/10，这是因为只走了一半 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0 || x != 0 &amp;&amp; x%10 == 0) return false; int rev = 0; while(x &gt; rev)&#123; rev = rev * 10 + x % 10; x = x / 10; &#125; return (x == rev || x == rev / 10); &#125;&#125;; 我的代码实现一： 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0 || x&gt;0 &amp;&amp; x%10==0) return false; // 排除10， 100，1000这种情况 int rev = 0; while(rev&lt;x)&#123; rev = rev*10 + x%10; x /= 10; &#125; return rev == x || rev/10 == x; &#125;&#125;; 我的代码实现二： 1234567891011121314class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0 || x!=0 &amp;&amp; x%10 == 0) return false; int y = 0; while(y&lt;x)&#123; y = y*10 + x%10; x /= 10; &#125; // 注意此处该/还是% return x==y || x==y/10; &#125;&#125;; https://discuss.leetcode.com/topic/31602/this-problem-is-meanless This problem is meanless Impossible to solve without extra space. Always need space for constants, variables or whatever. Recursion calls will take space for call stack. If you are talking about constant space, then even declaring a string / stack will take constant space. (In fact at most (log(10, INT_MAX) * sizeof char), which is no worse than declaring an integer or more). Actually, even recursion will take constant space. https://discuss.leetcode.com/topic/3151/2147447412-is-not-a-palindromic-number -2147447412 is not a palindromic number I am wondering how the other people got their code ACed, the testing result of “-2147447412” seems a little odd to me. Should it be a palindromic number or not? Note: I believe the range of int is [-2147483648, 2147483647] and “-2147447412” is not overflowed, plus I handled the overflow cases already (test case “-2147483648” in particular). 11499 / 11502 test cases passed. Status: Wrong Answer Input: -2147447412 Output: true Expected: false Here’s my second question: Why does the function take “int” as input instead of “unsigned int”, when we assume all negative numbers are NOT palindromic. java https://leetcode.com/discuss/23563/line-accepted-java-code-without-the-need-handling-overflow 9-line accepted Java code, without the need of handling overflow 12ms, 46.14%, May.4th, 2016 compare half of the digits in x, so don’t need to deal with overflow. 123456789public boolean isPalindrome(int x) &#123; if (x&lt;0 || (x!=0 &amp;&amp; x%10==0)) return false; int rev = 0; while (x&gt;rev)&#123; rev = rev*10 + x%10; x = x/10; &#125; return (x==rev || x==rev/10);&#125; https://discuss.leetcode.com/topic/9477/o-1-space-o-lgn-time-java-solution-no-overflow-risk O(1) space, O(lgn) time java solution, no overflow risk 123456789101112131415public boolean isPalindrome(int x) &#123; if (x &lt; 0) return false; int p = x; int q = 0; while (p &gt;= 10)&#123; q *=10; q += p%10; p /=10; &#125; return q == x / 10 &amp;&amp; p == x % 10;&#125; so the reversed version of int is always 1 time short in the factor of 10s . in case of Int16, check 63556 will finally check if (6553 == 6355 &amp;&amp; 6 == 63556%10) so there will have no concerns about the overflow. https://discuss.leetcode.com/topic/3879/neat-ac-java-code-o-n-time-complexity Neat AC java code. O(n) time complexity. 123456789public boolean isPalindrome(int x) &#123; int palindromeX = 0; int inputX = x; while(x&gt;0)&#123; palindromeX = palindromeX*10 + (x % 10); x = x/10; &#125; return palindromeX==inputX; &#125; https://discuss.leetcode.com/topic/39795/simple-java-o-1-space-solution Simple JAVA O(1) space solution 12345678910public boolean isPalindrome(int x) &#123; if(x&lt;0 || (x!=0 &amp;&amp; x%10==0)) return false; int res = 0; while(x&gt;res)&#123; res = res*10 + x%10; x = x/10; &#125; return (x==res || x==res/10);&#125; cpp https://leetcode.com/discuss/33500/an-easy-lines-code-only-reversing-till-half-and-then-compare An easy c++ 8 lines code (only reversing till half and then compare) 76ms, 65.37%, May.4th, 2016 123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0 || x != 0 &amp;&amp; x%10 == 0) return false; int rev = 0; while(x &gt; rev)&#123; rev = rev * 10 + x % 10; x = x / 10; &#125; return (x == rev || x == rev / 10); &#125;&#125;; https://discuss.leetcode.com/topic/39259/7-line-simple-c-solution-beats-90-submissions-in-o-1-space-two-pointers 7 line simple C++ solution beats 90% submissions in O(1) space, two pointers Use two pointers concept, find the half point, and compare first half and 2nd half. Variable revhalf is the reversed 2nd half(x has even number of digits), or 2nd half with the middle digit(if x has odd number of digits) 12345678910111213class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0) return false; int revhalf = 0, slow = x, fast = x; while(fast)&#123; revhalf = revhalf * 10 + slow % 10; slow /= 10; fast /= 100; &#125; return slow == revhalf || slow == revhalf / 10; &#125;&#125;; https://discuss.leetcode.com/topic/18921/my-c-solution My C++ solution.. 1234567891011121314151617bool isPalindrome(int x) &#123; if(x&lt;0) return false; int num=x; int a=0; while(x) &#123; a=a*10 + x%10; x=x/10; &#125; if(a==num) return true; else return false; &#125; python 272ms, 66.06%, May.4th, 2016 https://leetcode.com/discuss/82355/5-line-python-solution-248ms 1234567891011class Solution(object): def isPalindrome(self, x): &quot;&quot;&quot; :type x: int :rtype: bool &quot;&quot;&quot; if x &lt; 0 or (x &gt; 0 and x % 10 == 0): return False half = 0 while x &gt; half: half, x = half * 10 + x % 10, x / 10 return x in (half, half / 10)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[008. String to Integer (atoi)]]></title>
    <url>%2Fp%2F7d4ee2b3%2F</url>
    <content type="text"><![CDATA[14.0% https://leetcode.com/problems/string-to-integer-atoi/ Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Update (2015-02-10): The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition. spoilers alert… click to show requirements for atoi. Requirements for atoi: The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned. https://discuss.leetcode.com/topic/35270/such-a-shitty-problem Such a shitty problem The description is not clear not all unless you click on the hint. What’s the point of testing all the “+-1” or “-+1” without any input spec nor any situation where input is obtained. 方法一： 如下代码，从第一个非 ‘ ‘开始，然后正负号，然后每个进行判别，考虑与最大最小值的差异。 string的函数方法find_first_not_of(‘ ‘) 1234567891011121314151617int myAtoi(string str) &#123; long result = 0; int indicator = 1; for(int i = 0; i&lt;str.size();) &#123; i = str.find_first_not_of(&apos; &apos;); if(str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) indicator = (str[i++] == &apos;-&apos;)? -1 : 1; while(&apos;0&apos;&lt;= str[i] &amp;&amp; str[i] &lt;= &apos;9&apos;) &#123; result = result*10 + (str[i++]-&apos;0&apos;); if(result*indicator &gt;= INT_MAX) return INT_MAX; if(result*indicator &lt;= INT_MIN) return INT_MIN; &#125; return result*indicator; &#125;&#125; 我优化后的代码实现： 123456789101112131415161718class Solution &#123;public: int myAtoi(string str) &#123; long result = 0; int indicator = 1; int i = 0; i = str.find_first_not_of(' '); if(str[i] == '-' || str[i] == '+') indicator = (str[i++] == '-')? -1 : 1; while('0'&lt;= str[i] &amp;&amp; str[i] &lt;= '9') &#123; result = result*10 + (str[i++]-'0'); if(result*indicator &gt;= INT_MAX) return INT_MAX; if(result*indicator &lt;= INT_MIN) return INT_MIN; &#125; return result*indicator; &#125;&#125;; 我的代码实现： 注意里面的坑，处理整数int数字，一定要注意溢出问题，所以这样的，反转的等等，一定要用long 不用int，而是用long，处理溢出问题，此处要特别注意。 123456789101112131415161718class Solution &#123;public: int myAtoi(string str) &#123; if(str.empty()) return 0; int flag = 1; int i = 0; i = str.find_first_not_of(' '); if(str[i]=='+' || str[i]=='-') flag = (str[i++]=='-') ? -1 : 1; long base = 0; // 此处一定要用long while(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9')&#123; base = base*10 + (str[i++]-'0'); if(base*flag &gt;= INT_MAX) return INT_MAX; if(base*flag &lt;= INT_MIN) return INT_MIN; &#125; return flag*base; &#125;&#125;; 我的代码实现： 对于int可能溢出的题目，就用long long 123456789101112131415161718192021class Solution &#123;public: int myAtoi(string str) &#123; long long res = 0; int i = str.find_first_not_of(' '); int flag = 1; if(str[i] == '+')&#123; flag = 1; i++; &#125;else if(str[i]=='-')&#123; flag = -1; i++; &#125; while(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9')&#123; res = res*10 + str[i++] - '0'; if(flag*res &gt; INT_MAX) return INT_MAX; if(flag*res &lt; INT_MIN) return INT_MIN; &#125; return flag*res; &#125;&#125;; cpp https://discuss.leetcode.com/topic/15891/8ms-c-solution-easy-to-understand 8ms C++ solution, easy to understand 12ms, 15.61%, August 31, 2016 1234567891011121314151617int myAtoi(string str) &#123; long result = 0; int indicator = 1; for(int i = 0; i&lt;str.size();) &#123; i = str.find_first_not_of(&apos; &apos;); if(str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) indicator = (str[i++] == &apos;-&apos;)? -1 : 1; while(&apos;0&apos;&lt;= str[i] &amp;&amp; str[i] &lt;= &apos;9&apos;) &#123; result = result*10 + (str[i++]-&apos;0&apos;); if(result*indicator &gt;= INT_MAX) return INT_MAX; if(result*indicator &lt;= INT_MIN) return INT_MIN; &#125; return result*indicator; &#125;&#125; https://discuss.leetcode.com/topic/29207/8-line-c-concise-solution 8 line C++ concise solution 12345678910int myAtoi(string str) &#123; int ret = 0, sign = 1, i = str.find_first_not_of(&apos; &apos;), base = INT_MAX / 10; if (str[i] == &apos;+&apos; || str[i] == &apos;-&apos;) sign = str[i++] == &apos;+&apos; ?: -1; while (isdigit(str[i])) &#123; if (ret &gt; base || (ret == base &amp;&amp; str[i] - &apos;0&apos; &gt; 7)) return sign &gt; 0 ? INT_MAX : INT_MIN; ret = 10 * ret + (str[i++] - &apos;0&apos;); &#125; return sign * ret;&#125; https://discuss.leetcode.com/topic/32966/c-10-lines-solution-easy-understanding-clean-code C++ 10 lines solution, easy understanding, clean code 12345678910111213int myAtoi(string str) &#123; if (str.empty()) return 0; int i = 0, sign = 1; while (i + 1 &lt; str.size() &amp;&amp; isspace(str[i])) ++i; long res = 0; if (str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) sign = 44 - str[i++]; while (i &lt; str.size()) &#123; if (isdigit(str[i])) res = 10 * res + str[i++] - &apos;0&apos;; else return res * sign; if (res &gt; INT_MAX) return sign == -1 ? INT_MIN : INT_MAX; &#125; return res * sign;&#125; python https://discuss.leetcode.com/topic/10740/python-solution-based-on-regex Python solution based on RegEx 123456789101112131415161718class Solution: # @return an integer def atoi(self, str): str = str.strip() str = re.findall(&apos;(^[\+\-0]*\d+)\D*&apos;, str) try: result = int(&apos;&apos;.join(str)) MAX_INT = 2147483647 MIN_INT = -2147483648 if result &gt; MAX_INT &gt; 0: return MAX_INT elif result &lt; MIN_INT &lt; 0: return MIN_INT else: return result except: return 0 https://discuss.leetcode.com/topic/26920/60ms-python-solution-oj-says-this-beats-100-python-submissions 60ms python solution; OJ says this beats 100% python submissions 12345678910111213141516171819class Solution(object): def myAtoi(self, s): &quot;&quot;&quot; :type str: str :rtype: int &quot;&quot;&quot; ###better to do strip before sanity check (although 8ms slower): #ls = list(s.strip()) #if len(ls) == 0 : return 0 if len(s) == 0 : return 0 ls = list(s.strip()) sign = -1 if ls[0] == &apos;-&apos; else 1 if ls[0] in [&apos;-&apos;,&apos;+&apos;] : del ls[0] ret, i = 0, 0 while i &lt; len(ls) and ls[i].isdigit() : ret = ret*10 + ord(ls[i]) - ord(&apos;0&apos;) i += 1 return max(-2**31, min(sign * ret,2**31-1)) java https://discuss.leetcode.com/topic/2666/my-simple-solution My simple solution I think we only need to handle four cases: discards all leading whitespaces sign of the number overflow invalid input Is there any better solution? Thanks for pointing out! 123456789101112131415int atoi(const char *str) &#123; int sign = 1, base = 0, i = 0; while (str[i] == &apos; &apos;) &#123; i++; &#125; if (str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) &#123; sign = 1 - 2 * (str[i++] == &apos;-&apos;); &#125; while (str[i] &gt;= &apos;0&apos; &amp;&amp; str[i] &lt;= &apos;9&apos;) &#123; if (base &gt; INT_MAX / 10 || (base == INT_MAX / 10 &amp;&amp; str[i] - &apos;0&apos; &gt; 7)) &#123; if (sign == 1) return INT_MAX; else return INT_MIN; &#125; base = 10 * base + (str[i++] - &apos;0&apos;); &#125; return base * sign;&#125; https://discuss.leetcode.com/topic/12473/java-solution-with-4-steps-explanations 3ms, August 31, 2016 Java Solution with 4 steps explanations 1234567891011121314151617181920212223242526272829public int myAtoi(String str) &#123; int index = 0, sign = 1, total = 0; //1. Empty string if(str.length() == 0) return 0; //2. Remove Spaces while(str.charAt(index) == &apos; &apos; &amp;&amp; index &lt; str.length()) index ++; //3. Handle signs if(str.charAt(index) == &apos;+&apos; || str.charAt(index) == &apos;-&apos;)&#123; sign = str.charAt(index) == &apos;+&apos; ? 1 : -1; index ++; &#125; //4. Convert number and avoid overflow while(index &lt; str.length())&#123; int digit = str.charAt(index) - &apos;0&apos;; if(digit &lt; 0 || digit &gt; 9) break; //check if total will be overflow after 10 times and add digit if(Integer.MAX_VALUE/10 &lt; total || Integer.MAX_VALUE/10 == total &amp;&amp; Integer.MAX_VALUE %10 &lt; digit) return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; total = 10 * total + digit; index ++; &#125; return total * sign;&#125; https://discuss.leetcode.com/topic/33142/java-easy-version-to-understand JAVA——-Easy Version To Understand!!!!!!!!!! 1234567891011121314151617181920212223242526public static int myAtoi(String str) &#123; if (str == null || str.length() == 0) return 0;// str = str.trim(); char firstChar = str.charAt(0); int sign = 1, start = 0, len = str.length(); long sum = 0; if (firstChar == &apos;+&apos;) &#123; sign = 1; start++; &#125; else if (firstChar == &apos;-&apos;) &#123; sign = -1; start++; &#125; for (int i = start; i &lt; len; i++) &#123; if (!Character.isDigit(str.charAt(i))) return (int) sum * sign; sum = sum * 10 + str.charAt(i) - &apos;0&apos;; if (sign == 1 &amp;&amp; sum &gt; Integer.MAX_VALUE) return Integer.MAX_VALUE; if (sign == -1 &amp;&amp; (-1) * sum &lt; Integer.MIN_VALUE) return Integer.MIN_VALUE; &#125; return (int) sum * sign;&#125; https://discuss.leetcode.com/topic/37311/my-nice-java-code-3ms My Nice Java Code 3ms 123456789101112131415161718192021public class Solution &#123; public int myAtoi(String str) &#123; if (str.isEmpty()) return 0; str = str.trim(); int i = 0, ans = 0, sign = 1, len = str.length(); if (str.charAt(i) == &apos;-&apos; || str.charAt(i) == &apos;+&apos;) sign = str.charAt(i++) == &apos;+&apos; ? 1 : -1; for (; i &lt; len; ++i) &#123; int tmp = str.charAt(i) - &apos;0&apos;; if (tmp &lt; 0 || tmp &gt; 9) break; if (ans &gt; Integer.MAX_VALUE / 10 || (ans == Integer.MAX_VALUE / 10 &amp;&amp; Integer.MAX_VALUE % 10 &lt; tmp)) return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; else ans = ans * 10 + tmp; &#125; return sign * ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[007. Reverse Integer]]></title>
    <url>%2Fp%2Ff2b740bb%2F</url>
    <content type="text"><![CDATA[23.8% https://leetcode.com/problems/reverse-integer/ Reverse digits of an integer. 12Example1: x = 123, return 321Example2: x = -123, return -321 click to show spoilers. Have you thought about this? Here are some good questions to ask before coding. Bonus points for you if you have already thought through this! If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100. Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases? For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Update (2014-11-10): Test cases had been added to test the overflow behavior. 如果为负数，是怎么样的情形呢？ 1234567-78 / 10 = -7 -78 % 10 = -8-78 / 100 = 0-78 % 100 = 78-9 / 10 = 0-9 % 10 = -9 方法一： 考虑负数和0的情况 Shortest code possible in c++ long long make res a 64 bit number, the overflow is checked. 1234567891011class Solution &#123;public: int reverse(int x) &#123; long long res = 0; while(x) &#123; res = res*10 + x%10; x /= 10; &#125; return (res&lt;INT_MIN || res&gt;INT_MAX) ? 0 : res; &#125;&#125;; 我的代码实现及注意事项 1234567891011class Solution &#123;public: int reverse(int x) &#123; long long res = 0; // 此处要用long long，因为int会溢出 while(x)&#123; res = res*10 + x%10; x /= 10; &#125; return (res&lt;INT_MIN || res&gt;INT_MAX)?0:res; // 括号最好不要省略，不然可能会出问题 &#125;&#125;; 我的代码实现二: 1234567891011121314class Solution &#123;public: int reverse(int x) &#123; // 用到大数的时候一定要记得用long long // 虽然给的是int，但是我们依然要用long long long long res = 0; while(x!=0)&#123; res = res*10 + x%10; x /= 10; &#125; // 下面最好加括号，以示区分，虽然不要括号也能正确运行 return (res&lt;INT_MIN || res&gt;INT_MAX) ? 0 : res; &#125;&#125;; 方法二： 边走边检查边界 8 ms simple C++ solution which checks overflow 8ms, 49.31%, 17 July 2016 123456789101112131415class Solution &#123;public: int reverse(int x) &#123; int ans = 0; while(x)&#123; int temp = ans * 10 + x % 10; if(temp / 10 != ans) return 0; ans = temp; x /= 10; &#125; return ans; &#125;&#125;; https://discuss.leetcode.com/topic/6005/shortest-code-possible-in-c Shortest code possible in c++ long long make res a 64 bit number, the overflow is checked. 1234567891011class Solution &#123;public: int reverse(int x) &#123; long long res = 0; while(x) &#123; res = res*10 + x%10; x /= 10; &#125; return (res&lt;INT_MIN || res&gt;INT_MAX) ? 0 : res; &#125;&#125;; https://discuss.leetcode.com/topic/34506/8-ms-simple-c-solution-which-checks-overflow 8 ms simple C++ solution which checks overflow 8ms, 49.31%, 17 July 2016 123456789101112131415class Solution &#123;public: int reverse(int x) &#123; int ans = 0; while(x)&#123; int temp = ans * 10 + x % 10; if(temp / 10 != ans) return 0; ans = temp; x /= 10; &#125; return ans; &#125;&#125;; python https://discuss.leetcode.com/topic/15832/golfing-in-python Golfing in Python Get the sign, get the reversed absolute integer, and return their product if r didn’t “overflow”. 1234def reverse(self, x): s = cmp(x, 0) r = int(`s*x`[::-1]) return s*r * (r &lt; 2**31) As compressed one-liner, for potential comparison: 12def reverse(self, x): s=cmp(x,0);r=int(`s*x`[::-1]);return(r&lt;2**31)*s*r Anybody got something shorter? 12345678910111268ms, 50.07%, 17 July 2016class Solution(object): def reverse(self, x): &quot;&quot;&quot; :type x: int :rtype: int &quot;&quot;&quot; x = (-1 if x &lt; 0 else 1) * int(str(abs(x))[::-1]) if (x &lt; 2**31 - 1) and (x &gt; -2**31 + 1): return x else: return 0 c https://discuss.leetcode.com/topic/12975/a-simple-c-solution-with-5ms A simple C solution with 5ms 12345678910int reverse(int x) &#123; long long val = 0; do &#123; val = val * 10 + x % 10; x /= 10; &#125; while (x); return (val &gt; INT_MAX || val &lt; INT_MIN) ? 0 : val;&#125; java https://discuss.leetcode.com/topic/6104/my-accepted-15-lines-of-code-for-java My accepted 15 lines of code for Java Only 15 lines. If overflow exists, the new result will not equal previous one. No flags needed. No hard code like 0xf7777777 needed. Sorry for my bad english. 12345678910111213141516public int reverse(int x)&#123; int result = 0; while (x != 0) &#123; int tail = x % 10; int newResult = result * 10 + tail; if ((newResult - tail) / 10 != result) &#123; return 0; &#125; result = newResult; x = x / 10; &#125; return result;&#125; https://discuss.leetcode.com/topic/15134/very-short-7-lines-and-elegant-solution Very Short (7 lines) and Elegant Solution 2ms, 48.43%, 17 July 2016 123456789101112public class Solution &#123; public int reverse(int x) &#123; long rev= 0; while( x != 0)&#123; rev= rev*10 + x % 10; x= x/10; if( rev &gt; Integer.MAX_VALUE || rev &lt; Integer.MIN_VALUE) return 0; &#125; return (int) rev; &#125;&#125; https://discuss.leetcode.com/topic/8941/simple-java-solution-o-n-time-and-o-1-space Simple Java Solution O(N) time and O(1) space. Simply just modulo the input by 10, add it to a long-integer variable as the result. Repeat. When the result is &gt; max integer or &lt; min integer, return 0. Hence, return the result as an integer 123456789101112131415public class Solution &#123; public int reverse(int x) &#123; long result =0; while(x != 0) &#123; result = (result*10) + (x%10); if(result &gt; Integer.MAX_VALUE) return 0; if(result &lt; Integer.MIN_VALUE) return 0; x = x/10; &#125; return (int)result; &#125;&#125; https://discuss.leetcode.com/topic/41683/might-be-helpful-to-you-my-2ms-11-lines-java-solution Might be helpful to you: my 2ms 11 lines Java solution 1234567891011public int reverse(int x) &#123; long result = 0; while (x != 0) &#123; result = result * 10 + x%10; if (result &gt; Integer.MAX_VALUE || result &lt; Integer.MIN_VALUE) &#123; return 0; &#125; x = x / 10; &#125; return (int)result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[006. ZigZag Conversion]]></title>
    <url>%2Fp%2F6cbc5e00%2F</url>
    <content type="text"><![CDATA[26.3% https://leetcode.com/problems/zigzag-conversion/ 123456789101112The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P A H NA P L S I I GY I RAnd then read line by line: &quot;PAHNAPLSIIGYIR&quot;Write the code that will take a string and make this conversion given a number of rows:string convert(string text, int nRows);convert(&quot;PAYPALISHIRING&quot;, 3) should return &quot;PAHNAPLSIIGYIR&quot;. 方法一： 最好的一点是使用了空间，分成了n个组，每个组都是string，最后合并。 https://discuss.leetcode.com/topic/4502/share-simple-c-solution 28ms, 23.79%, August 31, 2016 The problem statement itself is unclear for many. Especially for 2-row case. “ABCD”, 2 –&gt; “ACBD”. The confusion most likely is from the character placement. I would like to extend it a little bit to make ZigZag easy understood. 设了一个数组，每一组代表一行的值，然后将他们串联到一起 The example can be written as follow: P…….A……..H…….N ..A..P….L..S….I…I….G ….Y………I……..R Therefore, &lt;ABCD, 2&gt; can be arranged as: A….C …B….D My simple accepted code: 12345678910111213141516171819202122232425262728class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows &lt;= 1) return s; const int len = (int)s.length(); string *str = new string[numRows]; int row = 0, step=1; for(int i = 0; i &lt; len; ++i)&#123; str[row].push_back(s[i]); if(row==0) step = 1; else if(row == numRows - 1) step = -1; row += step; &#125; s.clear(); for(int j= 0; j &lt; numRows; ++j) s.append(str[j]); delete[] str; return s; &#125;&#125;; 我的代码实现： 可以学习上一段代码中的clear，append，delete函数 123456789101112131415161718192021class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows&lt;=1) return s; // 此处要初始化为v(numRows) vector&lt;string&gt; v(numRows); int pos = 0, flag = 1; for(int i=0; i&lt;s.size(); i++)&#123; v[pos] += s[i]; if(pos==0) flag = 1; else if(pos==numRows-1) flag = -1; pos += flag; &#125; string t = ""; for(int i=0; i&lt;numRows; i++) t.append(v[i]); return t; &#125;&#125;; https://discuss.leetcode.com/topic/22925/if-you-are-confused-with-zigzag-pattern-come-and-see If you are confused with zigzag pattern,come and see! 123456789/*n=numRowsΔ=2n-2 1 2n-1 4n-3Δ= 2 2n-2 2n 4n-4 4n-2Δ= 3 2n-3 2n+1 4n-5 .Δ= . . . . .Δ= . n+2 . 3n .Δ= n-1 n+1 3n-3 3n-1 5n-5Δ=2n-2 n 3n-2 5n-4*/ that’s the zigzag pattern the question asked!Be careful with nR=1 &amp;&amp; nR=2 my 16ms code in c++: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string convert(string s, int numRows) &#123; string result=""; if(numRows==1) return s; int step1,step2; int len=s.size(); for(int i=0;i&lt;numRows;++i)&#123; step1=(numRows-i-1)*2; step2=(i)*2; int pos=i; if(pos&lt;len) result+=s.at(pos); while(1)&#123; pos+=step1; if(pos&gt;=len) break; if(step1) result+=s.at(pos); pos+=step2; if(pos&gt;=len) break; if(step2) result+=s.at(pos); &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/22925/if-you-are-confused-with-zigzag-pattern-come-and-see1234567891011/*n=numRowsΔ=2n-2 1 2n-1 4n-3Δ= 2 2n-2 2n 4n-4 4n-2Δ= 3 2n-3 2n+1 4n-5 .Δ= . . . . .Δ= . n+2 . 3n .Δ= n-1 n+1 3n-3 3n-1 5n-5Δ=2n-2 n 3n-2 5n-4*/that&apos;s the zigzag pattern the question asked!Be careful with nR=1 &amp;&amp; nR=2 my 16ms code in c++: 123456789101112131415161718192021222324252627282930class Solution &#123;public: string convert(string s, int numRows) &#123; string result=&quot;&quot;; if(numRows==1) return s; int step1,step2; int len=s.size(); for(int i=0;i&lt;numRows;++i)&#123; step1=(numRows-i-1)*2; step2=(i)*2; int pos=i; if(pos&lt;len) result+=s.at(pos); while(1)&#123; pos+=step1; if(pos&gt;=len) break; if(step1) result+=s.at(pos); pos+=step2; if(pos&gt;=len) break; if(step2) result+=s.at(pos); &#125; &#125; return result; &#125;&#125;; https://discuss.leetcode.com/topic/21196/a-10-lines-one-pass-o-n-time-o-1-space-accepted-solution-with-detailed-explantation A 10-lines one-pass o(n)-time o(1)-space accepted solution with detailed explantation The distribution of the elements is period. 123P A H NA P L S I I GY I R For example, the following has 4 periods(cycles): 123P | A | H | NA P | L S | I I | GY | I | R | The size of every period is defined as “cycle” 1cycle = (2*nRows - 2), except nRows == 1. In this example, (2*nRows - 2) = 4. In every period, every row has 2 elements, except the first row and the last row. Suppose the current row is i, the index of the first element is j: 1j = i + cycle*k, k = 0, 1, 2, ... The index of the second element is secondJ: 1secondJ = (j - i) + cycle - i (j-i) is the start of current period, (j-i) + cycle is the start of next period. 12345678910111213141516string convert(string s, int nRows) &#123; if(nRows &lt;= 1) return s; string result = &quot;&quot;; //the size of a cycle(period) int cycle = 2 * nRows - 2; for(int i = 0; i &lt; nRows; ++i) &#123; for(int j = i; j &lt; s.length(); j = j + cycle)&#123; result = result + s[j]; int secondJ = (j - i) + cycle - i; if(i != 0 &amp;&amp; i != nRows-1 &amp;&amp; secondJ &lt; s.length()) result = result + s[secondJ]; &#125; &#125; return result; &#125; python https://discuss.leetcode.com/topic/34573/python-o-n-solution-in-96ms-99-43 Python O(n) Solution in 96ms (99.43%) 12345678910111213141516171819202122class Solution(object): def convert(self, s, numRows): &quot;&quot;&quot; :type s: str :type numRows: int :rtype: str &quot;&quot;&quot; if numRows == 1 or numRows &gt;= len(s): return s L = [&apos;&apos;] * numRows index, step = 0, 1 for x in s: L[index] += x if index == 0: step = 1 elif index == numRows -1: step = -1 index += step return &apos;&apos;.join(L) https://discuss.leetcode.com/topic/10330/a-simple-python-solution-97ms-8-lines A simple python solution, 97ms, 8 lines 12345678910111213141516def convert(self, s, nRows): if nRows==1: return s period= 2*(nRows -1) lines=[&quot;&quot; for i in range(nRows)] d=&#123;&#125; # dict remainder:line for i in xrange(period): if i&lt;nRows: d[i]=i else: d[i]=period-i for i in xrange(len(s)): lines[ d[i%period] ] +=s[i] return &quot;&quot;.join(lines) The idea is to use the remainder (index%period) to determine which line the character at the given index will be. The period is calculated first based on nRows. A dictionary with remainder:line as key:value is then created (this can also be done with a list or a tuple). Once these are done, we simply go through s, assign each character to its new line, and then combine these lines to get the converted string. The code can be further shortened to 8 lines by using dict comprehension: 1d=&#123;i:i if i&lt;nRows else (period-i) for i in xrange(period)&#125; 1234567891011def convert(self, s, nRows): if nRows==1: return s period= 2*(nRows -1) lines=[&quot;&quot; for i in range(nRows)] d=&#123;i:i if i&lt;nRows else (period-i) for i in xrange(period)&#125; for i in xrange(len(s)): lines[ d[i%period] ] +=s[i] return &quot;&quot;.join(lines) java https://discuss.leetcode.com/topic/3162/easy-to-understand-java-solution Easy to understand Java solution Create nRows StringBuffers, and keep collecting characters from original string to corresponding StringBuffer. Just take care of your index to keep them in bound. 1234567891011121314151617public String convert(String s, int nRows) &#123; char[] c = s.toCharArray(); int len = c.length; StringBuffer[] sb = new StringBuffer[nRows]; for (int i = 0; i &lt; sb.length; i++) sb[i] = new StringBuffer(); int i = 0; while (i &lt; len) &#123; for (int idx = 0; idx &lt; nRows &amp;&amp; i &lt; len; idx++) // vertically down sb[idx].append(c[i++]); for (int idx = nRows-2; idx &gt;= 1 &amp;&amp; i &lt; len; idx--) // obliquely up sb[idx].append(c[i++]); &#125; for (int idx = 1; idx &lt; sb.length; idx++) sb[0].append(sb[idx]); return sb[0].toString();&#125; https://discuss.leetcode.com/topic/41037/java-solution-easy-and-clear-interesting-approach JAVA solution–easy and clear ( interesting approach ) 12345678910111213141516171819202122public class Solution &#123; public String convert(String s, int numRows) &#123; if(numRows&lt;=1)return s; StringBuilder[] sb=new StringBuilder[numRows]; for(int i=0;i&lt;sb.length;i++)&#123; sb[i]=new StringBuilder(&quot;&quot;); //init every sb element **important step!!!! &#125; int incre=1; int index=0; for(int i=0;i&lt;s.length();i++)&#123; sb[index].append(s.charAt(i)); if(index==0)&#123;incre=1;&#125; if(index==numRows-1)&#123;incre=-1;&#125; index+=incre; &#125; String re=&quot;&quot;; for(int i=0;i&lt;sb.length;i++)&#123; re+=sb[i]; &#125; return re.toString(); &#125;&#125; https://discuss.leetcode.com/topic/3305/two-ways-of-o-n-solutions-one-follows-the-order-of-input-string-and-other-follows-the-order-of-output-string Two ways of O(n) solutions one follows the order of input string and other follows the order of output string Both the algorithms are of O(n) time complexity as every character in the input string is traversed only once.In the first version of algorithm, the output string’s string buffer get populated based on the output string order i.e, string builder gets populated incrementally from 0 to size-1. 12345670 6 12 181 5 7 11 13 17 192 4 8 10 14 16 203 9 15 21 In the above sample case the number of rows is 4, when the first iteration is completed the locations 0,1,2,3 of the string builder gets filled with the locations 0,6,12,18 of the input string it goes on further for other three rows. 123456789101112131415161718192021222324252627282930public class Solution &#123; public String convert(String s, int nRows) &#123; if (nRows == 1) return s; StringBuilder strBuilder = new StringBuilder(); int borderRowStep = 2 * nRows - 2; for (int i = 0; i &lt; nRows; i++) &#123; if (i == 0 || i == nRows - 1) &#123; for (int j = i; j &lt; s.length(); j = j + borderRowStep) &#123; strBuilder.append(s.charAt(j)); &#125; &#125; else &#123; int j = i; boolean flag = true; int insideRowLargeStep = 2 * (nRows - 1 - i); int insideRowSmallStep = borderRowStep - insideRowLargeStep; while (j &lt; s.length()) &#123; strBuilder.append(s.charAt(j)); if (flag) j = j + insideRowLargeStep; else j = j + insideRowSmallStep; flag = !flag; &#125; &#125; &#125; return strBuilder.toString(); &#125;&#125; In the second version of algorithm string buffer is filled in the order of input string i.e, the string buffer gets filled in the zig zag order, when the first iteration of the outer while loop completes the locations 0,5,11,17 in string builder gets filled with the locations 0,1,2,3, from the input string 123456789101112131415161718class Solution&#123;public String convert(String s, int nRows) &#123; char[] c = s.toCharArray(); int len = c.length; StringBuffer[] sb = new StringBuffer[nRows]; for (int z=0; z &lt; sb.length; z++) sb[z] = new StringBuffer(); int k=0; while (k &lt; len) &#123; for (int zigZagIndex = 0; zigZagIndex &lt; nRows &amp;&amp; k &lt; len; zigZagIndex++) // vertically down sb[zigZagIndex].append(c[k++]); for (int zigZagIndex = nRows-2; zigZagIndex &gt;= 1 &amp;&amp; k &lt; len; zigZagIndex--) // obliquely up sb[zigZagIndex].append(c[k++]); &#125; for (int index = 1; index &lt; sb.length; index++) sb[0].append(sb[index]); return sb[0].toString();&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[005. Longest Palindromic Substring]]></title>
    <url>%2Fp%2Fa8573ae4%2F</url>
    <content type="text"><![CDATA[25.0% https://leetcode.com/problems/longest-palindromic-substring/ Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. 1234567Example:Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. 12345Example:Input: &quot;cbbd&quot;Output: &quot;bb&quot; 方法一： 依次遍历，遍历至i时，从i开始向左向右移动，找到最大长度。 12345678910111213141516171819202122232425class Solution &#123; int start, longest;public: string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; for(int i=0; i&lt;n-1; i++)&#123; helper(s, i, i); helper(s, i, i+1); &#125; return s.substr(start, longest); &#125; void helper(string&amp; s, int i, int j)&#123; while(i&gt;=0 &amp;&amp; j&lt;s.size() &amp;&amp; s[i]==s[j])&#123; i--; j++; &#125; if(longest&lt;j-i-1)&#123; start = i+1; longest = j-i-1; &#125; return; &#125;&#125;; 我的代码实现一： 1234567891011121314151617181920212223242526class Solution &#123;public: int head = 0; int l = 0; string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; for(int i=0; i&lt;n-1; i++)&#123; helper(i, i, s); helper(i, i+1, s); &#125; return s.substr(head, l); &#125; void helper(int left, int right, string &amp; s)&#123; int n = s.size(); while(left&gt;=0 &amp;&amp; right&lt;n &amp;&amp; s[left]==s[right])&#123; left--; right++; &#125; if(right-left-1&gt;l)&#123; head = left+1; l = right-left-1; &#125; &#125;&#125;; 我的代码实现二： 12345678910111213141516171819202122232425class Solution &#123;public: string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; int head = 0, d = 0; for(int i=0; i&lt;n-1; i++)&#123; helper(s, i, i, head, d); helper(s, i, i+1, head, d); &#125; return s.substr(head, d); &#125; void helper(string s, int left, int right, int&amp; head, int&amp; d)&#123; while(left&gt;=0 &amp;&amp; right&lt;s.size() &amp;&amp; s[left]==s[right])&#123; left--; right++; &#125; if(right-left-1&gt;d)&#123; head = left+1; d = right-left-1; &#125; return; &#125;&#125;; 方法二： https://discuss.leetcode.com/topic/16317/accepted-4ms-c-solution Accepted 4ms c++ solution. 核心逻辑点： 1 5 5 5 5 6 7 8 遍历到某一个核心如 5 5时，一定要把5全部放中间才是最长的，不然肯定遇见一个不对称的5 然后下一个核心是6，同时当前位置距离末尾小于最长长度时要停止，进一步优化了算法 1234567891011121314151617181920212223class Solution &#123;public: std::string longestPalindrome(std::string s) &#123; if (s.size() &lt; 2) return s; int len = s.size(), max_left = 0, max_len = 1, left, right; for (int start = 0; start &lt; len &amp;&amp; len - start &gt; max_len / 2;) &#123; left = right = start; while (right &lt; len - 1 &amp;&amp; s[right + 1] == s[right]) ++right; start = right + 1; while (right &lt; len - 1 &amp;&amp; left &gt; 0 &amp;&amp; s[right + 1] == s[left - 1]) &#123; ++right; --left; &#125; if (max_len &lt; right - left + 1) &#123; max_left = left; max_len = right - left + 1; &#125; &#125; return s.substr(max_left, max_len); &#125;&#125;; 我的代码实现： 两点优化 3ms，94.75% 123456789101112131415161718192021222324class Solution &#123;public: string longestPalindrome(string s) &#123; int n = s.size(); if(n&lt;=1) return s; int head = 0, d = 0; int left = 0, right = 0; for(int i=0; i&lt;n-d/2; )&#123; left = right = i; while(right+1&lt;n &amp;&amp; s[right+1]==s[right]) right++; i = right+1; while(left-1&gt;=0 &amp;&amp; right+1&lt;n &amp;&amp; s[left-1]==s[right+1])&#123; left--; right++; &#125; if(right-left+1&gt;d)&#123; head = left; d = right-left+1; &#125; &#125; return s.substr(head, d); &#125;&#125;; https://discuss.leetcode.com/topic/12187/simple-c-solution-8ms-13-lines Simple C++ solution (8ms, 13 lines) 123456789101112131415string longestPalindrome(string s) &#123; if (s.empty()) return &quot;&quot;; if (s.size() == 1) return s; int min_start = 0, max_len = 1; for (int i = 0; i &lt; s.size();) &#123; if (s.size() - i &lt;= max_len / 2) break; int j = i, k = i; while (k &lt; s.size()-1 &amp;&amp; s[k+1] == s[k]) ++k; // Skip duplicate characters. i = k+1; while (k &lt; s.size()-1 &amp;&amp; j &gt; 0 &amp;&amp; s[k + 1] == s[j - 1]) &#123; ++k; --j; &#125; // Expand. int new_len = k - j + 1; if (new_len &gt; max_len) &#123; min_start = j; max_len = new_len; &#125; &#125; return s.substr(min_start, max_len);&#125; python https://discuss.leetcode.com/topic/7144/python-o-n-2-method-with-some-optimization-88ms 14ms, 79.15%, 23 July 2016 maxLen是长度，i为当前位置，判断，i-maxLen至i之间是否对称 Basic thought is simple. when you increase s by 1 character, you could only increase maxPalindromeLen by 1 or 2, and that new maxPalindrome includes this new character. Proof: if on adding 1 character, maxPalindromeLen increased by 3 or more, say the new maxPalindromeLen is Q, and the old maxPalindromeLen is P, and Q&gt;=P+3. Then it would mean, even without this new character, there would be a palindromic substring ending in the last character, whose length is at least Q-2. Since Q-2 would be &gt;P, this contradicts the condition that P is the maxPalindromeLen without the additional character. So, it becomes simple, you only need to scan from beginning to the end, adding one character at a time, keeping track of maxPalindromeLen, and for each added character, you check if the substrings ending with this new character, with length P+1 or P+2, are palindromes, and update accordingly. Now, this is O(n^2) as taking substrings and checking palindromicity seem O(n) time. We can speed up it by realizing that strings are immutable, and there are memory slicing tricks will help to speed these operations up. comparing string equality with “==” is O(1), and using slicing to substring and reverse is ̶a̶l̶s̶o̶ ̶O̶(̶1̶)̶ ̶(̶n̶o̶t̶ ̶t̶o̶t̶a̶l̶l̶y̶ ̶s̶u̶r̶e̶ ̶a̶b̶o̶u̶t̶ ̶t̶h̶e̶ ̶s̶l̶i̶c̶i̶n̶g̶ ̶t̶h̶o̶u̶g̶h̶.̶ ̶ ̶I̶ ̶t̶h̶i̶n̶k̶ ̶i̶t̶ ̶i̶s̶ ̶O̶(̶1̶)̶,̶ ̶b̶u̶t̶ ̶c̶o̶u̶l̶d̶ ̶n̶o̶t̶ ̶f̶i̶n̶d̶ ̶a̶n̶y̶ ̶s̶o̶l̶i̶d̶ ̶l̶i̶t̶e̶r̶a̶t̶u̶r̶e̶ ̶a̶b̶o̶u̶t̶ ̶i̶t̶.̶ O(n) (thanks to ChuntaoLu). But as slicing is optimized by the interpreter’s C code, it should run pretty fast. I’m pretty new to Python. Would appreciate you would give more insights or further optimization. Thus, here is the O(n) method: 123456789101112131415161718class Solution(object): def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; if len(s) == 0: return 0 maxLen = 1 start = 0 for i in xrange(len(s)): if i - maxLen &gt;= 1 and s[i-maxLen - 1: i+1] == s[i - maxLen-1:i+1][::-1]: start = i-maxLen -1 maxLen+= 2 continue if i - maxLen &gt;= 0 and s[i-maxLen:i+1] == s[i-maxLen:i+1][::-1]: start = i - maxLen maxLen += 1 return s[start:start+maxLen] https://discuss.leetcode.com/topic/20844/python-easy-to-understand-solution-with-comments-from-middle-to-two-ends Python easy to understand solution with comments (from middle to two ends). 12345678910111213141516171819def longestPalindrome(self, s): res = &quot;&quot; for i in xrange(len(s)): # odd case, like &quot;aba&quot; tmp = self.helper(s, i, i) if len(tmp) &gt; len(res): res = tmp # even case, like &quot;abba&quot; tmp = self.helper(s, i, i+1) if len(tmp) &gt; len(res): res = tmp return res # get the longest palindrome, l, r are the middle indexes # from inner to outerdef helper(self, s, l, r): while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]: l -= 1; r += 1 return s[l+1:r] java https://discuss.leetcode.com/topic/23498/very-simple-clean-java-solution The performance is pretty good, surprisingly. 12345678910111213141516171819202122232425public class Solution &#123;private int lo, maxLen;public String longestPalindrome(String s) &#123; int len = s.length(); if (len &lt; 2) return s; for (int i = 0; i &lt; len-1; i++) &#123; extendPalindrome(s, i, i); //assume odd length, try to extend Palindrome as possible extendPalindrome(s, i, i+1); //assume even length. &#125; return s.substring(lo, lo + maxLen);&#125;private void extendPalindrome(String s, int j, int k) &#123; while (j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k)) &#123; j--; k++; &#125; if (maxLen &lt; k - j - 1) &#123; lo = j + 1; maxLen = k - j - 1; &#125;&#125;&#125; https://discuss.leetcode.com/topic/21848/ac-relatively-short-and-very-clear-java-solution (AC) relatively short and very clear Java solution Key idea, every time we move to right, we only need to consider whether using this new character as tail could produce new palindrome string of length (current length +1) or (current length +2) 12345678910111213141516171819202122232425public class Solution &#123; public String longestPalindrome(String s) &#123; String res = &quot;&quot;; int currLength = 0; for(int i=0;i&lt;s.length();i++)&#123; if(isPalindrome(s,i-currLength-1,i))&#123; res = s.substring(i-currLength-1,i+1); currLength = currLength+2; &#125; else if(isPalindrome(s,i-currLength,i))&#123; res = s.substring(i-currLength,i+1); currLength = currLength+1; &#125; &#125; return res; &#125; public boolean isPalindrome(String s, int begin, int end)&#123; if(begin&lt;0) return false; while(begin&lt;end)&#123; if(s.charAt(begin++)!=s.charAt(end--)) return false; &#125; return true; &#125;&#125; For friends who are confused about the key idea to check only new palindrome with length = current length +2 or +1, I add some more explanation here. 12345678910Example: &quot;xxxbcbxxxxxa&quot;, (x is random character, not all x are equal) now we are dealing with the last character &apos;a&apos;. The current longest palindrome is &quot;bcb&quot; with length 3.1. check &quot;xxxxa&quot; so if it is palindrome we could get a new palindrome of length 5.2. check &quot;xxxa&quot; so if it is palindrome we could get a new palindrome of length 4.3. do NOT check &quot;xxa&quot; or any shorter string since the length of the new string is no bigger than current longest length.4. do NOT check &quot;xxxxxa&quot; or any longer string because if &quot;xxxxxa&quot; is palindrome then &quot;xxxx&quot; got from cutting off the head and tail is also palindrom. It has length &gt; 3 which is impossible.&apos; https://discuss.leetcode.com/topic/25500/share-my-java-solution-using-dynamic-programming Share my Java solution using dynamic programming dp(i, j) represents whether s(i … j) can form a palindromic substring, dp(i, j) is true when s(i) equals to s(j) and s(i+1 … j-1) is a palindromic substring. When we found a palindrome, check if it’s the longest one. Time complexity O(n^2). 123456789101112131415161718public String longestPalindrome(String s) &#123; int n = s.length(); String res = null; boolean[][] dp = new boolean[n][n]; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i; j &lt; n; j++) &#123; dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; 3 || dp[i + 1][j - 1]); if (dp[i][j] &amp;&amp; (res == null || j - i + 1 &gt; res.length())) &#123; res = s.substring(i, j + 1); &#125; &#125; &#125; return res;&#125; https://discuss.leetcode.com/topic/23498/very-simple-clean-java-solution 14ms, 79.15%, 23 July 2016 第一遍循环，针对每个索引，开始向两遍扩展，直到不能扩展为止。 123456789101112131415161718192021222324252627public class Solution &#123; private int lo, maxLen; public String longestPalindrome(String s) &#123; int len = s.length(); if(len &lt; 2) return s; for(int i=0; i&lt;len-1;i++)&#123; // assume odd length, try to extend Palindrome as possible extenPalindrome(s, i, i); //assume even length. extenPalindrome(s, i, i+1); &#125; return s.substring(lo, lo + maxLen); &#125; private void extenPalindrome(String s, int j, int k)&#123; while(j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k))&#123; j--; k++; &#125; if(maxLen &lt; k - j - 1)&#123; lo = j + 1; maxLen = k - j - 1; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[004. Median of Two Sorted Arrays]]></title>
    <url>%2Fp%2F82de9929%2F</url>
    <content type="text"><![CDATA[21.0% https://leetcode.com/problems/median-of-two-sorted-arrays/ There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 12345Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0 12345Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 cpp https://discuss.leetcode.com/topic/16797/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation Very concise O(log(min(M,N))) iterative solution with detailed explanation This problem is notoriously hard to implement due to all the corner cases. Most implementations consider odd-lengthed and even-lengthed arrays as two different cases and treat them separately. As a matter of fact, with a little mind twist. These two cases can be combined as one, leading to a very simple solution where (almost) no special treatment is needed. First, let’s see the concept of ‘MEDIAN’ in a slightly unconventional way. That is: 123&quot;if we cut the sorted array to two halves of EQUAL LENGTHS, thenmedian is the AVERAGE OF Max(lower_half) and Min(upper_half), i.e. thetwo numbers immediately next to the cut&quot;. For example, for [2 3 5 7], we make the cut between 3 and 5: 1[2 3 / 5 7] then the median = (3+5)/2. Note that I’ll use ‘/‘ to represent a cut, and (number / number) to represent a cut made through a number in this article. for [2 3 4 5 6], we make the cut right through 4 like this: [2 3 (4/4) 5 7] Since we split 4 into two halves, we say now both the lower and upper subarray contain 4. This notion also leads to the correct answer: (4 + 4) / 2 = 4; For convenience, let’s use L to represent the number immediately left to the cut, and R the right counterpart. In [2 3 5 7], for instance, we have L = 3 and R = 5, respectively. We observe the index of L and R have the following relationship with the length of the array N: 123456789N Index of L / R1 0 / 02 0 / 13 1 / 1 4 1 / 2 5 2 / 26 2 / 37 3 / 38 3 / 4 It is not hard to conclude that index of L = (N-1)/2, and R is at N/2. Thus, the median can be represented as 1(L + R)/2 = (A[(N-1)/2] + A[N/2])/2 To get ready for the two array situation, let’s add a few imaginary ‘positions’ (represented as #’s) in between numbers, and treat numbers as ‘positions’ as well. 12345[6 9 13 18] -&gt; [# 6 # 9 # 13 # 18 #] (N = 4)position index 0 1 2 3 4 5 6 7 8 (N_Position = 9) [6 9 11 13 18]-&gt; [# 6 # 9 # 11 # 13 # 18 #] (N = 5)position index 0 1 2 3 4 5 6 7 8 9 10 (N_Position = 11) As you can see, there are always exactly 2*N+1 ‘positions’ regardless of length N. Therefore, the middle cut should always be made on the Nth position (0-based). Since index(L) = (N-1)/2 and index(R) = N/2 in this situation, we can infer that index(L) = (CutPosition-1)/2, index(R) = (CutPosition)/2. Now for the two-array case: 123A1: [# 1 # 2 # 3 # 4 # 5 #] (N1 = 5, N1_positions = 11)A2: [# 1 # 1 # 1 # 1 #] (N2 = 4, N2_positions = 9) Similar to the one-array problem, we need to find a cut that divides the two arrays each into two halves such that 12&quot;any number in the two left halves&quot; &lt;= &quot;any number in the two righthalves&quot;. We can also make the following observations： There are 2N1 + 2N2 + 2 position altogether. Therefore, there must be exactly N1 + N2 positions on each side of the cut, and 2 positions directly on the cut. Therefore, when we cut at position C2 = K in A2, then the cut position in A1 must be C1 = N1 + N2 - k. For instance, if C2 = 2, then we must have C1 = 4 + 5 - C2 = 7. 123[# 1 # 2 # 3 # (4/4) # 5 #] [# 1 / 1 # 1 # 1 #] When the cuts are made, we’d have two L’s and two R’s. They are L1 = A1[(C1-1)/2]; R1 = A1[C1/2];L2 = A2[(C2-1)/2]; R2 = A2[C2/2];In the above example, 12L1 = A1[(7-1)/2] = A1[3] = 4; R1 = A1[7/2] = A1[3] = 4;L2 = A2[(2-1)/2] = A2[0] = 1; R2 = A1[2/2] = A1[1] = 1; Now how do we decide if this cut is the cut we want? Because L1, L2 are the greatest numbers on the left halves and R1, R2 are the smallest numbers on the right, we only need 1L1 &lt;= R1 &amp;&amp; L1 &lt;= R2 &amp;&amp; L2 &lt;= R1 &amp;&amp; L2 &lt;= R2 to make sure that any number in lower halves &lt;= any number in upper halves. As a matter of fact, sinceL1 &lt;= R1 and L2 &lt;= R2 are naturally guaranteed because A1 and A2 are sorted, we only need to make sure: L1 &lt;= R2 and L2 &lt;= R1. Now we can use simple binary search to find out the result. 12345678If we have L1 &gt; R1, it means there are too many large numbers on the left half of A1, then we must move C1 to the left (i.e. move C2 to the right); If L2 &gt; R1, then there are too many large numbers on the left half of A2, and we must move C2 to the left.Otherwise, this cut is the right one. After we find the cut, the medium can be computed as (max(L1, L2) + min(R1, R2)) / 2; Two side notes: A. since C1 and C2 can be mutually determined from each other, we might as well select the shorter array (say A2) and only move C2 around, and calculate C1 accordingly. That way we can achieve a run-time complexity of O(log(min(N1, N2))) B. The only edge case is when a cut falls on the 0th(first) or the 2Nth(last) position. For instance, if C2 = 2N2, then R2 = A2[2*N2/2] = A2[N2], which exceeds the boundary of the array. To solve this problem, we can imagine that both A1 and A2 actually have two extra elements, INT_MAX at A[-1] and INT_MAX at A[N]. These additions don’t change the result, but make the implementation easier: If any L falls out of the left boundary of the array, then L = INT_MIN, and if any R falls out of the right boundary, then R = INT_MAX. I know that was not very easy to understand, but all the above reasoning eventually boils down to the following concise code: 1234567891011121314151617181920212223double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int N1 = nums1.size(); int N2 = nums2.size(); if (N1 &lt; N2) return findMedianSortedArrays(nums2, nums1); // Make sure A2 is the shorter one. if (N2 == 0) return ((double)nums1[(N1-1)/2] + (double)nums1[N1/2])/2; // If A2 is empty int lo = 0, hi = N2 * 2; while (lo &lt;= hi) &#123; int mid2 = (lo + hi) / 2; // Try Cut 2 int mid1 = N1 + N2 - mid2; // Calculate Cut 1 accordingly double L1 = (mid1 == 0) ? INT_MIN : nums1[(mid1-1)/2]; // Get L1, R1, L2, R2 respectively double L2 = (mid2 == 0) ? INT_MIN : nums2[(mid2-1)/2]; double R1 = (mid1 == N1 * 2) ? INT_MAX : nums1[(mid1)/2]; double R2 = (mid2 == N2 * 2) ? INT_MAX : nums2[(mid2)/2]; if (L1 &gt; R2) lo = mid2 + 1; // A1&apos;s lower half is too big; need to move C1 left (C2 right) else if (L2 &gt; R1) hi = mid2 - 1; // A2&apos;s lower half too big; need to move C2 left. else return (max(L1,L2) + min(R1, R2)) / 2; // Otherwise, that&apos;s the right cut. &#125; return -1;&#125; If you have any suggestions to make the logic and implementation even more cleaner. Please do let me know! https://discuss.leetcode.com/topic/2778/share-my-simple-o-log-m-n-solution-for-your-reference Share my simple O(log(m+n)) solution for your reference Binary search. Call 2 times getkth and k is about half of (m + n). Every time call getkth can reduce the scale k to its half. So the time complexity is log(m + n). 12345678910111213141516171819202122232425class Solution &#123;public: int getkth(int s[], int m, int l[], int n, int k)&#123; // let m &lt;= n if (m &gt; n) return getkth(l, n, s, m, k); if (m == 0) return l[k - 1]; if (k == 1) return min(s[0], l[0]); int i = min(m, k / 2), j = min(n, k / 2); if (s[i - 1] &gt; l[j - 1]) return getkth(s, m, l + j, n - j, k - j); else return getkth(s + i, m - i, l, n, k - i); return 0; &#125; double findMedianSortedArrays(int A[], int m, int B[], int n) &#123; int l = (m + n + 1) &gt;&gt; 1; int r = (m + n + 2) &gt;&gt; 1; return (getkth(A, m ,B, n, l) + getkth(A, m, B, n, r)) / 2.0; &#125;&#125;; https://discuss.leetcode.com/topic/5728/share-one-divide-and-conquer-o-log-m-n-method-with-clear-description Share one divide and conquer O(log(m+n)) method with clear description // using divide and conquer idea, each time find the mid of both arrays 12345678910111213141516171819202122232425262728293031323334353637383940414243double findMedianSortedArrays(int A[], int m, int B[], int n) &#123; /* A[0, 1, 2, ..., n-1, n] */ /* A[0, 1, 2, ..., m-1, m] */ int k = (m + n + 1) / 2; double v = (double)FindKth(A, 0, m - 1, B, 0, n - 1, k); if ((m+n) % 2 == 0) &#123; int k2 = k+1; double v2 = (double)FindKth(A, 0, m - 1, B, 0, n - 1, k2); v = (v + v2) / 2; &#125; return v; &#125; // find the kth element int the two sorted arrays // let us say: A[aMid] &lt;= B[bMid], x: mid len of a, y: mid len of b, then wen can know // // (1) there will be at least (x + 1 + y) elements before bMid // (2) there will be at least (m - x - 1 + n - y) = m + n - (x + y +1) elements after aMid // therefore // if k &lt;= x + y + 1, find the kth element in a and b, but unconsidering bMid and its suffix // if k &gt; x + y + 1, find the k - (x + 1) th element in a and b, but unconsidering aMid and its prefix int FindKth(int A[], int aL, int aR, int B[], int bL, int bR, int k) &#123; if (aL &gt; aR) return B[bL + k - 1]; if (bL &gt; bR) return A[aL + k - 1]; int aMid = (aL + aR) / 2; int bMid = (bL + bR) / 2; if (A[aMid] &lt;= B[bMid]) &#123; if (k &lt;= (aMid - aL) + (bMid - bL) + 1) return FindKth(A, aL, aR, B, bL, bMid - 1, k); else return FindKth(A, aMid + 1, aR, B, bL, bR, k - (aMid - aL) - 1); &#125; else &#123; // A[aMid] &gt; B[bMid] if (k &lt;= (aMid - aL) + (bMid - bL) + 1) return FindKth(A, aL, aMid - 1, B, bL, bR, k); else return FindKth(A, aL, aR, B, bMid + 1, bR, k - (bMid - bL) - 1); &#125; &#125; https://discuss.leetcode.com/topic/11478/o-lg-m-n-c-solution-using-kth-smallest-number O(lg(m+n)) c++ solution using kth smallest number 1234567891011121314151617181920212223class Solution &#123;public: int kth(int a[], int m, int b[], int n, int k) &#123; if (m &lt; n) return kth(b,n,a,m,k); if (n==0) return a[k-1]; if (k==1) return min(a[0],b[0]); int j = min(n,k/2); int i = k-j; if (a[i-1] &gt; b[j-1]) return kth(a,i,b+j,n-j,k-j); return kth(a+i,m-i,b,j,k-i); &#125; double findMedianSortedArrays(int a[], int m, int b[], int n) &#123; int k = (m+n)/2; int m1 = kth(a,m,b,n,k+1); if ((m+n)%2==0) &#123; int m2 = kth(a,m,b,n,k); return ((double)m1+m2)/2.0; &#125; return m1; &#125;&#125;; https://discuss.leetcode.com/topic/26926/another-simple-and-neat-solution-binary-search-non-recursion-3-rows-of-core-code-o-log-min-m-n Another simple and neat solution, binary search, non-recursion, 3 rows of core code, O(log(min(m, n))) If you solve the k-th minmum value of two sorted arrays, you solve this problem.This is a classical problem of “Divide and conquer”. Here is another more simple and more neat solution. Cosider chosing first x numbers from A and k - x numbers from B.if these k numbers are the k minmum numbers of A and B, x must satisfies that A[x + 1] &gt;= B[k - x] and B[k - x + 1] &gt;= A[x] (for better explanation index is base-1). So this x is what we want. Obviously, if A[x + 1] &lt; B[k - x + 1] then x must be smaller, else if B[k - x] &lt; A[x] then x must be greater. A nice two-value definition for binary search :) To simplify edge cases, we cosider each array indefinite, with value of INTMIN when index &lt; 1 and INTMAX when index &gt; n. Here is the solution of c++ version: 12345678910111213141516171819202122232425typedef vector&lt;int&gt; vi;const int inf = 0x7fffffff, ninf = 0x80000000;class Solution &#123; int kth_min(vi&amp; a, vi&amp; b, int k, int n, int m)&#123; #define A(i) (i &lt; 1 ? ninf : (i &gt; n ? inf : a[i - 1])) #define B(i) (i &lt; 1 ? ninf : (i &gt; m ? inf : b[i - 1])) int l = 0, r = n + 1, x; while(l &lt;= r)&#123; x = (l + r) &gt;&gt; 1; if(A(x) &gt; B(k - x + 1)) r = x - 1; else if(B(k - x) &gt; A(x + 1)) l = x + 1; else return max(A(x), B(k - x)); &#125; return 0; //never execute , just to hide the warning :) #undef A #undef B &#125;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123; int n = a.size(), m = b.size(); if(n &gt; m) return findMedianSortedArrays(b, a); //make sure that a.size() &lt;= b.size() if((m + n) &amp; 1) return kth_min(a, b, (m + n + 1) &gt;&gt; 1, n, m); return (0.0 + kth_min(a, b, (m + n + 1) &gt;&gt; 1, n, m) + kth_min(a, b, ((m + n) &gt;&gt; 1) + 1, n, m)) * 0.5; &#125;&#125;; python https://discuss.leetcode.com/topic/4996/share-my-o-log-min-m-n-solution-with-explanation To solve this problem, we need to understand “What is the use of median”. In statistics, the median is used for dividing a set into two equal length subsets, that one subset is always greater than the other. If we understand the use of median for dividing, we are very close to the answer.1234First let&apos;s cut A into two parts at a random position i: left_A | right_AA[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1] Since A has m elements, so there are m+1 kinds of cutting( i = 0 ~ m ). And we know: len(left_A) = i, len(right_A) = m - i . Note: when i = 0 , left_A is empty, and when i = m , right_A is empty.1234With the same way, cut B into two parts at a random position j: left_B | right_BB[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] Put left_A and left_B into one set, and put right_A and right_B into another set.1234Let&apos;s name them left_part and right_part : left_part | right_partA[0], A[1], ..., A[i-1] | A[i], A[i+1], ..., A[m-1]B[0], B[1], ..., B[j-1] | B[j], B[j+1], ..., B[n-1] If we can ensure:121) len(left_part) == len(right_part)2) max(left_part) &lt;= min(right_part) then we divide all elements in {A, B} into two parts with equal length, and one part is always greater than the other. Then median = (max(left_part) + min(right_part))/2. To ensure these two conditions, we just need to ensure:123(1) i + j == m - i + n - j (or: m - i + n - j + 1) if n &gt;= m, we just need to set: i = 0 ~ m, j = (m + n + 1)/2 - i(2) B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j] (For simplicity, I presume A[i-1],B[j-1],A[i],B[j] are always valid even if i=0/i=m/j=0/j=n . I will talk about how to deal with these edge values at last.) So, all we need to do is:12Searching i in [0, m], to find an object `i` that: B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j], ( where j = (m + n + 1)/2 - i ) And we can do a binary search following steps described below:123456789101112131415161718192021222324&lt;1&gt; Set imin = 0, imax = m, then start searching in [imin, imax]&lt;2&gt; Set i = (imin + imax)/2, j = (m + n + 1)/2 - i&lt;3&gt; Now we have len(left_part)==len(right_part). And there are only 3 situations that we may encounter: &lt;a&gt; B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j] Means we have found the object `i`, so stop searching. &lt;b&gt; B[j-1] &gt; A[i] Means A[i] is too small. We must `ajust` i to get `B[j-1] &lt;= A[i]`. Can we `increase` i? Yes. Because when i is increased, j will be decreased. So B[j-1] is decreased and A[i] is increased, and `B[j-1] &lt;= A[i]` may be satisfied. Can we `decrease` i? `No!` Because when i is decreased, j will be increased. So B[j-1] is increased and A[i] is decreased, and B[j-1] &lt;= A[i] will be never satisfied. So we must `increase` i. That is, we must ajust the searching range to [i+1, imax]. So, set imin = i+1, and goto &lt;2&gt;. &lt;c&gt; A[i-1] &gt; B[j] Means A[i-1] is too big. And we must `decrease` i to get `A[i-1]&lt;=B[j]`. That is, we must ajust the searching range to [imin, i-1]. So, set imax = i-1, and goto &lt;2&gt;. When the object i is found, the median is:12max(A[i-1], B[j-1]) (when m + n is odd) 注释 odd 奇数or (max(A[i-1], B[j-1]) + min(A[i], B[j]))/2 (when m + n is even) Now let’s consider the edges values i=0,i=m,j=0,j=n where A[i-1],B[j-1],A[i],B[j] may not exist. Actually this situation is easier than you think. What we need to do is ensuring that max(left_part) &lt;= min(right_part). So, if i and j are not edges values(means A[i-1],B[j-1],A[i],B[j] all exist), then we must check both B[j-1] &lt;= A[i] and A[i-1] &lt;= B[j]. But if some of A[i-1],B[j-1],A[i],B[j] don’t exist, then we don’t need to check one(or both) of these two conditions. For example, if i=0, then A[i-1] doesn’t exist, then we don’t need to check A[i-1] &lt;= B[j]. So, what we need to do is:123456789101112131415Searching i in [0, m], to find an object `i` that: (j == 0 or i == m or B[j-1] &lt;= A[i]) and (i == 0 or j == n or A[i-1] &lt;= B[j]) where j = (m + n + 1)/2 - iAnd in a searching loop, we will encounter only three situations:&lt;a&gt; (j == 0 or i == m or B[j-1] &lt;= A[i]) and (i == 0 or j = n or A[i-1] &lt;= B[j]) Means i is perfect, we can stop searching.&lt;b&gt; j &gt; 0 and i &lt; m and B[j - 1] &gt; A[i] Means i is too small, we must increase it.&lt;c&gt; i &gt; 0 and j &lt; n and A[i - 1] &gt; B[j] Means i is too big, we must decrease it. Thank @Quentin.chen , him pointed out that: i &lt; m ==&gt; j &gt; 0 and i &gt; 0 ==&gt; j &lt; n . Because:12m &lt;= n, i &lt; m ==&gt; j = (m+n+1)/2 - i &gt; (m+n+1)/2 - m &gt;= (2*m+1)/2 - m &gt;= 0 m &lt;= n, i &gt; 0 ==&gt; j = (m+n+1)/2 - i &lt; (m+n+1)/2 &lt;= (2*n+1)/2 &lt;= n So in situation and , we don’t need to check whether j &gt; 0 and whether j &lt; n. Below is the accepted code:1234567891011121314151617181920212223242526272829303132def median(A, B): m, n = len(A), len(B) if m &gt; n: A, B, m, n = B, A, n, m if n == 0: raise ValueError imin, imax, half_len = 0, m, (m + n + 1) / 2 while imin &lt;= imax: i = (imin + imax) / 2 j = half_len - i if i &lt; m and B[j-1] &gt; A[i]: # i is too small, must increase it imin = i + 1 elif i &gt; 0 and A[i-1] &gt; B[j]: # i is too big, must decrease it imax = i - 1 else: # i is perfect if i == 0: max_of_left = B[j-1] elif j == 0: max_of_left = A[i-1] else: max_of_left = max(A[i-1], B[j-1]) if (m + n) % 2 == 1: return max_of_left if i == m: min_of_right = B[j] elif j == n: min_of_right = A[i] else: min_of_right = min(A[i], B[j]) return (max_of_left + min_of_right) / 2.0 https://leetcode.com/discuss/15790/share-my-o-log-min-m-n-solution-with-explanation 120ms, 86.12%, June.25th, 2016 12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def findMedianSortedArrays(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: float &quot;&quot;&quot; m, n = len(nums1), len(nums2) if m &gt; n: nums1, nums2, m, n = nums2, nums1, n, m if n == 0: raise ValueError imin, imax, half_len = 0, m, (m + n + 1) / 2 while imin &lt;= imax: i = (imin + imax) / 2 j = half_len - i if j &gt; 0 and i &lt; m and nums2[j-1] &gt; nums1[i]: # i is too small, must increase it imin = i + 1 elif i &gt; 0 and j &lt; n and nums1[i-1] &gt; nums2[j]: # i is too big, must decrease it imax = i - 1 else: # i is perfect if i == 0: max_of_left = nums2[j-1] elif j == 0: max_of_left = nums1[i-1] else: max_of_left = max(nums1[i-1], nums2[j-1]) if (m + n) % 2 == 1: return max_of_left if i == m: min_of_right = nums2[j] elif j == n: min_of_right = nums1[i] else: min_of_right = min(nums1[i], nums2[j]) return (max_of_left + min_of_right) / 2.0 https://leetcode.com/discuss/20897/intuitive-python-solution-smallest-two-sorted-arrays-252ms Intuitive Python O(log (m+n)) solution, by kth smallest in the two sorted arrays, 252ms 144ms, 30.79%, June.25th, 2016 The idea is in the comment: 12345678910111213141516171819202122232425262728293031class Solution(object): def findMedianSortedArrays(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: float &quot;&quot;&quot; l = len(nums1) + len(nums2) if l % 2 == 1: return self.kth(nums1, nums2, l // 2) else: return (self.kth(nums1, nums2, l // 2) + self.kth(nums1, nums2, l // 2 - 1)) / 2. def kth(self, a, b, k): if not a: return b[k] if not b: return a[k] ia, ib = len(a) // 2, len(b) // 2 ma, mb = a[ia], b[ib] if ia + ib &lt; k: if ma &gt; mb: return self.kth(a, b[ib + 1:], k - ib - 1) else: return self.kth(a[ia + 1:], b, k -ia - 1) else: if ma &gt; mb: return self.kth(a[:ia], b, k) else: return self.kth(a, b[:ib], k) https://discuss.leetcode.com/topic/22406/python-o-log-min-m-n-solution Python O(log(min(m,n)) solution It’s guaranteed to be O(log(min(m,n)) because every time the findKth function cuts the shorter array by half of its size. 123456789101112131415161718192021class Solution: # @return a float def findMedianSortedArrays(self, A, B): l=len(A)+len(B) return self.findKth(A,B,l//2) if l%2==1 else (self.findKth(A,B,l//2-1)+self.findKth(A,B,l//2))/2.0 def findKth(self,A,B,k): if len(A)&gt;len(B): A,B=B,A if not A: return B[k] if k==len(A)+len(B)-1: return max(A[-1],B[-1]) i=len(A)//2 j=k-i if A[i]&gt;B[j]: #Here I assume it is O(1) to get A[:i] and B[j:]. In python, it&apos;s not but in cpp it is. return self.findKth(A[:i],B[j:],i) else: return self.findKth(A[i:],B[:j],j) java https://discuss.leetcode.com/topic/3367/share-my-iterative-solution-with-o-log-min-n-m Share my iterative solution with O(log(min(n, m))) This is my iterative solution using binary search. The main idea is to find the approximate location of the median and compare the elements around it to get the final result. do binary search. suppose the shorter list is A with length n. the runtime is O(log(n)) which means no matter how large B array is, it only depends on the size of A. It makes sense because if A has only one element while B has 100 elements, the median must be one of A[0], B[49], and B[50] without check everything else. If A[0] &lt;= B[49], B[49] is the answer; if B[49] &lt; A[0] &lt;= B[50], A[0] is the answer; else, B[50] is the answer. After binary search, we get the approximate location of median. Now we just need to compare at most 4 elements to find the answer. This step is O(1). the same solution can be applied to find kth element of 2 sorted arrays. Here is the code: 123456789101112131415161718192021222324252627282930313233343536public double findMedianSortedArrays(int A[], int B[]) &#123;int n = A.length;int m = B.length;// the following call is to make sure len(A) &lt;= len(B).// yes, it calls itself, but at most once, shouldn&apos;t be// consider a recursive solutionif (n &gt; m) return findMedianSortedArrays(B, A);// now, do binary searchint k = (n + m - 1) / 2;int l = 0, r = Math.min(k, n); // r is n, NOT n-1, this is important!!while (l &lt; r) &#123; int midA = (l + r) / 2; int midB = k - midA; if (A[midA] &lt; B[midB]) l = midA + 1; else r = midA;&#125;// after binary search, we almost get the median because it must be between// these 4 numbers: A[l-1], A[l], B[k-l], and B[k-l+1] // if (n+m) is odd, the median is the larger one between A[l-1] and B[k-l].// and there are some corner cases we need to take care of.int a = Math.max(l &gt; 0 ? A[l - 1] : Integer.MIN_VALUE, k - l &gt;= 0 ? B[k - l] : Integer.MIN_VALUE);if (((n + m) &amp; 1) == 1) return (double) a;// if (n+m) is even, the median can be calculated by // median = (max(A[l-1], B[k-l]) + min(A[l], B[k-l+1]) / 2.0// also, there are some corner cases to take care of.int b = Math.min(l &lt; n ? A[l] : Integer.MAX_VALUE, k - l + 1 &lt; m ? B[k - l + 1] : Integer.MAX_VALUE);return (a + b) / 2.0;&#125; I’m lazy to type. But I found a very good pdf to explain my algorithm: http://ocw.alfaisal.edu/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/30C68118-E436-4FE3-8C79-6BAFBB07D935/0/ps9sol.pdf BTW: Thanks to xdxiaoxin. I’ve removed the check “midB &gt; k”. https://discuss.leetcode.com/topic/28602/concise-java-solution-based-on-binary-search Concise JAVA solution based on Binary Search Explanation The key point of this problem is to ignore half part of A and B each step recursively by comparing the median of remaining A and B: 123if (aMid &lt; bMid) Keep [aRight + bLeft]else Keep [bRight + aLeft] As the following: time=O(log(m + n)) 123456789101112131415161718192021public double findMedianSortedArrays(int[] A, int[] B) &#123; int m = A.length, n = B.length; int l = (m + n + 1) / 2; int r = (m + n + 2) / 2; return (getkth(A, 0, B, 0, l) + getkth(A, 0, B, 0, r)) / 2.0; &#125;public double getkth(int[] A, int aStart, int[] B, int bStart, int k) &#123; if (aStart &gt; A.length - 1) return B[bStart + k - 1]; if (bStart &gt; B.length - 1) return A[aStart + k - 1]; if (k == 1) return Math.min(A[aStart], B[bStart]); int aMid = Integer.MAX_VALUE, bMid = Integer.MAX_VALUE; if (aStart + k/2 - 1 &lt; A.length) aMid = A[aStart + k/2 - 1]; if (bStart + k/2 - 1 &lt; B.length) bMid = B[bStart + k/2 - 1]; if (aMid &lt; bMid) return getkth(A, aStart + k/2, B, bStart, k - k/2);// Check: aRight + bLeft else return getkth(A, aStart, B, bStart + k/2, k - k/2);// Check: bRight + aLeft&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>array</tag>
        <tag>divide and conquer</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[003. Longest Substring Without Repeating Characters]]></title>
    <url>%2Fp%2Ff34c3115%2F</url>
    <content type="text"><![CDATA[23.9% https://leetcode.com/problems/longest-substring-without-repeating-characters/ Given a string, find the length of the longest substring without repeating characters. Examples: Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. leetcode 3 leetcode 76 leetcode 159 相似，模板相似，学习一下 方法一： 使用哈希表维护值和值的index 方法二： 既然是对数字的哈希，不如使用数组来的方便。 我的代码实现一： 实现效果最好。 最开始index都指向-1，指向开始索引的前一个位置，就是-1。 然后start就是指向索引的前一个位置。 一个end从0开始遍历至最后，start指向前一个位置。 更新时，先更新start，然后是length，最后更新索引，end++。 1234567891011121314151617class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.size(); if(n&lt;=1) return n; vector&lt;int&gt; indexs(256, -1); int start = -1, end = 0, length=0; while(end &lt; n)&#123; start = max(start, indexs[s[end]]); length = max(length, end-start); indexs[s[end]] = end; end++; &#125; return length; &#125;&#125;; 我的代码实现二： 实现逻辑清晰，但是不如上面代码。 字符要用256位，不要用26位。 12345678910111213141516171819class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int res = 0; int start = 0; vector&lt;int&gt; v(256, -1); for(int i=0; i&lt;s.size(); i++)&#123; if(v[s[i]]!=-1)&#123; start = max(start, v[s[i]]+1); res = max(res, i-start+1); v[s[i]] = i; &#125;else&#123; res = max(res, i-start+1); v[s[i]] = i; &#125; &#125; return res; &#125;&#125;; 我的代码实现: 123456789101112131415class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; indexs(256, -1); int length = 0, start = -1, end = 0; int n = s.size(); while(end&lt;n)&#123; start = max(start, indexs[s[end]]); length = max(length, end-start); indexs[s[end]] = end; end++; &#125; return length; &#125;&#125;; code 1： https://discuss.leetcode.com/topic/4083/shortest-o-n-dp-solution-with-explanations Shortest O(n) DP solution with explanations 12345678910111213141516171819202122232425262728293031323334/** * Solution (DP, O(n)): * * Assume L[i] = s[m...i], denotes the longest substring without repeating * characters that ends up at s[i], and we keep a hashmap for every * characters between m ... i, while storing &lt;character, index&gt; in the * hashmap. * We know that each character will appear only once. * Then to find s[i+1]: * 1) if s[i+1] does not appear in hashmap * we can just add s[i+1] to hash map. and L[i+1] = s[m...i+1] * 2) if s[i+1] exists in hashmap, and the hashmap value (the index) is k * let m = max(m, k), then L[i+1] = s[m...i+1], we also need to update * entry in hashmap to mark the latest occurency of s[i+1]. * * Since we scan the string for only once, and the &apos;m&apos; will also move from * beginning to end for at most once. Overall complexity is O(n). * * If characters are all in ASCII, we could use array to mimic hashmap. */int lengthOfLongestSubstring(string s) &#123; // for ASCII char sequence, use this as a hashmap vector&lt;int&gt; charIndex(256, -1); int longest = 0, m = 0; for (int i = 0; i &lt; s.length(); i++) &#123; m = max(charIndex[s[i]] + 1, m); // automatically takes care of -1 case charIndex[s[i]] = i; longest = max(longest, i - m + 1); &#125; return longest;&#125; code 2： start 表示最长字符串起始的位置。 i表示终止的位置，或者说当前到达的位置。 1234567891011121314class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; dict(256, -1); int maxLen = 0, start = -1; for (int i = 0; i != s.length(); i++) &#123; if (dict[s[i]] &gt; start) start = dict[s[i]]; dict[s[i]] = i; maxLen = max(maxLen, i - start); &#125; return maxLen; &#125;&#125;; 方法三： 我的代码实现： 12345678910111213141516171819202122class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int start = 0, length = 0, end = 0, cnt = 0; vector&lt;int&gt; v(256, 0); int n = s.size(); while(end&lt;n)&#123; if(v[s[end]]==1) cnt++; v[s[end]]++; end++; while(cnt&gt;0)&#123; if(v[s[start]]==2) cnt--; v[s[start]]--; start++; &#125; length = max(length, end-start); &#125; return length; &#125;&#125;; 有模板的，下面是详情 12345678910int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; map(128,0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++&gt;0) counter++; while(counter&gt;0) if(map[s[begin++]]--&gt;1) counter--; d=max(d, end-begin); //while valid, update d &#125; return d; &#125; 我的代码实现一： 1234567891011121314151617181920212223class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.size(); if(n&lt;=1) return n; vector&lt;int&gt; indexs(256, 0); int left = 0, right = 0, counter = 0, length = 0; while(right&lt;n)&#123; if(indexs[s[right]]&gt;0) counter++; indexs[s[right]]++; right++; while(counter&gt;0)&#123; if(indexs[s[left]]&gt;1) counter--; indexs[s[left]]--; left++; &#125; length = max(length, right-left); &#125; return length; &#125;&#125;; 我的代码实现二： 1234567891011121314151617181920212223class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; if(s.empty()) return 0; int head = 0, end = 0, d = 0, cnt = 0; vector&lt;int&gt; v(256, 0); while(end &lt; s.size())&#123; if(v[s[end]]!=0) cnt++; v[s[end]]++; end++; while(cnt&gt;0)&#123; if(v[s[head]]&gt;1) cnt--; v[s[head]]--; head++; &#125; d = max(d, end - head); &#125; return d; &#125;&#125;; 学习区： https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems I will first give the solution then show you the magic template. The code of solving this problem is below. It might be the shortest among all solutions provided in Discuss. Minimum Window Substring 12345678910111213string minWindow(string s, string t) &#123; vector&lt;int&gt; map(128,0); for(auto c: t) map[c]++; int counter=t.size(), begin=0, end=0, d=INT_MAX, head=0; while(end&lt;s.size())&#123; if(map[s[end++]]--&gt;0) counter--; //in t while(counter==0)&#123; //valid if(end-begin&lt;d) d=end-(head=begin); if(map[s[begin++]]++==0) counter++; //make it invalid &#125; &#125; return d==INT_MAX? &quot;&quot;:s.substr(head, d); &#125; Here comes the template. For most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers. The template is given below. 12345678910111213141516171819202122232425int findSubstring(string s)&#123; vector&lt;int&gt; map(128,0); int counter; // check whether the substring is valid int begin=0, end=0; //two pointers, one point to tail and one head int d; //the length of substring for() &#123; /* initialize the hash map here */ &#125; while(end&lt;s.size())&#123; if(map[s[end++]]-- ?)&#123; /* modify counter here */ &#125; while(/* counter condition */)&#123; /* update d here if finding minimum*/ //increase begin to make it invalid/valid again if(map[s[begin++]]++ ?)&#123; /*modify counter here*/ &#125; &#125; /* update d here if finding maximum*/ &#125; return d; &#125; One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop. The code of solving Longest Substring with At Most Two Distinct Characters is below: 12345678910int lengthOfLongestSubstringTwoDistinct(string s) &#123; vector&lt;int&gt; map(128, 0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++==0) counter++; while(counter&gt;2) if(map[s[begin++]]--==1) counter--; d=max(d, end-begin); &#125; return d; &#125; The code of solving Longest Substring Without Repeating Characters is below: Update 01.04.2016, thanks @weiyi3 for advise. 12345678910int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; map(128,0); int counter=0, begin=0, end=0, d=0; while(end&lt;s.size())&#123; if(map[s[end++]]++&gt;0) counter++; while(counter&gt;0) if(map[s[begin++]]--&gt;1) counter--; d=max(d, end-begin); //while valid, update d &#125; return d; &#125; I think this post deserves some upvotes! : ) https://discuss.leetcode.com/topic/24739/c-code-in-9-lines 16ms, 62.39%, 23 July 2016 1234567891011121314class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; dict(256, -1); int maxLen = 0, start = -1; for (int i = 0; i != s.length(); i++) &#123; if (dict[s[i]] &gt; start) start = dict[s[i]]; dict[s[i]] = i; maxLen = max(maxLen, i - start); &#125; return maxLen; &#125;&#125;; https://discuss.leetcode.com/topic/1914/my-o-n-solution My O(n) Solution if only use DP, it’s an O(n*n) solution, adding a map to get O(n). 1234567891011121314151617181920class Solution &#123; public: int lengthOfLongestSubstring(string s) &#123; if(s.size()&lt;2) return s.size(); int d=1, maxLen=1; unordered_map&lt;char,int&gt; map; map[s[0]]=0; for(int i=1;i&lt;s.size();i++) &#123; if(map.count(s[i])==0 || map[s[i]]&lt;i-d) d++; else d= i- map[s[i]]; map[s[i]]=i; if(d&gt;maxLen) maxLen = d; &#125; return maxLen; &#125; &#125;; python https://discuss.leetcode.com/topic/11632/a-python-solution-85ms-o-n 104ms, 84.17%, 23 July 2016 1234567891011121314151617class Solution(object): def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; start = maxLength = 0 usedChar = &#123;&#125; for i in range(len(s)): if s[i] in usedChar and start &lt;= usedChar[s[i]]: start = usedChar[s[i]] + 1 else: maxLength = max(maxLength, i - start + 1) usedChar[s[i]] = i return maxLength java https://discuss.leetcode.com/topic/8232/11-line-simple-java-solution-o-n-with-explanation 11-line simple Java solution, O(n) with explanation the basic idea is, keep a hashmap which stores the characters in string as keys and their positions as values, and keep two pointers which define the max substring. move the right pointer to scan through the string , and meanwhile update the hashmap. If the character is already in the hashmap, then move the left pointer to the right of the same character last found. Note that the two pointers can only move forward. 12345678910111213public int lengthOfLongestSubstring(String s) &#123; if (s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max=0; for (int i=0, j=0; i&lt;s.length(); ++i)&#123; if (map.containsKey(s.charAt(i)))&#123; j = Math.max(j,map.get(s.charAt(i))+1); &#125; map.put(s.charAt(i),i); max = Math.max(max,i-j+1); &#125; return max;&#125; https://discuss.leetcode.com/topic/25499/share-my-java-solution-using-hashset Share my Java solution using HashSet The idea is use a hash set to track the longest substring without repeating characters so far, use a fast pointer j to see if character j is in the hash set or not, if not, great, add it to the hash set, move j forward and update the max length, otherwise, delete from the head by using a slow pointer i until we can put character j to the hash set. 123456789101112131415public int lengthOfLongestSubstring(String s) &#123; int i = 0, j = 0, max = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); while (j &lt; s.length()) &#123; if (!set.contains(s.charAt(j))) &#123; set.add(s.charAt(j++)); max = Math.max(max, set.size()); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return max;&#125; https://leetcode.com/articles/longest-substring-without-repeating-characters/ 思路：双指针，j在前，i在后，如果s[j]不包含，则添加进哈希表，如果包含，则去掉i，i向后走。123456789101112131415161718public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int ans = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) &#123; // try to extend the range [i, j] if (!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j++)); ans = Math.max(ans, j - i); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return ans; &#125;&#125; 思路：建立map，不仅存字符还存字符的位置 123456789101112131415public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) &#123; if (map.containsKey(s.charAt(j))) &#123; i = Math.max(map.get(s.charAt(j)), i); &#125; ans = Math.max(ans, j - i + 1); map.put(s.charAt(j), j + 1); &#125; return ans; &#125;&#125; 与上一段代码思路相同 一个是length为0，return 0，检查特殊情况。 一个是做一个hashmap，存入获取的操作要好好看看。 22ms, 31.97%, 23 July 2016 https://discuss.leetcode.com/topic/8232/11-line-simple-java-solution-o-n-with-explanation/11234567891011121314public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max = 0; for(int i=0, j=0; i &lt; s.length(); ++i)&#123; if(map.containsKey(s.charAt(i))) j = Math.max(j, map.get(s.charAt(i))+1); map.put(s.charAt(i), i); max = Math.max(max, i-j+1); &#125; return max; &#125;&#125; The previous implements all have no assumption on the charset of the string s. If we know that the charset is rather small, we can replace the Map with an integer array as direct access table. Commonly used tables are: 123int[26] for Letters &apos;a&apos; - &apos;z&apos; or &apos;A&apos; - &apos;Z&apos;int[128] for ASCIIint[256] for Extended ASCII 12345678910111213public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(), ans = 0; int[] index = new int[128]; // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) &#123; i = Math.max(index[s.charAt(j)], i); ans = Math.max(ans, j - i + 1); index[s.charAt(j)] = j + 1; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>medium</tag>
        <tag>hash table</tag>
        <tag>string</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[002. Add Two Numbers]]></title>
    <url>%2Fp%2F7dbbe8ef%2F</url>
    <content type="text"><![CDATA[26.7% https://leetcode.com/problems/add-two-numbers/ You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. 12Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 方法一：我的代码实现一： 1234567891011121314151617181920class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; if(!l1) return l2; else if(!l2) return l1; int carry = 0; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 || l2 || carry)&#123; carry += l1 ? l1-&gt;val : 0; carry += l2 ? l2-&gt;val : 0; cur-&gt;next = new ListNode(carry%10); cur = cur-&gt;next; carry /= 10; l1 = l1 ? l1-&gt;next : 0; l2 = l2 ? l2-&gt;next : 0; &#125; return dummy-&gt;next; &#125;&#125;; 我的代码实现二： 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); int carry = 0; ListNode* cur = dummy; while(l1 || l2 || carry)&#123; carry += l1 ? l1-&gt;val : 0; carry += l2 ? l2-&gt;val : 0; cur-&gt;next = new ListNode(carry%10); carry /= 10; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; cur = cur-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;; 40ms, 24.98%, 17 July 2016 12345678910111213141516class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while(l1 || l2 || extra)&#123; int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + extra; extra = sum / 10; p-&gt;next = new ListNode(sum % 10); p = p-&gt;next; l1 = l1 ? l1-&gt;next : l1; l2 = l2 ? l2-&gt;next : l2; &#125; return preHead.next; &#125;&#125;; https://discuss.leetcode.com/topic/5905/c-sharing-my-11-line-c-solution-can-someone-make-it-even-more-concise/4 How about this? 123456789101112ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) &#123; ListNode preHead(0), *p = &amp;preHead; int extra = 0; while (l1 || l2 || extra) &#123; if (l1) extra += l1-&gt;val, l1 = l1-&gt;next; if (l2) extra += l2-&gt;val, l2 = l2-&gt;next; p-&gt;next = new ListNode(extra % 10); extra /= 10; p = p-&gt;next; &#125; return preHead.next;&#125; python https://discuss.leetcode.com/topic/21192/python-concise-solution 188ms, 7.15%, 17 July 2016 Python concise solution. 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; dummy = cur = ListNode(0) carry = 0 while l1 or l2 or carry: if l1: carry += l1.val l1 = l1.next if l2: carry += l2.val l2 = l2.next cur.next = ListNode(carry%10) cur = cur.next carry //= 10 return dummy.next https://discuss.leetcode.com/topic/8909/clear-python-code-straight-forward 172ms, 15.49%, 17 July 2016 Clear python code, straight forward 123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; carry = 0 root = n = ListNode(0) while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry, 10) n.next = ListNode(val) n = n.next return root.next https://discuss.leetcode.com/topic/8909/clear-python-code-straight-forward 1234567891011121314151617class Solution:# @return a ListNodedef addTwoNumbers(self, l1, l2): carry = 0 root = n = ListNode(0) while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry, 10) n.next = ListNode(val) n = n.next return root.next https://discuss.leetcode.com/topic/14575/python-for-the-win Python for the win Python supports arbitrarily large integers, so I can safely turn the two lists into ints, add them, and turn the sum into a list. 12345678910class Solution: def addTwoNumbers(self, l1, l2): def toint(node): return node.val + 10 * toint(node.next) if node else 0 def tolist(n): node = ListNode(n % 10) if n &gt; 9: node.next = tolist(n / 10) return node return tolist(toint(l1) + toint(l2)) Iterative tolist instead of recursive: 12345678910class Solution: def addTwoNumbers(self, l1, l2): def toint(node): return node.val + 10 * toint(node.next) if node else 0 n = toint(l1) + toint(l2) first = last = ListNode(n % 10) while n &gt; 9: n /= 10 last.next = last = ListNode(n % 10) return first And a very different solution that could sum arbitrarily many addends, not just two: 1234567891011class Solution: def addTwoNumbers(self, l1, l2): addends = l1, l2 dummy = end = ListNode(0) carry = 0 while addends or carry: carry += sum(a.val for a in addends) addends = [a.next for a in addends if a.next] end.next = end = ListNode(carry % 10) carry /= 10 return dummy.next java https://leetcode.com/articles/add-two-numbers/ Time complexity : O(\max(m, n))O(max(m,n)). Assume that mm and nn represents the length of l1l1 and l2l2 respectively, the algorithm above iterates at most \max(m, n)max(m,n) times. Space complexity : O(\max(m, n))O(max(m,n)). The length of the new list is at most \max(m,n) + 1max(m,n)+1. 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next; &#125;&#125; 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode c1 = l1; ListNode c2 = l2; ListNode sentinel = new ListNode(0); ListNode d = sentinel; int sum = 0; while (c1 != null || c2 != null) &#123; sum /= 10; if (c1 != null) &#123; sum += c1.val; c1 = c1.next; &#125; if (c2 != null) &#123; sum += c2.val; c2 = c2.next; &#125; d.next = new ListNode(sum % 10); d = d.next; &#125; if (sum / 10 == 1) d.next = new ListNode(1); return sentinel.next; &#125;&#125; https://discuss.leetcode.com/topic/799/is-this-algorithm-optimal-or-what Is this Algorithm optimal or what? 12345678910111213141516171819202122232425public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode c1 = l1; ListNode c2 = l2; ListNode sentinel = new ListNode(0); ListNode d = sentinel; int sum = 0; while (c1 != null || c2 != null) &#123; sum /= 10; if (c1 != null) &#123; sum += c1.val; c1 = c1.next; &#125; if (c2 != null) &#123; sum += c2.val; c2 = c2.next; &#125; d.next = new ListNode(sum % 10); d = d.next; &#125; if (sum / 10 == 1) d.next = new ListNode(1); return sentinel.next; &#125;&#125; https://discuss.leetcode.com/topic/6220/my-accepted-java-solution My accepted Java solution Two things to make the code simple: Whenever one of the two ListNode is null, replace it with 0. Keep the while loop going when at least one of the three conditions is met. Let me know if there is something wrong. Thanks. 12345678910111213141516171819public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode prev = new ListNode(0); ListNode head = prev; int carry = 0; while (l1 != null || l2 != null || carry != 0) &#123; ListNode cur = new ListNode(0); int sum = ((l2 == null) ? 0 : l2.val) + ((l1 == null) ? 0 : l1.val) + carry; cur.val = sum % 10; carry = sum / 10; prev.next = cur; prev = cur; l1 = (l1 == null) ? l1 : l1.next; l2 = (l2 == null) ? l2 : l2.next; &#125; return head.next; &#125;&#125; https://discuss.leetcode.com/topic/39130/4ms-11lines-java-solution 4ms 11lines java solution 1234567891011121314151617public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode ln1 = l1, ln2 = l2, head = null, node = null; int carry = 0, remainder = 0, sum = 0; head = node = new ListNode(0); while(ln1 != null || ln2 != null || carry != 0) &#123; sum = (ln1 != null ? ln1.val : 0) + (ln2 != null ? ln2.val : 0) + carry; carry = sum / 10; remainder = sum % 10; node = node.next = new ListNode(remainder); ln1 = (ln1 != null ? ln1.next : null); ln2 = (ln2 != null ? ln2.next : null); &#125; return head.next; &#125;&#125; https://discuss.leetcode.com/topic/44133/java-concise-solution Java concise solution. 12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int carry = 0; ListNode p, dummy = new ListNode(0); p = dummy; while (l1 != null || l2 != null || carry != 0) &#123; if (l1 != null) &#123; carry += l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; carry += l2.val; l2 = l2.next; &#125; p.next = new ListNode(carry%10); carry /= 10; p = p.next; &#125; return dummy.next;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
        <tag>linked list</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[001. Two Sum]]></title>
    <url>%2Fp%2F6bed6d6%2F</url>
    <content type="text"><![CDATA[31.0% https://leetcode.com/problems/two-sum/ Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. 12345Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. UPDATE (2016/2/13): The return format had been changed to zero-based indices. Please read the above updated description carefully. 思路 方法一： dic, 全部都放入dic, 依次遍历，查找当前值target缺的那部分，要缺的index大于当前的index。 1234567891011121314151617181920// 面试奇虎360时曾遇到过 // beats 45.40% of cppsubmissions.class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; mapping; vector&lt;int&gt; result; for(int i = 0; i &lt; nums.size(); i++)&#123; mapping[nums[i]] = i; &#125; for(int i = 0; i &lt; nums.size(); i++)&#123; const int gap = target - nums[i]; if(mapping.find(gap) != mapping.end() &amp;&amp; mapping[gap] &gt; i)&#123; result.push_back(i); result.push_back(mapping[gap]); &#125; &#125; return result; &#125;&#125;; 方法二： 一遍遍历，一边放入dic 代码实现一: 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res; unordered_map&lt;int, int&gt; map; for(int i=0; i&lt;nums.size(); i++)&#123; int nex = target - nums[i]; if(map.find(nex)!=map.end())&#123; res.push_back(i); res.push_back(map[nex]); break; &#125;else&#123; map[nums[i]] = i; &#125; &#125; return res; &#125;&#125;; 代码实现二： 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2, -1); unordered_map&lt;int, int&gt; map; for(int i=0; i&lt;nums.size(); i++)&#123; int gap = target - nums[i]; if(map.count(gap))&#123; res[0] = map[gap]; res[1] = i; return res; &#125;else map[nums[i]] = i; &#125; &#125;&#125;; 48ms, 59.36%, Apr.23rd, 2016 找出数组中的两个数，这两个数和为target 扫到x时看前面Hash的数里有没有target-x，然后将x也放进Hash表。 12345678910111213class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; dict = &#123;&#125; for i in range(len(nums)): if dict.get(target - nums[i], None) == None: dict[nums[i]] = i else: return (dict[target - nums[i]], i) my code 123456789101112class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; maps = &#123;&#125; for i, num in enumerate(nums): if target-num in maps: return [i, maps[target-num]] maps[num] = i 下面这个方法速度特慢，原因:对每个元素都进行了哈希，总之，无论建立还是查找都费了时间。 上面一种方法，注意，python字典有get方法 1234567891011class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; dict = &#123;n: i for i, n in enumerate(nums)&#125; for i, n in enumerate(nums): if target-n in dict.keys() and dict[target-n] != i: return [i, dict[target-n]] java https://leetcode.com/articles/two-sum/ Approach #2 (Two-pass Hash Table) [Accepted] To improve our run time complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to look up its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table. We reduce the look up time from O(n)O(n) to O(1)O(1) by trading space for speed. A hash table is built exactly for this purpose, it supports fast look up in near constant time. I say “near” because if a collision occurred, a look up could degenerate to O(n)O(n) time. But look up in hash table should be amortized O(1)O(1) time as long as the hash function was chosen carefully. A simple implementation uses two iterations. In the first iteration, we add each element’s value and its index to the table. Then, in the second iteration we check if each element’s complement (target - nums[i]target−nums[i]) exists in the table. Beware that the complement must not be nums[i]nums[i] itself!12345678910111213public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; return new int[] &#123; i, map.get(complement) &#125;; &#125; &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;);&#125; Complexity Analysis: Time complexity : O(n)O(n). We traverse the list containing nn elements exactly twice. Since the hash table reduces the look up time to O(1)O(1), the time complexity is O(n)O(n). Space complexity : O(n)O(n). The extra space required depends on the number of items stored in the hash table, which stores exactly nn elements. Approach #3 (One-pass Hash Table) [Accepted] It turns out we can do it in one-pass. While we iterate and inserting elements into the table, we also look back to check if current element’s complement already exists in the table. If it exists, we have found a solution and return immediately.1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;);&#125; Complexity Analysis: Time complexity : O(n)O(n). We traverse the list containing nn elements only once. Each look up in the table costs only O(1)O(1) time. Space complexity : O(n)O(n). The extra space required depends on the number of items stored in the hash table, which stores at most nn elements.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
        <tag>hash table</tag>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Multi-objective Learning and Mask-based Post-processing for Deep Neural Network based Speech Enhancement》阅读笔记]]></title>
    <url>%2Fp%2F719f3cc0%2F</url>
    <content type="text"><![CDATA[这是2017年Xu Yong关于使用多任务学习和使用mask做后处理做语音增强的一篇论文[1]。 同样有github源码[2]及展示demo[3,4]。 论文原文：Multi-objective Learning and Mask-based Post-processing for Deep Neural Network based Speech Enhancement 1. Abstract论文主要的学习目标是clean log-power spectra (LPS) features，因为LPS可以直接用于构造增强后的信号。作为多任务学习，使用了附加的架构，去学习比如MFCC特征，同时去学习类别信息，比如ideal binary mask (IBM)。这些特征其实也是对DNN的一种限制，潜在的能提高LPS这个首要目标的效果。 2. Introduction3. Multi-objective Learning for DNN-based Speech Enhancement多任务学习框架如下图图1所示： 输入是带噪语音信号，输出是干净音频信号。只是输入输出有时有带噪的特征，输出是干净的特征。输出有时有类别信息。 公式2是单独的dnn+LPS训练的误差函数，公式3是多输出的。 3.1 Joint Prediction of LPS with MFCC这个就是LPS和MFCC两个的多输出了。 3.2 Joint Prediction of LPS with IBM同上，LPS+IBM 3.3 IBM-based Post-processingIBM用于LPS的后处理。如公式3，如果IBM大于一定阈值，说明SNR很高，就不必做语音增强了，所以直接用原始的语音信息。如果中间就是原始信息和增强后的信息的均值。如果低于一定阈值，就是使用处理后的信息。 4. Experimental Results and Analysis 5. Conclusion本文提出了多目标学习以改善语音增强的DNN训练。 显示目标函数中添加来自MFCC或IBM等功能的约束可获得更准确的干净的LPS估计。 MFCC可以使对数频谱失真在低频下更加一致; IBM可以明确表示T-F单元的语音呈现信息，因此可以提供更高的SSNR。 此外，可以采用估计的IBM来进行后期处理，以减轻基于回归的DNN中的高估或低估问题。 基于IBM的后处理对于减少语音失真至关重要，特别是在高信噪比T-F单元。 参考资料： https://arxiv.org/abs/1703.07172 https://github.com/yongxuUSTC/sednn http://staff.ustc.edu.cn/~jundu/The%20team/yongxu/demo/SE_DNN_taslp.html http://staff.ustc.edu.cn/~jundu/The%20team/yongxu/demo/IS15.html http://yucc.me/p/719f3cc0/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>speech enhancement</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《SEGAN: Speech Enhancement Generative Adversarial Network》阅读笔记]]></title>
    <url>%2Fp%2Fbea139a%2F</url>
    <content type="text"><![CDATA[本论文是2017年的一篇使用GAN网络做单声道语音增强的论文[1]，在github上有作者的开源代码[2]，语音增强的效果有官方示例[3]。 论文原文：SEGAN: Speech Enhancement Generative Adversarial Network 1. Introduction经典的语音增强（speech enhancement）方法有谱减法（spectral subtraction）、维纳滤波（Wiener filtering）、统计模型（statistical model-based methods）和子空间算法（subspace algorithms）。 其中统计模型有最大似然、贝叶斯、MMSE及Log-MMSE。 论文给予GAN网络（Generative Adversarial Networks）提出了segan（speech enhancementGAN），segan主要优势有三点： 它提供了一个快速语音增强过程。 没有因果关系是必需的，因此没有像RNN那样的递归操作。 它基于原始音频做处理。 因此，没有提取手工特征，因此没有对原始数据做出明确的假设。 从不同的说话人和噪声类型中学习，并将它们合并到相同的共享参数中。这使得系统在这些维度上变得简单和一般化。 2. Generative Adversarial Networks这节是GAN网络的介绍。如果有GAN网络基础，可以跳过此节。 GAN网络能是一种对抗性模型，可以将样本服从Z分布的样本z映射到服从X分布的x。 来理解这句话。在我们这里，可以理解为Z为含噪声的语音的分布，z为其中的一个样本。X为纯净语音的分布，x为其中的一个样本。 GAN中，有两个单元，一个负责映射，叫做生成器G，另一个负责判别，叫做判别器D。G负责映射，G的映射负责从Z分布映射到X分布，不同于传统的输入输出映射。判别器D是一个二分类器，输出值是0-1之间的数字。 G将样本z映射为$\hat{x}$，而真实样本为$x$，G的目的是尽可能的使$\hat{x}$与$x$相似，以迷惑判别器D。而D的功能是区分真实样本$x$和G生成的样本$\hat{x}$，真实样本尽可能的判为1，G生成的尽可能的判为0。所以G的目的在于迷惑D，而D的目的是不被G迷惑。所以叫生成对抗网络。 于是就有了对抗网络的基本公式： 其中pdata(x)表示真实样本，pz(z)表示经过G之前的样本。 意义就很明显了，对于D优化的目标就是希望真实样本输出越大，生成的样本尽可能输出小，使得结果最大。对于G，希望生成的时候，尽可能的骗过D，使得目标函数最小。 下面的公式2是带额外信息的GAN。 一些论文致力于提升GAN网络生成的质量。比如，在原始的训练中，由于使用sigmoid交叉熵损失，会出现梯度消失的问题。这时，可以将损失替换为最小平方（least square）的Least Square GAN（LSGAN）方法。结果如下： 关于gan的更多解释： 有人说GAN强大之处在于可以自动的学习原始真实样本集的数据分布，不管这个分布多么的复杂，只要训练的足够好就可以学出来。针对这一点，感觉有必要好好理解一下为什么别人会这么说。 我们知道，传统的机器学习方法，我们一般都会定义一个什么模型让数据去学习。比如说假设我们知道原始数据属于高斯分布呀，只是不知道高斯分布的参数，这个时候我们定义高斯分布，然后利用数据去学习高斯分布的参数得到我们最终的模型。再比如说我们定义一个分类器，比如SVM，然后强行让数据进行东变西变，进行各种高维映射，最后可以变成一个简单的分布，SVM可以很轻易的进行二分类分开，其实SVM已经放松了这种映射关系了，但是也是给了一个模型，这个模型就是核映射（什么径向基函数等等），说白了其实也好像是你事先知道让数据该怎么映射一样，只是核映射的参数可以学习罢了。 所有的这些方法都在直接或者间接的告诉数据你该怎么映射一样，只是不同的映射方法能力不一样。那么我们再来看看GAN，生成模型最后可以通过噪声生成一个完整的真实数据（比如人脸），说明生成模型已经掌握了从随机噪声到人脸数据的分布规律了，有了这个规律，想生成人脸还不容易。然而这个规律我们开始知道吗？显然不知道，如果让你说从随机噪声到人脸应该服从什么分布，你不可能知道。这是一层层映射之后组合起来的非常复杂的分布映射规律。然而GAN的机制可以学习到，也就是说GAN学习到了真实样本集的数据分布。 再拿原论文中的一张图来解释： 这张图表明的是GAN的生成网络如何一步步从均匀分布学习到正太分布的。原始数据x服从正太分布，这个过程你也没告诉生成网络说你得用正太分布来学习，但是生成网络学习到了。假设你改一下x的分布，不管什么分布，生成网络可能也能学到。这就是GAN可以自动学习真实数据的分布的强大之处。 还有人说GAN强大之处在于可以自动的定义潜在损失函数。 什么意思呢，这应该说的是判别网络可以自动学习到一个好的判别方法，其实就是等效的理解为可以学习到好的损失函数，来比较好或者不好的判别出来结果。虽然大的loss函数还是我们人为定义的，基本上对于多数GAN也都这么定义就可以了，但是判别网络潜在学习到的损失函数隐藏在网络之中，不同的问题这个函数就不一样，所以说可以自动学习这个潜在的损失函数。 3. Speech Enhancement GAN &amp;&amp; Experimental Setup这部分是本文的而核心SEGAN。 整个网络全部是由CNN组成。 下图是生成器G，它是一个encoder-decoder。D的结构是encoder，上面接了一个降维层。将8* 1024个参数降为8个。 encoder由步长为2的1维卷积层构成。16384×1, 8192×16, 4096×32, 2048×32, 1024×64, 512×64, 256×128, 128×128, 64×256,32×256, 16×512, and 8×1024。 至于SEGAN的训练，其实跟普通的GAN很类似。如下图所示，先训练一个判别器D。D的输入为纯净信号和经过生成器增强后的信号。然后再固定判别器D，改变生成器G的参数。 其中，有一点，在初步实验中，我们发现在G的损失中增加一个次要成分是很方便的，以便将它的世代与干净的例子之间的距离减至最小。 为了测量这种距离，我们选择了L1范数，因为它已被证明在图像处理领域有效。 所以最终G的损失函数如公式6： 4. Results分为客观和主观评价两部分。 4.1 Objective Evaluation客观评价，有以下几个指标，都是越大越好： PESQ: Perceptual evaluation of speech quality, using the wide-band version recommended in ITU-T P.862.2 (from –0.5 to 4.5).主观语音质量评估，虽然叫主观，实际还是个客观的值。 CSIG: Mean opinion score (MOS) prediction of the signal distortion attending only to the speech signal(from 1to 5). CBAK: MOS prediction of the intrusiveness of background noise (from 1 to 5). COVL: MOS prediction of the overall effect(from 1 to 5). SSNR: Segmental SNR (from 0 to ∞). 结果如下图： 可以看到，segan在PESQ指标上表现稍微差一点。在所有其他指标上，这些指标更与语音失真有关系，segan都比wiener更好。segan产生更少的语音失真（CSIG）和移除噪声更有效（CBAK和SSNR）。所以，segan能在二者之间取得更好的权衡。 4.2 Subjective Evaluation主观描述，就是一段音频，给出它原始音频、wiener处理的音频、segan处理后的音频，不显示具体哪个对应哪个，让被测试者打分，1-5之间，分数越高代表越好。 16个测试者，20个句子。效果如下图。 5. Conclusions在这项工作中，端对端语音增强方法已经在生成对抗框架内实施。该模型使用编码器-解码器完全卷积结构，使得它能够快速操作来对波形块进行去噪。 结果表明，不仅该方法是可行的，而且它也可以作当前方法的有效替代。 疑惑： 对称的解卷积是如何做的？ 参考资料： https://arxiv.org/abs/1703.09452 https://github.com/santi-pdp/segan http://veu.talp.cat/segan/ https://mp.weixin.qq.com/s?__biz=MjM5ODU3OTIyOA==&amp;mid=2650668193&amp;idx=3&amp;sn=19157c2124a9731094e23e67fd846abd&amp;scene=19#wechat_redirect https://v.qq.com/x/page/m05070a168l.html https://mp.weixin.qq.com/s?__biz=MzAwNDI4ODcxNA==&amp;mid=2652247409&amp;idx=2&amp;sn=0373c6984e722dd6542e2bc8fd983936&amp;chksm=80cc8cd4b7bb05c22cb61616307525fbb7ce5846707c5289999359704ec219aff2a9968b12d6&amp;scene=0#rd http://yucc.me/p/bea139a/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>speech enhancement</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vultr搭建vpn（shadowsocks）科学上网/翻墙并支持北邮人bt（ipv6）下载教程]]></title>
    <url>%2Fp%2Fb4d20b2d%2F</url>
    <content type="text"><![CDATA[学习本教程，主要收获会有两个。一个是科学上网，一个能够去北邮人bt或晨光pt（六维bt不适用）上传下载资源。内容概要如下，如果只为了科学上网，学习1-3即可。需要支持北邮人bt或晨光pt看1-4，服务器管理相关的内容放在了5，章节6主要是一些问题的解决办法。内容主要是以win、mac为例写的，android的科学上网也可以跟着本教程来。内容概要： vultr购买VPS服务器 在服务器上搭建shadowsocks 在win、mac或Android中配置shadowsocks 配置utorrent，支持北邮人bt 服务器管理说明 Q &amp; A 1. vultr上购买VPS服务器要科学上网，需要使用到VPS服务器，本教程推荐使用的是vultr，除了vultr也可以使用其他的VPS，效果类似，服务器务必支持ipv4及ipv6。一些同学用的搬瓦工，跟我的可能会有些不同，本教程只讲vultr搭建的过程。 1.1 注册及交费这一步就非常简单了，用下面的链接注册： https://www.vultr.com/?ref=7402906 1.2 购买服务器注册完账户，并充值后。进入以下网址购买服务器。 https://my.vultr.com/deploy/ Server Location自己随意选，Server Type自己随意，建议用centos。Server Size随意，现在2.5美元那个只支持ipv6，如果支持ipv4的话需要再花钱买支持ipv4。所以这里建议使用5美元的服务器，同时支持ipv4及ipv6，简单省事。 Additional Features中，如果想支持ipv6， 访问北邮人bt，那么Enable IPv6必选。 然后点击Deploy Now。 然后跳转或访问以下网址： https://my.vultr.com/ 就能看到自己的ip地址（IP address）、用户名（Username，通常是root）和密码（password）了。 1.3 ping ip，检查ip地址是否被墙这一步，win系统的同学需要打开cmd（mac对应为“终端”）输入 ping ip并按回车，检查是否被墙。其中ip需要替换为你上一步看到的ip地址。 如果没有出现time out。恭喜这个没问题。如果你不知道如何打开cmd，可以自行百度或google，或跳过此步骤。 如果ping不通，出现time out，说明该ip可能被墙了。建议把该服务器销毁，重新走1.2的步骤。vultr是按小时或分钟计费的，所以销毁再买服务器的费用几乎可以忽略不计。 2. 在服务器上搭建shadowsocks2.1 下载xshell并登录服务器win下，可以使用xshell来登录。 可以下载好xshell。 xshel下载链接: https://pan.baidu.com/s/1ufbvTXJs8weVJJTkL8FQFQ 密码: 6sfz。 mac环境下，使用“终端(terminal)”或“iterm2”，一样的效果。 在黑窗口里输入一下代码： 1ssh root@ip 其中ip替换为你自己的ip地址。然后会弹出弹出一个框，输入你前几步提到的密码，并回车（enter键）。至此，你已经登陆了。 2.2 服务器上部署shadowsocks在刚才登录的xshell服务器上，输入以下代码。 123wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 按照提示输入密码、端口号、加密方式等就好了。注意端口号不要太大，建议使用1000以内的。 安装完成后显示效果如下，可以截图保存这些信息下面配置会用的到： 12345678910Congratulations, Shadowsocks-python server install completed!Your Server IP : your ipYour Server Port : your portYour Password : your passwordYour Encryption Method: your encryption methodWelcome to visit:https://teddysun.com/342.htmlEnjoy it![root@vultr ~]# 至此，服务器端的配置已经完成。 3. 在win、mac或Android中配置shadowsocks3.1 下载shadowsocks客户端Windows：https://github.com/shadowsocks/shadowsocks-windows/releases Android：https://github.com/shadowsocks/shadowsocks-android/releases mac：https://github.com/shadowsocks/ShadowsocksX-NG/releases ubuntu的配置较为复杂，可以参考[4]。 3.2 配置shadowsocks客户端以win为例，下载，并解压缩后，运行shadowsocks。输入ip，port，password，及encryption点击确定。 然后再桌面右下角找到shadowsocks，右键点击勾选上“Enable System Proxy”（启用系统代理）。此时就可以愉快的科学上网了。 请注意，如果win下面提示去安装.net4.5还是更高的框架时，按照提示去安装就好了。安装完再打开shadowsocks运行上面的步骤。 如果是mac，解压缩后运行，在上面点击那个小飞机，出现下拉栏“服务器-新服务器”-“服务器设置”。同样是输入地址、端口、加密方法、密码，并点击确定。类似于win，有可能需要点击勾选“Enable System Proxy”（启用系统代理）。 如果是Android，则点击右上角的较好，进去配置服务器、远程端口、密码、加密方式、路由，然后点击右上角的对号进行保存。 然后，选中刚才配置的vpn，然后点击右下角有个飞机的那个圆圈，就可以了。快来测试下吧！ 有可能需要关闭并重新打开shadowsocks的操作，有可能不需要。打开你的浏览器，输入 https://www.google.com/ ，那么见证奇迹的时刻到了。 至此，电脑及手机的科学上网已经配置完成。 此外，正常情况下，会默认国内网站直连，国外走代理，没有问题的。但是一些网站需要走代理，但是并没有走代理的话，可以参照4.1的方法，将网站相应的网址加入走代理的列表里，重启shadowsocks即可。 4. 配置utorrent，支持北邮人bt两步，第一步将北邮人bt的网址加入支持翻墙的列表，第二步配置utorrent。都很简单。 4.1 配置shadowsocks首先通过 右键Shadowsocks托盘图标 &gt;-&gt; PAC &gt;-&gt; 编辑 GFWList 的用户规则（或 Edit User rule for GFWList） 来打开user-rule.txt。（mac用户，点击小飞机，“编辑PAC用户自定规则”） 添加如下规则并保存： 1||bt.byr.cn^ 效果如下图： 此时关闭shadowsocks，并重新打开。在地址栏里输入北邮人bt的网址: https://bt.byr.cn/ 。就可以正常访问了。 4.2 配置utorrent下载并打开utorrent。这一步就不说了。 windows用户配置方法：按快捷键：“ctrl+P”，打开utorrent的设置。设置左侧找到Connection（中文应该是连接），配置如下图红圈里所示： mac用户配置方法：按快捷键：“command+,”，打开utorrent的设置。在设置上侧找到Network（中文应该是网络），配置方法跟上图类似。就是配置proxy server，address，port，配置的内容跟上图对应的一样。同时选中下面的use proxy for hostname lookups及use proxy for peer-to-peer connections。 至此就能愉快的下载了。 本章内容除了可以用于北邮人bt，也可以用于北交大的晨光pt，只要把晨光pt的网址按类似方法加进去就可以了。 试试效果？有问题欢迎留言。下面的5是对于服务器管理用的，一般用不到，可以不看，至此完成了科学上网+支持北邮人bt。 5. 服务器管理说明此内容是用于对服务器的vpn进行管理使用的，正常情况下是不需要看这个的。 5.1 卸载方法说明：使用root用户登录，运行以下命令： 1./shadowsocks.sh uninstall 5.2 配置说明：单用户配置文件示例： 配置文件路径：/etc/shadowsocks.json12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:your_server_port, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;your_password&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 多用户多端口配置文件示例： 配置文件路径：/etc/shadowsocks.json 123456789101112131415&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123; &quot;8989&quot;:&quot;password0&quot;, &quot;9001&quot;:&quot;password1&quot;, &quot;9002&quot;:&quot;password2&quot;, &quot;9003&quot;:&quot;password3&quot;, &quot;9004&quot;:&quot;password4&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 5.3 使用命令：启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 状态：/etc/init.d/shadowsocks status 6. Q &amp; A本小结是对配置有问题的一些问题的回答。 google上不去。 这是shadowsocks都没配置好。出问题的地方可能有 一、你的服务器ip被墙了。可以尝试在cmd中敲ping ip，看看是否有time out。有time out说明你连不上服务器的，我在家就经常连不上，在公司就没问题。一个办法就是销毁服务器，重新申请台服务器的ip。我换了好几个ip都没用，我感觉我是家里的网可能有问题。 二、对于很多问题，可以尝试换个浏览器、重启shadowsocks之类的看看能不能登录。 三、看报什么错。如果是500 Internal Privoxy Error。可以修改端口号、加密方式。一些端口号可能被重点关照了，建议修改为较小的端口号， 比如一千以内的。楼下也有修改加密方式解决问题的。四、自行根据error上网搜相关资料。 google能上，bt上不去问题。 google能上，说明shadowsocks配置没问题。bt相对于普通的科学上网，多的步骤就三个，一、vps支持ipv6，二、北邮人bt的网址加入到走外网名单，三、utorrent的配置。 主要检查一和二。 bt可以上网，utorrent配置找不到或下载没速度。 那就是utorrent配置的问题了，有的同学的utorrent配置和我给的有些出入，建议更新utorrent到最新版，或许就找到对应的配置地方了。 500 Internal Privoxy Error 首先看是否能上google，如果不能，尝试修改端口号、加密方式。 如果能上能上google，不能bt，就是问题2。 bt做种，可以正常下载，但是没有上传速度 我的上传速度也是经常非常小，引用楼下 @liuleiwindy 的说法。“看到一条资料说是因为bt站会优先选择通信质量高的线路，而教育网的质量应该比vps+ipv6隧道的质量高，所以除非实在没有人做种，否则按优先级应该排不到我们这些用vps的人。” 我自己就是一直放着，慢慢的有一定的上传，虽然非常少。同时对于北邮人bt，一直放着也会有魔力值积分，积够1300积分可以换10g上传流量。我暂时没有更好的办法。 参考资料： https://teddysun.com/342.html https://doub.io/ss-jc43/ https://www.cnblogs.com/edward2013/p/5560836.html https://blog.csdn.net/TotoroCyx/article/details/80032556 http://yucc.me/p/b4d20b2d/]]></content>
      <categories>
        <category>experience of life</category>
      </categories>
      <tags>
        <tag>翻墙</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类任务中的模型性能评估指标详解]]></title>
    <url>%2Fp%2F82f51d0e%2F</url>
    <content type="text"><![CDATA[本文主要内容有： 错误率（Error Rate）与准确率（Accuracy、ACC） 混淆矩阵（Confusion matrix） 精确率（Precision）、召回率（Recall）、F1值（F1-score） 宏精确率（macro-P）、宏召回率（marco-R）、宏F1值（macro-F1）、微精确率（micro-P）、微召回率（micro-R）、微F1值（micro-F1） ROC与AUC Mean Average Precision @ K 回归任务的评估指标 对于分类模型常用的分类指标有1-6。这些评估指标，工程和研究中都会经常遇到，需要对其有透彻的理解和对其中的差别清楚知晓。本文对这些指标进行一些总结和归纳。 1. 错误率（Error Rate）与准确率（Accuracy、ACC）准确率亦称精度。错误率与准确率是分类任务中常见的性能度量，同时适用于二分类及多分类任务。错误率是分类错误的样本数占样本总数的比例，准确率是分类正确的样本数占样本总数的比例。显然，二者的和为1。 对于样例集$D$，分类的错误率可以定义为： $$\begin{equation}E(f; D) = \frac{1}{m} \sum_{i=1}^m {I(f(x_i) \ne y_i)}\end{equation} \tag{1}$$ 其中m表示m个类别，$y_i$表示$x_i$对应的真实标签。 准确率则定义为： $$\begin{equation}\begin{split}ACC(f; D) &amp; = \frac{1}{m} \sum_{i=1}^m {I(f(x_i) = y_i)} \\&amp; = 1 - E(f; D)\end{split}\end{equation} \tag{2}$$ 对于更一般的情况，数据分布为D，概率分布为p(·)，错误率和准确率可以描述为： $$\begin{equation}E(f; D) = \int_{x \sim D} I(f(x) \ne y)p(x) {\rm d}x\end{equation} \tag{3}$$ $$\begin{equation}\begin{split}ACC(f; D) &amp; = \int_{x \sim D} I(f(x) = y)p(x) {\rm d}x \\&amp; = 1 - E(f; D)\end{split}\end{equation} \tag{4}$$ 2. 混淆矩阵（Confusion matrix）混淆矩阵是监督学习中的一种可视化工具，主要用于比较分类结果和实例的真实信息。矩阵中的每一行代表实例的预测类别，每一列代表实例的真实类别。下表是一个二分类任务的分类结果的混淆矩阵。 - 真实值为正样本P 真实值为负样本N 预测值为P True Postive(TP) False Postive(FP) 预测值为N False Negative(FN) True Negative(TN) 在混淆矩阵中，每一个实例可以划分为以下四种类型之一： 真正(True Positive , TP)：被模型预测为正的正样本 假正(False Positive , FP)：被模型预测为正的负样本 假负(False Negative , FN)：被模型预测为负的正样本 真负(True Negative , TN)：被模型预测为负的负样本 3. 真正率、假负率、假正率及真负率定义以下几个指标 真正率(True Positive Rate, TP Rate, TPR)（灵敏度sensitivity， 也是召回率）定义为$\frac{被预测为正的正样本结果数}{正样本实际数}$，即： $$\begin{equation}TPR = \frac{TP}{TP + FN}\end{equation} \tag{5}$$ 假负率(False Negative Rate, FN Rate, FNR)定义为$\frac{被预测为负的正样本结果数}{正样本实际数}$，即： $$\begin{equation}FNR = \frac{FN}{TP + FN}\end{equation} \tag{6}$$ 假正率(False Positive Rate, FP Rate, FPR) 定义为$\frac{被预测为正的负样本结果数}{负样本实际数}$，即： $$\begin{equation}FPR = \frac{FP}{FP + TN}\end{equation} \tag{7}$$ 真负率(True Negative Rate, TN Rate, TNR)（特指度specificity）定义为$\frac{被预测为负的负样本结果数}{负样本实际数}$，即： $$\begin{equation}TNR = \frac{TN}{TN + FP}\end{equation} \tag{8}$$ 可以看出，真正（TP）和假负（FN）都是实际类别是正样本，分别被判为正及负，真正率（TPR）及假负率（FNR）都是除以正样本的总个数（TP+FN）。所以TPR+FNR=1。类似的，假正（FP）和真负（TN）都是实际样本类别是负样本，分别被判为正及负，假正率（FPR）及真负率（TNR）都是除以负样本的总数（FP+TN）。所以FPR+TNR=1。 可以看出，以上四个率（Rate）都是除以他们的真实标签对应的所有与它们真实标签相同的样本的个数。TPR、FNR二者知其一，便知另外一个。FPR、TNR也只需要知道一个便知另外一个。 一个具体的例子，就是[5]。假设你正在构建一个使用麦克风来监听用户说出特定“唤醒词”，检测到“唤醒词就唤醒系统的硬件设备。例如亚马逊的Echo倾听“Alexa”，苹果siri的“Hey Siri”，安卓的“Okay Google”及百度应用的“你好，百度”。你关心的是假正率（假阳性率）及假负率（假阴性率）。假正率（假阳性率）指没有人说唤醒词系统醒来的频率，假负率（假阴性率）是当有人说唤醒词系统没有醒来的频率。一个合理的目标是在满足每运行24小时不会有一个假阳性（满足指标）的情况下，最大限度的减少假阴性率（优化指标）。 在weka里，会显示TPR和FPR两个参数。 3. 精确率（Precision）、召回率（Recall）、F1值（F1-score）二分类问题常用的评价指标有精确率（Precision）、召回率（Recall）和F1值。精确率亦称为“查准率”，召回率亦称“查全率”。 精确率定义为： $$\begin{equation}P = \frac{TP}{TP+FP}\end{equation} \tag{9}$$ 召回率定义为： $$\begin{equation}R = \frac{TP}{TP+FN}\end{equation} \tag{10}$$ F1之定义为精确率和召回率的调和平均数，即： $$\begin{equation}\frac{2}{F1} = \frac{1}{P} + \frac{1}{R}\end{equation} \tag{11}$$ 即 $$\begin{equation}\begin{split}F1 &amp; = \frac{2PR}{P+R} \\&amp; = \frac{2}{\frac{TP+FP}{TP}+\frac{TP+FN}{TP}} \\&amp; = \frac{2TP}{2TP+FP+FN}\end{split}\end{equation} \tag{12}$$ 对于一些应用，精确率和召回率重视程度不同，比如在商品推荐中，为了减少对用户的打扰，更希望推荐用户感兴趣的，此时精确率更重要。查找逃犯时，希望尽可能的减少逃犯遗漏，则召回率更重要。于是有了F1值更一般的形势$F_\beta$，定义为精确率和召回率的加权平均数： $$\begin{equation}\frac{1+\beta^2}{F_\beta} = \frac{1}{P} + \frac{\beta^2}{R}\end{equation} \tag{13}$$ 即： $$\begin{equation}F_\beta = \frac{(1+\beta^2)PR}{\beta^2P + R}\end{equation} \tag{14}$$ 其中，$\beta &gt; 0$，$\beta$度量了精确率和召回率之间的重要性，当$\beta=1$时,就是F1；当$\beta&lt;1$时，精确率更重要；当$\beta&gt;1$时，召回率更重要。这些结论可以通过观察公式（13）得出。 4. 宏精确率（macro-P）、宏召回率（marco-R）、宏F1值（macro-F1）、微精确率（micro-P）、微召回率（micro-R）、微F1值（micro-F1）很多时候我们有多个二分类混淆矩阵，例如进行多次训练/测试，每次得到一个混淆矩阵;或是在多个数据集上进行训练/测试，希望估计算法的”全局”性能;甚或是执行多分类任务，每两两类别的组合都对应一个混淆矩阵，总之，我们希望在个二分类混淆矩阵上综合考察精确率和召回率。 一种直接的做法是现在各个混淆矩阵上分别计算出精确率和召回率，记为$(P_1, R_1),(P_2,R_2),…,(P_n, R_n)$，再计算平均值，这样就得到宏精确率（macro-P）、宏召回率（marco-R）、宏F1值（macro-F1），分别定义如下： $$\begin{equation}marco-P = \frac{1}{n} \sum_{i=1}^n P_i\end{equation} \tag{15}$$ $$\begin{equation}marco-R = \frac{1}{n} \sum_{i=1}^n R_i\end{equation} \tag{16}$$ $$\begin{equation}marco-F1 = \frac{2 \times marco-P \times macro-R}{macro-P + macro-R}\end{equation} \tag{17}$$ 除此之外，还可以将各个混淆矩阵的对应元素进行平均，得到TP、FP、TN、FN的平均值，分别记为$\overline{TP}、 \overline{FP}、 \overline{TN}、 \overline{FN}$，然后再基于这些指标，计算出微精确率（micro-P）、微召回率（micro-R）、微F1值（micro-F1），分别定义如下： $$\begin{equation}mirco-P = \frac{\overline{TP}}{\overline{TP}+\overline{FP}}\end{equation} \tag{18}$$ $$\begin{equation}mirco-R = \frac{\overline{TP}}{\overline{TP}+\overline{FN}}\end{equation} \tag{19}$$ $$\begin{equation}mirco-F1 = \frac{2 \times mirco-P \times micro-R}{micro-P + micro-R}\end{equation} \tag{20}$$ 从上述公式来看，宏平均（宏精确率、召回率等）对每个类别同等对待，而微平均（微精确率、微召回率等）对每个样本同等对待。 5. ROC曲线与AUCROC全称是受试者工作特征（Receiver Operating Characteristic）。ROC曲线的纵轴是上文提到的真正率（TPR），横轴是假正率（FPR），分别对应于公式（5）和公式（7）。此处再次搬运过来。 $$\begin{equation}TPR = \frac{TP}{TP + FN}\end{equation} \tag{21}$$ $$\begin{equation}FPR = \frac{FP}{FP + TN}\end{equation} \tag{22}$$ 正如前文分析的那样，TPR的分子为分类结果中为正样本且真实标签也为正样本的个数，分母是所有样本中正样本的个数。FPR的分子为分类结果为正样本且真实样本为负样本的个数，分母是所有样本中负样本的个数。所以对于一个固定的测试集来说，TPR、FPR的分母都是固定值。一个ROC曲线图如下所示： 对上图的四个关键点进行分析： (0,0)：TP=0，FP=0，可以发现该分类器预测所有的样本都为负样本(Negative) (1,1)：TN=0，FN=0，可以发现该分类器预测所有的样本都为正样本(Positive) (0,1)：FP=0，FN=0，它将所有的样本都正确分类 (1,0)：TP=0，TN=0，它将所有的样本都错误分类 从上面的分析我们可以看到，如果ROC曲线越靠近左上方，那么分类器的效果越好。进行学习器的比较时，若一个分类器的ROC曲线完全包住另一个分类器，那么可以判断前者的性能更好。 ROC的绘图过程是：给定$m^+$个正样本和$m^-$个负样本。根据学习期预测结果对样例进行排序，然后把分类阈值设为最大，则把所有结果预测为负样本，此时真正率和假正率均为0，在坐标（0,0）处标记一个点。然后，将分类阈值一次设为每个样本的预测值，即依次将每个样例划分为正样本。设签一个标记点坐标为（x，y），当前若为正样本，则对应标记点的坐标为$(x,y+\frac{1}{m^+})$；当前若当负样本，则对应标记点的坐标为$(x+\frac{1}{m^-}, y)$，然后用线段连接相邻点即可。 在进行学习期比较时，如果一个学习期的ROC曲线被另一个学习期的曲线完全“包住”，则可以断言后者优于前者。但是如果有交叉，则一般难以断言哪个更好。此时如果一定要比较，则较为合理的判断是比较ROC曲线下的面积，即AUC（Area Under ROC Curve）。 从以上定义可知，AUC可以通过对ROC曲线下个面积求和得到。假设ROC曲线的坐标为${(x_1, y_1),(x_2, y_2),…(x_m, y_m)}的点按序连接而成$(x_1 = 0, x_m = 1)$，则AUC可以估算为： $$\begin{equation}AUC = \frac{1}{2} \sum_{i=1}^{m-1} (x_{i+1} - x_i)(y_i + y_{i+1})\end{equation} \tag{23}$$ 所以，ROC 与 AUC的区别是，ROC是曲线，就是上图中的那条曲线，而AUC是ROC曲线下面围成的面积。 6. Mean Average Precision @ K在kaggle的Freesound General-Purpose Audio Tagging Challenge[7]使用的评估方法是Mean Average Precision @ 3 (MAP@3)，该问题是每个音频文件进行自动标注，每个音频实际上只对应一个标签，但是可以做出最多三个预测标签值，对应的公式是： $$\begin{equation}MAP@3 = \frac{1}{U} \sum_{u=1}^U {\sum_{k=1}^{min(n,3)} P(k)}\end{equation} \tag{24}$$ U是样本的总个数，最后是对每个样本的评价求平均，所以关键还是要Average Precision @ 3 (AP@3），所以对应的公式是： $$\begin{equation}AP@3 = \sum_{k=1}^{min(n,3)} P(k)\end{equation} \tag{25}$$ n是预测结果的总个数，也就是限制为3。比如一个真实标签为鸟叫声的音频，可以预测为：鸟叫声，门声，玻璃破碎声。则对应的结果为AP@3 = 1 * 1 + 0 * 1/2 + 0 * 1/3 = 1。也就是每一位是有权重的，越靠前权重越高，第一位权重为1，第二位1/2，第三位为1/3。如果预测为门声，玻璃破碎声，鸟叫声，则AP@3 = 0 * 1 + 0 * 1/2 + 0 * 1/3 = 1/3 。 7. 回归任务的评估指标回归任务中最常用的性能度量是均方误差（mean squared error)： $$\begin{equation}E(f; D) = \frac{1}{m} \sum_{i=1}^m (f(x_i)-y_i)^2\end{equation} \tag{26}$$ 更一般的，对于数据分布D和概率密度函数p(·)，均方误差可以如下定义： $$\begin{equation}E(f; D) = \int_{x \sim D} (f(x) - y)^2p(x) {\rm d}x\end{equation} \tag{27}$$ 8. 后续工作与其他内容一样，有内容会持续更新。 PRC Area与MCC还需要在更新。 参考资料： http://blog.sina.com.cn/s/blog_629e606f0102v7a0.html https://en.wikipedia.org/wiki/Evaluation_of_binary_classifiers 周志华《机器学习》 李航《统计学习方法》 https://yuchenchen.gitbook.io/machine-learning-yearning/9.-you-hua-he-man-zu-zhi-biao https://zhuanlan.zhihu.com/p/25528580 https://www.kaggle.com/c/freesound-audio-tagging#evaluation http://yucc.me/p/82f51d0e/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>machine learning</tag>
        <tag>to do</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[误差反向传播（error backpropagation）推导过程【待完成】]]></title>
    <url>%2Fp%2F55aa0f10%2F</url>
    <content type="text"><![CDATA[误差反向传播算法（error backpropagation）推导过程是每个做深度学习（deep learning）的人员必会的基本功。这里是针对前馈神经网络（Feed Forward Neural Network）或者叫多层感知机（Multi Layer Perceptron）或者叫深度神经网络（Deep Neural Network）的做一个推导。此处用到的误差函数是均方误差（Mean Squared Error）。 1. 前馈神经网络简介基本网络如图1所示，这是一个基本的神经网络，下面来解析这个网络结构。 首先，我们构造输入变量$x_1,…,x_D$的线性组合，形式为： $$\begin{equation}{a_j} = \sum_{i=1}^D {w_{ji}}^{(1)} \cdot x_i + {w_{j0}}^{(1)}\end{equation} \tag{1}$$ 其中$j=1,…,M$，M是输出的总量，且上标(1)表示对应的参数是神经网络的第一层。${w_{ji}}^{(1)}$叫做权重（weight），参数$w_{j0}$叫做偏置（bias）,$a_j$叫做激活(activation)。每个激活都使用一个非线性激活函数(activation function) $h(·)$进行变换，得： $$\begin{equation}z_j = h(a_j)\end{equation} \tag{2}$$ 非线性函数$h(a_j)$通常选用sigmoid，tanh，relu等。$z_j$为经过激活函数的值。这些值会再次线性组合，得到输出单元激活（output unit activation）： $$\begin{equation}{a_k} = \sum_{i=1}^K {w_{kj}}^{(2)} \cdot z_j + {w_{k0}}^{(2)}\end{equation} \tag{3}$$ 这个变换对应于神经网络第二层，类似于之前。最后使用一个恰当的激活函数进行变换，得到神经网络的一组输出$y_k$。对于标准回归问题，激活函数是恒等函数，从而$y_k = a_k$。对于一个二元分类问题，每个输出单元激活可以使用logistic sigmoid进行变换，即: $$\begin{equation}y_k = \sigma(a_k)\end{equation} \tag{4}$$ $\sigma(·)$函数形式这里不再给出，可以自己查看。对于多分类问题，可以使用softmax激活函数。 最后综合以上的观点，我们容易得到一个网络整体，如下: $$\begin{equation}y_k = \sigma(\sum_{i=1}^K {w_{kj}}^{(2)} \cdot h(\sum_{i=1}^D {w_{ji}}^{(1)} \cdot x_i + {w_{j0}}^{(1)}) + {w_{k0}}^{(2)})\end{equation} \tag{5}$$ 其中所有权重参数和偏置被聚集在一起，记做$\vec{w}$。因此，神经网络可以简单地认为是从输入变量$\vec{x}$到输出变量$\vec{y}$的非线性函数，映射由调节参数$\vec{w}$来控制。 具体网络结构正如图1所示。计算公式（5）的过程可以认为是信息通过网络的前向传播（forward propagation）。 通过定义额外的输入变量$x_0$讲公式(1)中的偏置参数整合进权重参数集合中，并且$x_0$被限定为1，因此公式（1）可以改写为： $$\begin{equation}{a_j} = \sum_{i=0}^D {w_{ji}}^{(1)} \cdot x_i\end{equation} \tag{6}$$ 第二层的偏置也做类似处理，最终整体网络函数可以从公式（5）变为： $$\begin{equation}y_k = \sigma(\sum_{i=0}^K {w_{kj}}^{(2)} \cdot h(\sum_{i=0}^D {w_{ji}}^{(1)} \cdot x_i))\end{equation} \tag{7}$$ 至此，一个简单的前馈神经网络已经完成了。 2. 误差反向传播算法简介我们的目标是寻找一种计算前馈神经网络的误差函数$E(w)$的梯度高效的方法。我们将会看到，可以使用局部信息传递的思想来完成这一点。在局部信息传递的思想中，信息在神经网络中交替的向前、向后传播。这种方法被称为误差反向传播（error propagation），有时被称为backprop，通常简称bp算法。 关于训练过程的本质。大部分训练算法涉及到一个迭代的步骤用于误差函数的最小化，以及通过一系列的步骤进行权重调节。在每一个这样迭代过程中，我们可以区分这两个不同的阶段。在第一个阶段，误差函数关于权重的导数必须被计算出来。正如我们稍后看到的那样，反向传播算法的一个重要贡献是提供了计算这些导数的一个高效的方法。由于正是这个阶段，误差通过网络进行传播，因此我们将专门使用反向传播这个属于来描述计算导数的过程。在第二个阶段，导数用于计算权重的调整量。最简单的方法，也是最开始由Rumelhart et al.（1986）考虑的方法，涉及到梯度下降。认识到这两个阶段属于不同的阶段是很重要的。因此，第一阶段，即为了计算导数而进行的误差在网络中的反向传播阶段，可以应用于许多不同种类的网络，而不仅仅是多层感知器。它也可以 应用于其他的误差函数，而不仅仅是简单的平方和误差函数。它也可以用于计算其他类型的导数。第二阶段，即使用计算过的导数调整权重的阶段，可以使用许多最优化方法处理，许多最优化方法本质上要比简单的梯度下降更强大。 3. 简单线性模型误差导数的计算许多实际应用中使用的误差函数，例如针对一组独立同分布的数据的最大似然方法定义的误差函数，由若干项的求和公式组成。每一项对应于训练集中的一个数据点，即： $$\begin{equation}E(w) = \sum_{n=1}^N {w}\end{equation} \tag{8}$$ 这里，我们要考虑计算$\nabla E_n(w)$的问题。这可以直接使用顺序优化的方法计算，或者使用批处理方法在训练集上进行累加。 对于一个特定的输入模式n（等价于对于一个特定的样本$\vec{x}$），误差函数形式为： $$\begin{equation}E_n = \frac{1}{2} \cdot \sum_{k} {(y_{nk}-t_{nk})}^2\end{equation} \tag{9}$$ 其中$y_{nk} = y_k(\vec{x_n}, \vec{w})$，$y_{nk}$表示对于特定输入模式的输出，$t_{nk}$表示对应的实际标签（或预测值）。这个误差函数关于权重$w_{ji}$的梯度为： $$\begin{equation}\frac{E_n}{w_{ji}} = (y_{nj} - t_{nj})x_{ni}\end{equation} \tag{10}$$ 它可以表示为与链接$w_{ji}$的输出端关联的“误差信号”$y_{nj}-t_{nj}$和与链接的输入端相关连的变量$x_{ni}$的乘积。我们现在会看到这个简单的结果如何扩展到更复杂的多层前馈神经网络中。 4. 通用前馈神经网络bp算法推导 5. 一个简单的例子参考资料： BISHOP, C, M. Pattern recognition and machine learning[M]. New York:Springer, 2006. 225-244 http://yucc.me/p/55aa0f10/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>to do</tag>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 3 读取中文文件]]></title>
    <url>%2Fp%2F6821aaf2%2F</url>
    <content type="text"><![CDATA[在windows环境下，python3 读取中文文件方法，折腾了很久，总结了下。 先找到文件编码格式。 因为读文件的时候，需要知道文件的编码格式，编码格式怎么看呢？ 我的方法是，使用windows自带的记事本打开文件，然后ctrl+shift+s，或文件-另存为，可以看到文件的编码格式。 常见的编码格式有utf-8，gbk，gb2312。我今天把这些编码格式都试了发现都不能解码，最后发现文件编码格式是Unicode big endian，然后看到Stack Overflow上说，编码就是UTF-16[1]，最终解决问题。 编写相应代码。 两种方法，方法一，使用codecs模块： 123import codecswith codecs.open(file, 'r', encoding='utf-16') as f: text = f.read() 或 12with open(file, 'rb') as f: text = f.read().decode('utf-16') 方法二： 12with open(file, 'r', encoding='UTF-16') as f: text = f.read() 自己写的时候记得修改encoding为自己文件的相应格式，同时根据自己需要修改读写。 参考资料： https://stackoverflow.com/questions/8827419/converting-utf-16-utf-8-and-remove-bom http://yucc.me/p/6821aaf2/]]></content>
      <categories>
        <category>experience of code</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[machine-learning-yearning(by Andrew Ng) 1-22章翻译最新版]]></title>
    <url>%2Fp%2Fb706c49c%2F</url>
    <content type="text"><![CDATA[machine-learning-yearning本内容是Andrew NG的My Machine Learning Yearning 1-22章内容的翻译及其原稿，会持续更新。 Andrew表示最近每周会持续更新本书籍，我决定把它翻译出来，加深自己的印象，同时希望能对大家有点帮助，后续会持续更新。 本书官网：http://www.mlyearning.org/ Andrew Ng关于本书介绍亲爱的朋友，你是如何组织一个人工智能（AI）项目的呢？ 人工智能（AI），机器学习（Machine Leaning）和深度学习（Deep learning）正在改变众多行业。我一直在写此书——Machine Learning Yearning，来教你如何构建机器学习项目。 本书的重点不在于教授机器学习算法，而在于使机器学习算法发挥作用。一些人工智能技术会给你一个锤子，而本书教你如何使用锤子。如果你渴望成为人工智能技术的领导者并想学习如何为你的团队设定方向，这本书将会有所帮助。 阅读完Machine Learning Yearning之后，你将能够： 为人工智能项目最有前途的方向设立优先级 诊断机器学习系统中的错误 在复杂设置中构建机器学习，例如不匹配的训练集/测试集 建立一个可以人类比较或超越人类表现的机器学习项目 了解何时以及如何应用端到端学习（end-to-end learning），迁移学习（transfer learning）和多任务学习（multi-task learning） 从历史上看，学习如何制定这些“策略”决策的唯一方法是在研究生课程或公司中做多年的学徒。我正在写的Machine Learning Yearning可以帮你快速的获得这项技能，以便你可以更好地构建人工智能系统。 本书大约100页，包含很多易于阅读的1-2页的章节。如果你希望收到每章完成后的草稿，请注册邮件列表。 —— 吴恩达（Andrew Ng） 翻译版gitbook阅读地址：gitbook阅读体验更好，欢迎来点击下面链接阅读翻译版： https://yuchenchen.gitbook.io/machine-learning-yearning/ 翻译版github地址：https://github.com/yucc2018/machine-learning-yearning 英文原版pdf下载：原文原版手稿已经更新到19章，下载链接分别如下: 1-14章pdf下载（2018.04.18版） 15-19章pdf下载（2018.04.25版） 20-22章pdf下载（2018.05.02版） 我自己手动将上面两部分合并，成为1-19章的合集。想下载一个的直接点下面这个链接。 1-22章合并版pdf下载（2018.05.02更新） 翻译章节：1. 为什么是机器学习策略？ 2. 如何使用本书来帮助你的团队 3. 预备知识和表示符号 4. 规模推动机器学习进度 下一部分：设置开发和测试集 5. 你的开发集和测试集 6. 你的开发集和测试集应当来自相同的分布 7. 开发集和测试集需要多大？ 8. 为你的团队进行算法优化建立一个单数字估指标 9. 优化和满足指标 10. 使用开发集和评估指标来加速迭代 11. 何时更改开发集/测试集和评估指标 12. 小结：设置开发集和测试集 下一部分：基本错误分析 13. 快速构建你的第一个系统，然后迭代 14. 错误分析：查看开发集的例子来评估想法 15. 在错误分析中并行评估多个想法 16. 清理错误标记的开发集和测试集样例 17. 如果你有一个很大的开发集，将它分成两个，而且你只看一个 18. 眼球开发集和黑盒开发集应该多大？ 19. 基本错误分析 下一部分：偏差（Bias）和方差（Variance） 20. 偏差（Bias）和方差（Variance）：错误的两大来源 21. 偏差（Bias）和方差（variance）的例子 22. 对比最优错误率 待Andrew更新后翻译章节： Addressing Bias and Variance Bias vs. Variance tradeoff Techniques for reducing avoidable bias Techniques for reducing Variance Error analysis on the training set Diagnosing bias and variance: Learning curves Plotting training error Interpreting learning curves: High bias Interpreting learning curves: Other cases Plotting learning curves Why we compare to human-level performance How to define human-level performance Surpassing human-level performance Why train and test on different distributions Whether to use all your data Whether to include inconsistent data Weighting data Generalizing from the training set to the dev set Addressing Bias, and Variance, and Data Mismatch Addressing data mismatch Artificial data synthesis The Optimization Verification test General form of Optimization Verification test Reinforcement learning example The rise of end-to-end learning More end-to-end learning examples Pros and cons of end-to-end learning Learned sub-components Directly learning rich outputs Error Analysis by Parts Beyond supervised learning: What’s next? Building a superhero team - Get your teammates to read this Big picture Credits 联系方式：6506666@gmail.com 参考资料： http://yucc.me/p/b706c49c/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>machine learning</tag>
        <tag>to do</tag>
        <tag>machine learning yearning</tag>
        <tag>Andrew Ng</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年算法工程师（机器学习方向）找实习找校招经验总结]]></title>
    <url>%2Fp%2F102faecd%2F</url>
    <content type="text"><![CDATA[写在前面，这是我去年年底（2017.12）依据自己找实习找工作经历撰写，分享在北邮人bbs上的文章，觉得还是有价值的，重新发表在这里。 2017年即将过去，今年是忙碌的一年，从2月17还没开学就来学校，到现在12月初，工作的事情终于尘埃落定，现将这一段经历写下来，希望能帮助来年找工作的学弟学妹，同时，对自己来说，也是一年的工作总结，总结经验教训，对自己一个提升。 简单介绍一下，北邮本硕，要找的岗位主要是算法工程师（机器学习方向）。算法工程师找实习的时候，最终的结果是找到了四家：亚马逊、京东、滴滴、腾讯地图。找工作的时候，主要有百度sp、滴滴sp、美团sp、新浪sp、搜狗sp、小米（没谈薪资直接拒了）等。总体而言，今年找工作相对以往还是很顺利的，各大公司都很缺人，各家开出的工资相对于去年都非常诱人，找工作的情况也出乎了我们很多人的意料。 年初的时候，大概2月28左右开学吧，我2月16就来了，开始准备找实习。简单的说一下面试的情况，有些可能已经忘记，现在说个大概情况。 各家面试情况 滴滴，实习的是在论坛招人内推的，两面，第一面是主要问了svm lr等原理，简历上的项目，svm怎么用于多分类。第二面写了一道算法题，leetcode 63. Unique Paths II。问我是否会用spark，我说不会。然后就给我介绍了他们所做的项目。后来回来的路上我想了想，当时问我是否会不会spark，我应该说我虽然不会，但是可以学的，留个好印象。没过多久，就发了实习offer。后来去了滴滴实习。实习转正三面，每面半小时，所以还是相对容易了很多。转正一面，主要问了在滴滴的实习，给我的柑橘是更偏重业务，对技术并不是太热衷，做的项目的业务的主要应用是什么，将来怎么评价之类的。一道算法题，leetcode上的，旋转数组，leetcode 59. Spiral Matrix II。转正二面，也是问了问滴滴的实习，问了下gbdt的原理，xgboost与gbdt的区别，gbdt用于分类时，分类概率的梯度体现在哪里。一道编程题，矩阵A与矩阵B相乘得到矩阵C，给定A和B，求C的秩。转正三面，三面面试官是一个研究员，对数学推导有独特的兴趣。问了svm的推导，什么是凸函数，为什么拉格朗日对偶方程成立。滴滴的offer大约10月初发。 美团。实习的时候貌似没内推，走的校招。一面，上来让写了几个算法，一个是数组全排列，一个是二叉树的非递归先序遍历，一个是反转链表。然后问了过拟合问题，l1 l2正则区别之类的。然后进入二面，二面的时候面试官先问了一个二叉树的垂直遍历，LeetCode 314. Binary Tree Vertical Order Traversal（这个题是leetcode付费的题）。没答上来，就挂了。校招时是找斜对门的美团实习的大佬内推的。共三面，一面面完告知通过接着二面，二面面完告知通过让回去等三面，三面是电话面，晚上7点三面的，晚上12点就收到录取意向书。做完笔试，过了几天，晚上9点多美团打电话过来，说明天早上10点来某某酒店面试。第二天一面问了简历上的项目，编程题问了1到n的一个排好序的数组，少了一个元素，怎么找出来。我说二分查找，时间效率logn（也可以用位运算，时间效率n）。二面问了项目，我简历上有k-means，就问了其他聚类的方法，距离有多少种，影响聚类的因素。问了编程题leetcode 198 House Robber（动态规划）。三面电话面，问了项目，问了过拟合的问题产生、解决办法，问了两个编程题，leetcode 69 Sqrt(x)，两种方法解决，一种是二分查找，一种是牛顿法。另一个编程题给忘了，想起再补充。 百度。内推实习的时候，去年毕业的师兄去了百度组，我们就找他内推的。说实话，挺后悔的，我并不喜欢他这个方向，一方面我不擅长，另一方面过了我也不会去。不该图省事找他推的。内推实习时，共二面，挂了。面试主要问的是方面的，也没什么意思，答的也不好。问了leetcode 206 Reverse Linked List，让自己定义链表，问指针，对象，指针是对象吗，对C++的考察很多。到校招实习时，没投简历。到校招开始时，我投的比较晚，所以错过了内推机会，然后到了校招。校招共三面，都是技术面，当天状态不太好，感冒了。主要问了二分类的标准有多少种，每种都是什么。struct与class的区别。线程与进程的区别，io密集，计算密集使用多线程还是多进程。一个发生器，产生0的概率是p，产生1的概率是1-p，p！=0.5，怎么使用这个产生0和1等概率的发生器（可以每次产生两个数字，0 1判为0，1 0判为1，其他的舍弃重来）。k-means聚类相关问题，svm与lr的对比与区别。编程题问了多道，最小栈leetcode 155. Min Stack，还有几道其他题目，忘了已经。 腾讯。实习投的北京微信，校招投的广州微信，然而都没找我面试。找实习时，qq空间把我捞了起来邀请我面试，我拒绝了，后来腾讯地图邀请我去面试，就去了。面试一下午，从1：40到5：20，共四面，前三个为技术面，第四个为leader面，leader也问了一些技术，未来的规划，来这里之后会干什么，反正就是泛泛的聊，还有就是你印象最深刻的一件事，最感动的，最难忘的一件事，哎，这些问题。先是40分钟一套卷子，让做题，5道编程题，3道问答题可以选择做。我当时40分钟把5道编程写完就没时间了。有一道是leetcode 300 Longest Increasing Subsequence，其他忘了，不过也不难。面试聊了项目，花了不少时间，也看了那5道编程题，怎么处理POI中的名称问题，就是说一个地点可能有很多备选的名字，怎么确定哪个更合适。爬虫相关技术。还聊了聊手头的offer情况等。到后面校招内推时，投的广州微信，但是广州微信并不怎么缺人，投的人又多，所以就没给面试机会。qq音乐把我捞了起来，但我并不想去深圳，就拒绝了。再后来校招的时候，不知道腾讯哪个部门邀请我去面试开发岗。我想了想，我并不想做开发，就拒绝了。现在看起来，腾讯我还是有很多机会的，然而我都拒绝了。哎，现在仔细想一想，虽然房价高，但是深圳其他方面都挺好的，空气质量好，各种生活还是很不错的，四个面试机会，只面了一个，其他的都自己拒绝的，感觉还是非常可惜的。 新浪。实习没有投，校招投的内推，面了四面，两面技术面，三面总监面，四面hr面。主要问了项目、gbdt与xgboost的区别、贝叶斯学派和统计学派的分歧，编程题问了反转链表leetcode206，top k大的数（剑指offer题目，第一版30题）。 搜狗。实习没有投，校招内推面了两面挂了，校招面了两面，发了offer。校招内推时，也是为了省事，找的搜狗某组的大大大师兄推的，跟百度那个类似，我也不感兴趣。面试问了项目，编程问了最小编辑距离leetcode 72 Edit Distance，剑指offer 31连续子数组的最大和（找到起始位置和最大和）。校招两面。主要是项目，二分类的评价标准有哪些、分别是什么。编程有二叉树的先序中序后续非递归遍历。二面面完说去看看领导在不在，回来说领导不在，就让回来了，说后面可能有hr面。我心想，这是委婉拒绝的套路吧，过了几天hr让我去公司面，问了下学历，问考研还是保研，有哪些offer，然后发了offer。 小米。三面技术面。面试之后，发了意向书，直到前些日子才联系我。我说我已经交其他公司三方，校招结束了。编程题问了leetcode 228. Summary Ranges， 给一个二叉树，找到最深的一个节点到最浅的一个节点之间的最小公共父节点，我的方法是层次遍历，找到最浅的节点及最深的节点，然后使用 leetcode 236 Lowest Common Ancestor of a Binary Tree中的方法去解决问题，时间效率为o（n），空间效率为o（n），面试官给的方法是保存所有路径，然后去查找。问了项目，两个项目问的非常细，使用random forest计算特征重要性，对该维特征不进行permutation，删除可以不可以。峰度、偏度的数学公式及意义。二分类中AUC的具体定义，各个分类评价方法。最后三面leader面的时候还问了两个思考问题，金融违约率，可能要房贷很长时间才能知道是否违约，数据少，实验样本回收时间长所以对于这个问题怎么处理。还有就是为何利用训练集训练，用来预测测试集可以用来预测。我说的是这是基于一个大的假设，训练样本和测试样本是基于独立同分布的，后来我想了想我觉得也可以从熵 信息增益的角度思考。 京东。 京东是实习过了，校招没邀请我面试。 校招的时候，我找的京东的师兄内推的，后来也参加了校招，笔试的挺好的，就是没邀请面试，也有一些同学跟我一样的情况，可能简历挂了吧。京东实习面试是三面，两面技术面，一面hr面。感觉比较坑的是京东的三面分别安排在了三天，为此我给我们老师请了三天假。京东用的较多的是Java，我自己是cpp Python较多。面试相对简单，问了svm原理推导，两个排好序的数组怎么合并成一个排好序的数组，双指针啊。问了一个业务题场景题，给你一些恶数据，让你对顾客对一个新商品的退单率预测，如果能预测出退单率，则可以延迟或者不发货，节约物流成本。hr面的时候问了几个问题，现在厉害的很多都是博士，你怎么看，有无读博的打算？介绍一个你的项目。 亚马逊。 亚马逊也是实习过了，校招没邀请我。亚马逊实习投的早，后来邀请去面试，共两面技术面。第一面是一个美丽的北邮学姐（我不认识），主要问了简历的项目，lstm的原理，lstm为何能长时记忆。二面有两位面试官同时面，主要是编程题，也问了项目。编程题相对都是比较容易的，主要是leetcode 1 Two Sum ，leetcode 15 3Sum，leetcode 16 3Sum Closest ，leetcode 18 4Sum。还问了一个业务场景预测题，亚马逊要销售很多商品，你如何去预测商品需要用到的货仓的体积。如果能预测出货仓体积，这样子就很容易去租赁仓库了。后面的公司都是实习和校招都没过的。有的是面试未通过，有的是没有面试，也一并写下来。 360。实习三面挂，校招内推一面挂。实习面试，是我第一次去面试，面的实习，路上还想，如果360过了，实习就结束了，可惜想法是美好的，现实是残酷。实习是三面，两面技术，一面hr。上午10点面，40分钟一场，等面完二面等下午1点半还是2点开始hr面。两面技术面的的确挺不好的，那是第一次去面试，也没看网上的面经，自己的技术也并不太好。技术主要问了，svm的原理，smo算法，lstm有什么好处，为何防止梯度爆炸和梯度消失，bp推导，编程题问了树的深度，这个简单，但是代码中竟然把==错写成了=，范了这样的错误。还有问了找出二叉树中和最大的一条路径，不必经过根节点leetcode 124. Binary Tree Maximum Path Sum。 hr面的时候问了以前的实习经历，考研还保研，我说考研，问考了多少分，有无对象，将来是打算在哪里发展。校招的时候，内推去面，一挂面。问了简历项目，问了聚类算法都有那些，算法的比较，cnn的原理各个层的作用，编程题问了二分搜索。感觉面的挺好的，然而还是挂了。很多同学都说360基本不缺人。的确实习还是校招，周围过360的很少，包括很多大牛。 阿里。 实习内推一面视频面，后来的实习校招也是一面挂，校招也是视频一面挂。实习面的时候，主要问了简历项目，问了svm的原理，svm的核函数的作用，lr能不能用核函数，为什么。校招的时候，问了多元高斯函数的期望是什么，怎么推导？熵的定义是什么？怎么理解？编程题是剑指offer 30题，最小的k个数，也是leetcode 215 Kth Largest Element in an Array，写代码并分析时间复杂度。阿里实习投的是阿里妈妈，校招投的是蚂蚁金服。除了技术需要加强之外，视频面试也表现出了两个缺点，一个是表达沟通需要大大的加强，一个是要自信，同学在旁边表示我的表达太快，太紧张了。还有一个非常重要的一点，我校招内推投的太晚了（8.8投的）以至于错过了校招内推的时间点，没人找我面试，直接到了校招了。我为什么投这么晚呢？可以记住一个时间点，大概6月底，7月初就开始互联网的内推了。我们是7月开始放实习，7.4才开始去实习公司报到，那个时候想着，简历上没有个像样的实习，刚去实习的公司，什么也不会呢，简历也不好写。所以想稍微等一等，结果8.8再投的时候，差不多快结束了，我记得校招的内推是8.18左右。所以时间节点一定要把握好，千万不要拖。 网易。实习的时候是笔试挂了，校招内推也是笔试挂了，校招的时候申的深度学习工程师，校招时二面挂。第一面是一个美女姐姐，第二面试是两位面试官一起面。主要问了项目，自己搭建网络的结构，CNN网络的结构，相关知名的cnn网络结构，编程就问了一道，一些坐标点都是（x，y）形式的让以x的大小排序，x一样的按y排序，我说很简单啊，使用sort函数写个compare函数就可以了，不知道是要考察什么，要考察现场写排序算法吗？我当时应该问问的。其实我对深度学习的了解还是太少，需要更多的学习，目前更多的是工程使用上的东西，我当时应该申机器学习工程师的，或许面试就通过了。 网易游戏。 实习的时候简历挂了，校招的时候本来申的人工智能工程师，结果给我转成了游戏研发工程师，还不能更改，我去面了，一面挂。首先可以说明一点，网易和网易游戏是分开招聘的，两家可以分别投。再有就是网易游戏有两块，一块是雷火盘古，一块是互娱。我实习投的是雷火，找了互娱的同学内推了一下，最开始不知道他们内部互不承认，结果相当于没有内推，简历就给我挂了。所以投雷火一定要找雷火的人推，投互娱一定要找互娱的人推，不然等于没有推。还有就是网易游戏实习开始的特别早，去年11月还是12月，就开始内推了，现在也是12月大家可以关注下消息。今年2月份我刚过完年来学校，我同学跟我说他网易游戏已经笔试过两批了，我顿时觉得自己落后了很多，有种别人校招都结束了，你才刚来学校的feel，何况我比学校规定的开学时候早来了十多天，当时一顿慌张，赶紧问问师兄师姐到底什么情况。再有就是校招面试，先是40分钟让写道编程题，然后再去见面试官。因为他们给我调成了开发，我自己也确实没什么经验，问的全是语言细节的，算法工程师从来不怎么问的，结果可想而知，就挂了。 今日头条。实习的时候一面挂，校招的时候也是一面挂。实习的时候问了简历，当时第一家面的360，挂了。貌似第二家面的头条，也挂了，挂了很多家，心情还是挺郁闷的当时。头条实习一面的时候先让写编程题，类似于剑指offer第一版的第7章的7.2里的题目，叫做多叉树（没有指向父节点指针）中两个节点的最低公共祖先。然后问了项目，问了svm的推导，问的非常细，问距离到底如何定义的，不可分的svm中松弛变量怎么理解，如果有个点特别异常，是否还能找到分割面，我自己当时水平也比较菜，他问一个我回答一个，我回答一个，他说一句靠（kao 四声），我心里一阵慌张。问了lr的公式推导。的确面的不好。校招的时候，找的内推，当时内推要内推码，但是内推有内推码也要笔试，但是内推码有一种是内推白金码，只有头条技术员工有，且每人只有一个，有了内推白金码，可以直接面试，免笔试，早面试。我就找人要了一个内推白金码，是头条的第一批面试，挂了。校招内推挂了，不能参加后续的校招，跟360一样的。校招一面，主要问了简历，问了项目，问了一些倒排索引，词向量及复杂度相关问题。编程是leetcode 57 Insert Interval，这是leetcode的hard题目，根据大家的反应，头条编程题问的普遍相对难一些。编程题我没答上来，挂了也是很正常的事情。 海康威视。实习没投，校招投了。共三面。先是电话一面，后是去公司面试二面和三面，而面试技术面2v1，三面是hr面。一面就是简单的聊了聊，问了问。二面是聊聊平时用什么技术，用什么网络，业内（我的研究方向）主要用什么方法，业内（我的研究方向）都在做什么，对了解多少，有无转方向的意愿。也没太多的问题，更多的是发散性的问题。hr面的时候，问了有多少offer了，因为已经很晚了，我就说我现在有7家公司发了sp offer。后来没给我发offer，我觉得可能主要在于我对方向了解甚少，我本来也不是研究那个方向，但是平时还是有很多与方向学习的机会，我都不想去学。这给我一个提示，除了技术的深度，一定要提高的自己涉猎的广度。 微策略。 先是线下笔试，然后三面技术面。微策略是先去听宣讲会，然后再线上面试。笔试面试都是全英的。笔试一小时，题目还是不太难的。面试一面，13*16 = 244，问这事几进制，答：（1x+3)(x+6) = 2x^2 + 4x + 4 =&gt; x=7。证明：n(n^2-1) 对于任何n&gt;=3的奇数都可以整除。答：可以数学归纳法，假定n=2k+1满足条件，证明（2k+3)也满足，最后得到[(2k+1)^3-(2k+1)] + 24k^2 + 48k + 24显然成立。问一个字符串的全排列，我以为是leetcode 46. Permutations，实际上是leetcode 47. Permutations II。我按照46的思路写的代码，主要差别是47是有重复的。后来他提示是否有bug，我想到了47，然后改了重复的部分，但是竟然又忘了先sort下。所以这道题答的不好。这道题答的不好，我也反思过，自己不够灵活，没考虑那么多，直接对上题号了，思想僵（jiang）化了，一定要与自己做过的题目对一起做对比，注意差别。二面。给一段代码，让找出bug，里面涉及了指针和malloc和strcpy这些，我没找出bug。编程题1，一段链表，反转前n个节点。类似于leetcode 92. Reverse Linked List II。编程题2，leetcode 25. Reverse Nodes in k-Group。 编程题3，single number问题leetcode 136. Single Number，编程题4，leetcode 137. Single Number II。三面。编程题1， 121. Best Time to Buy and Sell Stock，编程题2， leetcode 123. Best Time to Buy and Sell Stock III，编程题3，leetcode 122. Best Time to Buy and Sell Stock II，编程题4，397 Integer Replacement 。编程题 2写了两种方法，思考花了些时间。编程题4给了几种解法，但遗憾的是没有给出最优解。 商汤。实习的时候笔试过了，邀请面试，我当时有三四家都要面试，还要交ppt，听说比较难，就没去面。校招的时候笔试挂了。 face++，实习没投，校招笔试挂。 微软。实习和校招都是笔试挂了。 蘑菇街&amp;美丽说。 实习投了没理我。校招内推把我简历挂了，校招又投了一次，又挂了一次简历。 freewheel，第四范式，hulu，快手等投了校招，没消息，应该是简历挂了。看周围人都投了链家网的内推，我就投了链家网，结果链家的校招是线下笔试，我不知道，就错过了。 面试心得以上就是详细的面试部分，下面是一些自己参考别人的经验及自身的经历，总结的一些经验教训吧，希望对自己是一个总结，对学弟学妹们也希望能有所帮助吧。 把握好时间实习、校招的时间表。实习分为内推阶段和校招阶段。众所周知，互联网找工作的时间越来越早。2017年今年的情况是大部分公司在2-5月（实习包含内推和校招两阶段）。先是内推，后面就是校招。也有特别早的，比如网易游戏，去年12月左右就开始内推了。内推阶段刚走完或者没有走完就开始到了实习的校招阶段了。校招也分两个阶段，内推阶段和（正式）校招阶段。时间在6月底左右-11月。很多公司在6月底7月初就开始了，比如京东、阿里、腾讯等。京东以往貌似都是比较早的，今年也是早早的面试，早早地发了offer。除了内推和校招阶段，有的公司貌似还有提前批（京东貌似有）。我自己的教训就是，校招投的太晚，以至于错过了很多面试机会。我为什么投这么晚呢？上面也分析过，有希望能把实习经历写上去，也有自己想好好复习好好准备的因素。实习的时候我投的就非常早，结果准备的不充分，遇到了很多被拒，也算是找实习遇到的小后遗症吧。投的太晚错过了腾讯、阿里的校招内推阶段，是非常可惜的。阿里的校招内推需要重新内推，腾讯的实习的简历会直接转成校招内推的，不用再推，可以更新下自己投的部门信息就行了。我自己也没去更新简历。总之吧，自己的简历不够好看，希望能刷新下简历再投，以至于错过了时间。还有亚马逊，亚马逊写的校招开始时9.10，结果我投的晚，人家9.5就开始第2轮还是第3轮笔试了。挺可惜的错过了。 把握好内推和实习转正机会。现在大家都招内推了，然后内推跟正式的也差不多了。无论从实习还是校招的结果来看，内推会吸收很大一批人，所以留给校招的名额并不多，并且所有人都参加校招，所以竞争是非常激烈的。所以大家一定要把握好内推的机会。尤其校招的时候，很多公司的实习生都转正了，占用了很多名额，所以校招的内推和校招阶段竞争还是非常激烈的，学弟学妹们还是要加油。说是实习转正，大家要千万把握好机会。如果想在某个公司留下，我个人建议，优先去该公司实习。实习转正，尤其是实习的本部门转正是最容易的。想在哪个部门工作，实习是一个非常简单又省事的途径。内推的时候最好要找熟人内推。可以帮忙查看简历进度。腾讯的内部可以看到简历评价S级、A+、A、B、C等。也可以看到面试官的名称等信息。阿里的也可以看到面试官的名称信息，并依此判断某些信息。找熟人推，方便后续的联系。还有最好直接推到自己想去的部门。如果自己有明确的部门，可以直接推到相关部门，如果不写部门，很多都是直接进公司简历池。如果写了，相当于先在部门简历池，然后进公司简历池，相对而言，相当于多了一次机会。找熟人内推的另一个好处是，如果是投的他的部门，他可以直接把简历扔给他老大，邀请你去面试。 写好简历，讲好项目。简历肯定是特别重要的，简历是面试官对你的第一印象，一定要好好写，如实稍微修饰的写。自己的会的能讲清楚明白的都写上去，自己含糊其辞的搞不太清楚容易被问懵的就不要写了。经常更新自己的简历。我自己的简历面试完就会改一改，修一修，每次都总结一下面试，修缮一下简历。简历上的项目的细节之类的自己都要清楚地明白，一定不能给面试官问的答不出来，那面试官就很怀疑你的水平和项目是否你做的了。 提高自己的编程水平。很多人都推荐剑指offer、leetcode。的确很不错的，我看现在剑指offer都更新到第二版了。至于编程提高到什么水平，剑指offer可以都看了，都搞明白了。我自己是刷了300道leetcode，刷了两遍左右的。我看周围的同学大都在100-200左右的样子，也都找到的非常不错的工作。我这里的经验是算法工程师的，很多公司的（比如滴滴、美团、百度、阿里等）算法工程岗位的面试，一场面试都是分三块，项目介绍、机器学习相关知识、编程题。一场面试一般就一道编程题。编程写不出来就基本挂了。当然面试也没有非要按一定套路的，要看面试官的，面试官喜欢问什么，我们就答什么。有的公司非常注重编程，比如微软，面试几乎全是编程题，而且编程的要求比较高。头条的编程题问的也很不容易。要是想找一般的互联网公司，感觉看完剑指offer、刷leetcode 100-200道就差不多了。当然这是我自己的判断，仅供参考，对此不负责任。还有建议是刷题的时候，要做一下笔记，经常回头看一看，我刷题的时候，使用某笔记（电子笔记类产品，避免广告嫌疑）记录一下题目，标签，解决思路与方法等。以后方便回顾。我自己就是经常看一看自己做的笔记，比每次都重头刷，思路清晰多了。建议尝试一下。 提高机器学习相关的技术水平。算法工程师一定会问机器学习相关的知识，这一块一定要好好的搞清楚明白了。我自己是看了李航老师的统计学习方法+部分prml+一些其他的学习。对这一块内容的理解应该是决定是否发大offer的关键。一般编程题都能写出来，写不出来就挂了。你对机器学习相关的理解深入程度、好的实习经历、好的论文、好的竞赛都是面试中的亮点。如果你其他方面都不能闪光的话，就把对技术的理解深入作为切入点，好好的专研下去吧。 本贴的目的在于对自己一年工作的总结与思考，同时希望能对学弟学妹们有所帮助欢迎讨论，如有不当，望指出。最后祝学弟学妹们都能有好的实习，收割大量的offer！如需转载，注明出处。 相关问题及我的想法：1.可以简单介绍一下你简历上有几个项目(我看文章里说是2个)，以及项目的大致工作吗？我自己写简历的时候也是蛮尴尬的，项目的确非常少。我自己只有一段小公司的实习经历，而且跟算法关系不大。除此之外，因为导师严格不让实习，就没有实习经历了。相对比较好的是，我们实验室都是做算法相关的，所以我把本科毕设写了进去。研究生期间导师也没有项目，所以我把我的研究方向（就是我自己研究方向做的实验，也是研究生毕设）写了进去。之前还有参加了一个小型的竞赛，所以这样子就凑够了四个项目。一般简历上大家写3-4个就够了，写太多也没太多意义。其中我的那个小公司实习面试的时候几乎没人问，所以在面实习的时候主要是问研究生相关的那个项目，那个小竞赛，还有本科毕设。后来校招的时候就把那个小公司实习给换成了滴滴的实习，把小公司实习给删了。找工作的时候大家都会问你的实习经历。当时的本科毕设做的的确比较水，又加上本科时水平菜，做的的确就那样。研究生的毕设做的还是挺认真的，还是有进步的空间。如果重新走的话，我这些都会更认真的做，找实习找工作还是非常有有用的。研一暑假是去实习的好机会，那时我们是按校历放假的，又有时间，我没有抓住。 2.项目在面试过程中的重要性是1/3左右吗？如果给项目、机器学习知识以及编程排序，应该是怎么样的？有没有项目经历不足，但用基础知识去平衡的情况？很多同学都会问项目相关问题。面试中的确会问项目，一般一个小时一场面试，常规的是20分钟聊项目，20分钟聊机器学习相关知识，最后20分钟编程并白纸算法。时间20分钟只是估计，只能说是大概。一般一面都是技术，二面可能技术也可能会随便聊。如上文所述，我也没有特别好看的项目。都是本科毕设，研究生毕设，小竞赛这样子的。大家也可以发挥聪明的脑子想想怎么写简历。至于重要性，都是非常重要的。有的面试官喜欢全程聊项目，聊着项目穿插着机器学习相关知识的提问。之前找实习的时候，很多人阿里的一面就是拿着简历聊项目及相关知识。这也涉及一个很大的问题，就是面试到底要面什么？分解起来就是要面什么内容，想考察什么能力呢？或者说一个算法工程师对这些的要求是什么呢？很直白的，很基本的就是编程，算法的理解，工程实践能力，还会考察数学知识，脑筋急转弯等，甚至更加深入的会考察你的知识的广度，深度，还有随机应变的能力。对于编程，我认为最低要求是别让编程拖你的后腿，一般来说，每场面试都会有一个编程题，一般套路是先讲思路，再写代码。代码最好bug-free。即使没有bug-free，经过提醒想明白也是可以的。大部分都会让分析下你的算法时间复杂度，空间复杂度，并能说明为什么是这个时间复杂度。很多都会追求最优解，所以这也给刷题一个提示，刷题不是ac就可以了，而是要追求最优解。编程这块可以自己把握，千万不要只追求编程，不管其他的。这多个方面要平衡下时间和精力。我之前有一段时间整天刷题，有段时间整天看算法，感觉都不是很好。最好能平衡下来，不让任何一方面去拉后腿。很多公司来说，编程会考察，但是通过的大家都给出最优解，差别也没那么大，所以多多掌握机器学习相关的算法吧，目前我是这么看的。关于工程实践，也就项目。做的项目，都是工程实现的一部分，如果什么项目都没做过，我们是面试官，我们也会对这样的面试者不放心的。像很好的实习经历，很多实验室或导师不放实习的情况下，实习经历很多同学都没有。如果有实习机会，一定要把握住。比如研一下的暑假，那个假期如果放假时间比较长的话，可以找个短期的实习，体验一下。有些如ACM大神，可能很多人是到不了这个层次的。对于多数同学来说，的确没有太好的实习经历。解决办法是如果条件允许，就去找一段实习。如果条件不允许，可以在学校好好的学好相关的机器学习理论，做好自己的课题。有些同学参加一些竞赛，也是可以的。至于排名，肯定是越靠前越好。我自己做的那个小竞赛也没拿到太好的名次。根据我的面试来看，面试官或者hr可能会问面试排名，也可能不问。但是排名并不是重点，重点是你能讲清楚你的项目中，你做了什么工作，思考出了哪些思路，都用了哪些方法，具体的工作及收获是什么。他们看到你的项目，重点还是想通过你的项目，看清楚你的能力和实力。至于这些竞赛能不能写到简历上，当然完全是可以的。机器学习算法相关的理解。很多人说，算法工程师日常工作是调参，调模型。调参和调用模型还是要理解其中的原理，才能向正确的方向走。对算法的考察，重点会考察你基本功的理解，比如svm lr的基本原理，各种分类的评价准则，l1 l2的区别等。再拓展的就是对算法广度的理解，最基本的就是对常用的一些算法有深入的理解就够了。其他相关的，算法工程师要掌握的很多，数学相关的知识用到的很多，比如矩阵，概率论相关的。比如滴滴之前问的求A和B的乘得到的矩阵C的秩，面试官聊完告诉我，这道题的重点就是考察一下数学相关的知识，因为算法工程师日常会用到很多数学知识。再比如，美团内推面试一面的时候，还问了一个概率题，我忘了写了，是这样的。一个村子特别热爱男孩，最初村子里男女平衡，但是夫妻生孩子时，如果生到女儿就会一直生，直到生到男孩为止，问，多年后，男女比例是多少?还问了两个人轮流投硬币，直到有人投到正面为赢。问先手和后手赢的概率多少。两个题很类似。到最后，无论是聊项目，还是机器学习相关算法，都是要考察你的整个的思维能力，基本功的能力。如果没有很好的项目，就从实习、竞赛、自己的实验室项目、自己的研究课题等方面找找灵感。重点还是自己对这些知识的掌握程度还有编程的能力。 3.如果没有好看的项目，简历上如何形成项目呢？或者是在目前这个紧急的阶段，可以临时做一些什么事情补救？类似问题：你做的项目是实验室的项目吗？实验室本身不是研究机器学习方向的，没有项目怎么办呢？这个问题，跟前面的有些类似。就从实习、竞赛、自己的实验室项目、研究课题等方面找灵感。我一同学，他也是通信相关方向，转nlp。就先找了一个小一点的公司实习，然后校招去了tmd中的一家。项目不是越多越好，我之前见有人简历上写了7个项目，写满了。然而这也没太多意义。简历上除了项目，可以写一下个人技能之类的，突出下自己的优点。我自己也是项目不够多，凑的。或许其他学长学姐有独特的项目技巧，我不太知道。 4.我最近参加了一个XX的比赛，但最后的名次可能不太好（猜测前10%吧，比赛没结束，最近疯狂被超，但感觉自己已经没有思路了），这种经历可以往简历上写吗？当然可以了。如前文所述，项目竞赛之类的写上简历，如果有好看的名次，肯定是好的，没有也没关系。前10%已经很不错了。我以为，面试官更看重的还是通过这个竞赛，体现了你对哪些知识的运用，自己提供这个竞赛的解决方案和思路是什么。重点还是考察你的能力和水准在哪里。如果一个竞赛，你拿到了特别靠前的名次，但面试的时候，什么也讲不出来，都是靠随便调参得来的，没有东西可以讲，还是非常尴尬的。 刷题上，笔记也做了分析也做了，但没几天前面的就感觉一点儿也想不起来了类似：很担心编程题啊。虽然在刷题，但是感觉现场还是不一定能bug-free啊，刷题好难啊编程很多考察的还在easy，偏medium的水准。当然也看公司看部门，有些公司就是看中编程，比如微软，那你想去就好好搞好编程就好了。对于很多公司来说，编程知识考察的一部分，一般都是medium水准。也有部分公司或部门考察hard的。刷题的时候，多做笔记，经常回顾，多找同学讨论。一道题，多多的思考，多多的去讨论。思路这个东西，有时候同学的理解和见识能很大的帮助你的成长。的确会忘记，但是你可以把一类题目总结下方法，或者看别人总结的方法。这个要多练习，多总结，多交流。我也确实没特别好的方法。但是我觉得经常回顾与思考，经常练习，肯定会对编程有所提升的。我自己看了cpp primer的一半和算法导论的一半左右，基本都看了算是两边多一点吧。剑指offer倒是看了四五遍。leetcode我做的题也基本在两遍以上吧。面试的时候，除了编程，有时候也会考察cpp的基本知识（如果你用cpp的话），比如虚函数的概念，struct与class的区别，指针，static等。 从你的经历来看，无论是基础的机器学习知识还是编程题（从我刷leetcode和剑指offer来看，感觉都是medium和hard的题目）的掌握来看，感觉师兄很历害，也拿到了很多sp的offer。但是在阿里的面试仅仅是因为投的较晚的原因导致的吗？是否还有其他的因素和注意的点。因为想去杭州，所以对阿里格外的关注。不仅仅是因为投的晚。我想说的是投的晚是非常重要的一个影响因素。我投的时候，我周围的同学都已经面过二面或者三面了，也就是说基本都已经结束了。所以错过内推阶段，加上内推消耗很多名额，转正也消耗了很多名额，最后留给激烈的校招的名额不多。最根本的还是自己的简历和自己的能力不够优秀或者说不足。如果能力非常强，什么时候都有机会嘛。但是对于很多人，包括我认识一些非常牛的的大神来说，还是要把握好机会，能事半功倍。我这里的建议是把握时间和机会，提前好好准备，不要犹豫。我校招投的蚂蚁金服，蚂蚁金服相对阿里其他部门来说是非常难进的部门，今年蚂蚁金服的实习貌似容易一些，我没投蚂蚁实习，校招也不容易吧。想去杭州的话，将来实习可以直接申请阿里杭州的实习，转正直接转本部门就好了。这样的一个坏处就是将来校招的时候，你可能在杭州实习，如果来北京面试其他公司，可能会不会太方便。但是你有了那边的offer，麻烦点也就那么回事。虽然有的公司内部也可以转到杭州，我觉得还是直接转会好一点。阿里的面试，根据其他同学的反馈，除了简历、项目、编程外，也会问一些数学或脑筋急转弯的问题。关于数学概率论的简单的一道题，两个随机变量X Y都符合均匀分布，那X+Y符合什么分布呢？看你想去哪个部门，多跟那里的学长学姐交流，可以针对性的准备下。 关于项目的问题。从你分享的内容来看，感觉项目占的不是很多，这一块是否占的比例比较小。因为我在实验室没做什么项目，只是学了一些相关的大数据处理工具，所以项目这一块很缺，最近打了一些比赛，这个用来充实项目是否够。关于项目，基本每场面试都会问吧。有的我可能没写要问项目。70%的面试都会先问问项目，很多都会一个或者两个。也有的会简单的问，有的深入的问。看面试官的风格。竞赛可以充实项目。只要你的竞赛跟你要找的岗位匹配的上。 你觉得公司对 数据挖掘比赛 看重的程度怎样？除非很好很知名的比赛你拿到特别好的名词，一般来说，更注重要考察的是你的知识的理解，全局把控，提出的解决方案等相关的能力。因为我自己的竞赛比较小，所以都是谈论技术相关的。其他大神的nb竞赛我也不知道怎么样的。 补充小米还问了对于类别不平衡的样本怎么处理。搜狗，对于分类使用auc f值等，对于预测问题的标准怎么评判？新浪，问了bias-variance分解问题。美团，搜狗，xgboost调哪些参数，哪些参数有效果，训练时间，是想问下具体过程。百度，svm lr损失函数对比，对噪声敏感性。还有问为何random forest能够降低误差的。新浪还问了，先验相关的，哪种先验分别对应l1 l2，还有高斯的先验是什么。阿里，熵是什么。 参考资料 http://yucc.me/p/102faecd/]]></content>
      <categories>
        <category>Artificial Intelligence</category>
      </categories>
      <tags>
        <tag>AI一丝一毫</tag>
        <tag>实习</tag>
        <tag>校招</tag>
        <tag>面试经验</tag>
        <tag>面经</tag>
      </tags>
  </entry>
</search>
