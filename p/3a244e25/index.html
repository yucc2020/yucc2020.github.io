<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="http://p94fw3huv.bkt.clouddn.com/static/images/favicon-48-48.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="http://p94fw3huv.bkt.clouddn.com/static/images/favicon-32-32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="http://p94fw3huv.bkt.clouddn.com/static/images/favicon-16-16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="leetcode,hard,tree,depth first search," />










<meta name="description" content="29.0%  https://leetcode.com/problems/recover-binary-search-tree/?tab=Description Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. No">
<meta name="keywords" content="leetcode,hard,tree,depth first search">
<meta property="og:type" content="article">
<meta property="og:title" content="099. Recover Binary Search Tree">
<meta property="og:url" content="http://yucc.me/p/3a244e25/index.html">
<meta property="og:site_name" content="Chenchen Yu">
<meta property="og:description" content="29.0%  https://leetcode.com/problems/recover-binary-search-tree/?tab=Description Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. No">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://pochmann.org/leetcode/images/tree1.png">
<meta property="og:image" content="http://pochmann.org/leetcode/images/tree2.png">
<meta property="og:updated_time" content="2018-05-22T05:09:43.029Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="099. Recover Binary Search Tree">
<meta name="twitter:description" content="29.0%  https://leetcode.com/problems/recover-binary-search-tree/?tab=Description Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. No">
<meta name="twitter:image" content="http://pochmann.org/leetcode/images/tree1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yucc.me/p/3a244e25/"/>





  <title>099. Recover Binary Search Tree | Chenchen Yu</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chenchen Yu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yucc.me/p/3a244e25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chenchen Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p94fw3huv.bkt.clouddn.com/static/images/yucc.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chenchen Yu">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">099. Recover Binary Search Tree</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-22T12:16:37+08:00">
                2018-05-22 12:16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-05-22T13:09:43+08:00">
                2018-05-22 13:09
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">本文总阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,671
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  23
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ul>
<li>29.0%</li>
</ul>
<p><a href="https://leetcode.com/problems/recover-binary-search-tree/?tab=Description" target="_blank" rel="noopener">https://leetcode.com/problems/recover-binary-search-tree/?tab=Description</a></p>
<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p>Note:</p>
<p>A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?</p>
<a id="more"></a>
<hr>
<p>方法一：</p>
<p>我的代码实现:</p>
<p>中序遍历，dfs</p>
<p>违反的，更新到first，如果first有值，更新到second。</p>
<p>中间second可能多次更新。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* first = <span class="literal">nullptr</span>, *second = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        traverse(root, prev, first, second);</span><br><span class="line">        swap(first-&gt;val, second-&gt;val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, TreeNode*&amp; prev, TreeNode*&amp; first, TreeNode*&amp; second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        traverse(root-&gt;left, prev, first, second);</span><br><span class="line">        <span class="keyword">if</span>(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val &amp;&amp; !first)</span><br><span class="line">            first = prev;</span><br><span class="line">        <span class="keyword">if</span>(prev &amp;&amp; prev-&gt;val &gt;= root-&gt;val &amp;&amp; first)</span><br><span class="line">            second = root;</span><br><span class="line">        prev = root; <span class="comment">// 不要忘记更新prev</span></span><br><span class="line">        traverse(root-&gt;right, prev, first, second);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://discuss.leetcode.com/topic/35013/recommend-for-beginners-clean-c-implementation-with-detailed-explaination" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/35013/recommend-for-beginners-clean-c-implementation-with-detailed-explaination</a></p>
<p>[recommend for beginners]clean C++ implementation with detailed explaination</p>
<p>Just use the “first” and “second” pointer to find the 2 nodes that violate the order. Then change the value of the first node ad the second node by their value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    TreeNode* first=NULL;</span><br><span class="line">    TreeNode* second=NULL;</span><br><span class="line">    TreeNode* prev = new TreeNode(INT_MIN);</span><br><span class="line">public:</span><br><span class="line">    void recoverTree(TreeNode* root) &#123;</span><br><span class="line">        help(root);</span><br><span class="line">        swp(first-&gt;val, second-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void help(TreeNode* root)&#123;</span><br><span class="line">        if(root==NULL)  return;</span><br><span class="line">        help(root-&gt;left);</span><br><span class="line">        if(first==NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val)   first=prev;</span><br><span class="line">        if(first!=NULL &amp;&amp; prev-&gt;val &gt;= root-&gt;val)   second=root;</span><br><span class="line">        prev=root;</span><br><span class="line">        help(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我的代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    TreeNode* first = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* second = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* prev = <span class="keyword">new</span> TreeNode(INT_MIN);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="comment">// 注意交换的是first-&gt;val，second-&gt;val</span></span><br><span class="line">        swap(first-&gt;val, second-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        helper(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(first==<span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val) first=prev;</span><br><span class="line">        <span class="keyword">if</span>(first!=<span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val) second=root;</span><br><span class="line">        prev = root;</span><br><span class="line">        helper(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于算法的解释：</p>
<p><a href="https://discuss.leetcode.com/topic/3988/no-fancy-algorithm-just-simple-and-powerful-in-order-traversal" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/3988/no-fancy-algorithm-just-simple-and-powerful-in-order-traversal</a></p>
<p>No Fancy Algorithm, just Simple and Powerful In-Order Traversal</p>
<p>This question appeared difficult to me but it is really just a simple in-order traversal! I got really frustrated when other people are showing off Morris Traversal which is totally not necessary here.</p>
<p>Let’s start by writing the in order traversal:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void traverse (TreeNode root) &#123;</span><br><span class="line">   if (root == null)</span><br><span class="line">      return;</span><br><span class="line">   traverse(root.left);</span><br><span class="line">   // Do some business</span><br><span class="line">   traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>So when we need to print the node values in order, we insert System.out.println(root.val) in the place of “Do some business”.</p>
<p>What is the business we are doing here?<br>We need to find the first and second elements that are not in order right?</p>
<p>How do we find these two elements? For example, we have the following tree that is printed as in order traversal:</p>
<p>6, 3, 4, 5, 2</p>
<p>We compare each node with its next one and we can find out that 6 is the first element to swap because 6 &gt; 3 and 2 is the second element to swap because 2 &lt; 5.</p>
<p>Really, what we are comparing is the current node and its previous node in the “in order traversal”.</p>
<p>Let us define three variables, firstElement, secondElement, and prevElement. Now we just need to build the “do some business” logic as finding the two elements. See the code below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    TreeNode firstElement = null;</span><br><span class="line">    TreeNode secondElement = null;</span><br><span class="line">    // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized</span><br><span class="line">    TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);</span><br><span class="line">    </span><br><span class="line">    public void recoverTree(TreeNode root) &#123;</span><br><span class="line">        </span><br><span class="line">        // In order traversal to find the two elements</span><br><span class="line">        traverse(root);</span><br><span class="line">        </span><br><span class="line">        // Swap the values of the two nodes</span><br><span class="line">        int temp = firstElement.val;</span><br><span class="line">        firstElement.val = secondElement.val;</span><br><span class="line">        secondElement.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void traverse(TreeNode root) &#123;</span><br><span class="line">        </span><br><span class="line">        if (root == null)</span><br><span class="line">            return;</span><br><span class="line">            </span><br><span class="line">        traverse(root.left);</span><br><span class="line">        </span><br><span class="line">        // Start of &quot;do some business&quot;, </span><br><span class="line">        // If first element has not been found, assign it to prevElement (refer to 6 in the example above)</span><br><span class="line">        if (firstElement == null &amp;&amp; prevElement.val &gt;= root.val) &#123;</span><br><span class="line">            firstElement = prevElement;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // If first element is found, assign the second element to the root (refer to 2 in the example above)</span><br><span class="line">        if (firstElement != null &amp;&amp; prevElement.val &gt;= root.val) &#123;</span><br><span class="line">            secondElement = root;</span><br><span class="line">        &#125;        </span><br><span class="line">        prevElement = root;</span><br><span class="line"></span><br><span class="line">        // End of &quot;do some business&quot;</span><br><span class="line"></span><br><span class="line">        traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And we are done, it is just that easy!</p>
<hr>
<p><a href="https://discuss.leetcode.com/topic/19771/real-o-1-space-no-recursion-no-stack-etc-o-n-time-solution-48ms-c" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/19771/real-o-1-space-no-recursion-no-stack-etc-o-n-time-solution-48ms-c</a></p>
<p>REAL O(1) Space (No recursion/No stack, etc) O(n) Time solution. 48ms C++</p>
<p>Someone complained that a recursion solution isn’t really a O(1) space solution. Ok, here comes the real O(1) solution. No recursion, no stack. Pure Morris traversal. 48 ms, C++ :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">        TreeNode * wrong_node0 = nullptr, * wrong_node1 = nullptr, * prev = nullptr;</span><br><span class="line">        void verify(TreeNode * cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if (prev != nullptr &amp;&amp; prev -&gt; val &gt; cur -&gt; val)</span><br><span class="line">            &#123;</span><br><span class="line">                if (wrong_node0 == nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    wrong_node0 = prev;</span><br><span class="line">                    wrong_node1 = cur; // in case the tree has only 2 elements.</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    wrong_node1 = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        void morrisInorder(TreeNode * root)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode * cur = root;</span><br><span class="line">            while (cur)</span><br><span class="line">            &#123;</span><br><span class="line">                if (cur-&gt;left == nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    verify(cur);       </span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                TreeNode * pred = cur-&gt;left;</span><br><span class="line">                while (pred -&gt; right != nullptr &amp;&amp; pred -&gt; right != cur)</span><br><span class="line">                    pred = pred -&gt; right; //finding predecessor</span><br><span class="line">                if (pred -&gt; right == nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    pred -&gt; right = cur;</span><br><span class="line">                    cur = cur -&gt; left;</span><br><span class="line">                &#125;else &#123;//pred -&gt; right == cur;</span><br><span class="line">                    pred -&gt; right = nullptr;</span><br><span class="line">                    verify(cur);</span><br><span class="line">                    cur = cur -&gt; right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    public:</span><br><span class="line">        void recoverTree(TreeNode* root) &#123;</span><br><span class="line">            morrisInorder(root);</span><br><span class="line">            swap(wrong_node0-&gt;val, wrong_node1-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><hr>
<p><a href="https://discuss.leetcode.com/topic/16600/tree-deserializer-and-visualizer-for-python" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/16600/tree-deserializer-and-visualizer-for-python</a></p>
<p>Tree Deserializer and Visualizer for Python</p>
<p>Wrote some tools for my own local testing. For example<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deserialize(&apos;[1,2,3,null,null,4,null,null,5]&apos;)</span><br></pre></td></tr></table></figure></p>
<p> will turn that into a tree and return the root as explained in the FAQ. I also wrote a visualizer. Two examples:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawtree(deserialize(&apos;[1,2,3,null,null,4,null,null,5]&apos;)):</span><br></pre></td></tr></table></figure>
<p><img src="http://pochmann.org/leetcode/images/tree1.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawtree(deserialize(&apos;[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]&apos;)):</span><br></pre></td></tr></table></figure>
<p><img src="http://pochmann.org/leetcode/images/tree2.png" alt="image"></p>
<p>Here’s the code. If you save it as a Python script and run it, it should as a demo show the above two pictures in turtle windows (one after the other). And you can of course import it from other scripts and then it will only provide the class/functions and not show the demo.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val, left=None, right=None):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &apos;TreeNode(&#123;&#125;)&apos;.format(self.val)</span><br><span class="line">    </span><br><span class="line">def deserialize(string):</span><br><span class="line">    if string == &apos;&#123;&#125;&apos;:</span><br><span class="line">        return None</span><br><span class="line">    nodes = [None if val == &apos;null&apos; else TreeNode(int(val))</span><br><span class="line">             for val in string.strip(&apos;[]&#123;&#125;&apos;).split(&apos;,&apos;)]</span><br><span class="line">    kids = nodes[::-1]</span><br><span class="line">    root = kids.pop()</span><br><span class="line">    for node in nodes:</span><br><span class="line">        if node:</span><br><span class="line">            if kids: node.left  = kids.pop()</span><br><span class="line">            if kids: node.right = kids.pop()</span><br><span class="line">    return root</span><br><span class="line"></span><br><span class="line">def drawtree(root):</span><br><span class="line">    def height(root):</span><br><span class="line">        return 1 + max(height(root.left), height(root.right)) if root else -1</span><br><span class="line">    def jumpto(x, y):</span><br><span class="line">        t.penup()</span><br><span class="line">        t.goto(x, y)</span><br><span class="line">        t.pendown()</span><br><span class="line">    def draw(node, x, y, dx):</span><br><span class="line">        if node:</span><br><span class="line">            t.goto(x, y)</span><br><span class="line">            jumpto(x, y-20)</span><br><span class="line">            t.write(node.val, align=&apos;center&apos;, font=(&apos;Arial&apos;, 12, &apos;normal&apos;))</span><br><span class="line">            draw(node.left, x-dx, y-60, dx/2)</span><br><span class="line">            jumpto(x, y-20)</span><br><span class="line">            draw(node.right, x+dx, y-60, dx/2)</span><br><span class="line">    import turtle</span><br><span class="line">    t = turtle.Turtle()</span><br><span class="line">    t.speed(0); turtle.delay(0)</span><br><span class="line">    h = height(root)</span><br><span class="line">    jumpto(0, 30*h)</span><br><span class="line">    draw(root, 0, 30*h, 40*h)</span><br><span class="line">    t.hideturtle()</span><br><span class="line">    turtle.mainloop()</span><br><span class="line">    </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    drawtree(deserialize(&apos;[1,2,3,null,null,4,null,null,5]&apos;))</span><br><span class="line">    drawtree(deserialize(&apos;[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]&apos;))</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><hr>
<p><a href="https://discuss.leetcode.com/topic/3988/no-fancy-algorithm-just-simple-and-powerful-in-order-traversal" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/3988/no-fancy-algorithm-just-simple-and-powerful-in-order-traversal</a></p>
<p>No Fancy Algorithm, just Simple and Powerful In-Order Traversal</p>
<p>This question appeared difficult to me but it is really just a simple in-order traversal! I got really frustrated when other people are showing off Morris Traversal which is totally not necessary here.</p>
<p>Let’s start by writing the in order traversal:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void traverse (TreeNode root) &#123;</span><br><span class="line">   if (root == null)</span><br><span class="line">      return;</span><br><span class="line">   traverse(root.left);</span><br><span class="line">   // Do some business</span><br><span class="line">   traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>So when we need to print the node values in order, we insert System.out.println(root.val) in the place of “Do some business”.</p>
<p>What is the business we are doing here?</p>
<p>We need to find the first and second elements that are not in order right?</p>
<p>How do we find these two elements? For example, we have the following tree that is printed as in order traversal:</p>
<p>6, 3, 4, 5, 2</p>
<p>We compare each node with its next one and we can find out that 6 is the first element to swap because 6 &gt; 3 and 2 is the second element to swap because 2 &lt; 5.</p>
<p>Really, what we are comparing is the current node and its previous node in the “in order traversal”.</p>
<p>Let us define three variables, firstElement, secondElement, and prevElement. Now we just need to build the “do some business” logic as finding the two elements. See the code below:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    TreeNode firstElement = null;</span><br><span class="line">    TreeNode secondElement = null;</span><br><span class="line">    // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized</span><br><span class="line">    TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);</span><br><span class="line">    </span><br><span class="line">    public void recoverTree(TreeNode root) &#123;</span><br><span class="line">        </span><br><span class="line">        // In order traversal to find the two elements</span><br><span class="line">        traverse(root);</span><br><span class="line">        </span><br><span class="line">        // Swap the values of the two nodes</span><br><span class="line">        int temp = firstElement.val;</span><br><span class="line">        firstElement.val = secondElement.val;</span><br><span class="line">        secondElement.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void traverse(TreeNode root) &#123;</span><br><span class="line">        </span><br><span class="line">        if (root == null)</span><br><span class="line">            return;</span><br><span class="line">            </span><br><span class="line">        traverse(root.left);</span><br><span class="line">        </span><br><span class="line">        // Start of &quot;do some business&quot;, </span><br><span class="line">        // If first element has not been found, assign it to prevElement (refer to 6 in the example above)</span><br><span class="line">        if (firstElement == null &amp;&amp; prevElement.val &gt;= root.val) &#123;</span><br><span class="line">            firstElement = prevElement;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // If first element is found, assign the second element to the root (refer to 2 in the example above)</span><br><span class="line">        if (firstElement != null &amp;&amp; prevElement.val &gt;= root.val) &#123;</span><br><span class="line">            secondElement = root;</span><br><span class="line">        &#125;        </span><br><span class="line">        prevElement = root;</span><br><span class="line"></span><br><span class="line">        // End of &quot;do some business&quot;</span><br><span class="line"></span><br><span class="line">        traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And we are done, it is just that easy!</p>
<hr>
<p><a href="https://discuss.leetcode.com/topic/9305/detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/9305/detail-explain-about-how-morris-traversal-finds-two-incorrect-pointer</a></p>
<p>Detail Explain about How Morris Traversal Finds two Incorrect Pointer</p>
<p>To understand this, you need to first understand Morris Traversal or Morris Threading Traversal.<br>It take use of leaf nodes’ right/left pointer to achieve O(1) space Traversal on a Binary Tree.<br>Below is a standard Inorder Morris Traversal, referred from <a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html" target="_blank" rel="noopener">http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html</a> (a Chinese Blog, while the graphs are great for illustration)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void morrisTraversal(TreeNode root)&#123;</span><br><span class="line">		TreeNode temp = null;</span><br><span class="line">		while(root!=null)&#123;</span><br><span class="line">			if(root.left!=null)&#123;</span><br><span class="line">				// connect threading for root</span><br><span class="line">				temp = root.left;</span><br><span class="line">				while(temp.right!=null &amp;&amp; temp.right != root)</span><br><span class="line">					temp = temp.right;</span><br><span class="line">				// the threading already exists</span><br><span class="line">				if(temp.right!=null)&#123;</span><br><span class="line">					temp.right = null;</span><br><span class="line">					System.out.println(root.val);</span><br><span class="line">					root = root.right;</span><br><span class="line">				&#125;else&#123;</span><br><span class="line">					// construct the threading</span><br><span class="line">					temp.right = root;</span><br><span class="line">					root = root.left;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				System.out.println(root.val);</span><br><span class="line">				root = root.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>In the above code, System.out.println(root.val);appear twice, which functions as outputing the Node in ascending order (BST). Since these places are in order, replace them with</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123;</span><br><span class="line">    	if(first==null)&#123;first = pre;second = root;&#125;</span><br><span class="line">    	else&#123;second = root;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">pre = root;</span><br></pre></td></tr></table></figure>
<p>each time, the pre node and root are in order as System.out.println(root.val); outputs them in order.</p>
<p>Then, come to how to specify the first wrong node and second wrong node.</p>
<p>When they are not consecutive, the first time we meet pre.val &gt; root.val ensure us the first node is the pre node, since root should be traversal ahead of pre, pre should be at least at small as root. The second time we meet pre.val &gt; root.val ensure us the second node is the root node, since we are now looking for a node to replace with out first node, which is found before.</p>
<p>When they are consecutive, which means the case pre.val &gt; cur.val will appear only once. We need to take case this case without destroy the previous analysis. So the first node will still be pre, and the second will be just set to root. Once we meet this case again, the first node will not be affected.</p>
<p>Below is the updated version on Morris Traversal.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void recoverTree(TreeNode root) &#123;</span><br><span class="line">        TreeNode pre = null;</span><br><span class="line">        TreeNode first = null, second = null;</span><br><span class="line">        // Morris Traversal</span><br><span class="line">        TreeNode temp = null;</span><br><span class="line">		while(root!=null)&#123;</span><br><span class="line">			if(root.left!=null)&#123;</span><br><span class="line">				// connect threading for root</span><br><span class="line">				temp = root.left;</span><br><span class="line">				while(temp.right!=null &amp;&amp; temp.right != root)</span><br><span class="line">					temp = temp.right;</span><br><span class="line">				// the threading already exists</span><br><span class="line">				if(temp.right!=null)&#123;</span><br><span class="line">				    if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123;</span><br><span class="line">				        if(first==null)&#123;first = pre;second = root;&#125;</span><br><span class="line">				        else&#123;second = root;&#125;</span><br><span class="line">				    &#125;</span><br><span class="line">				    pre = root;</span><br><span class="line">				    </span><br><span class="line">					temp.right = null;</span><br><span class="line">					root = root.right;</span><br><span class="line">				&#125;else&#123;</span><br><span class="line">					// construct the threading</span><br><span class="line">					temp.right = root;</span><br><span class="line">					root = root.left;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				if(pre!=null &amp;&amp; pre.val &gt; root.val)&#123;</span><br><span class="line">				    if(first==null)&#123;first = pre;second = root;&#125;</span><br><span class="line">				    else&#123;second = root;&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				pre = root;</span><br><span class="line">				root = root.right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// swap two node values;</span><br><span class="line">		if(first!= null &amp;&amp; second != null)&#123;</span><br><span class="line">		    int t = first.val;</span><br><span class="line">		    first.val = second.val;</span><br><span class="line">		    second.val = t;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a href="https://discuss.leetcode.com/topic/29161/share-my-solutions-and-detailed-explanation-with-recursive-iterative-in-order-traversal-and-morris-traversal" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/29161/share-my-solutions-and-detailed-explanation-with-recursive-iterative-in-order-traversal-and-morris-traversal</a></p>
<p>Share my solutions and detailed explanation with recursive/iterative in-order-traversal and Morris-traversal</p>
<p>In-order traversal is really useful in BST. Following in-order traversal, we should have following order: prev.val &lt; curr.val. If not, then we found at least one incorrectly placed node</p>
<p>So the basic idea is to visit the tree with in-order traversal and search for two swapped nodes. Then swap them back.</p>
<p>Now the problem is if we found an incorrect pair where prev.val &gt; curr.val, how do we know which node is the incorrect one? The answer is it depends on whether we have found incorrect node before. So What is that?</p>
<p>Since we get two elements that are swapped by mistake, there must be a smaller TreeNode get a larger value and a larger TreeNode get a smaller value.</p>
<p>Their value are swapped, but the incorrect smaller node is still in smaller tree and incorrect larger node is still in larger tree. So we will visit the incorrect smaller node first, and this node will be detected when we compare its value with next.val, i.e. when it is treated as prev node. The incorrect larger node will be detected when we compare its value with prev.val. We don’t know if it is close or not close to incorrect smaller node, so we should continue search BST and update it if we found another incorrect node.</p>
<p>Therefore if it is the first time we found an incorrect pair, the prev node must be the first incorrect node.<br>If it is not the first time we found an incorrect pair, the curr node must be the second incorrect node, though<br>we may have corner case that two incorrect nodes are in same pair.</p>
<p>Recursive in-order traversal based on above idea:</p>
<p>public void recoverTree(TreeNode root) {</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//use inorder traversal to detect incorrect node</span><br><span class="line">    </span><br><span class="line">    inOrder(root);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    int temp = first.val;</span><br><span class="line">    first.val = second.val;</span><br><span class="line">    second.val = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode prev = null;</span><br><span class="line">TreeNode first = null;</span><br><span class="line">TreeNode second = null;</span><br><span class="line"></span><br><span class="line">public void inOrder(TreeNode root)&#123;</span><br><span class="line">    if(root == null) return;</span><br><span class="line">    //search left tree</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    </span><br><span class="line">    //in inorder traversal of BST, prev should always have smaller value than current value</span><br><span class="line">    if(prev != null &amp;&amp; prev.val &gt;= root.val)&#123;</span><br><span class="line">        //incorrect smaller node is always found as prev node</span><br><span class="line">        if(first == null) first = prev;</span><br><span class="line">      //incorrect larger node is always found as curr(root) node</span><br><span class="line">        second = root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //update prev node</span><br><span class="line">    prev = root;</span><br><span class="line"></span><br><span class="line">    //search right tree</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iterative in-order traversal based on above idea:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public void recoverTree(TreeNode root) &#123;</span><br><span class="line">    TreeNode first = null;</span><br><span class="line">    TreeNode second = null;</span><br><span class="line">    </span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    TreeNode prev = null;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();</span><br><span class="line">    </span><br><span class="line">    while(!stack.isEmpty() ||  curr != null)&#123;</span><br><span class="line">        if(curr != null)&#123;</span><br><span class="line">            //visit curr&apos;s left subtree</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //done left subtree of curr Node</span><br><span class="line">            curr = stack.pop();</span><br><span class="line">            </span><br><span class="line">            //compare curr.val with prev.val if we have one</span><br><span class="line">            if(prev != null &amp;&amp; curr.val &lt;= prev.val)&#123;</span><br><span class="line">                //incorrect smaller node is always found as prev node</span><br><span class="line">                if(first == null) first = prev;</span><br><span class="line">                //incorrect larger node is always found as curr node</span><br><span class="line">                second = curr;         </span><br><span class="line">            &#125;  </span><br><span class="line">            </span><br><span class="line">            //visit curr&apos;s right subtree</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //recover swapped nodes</span><br><span class="line">    int temp = first.val;</span><br><span class="line">    first.val = second.val;</span><br><span class="line">    second.val = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Both recursive and iterative will occupy O(n) space in worst case, in which the tree is like a LinkedList</p>
<p>To reduce the space to constant space, we have to use Morris-traversal.</p>
<p>Morris-traversal is similar to recursive/iterative traversal, but we need to modify the tree structure during the<br>traversal. before we visiting the left tree of a root, we will build a back-edge between rightmost node in left tree and the root. So we can go back to the root node after we are done with the left tree. Then we locate the rightmost node in left subtree again, cut the back-edge, recover the tree structure and start visit right subtree. The detection of two incorrect TreeNodes is similar to iterative/recursive in-order traversal.<br>We don’t use extra data structure here, so the space complexity is reduced to O(1) and the time complexity will be O(n)</p>
<p>Morris-traversal based on above description:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public void recoverTree(TreeNode root) &#123;</span><br><span class="line">	//Morris-traversal</span><br><span class="line">	</span><br><span class="line">    TreeNode first = null;</span><br><span class="line">    TreeNode second = null;</span><br><span class="line">    </span><br><span class="line">    TreeNode pred = null; //rightmost node in left tree</span><br><span class="line">    TreeNode prev = null; </span><br><span class="line">    </span><br><span class="line">    TreeNode curr = root;</span><br><span class="line">    </span><br><span class="line">    while(curr != null)&#123;</span><br><span class="line">        //for each node, we compare it with prev node as we did in in-order-traversal</span><br><span class="line">        if(prev != null &amp;&amp; curr.val &lt;= prev.val)&#123;</span><br><span class="line">            if(first == null) first = prev;</span><br><span class="line">            second = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(curr.left != null)&#123;</span><br><span class="line">            //got left tree, then let&apos;s locate its rightmost node in left tree</span><br><span class="line">            pred = curr.left;</span><br><span class="line">            //we may have visited the left tree before, and connect the rightmost node with curr node (root node)</span><br><span class="line">            while(pred.right != null &amp;&amp; pred.right != curr)&#123;</span><br><span class="line">                pred = pred.right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if(pred.right == curr)&#123;</span><br><span class="line">                //if this left tree has been visited before, then we are done with it</span><br><span class="line">                //cut the connection with currNode and start visit curr&apos;s right tree</span><br><span class="line">                pred.right = null;</span><br><span class="line">                prev = curr;</span><br><span class="line">                curr = curr.right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //if this left tree has not been visited before, then we create a back edge from rightmost node</span><br><span class="line">                // to curr node, so we can return to the start point after done the left tree</span><br><span class="line">                pred.right = curr;</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //no left tree, then just visit its right tree</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int temp = first.val;</span><br><span class="line">    first.val = second.val;</span><br><span class="line">    second.val = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>谢谢你！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>赞赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="http://p94fw3huv.bkt.clouddn.com/static/images/wechatpay.jpg" alt="Chenchen Yu 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="http://p94fw3huv.bkt.clouddn.com/static/images/alipay.jpg" alt="Chenchen Yu 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Marco Yu
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yucc.me/p/3a244e25/" title="099. Recover Binary Search Tree">http://yucc.me/p/3a244e25/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          
            <a href="/tags/hard/" rel="tag"># hard</a>
          
            <a href="/tags/tree/" rel="tag"># tree</a>
          
            <a href="/tags/depth-first-search/" rel="tag"># depth first search</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/p/92064786/" rel="next" title="098. Validate Binary Search Tree">
                <i class="fa fa-chevron-left"></i> 098. Validate Binary Search Tree
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/p/7dcacf8f/" rel="prev" title="100. Same Tree">
                100. Same Tree <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://p94fw3huv.bkt.clouddn.com/static/images/yucc.jpg"
                alt="Chenchen Yu" />
            
              <p class="site-author-name" itemprop="name">Chenchen Yu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">381</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">65</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yucc2018" target="_blank" title="github">
                      
                        <i class="fa fa-fw fa-github"></i>github</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://zhuanlan.zhihu.com/yuchenchen" target="_blank" title="zhihu">
                      
                        <i class="fa fa-fw fa-globe"></i>zhihu</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/zxjhdn" target="_blank" title="weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.linkedin.com/in/chenchen-yu-510401107/" target="_blank" title="Linkedin">
                      
                        <i class="fa fa-fw fa-linkedin"></i>Linkedin</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/yucc2018" target="_blank" title="twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/yucc2018" target="_blank" title="facebook">
                      
                        <i class="fa fa-fw fa-facebook"></i>facebook</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:6506666@gmail.com" target="_blank" title="email">
                      
                        <i class="fa fa-fw fa-envelope"></i>email</a>
                  </span>
                
            </div>
          

          
          

          
          

          
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#python"><span class="nav-text">python</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java"><span class="nav-text">java</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chenchen Yu</span>

  
</div>

<div>
<span id="showDays"></span>
</div>





<script>
  var seconds = 1000;
  var minutes = seconds * 60;
  var hours = minutes * 60;
  var days = hours * 24;
  var years = days * 365;
  var birthDay = Date.UTC(2018,04,23,12,00,00); // 这里设置建站时间
  setInterval(function() {
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    var now = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = now - birthDay;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
      document.getElementById('showDays').innerHTML="本站已运行 "+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 ";
  }, 1000);
</script>
        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站总访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
        <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
    
<!-- END LOCAL -->

    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitment({
            id: window.location.pathname, 
            owner: 'yucc2018',
            repo: 'yucc2018.github.io',
            
            oauth: {
            
            
                client_secret: '704923b823cfe85343062ae2444019597f96be86',
            
                client_id: '174a67d1482f56c9aabb'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

</body>
</html>
